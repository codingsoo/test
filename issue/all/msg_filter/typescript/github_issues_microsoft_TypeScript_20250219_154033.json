[
  {
    "number": 60535,
    "title": "language services: If tsconfig.json under the ConguredProject project ignores some files, such as d.ts, opening these d.ts will create a new InferredProject. Is it designed like this?",
    "created_at": "2024-11-19T06:35:16Z",
    "closed_at": "2024-12-04T06:06:21Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/60535",
    "body": "### \ud83d\udd0e Search Terms\n\nIf tsconfig.json under the ConguredProject project ignores some files, such as d.ts, opening these d.ts will create a new InferredProject. Is it designed like this?\n\n### \ud83d\udd57 Version & Regression Information\n\nversion: 5.6.3\n\n### \u23ef Playground Link\n\n_No response_\n\n### \ud83d\udcbb Code\n\n```ts\n// Your code here\n```\n\n\n### \ud83d\ude41 Actual behavior\n\nThe two project paths are the same, but the ProjectKind is different\n\n### \ud83d\ude42 Expected behavior\n\nExpect not to create a new project\n\n### Additional information about the issue\n\n_No response_",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/60535/comments",
    "author": "schizobulia",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2024-12-02T07:08:08Z",
        "body": "Yes - why wouldn't it?"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2024-12-03T18:59:02Z",
        "body": "The most likely scenario of opening a `.d.ts` file that wasn't part of a configured project is that it's the *output* of that configured project, so merging it into the same project context as the tsconfig would result in many \"duplicate identifier\" errors"
      }
    ]
  },
  {
    "number": 60245,
    "title": "Type of a generic is not narrowed",
    "created_at": "2024-10-16T17:50:28Z",
    "closed_at": "2024-10-20T01:32:39Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/60245",
    "body": "### \ud83d\udd0e Search Terms\n\ngeneric narrowed class instance enum\n\n### \ud83d\udd57 Version & Regression Information\n\n- This is the behavior in every version I tried, and I reviewed the FAQ for entries about narrowed.\n\n\n### \u23ef Playground Link\n\n_No response_\n\n### \ud83d\udcbb Code\n\n```ts\nenum Tag {\n  A,\n  B,\n  C,\n}\n\ninterface InterfaceByTag {\n  [Tag.A]: {\n    type: string;\n  };\n  [Tag.B]: {\n    type: number;\n  };\n  [Tag.C]: {\n    type: boolean;\n  };\n}\n\nclass C<\n  T extends Tag = Tag,\n> {\n  tag: T;\n  type: InterfaceByTag[T][\"type\"];\n\n  constructor(tag: T, type: InterfaceByTag[T][\"type\"]) {\n    this.tag = tag;\n    this.type = type;\n  }\n}\n\nconst tagIsA = new C(Tag.A, \"string\");\nconst tagIsAError = new C(Tag.A, 123);\n\nfunction test(instance: C) {\n  switch (instance.tag) {\n    case Tag.A: {\n      const type = instance.type; // should get string, but get string | number | boolean.\n      break;\n    }\n    case Tag.B: {\n      const type = instance.type; // Same as above\n      break;\n    }\n    case Tag.C: {\n      const type = instance.type; // Same as above\n      break;\n    }\n  }\n}\n```\n\n\n### \ud83d\ude41 Actual behavior\n\nIt is not narrowed in the switch statement. In all case, the type of `instance.type` is `string | number | boolean`.\n\n### \ud83d\ude42 Expected behavior\n\nI think the specific type has been identified In the switch statement. What I expected:\n```ts\n  switch (instance.tag) {\n    case Tag.A: {\n      const type = instance.type; // string\n      break;\n    }\n    case Tag.B: {\n      const type = instance.type; // number\n      break;\n    }\n    case Tag.C: {\n      const type = instance.type; // boolean\n      break;\n    }\n  }\n```\n\n### Additional information about the issue\n\n_No response_",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/60245/comments",
    "author": "Nlicro",
    "comments": [
      {
        "user": "MartinJohns",
        "created_at": "2024-10-16T17:54:43Z",
        "body": "This is working as intended. You do not specify the type parameter for `C` in your `test` function, so it falls back to the default `Tag`. That means the type is `C<Tag>`, which results in the type `{ tag: Tag, type: string | number | boolean }`. This is not a union type that can be narrowed."
      },
      {
        "user": "MartinJohns",
        "created_at": "2024-10-16T18:34:46Z",
        "body": "> you misunderstood it.\n\nI did not. The type of `instance` is `C<Tag>`, which results in the type `{ tag: Tag, type: string | number | boolean }`. It's **not** the type `{ tag: Tag.A, type: string } | { tag: Tag.B, type: number } | { tag: Tag.C, type: boolean }`, so it can't be narrowed the way you expect it to. It's perfectly valid to have the value `{ tag: Tag.A, type: true }` assigned to `C<Tag>`."
      },
      {
        "user": "MartinJohns",
        "created_at": "2024-10-17T06:22:11Z",
        "body": "This approach is unsafe, as it does not align with your types. Again, `{ tag: tag.A, type: true }` is a perfectly valid assignment to the type `C`, but using your `isTagA` type guard it would wrongly assume the type of `type` is `string`, when it's actually `boolean`.\n\nYou seem to wrongly assume that `InterfaceByTag[T][\"type\"]` is a type depending on what's assigned to `tag`, but that's not the case. The type depends on whatever `T` is, which can be a union type as well - and actually is a union type when your type argument defaults to `Tag`.\n\nYou need to use a union of the types you want:\n- `C<Tag.A> | C<Tag.B> | C<Tag.C>`, which results in `{ tag: Tag.A, type: string } | { tag: Tag.A, type: number } | { tag: Tag.C, type: boolean }`\n- **not** `C<Tag>` or `C` (they're the same), which results in `{ tag: Tag, type: string | number | boolean }`\n\nYou could use a helper type and make use of distributive conditional types to get a union based on your tags: `type AllTagC<T extends Tag> = T extends Tag ? C<T> : never`  \nThen use it: `function test(instance: AllTagC<Tag>) { ... }`\n\nIt's crucial to understand what structure your types actually look like."
      }
    ]
  },
  {
    "number": 57789,
    "title": "TypeScript only find types",
    "created_at": "2024-03-15T10:37:46Z",
    "closed_at": "2024-03-15T17:45:00Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/57789",
    "body": "### \ud83d\udd0e Search Terms\n\nTS18042, TS2693, import, exports, types\n\n### \ud83d\udd57 Version & Regression Information\n\n- This is the behavior in every version I tried (_5.4.2_ and _5.0.2_), and I reviewed the FAQ for entries about _exports_.\n\n### \u23ef Playground Link\n\n_No response_\n\n### \ud83d\udcbb Code\n\n- `package.json`\r\n\r\n  ```JSON\r\n  {\r\n    \"name\": \"testcase\",\r\n    \"version\": \"1.0.0\",\r\n    \"type\": \"module\",\r\n    \"dependencies\": {\r\n      \"subproject\": \"./subproject/\",\r\n      \"typescript\": \"5.4.2\"\r\n    }\r\n  }\r\n  ```\r\n\r\n- `index.js`\r\n\r\n  ```JavaScript\r\n  import sub from \"subproject\";\r\n\r\n  console.log(sub.foo);\r\n  ```\r\n\r\n- `subproject/`\r\n  - `package.json`\r\n\r\n    ```JSON\r\n    {\r\n      \"name\": \"subproject\",\r\n      \"version\": \"1.0.0\",\r\n      \"type\": \"module\",\r\n      \"exports\": {\r\n        \".\": {\r\n          \"types\": \"./sub.d.ts\",\r\n          \"default\": \"./sub.js\"\r\n        }\r\n      }\r\n    }\r\n    ```\r\n\r\n  - `sub.js`\r\n\r\n    ```JavaScript\r\n    export default {\r\n      foo: \"bar\",\r\n      baz: 42,\r\n    };\r\n    ```\r\n\r\n  - `sub.d.ts`\r\n\r\n    ```TypeScript\r\n    declare type _default = {\r\n      foo: string;\r\n      baz: number;\r\n    };\r\n\r\n    export default _default;\r\n    ```\r\n\r\n1. `npm install`\r\n2. `npx tsc --noEmit --checkJs --module nodenext index.js`\r\n   or `npx tsc --noEmit --checkJs --module nodenext --moduleResolution nodenext index.js`\n\n### \ud83d\ude41 Actual behavior\n\n```\r\nindex.js:1:8 - error TS18042: 'sub' is a type and cannot be imported in JavaScript files. Use 'import(\"subproject\").sub' in a JSDoc type annotation.\r\n\r\n1 import sub from \"subproject\";\r\n         ~~~\r\n\r\nindex.js:3:13 - error TS2693: 'sub' only refers to a type, but is being used as a value here.\r\n\r\n3 console.log(sub.foo);\r\n              ~~~\r\n\r\n\r\nFound 2 errors in the same file, starting at: index.js:1\r\n```\n\n### \ud83d\ude42 Expected behavior\n\nNo error.\n\n### Additional information about the issue\n\nI also reproduce the bug with `npm pack` and:\r\n\r\n```JSON\r\n{\r\n  \"dependencies\": {\r\n    \"subproject\": \"./subproject/subproject-1.0.0.tgz\",\r\n  }\r\n}\r\n```",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/57789/comments",
    "author": "regseb",
    "comments": [
      {
        "user": "regseb",
        "created_at": "2024-03-15T10:58:23Z",
        "body": "I'm having the same problem with a TypeScript file:\r\n\r\n```TypeScript\r\n// index.ts\r\nimport type subType from \"subproject\";\r\nimport sub from \"subproject\";\r\n\r\nconst a: subType = {\r\n    foo: \"bar\",\r\n    baz: \"Not a Number\",\r\n};\r\nconst b: sub = {\r\n    foo: \"bar\",\r\n    baz: \"Not a Number\",\r\n};\r\n\r\nconsole.log(sub.foo);\r\n```\r\n\r\n`npx tsc --noEmit --module nodenext index.ts`\r\n\r\n```\r\nindex.ts:7:5 - error TS2322: Type 'string' is not assignable to type 'number'.\r\n\r\n7     baz: \"Not a Number\",\r\n      ~~~\r\n\r\n  node_modules/subproject/sub.d.ts:3:5\r\n    3     baz: number;\r\n          ~~~\r\n    The expected type comes from property 'baz' which is declared here on type '_default'\r\n\r\nindex.ts:11:5 - error TS2322: Type 'string' is not assignable to type 'number'.\r\n\r\n11     baz: \"Not a Number\",\r\n       ~~~\r\n\r\n  node_modules/subproject/sub.d.ts:3:5\r\n    3     baz: number;\r\n          ~~~\r\n    The expected type comes from property 'baz' which is declared here on type '_default'\r\n\r\nindex.ts:14:13 - error TS2693: 'sub' only refers to a type, but is being used as a value here.\r\n\r\n14 console.log(sub.foo);\r\n               ~~~\r\n\r\n\r\nFound 3 errors in the same file, starting at: index.ts:7\r\n```"
      },
      {
        "user": "IllusionMH",
        "created_at": "2024-03-15T11:59:37Z",
        "body": "`types` in `exports` section override/shadow `import`/`require` and in your declarations you only export type.\n\nTo export value you need to declare const and export it as default IIRC"
      },
      {
        "user": "jakebailey",
        "created_at": "2024-03-15T14:43:44Z",
        "body": "```ts\r\ndeclare const _default: {\r\n  foo: string;\r\n  baz: number;\r\n};\r\n\r\nexport default _default;\r\n```"
      },
      {
        "user": "jakebailey",
        "created_at": "2024-03-15T14:45:32Z",
        "body": "If you're already using TypeScript, you'd be better of using it to produce your declaration files instead of doing it by hand; it would have done the right thing."
      },
      {
        "user": "regseb",
        "created_at": "2024-03-15T17:45:01Z",
        "body": "Thank you for your feedback. I understood the association between _.js_ and _.d.ts_ files. The _.d.ts_ file:\r\n\r\n- must **not** export the type of JavaScript objects.\r\n- must export typed JavaScript objects.\r\n\r\n---\r\n\r\nI want to add typing to a JavaScript project. That's why I'm writing the declaration file by hand. And then I use TypeScript and JSDoc to validate the types in the JavaScript files."
      }
    ]
  },
  {
    "number": 56224,
    "title": "Types not generated/working with AMD module",
    "created_at": "2023-10-26T10:08:53Z",
    "closed_at": "2023-10-27T18:26:56Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/56224",
    "body": "### Acknowledgement\n\n- [X] I acknowledge that issues using this template may be closed without further explanation at the maintainer's discretion.\n\n### Comment\n\nWhen using AMD modules and working in VSCode, type declarations are not being picked up for modules that load dependencies using an array passed to the define function, but they are working for modules that load dependencies using `require('./module-path')`\r\n\r\nIn a simple project structured like this:\r\n\r\n```\r\napp\r\n    |app.js\r\n    |lib.js\r\n    |lib.d.ts\r\n```\r\nThe file `lib.js` contains this:\r\n\r\n```\r\ndefine('lib', function() {\r\n    return {\r\n        libTest: (msg) => {\r\n            console.log('lib is working!', msg);\r\n            return true;\r\n        },\r\n    }\r\n});\r\n```\r\nThe file `lib.d.ts` looks like this:\r\n\r\n```\r\n/** @name declaration test */\r\nexport module './lib';\r\n/** @name libTest */\r\nexport function libTest(msg: string): boolean;\r\n```\r\nThe declarations from `lib.d.ts` are correctly picked up in `app.js` with this and Intellisense works as expected, pulling info from `lib.d.ts`:\r\n\r\n```\r\nconst lib = require('./lib');\r\nlib.libTest(); // hovering pointer on 'libTest' shows \"function libTest(msg: string): boolean \\n @name -- libTest\" and hovering on 'lib' shows \"@name -- declaration test\"\r\n```\r\nThe declarations also work as expected if `app.js` looks like this instead:\r\n\r\n```\r\ndefine(function() {\r\n    const lib = require('./lib');\r\n    lib.libTest(); // hovering pointer on 'libTest' shows \"function libTest(msg: string): boolean \\n @name -- libTest\" and hovering on 'lib' shows \"@name -- declaration test\"\r\n});\r\n```\r\nHowever, the declarations **do not work** at all when the code in `app.js` looks like this:\r\n\r\n```\r\ndefine(['lib'], function(lib) {\r\n    lib.libTest(); // hovering pointer on either 'lib' or 'libTest' just shows \"any\"\r\n});\r\n```\r\nWhy are the declarations from the `lib.d.ts` file working as expected for the first two variations of `app.js`, but not the third variation which uses an array of dependencies?\r\n\r\nAdditionally, if I delete the `lib.d.ts` file and try to have the compiler generate the declarations automatically (using `\"declaration\": true, \"emitDeclarationOnly\": true` in tsconfig) the tsc command completes successfully, but the generated d.ts file is completely empty",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/56224/comments",
    "author": "ts-lover",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2023-10-26T16:31:23Z",
        "body": "JS module inference only works for calls to the `require` function; it doesn't support AMD `define` calls."
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2023-10-27T16:53:19Z",
        "body": "You'd have to write it with \"normal\" TS syntax and transpile to AMD format for it to be recognized"
      }
    ]
  },
  {
    "number": 56160,
    "title": "tsc target did not work expectedly when compile ES2022 to ES2015",
    "created_at": "2023-10-20T07:59:04Z",
    "closed_at": "2023-10-23T01:26:29Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/56160",
    "body": "### \ud83d\udd0e Search Terms\n\ntarget  ES2022  ES2015\n\n### \ud83d\udd57 Version & Regression Information\n\nTS 4.5\r\n\n\n### \u23ef Playground Link\n\n_No response_\n\n### \ud83d\udcbb Code\n\nnpx tsc --target es5 index.ts --outFile indexout.js\r\n\r\n\r\nindex.ts:\r\nconst arr = [1, 2, 3, 4, 5];\r\narr.at(1); // 2\n\n### \ud83d\ude41 Actual behavior\n\nindexout.js:\r\n\r\nconst arr = [1, 2, 3, 4, 5];\r\narr.at(1); // 2\n\n### \ud83d\ude42 Expected behavior\n\nArray.at is a new feature in ES2022\r\nThe target is ES5, the output js should not include Array.at\r\nso the indexout.js can not work on the old browser.\n\n### Additional information about the issue\n\n_No response_",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/56160/comments",
    "author": "turtleinspace1",
    "comments": [
      {
        "user": "MartinJohns",
        "created_at": "2023-10-20T08:07:34Z",
        "body": "TypeScript will only downlevel newer syntax. If the function you're trying to call does not exist at your runtime it's your responsibility to polyfill it."
      }
    ]
  },
  {
    "number": 54189,
    "title": "Uncaught SyntaxError \":\" in recursive function signature",
    "created_at": "2023-05-08T23:45:10Z",
    "closed_at": "2023-05-09T16:47:56Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/54189",
    "body": "Uncaught SyntaxError C:\\Users\\Owner\\Documents\\TS\\HelloWorlds\\HelloHanoi\\hanoi.ts:19\r\n  height: number,\r\n        ^\r\n\r\nfunction moveTower(\r\n  height: number,\r\n  fromPole: string,\r\n  toPole: string,\r\n  withPole: string\r\n): void {\r\n  if (height >= 1) {\r\n    // Move tower of height-1 to an intermediate pole, using the destination pole.\r\n    moveTower(height - 1, fromPole, withPole, toPole);\r\n\r\n    // Move the remaining disk to the destination pole.\r\n    console.log(`Move disk from ${fromPole} to ${toPole}`);\r\n\r\n    // Move the tower of height-1 from the intermediate pole to the destination pole using the source pole.\r\n    moveTower(height - 1, withPole, toPole, fromPole);\r\n  }\r\n}\r\n\r\n// Call the function with the initial parameters.\r\nmoveTower(3, \"A\", \"C\", \"B\");",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/54189/comments",
    "author": "peternroth",
    "comments": [
      {
        "user": "jakebailey",
        "created_at": "2023-05-09T04:13:14Z",
        "body": "You are attemping to execute TypeScript without compiling it to JavaScript, hence the error on the `:` token. You'll need to run `tsc` and then execute its output, or use a tool such as `ts-node` or `tsx` to run your script directly."
      }
    ]
  },
  {
    "number": 50564,
    "title": "Allow to use value as type in some cases",
    "created_at": "2022-08-31T12:13:10Z",
    "closed_at": "2022-09-02T04:35:24Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/50564",
    "body": "## \ud83d\udd0d Search Terms\r\nts2747, Allow to use value as type\r\n\r\n## \u2b50 Suggestion\r\n\r\nAllow to use value as type in some cases\r\n\r\n## \ud83d\udcbb Use Cases\r\n\r\nSometimes it would be nice to have ability to use value as type:\r\n```\r\nclass A {\r\n    public static classname = 'A';\r\n    public a: number = 2;\r\n    classname = 'A';\r\n    constructor (v: number) {\r\n        this.a = v;\r\n    }\r\n}\r\n\r\nclass B {\r\n    public static classname = 'B';\r\n    public b: number = 2;\r\n    classname = 'B';\r\n    constructor (v: number) {\r\n        this.b = v;\r\n    }\r\n}\r\n\r\nconst list = [new A(1), new A(2), new B(3), new A(4), new B(5)];\r\n\r\n// first case\r\nfunction findByType<T> (source: T[], type: Function): type { // 'type' refers to a value, but is being used as a type here.\r\n    return source.find(e => e instanceof type);\r\n}\r\nconsole.log(findByType(list, A).a + findByType(list, B).b);\r\n\r\n\r\n// second case\r\nfunction isTypeOf<T> (source: T, type: Function): source is type { // 'type' refers to a value, but is being used as a type here.\r\n    return (source as any).classname === (type as any).classname;\r\n}\r\nif (isTypeOf(list[0], A)) console.log(list[0].a);\r\n```\r\nThis is a highly simplified example, but it shows how this feature can be used in real application.\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/50564/comments",
    "author": "buryndin",
    "comments": [
      {
        "user": "buryndin",
        "created_at": "2022-08-31T13:31:35Z",
        "body": "I need not a 'typeof'. I pass type as parameter and I want to use this type.\r\ntypeof A === 'function' - it is useless.\r\nI understand that we cannot use type as value, because some kind of types ('type' or 'interface') does not exist in runtime(compiled js-code). But It seems using value as type is quite possible."
      },
      {
        "user": "IllusionMH",
        "created_at": "2022-08-31T13:52:37Z",
        "body": "Because you have explicit type `Function`. You should make that type generic (with constraint).\r\n\r\nAlso type of `type` is constructor type as you expect function and pass class constructor.\r\nYou should use `InstanceType<typeof type>` to get type you are looking for."
      },
      {
        "user": "fatcerberus",
        "created_at": "2022-08-31T13:53:33Z",
        "body": "> typeof A === 'function' - it is useless.\r\n\r\nWe're not talking about runtime `typeof`, we're talking about type-level `typeof`, which means \"get the compile-time type of this variable\":\r\n\r\n```ts\r\nlet x: number = 42;\r\nlet y: typeof x = 812;\r\n//  ^?\r\n//  (number)\r\n```"
      },
      {
        "user": "fatcerberus",
        "created_at": "2022-08-31T13:55:53Z",
        "body": "```ts\r\nfunction isTypeOf<T extends Function>(source: Function, type: T): source is typeof type {\r\n    return (source as any).classname === (type as any).classname;\r\n}\r\n```\r\n\r\nThis works.  But of course at this point you might as well just write `source is T`."
      },
      {
        "user": "buryndin",
        "created_at": "2022-08-31T14:29:51Z",
        "body": "> You should use `InstanceType<typeof type>`\r\nIt is not working:\r\n```ts\r\nfunction findByType<T> (source: T[], type: Function): InstanceType<typeof type> { // error Type 'Function' does not satisfy the constraint ...\r\n    return source.find(e => e instanceof type);\r\n}\r\n```\r\n> ```ts\r\n> function isTypeOf<T extends Function>(source: Function, type: T): source is typeof type {\r\n>     return (source as any).classname === (type as any).classname;\r\n> }\r\n> ```\r\n\r\nThis is does not work also\r\n```ts\r\nfunction isTypeOf<T extends {}>(source: {}, type: T): source is typeof type {\r\n    return (source as any).classname === (type as any).classname;\r\n}\r\nif (isTypeOf(list[0], A)) console.log(list[0].a); // Property 'a' does not exist on type 'B & typeof A'.\r\n```\r\n\r\nPlease see my suggestion carefully: if predicate isTypeOf is true I expect that on the line \r\n```\r\nif (isTypeOf(list[0], A)) console.log(list[0].a); \r\n```\r\ntypeof list[0]  = A"
      },
      {
        "user": "MartinJohns",
        "created_at": "2022-08-31T14:34:27Z",
        "body": "```typescript\r\nfunction isTypeOf<T extends new (...args: any) => any>(source: {}, type: T): source is InstanceType<T> {\r\n    return (source as any).classname === (type as any).classname;\r\n}\r\n```"
      },
      {
        "user": "IllusionMH",
        "created_at": "2022-08-31T14:35:50Z",
        "body": "> You should use InstanceType<typeof type>\r\n> It is not working:\r\n\r\nYou've skipped first part where it should be generic, but as **wisecerberus** mentioned, in that case you can just use generic `T` type instead of `typeof type`. Or as posted above by **MartinJohns**"
      },
      {
        "user": "fatcerberus",
        "created_at": "2022-08-31T14:38:54Z",
        "body": "> if predicate isTypeOf is true I expect that ... typeof list[0] = A\r\n\r\nThat's literally just `list[0] instanceof A`.  Martin's version is the correct way to implement your custom version."
      }
    ]
  },
  {
    "number": 48404,
    "title": "Update from 4.6.0-Beta to 4.6.1-RC introduced bug with Electron 12",
    "created_at": "2022-03-24T18:50:48Z",
    "closed_at": "2022-03-24T19:39:23Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/48404",
    "body": "# Bug Report\r\n\r\nAfter updating and compiling the project, the Electron-App (Runniing on Electron v12.0.2) does not load the resulting javascript file but reports an error just a view lines into the code.\r\n`Uncaught SyntaxError: Unexpected token '{'`\r\n\r\n### \ud83d\udd0e Search Terms\r\n\r\n`Uncaught SyntaxError: Unexpected token '{'` Electron 4.6.1-RC\r\n\r\n### \ud83d\udd57 Version & Regression Information\r\n\r\nAfter update from 4.5.0-Beta to 4.6.2, did some research to find it was introduced with 4.6.1-RC\r\n\r\n- This is a crash\r\n- This changed between versions 4.6.0-Beta and 4.6.1-RC\r\n\r\n\r\n### \ud83d\udcbb Code\r\n\r\n<!-- Please post the relevant code sample here as well-->\r\n```ts\r\n    class DebugConsole extends FudgeCore.DebugTarget {\r\n        static { this.delegates = {                                                    // error thrown from this line\r\n            [FudgeCore.DEBUG_FILTER.INFO]: console.info,\r\n            [FudgeCore.DEBUG_FILTER.LOG]: console.log,\r\n            [FudgeCore.DEBUG_FILTER.WARN]: console.warn,\r\n            [FudgeCore.DEBUG_FILTER.ERROR]: console.error,\r\n            [FudgeCore.DEBUG_FILTER.FUDGE]: DebugConsole.fudge,\r\n            [FudgeCore.DEBUG_FILTER.CLEAR]: console.clear,\r\n            [FudgeCore.DEBUG_FILTER.GROUP]: console.group,\r\n            [FudgeCore.DEBUG_FILTER.GROUPCOLLAPSED]: console.groupCollapsed,\r\n            [FudgeCore.DEBUG_FILTER.GROUPEND]: console.groupEnd,\r\n            [FudgeCore.DEBUG_FILTER.SOURCE]: DebugConsole.source\r\n        }; }\r\n```\r\n\r\nPrevious output, which Electron12 was able to run, was\r\n```ts\r\n    class DebugConsole extends FudgeCore.DebugTarget {\r\n          ....\r\n    }\r\n    DebugConsole.delegates = {\r\n            [FudgeCore.DEBUG_FILTER.INFO]: console.info,\r\n             ....\r\n```\r\n\r\n### \ud83d\ude41 Actual behavior\r\n\r\nElectron aborts loading the compiled Javascript file and throws the error \r\n\r\n### \ud83d\ude42 Expected behavior\r\n\r\nLoad the compiled file and run it\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/48404/comments",
    "author": "JirkaDellOro",
    "comments": [
      {
        "user": "DanielRosenwasser",
        "created_at": "2022-03-24T19:17:20Z",
        "body": "Hmm, are you using `--target esnext`? If so, that isn't a stable output target across different versions of TypeScript, and will emit syntax that may be newer than what your engine expects. In this case, I would expect `--target es2020` would be good enough. Otherwise, we need more info about what went wrong (e.g. compiler options and new output)."
      }
    ]
  },
  {
    "number": 47084,
    "title": "warning: Experimental support for decorators is a feature that is subject to change in a future release",
    "created_at": "2021-12-09T09:29:46Z",
    "closed_at": "2021-12-10T08:45:57Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/47084",
    "body": "# Bug Report\r\n\r\n<!--\r\n  Please fill in each section completely. Thank you!\r\n-->\r\n\r\n### \ud83d\udd0e Search Terms\r\n\r\nExperimental  decorators\r\n\r\n### \ud83d\udd57 Version & Regression Information\r\n\r\nmonaco: v0.30.1\r\ntypescript: 3.2.4\r\n\r\n\r\n### \ud83d\udcbb Code\r\nplaygroud code:\r\nmonaco.languages.typescript.javascriptDefaults.setDiagnosticsOptions({\r\n\tnoSemanticValidation: true,\r\n\tnoSyntaxValidation: false\r\n});\r\n\r\n// compiler options\r\nmonaco.languages.typescript.javascriptDefaults.setCompilerOptions({\r\n\ttarget: monaco.languages.typescript.ScriptTarget.ES2015,\r\n        experimentalDecorators: true,\r\n\tallowNonTsExtensions: true\r\n});\r\n\r\n\r\nvar jsCode = [\r\n    'import { Injectable } from \\'@angular/core\\';',\r\n    'import { ApplicationParamService } from \\'@farris/command-services\\';',\r\n    'import { HttpClient, HttpHeaders } from \\'@angular/common/http\\';',\r\n    '@Injectable()',\r\n    'export class List1FrmWebcmpService {',\r\n        'constructor(private obj: ApplicationParamService, private http:HttpClient) {',\r\n            'this.obj.parseParams;',\r\n        '}',\r\n        'private get() { }',\r\n        'set() { }',\r\n    '}'\r\n].join('\\n');\r\n\r\nmonaco.editor.create(document.getElementById('container'), {\r\n\tvalue: jsCode,\r\n\tlanguage: 'typescript'\r\n});\r\n\r\n### \ud83d\ude41 Actual behavior\r\n\r\n'List1FrmWebcmpService' has underline&warning ' Experimental support for decorators is a feature that is subject to change in a future release. Set the 'experimentalDecorators' option in your 'tsconfig' or 'jsconfig' to remove this warning '\r\n\r\n### \ud83d\ude42 Expected behavior\r\n'experimentalDecorators: true' option not wok,how to remove this warning?\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/47084/comments",
    "author": "chenqiangkobe",
    "comments": [
      {
        "user": "MartinJohns",
        "created_at": "2021-12-09T09:57:20Z",
        "body": "Did you mean to set `typescriptDefaults` instead of `javascriptDefaults`? Regardless, this doesn't seem to be an issue with TypeScript itself.\r\n\r\n> typescript: 3.2.4\r\n\r\nAre you really using a version released on 3. January **2019**? The latest version is 4.5.2."
      }
    ]
  },
  {
    "number": 37795,
    "title": "Better type inference for Frozen const arrays ",
    "created_at": "2020-04-05T01:01:08Z",
    "closed_at": "2020-04-23T22:02:26Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/37795",
    "body": "Search Terms: Object.freeze, Readonly\r\n\r\nI think typescript should have better type inference when object freeze is used on arrays and The type used is readonly array of the given type, instead the type should be readonly tuple that has the types used in the array.\r\n\r\nExample:\r\n``` javaScript\r\n// The type of the array is: \r\n// readonly Array<string | number>\r\n\r\n// What the type should be:\r\n// readonly [\"Abra\", \"Isma\", 0]\r\nconst b = Object.freeze([\"Abra\", \"Isma\", 0]);\r\n```",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/37795/comments",
    "author": "joseDaKing",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2020-04-17T20:59:07Z",
        "body": "You can use `as const` if this is your intent"
      },
      {
        "user": "RyanLamansky",
        "created_at": "2020-04-23T20:42:30Z",
        "body": "He means this:\r\n```TS\r\nconst b = Object.freeze([\"Abra\", \"Isma\", 0] as const);\r\n```"
      }
    ]
  },
  {
    "number": 33203,
    "title": "Compiler API: getConstantValue() can't get a real value from enum's PropertyAccessExpression",
    "created_at": "2019-09-03T03:48:37Z",
    "closed_at": "2019-09-04T01:43:49Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/33203",
    "body": "<!-- Please try to reproduce the issue with `typescript@next`. It may have already been fixed. -->\r\n**TypeScript Version:**  3.5.3\r\n\r\n<!-- Search terms you tried before logging this (so others can find this issue more easily) -->\r\n**Search Terms:**\r\n\r\nCompiler API, getConstantValue, PropertyAccessExpression\r\n\r\n**Code**\r\n\r\n```ts\r\nimport * as ts from \"typescript\";\r\n\r\n\r\nlet program = ts.createProgram(['/src/sandbox/test.ts'], {});\r\nlet checker = program.getTypeChecker();\r\n\r\nlet source = program.getSourceFile('/src/sandbox/test.ts')!;\r\n\r\nsource.forEachChild(node => {\r\n  switch (node.kind) {\r\n    case ts.SyntaxKind.EnumDeclaration:\r\n      (() => {\r\n        const real = node as ts.EnumDeclaration;\r\n        real.members.forEach(item => {\r\n          console.log(item.name.getText(), checker.getConstantValue(item))\r\n        })\r\n      })()\r\n      break;\r\n    case ts.SyntaxKind.ExpressionStatement:\r\n      (() => {\r\n        const a = node as ts.ExpressionStatement;\r\n        const real = a.expression as ts.PropertyAccessExpression;\r\n        console.log(checker.getConstantValue(real)) // ------------------------> Undefined\r\n      })()\r\n      break\r\n  }\r\n});\r\n```\r\n\r\nThe '/src/sandbox/test.ts':\r\n```ts\r\nenum Test {\r\n    A = 100,\r\n    B,\r\n}\r\n\r\nTest.A;\r\n```\r\n\r\n**Expected behavior:**\r\n\r\nTell me `100`\r\n\r\n**Actual behavior:**\r\n\r\nReturns `undefined`\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/33203/comments",
    "author": "mohanson",
    "comments": [
      {
        "user": "sandersn",
        "created_at": "2019-09-03T23:08:50Z",
        "body": "getConstantValue doesn't follow references back to their declaration. You have to do that yourself by looking at the symbol's declaration. Something like\r\n\r\n`checker.getConstantValue(checker.getSymbolAtLocation(real))`"
      }
    ]
  },
  {
    "number": 32043,
    "title": "Support 'as const' together with type restriction",
    "created_at": "2019-06-22T19:32:41Z",
    "closed_at": "2019-07-13T00:00:10Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/32043",
    "body": "Would be nice to be able to apply type checking to 'as const' types, currently I have to use the silly trick of using type checks when writing them, then switch to 'as const' afterwards.\r\n\r\n```\r\ntype MyType = {name: string};\r\n\r\nconst x:MyType = {\r\n    name: 'test' // Autocompleted, typesafe. But Type is {name: string}, not \r\n                 // what I want, I want {readonly name: 'test'}\r\n} as const;\r\n\r\nconst x = { name: 'test' } as const; // Gives correct type, but no type check for MyType...\r\n```",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/32043/comments",
    "author": "KnutRyagerInmeta",
    "comments": [
      {
        "user": "MartinJohns",
        "created_at": "2019-06-22T22:24:35Z",
        "body": "Your type `MyType` clearly says that `name` is a mutable property. If you want it read-only, then you can just use `Readonly<MyType>`."
      },
      {
        "user": "jcalz",
        "created_at": "2019-06-23T00:59:09Z",
        "body": "Helper function to the rescue!\r\n\r\n```ts\r\ntype MyType = { name: string };\r\nconst asMyType = <T extends MyType>(x: T) => x; // helper function\r\nconst x = asMyType({ name: \"test\" } as const); // \ud83d\ude03\r\n```"
      },
      {
        "user": "MartinJohns",
        "created_at": "2019-06-23T16:15:47Z",
        "body": "@KnutRyagerInmeta You mean a string literal type, e.g. `'fixed'` instead of `string`. In that case the same logic applies: Your type `MyType` explicitly says the property `name` can be of **any** string.\r\n\r\nWith jcalz solution you will have the same issue when you use the wrong type:\r\n\r\n    const x: MyType = asMyType({ name: \"test\" } as const); // x.name is of type string again\r\n\r\nBut I likely misunderstand you, and you want something like \"make sure this object matches SomeType, then make it a const context\", in which case jcalz solution is probably the best."
      }
    ]
  },
  {
    "number": 31176,
    "title": "Type checking of extended mapped type",
    "created_at": "2019-04-30T18:49:06Z",
    "closed_at": "2019-05-01T12:14:48Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/31176",
    "body": "**Typescript version:** 3.4.5.\r\n\r\nI'm writing the boilerplate code for type-safe Express routes in my projects, possibly even create a npm library, if it works as expected.\r\nThe idea is to make sure all the API responses have the shape\r\n```ts\r\n{result: T, error?: any}\r\n```\r\nwhere T is the Response type of the route, or\r\n```ts\r\n{error: any}\r\n```\r\nif there is an error and declare the type of each routes' request and response types in a declarative way.\r\n\r\nThe API is routed under the `/api` route. I'm accomplishing this with `app.use('/api', indexRouter.router)`, where `indexRouter` is an instance of `WrappedRouter` (which is defined at the end of this bug report) which is imported from the file `routes/index.ts`.\r\n\r\n**Contents of `routes/index.ts`**:\r\n```ts\r\nimport authRouter from './auth';\r\nimport makeRouter from \"../utils/RestRoute\";\r\n\r\nconst router = makeRouter();\r\n\r\nrouter.makeSubRoute('/auth',authRouter);\r\n\r\nexport default router;\r\n```\r\n\r\n**Contents of `routes/auth/types.ts`**:\r\n```ts\r\nimport {ITypes} from '../../utils/RestRoute';\r\n\r\nexport interface Types extends ITypes {\r\n    '/sayHello': {\r\n        request: void,\r\n        response: string\r\n    }\r\n}\r\n```\r\n\r\nThe idea is that I can now write this:\r\n**Contents of `routes/auth/index.ts`**:\r\n```ts\r\nimport makeRouter from '../../utils/RestRoute';\r\nimport {Types} from \"./types\";\r\n\r\nconst router = makeRouter<Types>();\r\n\r\nrouter.route('/sayHello',args => ({\r\n    result: 'Hello World!'\r\n}));\r\n\r\nexport default router.router;\r\n```\r\n____________________________________________________________\r\n\r\n**Contents of `RestRoute.ts`** (which contains the wrapper around Express.JS's Route and most of the boilerplate logic):\r\n\r\n```ts\r\nimport express from 'express';\r\n\r\nexport interface ITypes {\r\n    [key: string]: {\r\n        request: any,\r\n        response: any\r\n    }\r\n}\r\n\r\ninterface HandlerFuncionArgs<Req> {\r\n    cookies: express.Request[\"cookies\"],\r\n    hostname: express.Request[\"hostname\"],\r\n    ip: express.Request[\"ip\"],\r\n    clearCookie: express.Response[\"clearCookie\"],\r\n    cookie: express.Response[\"cookie\"],\r\n    secure: express.Request[\"secure\"],\r\n    body: Req,\r\n    params: express.Request[\"params\"]\r\n}\r\n\r\nexport type APIResultType<T> = {result: T, error?: any} | {error: any};\r\n\r\nexport type HandlerFunction<Req,Res> = (args: HandlerFuncionArgs<Req>)=>APIResultType<Res> & {status?: number};\r\n\r\nclass WrappedRouter<Types extends ITypes> {\r\n    public constructor(public readonly router: express.Router) {}\r\n\r\n    private static proxyFunction<Req,Res>(handlerFunction: HandlerFunction<Req,Res>): express.RequestHandler {\r\n        return (req, res, next) => {\r\n            res.type('application/json');\r\n            try {\r\n                const ret = handlerFunction({\r\n                    cookies: req.cookies,\r\n                    hostname: req.hostname,\r\n                    ip: req.ip,\r\n                    clearCookie: res.clearCookie,\r\n                    cookie: res.cookie,\r\n                    secure: req.secure,\r\n                    body: req.body,\r\n                    params: req.params\r\n                });\r\n                res.status(ret.status || 200);\r\n                delete ret.status;\r\n                res.json(ret as APIResultType<Res>);\r\n            } catch(e) {\r\n                res.status(500);\r\n                res.json({error: e} as APIResultType<Res>);\r\n            } finally {\r\n                res.end();\r\n            }\r\n        };\r\n    }\r\n\r\n    public route<Path extends keyof Types>(path: Path, handlerFunction: HandlerFunction<Types[Path][\"request\"],Types[Path][\"response\"]>):void {\r\n        this.router.post(path as string,WrappedRouter.proxyFunction(handlerFunction));\r\n    }\r\n\r\n    public makeSubRoute(path: string, subRouter: express.Router): void;\r\n\r\n    public makeSubRoute<SubRouterTypes extends ITypes>(path: string, subRouter: WrappedRouter<SubRouterTypes>): void;\r\n\r\n    public makeSubRoute<SubRouterTypes extends ITypes>(path: string, subRouter: express.Router|WrappedRouter<SubRouterTypes>) {\r\n        if(subRouter instanceof WrappedRouter) {\r\n            this.router.use(path,subRouter.router);\r\n        } else {\r\n            this.router.use(path,subRouter);\r\n        }\r\n    }\r\n}\r\n\r\nexport function wrapRouter<Types extends ITypes>(router: express.Router) {\r\n    return new WrappedRouter<Types>(router);\r\n}\r\n\r\nexport function makeRouter<Types extends ITypes>() {\r\n    return new WrappedRouter<Types>(express.Router({caseSensitive: true, mergeParams: true}));\r\n}\r\n\r\nexport default makeRouter;\r\n```\r\n(`ITypes` is supposed to be the generic shape of every route's type: each key, representing a route, should contain an object with \"response\" and \"request\" as its only keys. `ITypes` isn't supposed to be instantiated, only extended by other types)\r\n\r\n**Expected behavior:**\r\nCorrectly checks the types of the request and response of each route **AND** doesn't allow routes which aren't defined in that sub-route's `Type`.\r\n\r\n**Actual behaviour:**\r\nIt works well in checking the types of the route: ie. if I try to return `result: 1` in the `/api/auth/sayHello` route, the compiler fails and says that number isn't compatible with string.\r\nThe problem is when I mistype `/sayHello` for, say, `/sayHelo`. There is no error reported from the compiler _even though_ `WrappedRouter.route`'s first argument is of type `Path extends keyof Types`. It just simply accepts any type in the request and any type in the response... It should be an error because `/sayHelo` __**is not**__ in `keyof Type`, which is equal to `/sayHelo`.\r\n\r\nI'm guessing the problem is in extending the interface because it is first declared as having string keys but doesn't specify the keys' type when it is extended. I think `keyof Types` computes to `\"/sayHello\" | string`.\r\n\r\nI've tried to change the generic type of the `route` function to `<Path extends Exclude<keyof Types, string>>` but it doesn't work because it also deletes `\"/sayHello\"` from the union type. Then the `router.route('/sayHello' (...)` line in the `auth/index.ts` file reports the error `TS2345: Argument of type '\"/sayHello\"' is not assignable to parameter of type 'number'`.\r\n\r\nIs there any workaround or a hacky way of accomplishing this while this isn't fix this in a future version of TS?",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/31176/comments",
    "author": "TheDSCPL",
    "comments": [
      {
        "user": "dragomirtitian",
        "created_at": "2019-04-30T21:29:50Z",
        "body": "That is one long question, might I suggest in the future: \r\n\r\n1. Isolating a smaller code snippet illustrating your issue.\r\n2. Trying stackoverflow first. This forum is generally reserved for bugs, or questions that SO didn't or can't answer (you will probably get answers there just as fast here and by the same people)\r\n\r\nThat being said, your root cause is that you force `Types` to have an index signature. If `Types` has an index signature, `keyof Types` will be `string` allowing any string in path.\r\n\r\nYou can change the definitions a bit, you actually want to constrain `ITypes` to have only properties of type `{ request: any, response: any }` regardless of if they have an index signature.\r\n\r\nA solution that seems to work (although I have not tested it a lot) would be: \r\n\r\n```ts\r\n//RestRoute.ts\r\nimport express from 'express';\r\n\r\nexport type ITypes<K extends PropertyKey> = Record<K, { request: any, response: any }>\r\n\r\ninterface HandlerFuncionArgs<Req> {\r\n    cookies: express.Request[\"cookies\"],\r\n    hostname: express.Request[\"hostname\"],\r\n    ip: express.Request[\"ip\"],\r\n    clearCookie: express.Response[\"clearCookie\"],\r\n    cookie: express.Response[\"cookie\"],\r\n    secure: express.Request[\"secure\"],\r\n    body: Req,\r\n    params: express.Request[\"params\"]\r\n}\r\n\r\nexport type APIResultType<T> = {result: T, error?: any} | {error: any};\r\n\r\nexport type HandlerFunction<Req,Res> = (args: HandlerFuncionArgs<Req>)=>APIResultType<Res> & {status?: number};\r\n\r\nclass WrappedRouter<Types extends ITypes<keyof Types>> {\r\n    public constructor(public readonly router: express.Router) {}\r\n\r\n    private static proxyFunction<Req,Res>(handlerFunction: HandlerFunction<Req,Res>): express.RequestHandler {\r\n        return (req, res, next) => {\r\n            res.type('application/json');\r\n            try {\r\n                const ret = handlerFunction({\r\n                    cookies: req.cookies,\r\n                    hostname: req.hostname,\r\n                    ip: req.ip,\r\n                    clearCookie: res.clearCookie,\r\n                    cookie: res.cookie,\r\n                    secure: req.secure,\r\n                    body: req.body,\r\n                    params: req.params\r\n                });\r\n                res.status(ret.status || 200);\r\n                delete ret.status;\r\n                res.json(ret as APIResultType<Res>);\r\n            } catch(e) {\r\n                res.status(500);\r\n                res.json({error: e} as APIResultType<Res>);\r\n            } finally {\r\n                res.end();\r\n            }\r\n        };\r\n    }\r\n\r\n    public route<Path extends keyof Types>(path: Path, handlerFunction: HandlerFunction<Types[Path][\"request\"],Types[Path][\"response\"]>):void {\r\n        this.router.post(path as string,WrappedRouter.proxyFunction(handlerFunction));\r\n    }\r\n\r\n    public makeSubRoute(path: string, subRouter: express.Router): void;\r\n\r\n    public makeSubRoute<SubRouterTypes extends ITypes<keyof SubRouterTypes>>(path: string, subRouter: WrappedRouter<SubRouterTypes>): void;\r\n\r\n    public makeSubRoute<SubRouterTypes extends ITypes<keyof SubRouterTypes>>(path: string, subRouter: express.Router|WrappedRouter<SubRouterTypes>) {\r\n        if(subRouter instanceof WrappedRouter) {\r\n            this.router.use(path,subRouter.router);\r\n        } else {\r\n            this.router.use(path,subRouter);\r\n        }\r\n    }\r\n}\r\n\r\nexport function wrapRouter<Types extends ITypes<keyof Types>>(router: express.Router) {\r\n    return new WrappedRouter<Types>(router);\r\n}\r\n\r\nexport function makeRouter<Types extends ITypes<keyof Types>>() {\r\n    return new WrappedRouter<Types>(express.Router({caseSensitive: true, mergeParams: true}));\r\n}\r\n\r\nexport default makeRouter;\r\n\r\n// types.ts\r\n\r\nimport {ITypes} from '../../utils/RestRoute';\r\n\r\nexport interface Types extends ITypes<keyof Types> { // ensures all properties have the correct shape\r\n    '/sayHello': {\r\n        request: void,\r\n        response: string\r\n    }\r\n}\r\n\r\n//auth/index.ts\r\nimport makeRouter from '../../utils/RestRoute';\r\n\r\nimport {Types} from \"./types\";\r\n\r\nconst router = makeRouter<Types>();\r\n\r\n//ok\r\nrouter.route('/sayHello',args => ({\r\n    result: 'Hello World!'\r\n}));\r\n\r\n//err\r\nrouter.route('/sayHelloo',args => ({\r\n    result: 'Hello World!'\r\n}));\r\n\r\nexport default router.router;"
      }
    ]
  },
  {
    "number": 30707,
    "title": "weird type relationship",
    "created_at": "2019-04-02T16:07:01Z",
    "closed_at": "2019-04-02T17:13:42Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/30707",
    "body": "problem:\r\n\r\n```ts\r\ndeclare function sureNever<_T extends never>(): void;\r\ntype NeverDifferent<L, R> = L extends R ? R extends L ? never : 'right does not extend left' : 'left does not extend right';\r\nsureNever<NeverDifferent<'a', 'a'>>(); // works\r\nsureNever<NeverDifferent<{}, {}>>(); // works\r\nsureNever<NeverDifferent<'a' | 'b', 'a' | 'b'>>(); // breaks: Type '\"right does not extend left\"' does not satisfy the constraint 'never'\r\n```\r\n\r\nnasty workaround:\r\n\r\n```ts\r\ndeclare function sureIdentical<L, R>(\r\n    asRight: (left: L) => R,\r\n    asLeft: (right: R) => L,\r\n): void;\r\nsureIdentical<'a' | 'b', 'a'>(x => x, x => x); // breaks as expected\r\nsureIdentical<'a', 'a' | 'b'>(x => x, x => x); // breaks as expected\r\nsureIdentical<'a' | 'b', 'a' | 'b'>(x => x, x => x); // works as expected\r\n```",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/30707/comments",
    "author": "zpdDG4gta8XKpMCd",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2019-04-02T17:07:49Z",
        "body": "Conditional type distributivity (yr fav) is what's causing this. This produces the behavior desired by the example:\r\n```ts\r\ntype NeverDifferent<L, R> = [L] extends [R] ? R extends L ? never : 'right does not extend left' : 'left does not extend right';\r\n```"
      }
    ]
  },
  {
    "number": 30641,
    "title": "defaultProps in HOC when use React.ComponentType<M>",
    "created_at": "2019-03-29T07:59:37Z",
    "closed_at": "2019-07-13T00:00:45Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/30641",
    "body": "I have a problem of HOC .  when pass a component with a defaultProps to HOC, the props of component exposed to user become optional as the defaultProps is Partial. see example below\r\n\r\nthe property df1 and df2 is not optional after wrapper by HOC!\r\n\r\nbecause \r\n\r\n```js\r\nconst TabRCT = Tab as React.ComponentType<Props & WithProps>\r\ntype DpProps = typeof TabRCT.defaultProps\r\ntype DpProps1 = typeof Tab.defaultProps\r\n```\r\nDpProps is Partial<Props & WithProps> | undefined\r\nDpProps1 is DefaultTabProps\r\n\r\n\r\nthe complete example\r\n \r\n```js\r\nimport * as React from 'react'\r\n\r\ninterface DefaultTabProps {\r\n  df1: number,\r\n  df2: string\r\n}\r\n\r\ninterface Props extends DefaultTabProps {\r\n  pp1?: number\r\n  pp2: number\r\n}\r\n\r\ninterface WithProps {\r\n  wp: string\r\n}\r\n\r\ninterface InjectProps {\r\n  ij: number\r\n}\r\n\r\nclass Tab extends React.Component<Props & WithProps, any> {\r\n  static defaultProps: DefaultTabProps = {\r\n    df1: 11,\r\n    df2: '12'\r\n  }\r\n  render() {\r\n    return <div />\r\n  }\r\n}\r\n\r\n\r\ntype Merge<M, T> = Pick<M, Exclude<keyof M, keyof T>> & T\r\n\r\n\r\n// \u5e0c\u671bM\u662f\u5904\u7406\u540e\u7684 \uff0c\u5373\u6700\u521dM\u662fProps\uff0c\u6700\u540e\u7ec4\u4ef6\u66b4\u9732\u51fa\u6765\u7684props\u662f{...Props, ...DefaultProps }\uff0c\u800cWithProps\u540e\u66b4\u9732\u51fa\u6765\u7684\u8fd8\u662fProps\uff0c\u5e0c\u671b\u52a0\u4e0aWithProps\r\nfunction WithTest<M>(Cp: React.ComponentType<M & WithProps>) {\r\n  return (props: Merge<M, typeof Cp.defaultProps> & InjectProps) => {\r\n    let params = omit(props, ['ij']) as M\r\n    let wp = (props.ij * 100) + '%'\r\n    return <Cp {...params} wp={wp}/>\r\n  }\r\n}\r\n\r\nconst TabWith = WithTest(Tab)\r\n\r\n\r\nfunction omit<T, K extends keyof T>(obj: T, keys: K[]) {\r\n  const newObj: { [key in keyof OmitType<T, K>]?: T[key] } = {}\r\n\r\n  return (Object.keys(obj) as (keyof OmitType<T, K>)[])\r\n    .filter((curr: any) => !keys.includes(curr))\r\n    .reduce((acc: { [key in keyof OmitType<T, K>]?: T[key] }, curr: (keyof OmitType<T, K>)) => (\r\n      acc[curr] = obj[curr],\r\n      acc\r\n    ), newObj)\r\n}\r\n \r\n\r\nconst obj = {\r\n  A: <TabWith ij={12} pp2={1} /> \r\n}\r\n\r\n```\r\n\r\n\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/30641/comments",
    "author": "luckhpy",
    "comments": [
      {
        "user": "dragomirtitian",
        "created_at": "2019-03-29T08:23:44Z",
        "body": "Might I suggest asking this sort of question on SO first. There is a dedicated comunity there just wating to help. GitHub is for bugs or questions that SO can't answer or need an official position (IMO)\r\n\r\nThere is no magic reason for the default props to be preserved in the wrapped component. The returned function does not have a defaultProps. If you want to preserve default props you need to add them to the returned function type. This will work as you expect it: \r\n\r\n```ts\r\nfunction WithTest<M, DF>(Cp: React.ComponentType<M & WithProps> & { defaultProps : DF}) : { // Explicit return annotation not required, just for clarity \r\n  (props: Merge<M, typeof Cp.defaultProps> & InjectProps) : JSX.Element\r\n  defaultProps : DF\r\n} {\r\n  function wrapped (props: Merge<M, typeof Cp.defaultProps> & InjectProps) {\r\n    let params = omit(props, ['ij']) as M\r\n    let wp = (props.ij * 100) + '%'\r\n    return <Cp {...params as any} wp={wp}/> // The conditional types that handle the defaults make this assertion necessary unfortunately \r\n  }\r\n  wrapped.defaultProps = Cp.defaultProps\r\n  return wrapped\r\n}\r\n```"
      }
    ]
  },
  {
    "number": 30127,
    "title": "Is it possible to define a universal default generic type parameter so that a bottom object like `new None()`, can type check any type of None, such as None<number>, None< ()=>any >?",
    "created_at": "2019-02-27T14:33:11Z",
    "closed_at": "2019-07-13T00:01:00Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/30127",
    "body": "**In short, TypeScripts uses type {} for default generic type parameter, when T is not provided for `new ClassA<T>(...)`** so Applicative data structure would require developers more concious with types, which is a barrier for more advanced data structure.\r\n\r\nIs it possible to define an universal default generic type so that a bottom datastructure like `new None()`, can type check any type of None, such as `None<number>`, `None< ()=>any >`?\r\n\r\n**Details:**\r\n\r\nI was trying to implement an Applicative data structure in TS as the Applicative of Haskell:\r\n\r\n```\r\n(Some f) <*> (Some x) = Some (f x)\r\n(None) <*>(Some x) = None\r\n```\r\n\r\nFirst try is to implement functor/applicative  on Option and subclass Some and None.\r\nBelow is the type and class definition:\r\n\r\n\r\n```\r\nexport const id = (a: any) => a\r\n\r\nexport interface Functor<T> {\r\n  fmap(f: (a: T) => any): Functor<any>\r\n}\r\n\r\nexport interface Applicative<T> extends Functor<T> {\r\n  ffmap(af: Applicative<(a: T) => any>): Applicative<any>\r\n}\r\n\r\nexport abstract class Option<T> implements Functor<T> {\r\n  abstract _a: T | undefined\r\n\r\n  abstract fmap(f: (a: T) => any): Functor<any>\r\n\r\n  *[Symbol.iterator]() {\r\n    yield this._a\r\n  }\r\n}\r\n\r\nexport class Some<T> extends Option<T> {\r\n  _a: T\r\n\r\n  constructor(a: T) {\r\n    super()\r\n    this._a = a\r\n  }\r\n\r\n  fmap(f: (a: T) => any): Option<any> {\r\n    return new Some(f(this._a))\r\n  }\r\n\r\n  ffmap(a: Option<(a: T) => any>): Option<any> {\r\n    if (a instanceof None) return new None()\r\n\r\n    const f = a._a\r\n\r\n    if (f === undefined || f === null) return new None()\r\n    else return new Some(f!(this._a))\r\n  }\r\n}\r\n\r\nexport class None<T> extends Option<T> {\r\n  _a: T | undefined\r\n  constructor() {\r\n    super()\r\n    this._a = undefined\r\n  }\r\n\r\n  fmap(f: (a: T) => any): Option<any> {\r\n    return new None()\r\n  }\r\n\r\n  ffmap(a: Option<(a: T) => any>): Option<any> {\r\n    return new None()\r\n  }\r\n}\r\n\r\n```\r\nI have written some test cases and most work. However when test the case :\r\n\r\n```\r\n  test(' Some.ffmap(None) === None', () => {\r\n    const a = new Some(33)\r\n\r\n    const af = new None()\r\n\r\n    expect(a.ffmap(af)).toEqual(new None())\r\n  })\r\n```\r\n\r\nFollowing error is reported:\r\n```\r\n    src/index.test.ts:116:20 - error TS2345: Argument of type 'None<{}>' is not assignable to parameter of type 'Option<(a: number) => any>'.\r\n      Types of property '_a' are incompatible.\r\n        Type '{} | undefined' is not assignable to type '((a: number) => any) | undefined'.\r\n          Type '{}' is not assignable to type '(a: number) => any'.\r\n            Type '{}' provides no match for the signature '(a: number): any'.\r\n\r\n    116     expect(a.ffmap(af)).toEqual(new None())\r\n```\r\n\r\nSpcifically, TS consider new None() has the type of new None<{}>(), which is no match with applicative parameter, new None< ()=>any>()\r\n\r\nWhen I change the test case to the following, it works:\r\n\r\n```\r\n  test(' Some.fmap(None) = None', () => {\r\n    const a = new None<number>()\r\n\r\n    const f = (a: number) => a + 2\r\n\r\n    expect(a.fmap(f)).toEqual(a)\r\n  })\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/30127/comments",
    "author": "reactma",
    "comments": [
      {
        "user": "jack-williams",
        "created_at": "2019-02-27T14:39:57Z",
        "body": "Did you try:\r\n```ts\r\nexport class None extends Option<never> {\r\n    \u2026\r\n}\r\n```"
      },
      {
        "user": "j-oliveras",
        "created_at": "2019-02-27T14:42:07Z",
        "body": "You can defined a default type parameter as:\r\n```ts\r\n// Change any with the type you want to be the default.\r\nexport interface Functor<T = any> {\r\n  fmap(f: (a: T) => any): Functor<any>\r\n}\r\n```"
      }
    ]
  },
  {
    "number": 29411,
    "title": "Function return value types not inferred in some cases",
    "created_at": "2019-01-14T20:52:32Z",
    "closed_at": "2019-01-15T17:54:18Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/29411",
    "body": "**TypeScript Version:**  3.3.0-dev.20190112\r\n\r\n**Search Terms:** function return type\r\n\r\n**Code**\r\n See code below which has a function returning a Promise<HelloInterface | undefined>\r\nThe calling code only infers the type to be HelloInterface.\r\n\r\n```ts\r\nclass Example1 {\r\n  public testFunction1(): void {\r\n    this.getResponse().then((value: HelloInterface) => {  // Expected tsc to infer this to be value: HelloInterface | undefined \r\n\r\n      console.log(value.property1);  // Potential runtime error as value can be undefined.\r\n    });\r\n  }\r\n\r\n  private getResponse(): Promise<HelloInterface | undefined> {\r\n    return Promise.resolve({ \"property1\": \"value1\" });\r\n  }\r\n}\r\n\r\ninterface HelloInterface {\r\n  \"property1\": string;\r\n}\r\n\r\n```\r\n\r\n**Expected behavior:**\r\n1) value should have inferred type as HelloInterface | undefined. \r\nThis will force me to handle the case where it is undefined in the caller.\r\n\r\n**Actual behavior:**\r\nvalue has type HelloInterface\r\nThere will be a runtime error when we access say value.property1 when value is undefined.\r\n\r\n**Playground Link:** \r\nPaste above code in vscode editor. \r\nI would expect vscode editor to indicate an error for value possibly being undefined.\r\n\r\n** Other Observations **\r\n The same works if the function return type is say Promise<HelloInterface | string>\r\n It appears this is seen when we have 'undefined' as one of the return value types.\r\n\r\n**Related Issues:**\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/29411/comments",
    "author": "psavur",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2019-01-14T21:53:26Z",
        "body": "Sounds like you have `strictNullChecks` off - enable this option to have TS check for `null` / `undefined` values"
      },
      {
        "user": "psavur",
        "created_at": "2019-01-14T23:26:34Z",
        "body": "@RyanCavanaugh  strictNullChecks are on.\r\nI updated the code example above to be more clear.\r\n\r\n"
      },
      {
        "user": "ajafff",
        "created_at": "2019-01-15T07:42:24Z",
        "body": "And do you have `strictFunctionTypes` enabled?"
      }
    ]
  },
  {
    "number": 29295,
    "title": "Extract<keyof T, string> is not assignable to K extends Extract<keyof T, string> when used as K[]",
    "created_at": "2019-01-07T20:06:40Z",
    "closed_at": "2019-01-08T00:11:45Z",
    "labels": [
      "Question",
      "Domain: lib.d.ts"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/29295",
    "body": "**TypeScript Version:**  3.3.0-dev.20190105\r\n\r\n<!-- Search terms you tried before logging this (so others can find this issue more easily) -->\r\n**Search Terms:** keyof string array, K extends Extract<keyof T, string>\r\n\r\n**Code**\r\n\r\nUsing a generic `K extends Extract<keyof T, string>` generic definition does not work:\r\n\r\n```ts\r\nfunction copyAllExcept<T, K extends Extract<keyof T, string>>(target: any, source: T, skip: K[]) {\r\n    for (const key in source) {\r\n        if (source[key] != null && !skip.includes(key)) {\r\n            target[key] = source[key];\r\n        }\r\n    }\r\n}\r\n```\r\nError at the `!skip.includes(key)` part:\r\n\r\nArgument of type 'Extract<keyof T, string>' is not assignable to parameter of type 'K'.\r\n  Type 'string & keyof T' is not assignable to type 'K'.\r\n    Type 'string' is not assignable to type 'K'.\r\n      Type 'string' is not assignable to type 'K'.\r\n\r\n\r\nUsing `Array<Extract<keyof T, string>>` directly as the argument definition does work though:\r\n\r\n```ts\r\nfunction copyAllExcept<T>(target: any, source: T, skip: Array<Extract<keyof T, string>>) {\r\n    for (const key in source) {\r\n        if (source[key] != null && !skip.includes(key)) {\r\n            target[key] = source[key];\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/29295/comments",
    "author": "manigandham",
    "comments": [
      {
        "user": "weswigham",
        "created_at": "2019-01-07T23:56:18Z",
        "body": "You don't need the `K` type parameter - you're overconstraining your input a bit:\r\n```ts\r\nfunction copyAllExcept<T>(target: any, source: T, skip: (Extract<keyof T, string>)[]) {\r\n  for (const key in source) {\r\n      if (source[key] != null && !skip.includes(key)) {\r\n          target[key] = source[key];\r\n      }\r\n  }\r\n}\r\n```\r\nand that seems to work fine.\r\n\r\nNow, the type parameter doesn't work because you're saying that you're searching through a `K[]` for a `Extract<keyof T, string>` - while `K extends Extract<keyof T, string>`, `Extract<keyof T, string>` is a less specific type and so doesn't satisfy the argument type. `includes` is going to be OK with this at runtime anyway - the parameter type is actually meaningless, you define its type as `unknown` and be fine, which is what's unfortunate here - the `lib` definition of `Array.prototype.includes` constrains its argument to the type of only things in the array - meaning you can't pass less specific types that might still be the same as things in the array."
      }
    ]
  },
  {
    "number": 29097,
    "title": "error TS2304: Cannot find name 'EventListenerOrEventListenerObject' (and others)",
    "created_at": "2018-12-19T14:32:15Z",
    "closed_at": "2018-12-19T19:47:08Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/29097",
    "body": "This is a duplicate of #21922, but that one has been fixed in 2.8. Maybe the DT entry for electron needs updating. In this case this issue would be obsolete.\r\n\r\n**TypeScript Version:**  3.3.0-dev.20181219\r\n\r\n**Search Terms:**\r\n\r\n**Code**\r\n\r\n```ts\r\n// any code using electron, both with obsolete @types/electron or types included in electron.\r\n```\r\n\r\n**Expected behavior:**\r\n\r\nNo errors\r\n\r\n**Actual behavior:**\r\n\r\n```\r\ntsc --noEmit\r\n\r\nnode_modules/electron/electron.d.ts:3675:116 - error TS2304: Cannot find name 'ReadableStream'.\r\n\r\n3675     interceptStreamProtocol(scheme: string, handler: (request: InterceptStreamProtocolRequest, callback: (stream?: ReadableStream | StreamProtocolResponse) => void) => void, completion?: (error: Error) => void): void;\r\n                                                                                                                        ~~~~~~~~~~~~~~\r\n\r\nnode_modules/electron/electron.d.ts:3744:114 - error TS2304: Cannot find name 'ReadableStream'.\r\n\r\n3744     registerStreamProtocol(scheme: string, handler: (request: RegisterStreamProtocolRequest, callback: (stream?: ReadableStream | StreamProtocolResponse) => void) => void, completion?: (error: Error) => void): void;\r\n                                                                                                                      ~~~~~~~~~~~~~~\r\n\r\nnode_modules/electron/electron.d.ts:4200:11 - error TS2304: Cannot find name 'ReadableStream'.\r\n\r\n4200     data: ReadableStream;\r\n               ~~~~~~~~~~~~~~\r\n\r\nnode_modules/electron/electron.d.ts:6535:38 - error TS2304: Cannot find name 'HTMLElementEventMap'.\r\n\r\n6535     addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, useCapture?: boolean): void;\r\n                                          ~~~~~~~~~~~~~~~~~~~\r\n\r\nnode_modules/electron/electron.d.ts:6535:102 - error TS2304: Cannot find name 'HTMLElementEventMap'.\r\n\r\n6535     addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, useCapture?: boolean): void;\r\n                                                                                                          ~~~~~~~~~~~~~~~~~~~\r\n\r\nnode_modules/electron/electron.d.ts:6536:46 - error TS2304: Cannot find name 'EventListenerOrEventListenerObject'.\r\n\r\n6536     addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\r\n                                                  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n\r\nnode_modules/electron/electron.d.ts:6537:41 - error TS2304: Cannot find name 'HTMLElementEventMap'.\r\n\r\n6537     removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, useCapture?: boolean): void;\r\n                                             ~~~~~~~~~~~~~~~~~~~\r\n\r\nnode_modules/electron/electron.d.ts:6537:105 - error TS2304: Cannot find name 'HTMLElementEventMap'.\r\n\r\n6537     removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, useCapture?: boolean): void;\r\n                                                                                                             ~~~~~~~~~~~~~~~~~~~\r\n\r\nnode_modules/electron/electron.d.ts:6538:49 - error TS2304: Cannot find name 'EventListenerOrEventListenerObject'.\r\n\r\n6538     removeEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\r\n                                                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n\r\n[EDIT: removed irrelevant errors]\r\n```\r\n**Playground Link:** <!-- A link to a TypeScript Playground \"Share\" link which demonstrates this behavior -->\r\n\r\n**Related Issues:** #21922",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/29097/comments",
    "author": "mutech",
    "comments": [
      {
        "user": "weswigham",
        "created_at": "2018-12-19T18:17:09Z",
        "body": "`EventListenerOrEventListenerObject` is definitely still used in the `DOM` lib file - are you compiling with `noLib` or without the dom lib?"
      },
      {
        "user": "weswigham",
        "created_at": "2018-12-19T18:58:23Z",
        "body": "Yeah, I can only repro these errors if the `dom` lib isn't in the build. Does your `lib` compiler option include `dom`?"
      },
      {
        "user": "mutech",
        "created_at": "2018-12-19T19:47:08Z",
        "body": "You're right, `dom` was missing. I split the compilation for main and renderer parts and removed `dom` for the main part. Didn't realize tha the d.ts is the same for node/chrome. Sorry for the noise."
      }
    ]
  },
  {
    "number": 28593,
    "title": "Classes cannot satisfy Constructor<Itself> bound",
    "created_at": "2018-11-18T21:28:08Z",
    "closed_at": "2018-11-19T18:41:55Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/28593",
    "body": "<!-- Please try to reproduce the issue with `typescript@next`. It may have already been fixed. -->\r\n**TypeScript Version:**  3.2.0-dev.201xxxxx\r\n\r\n<!-- Search terms you tried before logging this (so others can find this issue more easily) -->\r\n**Search Terms:** generics mixin classes interfaces constructor\r\n\r\n**Code**\r\n\r\n```ts\r\ntype Constructor<T> = new(...args: any[]) => T;\r\n\r\ninterface XInterface {}\r\nfunction make<T extends Constructor<XInterface>>(Base: T) {\r\n    return class extends Base implements XInterface {}\r\n}\r\n\r\n// This is ok.\r\nclass X extends make(Function) { }\r\n\r\n// But this fails.\r\nclass X2 extends make(Function) implements Constructor<XInterface> { }\r\n```\r\n\r\n**Expected behavior:** \r\nCode should compile\r\n\r\n**Actual behavior:**\r\nCompiler error: X2 provides no match for signature `new(...args: any[]) => XInterface`\r\n\r\n\r\n--- \r\n\r\n**Edit 1:**\r\nLooks like even something more basic like \r\n\r\n```ts\r\nclass Y implements XInterface, Constructor<XInterface> {}\r\n```\r\n\r\nfails to compile. This makes it difficult to chain together a set of mixin extending through another mixin function. \r\n\r\n**Edit 2**\r\n\r\nLooks like even the simplest case of\r\n\r\n```ts\r\nclass Y implements Constructor<Y>\r\n```\r\n\r\nfails.",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/28593/comments",
    "author": "prasannavl",
    "comments": [
      {
        "user": "weswigham",
        "created_at": "2018-11-19T18:29:30Z",
        "body": "@prasannavl the `implements` clause constrains the instance shape of a class - the constructor signature of a class is associate with its static side (it returns the instance), therefore isn't constrainable via `implements`.\r\n\r\n```ts\r\nclass X2 extends make(Function) implements Constructor<XInterface> { }\r\n```\r\nis saying the class X2 extends a `Constructor<XInterface>` and its instance is a `Constructor<XInterface>` - meaning that when you say `new X2()`, the result is something you can use `new` on and get an `XInterface`, which is, ofc, not the case here."
      }
    ]
  },
  {
    "number": 28191,
    "title": "Spread operator with one union-typed key gives type error?",
    "created_at": "2018-10-28T18:43:19Z",
    "closed_at": "2018-10-29T19:27:03Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/28191",
    "body": "I'm not sure if the following code should be filed as a bug, or it's just me not completely understanding the Typescript type-system.\r\n\r\nIn the following code (testing the playground V3.1), the function `fails` gives a type error, complaining that `Type 'Tag.BAR' is not assignable to type 'Tag.FOO'`.\r\n\r\nHowever, this function just returns the `x` object again, it's just that the `id` key is copied explicitly.\r\n\r\nCan someone explain why this doesn't work, and/or if this is a bug or by design?\r\n\r\n```ts\r\n// Dummy _tag_ key to avoid passing identifiers as plain numbers\r\ntype Identifier<TAG> = number & { readonly _tag_: TAG };\r\n\r\ninterface Entity<TAG> {\r\n  readonly tag: TAG;\r\n  readonly id: Identifier<TAG>;\r\n}\r\n\r\nenum Tag {\r\n  FOO = 0,\r\n  BAR = 1\r\n}\r\n\r\ninterface Foo extends Entity<Tag.FOO> {\r\n    foo: string;\r\n}\r\n\r\ninterface Bar extends Entity<Tag.BAR> {\r\n    bar: boolean;\r\n}\r\n\r\nfunction works(x: Foo | Bar): Foo | Bar {\r\n    return { ...x };\r\n}\r\n\r\nfunction fails(x: Foo | Bar): Foo | Bar {\r\n    return { ...x, id: x.id };\r\n}\r\n```\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/28191/comments",
    "author": "ziriax",
    "comments": [
      {
        "user": "weswigham",
        "created_at": "2018-10-29T18:22:04Z",
        "body": "When you say `x.id`, you get the type of the `id` field on both `Foo` and `Bar` - so `Identifier<Tag.FOO> | Identifier<Tag.BAR>`. The assignment doesn't retain a dependency relationship on `x`'s type, so what happens is in both of the union elements you spread over, you assign this combined type to both members, causing the problem."
      }
    ]
  },
  {
    "number": 26934,
    "title": "Can i declare an Object properties must contain a or b ?",
    "created_at": "2018-09-06T06:36:10Z",
    "closed_at": "2018-09-06T22:53:40Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/26934",
    "body": "when i declare an Object like this:\r\n`interface obj {\r\n a?:string,\r\n b?string\r\n}\r\n`\r\nbut i want the attribute a not to exist, the attribute b must exist.\r\n`let obj:obj={}`  It is allowed ,i want it is not allowed\r\n`let obj:obj={a:'a'}` or `let obj:obj={b:'b'}`  if i want It is allowed. what should I do?\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/26934/comments",
    "author": "Zane0816",
    "comments": [
      {
        "user": "markusjohnsson",
        "created_at": "2018-09-06T12:48:26Z",
        "body": "Yes, but not using an interface. Instead, use `type`:\r\n\r\n```ts\r\ntype obj = { a: string } | { b: string };\r\n```\r\n\r\nif you want both properties:\r\n\r\n```ts\r\ntype obj = { a: string } | { b: string } | { a: string; b: string; };\r\n```"
      }
    ]
  },
  {
    "number": 25768,
    "title": "Stringify like in \"c\" ",
    "created_at": "2018-07-18T14:12:27Z",
    "closed_at": "2018-07-19T05:56:50Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/25768",
    "body": "Hi ,\r\nHow do we convert object dot walking into string signature.\r\n``` typescript\r\nlet person = {\r\n\tcompany: {\r\n\t\tdepartment: {\r\n\t\t\tmsging: {\r\n\t\t\t\tphone: \"xyz\",\r\n\t\t\t\tfax: \"abc\"\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\tage: 34\r\n}\r\n\r\nfunction evaluateObject(val: string) {\r\n // some logic to evalute\r\n}\r\nevaluateObject(`${person.company.department.msging.phone}`);\r\n```\r\nthis will emit \r\n``` javascript\r\nevaluateObject('xyz');\r\n```\r\nbut I want to emit something like this.\r\n``` javascript\r\nevaluateObject('person.company.department.msging.phone');\r\n```\r\nIs there anyway to achieve this? Any Custom syntax like in \"C\" macros\r\n```typescript\r\nevaluateObject(`#{person.company.department.msging.phone}`);\r\n```\r\n\r\nIs it possible to achieve with any plugin kind of thing?.\r\n-thanks",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/25768/comments",
    "author": "yln99517",
    "comments": [
      {
        "user": "ghost",
        "created_at": "2018-07-18T15:07:10Z",
        "body": "I think this is possible like so:\r\n```ts\r\nfunction path<K0 extends string>(obj: Record<K0, unknown>, k0: K0): string;\r\nfunction path<K0 extends string, K1 extends string>(obj: Record<K0, Record<K1, unknown>>, k0: K0, k1: K1): string;\r\nfunction path<K0 extends string, K1 extends string, K2 extends string>(obj: Record<K0, Record<K1, Record<K2, unknown>>>, k0: K0, k1: K1, k2: K2): string;\r\nfunction path(_: any, ...keys: string[]): string {\r\n    return keys.join(\".\");\r\n}\r\n\r\nconst obj = {\r\n    a: {\r\n        b: {\r\n            c: 0,\r\n        },\r\n    },\r\n};\r\n\r\nconsole.log(path(obj, \"a\")); // \"a\"\r\nconsole.log(path(obj, \"a\", \"b\")); // \"a.b\"\r\nconsole.log(path(obj, \"a\", \"b\", \"c\")); // \"a.b.c\"\r\npath(obj, \"a\", \"b\", \"x\"); // Compile error\r\n```\r\n\r\nSee also #1579."
      },
      {
        "user": "ghost",
        "created_at": "2018-07-18T15:32:40Z",
        "body": "@sandersn Pointed out that this can be done without overloads:\r\n\r\n```ts\r\nfunction dive<T>(obj: T): Diver<T> {\r\n    return new Diver(obj, \"\");\r\n}\r\nclass Diver<T> {\r\n    constructor(readonly obj: T, readonly str: string) {}\r\n\r\n    p<K extends string, TT extends Record<K, unknown>>(this: Diver<TT>, k: K): Diver<TT[K]> {\r\n        return new Diver(this.obj[k], this.str === \"\" ? k : this.str + \".\" + k);\r\n    }\r\n}\r\n\r\nconst obj = {\r\n    a: {\r\n        b: {\r\n            c: 0,\r\n        },\r\n    },\r\n};\r\n\r\nconsole.log(dive(obj).p(\"a\").p(\"b\").p(\"c\").str);\r\n```"
      }
    ]
  },
  {
    "number": 24216,
    "title": "Strict keys in HashMap",
    "created_at": "2018-05-17T19:45:02Z",
    "closed_at": "2018-06-02T19:56:07Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/24216",
    "body": "It's very powerful feature in typescript by strict value type in HashMap declaration. However looks like the same feature is missing for key values. I tried defined as type of string or enums but getting errors.\r\n\r\n\r\n```\r\ntype Keys1 = \"key1\" | \"key2\";\r\nenum Keys2 {key1, key2}\r\nconst map1: {[key: string]: Keys1 | null} = {\r\n    \"key1\": \"key1\",\r\n    \"key2\": \"key2\",\r\n    \"key3\": \"key3\"  //That is working!!!\r\n                    // Property '\"key3\"' is incompatible with index signature.\r\n                    // Type '\"key3\"' is not assignable to type '\"key1\" | \"key2\" | null'.\r\n};\r\n\r\nconst map2: {[key: string]: Keys1 | null} = {\r\n    \"key1\": \"key1\",\r\n    \"key2\": \"key2\",\r\n    \"key3\": null //I would like to strct and get error\r\n};\r\n\r\nconst map3: {[key: Keys1]: boolean} = {  //[ts] An index signature parameter type cannot be a union type. \r\n                                        //Consider using a mapped object type instead.\r\n                                        //(parameter) key: \"key1\" | \"key2\"\r\n    \"key3\": true\r\n};\r\n\r\nconst map4: {[key: Keys2]: boolean} = {  //[ts] An index signature parameter type must be 'string' or 'number'.\r\n                                        //(parameter) key: Keys2\r\n    \"key3\": true\r\n};\r\n```",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/24216/comments",
    "author": "dgofman-equinix",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2018-05-17T19:51:22Z",
        "body": "Use mapped types:\r\n\r\n```ts\r\nconst map3: { [key in Keys1]: boolean } = {\r\n    \"key3\": true\r\n};\r\n\r\nconst map4: { [key in Keys2]?: boolean } = {  \r\n    [Keys2.key1]: true\r\n};\r\n```"
      }
    ]
  },
  {
    "number": 24092,
    "title": "input file override crazytown",
    "created_at": "2018-05-14T02:46:07Z",
    "closed_at": "2018-05-14T16:49:58Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/24092",
    "body": "I have this config:\r\n\r\n```json\r\n{\r\n  \"compilerOptions\": {\r\n    \"outDir\":\"dist\",\r\n    \"allowJs\": false,\r\n    \"pretty\": true,\r\n    \"skipLibCheck\": true,\r\n    \"declaration\": true,\r\n    \"baseUrl\": \".\",\r\n    \"target\": \"es6\",\r\n    \"module\": \"commonjs\",\r\n    \"noImplicitAny\": true,\r\n    \"removeComments\": true,\r\n    \"allowUnreachableCode\": true,\r\n    \"lib\": [\r\n      \"es2015\",\r\n      \"es2016\",\r\n      \"es2017\"\r\n    ]\r\n  },\r\n  \"compileOnSave\": false,\r\n  \"include\": [\r\n    \"src\"\r\n  ]\r\n}\r\n```\r\n\r\nI keep getting this error:\r\n\r\n> error TS5055: Cannot write file '/Users/alexamil/WebstormProjects/oresoftware/fly/dist/fly.d.ts' because it would overwrite input file.\r\n\r\n\r\nIt's driving me batty lol. `tsc` should know that the `dist` dir is the destination, so no input files should come from there, right? not only that, but the `include` is set to `src` in the config.\r\n\r\n\r\nhere are my versions:\r\n```bash\r\nnodejs version: v9.11.1\r\nnpm version: 5.6.0\r\ntypescript version: Version 2.8.3\r\n```\r\n\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/24092/comments",
    "author": "ORESoftware",
    "comments": [
      {
        "user": "ghost",
        "created_at": "2018-05-14T15:32:58Z",
        "body": "You probably imported from `dist` at some point. Include doesn't specify the files to be included (Microsoft/TypeScript-Handbook#692), it specifies the *root* files."
      }
    ]
  },
  {
    "number": 23670,
    "title": "static return might fail with switch statement",
    "created_at": "2018-04-24T22:42:15Z",
    "closed_at": "2018-04-25T18:39:50Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/23670",
    "body": "I have this:\r\n\r\n```js\r\nconst onUpdate = function (v: string, o: any) : Promise<any> {\r\n  \r\n  const finalName = String(v || '').split('.')[1]; // collection name\r\n  const _id = o && o.o2 && o.o2._id;\r\n  let key;\r\n  \r\n  switch (finalName) {\r\n    \r\n    case 'categories':      \r\n      return Category.findOne({_id}).exec().then(function (cat: any) {\r\n         // ....\r\n      });\r\n    \r\n    case 'acquisitions':\r\n        return Acquisition.findOne({_id}).exec().then(function (acq: any) {\r\n         // ...\r\n      });\r\n    \r\n    case 'functionalTeams':\r\n      return FunctionalGroup.findOne({_id}).exec().then(function (ft: any) {\r\n           // ...\r\n      });\r\n    \r\n    default:\r\n      log.error('document collection did not match a pre-defined name');\r\n      // nothing is returned here, but can TS check to see if it does/doesn't\r\n  }\r\n  \r\n};\r\n```\r\n\r\ncan TypeScript check to see if a Promise fails to be returned in the default or after the switch statement? Right now it's compiling even though a Promise is not returned in all cases.",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/23670/comments",
    "author": "ORESoftware",
    "comments": [
      {
        "user": "ghost",
        "created_at": "2018-04-24T23:26:57Z",
        "body": "You probably just need `--strictNullChecks` enabled."
      },
      {
        "user": "MartinJohns",
        "created_at": "2018-04-25T07:07:54Z",
        "body": "Or alternatively `--noImplicitReturns`. Enabling `--strictNullChecks` is often very difficult to add in old code bases, but `--noImplicitReturns` is a no-brainer."
      },
      {
        "user": "MartinJohns",
        "created_at": "2018-04-25T07:21:07Z",
        "body": "The default behaviour is to align with JavaScript. If a function returns \"nothing\", it implicitly returns `undefined`. That is what is happening here. And with `strictNullChecks` disabled, the value of `undefined` is compatible with the type `Promise<any>`, the value is compatible with **any** type.\r\n\r\n`strictNullChecks` will change the semantics of `undefined` from a mere *value* to a *type*, so the value `undefined` will be of the type `undefined`, which is not compatible with `Promise<any>` anymore. You will get an error.\r\n\r\n`noImplicitReturns` will enforce what the name implies: A method may not have an implicit return value. That means you have to explicitly write `return undefined;`."
      },
      {
        "user": "ORESoftware",
        "created_at": "2018-04-25T07:28:16Z",
        "body": "ok understood, to move this in a more productive direction, is there a way to never allow null/undefined in the place of a defined value? In Java, all those NullPointerException's are caused by allowing null to exist in far too many places.\r\n\r\nReturning null from a function/method instead of an array or Promise, or anything, it's just crazy imo.\r\n\r\n"
      },
      {
        "user": "MartinJohns",
        "created_at": "2018-04-25T09:10:26Z",
        "body": "Yes... That is pretty much what `strictNullChecks` is for. And related to that the `strictPropertyInitialization` feature (works only together with `strictNullChecks`."
      }
    ]
  },
  {
    "number": 22857,
    "title": "Union type in JSX IntrinsicElements seems like a bug",
    "created_at": "2018-03-24T14:14:24Z",
    "closed_at": "2018-03-24T15:30:53Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/22857",
    "body": "```typescript\r\ndeclare namespace JSX {\r\n  interface IntrinsicElements {\r\n    foo: { bar: boolean } | { baz: boolean };\r\n  }\r\n}\r\n\r\nconst one = <foo bar baz />; // ok\r\n```\r\n\r\nHi. Is this a bug? I was expecting this to not compile but it does. \r\n\r\nIn the IntrinsicElements interface the type for `foo` is defined as having a boolean attribute of `foo` **or** `baz` but it compiles when both are set.\r\n\r\nI'm new to typescript so apologies if the issue is just my understanding of the type system.",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/22857/comments",
    "author": "mikelnrd",
    "comments": [
      {
        "user": "MartinJohns",
        "created_at": "2018-03-24T14:57:39Z",
        "body": "Union types are **or**, but not **xor**. **or** means **any** of the types is provided. If all are provided it's fine. **xor** means **one** of the types is provided, not more. Currently it's not directly supported to have a **xor** union type beyond having a discriminated union. See also #14094."
      }
    ]
  },
  {
    "number": 22372,
    "title": "Using createVariableStatement in a compiler transformer breaks the compiler",
    "created_at": "2018-03-07T11:15:49Z",
    "closed_at": "2018-03-07T19:16:36Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/22372",
    "body": "**TypeScript Version:**  2.8.0-dev.20180307\r\n\r\n**Search Terms:** createVariableStatement const\r\n\r\n**Code (compiler)**\r\n\r\n```ts\r\n// A *self-contained* demonstration of the problem follows...\r\nimport * as ts from 'typescript';\r\n\r\nfunction transformer(program: ts.Program): ts.TransformerFactory<ts.SourceFile> {\r\n    return (context: ts.TransformationContext) => (file: ts.SourceFile) => transformFile(program, context, file);\r\n}\r\n\r\nfunction transformFile(program: ts.Program, context: ts.TransformationContext, file: ts.SourceFile): ts.SourceFile {\r\n    const transformedFile = ts.visitEachChild(file, child => visit(child, context, file), context);\r\n    return transformedFile;\r\n}\r\nfunction visit(node: ts.Node, context: ts.TransformationContext, file: ts.SourceFile): ts.Node {\r\n    if (ts.isMethodDeclaration(node)) {\r\n        const newNode = ts.createMethod(\r\n            [ts.createToken(ts.SyntaxKind.StaticKeyword)], \r\n            [], \r\n            null, \r\n            node.name, \r\n            null, \r\n            [], \r\n            node.parameters, \r\n            node.type, \r\n            ts.createBlock([ \r\n                ts.createVariableStatement(\r\n                    [ts.createToken(ts.SyntaxKind.ConstKeyword)], \r\n                    [ts.createVariableDeclaration('myConst', null, ts.createLiteral('value'))]\r\n                ),\r\n                ...(node.body ? node.body.statements : [])\r\n            ])\r\n        );\r\n        console.log(ts.createPrinter().printNode(ts.EmitHint.Unspecified, newNode, file));\r\n        return newNode;\r\n    }\r\n    return ts.visitEachChild(node, child => visit(child, context, file), context);\r\n}\r\n\r\nconst program = ts.createProgram([\r\n  '../transformer-issue-src/src/A.ts'\r\n], {\r\n    target: ts.ScriptTarget.ES5,\r\n    module: ts.ModuleKind.CommonJS,\r\n    moduleResolution: ts.ModuleResolutionKind.NodeJs,\r\n    importHelpers: true,\r\n    alwaysStrict: true,\r\n    noImplicitAny: true,\r\n    noImplicitThis: true,\r\n    removeComments: true,\r\n    sourceMap: true,\r\n    outDir: \"../transformer-issue-src/lib\",\r\n    declaration: true,\r\n    declarationDir: \"../transformer-issue-src/lib\",\r\n    lib: [\r\n      \"lib.es2017.d.ts\",\r\n    ],\r\n    experimentalDecorators: true,\r\n    noEmitOnError: true,\r\n});\r\n\r\nconst transformers = {\r\n  before: [\r\n    transformer(program),\r\n  ]\r\n}\r\nconst result = program.emit(undefined, undefined, undefined, false, transformers);\r\n```\r\n\r\n**Code (test program, ../transformer-issue-src/src/A.ts)**\r\n\r\n```ts\r\nexport class A {\r\n    static myMethod() {\r\n        return 'value';\r\n    }\r\n}\r\n```\r\n\r\n**Expected behavior:**\r\nThe .js file should be emitted.\r\nThe `console.log` statement should print the following:\r\n\r\n```ts\r\nstatic myMethod() { const myConst = \"value\"; return 'value'; }\r\n```\r\n\r\n**Actual behavior:**\r\nThe .js file is not emitted due to a compiler exception. Message and stack trace:\r\n\r\n```\r\nTypeError: Cannot read property 'transformFlags' of null\r\n    at aggregateTransformFlagsForNode (d:\\solutions\\transformer-issue-compiler\\node_modules\\typescript\\lib\\typescript.js:54626:18)\r\n    at Object.aggregateTransformFlags (d:\\solutions\\transformer-issue-compiler\\node_modules\\typescript\\lib\\typescript.js:54611:9)\r\n    at visitNode (d:\\solutions\\transformer-issue-compiler\\node_modules\\typescript\\lib\\typescript.js:53754:12)\r\n    at Object.visitEachChild (d:\\solutions\\transformer-issue-compiler\\node_modules\\typescript\\lib\\typescript.js:54053:108)\r\n    at visitVariableDeclaration (d:\\solutions\\transformer-issue-compiler\\node_modules\\typescript\\lib\\typescript.js:61625:30)\r\n    at Object.flatMap (d:\\solutions\\transformer-issue-compiler\\node_modules\\typescript\\lib\\typescript.js:2047:25)\r\n    at visitVariableDeclarationList (d:\\solutions\\transformer-issue-compiler\\node_modules\\typescript\\lib\\typescript.js:61510:39)\r\n    at visitJavaScript (d:\\solutions\\transformer-issue-compiler\\node_modules\\typescript\\lib\\typescript.js:60282:28)\r\n    at visitor (d:\\solutions\\transformer-issue-compiler\\node_modules\\typescript\\lib\\typescript.js:60243:24)\r\n    at visitNode (d:\\solutions\\transformer-issue-compiler\\node_modules\\typescript\\lib\\typescript.js:53755:23)\r\n```\r\n\r\nEven if I remove the `ts.createToken(ts.SyntaxKind.ConstKeyword)` token, this exception is still thrown.\r\n\r\nAlso, the `console.log` statement prints the following (the var keyword is left there):\r\n\r\n```ts\r\nstatic myMethod() { const var myConst = \"value\"; return 'value'; }\r\n```",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/22372/comments",
    "author": "pedro-pedrosa",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2018-03-07T17:43:02Z",
        "body": "80% sure the problem is that you're passing `null` instead of `undefined` for some of those parameters. The TS API basically never uses `null` and will behave badly if given it because it's only ever checking for ` === undefined`"
      },
      {
        "user": "pedro-pedrosa",
        "created_at": "2018-03-07T18:33:44Z",
        "body": "Replacing the `null` in `createVariableDeclaration` with `undefined` made the exception go away (wasn't needed on createMethod), however it still prints `const var`."
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2018-03-07T18:56:58Z",
        "body": "Pass `NodeFlags.Const` to `createVariableDeclarationList` rather than trying to push in a `const` keyword in the array.\r\n\r\nThere are lots of examples in the TypeScript codebase that show calling this function correctly."
      }
    ]
  },
  {
    "number": 21877,
    "title": "Salsa Intellisense for parameters of closures with javascript",
    "created_at": "2018-02-12T07:14:55Z",
    "closed_at": "2018-02-13T07:53:23Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/21877",
    "body": "**Version:**  VS2017\r\n\r\nMy TypeScript project produces a `.d.ts` file. Which is perfect for TS projects:\r\n\r\n```ts\r\ndeclare function myGlobal(param: string): string;\r\ndeclare module myHmi {\r\n    class foo {\r\n        static myStatic(bar: string): string;\r\n    }\r\n}\r\n```\r\n\r\nBut other teams are on JS and wants to use our nice typings. They have the .d.ts file inside the project. VS2017 detects it in the new JS Language Service (Salsa).\r\n\r\n```js\r\nvar myHmi;\r\n(function (myHmi) {\r\n    // Here VS2017 knows myGlobal()\r\n    // Here VS2017 detected myHmi as {}. So it has no knowledge of myHmi.foo.myStatic()\r\n\r\n    main code...\r\n})(myHmi || (myHmi = {}));\r\n\r\n// Here VS2017 knows myGlobal()\r\n// Here VS2017 knows myHmi.foo.myStatic()\r\n\r\n```\r\nCan we use a hint (jsdoc magic?) to tell VS that the inner myHmi is an extension of the outer myHmi?\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/21877/comments",
    "author": "HolgerJeromin",
    "comments": [
      {
        "user": "ghost",
        "created_at": "2018-02-12T15:23:13Z",
        "body": "The JS developers should *also* be able to use the `.d.ts` file instead of the compiled `.js`. Just give it the same name and put it next to the `.js` file. So I don't see why it would be important to have accurate typings inside of the compiled code?"
      },
      {
        "user": "HolgerJeromin",
        "created_at": "2018-02-12T17:05:55Z",
        "body": "The JS developers are including their code into `myHmi` TS module infrastructure (as an extension). \r\nThey do not code in compiled code but their JS code looks the same as TS transpiled output."
      },
      {
        "user": "ghost",
        "created_at": "2018-02-12T17:15:34Z",
        "body": "So your JS developers are manually writing code that looks like TS transpiled output?\r\nIf you omit `var myHmi` it will work...\r\n```js\r\n(function (myHmi) {\r\n    myHmi.foo; // works\r\n\r\n// @ts-ignore (cannot assign to myHmi because it is not a variable)\r\n})(myHmi || (myHmi = {}));\r\n```"
      },
      {
        "user": "HolgerJeromin",
        "created_at": "2018-02-13T07:53:23Z",
        "body": "> So your JS developers are manually writing code that looks like TS transpiled output?\r\n\r\nYes. We want to elevate them eventually to Typescript. \r\n\r\n`})(myHmi || (myHmi = {}));`\r\n\r\nThis does not work in my complex code in VS 15.5.4, JS language service 2.0, TS Tools 15.5.11025.1\r\nI need to have:\r\n`})(myHmi);`\r\n\r\nBut this is working pretty good. \r\nThanks for your help."
      }
    ]
  },
  {
    "number": 21723,
    "title": "Export `with` as a property within declaration file",
    "created_at": "2018-02-07T16:28:41Z",
    "closed_at": "2018-02-08T16:39:59Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/21723",
    "body": "I got a CommonJS module that exports a function by default. The function has a property named `with`, which is a reserved word in JavaScript. JavaScript allows this kind of usage (`with` as a property name), but unfortunately, I can't get it working in TS declaration file.\r\n\r\n## Code\r\n**a.js**\r\n```javascript\r\nmodule.exports = () => 1;\r\nmodule.exports.with = (n: number) => 1 + n;\r\n```\r\n\r\n**a.d.ts**\r\n```ts\r\nexport = GetNumber;\r\n\r\ndeclare function GetNumber(): number;\r\n\r\ndeclare namespace GetNumber {\r\n\texport function with(n: number): number;\r\n}\r\n```\r\n\r\n**b.ts**\r\n```ts\r\nimport * as getNumber from './a';\r\n\r\nconsole.log(getNumber()); // => 1\r\nconsole.log(getNumber.with(2)); // => 3\r\n```\r\n\r\n## Expected behavior:\r\n\r\nDeclaration should be valid for both `getNumber` and `getNumber.with`.\r\n\r\n## Actual behavior:\r\n\r\nGetting an error in compilation:\r\n```\r\n$ tsc a.d.ts\r\na.d.ts(6,19): error TS1003: Identifier expected.\r\na.d.ts(6,25): error TS1005: ')' expected.\r\na.d.ts(6,33): error TS1005: ';' expected.\r\na.d.ts(6,34): error TS1128: Declaration or statement expected.\r\n```",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/21723/comments",
    "author": "yardnsm",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2018-02-07T17:44:56Z",
        "body": "use `export { ... as with }` instead:\r\n\r\n```ts\r\nexport = GetNumber;\r\n\r\ndeclare function GetNumber(): number;\r\n\r\ndeclare namespace GetNumber {\r\n    function _with(n: number): number;\r\n    export { _with as with}\r\n}\r\n```"
      }
    ]
  },
  {
    "number": 21421,
    "title": "Mapped type should take a function form as well",
    "created_at": "2018-01-26T06:02:30Z",
    "closed_at": "2018-01-30T04:32:28Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/21421",
    "body": "According to #12114 mapped types currently support following forms:\r\n\r\n```ts\r\n{ [ P in K ] : T }\r\n{ [ P in K ] ? : T }\r\n{ readonly [ P in K ] : T }\r\n{ readonly [ P in K ] ? : T }\r\n```\r\n\r\nI think it shall also at least support a function form:\r\n\r\n```ts\r\n{ ([ P in K ]) : T }\r\n{ ([ P in K ]) ? : T }\r\n{ ([ P in K])(entities: P[], someBoolean: boolean) ? : T }\r\n```\r\n\r\nCurrently Im trying to implement a `Functionize<T>` interface which forces implementors to implement any property of the T, but make it a function with maybe additional arguments. Example:\r\n\r\n```ts\r\ninterface User {\r\n     name: string;\r\n     age: number\r\n}\r\n```\r\n\r\nI want to do Functionize<User> which I want to give me:\r\n\r\n```ts\r\n{\r\n       name(names: string[]): string;\r\n       age(ages: number[]): number;\r\n}\r\n```\r\n\r\nAnd I'm asking about following method signature:\r\n\r\n```ts\r\ntype Functionize<T> = {\r\n   [P in keyof T](values: T[])?: T[P];\r\n};\r\n```",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/21421/comments",
    "author": "pleerock",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2018-01-26T06:04:57Z",
        "body": "Someone suggested to do:\r\n\r\n```ts\r\ntype Functionize <T> = {\r\n   [P in keyof T]: () => T[P];\r\n};\r\n```\r\n\r\nhowever it does not work with extra function parameters, e.g.\r\n\r\n```ts\r\ntype Functionize <T> = {\r\n   [P in keyof T]: (values: T[]) => T[P];\r\n};\r\n```\r\n\r\ncompiler have no errors when values argument is not defined in the implementor of Functionize interface.\r\n\r\nEDIT: it appears to work partially, if I define lets say `name(names: boolean[])` instead of `name(names: string[])` it will give me a compiler error, however if I do simply `name()` its not telling me that names is required parameter."
      },
      {
        "user": "jack-williams",
        "created_at": "2018-01-26T14:14:10Z",
        "body": "> however if I do simply name() its not telling me that names is required parameter.\r\n\r\nI believe the issue is that a signature that accepts fewer inputs is assignable to one that accepts more (provided they agree on matching parameters and output). So the following is acceptable:\r\n\r\n```typescript\r\nlet f: () => number = () => 42;\r\nlet g: (x: number[]) => number = f;\r\n```\r\n\r\nIn your specific example, the type `{ name: () => string }` is assignable to the type `{ name: (names: string[]) => string }`.\r\n\r\nYou get a compiler error when using `boolean[]` because they disagree on a shared parameter.\r\n\r\nAlso, from your requirements I think the definition of `Functionize` should be: \r\n```typescript\r\ntype Functionize <T> = {\r\n   [P in keyof T]: (values: (T[P])[]) => T[P]; // or [P in keyof T]?: (values: (T[P])[]) => T[P] if you want optional properties \r\n};\r\n```\r\n(added a lookup on the type of `values`."
      },
      {
        "user": "pleerock",
        "created_at": "2018-01-29T09:16:02Z",
        "body": "> Also, from your requirements I think the definition of Functionize should be:\r\n\r\ncorrect, sorry Im using a bit different code, I just wanted to provide an example and make this mistake.\r\n\r\n> In your specific example, the type { name: () => string } is assignable to the type { name: (names: string[]) => string }.\r\n\r\ncorrect, that's exactly issue I have. Is it tracked, or is it by design? "
      },
      {
        "user": "jack-williams",
        "created_at": "2018-01-29T10:21:52Z",
        "body": "I believe it's by design. From the spec:\r\n\r\n> M has a rest parameter or the number of non-optional parameters in N is less than or equal to the total number of parameters in M.\r\n\r\nwhen defining whether call-signature N is a subtype of call-signature M.\r\n\r\nIntuitively if a user writes a function of type `() => number`, then it can always ignore extra arguments given and still return a number. So it also works when used as the type `(x: boolean) => number` or `(names: number[]) => number`.\r\n\r\nThe only way I could see this being something you *don't* want is if the output of the function *must* come from the input of the function. So in the type:\r\n```\r\n{\r\n       name(names: string[]): string;\r\n       age(ages: number[]): number;\r\n}\r\n```\r\n\r\nthe output of `name` always comes from an element in `names`, and the output of `age` always comes from an element in `ages`. If this is something you want, then I think the most likely solution will be parametricity and generics. Instead, would the follow types for you work?\r\n```\r\n{\r\n       name<X>(names: X[]): X;\r\n       age<X>(ages: X[]): X;\r\n}\r\n```\r\nThe rules about adding extra inputs to a function signature still apply, but in this case it's impossible to create something of type `X` out of nothing (unless you cheat and use `any`). An implementor of the function will not be able to write a function with the type: `<X>() => X`; the only way to return an `X` is to use one that is given to you from the input."
      },
      {
        "user": "mhegazy",
        "created_at": "2018-01-30T00:33:10Z",
        "body": "here is the syntax for definitnon a mapped type with function typed properties:\r\n\r\n```ts\r\ntype Funcs<T> = {[P in keyof T]?: (entities: P[], someBoolean: boolean) => T };\r\n```"
      }
    ]
  },
  {
    "number": 21096,
    "title": "Issue with generic extension of object with index signature that returns functions",
    "created_at": "2018-01-09T17:19:58Z",
    "closed_at": "2018-01-09T21:03:58Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/21096",
    "body": "**TypeScript Version:**  2.7.0-dev.20180109\r\n\r\nHi. I ran into this issue trying to assign a class to a generic type that takes in T which extends an index signature type [s:string]:Function. The same issue happens with index sig [s:string]:new(..._)=>any\r\n\r\n**Code**\r\n\r\n```ts\r\nclass C {\r\n}\r\n\r\ntype Test<T extends {[s:string]:Function}> = {};\r\n\r\nconst t:Test<{c:C}> = { //error\r\n\tc:C,\r\n};\r\n\r\ntype Test2 = {\r\n\t[s:string]:Function\r\n}\r\n\r\nconst f:Test2 = {c:C}; //fine\r\n```\r\n\r\n**Expected behavior:**\r\nI should be able to assign {c:C} to the generic type\r\n\r\n**Actual behavior:**\r\n\r\nerror: \r\n\r\nError:(6, 14) TS2344: Type '{ c: C; }' does not satisfy the constraint '{ [s: string]: Function; }'.\r\n  Property 'c' is incompatible with index signature.\r\n    Type 'C' is not assignable to type 'Function'.\r\n      Property 'apply' is missing in type 'C'.\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/21096/comments",
    "author": "dontsave",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2018-01-09T18:26:10Z",
        "body": "i think you meant `Test<{c:typeof C}>` there. `C` refers to the instance type of `C`, `typeof C` refers to the type of the constructor function for `C`."
      }
    ]
  },
  {
    "number": 20747,
    "title": "TS doesn't merge members for Window interface",
    "created_at": "2017-12-18T08:26:09Z",
    "closed_at": "2018-01-02T18:40:08Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/20747",
    "body": "I've tried to add a new property `counter` to the `Window` interface like this in the `main.ts` file:\r\n\r\n```\r\n// main.ts\r\n\r\ninterface Window {\r\n    counter;\r\n}\r\n```\r\n\r\n**Expected behavior:**\r\n\r\nI expected the property to be available on the `window` object:\r\n\r\n```\r\nwindow.counter;\r\n```\r\n\r\n**Actual behavior:**\r\n\r\nHowever, I got the error:\r\n\r\n```\r\nError:(19, 16) TS2339: Property 'counter' does not exist on type 'Window'.\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/20747/comments",
    "author": "maxkoretskyi",
    "comments": [
      {
        "user": "yortus",
        "created_at": "2017-12-18T14:39:51Z",
        "body": "Try this:\r\n\r\n```ts\r\n// main.ts\r\n\r\ndeclare global {\r\n    interface Window {\r\n        counter;\r\n    }\r\n}\r\n```\r\n"
      },
      {
        "user": "maxkoretskyi",
        "created_at": "2017-12-18T16:19:44Z",
        "body": "@yortus, thanks a lot, works this way. Can you elaborate a bit, why is `declare global` required?"
      },
      {
        "user": "kitsonk",
        "created_at": "2017-12-18T16:39:50Z",
        "body": "Because TypeScript is assuming you are in a module, likely because of the way you have your `tsconfig.json` configured (or the way you are compiling via `tsc`).  It therefore interfaces by default are scoped locally, instead of globally.  `declare global` indicates you are a module attempting to modify the global interfaces."
      }
    ]
  },
  {
    "number": 20668,
    "title": "tsc copy filed not included it's parent dir after compiled with setting other dir exclued in tsconfig.json",
    "created_at": "2017-12-13T08:35:54Z",
    "closed_at": "2017-12-14T13:11:02Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/20668",
    "body": "`tsc 2.6.2`. there is source dir tree:\r\n\r\n```\r\nsrc/\r\n\u251c\u2500\u2500 client\r\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 client.tsx\r\n\u251c\u2500\u2500 server\r\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 actions\r\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 app.ts\r\n\u251c\u2500\u2500 shared\r\n```\r\n\r\nwhere `tsconfig.json` settings:\r\n```json\r\n{\r\n...,\r\n\"outDir\": \"dist\",\r\n\"exclude\": [\r\n    \"./src/shared/**/*\",\r\n    \"./src/client/**/*\",\r\n    \"./src/server/*.tsx\",\r\n    \"./src/server/**/*.tsx\",\r\n],\r\n\"include\": [\r\n    \"./src/**/*\"\r\n  ]\r\n}\r\n```\r\n\r\nexec `tsc -p tsconfig.json`, expected `dist dir tree`:\r\n```\r\nsrc/\r\n\u251c\u2500\u2500 server\r\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 actions\r\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 app.ts\r\n```\r\n\r\nin fact\uff0cit output:\r\n```\r\ndist\r\n\u251c\u2500\u2500 app.js\r\n\u251c\u2500\u2500 app.js.map\r\n\u251c\u2500\u2500 actions\r\n```\r\n\r\nbut,  this's `tsconfig.json` is okay:\r\n```json \r\n{\r\n...,\r\n\"outDir\": \"dist\",\r\n\"exclude\": [\r\n    \"./src/shared/**/*\",\r\n],\r\n\"include\": [\r\n    \"./src/**/*\"\r\n  ]\r\n}\r\n```\r\n\r\nthe output `dist dir  tree`:\r\n```\r\ndist\r\n\u251c\u2500\u2500 client\r\n\u2514\u2500\u2500 server\r\n```\r\n\r\nso, i am confused. that is a bug ?\ud83d\ude37\ud83d\ude37\ud83d\ude37\r\n\r\nThanks.",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/20668/comments",
    "author": "Phinome",
    "comments": [
      {
        "user": "ghost",
        "created_at": "2017-12-13T15:18:22Z",
        "body": "Seems like a duplicate of #16563.\r\nNormally we will find the common root directory of all the files that were included -- so if you only include files in `src/server` and compile to `dist`, we'll compile from `src/server` to `dist` and not add a `server` directory.\r\nAs mentioned in that issue, you can override this behavior by setting an explicit `\"rootDir\": \"src\"` in your `\"compilerOptions\"` in `tsconfig.json`."
      }
    ]
  },
  {
    "number": 20280,
    "title": "Wrong type inferred for nested union",
    "created_at": "2017-11-27T18:11:05Z",
    "closed_at": "2018-10-05T19:06:52Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/20280",
    "body": "**TypeScript Version:**  2.7.0-dev.20171126\r\n\r\nContext: a method for ember.js which extracts the value from some path, e.g.\r\n```ts\r\nget({ foo: { bar: { baz: 'hello' }}}, 'foo', 'bar', 'baz') // returns \"hello\"\r\n```\r\n\r\nEach value in the path might be some plain object `T` or a `Wrapped<T>` (in which case we return the underlying `T`)\r\n\r\n**Code**\r\n\r\nTypescript can infer the returned type using a union:\r\n\r\n```ts\r\n// working example\r\ninterface Wrapped<T> { value: T }\r\n\r\ntype Props1<T> = {\r\n    [K in keyof T]: Wrapped<T[K]> | T[K];\r\n}\r\n\r\ndeclare function get1<T, K1 extends keyof T>(obj: Props1<T>, k1: K1): T[K1];\r\n\r\ndeclare const obj1: { a: string };\r\nconst v1: string = get1(obj1, 'a'); // works\r\n\r\ndeclare const obj2: { a: Wrapped<string> };\r\nconst v2: string = get1(obj2, 'a'); // works\r\n```\r\n\r\nHowever, it no longer works when the union types are nested:\r\n\r\n```ts\r\n// non-working example\r\ntype Props2<T> = {\r\n    [K in keyof T]: Wrapped<Props1<T[K]>> | Props1<T[K]>\r\n};\r\n\r\ndeclare function get2<T, K1 extends keyof T, K2 extends keyof T[K1]>(obj: Props2<T>, k1: K1, k2: K2): T[K1][K2];\r\n\r\ndeclare const obj3: { a: { b: string } };\r\nconst v3: string = get2(obj3, 'a', 'b'); // works\r\n\r\ndeclare const obj4: { a: Wrapped<{ b: Wrapped<string> }> };\r\nconst v4: string = get2(obj4, 'a', 'b'); // TS2345:Argument of type '\"b\"' is not assignable to parameter of type 'never'.\r\n```\r\n\r\nIf I eliminate the _right side_ of the union from `Props2`, then the `obj4` example works\r\n```ts\r\ntype Props2<T> = {\r\n    [K in keyof T]: Wrapped<Props1<T[K]>> //| Props1<T[K]>\r\n};\r\n```\r\nThe `obj4` example should pick the left side of the union to begin with",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/20280/comments",
    "author": "dwickern",
    "comments": [
      {
        "user": "chriskrycho",
        "created_at": "2017-11-27T19:01:09Z",
        "body": "To add a bit, the motivation is providing a type-safe wrapper around `Ember.get(someObj, 'a.b')`. We want to be able to do a `safeGet(someObj, 'a', 'b')` which simply dispatches internally to the relevant path, but which does type-checking on the supplied keys \u2013 for an API that's *slightly* less ergonomic than the built-in Ember API, but which is much nicer than doing it the way we are presently.\r\n\r\n```ts\r\n// current way to do it to get type inference\r\nconst a = get(someObj, 'a');\r\nconst b = get(a, 'b');\r\n\r\n// desired API\r\nconst b = safeGet(someObj, 'a', 'b');\r\n```\r\n"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2018-08-07T22:03:42Z",
        "body": "@dwickern @chriskrycho I wrote a version using conditional types that works:\r\n```ts\r\ntype Unwrap<T> = T extends Wrapped<infer U> ? U : T;\r\n\r\n// working example\r\ninterface Wrapped<T> {\r\n  value: T\r\n}\r\n\r\ntype Props1<T> = {\r\n    [K in keyof T]: T[K];\r\n}\r\n\r\ndeclare function get1<T, K1 extends keyof T>(obj: Props1<T>, k1: K1): Unwrap<T[K1]>;\r\n\r\ndeclare const obj1: { a: string };\r\nconst v1: string = get1(obj1, 'a'); // works\r\n\r\ndeclare const obj2: { a: Wrapped<string> };\r\nconst v2: string = get1(obj2, 'a'); // works\r\n\r\ntype Props2<T> = {\r\n    [K in keyof T]: Unwrap<Props1<T[K]>>\r\n};\r\n\r\ndeclare function get2<T, K1 extends keyof T, K2 extends keyof Unwrap<T[K1]>>(obj: Props2<T>, k1: K1, k2: K2): Unwrap<Unwrap<T[K1]>[K2]>;\r\n\r\ndeclare const obj3: { a: { b: string } };\r\nconst v3: string = get2(obj3, 'a', 'b'); // works\r\n\r\ndeclare const obj4: { a: Wrapped<{ b: Wrapped<string> }> };\r\nconst v4: string = get2(obj4, 'a', 'b'); // now works\r\n```\r\nI don't think this is solvable otherwise because we don't preferentially go down one path or the other when inferring a key type for the union."
      }
    ]
  },
  {
    "number": 19529,
    "title": "Can TypeScript refer to an instance type over a namespace type?",
    "created_at": "2017-10-27T13:19:56Z",
    "closed_at": "2017-10-27T14:41:46Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/19529",
    "body": "I have a library whose `.d.ts` file defined something like:\r\n\r\n```\r\ndeclare class Logger extends EventEmitter {\r\n    constructor();\r\n    info(message: string);\r\n    error(message: string);\r\n}\r\n\r\ndeclare namespace Logger {\r\n    const INFO: number;\r\n    const ERROR: number;\r\n}\r\n\r\nexport = Logger;\r\n```\r\n\r\nI'm accessing it with `require()` and loading it in at runtime:\r\n\r\n```\r\nimport LoggerType = require(\"mylogger\");\r\n\r\n...\r\n\r\nlet logger: typeof LoggerType;\r\ntry {\r\n    logger = require(\"mylogger\").createLogger(...);\r\n}\r\ncatch (err) {\r\n    ...\r\n}\r\n\r\nif (logger) {\r\n    logger.info(\"hello world\");\r\n}\r\n```\r\n\r\nBut this doesn't work because TypeScript doesn't see `logger` as an instance of `Logger` but as the namespace `Logger`.  Can it instead refer to the instance of `Logger` so `logger.info()` will not be a type violation?",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/19529/comments",
    "author": "jez9999",
    "comments": [
      {
        "user": "ghost",
        "created_at": "2017-10-27T14:27:59Z",
        "body": "`let logger: LoggerType;`\r\n`typeof LoggerType` gives you the type of the module's export, which is a *class*. `LoggerType` gives you the type exported by the module, which is the type of *instances* of `Logger`."
      }
    ]
  },
  {
    "number": 19382,
    "title": "Referenced type variable incorrectly inferred as \"{}\" in function calls",
    "created_at": "2017-10-20T19:39:19Z",
    "closed_at": "2017-11-07T16:55:28Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/19382",
    "body": "**TypeScript Version:**  2.6.0-dev.201xxxxx\r\n\r\n**Code**\r\n\r\n```ts\r\n// Fails:  error TS2339: Property 'a' does not exist on type '{}'.\r\ninfer({ thing: { a: 10 } }).a; \r\n\r\n// With explicit type parameters, it works\r\ninfer<{a:number}, Holder<{a: number}>>({ thing: { a: 10 } }).a; \r\n\r\ninterface Holder<T> {\r\n\tthing: T;\r\n}\r\nfunction infer<T, H extends Holder<T>>(holder: H): T {\r\n\treturn holder.thing;\r\n}\r\n```\r\n\r\n**Expected behavior:**\r\n\r\nThe type parameter `T` should be inferred to be the type of `thing` in the instance of `Holder` passed to the function `infer()`.\r\n\r\nPerhaps there is another way to get this type of inference to work? I'm building a builder-pattern class and really need this to correctly return the right types.\r\n\r\n**Actual behavior:**\r\n\r\nThe type parameter, `T`, is inferred to be `{}` when calling `infer()`\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/19382/comments",
    "author": "Yona-Appletree",
    "comments": [
      {
        "user": "ghost",
        "created_at": "2017-10-20T20:11:44Z",
        "body": "You don't actually need `H` here.\r\n```ts\r\nfunction infer<T>(holder: Holder<T>): T {\r\n\treturn holder.thing;\r\n}\r\n```"
      },
      {
        "user": "Yona-Appletree",
        "created_at": "2017-10-20T20:17:49Z",
        "body": "Fair, though in my actual code I do need it. Slightly contrived, but closer to my actual use case:\r\n\r\n```ts\r\nconst result = infer({ thing: { a: 10 } });\r\nresult.holder.thing += result.value.thing;\r\n\r\ninterface Holder<T> {\r\n\tthing: T;\r\n}\r\nfunction infer<T, H extends Holder<T>>(holder: H): { holder: H, value: T} {\r\n\treturn { holder, value: holder.thing };\r\n}\r\n```\r\n\r\n"
      },
      {
        "user": "ghost",
        "created_at": "2017-10-20T20:41:27Z",
        "body": "How about `function infer<T, H extends Holder<T>>(holder: H & Holder<T>): { holder: H, value: T} {`?"
      },
      {
        "user": "ghost",
        "created_at": "2017-10-20T21:02:46Z",
        "body": "@sandersn Could we infer a more specific `T` in the original example? It seems silly to add `& Holder<T>` when `H` already extends that."
      },
      {
        "user": "gcanti",
        "created_at": "2017-10-21T03:07:17Z",
        "body": "Another option\r\n\r\n```ts\r\nfunction infer<H extends Holder<any>>(holder: H): { holder: H; value: H['thing'] } {\r\n  return { holder, value: holder.thing }\r\n}\r\n```"
      },
      {
        "user": "mhegazy",
        "created_at": "2017-10-23T20:23:11Z",
        "body": "you can define your function as: \r\n```ts\r\nfunction infer<T, H extends Holder<T>>(holder: Holder<T> & H): T \r\n```"
      },
      {
        "user": "ghost",
        "created_at": "2017-11-07T15:50:09Z",
        "body": "@sandersn Could we infer a more specific `T` in the original example? It seems silly to add `& Holder<T>` when `H` already extends that."
      },
      {
        "user": "mhegazy",
        "created_at": "2017-11-07T16:55:28Z",
        "body": "constraints are not inference positions.. they are merely for checking constraints after an inference has occurred. \r\n\r\nNow, the general question is i want to capture a container type \"and\" the type it contains.. this is doable through one of two ways.. either, you infer the container type, and you access the element type using indexed access type, e.g.:\r\n```ts\r\nfunction infer<H extends Holder<any>>(holder: H): H['thing'];\r\n```\r\nor through making two inferences using intersection types, e.g.:\r\n\r\n```ts\r\nfunction infer<T, H extends Holder<T>>(holder: Holder<T> & H): T;\r\n```"
      }
    ]
  },
  {
    "number": 19186,
    "title": "TS2339: Property 'tooltip' does not exist on type '{ label: string; } | { label: string; tooltip: string; }'.",
    "created_at": "2017-10-14T19:27:31Z",
    "closed_at": "2017-10-30T18:31:36Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/19186",
    "body": "**TypeScript Version:**  typescript@2.6.0-dev.20171014\r\n\r\n**Code**\r\n\r\n```ts\r\nconst cells = [\r\n  { label: '1' },\r\n  { label: '2', tooltip: '2' },\r\n  { label: '3', tooltip: '3' },\r\n  { label: '4' },\r\n  { label: '5' },\r\n  { label: '6' },\r\n]\r\nfor (const cell of cells) {\r\n  if (cell.tooltip) console.log(cell.tooltip)\r\n}\r\n```\r\n\r\n**Expected behavior:**\r\nThat this compiles without error; the error message seems to indicate TS sees a call to cell.tooltip as valid but then forbids it in the second part of the error message.\r\n\r\n**Actual behavior:**\r\n```\r\ntt.ts(10,12): error TS2339: Property 'tooltip' does not exist on type '{ label: string; } | { label: string; tooltip: string; }'.\r\n  Property 'tooltip' does not exist on type '{ label: string; }'.\r\ntt.ts(10,38): error TS2339: Property 'tooltip' does not exist on type '{ label: string; } | { label: string; tooltip: string; }'.\r\n  Property 'tooltip' does not exist on type '{ label: string; }'.\r\n```",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/19186/comments",
    "author": "retorquere",
    "comments": [
      {
        "user": "DanielRosenwasser",
        "created_at": "2017-10-14T21:20:28Z",
        "body": "Looks like a duplicate of #1260. You can get around this with a user-defined type guard or a type-assertion."
      },
      {
        "user": "retorquere",
        "created_at": "2017-10-14T21:53:16Z",
        "body": "I eyed that issue but couldn't make out whether it was the same problem; If it's a dup feel free to close. The suggestions in #1260 do allow compilation, but is this issue planned for a fix in a 2.x release? #1260 has been open for a while."
      },
      {
        "user": "ajafff",
        "created_at": "2017-10-14T22:22:10Z",
        "body": "The easy fix for your problem is a type annotation:\r\n```ts\r\nconst cells: {label: string, tooltip?: string} = [\r\n  { label: '1' },\r\n  { label: '2', tooltip: '2' },\r\n  { label: '3', tooltip: '3' },\r\n  { label: '4' },\r\n  { label: '5' },\r\n  { label: '6' },\r\n]\r\n```"
      }
    ]
  },
  {
    "number": 19017,
    "title": "Type inference by property comparison",
    "created_at": "2017-10-08T12:59:55Z",
    "closed_at": "2017-10-08T16:00:32Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/19017",
    "body": "**TypeScript Version:**  2.5.3\r\n\r\n**Code**\r\n\r\n```ts\r\ninterface Symbol\r\n{\r\n    kind: \"namespace\"|\"class\"|\"interface\"|\"enum\";\r\n    basename: string;\r\n}\r\n\r\ninterface SymbolClass extends Symbol\r\n{\r\n    kind: \"class\";\r\n    extends: string;\r\n}\r\n\r\nfunction (symbol: Symbol)\r\n{\r\n    if (symbol.kind === \"class\")\r\n    {\r\n        //infer symbol as SymbolClass, is it possible?\r\n        console.log(symbol.extends);\r\n    }\r\n}\r\n```\r\n\r\n**Expected behavior:**\r\nNo error\r\n\r\n**Actual behavior:**\r\nProperty 'extends' does not exist on type 'Symbol'.",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/19017/comments",
    "author": "lmcarreiro",
    "comments": [
      {
        "user": "j-oliveras",
        "created_at": "2017-10-08T13:57:12Z",
        "body": "Something like:\r\n```ts\r\ninterface SymbolBase {\r\n    basename: string;\r\n}\r\n\r\ninterface SymbolClass extends SymbolBase {\r\n    kind: \"class\";\r\n    extends: string;\r\n}\r\n\r\ninterface SymbolNamespace extends SymbolBase {\r\n    kind: \"namespace\";\r\n}\r\n\r\ninterface SymbolInterface extends SymbolBase {\r\n    kind: \"interface\";\r\n}\r\n\r\ninterface SymbolEnum extends SymbolBase {\r\n    kind: \"enum\";\r\n}\r\n\r\ntype SymbolType = SymbolClass | SymbolNamespace | SymbolInterface | SymbolEnum;\r\n\r\nfunction func(sym: SymbolType) {\r\n    if (sym.kind === \"class\") {\r\n        console.log(sym.extends);\r\n    }\r\n}\r\n```"
      }
    ]
  },
  {
    "number": 18973,
    "title": "compiler hide errors in tsx files, if there is \"import\"",
    "created_at": "2017-10-05T20:02:24Z",
    "closed_at": "2017-10-06T08:32:57Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/18973",
    "body": "**TypeScript Version:**  2.5.3\r\n\r\n**Code**\r\n\r\n1.tsx\r\n```ts\r\nimport Test from \"./2\"\r\n\r\ndeclare namespace JSX {\r\n  interface IntrinsicElements {\r\n    foo: { requiredProp: string; optionalProp?: number }\r\n  }\r\n}\r\nclass React {  static Render(a?: any, b?: any, c?: any) {} }\r\n\r\nfunction xxxxx() {\r\n  <foo />;\r\n}\r\n```\r\n2.ts\r\n```ts\r\nexport default class Test {}\r\n```\r\ncommand line\r\n``` tsc 1.tsx --jsx react```\r\n\r\n**Expected behavior:**\r\n```error TS2322: Type '{}' is not assignable to type '{ requiredProp: string; optionalProp?: number; }'.\r\n  Property 'requiredProp' is missing in type '{}'\r\n```\r\n\r\n**Actual behavior:**\r\ncompilation is success\r\n\r\n**Note:**  \r\nif I comment line 'import Test from \"./2\"', I get error as expected.",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/18973/comments",
    "author": "jack128",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2017-10-05T20:18:49Z",
        "body": "once a file has a top-level `import` or `export` it becomes a module. modules have their own scope. declarations within this module do not merge with declarations in the global scope.\r\n\r\nUse `declare global` instead:\r\n\r\n```ts\r\ndeclare global {\r\n  namespace JSX {\r\n    interface IntrinsicElements {\r\n      foo: { requiredProp: string; optionalProp?: number }\r\n    }\r\n  }\r\n}\r\n```"
      }
    ]
  },
  {
    "number": 18761,
    "title": "Cannot find types in sub-project",
    "created_at": "2017-09-26T07:23:08Z",
    "closed_at": "2017-09-27T03:23:02Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/18761",
    "body": "**TypeScript Version:**  2.5.2\r\n\r\n**Code**\r\n```js\r\n// [1]\r\n// tsconfig.json\r\n{\r\n    \"compilerOptions\": {\r\n      \"allowJs\": true,\r\n      \"sourceMap\": true,\r\n      \"declaration\": false,\r\n      \"skipLibCheck\": true,\r\n      \"noImplicitAny\": false,\r\n      \"strictNullChecks\": false,\r\n      \"module\": \"es2015\",\r\n      \"moduleResolution\": \"node\",\r\n      \"target\": \"es5\",\r\n      \"typeRoots\": [\r\n        \"node_modules/@types\"\r\n      ],\r\n      \"lib\": [\r\n        \"dom\",\r\n        \"es5\",\r\n        \"scripthost\",\r\n        \"es2015\"\r\n      ]\r\n    },\r\n    \"include\": [\r\n      \"types/**/*.d.ts\",\r\n      \"src/**/*.ts\"\r\n    ],\r\n    \"exclude\": [\r\n      \"node_modules\"\r\n    ]\r\n  }\r\n```\r\n\r\n```ts\r\n// git-submodule/src/index.ts\r\nDate.prototype.format = function () {\r\n    return 90; // Just for demo\r\n};\r\nconst date = new Date();\r\nconst format = date.format();\r\nexport default format;\r\n\r\n// git-submodule/types/custom.d.ts\r\ninterface Date {\r\n    format(): number;\r\n}\r\n\r\n// git-submodule/tsconfig.json // see above [1]\r\n\r\n// src/index.ts\r\nimport Sub from '../git-submodule/src/index';\r\n\r\n// src/tsconfig.json // see above [1]\r\n```\r\n\r\nthen, run `tsc` in root directory.\r\n\r\n**Expected behavior:**\r\nNo errors.\r\n\r\n**Actual behavior:**\r\n```\r\n// errors\r\ngit-submodule/src/index.ts(1,16): error TS2339: Property 'format' does not exist on type 'Date'.\r\ngit-submodule/src/index.ts(6,21): error TS2339: Property 'format' does not exist on type 'Date'.\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/18761/comments",
    "author": "Aqours",
    "comments": [
      {
        "user": "ghost",
        "created_at": "2017-09-26T14:38:43Z",
        "body": "TypeScript won't look at the `tsconfig.json` for imported modules. So it won't know that in `git-submodule` you had a `tsconfig.json` that included the types.\r\nIf you need to expose types from a package, you should reference them from its `index` in some way, such as with `/// <reference path=\"./types/custom.d.ts\" />.`\r\nIn this case, you could also not bother with putting types in a separate file and just do:\r\n```ts\r\ndeclare global {\r\n    interface Date {\r\n        format(): number;\r\n    }\r\n}\r\n```"
      }
    ]
  },
  {
    "number": 18676,
    "title": "Cannot find module 'vue' when 'module' is set to 'umd'",
    "created_at": "2017-09-22T02:08:27Z",
    "closed_at": "2017-09-22T05:08:51Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/18676",
    "body": "**TypeScript Version:**  2.5.2\r\n\r\nwhen tsc complie `d:/elecapp/one/comp/test.ts`\r\n\r\n**Code**\r\n\r\n```javascript\r\n======== Resolving module 'vue' from 'd:/elecapp/one/comp/test.ts'. ========\r\nModule resolution kind is not specified, using 'Classic'.\r\nFile 'd:/elecapp/one/comp/vue.ts' does not exist.\r\nFile 'd:/elecapp/one/comp/vue.tsx' does not exist.\r\nFile 'd:/elecapp/one/comp/vue.d.ts' does not exist.\r\nFile 'd:/elecapp/one/vue.ts' does not exist.\r\nFile 'd:/elecapp/one/vue.tsx' does not exist.\r\nFile 'd:/elecapp/one/vue.d.ts' does not exist.\r\nFile 'd:/elecapp/vue.ts' does not exist.\r\nFile 'd:/elecapp/vue.tsx' does not exist.\r\nFile 'd:/elecapp/vue.d.ts' does not exist.\r\nFile 'd:/vue.ts' does not exist.\r\nFile 'd:/vue.tsx' does not exist.\r\nFile 'd:/vue.d.ts' does not exist.\r\nDirectory 'd:/elecapp/one/comp/node_modules' does not exist, skipping all lookups in it.\r\nDirectory 'd:/elecapp/one/node_modules' does not exist, skipping all lookups in it.\r\nFile 'd:/elecapp/node_modules/@types/vue.d.ts' does not exist.\r\nDirectory 'd:/node_modules' does not exist, skipping all lookups in it.\r\nFile 'd:/elecapp/one/comp/vue.js' does not exist.\r\nFile 'd:/elecapp/one/comp/vue.jsx' does not exist.\r\nFile 'd:/elecapp/one/vue.js' does not exist.\r\nFile 'd:/elecapp/one/vue.jsx' does not exist.\r\nFile 'd:/elecapp/vue.js' does not exist.\r\nFile 'd:/elecapp/vue.jsx' does not exist.\r\nFile 'd:/vue.js' does not exist.\r\nFile 'd:/vue.jsx' does not exist.\r\n======== Module name 'vue' was not resolved. ========\r\n```\r\n\r\n**Expected behavior:**\r\n\r\n```javascript\r\nFile 'd:/elecapp/node_modules/@types/vue.d.ts' does not exist.\r\nFile 'd:/elecapp/node_modules/vue/types/index.d.ts' exist.\r\n```\r\n\r\n**Actual behavior:**\r\n\r\n```javascript\r\nFile 'd:/elecapp/node_modules/@types/vue.d.ts' does not exist.\r\n```\r\n\r\nIt's only find `@types/vue.d.ts` does not exist , but it didn't find there is `vue/types/index.d.ts` already exists.\r\n\r\ninside /vue/package.json(there is typings):\r\n\r\n```javascript\r\n  \"typings\": \"types/index.d.ts\",\r\n  \"unpkg\": \"dist/vue.js\",\r\n  \"version\": \"2.4.4\"\r\n```\r\n\r\n\r\nps tsconfig.json:\r\n```javascript\r\n{\r\n  \"compilerOptions\": {\r\n    \"target\": \"es5\",\r\n    \"module\": \"umd\",\r\n    \"declaration\": false,\r\n    \"traceResolution\": true,\r\n    \"noImplicitAny\": false, \r\n    \"skipLibCheck\": true, \r\n    \"allowJs\": false,\r\n    \"checkJs\": false,\r\n    \"lib\": [\r\n      \"dom\",\r\n      \"scripthost\",\r\n      \"webworker\",\r\n      \"es5\",\r\n      \"es2015\",\r\n      \"es2016\",\r\n      \"es2017\",\r\n      \"esnext\"\r\n    ]\r\n  },\r\n  \"include\": [\r\n    \"one/*/*.tsx\",\r\n    \"one/*/*.ts\"\r\n  ],\r\n  \"exclude\": []\r\n}\r\n```",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/18676/comments",
    "author": "yolio2003",
    "comments": [
      {
        "user": "DanielRosenwasser",
        "created_at": "2017-09-22T03:18:42Z",
        "body": "Try setting your `\"moduleResolution\"` strategy to `\"node\"` which isn't the default on `\"module\": \"umd\"`"
      }
    ]
  },
  {
    "number": 18389,
    "title": "Overloading function with literal argument doesn't work",
    "created_at": "2017-09-11T15:56:31Z",
    "closed_at": "2017-09-11T16:04:52Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/18389",
    "body": "**TypeScript Version:**  2.5.2\r\n\r\n**Code**\r\n```ts\r\nfunction test(p: 'a'): 'a';\r\nfunction test(p: string): string {\r\n    return p;\r\n}\r\n\r\ntest('b');\r\n```\r\n\r\n**Expected behavior:**\r\nno errors\r\n\r\n**Actual behavior:**\r\nArgument of type '\"b\"' is not assignable to parameter of type '\"a\"'.\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/18389/comments",
    "author": "dfilatov",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2017-09-11T15:59:21Z",
        "body": "The function has one signature. the other one is called an \"implementation\" signature, is only visible within the body of the function. so if you want your function to be called with a `string`, add a new overload.\r\n\r\n```ts\r\nfunction test(p: 'a'): 'a';\r\nfunction test(p: string): string;\r\nfunction test(p: string): string {\r\n    return p;\r\n}\r\n```"
      }
    ]
  },
  {
    "number": 18041,
    "title": "keyof strange type casting",
    "created_at": "2017-08-25T12:53:09Z",
    "closed_at": "2017-08-29T14:17:37Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/18041",
    "body": "TSC 2.4.2\r\n\r\n```ts\r\nfunction foo1<T>(e: T, k: string) {\r\n    let\r\n        v = e[k];   // v: any\r\n}\r\n\r\nfunction foo2<T>(e: T, k: keyof T) {\r\n    let\r\n        v = e[k];   // v: T[keyof T]\r\n}\r\n```\r\n\r\nI would expect that for `foo2` type of `v` should also be `any`",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/18041/comments",
    "author": "pankleks",
    "comments": [
      {
        "user": "ikatyang",
        "created_at": "2017-08-25T13:49:24Z",
        "body": "`v` in `foo2` must be something in `e`, `T[keyof T]` did describe its relationship well."
      },
      {
        "user": "ikatyang",
        "created_at": "2017-08-29T12:50:50Z",
        "body": "Not sure how to elaborate, lets take an example. Imagine passing `MyObject` as `T` into that function:\r\n\r\n```ts\r\ninterface MyObject {\r\n  a: boolean;\r\n  b: number;\r\n  c: string;\r\n}\r\n\r\ntype MyKeys = keyof MyObject; //=> 'a' | 'b' | 'c'\r\ntype MyValues = MyObject[MyKeys]; //=> boolean | number | string\r\n\r\nfunction foo1<T>(e: T, k: string) {\r\n    //           ^     ^ string\r\n    //           MyObject\r\n    let\r\n        v = e[k];\r\n    //  ^ MyObject[string] = ??? = any\r\n    //    (string is not one of its keys, so TS think it can be anything.)\r\n    //    (keys are string, but string is not key, since key is more specific.)\r\n}\r\n\r\nfunction foo2<T>(e: T, k: keyof T) {\r\n    //           ^     ^ MyKeys\r\n    //           MyObject\r\n    let\r\n        v = e[k];\r\n    //  ^ MyObject[MyKeys] = MyValues = boolean | number | string\r\n    //    (MyKeys is one of its keys, so TS knows how to get its type)\r\n}\r\n```"
      }
    ]
  },
  {
    "number": 17854,
    "title": "deconstruction of the object ",
    "created_at": "2017-08-17T02:44:22Z",
    "closed_at": "2017-08-17T03:16:22Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/17854",
    "body": "let obj = {\r\n    p: [\r\n      'Hello',\r\n      { y: 'World' }\r\n    ]\r\n  };\r\n  \r\n  let { p, p: [x, { y }] } = obj;\r\n \r\n\r\nwhy \r\nerror TS2459: Type 'string | {\r\ny: string; }' has no property 'y' and no strin\r\ng index signature.???????????",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/17854/comments",
    "author": "JLBear",
    "comments": [
      {
        "user": "ikatyang",
        "created_at": "2017-08-17T03:01:31Z",
        "body": "The type for property will always be widened (no tuple, no literal type) unless place it in the place contextual type inference is available, e.g.\r\n\r\n(original)\r\n\r\n```ts\r\nlet obj = {\r\n  p: ['Hello', { y: 'World' }],\r\n}; //=> { p: (string | { y: string })[] }\r\n\r\nlet { p, p: [x, { y }] } = obj;\r\n//                ^ [ts] Type 'string | { y: string; }' has no property 'y' and no string index signature.\r\n```\r\n\r\n(solution 1)\r\n\r\n```ts\r\nlet { p, p: [x, { y }] } = {\r\n  p: ['Hello', { y: 'World' }],\r\n}; // works fine\r\n```\r\n\r\n(solution 2)\r\n\r\n```ts\r\nfunction deconstruction({ p, p: [x, { y }] }) {\r\n  // do something\r\n}\r\n\r\ndeconstruction({\r\n  p: ['Hello', { y: 'World' }],\r\n}); // works fine\r\n```"
      }
    ]
  },
  {
    "number": 17802,
    "title": "\"TS6143 --allowJs is not set\" error but only on one setup",
    "created_at": "2017-08-15T11:06:33Z",
    "closed_at": "2017-08-22T08:47:59Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/17802",
    "body": "**TypeScript Version:**  2.2\r\n\r\nWe have several machines with the same Angular 2 + ASP.NET Core 1.6 project on them. All of the setups are similar as far as we can say and one of those VS.NET setups is having this error on build and we couldn't figure out what's different/missing:\r\n\r\n```\r\nError\tTS6143\tBuild:Module './src/common' was resolved to 'D:/MyProject/node_modules/@angular/common/src/common.js', but '--allowJs' is not set.\r\nD:\\MyProject\\node_modules\\@angular\\common\\index.d.ts\t13\t\r\n```\r\n\r\nThe same project builds and runs fine on other setups. Here's what they all have common:\r\n\r\n- VS.NET 2017 15.2\r\n- TypeScript 2.2\r\n- .NET SDK 1.0.4\r\n\r\n`tsconfig.json` is in the root folder of the project.\r\n\r\n**tsconfig.json:**\r\n\r\n```\r\n{\r\n  \"compilerOptions\": {\r\n    \"target\": \"es5\",\r\n    \"module\": \"commonjs\",\r\n    \"moduleResolution\": \"node\",\r\n    \"sourceMap\": true,\r\n    \"emitDecoratorMetadata\": true,\r\n    \"experimentalDecorators\": true,\r\n    \"lib\": [ \"es2015\", \"dom\" ],\r\n    \"suppressImplicitAnyIndexErrors\": true\r\n  },\r\n  \"exclude\": [\r\n    \"node_modules\",\r\n    \"wwwroot/Application/Models/Custom/**/*\",\r\n    \"wwwroot/Application/Models/Generator/**/*\",\r\n    \"wwwroot/Application/**/*.js\",\r\n    \"wwwroot/Application/**/*.js.map\"\r\n  ]\r\n}\r\n```\r\n\r\nWhat could be wrong with this problematic machine?",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/17802/comments",
    "author": "deastr",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2017-08-16T18:42:36Z",
        "body": "Seems like you must have different node_modules folder contents. Try setting up a package-lock.json and making sure you have identical NPM modules installed"
      },
      {
        "user": "deastr",
        "created_at": "2017-08-22T08:47:59Z",
        "body": "Yes the problem was incomplete node_modules folder. We cleared cache, node_modules and restore clean and it works now."
      }
    ]
  },
  {
    "number": 17795,
    "title": "Type loss when using generic decorators",
    "created_at": "2017-08-15T04:50:06Z",
    "closed_at": "2017-09-06T19:01:22Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/17795",
    "body": "**TypeScript Version:**  2.4.1\r\n\r\nThe following code aims to restrict the decorator `decorate` to members of a class inheriting from `Base`. However, it seems that `K` ends up only including members in `Base`, not in the inherited class. (This is a minimal reproducible example for other cases, e.g., restricting the decorator to methods within subclasses of `Base` of a certain return type.)\r\n\r\n**Code**\r\n\r\n```ts\r\nabstract class Base {\r\n  base() { return 1; };\r\n}\r\n\r\ntype ProtoOf<T> = Pick<T, keyof T>;\r\n\r\nfunction decorate<T extends Base, K extends keyof ProtoOf<T>, F extends T[K]>() {\r\n  return (proto: ProtoOf<T>, propertyKey: K, descriptor: TypedPropertyDescriptor<F>) => {\r\n    // Do stuff.\r\n  };\r\n}\r\n\r\nclass Test extends Base {\r\n  @decorate()\r\n  bar(): boolean {\r\n    return false;\r\n  }\r\n}\r\n```\r\n\r\n**Expected behavior:**\r\nNo errors when applying `@decorate()` to `bar()`.\r\n\r\n**Actual behavior:**\r\nError: `[ts] Argument of type '\"bar\"' is not assignable to parameter of type '\"base\"'.`",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/17795/comments",
    "author": "oleg-codaio",
    "comments": [
      {
        "user": "aluanhaddad",
        "created_at": "2017-08-16T03:15:11Z",
        "body": "You can work around it by returning a generic decorator from your decorator factory.\r\n```ts\r\nfunction decorate() {\r\n  return <T extends Base, K extends keyof T, F extends T[K]>\r\n    (proto: ProtoOf<T>, propertyKey: K, descriptor: TypedPropertyDescriptor<F>) => {\r\n    // Do stuff.\r\n  };\r\n}\r\n\r\nclass Test extends Base {\r\n  @decorate() bar(): boolean {\r\n    return false;\r\n  }\r\n}\r\n```\r\nI think this behavior is correct since it is equivalent to writing\r\n```ts\r\n\r\nfunction decorate<T extends Base, K extends keyof ProtoOf<T>, F extends T[K]>() {\r\n  return (proto: ProtoOf<T>, propertyKey: K, descriptor: TypedPropertyDescriptor<F>) => {\r\n    // Do stuff.\r\n  };\r\n}\r\n\r\nconst decorator = decorate();\r\n\r\nclass Test extends Base {\r\n  @decorator bar(): boolean {\r\n    return false;\r\n  }\r\n}\r\n```"
      },
      {
        "user": "oleg-codaio",
        "created_at": "2017-08-16T18:37:48Z",
        "body": "@aluanhaddad thanks for the update! Your solution does address the issue in my earlier example, though I guess the actual problem I was having had to do with decorator arguments:\r\n\r\n```\r\nfunction decorate<T extends Base>(property: keyof T) {\r\n  return <U extends T, K extends keyof U, F extends U[K]>\r\n    (proto: ProtoOf<U>, propertyKey: K, descriptor: TypedPropertyDescriptor<F>) => {\r\n    // Do stuff.\r\n  };\r\n}\r\n\r\nclass Test extends Base {\r\n  @decorate('foo') bar(): boolean {\r\n    return false;\r\n  }\r\n\r\n  foo(): boolean { return false; }\r\n}\r\n```\r\n\r\nSo the decorator works on `bar()` fine now, but is failing with this error: `[ts] Argument of type '\"foo\"' is not assignable to parameter of type '\"base\"'.` Basically, is there a good way of having the decorator parameters be generic w.r.t. the decorated class?"
      },
      {
        "user": "oleg-codaio",
        "created_at": "2017-08-16T19:11:41Z",
        "body": "On another note, if `bar()` is marked private, then the original error returns - it seems that in this case, the decorator is only able to access public properties? My gut feeling is this is a limitation we'd have to deal with."
      },
      {
        "user": "mhegazy",
        "created_at": "2017-08-22T22:24:53Z",
        "body": "Just nothing that this `function decorate<T extends Base>(property: keyof T)`  does not have any place to infer `T`, you can not infer a type from a name of one of its properties. and remember decorate is a factory that returns a function that will be used to decorate. so it is equivalent to `decorate(property: keyof Base)`, which means you can only decorate properties that have the same name as ones in `Base`.\r\n\r\nSo @aluanhaddad's suggestion seems like the correct solution here.\r\n"
      },
      {
        "user": "oleg-codaio",
        "created_at": "2017-08-22T22:40:04Z",
        "body": "Your explanation makes sense. Though the issue still stands that it doesn't seem currently possible to have decorate properties work off the decorated class. It would be great if there was a way to give \"context\" to decorator properties as to what exact object they're decorating."
      },
      {
        "user": "aluanhaddad",
        "created_at": "2017-08-23T15:15:04Z",
        "body": "@vaskevich I'm not sure if I understand what you are trying to achieve correctly, but you can capture a string literal type parameter when the decorator factory is applied and then subsequently validate that this property exists on the class with the decorated method.\r\n\r\nSo, going back to your example, you can validate that a `foo` member exists on the decorated class and we can even place constraints on its type. For example, in the following, `Test` must have a callable member `foo` that has the same return type as the decorated member.\r\n\r\n(Warning these types are pretty hard to read and I experienced several language service crashes in VS code due to recursion while working them out.)\r\n\r\n```ts\r\ntype ProtoOf<T> = Pick<T, keyof T>;\r\n\r\nfunction decorate<CK extends string>(property: CK) {\r\n\r\n  return <\r\n    T extends Base & {[P in CK]: G},\r\n    K extends keyof T,\r\n    F extends T[K] & G,\r\n    G extends  ((...args: {}[]) => R),\r\n    R>(\r\n      proto: ProtoOf<T> & {[P in CK]: (...args: {}[]) => R},\r\n      propertyKey: K,\r\n      descriptor: TypedPropertyDescriptor<F>) => {\r\n    // Do stuff.\r\n  };\r\n}\r\n\r\nclass Test extends Base {\r\n  @decorate('foo') bar(): boolean {\r\n    return false;\r\n  }\r\n\r\n  foo(): boolean {return false;}\r\n}\r\n````\r\nThe way this works is by capturing a type for the argument to the factory and using that argument to define the expected shape of the object that will be decorated. The declaration of `G` and the intersection type used to describe the target of the decorator was an experiment that seemed to work. The intent was that if we change `foo` to return a type not assignable to the return type of `bar`, we will get an error at the decorator application site.\r\n\r\nNote that the the declaration of T is provided, as in my previous example, by the decorator and not the decorator factory."
      }
    ]
  },
  {
    "number": 17775,
    "title": "Enum Error after Using tsc --target a.ts. ",
    "created_at": "2017-08-14T12:46:07Z",
    "closed_at": "2017-08-15T01:15:18Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/17775",
    "body": "enum DoorState\r\n{\r\nOpen, Closed, Ajar\r\n}\r\nsave as 2_a.ts\r\nCompile using tsc --target es6 2_a.ts\r\nRun using node 2_a.js\r\nResult::\r\nUnexpected reserved word.\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/17775/comments",
    "author": "ybchoo",
    "comments": [
      {
        "user": "ikatyang",
        "created_at": "2017-08-14T13:34:12Z",
        "body": "I guess you might execute the wrong file, e.g. `node 2_a.ts`, otherwise can you share your TS/Node version and generated `2_a.js`?"
      }
    ]
  },
  {
    "number": 17645,
    "title": "async  can use it at Typescript?",
    "created_at": "2017-08-07T02:24:13Z",
    "closed_at": "2017-08-07T03:05:53Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/17645",
    "body": "async function getStockPriceByName(name) {\r\n  return name;\r\n}\r\n\r\n\r\nerror TS2468: Cannot find global value 'Promise'.\r\ntest.ts(1,16): error TS2705: An async function or method in ES5/\r\nES3 requires the 'Promise' constructor.  Make sure you have a de\r\nclaration for the 'Promise' constructor or include 'ES2015' in y\r\nour `--lib` option.\r\n\r\n\r\n{\r\n    \"compilerOptions\": {\r\n        \"target\": \"es5\",\r\n        \"experimentalDecorators\": true,\r\n         \"lib\": [\r\n      \"dom\",\r\n      \"es5\",\r\n       \"es6\"\r\n    ]\r\n    }\r\n}",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/17645/comments",
    "author": "JLBear",
    "comments": [
      {
        "user": "ikatyang",
        "created_at": "2017-08-07T02:46:40Z",
        "body": "You have to specify your `tsconfig.json` for `tsc` so that TS can pick up your configs.\r\n\r\n```sh\r\ntsc -p path/to/your/tsconfig.json\r\n```\r\n\r\n`tsc test.ts` is considered using default settings."
      }
    ]
  },
  {
    "number": 17515,
    "title": "tsc is transpiling multiple files, when I just want 1 file transpiled",
    "created_at": "2017-07-30T03:32:41Z",
    "closed_at": "2017-08-17T17:13:32Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/17515",
    "body": "Not sure if this is a bug or not.\r\n\r\nI have a file like so:\r\n\r\n```typescript\r\n//foo.ts\r\nimport {Client} from \"../../client\";\r\nconsole.log('foo');\r\n```\r\n\r\nI transpile this .ts file like so:\r\n\r\n `tsc ${foo} --outDir \"${OUT_DIR}\"`\r\n\r\nwhat happens, however, is that tsc will transpile multiple files including `../../client`, and write them out to the filesystem.\r\n\r\nI would expect only `${foo}` to get transpiled.\r\n\r\n`${foo}` represents just one file, I double checked.\r\n\r\nAny idea if this is a bug or expected behavior? It's causing problems for me, as is.\r\n\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/17515/comments",
    "author": "ORESoftware",
    "comments": [
      {
        "user": "aluanhaddad",
        "created_at": "2017-07-30T03:56:42Z",
        "body": "@ORESoftware \r\n```bash\r\n> tsc ${foo} --noResolve --outDir \"${OUT_DIR}\"\r\n```\r\nAlso, why not ask on Stack Overflow?"
      }
    ]
  },
  {
    "number": 17333,
    "title": "Relax rule about `super` followed by member access",
    "created_at": "2017-07-20T22:33:00Z",
    "closed_at": "2017-07-22T01:07:59Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/17333",
    "body": "I have a method that takes a class type. I can pass an explicit class name to it `Foo`, or I can pass `this`, but I cannot pass `super` because of the ts error:\r\n\r\n> 'super' must be followed by an argument list of member access.\r\n\r\nIs there a specific design goal behind disabling this?\r\n\r\n**TypeScript Version:**  2.4.1\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/17333/comments",
    "author": "yebrahim",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2017-07-20T23:40:32Z",
        "body": "> Is there a specific design goal behind disabling this?\r\n\r\nIt's not in any sense \"disabled\" as much as simply not existing in the first place - it's not legal ES6 code to nakedly reference `super`, and there's not an immediately obvious ES5 transpilation."
      }
    ]
  },
  {
    "number": 17034,
    "title": "how to disable 'this' tranform to '_this'\uff0cI want to add linq extension metthod for Array",
    "created_at": "2017-07-08T16:49:51Z",
    "closed_at": "2017-07-08T17:47:22Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/17034",
    "body": "I want to add linq extension metthod for Array, like c# static Extension method\u3002\r\n\r\nhere is the code\r\n\r\ndeclare interface Array<T> {\r\n    where(predicate: (value?: T, index?: number, list?: T[]) => boolean): T[];\r\n}\r\nArray.prototype.where = (predicate?: (value?: T, index?: number, list?: T[]) => boolean) => {\r\n return this.filter(predicate);\r\n};\r\n\r\nbut the tsc compiled 'this 'into '_this',and code work incorrect.",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/17034/comments",
    "author": "mokeyish",
    "comments": [
      {
        "user": "ikatyang",
        "created_at": "2017-07-08T16:55:50Z",
        "body": "You should use `function () { /* ... */ }`(function) instead of `() => { /* ... */ }`(arrow-function), arrow-function is a function that does not have its own `this`."
      }
    ]
  },
  {
    "number": 16935,
    "title": "Compiler API transpile type cast code wrong.",
    "created_at": "2017-07-05T03:12:16Z",
    "closed_at": "2017-07-05T06:35:49Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/16935",
    "body": "**TypeScript Version:**  2.3.4 \r\n\r\n**Code**\r\n- compiler api invoke\r\n```ts\r\nimport * as ts from \"typescript\";                                                                                                                                                       \r\nfunction _go_transpileModule(script: string): string {\r\n    let result = ts.transpileModule(script, {compilerOptions: {module: ts.ModuleKind.CommonJS, target: ts.ScriptTarget.ES5}}); \r\n    return result.outputText;\r\n}  \r\n```\r\nI call _go_transpileModule method in myself embed v8 engine application, not node.js.\r\n\r\n- ts source code\r\n```ts\r\nfunction sqlDemo() {                                           \r\n                                                               \r\n    try {                                                      \r\n        let s = db.sql();                                      \r\n        let records = <Object[]>s.exec('select * from script');\r\n                                                               \r\n        records.forEach((r) => printRecord(r));                \r\n                                                               \r\n        for (let i = 0; i < records.length; i++) {             \r\n            printRecord(records[i]);                           \r\n        }                                                      \r\n                                                               \r\n        s.exec(\"update script set id = 1111 where id = 1;\");   \r\n    } catch (error) {                                          \r\n        console.log(error.name, error.message);                \r\n    }                                                          \r\n}                       \r\n\r\n```\r\n\r\n- the javascript code after transpiled\r\n```js\r\nfunction sqlDemo() {\r\n    try {\r\n        var s = db.sql();\r\n        var records = <Object />, _a =  > s.exec('select * from script');\r\n        records.forEach(function (r) { return printRecord(r); });\r\n        for (var i = 0; i < records.length; i++) {\r\n            printRecord(records[i]);\r\n        }\r\n        s.exec(\"update script set id = 1111 where id = 1;\");\r\n    }\r\n    catch (error) {\r\n        console.log(error.name, error.message);\r\n    }\r\n}\r\n```\r\n\r\n**Expected behavior:**\r\n\r\neverything is ok.\r\n\r\n**Actual behavior:**\r\n\r\nbut the follow code:\r\n```ts\r\n<Object[]>\r\n```\r\n has been translated to \r\n```js\r\n<Object />, _a =  >\r\n```\r\n\r\nHow can I solve this problem?\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/16935/comments",
    "author": "saibing",
    "comments": [
      {
        "user": "ikatyang",
        "created_at": "2017-07-05T03:44:05Z",
        "body": "It seems something might be wrong with your `jsx` config, can you give a try with\r\n\r\n```js\r\ntranspileOptions = {compilerOptions: {jsx: ts.JsxEmit.None, /* ... */}, /* ... */}\r\n``` \r\n\r\nor \r\n\r\n```js\r\ntranspileOptions = {fileName: 'something.ts', /* ... */}\r\n```"
      }
    ]
  },
  {
    "number": 16927,
    "title": "Failed to launch external program tsc -p ts spawn tsc ENOENT",
    "created_at": "2017-07-04T16:06:56Z",
    "closed_at": "2017-08-17T17:25:56Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/16927",
    "body": "**TypeScript Version:**  2.4.1\r\n**VSCode Version:** 1.3.1\r\n**OS Version:** Linux Mint 18.1\r\n**node:** 6.11.0\r\n**npm:** 5.0.3\r\n\r\nSteps to Reproduce:\r\n\r\nOpen VSCode insider from Nemo or from terminal\r\nTry to run build task **Ctrl+Shift+B** (using tsc -p in task.json 'args')\r\n\r\ntasks.json\r\n```javascript\r\n{\r\n    \"version\": \"0.1.0\",\r\n    \"command\": \"tsc\",\r\n    \"isShellCommand\": true,\r\n    \"args\": [\"-p\", \"ts\"],\r\n    \"showOutput\": \"silent\",\r\n    \"problemMatcher\": \"$tsc\"\r\n}\r\n```\r\n\r\nhelloworld.ts in **ts** folder\r\n```typescript\r\nclass HelloWorld {\r\n    \r\n}\r\n```\r\ntsconfig.json\r\n```javascript\r\n{\r\n    \"compilerOptions\": {\r\n        \"target\": \"es5\",\r\n        \"outFile\": \"../js/app.js\",\r\n        \"sourceMap\": true\r\n    }\r\n}\r\n```\r\n\r\nEmpty folder **js**\r\n\r\n**Expected behavior:**\r\nI believe that this setup should compile the typescrpt files in my project to js files and put them in my js folder.\r\n\r\n**Actual behavior:**\r\nWhen I hit **Ctrl+Shift+B** i get: \r\n**Failed to launch external program tsc -p ts.**\r\n**spawn tsc ENOENT**\r\nin the output window\r\n\r\nIts worth noting that if I run the **tsc** command with args in the VSCode terminal window in my projects root directory (tsc -p ts) it **DOES** seem to work fine(I get the expected behavior). \r\n\r\nThis issues is similar to #8434 \r\nI do have custom code in my .profile and .bashrc, but in my case it does not matter if I open from the terminal or from the file explorer\r\n\r\nrunning process.env.PATH in VScode dev tools console outputs the same path as running echo $PATH from my command line. ",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/16927/comments",
    "author": "kylerdanielster",
    "comments": [
      {
        "user": "leonadler",
        "created_at": "2017-07-05T13:00:43Z",
        "body": "This is normally caused by `tsc` not being in your $PATH. Double-check if your global node_modules/.bin is reachable outside of bash, e.g. via running `which tsc` in `sh`/`zsh`.\r\n\r\nWhile not a fix for your issue per se, consider running the local `tsc` in your project:\r\n```json\r\n{\r\n    \"version\": \"0.1.0\",\r\n    \"command\": \"node\",\r\n    \"isShellCommand\": true,\r\n    \"args\": [\"${workSpaceRoot}/node_modules/typescript/bin/tsc\", \"-p\", \"ts\"],\r\n    \"showOutput\": \"silent\",\r\n    \"problemMatcher\": \"$tsc\"\r\n}\r\n```\r\n\r\nThis allows you to track the version of the TypeScript compiler you want to use in your package.json independent of the globally installed one (`npm i -g typescript`)."
      },
      {
        "user": "kylerdanielster",
        "created_at": "2017-07-09T02:00:22Z",
        "body": "This worked.\r\n\r\nInstalled typescript locally with `npm i typescript` and changed tasks.json to \r\n```\r\n{\r\n    \"version\": \"0.1.0\",\r\n    \"command\": \"node\",\r\n    \"isShellCommand\": true,\r\n    \"args\": [\"{pathToWorkSpaceRoot}/node_modules/typescript/bin/tsc\", \"-p\", \"ts\"],\r\n    \"showOutput\": \"silent\",\r\n    \"problemMatcher\": \"$tsc\"\r\n}\r\n```\r\nWhich as you say \"allows you to track the version of the TypeScript compiler you want to use in your package.json independent of the globally installed one\". Seems like a good idea. \r\n\r\nI think it is worth noting that: ~/.npm-global/bin is in my path which contains the tsc package. This should be equivalent to node_modules/.bin I believe. \r\n\r\nRegardless, running 'sh' and 'tcs' I get 'tsc: not found'."
      },
      {
        "user": "leonadler",
        "created_at": "2017-07-10T09:36:25Z",
        "body": "@kylerdanielster glad it solves your issue!\r\nJust a little addendum, since you wrote \"{pathToWorkSpaceRoot}\", I assume you hard-coded the path - you can use the actual string `${workSpaceRoot}` so it works regardless of where you checkout the project."
      },
      {
        "user": "kylerdanielster",
        "created_at": "2017-07-11T00:14:53Z",
        "body": "@leonadler \"${workSpaceRoot}/node_modules/typescript/bin/tsc\" did not work for me, that is why I hard coded it. \r\n\r\nI played around with the path some more and \"node_modules/typescript/bin/tsc\" this did the trick as well.\r\n\r\nCurrent task.json (in .vscode folder)\r\n```\r\n{\r\n    \"version\": \"0.1.0\",\r\n    \"command\": \"node\",\r\n    \"isShellCommand\": true,\r\n    \"args\": [\"node_modules/typescript/bin/tsc\", \"-p\", \"ts\"],\r\n    \"showOutput\": \"silent\",\r\n    \"problemMatcher\": \"$tsc\"\r\n}\r\n```"
      }
    ]
  },
  {
    "number": 16629,
    "title": "Change return type by type guard",
    "created_at": "2017-06-19T20:54:04Z",
    "closed_at": "2017-06-19T21:07:57Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/16629",
    "body": "```\r\nclass Foo {\r\n  foo = 123;\r\n}\r\nclass Bar {\r\n  bar = 123;\r\n}\r\nfunction distinguish(arg: Foo | Bar): Foo | Bar {\r\n  if(arg instanceof Foo) {\r\n    return arg\r\n  }\r\n  else {\r\n    return arg\r\n  }\r\n}\r\nlet result: Foo = distinguish(new Foo())\r\n// Type 'Foo | Bar' is not assignable to type 'Foo'\r\n```",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/16629/comments",
    "author": "pravdomil",
    "comments": [
      {
        "user": "DanielRosenwasser",
        "created_at": "2017-06-19T21:04:40Z",
        "body": "I'm not sure what you're asking or what the motivating scenario is, but would this fix it?\r\n\r\n```ts\r\nfunction distinguish<T extends Foo | Bar>(arg: T): T {\r\n  if (arg instanceof Foo) {\r\n    return arg\r\n  }\r\n  else {\r\n    return arg\r\n  }\r\n}\r\n```\r\n"
      }
    ]
  },
  {
    "number": 16192,
    "title": "can any one tell me how to implement extension method for Array in Typescript (Let's suppose i want to write functionality for sorting the array )",
    "created_at": "2017-06-01T11:29:42Z",
    "closed_at": "2017-06-05T22:05:12Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/16192",
    "body": "",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/16192/comments",
    "author": "Prashant3108",
    "comments": [
      {
        "user": "ikatyang",
        "created_at": "2017-06-01T11:39:56Z",
        "body": "(./extend.ts)\r\n\r\n```ts\r\ndeclare global {\r\n  interface Array<T> {\r\n    some_method(): this;\r\n  }\r\n}\r\n\r\nArray.prototype.some_method = function () {\r\n  return this.sort().reverse();\r\n};\r\n\r\nexport {};\r\n```\r\n\r\n(./test.ts)\r\n\r\n```ts\r\nimport './extend';\r\n\r\nconst a = ['abc', 'def'].some_method();\r\n```\r\n\r\nIs this what you want?\r\n\r\n"
      }
    ]
  },
  {
    "number": 15994,
    "title": "Control flow type narrowing doesn't work",
    "created_at": "2017-05-22T15:24:34Z",
    "closed_at": "2017-05-22T16:00:06Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/15994",
    "body": "**TypeScript Version:**  2.3.2\r\n\r\n**Code**\r\n\r\n```ts\r\ntype JoinModels<A, K extends string, B> = A & {\r\n    [k in K]: B;\r\n};\r\n\r\ninterface User {\r\n    username: string;\r\n}\r\n\r\ninterface Post {\r\n    title: string;\r\n}\r\n\r\ntype UserWithPosts = JoinModels<User, \"posts\", Post[]> | null;\r\n\r\nlet userWithPosts: UserWithPosts = null;\r\nif (userWithPosts == null) {\r\n    console.log(userWithPosts.posts[0].title);\r\n}\r\n```\r\n\r\n**Expected behavior:**\r\n`userWithPosts` should be narrowed to null;\r\n\r\n**Actual behavior:**\r\nNo error occurs",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/15994/comments",
    "author": "CurlerRoo",
    "comments": [
      {
        "user": "blakeembrey",
        "created_at": "2017-05-22T15:32:21Z",
        "body": "@pc-lover If you enable `strictNullChecks`, this should work as expected. Without it, there is no `null` or `undefined` types used. Do you have an expected behaviour without `strictNullChecks` enabled?"
      }
    ]
  },
  {
    "number": 15858,
    "title": "React Props validation does not work for extended classes",
    "created_at": "2017-05-15T22:08:29Z",
    "closed_at": "2017-05-15T22:31:26Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/15858",
    "body": "We have a generic BaseComponent that does some autobinding and transition blocking. \r\n\r\nIf I have a component that extends BaseComponent<Props, State>, the compiler does not recognize error in props validation.\r\n\r\nThe following component does not throw compiler errors.\r\n```jsx\r\ninterface Props {\r\n  notMyField: string,\r\n}\r\n\r\nclass MyComponent extends BaseComponent<Props, any> {\r\n   render() {\r\n      return <div>{this.props.myField}</div>;\r\n   } \r\n}\r\n```\r\n\r\n```jsx\r\nimport * as PropTypes from 'prop-types';\r\nimport * as React from 'react';\r\n\r\n/**\r\n * The base component that autobinds all the methods to this.\r\n */\r\nclass BaseComponent<Props, State> extends React.Component<Props, State> {\r\n  static propTypes;\r\n  static contextTypes = {\r\n    router: PropTypes.object,\r\n  };\r\n\r\n  props;\r\n  unblock;\r\n\r\n  constructor(props: Props) {\r\n    super(props);\r\n    Object.getOwnPropertyNames(Object.getPrototypeOf(this)).forEach((method) => {\r\n      if (typeof this[method] !== 'function') {\r\n        return;\r\n      }\r\n      this[method] = this[method].bind(this);\r\n    });\r\n  }\r\n\r\n  componentDidMount() {\r\n    const {\r\n      props: {\r\n        history\r\n      },\r\n      willTransition\r\n    } = this as any;\r\n    // TODO: Figure out why react/prop-types is warning here.\r\n    /* eslint-disable react/prop-types */\r\n    if (history && willTransition) {\r\n      this.unblock = history.block(willTransition);\r\n    }\r\n    /* eslint-enable react/prop-types */\r\n  }\r\n\r\n  componentWillUnmount() {\r\n    if (this.unblock) {\r\n      this.unblock();\r\n    }\r\n  }\r\n}\r\n\r\nexport default BaseComponent;\r\n```",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/15858/comments",
    "author": "robin-anil",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2017-05-15T22:24:13Z",
        "body": "`BaseComponent` has a declaration for `props` with no type, and hence it gets a type `any`. remove the declaration of `props`. \r\n```ts\r\nclass BaseComponent<Props, State> extends React.Component<Props, State> {\r\n    ...\r\n    // props;\r\n   ...\r\n```\r\n\r\nalso worth nothing that using `--noImplicitAny` would have flagged these properties as `any` for you."
      }
    ]
  },
  {
    "number": 15801,
    "title": "--allowJs Unexpected behavior",
    "created_at": "2017-05-12T16:54:18Z",
    "closed_at": "2017-05-30T18:59:14Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/15801",
    "body": "Hello mates, \r\nI have a problem, when enable option \"allowJs\" , The ts compiler goes crazy \r\ntrying to compile again and again the same files \ud83d\udc4e \r\n\r\nThey could tell me why, Thanks for your time greetings!\r\n\r\nTypescript 2.3.2 \r\nvscode 1.12.1",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/15801/comments",
    "author": "11ume",
    "comments": [
      {
        "user": "aaronbeall",
        "created_at": "2017-05-12T18:04:24Z",
        "body": "Are you outputting the JS in the same folder you are compiling?"
      },
      {
        "user": "mhegazy",
        "created_at": "2017-05-12T18:35:55Z",
        "body": "make sure you have your output folder in your `exclude` property."
      },
      {
        "user": "11ume",
        "created_at": "2017-05-12T19:22:06Z",
        "body": "I have included the output folder in my exclude property and now works perfectly thank you for your time\r\nregards!!"
      }
    ]
  },
  {
    "number": 15793,
    "title": "Object types (Specification)",
    "created_at": "2017-05-12T08:21:38Z",
    "closed_at": "2017-05-12T13:19:26Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/15793",
    "body": "From specification:\r\n````\r\n3.3 Object Types\r\n\r\nObject types are composed from properties, call signatures, construct signatures, \r\nand index signatures, collectively called members.\r\n3.8.3 Object Type Literals\r\n  ...\r\n  TypeMember:\r\n\u2003\u2003\u2003PropertySignature\r\n\u2003\u2003\u2003CallSignature\r\n\u2003\u2003\u2003ConstructSignature\r\n\u2003\u2003\u2003IndexSignature\r\n\u2003\u2003\u2003MethodSignature\r\n  ...\r\n  Object type members are described in section 3.9.\r\n\r\n3.9 Specifying Members\r\n3.9.5 Method Signatures\r\n\r\n  A method signature is shorthand for declaring a property of a function type.\r\n\r\n````\r\nWhy there is no **method signatures** in the first sentence?\r\n_Object types are composed from properties, call signatures, construct signatures, \r\nand index signatures, collectively called members._\r\n\r\nDoes `properties` mean `method and property signatures` together?\r\nIf so it is not evidently.\r\nMay be it is better to split `properties` into `property and method signatures`,\r\nbecause we will enumerate entities from one domain (signatures).  \r\n\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/15793/comments",
    "author": "olegdunkan",
    "comments": [
      {
        "user": "DanielRosenwasser",
        "created_at": "2017-05-12T09:18:19Z",
        "body": "A method signature is really just a property signature whose type is an object type which contains a call signature.\r\n\r\nIn other words\r\n\r\n```ts\r\ninterface Foo {\r\n  bar(): string;\r\n}\r\n```\r\n\r\nis the same as\r\n\r\n```ts\r\ninterface Foo {\r\n  bar: {\r\n    (): string;\r\n  }\r\n}\r\n```"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2017-05-12T16:12:24Z",
        "body": "No prob! It's more a difference between the syntax and the type itself"
      }
    ]
  },
  {
    "number": 15646,
    "title": "[2339] Property ... does not exist on type 'typeof (Anonymous class)'",
    "created_at": "2017-05-08T00:34:59Z",
    "closed_at": "2017-05-08T19:46:41Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/15646",
    "body": "**TypeScript Version:**  2.2.1 stable\r\n\r\n**Code**\r\n\r\n```ts\r\nclass skrolr {\r\n    private static _Array = class extends Array {\r\n        from( obj: HTMLCollection ) {\r\n            let arr = [];\r\n            for( let i=0, len=obj.length; i<len; i++ ) {\r\n                arr[i] = obj[i];\r\n            }\r\n        }\r\n    }\r\n    \r\n    // in another class\r\n    skrolr._Array.from( [HTMLCollection object] );\r\n}\r\n```\r\n\r\n**Expected behavior:**\r\nSuccessful transpiling to ES3\r\n\r\n**Actual behavior:**\r\nError 2339\r\n\r\nBasically just trying to have a simplified polyfill for Array.from(), but I don't want this to be global, so I'm doing it in a subclass. It works as expected in ES6, and the subclass transpiles correctly to ES3, it's just the parser for some reason isn't seeing it.",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/15646/comments",
    "author": "jhpratt",
    "comments": [
      {
        "user": "hediet",
        "created_at": "2017-05-08T09:01:30Z",
        "body": "You are not instantiating your class `_Array`, so either you want to make `from` static or put it in an object rather than a class:\r\n```\r\n... \r\nprivate static _array = { from: function() {...}} ;\r\n... \r\n```"
      },
      {
        "user": "mhegazy",
        "created_at": "2017-05-08T16:21:07Z",
        "body": "` skrolr._Array` is a class, whose instances have a function called `from`. \r\n\r\nso either defined `from` as `static`, or call `(new skrolr._Array()).from`"
      },
      {
        "user": "mhegazy",
        "created_at": "2017-05-08T19:46:37Z",
        "body": "not sure what you mean by `transpile`..\r\n\r\nthe generated code is the same semantically, it just happens that on ES6 engine, your class has a static `from` method that it got from the base `Array`, on an ES3 engine, that is not the same..\r\n\r\nin both cases, your new function goes not get to execute."
      }
    ]
  },
  {
    "number": 15264,
    "title": "No --target es2016 support on VS2017?",
    "created_at": "2017-04-19T05:31:15Z",
    "closed_at": "2017-04-19T08:41:20Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/15264",
    "body": "**TypeScript Version:**  2.1.5.0 (VS2017)\r\n\r\n**Code**\r\n\r\n```xml\r\n  <PropertyGroup Label=\"Configuration\" Condition=\"'$(Configuration)|$(Platform)'=='Release|AnyCPU'\">\r\n    <TypeScriptTarget>ES2016</TypeScriptTarget>\r\n    <TypeScriptNoImplicitAny>true</TypeScriptNoImplicitAny>\r\n    <TypeScriptOutFile>js/app.js</TypeScriptOutFile>\r\n  </PropertyGroup>\r\n```\r\n\r\n**Expected behavior:**\r\n\r\nIt should compile\r\n\r\n**Actual behavior:**\r\n\r\n`Build:Cannot find name '(every type in lib.d.ts e.g. Document)'`",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/15264/comments",
    "author": "saschanaz",
    "comments": [
      {
        "user": "DanielRosenwasser",
        "created_at": "2017-04-19T07:45:51Z",
        "body": "I think this is related to #14401. Can you try adding `\"lib\": [\"es2016\", \"dom\"]`?"
      }
    ]
  },
  {
    "number": 15263,
    "title": "Typing static class",
    "created_at": "2017-04-19T02:11:56Z",
    "closed_at": "2017-04-19T03:31:02Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/15263",
    "body": "**TypeScript Version:**  2.2.1\r\n\r\n**Code**\r\n\r\n```ts\r\nimport { Component, DebugElement, Type } from '@angular/core';\r\nimport { ComponentFixture, TestBed } from '@angular/core/testing';\r\n\r\ninterface TestFixture<T> {\r\n  component: T;\r\n  debugElement: DebugElement;\r\n  element: any;\r\n  fixture: ComponentFixture<T>;\r\n}\r\n\r\nexport function createComponent<T>(TestBed: Static<TestBed>, cmpt: Type<T>): TestFixture<T> {\r\n  const fixture = TestBed.createComponent(cmpt);\r\n  const component = fixture.componentInstance;\r\n  const debugElement = fixture.debugElement;\r\n  const element = fixture.nativeElement;\r\n\r\n  return { component, debugElement, element, fixture };\r\n}\r\n```\r\n\r\n**Expected behavior:**\r\n\r\nI propose that we have a good way of typing a static class value in a function argument - in this example, this prevents me from accurately typing `fixture`, `component`, `debugElement`, and `element` without force casting since TypeScript does not appear to support typing static instances.\r\n\r\nIn my example, I am proposing that a syntax such as `Static<TestBed>` represent the static class `TestBed`, which is not meant to be newed.\r\n\r\n**Actual behavior:**\r\n\r\nI get errors such as\r\n```\r\nTS2345: Argument of type 'typeof TestBed' is not assignable to parameter of type 'TestBed'\r\n```",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/15263/comments",
    "author": "wesleycho",
    "comments": [
      {
        "user": "aluanhaddad",
        "created_at": "2017-04-19T02:32:05Z",
        "body": "> In my example, I am proposing that a syntax such as Static<TestBed> represent the static class TestBed, which is not meant to be newed.\r\n\r\nThere is such syntax already:\r\n```ts\r\ninterface TestBed {\r\n  createComponent<T extends new (...args:{}[]) => {})>(Component: T): Fixture;\r\n}\r\ninterface Fixture {...}\r\n```\r\n> TypeScript does not appear to support typing static instances.\r\n\r\nMaybe I misunderstand, but what is a static instance? Everything is just an object, even a class which is why the interface declaration above will work."
      },
      {
        "user": "wesleycho",
        "created_at": "2017-04-19T03:31:02Z",
        "body": "TestBed is not something I own - it is something that the Angular team provides with static methods on the class itself.\r\n\r\nLooks like the answer was to use `typeof TestBed` in this instance though.\r\n\r\nClosing as this appears to have a good enough solution for my case."
      },
      {
        "user": "aluanhaddad",
        "created_at": "2017-04-19T07:01:41Z",
        "body": "@wesleycho that doesn't mean you can't declare a type for it. Just use another name.\r\n\r\nThat said, I think using `typeof` is the right solution here but I wanted to explain how the specific feature requested is already provided so that you could employ it whenever you might need to. I feel like there's a fair amount of confusion around classes."
      }
    ]
  },
  {
    "number": 15215,
    "title": "Performance request/question: direct use of \"arguments\" variable inside a function ",
    "created_at": "2017-04-17T06:24:03Z",
    "closed_at": "2017-04-17T06:57:53Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/15215",
    "body": "**TypeScript Version:**  2.2.2, Linux Ubuntu 16.04 x86_64.\r\n\r\nI find it depressing that I cannot use the arguments variable somehow directly, that I have to see TypeScript creating a horrible duplication of memory, and waste of time. I think/wish/dream we should be able to use \"...arguments\" so that the generated javascript can just use \"arguments\" directly.\r\n\r\nI think I want something like:\r\n\r\n```ts\r\nfunction foo(...arguments) {\r\n   console.log( arguments[0] ); // TS2396\r\n}\r\n```\r\n\r\nso I have to do something like:\r\n\r\n```ts\r\nfunction foo(...args) {\r\n   console.log( args[0] ); // ok\r\n}\r\n```\r\n\r\nbut it generates depressing overhead in the final js:\r\n\r\n```js\r\n// the generated js \r\n    var args = [];\r\n    for (var _i = 0; _i < arguments.length; _i++) {\r\n        args[_i] = arguments[_i];\r\n    }\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/15215/comments",
    "author": "raould",
    "comments": [
      {
        "user": "ikatyang",
        "created_at": "2017-04-17T06:51:26Z",
        "body": "Default target is `es5` which cannot use `...`, you have to set `es6` or above\r\n\r\nCLI\r\n\r\n```sh\r\ntsc test.ts --target es6\r\n```\r\n\r\nor using `tsconfig.json`:\r\n\r\n```json\r\n{\r\n    \"compilerOptions\": {\r\n        \"target\": \"es6\"\r\n    }\r\n}\r\n\r\n```\r\ntest.ts\r\n```ts\r\nfunction foo(...args) {\r\n   console.log( args[0] ); // ok\r\n}\r\n```\r\n\r\ntest.js\r\n```js\r\nfunction foo(...args) {\r\n    console.log(args[0]); // ok\r\n}\r\n```"
      }
    ]
  },
  {
    "number": 15025,
    "title": "Inexplicable behavior",
    "created_at": "2017-04-05T14:54:28Z",
    "closed_at": "2017-04-05T15:32:08Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/15025",
    "body": "**Example 1**\r\n\r\n```ts\r\nclass foo {\r\n  readonly 1 // the same with private and static\r\n}\r\n```\r\n\r\n**Error**\r\n\r\nNo\r\n\r\n**Result**:\r\n\r\n```js\r\nvar foo = (function () {\r\n    function foo() {\r\n    }\r\n    return foo;\r\n}());\r\n\r\n```\r\n\r\n**Example 2**\r\n\r\n```ts\r\nclass foo {\r\n  const a () {} \r\n}\r\n```\r\n\r\n**Error**\r\n\r\n```\r\nError:(2, 9) TS1248:A class member cannot have the 'const' keyword.\r\n```\r\n\r\n**Result**:\r\n\r\n```js\r\nvar foo = (function () {\r\n    function foo() {\r\n    }\r\n    foo.prototype.a = function () { };\r\n    return foo;\r\n}());\r\n```\r\n\r\nIs it ok?\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/15025/comments",
    "author": "monolithed",
    "comments": [
      {
        "user": "ghost",
        "created_at": "2017-04-05T15:04:07Z",
        "body": "**Example 1**:\r\nIt might help clarify to turn on `\"noImplicitAny\": true,` in your tsconfig. `1` is the *key* of the property there, and the type is omitted.\r\nProperty declarations have no effect on emit (unless they have an initializer).\r\nFYI `readonly 1 = 2;` is totally valid code. Then `new foo()[1]` will be `2`.\r\n\r\n**Example 2**:\r\n`const` isn't allowed on a method (this ain't C++), so TypeScript correctly gave you an error here.\r\nTS will still have a best-guess emit even after an error; in this case it simply ignores `const`."
      }
    ]
  },
  {
    "number": 14763,
    "title": "Readonly tuple function",
    "created_at": "2017-03-21T13:24:08Z",
    "closed_at": "2017-03-21T15:34:18Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/14763",
    "body": "I want to create a function that returns a tuple with literal types.\r\n\r\nHere is what I got with TS 2.2:\r\n\r\n``` ts\r\nconst tuple2 = <A, B>(tuple: Readonly<[A, B]>): Readonly<[A, B]> => tuple\r\ntuple2(['foo', 'bar']) // actual Readonly<[string, string]>, expected Readonly<['foo', 'bar']>\r\n```\r\n\r\nIs there any way to make this return literal types?",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/14763/comments",
    "author": "OliverJAsh",
    "comments": [
      {
        "user": "zpdDG4gta8XKpMCd",
        "created_at": "2017-03-21T13:49:58Z",
        "body": "```typescript\r\nconst tuple2 = <A extends string, B extends string>(tuple: Readonly<[A, B]>): Readonly<[A, B]> => tuple\r\ntuple2(['foo', 'bar']) // Readonly<['foo', 'bar']>\r\n```"
      },
      {
        "user": "gcnew",
        "created_at": "2017-03-21T15:23:58Z",
        "body": "I've defined a `Literal` type alias. This way the function can accept all literal values and treat them as such.\r\n\r\n```ts\r\ntype Literal = boolean | string | number | null | undefined | object;\r\n\r\nfunction pair<L extends Literal, R extends Literal>(l: L, r: R): [L, R] {\r\n    return [l, r]\r\n}\r\n\r\npair(1, 'hello');            // [1, 'hello']\r\npair(true, false);           // [true, false]\r\npair([1, 2, 3], { a: 'a' })  // [number[], { a: string }]\r\npair(/test/, 'value')        // [RegExp, 'value']\r\npair(null, undefined)        // [null, undefined]\r\n```\r\n"
      }
    ]
  },
  {
    "number": 14687,
    "title": "TS2300: Duplicate identifier",
    "created_at": "2017-03-16T13:22:43Z",
    "closed_at": "2017-04-21T16:30:50Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/14687",
    "body": "**TypeScript Version:**  2.2.1\r\n\r\n```\r\n{\r\n\t\"compilerOptions\": {\r\n\t\t\"typeRoots\": [\r\n\t\t\t\"./node_modules/@types\",\r\n\t\t\t\"./types\"\r\n\t\t],\r\n\r\n\t\t\"outDir\": \"cache/\",\r\n\r\n\t\t\"types\": [\r\n\t\t\t\"debug\",\r\n\t\t\t\"deepmerge\",\r\n\t\t\t\"imap\",\r\n\t\t\t\"faker\",\r\n\t\t\t\"minimist\",\r\n\t\t\t\"mocha\",\r\n\t\t\t\"nodemailer\",\r\n\t\t\t\"node\",\r\n\t\t\t\"request\",\r\n\t\t\t\"webdriverio\"\r\n\t\t],\r\n\r\n\t\t\"lib\": [\r\n\t\t\t\"es2017\",\r\n\t\t\t\"scripthost\",\r\n\t\t\t\"webworker\",\r\n\t\t\t\"dom\"\r\n\t\t],\r\n\r\n\t\t\"target\": \"es2017\",\r\n\t\t\"module\": \"commonjs\",\r\n\t\t\"moduleResolution\": \"node\",\r\n\t\t\"noImplicitAny\": false,\r\n\r\n\t\t\"declaration\": false,\r\n\t\t\"allowJs\": true,\r\n\r\n\t\t\"emitDecoratorMetadata\": true,\r\n\t\t\"experimentalDecorators\": true,\r\n\t\t\"sourceMap\": true\r\n\t},\r\n\r\n\t\"exclude\": [\r\n\t\t\"./config.js\",\r\n\t\t\"./config.local.js\",\r\n\t\t\"./node_modules\",\r\n\t\t\"./utils\",\r\n\t\t\"./tasks\",\r\n\t\t\"./files\",\r\n\t\t\"./cache\"\r\n\t]\r\n}\r\n```\r\n\r\n```\r\n\u279c tsc\r\n/usr/local/lib/node_modules/typescript/lib/lib.dom.d.ts(14171,14): error TS2300: Duplicate identifier 'EventListenerOrEventListenerObject'.\r\n/usr/local/lib/node_modules/typescript/lib/lib.dom.d.ts(14897,6): error TS2300: Duplicate identifier 'AlgorithmIdentifier'.\r\n/usr/local/lib/node_modules/typescript/lib/lib.dom.d.ts(14898,6): error TS2300: Duplicate identifier 'BodyInit'.\r\n/usr/local/lib/node_modules/typescript/lib/lib.dom.d.ts(14920,6): error TS2300: Duplicate identifier 'IDBKeyPath'.\r\n/usr/local/lib/node_modules/typescript/lib/lib.dom.d.ts(14929,6): error TS2300: Duplicate identifier 'RequestInfo'.\r\n/usr/local/lib/node_modules/typescript/lib/lib.dom.d.ts(14930,6): error TS2300: Duplicate identifier 'USVString'.\r\n/usr/local/lib/node_modules/typescript/lib/lib.dom.d.ts(14934,6): error TS2300: Duplicate identifier 'IDBValidKey'.\r\n/usr/local/lib/node_modules/typescript/lib/lib.dom.d.ts(14935,6): error TS2300: Duplicate identifier 'BufferSource'.\r\n/usr/local/lib/node_modules/typescript/lib/lib.webworker.d.ts(72,5): error TS2403: Subsequent variable declarations must have the same type.  Variable 'source' must be of type 'Window', but here has type 'any'.\r\n/usr/local/lib/node_modules/typescript/lib/lib.webworker.d.ts(367,5): error TS2375: Duplicate number index signature.\r\n/usr/local/lib/node_modules/typescript/lib/lib.webworker.d.ts(398,14): error TS2403: Subsequent variable declarations must have the same type.  Variable 'srcElement' must be of type 'Element', but here has type 'any'.\r\n/usr/local/lib/node_modules/typescript/lib/lib.webworker.d.ts(446,5): error TS2375: Duplicate number index signature.\r\n/usr/local/lib/node_modules/typescript/lib/lib.webworker.d.ts(715,14): error TS2403: Subsequent variable declarations must have the same type.  Variable 'source' must be of type 'Window', but here has type 'any'.\r\n/usr/local/lib/node_modules/typescript/lib/lib.webworker.d.ts(1096,14): error TS2403: Subsequent variable declarations must have the same type.  Variable 'responseXML' must be of type 'Document', but here has type 'any'.\r\n/usr/local/lib/node_modules/typescript/lib/lib.webworker.d.ts(1684,14): error TS2300: Duplicate identifier 'EventListenerOrEventListenerObject'.\r\n/usr/local/lib/node_modules/typescript/lib/lib.webworker.d.ts(1710,13): error TS2403: Subsequent variable declarations must have the same type.  Variable 'onmessage' must be of type '(this: Window, ev: MessageEvent) => any', but here has type '(this: DedicatedWorkerGlobalScope, ev: MessageEvent) => any'.\r\n/usr/local/lib/node_modules/typescript/lib/lib.webworker.d.ts(1715,13): error TS2403: Subsequent variable declarations must have the same type.  Variable 'location' must be of type 'Location', but here has type 'WorkerLocation'.\r\n/usr/local/lib/node_modules/typescript/lib/lib.webworker.d.ts(1716,13): error TS2403: Subsequent variable declarations must have the same type.  Variable 'onerror' must be of type 'ErrorEventHandler', but here has type '(this: DedicatedWorkerGlobalScope, ev: ErrorEvent) => any'.\r\n/usr/local/lib/node_modules/typescript/lib/lib.webworker.d.ts(1718,13): error TS2403: Subsequent variable declarations must have the same type.  Variable 'self' must be of type 'Window', but here has type 'WorkerGlobalScope'.\r\n/usr/local/lib/node_modules/typescript/lib/lib.webworker.d.ts(1724,13): error TS2403: Subsequent variable declarations must have the same type.  Variable 'navigator' must be of type 'Navigator', but here has type 'WorkerNavigator'.\r\n/usr/local/lib/node_modules/typescript/lib/lib.webworker.d.ts(1743,6): error TS2300: Duplicate identifier 'AlgorithmIdentifier'.\r\n/usr/local/lib/node_modules/typescript/lib/lib.webworker.d.ts(1744,6): error TS2300: Duplicate identifier 'BodyInit'.\r\n/usr/local/lib/node_modules/typescript/lib/lib.webworker.d.ts(1745,6): error TS2300: Duplicate identifier 'IDBKeyPath'.\r\n/usr/local/lib/node_modules/typescript/lib/lib.webworker.d.ts(1746,6): error TS2300: Duplicate identifier 'RequestInfo'.\r\n/usr/local/lib/node_modules/typescript/lib/lib.webworker.d.ts(1747,6): error TS2300: Duplicate identifier 'USVString'.\r\n/usr/local/lib/node_modules/typescript/lib/lib.webworker.d.ts(1748,6): error TS2300: Duplicate identifier 'IDBValidKey'.\r\n/usr/local/lib/node_modules/typescript/lib/lib.webworker.d.ts(1749,6): error TS2300: Duplicate identifier 'BufferSource'.\r\n```\r\n\r\nI see these errors with `lib.webworker`",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/14687/comments",
    "author": "monolithed",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2017-03-16T15:26:10Z",
        "body": "You can't target `webworker` and `dom` at the same time -- these are mutually exclusive, and have different types for certain global variables. You'll need two separate compilations, one for the code which runs in your webworker threads, and one for code which runs in the DOM"
      },
      {
        "user": "monolithed",
        "created_at": "2017-03-16T20:14:59Z",
        "body": "```\r\n/usr/local/lib/node_modules/typescript/lib/lib.dom.d.ts(14171,14): error TS2300: Duplicate identifier 'EventListenerOrEventListenerObject'.\r\n```\r\n\r\nUsually such error messages are not informative. It would be nice to print something like:\r\n\r\n> You can't target webworker and dom at the same time -- these are mutually exclusive, and have different types for certain global variables. You'll need two separate compilations, one for the code which runs in your webworker threads, and one for code which runs in the DOM\r\n\r\n\ud83d\ude09"
      }
    ]
  },
  {
    "number": 14650,
    "title": "When using the native method 'defineProperty ' to define a 'Getter' for a class, the compiler error!",
    "created_at": "2017-03-14T11:31:17Z",
    "closed_at": "2017-04-21T16:40:50Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/14650",
    "body": "**TypeScript Version:**  1.8.0\r\n\r\n**Code:**\r\n\r\n```ts\r\n// a function used to define targetObject's descriptor from SourceObject's properties\r\n\r\nfunction defineGetter(SourceObject, targetObject) {\r\n    \r\n    Object.keys(SourceObject).forEach(function (key) {\r\n        Object.defineProperty(targetObject.prototype, key, {\r\n            get: function () {\r\n                return SourceObject[key]\r\n            },\r\n            enumerable: true,\r\n            configurable: true\r\n        })\r\n    })\r\n}\r\n\r\ninterface IForm {\r\n    name: string;\r\n    label: string;\r\n    value: any;\r\n    sequence: number;\r\n    width: number;\r\n    type: number;\r\n}\r\n\r\n\r\nclass Form {\r\n    constructor(form: IForm) {\r\n        defineGetter(form, Form);\r\n    }\r\n    get info() {\r\n        return `name is ${this.name}, label is ${this.label}`;\r\n    }\r\n}\r\n\r\nlet form = new Form({\r\n       name: '1',\r\n       label: '2',\r\n       value: 3,\r\n       sequence: 4,\r\n       width: 5,\r\n       type: 6\r\n})\r\n```\r\n\r\n\r\n\r\n**Expected behavior & Actual behavior:**\r\nI want to complete my definition of **Getter** with metadata(a Singleton Object) through a **defineGetter ()** method, It seems to be successful. but, When I manually define another Getter (info), the compiler prompts\uff1a\r\n\r\n> \u201c error TS2339: Property 'name' does not exist on type 'Form'\u201d\r\n> \u201c  error TS2339: Property 'type' does not exist on type 'Form'. \u201d\r\n\r\nI just want to use a function to solve my burden of writing the getter repeatedly\uff0cHow can I solve this problem?\r\n\r\n\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/14650/comments",
    "author": "ulivz",
    "comments": [
      {
        "user": "ulivz",
        "created_at": "2017-03-14T12:05:39Z",
        "body": "How can I only write a class in this way \ud83d\ude10:\r\n```ts\r\nclass Form{\r\n\r\n    private _form: IForm;\r\n\r\n    constructor(form: IForm) {\r\n        this._form = form;\r\n    }\r\n\r\n    get name() {\r\n        return this._form.name;\r\n    }\r\n\r\n    get label() {\r\n        return this._form.name;\r\n    }\r\n\r\n    get value() {\r\n        return this._form.value;\r\n    }\r\n    \r\n    get width() {\r\n        return this._form.width;\r\n    }\r\n    \r\n    get type() {\r\n        return this._form.type;\r\n    }\r\n    \r\n    get sequence() {\r\n        return this._form.sequence;\r\n    }\r\n\r\n    // extra getter\r\n    get info() {\r\n        return this.width + this.type;\r\n    }\r\n\r\n}\r\n```"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2017-03-14T18:13:57Z",
        "body": "Write this:\r\n```ts\r\nclass Form {\r\n    constructor(form: IForm) {\r\n        defineGetter(form, Form);\r\n    }\r\n    get info() {\r\n        return `name is ${this.name}, label is ${this.label}`;\r\n    }\r\n}\r\ninterface Form extends IForm { }\r\n```"
      },
      {
        "user": "kitsonk",
        "created_at": "2017-03-15T10:07:21Z",
        "body": "> Can the name of interface and class be the same name?\r\n\r\nIt takes advantage of what TypeScript calls \"interface merging\".  When an interface and a class have the same name, it automatically merges the two.  This is in part why it is often recommended not to name your interfaces with an `I...` which is a convention in many other languages, since there some \"automagic\" that can happen when the names are the same.\r\n\r\nIt is best to think as the type system in TypeScript as an \"overlay\" on top of the underlying JavaScript.\r\n\r\nAlso to properly type your interface, you should be marking properties that only have a getter as `readonly` in the interface, which will disallow assignment to the properties within the type system, which would more accurately reflect your runtime intent."
      }
    ]
  },
  {
    "number": 14627,
    "title": "how can i type-annotate a function that creates an object literal out of a literal key and a value?",
    "created_at": "2017-03-13T11:38:44Z",
    "closed_at": "2017-03-13T15:56:49Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/14627",
    "body": "i have\r\n```typescript\r\nconst key: 'name' = 'name';\r\nconst value: number = 1;\r\n```\r\n\r\ni need a function that turns these key/value into an object with a property, in JavaScript it would look like:\r\n```javascript\r\n// javascript\r\nfunction(key, value) {\r\n    return { [key]: value };\r\n}\r\n```\r\n\r\nso that:\r\n```typescript\r\nconst data = fn(key, value);\r\n// data is expected to be of type: { name: number; }\r\n```\r\n\r\nis there a way to type-annotate `fn` so that it returns an object of type `{ name: number; }`? if so, how?\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/14627/comments",
    "author": "zpdDG4gta8XKpMCd",
    "comments": [
      {
        "user": "gcanti",
        "created_at": "2017-03-13T14:07:50Z",
        "body": "```ts\r\nfunction fn<K extends string, V>(key: K, value: V): { [k in K]: V } {\r\n  return { [key as any]: value } as any\r\n}\r\n```"
      }
    ]
  },
  {
    "number": 14608,
    "title": "Unable to parameterize keyof (in function) to access object's fields",
    "created_at": "2017-03-12T13:05:47Z",
    "closed_at": "2017-03-12T17:17:39Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/14608",
    "body": "I'm having problems understanding how to parameterize **keyof**. I have extracted a simple code that describes the issue I'm facing.\r\n\r\n```ts\r\ninterface INested3 {\r\n    id: number;\r\n    name: string;\r\n}\r\n\r\ninterface INested2a {\r\n    id: number;\r\n    name: string;\r\n    nested3: INested3;\r\n}\r\n\r\ninterface INested2b {\r\n    id: number;\r\n    name: string;\r\n    nested3: INested3;\r\n}\r\n\r\ninterface INested1 {\r\n    id: number;\r\n    name: string;\r\n    nested2a: INested2a;\r\n    nested2b: INested2b;\r\n}\r\n\r\ninterface IFoo {\r\n    id: number;\r\n    name: string;\r\n    nested1: INested1;\r\n}\r\n\r\nfunction get<T, K1 extends keyof T, K2 extends keyof T[K1], K3 extends keyof T[K1][K2]>(obj: T, key1: K1, key2: K2, key3: K3): T[K1][K2][K3] {\r\n    return obj[key1][key2][key3];\r\n}\r\n\r\n// Fine\r\nfunction foo1a(f: IFoo): void {\r\n    console.log(\r\n        get(f, \"nested1\", \"nested2a\", \"nested3\")\r\n    );\r\n}\r\n\r\nfunction foo1b(f: IFoo): void {\r\n    console.log(\r\n        get(f, \"nested1\", \"nested2b\", \"nested3\")\r\n    );\r\n}\r\n\r\n// Not fine - why?\r\n// Argument of type '\"nested3\"' is not assignable to parameter of type '\"toString\" | \"valueOf\"'.\r\nfunction foo1param(f: IFoo, nested2key: keyof INested1): void {\r\n    console.log(\r\n        get(f, \"nested1\", nested2key, \"nested3\")\r\n    )\r\n}\r\n\r\nvar f: IFoo = {\r\n    id: 1,\r\n    name: \"Foo\",\r\n    nested1: {\r\n        id: 1,\r\n        name: \"Nested 1\",\r\n        nested2a: {\r\n            id: 1,\r\n            name: \"Nested 2A\",\r\n            nested3: {\r\n                id: 1,\r\n                name: \"Nested 3\",\r\n            }\r\n        },\r\n        nested2b: {\r\n            id: 1,\r\n            name: \"Nested 2B\",\r\n            nested3: {\r\n                id: 2,\r\n                name: \"Nested 3\",\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// Would like to use it like this\r\nfoo1param(f, \"nested2a\");\r\nfoo1param(f, \"nested2b\");\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/14608/comments",
    "author": "vladimir-djokic",
    "comments": [
      {
        "user": "ahejlsberg",
        "created_at": "2017-03-12T17:11:54Z",
        "body": "In your example, `keyof INested1` is equivalent to `\"id\" | \"name\" | \"nested2a\" | \"nested2b\"` (the full set of property names for `INested1`). You need to restrict it to just `\"nested2a\" | \"nested2b\"`:\r\n\r\n```ts\r\nfunction foo1param(f: IFoo, nested2key: \"nested2a\" | \"nested2b\"): void { ... }\r\n```\r\n\r\nOnce you do that your example works."
      }
    ]
  },
  {
    "number": 14352,
    "title": "String not assignable to string enum even when value is known at compile time and is part of the enum.",
    "created_at": "2017-02-28T03:27:45Z",
    "closed_at": "2017-03-01T04:02:00Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/14352",
    "body": "Typescript@2.1.6\r\n\r\nHere's an example:\r\n\r\n```\r\ninterface Test {\r\n    fun(opts: {foo: 'enum1' | 'enum2'}): void\r\n}\r\n\r\nconst bar: Test = {\r\n    fun: (opts) => { }\r\n}\r\n\r\nconst defaults = {\r\n    foo: 'enum1'\r\n};\r\n\r\nbar.fun(defaults) // Error: Type 'string' is not assignable to type '\"enum1\" | \"enum2\"'\r\n```\r\n\r\nShouldn't `defaults.foo` be inferred to be a subset of the string enum?",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/14352/comments",
    "author": "realyze",
    "comments": [
      {
        "user": "realyze",
        "created_at": "2017-02-28T03:28:35Z",
        "body": "FWIW, `bar.fun({foo: 'enum1'})` compiles OK."
      },
      {
        "user": "realyze",
        "created_at": "2017-02-28T03:30:34Z",
        "body": "I would suggest `defaults` type to be inferred as `{ foo: string & 'enum1' }` rather than `string`."
      },
      {
        "user": "Jessidhia",
        "created_at": "2017-02-28T04:39:12Z",
        "body": "Note that `defaults.foo` is mutable, so the inferred type has to be `string`; otherwise it would prevent you from ever mutating it. Using `&` is even more dangerous as, if you _did_ mutate it, the `& 'enum1'` part of the type would make its type be `'enum1'` even if it was any other value.\r\n\r\nYou probably want something similar to this, probably with an `interface` or `type` alias to avoid repetition:\r\n\r\n```ts\r\nconst defaults: { foo: 'enum1' | 'enum2' } = {\r\n  foo: 'enum1'\r\n}\r\n```"
      },
      {
        "user": "ubershmekel",
        "created_at": "2017-08-14T23:48:36Z",
        "body": "Going to leave the answer to my case here because google brought me to this issue:\r\n\r\n    import * as isomorphicFetch from \"isomorphic-fetch\";\r\n    const fetchOptions: isomorphicFetch.RequestInit = {\r\n        method: \"POST\",\r\n        body: JSON.stringify(body),\r\n        headers: headers,\r\n        // required for cookies in ajax\r\n        \"credentials\": \"include\",\r\n    };\r\n    let response = await isomorphicFetch(url, fetchOptions);\r\n\r\nCaused this error:\r\n\r\n```\r\nfile: 'file:///Users/backend/packages/nuxt-typescript/lib/api.ts'\r\nseverity: 'Error'\r\nmessage: 'Argument of type '{ method: string; headers: { \"Content-Type\": string; }; \"credentials\": string; }' is not assignable to parameter of type 'RequestInit | undefined'.\r\n  Type '{ method: string; headers: { \"Content-Type\": string; }; \"credentials\": string; }' is not assignable to type 'RequestInit'.\r\n    Types of property 'credentials' are incompatible.\r\n      Type 'string' is not assignable to type '\"include\" | \"omit\" | \"same-origin\" | undefined'.'\r\nat: '120,51'\r\nsource: 'ts'\r\n```\r\n\r\nSolved by:\r\n\r\n    let fetchOptions: RequestInit = {\r\n\r\n"
      },
      {
        "user": "ZelphirKaltstahl",
        "created_at": "2017-12-22T10:58:21Z",
        "body": "It seems like `tsc` does not consider `string`s like `\"cors\"` or `\"default\"` to be of the types `RequestMode` or `RequestCache`, unless one adds the type declaration as @ubershmekel did in their answer."
      }
    ]
  },
  {
    "number": 14321,
    "title": "locally modifying+testing published definitions is a pain (bug/rant/perhaps-question)",
    "created_at": "2017-02-26T19:56:07Z",
    "closed_at": "2017-04-21T13:50:25Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/14321",
    "body": "the ```@types``` process is pretty great for consuming .d.ts files (much better than the previous typings or tsd workflows)   \r\n\r\nhowever, I seem to have a big problem as a creator of ```.d.ts``` for publication.    I don't see any way of creating a .d.ts file for local use and testing, and then be able to then publish the file as-is.   \r\n\r\nFor example, if this is a definition I publish to DT:  \r\n\r\n```foo/index.d.ts```:\r\n`\r\ndeclare namespace Foo{ export function foo():void; }\r\nexport = Foo;\r\nexport as namespace Foo;\r\n`\r\n\r\nand usage:\r\n`\r\nimport foo = require(\"foo\");\r\n`\r\n\r\n\r\nHow would I consume my own definitions for ```foo``` locally?  I don't see how to do this with the normal import style.  instead I need to modify my d.ts and consumption usage like:\r\n\r\n```myProject/_dts/foo.ts```\r\n`\r\nexport declare namespace _foo{ export function foo():void; }\r\nexport const Foo: typeof _foo = require(\"foo\");\r\n`\r\nand usage:\r\n`\r\nimport foo = require(\"./_dts/foo\");\r\n`\r\n\r\nBasically this means that I can't easily test and/or modify a definition that I want to share publically, which adds a lot of friction for re-contributing to the community.   Am I doing something wrong?  Is there an easy way to modify and locally reference a published type?\r\n\r\n\r\n\r\n**Note**: I don't know if i'm doing it wrong these days, so please correct my understanding if you see problems with my logic above.\r\n\r\n\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/14321/comments",
    "author": "jasonswearingen",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2017-02-27T21:49:02Z",
        "body": "> How would I consume my own definitions for foo locally? I don't see how to do this with the normal import style. instead I need to modify my d.ts and consumption usage like:\r\n\r\nLet's say you want to write defintions for `foo`, which is a module:\r\n- under your app: `src\\extra-types\\foo`, create `index.d.ts` that has your declaration as noted above (along with tsconfig.json, tslint.json, and tests for DT if you want). \r\n- in your `tsconfig.json` add a path mapping rule: \r\n ```js\r\n{\r\n     ...\r\n    \"paths\": {\r\n       \"foo\" : [\"src/extra-types/foo\"]\r\n    }\r\n}\r\n  ```\r\n  or if you have multiple:\r\n  ```js\r\n{\r\n     ...\r\n    \"paths\": {\r\n       \"*\" : [ \"*\", \"src/extra-types/*\"]\r\n    }\r\n}\r\n  ```\r\n- once you have published to DT, delete `src\\extra-types\\foo` and add `@types/foo`, no other changes should be required.\r\n"
      }
    ]
  },
  {
    "number": 13952,
    "title": "Local @types",
    "created_at": "2017-02-08T12:49:49Z",
    "closed_at": "2017-02-09T08:33:44Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/13952",
    "body": "Hi all,\r\n\r\nI'm developing 2 libraries `A` and `B` in different folders where `A` is exported as target es5 and module commonjs.\r\n\r\nIn `B` I'd like to use `index.d.ts` from `A` among other @types libraries which are in node_modules folder. And then use some classes from `A` via in import like this: `import {MyClass} from \"a\";`.\r\nUnfortunately this doesn't work: a not found in `node_modules/@types/a` etc.\r\nI tried without success with:\r\n \r\n```typescript\r\n\"baseUrl\": \".\",\r\n    \"paths\": {\r\n      \"a\": [\r\n        \"lib/a\"\r\n      ]\r\n    },\r\n```\r\n\r\nHow to setup typescript to find lib/a/index.d.ts without modifying my import with relative path (e.g. `import {MyClass} from \"../lib/a/index\";`)?\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/13952/comments",
    "author": "sternbel",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2017-02-08T18:55:57Z",
        "body": "The target in the \"paths\" list is relative to `\"baseUrl\"`. so your \"paths\" here says `\"a\" => \"./lib/a\"` so you either want to set the `\"baseUrl\"` to `\"../\"` or set the target to `\"../lib/a\"`.\r\n\r\n```ts\r\n{\r\n    \"compilerOptions\": {\r\n        \"module\": \"commonjs\",\r\n        \"target\": \"es5\",\r\n        \"baseUrl\": \"./\",\r\n        \"paths\": {\r\n            \"a\" : [\"../lib/a/index.d.ts\"]\r\n        }\r\n    }\r\n}\r\n```"
      }
    ]
  },
  {
    "number": 13907,
    "title": "Avoid \"cannot assign an abstract constructor ...\" through union type",
    "created_at": "2017-02-06T20:28:23Z",
    "closed_at": "2017-04-21T16:55:52Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/13907",
    "body": "I have this code in TS 2.1:\r\n```ts\r\nabstract class Test { _brand: string; }\r\n\r\nfunction test1<T>(arg: { new(): T }): T { return null!; }\r\nfunction test2<T>(arg: { new(): T } | Function): T { return null!; }\r\n\r\nconst a = test1(Test);\r\nconst b = test2(Test);\r\n```\r\nAs discussed in #5843, `test1` is not supposed to typecheck. However, surprisingly, `test2` does.\r\nTypeScript infers `T` for `a` and `Test` for `b`.\r\nI don't know whether this is intended - can I build upon that behavior?",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/13907/comments",
    "author": "hediet",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2017-02-06T22:06:05Z",
        "body": "The type `{ new(): T } | Function` is equivalent to `Function` because `{ new(): T }` is assignable to `Function` (the same way the type `Dog | Animal` is equivalent to `Animal`). We call this \"subtype reduction\" and in general it's really bad to write down a type that undergoes immediate reduction (we probably should have made this an error when we made union types, but too late now).\r\n\r\nMost of the time when people write `Function` the actual type they want is `(...args: any[]) => any)`:\r\n```ts\r\n`function test2<T>(arg: { new(): T } | ((...args: any[]) => any) ): T { return null!; }\r\n\r\nconst b = test2(Test); // Error\r\n```"
      },
      {
        "user": "hediet",
        "created_at": "2017-02-06T22:34:02Z",
        "body": "Thanks for your answer!\r\nBut still, the type of the expression `test2(Test)` infers to `Test`. If `{ new():T } | Function` is actually equivalent to `Function`, TypeScript should have inferred `any`, as it does for `test3(Test)` in\r\n```ts\r\nfunction test3<T>(arg: Function): T { return null!; }\r\n```\r\nHowever, I like TypeScripts current inference behavior as it solves #5843. I need this for my remoting library that instantiates abstract classes (which need to be classes so they can be decorated with metadata)."
      }
    ]
  },
  {
    "number": 13861,
    "title": "Unsafe coercion from \"any type\" to {}",
    "created_at": "2017-02-03T10:32:00Z",
    "closed_at": "2017-02-03T18:57:18Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/13861",
    "body": "**TypeScript Version:**  2.1.5 and 2.2.0-dev.20170201\r\nUsing --noImplicitAny and --strictNullChecks\r\n\r\n**Code**\r\n\r\n```ts\r\nfunction doItWithAnObject<A extends {}>(a: A) {\r\n  a.toString()\r\n}\r\n\r\nfunction doItWithAnything<B>(b: B) {\r\n  doItWithAnObject(b)\r\n}\r\n\r\ndoItWithAnything(null)\r\ndoItWithAnything(undefined)\r\n```\r\n\r\n**Expected behavior:**\r\n`doItWithAnything` should not compile because it calls `doItWithAnObject` with something that is potentially not an object.\r\n\r\n**Actual behavior:**\r\nNo compilation error. Runtime errors.\r\n\r\nPerhaps related: If I have an abstract type A, and I narrow it down to A minus null minus undefined, it isn't considered as an object.\r\n\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/13861/comments",
    "author": "AlexGalays",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2017-02-03T18:15:05Z",
        "body": "if you want to exclude `null` and `undefined`, give the generic type parameter a constraint for `{}`. if you want to further exclude primitives, give it a constraint `object`. otherwise, it goes to the top type, i.e. `{} | null | undefined`"
      },
      {
        "user": "ikokostya",
        "created_at": "2017-02-03T19:25:24Z",
        "body": "> if you want to exclude null and undefined, give the generic type parameter a constraint for {}\r\n\r\nBut it already done for `doItWithAnObject` function:\r\n\r\n```ts\r\nfunction doItWithAnObject<A extends {}>(a: A) {\r\n  a.toString();\r\n}\r\ndoItWithAnObject(null); // Error: Argument of type 'null' is not assignable to parameter of type '{}'\r\n```\r\n\r\nWhy compiler doesn't check this inside `doItWithAnything` function?\r\n\r\n```ts\r\nfunction doItWithAnything<B>(b: B) {\r\n  doItWithAnObject(b); // No errors, but argument \"b\" has \"null\" type here\r\n}\r\ndoItWithAnything(null);\r\n```"
      }
    ]
  },
  {
    "number": 13809,
    "title": "[request] allow namespaces to become types",
    "created_at": "2017-02-01T06:21:10Z",
    "closed_at": "2017-02-01T11:10:18Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/13809",
    "body": "How about allowing namespaces to become types?\r\n\r\ne.g.)\r\n\r\n```typescript\r\n// some declaration file I can't touch\r\ndeclare module monaco {   //this is monaco, not 'monaco'. so it's a namespace.\r\n   ...\r\n}\r\n\r\ntype _MonacoNamespaceType = ::monaco; // or any other syntax is fine.\r\n```\r\n--------------------------------\r\nbackground: I'm having problems trying to write d.ts file for react-monaco-editor.\r\n\r\nmonaco-editor's typescript definition has everything in ts namespaces, so I'm stuck trying to get 'monaco' as a type.\r\n\r\nhere's the definition file I'm working on:\r\n```typescript\r\n/// <reference path=\"../../node_modules/monaco-editor/monaco.d.ts\" />\r\n\r\n\r\ndeclare module 'react-monaco-editor' {\r\n  import { Component } from 'react';\r\n  export type ReactMonacoEditorProps = {\r\n    width: string,\r\n    height: string,\r\n    language: string,\r\n    options: monaco.editor.IEditorOptions,\r\n    editorDidMount?: (editor: monaco.editor.ICodeEditor, monaco: any) => any,\r\n  };\r\n  import test = monaco;\r\n  export type ICodeEditor = monaco.editor.ICodeEditor;\r\n  export default class ReactMonacoEditor\r\n      extends Component<ReactMonacoEditorProps, void> { }\r\n}\r\n```\r\nAs you can see on **editorDidMount?: (editor: monaco.editor.ICodeEditor, monaco: any) => any,**\r\nI couldn't give the 'monaco' type on monaco as 'monaco' namespace cannot be a type.",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/13809/comments",
    "author": "devdoomari",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2017-02-01T06:32:21Z",
        "body": "`typeof monaco` ?"
      }
    ]
  },
  {
    "number": 13581,
    "title": "tsc doesn't resolve module specified in the typeRoots",
    "created_at": "2017-01-19T18:17:36Z",
    "closed_at": "2017-04-21T16:56:05Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/13581",
    "body": "**TypeScript Version:**  2.1.5\r\n\r\nI have the following directory structure:\r\n```\r\ntsconfig.json\r\na.ts\r\nnode_modules\r\n|--- custom\r\n     |--- rembo\r\n           |---index.d.ts\r\n```\r\n\r\nThe content of `index.d.ts` is the following:\r\n```\r\nexport declare class Rembo {\r\n    name: string;\r\n}\r\n```\r\n\r\nI reference this module in `a.ts`:\r\n`import {Rembo} from 'rembo';`\r\n\r\nThe `package.json` is the following:\r\n```\r\n{\r\n  \"compilerOptions\": {\r\n    \"moduleResolution\": \"node\",\r\n    \"module\": \"es6\",\r\n    \"target\": \"es6\",\r\n    \"typeRoots\": [\r\n      \"node_modules/custom\"\r\n    ]\r\n  }\r\n}\r\n```\r\nThe problem is that `rembo` module can't be resolved. When compiled, I get the following result:\r\n\r\n`$ tsc --traceResolution`\r\n\r\n```\r\n======== Resolving type reference directive 'rembo', containing file 'D:/Projects/typescript/__inferred type names__.ts', root directory 'D:/Projects/typescript/node_modules/custom'. ========\r\nResolving with primary search path 'D:/Projects/typescript/node_modules/custom'\r\nFile 'D:/Projects/typescript/node_modules/custom/rembo/package.json' does not exist.\r\nFile 'D:/Projects/typescript/node_modules/custom/rembo/index.d.ts' exist - use it as a name resolution result.\r\nResolving real path for 'D:/Projects/typescript/node_modules/custom/rembo/index.d.ts', result 'D:/Projects/typescript/node_modules/custom/rembo/index.d.ts'\r\n======== Type reference directive 'rembo' was successfully resolved to 'D:/Projects/typescript/node_modules/custom/rembo/index.d.ts', primary: true. ========\r\na.ts(3,21): error TS2307: Cannot find module 'rembo'.\r\n```\r\n\r\nI don't understand why the error, since it reports then:\r\n\r\n> Type reference directive 'rembo' was **successfully** resolved to 'D:/Projects/typescript/node_modules/custom/rembo/index.d.ts', primary: true.\r\n\r\n\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/13581/comments",
    "author": "maxkoretskyi",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2017-01-19T22:49:50Z",
        "body": "TypeRoots is useful for global declarations, things that you do not `import`, e.g. node definition file. when the compiler starts it loads all files under `typeRoots` and adds them in the global scope.\r\n\r\nSeems like this is not what you are looking for, what you need is [Path mapping](www.typescriptlang.org/docs/handbook/module-resolution.html#path-mapping):\r\n\r\n```ts\r\n{\r\n  \"compilerOptions\": {\r\n    \"moduleResolution\": \"node\",\r\n    \"module\": \"es6\",\r\n    \"target\": \"es6\",\r\n    \"baseUrl\": \"./\",\r\n    \"paths\": {\r\n      \"*\" : [\"node_modules/custom/*\"]\r\n    }\r\n  }\r\n}\r\n```\r\n\r\nThis tells the compiler to look under `<baseUrl>/node_modules/custom` for any import it sees."
      },
      {
        "user": "gdamjan",
        "created_at": "2017-02-10T00:27:35Z",
        "body": "What if the node_modules including node_modules/@types are outside the source directory alltogether?\r\n\r\n```\r\nSRC=$HOME/Pojects/demo\r\nDEST=/tmp/build\r\n\r\nln -s $SRC/package.json $DEST/package.json\r\ncd $DEST\r\nnpm install\r\n\r\ncd $SRC\r\ntsc --outDir $DEST/build --typeRoots $DEST/???\r\n```\r\nthis doesn't work\r\n\r\n\r\n\r\n\r\n(ts 2.1.6)"
      },
      {
        "user": "mhegazy",
        "created_at": "2017-02-10T00:47:46Z",
        "body": "`paths` is relative to the `baseUrl` and not the `projectRoot`. so you can make the `baseUrl` whatever you want."
      }
    ]
  },
  {
    "number": 13530,
    "title": "Invoking methods from object iteration",
    "created_at": "2017-01-17T12:05:32Z",
    "closed_at": "2017-01-17T20:01:49Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/13530",
    "body": "**TypeScript Version:**  2.1.5\r\n\r\n**Code**\r\n\r\n```ts\r\nclass Params {\r\n\tpublic paramsInit () {\r\n\t\tfor ( let prop in this ) {\r\n\t\t\tif ( typeof this[ prop ] === 'function' ) {\r\n\t\t\t\tlet res = this[ prop ]();\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\nclass Test extends Params {\r\n\tconstructor () {\r\n\t\tsuper();\r\n\t\tthis.paramsInit();\r\n\t}\r\n\r\n\tpublic param1 (): void {\r\n\t\tconsole.log( 'param1' );\r\n\t}\r\n}\r\n```\r\n\r\n**Expected behavior:**\r\n\r\nIn TypeScript 2.0 the above compiles without any errors.\r\n\r\n**Actual behavior:**\r\n\r\nIn TypeScript 2.1.5 I get:\r\n\r\n> test.ts(5,15): error TS2349: Cannot invoke an expression whose type lacks a call signature. Type 'Params[keyof this]' has no compatible call signatures.\r\n\r\nI can see why tsc might not like invooking `this[ prop ]`, but I can't see any way to tell it that it is a valid function. I've tried using `as` in various combinations, but with no luck.\r\n\r\nIs there a way to get this to compile in 2.1 without errors?",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/13530/comments",
    "author": "DataTables",
    "comments": [
      {
        "user": "ahejlsberg",
        "created_at": "2017-01-17T14:33:46Z",
        "body": "This works:\r\n\r\n```ts\r\nclass Params {\r\n    public paramsInit () {\r\n        for ( let prop in this ) {\r\n            if ( typeof this[ prop ] === 'function' ) {\r\n                let res = (this[ prop ] as any)();\r\n            }\r\n        }\r\n    }\r\n}\r\n```"
      },
      {
        "user": "ahejlsberg",
        "created_at": "2017-01-17T18:40:13Z",
        "body": "The current behavior is correct. The call without a type assertion is clearly not type safe, but previously we were not equipped to track the type of a computed property access so we would give an implicit `any` type to `this[prop]` (and you'd get an error with `--noImplicitAny`). Now, because of indexed access types (a.k.a. \"lookup types\") we can do a better job."
      }
    ]
  },
  {
    "number": 13399,
    "title": "files/dirs that start with a dot (.) do not get copied or transpiled by default",
    "created_at": "2017-01-10T20:04:48Z",
    "closed_at": "2017-04-21T16:31:16Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/13399",
    "body": "**TypeScript Version:**  2.1.4\r\n\r\n**Code**\r\n\r\n```\r\n/lib\r\n/test\r\n    /.suman\r\n    /test-src\r\n```\r\n\r\nif I build this project with `tsc` and use the outDir option, the .suman directory **won't** get moved/transpiled, presumably because it starts with a dot .\r\n\r\nbased on the above project structure, the resulting _incorrect_ build would look like:\r\n\r\n```\r\n/dist\r\n   /lib\r\n   /test\r\n       /test-src  \r\n```\r\nabove we can see that the .suman dir is missing from the test dir\r\n\r\nif I rename the .suman directory to suman like so:\r\n\r\n```\r\n/lib\r\n/test\r\n    /suman    // renamed from .suman to suman\r\n    /test-src\r\n```\r\n\r\nthen it will get moved to the outDir, because it no longer starts with a dot .\r\n\r\nso the expected result actually happens, which is of course:\r\n\r\n```\r\n/dist\r\n   /lib\r\n   /test\r\n       /suman\r\n       /test-src\r\n```\r\n\r\n\r\n\r\n\r\nhere is my config, which shows that I want to `include` my test dir, in the build.\r\n\r\n```json\r\n{\r\n  \"compilerOptions\": {\r\n    \"compileOnSave\": true,\r\n    \"target\": \"es5\",\r\n    \"noImplicitAny\": false,\r\n    \"removeComments\": true,\r\n    \"preserveConstEnums\": true,\r\n    \"outDir\": \"dist\",\r\n    \"allowJs\": true,\r\n    \"allowUnreachableCode\": true,\r\n    \"lib\": [\"es2015\", \"dom\"]\r\n  },\r\n  \"include\": [\r\n    \"./**/*\"\r\n  ],\r\n  \"exclude\": [\r\n    \"node_modules\"\r\n  ]\r\n}\r\n\r\n```\r\n\r\n**Expected behavior:**\r\n\r\nI would expect it would include files/directories that start with a dot, unless you exclude files/dirs that start with a dot\r\n\r\n**Actual behavior:**\r\n\r\nTS/tsc seems to exclude files/dirs that start with a dot by default, which seems very strange, since users could easily specify with a regex to ignore dirs/files that start with a dot!\r\n\r\n**My question is then, is there a tsconfig.json setting I can use to include the .suman directory with my build?**\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/13399/comments",
    "author": "ORESoftware",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2017-01-11T17:49:38Z",
        "body": "files and folders starting with a `.` are ignored by the glob patterns. this to accomodate for hidden folders that tools like git rely on. You need to add the folder starting with a `.` explcitlly in your include patter:\r\n\r\n```json\r\n  \"include\": [\r\n    \"./**/*\",\r\n    \"./test/.suman/**/*\"\r\n  ],\r\n```\r\n\r\nalso one note, you need to exclude your outDir, or you will be consuming the output again, given that you have `--allowJs` set. so your exclude patterns should be:\r\n```json\r\n  \"exclude\": [\r\n    \"node_modules\",\r\n    \"./dist\"\r\n  ]\r\n```"
      }
    ]
  },
  {
    "number": 13311,
    "title": "Performance Query - Large String Union Types",
    "created_at": "2017-01-06T03:35:44Z",
    "closed_at": "2017-05-08T08:00:20Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/13311",
    "body": "## Background \r\n\r\nWe have a 2000 line localization file, and a localize function in our code which pulls out the translation at run-time.\r\n\r\nI am investigating the possibility of auto-generating a large string union type, writing it out to a file, and using it as a type parameter for the localize function.\r\n\r\n## Code\r\n\r\n**TypeScript Version:**  2.1.4\r\n\r\n**Before**\r\n\r\n```ts\r\nfunction localize(id: string) {\r\n   // ...\r\n}\r\n\r\nlocalize('not a real key'); // OK\r\n```\r\n\r\n**After**\r\n\r\n```ts\r\nfunction localize(id: LocalizationKey) {\r\n   // ...\r\n}\r\n\r\nlocalize('not a real key'); // NOT OK\r\n\r\n// auto-generated\r\ntype LocalizationKey =\r\n    \"foo\"\r\n  | \"bar\"\r\n  | ... // 2000+ items.\r\n```\r\n\r\nThis works fine.\r\n\r\n## Question\r\n\r\nWe are concerned about type-checking performance, both at compile time, and in TypeScript language services in our IDEs (VS Code and Visual Studio).\r\n\r\nIs this a valid concern, or will these types be cached in an efficient manner?\r\n\r\nThanks.",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/13311/comments",
    "author": "azz",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2017-05-08T17:15:25Z",
        "body": "FYI - Large unions of literal types are highly optimized because that's the internal representation of an enum value. We have an enum in the compiler with ~350 members and it doesn't cause any problems (that I'm aware of). 2,000 might be pushing it but I suspect you'll be OK."
      }
    ]
  },
  {
    "number": 13207,
    "title": "\u03bb return object",
    "created_at": "2016-12-29T05:43:13Z",
    "closed_at": "2016-12-29T07:11:36Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/13207",
    "body": "let func=(val:number)=>{x:val};//error\r\nlet func=(val:number)=>{return {x:val};};//ok",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/13207/comments",
    "author": "kgtkr",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2016-12-29T05:47:06Z",
        "body": "The first line is, unfortunately , a valid JS grammar production. the `{}` represent the body of the function, the `x` is a label, the `val` is an expression, the function as a whole implicitly returns `undefined`.\r\n\r\nyou can wrap it in parans to avoid this. e.g. \r\n```ts\r\nlet func1 = (val: number) => ({ x: val });\r\n```"
      }
    ]
  },
  {
    "number": 13200,
    "title": " Conflict between  Intersection types and keyof",
    "created_at": "2016-12-28T13:36:15Z",
    "closed_at": "2016-12-28T16:44:23Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/13200",
    "body": "**TypeScript Version:**  2.1.4 / nightly (2.2.0-dev.20161228)\r\n\r\n**Code**\r\n\r\n```ts\r\nclass Tween<T>{\r\n\r\n    static get<T>(target: T): Tween<T> {\r\n        return new Tween(target);\r\n    }\r\n\r\n    constructor(private target: T) {\r\n\r\n    }\r\n\r\n    /** \r\n     * modify the value of target from a old number value to new number value;\r\n     * there are two rules props should be followed : \r\n     * 1. key of props must be the key of target \r\n     * 2. every value of props should be number\r\n     */\r\n    public to(props: Partial<T> & { [index: string]: number }) {\r\n\r\n    }\r\n}\r\n\r\n\r\nvar textField = { x: 0, y: 0, text: \"helloworld\" };\r\nvar tween = Tween.get(textField);\r\ntween.to({ \"x\": 100 })\r\ntween.to({ \"xx\": 100 });\r\ntween.to({ \"text\": \"hello,typescript\" });\r\ntween.to({ \"text\": 1 });\r\n\r\n```\r\n\r\n\r\n**Expected behavior:**\r\n```\r\ntween.to({ \"x\": 100 }) // right\r\ntween.to({ \"xx\": 100 });  // report error because 'xx' is not existed in typeof textfield\r\ntween.to({ \"text\": \"hello,typescript\" }); // report error because 'hello,typescript' is not number\r\ntween.to({ \"text\": 1 });// report error because 'text' in typeof textfield should be string\r\n```\r\n\r\n\r\n**Actual behavior:**\r\n\r\n```\r\ntween.to({ \"x\": 100 }) // right\r\ntween.to({ \"xx\": 100 });  // right , why ???????\r\ntween.to({ \"text\": \"hello,typescript\" }); // report error because 'hello,typescript' is not number\r\ntween.to({ \"text\": 1 });// report error because 'text' in typeof textfield should be string\r\n```",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/13200/comments",
    "author": "WanderWang",
    "comments": [
      {
        "user": "blakeembrey",
        "created_at": "2016-12-28T16:00:51Z",
        "body": "This looks correct to me. Your signature is saying `{ [key: string]: number }` is valid, so any key not in `T` must be a number (and anything in `T` intersects with `number` so makes some `never` types when `string & number`. Perhaps you want a signature more like `Partial<{ [X in keyof T]: number }>`? If `{ text: 1 }` is definitely meant to be an error, try the signature `Partial<T & { [X in keyof T]: number }>`, I couldn't really tell if the error there was intentional."
      }
    ]
  },
  {
    "number": 13197,
    "title": "support of native async/await is missing ",
    "created_at": "2016-12-28T10:29:16Z",
    "closed_at": "2016-12-30T18:08:40Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/13197",
    "body": "\r\n**TypeScript Version:**  2.1.1 / nightly (2.2.0-dev.201xxxxx)\r\n\r\n**Code**\r\n\r\n```ts\r\n\r\nasync function f() {\r\n let value = await anotherAsyncFunction()\r\n  ....\r\n}\r\n```\r\n\r\n**Expected behavior:**\r\nIf target type is set to ES7 (which it currently doesn't even support) it should leave the above code _as is_, since the current versions of Node already support it (and it is much easier to debug, too).\r\n\r\n**Actual behavior:**\r\n1. Currently it generates the __awaiter code and uses yield, etc.\r\n1. There's no support for target type es7\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/13197/comments",
    "author": "dharmax",
    "comments": [
      {
        "user": "alitaheri",
        "created_at": "2016-12-28T10:42:09Z",
        "body": "@dharmax es doesn't follow that versioning semantic anymore. use `es2017`."
      },
      {
        "user": "blakeembrey",
        "created_at": "2016-12-28T15:53:35Z",
        "body": "@dharmax it's still behind a flag, try `node --harmony-async-await`."
      }
    ]
  },
  {
    "number": 12877,
    "title": "How to convert enum type to Array<Object>",
    "created_at": "2016-12-13T11:47:34Z",
    "closed_at": "2016-12-13T19:04:27Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/12877",
    "body": "I want convert enum type to Array<Object>.\r\n\r\nexample : \r\n\r\nenum A {\r\n  dog = 1,\r\n  cat = 2,\r\n  ant = 3\r\n}\r\n\r\nconvert to: [{id: 1, name: 'dog'}, {id: 2, name: 'cat'}, {id: 3, name: 'ant'}]\r\n\r\n\r\nthank you.",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/12877/comments",
    "author": "attachai-b",
    "comments": [
      {
        "user": "dead-claudia",
        "created_at": "2016-12-13T14:36:37Z",
        "body": "@narutomxc \r\n\r\nThis is an issue tracker, not a standard help forum. But anyways, here's how you'd do it:\r\n\r\n```ts\r\n// This requires TypeScript 2.1.\r\n// If you need older versions, use `string` instead of `keyof E`.\r\ninterface EnumItem<E> { id: E; name: keyof E; }\r\n\r\nfunction enumToArray<E>(Enum: {[keyof E]: E}): EnumItem<E>[] {\r\n    return Object.keys(Enum).map(key => ({id: Enum[key], name: key} as EnumItem<E>))\r\n}\r\n```"
      },
      {
        "user": "xmeng1",
        "created_at": "2017-11-01T12:57:37Z",
        "body": "I found `{[keyof E]: E}` cannot be recognise in Webstorm. so replace it with any..."
      }
    ]
  },
  {
    "number": 12821,
    "title": "Is it safe to access private members by using an element access expression?",
    "created_at": "2016-12-10T10:36:12Z",
    "closed_at": "2016-12-11T00:20:58Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/12821",
    "body": "**TypeScript Version:**  2.1 / nightly (2.2.0-dev.20161127)\r\n\r\n**Code**\r\n```ts\r\ninterface SomeType { }\r\n\r\nclass A { private m: SomeType; }\r\n\r\nclass B {\r\n\tfoo(a: A) {\r\n\t\tconst n1 = a.m; // (1)\r\n\t\tconst n2 = a[\"m\"]; // (2)\r\n\t}\r\n}\r\n```\r\nAs expected, the property access expression (1) produces a compile error. However, the element access expression (2) does not, even though typescript recognizes that (2) refers to member \"A.m\" as it infers the type \"SomeType\" for n2.\r\n\r\nCan I expect (2) to not produce any compile errors in future typescript versions?",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/12821/comments",
    "author": "hediet",
    "comments": [
      {
        "user": "ahejlsberg",
        "created_at": "2016-12-10T23:27:57Z",
        "body": "It's been that way since forever and several code bases depend on it so I don't imagine us changing it. If we did, we would minimally put it under a compiler switch."
      }
    ]
  },
  {
    "number": 12650,
    "title": "Bug or feature?",
    "created_at": "2016-12-04T13:38:05Z",
    "closed_at": "2016-12-04T17:53:25Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/12650",
    "body": "TypeScript Version:  2.0.10\r\n\r\nThe following code does _not_ produce a syntax error (and I am really hoping this is a feature and not a bug):\r\n```ts\r\nclass MyClass {\r\n    test: { (): number; (_: number): MyClass }\r\n}\r\nlet tmp = new MyClass();\r\ntmp\r\n    .test(22)\r\n    .test()\r\n;\r\n```\r\n\r\n**Expected behavior:**\r\nSyntax error at compilation time on MyClass declaration\r\n\r\n**Actual behavior:**\r\nRuntime error on call to ```tmp.test```\r\n\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/12650/comments",
    "author": "GordonSmith",
    "comments": [
      {
        "user": "aluanhaddad",
        "created_at": "2016-12-04T15:08:36Z",
        "body": "Definitely not a bug. It is a valid type annotation. Initializing is a bit of a pain.\\\r\n```ts\r\nclass MyClass {\r\n  test: { (): number; (_: number): MyClass } = ((_?: number) => {\r\n    if (_ || _ === 0) {\r\n      return new MyClass();\r\n    }\r\n    return 10;\r\n  }) as any;\r\n}\r\nlet tmp = new MyClass();\r\n```\r\nNo runtime errors"
      },
      {
        "user": "GordonSmith",
        "created_at": "2016-12-04T17:53:25Z",
        "body": "@aluanhaddad Interesting and I think your may well be correct since \"test\" is just a property and not a method (which happens to be an instance of an interface declared inline).\r\n\r\nWhat I wrote is effectively a more declarative version of this:\r\n```\r\nclass MyClass {\r\n    test2: (_?) => number | MyClass;\r\n}\r\n```\r\nWhich also produces no compile time error - thx.\r\n "
      }
    ]
  },
  {
    "number": 12549,
    "title": "bug: type predicates (`V is T`) fails on expressions (`V[K] is T`)",
    "created_at": "2016-11-29T04:37:52Z",
    "closed_at": "2016-11-29T07:13:38Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/12549",
    "body": "**TypeScript Version:** nightly (2.2.0-dev.20161128)\r\n\r\n**Code**\r\n\r\n```ts\r\npropIs<T, V, K extends keyof V>(type: T, name: K, obj: V): V[K] is T;\r\n```\r\n\r\n**Expected behavior:**\r\nTS being totally cool with `V[K] is T`.\r\n\r\n**Actual behavior:**\r\nNope, many syntax errors.\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/12549/comments",
    "author": "KiaraGrouwstra",
    "comments": [
      {
        "user": "DanielRosenwasser",
        "created_at": "2016-11-29T04:42:19Z",
        "body": "The type predicate syntax has always taken a parameter name on the left side of the `is` keyword. So it sounds like what you want is better parser recovery here."
      },
      {
        "user": "KiaraGrouwstra",
        "created_at": "2016-11-29T04:50:16Z",
        "body": "Oh, yeah, `V is T` itself works fine, this seems to be specifically about adding the `[K]` there. It does seem like storing (`extends`) `V[K]` in a new generic may form a solution here...\r\nBut apparently `propIs<T, V, K extends keyof V, R extends V[K]>(type: T, name: K, obj: V): R is T;` yields `Cannot find parameter 'R'`. I must be doing something wrong...\r\n"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2016-11-29T06:07:13Z",
        "body": "Well it's only the *parameter* that a type predicate can operate on - in other words, you write\r\n\r\n```ts\r\nfunction foo(x: any): x is string {\r\n    // ....\r\n}\r\n```\r\n\r\nAs opposed to the following:\r\n\r\n```ts\r\nfunction foo(x: any): any is string {\r\n    // ....\r\n}\r\n```"
      },
      {
        "user": "KiaraGrouwstra",
        "created_at": "2016-11-29T06:34:59Z",
        "body": "I'm sorry, that would be my misinterpretation then.\r\nIn that event I would be inclined to try the following for this specific case:\r\n```ts\r\npropIs<T, V, K extends keyof V, R extends V[K]>(type: T, name: K, obj: V): obj[name] is T;\r\n```\r\nStill not okay though. I suppose it'd help if I had the ability to save this result to a new variable first, but I'm not confident I can do this in the type language...\r\n"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2016-11-29T07:08:10Z",
        "body": "You could do something like this:\r\n\r\n```ts\r\npropIs<T, V, K extends keyof V, R extends V[K]>(type: T, name: K, obj: V): obj is (V & Record<K, T>)\r\n```"
      }
    ]
  },
  {
    "number": 12385,
    "title": "error TS2304: Cannot find name 'UriMapHandlerArray'.",
    "created_at": "2016-11-19T21:03:42Z",
    "closed_at": "2016-11-19T23:52:05Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/12385",
    "body": "UriMapHandlerArray is defined in the same file, TS cannot find it.\r\n\r\nts v2.0.10\r\n**Code**\r\n\r\n```js\r\ninterface UriMapHandlerArray {\r\n  [index: string]: IUriMapHandler;\r\n}\r\n\r\nexport class Furi {\r\n\r\n  private _get:    IUriMap = { uri_map: UriMapHandlerArray };\r\n```\r\n\r\n```ts\r\n// A *self-contained* demonstration of the problem follows...\r\n\r\n```\r\n\r\n**Expected behavior:**\r\n\r\n**Actual behavior:**\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/12385/comments",
    "author": "rajinder-yadav",
    "comments": [
      {
        "user": "j-oliveras",
        "created_at": "2016-11-19T21:20:02Z",
        "body": "You uses UriMapHandlerArray as a value of uri_map property not as a type.\n\nIf you want to define IUriMap type as { uri_map: UriMapHandlerArray } you can do:\n`type IUriMap = { uri_map: UriMapHandlerArray }`\nor:\n`interface IUriMap { uri_map: UriMapHandlerArray }`\nand then use it as \n\n```\nexport class Furi {\n  private _get: IUriMap = { uri_map: {} };\n}\n```\n"
      }
    ]
  },
  {
    "number": 12005,
    "title": "TS is incorrectly disallowing a variable assignment.",
    "created_at": "2016-11-02T20:25:10Z",
    "closed_at": "2016-11-03T16:14:46Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/12005",
    "body": "**TypeScript Version:**  2.0.3 \r\n\r\n**Code**\r\n\r\nAll of the code in this issue can be run in the playground.\r\n\r\nThe following gives this compile error: **\"Type 'EntityInstance' is not assignable to type 'EntityInstance'.\"**\r\n\r\n```ts\r\nexport class EntityInstance {\r\n    public deleted = false;\r\n    private children = new EntityArray<EntityInstance>();\r\n\r\n    getChildren(): EntityArray<EntityInstance> {\r\n        return this.children;\r\n    }\r\n}\r\n\r\nexport class ExtendedInstance extends EntityInstance {\r\n    public anotherProperty = true;\r\n\r\n    getChildren(): EntityArray<ExtendedInstance> {\r\n        return super.getChildren() as EntityArray<ExtendedInstance>;\r\n    }\r\n}\r\n\r\nlet ei = new ExtendedInstance();\r\nei.getChildren()[0].anotherProperty = false;\r\n\r\nexport class EntityArray<EntityInstance> extends Array<EntityInstance> {\r\n\r\n    delete(index?: number) {\r\n        let ei = new EntityInstance();\r\n        ei = this.splice( index, 1 )[0];\r\n        ei.deleted = true;\r\n    }\r\n}\r\n\r\n```\r\n\r\n**Expected behavior:**\r\n\r\nThis should be allowed.  It appears that TS thinks that EntityInstance as specified in \"EntityArray<EntityInstance>\" is a different type from EntityInstance.  The former EntityInstance doesn't appear to have type information.  For example, if I rewrite the delete() as follows there is an error because TS doesn't know about the 'deleted' property:\r\n\r\n```ts\r\n    delete(index?: number) {\r\n        let ei = this.splice( index, 1 )[0];\r\n        ei.deleted = true;\r\n    }\r\n```\r\n\r\n**Actual behavior:** \r\n\r\nTS raises compile error.\r\n\r\n**More notes:**\r\n\r\nI could define EntityArray without the <> (which then correctly determines the types in delete) but then I lose type information when I call ExtendedInstance.getChildren().  For example, the above code fails when rewitten as:\r\n\r\n```ts\r\nexport class EntityInstance {\r\n    public deleted = false;\r\n    private children = new EntityArray();\r\n\r\n    getChildren(): EntityArray {\r\n        return this.children;\r\n    }\r\n}\r\n\r\nexport class ExtendedInstance extends EntityInstance {\r\n    public anotherProperty = true;\r\n\r\n    getChildren(): EntityArray {\r\n        return super.getChildren();\r\n    }\r\n}\r\n\r\nlet ei = new ExtendedInstance();\r\nei.getChildren()[0].anotherProperty = false;\r\n\r\nexport class EntityArray extends Array<EntityInstance> {\r\n\r\n    delete(index?: number) {\r\n        let ei = new EntityInstance();\r\n        ei = this.splice( index, 1 )[0];\r\n        ei.deleted = true;\r\n    }\r\n}\r\n```\r\n\r\nI can get by the original error by casting to <any> in the delete method but who wants to do that in Typescript?\r\n\r\n```ts\r\ndelete(index?: number) { \r\n    let ei = this.splice( index, 1 )[0] as any; \r\n    ei.deleted = true; \r\n}\r\n```",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/12005/comments",
    "author": "DeegC",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2016-11-02T21:53:33Z",
        "body": ">  It appears that TS thinks that EntityInstance as specified in \"EntityArray<EntityInstance>\" is a different type from EntityInstance\n\nIt is. You declared a type parameter that shadowed the name:\n\n``` ts\nclass EntityArray<EntityInstance> extends Array<EntityInstance> {\n```\n\nYou probably meant to write\n\n``` ts\nclass EntityArray extends Array<EntityInstance> {\n```\n"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2016-11-02T21:54:42Z",
        "body": "Or perhaps this:\n\n``` ts\nclass EntityArray<T extends EntityInstance> extends Array<T> {\n```\n"
      },
      {
        "user": "aluanhaddad",
        "created_at": "2016-11-03T15:59:48Z",
        "body": "Shadowing is, for better or worse, a part of JavaScript that is fairly ubiquitous. Of course these are types, not Java Script values but it makes sense that the same naming rules would apply. Maybe just displaying that it's a type parameter in the error message would be helpful.\n"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2016-11-03T16:14:46Z",
        "body": "It's kind of necessary to allow type name shadowing, otherwise we wouldn't be able to safely add things to the global namespace without the risk of a breaking change.\n\nThere's perhaps a suggestion lurking here which is that our error messages should do something (I don't know what) if we ever issue a message like \"Cannot assign X to X\" where both X's have identical spelling. I mean ideally you'd see something like \"Cannot assign X (Type Parameter) to X (Interface)\", but it's hard to guess if even that would cover all the cases.\n"
      },
      {
        "user": "aluanhaddad",
        "created_at": "2016-11-04T11:17:05Z",
        "body": "> There's perhaps a suggestion lurking here which is that our error messages should do something (I don't know what) if we ever issue a message like \"Cannot assign X to X\" where both X's have identical spelling. I mean ideally you'd see something like \"Cannot assign X (Type Parameter) to X (Interface)\", but it's hard to guess if even that would cover all the cases.\n\n@RyanCavanaugh I was going to suggest this at first but there are a lot of lenses via which to look at a type so it could become ambiguous, or a just a best guess, in a lot of cases. \n\nMaybe a simpler, higher value option would be to do something like\n\n``` scala\ngiven Types A and B over assignment\nwhere not A assignable to B\nreport IncompatableAssignementOfIdenticallyNamedTypesDiagnostic\nwhen A name is B name\notherwise report IncompatibleTypesDiagnostic\n```\n\nSo it would say something like **\"Type 'B' is not assignable to type 'A'. (note that they are _not_ same Declaration)\"**\n"
      },
      {
        "user": "DeegC",
        "created_at": "2016-11-05T20:17:36Z",
        "body": "Would it be possible to make it illegal for the name of a generic type to shadow a previously defined type?  I'm obviously no TS expert (yet!) but I can't think of a reason one would need to shadow a currently existing type.  The error message could be something like \"Generic type name 'EntityInstance' not allowed because it would shadow an existing type.'\n\nThat would potentially break some current client code; if that's forbidden maybe make it a warning?\n"
      }
    ]
  },
  {
    "number": 11887,
    "title": "Typescript error TS5055",
    "created_at": "2016-10-27T12:49:27Z",
    "closed_at": "2016-10-27T18:34:15Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/11887",
    "body": "**TypeScript Version:**  nightly (2.1.0-dev.20161027)\n\n**Simulation**\n\nCreate a project with the following configuration:\n\n``` json\n{\n  \"compilerOptions\": {\n    \"module\": \"commonjs\",\n    \"target\": \"es5\",\n    \"experimentalDecorators\": true,\n    \"emitDecoratorMetadata\": true,\n    \"noImplicitAny\": true,\n    \"noUnusedParameters\": true,\n    \"noUnusedLocals\": true,\n    \"noEmitOnError\": true,\n    \"skipLibCheck\": true,\n    \"declaration\": true,\n    \"sourceMap\": true,\n    \"outDir\": \"out/\",\n    \"rootDir\": \"src\",\n    \"baseUrl\": \"src\",\n    \"moduleResolution\": \"node\",\n    \"lib\": [\n      \"es5\",\n      \"es2015\",\n      \"dom\"\n    ]\n  },\n  \"exclude\": [\n    \"node_modules\"\n  ]\n}\n```\n\nThe directory structure should be:\n- project\n  - src\n    - index.ts\n    - hello.ts\n  - out\n\nThe content of the `hello.ts` could be:\n\n``` typescript\nexport function hello(name: string) {\n  return `Hello, ${name}`;\n}\n```\n\nThe `index.ts` should re-export the hello module contents:\n\n``` typescript\nexport * from \"./hello\";\n```\n\nAfter that, compile twice using the vscode or the tsc:\n- `tsc -p .`\n- `tsc -p .`\n\n**Expected behavior:**\n\nCompile and produce again the js and the definitions.\n\n**Actual behavior:** \n\nIn the first compilation, it will compile normally. But at the second one, it will file with a message like `error TS5055: Cannot write file '.../hello.d.ts' because it would overwrite input file.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/11887/comments",
    "author": "danfma",
    "comments": [
      {
        "user": "danfma",
        "created_at": "2016-10-27T12:55:40Z",
        "body": "Just to point out, it works with the current production release version.\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2016-10-27T18:34:14Z",
        "body": "add your  `\"outDir\"` to your exclude list. i.e.:   `\"exclude\": [\"node_modules\", \"out\"]`\n"
      }
    ]
  },
  {
    "number": 11792,
    "title": "Question: Why are some of the CompilerOptions Internal?",
    "created_at": "2016-10-22T00:45:52Z",
    "closed_at": "2016-10-22T21:39:50Z",
    "labels": [
      "Question",
      "API"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/11792",
    "body": "I am upgrading my bundling Typescript compiler to use Typescript 2.x and noticed that a number of CompilerOptions ares now internal ( Diagnostics, ListFiles, Watch, etc ). Is there a reason for this?\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/11792/comments",
    "author": "ToddThomson",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2016-10-22T00:48:04Z",
        "body": "These are options that are used only by commandline compiler driver (tsc.js), no other parts of the system use them, so specifying them would be not be useful. e.g. `help`. setting this on the API does not do any thing. \n"
      },
      {
        "user": "ToddThomson",
        "created_at": "2016-10-22T17:50:52Z",
        "body": "I use them. For example when doing white space elimination I use the Diagnostics flag to output white space reduction statistics. I also need to know if the user has the Watch flag set as I have compile and bundling and minification functions that result when a source file changes.\nI agree that these settings are most likely only used by those of us writing features on top of the transpiler, but they are needed. \n"
      },
      {
        "user": "mhegazy",
        "created_at": "2016-10-22T20:52:35Z",
        "body": "Nothing stops you from defining a new property on the option bag. Your diagnostics flag means something to you, so that is fine, but it is not the same meaning the one in types has. So my recomedation is to add your declarations on top of the exisitng compileroptions as needed.\n"
      }
    ]
  },
  {
    "number": 11472,
    "title": "Define array of non-nullables",
    "created_at": "2016-10-09T19:20:31Z",
    "closed_at": "2016-10-09T19:38:50Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/11472",
    "body": "I need to define array of any non-nullable values. Is it possible?\nExample:\n\n``` ts\ndeclare type NonNullable; // this is placeholder for type, which I am looking for\nlet a: NonNullable[] = [];\nlet b: string | null;\na.push(b); // expected compile error;\n```\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/11472/comments",
    "author": "Strate",
    "comments": [
      {
        "user": "DanielRosenwasser",
        "created_at": "2016-10-09T19:30:18Z",
        "body": "`{}` is the empty object type, which every type is structurally compatible with, except for `null`, `undefined`, and `void`.\n\nThis should work with `--strictNullChecks` mode.\n\n``` ts\ntype NonNullable = {};\n\nlet a: NonNullable[] = [];\nlet b: string | null;\n\na.push(b); // expected compile error;\n```\n"
      }
    ]
  },
  {
    "number": 11402,
    "title": "Unification overly simplifies types resulting in the swallowing of 'undefined'",
    "created_at": "2016-10-05T21:33:16Z",
    "closed_at": "2016-10-06T08:50:12Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/11402",
    "body": "**TypeScript Version:**  2.0.3\n\nThis is very problematic as it weakens undefined safety _a lot_.\n\n**Code**\n\n``` ts\nfunction bar<A>(c:boolean, a:A, au:A |\u00a0undefined) { // foo return type is inferred to A instead of A | undefined\n    return c ? a : au;\n}\n```\n\n**Expected behavior:**\n\nbar return type is inferred to A | undefined (valid simplification of A | A | undefined)\n\n**Actual behavior:** \n\nbar return type is inferred to A\n\nNote: similar problem with 'null' instead of 'undefined'\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/11402/comments",
    "author": "sledorze",
    "comments": [
      {
        "user": "yortus",
        "created_at": "2016-10-06T00:26:32Z",
        "body": "If you set `strictNullChecks: true` in your `tsconfig.json`, then `bar` does return `A | undefined` as you expect.\n"
      }
    ]
  },
  {
    "number": 11053,
    "title": "Redundant rest parameter should be omitted from compiled output",
    "created_at": "2016-09-22T01:45:26Z",
    "closed_at": "2016-09-22T04:33:49Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/11053",
    "body": "**TypeScript Version:**  2.0.2 (rc)\n\nIn some cases I am iterating through arguments using the arguments object, and don't actually need to reference the paremeters. In these sorts of cases, the only reason to include the rest parameter in the original source is to tell TypeScript that the function may be called with any number of arguments. If the parameter is never actually referenced (particularly if you then access the arguments object), it should be able to infer that the parameter is redundant and drop it from the compiled output.\n\nHaving an intermediate array built, or even just a redundant rest parameter when targeting ES2015, is not ideal when your code is performance-critical. Optimizing compilers might be smart enough to skip an unused rest parameter, but it still feels sloppy, and ES5 output will be worse, of course.\n\nThe example below is contrived of course, but it serves to illustrate the redundant output:\n\n``` ts\nfunction run(...args: any[]) {\n  const values = arguments;\n  for(var i = 0; i < values.length; i++) {\n    console.log(values[i]);\n  }\n}\n```\n\nES5 output:\n\n``` js\nfunction run() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i - 0] = arguments[_i];\n    }\n    var values = arguments;\n    for (var i = 0; i < values.length; i++) {\n        console.log(values[i]);\n    }\n}\n```\n\nand ES2015 output:\n\n``` js\nfunction run(...args) {\n    const values = arguments;\n    for (var i = 0; i < values.length; i++) {\n        console.log(values[i]);\n    }\n}\n```\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/11053/comments",
    "author": "axefrog",
    "comments": [
      {
        "user": "yortus",
        "created_at": "2016-09-22T02:29:15Z",
        "body": "@axefrog since the prime concern here seems to be performance, what is the performance difference if you actually use the `args` rest parameter instead of `arguments` in your implementation? E.g. is `run1` slower than `run2` in the code below? I'm genuinely curious.\n\n``` ts\nfunction run1(...args: any[]) {\n  for(var i = 0; i < args.length; i++) {\n    console.log(args[i]);\n  }\n}\n\nfunction run2() {\n  const values = arguments;\n  for(var i = 0; i < values.length; i++) {\n    console.log(values[i]);\n  }\n}\n```\n"
      },
      {
        "user": "axefrog",
        "created_at": "2016-09-22T02:44:07Z",
        "body": "@yortus it's not quite as specific as this (yes I do have one function in mind right now, but I don't want to focus on that); rather than optimizing for one specific case I'm experiencing, and then changing my code to try and cater to TypeScript idiosyncracies, I'm just observing that, because JavaScript offers an arguments object and that sometimes it will be used directly, and that sometimes doing so will be in an area of code where redundancy creates a question mark as to expected performance characteristics on different runtime compilers, it seems logical that I should be able to take advantage of this language feature of JavaScript without paying the cost of redundant compiler output. Also, generating redundant syntax seems sloppy.\n"
      },
      {
        "user": "yortus",
        "created_at": "2016-09-22T03:00:01Z",
        "body": "Would the following meet your needs? It has both the compile-time (variadic) and runtime (no redundant var) characteristics you mentioned.\n\n``` ts\nconst foo: (...args) => void = function () {\n    const values = arguments;\n    for (var i = 0; i < values.length; i++) {\n        console.log(values[i]);\n    }\n}\n```\n\n**EDIT:** @RyanCavanaugh's solution below is more idiomatic TS and preserves hoisting, so use that.\n"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2016-09-22T03:00:55Z",
        "body": "The solution is simple, though undiscoverable:\n\n``` ts\nfunction run(...args: any[]): void;\nfunction run() {\n  const values = arguments;\n  for(var i = 0; i < values.length; i++) {\n    console.log(values[i]);\n  }\n}\n```\n"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2016-09-22T06:57:05Z",
        "body": "We try to keep the documentation to common-ish cases and this seems to be fairly rare. You can also see #498 which we're accepting PRs for.\n"
      }
    ]
  },
  {
    "number": 10854,
    "title": "Simultaneous use of export equals and export default in a module",
    "created_at": "2016-09-11T12:35:00Z",
    "closed_at": "2016-09-11T14:52:16Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/10854",
    "body": "I have some NPM modules written that uses the old default export syntax:\n\n``` ts\ndeclare module 'my-module' {\n    function test(): string;\n    export = test;\n}\n```\n\nTo promote ES import syntax but still keep the old one, I wanted to add both the new and old default export syntax:\n\n``` ts\ndeclare module 'my-module' {\n    function test(): string;\n    export default test;\n    export = test; // An export assignment cannot be used in a module with other exported element\n}\n```\n\nThough it complains that it cannot use an export assignment with other export statements.\n\nI think it is reasonable to support both syntax simultaneously in a module. Because choosing between both syntax. I would choose `export =` before `export default`, simply because of no API breakage.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/10854/comments",
    "author": "tinganho",
    "comments": [
      {
        "user": "kitsonk",
        "created_at": "2016-09-11T13:21:19Z",
        "body": "No it isn't really practical at all, because it isn't \"magic\" that produces the default export.  It is added as a property on the export of the module.  What is provided above is trying to export something as `my-module.default` and then overwriting it with a function named `test` and TypeScript is preventing you from describing something that contradicts itself.\n\nI think what you might want to consider the solution to #5285 (`--allowSyntheticDefaultImports`), which allows you to import a module as if it were the shape you denoted.\n"
      },
      {
        "user": "tinganho",
        "created_at": "2016-09-11T13:42:13Z",
        "body": "There could be a problem. I'm currently doing the magic on the module itself and not relying on any module loader doing the magic for me. There could possibly be people that are not using `--allowSyntheticDefaultImports` so they cannot use one of my modules, unless they want to use the old import syntax. Telling all users that they need to add a flag just to use a module is little bit harsh also.\n\nFYI. This is the magic I do:\n\n``` ts\ndeclare var module: any;\nmodule.exports = myModule;\nmodule.exports.default = myModule;\n```\n"
      },
      {
        "user": "kitsonk",
        "created_at": "2016-09-11T14:37:01Z",
        "body": "``` typescript\ndeclare module 'my-module' {\n    const test: () => string & { default: () => string };\n    export = test;\n}\n```\n"
      }
    ]
  },
  {
    "number": 10779,
    "title": "Generics not inferred from union type",
    "created_at": "2016-09-08T14:08:19Z",
    "closed_at": "2016-09-08T14:37:18Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/10779",
    "body": "Latest 2 beta\n\n``` ts\nconst y = <S, E>(z: S | E) => 1;\ny(5 || 'foo') // generics should be number and string, but are {} and {}\n```\n\nI expect the generics `S` and `E` to be inferred correctly as `number` and `string`, but it seems like TypeScript infers them both as `{}` instead.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/10779/comments",
    "author": "OliverJAsh",
    "comments": [
      {
        "user": "kitsonk",
        "created_at": "2016-09-08T14:24:23Z",
        "body": "TypeScript cannot infer generics in that way.  A simple example:\n\n``` typescript\nconst y = <S, E>(z: S | E) => 1;\ny(5 || 'foo' || true) // What should be inferred here?\n```\n\nWhere as:\n\n``` typescript\nconst y = <S>(z: S) => 1;\ny(5 || 'foo') // inferred as `string | number`\n```\n\nIn order to infer generics contextually, TypeScript needs to be in a position to actually resolve to a single type (which a union type is a single type).  For example:\n\n``` typescript\nconst y = <S, E>(z: S | E, a: S, b: E) => 1;\ny(5 || 'foo', 6, 'bar') // inferred as number, string\ny(5 || true, 6, 'bar') // an Error\n```\n"
      }
    ]
  },
  {
    "number": 10655,
    "title": "Async map iteration does not work as expected",
    "created_at": "2016-08-31T22:37:21Z",
    "closed_at": "2016-09-02T22:07:17Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/10655",
    "body": "**TypeScript Version:**  1.8.10\n\n**Code**\n\n``` ts\nvar map = new Map<string, any>();\nmap.set('abc', 123);\nmap.forEach(async (value)=>{\nawait DoSomethingAsyncWithValue(val);\n});\n```\n\n**Expected behavior:**\nShould asynchronously iterate over the map.\n\n**Actual behavior:** \nSynchronously iterates over the map.\n\nThere are no compilation errors from this code, so a developer would assume it'd work the same as an Array forEach.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/10655/comments",
    "author": "Roam-Cooper",
    "comments": [
      {
        "user": "Arnavion",
        "created_at": "2016-09-01T01:13:42Z",
        "body": "> Expected behavior:\n> Should asynchronously iterate over the map.\n\nThat would be a violation of the ES6 spec, and is outside of TS's control at any rate.\n\n> There are no compilation errors from this code, so a developer would assume it'd work the same as an Array forEach.\n\nThat is technically legal from both runtime perspective and compiler perspective.\n\nFrom runtime's point of view, the callback given to `forEach` is returning a `Promise` that `forEach` ignores and throws away.\n\nFrom TS compiler's point of view, `forEach` excepts a callback that returns `void`, whereas the actual callback is returning a `Promise`. But it is legal to assign callbacks that return non-`void` to callbacks that return `void`. (This is useful for writing single-expression lambdas where one just wants the result of the expression to be ignored.) So there is nothing to raise a compiler error about.\n\nPerhaps you could create a tslint rule for this, something like \"Async lambda used with Array#forEach may not work as expected.\"\n"
      },
      {
        "user": "yortus",
        "created_at": "2016-09-01T07:20:23Z",
        "body": "@Roam-Cooper you could try something like this:\n\n``` ts\nasync function foo() {\n    var map = new Map<string, any>();\n    map.set('abc', 123);\n\n    for (let [key, val] of map) {\n        await doSomethingAsyncWithValue(val);\n    }\n}\n```\n"
      }
    ]
  },
  {
    "number": 10551,
    "title": "Generic type constraint for abstract class.",
    "created_at": "2016-08-26T02:10:03Z",
    "closed_at": "2016-08-26T04:11:27Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/10551",
    "body": "Too constraint a generic type that is a class, we can write `{new():T}`, however it doesn't match an abstract class.\n\n``` typescript\nclass X{};\nabstract class Y{};\nfunction f<T>(x: {new():T});\nf(X);// OK\nf(Y);// Faild\n```\n\nIs there any way overcome this?\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/10551/comments",
    "author": "thynson",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2016-08-26T03:32:14Z",
        "body": "Why would you want to? It's illegal to `new Y`.\n\nYou could also write `function f<T>(x: {prototype: T})`\n"
      },
      {
        "user": "thynson",
        "created_at": "2016-08-26T04:11:27Z",
        "body": "I'm writing an IoC container, use abstract class itself as indentifier to register its implementation.\nAnd `function f<T>(x: {prototype: T})` works, thank you!\n"
      }
    ]
  },
  {
    "number": 10363,
    "title": "\"A class must be declared after its base class\" on classes in different directories",
    "created_at": "2016-08-16T07:02:48Z",
    "closed_at": "2016-08-16T07:08:25Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/10363",
    "body": "**TypeScript Version:**  master branch\n\n**Repro**\n1. Create a new JavaScript->Windows->Universal->Blank App project\n2. Add directories and empty files as following:\n   \n   ```\n   (App name)\n   |>sources\n   |    |>cats\n   |    |    |>elephants\n   |    |    | foo.ts\n   |    | bar.ts\n   \n   sources/cats/elephants/foo.ts\n   sources/cats/bar.ts\n   ```\n3. Write codes as following:\n   \n   ``` ts\n   // In sources/cats/elephants/foo.ts:\n   class Foo extends Bar {\n   }\n   \n   // In sources/cats/bar.ts:\n   class Bar {\n   }\n   ```\n4. Open project properties and set \"Combine JavaScript output into file\" to \"js/app.js\"\n5. Unload project\n6. Reload project\n\n**Expected behavior:**\n\nCompiler should automatically make a proper order for the classes\n\n**Actual behavior:** \n\n``` ts\nclass Foo extends Bar {\n//                ~~~\n//                A class must be declared after its base class.\n}\n```\n\n**Workaround:**\n\nRename \"foo.ts\" to \"a.ts\".\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/10363/comments",
    "author": "saschanaz",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2016-08-16T07:05:55Z",
        "body": "The compiler doesn't figure out what the \"right\" order of files is based on class dependencies or anything else. The usual methods are available: have a `_reference.ts`, use `/// <reference` directives, or use a module loader (if applicable)\n"
      }
    ]
  },
  {
    "number": 10156,
    "title": "On static method Error TS2339: Property 'then' does not exist on type '() => Promise'",
    "created_at": "2016-08-04T22:26:53Z",
    "closed_at": "2016-08-04T23:29:43Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/10156",
    "body": "<!-- BUGS: Please use this template. -->\n\n**TypeScript Version:**  1.8.10 and nightly (2.1.0-dev.20160804)\n\n**Code**\n\n``` ts\n/// <reference path=\"typings/globals/core-js/index.d.ts\" />\n\nexport class CryptoService\n{\n  static getToken()\n  {\n    return Promise.resolve('123');\n  }\n\n  static setXsrf()\n  {\n    return this.getToken.then( token  => {} );\n  }\n}\n```\n\n**Not expected error:**\n\n> error TS2339: Property 'then' does not exist on type '() => Promise<string>'.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/10156/comments",
    "author": "KostyaTretyak",
    "comments": [
      {
        "user": "DickvdBrink",
        "created_at": "2016-08-04T22:30:47Z",
        "body": "You wanted to write `this.getToken()` (notice the `()`) right?\n"
      },
      {
        "user": "normalser",
        "created_at": "2016-08-04T23:26:09Z",
        "body": "Change:\n`return this.getToken.then( token  => {} );`\nto\n`return this.getToken().then( token  => {} );`\n"
      }
    ]
  },
  {
    "number": 10135,
    "title": "Cannot rebuild declarations with declarationDir",
    "created_at": "2016-08-04T13:03:51Z",
    "closed_at": "2016-08-31T14:54:47Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/10135",
    "body": "**TypeScript Version:**  2.0.0-beta\n\n**Configuration**\n\n``` json\n{\n    \"compilerOptions\": {\n        \"declaration\": true,\n        \"declarationDir\": \"declarations\"\n    }\n}\n```\n\n**Expected behavior:**\nIn the first run, compiler generate declarations. When start second build `.d.ts` files should be updated.\n\n**Actual behavior:** \nAfter second run, I get this error:\n\n``` cmd\nerror TS5055: Cannot write file 'declarations/*.d.ts' because it would overwrite input file.\n```\n\nAnd declarations files not updated.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/10135/comments",
    "author": "GiedriusGrabauskas",
    "comments": [
      {
        "user": "lostfields",
        "created_at": "2016-08-31T07:39:44Z",
        "body": "add the following to your tsconfig.json to avoid making declarations of declarations or something :-)\n\n```\n\"exclude\": [\"./declarations\"]\n```\n"
      }
    ]
  },
  {
    "number": 10105,
    "title": "Use lib/lib.*.d.ts as regular program files",
    "created_at": "2016-08-03T00:20:32Z",
    "closed_at": "2016-08-03T05:56:12Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/10105",
    "body": "We use the same `tsconfig.json` `compilerOptions` for all code in our monorepo.\nEach target gets to specify only the `files` list.\n\nWe'd like some targets to be able to opt-in for typings like collections. In the past, we did that by including the DefinitelyTyped es6-collections.d.ts in the files.\n\nIf I include one of the `///<reference no-default-lib=true/>` files, though, I get an error:\n\n```\nalexeagle@alexeagle:~/Projects/repro$ cat tsconfig.json \n{\n    \"compilerOptions\": {\n        \"module\": \"commonjs\",\n        \"target\": \"es5\"\n    },\n    \"files\": [\"node_modules/typescript/lib/lib.es2015.collection.d.ts\"]\n}\nalexeagle@alexeagle:~/Projects/repro$ $(npm bin)/tsc\nerror TS2318: Cannot find global type 'Array'.\nerror TS2318: Cannot find global type 'Boolean'.\nerror TS2318: Cannot find global type 'Function'.\nerror TS2318: Cannot find global type 'IArguments'.\nerror TS2318: Cannot find global type 'Number'.\nerror TS2318: Cannot find global type 'Object'.\nerror TS2318: Cannot find global type 'RegExp'.\nerror TS2318: Cannot find global type 'String'.\n```\n\nThis is the case even if other files are included in the compilation. I can solve it by removing the `///ref` but this means we have local modifications to Typescript. Is there another way to defeat the error?\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/10105/comments",
    "author": "alexeagle",
    "comments": [
      {
        "user": "DanielRosenwasser",
        "created_at": "2016-08-03T03:13:14Z",
        "body": "Those errors only come up because you didn't include `lib.es5.d.ts` , so you didn't have the global core types available.\n\nDoes this using this `tsconfig.json` fix the issue?\n\n``` json\n{\n    \"compilerOptions\": {\n        \"module\": \"commonjs\",\n        \"target\": \"es5\"\n    },\n    \"files\": [\n        \"node_modules/typescript/lib/lib.es5.d.ts\",\n        \"node_modules/typescript/lib/lib.es2015.collection.d.ts\"\n    ]\n}\n```\n"
      },
      {
        "user": "alexeagle",
        "created_at": "2016-08-03T05:56:12Z",
        "body": "Thanks Daniel, that does work.\n\nI had tried\n\n```\n{\n    \"compilerOptions\": {\n        \"module\": \"commonjs\",\n        \"target\": \"es5\",\n        \"noImplicitAny\": false,\n        \"sourceMap\": false,\n        \"lib\": [\"es5\"]\n    },\n    \"files\": [\n        \"app.ts\",\n        //\"node_modules/typescript/lib/lib.es5.d.ts\",\n        \"node_modules/typescript/lib/lib.es2015.collection.d.ts\"\n    ]\n}\n```\n\nthinking that the `--lib` flag would bring in the standard types (and this is what we have today). I imagine that `no-default-lib` actually means don't use any default libs, and the `--lib` flag just chooses a different set of \"default\" libs?\n\nBut it will probably make our setup easier to just use `--noLib` and pass all files together, rather than a mix of `--lib` and `files`\n"
      },
      {
        "user": "alexeagle",
        "created_at": "2016-08-08T21:27:49Z",
        "body": "I take that back, we are investigating a 2x performance regression for compiles.\nWe now include v1_9_0_dev_20160526/lib/lib.es5.d.ts in the `files[]` of tsconfig. Even though we have a cache that prevents re-reading from disk, and we don't ask to type-check that file, I suspect we now hit some parse time when creating a `ts.Program` containing that.\nPreviously, it was in `--lib` and we `skipDefaultLibCheck` - I am guessing we also skipped parsing?\n\ncc @evmar who is profiling it.\n"
      },
      {
        "user": "alexeagle",
        "created_at": "2016-09-09T13:11:40Z",
        "body": "thanks for following up. We did track down our performance regression. @evmar could confirm, looking at the history we were not certain what introduced it. removing `--noEmitOnError` helped, as that was triggering an extra type-check.\n"
      }
    ]
  },
  {
    "number": 10056,
    "title": "Mystique Screen interface",
    "created_at": "2016-07-31T19:16:24Z",
    "closed_at": "2016-07-31T21:47:35Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/10056",
    "body": "Go to playground and type\n\n``` ts\ninterface Screen<T> {}\n```\n\nyou will see error: all declarations of an interface must have identical type parameters.\n\nI have tried it in Chrome and Mozila, OS -windows 8\n\nIt seems to me that some code inside playground in global scope.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/10056/comments",
    "author": "olegdunkan",
    "comments": [
      {
        "user": "olegdunkan",
        "created_at": "2016-07-31T19:49:53Z",
        "body": "I found out that Screen is the global object in browser environment, then I saw the same issue about 'name' variable. For novice it is not obvious that code in playground is executed in global scope.  The questions like this will appear more and more. Maybe it will better to limit scope or make some attention to this for users.  \n\nIn my case typescript generates nothing, there is no any variable named Screen. How can I suppose that nothing interferes with global Screen object? \n"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2016-07-31T21:47:35Z",
        "body": "If you use modules, you'll get a \"fresh\" scope inside the global scope where you can shadow existing names as you like.\n\nIn real life, conflict with global variables when code executes at the global scope is actually a very large concern and it's desirable to be warned of this. It'd be very bad, for example, to assign to `Screen` or some other mutable variable and break some downstream code.\n"
      }
    ]
  },
  {
    "number": 9811,
    "title": "Cannot define declared variable with the same property",
    "created_at": "2016-07-19T07:46:15Z",
    "closed_at": "2016-07-25T06:14:32Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/9811",
    "body": "**TypeScript Version:**  1.8.0 / nightly (2.0.0-dev.201xxxxx)\n\n**Code**\n\n``` ts\ninterface A {   \n}\n\ndeclare var A: {\n    x: number;\n}\n\nclass AShim implements A {\n    x: number;\n}\n\nvar A: {\n     x: number;\n} = AShim;\n```\n\n**Expected behavior:**\nI expect this to compile successfully.\n\n**Actual behavior:** \n\n```\na.ts(12,5): error TS2322: Type 'typeof AShim' is not assignable to type '{ x: number; }'.\n  Property 'x' is missing in type 'typeof AShim'.\n```\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/9811/comments",
    "author": "NN---",
    "comments": [
      {
        "user": "kitsonk",
        "created_at": "2016-07-19T10:41:56Z",
        "body": "Classes have two interfaces, the instance interface and the static interface of the constructor function.  You are trying to assign something that is a class to something that is a simple object interface.  The static interface can be referenced as `typeof AShim` and `new AShim()` would produce something that is assignable to `A`.\n\nTo describe an interface that `AShim` could be assigned to, it would look like this:\n\n``` typescript\ninterface AConstructor {\n    new (): A;\n    prototype: A;\n}\n\nvar A: AConstructor = AShim;\n```\n"
      },
      {
        "user": "NN---",
        "created_at": "2016-07-19T18:25:03Z",
        "body": "Why it works for other cases like this:\n\n``` ts\n\ninterface Blob {\n    size: number;\n    type: string;\n    msClose(): void;\n    msDetachStream(): any;\n    slice(start?: number, end?: number, contentType?: string): Blob;\n}\n\ndeclare var Blob: {\n    prototype: Blob;\n    new (blobParts?: any[], options?: BlobPropertyBag): Blob;\n}\n\nclass BlobShim implements Blob {\n    constructor(blobParts?: any[], options?: BlobPropertyBag) { }\n    msDetachStream(): any {}\n    slice(start?: number, end?: number, contentType?: string): Blob {\n        return null;\n    }\n    msClose(): void {}\n    type: string;\n    size: number;\n}\n\n// OK\nvar Blob: {\n    prototype: Blob;\n    new(blobParts?: any[], options?: BlobPropertyBag): Blob;\n} = BlobShim;\n```\n"
      },
      {
        "user": "kitsonk",
        "created_at": "2016-07-19T21:39:17Z",
        "body": "Because BlobShim's interface matches the interface for `var Blob`.  Above, you were trying to put assign a constructor function/class to an instance interface, as I explained.  Here, you are assigning `BlobShim` to a constructor interface, which works.\n"
      },
      {
        "user": "NN---",
        "created_at": "2016-07-20T06:20:49Z",
        "body": "@kitsonk Your example doesn't compile.\n\n``` ts\ninterface A {   \n}\n\ndeclare var A: {\n    x: number;\n}\n\nclass AShim implements A {\n    x: number;\n}\n\ninterface AInterface {\n    x: number;\n}\n\nvar A: AInterface = AShim;\n```\n"
      },
      {
        "user": "NN---",
        "created_at": "2016-07-20T09:40:56Z",
        "body": "@mhegazy I am writing tests with PhantomJS runner.\nIt doesn't have window.URL object, so I want to create my own.\nThe code worked well in TS 1.8 and stopped working in TS 2.0.\nAfter some investigations I got to this minimal code sample.\n\nI don't understand why it doesn't work while having the exact same types on both sides.\n"
      },
      {
        "user": "normalser",
        "created_at": "2016-07-21T03:03:47Z",
        "body": "@NN---  \n\nSeems like you did not understand @kitsonk explanation\n\nHere is your last full example adjusted to compile\n\n``` ts\ninterface A {   \n}\n\ndeclare var A: {\n    x: number;\n}\n\nclass AShim implements A {\n    x: number;\n}\n\ninterface AInterface {\n    x: number;\n}\n\nvar A: AInterface = AShim.prototype;\nvar A: AInterface = new AShim();\n\ninterface AInterface2 {\n    new (): AInterface;\n    prototype: AInterface;\n}\n\nvar A2: AInterface2 = AShim;\n```\n"
      },
      {
        "user": "NN---",
        "created_at": "2016-07-21T20:38:27Z",
        "body": "@wallverb The only problem that I want to it without A2.\n\nI want to define a variable of URL with my implementation.\nHow I do it ?\nThank you.\n\n``` ts\ninterface URL {\n    hash: string;\n    host: string;\n    hostname: string;\n    href: string;\n    readonly origin: string;\n    password: string;\n    pathname: string;\n    port: string;\n    protocol: string;\n    search: string;\n    username: string;\n    toString(): string;\n}\n\ndeclare var URL: {\n    prototype: URL;\n    new(url: string, base?: string): URL;\n    createObjectURL(object: any, options?: ObjectURLOptions): string;\n    revokeObjectURL(url: string): void;\n}\n```\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2016-07-21T23:27:17Z",
        "body": "all you need is somehting that has the shape of the the URL constructor, i.e. the type of the `var` `URL`.\n\nso:\n\n``` ts\nclass URLShim {\n    // instace side, i.e. interface URL\n    hash: string;\n    host: string;\n    hostname: string;\n    href: string;\n    readonly origin: string;\n    password: string;\n    pathname: string;\n    port: string;\n    protocol: string;\n    search: string;\n    username: string;\n\n    // Static side, i,e. typeof var URL\n    constructor(url: string, base?: string) { }\n    static createObjectURL(object: any, options?: ObjectURLOptions): string { }\n    static revokeObjectURL(url: string): void { }\n}\n\nURL = URLShim;\n\n```\n"
      }
    ]
  },
  {
    "number": 9604,
    "title": "Overriding addEventListener to augment event objects",
    "created_at": "2016-07-11T00:25:45Z",
    "closed_at": "2016-07-11T21:33:53Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/9604",
    "body": "Ultimately, what I want to do is to describe the following trick:\n\n``` js\nconst element = document.createElement(\"div\");\n\nelement.addEventListener(\"click\", event => {\n  event.foo = 123;\n});\n```\n\nAs you see, my `<div>` element intercepts all \"click\" events and adds a new property to them, so whoever attaches a \"click\" listener later will see this new property.\n\nA practical example would be a custom UI element that represents, for instance, a chess board, and adds `row` and `col` properties to every mouse event, as the consumers of the UI element shouldn't need to convert the plain `x` and `y` coordinates to the cell coordinates.\n\nMy attempt to describe this failed:\n\n``` ts\ninterface MyMouseEvent {\n  foo?: number;\n}\n\ninterface MyElement extends HTMLElement {\n  addEventListener(type: \"click\", listener: (ev: MyMouseEvent) => any, capture?: boolean): void;\n}\n```\n\ntsc complains that the HTMLElement interface is incorrectly extended:\n\n```\nTS2430  Interface 'MyElement' incorrectly extends interface 'HTMLElement'.\n  Types of property 'addEventListener' are incompatible.\n    Type '(type: \"click\", listener: (ev: MyMouseEvent) => any, useCapture?: boolean) => void' is not assignable to type '{ (type: \"MSContentZoom\", listener: (ev: UIEvent) => any, useCapture?: boolean): void; (type: \"MS...'.\n      Type '(type: \"click\", listener: (ev: MyMouseEvent) => any, useCapture?: boolean) => void' provides no match for the signature '(type: string, listener: EventListener | EventListenerObject, useCapture?: boolean): void'\n```\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/9604/comments",
    "author": "d180cf",
    "comments": [
      {
        "user": "kitsonk",
        "created_at": "2016-07-11T07:19:31Z",
        "body": "When you have overrides that is also an overload, you have to provide at least one overload that matches the overridden function.  This is fairly clearly implied by the error:\n\n``` typescript\ninterface MyElement extends HTMLElement {\n  addEventListener(type: \"click\", listener: (ev: MyMouseEvent) => any, capture?: boolean): void;\n  addEventListener(type: string, listener: EventListener | EventListenerObject, useCapture?: boolean): void;\n}\n```\n"
      }
    ]
  },
  {
    "number": 9456,
    "title": "Dont require declaration files after compile",
    "created_at": "2016-06-30T22:09:18Z",
    "closed_at": "2016-07-06T23:31:30Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/9456",
    "body": "I use `import` instead of `<reference ..` to import my `d.ts` files. But after I'd compiled this:\n\n``` ts\nimport 'tests/interfaces/mocha.d.ts';\n```\n\nI've got:\n\n``` js\n\"use strict\";\nrequire('tests/interfaces/mocha.d.ts');\n```\n\nMy config file:\n\n``` json\n{\n    \"compilerOptions\": {\n        \"emitDecoratorMetadata\": true,\n        \"experimentalDecorators\": true,\n        \"module\": \"commonjs\",\n        \"moduleResolution\": \"classic\",\n        \"noImplicitAny\": false,\n        \"outDir\": \"dist\",\n        \"rootDir\": \".\",\n        \"sourceMap\": true,\n        \"target\": \"es5\"\n    }\n}\n```\n\nCan i change this behaviour by config?\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/9456/comments",
    "author": "lasekio",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2016-06-30T22:27:30Z",
        "body": "do not put the file extension in the require statement. use the module name. so:\n\n``` ts\nimport 'tests/interfaces/mocha';\n```\n\nor  if you are using TS 2.0: \n\n``` ts\nimport 'tests/interfaces/mocha.js';\n```\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2016-06-30T22:38:25Z",
        "body": "> Can i change this behavior by config?\n\nno. module names are resource identifiers, they are written in the output the same way they are read. the compiler will not change the import name or extension.\n"
      }
    ]
  },
  {
    "number": 9370,
    "title": "Allow empty return statements on setters",
    "created_at": "2016-06-27T11:06:27Z",
    "closed_at": "2016-06-27T16:32:09Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/9370",
    "body": "**TypeScript Version:** \n1.8.10\n\n**Code**\n\n``` ts\nclass Foo {\n  private _value: string = '';\n  set value(newV: string): void {\n    if (newV === this._value) {\n      return;\n    }\n\n    // ...\n  }\n}\n```\n\n**Expected behavior:**\n\nNo errors.\n\n**Actual behavior:** \n\n`A 'set' accessor cannot have a return type annotation.`.\n\nThanks :)\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/9370/comments",
    "author": "gjuchault",
    "comments": [
      {
        "user": "aluanhaddad",
        "created_at": "2016-06-27T11:51:42Z",
        "body": "Is the issue of the Void annotation, or the return statement I believe it's the former.\n"
      },
      {
        "user": "gjuchault",
        "created_at": "2016-06-27T11:58:30Z",
        "body": "The error is that TypeScript puts an error when there is a return statement on a setter; when it can makes sense to stop the setter becasue of validation or whatever\n"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2016-06-27T16:32:09Z",
        "body": "The issue is the return type annotation, not the return statement. Expressionless return statements are legal. Return type annotations are not.\n"
      },
      {
        "user": "gjuchault",
        "created_at": "2016-06-28T07:36:09Z",
        "body": "@RyanCavanaugh Ok I'm not really sure what's the difference between the two. Is the `: void` non-sense on a setter ?\n"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2016-06-28T15:25:40Z",
        "body": "Yes. The returned value of a setter is unobservable, so it doesn't make any sense to talk about its return type.\n"
      }
    ]
  },
  {
    "number": 9368,
    "title": "should ts avoid to use the this keyworld in class ?",
    "created_at": "2016-06-27T06:16:31Z",
    "closed_at": "2016-06-27T07:10:27Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/9368",
    "body": "**version**\n1.8.31\n\n``` ts\nclass A {\n    public count: number = 10;\n    public AddOne(): void{\n        this.count += 1;\n    }\n}\n```\n\nand will generate those js\n\n``` js\nvar A = (function () {\n    function A() {\n        this.count = 10;\n    }\n    A.prototype.AddOne = function () {\n        this.count += 1;\n    };\n    return A;\n}());\n\n```\n\nthis is ok when you `let a = new A()`  and `a.AddOne()`  , \nbut when  `let myadd = a.AddOne`  and   `myadd()`\nthe result will be different . because  `this`  became something else.\n\nshould  the output js like this ?\n\n``` js\nvar A = (function () {\n    var _this;\n    function A() {\n        this.count = 10;\n        _this = this;\n    }\n    A.prototype.AddOne = function () {\n        _this.count += 1;  // not use this\n    };\n    return A;\n}());\n```\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/9368/comments",
    "author": "John0King",
    "comments": [
      {
        "user": "kitsonk",
        "created_at": "2016-06-27T06:27:46Z",
        "body": "This is just the behaviour of JavaScript.  When using `class` in a ES6 compatible environment, you get an error when you called an improperly bound method:\n\n``` javascript\nclass A {\n    constructor() {\n        this.count = 10;\n    }\n    AddOne() {\n        this.count += 1;\n    }\n}\n\nconst a = new A();\nconst myaddone = a.AddOne;\n\nmyaddone();  // Uncaught TypeError: Cannot read property 'count' of undefined\n```\n\nTherefore if your suggestion would break compatibility with ES6 classes.\n\nIf you need a reference of a method bound to an instance, just bind it:\n\n``` typescript\nconst myaddone = a.AddOne.bind(a);\n```\n"
      },
      {
        "user": "John0King",
        "created_at": "2016-06-27T06:43:31Z",
        "body": "@kitsonk  How to use it in  jquery's  `click`  or  `change` method ?\n"
      },
      {
        "user": "kitsonk",
        "created_at": "2016-06-27T06:51:23Z",
        "body": "I am afraid this isn't a general support forum, but without some example of how you want to use something and what is not working, it is really difficult to even answer that question.  The problem could be solved any number of ways, which are patterns used with construction functions with prototypes since the early days of JavaScript.  Most libraries like jQuery have mechanisms for being context when it can be lost as well as ES6 offer lexical `this` binding when using arrow/lambda functions.\n\nBut all of this is probably not for discussion in a issue tracker for bugs with TypeScript.  StackOverflow, Gitter and IRC are better places to discuss \"how do I use\" something.\n"
      }
    ]
  },
  {
    "number": 9302,
    "title": "Typing is clumsy when instancing using class objects derived from an abstract class",
    "created_at": "2016-06-21T20:04:57Z",
    "closed_at": "2016-09-20T22:48:19Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/9302",
    "body": "Suppose you have an abstract class `A` and two concrete clases `B`, `C` derived from `A`, and you want to store `B` and `C` as first-class values to make instances from these values: \n\n``` ts\nabstract class A  { a: any}\nclass B extends A { b: any}\nclass C extends A { c: any}\n\nlet classes  = [B, C]            // inferred type = (typeof B | typeof C)[]\nlet instance = new classes[1]()  // inferred type = (B | C)\ninstance.a                       // ok, because .a is in B and C\n```\n\nIt will be nice if the previous example inferred the `instance` type as `A` instead of `(B | C)`. But it works. \nThe problem comes when TS can't infer the `classes` type, like when using a `Map` instead of an array:\n\n``` ts\nlet classes2 = new Map([[\"b\", B], [\"c\", C]]) // error TS2453: The type argument for type parameter 'V' cannot be inferred from the usage.\nlet classes3 = new Map<string, typeof A>([[\"b\",B], [\"c\", C]])\nlet classes4 = new Map<string, typeof B | typeof C>([[\"b\",B], [\"c\", C]])\n\nvar instance3 = new (classes3.get(\"c\"))()   // TS2511: Cannot create an instance of the abstract class 'A'.\nvar instance4 = new (classes4.get(\"c\"))()   // inferred type = (B | C)\n```\n\n`classes2` doesn't work because TS can't infer the type. \n`classes3` doesn't work because you can't use it for instancing.\n`classes4` example worked but is very clumsy for a large number of classes, you need to type `(typeof B | typeof C | ...)` for all the classes involved. Maybe this is acceptable but I think there is a need to be able of defining (and inferring) a type like \"all concrete classes derived from A\".\n\nBelow is the same example but using a concrete base class. Note in this case you can use `<typeof A>` as the type of the array / map values:\n\n``` ts\nclass A  {a : any}    // now concrete\nclass B extends A { b: any}\nclass C extends A { c: any}\n\nlet classes0 = [B, C]  // inferred type = (typeof B | typeof C)[]\nlet classes1 = <typeof A[]>[B,C]\n\nlet instance1 = new classes0[1]()  // inferred type = (B | C)\ninstance1.a                        // ok, because .a is in B and C\nlet instance2 = new classes1[1]()  // inferred type = A\ninstance2.a                        // ok, because .a is in A\n\nlet classes2 = new Map([[\"b\", B], [\"c\", C]]) // error TS2453: The type argument for type parameter 'V' cannot be inferred from the usage.\nlet classes3 = new Map<string, typeof A>([[\"b\",B], [\"c\", C]])\nlet classes4 = new Map<string, typeof B | typeof C>([[\"b\",B], [\"c\", C]])\n\nvar instance3 = new (classes3.get(\"c\"))()   // inferred type = A\nvar instance4 = new (classes4.get(\"c\"))()   // inferred type = (B | C)\n```\n\n**TypeScript Version:** \n\n1.9.0-dev.20160616-1.0\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/9302/comments",
    "author": "nahuel",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2016-06-21T20:13:35Z",
        "body": "I think what you want is this?\n\n``` ts\nlet classes5 = new Map<string, new() => A>([[\"b\",B], [\"c\", C]]); // OK\n\nvar instance5 = new (classes5.get(\"c\"))(); // OK, instance5: A\n```\n"
      },
      {
        "user": "nahuel",
        "created_at": "2016-06-22T14:27:38Z",
        "body": "@RyanCavanaugh thanks, your example solves this problem! Just a detail, there is a way to reference the `A` constructor signature to avoid repeating it on the `Map` one? I mean:\n\n``` ts\nabstract class A  { a: any\n                    constructor (x: number, y: number) {}}\nclass B extends A { b: any}\nclass C extends A { c: any}\n\nlet classes5 = new Map<string, new(x : number, y : number) => A>([[\"b\",B], [\"c\", C]]); // OK\n     // must repeat args signature ^^^^^^^^^^^^^^^^^^^^^^\nvar instance5 = new (classes5.get(\"c\"))(1,2); // OK, instance5: A\n\n// Is possible to reference the A constructor signature? something like this:\nlet classes6 = new Map<string, typeof A.new>([[\"b\",B], [\"c\", C]]); \n```\n\nThanks for your reply.\n"
      },
      {
        "user": "aluanhaddad",
        "created_at": "2016-06-22T19:53:00Z",
        "body": "It's interesting to note that using an object literal might be more typesafe and refactoring friendly than using a `Map`.\n\n``` TypeScript\nabstract class A  { a: any}\nclass B extends A { b: any}\nclass C extends A { c: any}\n\nlet classes  = { B, C };\nlet instance = new classes.B()  // inferred type = B\ninstance.a                       // ok, because .a is in B\n```\n"
      },
      {
        "user": "nahuel",
        "created_at": "2016-06-25T20:28:02Z",
        "body": "@aluanhaddad that works, but not when you use an string based key (eg. one taken from a config file). In your example `var a = 'B' ; classes[a]` will be inferred as `any`.\n"
      },
      {
        "user": "aluanhaddad",
        "created_at": "2016-06-25T21:01:13Z",
        "body": "The keys are strings, I'm simply using concise object literal notation for brevity and in order to leverage refactoring. It's true that if you're using an index signature with a string literal, it becomes more difficult, but I don't see how it is any worse than an array, and at least it makes any necessary casting more intuitive. But you could add an index signature like\n\n``` typescript\n[key: string]: B | C;\n```\n\nor\n\n``` typescript\n[key: string]: new () => A;\n```\n\nThen again that kind of defeats the thing you were trying to achieve in the first place. When the keys are not constants, it's easy to run into this sort of thing.\nWould it be possible for the config file to be a TypeScript file containing exported constants? I found that to be quite useful in certain cases. Also it looks like there will be support for typed JSON Imports at some point in the future.\n"
      },
      {
        "user": "nahuel",
        "created_at": "2016-06-25T21:18:17Z",
        "body": "@aluanhaddad: let me check if I get you, given this:\n\n``` ts\nlet classes1 = new Map<string, new() => A>([[\"B\", B], [\"C\", C]]); \nlet classes2 : {[k : string] : new() => A } = { B, C };\n```\n\n`classes2` is more concise, and his initialization is more refactorizable when you change `B` or `C` names. But there are no other advantages over `classes1` in the later usage when you need to access it using string keys.\n"
      },
      {
        "user": "aluanhaddad",
        "created_at": "2016-06-25T21:45:11Z",
        "body": "Actually, I think this works better,\n(TypeScript 1.9.0-dev.20160624-1.0)\n\n``` TypeScript\nlet classes = { B, C };\n\nlet CPrime = classes[\"C\"]; // CPrime has the same type as C\nlet instance = new C(); // instance is an instance of C\nconsole.log(instance.c);\n```\n\nThe problem is the config file. The constant value does not seem to propagate across module boundaries. Forgot my idea of about using a _.ts_ configuration file. It only seems to work within one file.\n\nI had a thought that you could do \n\n``` TypeScript\nimport { classKey } from \"./config\"; // classKey is defined as \"export const classKey = 'C';\"\nlet CPrime = classes[classKey]; // Unfortunately has type any\n```\n\nEdit: It's not related to modules, it has to do with string literal type inference. Even if I give a variable an explicit string literal type, it does not flow from the variable to the index signature. There are a lot of issues related to this.\n"
      },
      {
        "user": "nahuel",
        "created_at": "2016-06-25T22:37:51Z",
        "body": "@aluanhaddad when I said \"a config file\" I meant an arbitrary JSON document loaded at runtime, not an imported \"config\" module. But yes, I think you are pointing to another valid issue.\n"
      },
      {
        "user": "aluanhaddad",
        "created_at": "2016-06-26T00:14:06Z",
        "body": "@nahuel that probably should have been obvious to me because otherwise they wouldn't have been much of a point to the scenario you described. Sorry if I got the issue off track. I don't see how TypeScript could provide this however, without compile time constants. A run-time scenario like you mention, where the type is decided based on dynamically imported configuration is going to have to do type assertions. There is an issue tracking type providers which may be closer to what you're looking for #3136\n"
      }
    ]
  },
  {
    "number": 9247,
    "title": "Cannot set property 'xyz' of undefined",
    "created_at": "2016-06-18T11:38:15Z",
    "closed_at": "2016-06-18T18:13:46Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/9247",
    "body": "It would seem like this is a (common?) bug that the compiler could catch for us.\n\nGiven this example class:\n\n``` javascript\nclass Foo {\n    bar: number;\n}\nlet a: Foo;\na.bar = 1;\n```\n\nAt runtime I will get an error 'Cannot set property 'bar' of undefined because I never actually initialized the object. (i.e. `let a: Foo = new Foo();` or `let a = new Foo();`)\nThis seems to me like it could probably be a pretty common developer mistake given the ability to provide types (: Foo), especially since editors will give you full Intellisense on the object just by naming the type of it without initialization.  I'm curious if it's something that the Compiler could catch?  (variable a is undefined; declared, but never initialized)\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/9247/comments",
    "author": "benjaminmillhouse",
    "comments": [
      {
        "user": "yortus",
        "created_at": "2016-06-18T13:25:50Z",
        "body": "If you use the `--strictNullChecks` compiler option, you'll get a compiler error stating `Variable 'a' is used before being assigned`. Is that what you are after?\n"
      },
      {
        "user": "yortus",
        "created_at": "2016-06-18T20:47:14Z",
        "body": "@benmillhouse it's only in the nightly version, so might not be documented yet. See #7140. \n"
      }
    ]
  },
  {
    "number": 9243,
    "title": "a class cannot extend events node module",
    "created_at": "2016-06-18T06:11:48Z",
    "closed_at": "2016-06-18T18:17:01Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/9243",
    "body": "**TypeScript Version:** \n\n1.8.10\n\n**Code**\n\n``` ts\n/// <reference path=\"./../../../typings/index.d.ts\" />\nimport {EventEmitter} from \"events\";\nclass _req extends EventEmitter {\n    constructor() {\n        super();\n    }\n    emit() {\n        super.emit(\"test\")\n    }\n}\nconst a = new _req();\na.on(\"test\", _ => {\n    console.log(\"test was called\");\n})\na.emit();\n```\n\n**Expected behavior:**\ncompile with no errors \n**Actual behavior:** \ni got the error telling me \n\n```\nts/core/request/index.ts(3,7): error TS2415: Class '_req' incorrectly extends base class 'EventEmitter'.\n  Types of property 'emit' are incompatible.\n    Type '() => void' is not assignable to type '(event: string, ...args: any[]) => boolean'.\n      Type 'void' is not assignable to type 'boolean'.\n```\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/9243/comments",
    "author": "ta3pks",
    "comments": [
      {
        "user": "kitsonk",
        "created_at": "2016-06-18T06:56:05Z",
        "body": "This isn't an issue with TypeScript.  This is basic stuff.  You should read the error and fix it.\n\nThe method you are extending does not match the contract of the underlying class.  As the error says, your extended `emit` is of type `() => void`, but the method you are extending is of type `(event: string, ...args: any[]) => boolean` and the need to be compatible, so at the very least `emit` need to return a boolean value.\n\nFor basic questions like these, StackOverflow, Gitter or IRC are better places to ask.\n"
      }
    ]
  },
  {
    "number": 9137,
    "title": "Allow to discard code when generating code.",
    "created_at": "2016-06-13T18:15:15Z",
    "closed_at": "2016-06-13T18:48:43Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/9137",
    "body": "I have JavaScript library , where I have multiple inheritance done with my own functions to extend.\n\nBut for intellisense purpose we have add some interface to allow lookup for function withing the classes and implemented dummy functions for completeness. But when generating the code, I would like to take that out.\n\nCan we added that feature take out some code when generating JS code.\nJust one switch let us say, #NOT_A_CODE #END_NOT_A_CODE ... and ignore the code in between.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/9137/comments",
    "author": "mubbasher16",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2016-06-13T18:22:41Z",
        "body": "Interfaces don't generate code; if you need to have a class that doesn't generate code, you can use the `declare` keyword to create an ambient class. There shouldn't be anything you need to do for intellisense / type information purposes that requires a construct that generates code.\n"
      },
      {
        "user": "mubbasher16",
        "created_at": "2016-06-13T19:10:31Z",
        "body": "It's not ambient class.\nit is actual class.  I get this error.\n[ts] 'declare' modifier cannot appear on a class element.\n\nSome stuff needs to be added to the class for intellisense. But It would be only added at runtime.\nby some other JS library say for instance.\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2016-06-13T19:43:05Z",
        "body": "not the class member, the whole class.\n\n``` ts\ndeclare class C {\n    property: number;\n    method(a: string): C;    \n}\n\n\nvar x = new C();\nx.method(\"string\");\n```\n"
      }
    ]
  },
  {
    "number": 8890,
    "title": "Unable to run Array.map on an Array",
    "created_at": "2016-05-31T07:45:40Z",
    "closed_at": "2016-05-31T09:48:34Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/8890",
    "body": "**TypeScript Version:** \n\n1.8\n\n**Code**\n\n``` ts\nfunction getARPTable() {\n    return new Promise((resolve, reject) => {\n        arp.table((error, devices) => {\n            if (error) reject(error);\n            else resolve(devices);\n        });\n    });\n}\n\nasync function scanPorts() {\n    let devices = await getARPTable();\n    console.log(Array.isArray(devices)); // true\n    devices = devices.map((device) => device); // error\n                      ^\n    return true;\n}\n\nscanPorts();\n```\n\n**Expected behavior:**\n\nNo error output\n\n**Actual behavior:** \n\n`error TS2339: Property 'map' does not exist on type '{}'.`\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/8890/comments",
    "author": "xeoneux",
    "comments": [
      {
        "user": "kitsonk",
        "created_at": "2016-05-31T09:31:33Z",
        "body": "TypeScript cannot contextually determine what the `Promise` resolves to (see: #5254) therefore you have to assert it.\n\nSomething like:\n\n``` typescript\nfunction getARPTable() {\n    return new Promise<any[]>((resolve, reject) => {\n        arp.table((error, devices) => {\n            if (error) reject(error);\n            else resolve(devices);\n        });\n    });\n}\n```\n"
      },
      {
        "user": "xeoneux",
        "created_at": "2016-05-31T09:37:51Z",
        "body": "@kitsonk Thanks! I created a similar interface to fix it. However, I am still not sure why does the error occur even after successful compilation to JavaScript and running under node?\n"
      },
      {
        "user": "kitsonk",
        "created_at": "2016-05-31T09:44:02Z",
        "body": "Because, instead of inferring type `any` for the `Promise` resolution, TypeScript infers `{}` which is an object with no properties, therefore doesn't have a `.map` method.  IIRC there was a lot of discussion in the ticket I linked to as to why `{}` instead of `any` makes sense when filling a generic that cannot be contextually determined.  By default, TypeScript will still emit the code, even if it has errors.  So while the run-time behaviour works, TypeScript couldn't be sure it would be when it emitted the code.\n"
      }
    ]
  },
  {
    "number": 8867,
    "title": "Bad inference when using void and &&",
    "created_at": "2016-05-27T22:02:23Z",
    "closed_at": "2016-06-07T21:48:11Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/8867",
    "body": "``` javascript\nconst a: void = undefined;\nconst b: number = 33;\n\nconst z = a && b;\n```\n\nz is always inferred to be of the same type as b, even though a is undefined.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/8867/comments",
    "author": "AlexGalays",
    "comments": [
      {
        "user": "Arnavion",
        "created_at": "2016-05-29T19:00:27Z",
        "body": "Without `--strictNullChecks` there is nothing wrong. `&&` is allowed when the left expression is of type `void` to maintain compatibility with JS, and `undefined` is a valid value for `number`.\n\nWith `--strictNullChecks` it should probably be inferred as `number | undefined | null`, but it's still inferred as `number`. That looks like a bug.\n"
      },
      {
        "user": "Arnavion",
        "created_at": "2016-06-07T23:08:37Z",
        "body": "For future reference, the bug I noted above doesn't happen if `a` is of type `undefined` instead of `void`. I imagine it's probably best to never use `void` as a holder for `undefined` values to reap the benefits of `--strictNullChecks`\n"
      },
      {
        "user": "AlexGalays",
        "created_at": "2016-06-08T06:31:10Z",
        "body": "Not sure what you mean, undefined is not a type?  Are you saying void should never be used at all in type annotations and we should just rely on type inference?\n\nAnyway, I'm not sure why this got closed without much explanation :(\n"
      },
      {
        "user": "kitsonk",
        "created_at": "2016-06-08T06:52:06Z",
        "body": "I think @Arnavion assumed TypeScript@next usage (as you didn't specify a version of TypeScript in the issue, though the issue template requests one).  In TypeScript 2.0, `undefined` and `null` are types that are removed from all other types (except `any`) and can be dealt with better.\n\nSo, if you feel like you need to be neurotic in your type annotations:\n\n``` typescript\nconst a: undefined = undefined;\n```\n\nIs a better way of representing `undefined`, but of course it being a `const`, therefore disallowing reassignment, the type annotation it entirely superfluous.\n\nTypeScript 2.0 introduces the compiler flag `--strictNullChecks` and @Arnavion noted that with `--strictNullChecks` the `void` type appears to not be handled properly, which he states is likely a bug, though I think @mhegazy might have not have noticed that, trying to quickly triage the name issues that are opened here.  On the other hand, the new types of `undefined` and `null` are handled properly, so it might not be a bug.\n\nIn 1.8, there is no `undefined` type, but the compiler is still working correctly, since `number` could be expressed as `number | undefined | null` in TypeScript 2.0 terms as all types are inclusive of those values, because JavaScript is a crazy language.  There is no concept of a hard \"bottom\" type in TypeScript 1.8.  `void` is only used to imply that no value is likely to be returned from an operation, but upon assignment, it doesn't \"hold\".\n\nSo in summary, there is an improvement of this in TypeScript 2.0 that lets you better model this, but technically TypeScript 1.8 isn't broken either.\n"
      },
      {
        "user": "AlexGalays",
        "created_at": "2016-09-01T15:15:38Z",
        "body": "I'm now happily using TS 2.0 and use the undefined type whenever it applies, however I still struggle to see what's the difference between undefined and void. Is that documented somewhere ?\n"
      },
      {
        "user": "kitsonk",
        "created_at": "2016-09-01T15:45:50Z",
        "body": "Like Cher, I suspect that if the TypeScript team could rollback time, `void` would not exist and `undefined` and `null` would have been distinct types from the start.\n\n`void` is intended to denote a return from a function where from an interface perspective, no one should depend upon any return.  It wasn't really a type, in the way `undefined` is.  Because of the significant breaking change of `strictNullChecks` this was introduced under a flag to avoid breaking all the stuff people already had (and make transition from JavaScript to TypeScript easy and potentially incremental).\n\nI am not sure it documented anywhere specifically yet.\n"
      }
    ]
  },
  {
    "number": 8642,
    "title": "Using interface of an enumeration and module merged type as generics type parameter",
    "created_at": "2016-05-17T09:45:41Z",
    "closed_at": "2016-05-18T09:31:49Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/8642",
    "body": "I found a strange behaviour of enumeration and module merging when using generics. Take a look at the following example:\n\n``` typescript\ninterface IEnumerationType {\n     getNames(): string[];\n}\n\nenum RoleType {\n    ApplicationRole,\n    CompanyRole,\n}\n\nmodule RoleType {\n    export function getNames(): string[] {\n        return [\"ApplicationRole\", \"CompanyRole\"];\n    }\n}\n\nvar r : IEnumerationType = RoleType;\n```\n\nIt compiles without error. The RoleType implements the IEnumerationType, it has a getNames method because of the enum+module merging.\n\nIf I want to use IEnumerationType and RoleType as a generic type parameter, it fails:\n\n``` typescript\ninterface MyInterface<TEnumeration extends IEnumerationType> {\n    enumerationType: TEnumeration;\n}\n\nvar x : MyInterface<RoleType>; // error, why? RoleType implements IEnumerationType\n```\n\nIs this a bug or is it a documented behaviour?\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/8642/comments",
    "author": "laszlojakab",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2016-05-17T19:18:14Z",
        "body": "The type name `RoleType` refers to a value of the enum type. Remember that you would normally write:\n\n``` ts\nlet x: RoleType = RoleType.CompanyRole;\n```\n\nThe type `RoleType` doesn't implement `IEnumerationType` because it's just a specialized subtype of `number`.\n\nThe type of the value `RoleType` itself is actually anonymous; you can refer to it using the `typeof` operator:\n\n``` ts\nvar x : MyInterface<typeof RoleType>; // OK\n```\n"
      }
    ]
  },
  {
    "number": 8498,
    "title": "interface optional methods not showing ",
    "created_at": "2016-05-06T12:25:37Z",
    "closed_at": "2016-05-09T08:37:15Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/8498",
    "body": "**TypeScript Version:** \n\n1.8.30\n\n**Code**\n\n``` ts\ninterface ITest {\n  init?();\n}\n\nclass Test implements ITest {\n  print() {\n    if (typeof this.init == \"function\")\n      this.init();\n  }\n}\n\nclass MyOwnTest extends Test {\n  init() {\n    // boo!  \n  }\n}\n```\n\n**Expected behavior:**\ncompiles without error\n\n**Actual behavior:** \nProperty 'init' does not exist in 'Test'\n\nWhy such construction? \nI would like to provide optional implementation of `init` in user derived type, and check in base class if it was really implemented.\n\ntoday I have to use `this[\"init\"]` - which is not strong type.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/8498/comments",
    "author": "pankleks",
    "comments": [
      {
        "user": "malibuzios",
        "created_at": "2016-05-06T12:58:21Z",
        "body": "_(tested on `1.9.0-dev.20160506`)_\n\nI believe it is possible to work around this by declaring an uninitialized property having a a function type in the base class:\n\n``` ts\ninterface ITest {\n    init?(): void;\n}\n\nclass Test implements ITest {\n    init: () => void; // when strict null checking is enabled,\n                      // '() => void | undefined' is possible here as well\n\n    print() {\n        if (typeof this.init == \"function\")\n            this.init();\n    }\n}\n\nclass MyOwnTest extends Test {\n    init = () => {\n        // boo!  \n    }\n}\n```\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2016-05-06T16:40:59Z",
        "body": "you can use a class/interface pair to define optional properties on a class, so \n\n``` ts\ninterface Test {\n    init?();\n}\n\nclass Test {\n    print() {\n        if (typeof this.init == \"function\")\n            this.init();  // OK\n    }\n}\n```\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2016-05-06T16:42:33Z",
        "body": "the other option is to use abstract classes/methods. not sure if this fits your requirements though,\n"
      }
    ]
  },
  {
    "number": 8475,
    "title": "is there a way to declare an interface with a method returning an anonymous class?",
    "created_at": "2016-05-05T16:37:36Z",
    "closed_at": "2016-05-05T17:31:17Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/8475",
    "body": "``` typescript\nfunction toClass() {\n    return class {}\n}\n\ninterface I {\n    toClass: () => { /* what goes here? */ }\n}\n\nconst i : I = {\n    toClass: toClass\n};\n\n// need the following to work:\nclass MyClass extends i.toClass() {\n\n}\n```\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/8475/comments",
    "author": "zpdDG4gta8XKpMCd",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2016-05-05T16:44:25Z",
        "body": "there is not a way to keep the class construct, but you should be able to declare it as a consttructor and instance type pair:\n\n``` ts\ninterface Base {\n ....\n}\n\ninterface I {\n    toClass: () => { new (...args: any[]) : Base }\n}\n```\n"
      }
    ]
  },
  {
    "number": 8260,
    "title": "Can't minus two Date object",
    "created_at": "2016-04-23T06:31:58Z",
    "closed_at": "2016-04-23T10:21:50Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/8260",
    "body": "**TypeScript Version:** \n\n1.8.9\n\n**Code**\n\n``` ts\n\"use strict\";\n\nlet start = new Date()\nlet end = new Date()\nconsole.log(start - end)\n```\n\n**Expected behavior:**\nprint the difference between two date\n**Actual behavior:** \ndon't compile when compile option  `noEmitOnError` is enabled. \nHere is the error message:\n\n``` bash\napp.ts(5,13): error TS2362: The left-hand side of an arithmetic operation must be of type 'any', 'number' or an enum type.\napp.ts(5,21): error TS2363: The right-hand side of an arithmetic operation must be of type 'any', 'number' or an enum type.\n```\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/8260/comments",
    "author": "bennyyip",
    "comments": [
      {
        "user": "Arnavion",
        "created_at": "2016-04-23T08:14:49Z",
        "body": "TS doesn't understand `valueOf`, so it doesn't consider `Date` to be intrinsically convertible to `number` for arithmetic operations. You have to be explicit with `end.getTime() - start.getTime()`\n"
      },
      {
        "user": "weswigham",
        "created_at": "2016-04-23T09:23:57Z",
        "body": "Explicitly coercing to a number with `+` also works.\n\n``` ts\n\"use strict\";\n\nlet start = new Date()\nlet end = new Date()\nconsole.log(+start - +end)\n```\n"
      },
      {
        "user": "mikemaccana",
        "created_at": "2017-10-18T14:45:13Z",
        "body": "A more explicit way to coerce to a Number is to use Number:\r\n\r\n    Number(new Date())"
      }
    ]
  },
  {
    "number": 8032,
    "title": "Empty object or type (`{} | Type`) doesn't work as expected",
    "created_at": "2016-04-12T19:19:44Z",
    "closed_at": "2016-04-12T20:06:31Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/8032",
    "body": "**TypeScript Version:** \n\n1.8.9\n\n**Code**\n\n``` ts\ninterface IAnimal {\n  legs: Number;\n}\n\ninterface IHouse {\n  cat: {} | IAnimal;\n}\n\nconst obj: IHouse = {\n  cat: {\n    legs: 2,\n  },\n};\n\nobj.cat.legs = 5;   // Property 'legs' does not exist on type '{} | IAnimal'.\nobj.cat = {};\n```\n\n**Expected behavior:**\n\nShould be able to assign `cat.legs` or `{}` interchangeably.\n\n**Actual behavior:** \n\nUnable to assign `legs` of `{} | IAnimal`.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/8032/comments",
    "author": "alexgorbatchev",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2016-04-12T19:22:25Z",
        "body": "You can't assign the `legs` property to `{}` (it has no members), and the `cat` property might be `{}`.\n\nWhat was your intent in writing `{} | IAnimal` ? This is a somewhat unusual thing to write and it's probably not doing what you think it does.\n"
      },
      {
        "user": "alexgorbatchev",
        "created_at": "2016-04-12T19:24:07Z",
        "body": "You are most likely correct. I'm trying to have a property where it could be a predefined type or an empty object `{}`. \n\n`{} | IAnimal` seemed like an intuitive thing to do, I couldn't find an existing example.\n"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2016-04-12T19:33:52Z",
        "body": ">  I'm trying to have a property where it could be a predefined type or an empty object `{}`.\n\nIn that case, what you wrote is correct (usually people use `null` or `undefined` as a placeholder, hence my question).\n\nFor this example, the best solution would be a type assertion, since the compiler doesn't know whether or not the `cat` property is `{}` or not:\n\n``` ts\ninterface IAnimal {\n  legs: Number;\n}\n\ninterface IHouse {\n  cat: {} | IAnimal;\n}\n\nconst obj: IHouse = {\n  cat: {\n    legs: 2,\n  },\n};\n\n(obj.cat as IAnimal).legs = 5;   // OK\nobj.cat = {};\n```\n\nThere are other solutions you could play with (writing a type predicate, making `legs` optional, etc) but it really depends on the situation.\n\nAs an aside, you _definitely_ want to use `number` instead of `Number`. `Number` refers to the boxed object you get from e.g. `new Number(5)`; `number` refers to actual numbers you'd commonly see in JS.\n"
      },
      {
        "user": "alexgorbatchev",
        "created_at": "2016-04-12T20:06:31Z",
        "body": "Interesting, thanks for clearing that up. I believe I see how it works now. Because there's no clear way to discern between `{}` and `IAnimal` compiler just choses the first one from `{} | IAnimal`, is that right?\n\nI got it work with making `legs` optional, which isn't ideal, because it's either all properties or an empty object (the actual code is more involved).\n\nThanks for the `number` correction, I haven't realized that.\n"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2016-04-12T20:53:10Z",
        "body": ">  Because there's no clear way to discern between {} and IAnimal compiler just choses the first one from {} | IAnimal, is that right?\n\nBasically. The rule for union types is that we only allow an operation if it would be legal to do on _each_ member of the union. Since `{}` doesn't have `legs`, the property assignment isn't allowed.\n\nDepending on context we can sometimes tell which you happen to have and will \"narrow\" to one member of the union (e.g. if there's an `instanceof` or `typeof` check), but this situation isn't one of them.\n"
      },
      {
        "user": "tonyxiao",
        "created_at": "2018-03-03T20:03:03Z",
        "body": "@RyanCavanaugh what if I actually want to define an empty object that may not have any properties? (such that the only acceptable value for that object is `{}`)? How would I define the type for that in TypeScript?"
      },
      {
        "user": "mhegazy",
        "created_at": "2018-03-03T20:16:57Z",
        "body": "use `object` instead."
      },
      {
        "user": "evenfrost",
        "created_at": "2018-05-16T16:13:47Z",
        "body": "`object` throws same error. I'm using this to define Vuex default state structure. Any way to define `empty object | Type`  without making all properties of `Type` optional?"
      }
    ]
  },
  {
    "number": 7790,
    "title": "[Question] - Is it possible to cast a type to an entire block?",
    "created_at": "2016-04-02T22:30:32Z",
    "closed_at": "2016-04-02T23:07:03Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/7790",
    "body": "Hi there,\n\nQuick question (or suggestion if this isn't possible):\n\nWhat I'm interested in doing is casting a type to an entire block (or to the rest of the current block). I do pretty explicit error handling, and I've found that I have to do this overly verbose `as <type>` statement each time. \n\nHere's a very pointless, but descriptive example:\n\n``` ts\ninterface Person {\n  firstname: string\n  lastname: string\n  age: number\n}\n\nfunction myFunc(x: boolean): Person|Error {\n  if (!x) {\n     return new Error('My error message');\n  }\n  return {\n    firstname: 'John',\n    lastname: 'Doe',\n    age: 45,\n  }\n}\n\nlet output = myFunc(true);\n\n// Handle the error\nif ((output as Error).name === 'Error') {\n  throw output;\n} \n\nconsole.log(\n  (output as Person).firstname + ' ' + (output as Person).lastname\n);\n\n```\n\nI'd like to assume that the `output` variable is of type Person after the if block that checks for an error. Is there any way to re-declare that it is type `Person` so that I don't have to do `(output as Person)` for everything thereafter?\n\nI hope that makes sense. Thanks a lot for the clarification! :smile: \n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/7790/comments",
    "author": "dsifford",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2016-04-02T23:01:31Z",
        "body": "This will be possible once type guards are rewritten to use flow control analysis (this work is currently in progress), assuming you add one helper function that creates an explicit type predicate.\n\nThe working version of the code (simplified) would look like this:\n\n``` ts\nfunction isError(p: any): p is Error {\n  return (p as Error).name === 'Error';\n}\n\nlet x: Person | Error = /* ... */;\n\nif (isError(x)) {\n  throw x;\n}\n\n// Because we know we can't get here if 'x' is 'Error',\n// all future uses of 'x' in this block are seen as type 'Person'\nlet n = x.firstname; // OK\n```\n"
      }
    ]
  },
  {
    "number": 7659,
    "title": "[Question] - Is there a syntax for defining interface properties of the same type on the same line?",
    "created_at": "2016-03-23T20:29:52Z",
    "closed_at": "2016-03-23T20:39:50Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/7659",
    "body": "Hello, \n\nSorry if this has been asked before. The issue history is massive and I couldn't locate it if it has. I also checked SO but didn't find anything.\n\nI'm coming from Golang and one thing that I like from there is the ability to declare properties of the same type on the same line (It reads cleaner IMO). \n\nIs this possible with Typescript?\n\nHere's how I'd define an interface (struct type) in Go\n\n``` go\ntype person struct {\n        firstName, lastName string\n        age int\n}\n```\n\nHere's how I do the same thing currently in TypeScript\n\n``` ts\ninterface person {\n  firstName : string\n  lastName : string\n  age : number\n}\n```\n\nHere's how I'd like to do it\n\n``` ts\ninterface person {\n  firstName, lastName : string\n  age : number\n}\n```\n\nThanks for the clarification! :smile: \n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/7659/comments",
    "author": "dsifford",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2016-03-23T20:37:15Z",
        "body": "It is not allowed to define multiple member declarations in the same declaration statements for interfaces, or classes. nor is it allowed for variable declarations.\n\nto get this behavior you will need to specify the type for each member. If no type is specified, the type is `any`.\n\nthis also applies for variable declarations.\n\n``` ts\nvar x, y : number;  // x : any, y: number\n```\n"
      }
    ]
  },
  {
    "number": 7641,
    "title": "Possible to add a static method on a union type?",
    "created_at": "2016-03-22T19:40:35Z",
    "closed_at": "2016-03-22T20:55:53Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/7641",
    "body": "I'm using C like a companion object in Scala:\n\n``` ts\ninterface A {\n  a: number\n}\ninterface B {\n  b: number\n}\nclass C {\n  a: number\n  b: number\n  static c(d: number): number {...}\n}\n```\n\nHow do I express that `C = A|B`? I can do\n\n``` ts\ninterface A {...}\ninterface B {...}\ntype C = A|B\n```\n\nBut then I lose the static method\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/7641/comments",
    "author": "bcherny",
    "comments": [
      {
        "user": "jeffreymorlan",
        "created_at": "2016-03-22T20:33:50Z",
        "body": "Just use a variable, not a class:\n\n``` ts\ntype C = A|B;\nvar C = {\n    c(d: number): number {...}\n};\n```\n"
      }
    ]
  },
  {
    "number": 7633,
    "title": "Index signature not inherited from interface to class",
    "created_at": "2016-03-22T09:31:25Z",
    "closed_at": "2016-03-29T00:06:57Z",
    "labels": [
      "Question",
      "Canonical"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/7633",
    "body": "``` ts\ninterface Foo {\n    [key:string]:any;\n}\n\ninterface Bar extends Foo {\n}\n\nclass Baz implements Foo {\n    [key:string]:any;\n}\n\nclass Qux implements Foo {\n}\n\nconsole.log((<Foo>{})['x']);\nconsole.log((<Bar>{})['x']);\nconsole.log((<Baz>{})['x']);\nconsole.log((<Qux>{})['x']);\n```\n\nOn `(<Qux>{})['x']` compiler fails with `Index signature of object type implicitly has an 'any' type.` message. When it's explicitly added to a class, like with `Baz`, everything works ok. With interfaces it seems to work fine, for example, `Bar` interface behaves as expected.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/7633/comments",
    "author": "iby",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2016-03-29T00:06:56Z",
        "body": "There is a distinction between `extends` and `implements` clauses for classes. `extends` means the current class inherits the shape of the parent; this includes index signatures, properties, and methods. `implements` on the other hand, is just a constraint. it says to the compiler, \"please check that this class incorrectly implements this interface\". there is nothing that is \"inherited\" by implementing the interface.\n\nTypeScript's type system is a structural one. so the implements clause is not required for an instance of this class to be assignable to an instance of the interface it implements. the only requirements, is that their structures match. As a matter of fact, removing the implement clause, should not change the semantics of your program.\n"
      }
    ]
  },
  {
    "number": 7430,
    "title": "Augmenting re-exported names from ambient module",
    "created_at": "2016-03-08T15:06:04Z",
    "closed_at": "2016-03-08T20:56:47Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/7430",
    "body": "**TypeScript Version:** \n\nnightly (1.9.0-dev.20160308)\n\n**Code**\n\n``` ts\n// test1.d.ts\ndeclare module 'test1/lib' {\n    export interface Test {\n        a: number;\n    } \n}\n\ndeclare module 'test1' {\n    export * from 'test1/lib';\n}\n\n// augment.d.ts\n\n/// <reference path=\"test1.d.ts\" />\nimport 'test1';\ndeclare module 'test1' {\n    interface Test { // Module augmentation cannot introduce new names in the top level scope. (2665)\n        b: string;\n    }\n}\n```\n\nShouldn't it be allowed?\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/7430/comments",
    "author": "asvetliakov",
    "comments": [
      {
        "user": "vladima",
        "created_at": "2016-03-08T20:47:59Z",
        "body": "re-exports does not add exported names into the local scope of the module - here module `test1` won't have local entry for `interface Test` so compiler error is correct.\n"
      }
    ]
  },
  {
    "number": 7357,
    "title": "Overloaded array type",
    "created_at": "2016-03-03T01:27:45Z",
    "closed_at": "2016-03-03T05:53:14Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/7357",
    "body": "I was unable to find this in the documentation or among the existing issues.\n\nIs there any way to have overloaded array types? Something that would look like:\n\n```\ninterface I {\n    [s: string]<T extends Bar>: T;\n    method<T extends Bar>(): T;   // this is allowed\n}\n```\n\nI guess it would also need a syntax at call-sites, which would look weird:\n\n```\ndeclare var array: I\n\n// and in client code:\nclass Foo extends Bar { foo(); }\narray[\"field\"]<Foo>.foo();\n```\n\n(As an aside, I'm not sure how to use the array type syntax)\n\nMy apologies if this is already do-able, I couldn't find a way...\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/7357/comments",
    "author": "Ptival",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2016-03-03T05:19:23Z",
        "body": "There isn't a direct way to do this, but really all you're doing is writing a type assertion at the indexing site. You could equivalently write:\n\n``` ts\ndeclare var array: { [s: string]: Bar; };\n(<Foo>array[\"field\"]).foo();\n```\n"
      },
      {
        "user": "Ptival",
        "created_at": "2016-03-03T05:42:50Z",
        "body": "It would indeed defer type assertions to the indexing site, but it could at least guarantee the subtyping condition.\n\nMy use case is for a JS library which registers multiple kinds of objects into an array.\nIf I just make it:\n\n```\ninterface W2UI {\n    [s: string]: any;\n}\ndeclare var w2ui : W2UI\n```\n\nThen I don't get any documentation/type-checking out of what comes out of the array.\nSince the main mode of interaction with the library is with:\n\n```\nw2ui[\"layout\"].layoutMethod();\nw2ui[\"tab\"].tabMethod();\n```\n\nIt becomes pretty much useless to even give type to anything.\n\nIs there a way to describe a type that is one of 7 classes, but is allowed to be any of them? (even when they are not compatible)\n"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2016-03-03T05:49:24Z",
        "body": "You could use a union type:\n\n``` ts\ninterface W2UI {\n  [s: string]: TabControl | InputControl | LabelControl;\n}\nvar arr: W2UI;\n// Just type assert\n(<InputControl>arr[\"input\"]).setValue();\n// N.B. still typesafeish\n(<HTMLDivElement>arr[\"nope\"]).blur(); // Error, can't convert HTMLDivElement to ...\n\n// Use some actual sanity checking\nconst x = arr['layout'];\nif(x instanceof TabControl) {\n  x.tabMethod();\n}\n```\n"
      }
    ]
  },
  {
    "number": 7090,
    "title": "Union type of string literals",
    "created_at": "2016-02-16T09:28:30Z",
    "closed_at": "2016-02-16T10:47:29Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/7090",
    "body": "With TypeScript 1.8, this code fails:\n\n```\ntype SomeString = ('string1' | 'string2') & ('string3' | 'string4');\nconst x: SomeString = 'string1';\n```\n\nWith the following error: `Type 'string' is not assignable to type '(\"string1\" | \"string2\") & (\"string3\" | \"string4\")'. Type 'string' is not assignable to type '\"string1\" | \"string2\"'. Type 'string' is not assignable to type '\"string2\"'`.\n\nIs this by design? Should it not be possible to use unions for string literal types?\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/7090/comments",
    "author": "andersekdahl",
    "comments": [
      {
        "user": "yortus",
        "created_at": "2016-02-16T10:36:42Z",
        "body": "The following _does_ work:\n\n``` typescript\ntype SomeString = 'string1' | 'string2' | 'string3' | 'string4';\nconst x: SomeString = 'string1';\n```\n\nSo it is possible to use unions for string literal types. Your example is an intersection, which `'string1'` cannot possibly satisfy, because it must simultaneously satisfy `'string3'|'string4'`, which it clearly can't.\n\nThe error message you are getting from tsc is not very helpful in this case.\n"
      }
    ]
  },
  {
    "number": 6830,
    "title": "qualified types in function header only with named parameter",
    "created_at": "2016-02-02T10:21:00Z",
    "closed_at": "2016-02-02T11:44:29Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/6830",
    "body": "This gives a compile error:\n\n```\n\nmodule b {\n  interface t {}\n}\n\nabstract class A {\n  abstract f(b.t) : void;\n}\n\n```\n\nThis compiles:\n\n```\n\nmodule b {\n  interface t {}\n}\n\nabstract class A {\n  abstract f(x : b.t) : void;\n}\n\n```\n\nQualifying the type t makes it necessary to name the parameter of the function although this should not be necessary.\n\nThis again works:\n\n```\n\nmodule b {\n  interface t {}\n}\n\nabstract class A {\n  type t = b.t;\n  abstract f(t) : void;\n}\n\n```\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/6830/comments",
    "author": "fphh",
    "comments": [
      {
        "user": "Arnavion",
        "created_at": "2016-02-02T10:57:46Z",
        "body": "That last example doesn't do what you think it does. `abstract f(t) : void` doesn't define a method which takes one parameter of type `t`, it defines a method which takes one parameter of type `any`.\n\nIn general, signatures in TS (function signatures, indexer signatures, etc.) have parameter name required and type optional. So reversing this for abstract method signatures will just cause confusion.\n\nAlso having parameter names is descriptive. And if you want to attach JSDoc you need to have a parameter name.\n"
      },
      {
        "user": "fphh",
        "created_at": "2016-02-02T11:44:29Z",
        "body": "Yes, I see my mistake. However it is strange that parameter names are mandatory and parameter types are optional. Note that we define already the arity of the function, and, thus, a partial type for it. Why not defining the whole type and making the parameter names optional? I think, that's a design question and I consider this issue closed.\n"
      },
      {
        "user": "Arnavion",
        "created_at": "2016-02-02T18:23:40Z",
        "body": "As I said, everywhere else parameter names are required and types optional.\n\nDefining a function - `function foo(a, b) { }` or `function foo(a: number, b: string) { }`\nDefining a method - `class Foo { bar(a, b) { } }` or `class Foo { bar(a: number, b: string) { } }`\n\nSo as I said it would be confusing to change the rules only for abstract methods and make it that `abstract bar(a, b)` means a and b are types.\n"
      }
    ]
  },
  {
    "number": 6806,
    "title": "Question: Interface with _at least one_ defined member?",
    "created_at": "2016-02-02T00:02:48Z",
    "closed_at": "2016-02-02T00:48:21Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/6806",
    "body": "In RxJS, we have a need for an interface that is basically this:\n\n``` TypeScript\ninterface Observer<T> {\n  next?: (value: T) => void;\n  error?: (err: any) => void;\n  complete?: () => void;\n}\n```\n\nbut you'll notice that it matches `{}` in that case, which isn't what we want. What we _really_ want is _at least one_ of those members.\n\nIt seems like I'd be able to do something with `PartialObserver<T> = NextObserver<T>|ErrorObserver|CompleteObserver`, but I'm honestly not sure how to accomplish this.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/6806/comments",
    "author": "benlesh",
    "comments": [
      {
        "user": "weswigham",
        "created_at": "2016-02-02T00:12:30Z",
        "body": "``` ts\ninterface NextObserver<T> {\n  next: (value: T) => void;\n}\ninterface ErrorObserver {\n  error: (err: any) => void;\n}\ninterface CompleteObserver {\n  complete: () => void;\n}\ntype Observer<T> = NextObserver<T> | ErrorObserver | CompleteObserver | (NextObserver<T> & ErrorObserver & CompleteObserver) | (ErrorObserver & CompleteObserver) | (NextObserver<T> & ErrorObserver) | (NextObserver<T> & CompleteObserver);\n```\n\nYou can enumerate the power set of interface combinations by hand, though I'll admit the definition is a little dense (and possibly more verbose than need be).\n"
      },
      {
        "user": "ahejlsberg",
        "created_at": "2016-02-02T00:26:34Z",
        "body": "Perhaps this?\n\n``` typescript\ninterface NextObserver<T> {\n  next: (value: T) => void;\n  error?: (err: any) => void;\n  complete?: () => void;\n}\ninterface ErrorObserver<T> {\n  next?: (value: T) => void;\n  error: (err: any) => void;\n  complete?: () => void;\n}\ninterface CompleteObserver<T> {\n  next?: (value: T) => void;\n  error?: (err: any) => void;\n  complete: () => void;\n}\ntype Observer<T> = NextObserver<T> | ErrorObserver<T> | CompleteObserver<T>;\n```\n"
      },
      {
        "user": "benlesh",
        "created_at": "2016-02-02T00:49:49Z",
        "body": "Also, @weswigham I tried the same thing you recommended, and (just for informational purposes) it caused compilation errors on the consumption side.  `observer.next()` would say `\"next\" does not exist on  NextObserver<T> | ErrorObserver | CompleteObserver | (NextObserver<T> & ErrorObserver & CompleteObserver) | (ErrorObserver & CompleteObserver) | (NextObserver<T> & ErrorObserver) | (NextObserver<T> & CompleteObserver);` unless I cast it first.\n"
      },
      {
        "user": "weswigham",
        "created_at": "2016-02-10T09:55:23Z",
        "body": "Just realized I never came back to this - the intention of my definitions would be for a strongly typed observer which _requires_ checks for members before calls are allowed. Pair the definitions in my prior post with type guards like so:\n\n``` ts\nfunction hasNext<T, U extends Observer<T>>(o: U): o is NextObserver<T> {\n  return !!(o as NextObserver<T>).next;\n}\n\nfunction hasComplete<T, U extends Observer<T>>(o: U): o is CompleteObserver<T> {\n  return !!(o as any).complete;\n}\n\nfunction hasError<T, U extends Observer<T>>(o: U): o is ErrorObserver<T> {\n  return !!(o as any).error;\n}\n```\n\nAnd use like so:\n\n``` ts\nconst obs: Observer<Observee> = fetchObs();\nfor (i=1, i<3, i++) {\n  if (hasNext(obs)) {\n    try {\n      thing = doThing()\n    }\n    catch (e) {\n      if (hasError(obs)) {\n        return obs.error(e);\n      }\n    }\n    obs.next(thing);\n  }\n}\nif (hasComplete(obs)) {\n  obs.complete()\n}\n```\n\nI _think_ I've got the types right for that, but I can't claim to have tested it, as it makes use of TS 1.8's F-Bounded Polymorphism, so I can't just drop it into the playground to test it yet (and I'm away from my PC at the moment).\n"
      }
    ]
  },
  {
    "number": 6641,
    "title": "Generics in indexers",
    "created_at": "2016-01-27T13:55:22Z",
    "closed_at": "2016-01-27T16:30:36Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/6641",
    "body": "Hi,\n\nI was wondering why something like that is not possible:\n\n``` javascript\ninterface IDictionary<TKey, TValue> {\n  [index: TKey]: TValue;\n}\n```\n\nit tells me: index signature parameter must be string or number\n\nI agree, but why I could not get this error when trying to use something else than string or number as TKey? Generics are analyzed at build time right? if so, this should be easy to find.\n\n``` javascript\n  temp: IDictionary<number, ...>;\n```\n\nshould work.\n\nI could even do something like this, to be more precise:\n\n``` javascript\ninterface IDictionary<TKey extends string | number, TValue>\n```\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/6641/comments",
    "author": "pankleks",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2016-01-27T16:30:36Z",
        "body": "String indexers and number indexers have very different effects on the types they're contained in. They're not really interchangeable in any meaningful way, so it's pointless to make them able to be based on generic type parameters.\n\nPractically speaking, you really have two types: `IDictionaryString<T> { [s: string]: T }` and `IDictionaryNumber<T> { [n: number]: T }`. There's nothing gained by making them generic.\n"
      }
    ]
  },
  {
    "number": 6622,
    "title": "export types not found",
    "created_at": "2016-01-26T13:19:47Z",
    "closed_at": "2016-01-29T22:46:40Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/6622",
    "body": "This might be a tad 'anti-typescript' but figured I throw it out anyway. I have a function that reads a array and dynamically creates exports like so:\n\n```\nconst methods = ['head', 'options', 'get', 'post', 'put', 'patch', 'del', 'delete', 'all']\nmethods.forEach(method => {\n  let methName = method.charAt(0).toUpperCase() + method.slice(1);\n  exports[`http${methName}`] = route.bind(null, method);\n});\n```\n\nFor obvs reasons, TypeScripts complains on compiling about this:\n\n```\n\u001b[100;30m\nsrc/api/ApplicationController.ts(1,22): error TS2305: Module '\"src/common/routing\"' has no exported member 'httpGet'.\n```\n\nIs there anything on the roadmap to do this type of dynamic / functional exports?\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/6622/comments",
    "author": "amcdnl",
    "comments": [
      {
        "user": "WreckedAvent",
        "created_at": "2016-01-26T14:13:50Z",
        "body": "You could do something like this:\n\n``` typescript\nconst methods = ['head', 'options', 'get', 'post', 'put', 'patch', 'del', 'delete', 'all'];\nconst toExport: {[action: string]: () => void} = {};\n\nmethods.forEach(method => {\n  let methName = method.charAt(0).toUpperCase() + method.slice(1);\n  toExport[`http${methName}`] = route.bind(null, method);\n});\n\nexport = toExport;\n```\n\nWhatever you type `toExport` to be should be what other files get from their `import`. \n"
      },
      {
        "user": "amcdnl",
        "created_at": "2016-01-29T15:18:36Z",
        "body": "@WreckedAvent  - I do other exports in the module, so I get a error saying like `export assignment can not be used with other export assignments...`\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2016-01-29T22:46:37Z",
        "body": "The shape of the module needs to be statically known. anything that is dynamic will not work. This is also the same semantics as ES6 modules. you are better of defining each as an export:\n\n``` ts\nexport const httpHead = route.bind(undefined, \"head\"); \n```\n\nthe other alternative, is you put these one level deeper inside the module:\n\n``` ts\nexport var exportedMethods: IMethods = {}\n\nmethods.forEach(method => {\n  let methName = method.charAt(0).toUpperCase() + method.slice(1);\n  exportedMethods[`http${methName}`] = route.bind(null, method);\n});\n```\n"
      }
    ]
  },
  {
    "number": 6543,
    "title": "Can't get to the instance type of a wrapped class across modules",
    "created_at": "2016-01-19T22:58:31Z",
    "closed_at": "2016-01-19T23:09:21Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/6543",
    "body": "Ran into this trying to leverage higher-order React components but it doesn't take much to reproduce:\n\nThing.ts\n\n``` typescript\nclass Thing { }\n\nfunction wrap<T>(classType: T): T {\n    return classType;\n}\n\nexport default wrap(Thing);\n```\n\nThingImporter.ts\n\n``` typescript\nimport Thing from \"./Thing\";\n\nlet thingInstance: Thing; //error: Cannot find name 'Thing'\nlet thingConstructor: typeof Thing; //ok\n```\n\nEven though the wrap function returns exactly what it takes in, the type gets changed from `class Thing` to `typeof Thing` and it seems this causes it to lose the class-reference-equals-instance-type magic in other modules.\n\nTS versions: 1.7.5 and 1.8.0-dev.20160119\ntsconfig:\n\n``` json\n{\n  \"compilerOptions\": {\n    \"module\": \"commonjs\",\n    \"target\": \"es5\"\n  }\n}\n```\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/6543/comments",
    "author": "jwbay",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2016-01-19T23:09:21Z",
        "body": "Thanks for reducing the repro.\n\nWhen we see an `export default` declaration, we expose \"all meanings\" of the expression on the right. The expression on the right, in this case, does not have any types, so there is no type meaning to expose.\n\nDoing a general purpose expansion of the right-hand side here is generally not tractable.\n\nIf you wanted to create a default export that had a type meaning, you could write something like this:\n\n``` ts\nclass _Thing { }\n\nfunction wrap<T>(classType: T): T {\n    return classType;\n}\n\nconst Thing: typeof _Thing = wrap(_Thing);\ntype Thing = _Thing;\nexport default Thing;\n```\n"
      },
      {
        "user": "jwbay",
        "created_at": "2016-01-19T23:29:38Z",
        "body": "Thanks for the quick reply! That works like a charm. I never would have thought to make an alias/local type with the same name as the actual export.\n\nFor anyone else who runs across this -- the root cause seems to be the wrap function and not so much the export. The same problem and fix applies within a single file.\n\n``` typescript\nfunction wrap<T>(classType: T): T {\n    return classType;\n}\n\nclass Thing { }\n\nconst ThingTwo = wrap(Thing);\nconst ThingThree = wrap(Thing);\ntype ThingThree = Thing;\n\nlet thingTwo: ThingTwo; //error: Cannot find name \"ThingTwo\"\nlet thingThree: ThingThree; //ok \n```\n"
      }
    ]
  },
  {
    "number": 6463,
    "title": "Cannot define type while destructuring in a $q.all ",
    "created_at": "2016-01-13T13:43:49Z",
    "closed_at": "2016-01-13T22:49:17Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/6463",
    "body": "<pre>\n$q.all([\n  IPromise&lt;type does not work here&gt;promise1,\n  promise2\n])\n.then([result1: &lt;can't define type here as well&gt;, result2] => { }`\n</pre>\n\n\nI have tried to type cast promise and tried to define type in `.then` as well and it still gives error. I have tried with simple function as well and it does not work for simple functions as well.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/6463/comments",
    "author": "khagesh",
    "comments": [
      {
        "user": "kitsonk",
        "created_at": "2016-01-13T18:57:11Z",
        "body": "These are best for other forums, like StackOverflow or gitter.im.\n\nYou need to understand tuple types in TypeScript better.\n\n``` typescript\n$q.all([ promise1, promise2 ])\n    .then(( [ result1, result2 ]: [ string, string ] ) => { });\n```\n"
      }
    ]
  },
  {
    "number": 6397,
    "title": "signature overloading breaking change?",
    "created_at": "2016-01-08T10:19:20Z",
    "closed_at": "2016-01-08T16:56:19Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/6397",
    "body": "Looks like that in 1.7.5 overloading order became significant in some cases\n\n1) specific first\n\n``` TypeScript\ndeclare class A {\n    f(x:string): any;\n    f(x:{[key: string]: any}): A;\n}\n\nvar a: A;\nvar x = a.f(\"A\") + 1;  // OK in both TS 1.7.5 and TS 1.5.3\n```\n\n2) specific second\n\n``` TypeScript\ndeclare class A {\n    f(x:{[key: string]: any}): A;\n    f(x:string): any;\n}\n\nvar a: A;\nvar x = a.f(\"A\") + 1; // Fails on TS 1.7.5 (Worked on 1.5.3). Inferred f result as A\n```\n\nIs it by design?\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/6397/comments",
    "author": "Artazor",
    "comments": [
      {
        "user": "ahejlsberg",
        "created_at": "2016-01-08T14:59:12Z",
        "body": "Yes, it is by design. Specifically, it is an effect of the change in #4074.\n"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2016-01-08T16:56:19Z",
        "body": "Overloading has always been order-sensitive -- the first signature that matches is the one that's selected.\n\nRecommended fix would be to replace `[key: string]: any` with `[key: string]: {}`\n"
      }
    ]
  },
  {
    "number": 6360,
    "title": "Cannot use type that is re-exported by another module",
    "created_at": "2016-01-05T16:29:34Z",
    "closed_at": "2016-01-05T17:49:45Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/6360",
    "body": "I'm trying to re-export a class from a module `bar.ts` that has been imported from `foo.ts`. The class itself is usable but its type cannot be used for declaring variables. I'm using latest typescript 1.8.0-dev.20160105 from npm:\n\nfoo.ts (type definition):\n\n```\nexport class Foo {\n}\n```\n\nbar.ts (type re-export):\n\n```\nexport = {\n  Foo: require('./foo')\n};\n```\n\nqux.ts (type usage):\n\n```\nimport Bar = require('./bar');\nvar foo: Bar.Foo;\n```\n\ntsconfig.json:\n\n```\n{\n  \"compilerOptions\": {\n    \"target\": \"es6\",\n    \"module\": \"commonjs\"\n  }\n}\n```\n\nThe actual error:\n\n```\n$ tsc\nqux.ts(2,10): error TS2503: Cannot find namespace 'Bar'.\n```\n\nI haven't found a way to re-export a type. It's useful for me to split up several database models in multiple files, and then aggregate all of them in a single file. However actually I'm losing the types.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/6360/comments",
    "author": "lucabrunox",
    "comments": [
      {
        "user": "DanielRosenwasser",
        "created_at": "2016-01-05T17:00:12Z",
        "body": "With `bar.ts`:\n\n``` ts\nexport = {\n  Foo: require('./foo')\n};\n```\n\nWe don't recognize that as `require` as an import form, so there's no type/namespace side that we know of.\n\nInstead, I'd suggest you use an ES2015 style export:\n- New `bar.ts`\n  \n  ``` ts\n  export { Foo } from \"./foo\";\n  ```\n\nWhile you're at it, you might as well use a new import form in `qux.ts` as well:\n\n``` ts\nimport * as Bar from \"./bar\";\nlet foo: Bar.Foo;\n```\n"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2016-01-05T17:39:15Z",
        "body": "If you really need to keep it as an `export =`, you'll need to use the old-style imports like so:\n\n``` ts\nexport import Foo = require(\"./foo\");\n```\n\nfor `foo.ts`.\n\nIf you use a module loader that automatically fixes up `export =` forms to `default` exports, you can use the `--allowSyntheticDefaultImports` which is available in the nightly.\n"
      },
      {
        "user": "lucabrunox",
        "created_at": "2016-01-05T17:44:46Z",
        "body": "Also `export import Foo = require('./foo');` + `export = Foo;` works very well.\n"
      }
    ]
  },
  {
    "number": 5877,
    "title": "Incorrect function return type: expected it to match generic type parameter",
    "created_at": "2015-12-02T00:33:12Z",
    "closed_at": "2015-12-02T00:45:29Z",
    "labels": [
      "By Design",
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/5877",
    "body": "I may just be abusing the type system here, but there's no warnings or errors, so I have to assume it should work. I'm trying to dispatch a command to a registered handler and return the result, which should be of the type specified by the command.\n\nQuestion is, why is the result always of type object, when the type parameter is clearly a string? Is this a bug or known limitation, and if so, is it a bug that there is no error or warning here?\n\n``` typescript\ninterface Command<T>\n{\n}\n\nclass TestCommand implements Command<string>\n{\n}\n\nfunction dispatch<T>(command: Command<T>): T\n{\n    let result: any = \"Result of executing the command handler\";\n\n    return result as T;\n}\n\nlet result = dispatch(new TestCommand());\n// Why is result of type object? I expected it to be a string.\n```\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/5877/comments",
    "author": "thomas-darling",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2015-12-02T00:45:29Z",
        "body": "The problem is that `T` is never manifested in the object, and since it is a structural type system, setting `T` to a string without using it has no impact on the inference. if you add a property `p: T` to your interface, your result should be of type `T`, in this case, `string` as you would expect.\n"
      }
    ]
  },
  {
    "number": 5778,
    "title": "Declaring a named module with call signature?",
    "created_at": "2015-11-24T21:05:51Z",
    "closed_at": "2015-11-25T21:55:15Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/5778",
    "body": "I'm having trouble typing the following scenario.\n\ndefs.d.ts\n\n```\ndeclare module \"my/module\" {\n  export = (arg: string) => any;\n}\n```\n\nmain.ts\n\n```\nimport myModule = require(\"my/module\");\nmyModule(\"hello\");\n```\n\nLine 2 in `main.ts` compiles fine, VS even shows the correct call signature, however, `defs.d.ts` does not compile correctly:\n`error TS2304: Cannot find name 'any'`\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/5778/comments",
    "author": "jseanxu",
    "comments": [
      {
        "user": "vladima",
        "created_at": "2015-11-24T21:43:09Z",
        "body": "can you define \"my/module\" like this?\n\n``` ts\ndeclare module \"my/module\" {\n    function f(arg: string) => any;\n    export = f;\n}\n```\n"
      }
    ]
  },
  {
    "number": 5629,
    "title": "Tests: no way ensuring that super has been called.",
    "created_at": "2015-11-12T01:39:36Z",
    "closed_at": "2015-11-13T06:37:04Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/5629",
    "body": "When writing tests (using Jasmine in my case), how can one ensure that the super of a class is called?\n\nFor instance, in the following code:\n\n```\nclass Snake extends Animal {\n    constructor(name: string) { super(name); }\n    move(meters = 5) {\n        alert(\"Slithering...\");\n        super.move(meters);\n    }\n}\n```\n\nHow can one write a test ensuring `super.move()` is called when `Snake.move()` is called?\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/5629/comments",
    "author": "Izhaki",
    "comments": [
      {
        "user": "bmayen",
        "created_at": "2015-11-12T02:54:51Z",
        "body": "Should be able to spy on it and then check if it was called with `toHaveBeenCalled`\n"
      },
      {
        "user": "Izhaki",
        "created_at": "2015-11-12T10:58:10Z",
        "body": "@bmayen how?\n\nI can't see `super` anywhere on the prototype.\n\n@DanielRosenwasser, might be phrased as a question, but I'm really arguing this cannot be done and thus an issue.\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2015-11-13T06:37:04Z",
        "body": "there is no entity called `super` super is just an alias to the class you are extending. in this case, `Animal`. so as @bmayen mentioned, `Animal.move` is what you want to check to have been called.\n"
      },
      {
        "user": "Izhaki",
        "created_at": "2015-11-13T16:24:55Z",
        "body": "@mhegazy Still not sure I understand. `Animal` is a class, not an instance.\n\nJust to make it more concrete, given this code:\n\n```\nclass Painter extends Transformer {\n\n    //.... \n\n    translate( aTranslation: Point ) {\n        this.context.translate( aTranslation.x , aTranslation.y );\n        super.translate( aTranslation );\n    }\n\n}\n```\n\nThe test:\n\n```\ndescribe( 'translate()', function() {\n\n    beforeAll( function () {\n        spyOn( iPainter.context, 'translate' );\n        iPainter.translate( new Point( 10, 20 ) );\n    });\n\n    it( 'Should translate the context', function() {\n        expect( iPainter.context.translate ).toHaveBeenCalledWith( 10, 20 );\n    });\n\n    it( 'Should call translate on its super', function() {\n        // What's here???\n    });        \n\n});\n```\n\nWhat would be the line to replace `What's here???`\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2015-11-13T17:18:14Z",
        "body": "``` ts\nvar originalTransformenrTranslate = Transformer. prototype.translate;\nTransformer. prototype.translate = function (...args) {\n    console.log(\"Transformer.translate is called!\");\n    originalTransformenrTranslate.apply(this, args);\n}\n\nvar originalPainterTranslate = Painter. prototype.translate;\nPainter. prototype.translate = function (...args) {\n    console.log(\"Painter.translate is called!\");\n    originalPainterTranslate.apply(this, args);\n}\n\n```\n"
      }
    ]
  },
  {
    "number": 5609,
    "title": "Destructuring and function properties",
    "created_at": "2015-11-11T09:59:00Z",
    "closed_at": "2015-11-11T10:56:12Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/5609",
    "body": "Hi,\n\nwe are using Visual Studio 2013 with TS 1.6\n\ni don't get why this is valid:\n\n``` typescript\nfunction foo({bar: string}) {}\n```\n\nbut this leads to a compile error:\n\n``` typescript\nfunction foo({bar: () => string}) {}\n```\n\nCompile error message is \"Cannon find name string\".\n\nFor me this is a defect behavior. What do you guys think?\n\nKind regards,\nTimo\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/5609/comments",
    "author": "Kinchkun",
    "comments": [
      {
        "user": "falsandtru",
        "created_at": "2015-11-11T10:24:11Z",
        "body": "Correct code example:\n\n``` ts\nfunction foo1({bar}: {bar: () => string}) {}\nfunction foo2({bar = () => ''}: {bar?: () => string}) {}\n```\n"
      }
    ]
  },
  {
    "number": 5570,
    "title": "Unable to define async function type",
    "created_at": "2015-11-09T10:08:09Z",
    "closed_at": "2015-11-10T01:24:16Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/5570",
    "body": "I'm just wondering if I could define an async function type. I want to create an interface where one of the properties of the interface is an async method.\n\n``` typescript\ninterface Setup {\n     asyncMethod: async () => Promise<any>; // cannot find name 'async'.\n}\n```\n\nThe reason I want to await, is so I can await on a function that returns a promise from a JS library. Also await on any type isn't working either.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/5570/comments",
    "author": "tinganho",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2015-11-09T17:44:57Z",
        "body": "`async` is only allowed in implementation. use `Promise`\n\n``` ts\ninterface Setup {\n    asyncMethod: () => Promise<number>;\n}\n\nasync function asyncMethodImplementation() {\n    return 0;\n}\n\nvar s: Setup;\n\ns.asyncMethod = asyncMethodImplementation;\n```\n"
      }
    ]
  },
  {
    "number": 5568,
    "title": "Definition file: unable refernce top namespace",
    "created_at": "2015-11-09T09:11:24Z",
    "closed_at": "2015-11-10T04:33:32Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/5568",
    "body": "This code (.ts) compiles fine\n\n```\nnamespace A {\n    export enum TestEnum { One };\n}\n\nnamespace A {\n    namespace B {\n        namespace A {\n            class Test {\n                main(): TestEnum {\n                    return TestEnum.One;\n                }\n            }\n        }\n    }\n}\n```\n\nThis code (.d.ts) \n\n```\ndeclare namespace A {\n    export enum TestEnum { One }\n}\n\ndeclare namespace A {\n    namespace B {\n        namespace A {\n            class Test {\n                main(): A.TestEnum.One;\n            }\n        }\n    }\n}\n```\n\ncompiles with error `error TS2305: Build: Module 'A.B.A' has no exported member 'TestEnum'.`\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/5568/comments",
    "author": "MarenkovIgor",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2015-11-09T17:59:36Z",
        "body": "what version of typescript are you using? \n\nI can not seem to get a repro for this on latest:\n\n``` ts\nnamespace A {\n    export enum TestEnum { One };\n}\n\nnamespace A {\n    export namespace B {\n        export namespace A {\n            export class Test {\n                main(): TestEnum {\n                    return TestEnum.One;\n                }\n            }\n        }\n    }\n}\n```\n\ncompiling using:\n\n``` shell\n> tsc --v\nmessage TS6029: Version 1.8.0-dev.20151105\n\n> tsc C:\\test\\file1.ts --d\n```\n\nproduces:\n\n``` ts\ndeclare namespace A {\n    enum TestEnum {\n        One = 0,\n    }\n}\ndeclare namespace A {\n    namespace B {\n        namespace A {\n            class Test {\n                main(): TestEnum;\n            }\n        }\n    }\n}\n```\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2015-11-09T18:06:00Z",
        "body": "maybe i miss understood. is this .d.ts generated by the compiler or hand authored?\n\nif it is hand authored, then a few comments:\n- using the enum value `A.TestEnum.One` in a type location is not allowed, I am guessing you actually mean `TestEnum`\n- your inner namespace `A` shadows the outer `A`, so when you refer to `A` here it always means the inner one, which does not have a `TestEnum` on it.\n- options: \n  1. do not qualify it, and let the compiler find it in any enclosing scope, \n     2.if this is not possible e.g. there is another TestEnum in the path and you really want the outer one use aliasing to get the correct qualification.\n\ne.g.:\n\n``` ts\ndeclare namespace A {\n    import outerA = A;\n    namespace B {\n        namespace A {\n            class Test {\n                main(): outerA.TestEnum;\n            }\n        }\n    }\n}\n```\n"
      }
    ]
  },
  {
    "number": 5303,
    "title": "Duck typing on anonymous object literals and class objects",
    "created_at": "2015-10-17T06:29:13Z",
    "closed_at": "2015-10-18T22:57:44Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/5303",
    "body": "Based on new duck typing concept fresh objects can not have access property.\nLike this\n\n``` javascript\nlet a = { name:\"Bill\"};\nlet b = {name:\"Bill\", age:20};\n\na = {name: \"James\", age:30 }; // Error - excess property not allowed\na = b; // No error - works fine\n```\n\nNow the questions is does this concept also applies to class objects\nLike this:\n\n``` javascript\nclass Human {    \n    name: string;    \n    constructor(name: string){\n        this.name = name;\n    }\n}\n\nclass Animal {\n    name: string;\n    age: number;    \n    constructor(name: string, age: number){\n        this.name = name;\n        this.age = age;\n    }\n    eat(){\n        console.log(this.name + \" is a Human and is eating\");\n    }\n}\n\nlet h1 = new Human(\"James\");\nlet a1 = new Animal(\"Dog\", 2);\nh1 = new Animal(\"Cat\", 1); //this is working -- But based on duck typing concept it should not because it has excess property and its fresh object\n```\n\nThe error is same if I remove constructor.\n\nIs there any difference in duck typing concept for anonymous objects and class objects OR may be I'm missing something?\nOr is it really considered as fresh object?\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/5303/comments",
    "author": "zeeshanhanif",
    "comments": [
      {
        "user": "DanielRosenwasser",
        "created_at": "2015-10-17T08:08:49Z",
        "body": "_Object literals_ have an associated freshness before they're bound to a variable. The same doesn't apply for any other expressions.\n\nThe idea is that object literals are often used for option bags (where the user has to manually type out each property name at each use-site), and this behavior catches typos.\n\nIf you'd like to prevent `Animal` from being assigned to a `Human`, you can add a `private` property to `Animal`, since `private` and `protected` properties need to originate from the same declaration to be compatible.\n"
      }
    ]
  },
  {
    "number": 5180,
    "title": "sourceRoot should support relative paths and respect folder hirearchy",
    "created_at": "2015-10-08T19:12:20Z",
    "closed_at": "2015-10-09T02:10:59Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/5180",
    "body": "When supplying sourceRoot, it is just directly copied into the source map file as is. This doesn't work correctly with rootDir and outDir options. For example, if I have the following structure:\n\nrepo/src/www/foo.ts\nrepo/src/bar.ts\n\nand I want to output the files into repo/out/, I tried using sourceRoot: '../src' and that works okay for bar.js, but not www/foo.js. I hope this explanation makes sense.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/5180/comments",
    "author": "seanzer",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2015-10-08T22:14:40Z",
        "body": "`sourceRoot` represents the root to use by the debug to locate the sources relative to. if you just want a relative path, do not set sourceRoot and the right thing should happen..\n\nso here is my setup:\n\ntsconfig.json\n\n``` json\n{\n    \"compilerOptions\": {\n        \"rootDir\": \"./\",\n        \"outDir\": \"./out\",\n        \"sourceMap\": true\n    }\n}\n```\n\ncompiling, i get:\n\n``` cmd\nC:\\test\\5180>type out\\bar.js.map\n{\"version\":3,\"file\":\"bar.js\",\"sourceRoot\":\"\",\"sources\":[\"../src/bar.ts\"],\"names\":[],\"mappings\":\"AAAA,IAAI,CAAC,GAAE,CAAC,CAAC\"}\nC:\\test\\5180>type out\\www\\foo.js.map\n{\"version\":3,\"file\":\"foo.js\",\"sourceRoot\":\"\",\"sources\":[\"../../src/www/foo.ts\"],\"names\":[],\"mappings\":\"AAAA,IAAI,CAAC,GAAG,CAAC,CAAC\"}\n```\n"
      },
      {
        "user": "pleerock",
        "created_at": "2016-07-14T04:31:06Z",
        "body": "@mhegazy @sheetalkamat  I have following tsconfig.json:\n\n``` json\n{\n    \"compilerOptions\": {\n        \"rootDir\": \"./\",\n        \"outDir\": \"./out\",\n        \"sourceMap\": true\n    }\n}\n```\n\nmy sources are in **./src**\nAnd in source maps I have `\"sources\":[\"../../src/index.ts\"]`\nThis is correct for development, but what I want to do for production build is `\"sources\":[\"src/index.ts\"]` (because I emit source maps with source code, and want in production build to have ts near its js). Is there way to do it?\n"
      }
    ]
  },
  {
    "number": 5057,
    "title": "jake local fails",
    "created_at": "2015-10-01T18:55:28Z",
    "closed_at": "2015-11-13T06:28:38Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/5057",
    "body": "Hi,\n  since I have a few issues with tsx inside vs, I would like to use the latest language service instead of the packaged one to see if something is different.\n  I updated my typescript clone and launched **jake local** (I have already done this in the last months) but this time fails:\n  if I run from a command shell I obtain this error message\n\n> jake aborted.\n> Error: Cannot find module 'tslint'\n>    at Function.Module._resolveFilename (module.js:336:15)\n>    at Function.Module._load (module.js:278:25)\n> (See full trace by running task with --trace)\n\nif I run from powershell\n\n> module.js:338\n>    throw err;\n>          ^\n> Error: Cannot find module 'lru-cache'\n>    at Function.Module._resolveFilename (module.js:336:15)\n>    at Function.Module._load (module.js:278:25)\n>    at Module.require (module.js:365:17)\n>    at require (module.js:384:17)\n>    at D:\\GitHub\\typescript\\node_modules\\jake\\node_modules\\filelist\\node_modules\\minimatch\\minimatch.js:35:11\n>    at Object.<anonymous> (D:\\GitHub\\typescript\\node_modules\\jake\\node_modules\\filelist\\node_modules\\minimatch\\minimatch.js:1057:3)\n>    at Module._compile (module.js:460:26)\n>    at Object.Module._extensions..js (module.js:478:10)\n>    at Module.load (module.js:355:32)\n>    at Function.Module._load (module.js:310:12)\n\nThis is the first time I see something similar. Am I missing something?\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/5057/comments",
    "author": "lucamorelli",
    "comments": [
      {
        "user": "danquirk",
        "created_at": "2015-10-01T19:15:51Z",
        "body": "Run 'npm install' to update the necessary dependencies.\n"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2015-10-01T21:29:30Z",
        "body": "@weswigham does `&&` execute conditionally in PowerShell?\n"
      },
      {
        "user": "weswigham",
        "created_at": "2015-10-01T22:07:35Z",
        "body": "`&&` was removed from powershell as a valid deliminator recently, I think. You have to use `;` instead.\n"
      },
      {
        "user": "weswigham",
        "created_at": "2015-10-01T22:23:05Z",
        "body": "Cross-shell compatibility has never been easy... ahh... `|` I believe is supported on most shells, which could work if everything that needs to be run doesn't care about the output of the prior process...\n"
      },
      {
        "user": "weswigham",
        "created_at": "2015-10-01T22:26:30Z",
        "body": "@DanielRosenwasser But his question why why it worked in powershell but not in cmd, so I'm not sure it's important.\n"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2015-10-01T22:29:04Z",
        "body": "This means that PowerShell wasn't explicitly failing even though `tslint` wasn't present.\n"
      },
      {
        "user": "weswigham",
        "created_at": "2015-10-01T22:54:07Z",
        "body": "Looking at his stack traces, the different is that in powershell he was never even able to load `jake` from the local node_modules dir whereas in `cmd` he had at least gotten `jake` installed and started to read the jakefile before it got to the missing tslint dependency.\n"
      },
      {
        "user": "weswigham",
        "created_at": "2015-10-01T22:54:45Z",
        "body": "I don't see anything there that would have anything to do with a `&&` at all.\n"
      },
      {
        "user": "weswigham",
        "created_at": "2015-10-01T23:01:18Z",
        "body": "@DanielRosenwasser Also, TIL `;` is a valid separator in bash. I've always used `&&`.\n"
      }
    ]
  },
  {
    "number": 4968,
    "title": "Cannot export class expressions",
    "created_at": "2015-09-25T12:58:54Z",
    "closed_at": "2015-09-28T18:18:25Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/4968",
    "body": "```\nvar SomeClass = new (class\n{\n\n});\n```\n\nYields:\nExported variable 'SomeClass' has or is using private name '(Anonymous class)'.\n\nBug? Spec?\n\n(My goal was to use this structure as a singleton class of sorts, rather than making a class and remembering to mark all members as static)\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/4968/comments",
    "author": "Truebase-com",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2015-09-25T16:47:42Z",
        "body": "This error is generated as the compiler is writing the declaration file; it could not write a type annotation for your variable; generally a class types can not be inlined as  an object type literal, and the winter does not introduce new named declarations that were not in the file. One possible change is to allow for class expressions to be used at type position. \n\nTo Silve this issue, either make it a class declaration or give your variable an explicit type annotation so the .d.ts file can use it instead.\n"
      },
      {
        "user": "ahejlsberg",
        "created_at": "2015-09-25T18:24:12Z",
        "body": "Just as an aside, a simple way to make a singleton is to export a namespace:\n\n``` typescript\nexport namespace Utils {\n    export function foo(...) {...}\n    export function bar(...) {...}\n}\n```\n"
      }
    ]
  },
  {
    "number": 4927,
    "title": "Inline casting? ",
    "created_at": "2015-09-22T14:57:10Z",
    "closed_at": "2015-09-22T16:20:04Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/4927",
    "body": "Instead of doing something like the following:\n\n```\nlet myCastedObj = <SomeType>obj\n\nmyCastedObj.doSomething()\n```\n\nCan I do the following?\n\n```\n<<SomeType>obj>.doSomething()\n```\n\nIt _seems_ like I can't but is there a way to achieve this?\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/4927/comments",
    "author": "iam3yal",
    "comments": [
      {
        "user": "kitsonk",
        "created_at": "2015-09-22T15:25:44Z",
        "body": "``` typescript\n(<SomeType> obj).doSomething();\n```\n"
      }
    ]
  },
  {
    "number": 4863,
    "title": "Manually add to SystemJS imports, just like <amd-dependency> does for AMD",
    "created_at": "2015-09-18T19:57:14Z",
    "closed_at": "2015-09-18T20:54:22Z",
    "labels": [
      "Needs More Info",
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/4863",
    "body": "I'm developing with Aurelia which uses SystemJS loader. \nThere are cases where I need to use special kind of \"import\" to load CSS dynamically.\nwhile the code below is fine with Babel, it obviously doesn't compile with TypeScript\n`import 'bootstrap/css/bootstrap.css!'`\n\nTo make use of this feature I had to switch to AMD module loader and use `<amd-dependency path=\"bootstrap/css/bootstrap.css!\">` which emits proper code\n\nI'd love to see similar feature for SystemJS\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/4863/comments",
    "author": "migajek",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2015-09-18T20:07:16Z",
        "body": ">  it obviously doesn't compile with TypeScript\n\nthis compiles fine for me. what version are you using?\n\n``` cmd\nc:\\ts>type c:\\test\\module3.ts\nimport 'bootstrap/css/bootstrap.css!'\n\nc:\\ts>tsc c:\\test\\module3.ts --m system\n\nc:\\ts>type c:\\test\\module3.js\nSystem.register(['bootstrap/css/bootstrap.css!'], function(exports_1) {\n    return {\n        setters:[\n            function (_1) {}],\n        execute: function() {\n        }\n    }\n});\n```\n"
      }
    ]
  },
  {
    "number": 4710,
    "title": "Ability to exclude some compiled .ts files from output",
    "created_at": "2015-09-09T14:33:26Z",
    "closed_at": "2015-09-10T16:10:07Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/4710",
    "body": "It would be good (and probably necessary for big projects) to have implementation that supports the following (I will provide a concreate example) use case:\n1. I have the terminal.ts file that depends on the core.ts, env.ts files:\n\n```\n///<reference path=\"env\">\n///<reference path=\"core\">\n\n// this is terminal.ts\n```\n1. I already included the compiled version of it in the main index.html file:\n\n``` html\n<html>\n...\n<script src=\"env-core-terminal_merged.js\"></script>\n</html>\n```\n\nThe env-core-terminal_merged.js contains compiled content of the following files: env.ts, core.ts, terminal.ts. I created the env-core-terminal_merged.js file with the following command:\n\n```\ntsc --out public/js/env-core-terminal_merged.js terminal.ts\n```\n\nIn this case the tsc will find all files (env.ts and core.ts) using ///reference directive and merge them into one.\n3. Now for some area of the site I need other files, say editor.ts that depends on env.ts, core.ts and other editor specic files: color.ts, mode.ts:\n\n```\n///<reference path=\"env\">\n///<reference path=\"core\">\n///<reference path=\"color\">\n///<reference path=\"mode\">\n\n// this is editor.ts\n```\n\nI want to include it like this:\n\n``` html\n<html>\n...\n<script src=\"env-core-terminal-merged.js\"></script>\n<script src=\"color-mode-editor_merged.js\"></script>\n</html>\n```\n\nand I created it with the following command:\n\n```\ntsc --out public/js/color-mode-editor_merge.js editor.ts\n```\n\nBut now there is a problem: as the editor.ts depends on the core.ts and env.ts the tsc will paste the compiled content of them into the color-mode-editor_merged.js again. But I need to have only one the compiled content of the core.ts, env.ts be included. I can't include only one file that will have compiled content for the all .ts files and replace the env-core-terminal-merged.js with it, because the site has block architecture and each block can define its own javascript files and have a common part for all blocks (in this case the common part is defined in the env-core-terminal-merged.js) For now to resolve of this problem I can only open the color-mode-editor_merged.js with editor and delete the compiled content of the core.ts and env.ts by hand (manually).\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/4710/comments",
    "author": "ghost",
    "comments": [
      {
        "user": "weswigham",
        "created_at": "2015-09-09T17:24:18Z",
        "body": "I believe the conventional wisdom right now is to reference the generated `.d.ts` files for the files whose sources you don't wish to compile, rather than the original sources.\n"
      }
    ]
  },
  {
    "number": 4687,
    "title": "Declare variable as typeof external module without import",
    "created_at": "2015-09-08T03:36:12Z",
    "closed_at": "2015-09-08T21:30:12Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/4687",
    "body": "Hey there,\n\nIs it possible to write an external (commonjs) module \"A\", then in another module \"B\"'s code, declare a variable as being typeof module \"A\" without using import which ends up require-ing module \"A\".\n\nThe reason I want to do this is that I will be passing a reference to module \"A\" to the constructor of a class in another module \"B\", because I want module \"A\" to be a singleton. But I want to type the argument in the constructor to that of module \"A\", as if module \"A\" had been imported using import A = require(\"A\");\n\nThe reason I want a singleton module is that this module might contain instances of classes that manage database connections, etc, and I don't really want them re-initialising each time I have to import; I want to be able to pass them around rather than rely on potential \"node-module cache\" magic.\n\nIs there a way to do this? I've thought of other ways I can achieve want I want but this feels like the simplest, if it's possible.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/4687/comments",
    "author": "Roam-Cooper",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2015-09-08T17:59:56Z",
        "body": "Module imports are elided if they are not used in a value position. so if your import of module `A` is only used in a type position the `require` call will not be written out.\n\nfor instance:\n\n``` ts\n// B.ts\nimport s = require(\"./A\");\nvar x: typeof s;\n```\n\nemits\n\n``` js\nvar x;\n```\n\ndoes this answer your question?\n"
      },
      {
        "user": "BaamAadmi",
        "created_at": "2018-01-10T07:50:01Z",
        "body": "Hi Folks,\r\nI have a question which is on the same lines. I tried above solution but it did now work for me. \r\nI am importing classes from a webpack module parent   import { A, B } from \"parent\";\r\nI simply want to call constructor for these classes. I tried  const a = A( { data: 1} );  This does not give any TS error on compile. But it breaks on runtime javascript saying ,   Type error A is not a constructor. \r\n\r\nDo I need to create custom types and add it in devDependancies ? Or is there a specific way to export my \"parent\" module like export default. \r\n\r\nAny help is appreciated. \r\n\r\nCheers,\r\nSudeep"
      }
    ]
  },
  {
    "number": 4635,
    "title": "Interface in function declaration statement",
    "created_at": "2015-09-04T06:32:18Z",
    "closed_at": "2015-09-04T16:47:45Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/4635",
    "body": "There is a interface like this:\n\n``` ts\ninterface searchFunc {\n    (source: string, subString: string): boolean;\n}\n```\n\nI know I can use it in **function definition expression**:\n\n``` ts\nvar mySearch: searchFunc = function(src, sub) {\n    var result = src.search(sub);\n    if (result == -1) {\n        return false;\n    }\n    else {\n        return true;\n    }\n}\n```\n\nBut how can I use it in **function declaration statement** like below? Do I need to change the structure of interface?\n\n``` ts\nfunction mySearch(src, sub): searchFunc {\n    var result = src.search(sub);\n    if (result == -1) {\n        return false;\n    }\n    else {\n        return true;\n    }\n}\n```\n\nI'm waiting online,hope a answering.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/4635/comments",
    "author": "ChuanfengLai",
    "comments": [
      {
        "user": "DanielRosenwasser",
        "created_at": "2015-09-04T07:03:34Z",
        "body": "The short answer is you can't do it for a function declaration, only a function expression. You can still use your interface to ensure that when passing `mySearch` somewhere that its type is compatible, but you can't have your parameter types inferred the same way.\n"
      }
    ]
  },
  {
    "number": 4323,
    "title": "outDir compiler option description or function unclear",
    "created_at": "2015-08-14T23:44:40Z",
    "closed_at": "2015-08-17T17:41:04Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/4323",
    "body": "The description \"Redirect output structure to the directory\" seems to imply mimicing of the source structure in the specified directory. \n\nFor example, I take the above description to mean:\nif source is \"app/app.ts\", then output should be <outDir>/app/app.js\n\nOutputs are placed in directory without structure. What is the correct behavior? \n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/4323/comments",
    "author": "ldminoc",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2015-08-17T17:41:04Z",
        "body": "`--outDir` will mimic the input structure. the root of the input files is computed to be the longest common subpath of all input files, if you have one file, that is not going to work obviously.\n\nuse `--rootDir` to tell the compiler where is the root of your sources is. so in your case `--rootDir ./` should result in `<outDir>/app/app.js`\n"
      }
    ]
  },
  {
    "number": 4192,
    "title": "Bug: code repeated in my cordova appBundle.js",
    "created_at": "2015-08-06T18:33:46Z",
    "closed_at": "2015-08-06T21:02:52Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/4192",
    "body": "With Visual Studio 2015 RTM, In my cordova project, the compiled appBundle.js is repeating code at the end of the file, and doesn't repeat it sequentially.  For example, in the following example, debugMode is false when I use it in my project code, but it should be true.\n\nHere is a simplified example of what happens : \n\nFile config.ts\n\n```\nvar debugMode: boolean = false;\ndebugMode = true;\nvar enableWindowLog: boolean = false;\nvar configMode: string = \"\"\n\nif (debugMode) {\n    enableWindowLog = true;\n    configMode = \"-dev\";\n}\n```\n\nFile index.ts\n\n```\n//My app code\n```\n\nCompiled appBundle.js\n\n```\nvar debugMode = false;\ndebugMode = true;\nvar enableWindowLog = false;\nvar configMode = \"\";\nif (debugMode) {\n    enableWindowLog = true;\n    configMode = \"-dev\";\n}\n\n// My project code compiled\n\nvar debugMode = false;\nvar enableWindowLog = false;\nvar configMode = \"\";\nvar debugMode = false;\ndebugMode = true;\nvar enableWindowLog = false;\nvar configMode = \"\";\nif (debugMode) {\n    enableWindowLog = true;\n    configMode = \"-dev\";\n}\nvar debugMode = false;\ndebugMode = true;\nvar enableWindowLog = false;\nvar configMode = \"\";\nif (debugMode) {\n    enableWindowLog = true;\n    configMode = \"-dev\";\n}\nvar debugMode = false;\ndebugMode = true;\nvar enableWindowLog = false;\nvar configMode = \"\";\nif (debugMode) {\n    enableWindowLog = true;\n    configMode = \"-dev\";\n}\nvar debugMode = false;\ndebugMode = true;\nvar enableWindowLog = false;\nvar configMode = \"\";\nif (debugMode) {\n    enableWindowLog = true;\n    configMode = \"-dev\";\n}\nvar debugMode = false;\nvar enableWindowLog = false;\nvar configMode = \"\";\n```\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/4192/comments",
    "author": "NGumby",
    "comments": [
      {
        "user": "danquirk",
        "created_at": "2015-08-06T19:31:42Z",
        "body": "Can you share the actual compiler invocation command that's causing this? (presumably in the Output window)\n"
      },
      {
        "user": "NGumby",
        "created_at": "2015-08-06T20:36:35Z",
        "body": "1>Target \"PreComputeCompileTypeScript\" in file \"C:\\Program Files (x86)\\MSBuild\\Microsoft\\VisualStudio\\v14.0\\TypeScript\\Microsoft.TypeScript.targets\" from project \"D:\\CompuSport\\trunk\\CS Cordova\\CS.Cordova\\CS.Cordova.jsproj\" (target \"CompileTypeScript\" depends on it):\n1>Using \"VsTsc\" task from assembly \"C:\\Program Files (x86)\\MSBuild\\Microsoft\\VisualStudio\\v14.0\\TypeScript\\TypeScript.tasks.dll\".\n1>Task \"VsTsc\"\n1>  C:\\Program Files (x86)\\Microsoft SDKs\\TypeScript\\1.5\\tsc.exe --project \"D:\\CompuSport\\trunk\\CS Cordova\\CS.Cordova\\scripts\" COMPUTE_PATHS_ONLY\n1>Done executing task \"VsTsc\".\n\nhere is my tsconfig.json\n\n```\n{\n    \"compilerOptions\": { \n        \"noImplicitAny\": false,\n        \"noEmitOnError\": true,\n        \"removeComments\": false,\n        \"sourceMap\": false,\n        \"out\": \"www/scripts/appBundle.js\",\n        \"target\": \"es5\"\n    }\n}\n```\n"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2015-08-06T20:46:18Z",
        "body": "I'm guessing what's happening is that the Cordova project system, or something else (maybe a source code control tool?), is mirroring config.ts to some other locations in the project folder. `tsconfig` without a file will pick up all .ts files, recursively, in its containing folder. Can you verify that only the two .ts files that you expect to be there exist in the project folder?\n"
      }
    ]
  },
  {
    "number": 4171,
    "title": "Creating a class whose instances will be instances of Error",
    "created_at": "2015-08-05T22:05:25Z",
    "closed_at": "2015-08-10T23:39:44Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/4171",
    "body": "Hi,\n\nI'm creating some custom error classes, but ran into an issue when using jasmine's `expect(fn).toThrowError(MyCustomError);`\n\nThe problem is that jasmine's `toThrowError` matcher checks that the exception thrown by `fn` is an instance of `Error`. This is clumsy to satisfy in TypeScript, as in `lib.d.ts` `Error` is an interface.\n\nThus, if one creates `MyCustomError` in the most straightforward and intuitive way supported:\n\n``` javascript\nexport class MyCustomError implements Error { \n  public name: string = 'MyCustomError';\n  public message: string;\n}\n```\n\nand throws an instance of this class, code such as that in jasmine that checks for an instance of `Error` will fail. And yet, their assumption seems quite legitimate.\n\nHere's the code I ended up with:\n\n``` javascript\nexport class MyCustomError implements Error { \n  public name: string = 'MyCustomError';\n  public message: string;\n}\n\nMyCustomError.prototype = Object.create(Error.prototype);\n```\n\nThis will satisfy the `instanceof Error` constraint, but it's fairly unintuitive for what seems like a common task (creating a runtime subtype of `Error`) -- one that shouldn't require setting the `prototype` property manually.\n\nAny thoughts?\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/4171/comments",
    "author": "matthewjh",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2015-08-05T22:18:26Z",
        "body": "Upgrade to TypeScript nightly build (`npm install typescript@next`), or wait until TypeScript 1.6, then write\n\n``` ts\nclass MyCustomError extends Error {\n}\n```\n"
      },
      {
        "user": "matthewjh",
        "created_at": "2015-08-05T22:19:55Z",
        "body": "Oh cool. Out of interest, why was `Error` an interface in the first place and what motivated the change?\n"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2015-08-05T22:21:57Z",
        "body": "Prior to some other changes, it wasn't possible to augment an existing class the same way you can an interface (multiple class declarations were an error, rather than merging like interfaces do).\n\nThe change in 1.6 is that we allow arbitrary expressions in `extends` clauses instead of requiring the symbol to point to a class.\n"
      }
    ]
  },
  {
    "number": 4140,
    "title": "Can't define variable using type of typeof",
    "created_at": "2015-08-04T04:37:39Z",
    "closed_at": "2015-08-07T15:53:14Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/4140",
    "body": "I declared `test` module to export the global mongoose variable as below.\ntest1.d.ts:\n\n``` javascript\n  declare module \"test\" {\n    import _mongoose = require('mongoose');\n    export var export_mongoose: typeof _mongoose;\n  }\n```\n\nI tried to define mongoose.Model using the export_mongoose variable. Please refer to below code:\ntest2.ts:\n\n``` javascript\n  /// \\<reference path=\"test1.d.ts\" /\\>\n  import test = require('test');\n  var model: test.export_mongoose.Model\\<number\\>;  // it doesn't work.\n  var model = test.export_mongoose;  // it works well.\n```\n\nHowever, tsc compiler shows a following error message:\n  TS2305: Module `test` has no exported member `export_mongoose`.\n\nI think the export_mongoose is not proper as type cause defined by `typeof`.\nCan I use the `export_mongoose` as type?\n\nIt would be helpful for me if you have any idea on this.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/4140/comments",
    "author": "estherk0",
    "comments": [
      {
        "user": "DanielRosenwasser",
        "created_at": "2015-08-04T04:51:10Z",
        "body": "When you use `var export_mongoose = _mongoose`, `export_mongoose` only takes on the _value side_ of `_mongoose`.\n\nInstead of using `export_mongoose`, I suggest you instead export the import directly:\n\n``` TypeScript\ndeclare module \"test\" {\n    export import _mongoose = require(\"mongoose\");\n}\n```\n"
      },
      {
        "user": "estherk0",
        "created_at": "2015-08-04T07:36:30Z",
        "body": "Thanks for a quick reply!\n\nI understood how this code works.\nBut I have to use an export_mongoose variable for sharing the mongoose object in many places, not only test2.ts. \n\nIf there is no way to solve this problem, I will import mongoose and use it for type:\n\n``` javascript\nimport mongoose = ('mongoose');\nvar test_var: mongoose.Model<...>;\n```\n"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2015-08-04T14:27:07Z",
        "body": "Try \n\n``` Typescript\ndeclare module \"test\" {\n    import mongoose = require(\"mongoose\");\n    export import export_mongoose = mongoose;\n```\n\nThe `import...=` declaration above creates an alias to all meanings of `mongoose`.\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2015-08-04T17:17:56Z",
        "body": "I would use the ES6 import/export syntax here.\n\n``` Typescript\ndeclare module \"test\" {\n   // import it locally \n   import * as mongoose from \"mongoose\";\n   // use the import\n   var test_var: mongoose.Model<...>;\n\n   // export it directly from \"mongoose\" module\n   export * from \"mongoose\";\n```\n"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2015-08-04T17:40:45Z",
        "body": "Yes - if you're still intent on doing it the way you wanted, you can do something like\n\n``` TypeScript\ndeclare module \"test\" {\n    import * as mongoose from \"mongoose\";\n    export { mongoose as export_mongoose };\n}\n```\n"
      }
    ]
  },
  {
    "number": 3980,
    "title": "Class expression inside a generic function bug",
    "created_at": "2015-07-22T15:10:11Z",
    "closed_at": "2015-07-22T17:41:12Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/3980",
    "body": "This code seems to be valid TS:\n\n``` ts\ninterface ReactClass<P, S> {\n    setState(state: S): void;\n}\n\ninterface Props {}\n\ninterface State {\n    hovered: boolean;\n}\n\nfunction createComponent<P extends Props, S extends State>() {\n    return class Component implements ReactClass<P, S> {\n        constructor() {\n            this.setState({ hovered: true })\n        }\n\n        setState(state: S): void {}\n    }\n}\n```\n\nBut it fails to compile:\n\n```\nissue.tsx(15,27): error TS2345: Argument of type '{ hovered: boolean; }' is not assignable to parameter of type 'S'.\n```\n\nIs it a bug?\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/3980/comments",
    "author": "s-panferov",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2015-07-22T17:39:54Z",
        "body": "this is not really related to classes or functions. the constraint on S is it has to be _at least_ of type state, but does not mean that a value of type State is assignable to it, it may need more properties that are missing in the base type.\n\nhere is a simplified version of your snippit:\n\n``` ts\nfunction setState<T extends State>(t: T) {\n    var s: State = { hovered: true };\n\n    s = t; // OK, t is a T, which is a State\n    t = s; // Error, s may not be a T\n}\n```\n"
      }
    ]
  },
  {
    "number": 3933,
    "title": "Unable to use combinators on prototypes.",
    "created_at": "2015-07-20T19:05:22Z",
    "closed_at": "2015-07-21T15:40:31Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/3933",
    "body": "I can not apply combinators to prototype. A combinator is a function that takes a function and returns another function. I use these to divide up functionality. I can use them in TypeScript, but they do not go on the prototype. I struggled to get them on the prototype, but TypeScript always throws an error. Here is an example of what I was trying to do. Inspired by TypeScript unions types I found many cases where I would like to pass T or T[]. I needed to write the code to handle this many places. So I wrote a combinator to handle this. So I would have:\n\n``` javascript\nfunctionThatCanHandleBoth = makeFunctionToHandleArrayAndSingle(handleSingleFunction)\n```\n\nI want to put this on the prototype because I want to use these functions in objects that have many instances.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/3933/comments",
    "author": "willseitz",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2015-07-20T19:21:59Z",
        "body": "If i understand the issue correctly, you want to consolidate handling of parameter in one place, how about using decorators,\n\n``` ts\nclass C {\n    @makeFunctionToHandleArrayAndSingle\n     handleSingleFunction<T>(a:T) {\n\n    }\n}\n```\n\nalso you can put it directelly on the prototype if you want to:\n\n``` ts\nclass C {\n    handler: <T>(a: T | T[]) => void;\n}\n\nC.prototype.handler = makeFunctionToHandleArrayAndSingle(handleSingleFunction);\n```\n"
      },
      {
        "user": "willseitz",
        "created_at": "2015-07-21T15:40:31Z",
        "body": "*Edited a few times *\n\nThanks for the response. Both those approaches work (I had tried the second, but decorators were new to me), but I couldn't get either to preserve context aka 'this' at the time. I discovered that this issue was actually in how I was making the decorator and not in the transpiled code. \n\nFor reference here is a sample:\n\n``` javascript```\nvar decorate = function(func) {\n    console.log(\"decoration being set up\");\n    return function() {\n        console.log(\"/-----\\\\\");\n        var retval = func.apply(this,arguments);\n        console.log(\"\\\\-----/\");\n        return retval;\n    }\n}\n\nclass Dog {\n    constructor(private barkNoise: string) {\n\n    }\n    bark() {\n        console.log(this.barkNoise);\n    }\n}\n\n\nDog.prototype.bark = decorate(Dog.prototype.bark);\n\nvar littleDog = new Dog(\"Yip\");\nvar bigDog = new Dog(\"Woof\");\n\nlittleDog.bark();\nlittleDog.bark();\nlittleDog.bark();\nbigDog.bark();\n```\n\nand the decorator version:\n\n``` javascript\nvar decorate = (target, name, property) => {\n    console.log(\"decoration being set up\");\n    var func = property.value;\n// This must remain 'function', using fat arrow will disturb the context\n    property.value = function (...args) {\n        console.log(\"/-----\\\\\");\n        var retval = func.apply(this,args);\n        console.log(\"\\\\-----/\");\n        return retval;\n    }\n}\n\nclass Dog {\n    constructor(private barkNoise: string) {        \n    }\n    @decorate\n    bark() {\n        console.log(this.barkNoise);\n    }\n}\n\nvar littleDog = new Dog(\"Yip\");\nvar bigDog = new Dog(\"Woof\");\n\nlittleDog.bark();\nlittleDog.bark();\nlittleDog.bark();\nbigDog.bark();\n```\n"
      }
    ]
  },
  {
    "number": 3785,
    "title": "problem with rest params and function overloading",
    "created_at": "2015-07-08T21:04:47Z",
    "closed_at": "2015-07-09T17:55:52Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/3785",
    "body": "``` ts\nexport function injection(clazz: Class)\n    export function injection(...metadata: Metadata[])\n    export function injection(...value: any[]) {\n\n        if (typeof value === typeof []) {\n            return (clazz: Class) => {\n                Injector.instance.register(clazz, value);\n            }\n        }\n        else {\n            Injector.instance.register(<any>value);\n        }\n    }\n```\n\nI`v got the compilation error\n\n```\nArgument of type 'any[]' is not assignable to parameter of type 'Metadata'.\n```\n\nand \n\n```\nArgument of type 'any[]' is not assignable to parameter of type 'Metadata'.\n  Property 'name' is missing in type 'any[]'.   \n```\n\nHave you any idea?\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/3785/comments",
    "author": "OlegDokuka",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2015-07-08T22:00:44Z",
        "body": "I'm presuming the code looks like this:\n\n``` ts\ninterface Class { }\ninterface Metadata {\n    name: string;\n}\n\ndeclare var Injector: {\n    instance: {\n        register(c: Class, value: Metadata[]);\n        register(c: Class);\n    }\n}\n\nfunction injection(clazz: Class)\nfunction injection(...metadata: Metadata[])\nfunction injection(...value: any[]) {\n    if (typeof value === typeof []) {\n        return (clazz: Class) => {\n            Injector.instance.register(clazz, value);\n        }\n    }\n    else {\n        Injector.instance.register(<any>value);\n    }\n}\n```\n\nSeveral problems going on here.\n\nFirst, this line is wrong:\n\n``` ts\n   function injection(...value: any[]) {\n```\n\nHaving a rest arg in the implementation signature means that you're always going to have your arguments wrapped in an array, which means you're never going to hit the `else` clause. Instead, this should be `value: any`.\n\nMore accurately, though, you can write:\n\n``` ts\n    function injection(value: Metadata[]|Class) {\n```\n\nIf you do this, we can move on to the next problem.\n\n``` ts\n    if (typeof value === typeof []) {\n```\n\nThis code is also wrong (or at least overstates its specificity). `typeof []` is `\"object\"`, so this test is always going to be `true` for a bunch of things that aren't arrays. It's more accurate to write\n\n``` ts\n        if (value instanceof Array) {\n```\n\nIf you do both these fixes, the entire example compiles without error:\n\n``` ts\ninterface Class { }\ninterface Metadata {\n    name: string;\n}\n\ndeclare var Injector: {\n    instance: {\n        register(c: Class, value: Metadata[]);\n        register(c: Class);\n    }\n}\n\nfunction injection(clazz: Class)\nfunction injection(...metadata: Metadata[])\nfunction injection(value: Metadata[]|Class) {\n    if (value instanceof Array) {\n        return (clazz: Class) => {\n            Injector.instance.register(clazz, value);\n        }\n    }\n    else {\n        Injector.instance.register(<any>value);\n    }\n}\n```\n"
      }
    ]
  },
  {
    "number": 3562,
    "title": "Computed properties",
    "created_at": "2015-06-18T19:17:44Z",
    "closed_at": "2015-08-10T23:08:23Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/3562",
    "body": "``` typescript\nconst nameMember = \"_name\";\n\nclass Cls {\n    private [nameMember]: string;\n\n    constructor(name: string) {\n        this[nameMember] = name;\n    }\n}\n```\n\nCould be wrong, but isn't this now legal syntax? In both ES5 and ES6 modes, this generates the error:\n\n\"_A computed property name in a class property declaration must directly refer to a built-in symbol._\"\n\nComputed properties are listed on the Roadmap for Typescript 1.5 - is that still the case? If so, will ES6 mode be required, or will it work with ES5? Thanks.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/3562/comments",
    "author": "jamiewinder",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2015-06-18T21:28:35Z",
        "body": "Computed property names are valid in object literals. They are not supported as class property declarations (note that property declarations are not part of the ES6 class specification, so this is orthogonal to ES5/ES6).\n"
      },
      {
        "user": "jamiewinder",
        "created_at": "2015-06-18T21:51:40Z",
        "body": "Understood, thanks. I think a similar syntax would be useful specifically for TypeScript though. The code above effectively indicates that if a property is accessed on an instance of this class with the specified const variable (i.e. a[nameMember]) then assume the return value is a string. \n\nPerhaps this is something different entirely, but it'd be very handy.\n"
      },
      {
        "user": "JsonFreeman",
        "created_at": "2015-06-18T23:27:43Z",
        "body": "The feature you are asking for is constant propagation. We'd have to recognize in certain contexts that a const declared name corresponds uniquely to a single value. Then we could support class properties for these kinds of constants.\n\nOne requirement is that we could only support string or number literals because we have to know the value of that const at compile time. Otherwise we cannot know if two different consts refer to the same value.\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2015-08-10T23:08:23Z",
        "body": "Constant propagation is covered by #3964\n"
      }
    ]
  },
  {
    "number": 3422,
    "title": "Config to compile `const enum` as `enum` in development / Get SyntaxKind during development",
    "created_at": "2015-06-08T18:30:20Z",
    "closed_at": "2015-06-08T18:54:04Z",
    "labels": [
      "By Design",
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/3422",
    "body": "Hi,\n\nWhen I work on the code, I have to change `SyntaxKind` from `const enum` to `enum` so that I can do `write(`kind: ${SyntaxKind[node.kind]}`)`.\n\nIs there a way to config the compiler and jake to treat `const enum` as `enum` so this would work?\nOr is there another way to get the SyntaxKind without doing `SyntaxKind[node.kind]`?\n\nThanks,\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/3422/comments",
    "author": "unional",
    "comments": [
      {
        "user": "DanielRosenwasser",
        "created_at": "2015-06-08T18:54:04Z",
        "body": "You can keep the mapping at runtime with `--preserveConstEnum` for debugging purposes, but this behavior is the point of const enums.\n"
      },
      {
        "user": "unional",
        "created_at": "2015-06-08T20:59:50Z",
        "body": "jake already passes `--preserveConstEnums` to tsc.js, but it still fails compilation:\n\n`error TS2476: A const enum member can only be accessed using a string literal`\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2015-06-08T23:43:44Z",
        "body": "these exist only for debugging purposes. if you really want to do that cast to any. `(<any>ts).SyntaxKind[node.kind]`\n"
      }
    ]
  },
  {
    "number": 3405,
    "title": "Cannot find module during runtests",
    "created_at": "2015-06-07T07:06:16Z",
    "closed_at": "2015-06-08T20:36:30Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/3405",
    "body": "Put these two files under tests/cases/compiler, and run `jake runtests tests=Blade`\n\n**BladeMaterial.ts**\n\n``` ts\n//@module: amd\n\n/**\n * The base blade material class.\n */\nexport default class BladeMaterial {\n    stiffness: number\n    hardness: number\n    constructor(public name: string) {\n    }\n}\n```\n\n**BladeCompositeMaterial.ts**\n\n``` ts\n//@module: amd\n\nimport BladeMaterial from \"BladeMaterial\";\n\n/**\n * Composite material for blade.\n */\nexport default class BladeCompositeMaterial extends BladeMaterial {\n    constructor(public name: string) {\n        super(name);\n    }\n}\n```\n\nThe **BladeCompositeMaterial.ts** fails with TS2307: Cannot find module 'BladeMaterial`.\n\nI tap into `program.getSourceFile` and add:\n\n``` ts\nconsole.log(`${fileName}, hasProperty(...) => ${hasProperty(filesByName, fileName)}, filesByName: ${filesByName[fileName]}`);\n```\n\ni.e.\n\n``` ts\n\nfunction getSourceFile(fileName: string) {\n    fileName = host.getCanonicalFileName(normalizeSlashes(fileName));\n    console.log(`${fileName}, hasProperty(...) => ${hasProperty(filesByName, fileName)}, filesByName: ${filesByName[fileName]}`);\n    return hasProperty(filesByName, fileName) ? filesByName[fileName] : undefined;\n}\n```\n\nthe output result of `jake runtests tests=Blade` shows the order of the file matters:\ntests/cases/compiler/bladematerial.ts, hasProperty(...) => true, filesByName: undefined\ntests/cases/compiler/bladematerial.d.ts, hasProperty(...) => true, filesByName: undefined\ntests/cases/bladematerial.ts, hasProperty(...) => true, filesByName: undefined\ntests/cases/bladematerial.d.ts, hasProperty(...) => true, filesByName: undefined\ntests/bladematerial.ts, hasProperty(...) => true, filesByName: undefined\ntests/bladematerial.d.ts, hasProperty(...) => true, filesByName: undefined\nbladematerial.ts, hasProperty(...) => true, filesByName: undefined\nbladematerial.d.ts, hasProperty(...) => true, filesByName: undefined\n\n  \u2024\u2024\u2024\u2024\u2024\u2024\u2024\u2024\u2024tests/cases/compiler/bladematerial.ts, hasProperty(...) => true, filesByName: [object Object]\ntests/cases/compiler/bladematerial.ts, hasProperty(...) => true, filesByName: [object Object]\ntests/cases/compiler/bladematerial.ts, hasProperty(...) => true, filesByName: [object Object]\n\nThe caller of `program.getSourceFile()` which creates this problem is in checker.ts: 882, in function `resolveExternalModuleName`: `sourceFile = forEach(supportedExtensions, extension => host.getSourceFile(fileName + extension));`\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/3405/comments",
    "author": "unional",
    "comments": [
      {
        "user": "DanielRosenwasser",
        "created_at": "2015-06-07T18:52:19Z",
        "body": "Tests in `compiler` and conformance` are independent of one another. If I recall correctly, you can make a multifile test in one file as so:\n\n``` TypeScript\n// @filename: BladeMaterial.ts\nexport function blah() {\n}\n\n// @filename: BladeCompositeMaterial\nimport { blah } from \"BladeMaterial\";\n```\n\nLet us know if that helps.\n"
      }
    ]
  },
  {
    "number": 3329,
    "title": "Function type error in union type",
    "created_at": "2015-06-01T19:31:47Z",
    "closed_at": "2015-06-01T19:36:54Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/3329",
    "body": "I have been having issues with union types when using a function type as the second type in the union.\n\nAccording to the TypeScript 1.4 Language Specification: (3.4 Union Types, page 29)\n- A | B is equivalent to B | A\n\nThe following example compiles correctly:\n\n``` typescript\nfunction test(x: (y) => boolean | boolean) {\n    //do something with x\n}\n```\n\nBut this one gives an error:\n\n``` typescript\nfunction test(x: boolean | (y) => boolean) {\n    //do something with x\n}\n```\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/3329/comments",
    "author": "joeskeen",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2015-06-01T19:36:20Z",
        "body": "The language in the spec is a specification of type system behavior, not grammar.\n\nYou can fix this with parens:\n\n``` ts\nfunction test2(x: boolean | ((y) => boolean)) {\n    //do something with x\n}\n```\n"
      },
      {
        "user": "btesser-r7",
        "created_at": "2016-03-04T17:58:27Z",
        "body": "```\nfunction test(x: (y) => boolean | boolean) {\n    //do something with x\n}\n```\n\nlooks like what you are trying to accomplish is this:\n\n```\nfunction test(x: (y) => (boolean | boolean)) {\n    //do something with x\n}\n```\n"
      }
    ]
  },
  {
    "number": 3318,
    "title": "How can I debug compilation?",
    "created_at": "2015-05-31T13:31:13Z",
    "closed_at": "2015-06-01T10:02:03Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/3318",
    "body": "This is less an issue but a request for advice. I try to change the way code for namespaces is emitted.\n\nCurrently the typescript code\n\n```\nnamespace A{\n    var x = 42;\n}\n```\n\nis  emitted as\n\n```\nvar A;\n(function (A) {\n    var x = 42;\n})(A || (A = {}));\n```\n\nwhich I want to change to be emitted as\n\n```\n    var A_x = 42;\n```\n\nObviously, all references to x also need to become A_x .\n\nI walkted through emitter.ts and declarationEmitter.ts but without being able to stepping through the compilation with a debugger it is hard to fully understand the pieces. So my question:\n\n How can I debug compilation ?\n Hints on my namespace hack are also appreciated.     \n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/3318/comments",
    "author": "urbanhop",
    "comments": [
      {
        "user": "DanielRosenwasser",
        "created_at": "2015-06-01T06:02:58Z",
        "body": "If you're on Windows with a program that can use the script debugging interface (e.g. Visual Studio), you can use cscript with with `/X` flag to signal that it should stop on the first statement.\n\nIf you want to make it faster, use the Chakra engine using something like the flag `/E:{16d51579-a30b-4c8b-a276-0ff4dc41e755}`.\n\nIf you don't have that privilege, you can use `node-inspector` and run the compiler with `node --debug-brk build/local/tsc.js`.\n\nAs a word of caution, if you're intending on sending this out as a PR, I don't think we're inclined to accept something like that (or at least, we'd need a proposal to consider first). If it's for your own personal purposes, I fully encourage you to learn about the compiler and experiment. I'd look into `emitIdentifier` in `emitter.ts`.\n"
      }
    ]
  },
  {
    "number": 3290,
    "title": "Map,Set ... in ES5 target",
    "created_at": "2015-05-28T08:52:59Z",
    "closed_at": "2015-05-28T17:49:17Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/3290",
    "body": "After update the typescript compiler from version 1.4.1 to 1.5.0 beta, the source code included in my project became to make error log such as 'Map is not found'.\nThus, I researched this problem, and I reached an conclusion. The lib.d.ts became not to contain Map and Set definitions except ES6 being selected in tsconfig.json.\n\nActually, Map and Set is specification of ES6. It is natural that we can't use Map and Set in the project targeting ES5 or lower.\nBut we could use Map and Set even if I select ES5 as the target before typescript 1.4.1.\nI know that making it being enabled to use Map and Set in the project that is made for ES5 contains risk.\nBecause there is some of browsers not supporting Map and Set.\n\nHowever, I think it is better to make some of property of configuration that is for switching to use these definitions or not. Don't you think so?\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/3290/comments",
    "author": "kyasbal",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2015-05-28T17:42:24Z",
        "body": "@LimeStreem we removed some IE-specific types from the library in 1.5.0-beta. you can just define the type in one of your files like:\n\n``` ts\ninterface Map<K, V> {\n    clear(): void;\n    delete(key: K): boolean;\n    forEach(callbackfn: (value: V, index: K, map: Map<K, V>) => void, thisArg?: any): void;\n    get(key: K): V;\n    has(key: K): boolean;\n    set(key: K, value: V): Map<K, V>;\n    size: number;\n}\ndeclare var Map: {\n    new <K, V>(): Map<K, V>;\n    prototype: Map<any, any>;\n}\ninterface Set<T> {\n    add(value: T): Set<T>;\n    clear(): void;\n    delete(value: T): boolean;\n    forEach(callbackfn: (value: T, index: T, set: Set<T>) => void, thisArg?: any): void;\n    has(value: T): boolean;\n    size: number;\n}\ndeclare var Set: {\n    new <T>(): Set<T>;\n    prototype: Set<any>;\n}\n```\n"
      },
      {
        "user": "nin-jin",
        "created_at": "2017-06-27T09:57:39Z",
        "body": "```\r\ndeclare class WeakMap< Key , Value > {\r\n\tdelete( key : Key ) : boolean\r\n\tget( key : Key ) : Value\r\n\thas( key : Key ) : boolean\r\n\tset( key : Key , value : Value ) : Map< Key , Value >\r\n}\r\n\r\ndeclare class Map< Key , Value > {\r\n\tclear(): void\r\n\tdelete( key : Key ) : boolean\r\n\tforEach< Context = any >( handler : ( this : Context , value : Value , key : Key , map : Map< Key , Value > ) => void , context? : Context ) : void\r\n\tget( key : Key ) : Value\r\n\thas( key : Key ) : boolean\r\n\tset( key : Key , value : Value ) : Map< Key , Value >\r\n\tsize : number\r\n}\r\n\r\ndeclare class Set< Value > {\r\n\tadd( value : Value ) : Set< Value >\r\n\tclear() : void\r\n\tdelete( value : Value ) : boolean\r\n\tforEach< Context = any >( handler : ( this : Context , value : Value , key : Value , map : Set< Value > ) => void , context? : Context ) : void\r\n\thas( value : Value ) : boolean\r\n\tsize : number\r\n}\r\n```"
      }
    ]
  },
  {
    "number": 3243,
    "title": "vs plugin, 1.5beta regression: can not extend from class in external import",
    "created_at": "2015-05-21T13:29:24Z",
    "closed_at": "2015-05-21T17:44:52Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/3243",
    "body": "this works in older versions.\n\nwhen I have the following code in 1.5beta:\n\n```\nimport refs = require(\"../refs\");\nvar xlib = refs.xlib;\n\nexport class PjscBe extends xlib.ClassBase{}\n```\n\nI get the following error:\n`265  Cannot find name 'xlib'.`\n\nthis issue goes away if I remove the extends.  I can use my external module in other ways just fine:\n`var log = new xlib.diagnostics.logging.Logger(__filename);`\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/3243/comments",
    "author": "jasonswearingen",
    "comments": [
      {
        "user": "ahejlsberg",
        "created_at": "2015-05-21T16:14:11Z",
        "body": "Which older versions does it work in? Anyway, looks to me like the issue is that you're attempting to reference a variable (`xlib`) in a type name (`xlib.ClassBase`), which isn't possible. It should work if you change the declaration of `xlib` to be an `import`:\n\n``` typescript\nimport refs = require(\"../refs\");\nimport xlib = refs.xlib;\n\nexport class PjscBe extends xlib.ClassBase {}\n```\n\nThis will enable `xlib` to be used in both value and type positions.\n"
      }
    ]
  },
  {
    "number": 3213,
    "title": "Access to static fields via constructor property",
    "created_at": "2015-05-19T10:57:45Z",
    "closed_at": "2015-06-08T03:12:15Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/3213",
    "body": "This is example of correct code, though compiler raises an error `Property 'bar' does not exist on type 'Function'.`\n\n``` typescript\nclass A {\n    static bar(): void {\n        alert(\"Oh hi!\");\n    }\n\n    foo(): void {\n        this.constructor.bar(); //<-- compiler error\n    }\n}\n```\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/3213/comments",
    "author": "dvoyni",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2015-05-21T22:03:01Z",
        "body": "pinging @rbuckton for this one. the main reason is that constructor is not guaranteed to be set to the right thing all the time; consider an ambient class from a .d.ts modeling an existing js class implementation.\n"
      },
      {
        "user": "rbuckton",
        "created_at": "2015-05-21T22:15:01Z",
        "body": "Consider the following:\n\n``` ts\nclass A {\n    static x() { return 1; }\n    y() {\n        let z = this.constructor.x(); // z: string;\n        console.log(typeof z);\n    }\n}\n\nclass B extends A {\n    static x() { return undefined; }\n}\n\nclass C extends B {\n    static x() { return \"text\"; }\n}\n\nlet a = new A();\na.y(); // prints: \"number\";\nlet b = new B();\nb.y(); // prints: \"undefined\";\nlet c = new C();\nc.y(); // prints: \"string\";\n```\n\nIf we made `constructor` have the type `typeof A` here, a derived type could return something unexpected.\n"
      },
      {
        "user": "oxyflour",
        "created_at": "2015-06-08T03:09:54Z",
        "body": "Hi, I just found that using <typeof A> instead of <AStatic> is ok : )\n\n``` typescript\nclass A {\n    static bar(): void {\n        alert('hello')\n    }\n    foo(): void {\n        (<typeof A> this.constructor).bar()\n    }\n}\n\nnew A().foo()\n```\n"
      }
    ]
  },
  {
    "number": 3193,
    "title": "type-safe cast",
    "created_at": "2015-05-18T00:24:07Z",
    "closed_at": "2015-05-18T02:58:09Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/3193",
    "body": "There doesn't seem to be a safe cast in Typescript. (&lt;T&gt; x) does no dynamic check. This is a very common need and is provided in every other optionally and gradually typed language I know of. What is needed is something like:\n\n```\nfunction cast<T>(x: any): T {\n    if (x instanceof T) return x;\n    throw new Error('type cast exception');\n}\n```\n\nexcept that doesn't compile. Is there an alternative solution I'm missing?\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/3193/comments",
    "author": "JonathanMEdwards",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2015-05-18T02:58:09Z",
        "body": "``` ts\nfunction cast<T>(instance: T, ctor: { new(...args: any[]): T }): T {\n    if (instance instanceof ctor) return instance;\n    throw new Error('type cast exception');\n}\n```\n\nThe reason there's no built-in operation for this is that it's not possible at runtime to detect many things (for example, `(x: number) => any` and `(x: string) => any` are indistinguishable from a runtime perspective).\n"
      },
      {
        "user": "JonathanMEdwards",
        "created_at": "2015-05-18T03:27:11Z",
        "body": "I think you're just saying that instanceof is broken on primitives in JavaScript. But why can't we have a cast operation that is consistent with the semantics of instanceof? Which would work as expected on classes.\n"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2015-05-18T03:31:36Z",
        "body": "Can you post an example of how you'd want that to work? `instanceof` is already a qualifying operation for a type guard (e.g. if you have `var x: Giraffe|Elephant`, `if(x instanceof Giraffe) { x.longNeck(); }` works)\n"
      },
      {
        "user": "JonathanMEdwards",
        "created_at": "2015-05-18T03:45:32Z",
        "body": "Like I said:\n\n```\nfunction cast<T>(x: any): T {\n    if (x instanceof T) return x;\n    throw new Error('type cast exception');\n}\n```\n\nI find I keep repeating that boilerplate which mimics a \"normal\" safe cast operation.\n"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2015-05-18T03:48:34Z",
        "body": "For example, let's say you wrote the following:\n\n``` ts\ninterface Foo {\n  (x: string): void;\n}\n\nvar j: any = whatever;\nvar x = cast<Foo>(j);\n```\n\n``` ts\n/* write the JavaScript you would expect to be emitted here */\n```\n\nThe `cast` function _that can exist_ is the one I wrote above -- you have to specify the constructor function, but the types work as expected and the runtime behavior is correct.\n"
      },
      {
        "user": "JonathanMEdwards",
        "created_at": "2015-05-18T11:55:01Z",
        "body": "OK. I'd expect that to be an error, but that certainly would be annoying for a supposed cast expression.\nHow does your suggestion work? This doesn't:\n\n```\nfunction cast<T>(instance: T, ctor: { new(...args: any[]): T }): T {\n    if (instance instanceof ctor) return instance;\n    throw new Error('type cast exception');\n}\nclass A {\n    foo: number;\n}\nvar x: A | number = new A();\nvar y:A = cast<A>(x, A);\n```\n\ntest.ts(9,19): error TS2345: Argument of type 'number | A' is not assignable to parameter of type 'A'.\n  Type 'number' is not assignable to type 'A'.\n"
      },
      {
        "user": "duanyao",
        "created_at": "2015-05-18T16:25:59Z",
        "body": "This works:\n\n``` javascript\nfunction cast<T>(instance, ctor: { new(...args: any[]): T }): T { // instance should be \"any\"\n    if (instance instanceof ctor) return instance;\n    throw new Error('type cast exception');\n}\nclass A {\n    foo: number;\n}\nvar x: A | number = new A();\nvar y = cast(x, A); // type param is not required\n```\n"
      }
    ]
  },
  {
    "number": 3021,
    "title": "Getting \"Maximum call stack size exceeded\" when using \"getDocumentHighlights\" with reference paths and modules in 1.5.0-beta",
    "created_at": "2015-05-04T17:29:01Z",
    "closed_at": "2015-05-05T17:07:59Z",
    "labels": [
      "Question",
      "Fixed"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/3021",
    "body": "If I have code that looks something like this: \n\n``` typescript\n/// <reference path=\"nounreachable.test.ts\" />\n\nmodule S {\n  var template = '';\n}\n```\n\nand I try to do getDocumentHighlights on \"template\" in just that one file, I get a \"Maximum call stack size exceeded\" error. Am I doing something wrong? Or can you guys fix this, please? Thanks!\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/3021/comments",
    "author": "gscshoyru",
    "comments": [
      {
        "user": "DanielRosenwasser",
        "created_at": "2015-05-04T17:52:09Z",
        "body": "Hey @gscshoyru, is the definition file required to reproduce this error?\n"
      },
      {
        "user": "gscshoyru",
        "created_at": "2015-05-04T17:54:14Z",
        "body": "The definition file isn't necessary, it's just the existence of a reference path that causes the bug. It's the combination of the module and the reference path that does it for some reason, if you don't have have one or the other the bug doesn't happen. \n"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2015-05-04T18:52:48Z",
        "body": "Not able to repro - can you supply both a call stack and the original call that's triggering it? What set of parameters are you passing in when calling?\n"
      },
      {
        "user": "gscshoyru",
        "created_at": "2015-05-04T21:34:42Z",
        "body": "Ok, sorry, I apparently I copied the wrong thing since it was failing that way before. Now it's failing if there's a ../ in the reference path, like `/// <reference path=\"../nounreachable.test.ts\" />`. It may also have something to with how we're doing it, though, since we are creating our own language service host and whatnot -- I can add the code for that if it's necessary, and you still can't repro. \n"
      },
      {
        "user": "gscshoyru",
        "created_at": "2015-05-04T21:38:40Z",
        "body": "Actually, here:\n\n``` typescript\nmodule Lint {\n    export function createLanguageServiceHost(fileName: string, source: string) {\n        var host: ts.LanguageServiceHost = {\n            getScriptFileNames: () => [fileName],\n            getScriptVersion: () => \"1\",\n            getScriptSnapshot: () => {\n                return {\n                    getText: (start, end) => source.substring(start, end),\n                    getLength: () => source.length,\n                    getLineStartPositions: () => ts.computeLineStarts(source),\n                    getChangeRange: (oldSnapshot) => undefined\n                };\n            },\n            getCurrentDirectory: () => \"\",\n            getScriptIsOpen: () => true,\n            getCompilationSettings: () => Lint.createCompilerOptions(),\n            getDefaultLibFileName: () => \"lib.d.ts\",\n            log: (message) => { /* */ }\n        };\n\n        return host;\n    }\n}\n\nvar documentRegistry = ts.createDocumentRegistry();\nvar languageServiceHost = Lint.createLanguageServiceHost(\"file.ts\", sourceFile.getFullText());\nvar languageService = ts.createLanguageService(languageServiceHost, documentRegistry);\nlanguageService.getDocumentHighlights(\"file.ts\", position, [\"file.ts\"]);\n```\n\nThis is what we're doing (paraphrased a little) that's causing the issue. \n"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2015-05-04T22:05:59Z",
        "body": "Still not able to repro.\n\n> `ts.computeLineStarts(source)`\n\nDoesn't seem to be publicly exposed anymore, how are you doing this?\n\n> `Lint.createCompilerOptions()`\n\nNot sure what we get back from this, could be useful for the repro\n\n---\n\nHere's what I'm currently working with:\n\n``` TypeScript\n/// <reference path=\"built/local/typescript.d.ts\" />\n\nimport * as ts from \"typescript\"\n\nmodule Lint {\n    export function createLanguageServiceHost(fileName: string, source: string) {\n        var host: ts.LanguageServiceHost = {\n            getScriptFileNames: () => [fileName],\n            getScriptVersion: () => \"1\",\n            getScriptSnapshot: () => {\n                return {\n                    getText: (start, end) => source.substring(start, end),\n                    getLength: () => source.length,\n                    getLineStartPositions: () => (<any>ts).computeLineStarts(source),\n                    getChangeRange: (oldSnapshot) => undefined\n                };\n            },\n            getCurrentDirectory: () => \"\",\n            getScriptIsOpen: () => true,\n            getCompilationSettings: () => ({}),\n            getDefaultLibFileName: () => \"lib.d.ts\",\n            log: (message) => { /* */ }\n        };\n\n        return host;\n    }\n}\n\nvar sourceText = \"/// <reference path=\\\"../TypeScript3/foo.ts\\\" />\\n\\nmodule m {\\n    var s;\\n}\\n\";\n\nvar documentRegistry = ts.createDocumentRegistry();\nvar languageServiceHost = Lint.createLanguageServiceHost(\"boo.ts\", sourceText);\nvar languageService = ts.createLanguageService(languageServiceHost, documentRegistry);\n\nfor (var i = 0; i < sourceText.length; i++) {\n    console.log(JSON.stringify(languageService.getDocumentHighlights(\"boo.ts\", i, [\"boo.ts\"])));\n}\n```\n\nI'm asking for highlights at every position in the document and I'm still not running into any problems.\n"
      },
      {
        "user": "gscshoyru",
        "created_at": "2015-05-04T22:24:34Z",
        "body": "Sorry, create compiler options is just \n\n``` typescript\nexport function createCompilerOptions(): ts.CompilerOptions {\n        return {\n            target: ts.ScriptTarget.ES5\n        };\n    }\n```\n\nso shouldn't be anything special.\n\nYou're right that it doesn't blow up that way, but it does blow up if you do `/// <reference path=\\\"../foo.ts` instead. Not entirely sure why. \n\nIt also seems to blow up without reference paths if you have imports with the same problem, such as `import xyz = require(\"../xyz\");` instead of the reference path.\n"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2015-05-05T02:11:50Z",
        "body": "@gscshoyru the problem is that your `getScriptSnapshot` is not actually using its given parameters, nor is it trying to appropriately resolve the filename it is given.\n\n---\n\nEdit: Specifically, you're just returning the same source file as the root, so when requesting the file `../foo.ts`, you'll end up with the original file contents that have a reference comment asking for `../foo.ts` which is, relative to the original root, `../../foo.ts`.\n"
      },
      {
        "user": "ashwinr",
        "created_at": "2015-05-05T04:16:05Z",
        "body": "@DanielRosenwasser Thanks for the reply. Is there any way to ignore imports/references when calling this LS API (or other LS APIs in general)? TSLint doesn't actually need to resolve imports since it works on a file-by-file basis. Thanks again!\n"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2015-05-05T05:57:10Z",
        "body": "@ashwinr you should be able to just return an empty string if it's not one of the files you're interested in. Let us know how that works out.\n"
      },
      {
        "user": "vladima",
        "created_at": "2015-05-05T06:19:53Z",
        "body": "@ashwinr you can set `noResolve` to `true` in compilation options to tell compiler that it should not do any file resolutions except files that were provided explicitly\n"
      }
    ]
  },
  {
    "number": 2844,
    "title": "Duplicate identifier error in Visual Studio 2015 CTP",
    "created_at": "2015-04-21T07:36:34Z",
    "closed_at": "2015-04-22T13:12:59Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/2844",
    "body": "Hi\n\nI create the new \"typescript\" project.\nI generate the description file for the app.ts by `tsp --target es5 -d app.ts`\n\nI immediately receive the duplicate identifier error.\nI am not sure how to deal with this issue as I want to have both implementation and description files in my project.\n\nHere are the files `app.ts`\n\n``` javascript\nclass Greeter {\n    element: HTMLElement;\n    span: HTMLElement;\n    timerToken: number;\n\n    constructor(element: HTMLElement) {\n        this.element = element;\n        this.element.innerHTML += \"The time is: \";\n        this.span = document.createElement('span');\n        this.element.appendChild(this.span);\n        this.span.innerText = new Date().toUTCString();\n    }\n\n    start() {\n        this.timerToken = setInterval(() => this.span.innerHTML = new Date().toUTCString(), 500);\n    }\n\n    stop() {\n        clearTimeout(this.timerToken);\n    }\n\n}\n\nwindow.onload = () => {\n    var el = document.getElementById('content');\n    var greeter = new Greeter(el);\n    greeter.start();\n};\n```\n\nand `app.d.ts`\n\n``` javascript\ndeclare class Greeter {\n    element: HTMLElement;\n    span: HTMLElement;\n    timerToken: number;\n    constructor(element: HTMLElement);\n    start(): void;\n    stop(): void;\n}\n```\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/2844/comments",
    "author": "tomitrescak",
    "comments": [
      {
        "user": "DanielRosenwasser",
        "created_at": "2015-04-21T08:00:49Z",
        "body": "Do you mean that you're receiving duplicate identifier errors in VS when you have `app.ts` and `app.d.ts` (or another file that refers to `app.d.ts`) open at the same time?\n\nAlso could you be more specific with which duplicate identifier errors you're getting from underscore.d.ts?\n"
      },
      {
        "user": "tomitrescak",
        "created_at": "2015-04-21T11:47:19Z",
        "body": "I have both app.ts and app.d.ts in my project and I am receiving duplicate identifier error. Removing app.d.ts from the project seemed to help in a specific case.\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2015-04-21T16:37:50Z",
        "body": "both app.ts and app.d.ts define the same objects. so you will get the duplicate identifier errors. you only need one of them, and not both. your .ts expresses API shape and implementation, where as your .d.ts expresses your API shape only. so if you are coding against it, you can use either, but not both.\n\nI usually think of .js + .d.ts together as package (e.g. a .net dll) that you use .js portion for execution, and .d.ts portion for typechecking. but both are outputs.\n"
      },
      {
        "user": "tomitrescak",
        "created_at": "2015-04-22T03:25:43Z",
        "body": "OK. The weird thing here is tha according to Typescript conventions I should always create d.t.s files and reserence them instead of the .ts files. This behaviour of Visual Studio makes this job a bit more difficult.\n"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2015-04-22T04:14:12Z",
        "body": "If you have a group of files part of a common project, I don't see any reason you shouldn't just reference the `.ts` file. The `.d.ts` is more useful to an external consumer.\n\nIf you're familiar with C/C++, think of a `.d.ts` as a header file that describes the interface to a linked library, which is the `.js` file here.\n"
      }
    ]
  },
  {
    "number": 2755,
    "title": "error TS6050: Unable to open file 'tsconfig.json'.",
    "created_at": "2015-04-14T02:03:54Z",
    "closed_at": "2015-04-14T02:50:22Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/2755",
    "body": "Why?\nI'm not giving reasons for this to happen:\n   1- Running on windows.\n   2- I've closed the tsconfig.json file.\n   2- The command is \"tsc\" under a folder that has the following tsconfig.json file:\n\n```\n{\n    \"files\": [\n        './js/**/*.ts',\n        './modules/**/*.ts'\n    ]\n}\n```\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/2755/comments",
    "author": "ladaltamirano",
    "comments": [
      {
        "user": "danquirk",
        "created_at": "2015-04-14T02:44:03Z",
        "body": "tsc config doesn't support globbing, does removing that fix the error?\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2015-04-14T02:51:48Z",
        "body": " #2627 is tracking showing the errors .\n"
      },
      {
        "user": "luzianz",
        "created_at": "2015-05-31T01:23:59Z",
        "body": "valid json uses **double** quotes, not single.\n"
      }
    ]
  },
  {
    "number": 2712,
    "title": "Question about importing js file in typescript fashion",
    "created_at": "2015-04-10T17:52:58Z",
    "closed_at": "2015-04-10T19:26:19Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/2712",
    "body": "I am trying to import an existing javascript source file(not a 3rd party module) into my typescript file using `import ... = require()` syntax with no success. Could you please help me point out anything I did wrong in the following isolated example?\n\nadd.js\n\n``` javascript\nmodule.exports = function (n1, n2) {\n    return n1 + n2;\n};\n```\n\nadd.d.ts\n\n``` typescript\ndeclare module \"add\" {\n    function add(n1: number, n2: number): number;\n    export = add;\n}\n```\n\nmain.ts\n\n``` typescript\n/// <reference path='node.d.ts' />\n/// <reference path='add.d.ts' />\nimport add = require('./add');\nconsole.log(add(1, 2));\n```\n\nWhen I try to compile `main.ts`, I got the following error:\n\n```\nerror TS2306: File 'add.d.ts' is not an external module.\n```\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/2712/comments",
    "author": "ericlu88",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2015-04-10T18:16:02Z",
        "body": "Since you defclared add as an ambient module, in your consumtion file, main.ts do not use relative paths.\n\n``` ts\n/// <reference path='node.d.ts' />\n/// <reference path='add.d.ts' />\nimport add = require('add');\nconsole.log(add(1, 2));\n```\n"
      },
      {
        "user": "ericlu88",
        "created_at": "2015-04-10T18:21:33Z",
        "body": "@mhegazy This works with the compiler, but the generated js file will have `var add = require(add)`, which is incorrect module loading code for node. Node will error at runtime:\n\n```\nError: Cannot find module 'add'\n    at Function.Module._resolveFilename (module.js:336:15)\n    at Function.Module._load (module.js:278:25)\n    at Module.require (module.js:365:17)\n    at require (module.js:384:17)\n    at Object.<anonymous> (/Users/EricLu/Documents/Temp/main.js:3:11)\n    at Module._compile (module.js:460:26)\n    at Object.Module._extensions..js (module.js:478:10)\n    at Module.load (module.js:355:32)\n    at Function.Module._load (module.js:310:12)\n    at Function.Module.runMain (module.js:501:10)\n```\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2015-04-10T18:35:45Z",
        "body": "if you want to use relative path in the import, you will need:\n1. put the add.d.ts next to add.js\n2. define the file as an external module:\n\n```\n// add.d.ts\ndeclare function add(n1: number, n2: number): number;\nexport = add;\n```\n\ni.e. loose the \"declare module \"add\"\" part.\n\n#### more details:\n\nThere are two ways to define declarations for a .js module:\n\n1  using `declare module \"foo\"` and then you can have multiple module definitions in the same file:\n\n``` ts\n\n// mydefinitions.d.ts\ndeclare module \"mod1\" {\n    export var x = 0;\n}\n\ndeclare module \"mod2\" {\n    export var y = 0;\n}\n\ndeclare module \"mod3\" {\n    export var z = 0;\n}\n```\n\nand consuming them would have to be using absolute names:\n\n``` ts\n// main.ts\n\n/// <reference path=\"myDefintions.d.ts\" />\nimport * as mod1 from \"mod1\";\nimport mod2 = require(\"mod2\");\nimport {z} from \"mod3\";\n```\n\n2 alternatively you can define as a file, where the name of the file is the name of the module\n\n``` ts\n// myModule.d.ts\n\ndeclare var m = 0;\nexport = m;\n```\n\nand consume it as a normal .ts module:\n\n``` ts\nimport m = require(\"./myModule\");\nm.toString();\n```\n"
      },
      {
        "user": "canmrt",
        "created_at": "2015-06-29T09:51:47Z",
        "body": "How can I import a javascript file which consists of several modules with a single d.ts file by using relative paths?\n\nExample:\n\n``` js\n// bundle.js\ndefine('alert/alert', [\n    'require',\n    'exports'\n], function (require, exports) {\n    var Alert = function () {\n        function Alert() {\n        }\n        Alert.prototype.alert = function (message) {\n            alert(message);\n        };\n        return Alert;\n    }();\n    exports.Alert = Alert;\n});\ndefine('log/log', [\n    'require',\n    'exports'\n], function (require, exports) {\n    var Log = function () {\n        function Log() {\n        }\n        Log.prototype.log = function (message) {\n            console.log(message);\n        };\n        return Log;\n    }();\n    exports.Log = Log;\n});\ndefine('bundle', [\n    'require',\n    'exports',\n    'alert/alert',\n    'log/log'\n], function (require, exports, alert_1, log_1) {\n    exports.Alert = alert_1.Alert;\n    exports.Log = log_1.Log;\n});\n```\n\n``` js\n// bundle.d.ts\ndeclare module 'alert/alert' {\n    export class Alert {\n        alert(message: string): void;\n    }\n\n}\ndeclare module 'log/log' {\n    export class Log {\n        log(message: string): void;\n    }\n\n}\ndeclare module 'bundle' {\n    import { Alert as _Alert } from 'alert/alert';\n    import { Log as _Log } from 'log/log';\n    export var Alert: typeof _Alert;\n    export var Log: typeof _Log;\n\n}\n```\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2015-06-29T18:43:49Z",
        "body": "@canmrt add a /// <reference to your bundle.d.ts and then import your modules by name. e.g.:\n\n``` ts\nimport { Log } from \"log/log\";\n```\n"
      }
    ]
  },
  {
    "number": 2609,
    "title": "Class decorator parameters",
    "created_at": "2015-04-03T19:57:28Z",
    "closed_at": "2015-04-08T22:57:28Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/2609",
    "body": "I'm fairly sure I have the syntax right:\n\n``` javascript\n@ClassDecoratorTest(\"Test\")\nclass Test\n{\n}\n\nfunction ClassDecorationTest(target, name)\n{\n}\n```\n\nBut this won't compile. I get the following error on the @ClassDecorator line:\n\nerror TS2346: Supplied parameters do not match any signature of call target.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/2609/comments",
    "author": "jamiewinder",
    "comments": [
      {
        "user": "ghost",
        "created_at": "2015-04-05T18:52:57Z",
        "body": "This code works. It will log \"Test\" to the console.\n\n``` typescript\n@ClassDecoratorTest(\"Test\")\nclass Test {\n}\n\nfunction ClassDecoratorTest(str) {\n    return function (target): void {\n        target['d_value'] = str;\n        return target;\n    }\n}\n\nconsole.log(Test['d_value']);\n```\n\nWhen passing arguments you have to return a function with the correct format. `tsc` helps you with it, if you provide a wrong signature, it will tell you what you've done wrong.\n"
      }
    ]
  },
  {
    "number": 2492,
    "title": "tsconfig.json purpose?",
    "created_at": "2015-03-25T19:00:57Z",
    "closed_at": "2015-03-25T19:28:46Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/2492",
    "body": "Question: tsconfig.json appears to be a reasonable way to specify a compilation context. Why isn't it available from the command line? ( tsc -c tsconfig.json ). I would like to be able to use tsconfig.json within a build system ( gulp based ) rather than it be a build system.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/2492/comments",
    "author": "ToddThomson",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2015-03-25T19:19:51Z",
        "body": "On the command line you can run:\n\n> tsc -p <Directory path of tsconfig.json>\n\nor just call tsc with no file arguments in a directory with tsconfig.json in it\n\n> tsc\n\nyou can configure your build systems to call tsc with -p. @ivogabe might be able to help you better here.\n"
      }
    ]
  },
  {
    "number": 2420,
    "title": "Unsupported file encoding",
    "created_at": "2015-03-19T00:46:40Z",
    "closed_at": "2015-03-19T00:53:46Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/2420",
    "body": "Hi, i have a typescript file which provide string translations for Italian in my solution, when i compile the solution, i got follow compile errors:\n\nSeverity    Code    Description Project File    Line\nError       Build: Cannot read file 'D:/workdir/devunits/song_cordova20150227_dev/src/cordova/scripts/app/I18N/it-IT/Strings.ts': Unsupported file encoding.\n\nEnv and Tools i used:\nVS2015 CTP5 (incl. TS 1.4), Cordova project.\n\nHere is the content of cordova/scripts/app/I18N/it-IT/Strings.ts: \n\n\"use strict\";\nexport var Strings = {\n    MsgMarkUpShareFailed: \"Impossibile condividere i markup in OneNote\",\n    Erase: \"Cancella\",\n    TextForSelectJTFolder: \"Selezionare la cartella JT suddivisa\",\n    Error_Printing: \"Errore durante la stampa del modello\",\n    SharedFileNotFoundExceptionMessage: \"Impossibile trovare il file richiesto in OneDrive. Verificare con gli utenti che condividono il file che siano state accordate le necessarie autorizzazioni.\",\n    Property_LastAuthor: \"Ultimo autore\",\n    OpenInJT2Go: \"Apri in JT2Go\",\n    ShowPMI: \"Mostra PMI\",\n    Share: \"Condividi\",\n    MsgBedDepth: \"La  profondit\u00e0 deve essere maggiore di 0.\",\n    Cancel: \"Annulla\",\n    Error_NonPositiveVolume: \"Stampa interrotta. Il modello non ha un volume positivo\",\n    Dimensions: \"Quote\",\n    DrillUp: \"Drill up\",\n    MsgBedHeight: \"L'altezza deve essere maggiore di 0.\",\n    Property: \"Propriet\u00e0\",\n    Note: \"Nota\",\n    MsgPLMXMLWasModified: \"Il markup \u00e8 stato modificato e deve essere salvato. Salvarlo ora?\",\n    Loading: \"Caricamento\",\n    Created: \"creato\",\n    Property_Parts: \"Parti\",\n    OrientTo: \"Orienta verso\",\n    DrillDown: \"Drill down\",\n    Section: \"Sezione: \",\n    Samples: \"Campioni\",\n    Print: \"Stampa\",\n    Property_ProjectName: \"Nome progetto\",\n    AlignToView: \"Allinea a vista\",\n    TakeImage: \"Scegli immagine\",\n    ToLast: \"Vai all'ultimo\",\n    Property_Density: \"Densit\u00e0\",\n    DFS: \"Simboli feature Datum\",\n    Default: \"Predefinita\",\n    MsgPLMXMLNotMatchJTError: \"Questo file plmxml non corrisponde al file jt attualmente aperto. Selezionare il file corretto e riportare.\",\n    MsgFailedCreateHomePage: \"Errore durante la creazione della pagina iniziale.\",\n    Snapshot: \"Istantanea\",\n    BedHeight: \"Altezza (mm)\",\n    PinToStart: \"Aggancia all'avvio\",\n    Property_Unit: \"Unit\u00e0\",\n    PrintBedDepth: \"Profondit\u00e0\",\n    SelectionColor: \"Finestra dei colori\",\n    Home: \"Pagina iniziale\",\n    Pan: \"Sposta\",\n    Text: \"Caricatore di testo\",\n    Property_DocumentNumber: \"Nr. documento\",\n    MsgBedWidth: \"Lo spessore deve essere maggiore di 0.\",\n    TextForSelectJT: \"Selezionare un file JT\",\n    Properties: \"Propriet\u00e0\",\n    DefaultMarkupItemDescription: \"Commenti senza titolo\",\n    Property_TranslationDate: \"Data conversione\",\n    FinishPrinting: \"Dati inviati alla stampante 3D\",\n    FCF: \"Fotogrammi controllo feature\",\n    Error_InvalidModel: \"Stampa interrotta. Il modello non \u00e8 definito correttamente\",\n    Property_Company: \"Azienda\",\n    General: \"Generale\",\n    PMIFilters: \"Filtri PMI\",\n    MeasurementPoints: \"Punti di misurazione\",\n    Save: \"Salva\",\n    Open: \"Apri\",\n    ChooseImage: \"Scegli immagine\",\n    Property_NameOfSavingApplication: \"Nome dell'applicazione da salvare\",\n    BedWidth: \"Larghezza (mm)\",\n    Other: \"Altro\",\n    OneDriveLoadMarkupExceptionMessage: \"Errore durante l'apertura del markup da OneDrive\",\n    SettingLanguage: \"Lingua\",\n    DatumTargets: \"Destinazioni datum\",\n    SpotWelds: \"Punti di unione\",\n    StartPrinting: \"Stampa iniziata. L'operazione potrebbe richiedere alcuni minuti\",\n    HidePMI: \"Nascondi PMI\",\n    ShareToOneNote: \"Condividi in OneNote\",\n    Accept: \"Accetta\",\n    Less: \"Meno\",\n    More: \"Altro\",\n    Property_CADSource: \"Origine CAD\",\n    PMIPanelState: \"Selezionare i tipi PMI da visualizzare\",\n    SelectAll: \"Seleziona tutto\",\n    MsgGreaterThan: \"{0} deve essere maggiore di 0.\",\n    ToggleCamera: \"Attiva/Disattiva  videocamera\",\n    CollapseBar: \"Comprimi barra\",\n    Normal: \"Normale\",\n    DeleteView: \"Elimina vista\",\n    Error_NonManifold: \"Stampa interrotta. Il modello non \u00e8 impermeabile\",\n    OneDriveAuthenticationExceptionMessage: \"Errore durante il caricamento del file richiesto perch\u00e9 le credenziali di autenticazione presentano un'anomalia per quanto riguarda la connessione a OneDrive.\",\n    LanguageTag: \"it-IT\",\n    Property_LastSaveDate: \"Data ultimo salvataggio\",\n    Property_TriangleCount: \"Numero di triangoli\",\n    AppDescription: \"Un'applicazione di rendering 3D per la visualizzazione di file di formato JT.\",\n    View: \"Vista\",\n    Property_Keywords: \"Parole chiave\",\n    LoadFile: \"Carica\",\n    EditDescription: \"Modifica descrizione\",\n    ShowAllPMI: \"Mostra tutte le informazioni PMI\",\n    BedDepth: \"Spessore (mm)\",\n    Delete: \"Elimina\",\n    Property_ApplicationName: \"Nome applicazione\",\n    FullScreen: \"Schermo intero\",\n    Error_LoadPart: \"Impossibile aprire il file JT specificato\",\n    ModelView: \"Vista modello\",\n    Fit: \"Adatta\",\n    SharingStatus: \"Condivisione\",\n    LoadingStatus: \"Caricamento\",\n    RestoreDefaults: \"Ripristina i default\",\n    ExceedPrintableAreaMessage: \"Il modello supera l'area stampabile\",\n    HideAllPMI: \"Nascondi tutte le informazioni PMI\",\n    Recent: \"Recente\",\n    TextForSelectImage: \"Seleziona un file di immagine\",\n    Error: \"Errore\",\n    Property_Geometry: \"Geometria\",\n    Locators: \"Localizzatori\",\n    OneDriveLoginExceptionMessage: \"Impossibile eseguire l'accesso a OneDrive\",\n    Property_Comments: \"Commenti\",\n    Property_Category: \"Categoria\",\n    Property_Attribute: \"Attributo\",\n    Settings: \"Impostazioni\",\n    Spin: \"Rotazione\",\n    Hide: \"Nascondi\",\n    Freehand: \"A mano libera\",\n    PrintBedWidth: \"Larghezza\",\n    Attribute: \"Attributo\",\n    Property_TranslatorVersion: \"Versione convertitore\",\n    Reset: \"Ripristina\",\n    Options: \"Opzioni\",\n    Surface: \"Superficie\",\n    BackgroundColor: \"Colore sfondo\",\n    ViewType: \"Visualizza tipo\",\n    Property_VertexCount: \"Numero di vertici\",\n    LoadFileExceptionMessage: \"Si \u00e8 verificato un errore durante il caricamento del file.\",\n    Status_Pinned_Success: \"JT2Go \u00e8 agganciato allo schermo iniziale\",\n    Property_Length: \"Lunghezza\",\n    FontFamily: \"Segoe UI\",\n    Property_Subject: \"Oggetto\",\n    PMIColor: \"Colore PMI\",\n    PartLoaderExceptionMessage: \"Si \u00e8 verificato un errore durante il caricamento del file JT specificato.\",\n    Property_Author: \"Autore\",\n    MsgMarkUpShareSuccessed: \"Markup condivisi correttamente in OneNote\",\n    ClearAll: \"Cancella tutto\",\n    Property_OriginationDate: \"Data di origine\",\n    OneDriveConnectionExceptionMessage: \"Errore durante il caricamento del file richiesto causato dalla connessione OneDrive.\",\n    MsgExpectedNumber: \"{0} deve essere un numero.\",\n    Part: \"Parte\",\n    Status_Pinned_Failure: \"Errore durante l'aggancio di JT2GO alla schermata iniziale\",\n    LiveCamera: \"Videocamera live\",\n    Legal: \"Legale\",\n    Property_Name: \"Nome\",\n    Property_Width: \"Larghezza\",\n    Discard: \"Elimina\",\n    Decline: \"Calo\",\n    MsgFailedCreateLicensePage: \"Errore durante la creazione della pagina di licenze.\",\n    Geometry: \"Geometria\",\n    ShowAllParts: \"Mostra tutte le parti\",\n    Property_Material: \"Materiale\",\n    ToFirst: \"Vai al primo\",\n    ShatteredFolderIncorrectExceptionMessage: \"Si \u00e8 verificato un problema durante il caricamento della cartella suddivisa. Verificare di aver selezionato la cartella esatta.\",\n    PrivacyPolicy: \"Criteri sulla privacy\",\n    PrintBedHeight: \"Altezza\",\n    Property_Title: \"Titolo\",\n    WaitingStatus: \"Attesa\",\n    Background: \"Sfondo\",\n    CoordinateSystems: \"Sistemi di coordinate\",\n    Property_Height: \"Altezza\",\n    Structure: \"Struttura\",\n    DefaultMarkupItemDescriptionWithUserName: \"Commenti di {0}\",\n    Default3DPrinter: \"Stampante 3D predefinita\",\n    Help: \"Guida\"\n}\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/2420/comments",
    "author": "franksoong",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2015-03-19T00:49:02Z",
        "body": "The compiler does not support ANSI encoding, which i am guessing the encoding for this file. so you need to save the file in Unicode, to do that, in VS go to file\\Advanced Save Options, select \"Unicode (UTF-8 with Signature)\" and hit ok. save your file and try again.\n"
      }
    ]
  },
  {
    "number": 2373,
    "title": "Passthrough require(\"jsfile\") for commonjs",
    "created_at": "2015-03-16T16:53:03Z",
    "closed_at": "2015-03-16T22:01:36Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/2373",
    "body": "Hello Typescipters,\n\nI'm using the `Q` library with its typings installed via `tsd`.\nIn a module I'm using\n\n``` typescript\n/// <reference path=\"../typings/q/Q.d.ts\"/>\n// ...\n```\n\ncompiled with\n\n``` bash\ntsc -m commonjs --out test.js test.ts\ntsc --version\nmessage TS6029: Version 1.4.1.0\n```\n\nand would like `test.js` to contain a line like\n\n``` javascript\nvar Q = require(\"path/to/q\"); // to be executed by nodejs\n```\n\nwhere `path/to/q` points to the javascript file and has nothing to do with `../typings/q/Q.d.ts`.\nUsing `import Q = require(\"path/to/q\");` won't work as it probably expects a typescript module.\n\n``` bash\nbuilder.ts(5,32): error TS2307: Cannot find external module './../bower_components/q/q'.\n```\n\nI haven't found how to achieve this without rolling out some hackish _ad-hoc_ source markup/parse/replace. Have I overlooked something?\n\nIn a way I'm trying to \"link\" to the library code (in the C meaning) with node's `require` after having included the declarations (references to the `d.ts`).\n\nIf this is not currently possible, may I suggest a pass-through version of `require()` which kicks in when `-m commonjs` is used? Perhaps `js_require(\"blabla\")` which would be emitted as node's `require(\"blabla\")`. This would make it a lot easier to leverage other tools which analyze `require` statements.\n\nGreetings\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/2373/comments",
    "author": "dbarbeau",
    "comments": [
      {
        "user": "DanielRosenwasser",
        "created_at": "2015-03-16T17:29:13Z",
        "body": "> Using `import Q = require(\"path/to/q\");` won't work as it probably expects a typescript module.\n\nThe `import` keyword with a `require(...)` on the RHS works the same way as if you'd used a `var` except that it also brings in type information at compile time. What you can do in `test.js` is include both the `/// <reference path=\"../typings/q/Q.d.ts\"/>` and then `import Q = require(\"path/to/q\");`. Give it a try and let us know. If not, maybe there's some information I'm missing.\n"
      },
      {
        "user": "dbarbeau",
        "created_at": "2015-03-16T18:02:20Z",
        "body": "Hi! And thanks!\nI think you meant using `var` instead of `import`, because\n\n``` typescript\n/// <reference path='typings/q/Q.d.ts'/>\nimport q = require(\"bower_components/q/q\");\nvar deferred = Q.Promise(function(a,b,c){});\n```\n\nthrows `error TS2307: Cannot find external module 'bower_components/q/q'` and no code is generated (the output file is blank) while\n\n``` typescript\n/// <reference path='typings/q/Q.d.ts'/>\nvar q = require(\"bower_components/q/q\");\nvar deferred = Q.Promise(function(a,b,c){});\n```\n\nthrows `error TS2304: Cannot find name 'require'` and... the compiler does output the code I want :)\nSo it does work, though user feedback is a bit misleading!\n\n**EDIT:** To remove the TS2304 error, I had to add a reference tag to `node.d.ts`. Changing `import` to `var` has some consequences!\n\nThanks again ;)\n"
      },
      {
        "user": "dbarbeau",
        "created_at": "2015-03-16T18:44:34Z",
        "body": "I should have done a few more tests, because there is a catch:\n\n``` typescript\n/// <reference path=\"typings/node/node.d.ts\"/>\n/// <reference path=\"typings/q/Q.d.ts\"/>\n\nvar Q            = require(\"./../bower_components/q/q\");   /* LINE X */\nimport path   = require(\"path\"); /* LINE Y */\n\nvar qprom = Q.Promise(function(a,b,c){\n    var dummy = path.join(__dirname, \"yo\");  /* LINE Z */\n});\n```\n\nThe reference tag will declare Q with the type information.\n**LINE X** will declare another Q.\n\nIf you compile it like this, tsc 1.4.1.0 will emit no error, but also no code :)\nRemove **LINE Y** and **LINE Z** and you'll get.\n\n``` bash\nrequiretest2.ts(4,5): error TS2300: Duplicate identifier 'Q'.\ntypings/q/Q.d.ts(10,18): error TS2300: Duplicate identifier 'Q'.\ntypings/q/Q.d.ts(14,18): error TS2300: Duplicate identifier 'Q'.\ntypings/q/Q.d.ts(16,16): error TS2300: Duplicate identifier 'Q'.\n```\n\nSeems reasonable enough, although the compiler does emit the code I want. \n\nNow, suppose that TS2300 didn't emit code (or that I simply want to avoid having errors in my code). I'd have to write my typescript code against the Q declared in the 'Q.d.ts' file, but this would conflict with the Q created on the `require(...)` line. So, I'd have to write `var smallq = require(...);` instead of **LINE X**, but then at runtime nodejs would complain that `Q` doesn't exist. Or I write against `smallq` and lose the benefit of types.\n\nI'm in a deadlock :)\n"
      },
      {
        "user": "danquirk",
        "created_at": "2015-03-16T20:13:13Z",
        "body": "You absolutely want to use `import` and not `var`. Without `import` there is no type information associated with the `Q` you declared. You also just want to require the name as `'q'` and not the relative path. The last 3 lines of Q.d.ts are written to enable this pattern, similar to why you can require `\"path\"` like that from node.d.ts. This is how it should look:\n\n``` ts\n/// <reference path=\"Q.d.ts\"/>\nimport Q = require('q');\n\nvar aprom = Q.Promise((a,b,c) => {\n    console.log('hi');\n});\n```\n\nemits:\n\n```\n> tsc a.ts -m commonjs\n> type a.js\n/// <reference path=\"Q.d.ts\"/>\nvar Q = require('q');\nvar aprom = Q.Promise(function (a, b, c) {\n    console.log('hi');\n});\n```\n"
      },
      {
        "user": "dbarbeau",
        "created_at": "2015-03-16T22:01:36Z",
        "body": "Thank you @DanielRosenwasser and @danquirk  for the clear instructions, I wasn't going the right way. Now, I just had one issue in that compiling that exact file (`a.ts`) with:\n\n``` bash\ntsc a.ts -m commonjs --out a.js\n```\n\n(notice the --out flag) produced an empty `a.js`, whereas just omitting the `--out a.js` flag worked. I'm a bit confused, I'll need to check my installation, there's something fishy. Regarding the initial question I think it has been answered so this issue is closed.\n\n### LAST MINUTE OMG\n\nThe `--out` doesn't do what I expected it to do!\n\n``` bash\n> rm *.js\n> tsc a.ts -m commonjs --out ahaha.js\n> ls -l\ntotal 8\n-rw-rw-r--. 1 d d 136 16 mars  22:51 a.js\n-rw-rw-r--. 1 d d 131 16 mars  22:40 a.ts\n-rw-rw-r--. 1 d d   0 16 mars  22:51 ahaha.js\n```\n\nI was NOT expecting `a.js`, I thought the output would just end up in `ahaha.js`. So by specifiying that flag, I was overwriting tsc's output with a blank file. But why is it blank?\nI'll need to check my basic assumptions of life (like does `gcc -o` behave like this?)... wow!\n\nThanks again!\nDaniel\n"
      },
      {
        "user": "danquirk",
        "created_at": "2015-03-16T23:02:46Z",
        "body": "You generally don't want to use --out with external modules like you have. The target file for --out only gets whatever is in the global namespace. This is good when you're concatenating multiple internal modules together but it doesn't support concatenating multiple files together into a single external module. So most of the time you'll get 1 js file per ts file and an empty file that you asked --out for. We have an issue logged somewhere around here to consider just making it an error if --out creates an empty file since other people also get confused by this behavior .\n"
      }
    ]
  },
  {
    "number": 2189,
    "title": "Tuple type vs. array-of-union-type",
    "created_at": "2015-03-03T08:19:15Z",
    "closed_at": "2015-03-03T09:24:25Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/2189",
    "body": "Have I made a silly mistake here? I thought the tuple type `[string, number]` was roughly equivalent to the array-of-union-type `(string | number)[]`, and that the following was therefore legal:\n\n```\nfunction lengths (xs: string[]): [string, number][] {\n   return xs.map((x: string) => [x, x.length])\n}\n```\n\nHowever tsc 1.4 complains:\n\n```\nConfig.ts(127,11): error TS2322: Type '(string | number)[][]' is not assignable to type '[string, number][]'.      Type '(string | number)[]' is not assignable to type '[string, number]'.\n    Property '0' is missing in type '(string | number)[]'.\n```\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/2189/comments",
    "author": "rolyp",
    "comments": [
      {
        "user": "DanielRosenwasser",
        "created_at": "2015-03-03T08:46:10Z",
        "body": "I _believe_ (and others on the team should feel free to correct me) that this has to do with the way in which contextual typing takes effect (i.e. it _doesn't_ take effect on the return type of a call\u00a0expression).\n\nIn other words, `lengths`'s return type doesn't impact your call's type, and so the language computes the type `(string | number)[]`.\n\nYou can get the behavior you want by giving your lambda a return type.\n\n``` TypeScript\nfunction lengths(xs: string[]): [string, number][] {\n    return xs.map((x): [string, number] => [x, x.length]);\n}\n```\n"
      }
    ]
  },
  {
    "number": 2149,
    "title": "Define variable to match declared variable with 'new'",
    "created_at": "2015-02-26T10:24:05Z",
    "closed_at": "2015-02-26T14:31:52Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/2149",
    "body": "It is possible to define variable with declared when the function name is not 'new'\n\n``` typescript\ninterface X {\n}\ndeclare var X: {\n    f(): X;\n}\n\n// OK, compatible type\nvar X = {\n    f() { return <X>null; }\n};\n\n\ninterface Y {\n}\ndeclare var Y: {\n    new(): Y;\n}\n\n// Not compatible types\n// new() : Y vs. new() => Y\nvar Y = {\n    new() { return <Y>null; }\n};\n```\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/2149/comments",
    "author": "NN---",
    "comments": [
      {
        "user": "ahejlsberg",
        "created_at": "2015-02-26T14:31:12Z",
        "body": "Yes, you can do that by putting the property name in quotes in the declaration:\n\n``` typescript\ninterface Y {\n}\ndeclare var Y: {\n    \"new\"(): Y;  // Quotes to indicate this is not a construct signature\n}\n\n// OK, compatible type\nvar Y = {\n    new() { return <Y>null; }\n};\n```\n"
      },
      {
        "user": "NN---",
        "created_at": "2015-02-26T18:40:19Z",
        "body": "@ahejlsberg The only problem is that I cannot change the declaration :)\nIt is in lib.d.ts\nI am trying to define variable of Blob:\n\n``` typescript\ninterface Blob {\n    type: string;\n    size: number;\n    msDetachStream(): any;\n    slice(start?: number, end?: number, contentType?: string): Blob;\n    msClose(): void;\n}\ndeclare var Blob: {\n    prototype: Blob;\n    new (blobParts?: any[], options?: BlobPropertyBag): Blob;\n}\n```\n"
      },
      {
        "user": "ahejlsberg",
        "created_at": "2015-02-26T19:12:47Z",
        "body": "Not quite sure what you mean by \"trying to define variable of Blob\". Do you mean define a value that can be assigned to Blob? The Blob variable represents a constructor function (i.e. it is a variable of a constructor function type). To produce an assignment compatible value, you'll likely want to declare a class. For example:\n\n``` typescript\nclass MyBlob implements Blob {\n    type: string;\n    size: number;\n    constructor(blobParts?: any[], options?: BlobPropertyBag) {\n    }\n    msDetachStream(): any {\n        return undefined;\n    }\n    slice(start?: number, end?: number, contentType?: string): Blob {\n        return undefined;\n    }\n    msClose(): void {\n    }\n}\n```\n\nYou can then assign the class constructor function to the `Blob` variable:\n\n``` typescript\nBlob = MyBlob;\n```\n\nNote, it is important to understand that there are two distinct and different things called Blob: A type (produced by the interface declaration) and a variable (with an _unnamed_ constructor function type whose return value is the Blob interface). In type positions, Blob refers to the interface type, and in value positions (such as expressions) Blob refers to the constructor function.\n"
      },
      {
        "user": "NN---",
        "created_at": "2015-02-26T19:18:17Z",
        "body": "I want to define the variable that is declared by 'declare var Blob : { ... }' .\n\n``` typescript\nvar Blob = {  \n // prototype and the constructor\n};\n```\n"
      },
      {
        "user": "ahejlsberg",
        "created_at": "2015-02-26T20:03:02Z",
        "body": "You can't do that with an object literal because an object literal isn't \"callable\", i.e. it can't have a call or construct signature. Instead you need to write\n\n``` typescript\nvar Blob = MyBlob;\n```\n\nwhere `MyBlob` is a constructor function name introduced by a suitable class declaration (like my example above). Or you can assign some suitable constructor function object typed as `any` that you know has the correct shape.\n\nIt's important to understand that\n\n``` typescript\ndeclare var Blob: {\n    prototype: Blob;\n    new (blobParts?: any[], options?: BlobPropertyBag): Blob;\n}\n```\n\ndoesn't introduce a property named \"new\", but rather introduces a construct signature that defines how to call the constructor function using the `new` operator, as in\n\n```\nvar x = new Blob(...);\n```\n\nSo, basically the declaration says that `Blob` is a variable of a constructor function type that (a) has a property named `prototype` and (b) can be called using `new` with the specified parameters.\n"
      },
      {
        "user": "NN---",
        "created_at": "2015-02-26T21:04:04Z",
        "body": "Unfortunately this doesn't work.\nIt works with explicit cast, is it a bug ?\n\n``` typescript\ninterface QQ {\n}\n\ndeclare var QQ:{\n    new(): QQ;\n}\n\nclass QQImpl {\n    constructor() {}\n}\n\nvar QQ = QQImpl; // Doesn't work \n\n// But works with explicit cast !\nvar QQ = <{new():QQ;}> QQImpl;\n```\n"
      },
      {
        "user": "ahejlsberg",
        "created_at": "2015-02-26T21:14:35Z",
        "body": "You're getting an error because your `var QQ = QQImpl;` statement redeclares `QQ` with a (slightly) different type. The following works:\n\n``` typescript\ninterface QQ {\n}\n\ndeclare var QQ:{\n    prototype: QQ; // Include prototype property to make type identical to class\n    new(): QQ;\n}\n\nclass QQImpl {\n    constructor() {}\n}\n\nvar QQ = QQImpl; // Ok, types of QQ and QQImpl identical\n```\n\nAs does this:\n\n``` typescript\ninterface QQ {\n}\n\ndeclare var QQ:{\n    new(): QQ;\n}\n\nclass QQImpl {\n    constructor() {}\n}\n\nQQ = QQImpl; // Assignment, not redeclaration\n```\n"
      },
      {
        "user": "NN---",
        "created_at": "2015-02-26T21:20:08Z",
        "body": "The first sample doesn't work since the QQImpl doesn't have prototype property and types are incompatible.\nThe second one is not what I need because it produces the following JS.\nIt will fail in strict parsing mode if nobody defined QQ before.\n\n``` javascript\nvar QQImpl = (function () {\n    function QQImpl() {\n    }\n    return QQImpl;\n})();\nQQ = QQImpl; // Assignment, not redeclaration\n```\n"
      },
      {
        "user": "ahejlsberg",
        "created_at": "2015-02-26T21:41:29Z",
        "body": "It works in master, but apparently not with 1.3 or earlier.\n\nI'm still not sure what you're trying to accomplish so it's hard to make further suggestions. If all you care about is declaring a class QQ that has the same shape as the interface/var QQ, then you can simply do this:\n\n``` typescript\nclass QQ {\n}\n```\n\nThis introduces **_both**_ an interface QQ and a \"variable\" QQ (the constructor function) and in use you'll see the same effect as if you had declared the separate interface and variable.\n"
      },
      {
        "user": "NN---",
        "created_at": "2015-02-27T07:05:29Z",
        "body": "Ok, the situation is the following.\nI am using ES5 and browser specific features but some of them don't exist in other environments like nodejs or other browsers.\nNow I want to define a variable and make everything works without getting RefereneError.\nI can access to all variables through 'window' object and then it is possible to check and assign easily:\n\n``` typescript\nif (window.Blob) {\n   // Use window.Blob\n}\n```\n\nBut I don't want to change my code, moreover some definition libraries do not define global variables both globally and in window, so it means that I must rewrite definitions.\n\nI can add pure JS file that does the simple thing: \"function Blob() {}\" and that's all I need.\nI wanted to solve it using TypeScript language.\nSince I have typing and all interfaces defined I won't make a mistake in defining variables or types.\n\nI hope it is clear now.\nThanks.\n"
      },
      {
        "user": "NN---",
        "created_at": "2015-02-27T18:58:16Z",
        "body": "Found it ! :)\nYour code is totally correct but I was missing the 'var' part and it works as expected when I add it.\nThe only change is that I must specify the exact type of the declared variable.\nI would like to see whether it can be inferred somehow there. \n\n``` typescript\nclass MyBlob implements Blob {\n    constructor(blobParts?: any[], options?: BlobPropertyBag) { }\n    msDetachStream(): any {}\n    slice(start?: number, end?: number, contentType?: string): Blob { throw new Error(\"Not implemented\"); }\n    msClose(): void {}\n    type: string;\n    size: number;\n}\nvar Blob: {\n    prototype: Blob;\n    new(blobParts?: any[], options?: BlobPropertyBag): Blob;\n} = MyBlob;\n```\n"
      }
    ]
  },
  {
    "number": 2147,
    "title": "Question, how to make a variable within declared module name",
    "created_at": "2015-02-26T06:41:20Z",
    "closed_at": "2015-02-26T07:16:30Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/2147",
    "body": "I am writing a test and I have an issue.\nThe test runner doesn't have the global object I need since it is running in a different environment.\nI want to create this object because strict mode complains otherwise, but TypeScript cannot do it.\n\nI have declaration:\n\n``` typescript\ndeclare module Q {\n    function f(): string;\n}\n```\n\nand usage\n\n``` typescript\nvar x = Q.f();\n```\n\nNow in my test I want to mock Q.f and create object of my own.\n\n``` typescript\nvar Q = { ... }\n```\n\nThe TypeScript complains about multiple declarations.\n\nThere is a workaround to access the module through the global 'window' object in the code and then it is possible to test it.\n\n``` typescript\ninterface Window {\n Q: QInterface;\n}\n\ninterface QInterface {\n    function f(): string;\n}\n\n// the code\nvar x = !!window.Q ? window.Q.f() : \"\";\n```\n\nI would like to not use the workaround and find some solution without changing my code.\nThanks.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/2147/comments",
    "author": "NN---",
    "comments": [
      {
        "user": "DanielRosenwasser",
        "created_at": "2015-02-26T06:45:13Z",
        "body": "It sounds like describing your module with an interface will solve your problem.\n\n``` TypeScript\ninterface Q {\n    f(): string;\n}\n\nvar Q = {\n    f() {\n        return \"Hello\";\n    }\n}\n\nvar x = Q.f();\n```\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2015-02-26T06:53:02Z",
        "body": "how about;\n\n``` TypeScript\ndeclare var Q : {\n    f(): string;\n};\n```\n\nlater on in your tests:\n\n``` TypeScript\nvar Q = {\n    f() { .. }\n}\n```\n"
      },
      {
        "user": "NN---",
        "created_at": "2015-02-26T06:59:59Z",
        "body": "@DanielRosenwasser I don't see how it solves it\n@mhegazy It means that I must rewrite all the definition files that don't use 'var' .\nSome of definitions files are in the following form:\n\n``` typescript\ndeclare module A.B {\n function f(): Interface;\n interface I {}\n}\ndeclare module A.C {\n function g(): Interface; // Yes the same name as A.B but different meaning of course.\n interface I {}\n}\n//2500 similar lines\n```\n\nIs there easy way to refactor it ?:)\n"
      },
      {
        "user": "NN---",
        "created_at": "2015-02-26T07:02:50Z",
        "body": "If I could use modules as types specifiers then it would be easy to refactor the code for 'var' .\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2015-02-26T07:03:28Z",
        "body": "The probelm is that a module and var do not really merge. the var will override the value of the module, so this is why it is flagged as an error.\n\nhow about this:\n\n``` TypeScript\n// declaration\ndeclare module M {\n    function f(): string;\n}\n\n\n// tests\nmodule M { \n    M.f = ()=> \"\";\n}\n```\n"
      }
    ]
  },
  {
    "number": 2135,
    "title": "Import statement causes problem with external module ",
    "created_at": "2015-02-25T10:32:56Z",
    "closed_at": "2015-02-26T05:11:18Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/2135",
    "body": "I'm trying to write a tool for `Typescript`. Though I got some problem:\n\nIn scanner.ts:\n\n``` typescript\n/// <reference path=\"../../typings/node/node.d.ts\" />\n/// <reference path=\"../../typings/typescript/typescript.d.ts\" />\n/// <reference path=\"types.ts\" />\n\nimport ts = require(\"typescript\");\n\nmodule pp {\n    var textToToken: Map<AnnotationSyntaxKind> = {\n        \"@\": AnnotationSyntaxKind.AtsignToken,\n        \"@if\": AnnotationSyntaxKind.IfKeyword,\n        \"@endif\": AnnotationSyntaxKind.EndIfKeyword,\n        \"@requires\": AnnotationSyntaxKind.RequiresKeyword\n    }\n}\n```\n\nIn types.ts:\n\n``` typescript\nmodule pp {\n    export interface Map<T> {\n        [index: string]: T;\n    }\n\n    export const enum AnnotationSyntaxKind {\n        AtsignToken,\n        IfKeyword,\n        EndIfKeyword,\n        RequiresKeyword\n    }\n}\n```\n\nThis setup will yield:\n\n```\nsrc/preprocessor/scanner.ts(8,22): error TS2314: Generic type 'Map<K, V>' requires 2 type argument(s).\nsrc/preprocessor/scanner.ts(9,14): error TS2304: Cannot find name 'AnnotationSyntaxKind'.\nsrc/preprocessor/scanner.ts(10,16): error TS2304: Cannot find name 'AnnotationSyntaxKind'.\nsrc/preprocessor/scanner.ts(11,19): error TS2304: Cannot find name 'AnnotationSyntaxKind'.\nsrc/preprocessor/scanner.ts(12,22): error TS2304: Cannot find name 'AnnotationSyntaxKind'.\n```\n\nBut when I remove this line of code in scanner.ts:\n\n``` typescript\nimport ts = require(\"typescript\");\n```\n\nEverything works fine.\n\nWhat have I done wrong?\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/2135/comments",
    "author": "tinganho",
    "comments": [
      {
        "user": "danquirk",
        "created_at": "2015-02-25T19:25:10Z",
        "body": "Adding an `import` like that to scanner makes it an external module. This means everything inside it is in a new scope and the things from internal modules in other files are no longer accessible. Generally you do not want to mix internal and external modules.\n"
      },
      {
        "user": "tinganho",
        "created_at": "2015-02-25T20:58:11Z",
        "body": "@danquirk how do I achieve what I want to achieve then?\n\nI want to re-use some of the values in typescript like the enum `ts.SyntaxKind` in `scanner.ts`\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2015-02-25T23:46:48Z",
        "body": "in your external module do not add module pp, and refer to Map as pp.Map.\n"
      }
    ]
  },
  {
    "number": 2067,
    "title": "--mapRoot doesn't seem to work",
    "created_at": "2015-02-18T22:21:10Z",
    "closed_at": "2015-02-28T11:13:45Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/2067",
    "body": "`tsc --sourceMap --mapRoot maproot/ --out a.js t.ts`\n\nIt simply places the .js.map files in the same directory as the --out file.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/2067/comments",
    "author": "danihodovic",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2015-02-26T07:00:24Z",
        "body": "maproot does not place the files in a different place, it just controls the reference to the map file in the .js file. the assumption here is that you will move the map files to a different location, possibly a local directory, where as the other .js files are on your server, or a different server, etc.. it just tells the debugger where to look for the map files instead of next to the .js files.\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2015-02-27T18:33:18Z",
        "body": "correct. if you look at the javascript output, last line of your file, you will find the reference to the map file. this is what maproot controls. e.g.:\n\n``` TypeScript\n//# sourceMappingURL=rooot\\t1.js.map\n```\n"
      }
    ]
  },
  {
    "number": 1877,
    "title": "Different rules for function parameter compatibility when assignment is on a different line to variable declaration.",
    "created_at": "2015-01-31T19:06:04Z",
    "closed_at": "2015-01-31T19:21:58Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/1877",
    "body": "A function can choose to omit parameters defined in a signature, as shown by function `a` below. Callers of `a` must still supply arguments, but the function does not need to use them.\n\nDespite this, if the same function is assigned later in the program, this no longer applies and the identical function is now not compatible, as shown with function `b`.\n\n``` typescript\ninterface X {\n    (source: number): boolean;\n}\n\nvar a: X = function() { return true; }\n\nvar b: X;\n// Why is this an error?\nvar b = function() { return true; }\n```\n\nShouldn't both of these cases follow the same rules?\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/1877/comments",
    "author": "Steve-Fenton",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2015-01-31T19:21:58Z",
        "body": "This is an error because duplicate definitions of the same variable must have the _exact_ same type. This includes cases where the type of the variable is inferred from its initializer.\n\nIt's similar to if you had written\n\n``` ts\nvar x: Animal;\nvar x: Dog;\n```\n\nIf you removed the `var` keyword from the last line, you wouldn't see an error.\n"
      }
    ]
  },
  {
    "number": 1867,
    "title": "Private variables in definition files",
    "created_at": "2015-01-30T12:51:15Z",
    "closed_at": "2015-02-02T18:45:01Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/1867",
    "body": "When I produced definition files (.d.ts) for my projects, private variables of classes are also present.\n\nMost of the time, I use internal libraries that require others definition files (jquery.d.ts for example), or definition files that are not present in lib.d.ts (Promises.d.ts and TouchEvent.d.ts for example).\n\nBut as I use private variables in my classes for wich the type is only defined in these definition files, my project generated definition file contains these types.\n\nSo without publish all the other .d.ts files with my project one, it is unusable.\n\nIs there a way to manage it ? Or just remove the private variables to prevent these cases ?\n\nThanks\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/1867/comments",
    "author": "paztis",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2015-01-30T18:06:59Z",
        "body": "> But as I use private variables in my classes for wich the type is only defined in these definition files, my project generated definition file contains these types.\n\nCan you clarify? When the compiler generates a .d.ts for a class, it doesn't put type annotations on private members, so this shouldn't be a problem.\n"
      },
      {
        "user": "georgehdd",
        "created_at": "2016-04-12T05:58:26Z",
        "body": "A year later: privates are still generated in d.ts. Why are they there ? what is their added values ?\nThis forces my class to be treated as a nominal type instead of structural type.\n"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2016-04-12T17:29:03Z",
        "body": "It's absolutely necessary to have privates in generated .d.ts files. Otherwise you could derive from that class, declare a private of your own with the same name, and unknowingly stomp on your base class's private variable value. That failure mode would be very, very difficult to debug.\n"
      }
    ]
  },
  {
    "number": 1763,
    "title": "Not generating output for exported const enum makes the enum useless from regular JavaScript",
    "created_at": "2015-01-21T20:56:39Z",
    "closed_at": "2015-01-21T22:08:23Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/1763",
    "body": "Currently, no JavaScript is generated for const enum declarations (the language spec does not seem to address const enums).\n\nIs there a way to get the benefit of aggressive compile-time enum evaluation while still generating the JS enum object?\n\nIt would be nice if the computed values in the example below would be computed at compile-time like is done for const enum, but retain the generated JS so that the enum can be used from non-typescript applications:\n\n``` typescript\nexport enum Things {\n    ThingA = 0x1,\n    ThingB = 0x2,\n    ThingC = 0x4,\n    Mask = ThingA | ThingB | ThingC,\n}\n```\n\nDesired output:\n\n``` javascript\nvar Things;\n(function (Things) {\n    Things[Things[\"ThingA\"] = 1] = \"ThingA\";\n    Things[Things[\"ThingB\"] = 2] = \"ThingB\";\n    Things[Things[\"ThingC\"] = 4] = \"ThingC\";\n    Things[Things[\"Mask\"] = 7] = \"Mask\";\n})(Things || (Things = {}));\n```\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/1763/comments",
    "author": "sccolbert",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2015-01-21T21:29:44Z",
        "body": "The `--preserveConstEnums` flag does exactly this.\n"
      }
    ]
  },
  {
    "number": 1739,
    "title": "how to uninstall 1.4",
    "created_at": "2015-01-20T10:33:48Z",
    "closed_at": "2015-01-20T19:48:05Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/1739",
    "body": "",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/1739/comments",
    "author": "v-vairam",
    "comments": [
      {
        "user": "DavidRigglemanININ",
        "created_at": "2015-01-20T16:05:21Z",
        "body": "I may be able to provide some help here since I had to do the same thing after encountering a bug in 1.4 that forced me to uninstall that version. You can uninstall version 1.4 from the Remove Programs functionality in the Control Panel. In my case, I then also had to right click on version 1.3 in the Control Panel, click Modify, and then select Repair in order to restore TypeScript integration back into Visual Studio for 1.3\n"
      },
      {
        "user": "danquirk",
        "created_at": "2015-01-20T19:48:05Z",
        "body": "As mentioned, if you've installed it on VS2013 then there should be a normal Add/Remove Programs entry you can uninstall it from. \n"
      }
    ]
  },
  {
    "number": 1565,
    "title": "Null calling pre-compile check",
    "created_at": "2014-12-26T18:06:20Z",
    "closed_at": "2014-12-27T13:25:23Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/1565",
    "body": "Hi. I'm working on a bit bigger project that is fully driven by TS, and I noticed that compiler doesn't check if variables that have as type object, are filled with instances anywhere. I didn't realize that so now my project is full of variables that were never initialized. So I thought that this would help a lot, and it isn't that hard to check. But I'm a horrible JS programmer. I hate even look at JS. So... just an idea. \n\nThanks for reading.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/1565/comments",
    "author": "ghost",
    "comments": [
      {
        "user": "DanielRosenwasser",
        "created_at": "2014-12-27T05:37:44Z",
        "body": "Have you looked into our `--noImplicitAny` flag?\n\nWhen an assignable entity has no context for which it can infer a type (either by initialization, or an explicit type annotation), our type system automatically infers the type (or types of its constituents) to be `any`.\n\nFor instance, our compiler would error (but still emit) on all of the following with `--noImplicitAny`:\n\n``` TypeScript\nvar a;                 // type: any\nvar b = null;          // type: any\nvar c = undefined;     // type: any\nvar d = [];            // type: any[]\nvar e = [[null]];      // type: any[][]\n```\n"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2014-12-27T13:25:23Z",
        "body": "No problem. If that's not _actually_ helping you could simply use a regular expression on your codebase to see if you're not initializing a variable on declaration.\n\n```\nvar [^=]+$\n```\n\nThough, with this, you'll have to check instance members in classes separately.\n"
      }
    ]
  },
  {
    "number": 1487,
    "title": "Tuple type checking",
    "created_at": "2014-12-15T14:33:18Z",
    "closed_at": "2014-12-18T01:47:15Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/1487",
    "body": "I haven't had the time to investigate yet, but was surprised to see the following compile without error with tsc.exe shipped in the VS extension v1.3:\n    var testingzetuple: [number, string] = [1, \"world\", \"foreva\"];\nor\n    var testingzetuple: [number, number] = [1, 2, 3];\nIs that the expected behaviour? Shouldn't tuple type [t1,...,tn] be limited to size n?\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/1487/comments",
    "author": "codespare",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2014-12-17T18:53:07Z",
        "body": "By the substitution principle, a longer tuple is a subtype of a shorter tuple (assuming their first _n_ elements are the same).\n"
      }
    ]
  },
  {
    "number": 1481,
    "title": "Can an optional and required field of merged interfaces yield a required field?",
    "created_at": "2014-12-14T19:09:06Z",
    "closed_at": "2015-06-12T18:35:20Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/1481",
    "body": "I have this case from using the mongoose library, in which my domain object, A, might have a DB _id, but the mongoose.Document always has an _id.\nI use type A when not in the mongoose portions of the app, and type ADocument only within those parts that deal directly with mongoose.  Note that mongoose defines Document to contain _id like this:\n\n```\ninterface Document {\n    _id: string;\n}\n```\n\nI tried to model the A - ADocument relationship like this:\n\n```\ninterface A {\n    _id?: string;\n}\ninterface ADoc extends A, mongoose.Document {   \n}\n```\n\nbut I get this error:\n_Interface 'ADoc' cannot simultaneously extend types 'A' and 'Document':\n Named properties '_id' of types 'A' and 'Document' are not identical._\n\nI can get around this error by making _id be either optional in both definitions, or required in both.\n\nI expect that the compiler can infer that _id is now required in ADoc. \nIs the current behavior of issuing an error the correct behavior? \nIf so, does it make sense to merge such fields so they become required?\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/1481/comments",
    "author": "psnider",
    "comments": [
      {
        "user": "DanielRosenwasser",
        "created_at": "2014-12-14T20:32:57Z",
        "body": "Hm, I'm not sure about the actual semantics as per the spec behind this (a little hard for me to access it), but if you explicitly declare `_id` in `ADoc`, you should be able to get rid of this error.\n\n``` TypeScript\ninterface Document {\n    _id: string;\n}\n\ninterface A {\n    _id?: string;\n}\n\ninterface ADoc extends A, Document {\n    _id: string;\n}\n```\n"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2014-12-15T03:36:13Z",
        "body": "The spec addresses this in section 7.1:\n\n> The following constraints must be satisfied by an interface declaration or otherwise a compile-time error occurs:\n> - [...]\n> - Inherited properties with the same name must be identical (section 3.8.2).\n\nThe relevant definition of \"identical member\" at 3.8.2 is:\n\n> Two members are considered identical when\n> - they are public properties with identical names, **optionality**, and types,\n\nIn general we only ever merge properties when they are completely identical.\n"
      },
      {
        "user": "Igorbek",
        "created_at": "2014-12-15T23:47:23Z",
        "body": "@RyanCavanaugh so how does having merging field in target interface fix the error? Does it only check convertibility to interfaces extended from?\n"
      },
      {
        "user": "danquirk",
        "created_at": "2015-01-06T02:55:56Z",
        "body": "@Igorbek You've now overridden the declarations from the inherited members. The compiler then checks that with the overridden declaration ADoc is a subtype of A and a subtype of Document.\n"
      }
    ]
  },
  {
    "number": 1023,
    "title": "How to append method to Array.prototype with .d.ts",
    "created_at": "2014-11-01T07:07:15Z",
    "closed_at": "2014-11-01T08:46:48Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/1023",
    "body": "I need to append a method to Array.prototype such as  \n\n```\nArray.prototype.first = function(){\n    //blablabla\n}\n\n```\n\nHow to write this `.d.ts` file .\n\nThanks all \n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/1023/comments",
    "author": "WanderWang",
    "comments": [
      {
        "user": "DanielRosenwasser",
        "created_at": "2014-11-01T08:46:48Z",
        "body": "Hi there @WanderWang, it's just:\n\n``` TypeScript\ninterface Array<T> {\n    first(): T;\n}\n```\n\nThe declarations for `Array<T>` will merge.\n\nNote that in the future, questions relating to achieving tasks in TypeScript should be asked on sites such as StackOverflow, whereas our issue tracker is not the appropriate place to ask such questions.\n"
      }
    ]
  },
  {
    "number": 958,
    "title": "Support prototype extension of built-in types",
    "created_at": "2014-10-24T21:48:08Z",
    "closed_at": "2014-10-24T23:24:37Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/958",
    "body": "I can extend the `String` interface like so:\n\n``` ts\ninterface String {\n  upper(): String;\n}\n```\n\nI would expect that I could then do:\n\n``` ts\nString.prototype.upper = String.prototype.toUpperCase;\n```\n\nOr:\n\n``` ts\nString.prototype.upper = String.prototype.upper || function() {\n  return this.toUpperCase();\n};\n```\n\nOr even this:\n\n``` ts\nvar foo: String = 'bar'; // Type 'String' is missing property 'upper' from type 'String'.\n```\n\nIt would be nice if the `string` keyword would, of course, accommodate this change as well.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/958/comments",
    "author": "jednano",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2014-10-24T22:04:22Z",
        "body": "All the code you wrote compiles without error.\n\nDid you write `interface String {` inside a module (internal or external)? That would declare a new type instead of extending the existing one.\n"
      }
    ]
  },
  {
    "number": 423,
    "title": "Usage of void type ",
    "created_at": "2014-08-11T12:05:01Z",
    "closed_at": "2014-08-11T19:17:04Z",
    "labels": [
      "By Design",
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/423",
    "body": "Why this is allowed ?\n\n``` typescript\ninterface A<T> {\n f(x:number,a: T);\n}\n\n<A<void>>(null).f(1); \n```\n\nWhile calling the function via variable not ?\n\n``` typescript\nvar a = <A<void>>(null);\na.f(1);\n```\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/423/comments",
    "author": "NN---",
    "comments": [
      {
        "user": "basarat",
        "created_at": "2014-08-11T12:10:36Z",
        "body": "> While calling the function via variable not ?\n\nIts not about the variable. Your assertion needs brackets (note no variable): \n\n``` ts\ninterface A<T> {\n f(x:number,a: T);\n}\n\n(<A<void>>(null)).f(1);  // Error\n```\n"
      },
      {
        "user": "NN---",
        "created_at": "2014-08-11T12:30:09Z",
        "body": "I see.\nIt means it is impossible to use 'void' here and call a function without passing 'undefined' argument explicitly. \n"
      },
      {
        "user": "basarat",
        "created_at": "2014-08-11T12:32:50Z",
        "body": "> It means it is impossible to use 'void' here and call a function without passing 'undefined' argument explicitly\n\nyes.\n\nIf you want to prevent `T` being `void` you can use `extends` e.g. \n\n``` ts\ninterface A<T extends Object> {\n f(x:number,a: T);\n}\n\n(<A<void>>(null)) // error \n```\n"
      }
    ]
  },
  {
    "number": 54956,
    "title": "'Convert named export to default export' removes type-information",
    "created_at": "2023-06-29T15:00:14Z",
    "closed_at": "2023-10-08T13:23:40Z",
    "labels": [
      "Bug",
      "Help Wanted"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/54956",
    "body": "Type: <b>Bug</b>\r\n\r\n1. select a  type annotated named export in a tsx file   \r\n1. hit `ctrl+.`\r\n1. select 'Convert named export to default export' \r\n1. observe how your type info is discarded \r\n\r\nbefore:\r\n```tsx \r\nexport const LabelList: React.FC<{ labelIds: number[] }> = ({ labelIds }) => {\r\n  const labels = useSelector<Types.RootState, LabelsState>(\r\n    ({ labels }) => labels,\r\n  );\r\n  return (\r\n    <div>\r\n      {labelIds.length ? (\r\n        labelIds.map(l => labels![l]).map(l => <LabelToken label={l} />)\r\n      ) : (\r\n        <small className={styles.noDescription}>No labels</small>\r\n      )}\r\n    </div>\r\n  );\r\n};\r\n```\r\n\r\nafter:\r\n```tsx\r\nexport default ({ labelIds }) => {\r\n  const labels = useSelector<Types.RootState, LabelsState>(\r\n    ({ labels }) => labels,\r\n  );\r\n\r\n  return (\r\n    <div>\r\n      {labelIds.length ? (\r\n        labelIds.map(l => labels![l]).map(l => <LabelToken label={l} />)\r\n      ) : (\r\n        <small className={styles.noDescription}>No labels</small>\r\n      )}\r\n    </div>\r\n  );\r\n};\r\n```\r\n \r\ninlining the type-annotations in a default export may not be possible (im not sure), but an intemediate variable can be exported as a default  \r\n\r\nVS Code version: Code 1.79.2 (695af097c7bd098fbf017ce3ac85e09bbc5dda06, 2023-06-14T08:59:55.818Z)\r\nOS version: Linux x64 6.2.6-76060206-generic\r\nModes:\r\n\r\n<details>\r\n<summary>System Info</summary>\r\n\r\n|Item|Value|\r\n|---|---|\r\n|CPUs|AMD Ryzen 7 5800U with Radeon Graphics (16 x 3547)|\r\n|GPU Status|2d_canvas: enabled<br>canvas_oop_rasterization: disabled_off<br>direct_rendering_display_compositor: disabled_off_ok<br>gpu_compositing: enabled<br>multiple_raster_threads: enabled_on<br>opengl: enabled_on<br>rasterization: enabled<br>raw_draw: disabled_off_ok<br>video_decode: enabled<br>video_encode: disabled_software<br>vulkan: disabled_off<br>webgl: enabled<br>webgl2: enabled<br>webgpu: disabled_off|\r\n|Load (avg)|2, 1, 1|\r\n|Memory (System)|13.49GB (1.87GB free)|\r\n|Process Argv|--unity-launch --crash-reporter-id f14012b5-d0f7-448a-910a-706fee85982f|\r\n|Screen Reader|no|\r\n|VM|0%|\r\n|DESKTOP_SESSION|pop|\r\n|XDG_CURRENT_DESKTOP|Unity|\r\n|XDG_SESSION_DESKTOP|pop|\r\n|XDG_SESSION_TYPE|x11|\r\n</details><details><summary>Extensions (46)</summary>\r\n\r\nExtension|Author (truncated)|Version\r\n---|---|---\r\njest-snippets|and|1.9.1\r\nvscode-zipfs|arc|3.0.0\r\nvscode-toggle-quotes|Bri|0.3.6\r\nvscode-eslint|dba|2.4.2\r\nes7-react-js-snippets|dsz|4.4.3\r\nprettier-vscode|esb|9.16.0\r\ncode-runner|for|0.12.0\r\nshell-format|fox|7.2.5\r\ngitlab-workflow|Git|3.68.0\r\neasy-snippet|inu|0.6.3\r\nplantuml|jeb|2.17.5\r\nbetter-shellscript-syntax|jef|1.6.1\r\nbash-ide-vscode|mad|1.37.0\r\ndirenv|mkh|0.14.0\r\nvscode-docker|ms-|1.25.1\r\nisort|ms-|2022.8.0\r\npython|ms-|2023.10.1\r\nvscode-pylance|ms-|2023.6.40\r\njupyter|ms-|2023.5.1101742258\r\njupyter-keymap|ms-|1.1.2\r\njupyter-renderers|ms-|1.0.15\r\nvscode-jupyter-cell-tags|ms-|0.1.8\r\nvscode-jupyter-slideshow|ms-|0.1.5\r\nremote-containers|ms-|0.295.0\r\nremote-ssh|ms-|0.102.0\r\nremote-ssh-edit|ms-|0.86.0\r\nremote-explorer|ms-|0.4.0\r\nsqltools|mtx|0.28.0\r\nvscode-jest|Ort|5.2.3\r\nvscode-versionlens|pfl|1.5.0\r\nbash-extension-pack|pin|2.0.0\r\nvscode-react-refactor|pla|1.1.3\r\nansible|red|2.4.78\r\nvscode-yaml|red|1.13.0\r\nvscode-gitweblinks|red|2.9.2\r\nbash-debug|rog|0.3.9\r\nshebang-snippets|rpi|0.1.4\r\njs-snippets|run|0.2.6\r\nrust-analyzer|rus|0.3.1566\r\nvscode-taskexplorer|spm|2.13.2\r\nshellcheck|tim|0.32.6\r\njinja|who|0.0.8\r\nchange-case|wma|1.0.0\r\nJavaScriptSnippets|xab|1.8.0\r\ncursor-align|yo1|1.1.0\r\nmarkdown-pdf|yza|1.4.4\r\n\r\n\r\n</details><details>\r\n<summary>A/B Experiments</summary>\r\n\r\n```\r\nvsliv368:30146709\r\nvsreu685:30147344\r\npython383:30185418\r\nvspor879:30202332\r\nvspor708:30202333\r\nvspor363:30204092\r\nvslsvsres303:30308271\r\nvserr242cf:30382550\r\npythontb:30283811\r\nvsjup518:30340749\r\npythonptprofiler:30281270\r\nvshan820:30294714\r\nvstes263:30335439\r\nvscod805:30301674\r\nbinariesv615:30325510\r\nbridge0708:30335490\r\nbridge0723:30353136\r\nvsaa593:30376534\r\npythonvs932:30410667\r\npy29gd2263:30776702\r\nvsclangdc:30486549\r\nc4g48928:30535728\r\ndsvsc012:30540252\r\npynewext54:30695312\r\nazure-dev_surveyone:30548225\r\nvscccc:30610679\r\n3biah626:30602489\r\npyind779:30671433\r\n89544117:30613380\r\npythonsymbol12:30671437\r\n2i9eh265:30646982\r\nshowlangstatbar:30737416\r\nvsctsb:30748421\r\npythonms35:30701012\r\n03d35959:30757346\r\n57b77579:30736110\r\npythonfmttext:30731395\r\npythoncmv:30756943\r\nfixshowwlkth:30771522\r\npythongtdpath:30769146\r\ni26e3531:30769768\r\ndh2dc718:30776458\r\npythonidxpt:30772539\r\npythondjangotscf:30772537\r\npythonnoceb:30776495\r\n\r\n```\r\n\r\n</details>\r\n\r\n<!-- generated by issue reporter -->",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/54956/comments",
    "author": "midgethoen",
    "comments": [
      {
        "user": "awareness481",
        "created_at": "2023-10-07T09:58:04Z",
        "body": "I think this has been fixed, using the refactor test for the following code\r\n\r\n```ts\r\ntype A = any;\r\n\r\nexport const LabelList: A = () => {};\r\n```\r\n\r\nresults in\r\n\r\n```ts\r\ntype A = any;\r\n\r\nconst LabelList: A = () => {};\r\nexport default LabelList;\r\n```\r\n\r\nThe code from OP also seems to be formatted correctly."
      }
    ]
  },
  {
    "number": 30398,
    "title": "Can't exponentiate BigInts",
    "created_at": "2019-03-14T15:50:10Z",
    "closed_at": "2020-05-04T17:14:49Z",
    "labels": [
      "Bug",
      "Help Wanted",
      "Good First Issue",
      "ES2017"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/30398",
    "body": "In normal JavaScript, this works `BigInt(2) ** BigInt(2)`\r\n\r\nBut writing the above in TypeScript, compiles to `Math.pow(BigInt(2), BigInt(2))`, which doesn't work.\r\n\r\nAccording to MDN:\r\n\r\n> [BigInt] cannot be used with methods in the built-in Math object\r\n\r\n---\r\n\r\nTypeScript code\r\n\r\n```ts\r\nBigInt(2) ** BigInt(2)\r\n```\r\n\r\n**Expected behavior:**\r\nReturn 4.\r\n\r\n**Actual behavior:**\r\n\r\n```\r\nTypeError: Cannot convert a BigInt value to a number\r\n    at Math.pow (<anonymous>)\r\n```",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/30398/comments",
    "author": "msafi",
    "comments": [
      {
        "user": "ajafff",
        "created_at": "2019-03-14T17:36:39Z",
        "body": "Why is this an issue? Environments that support BigInt also know the exponentiation operator.\r\nTherefore you don't need to downlevel your code. The only target that makes sense for BigInt is ESnext.\r\nIIRC there's even a compile error if you use BigInt with a different target."
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2019-03-14T22:53:08Z",
        "body": "Technically I guess we could give an error when using `bigint`s in exponentiation expressions when targeting anything earlier than ES2017."
      },
      {
        "user": "santoshyadavdev",
        "created_at": "2019-03-25T17:51:25Z",
        "body": "Hi @DanielRosenwasser ,\r\n\r\nWhen we target es5 , we are getting \"error TS2304: Cannot find name 'BigInt'.\", if we change the error code to TS2737 which stands for \"BigInt literals are not available when targeting lower than ESNext.\" it will fix the issue, let me know if we can change."
      },
      {
        "user": "JoshuaKGoldberg",
        "created_at": "2019-09-11T11:36:45Z",
        "body": "This looks like it was separately already solved. With this file:\r\n\r\n```ts\r\n3 ** 4n;\r\nBigInt(2) ** BigInt(2);\r\n```\r\n\r\nTargeting `es5`, you get these errors:\r\n\r\n```\r\nindex.ts:1:1 - error TS2365: Operator '**' cannot be applied to types '3' and '4n'.\r\n\r\n1 3 ** 4n;\r\n  ~~~~~~~\r\n\r\nindex.ts:1:6 - error TS2737: BigInt literals are not available when targeting lower than ESNext.\r\n\r\n1 3 ** 4n;\r\n       ~~\r\n\r\nindex.ts:2:1 - error TS2304: Cannot find name 'BigInt'.\r\n\r\n2 BigInt(2) ** BigInt(2);\r\n  ~~~~~~\r\n\r\nindex.ts:2:14 - error TS2304: Cannot find name 'BigInt'.\r\n\r\n2 BigInt(2) ** BigInt(2);\r\n               ~~~~~~\r\n```"
      }
    ]
  },
  {
    "number": 30037,
    "title": "Poor error messages for properties mis-handled as shorthand property declarations",
    "created_at": "2019-02-22T02:01:00Z",
    "closed_at": "2019-04-22T20:14:22Z",
    "labels": [
      "Suggestion",
      "Fixed",
      "Help Wanted",
      "Good First Issue",
      "Domain: Error Messages",
      "Experience Enhancement"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/30037",
    "body": "```ts\r\ndeclare function foo(option: { abcd: number }): void;\r\n\r\nfoo({\r\n    abcd\r\n})\r\n```\r\n\r\n**Today**\r\n\r\n```\r\nCannot find name 'abcd'.\r\n```\r\n\r\n*Ideal**\r\n\r\n```\r\nThis shorthand property declaration is invalid because a local declaration could not be found for 'abcd'. Either declare one or provide an initializer.\r\n```",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/30037/comments",
    "author": "DanielRosenwasser",
    "comments": [
      {
        "user": "DanielRosenwasser",
        "created_at": "2019-02-22T08:56:36Z",
        "body": "Go for it! Messages in `diagnosticMessages.json`, `gulp generate-diagnostics` creates a new entry in the `Diagnostics` map, and you can specialize the message in `checker.ts`.\r\n\r\n`gulp runtests-parallel` and `gulp baseline-accept` will update the baselines."
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2019-04-19T00:42:53Z",
        "body": "Better message:\r\n\r\n```\r\nNo value exists in scope for the shorthand property '{0}'. Either declare one or provide an initializer.\r\n```"
      }
    ]
  },
  {
    "number": 28086,
    "title": "--downlevelIteration errors should mention using later targets",
    "created_at": "2018-10-23T19:37:43Z",
    "closed_at": "2019-01-15T22:06:58Z",
    "labels": [
      "Fixed",
      "Help Wanted",
      "Good First Issue",
      "Domain: Error Messages",
      "Experience Enhancement"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/28086",
    "body": "```js\r\n// @ts-check\r\nclass Foo {\r\n  constructor(...args) {}\r\n}\r\nfunction makeFoo() {\r\n  return new Foo(...arguments)\r\n}\r\n```\r\n\r\n**Actual**\r\n\r\n> Type 'IArguments' is not an array type. Use compiler option '--downlevelIteration' to allow iterating of iterators.\r\n\r\n**Expected**\r\n\r\n> Type 'IArguments' is not an array type. Either use the '--downlevelIteration' compiler option to allow iterating on iterators, or set the '--target' option to 'es2015' or above.",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/28086/comments",
    "author": "DanielRosenwasser",
    "comments": [
      {
        "user": "DanielRosenwasser",
        "created_at": "2018-10-24T08:14:02Z",
        "body": "Go for it - update `diagnosticMessages.json`, run the test suite, accept the baselines, and send us a PR."
      }
    ]
  },
  {
    "number": 19761,
    "title": "Class 'AnotherProductService' incorrectly implements interface 'ProductService'.",
    "created_at": "2017-11-06T09:58:29Z",
    "closed_at": "2017-11-07T02:54:00Z",
    "labels": [
      "Suggestion",
      "Help Wanted",
      "Domain: Error Messages"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/19761",
    "body": "I create a project with angular/cli , when I try used service, I get an error.\r\n-----\r\n\r\n**TypeScript Version:**  2.4.2\r\n**Angular CLI Version:** 1.5.0\r\n**NPM Version:** 5.0.3\r\n**Node.js Version:**  8.1.0\r\n**OS Version:**  Winwods 10 Professional Edition x64\r\n---------\r\n**Code**\r\n\r\n```ts\r\nimport { Injectable } from '@angular/core';\r\nimport { LoggerService } from './logger.service';\r\n\r\n\r\n@Injectable()\r\nexport class ProductService {\r\n\r\n  constructor(private logger: LoggerService) { }\r\n\r\n  getProduct(): Product {\r\n    this.logger.log('getProduct function');\r\n    return new Product(0, 'iphone7', 5899, 'apple phone');\r\n  }\r\n}\r\n\r\nexport class Product {\r\n\r\n  constructor(\r\n    public id: number,\r\n    public title: string,\r\n    public price: number,\r\n    public desc: string\r\n  ) {\r\n\r\n  }\r\n}\r\n```\r\n-------------\r\n```ts\r\nimport { Injectable } from '@angular/core';\r\nimport { Product, ProductService } from './product.service';\r\n\r\n@Injectable()\r\nexport class AnotherProductService implements ProductService {\r\n\r\n  getProduct(): Product {\r\n    return new Product(1, 'sunsumg7', 4899, 'sunsumg phone');\r\n  }\r\n\r\n  constructor() { }\r\n\r\n}\r\n```\r\n------------\r\n```ts\r\nimport { Injectable } from '@angular/core';\r\n\r\n@Injectable()\r\nexport class LoggerService {\r\n\r\n  constructor() { }\r\n\r\n  log(message: string) {\r\n    console.log(message);\r\n  }\r\n\r\n}\r\n```\r\n----------------\r\n```ts\r\nimport { BrowserModule } from '@angular/platform-browser';\r\nimport { NgModule } from '@angular/core';\r\n\r\nimport { AppComponent } from './app.component';\r\nimport { Product1Component } from './product1/product1.component';\r\nimport { ProductService } from './shared/product.service';\r\nimport { Product2Component } from './product2/product2.component';\r\nimport { LoggerService } from './shared/logger.service';\r\n\r\n@NgModule({\r\n  declarations: [\r\n    AppComponent,\r\n    Product1Component,\r\n    Product2Component\r\n  ],\r\n  imports: [\r\n    BrowserModule\r\n  ],\r\n  providers: [ProductService, LoggerService],\r\n  bootstrap: [AppComponent]\r\n})\r\nexport class AppModule { }\r\n```\r\n------\r\n\r\n**Expected behavior:**\r\n- If it is work, the Product where be get and show on the html.\r\n--------------\r\n\r\n**Actual behavior:**\r\n- I get an error.\r\n```\r\nERROR in src/app/shared/another-product.service.ts(5,14): error TS2420: Class 'AnotherProductService' incorrectly implements interface 'ProductService'.Property 'logger' is missing in type 'AnotherProductService'.\r\n\r\n```",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/19761/comments",
    "author": "dingziyang",
    "comments": [
      {
        "user": "ghost",
        "created_at": "2017-11-06T15:24:11Z",
        "body": "You probably meant `extends` instead of `implements`.\r\nYou can never `implement` a class with private members, so we should probably improve the error message here."
      },
      {
        "user": "dingziyang",
        "created_at": "2017-11-07T01:47:08Z",
        "body": "@andy-ms I understand what you main. Everything in interface must be public. \r\nBut, I'm sure I use implements here. Because I downloaded a study video, the teacher is doing this and it's worked. He also used Angular4 and TypeScript. \r\n**Oh! It drives me crazy!**"
      },
      {
        "user": "ghost",
        "created_at": "2017-11-07T02:08:33Z",
        "body": "It is possible to \"implement\" a class -- but it means treating the class as an interface, so you'll have to create an implementation of every one of its members.\r\nHowever, if the class you're implementing has a private member, it's impossible to implement.\r\n```ts\r\nclass A {\r\n\tprivate x: number;\r\n}\r\n// Error: Types have separate declarations of a private property 'x'.\r\nclass B implements A {\r\n\tprivate x: number;\r\n}\r\n```\r\n\r\nIt's correct that we give you this error message, because if `B implements A`, you would expect to be able to assign a `B` to an `A`, but you can't assign anything to a class with a private member unless it's derived from that class via `extends`. So the error message should just tell you that instead of telling you to implement a property that you can't possibly implement.\r\n\r\nIn your case, if you really don't intend to use `extends`, you must define an interface and have both classes implement that."
      }
    ]
  },
  {
    "number": 11205,
    "title": "Union Type made of two types of arrays fails to provide all array's methods",
    "created_at": "2016-09-28T09:05:56Z",
    "closed_at": "2016-12-30T22:28:16Z",
    "labels": [
      "Bug",
      "Fixed",
      "Help Wanted",
      "Domain: lib.d.ts"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/11205",
    "body": "**TypeScript Version:**  1.8.0 / TypeScript playground\n\n**Code**\n\n``` ts\nlet x1: number[];\nlet x2: number[][];\nx1.splice(1, 1); // OK\nx2.splice(1, 1); // OK\nlet x: number[] | number[][];\nx.splice(1, 1); // Error: Supplied parameters do not match any signature of call target.\n```\n\n**Expected behavior:**\nTS tutorial states: \n\n>  If we have a value that has a union type, we can only access members that are common to all types in the union.\n\nSince both `x1: number[];` and `x2: number[][]` have `splice` method with two params, I expect the union of these two types also to have this method.\n\n**Actual behavior:** \nCompiler reports an error:  Supplied parameters do not match any signature of call target. However, it allows using another overload of `splice` function:\n\n``` ts\nlet x: number[] | number[][];\nx.splice(1); // OK\n```\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/11205/comments",
    "author": "OleksandrNechai",
    "comments": [
      {
        "user": "kitsonk",
        "created_at": "2016-09-28T09:54:10Z",
        "body": "Yes, essentially it is the same, the subtle difference is that when matching the signature, it is matching one that it cannot union the overload:\n\n``` typescript\ninterface Array<T> {\n    splice(start: number): T[];\n    splice(start: number, deleteCount: number, ...items: T[]): T[];\n}\n```\n\nIt cannot union the type of the `...items: T[]` argument, therefore it causes an error.  Technically if there was anther overload, the code above would work, up until the point where you added arguments that you needed to insert:\n\n``` typescript\ninterface Array<T> {\n    splice(start: number): T[];\n    splice(start: number, deleteCount: number): T[];\n    splice(start: number, deleteCount: number, ...items: T[]): T[];\n}\n```\n\nBut it is better to have `(number | number[])[]` in the first place as mentioned in the issue you referenced.\n"
      },
      {
        "user": "OleksandrNechai",
        "created_at": "2016-09-28T10:46:13Z",
        "body": "> But it is better to have  (number | number[])[]  in the first place\n\nWell, then this code does not compile:\n\n``` ts\nlet x: (string[] | number[])[]\nx.forEach(e => e.splice(1, 1)); // The same error\n```\n\nUnfortunately I have both cases in my code. Whatever way I choose to describe my types I get this error :-(.\n"
      },
      {
        "user": "kitsonk",
        "created_at": "2016-09-28T12:41:15Z",
        "body": "This will work, but I suspect this is not what you want:\n\n``` typescript\nlet x: (string | number)[][]\nx.forEach(e => e.splice(1, 1));\n```\n\nAs I suspect you want an array of array of all numbers or an array of arrays of all strings.\n\nThe other option would be to help TypeScript along:\n\n``` typescript\nlet x: (string[] | number[])[];\nx.forEach((e: any[]) => e.splice(1, 1));\n```\n"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2016-09-28T16:38:37Z",
        "body": "I think we should rewrite the signatures to be\n\n```\ninterface Array<T> {\n    splice(start: number, deleteCount?: number): T[];\n    splice(start: number, deleteCount: number, ...items: T[]): T[];\n}\n```\n\nwith the observation that generic types should have signatures split according to their input use of their type parameters\n"
      }
    ]
  },
  {
    "number": 10699,
    "title": "Fix PromiseConstructor interface",
    "created_at": "2016-09-04T08:34:43Z",
    "closed_at": "2019-10-01T20:45:40Z",
    "labels": [
      "Bug",
      "Help Wanted",
      "Domain: lib.d.ts"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/10699",
    "body": "**TypeScript Version:**  master\n\n``` diff\ninterface PromiseConstructor {\n-    reject(reason: any): Promise<never>;\n-    reject<T>(reason: any): Promise<T>;\n+    reject(reason?: any): Promise<never>;\n}\n```\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/10699/comments",
    "author": "falsandtru",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2016-09-06T19:40:02Z",
        "body": "The second overload is handy for casts. it does not get picked up aromatically, it is only used if someone passes an explicit type argument. so i would keep that. \n\nchanging the argument to be optional seems correct. a PR would be appreciated.\n"
      },
      {
        "user": "falsandtru",
        "created_at": "2016-09-06T21:13:59Z",
        "body": "`Promise.reject` never changes the contextual type of Promise. So I think the fix your thoughts would be this. However, it is buggy. Anyone cannot trust a `reason` parameter type. Do you really need that?\n\n``` diff\ninterface PromiseConstructor {\n-    reject(reason: any): Promise<never>;\n-    reject<T>(reason: any): Promise<T>;\n+    reject(reason?: any): Promise<never>;\n+    reject<T>(reason: T): Promise<never>;\n}\n```\n\nAdd:\n\nCould you accept the following fix?\n\n``` diff\ninterface PromiseConstructor {\n-    new <T>(executor: (resolve: (value?: T | PromiseLike<T>) => void, reject: (reason?: any) => void) => void): Promise<T>;\n+    new <T>(executor: (resolve: (value: T | PromiseLike<T>) => void, reject: (reason?: any) => void) => void): Promise<T>;\n}\n```\n\nfor the current strict typings of `Promise.resolve`.\n\n``` ts\n    resolve<T>(value: T | PromiseLike<T>): Promise<T>;\n    resolve(): Promise<void>;\n```\n"
      },
      {
        "user": "kitsonk",
        "created_at": "2016-09-06T21:47:07Z",
        "body": "The cast is useful if you had something like this:\n\n``` typescript\nfunction looksLikeAsync(): Promise<string> {\n    if (someCondition) {\n        return Promise.resolve('foo');\n    }\n    else {\n        return Promise.reject<string>(new Error('I hate kittens'));\n    }\n}\n\nlooksLikeAsync()\n    .then((str) => { /* do something */ }, (err) => { /* handle error */ });\n```\n\nPreviously though `Promise<void>` was not assignable to `Promise<string>` but `Promise<never>` is always assignable to `Promise<string>`, though I suspect changing the typing and taking away the generic would break other peoples code who previously had to cast before `never` was a thing.\n"
      },
      {
        "user": "kitsonk",
        "created_at": "2016-09-06T22:10:12Z",
        "body": "> I believe its typing is verbose.\n\nBut it is the only way to accomplish the use case I provided.  There are other ways to cast, but I am fairly certain people have relied upon that and would be a breaking change.  Breaking other people's code for your personal sense of verbosity is cruel when it has no direct impact on your code or usage of TypeScript.\n"
      },
      {
        "user": "falsandtru",
        "created_at": "2016-09-06T23:19:02Z",
        "body": "For example, the following case returns the unexpected type. This is very bad.\n\n``` ts\n// An expected return type is Promise<void>, actually it returns Promise<string | void>\nfunction f() {\n  return Promise.resolve()\n    .then(() => Promise.resolve(), () => Promise.reject<string>(''));\n}\n```\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2016-09-06T23:24:21Z",
        "body": "you wrote `<string>`. not sure what you expected, and not sure what the compiler could have done to save you from your self, you could as easily write `<string>Promise.reject('')`\n"
      },
      {
        "user": "falsandtru",
        "created_at": "2016-09-06T23:33:03Z",
        "body": "`<string>Promise.reject('')` is not compilable. Can you provide the case your thoughts?\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2016-09-06T23:43:24Z",
        "body": "sorry, meant `Promise<string>`. so:\n\n``` ts\nfunction f() {\n    return Promise.resolve()\n        .then(() => Promise.resolve(), () => <Promise<string>>Promise.reject(''));\n}\n```\n\nis basically the same as:\n\n``` ts\n// An expected return type is Promise<void>, actually it returns Promise<string | void>\nfunction f() {\n  return Promise.resolve()\n    .then(() => Promise.resolve(), () => Promise.reject<string>(''));\n}\n```\n\nexcept that the later is easier to write and nicer to read.\n"
      },
      {
        "user": "falsandtru",
        "created_at": "2016-09-06T23:56:39Z",
        "body": "Why you make `Promise<string | void>`? Its type is wrong. I think TypeScript shouldn't provide the such way to make incorrect types. So `Promise.reject` should always return `Promise<never>` to make a correct type.\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2016-09-07T00:05:09Z",
        "body": "that is what `Promise.reject(value)` returns.\n\nif some one chose to pass an explicit type argument, e.g. `Promise.reject<any>(value)` i do not see why we should stop them. again this is identical to `<Promise<any>> Promise.reject(value)`, just easier to write.\n"
      },
      {
        "user": "falsandtru",
        "created_at": "2016-09-07T01:48:14Z",
        "body": "`<Promise<number>>Promise.reject(0)` and `<Promise<number>>Promise.resolve(0)` have different effects, but they have a same type. `<Promise<number>>Promise.reject(0)` never make `Promise<number>` by themselves.\n\n``` ts\nPromise.reject<string>(0)\n  .catch(() => <Promise<number>>Promise.resolve(0))\n  .then(n => console.log(n)); // 0\n\nPromise.reject<string>(0)\n  .catch(() => <Promise<number>>Promise.reject(0))\n  .then(n => console.log(n)); // Uncaught (in promise) 0\n```\n\nSo actually, your type casting means `<Promise<number>><Promise<never>>Promise.reject(0)`. So the minimum type of `Promise.reject(0)` is `Promise<never>`, `<Promise<number>>` is verbose and has no reason in that case. Signatures should defined by minimum types.\n\nWhy you need to make `Promise<T>` type by `Promise.reject<T>(reason: any)` even though `Promise<never>` can assign any other `Promise<T>`? And, why you need to hide that difference of effects? `Promise<never>` would help to know the actual behavior (effect). Standard definitions should help that standard understanding.\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2016-09-09T22:41:45Z",
        "body": "just to be clear, this bug is for marking the parameter as optional. removing the overload is not desired.\n"
      }
    ]
  },
  {
    "number": 8742,
    "title": "tsc truncates type errors longer than 100 chars with triple-dots",
    "created_at": "2016-05-22T20:18:05Z",
    "closed_at": "2017-10-02T11:59:53Z",
    "labels": [
      "Suggestion",
      "Help Wanted"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/8742",
    "body": "I'd like to see the entire error message.\n\nIn `tsc.js`:\n\n```\n        function typeToString(type, enclosingDeclaration, flags) {\n            var writer = ts.getSingleLineStringWriter();\n            getSymbolDisplayBuilder().buildTypeDisplay(type, writer, enclosingDeclaration, flags);\n            var result = writer.string();\n            ts.releaseStringWriter(writer);\n            var maxLength = compilerOptions.noErrorTruncation || flags & 4 ? undefined : 100;\n            if (maxLength && result.length >= maxLength) {\n                result = result.substr(0, maxLength - \"...\".length) + \"...\";\n            }\n            return result;\n        }\n```\n\nBut adding in `tsconfig.json`:\n\n```\n{\n  \"compilerOptions\": {\n    \"noErrorTruncation\": true\n  }\n}\n```\n\nhas no effect.\n\nIt seems that there's no other mention of that `noErrorTruncation` in the file -- I assume it's simply undefined (and I could also find no documentation about it).\n\nAdding to `ts.optionDeclarations` this entry:\n\n```\n        {\n            name: \"noErrorTruncation\",\n            type: \"boolean\"\n        },\n\n```\n\nmakes it work.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/8742/comments",
    "author": "nh2",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2016-05-23T16:59:58Z",
        "body": "noErrorTrunction was meant for the API users calling directly into the API with CompilerOptions object, e.g. IDE's, and not from the commandline. \nThe asumption is on the commandline no one wants to see the full error, as serlized types can be huge. \nSo can you elaborate on why this is needed? and would you use this all the time? do you use `--pretty` as well?\n"
      },
      {
        "user": "nh2",
        "created_at": "2016-05-23T17:32:51Z",
        "body": "@mhegazy I definitely want to see the full error. The types I'm using (provided by others, so I cannot change them easily) are very long, and typically contain the `... & type & type` unions I care about at the end. It's OK if the errors are shortened by default, but when trying to solve type errors like in my case, it can be really hard if you can only see the first 100 chars of a 200 char type.\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2016-05-23T17:36:01Z",
        "body": "so do you use an IDE? would getting the errors there be a better option?\n"
      },
      {
        "user": "nicksnyder",
        "created_at": "2017-04-27T17:12:02Z",
        "body": "@nh2 can you clarify how you worked around this? I have a similar error that I want to see the full error for."
      },
      {
        "user": "nicksnyder",
        "created_at": "2017-04-27T17:13:53Z",
        "body": "Oh, it looks like adding this to `tsconfig.json` works now\r\n\r\n```\r\n{\r\n  \"compilerOptions\": {\r\n    \"noErrorTruncation\": true\r\n  }\r\n}\r\n```\r\n\r\nI think this issue can be closed."
      },
      {
        "user": "another-guy",
        "created_at": "2017-10-02T05:15:44Z",
        "body": "@nicksnyder I confirm that the compiler option you mentioned is working for me too. I can't speak for @nh2 but IMO this issue is fixed in the compiler."
      }
    ]
  },
  {
    "number": 8101,
    "title": "Function expression, which lacks return-type annotation, implicitly has an 'any' return type.",
    "created_at": "2016-04-14T20:22:26Z",
    "closed_at": "2016-05-17T20:26:21Z",
    "labels": [
      "Bug",
      "Help Wanted",
      "Domain: lib.d.ts",
      "Good First Issue"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/8101",
    "body": "Hi there...\n\nI am using TS version 1.7.4...\n\nall of a sudden I started getting the error:\n\n> Error TS7011  Function expression, which lacks return-type annotation, implicitly has an 'any' return type.\n\nthe offending line of code is:\n\n`setTimeout(() => this.alertMessage = null, 2000);`\n\nnot sure why it suddenly started happening... I have been running this version for a while now... anyway... I don't understand why I am getting this error... the field \"alertMessage\" is defined as such:\n\n`alertMessage: string;`\n\nI guess I am wondering why the compiler is inferring \"any\" instead of \"string\"\n\nThank you\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/8101/comments",
    "author": "giancarloa",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2016-04-14T20:30:13Z",
        "body": "The issue is that the type of an assignment expression is always the type of the right operand, which in this case is `null` (which is widened to an implicit `any`).\n\nWe should fix this by adding an overload to `setTimeout`\n\n``` ts\ndeclare function setTimeout(handler: (...args: any[]) => any, timeout: number): number;\n```\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2016-05-16T18:01:42Z",
        "body": "should not the return type be `void`? the result is ignored by the caller.\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2016-05-16T18:04:02Z",
        "body": "i meant the return type of the call back, i.e.:\n\n``` ts\ndeclare function setTimeout(handler: (...args: any[]) => void, timeout: number): number;\n```\n"
      }
    ]
  },
  {
    "number": 6326,
    "title": "Union returntype with void must return a value",
    "created_at": "2016-01-02T22:53:01Z",
    "closed_at": "2016-01-25T23:12:40Z",
    "labels": [
      "Suggestion",
      "Fixed",
      "Spec",
      "Help Wanted",
      "Good First Issue"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/6326",
    "body": "I have a method declared as `stop(): void|Promise<void> {}` which get the error\n\n> A function whose declared type is neither 'void' nor 'any' must return a value\n\nAs void is a valid return type I would expect that to be fully valid code. Specifying only void is working.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/6326/comments",
    "author": "Pajn",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2016-01-04T05:19:56Z",
        "body": "Proposing changing spec section 6.3\n\n> An explicitly typed function whose return type isn't the Void or the Any type must have at least one return statement somewhere in its body\n\nto\n\n> An explicitly typed function whose return type isn't _the Void type, the Any type, or a union type containing the Void or Any type as a constituent_ must have at least one return statement somewhere in its body\n"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2016-01-04T05:35:51Z",
        "body": "That still doesn't actually cover `Promise<void>` on its own though.\n"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2016-01-04T05:38:26Z",
        "body": "Not sure I understand the comment\n"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2016-01-04T05:48:35Z",
        "body": "The change you're proposing doesn't permit an async function whose return type annotation is `Promise<void>` to have no return statements.\n"
      },
      {
        "user": "Pajn",
        "created_at": "2016-01-04T07:25:26Z",
        "body": "It would be nice if Promise<void> didn't require a return statement in an async function. However for the issue I had the already proposed change would be enough.\n"
      },
      {
        "user": "masaeedu",
        "created_at": "2016-01-15T17:26:27Z",
        "body": "@RyanCavanaugh Regarding:\n\n> An explicitly typed function whose return type isn't the Void type, the Any type, or a union type containing the Void **or Any type as a constituent** must have at least one return statement somewhere in its body\n\nIsn't the emphasized part redundant? The following already compiles:\n\n```\nfunction f(): number | any {\n}\n```\n\nI think the union resolution already recognizes that all types are subtypes of `any`, so any union involving `any` is just `any`.\n"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2016-01-15T17:50:37Z",
        "body": "I think that's an implementation side effect of the compiler. The spec doesn't specify that `number | any` is equivalent to the Any type, though.\n"
      }
    ]
  },
  {
    "number": 4984,
    "title": "Trailing whitespace is not removed by formatter on 'empty' lines",
    "created_at": "2015-09-26T09:59:52Z",
    "closed_at": "2016-01-08T00:43:21Z",
    "labels": [
      "Bug",
      "Fixed",
      "Help Wanted"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/4984",
    "body": "The following test fails:\n\n``` typescript\n/// <reference path='fourslash.ts' />\n\n////    /*1*/\n////    /*2*/\n\nformat.document();\nverify.currentFileContentIs(\"\\n\");\n```\n\n_(where the contents before marker 2 are a `\\t` character)_\n\nI notice trailing whitespace is not removed from comments; whilst I would argue trailing whitespace should be removed across the board, I think it should at least be removed from lines only containing whitespace. \n\nThoughts?\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/4984/comments",
    "author": "myitcv",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2015-09-28T18:06:29Z",
        "body": "We do not touch comments, and this is by design. comments are not code, and should not be formatted.\nas for empty lines, this is more of an optimization, and can be removed.\n"
      }
    ]
  },
  {
    "number": 1706,
    "title": "Union Type inference not working in class (ts version 1.4)",
    "created_at": "2015-01-17T13:13:17Z",
    "closed_at": "2023-07-07T18:42:46Z",
    "labels": [
      "Suggestion",
      "Help Wanted"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/1706",
    "body": "Hi,\nUnion type inference is not working inside classes functions. For example trying to compile the below code : \n\n``` TypeScript\ntype NameOrNameArray = string | string[];\n\nclass NameCreator {\n\n    constructor(public name:NameOrNameArray) {}\n\n    createName():string {\n        if (typeof this.name === \"string\") {\n            return name;\n        }\n        else {\n            this.name.forEach((elem)=>{\n                console.log(elem);\n            });\n            return this.name.join(\" \");\n        }\n    }\n}\n```\n\ngives the error : \n\n```\nProperty 'forEach' does not exist on type 'string | string[]'.\n```\n\nThe same code works well when using a function. Same error in Visual studio and in the Playground.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/1706/comments",
    "author": "erichillah",
    "comments": [
      {
        "user": "erichillah",
        "created_at": "2015-01-17T14:23:33Z",
        "body": "I am able to remove the error only by using explicit type assertion\n\n``` TypeScript\n(<string[]>this.name).forEach((elem)=>{\n    console.log(elem);\n });\n return (<string[]>this.name).join(\" \");\n```\n"
      },
      {
        "user": "ahejlsberg",
        "created_at": "2015-01-17T16:55:30Z",
        "body": "Type guards only work on simple variables, not properties of an object, so you need to copy the property into a local variable.\n\n``` TypeScript\ntype NameOrNameArray = string | string[];\n\nclass NameCreator {\n\n    constructor(public name: NameOrNameArray) {}\n\n    createName(): string {\n        var name = this.name;  // Copy into variable\n        if (typeof name === \"string\") {\n            return name;\n        }\n        else {\n            name.forEach(elem => {\n                console.log(elem);\n            });\n            return name.join(\" \");\n        }\n    }\n}\n```\n\nWe have this restriction because we want to track (to the best of our abilities) that there are no assignments to the variable in the guarded section. This is pretty much impossible to do correctly for properties without extensive flow and alias analysis. For example:\n\n``` typescript\nfunction printString(s: string) { ... }\nclass Foo {\n    name: string | string[];\n    foo() {\n        if (typeof this.name === \"string\") {\n            this.bar();\n            printString(this.name);  // Ok?\n        }\n    }\n    bar() {\n        this.name = [\"hello\"];\n    }\n}\n```\n\nThis is just a simple example. You can construct increasingly impossible ones with little effort.\n\nA possible alternative to our current design is to allow type guards to work on dotted names of the form `x.y.z` or `this.x.y.z` and to ignore the effects of assignments to such names (or parts of them). But it would mean that we wouldn't catch errors like the one in the example above.\n"
      },
      {
        "user": "erichillah",
        "created_at": "2015-01-18T01:17:52Z",
        "body": "Thanks, i get a much better understanding of type guard. The use of class properties or 'global variables' doesn't really make sense as it's pretty much impossible to make sure that the condition `typeof this.name === \"string\"` will still be true accross the type guarded scope. So i guess it'll still be confusing to allow dotted name in type guards.\n"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2015-01-22T17:13:48Z",
        "body": "We still need to work out the exact semantics of how this would work. It's less clear exactly what forms should be allowed since non-local effects are much easier on class members. Consider, for example:\n\n``` ts\nclass Thing {\n    x: string|number;\n\n    ensureXisString() {\n        this.x = this.x.toString();\n    }   \n\n    someMethod() {\n        if(typeof this.x === 'number') {\n            this.ensureXisString();\n            // Narrowed to this.x: number here, which is 100% wrong\n        }\n    }\n}\n```\n"
      },
      {
        "user": "danieljsinclair",
        "created_at": "2015-01-26T18:32:15Z",
        "body": "It would be nice if type guards recognised `Array.isArray()`\n\nthis doesn't seem to work either (v1.4) \n    `instanceof Array`\n"
      },
      {
        "user": "ahejlsberg",
        "created_at": "2015-01-26T18:40:01Z",
        "body": "@danieljsinclair The `x instanceof Array` issue was fixed in #1657.\n"
      },
      {
        "user": "jakebailey",
        "created_at": "2023-07-07T18:42:46Z",
        "body": "Just looking at old issues; this one was fixed in TS 2.0 when control flow analysis was introduced."
      }
    ]
  }
]