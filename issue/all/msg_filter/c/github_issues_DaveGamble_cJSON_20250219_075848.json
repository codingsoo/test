[
  {
    "number": 312,
    "title": "How to enclose the json string in square brackets?",
    "created_at": "2018-11-08T14:55:43Z",
    "closed_at": "2018-11-08T18:30:43Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/DaveGamble/cJSON/issues/312",
    "body": "How can I get the output as:\r\n\r\n[{\r\n    \"cars\": [{\r\n            \"CarType\":  \"BMW\",\r\n            \"carID\":    \"bmw123\"\r\n        }, {\r\n            \"CarType\":  \"mercedes\",\r\n            \"carID\":    \"mercedes123\"\r\n        }]\r\n}]\r\n\r\nI'm able to get output as:\r\n{\r\n    \"cars\": [{\r\n            \"CarType\":  \"BMW\",\r\n            \"carID\":    \"bmw123\"\r\n        }, {\r\n            \"CarType\":  \"mercedes\",\r\n            \"carID\":    \"mercedes123\"\r\n        }]\r\n}\r\n\r\nhow can I enclose the string with square brackets?",
    "comments_url": "https://api.github.com/repos/DaveGamble/cJSON/issues/312/comments",
    "author": "akhi3501",
    "comments": [
      {
        "user": "FSMaxB",
        "created_at": "2018-11-08T17:31:54Z",
        "body": "Create an array and add the object to it. Then it will be surrounded by square braces."
      }
    ]
  },
  {
    "number": 309,
    "title": "Reading Raw child",
    "created_at": "2018-10-17T13:45:39Z",
    "closed_at": "2018-11-08T07:38:41Z",
    "labels": [
      "question",
      "needs info"
    ],
    "url": "https://github.com/DaveGamble/cJSON/issues/309",
    "body": "Hi, \r\nI have this Json string:\r\n{\"cmd\":10,\"uId\":\"221ed5a229405c0e6315\",\"pyl\":{\"time\":\"2359f846\", \"time2\":\"2359f846\"}}\r\n\r\nI need to access to \"pyl\" content and consider it as a RAW data\r\nHow can i achieve that?\r\n\r\nI've tried \t\r\npayloadJSON = cJSON_GetObjectItem(manageMessageJSON, \"pyl\");\r\nbut in that way i retrieve only the Object PYL and cannot access all the contents but cycling each child. I would like to parse PYL content and then access single fields.\r\n\r\nThanks in advance\r\nLeonardo",
    "comments_url": "https://api.github.com/repos/DaveGamble/cJSON/issues/309/comments",
    "author": "lordbarba",
    "comments": [
      {
        "user": "FSMaxB",
        "created_at": "2018-10-19T17:33:52Z",
        "body": "I'm not entirely sure what you mean.\r\n\r\nYou want to parse your JSON in a way that the entire content of `pyl` is of type `cJSON_Raw`? If so: That is not possible. cJSON always parses the entire JSON and doesn't allow keeping parts of it as string. `cJSON_Raw` is only used for printing JSON."
      },
      {
        "user": "lordbarba",
        "created_at": "2018-11-07T09:22:25Z",
        "body": "For example, how can i retrieve all values from:\r\n{ \"cmd\": 6, \"userId\": \"f0c77f16dcc7\", \"pyl\" :{  \"idx\": 66, \"val\": 25 } }\r\n\r\nThis is my code:\r\n\t\r\ncJSON *manageMessageJSON = cJSON_Parse(package);\r\nint iCmd = cJSON_GetObjectItem(manageMessageJSON, \"cmd\")->valueint;\r\npayloadJSON = cJSON_GetObjectItem(manageMessageJSON, \"pyl\");\r\n\r\nHow can i parse \"payloadJSON\" and retrieve \"idx\" and \"val\" values? Do i have to do manually? "
      },
      {
        "user": "FSMaxB",
        "created_at": "2018-11-07T16:57:50Z",
        "body": "Yes, you need to use `cJSON_GetObjectItemCaseSensitive` on `payloadJSON` for both keys (`idx` and `val`). Than you can acess `valuedouble` on them."
      },
      {
        "user": "FSMaxB",
        "created_at": "2018-11-07T16:58:30Z",
        "body": "(after checking that they are actually numbers with `cJSON_IsNumber`)"
      }
    ]
  },
  {
    "number": 281,
    "title": "how to free?",
    "created_at": "2018-07-23T09:04:17Z",
    "closed_at": "2018-07-23T13:25:28Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/DaveGamble/cJSON/issues/281",
    "body": "excuse me, in the example \"char* create_monitor(void)\", how to free the string after already used? using \"cJSON_free\" or \"free\"?",
    "comments_url": "https://api.github.com/repos/DaveGamble/cJSON/issues/281/comments",
    "author": "junwanghust",
    "comments": [
      {
        "user": "FSMaxB",
        "created_at": "2018-07-23T13:25:28Z",
        "body": "If you never changed the allocator using `cJSON_InitHooks`, you can use `free`. Otherwise you will probably know what allocator you did set and use the correct deallocator accordingly.\r\n\r\n`cJSON_malloc` and `cJSON_free` are intended to be used by library writers that use cJSON and expect their users to use cJSON directly as well. This way the library can work properly even if it's user has changed the global allocators."
      }
    ]
  },
  {
    "number": 277,
    "title": "How to compare two json objects?",
    "created_at": "2018-06-26T19:46:42Z",
    "closed_at": "2018-06-27T17:11:39Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/DaveGamble/cJSON/issues/277",
    "body": "I need to determine if two json objects are identical for a unit test.I don't see any built in function for this.\r\n\r\nThe order of the two isn't deterministic, so `strcmp` with `cJSON_Print` won't work.\r\n\r\nIs there any recommended way to do this, or do I have to do `cJSON_GetObjectItemCaseSensitive` for each item that will be in the object?",
    "comments_url": "https://api.github.com/repos/DaveGamble/cJSON/issues/277/comments",
    "author": "iCodeSometime",
    "comments": [
      {
        "user": "FSMaxB",
        "created_at": "2018-06-27T17:11:01Z",
        "body": "`cJSON_Compare`"
      }
    ]
  },
  {
    "number": 270,
    "title": "cJSON_AddObjectToObject with a cJSON* parameter?",
    "created_at": "2018-06-14T09:12:14Z",
    "closed_at": "2018-06-15T12:22:10Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/DaveGamble/cJSON/issues/270",
    "body": "Is there any possibility to add a cJSON* object to another cJSON* object? The function that sounds like it would do what I want takes a string as parameter and doesn't seem to have any alternatives. Let me show why I need it:\r\nI have two structs:\r\n\r\n```c\r\ntypedef struct pet_t {\r\ncategory_t *category;\r\n} pet_t;\r\ntypedef struct category_t {\r\nchar *name;\r\nlong id;\r\n} category_t;\r\n```\r\nNow I would like to have a method for both of them like that:\r\n```c\r\ncJSON* pet_toJSON(pet_t *pet);\r\ncJSON* category_toJSON(category_t *category);\r\n```\r\nThe implementation I would like to have like that:\r\n```c\r\ncJSON *pet_toJSON(pet_t *pet) {\r\ncJSON *petJSONObject = cJSON_CreateObject();\r\ncJSON *categoryJSONObject = category_toJSON(pet->category);\r\ncJSON_AddObjectToObject(petJSONObject, \"category\", categoryJSONObject);\r\n```\r\nCurrently this is not possible and I do it like that:\r\n```c\r\ncJSON *pet_toJSON(pet_t *pet) {\r\ncJSON *petJSONObject = cJSON_CreateObject();\r\ncJSON *categoryJSONObject;\r\nif(cJSON_AddObjectToObject(petJSONObject, \"category\") == NULL) {\r\n\tgoto end;\r\n}\r\ncategoryJSONObject = cJSON_GetObjectItem(petJSONObject,\r\n\t                                                \"category\");\r\nif(cJSON_AddNumberToObject(categoryJSONObject, \"id\",\r\n\t                           pet->category->id) == NULL)\r\n{\r\n\tgoto end;\r\n}\r\n// Category->name\r\nif(cJSON_AddStringToObject(categoryJSONObject, \"name\",\r\n\t                          pet->category->name) == NULL)\r\n{\r\n\tgoto end;\r\n}\r\n```\r\n\r\nIs there any way to add a already created JSON Object to another one?",
    "comments_url": "https://api.github.com/repos/DaveGamble/cJSON/issues/270/comments",
    "author": "PowerOfCreation",
    "comments": [
      {
        "user": "FSMaxB",
        "created_at": "2018-06-14T20:16:05Z",
        "body": "I think you are looking for `cJSON_AddItemToObject`."
      },
      {
        "user": "FSMaxB",
        "created_at": "2018-06-14T20:33:18Z",
        "body": "```c\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <cjson/cJSON.h>\r\n\r\ntypedef struct category_t {\r\n\tchar *name;\r\n\tlong id;\r\n} category_t;\r\n\r\ntypedef struct pet_t {\r\n\tcategory_t *category;\r\n} pet_t;\r\n\r\ncJSON *category_toJSON(const category_t * const category) {\r\n\tif (category == NULL) {\r\n\t\treturn NULL;\r\n\t}\r\n\r\n\tdouble id = (double)category->id;\r\n\tif (id != category->id) {\r\n\t\t//over or underflow of the 2^53 bit integer that a double can store.\r\n\t\t//(assuming a IEEE 754 floating point implementation)\r\n\t\treturn NULL;\r\n\t}\r\n\r\n\tcJSON *category_json = cJSON_CreateObject();\r\n\tif (cJSON_AddStringToObject(category_json, \"name\", category->name) == NULL) {\r\n\t\tgoto fail;\r\n\t}\r\n\r\n\tif (cJSON_AddNumberToObject(category_json, \"id\", id) == NULL) {\r\n\t\tgoto fail;\r\n\t}\r\n\r\n\treturn category_json;\r\n\r\nfail:\r\n\tcJSON_Delete(category_json);\r\n\treturn NULL;\r\n}\r\n\r\ncJSON *pet_toJSON(const pet_t * const pet) {\r\n\tif (pet == NULL) {\r\n\t\treturn NULL;\r\n\t}\r\n\r\n\tcJSON *category = category_toJSON(pet->category);\r\n\tif (category == NULL) {\r\n\t\tgoto fail;\r\n\t}\r\n\r\n\tcJSON *pet_json = cJSON_CreateObject();\r\n\tif (pet_json == NULL) {\r\n\t\tgoto fail;\r\n\t}\r\n\r\n\tcJSON_AddItemToObject(pet_json, \"category\", category); //sadly we don't get any feedback if this fails (would break the API to fix this)\r\n\t//although we can manually check:\r\n\tif (pet_json->child == NULL) {\r\n\t\tgoto fail;\r\n\t}\r\n\r\n\treturn pet_json;\r\n\r\nfail:\r\n\tcJSON_Delete(pet_json);\r\n\treturn NULL;\r\n}\r\n\r\nint main(void) {\r\n\tcategory_t dog = {\r\n\t\t\"dog\",\r\n\t\t1\r\n\t};\r\n\r\n\tpet_t my_dog = {&dog};\r\n\r\n\tcJSON *dog_json = pet_toJSON(&my_dog);\r\n\tif (dog_json == NULL) {\r\n\t\tfprintf(stderr, \"Can't serialize my dog!\\n\");\r\n\t\treturn EXIT_FAILURE;\r\n\t}\r\n\r\n\tchar *dog_json_string = cJSON_Print(dog_json);\r\n\tcJSON_Delete(dog_json);\r\n\tif (dog_json_string == NULL) {\r\n\t\tfprintf(stderr, \"Can't print my serialized dog!\\n\");\r\n\t\treturn EXIT_FAILURE;\r\n\t}\r\n\r\n\tprintf(\"%s\\n\", dog_json_string);\r\n\tfree(dog_json_string);\r\n\r\n\treturn EXIT_SUCCESS;\r\n}\r\n```\r\n\r\nOutput:\r\n```\r\n{\r\n        \"category\":     {\r\n                \"name\": \"dog\",\r\n                \"id\":   1\r\n        }\r\n}\r\n```"
      },
      {
        "user": "PowerOfCreation",
        "created_at": "2018-06-15T12:22:08Z",
        "body": "I have already tried exactly that, but was confused about the error \"void value cannot be ignored as it ought to be\" and thought that it is not possible to add another object cJSON object, but only numbers/strings. Turns out the problem was, that this function, as you have also commented, does not have a return value. If it had this would have saved me a lot of time."
      }
    ]
  },
  {
    "number": 229,
    "title": "Crashing program if calling cJSON on infinite loop",
    "created_at": "2018-01-04T23:02:53Z",
    "closed_at": "2018-01-06T09:14:26Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/DaveGamble/cJSON/issues/229",
    "body": "I use cJSON on programming STM32 and i calling cJSON on infinite loop.\r\nAfter run ~37 cycles program is crashed :(\r\n\r\nMay be cJSON_Delete is not work and memory leaking?\r\n\r\n```c\r\nchar *BLE_Transmit(void)\r\n{\r\n    char *BLE_JSON = NULL;\r\n    cJSON *BLE_OJSON = cJSON_CreateObject();\r\n    cJSON_AddStringToObject(BLE_OJSON, \"111\", \"111\");\r\n    cJSON_AddStringToObject(BLE_OJSON, \"222\", \"222\");\r\n    BLE_JSON = cJSON_Print(BLE_OJSON);\r\n    cJSON_Delete(BLE_OJSON);\r\n    return BLE_JSON;\r\n}\r\n\r\nwhile (1)\r\n  {\r\n      HAL_UART_Transmit(&huart1, (unsigned char*)  BLE_Transmit(), strlen( BLE_Transmit()),10);\r\n      HAL_GPIO_TogglePin(GPIOC, GPIO_PIN_13);\r\n      HAL_Delay(100);\r\n  }\r\n```\r\nPlease help me...\r\n  \r\nThis error in function cJSON_Print. While i call without function cJSON_Print code is correct run.\r\n\r\n  ",
    "comments_url": "https://api.github.com/repos/DaveGamble/cJSON/issues/229/comments",
    "author": "leech001",
    "comments": [
      {
        "user": "FSMaxB",
        "created_at": "2018-01-05T20:38:47Z",
        "body": "Yes, this very much looks like a memory leak.\r\n\r\nYou create `BLE_JSON` with `cJSON_Print` and return it from `BLE_TRANSMIT`.  But the string needs to be freed. I guess that `HAL_UART_Transmit` doesn't free anything, so memory leaks and eventually you run out of memory.\r\n\r\nOnce out of memory, there might be different reasons why it would crash. For example `cJSON_Print` might return a `NULL` pointer that is then dereferenced somewhere or something like that."
      },
      {
        "user": "FSMaxB",
        "created_at": "2018-01-05T20:58:30Z",
        "body": "`strlen` might be the point where it crashes, because `strlen` doesn't necessarily check for `NULL` pointers, but it could also be somewhere else.\r\n\r\nThis should work:\r\n\r\n```c\r\nchar *BLE_Transmit(void)\r\n{\r\n\tchar *BLE_JSON = NULL;\r\n\tcJSON *BLE_OJSON = cJSON_CreateObject();\r\n\tcJSON_AddStringToObject(BLE_OJSON, \"111\", \"111\");\r\n\tcJSON_AddStringToObject(BLE_OJSON, \"222\", \"222\");\r\n\tBLE_JSON = cJSON_Print(BLE_OJSON);\r\n\tcJSON_Delete(BLE_OJSON);\r\n\treturn BLE_JSON;\r\n}\r\n\r\nint main(void)\r\n{\r\n\twhile (1)\r\n\t{\r\n\t\tunsigned char *json = (unsigned char*)BLE_TRANSMIT();\r\n\t\tif (json == NULL)\r\n\t\t{\r\n\t\t\t//do some error handling\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\tHAL_UART_Transmit(&huart1, json, strlen(json), 10);\r\n\t\tfree(json); /* <---- */\r\n\t\tHAL_GPIO_TogglePin(GPIOC, GPIO_PIN_13);\r\n\t\tHAL_Delay(100);\r\n\t}\r\n}\r\n```\r\n\r\nIf you know that the JSON will always be below a certain length, you could also print the JSON withouth any heap allocations using `cJSON_PrintPreallocated`:\r\n\r\n```c\r\nchar *BLE_Transmit(unsigned char * const buffer, size_t buffer_size)\r\n{\r\n\tchar *BLE_JSON = NULL;\r\n\tcJSON *BLE_OJSON = cJSON_CreateObject();\r\n\tcJSON_AddStringToObject(BLE_OJSON, \"111\", \"111\");\r\n\tcJSON_AddStringToObject(BLE_OJSON, \"222\", \"222\");\r\n\tif (!cJSON_PrintPreallocated(BLE_OJSON, buffer, buffer_size, 1)) {\r\n\t\tcJSON_Delete(BLE_OJSON);\r\n\t\treturn NULL;\r\n\t}\r\n\tcJSON_Delete(BLE_OJSON);\r\n\treturn BLE_JSON;\r\n}\r\n\r\nint main(void)\r\n{\r\n\tunsigned char buffer[BUFFER_SIZE];\r\n\r\n\twhile (1)\r\n\t{\r\n\t\tif (BLE_TRANSMIT(buffer, sizeof(buffer)) == NULL)\r\n\t\t{\r\n\t\t\t//do some error handling\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\tHAL_UART_Transmit(&huart1, buffer, strlen(buffer), 10);\r\n\t\tHAL_GPIO_TogglePin(GPIOC, GPIO_PIN_13);\r\n\t\tHAL_Delay(100);\r\n\t}\r\n}\r\n```\r\n\r\nAs it seems like you are transmitting Data via BLE, it probably doesn't need to be human readable, so formatting can be disabled. So you might want to use `cJSON_PrintUnformatted` or replace the `1` in the call to `cJSON_PrintPreallocated` with a `0`.\r\n\r\nIf `cJSON_PrintPreallocated` is not an option because you don't know the maximum length of your JSON, you can still reduce the number of heap allocations by using `cJSON_PrintBuffered` and giving it a buffer size that is long enough for the majority of JSONs.\r\n  "
      },
      {
        "user": "FSMaxB",
        "created_at": "2018-01-05T21:04:30Z",
        "body": "Also if you are rebuilding the same JSON over and over again with only small modifications, you don't really need to rebuild the entire thing over and over again. It should be enough to build it once, replace the changed items with one of the `cJSON_ReplaceItem` functions and then print it again.\r\n\r\nIf large subtrees of the JSON are statically known, these can be provided as Strings as `cJSON_Raw` type to avoid having to print them over and over again."
      }
    ]
  },
  {
    "number": 224,
    "title": "question about cJSON_Number",
    "created_at": "2017-12-13T10:21:19Z",
    "closed_at": "2017-12-14T07:25:20Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/DaveGamble/cJSON/issues/224",
    "body": "I have a question about cJSON_Number : in the cJSON struct there are 2 numbers, valueint and valuedouble. From what I saw while doing some tests, I understand that if type == cJSON_Number, I understood the number is stored in both values. What I would like to know if is there is any way to know if a cJSON_Number is an int or a double.\r\n\r\nI am asking this because I needed a function to convert cJSON objects to strings so I created one : \r\n```c\r\nvoid cJSON_ToString(cJSON* json, char str[200])\r\n{\r\n  cJSON* p_courant = json->child;\r\n  int j = cJSON_GetArraySize(json);\r\n  int i;\r\n  char n[12];\r\n  strcat(str,\"{\");\r\n  for (i = 1; i <= j ; i++)\r\n  {\r\n    strcat(str,\"\\\"\");\r\n    strcat(str,(char*)(p_courant->string));\r\n    strcat(str,\"\\\" : \");\r\n    if (p_courant->type == cJSON_String)\r\n    {\r\n      strcat(str,\"\\\"\");\r\n      strcat(str,(char*)(p_courant->valuestring));\r\n      strcat(str,\"\\\"\");\r\n    }\r\n    else if (p_courant->type == cJSON_Number)\r\n    {\r\n      sprintf(n,\"%f\",(double)(p_courant->valuedouble));\r\n      strcat(str,n);\r\n    }\r\n    if (i != j)\r\n    {\r\n      strcat(str,\",\");\r\n      p_courant = p_courant->next;\r\n    }\r\n  }\r\n  strcat(str,\"}\");\r\n}\r\n```\r\n\r\nbut I would like to be able to deal with both integers and floats, which I don't know how to do right now because cJSON_Number can be either.",
    "comments_url": "https://api.github.com/repos/DaveGamble/cJSON/issues/224/comments",
    "author": "helo-ch",
    "comments": [
      {
        "user": "FSMaxB",
        "created_at": "2017-12-13T12:15:10Z",
        "body": "Why don't you use `cJSON_Print`, or in your case `cJSON_PrintPreallocated` because you print to a fixed size buffer? It should print numbers correctly without decimal point if it is an integer.\r\n\r\n```c\r\ncJSON_bool cJSON_ToString(cJSON * const json, char buffer[200]) {\r\n    return cJSON_PrintPreallocated(json, buffer, 200, 0);\r\n}\r\n```\r\n\r\n`valueint` is only there for compatibility reasons, cJSON internally only uses `valuedouble` (but sets `valueint` as well for old applications).\r\n\r\nIf you want to find out if a number is an integer, there are several ways to do it.\r\n1. `((double)valueint) == valuedouble`\r\n2. `((double)((int)valuedouble)) == valuedouble` (not sure if there can be any rounding errors\r\n3. `double fractional; (modf(valuedouble, &fractional) == 0)`"
      }
    ]
  },
  {
    "number": 223,
    "title": "Help! question about: cJSON_Print",
    "created_at": "2017-12-13T09:26:26Z",
    "closed_at": "2017-12-14T03:02:52Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/DaveGamble/cJSON/issues/223",
    "body": "**IDE:  Keil.**\r\n**MCU: STM32F303**\r\n\r\n**my test code:**\r\n\r\n```c\r\nvoid cJSON_test(void)\r\n{\r\n\tchar *s = \"{\\\"list\\\":[{\\\"name\\\":\\\"xiao hong\\\",\\\"age\\\":10},{\\\"name\\\":\\\"hua hua\\\",\\\"age\\\":11}]}\";\r\n\tcJSON *root = cJSON_Parse(s);\r\n\tif (!root)\r\n\t{\r\n\t\tprintf(\"Error before: [%s]\\n\",cJSON_GetErrorPtr());\r\n\t}\r\n\tprintf(\"%s \\r\\n\",s);\r\n\tchar *str = cJSON_Print(root);\r\n\tprintf(\"%s \\r\\n\",str);\r\n\tcJSON_Delete(root);\r\n}\r\n```\r\n\r\n**Result:**\r\n```json\r\n{\"list\":[{\"name\":\"xiao hong\",\"age\":10},{\"name\":\"hua hua\",\"age\":11}]} \r\n8\u0007\r\n```\r\n\r\nWhat's the happen of the second print????\r\ni can't understand that why the  cJSON_Parse is OK but cJSON_Print is wrong...I didn't change anything\r\n\r\nif I change the string s to `\"{\\\"list\\\":{\\\"name\\\":\\\"xiao hong\\\"}}\"`\r\n**Result:**\r\n```json\r\n{\"list\":{\"name\":\"xiao hong\"}}\r\n{\"list\":{\"name\":\"xiao hong\"}}\r\n```\r\n\r\n\r\nthe result is ok, and i want to find the cause by debug, i find that:\r\n\r\n```c\r\nstatic unsigned char *print(const cJSON * const item, cJSON_bool format, const internal_hooks * const hooks)\r\n{\r\n    printbuffer buffer[1];\r\n    unsigned char *printed = NULL;\r\n\r\n    memset(buffer, 0, sizeof(buffer));\r\n\r\n    /* create buffer */\r\n    buffer->buffer = (unsigned char*) hooks->allocate(256);\r\n    buffer->format = format;\r\n    buffer->hooks = *hooks;\r\n             //if result is wrong ,buffer ==0, i can't understand why the buffer will equal to 0?\r\n    if (buffer->buffer == NULL)\r\n    {\r\n        goto fail;\r\n    }\r\n```\r\n\r\n\r\nI am desperate,please help...\r\n\r\n",
    "comments_url": "https://api.github.com/repos/DaveGamble/cJSON/issues/223/comments",
    "author": "LittleProgrammer-L",
    "comments": [
      {
        "user": "FSMaxB",
        "created_at": "2017-12-13T11:54:35Z",
        "body": "The code looks good to me except that you leak `str` and don't abort in case `root == NULL`.\r\n\r\nI tested it and it works fine. I will take a closer look."
      },
      {
        "user": "FSMaxB",
        "created_at": "2017-12-13T12:31:47Z",
        "body": "`buffer` being `0` make absolutely no sense. This is a value on the stack, not a heap allocation. This is guaranteed to never be `0` though.\r\n\r\n`buffer->buffer` being `NULL` is another matter entirely though. This means that the allocation failed.\r\n\r\nAnd since you never checked if `string` is `NULL` it will print garbage in this case (or on most systems just SEGFAULT). You should really check `str` before passing it to `printf`!!"
      },
      {
        "user": "LittleProgrammer-L",
        "created_at": "2017-12-14T01:42:29Z",
        "body": "Thank you for your answer.\r\nI'm sorry I did not make it clear before\uff0cHere I make it as clear as possible.\r\n\r\nmy test code is very easy:\r\n```c\r\nvoid cJSON_test(void)\r\n{\r\n\tchar *s = \"{\\\"list\\\":[{\\\"name\\\":\\\"xiao hong\\\",\\\"age\\\":10},{\\\"name\\\":\\\"hua hua\\\",\\\"age\\\":11}]}\";\t//print fail\r\n\t//char *s = \"{\\\"list\\\":[{\\\"name\\\":\\\"xiao hong\\\",\\\"age\\\":10}]}\";\t//print fail\r\n\t//char *s = \"{\\\"list\\\":{\\\"name\\\":\\\"xiao hong\\\"}}\";\t//print ok\r\n\tcJSON *root = cJSON_Parse(s);\r\n\tif (!root)\r\n\t{\r\n\t\tprintf(\"Error before: [%s]\\n\",cJSON_GetErrorPtr());\t//This print not appear mean root format is correct\uff0cright?\r\n\t}\r\n\tprintf(\"%s \\r\\n\",s);\r\n\tchar *str = cJSON_Print(root);\r\n\tprintf(\"%s \\r\\n\",str);\r\n\tcJSON_Delete(root);\r\n}\r\n```\r\n\r\n`printf(\"Error before: [%s]\\n\",cJSON_GetErrorPtr());` \r\nI am based on this print does not appear to determine the `root` format is correct.\r\n\r\nwhen s = `\"{\\\"list\\\":[{\\\"name\\\":\\\"xiao hong\\\",\\\"age\\\":10},{\\\"name\\\":\\\"hua hua\\\",\\\"age\\\":11}]}\"`\r\nprint result:\r\n```json\r\n{\"list\":[{\"name\":\"xiao hong\",\"age\":10},{\"name\":\"hua hua\",\"age\":11}]} \r\n8\u0007\r\n```\r\n\r\nwhen s = `\"{\\\"list\\\":[{\\\"name\\\":\\\"xiao hong\\\",\\\"age\\\":10}]}\"`\r\nprint result:\r\n```json\r\n{\"list\":[{\"name\":\"xiao hong\",\"age\":10}]} \r\n8\u0007\r\n```\r\n\r\nwhen s = `\"{\\\"list\\\":[{\\\"name\\\":\\\"xiao hong\\\",\\\"age\\\":10}]}\"`\r\nprint result:\r\n```json\r\n{\"list\":{\"name\":\"xiao hong\"}} \r\n{\"list\":{\"name\":\"xiao hong\"}}\r\n```\r\n\r\nSo, i debug the code and compared with the right print, find different places is here:\r\n```c\r\nstatic unsigned char *print(const cJSON * const item, cJSON_bool format, const internal_hooks * const hooks)\r\n{\r\n    printbuffer buffer[1];\r\n    unsigned char *printed = NULL;\r\n\r\n    memset(buffer, 0, sizeof(buffer));\r\n\r\n    /* create buffer */\r\n    buffer->buffer = (unsigned char*) hooks->allocate(256);    //The difference is here!!!\r\n    buffer->format = format;\r\n    buffer->hooks = *hooks;\r\n    if (buffer->buffer == NULL)    //I set the breakpoint here.\r\n    {\r\n        goto fail;\r\n    }\r\n```\r\nwhen print result is ok, `buffer->buffer` != 0\r\nwhen print result is fail, `buffer->buffer` == 0, it means the allocation failed? Is it related to the format of 'root'? Is not the format of 'root' correct?\r\n\r\nmy confusion is that why the `root` format is correct but print would be fail?  \r\n\r\nI still need to check `str`? It does not seem to be related to `str`.\r\n\r\nMany routines are like this is OK except mine, i need help..."
      },
      {
        "user": "FSMaxB",
        "created_at": "2017-12-14T02:29:28Z",
        "body": "In any case you have to check the result of `cJSON_Print` and don't use it for `printf` if it is `NULL`.\r\n\r\nAlso the allocation clearly fails in the first two cases, but doesn't in the third. I have no idea why that happens and have no influence over it.\r\n\r\nA couple of things you should investigate:\r\n* What allocator are you using? Standard `malloc` and `free`?\r\n* Does the allocation failure depend on the number of allocations that are done by `cJSON_Parse`?\r\n* Or maybe because of the size?\r\n* What happens when you replace `cJSON_Print` with `cJSON_PrintBuffered` and vary the prebuffer amount?\r\n* If you allocate 256 Bytes with `free` before the `cJSON_Print`, will it return `NULL` as well?\r\n\r\nAlso I noticed something else: You are either not showing me the correct output or you are using a modified version of cJSON instead of the original one. Because `cJSON_Print` produces formatted output, so if you are using the real cJSON you should see:\r\n```json\r\n{\"list\":{\"name\":\"xiao hong\"}}\r\n{\r\n        \"list\": {\r\n                        \"name\": \"xiao hong\"\r\n                }\r\n}\r\n```\r\n\r\nnot\r\n\r\n```json\r\n{\"list\":{\"name\":\"xiao hong\"}} \r\n{\"list\":{\"name\":\"xiao hong\"}}\r\n```\r\n\r\nIn any case: cJSON is not doing anything wrong here. It does exactly the correct thing: Returning `NULL` from `cJSON_Print` because of an allocation failure.\r\n\r\nPlease check the return values from cJSON properly!!! Here is a fixed version of your test code together with some things to test for debugging the allocation failure:\r\n```c\r\nvoid cJSON_test(void)\r\n{\r\n    char *s = \"{\\\"list\\\":[{\\\"name\\\":\\\"xiao hong\\\",\\\"age\\\":10},{\\\"name\\\":\\\"hua hua\\\",\\\"age\\\":11}]}\";\r\n    //char *s = \"{\\\"list\\\":[{\\\"name\\\":\\\"xiao hong\\\",\\\"age\\\":10}]}\";\r\n    //fail//char *s = \"{\\\"list\\\":{\\\"name\\\":\\\"xiao hong\\\"}}\";\r\n    char *str = NULL;\r\n    cJSON *root = cJSON_Parse(s);\r\n    if (root == NULL)\r\n    {\r\n        printf(\"Error before: [%s]\\n\",cJSON_GetErrorPtr());\r\n        goto cleanup;\r\n    }\r\n\r\n    // BEGIN Things to test\r\n    /*\r\n     * Test heap allocations directly\r\n     */\r\n    /*\r\n    char *test = malloc(256);\r\n    if (test == NULL) {\r\n        printf(\"ERROR: Heap allocation failed.\");\r\n    } else {\r\n        free(test);\r\n    }\r\n    */\r\n\r\n    /*\r\n     * Test cJSON_PrintPreallocated\r\n     */\r\n    /*\r\n    const int prebuffer = 256; //play around with this value\r\n    const cJSON_bool format = 0;\r\n    str = cJSON_PrintPreallocated(root, prebuffer, format);\r\n    if (str == NULL) {\r\n        goto cleanup;\r\n    }\r\n    free(str);\r\n    str = NULL;\r\n     */\r\n    // END Things to test\r\n\r\n    printf(\"%s \\r\\n\",s);\r\n    str = cJSON_Print(root);\r\n    if (str == NULL) {\r\n        printf(\"ERROR: cJSON_Print failed.\");\r\n        goto cleanup;\r\n    }\r\n    printf(\"%s \\r\\n\",str);\r\n\r\ncleanup:\r\n    if (root != NULL) {\r\n        cJSON_Delete(root);\r\n    }\r\n\r\n    if (str != NULL) {\r\n        free(str);\r\n    }\r\n}\r\n```\r\n\r\ntl;dr (summary)\r\n----------------------\r\n* You have an allocation failure that **you** need to investigate, I can't fix it for you.\r\n* cJSON handles the allocation failure correctly. (by returning `NULL` from `cJSON_Print`)\r\n* You are dereferencing a `NULL` pointer in `printf(\"%s \\r\\n\",str);`, this is where the garbage comes from. Please check for `NULL` pointers before printing them as string with `printf`!\r\n* You are most certainly using a modified version of cJSON (because `cJSON_Print` produces formatted output in the original version)"
      },
      {
        "user": "LittleProgrammer-L",
        "created_at": "2017-12-14T03:02:52Z",
        "body": "Thank you very much for your reply!\r\n\r\nWhat I need to correct is that the way I put the printed result is via `cJSON_PrintUnformatted` function, I'm sorry to make this point misleading.\r\n\r\nI think it should be the allocation of memory failure after I saw your answer, so I  find the file 'startup_stm32f303xe.s' and find the place where the stack is allocated:\r\n`Heap_Size      EQU     0x200`    //0x00000200 equal 512 Byte\r\nI change `0x200` to `0x400`, and all print results are normal.\r\n\r\nWhat still make me confuse is that the allocation fails in the first two cases but doesn't in the third. \r\n\r\nAnyway, thank you very much for your reply~\r\n"
      },
      {
        "user": "FSMaxB",
        "created_at": "2017-12-14T17:09:02Z",
        "body": "Probably just the size. The parsed JSON is quite large, `sizeof(cJSON)` should be around 50 bytes or so."
      }
    ]
  },
  {
    "number": 198,
    "title": "unknow character appearing while using the exmaple Test",
    "created_at": "2017-08-28T08:39:23Z",
    "closed_at": "2017-08-28T08:57:33Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/DaveGamble/cJSON/issues/198",
    "body": "I am using your example code with ESP32. I get some '.' before every data ... \r\nhere is my output.\r\n```\r\nVersion: 1.5.8\r\n{\r\n.\"name\":.\"Jack (\\\"Bee\\\") Nimble\",\r\n.\"format\":.{\r\n..\"type\":.\"rect\",\r\n..\"width\":.1920,\r\n..\"height\":.1080,\r\n..\"interlace\":.false,\r\n..\"frame rate\":.24\r\n.}\r\n}\r\n[\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"]\r\n[[0, -1, 0], [1, 0, 0], [0, 0, 1]]\r\n{\r\n.\"Image\":.{\r\n..\"Width\":.800,\r\n..\"Height\":.600,\r\n..\"Title\":.\"View from 15th Floor\",\r\n..\"Thumbnail\":.{\r\n...\"Url\":.\"http:/*www.example.com/image/481989943\",\r\n...\"Height\":.125,\r\n...\"Width\":.\"100\"\r\n..},\r\n..\"IDs\":.[116, 943, 234, 38793]\r\n.}\r\n}\r\n[{\r\n..\"precision\":.\"zip\",\r\n..\"Latitude\":.37.7668,\r\n..\"Longitude\":.-122.3959,\r\n..\"Address\":.\"\",\r\n..\"City\":.\"SAN FRANCISCO\",\r\n..\"State\":.\"CA\",\r\n..\"Zip\":.\"94107\",\r\n..\"Country\":.\"US\"\r\n.}, {\r\n..\"precision\":.\"zip\",\r\n..\"Latitude\":.37.371991,\r\n..\"Longitude\":.-122.026,\r\n..\"Address\":.\"\",\r\n..\"City\":.\"SUNNYVALE\",\r\n..\"State\":.\"CA\",\r\n..\"Zip\":.\"94085\",\r\n..\"Country\":.\"US\"\r\n.}]\r\n{\r\n.\"number\":.null\r\n}\r\n```\r\n\r\nwhat are this dot's ?? is it only issue with the printf of ESP32 IDF? I will post it there to.",
    "comments_url": "https://api.github.com/repos/DaveGamble/cJSON/issues/198/comments",
    "author": "shirish47",
    "comments": [
      {
        "user": "shirish47",
        "created_at": "2017-08-28T08:46:09Z",
        "body": "ok thats a problem of software I was using for serial.. coolterm ... in arduino's serial its clean.\r\n\r\n\u001b[0;32mI (191) cpu_start: Starting scheduler on APP CPU.\u001b[0m\r\nVersion: 1.5.8\r\n```\r\n{\r\n\t\"name\":\t\"Jack (\\\"Bee\\\") Nimble\",\r\n\t\"format\":\t{\r\n\t\t\"type\":\t\"rect\",\r\n\t\t\"width\":\t1920,\r\n\t\t\"height\":\t1080,\r\n\t\t\"interlace\":\tfalse,\r\n\t\t\"frame rate\":\t24\r\n\t}\r\n}\r\n[\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"]\r\n[[0, -1, 0], [1, 0, 0], [0, 0, 1]]\r\n{\r\n\t\"Image\":\t{\r\n\t\t\"Width\":\t800,\r\n\t\t\"Height\":\t600,\r\n\t\t\"Title\":\t\"View from 15th Floor\",\r\n\t\t\"Thumbnail\":\t{\r\n\t\t\t\"Url\":\t\"http:/*www.example.com/image/481989943\",\r\n\t\t\t\"Height\":\t125,\r\n\t\t\t\"Width\":\t\"100\"\r\n\t\t},\r\n\t\t\"IDs\":\t[116, 943, 234, 38793]\r\n\t}\r\n}\r\n[{\r\n\t\t\"precision\":\t\"zip\",\r\n\t\t\"Latitude\":\t37.7668,\r\n\t\t\"Longitude\":\t-122.3959,\r\n\t\t\"Address\":\t\"\",\r\n\t\t\"City\":\t\"SAN FRANCISCO\",\r\n\t\t\"State\":\t\"CA\",\r\n\t\t\"Zip\":\t\"94107\",\r\n\t\t\"Country\":\t\"US\"\r\n\t}, {\r\n\t\t\"precision\":\t\"zip\",\r\n\t\t\"Latitude\":\t37.371991,\r\n\t\t\"Longitude\":\t-122.026,\r\n\t\t\"Address\":\t\"\",\r\n\t\t\"City\":\t\"SUNNYVALE\",\r\n\t\t\"State\":\t\"CA\",\r\n\t\t\"Zip\":\t\"94085\",\r\n\t\t\"Country\":\t\"US\"\r\n\t}]\r\n{\r\n\t\"number\":\tnull\r\n}\r\n\r\n```\r\n\r\nwhy is Bee not in double quotes here ??"
      },
      {
        "user": "FSMaxB",
        "created_at": "2017-08-28T08:57:33Z",
        "body": "That dots are probably just a way that your terminal tells you that this is a tab character.\r\n\r\nAn `Bee` is in double quotes! But they are escaped with a backslash."
      }
    ]
  },
  {
    "number": 197,
    "title": "Copy some JSON element into a given JSON string",
    "created_at": "2017-08-25T12:21:01Z",
    "closed_at": "2017-08-25T15:22:34Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/DaveGamble/cJSON/issues/197",
    "body": "Hi,\r\n\r\nRunning this code make the program eat all available memory. It's actually the call to the `cJSON_AddItemToObject` function that does it.\r\n\r\n        cJSON *root = NULL;\r\n        cJSON *params = NULL;\r\n        cJSON *someparam = NULL;\r\n        const char *jsonString =\r\n                        \"{  \\\"params\\\":\"\\\r\n                        \"  {\"\\\r\n                        \"    \\\"someparam\\\":\"\\\r\n                        \"    {\"\\\r\n                        \"      \\\"attribute\\\": \\\"value\\\"\"\\\r\n                        \"    }\"\r\n                        \"  }\"\\\r\n                        \"}\";\r\n\r\n        root = cJSON_Parse(jsonString);\r\n        params = cJSON_GetObjectItem(root, \"params\");\r\n        someparam = cJSON_GetObjectItem(params, \"someparam\");\r\n        cJSON_AddItemToObject(params, \"someparam\", someparam);\r\n\r\n        printf(\"cJSON_Parse root : %s\\n\", cJSON_Print(root));\r\n        printf(\"cJSON_Parse params : %s\\n\", cJSON_Print(params));\r\n        printf(\"cJSON_Parse someparam : %s\\n\", cJSON_Print(someparam));\r\n\r\nObviously, I'm doing something wrong here and I'd like to have your feedback on how to re-insert an existing JSON element into a given JSON string, safely.\r\n\r\nThanks!",
    "comments_url": "https://api.github.com/repos/DaveGamble/cJSON/issues/197/comments",
    "author": "phsultan",
    "comments": [
      {
        "user": "FSMaxB",
        "created_at": "2017-08-25T15:14:51Z",
        "body": "This is incorrect because the elements of an object are stored in a doubly linked list. This means that if you add the same item twice, it's `next` and `prev` get messed up and create a cycle.\r\n\r\nActually it's not the `cJSON_AddItemToObject` function that eats all your memory. It's `cJSON_Print` that does! That is because the cycle of `someparam` pointing to itself as the next item ist equivalent to having an infinite list of `someparam` items that `cJSON_Print` tries to print out, thereby running out of memory.\r\n\r\nYou can fix this in one of two ways:\r\n1. Use `cJSON_DetachItemFromObject` in the line before `cJSON_AddItemToObject`. In that case you will have only one instance of it in the result.\r\n2. Duplicate `someparam` with `cJSON_Duplicate` before adding the duplicate with `cJSON_AddItemToObject`. Note though that having two objects with the same key doesn't make any sense!\r\n\r\n"
      }
    ]
  },
  {
    "number": 169,
    "title": "Printing to user-supplied buffer",
    "created_at": "2017-05-19T08:19:51Z",
    "closed_at": "2017-05-19T09:17:10Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/DaveGamble/cJSON/issues/169",
    "body": "It should be possible to print to a user-defined buffer:\r\n\r\n`size_t (bytes_written) cJSON_PrintUnformatted(cJSON *item, void *buf, size_t buf_len);`\r\n\r\nThis would halve memory consumption and avoid malloc() overhead. Doing this is currently impossible, because the printbuffer struct is not public.\r\n\r\n ",
    "comments_url": "https://api.github.com/repos/DaveGamble/cJSON/issues/169/comments",
    "author": "MrBuddyCasino",
    "comments": [
      {
        "user": "FSMaxB",
        "created_at": "2017-05-19T09:13:08Z",
        "body": "Use `cJSON_PrintPreallocated`!\r\n\r\n```c\r\nif (!cJSON_PrintPreallocated(item, buf, len, 0))\r\n{\r\n    /* error handling */\r\n}\r\n```\r\n\r\nThe API is currently not optimal, I will add the following items on the TODO list for cJSON version 2:\r\n* Return the length\r\n* Use `unsigned char*` buffer\r\n* Use `size_t` instead of `int` (is on the list anyways)\r\n\r\nCurrently you need to use `strlen()` if you want to get the length.\r\n"
      }
    ]
  },
  {
    "number": 167,
    "title": "Is there an interface to iterate json keys?",
    "created_at": "2017-05-10T03:15:42Z",
    "closed_at": "2017-05-10T11:16:36Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/DaveGamble/cJSON/issues/167",
    "body": "i failed to find such an interface in cJSON.h, so can i work around to iterate json keys?",
    "comments_url": "https://api.github.com/repos/DaveGamble/cJSON/issues/167/comments",
    "author": "buptUnixGuys",
    "comments": [
      {
        "user": "FSMaxB",
        "created_at": "2017-05-10T11:16:36Z",
        "body": "`cJSON_ArrayForEach` can be used to iterate over arrays and objects."
      },
      {
        "user": "FSMaxB",
        "created_at": "2017-05-10T11:22:57Z",
        "body": "Just to be clear, this is how you actually use `cJSON_ArrayForEach` to iterate over the keys of an object:\r\n\r\n```c\r\ncJSON *current_element = NULL;\r\nchar *current_key = NULL;\r\n\r\ncJSON_ArrayForEach(current_element, object)\r\n{\r\n    current_key = current_element->string;\r\n    if (current_key != NULL)\r\n    {\r\n        /* do something with the key */\r\n    }\r\n}\r\n```"
      }
    ]
  },
  {
    "number": 154,
    "title": "client's responsibility to free memory?",
    "created_at": "2017-04-20T22:32:52Z",
    "closed_at": "2017-04-26T07:13:59Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/DaveGamble/cJSON/issues/154",
    "body": "Hey Folks, \r\n\r\nI'm playing with the library and I'm wondering if the client is responsible to release the memory allocated by the cJSON struct. Here is an example:\r\n\r\n```c\r\nchar * test(char * t)\r\n{\r\n   cJSON * r = cJSON_Parse(t);\r\n   free(t);\r\n   char * s;\r\n   cJSON *id =  cJSON_GetObjectItem(r, \"id\");\r\n   s = id->valuestring;\r\n   free(r);                   //with or without this, s still points to the valid data\r\n   return s;\r\n}\r\n```\r\n\r\nI was thinking that I need to allocate  memory for the returned string since 'id'  goes away and so does 'id-valuestring' once it returns, but a test shows that it actually points to correct data. I checked that 'id->valuestring' is dynamically allocated, then client has the responsibility to free it like the following? \r\n\r\n```c\r\nchar * id = test(jsonstring);\r\n//do something with id\r\nfree(id);\r\n```\r\nAlso, with or without 'free(r)', it returns the same, so should I release the cJSON structure once I'm done? Is there a cascading 'free' function that could free all the dynamically allocated memory in the structure? is that just cJSON_Delete(root)? What if I already make a few objects like\r\n\r\n```c\r\ncJSON * t = cJSON_GetObjectItem(id,  \"name\");\r\n```\r\nthis t is actually the direct child of id, not root, would cJSON.Delete(root) free the whole thing?\r\nThanks,\r\nRui",
    "comments_url": "https://api.github.com/repos/DaveGamble/cJSON/issues/154/comments",
    "author": "rui-wang-codebase",
    "comments": [
      {
        "user": "FSMaxB",
        "created_at": "2017-04-21T08:43:06Z",
        "body": "Yes, the caller is always responsible to free the results from all variants of `cJSON_Parse` and `cJSON_Print` (except `cJSON_PrintPreallocated`, where the caller has full responsibility of the buffer)\r\n\r\nEither way you have a memory leak. If you just free `r`, all its children are still allocated.\r\n\r\ncJSON has a function `cJSON_Delete` that recursively frees a tree of `cJSON` structs. But if you do that, `s` will point to freed memory. So if you want a function that works like your function `test` that parses a JSON and returns a string from it, you need to clone the string in your `test` function by allocating a new buffer and copying it with `strcpy`.\r\n\r\nThis could look like this:\r\n```c\r\nchar * test(char * json)\r\n{\r\n   cJSON * root = cJSON_Parse(json);\r\n   free(json);\r\n\r\n   cJSON *id =  cJSON_GetObjectItem(root, \"id\");\r\n   if (!cJSON_IsString(id))\r\n   {\r\n      return NULL;\r\n   }\r\n\r\n   char *string = malloc(strlen(id->valuestring) + sizeof(\"\")); /* sizeof(\"\") accounts for '\\0' at the end */\r\n   strcpy(string, id->valuestring);\r\n   cJSON_Delete(root);\r\n\r\n   return string;\r\n}\r\n```\r\n\r\nAnd in the caller:\r\n```c\r\nchar *id = test(jsonstring);\r\nif (id == NULL)\r\n{\r\n   /* abort */\r\n}\r\n/* do something with id */\r\nfree(id);\r\n```"
      },
      {
        "user": "FSMaxB",
        "created_at": "2017-04-21T08:48:05Z",
        "body": "Alternatively you could \"detach\" the valuestring and then return it directly like this:\r\n\r\n```c\r\nchar * test(char * json)\r\n{\r\n   cJSON * root = cJSON_Parse(json);\r\n   free(json);\r\n\r\n   cJSON *id =  cJSON_GetObjectItem(root, \"id\");\r\n   if (!cJSON_IsString(id))\r\n   {\r\n      return NULL;\r\n   }\r\n\r\n   char *string = id->valuestring;\r\n   /* this removes the pointer to the string from the tree\r\n       of cJSON structs thereby preventing cJSON_Delete\r\n       from freeing it */\r\n   id->valuestring = NULL;\r\n   cJSON_Delete(root);\r\n\r\n   return string;\r\n}\r\n```"
      },
      {
        "user": "rui-wang-codebase",
        "created_at": "2017-04-21T18:51:03Z",
        "body": "Hey Max, thanks for the clarification. So...in the second option you showed above, the cJSON struct is actually 'damaged' to 'detach' the valuestring, thus it would be the caller to free the memory that valuestring points to, right? I didn't realize that user could just take the structure apart. :-) Btw, I'm curious why you used sizeof(\"\") instead of just 1 to accommodate for the '\\0' at the end of the string, do you mind educating me a bit? :-)"
      },
      {
        "user": "FSMaxB",
        "created_at": "2017-04-21T20:54:00Z",
        "body": "That's correct, by detaching the string that `valuestring` points to, you transfer the responsibility of freeing it to the caller.\n\nI use `sizeof(\"\")` to make the intent clear. It contains more information than `1` but compiles to the same machine code.\n\nI would use `sizeof('\\0')` but sadly in C this is the same as `sizeof(int)` because, unlike in C++, character literals are of type `int`."
      },
      {
        "user": "rui-wang-codebase",
        "created_at": "2017-04-22T01:36:37Z",
        "body": "Thanks, could you please look at this question?\r\n\r\ncJSON *id =  cJSON_GetObjectItem(r, \"id\");\r\ncJSON * t = cJSON_GetObjectItem(id,  \"name\");\r\n\r\nIf we run these 2 lines of code, I'm wondering if t is pointing to a subtree of id, or\r\nt has a duplicate of that subtree. (sorry I didn't get a chance to look into the source,\r\nand I should have done that) In another words, do I need to do\r\n\r\ncJSON_Delete(id);\r\ncJSON_Delete(t);\r\n\r\nor just \r\n\r\ncJSON_Delete(id);\r\n\r\nwould free both structs?\r\n\r\n\r\n"
      },
      {
        "user": "FSMaxB",
        "created_at": "2017-04-22T09:03:02Z",
        "body": "Just `cJSON_Delete(id);` would free `id` and `t`. But this is dangerous because once you run `cJSON_Delete(r);` you will get at least one double free because `r` still has a pointer to `id` (directly or via the linked list of children). Or even worse, you could corrupt arbitrary memory.\n\nIf you want to treat `id` separately, you can detach it from `r` with `cJSON_DetachItemFromObject`. Once it has been detached you have to delete it separately."
      }
    ]
  },
  {
    "number": 132,
    "title": "How to get the JSON size before invoke cJSON_PrintPreallocated",
    "created_at": "2017-03-22T15:16:15Z",
    "closed_at": "2017-03-22T16:51:00Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/DaveGamble/cJSON/issues/132",
    "body": "Hi,\r\nI have a question about the JSON size.\r\nI built a JSON Object and I need to print it into a char buffer allocated dynamically.\r\nTo allocate the buffer I need to compute the length of the JSON.\r\n \r\nI tried to invoke the **cJSON_PrintPreallocated** passing a buffer with the exactly size of JSON (computed by hand) but the function fails. If I add an extra 30 byte the cJSON_PrintPreallocated return success.\r\n\r\nIs there a function to create a buffer which length is exactly equal to the size of my JSON?\r\n\r\nThanks!\r\n",
    "comments_url": "https://api.github.com/repos/DaveGamble/cJSON/issues/132/comments",
    "author": "fedex03",
    "comments": [
      {
        "user": "FSMaxB",
        "created_at": "2017-03-22T15:32:11Z",
        "body": "No, for now you should always add 63 bytes because `print_number` always reserves 64 bytes."
      },
      {
        "user": "FSMaxB",
        "created_at": "2017-03-22T15:36:47Z",
        "body": "`cJSON_PrintPreallocated` was a recent addition to cJSON and cJSON hasn't been optimized too much for that use case.\r\n\r\nI'll add a comment to the header that mentions this."
      },
      {
        "user": "FSMaxB",
        "created_at": "2017-03-22T15:46:41Z",
        "body": "So it fails because of memory usage?"
      },
      {
        "user": "fedex03",
        "created_at": "2017-03-22T15:49:04Z",
        "body": "It fails into `print`, in particular here:\r\n```\r\n/* copy the buffer over to a new one */\r\n    printed = (unsigned char*) hooks->allocate(buffer->offset + 1);\r\n    if (printed == NULL)\r\n    {\r\n        goto fail;\r\n    }\r\n```"
      },
      {
        "user": "FSMaxB",
        "created_at": "2017-03-22T16:03:03Z",
        "body": "Yes, that means that it is running out of memory.\r\n\r\nThe different functions have different memory tradeoffs.\r\n\r\n`cJSON_Print` and `cJSON_PrintUnformatted` essentially do the following:\r\n1. `cJSON_PrintBuffered()` with 256 buffer size. This doubles the memory every time it runs out of memory and copies the old memory over.\r\n2. Take the length of the result, allocate a new buffer with that size and copy the json over to the new buffer, then freeing the old one.\r\n\r\nIn the absolute worst case, this can take up to 3 times the size of the printed JSON for a short amount of time, but it only takes the amount of memory of the JSON's size when it is finished.\r\n\r\nIf you are on a system without an MMU, buffered printing can be really bad because it can create memory fragmentation. In this case it mgith even take much more than 3 times the size of the JSON in total memory to make this work.\r\n\r\nSo if you know approximately how big your JSON will be, `cJSON_PrintPreallocated` is the way to go both in terms of performance and peak memory usage. If the JSON ist stored in memory for a long time, you still might want to copy to a new, smaller buffer after printing is finished."
      },
      {
        "user": "fedex03",
        "created_at": "2017-03-22T16:35:16Z",
        "body": "Yes my JSON has a know size and with `cJSON_PrintPreallocated` the system works. I use cJSON into an embedded system ( Cortex-M4 ).\r\n\r\nI don't understand your last statement: \r\n> If the JSON ist stored in memory for a long time, you still might want to copy to a new, smaller buffer after printing is finished."
      },
      {
        "user": "FSMaxB",
        "created_at": "2017-03-22T16:36:56Z",
        "body": "What I mean is that you can reclaim the memory that is wasted by using a too large buffer with cJSON_PrintPreallocated by first getting the actual length of the JSON and then creating a new memory location, copy it over and free the old buffer."
      },
      {
        "user": "fedex03",
        "created_at": "2017-03-22T16:39:50Z",
        "body": "After each `cJSON_PrintPreallocated `, I send the JSON to a server and then I free the buffer. Why should I copy the buffer to a new one?"
      },
      {
        "user": "FSMaxB",
        "created_at": "2017-03-22T16:40:39Z",
        "body": "In that case it doesnt make sense."
      }
    ]
  },
  {
    "number": 129,
    "title": "cjson_Delete doesn't free all memory",
    "created_at": "2017-03-21T13:28:41Z",
    "closed_at": "2017-03-21T13:54:29Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/DaveGamble/cJSON/issues/129",
    "body": "I using cJson ( C ) into an embedded project to parse a JSON object.\r\n\r\nAfter an intense debugging session I found a problem. The memory requested by the cJSON object isn't released completely. I found this problem printing on UART the free heap size.\r\n\r\nThis is my code:\r\n```c\r\ncJSON    *jsonObject;\r\ncJSON    *jsonItem;\r\nuint8_t  protocolVersion;\r\nchar     machineId[DATA_PROTOCOL_PROPERTY_MACHINE_ID_MAX_LEN];\r\n\r\n/* Free Heap: 22688 Byte */\r\njsonObject = cJSON_CreateObject();\r\n/* Free Heap: 22640 Byte. cJSON object uses 48 Byte */\r\n\r\njsonObject = cJSON_Parse( jsonMessage );\r\n\r\njsonItem = cJSON_GetObjectItem( jsonObject, \"ProtocolVerison\" );\r\nprotocolVersion = (uint8_t)jsonItem->valueint;\r\n\r\njsonItem = cJSON_GetObjectItem( jsonObject, \"MachineID\" );\r\nstrncpy( machineId, jsonItem->valuestring, SDK_DATA_PROTOCOL_PROPERTY_MACHINE_ID_MAX_LEN );\r\n\r\n/* Free Heap: 22152 Byte. cJSON object occupies 488 Byte */\r\ncJSON_Delete( jsonObject );\r\n/* Free Heap: 22640 Byte. cJSON object deleted */\r\n\r\n```\r\n\r\nThe difference between the free heap memory at start (22688 byte) and the free heap at the end ( 22640 byte ) is 48 byte equal to the cJSON object before start parsing.\r\n\r\nThis 48 byte, after several loop bring the system into a memory leak ( my application consume the entire heap).",
    "comments_url": "https://api.github.com/repos/DaveGamble/cJSON/issues/129/comments",
    "author": "fedex03",
    "comments": [
      {
        "user": "FSMaxB",
        "created_at": "2017-03-21T13:54:29Z",
        "body": "Yes, there is a memory leak in your code. Although it is not created by cJSON.\r\n\r\n```c\r\ncJSON    *jsonObject;\r\ncJSON    *jsonItem;\r\nuint8_t  protocolVersion;\r\nchar     machineId[SDK_DATA_PROTOCOL_PROPERTY_MACHINE_ID_MAX_LEN];\r\n\r\n/* This code mallocs your 48 bytes */\r\njsonObject = cJSON_CreateObject(); /* this line is unnecessary and creates the memory leak */\r\n\r\n/* here you are overwriting your pointer to the 48 bytes by overwriting it with the newly parsed object, thereby creating a memory leak */\r\njsonObject = cJSON_Parse( jsonMessage );\r\n/* please check if jsonObject is NULL and abort if it is */\r\n\r\njsonItem = cJSON_GetObjectItem( jsonObject, \"ProtocolVerison\" );\r\n/* same here, before using jsonItem, check if it is NULL */\r\n/* Also check the type, you can check if it is a number using cJSON_IsNumber(jsonItem) */\r\nprotocolVersion = (uint8_t)jsonItem->valueint;\r\n\r\njsonItem = cJSON_GetObjectItem( jsonObject, \"MachineID\" );\r\n/* same here, check if jsonItem is NULL and check if it is a string using cJSON_IsString(jsonItem) */\r\nstrncpy( machineId, jsonItem->valuestring, SDK_DATA_PROTOCOL_PROPERTY_MACHINE_ID_MAX_LEN ); /* you could also use sizeof(machineId) */\r\n\r\n/* This only frees what has been parsed by cJSON_Parse, your 48 bytes have already been lost earlier */\r\ncJSON_Delete( jsonObject );\r\n```"
      },
      {
        "user": "FSMaxB",
        "created_at": "2017-03-21T14:01:18Z",
        "body": "It has to, since it returns a pointer to a cJSON object. What you did would be correct if the return type were `cJSON` instead of `cJSON *`."
      }
    ]
  }
]