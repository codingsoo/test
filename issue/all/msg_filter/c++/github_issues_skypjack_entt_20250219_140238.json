[
  {
    "number": 1181,
    "title": "Runtime Eror with groups",
    "created_at": "2024-10-05T16:50:43Z",
    "closed_at": "2024-10-12T17:02:24Z",
    "labels": [
      "question",
      "solved"
    ],
    "url": "https://github.com/skypjack/entt/issues/1181",
    "body": "I get this runtime error: \r\n```Assertion failed: ((std::all_of(groups.cbegin(), groups.cend(), [](const auto &data) { return !(data.second->owned(type_id<Owned>().hash()) || ...); })) && (\"Conflicting groups\")), file ...file/path/to/source...\\entt\\entity/registry.hpp, line 1105```\r\n\r\ncode:\r\n```EntityManager::GetWorld().group<MeshInstance>(entt::get<Transform>).size()```\r\nEntityManager::GetWorld() basically returns the registry",
    "comments_url": "https://api.github.com/repos/skypjack/entt/issues/1181/comments",
    "author": "MineStorm999",
    "comments": [
      {
        "user": "skypjack",
        "created_at": "2024-10-07T10:23:01Z",
        "body": "Groups cannot share ownership of a same type. In this case, you're violating their rules. You have another group somewhere taking ownership of `MeshInstance`. Thus, the assert."
      },
      {
        "user": "MineStorm999",
        "created_at": "2024-10-07T11:58:35Z",
        "body": "Ok is it the same with Views?"
      },
      {
        "user": "skypjack",
        "created_at": "2024-10-07T12:46:28Z",
        "body": "No, they don't _own_ anything."
      }
    ]
  },
  {
    "number": 1150,
    "title": "Iterating over all entities",
    "created_at": "2024-06-21T11:22:45Z",
    "closed_at": "2024-06-21T12:39:14Z",
    "labels": [
      "question",
      "solved"
    ],
    "url": "https://github.com/skypjack/entt/issues/1150",
    "body": "For some housekeeping tasks in a game after a level is complete I wish to iterate over all entities in a registry and delete every entity that does not have the persistence compontnt.\r\n\r\n`registry::each` would be the function that I wanted to use since that ahs been widely noted as the function for this exact task but it appears that in version `3.13.2` this function is no longer available on the registry.\r\nWhat replaced this functionality or how do I createh the desired behavior with this version of the library?\r\n\r\n```\r\n---\\sources\\GameplayScreen.cpp(208): error C2039: 'each': is not a member of 'entt::basic_registry<entt::entity,std::allocator<Entity>>'\r\n        with\r\n        [\r\n            Entity=entt::entity\r\n        ]\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/skypjack/entt/issues/1150/comments",
    "author": "KiviTK",
    "comments": [
      {
        "user": "skypjack",
        "created_at": "2024-06-21T11:34:35Z",
        "body": "Something along this line: `for(auto entity: registry.view<entt::entity>(entt::exclude<T>)) { ... }`.\r\nEntities have their own (fully customizable) storage now, as it happens with the components.\r\nThis means that they work with views, they support signals and mixins, and so on. \ud83d\udc4d "
      }
    ]
  },
  {
    "number": 1140,
    "title": "Acecss components of an entity, without giving full registry access",
    "created_at": "2024-04-28T15:54:46Z",
    "closed_at": "2024-05-06T11:43:15Z",
    "labels": [
      "question",
      "solved"
    ],
    "url": "https://github.com/skypjack/entt/issues/1140",
    "body": "I have a function to initialize an entity with a bunch of components\r\n\r\nMy first attempt has been something like receiving only an entity, but that doesn't work. I have no way to create new components for that entity\r\n\r\n```\r\ntemplate <>\r\nvoid initialize<SomeObjectType>(entt::entity entity) {\r\n    // Initialize components for this entity\r\n    // but really can initialize anything, I can't store the components in the registry\r\n}\r\n```\r\n\r\nSo I add the registry to the function signature\r\n\r\n```\r\ntemplate <>\r\nvoid initialize<SomeObjectType>(entt:registry reg, entt::entity entity) {\r\n    // Initialize components for this entity\r\n    // This works fine, but it has too much access\r\n}\r\n```\r\n\r\nThis works from a usability perspective, but it gives the control full access to the whole registry, so now all the \"encapsulation\" is gone. Someone implementing that function might make something wrong with the registry, so I will have to double check every commited code...\r\n\r\nIs there anyway to allow to create new components or modify existing components but only for the particular entity I passed to the function? For modifying it might be possible to receive a `view` (althought getting the type right might be tricky), but how can I initialize the components if I only receive the entity?\r\n\r\n",
    "comments_url": "https://api.github.com/repos/skypjack/entt/issues/1140/comments",
    "author": "jjcasmar",
    "comments": [
      {
        "user": "skypjack",
        "created_at": "2024-04-29T11:20:43Z",
        "body": "Something like the `handle` class maybe? It has a method to get the registry though. However, you can use it as an example to implement a custom solution. Does it work for you?"
      },
      {
        "user": "jjcasmar",
        "created_at": "2024-04-29T11:35:37Z",
        "body": "I looked into the handle, and see that it had access to the entity and to the registry, so it doesn't really solves my issue. I guess I could inherit from `handle` and disable the registry access. Would you accept a contribute for this?"
      },
      {
        "user": "skypjack",
        "created_at": "2024-04-30T08:19:19Z",
        "body": "It would be a breaking change, so no. I don't plan to make the `registry` method private in that class. I'm sorry.\r\nHowever, you can inherit or take inspiration from it and do whatever you want that fits your design. \ud83d\udc4d "
      },
      {
        "user": "jjcasmar",
        "created_at": "2024-04-30T08:38:37Z",
        "body": "I was thinking on adding a new template parameter to the handle class, and instantiate the entity() and registry() methods depending on that template parameter. But I have checked the code and the basic_handle already has a ...Scope template parameter, which makes it impossible to add a new parameter between the Registry type and the Scope without making a breaking change. \r\n"
      },
      {
        "user": "Innokentiy-Alaytsev",
        "created_at": "2024-04-30T08:41:22Z",
        "body": "I guess Michele suggests doing whatever you want/need in your code base. Adding a new type that is essentially `handle`, but not quite, or complicating the `handle` itself is not a great plan maintenance-wise."
      },
      {
        "user": "jjcasmar",
        "created_at": "2024-04-30T08:49:56Z",
        "body": "Yeah, I think so. \r\nI still think the functionality will be a nice addition to EnTT, I have found my self several times trying to restrict access to the registry. But if there is not enough traction for adding it, we can just close the issue. \r\n\r\nThanks for the answers!"
      },
      {
        "user": "skypjack",
        "created_at": "2024-04-30T09:08:11Z",
        "body": "> I have found my self several times trying to restrict access to the registry\r\n\r\nWhat you're trying to do isn't restricting access to the registry though.\r\nInstead, you're trying to emulate the EC model of Unity or the like, where the entity is the key actor and you can do everything by means of its API.\r\nECS models are slightly different. Systems are meant to operate on a whole set of entities and components rather than on a single entity. Whit this in mind, you can already restrict a system's scope by passing storage classes or views to it.\r\nThat is why there isn't much traction probably. This is a pretty uncommon request. \ud83d\ude42 "
      },
      {
        "user": "jjcasmar",
        "created_at": "2024-04-30T09:21:55Z",
        "body": "The issue is not when operating on the entities, for that I use views. The issue comes when creating entities. In my use case, I am trying to create an entity with the needed components to simulate a garment. I need to add several components (Mesh, Collider...).\r\n\r\nRight now I have a function which is in charge of creating the components for the entity, but to do so, I need to pass the whole registry, so inside that function, which should only be allowed to create the components I want, now I can modify all the registry. That is why I was thinking on a way of being able to add components to a single entity, without giving full access to the registry. \r\n\r\nIf there is a better way to initialize the entities with its components, I am all ears"
      },
      {
        "user": "Green-Sky",
        "created_at": "2024-04-30T15:14:08Z",
        "body": "Passing in the \"whole\" `registry` is not an issue in your case.\r\n\r\nHowever I see 2 options for you that can enforce this form of separation.\r\n\r\n1. Like @skypjack said, instead of passing in the `registry` to the creation function, you can only pass in the `entity` and all the `storage`s (component pools) that you require.\r\n2. You already found the `Scope... template` on the `handle` :), while this still would allow to access the `registry field` of a `handle`, it would allow you to restrict which `component types` (`storage`s) can be accessed through it's interface. This feels more like the solution you want. You can also declare an alias for the special restricted handle type."
      },
      {
        "user": "jjcasmar",
        "created_at": "2024-04-30T15:58:47Z",
        "body": "Why do you say its not an issue in my case? I am thinking on a teammate doing something wrong like\r\n\r\n```\r\nvoid initialize_garment(entt::registry &reg, entt::entity garment) {\r\n    registry.emplace<Mesh>(garment);\r\n    registry.emplace<Collider>(garment);\r\n    registry.emplace<Material>(garment);\r\n    ...\r\n    auto meshes = reg.view<Mesh>(); // Wrong, we are also accessing already existing meshes\r\n}\r\n```\r\n\r\nI agree the programmer of that code is doing something really bad, and that code will never pass code review. But restricting what the programmer can use in the first place will solve the issue. \r\n\r\nHow would you use the component pools in this case? I have never done something like that. \r\n\r\nThe option of restricting the component types of the handle doesn't totally solve the issue (although it definitely improves it). I can still access entities which have one of the restricted types. \r\n\r\nMaybe there is a third solution. Create entities with a \"to be built\" component and pass a view to those entities. "
      },
      {
        "user": "skypjack",
        "created_at": "2024-05-01T09:05:19Z",
        "body": "I see your point. However, as you correctly pointed out, the handle class cannot be changed easily in this sense.\r\nThat said, if all you want is to restrict access when creating new entities, a small utility with a minimal interface is bettter suited probably. Something like this (completely out of my mind and just to give you a grasp of what I mean):\r\n```cpp\r\nstruct my_utility {\r\n    my_utility(entt::registry &ref, entt::entity target)\r\n        : reg{&ref}, entity{target}\r\n    {}\r\n\r\n    template<typename Type>\r\n    decltype(auto) emplace() { return reg->emplace<Type>(entity); }\r\n\r\nprivate:\r\n    entt::registry *reg;\r\n    entt::entity entity;\r\n```\r\nThat's all. You can pass it as a function argument and use it in the body as:\r\n```cpp\r\nMesh &mesh = util.emplace<Mesh>();\r\n// fill the mesh as needed and proceed with other components\r\n```\r\nI mean, for a grand total of 9 loc you've a fully encapsulated emplace function, which is what you're looking for if I get it correctly? If this is the case, it sounds like a good compromise to me. \ud83e\udd37\u200d\u2642\ufe0f \r\n\r\n> How would you use the component pools in this case?\r\n\r\nIt wouldn't fit your requirements anyway. If you pass a pool to a function, your teammate can still remove random elements from it or iterate all the instances in it and do something crazy with them.\r\n\r\n> Create entities with a \"to be built\" component and pass a view to those entities.\r\n\r\nI personally use something similar actually. Sort of _setup this entity as concept C_ component that is handled by a specific system at the _right_ point in the loop (for some definitions of right ofc \ud83d\ude05).\r\nThis doesn't solve your _issue_ though. My system still receives the whole registry to setup things."
      },
      {
        "user": "jjcasmar",
        "created_at": "2024-05-01T09:19:10Z",
        "body": "I like that small utility class, and it toally solves the issue. Probably it also need a variadic emplace() method to create the elements, but yeah, something like totally works. \r\n\r\nI was probably overthinking, since its only for creation, I only need the emplace functionality."
      }
    ]
  },
  {
    "number": 1135,
    "title": "Working with multiple storages for the same type and preparing a view for each of the storages",
    "created_at": "2024-04-05T04:03:17Z",
    "closed_at": "2024-05-02T14:04:45Z",
    "labels": [
      "question",
      "solved"
    ],
    "url": "https://github.com/skypjack/entt/issues/1135",
    "body": "There a couple of different posts that are similar to this. I apologize if this seems like a duplicate but I am not clear on how to achieve the following:\r\n\r\nI have a component `UserDefinedStruct` that I would like to add to an Entity multiple times where the component is differentiated by an index that is generated at runtime.\r\n\r\n```\r\nPool<UserDefinedStruct>(0)\r\nPool<UserDefinedStruct>(1)\r\nPool<UserDefinedStruct>(2)\r\n...\r\n```\r\n\r\nWhich then allows an `entity` to have the component `UserDefinedStruct` multiple times as long as they have a different index.\r\n\r\nI would then like to `view` each pool such that I get `UserDefinedStruct&` and the `entity` that the component is associated with.\r\n\r\nI realize this is not a valid call in `entt`, but something like:\r\n```cpp\r\nconst int runtime_id_from_somewhere = Get_RuntimeId();\r\nreg.view<UserDefinedStruct>(runtime_id_from_somewhere).each(...)\r\n```",
    "comments_url": "https://api.github.com/repos/skypjack/entt/issues/1135/comments",
    "author": "samaursa",
    "comments": [
      {
        "user": "skypjack",
        "created_at": "2024-04-05T12:51:08Z",
        "body": "I think it's more similar to:\r\n```cpp\r\nauto &storage = registry.storage<UserDefinedStruct>(id);\r\nstorage.emplace(entity, args...);\r\n```\r\nFor when you want to emplace/erase entities for example, while you can do this for the view:\r\n```cpp\r\nentt::basic_view ud_view{registry.storage<UserDefinedStruct>(id));\r\nfor(auto [entt, my_t, my_ud]: (registry.view<T>() | ud_view)) { ... }\r\n```\r\nIs this on the line of what you're looking for? Not sure I got your request. \ud83d\ude05 "
      }
    ]
  },
  {
    "number": 1110,
    "title": "Combine snapshot and meta features",
    "created_at": "2024-02-02T11:35:14Z",
    "closed_at": "2024-02-07T17:46:38Z",
    "labels": [
      "question",
      "solved"
    ],
    "url": "https://github.com/skypjack/entt/issues/1110",
    "body": "Hey\r\nI just started using the library and I love it. I have not fully understood how to use the meta feature but in below code I am trying to serialize components with the help of the meta information. There must be a better way to do what I am trying to do inside the Archive class below. Can you please help me understand how to achive the same thing but without having to compare strings?\r\n\r\n`\r\n\r\n\tstruct SomeStruct\r\n\t{\r\n\t\tfloat x = 0.f;\r\n\t\tfloat y = 0.f;\r\n\t\tfloat z = 0.f;\r\n\t\tbool b = false;\r\n\t\tuint8_t u8 = 0;\r\n\t\tuint16_t u16 = 0;\r\n\r\n\r\n\t\tSomeStruct(float in_x, float in_y, float in_z, bool in_b, uint8_t in_u8, uint16_t in_u16)\r\n\t\t\t: x(in_x), y(in_y), z(in_z), b(in_b), u8(in_u8), u16(in_u16)\r\n\t\t{\r\n\t\t}\r\n\t};\r\n\r\n\ttemplate<typename T>\r\n\tclass BitPacker\r\n\t{\r\n\tpublic:\r\n\t\tBitPacker(T& storage)\r\n\t\t{}\r\n\r\n\t\ttemplate<typename T>\r\n\t\tvoid serialize(T value) \r\n\t\t{}\r\n\t};\r\n\r\n\r\n\ttemplate<typename T>\r\n\tclass Archive\r\n\t{\r\n\tpublic:\r\n\t\tArchive(T& storage)\r\n\t\t\t: m_bitPacker(storage)\r\n\t\t{}\r\n\r\n\t\tvoid operator()(std::underlying_type_t<entt::entity> size) \r\n\t\t{}\r\n\r\n\t\tvoid operator()(entt::entity entity) \r\n\t\t{}\r\n\r\n\t\ttemplate<typename T>\r\n\t\tvoid operator() (const T& component)\r\n\t\t{\r\n\t\t\tentt::meta_any any(component);\r\n\r\n\t\t\tfor (auto&& key_value : any.type().data())\r\n\t\t\t{\r\n\t\t\t\tauto member = key_value.second.get(component);\r\n\t\t\t\tauto type = member.type();\r\n\r\n\t\t\t\tif (type.info().name() == \"bool\")\r\n\t\t\t\t{\r\n\t\t\t\t\tstd::cout << \"bool value \" << member.cast<bool>() << std::endl;\r\n\t\t\t\t\tm_bitPacker.serialize(member.cast<bool>());\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (type.info().name() == \"unsigned char\")\r\n\t\t\t\t{\r\n\t\t\t\t\tstd::cout << \"uint8_t value \" << member.cast<uint8_t>() << std::endl;\r\n\t\t\t\t\tm_bitPacker.serialize(member.cast<uint8_t>());\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (type.info().name() == \"unsigned short\")\r\n\t\t\t\t{\r\n\t\t\t\t\tstd::cout << \"uint16_t value \" << member.cast<uint16_t>() << std::endl;\r\n\t\t\t\t\tm_bitPacker.serialize(member.cast<uint16_t>());\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (type.info().name() == \"float\")\r\n\t\t\t\t{\r\n\t\t\t\t\tstd::cout << \"float value \" << member.cast<float>() << std::endl;\r\n\t\t\t\t\tm_bitPacker.serialize(member.cast<float>());\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\tprivate:\r\n\t\tBitPacker<T> m_bitPacker;\r\n\t};\r\n\r\n\tint main()\r\n\t{\r\n\t\tusing namespace entt::literals;\r\n\t\r\n\t\tentt::meta<SomeStruct>()\r\n\t\t\t.type(entt::type_hash<SomeStruct>::value())\r\n\t\t\t.data<&SomeStruct::x>(\"x\"_hs)\r\n\t\t\t.data<&SomeStruct::y>(\"y\"_hs)\r\n\t\t\t.data<&SomeStruct::y>(\"z\"_hs)\r\n\t\t\t.data<&SomeStruct::b>(\"b\"_hs)\r\n\t\t\t.data<&SomeStruct::u8>(\"u8\"_hs)\r\n\t\t\t.data<&SomeStruct::u16>(\"u16\"_hs);\r\n\r\n\t\tentt::registry registry;\r\n\t\tauto entity1 = registry.create();\r\n\t\tregistry.emplace<SomeStruct>(entity1, 0.f, 0.f, 0.f, false, 0, 0);\r\n\r\n\t\tauto entity2 = registry.create();\r\n\t\tregistry.emplace<SomeStruct>(entity2, 10.f, 10.f, 10.f, true, 10, 1222);\r\n\r\n\t\tstd::stringstream stream;\r\n\t\tArchive<std::stringstream> archive(stream);\r\n\t\r\n\t\tentt::snapshot{ registry }\r\n\t\t\t//.get<entt::entity>(archive)\r\n\t\t\t.get<SomeStruct>(archive);\r\n\r\n\t\treturn 0;\r\n\t}\r\n\r\n`",
    "comments_url": "https://api.github.com/repos/skypjack/entt/issues/1110/comments",
    "author": "bookmagnus",
    "comments": [
      {
        "user": "skypjack",
        "created_at": "2024-02-04T22:42:56Z",
        "body": "> Can you please help me understand how to achive the same thing but without having to compare strings?\r\n\r\nDo you mean here? `type.info().name() == \"bool\"`.\r\nYou can use the compile time hash for that, as in `type.info().hash() == entt::type_id<Type>().hash()`.\r\n\r\nAlso note that you're copying the object here: `entt::meta_any any(component);`.\r\nHowever, `meta_any` also supports creating references to elements: `entt::meta_any any = entt::forward_as_meta(component);`.\r\nThat said, you don't have to wrap the element in an `meta_any` object at all. Just use the meta type directly:\r\n```cpp\r\nfor (auto&& key_value : entt::resolve<Type>().data()) {\r\n    ...\r\n}\r\n```"
      }
    ]
  },
  {
    "number": 1073,
    "title": "registry.create() returning entt::entity of id greater than entt::null?",
    "created_at": "2023-09-27T06:29:01Z",
    "closed_at": "2023-09-27T11:01:36Z",
    "labels": [
      "question",
      "solved"
    ],
    "url": "https://github.com/skypjack/entt/issues/1073",
    "body": "After destroying created entities and creating new ones, registry.create() returns ids that are greater than entt::null. Is this normal?",
    "comments_url": "https://api.github.com/repos/skypjack/entt/issues/1073/comments",
    "author": "michellelor",
    "comments": [
      {
        "user": "skypjack",
        "created_at": "2023-09-27T07:28:38Z",
        "body": "> registry.create() returns ids that are greater than entt::null\r\n\r\nFortunately, it doesn't.\r\n\r\nIdentifiers are split in two parts, the entity and the version. `entt::null` _means_ 0xFFFF for all bits of the entity part.\r\nWhen you destroy an identifier, the version is increased while the entity remains the same. This is what you're observing.\r\nIn any case the resulting entity is greater than `entt::null` (also because `entt::null` is the maximum value allowed for the entity part, so this cannot happen by construction \ud83e\udd37\u200d\u2642\ufe0f).\r\n\r\nUse `entt::to_integral` to _convert_ an identifier to its integral value and `entt::to_entity` or `entt::to_version` to _extract_ and verify its parts.\r\nAlso note that identifiers are recycled as soon as possible the avoid wasting space in the entity storage. Therefore, if you destroy then create an identifier, it's likely that you get the same entity with a different version, that is, a completely different identifier."
      }
    ]
  },
  {
    "number": 1051,
    "title": "`entt::registry::empty()` is deprecated, but (...) has no member named `in_use()`",
    "created_at": "2023-08-06T21:48:46Z",
    "closed_at": "2023-08-07T15:35:27Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/skypjack/entt/issues/1051",
    "body": "Hi,\r\nI have the following code:\r\n```c\r\nif(registry.empty()) {\r\n    consoleLog.push_back({0, \"No entities in scene.\"});\r\n    return;\r\n}\r\n```\r\nMy compiler tells me:\r\n```\r\nwarning: 'empty' is deprecated: use .storage<Entity>().in_use() instead\r\n```\r\nSo I change the code to this:\r\n```c\r\nif(!registry.storage().in_use()) {\r\n    consoleLog.push_back({0, \"No entities in scene.\"});\r\n    return;\r\n}\r\n```\r\nNow, my compiler tells me this:\r\n```\r\nerror: no member named 'in_use' in 'entt::iterable_adaptor<entt::internal::registry_storage_iterator<entt::internal::dense_map_iterator<__gnu_cxx::__normal_iterator<entt::internal::dense_map_node<unsigned int, std::shared_ptr<entt::basic_sparse_set<>>> *, std::vector<entt::internal::dense_map_node<unsigned int, std::shared_ptr<entt::basic_sparse_set<>>>>>>>>'\r\n```\r\n\r\nWhat's going on? I'm using `single_include/entt/entt.hpp` with version v3.12.2.",
    "comments_url": "https://api.github.com/repos/skypjack/entt/issues/1051/comments",
    "author": "colleen05",
    "comments": [
      {
        "user": "skypjack",
        "created_at": "2023-08-07T07:18:43Z",
        "body": "> I still feel like being warned about deprecation, suggested to use a different function, and then finding out that function doesn't actually exist, is a bit odd\r\n\r\nI mean, the warning says `storage<Entity>().in_use()` and you did `storage().in_use()`.\r\nI find being notified of a change with a description of what to do, doing a different thing and then being surprised why it doesn't work is just as weird.\r\nProbably that function exists on the *right* storage though:\r\n```cpp\r\nif(registry.storage<entt::entity>().in_use() == 0u) {\r\n    // no entities currently in use here\r\n}\r\n```"
      },
      {
        "user": "colleen05",
        "created_at": "2023-08-07T15:35:27Z",
        "body": "Thanks for pointing this out to me!\r\nI failed to read the documentation last night, and I misunderstood the use of the function.\r\n\r\nI do have an additional question:\r\nWhy does it want me to specify type _Entity_, when there's just one entity type (essentially a uint32)? Can registries store more than just entities? Or is there some non-purely-ECS thing you can do like, for example, creating an entity class that contains the uint32 EnTT needs, but also storing a name string for in-game referencing?"
      },
      {
        "user": "skypjack",
        "created_at": "2023-08-07T15:39:42Z",
        "body": "Well, yeah, the entity type is customizable as everything else in EnTT. You can have 64b entities or use a custom class if you like.\r\nThat being said, `storage()` has a different purpose and `storage<T>()` wants a `T`. Since you're asking for the entity storage... \ud83e\udd37\u200d\u2642\ufe0f "
      }
    ]
  },
  {
    "number": 1020,
    "title": "clone a registry, or at least a subset of components",
    "created_at": "2023-06-09T12:26:33Z",
    "closed_at": "2023-08-31T09:19:29Z",
    "labels": [
      "question",
      "solved"
    ],
    "url": "https://github.com/skypjack/entt/issues/1020",
    "body": "Hey, I have an use case where I need to multi buffer a `registry`, or at least the entities and most of the components. What would be the best way for copy/cloning a `registry`?\r\n\r\nI couldn't manage to find a way to do it, based on previous issues and discussions, the api seems to have changed quite a bit.\r\n\r\nThanks.",
    "comments_url": "https://api.github.com/repos/skypjack/entt/issues/1020/comments",
    "author": "mgiacal",
    "comments": [
      {
        "user": "skypjack",
        "created_at": "2023-06-12T13:17:54Z",
        "body": "Do you want to do it with different registries or within the same registry? Because you can also multi-buffer in-place without having to restort to an external registry, as in `.storage<T>()` and `storage<T>(\"other\"_hs)`."
      },
      {
        "user": "mgiacal",
        "created_at": "2023-06-13T10:20:47Z",
        "body": "> Do you want to do it with different registries or within the same registry?\r\n\r\nDifferent registries, I have a use case where I need to keep copies and be able to rollback to some older state.\r\n"
      },
      {
        "user": "skypjack",
        "created_at": "2023-06-14T15:35:57Z",
        "body": "Well, you've a couple of possibilities here. If you want to copy everything at once, the best approach would be using meta or an erased function that you _bind_ to the given component type.\r\nDo you happen to use meta already? Otherwise I can provide an example without it. Let me know. \ud83d\udc4d "
      },
      {
        "user": "mgiacal",
        "created_at": "2023-06-15T10:20:30Z",
        "body": "> Do you happen to use meta already? Otherwise I can provide an example without it. Let me know. \ud83d\udc4d\r\n\r\nI have no idea yet :) Yes please, few examples on different approaches would help me, thanks!"
      },
      {
        "user": "skypjack",
        "created_at": "2023-06-16T15:54:16Z",
        "body": "Ok, so, if you want to only copy some types and know them, it's as easy as:\r\n```cpp\r\nauto &storage = from.storage<T>();\r\nto.insert<T>(src.entt::sparse_set::begin(), src.entt::sparse_set::end(), src.begin());\r\n```\r\nWhere `from` and `to` are the two registries. If you want to use named pools, just use the storage directly in all cases:\r\n```cpp\r\nauto &src = from.storage<T>(\"name\"_hs);\r\nto.storage<T>(\"name\"_hs).insert(src.entt::sparse_set::begin(), src.entt::sparse_set::end(), src.begin());\r\n```\r\nOtherwise, you can do it blindly in a couple of ways. The first option is with meta, that is, a reflection system.\r\nYou can register the meta type on your own or use a storage mixin to do that on creation. Then you can use the meta function to do the copy.\r\nSomething along this line should (almost) work already:\r\n```cpp\r\ntemplate<typename Type>\r\nvoid copy(entt::sparse_set& base, entt::registry &to) {\r\n    auto &src = static_cast<entt::storage_for_t<Type> &>(base);\r\n    to.insert<Type>(src.entt::sparse_set::begin(), src.entt::sparse_set::end(), src.begin());\r\n}\r\n\r\nvoid register_meta() {\r\n    using namespace entt::literals;\r\n    entt::meta<Type>().func<&copy<Type>>(\"copy\"_hs);\r\n    // ...\r\n}\r\n\r\nvoid copy_all(entt::registry &from, entt::registry &to) {\r\n    for (auto [id, storage] : from.storage()) {\r\n        using namespace entt::literals;\r\n        entt::resolve(storage.type()).invoke(\"copy\"_hs, {}, entt::forward_as_meta(storage), entt::forward_as_meta(to));\r\n    }\r\n}\r\n```\r\nFinally, you can obtain something similar without meta too.\r\nJust create a map of type ids and erased functions (like the `copy` function above, it decays to `void(*)(entt::sparse_set&, entt::registry &)` and `Type` disappears, you know), then use it as needed.\r\n\r\nI hope it helped. Let me know if you have any questions. \ud83d\udc4d "
      },
      {
        "user": "mgiacal",
        "created_at": "2023-06-20T10:09:11Z",
        "body": "> I assume this was solved? Let me know if you have any other questions. I'll close the issue in a few days otherwise. Thanks.\r\n\r\nhey, sorry for the late response, and thanks for the explanation. It took me a while to test the suggested methods, specially to make sure also entities are copied. I ended up with something like that:\r\n\r\n```\r\ntemplate <typename T>\r\nstatic void copy_storage(entt::registry& dst, entt::registry& src) {\r\n    auto& storage = src.storage<T>();\r\n    dst.insert<T>(storage.entt::sparse_set::begin(), storage.entt::sparse_set::end(), storage.begin());\r\n}\r\n\r\nto.assign(from.storage<Entity>().cbegin(), from.storage<Entity>().cend(), from.storage<Entity>().size());\r\ncopy_storage<Type1>(to, from);\r\ncopy_storage<Type2>(to, from);\r\n[...]\r\n```\r\n\r\nIf you don't see any problems with that, then I would say it is solved :) thanks again!"
      },
      {
        "user": "skypjack",
        "created_at": "2023-06-20T10:12:07Z",
        "body": "Oh, I see. With version 3.12, entities have their own storage, sorry. Forgot to mention it and the answer happened in the middle of the release. \ud83d\ude05 "
      }
    ]
  },
  {
    "number": 1006,
    "title": "Entity id de/serialize",
    "created_at": "2023-04-13T16:46:57Z",
    "closed_at": "2023-04-14T15:28:24Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/skypjack/entt/issues/1006",
    "body": "How can an entity id be de/serialized in order to send it over network?\r\nI found `entt::to_integral`, which seems to convert the `entt::entity` to the underlying type (guess uint64 is the default).\r\nWhat would be the counterpart, which converts the uint64 back to a `entt::entity`, so it can be get over the registry again?\r\n\r\nBackground: One node has the registry with all it's entities, it sends a network message (containing the `entt::entity`) to another node and this node would respond with the same entt::entity again, on receive of the response, the entt::entity should be get from the registry again.\r\nIt seems like there is some version encoded in the entt::entity as well, so I'm not sure if the to_integral would be enough and how to convert the uint64 back to the corresponding entity.",
    "comments_url": "https://api.github.com/repos/skypjack/entt/issues/1006/comments",
    "author": "immerhart",
    "comments": [
      {
        "user": "skypjack",
        "created_at": "2023-04-14T06:44:04Z",
        "body": "`entt::entity` is just an enum class. `entt::to_integral` is literally a static cast to its underlying type (which is an `std::uint32_t` by default btw). To recreate an identifier from this value, you can use it as `entt::entity entity{value};` and that's it. \ud83d\ude42 "
      }
    ]
  },
  {
    "number": 999,
    "title": "meta_any::invoke dose not change a instance which is passed as reference.",
    "created_at": "2023-03-22T14:29:07Z",
    "closed_at": "2023-03-22T14:47:55Z",
    "labels": [
      "question",
      "solved"
    ],
    "url": "https://github.com/skypjack/entt/issues/999",
    "body": "### Environment\r\n- entt : v3.11.1\r\n- visual studio 2022 : Version17.4.5\r\n\r\n### Issue\r\nI called meta_any::invoke with a function which receive a reference parameter and modify it.\r\n\r\nI read issue #460, so I used std::ref.\r\n\r\nBut the caller's instance value was not changed.\r\n\r\nMy code is as follow.\r\n\r\n``` cpp\r\nstruct Position\r\n{\r\n\tdouble x, y, z;\r\n\r\n\tvoid get(double& tmp)\r\n\t{\r\n\t\ttmp = x;\r\n\t}\r\n};\r\n\r\nBOOST_AUTO_TEST_CASE(Test)\r\n{\r\n\tusing entt::operator\"\"_hs;\r\n\r\n\tentt::meta<::Position>()\r\n\t\t.type(entt::type_id<::Position>().hash())\r\n\t\t.func<&::Position::get>(\"get\"_hs);\r\n\r\n\t::Position data{ 1.0, 2.0, 3.0 };\r\n\tauto any = entt::resolve(entt::type_id<Position>()).from_void(&data);\r\n\r\n\tdouble value;\r\n\tany.invoke(\"get\"_hs, std::ref(value));\r\n\r\n\tBOOST_TEST(value == data.x);\r\n}\r\n```\r\n\r\nIn addition, I executed the code in 460 with a slight modification.\r\nResults were similar.\r\n\r\n``` cpp\r\nBOOST_AUTO_TEST_CASE(MutateByRef)\r\n{\r\n\tusing entt::operator\"\"_hs;\r\n\r\n\tentt::meta<get_last_hour_data>().type(\"/getLastHourData\"_hs).template base<Base>().\r\n\t\ttemplate func<&get_last_hour_data::exec>(\"exec\"_hs).\r\n\t\ttemplate ctor<&get_last_hour_data::create>();\r\n\tauto type = entt::resolve(\"/getLastHourData\"_hs);\r\n\tassert(type);\r\n\r\n\tauto func = type.func(\"exec\"_hs);\r\n\tassert(func);\r\n\r\n\tauto any = type.construct(std::string{});\r\n\tassert(any);\r\n\r\n\tstd::string s;\r\n\tauto any_2 = func.invoke(any, std::ref(s));\r\n\tassert(any_2);\r\n\tBOOST_TEST(\".\" == s);\r\n}\r\n\r\nBOOST_AUTO_TEST_CASE(MutateBySharedPtrRef)\r\n{\r\n\tusing entt::operator\"\"_hs;\r\n\r\n\tentt::meta<get_last_hour_data>().template func<&get_last_hour_data::exec_ptr>(\"exec_ptr\"_hs);\r\n\r\n\tauto type = entt::resolve(\"/getLastHourData\"_hs);\r\n\tassert(type);\r\n\r\n\r\n\tauto func = type.func(\"exec_ptr\"_hs);\r\n\tassert(func);\r\n\r\n\tauto any = type.construct(std::string{});\r\n\tassert(any);\r\n\r\n\tauto s = std::make_shared<std::string>();\r\n\tauto any_2 = func.invoke(any, std::ref(s));\r\n\tassert(any_2);\r\n\tBOOST_TEST(\".\" == *s);\r\n}\r\n```\r\n\r\nThank you for your help in advance.",
    "comments_url": "https://api.github.com/repos/skypjack/entt/issues/999/comments",
    "author": "tetrisplusplus",
    "comments": [
      {
        "user": "Green-Sky",
        "created_at": "2023-03-22T14:34:50Z",
        "body": "you can use `entt::forward_as_meta(value)` instead of `std::ref(value)`"
      }
    ]
  },
  {
    "number": 987,
    "title": "Is there any specific component in my entity?",
    "created_at": "2023-02-25T19:43:05Z",
    "closed_at": "2023-02-26T09:29:50Z",
    "labels": [
      "question",
      "solved"
    ],
    "url": "https://github.com/skypjack/entt/issues/987",
    "body": "Hello, I would like to know how I can find out if there is a certain component in my entity. I know there used to be a \"has\" function, but now I can't find it. Thank you in advance for your answer",
    "comments_url": "https://api.github.com/repos/skypjack/entt/issues/987/comments",
    "author": "0LGL0",
    "comments": [
      {
        "user": "Green-Sky",
        "created_at": "2023-02-26T00:44:43Z",
        "body": "yes, they are now called `.all_of<Component>(e)` and `.any_of<Component>(e)`"
      }
    ]
  },
  {
    "number": 972,
    "title": "entt::basic_registry<uint64_t> causing bugs",
    "created_at": "2023-01-12T15:15:03Z",
    "closed_at": "2023-01-12T15:37:50Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/skypjack/entt/issues/972",
    "body": "Hi, I want to use entt::basic_registry<uint64_t>, and then I can use the id to serialize in my file, and deserialize to the Entity. (I think uint32_t is not enough for the UUID, so I want to use uint64_t and pass straightly to entt like `mRegistry.create(uuid)`)\r\n\r\nBut it causes some bugs in here:\r\n```\r\n  /**\r\n   * @brief Returns the identifier that occupies the given position.\r\n   * @param pos Position of the element to return.\r\n   * @return The identifier that occupies the given position.\r\n   */\r\n  [[nodiscard]] entity_type operator[](const size_type pos) const {\r\n      return begin()[pos];\r\n  }\r\n\r\n  /**\r\n   * @brief Returns the component assigned to the given entity.\r\n   * @param entt A valid identifier.\r\n   * @return The component assigned to the given entity.\r\n   */\r\n  [[nodiscard]] decltype(auto) operator[](const entity_type entt) const {\r\n      return get<Component>(entt);\r\n  }\r\n```\r\n\r\nbug: `error : functions that differ only in their return type cannot be overloaded`\r\n\r\nAs you can see, because the size_type (std::size_t) is same with the entity_type, which is the template argument of basic_registry.\r\n\r\nMy computer is Windows10 64bit environment.\r\n\r\nHow can I fix these and still use entt::basic_registry<uint64_t>? Hope for your help!",
    "comments_url": "https://api.github.com/repos/skypjack/entt/issues/972/comments",
    "author": "hebohang",
    "comments": [
      {
        "user": "skypjack",
        "created_at": "2023-01-12T15:28:05Z",
        "body": "Just define your entity type as:\r\n```cpp\r\nenum class my_entity_type: std::uint64_t {};\r\n```\r\nThen, create your registry as:\r\n```cpp\r\nentt::basic_registry<my_entity_type> registry;\r\n```\r\n\ud83d\udc4d "
      }
    ]
  },
  {
    "number": 963,
    "title": "Get TypeName and not TypeSignature from type_info",
    "created_at": "2022-12-28T07:04:29Z",
    "closed_at": "2023-01-02T12:01:37Z",
    "labels": [
      "question",
      "solved"
    ],
    "url": "https://github.com/skypjack/entt/issues/963",
    "body": "`entt::type_id<ArcEngine::TransformComponent>().name().data();` results in `\"struct ArcEngine::TransformComponent>(void) noexcept\"`\r\n\r\nWhich is the signature I think, is there any way to get a compile time name which in this case should be: `\"ArcEngine::TransformComponent\"` or `\"struct ArcEngine::TransformComponent\"`",
    "comments_url": "https://api.github.com/repos/skypjack/entt/issues/963/comments",
    "author": "GloriousPtr",
    "comments": [
      {
        "user": "skypjack",
        "created_at": "2022-12-28T15:20:37Z",
        "body": "`.name()` returns an `std::string_view`. You should use both `.data()` **AND** `.size()` to get the right portion of the original string.\r\nIf I get it correctly, this isn't what you did. Am I wrong?"
      },
      {
        "user": "GloriousPtr",
        "created_at": "2023-01-02T12:01:37Z",
        "body": "My bad, using `std::string_view.data()` and `std::string_view.size()` or `static_cast<std::string>(std::string_view)` works. Thanks for the help, closing the issue."
      }
    ]
  },
  {
    "number": 948,
    "title": "No more ``.has<T>`` for ``entt::registry``?",
    "created_at": "2022-10-31T11:06:31Z",
    "closed_at": "2022-11-01T14:08:14Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/skypjack/entt/issues/948",
    "body": "Hello!\r\nThanks for this convenient library, handy.\r\nI'd like to know how I can check if an entity has a particular component. I checked some tutorials online and most of them use ``registry.has<T>(entity)`` to check if the entity has component T. However, there is no ``has`` member for registry :/\r\nCould you tell me what I'm doing wrong, maybe the function was deprecated?",
    "comments_url": "https://api.github.com/repos/skypjack/entt/issues/948/comments",
    "author": "AlexandreImperator",
    "comments": [
      {
        "user": "skypjack",
        "created_at": "2022-10-31T11:54:07Z",
        "body": "It's `.any_of<...>` and `.all_of<...>` since long time ago already. \ud83d\ude42 "
      }
    ]
  },
  {
    "number": 937,
    "title": "Collector for construct and destruct?",
    "created_at": "2022-09-23T12:50:14Z",
    "closed_at": "2022-09-23T13:23:27Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/skypjack/entt/issues/937",
    "body": "When using class `entt::observer`, only collector for update signal `entt::collector.update` is available. But we do have three kinds of signals associated with component. Perhaps for some reasons Entt cannot add them?\r\n\r\nIt's not a feature request. Just for curiosity. Maybe don't be worried about adding them.",
    "comments_url": "https://api.github.com/repos/skypjack/entt/issues/937/comments",
    "author": "ShenCiao",
    "comments": [
      {
        "user": "skypjack",
        "created_at": "2022-09-23T13:00:10Z",
        "body": "Poorly named, but that's `.group<T>`. \ud83d\udc4d \r\nOtherwise, you can just use an `entt::storage<void>` and connect it to the registry signals. Then you can construct a view with it as in `entt::basic_view view{storage}` and combine it with other views from the registry as in `view | registry.view<U, V>()`.\r\n"
      },
      {
        "user": "ShenCiao",
        "created_at": "2022-09-23T13:23:27Z",
        "body": "Great thanks. It works exactly same as my expectation. I used to thought `.group<T>` is working exactly same as `entt::group<T>`."
      }
    ]
  },
  {
    "number": 936,
    "title": "About setting value to entt::meta_data",
    "created_at": "2022-09-20T08:46:39Z",
    "closed_at": "2022-09-21T08:47:13Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/skypjack/entt/issues/936",
    "body": "I have a generic buffer(void*) storing an arbitrary value, I just want to set this buffer back to meta_data using memcpy instead of using the strong type setter(`entt::meta_data.set(instance, value)`), I can get the raw data by `entt::meta_data.get(instance).data()`, but copying memory data seems not work. Is there any way to achieve this? Thanks!",
    "comments_url": "https://api.github.com/repos/skypjack/entt/issues/936/comments",
    "author": "hls333555",
    "comments": [
      {
        "user": "skypjack",
        "created_at": "2022-09-20T11:54:40Z",
        "body": "Well, if you **do** want to use `memcpy` (and I'm tempted to discourage this), you've the `void *` for the source and the destination already while the meta type also returns you the _size_ of the underlying type. That is, you've all you need for a `memcpy`.\r\nWhat's exactly the problem? I don't fully get it to be honest. Sorry. My advice is still to use a _setter_ after a call to `meta_type::from_void` if you want to stay in the erased field without incurring the risks of a `memcpy`."
      },
      {
        "user": "hls333555",
        "created_at": "2022-09-20T12:13:15Z",
        "body": "> Well, if you **do** want to use `memcpy` (and I'm tempted to discourage this), you've the `void *` for the source and the destination already while the meta type also returns you the _size_ of the underlying type. That is, you've all you need for a `memcpy`. What's exactly the problem? I don't fully get it to be honest. Sorry. My advice is still to use a _setter_ after a call to `meta_type::from_void` if you want to stay in the erased field without incurring the risks of a `memcpy`.\r\n\r\nThanks for the reply!\r\nIn fact, I do not stick to using `memcpy`, all I want is to set value to data directly using my buffer (void* pointer) without doing a type casting. However, I cannot find `from_void()` and I don't know how to call this. Please help. Thanks a lot!\r\n\r\nAnd here's my test code:\r\n```C++\r\nstruct TestComponent\r\n{\r\n\tfloat FloatVar;\r\n\tTestComponent() = default;\r\n\tTestComponent(const TestComponent&) = default;\r\n};\r\n\r\nint main()\r\n{\r\n        using namespace entt::literals;\r\n\tentt::meta<TestComponent>().type().data<&TestComponent::FloatVar>(\"FloatVar\"_hs);\r\n\r\n\tentt::registry reg;\r\n\tauto entity = reg.create();\r\n\tauto& testComp = reg.emplace<TestComponent>(entity);\r\n\ttestComp.FloatVar = 100.0f;\r\n\tentt::meta_any compInstance{ entt::forward_as_meta(testComp) };\r\n\tconst auto compType = compInstance.type();\r\n\tuint8_t* buffer = new uint8_t[4];\r\n\t*reinterpret_cast<float*>(buffer) = 4.0f;\r\n\tfor (const auto data : compType.data())\r\n\t{\r\n\t\tvoid* d = data.get(compInstance).data();\r\n\t\tfloat bufferV = *reinterpret_cast<float*>(buffer); // Here is 4.0f\r\n\t\tmemcpy(d, buffer, 4); // After memcpy, the FloatVar is still 100.0f\r\n\t}\r\n\tdelete[] buffer;\r\n}\r\n```\r\nEdit: After digging into memory, I have found that the data address returned from `meta_any::data()` is not stable, I actually set to a not-persist data location when calling `memcpy()` . When calling `meta_any::data()` again after `memcpy()`, the address has changed. Is there a way to get the stable data address or any other way to achieve this?"
      },
      {
        "user": "skypjack",
        "created_at": "2022-09-20T13:34:11Z",
        "body": "`meta_type::from_void` is available on `master` but it isn't part of a release yet.\r\nAs for the pointer stability, the address of the underlying element doesn't change unless you move the containing object (in this case, it only changes if the element is embedded, otherwise it's still stable).\r\n"
      },
      {
        "user": "hls333555",
        "created_at": "2022-09-20T13:37:38Z",
        "body": "> `meta_type::from_void` is available on `master` but it isn't part of a release yet. As for the pointer stability, the address of the underlying element doesn't change unless you move the containing object (in this case, it only changes if the element is embedded, otherwise it's still stable).\r\n\r\nThanks! But it seems that I do not explicitly move the TestComponent above, and it still does not work. Could you please help me fix the above code? Thanks!"
      },
      {
        "user": "skypjack",
        "created_at": "2022-09-21T06:43:21Z",
        "body": "You're not telling to meta to return your data member by reference. Therefore, it's returned by copy.\r\nWhat you want is likely the following:\r\n```cpp\r\n.data<&TestComponent::FloatVar, entt::as_ref_t>(\"FloatVar\"_hs)\r\n````\r\nOtherwise `data.get(compInstance)` returns a copy of the underlying object and this:\r\n```cpp\r\nvoid* d = data.get(compInstance).data();\r\n```\r\nIs a free ticket for a dangling pointer. \ud83d\ude42 "
      },
      {
        "user": "hls333555",
        "created_at": "2022-09-21T07:13:00Z",
        "body": "> You're not telling to meta to return your data member by reference. Therefore, it's returned by copy. What you want is likely the following:\r\n> \r\n> ```c++\r\n> .data<&TestComponent::FloatVar, entt::as_ref_t>(\"FloatVar\"_hs)\r\n> ```\r\n> \r\n> Otherwise `data.get(compInstance)` returns a copy of the underlying object and this:\r\n> \r\n> ```c++\r\n> void* d = data.get(compInstance).data();\r\n> ```\r\n> \r\n> Is a free ticket for a dangling pointer. \ud83d\ude42\r\n\r\n\r\nThanks for explanation! However, I have another question, if my float variable uses getter and setter like this:\r\n```C++\r\nfloat GetValue() const { return FloatVar; }\r\nvoid SetValue(float value) { FloatVar = value; }\r\n```\r\nIn this case, I cannot register the data using `entt::as_ref_t`, so that I am not able to use `memcpy` to properly copy my buffer to the data right? I know maybe I can register a by-reference-getter(`float& GetValue() { return FloatVar; }`) to use `entt::as_ref_t`, but is is a bit weird. Is there a better way to solve this? Thanks!"
      },
      {
        "user": "skypjack",
        "created_at": "2022-09-21T07:18:28Z",
        "body": "Well, the policy is **always** available and you can pass `entt::as_ref_t` also when using a setter and getter pair.\r\nAs you correctly pointed out, the problem is your getter that returns the element by copy. Meta cannot really work around it.\r\nIn this case, you're literally saying (as an user): _I'll never ever return this data member by reference and my getter prevents it_.\r\nSo, no, there is not an easy way to get around the will of the final user in general. \ud83d\ude42 "
      }
    ]
  },
  {
    "number": 897,
    "title": "Single component basic_view::get returning tuple",
    "created_at": "2022-06-16T01:37:40Z",
    "closed_at": "2022-06-16T07:54:06Z",
    "labels": [
      "question",
      "solved"
    ],
    "url": "https://github.com/skypjack/entt/issues/897",
    "body": "Is it intended that you can no longer call `registry.view<T>().get(id)` without specifying a component type or index?",
    "comments_url": "https://api.github.com/repos/skypjack/entt/issues/897/comments",
    "author": "james4k",
    "comments": [
      {
        "user": "skypjack",
        "created_at": "2022-06-16T05:59:05Z",
        "body": "Yes, it is. The API of the views (multi and single type) were unified a while ago.\r\nOn the other hand, you've an `operator[]` on the single type view that also takes an entity and returns its component:\r\n```cpp\r\nauto &&value = view[entity];\r\n```"
      }
    ]
  },
  {
    "number": 893,
    "title": "Question : Is it possible to add components (of the same type) while iterating a view?",
    "created_at": "2022-06-05T08:09:42Z",
    "closed_at": "2022-06-07T09:25:13Z",
    "labels": [
      "question",
      "solved"
    ],
    "url": "https://github.com/skypjack/entt/issues/893",
    "body": "Currently, I've created a component (named [ScriptingComponent] ) to contain all user-defined scripts attached to an entity. However, when I was iterating through all of the OnUpdate() functions in scripts with a view, user might need to create entities. During the creation process, [ScriptingComponent] is attached to an entity as default, because one might need to add scripts right afterward. Due to the reason, delay wouldn't be optimal.\r\n\r\nSo, is it possible to add components (of the same type) while iterating a view? Or, are there any other alternatives that I could take?\r\n\r\n(Below is a simplified version of what I'm doing)\r\n```\r\nauto view = registry.view<ScriptingComponent>();\r\nfor (auto e : view)\r\n{\r\n    auto& scriptingComponent = view.get<ScriptingComponent>(e);\r\n    for (Script* script : scriptingComponent.Scripts)\r\n    {\r\n        script->OnUpdate();\r\n    }\r\n}\r\n``` \r\n```\r\nvoid SomeScript::OnUpdate()\r\n{\r\n    // Create an additional entity\r\n    auto entity = registry.create();\r\n    // Adding a component while the view is still alive\r\n    registry.emplace<ScriptingComponent>(entity);\r\n}\r\n```",
    "comments_url": "https://api.github.com/repos/skypjack/entt/issues/893/comments",
    "author": "Oolalalalala",
    "comments": [
      {
        "user": "skypjack",
        "created_at": "2022-06-06T11:36:22Z",
        "body": "Yes, it is. Even more, references to already existing components aren't invalidated if you add new instances.\nThe documentation should contain all the details already. Let me know if something is unclear."
      },
      {
        "user": "Oolalalalala",
        "created_at": "2022-06-07T05:54:36Z",
        "body": "That's what I thought in the first place, too. But there's a bug in my code and I can't quite find it. However, I have reproduced the same error with the following code.\r\n\r\n```\r\n#include <iostream>\r\n#include <unordered_map>\r\n#include \"entt.hpp\"\r\n\r\nentt::registry reg;\r\nclass Script;\r\n\r\nstruct ScriptingComponent\r\n{\r\n\tstd::unordered_map<int, Script*> Scripts;\r\n};\r\n\r\nclass Script\r\n{\r\npublic:\r\n\tvoid OnUpdate()\r\n\t{\r\n\t\tcounter++;\r\n\t\tif (counter % 20 == 0) // Add a new entity per 20 updates\r\n\t\t{\r\n\t\t\tentt::entity e = reg.create();\r\n\t\t\treg.emplace<ScriptingComponent>(e);\r\n\t\t}\r\n\t\tstd::cout << \"Counter = \" << counter << \"\\n\";\r\n\t}\r\nprivate:\r\n\tint counter = 0;\r\n};\r\n\r\nint main()\r\n{\r\n\tentt::entity et = reg.create();\r\n\tauto& scriptingComponent = reg.emplace<ScriptingComponent>(et);\r\n\tscriptingComponent.Scripts.emplace(1, new Script());\r\n\r\n\twhile (1)\r\n\t{\r\n\t\tauto view = reg.view<ScriptingComponent>();\r\n\t\tfor (auto e : view)\r\n\t\t{\r\n\t\t\tauto& scripts = view.get<ScriptingComponent>(e).Scripts;\r\n\t\t\tfor (auto [idx, script] : scripts)\r\n\t\t\t{\r\n\t\t\t\tscript->OnUpdate();\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\nIt seems to work fine if I store the scripts with std::vector, but with std::unordered_map, the program throws an **Access Violation Error**. The unordered_map seems to become invalid when I add [ ScriptingComponent ] to an entity. Am I doing something incorrectly or misunderstanding anything? "
      },
      {
        "user": "Innokentiy-Alaytsev",
        "created_at": "2022-06-07T07:44:46Z",
        "body": "Wouldn't the reference be invalidated due to component pool reallocation during growth? Does this behaviour somehow depend on whether pointer stability is enabled or not?"
      },
      {
        "user": "skypjack",
        "created_at": "2022-06-07T07:54:06Z",
        "body": "Newest releases don't invalidate in this case.\n@Oolalalalala what version of EnTT are you using? This will help to figure it out.\n"
      },
      {
        "user": "Oolalalalala",
        "created_at": "2022-06-07T08:31:18Z",
        "body": "I'm currently using version 3.4.0. So, updating the version would help solve the issue?"
      },
      {
        "user": "skypjack",
        "created_at": "2022-06-07T08:44:04Z",
        "body": "Oh, yeah, transparent pointer stability on creation was added with a later version.\nI'm from mobile and I can't check right away but it's likely v3.7 or v3.8?"
      }
    ]
  },
  {
    "number": 891,
    "title": "Issue emplacing component to entity",
    "created_at": "2022-05-28T23:42:30Z",
    "closed_at": "2022-06-03T15:12:42Z",
    "labels": [
      "question",
      "solved"
    ],
    "url": "https://github.com/skypjack/entt/issues/891",
    "body": "Hi,\r\n\r\nI am getting the following error:\r\n`Assertion failed: (entity_traits::to_version(elem) == entity_traits::to_version(tombstone)), function assure_at_least, file sparse_set.hpp, line 210.`\r\n\r\nwhen I emplace a component to an entity that I know is alive (because I have printed out all the entities that have been \"destroyed\" by calling the method destroy and I didn't see that one on the list). The emplace happens within a view each and the entity that I am emplacing the component to is the current entity.\r\n\r\nI basically only call destroy from one single place in the codebase. I am assuming that this error message refers to a emplacing a component to an invalid/tombstoned entity, is that right? if so or not, what could be another situation when this message is shown?\r\nP.S. I am not using the in-place delete functionality.\r\n\r\nThanks",
    "comments_url": "https://api.github.com/repos/skypjack/entt/issues/891/comments",
    "author": "grimaldini",
    "comments": [
      {
        "user": "skypjack",
        "created_at": "2022-05-29T07:49:57Z",
        "body": "Can I ask you what version of EnTT is it? I can't find this line of code anymore. \ud83d\ude05 \r\nAnyway, at a first glance, this is what replaced it:\r\n```cpp\r\nENTT_ASSERT(elem == null, \"Slot not available\");\r\n```\r\nIt states that the set already contains the component. So, roughly speaking, you're adding a component to an entity that has an instance of the same type already.\r\nYou can try to assert before invoking `emplace` to confirm it."
      },
      {
        "user": "grimaldini",
        "created_at": "2022-05-29T12:38:04Z",
        "body": "I am based off commit a03b88e0eb679ca0fbb79d9c54293e772b4f4a93 \"dense_hash_[map/set]: suppress super annoying warnings\".\r\n\r\n> So, roughly speaking, you're adding a component to an entity that has an instance of the same type already.\r\n\r\nSo, you are saying that the entity already has the same component added to it?"
      },
      {
        "user": "skypjack",
        "created_at": "2022-05-29T13:11:52Z",
        "body": "It looks so from the error, yeah. Hard to confirm 100% without a repro though."
      },
      {
        "user": "grimaldini",
        "created_at": "2022-05-29T14:47:51Z",
        "body": "Ok, that makes sense, I was able to find the issue with your explanation, thanks. Quick question, do you normally use `emplace_or_replace`. I feel that it's hard to keep track of all system dependencies and the components that each add, especially with a large set of systems."
      },
      {
        "user": "skypjack",
        "created_at": "2022-05-29T15:24:01Z",
        "body": "Actually, I don't. The last version of EnTT offers the possibility of getting the storage from a view and this makes passing the registry around pointless. Moreover, the whole library is moving towards a model where you can have storage classes and views but no registry at all if you like."
      },
      {
        "user": "grimaldini",
        "created_at": "2022-05-30T22:00:48Z",
        "body": "Interesting, do you have a post or doc with more details of the model where EnTT is headed to?"
      },
      {
        "user": "skypjack",
        "created_at": "2022-06-01T10:59:12Z",
        "body": "I should but there is not actually. If you have any questions, feel free to drop them here and I'll be glad to answer them."
      }
    ]
  },
  {
    "number": 886,
    "title": "What are entity versions used for aside from marking tombstones?",
    "created_at": "2022-05-10T04:03:41Z",
    "closed_at": "2022-05-12T09:58:27Z",
    "labels": [
      "question",
      "solved"
    ],
    "url": "https://github.com/skypjack/entt/issues/886",
    "body": "I have been reading through the documentation and the source for entities and i am a bit confused on what are entity versions used for except for marking tombstones. What i understand is that tombstone entities are identified by a special version number, and that when an entity is removed from a registry the version is incremented (or set explicitly). \r\n\r\nWhat are other possible uses for entity versions (both within the library and in general)?",
    "comments_url": "https://api.github.com/repos/skypjack/entt/issues/886/comments",
    "author": "switch-blade-stuff",
    "comments": [
      {
        "user": "skypjack",
        "created_at": "2022-05-10T09:50:47Z",
        "body": "Identifiers are recycled in `EnTT` since day 0. That is, when you destroy an entity, its version is increased by 1.\r\nImagine to store identifiers aside for some reasons now. For example, in a quad tree. How do you know if that specific entity is still the same or a _recycled_ version with a completely different set of components?\r\nThe version helps with it. You can compare versions and find that the two identifers are not the same element, even though their entity part is the same."
      }
    ]
  },
  {
    "number": 835,
    "title": "Is there a way to deduce the unupdated (the opposite of entt::observer)?",
    "created_at": "2022-02-02T12:39:34Z",
    "closed_at": "2022-02-10T08:26:52Z",
    "labels": [
      "question",
      "solved"
    ],
    "url": "https://github.com/skypjack/entt/issues/835",
    "body": "So far I'm digging the observer design but there's a case where I also need to iterate the unupdated. Is there a way to know if an entity has been updated or not while iterating the entire view?\r\n\r\nI know this seems really strange in hindsight but I just don't want to populate my classes with unnecessary variables and sometimes I only want to iterate the unupdated.",
    "comments_url": "https://api.github.com/repos/skypjack/entt/issues/835/comments",
    "author": "Sonolil",
    "comments": [
      {
        "user": "skypjack",
        "created_at": "2022-02-02T13:22:35Z",
        "body": "There is not actually. If you don't update it, nothing happens. How can one track that _nothing has happened_? \ud83e\udd14 \r\nThough, you can maybe use the `is_updated` tag as a filter in a view and therefore get the non-updated entities this way."
      },
      {
        "user": "Sonolil",
        "created_at": "2022-02-02T14:28:09Z",
        "body": "Hi, sorry again but this is a related question. Is there a remove_if algorithm equivalent for entt? A passage in the sorting section implies I can create a custom sort function object so there must be a way to use this to send all deletable elements to the back?"
      },
      {
        "user": "skypjack",
        "created_at": "2022-02-02T14:33:32Z",
        "body": "Mmm it sounds to me like an XY-problem. Can I ask you what you're trying to achieve? Maybe there is a more EnTT-y way of doing it."
      },
      {
        "user": "Sonolil",
        "created_at": "2022-02-02T15:02:44Z",
        "body": "Not much really, I actually just got it done. I am reloading certain components based on whether my file is modified or not. I serialize a registry and a map of entities, with relative path to my root folder as its key. I deserialize the registry and map, iterate through the root folder and update entities with existing keys in my map comparing file write time and other data, then reiterate the file data view to reload modified file data to my components and remove the none-existing ones. (I know this sort of duplicates data in my registry but it's a cost I'm willing to pay)\r\n\r\nI couldn't find reference for the is_updated tag so I just attached a filedata component which also contains the write time and other info. This was all fine except I needed to detect erased files as well and destroy entities with invalid filepath. I was just hoping I could do ranged destruction on the eraseables as if with std::removed_if algorithm. I just found out I can destroy while iterating through my views so this isn't urgent but I still wonder if this is possible. \r\n\r\n"
      },
      {
        "user": "skypjack",
        "created_at": "2022-02-03T07:33:59Z",
        "body": "Oh, no, sorry, the `is_updated` component doesn't exist, it was just a hint on a possible solution. \ud83d\ude05 \r\nI see what you want now. `remove_if` just iterates the container and _moves_ things to the end, then you've to use `erase`. With a view, you combine the two as you did. That's perfectly fine."
      },
      {
        "user": "Sonolil",
        "created_at": "2022-02-04T00:45:47Z",
        "body": "Oh, I didn't realize that was possible, thank you! I was thinking of using the algorithm on the pool itself rather than the view entities (especially since the entities effectively only have one component attached). Does the ranged destroy optimize itself in this regard? I've never used it before"
      },
      {
        "user": "skypjack",
        "created_at": "2022-02-04T07:05:41Z",
        "body": "Yeah, range functionalities perform better in general, especially if you use iterators from storage classes or single type views (because of an internal machinery that helps to further optimize this case)."
      }
    ]
  },
  {
    "number": 770,
    "title": "[Question] How to discard a group after use?",
    "created_at": "2021-08-25T06:31:09Z",
    "closed_at": "2021-08-25T15:14:55Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/skypjack/entt/issues/770",
    "body": "Hi, another beginner's question here~ I'm trying to use groups inside a function, where I need to process some combinations of components using multiple groups, and I got a runtime assertion error.\r\n```c++\r\nvoid Foo() {\r\n    ....\r\n    \r\n    if (auto group = registry.group<A, B>(); !group.empty()) {\r\n        auto& b = group.get<B>(group.front());\r\n        ....\r\n    }\r\n\r\n    if (ctx.lightmask.test(0)) {\r\n        auto group = registry.group<C, A>();\r\n        group.sort([](const entt::entity a, const entt::entity b) { return a < b; });\r\n        ....\r\n    }\r\n}\r\n```\r\nAs per the documentation, these are conflicting groups and the second one is going to fail, so before creating the second group, I need to somehow discard the first group, but I couldn't find a function for that. I tried to wrap them inside an if-else block so that each group has a local scope, but it seems that the first group is still alive in the registry after it goes out of scope, I wonder if there's a way to manually clean it up? or perhaps the way I'm using groups is not correct?",
    "comments_url": "https://api.github.com/repos/skypjack/entt/issues/770/comments",
    "author": "neo-mashiro",
    "comments": [
      {
        "user": "skypjack",
        "created_at": "2021-08-25T08:30:23Z",
        "body": "Currently, you cannot and it's mostly on purpose. Groups aren't meant to be built and destroyed continuously at runtime. Quite the opposite actually, they are meant to optimize a specific access pattern in the long run."
      },
      {
        "user": "neo-mashiro",
        "created_at": "2021-08-25T15:14:55Z",
        "body": "> \r\n> \r\n> they are meant to optimize a specific access pattern in the long run.\r\n\r\nOK I got your point, so a group is like a rearranged owning subset of the registry, which is somewhat analogous to the RAM of CPU. Groups are intended to be setup once and used repeatedly, where later access can be made blazingly fast, but views do not take ownership so can be considered more \"temporary\" than groups. Is my understanding correct?\r\n\r\nI've re-read the groups part in the documentation and it's now making more sense to me. I removed the ownership of A by using `registry.group<B>(A)` and `registry.group<C>(A)` and the assertion passed, thanks for your clarification!"
      }
    ]
  },
  {
    "number": 762,
    "title": "How to access key-only associative container's values with meta?",
    "created_at": "2021-08-15T10:41:11Z",
    "closed_at": "2021-08-15T20:12:46Z",
    "labels": [
      "question",
      "solved"
    ],
    "url": "https://github.com/skypjack/entt/issues/762",
    "body": "Hi!\r\n\r\nI am having issues accessing values of an `std::set` that is stored in a `meta_any` object.\r\nHow i understand it, when iterating over an associative container i get a `pair` where the first item is the key, and the second one is the value.\r\nWhen iterating over a set (which is not empty, i have checked with a debugger) which is a key only type, the returned key has the correct type (`std::string` in this case) but the try_cast returns a nullptr. Am i doing something wrong?",
    "comments_url": "https://api.github.com/repos/skypjack/entt/issues/762/comments",
    "author": "switch-blade-stuff",
    "comments": [
      {
        "user": "skypjack",
        "created_at": "2021-08-15T14:46:08Z",
        "body": "Keys in a set are read-only and so are the meta keys returned by an associative container that wraps a set.\nTherefore, what you want is probably:\n```cpp\npair.first.try_cast<const std::string>()\n```\nUsing the non-const counterpart returns a null pointer instead.\nIt works the same with `cast` if you use reference types:\n```cpp\npair.first.cast<const std::string &>()\n```\nOtherwise, you can use `cast` with a non-reference type which creates a copy of the contained element:\n```cpp\npair.first.cast<std::string>()\n```\nLet me know if it works. :+1:"
      }
    ]
  },
  {
    "number": 753,
    "title": "[Question] Cache the result of the `get()` function?",
    "created_at": "2021-08-05T23:22:14Z",
    "closed_at": "2021-08-06T07:19:45Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/skypjack/entt/issues/753",
    "body": "Sorry for the basic question from a beginner, but I'd like to know about the price of calling `registry.get<T>()`. I have a `Entity` class like this:\r\n\r\n```c++\r\nclass Entity {\r\n  private:\r\n    std::string name = \"\";\r\n    entt::entity id = entt::null;\r\n    entt::registry* registry;\r\n\r\n  public:\r\n    Entity(const std::string& name, entt::entity id, entt::registry* registry);\r\n    ~Entity() {}\r\n\r\n    template<typename T>\r\n    T& GetComponent() {\r\n        CORE_ASERT(registry->all_of<T>(id), \"Component T not found in {0}!\", name);\r\n        return registry->get<T>(id);\r\n    }\r\n}\r\n```\r\n\r\nSince I come from Unity, whose `GetComponent()` method is known to be slow and not supposed to be invoked every frame, I'm thinking about caching the result of `registry->get<T>()` so that subsequent calls won't need to query the registry again. While caching is easy outside the class (on caller's side), it's a bit difficult to cache inside the class with generics (I'm still new to C++), and I wonder if this is at all necessary......\r\n\r\nCan you tell me a bit more about the `get()` function? Does it check `registry->all_of<T>()` automatically? Is it costly? Also, I don't understand why the documentation says `get_or_emplace()` is slightly faster. Thank you~!",
    "comments_url": "https://api.github.com/repos/skypjack/entt/issues/753/comments",
    "author": "neo-mashiro",
    "comments": [
      {
        "user": "skypjack",
        "created_at": "2021-08-06T06:47:19Z",
        "body": "The underlying pool in EnTT is based on sparse sets and getting an element is a O(1) lookup.\r\nCaching would be still faster, granted, though pointers aren't stable unless you enable pointer stability on all pools (available since 3.8.x). Also, I confirm that `get` uses `all_of` (well, sort of actually, but let's assume this is the case) under the hood to assert in case the entity doesn't own the component.\r\n`get_or_emplace` is faster than the following:\r\n```cpp\r\nif(registry.all_of<T>(e)) {\r\n    return registry.get<T>(e);\r\n} else {\r\n    return registry.emplace<T>(e);\r\n}\r\n```\r\nThis is due to the fact that the pool lookup takes place only once. Probably not something you'll ever be able to measure but technically speaking it's slightly faster."
      }
    ]
  },
  {
    "number": 752,
    "title": "How to Sort Entities",
    "created_at": "2021-08-05T11:31:53Z",
    "closed_at": "2021-08-05T20:21:23Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/skypjack/entt/issues/752",
    "body": "I'm using EnTT for my game and I'm trying to render some objects in a particular order, specifically by their distance to the camera. I need to create a view in which the entities are in a specific order. I read  the docs and I wrote this:\r\n\r\n```\r\nvoid systems::piece_render(entt::registry& registry, entt::entity hovered_entity, entt::entity camera_entity) {\r\n    auto& camera_transform = registry.get<TransformComponent>(camera_entity);\r\n\r\n    auto func = [&camera_transform](const TransformComponent& lhs, const TransformComponent& rhs) {\r\n        float distance1 = glm::length(camera_transform.position - lhs.position);\r\n        float distance2 = glm::length(camera_transform.position - rhs.position);\r\n        return distance1 < distance2;\r\n    };\r\n\r\n    registry.sort<TransformComponent>(func);\r\n\r\n    auto view = registry.view<TransformComponent, MeshComponent,\r\n                              MaterialComponent, TextureComponent,\r\n                              OutlineComponent, PieceComponent>();\r\n\r\n    for (entt::entity entity : view) {\r\n        auto [transform, mesh, material, textures, outline, piece] = view.get(entity);\r\n        // Render code here\r\n    }\r\n}\r\n```\r\n\r\nBut it doesn't seem to do what I want. Looks like the objects are still rendered like before. I think I'm using `sort` wrongly. **The docs aren't clear to me for some reason**. My question is: How can I achieve what I want?",
    "comments_url": "https://api.github.com/repos/skypjack/entt/issues/752/comments",
    "author": "SimonMaracine",
    "comments": [
      {
        "user": "skypjack",
        "created_at": "2021-08-05T12:30:41Z",
        "body": "You probably want to add a `view.use<TransformComponent>()` before iterating the view. It guarantees that the order of your `TransformComponent` is respected."
      },
      {
        "user": "OverShifted",
        "created_at": "2021-08-09T03:45:11Z",
        "body": "@skypjack Who fast (or slow) `registry.sort` is? Since it is called every frame."
      },
      {
        "user": "skypjack",
        "created_at": "2021-08-09T05:55:57Z",
        "body": "It sorts a sparse set. Slower than sorting a vector because it also has to update the sparse array. What remains is a single packed array that is sorted using `std::sort` or any other function you pass to it instead (it's configurable, probably an insertion sort is faster in many cases but this really depends on the application).\nEverything happens in-place. No allocations nor anything else. I also wrote an extensive post on the blog about this topic.\n\nI use it in real world applications, the reason for which it's there \nThis doesn't make it blazing fast automatically but at least confirms that it's not there just because. :)"
      },
      {
        "user": "OverShifted",
        "created_at": "2021-08-09T08:04:31Z",
        "body": "When I want to render my objects; I use a vector to save vertex buffer data before rendering them using a batch renderer.\r\nIs sorting that vector is faster than sorting entities?"
      },
      {
        "user": "skypjack",
        "created_at": "2021-08-09T08:10:42Z",
        "body": "Well, sorting a pool literally sorts a vector (similar cost) and updates the sparse array associated with it (additional cost).\nIt doesn't matter how small the second cost is, its existence is already the answer you're looking for."
      },
      {
        "user": "sourabh-gupta-dev",
        "created_at": "2022-03-31T16:07:29Z",
        "body": "I have a similar use case of sorting entities. But I am not able to use the view.use<Comp>() function.\r\nIt keeps giving me error\r\n```\r\nNo member named 'use' in 'entt::basic_view<entt::entity, entt::get_t<Shutter::SortComponent>, entt::exclude_t<>>'\r\n```\r\n\r\nI am using v3.9.0 and below is my usage.\r\n```\r\nm_Registry.sort<SortComponent>([](const auto &lhs, const auto &rhs) {\r\n            return lhs.sortOrder > rhs.sortOrder;\r\n        }, entt::insertion_sort());\r\n        auto view = m_Registry.view<SortComponent>();\r\n        view.use<SortComponent>();\r\n```\r\nPlease help me with this issue."
      },
      {
        "user": "skypjack",
        "created_at": "2022-03-31T17:00:34Z",
        "body": "@sourabh-gupta-dev `view::use` is only available for multi-type views. It tells to the view what pool to use to drive the iteration.\r\nIt wouldn't make much sense for a single type view actually since you don't really have a choice there. \ud83d\ude05 "
      }
    ]
  },
  {
    "number": 708,
    "title": "What is the correct to add new components during iteration?",
    "created_at": "2021-05-20T08:51:48Z",
    "closed_at": "2021-05-20T09:09:46Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/skypjack/entt/issues/708",
    "body": "Hi.\r\n\r\nI know that after adding new components duration iteration, the reference will be invalid. But I don't know what is the correct way to do it. Here is an example.\r\n\r\n```c++\r\nauto view = registry.view<const Com>();\r\nfor (auto [parent, c] : view.each()) {\r\n    for (auto i = 0u; i < c.repeat; ++i) {\r\n        const auto child = registry.create();\r\n        const auto new_c = Com(c.value);\r\n        registry.emplace<Com>(child, new_c);\r\n    }\r\n}\r\n```\r\n\r\nShould I generate all `new_c` before emplacing like this?\r\n\r\n```c++\r\nauto view = registry.view<const Com>();\r\nfor (auto [parent, c] : view.each()) {\r\n    std::vector<Com> vec;\r\n    for (auto i = 0u; i < c.repeat; ++i) {\r\n        vec.push_back(Com(c.value)); \r\n    }\r\n    for (auto i = 0u; i < c.repeat; ++i) {\r\n        const auto child = registry.create();\r\n        registry.emplace<Com>(child, vec[i]);\r\n    }\r\n}\r\n```\r\n\r\nThank you.",
    "comments_url": "https://api.github.com/repos/skypjack/entt/issues/708/comments",
    "author": "FishHawk",
    "comments": [
      {
        "user": "skypjack",
        "created_at": "2021-05-20T09:03:18Z",
        "body": "Only the currently iterated reference is invalidated. If you don't plan to use it (and you're not from what I see), you don't have to worry about it.\r\nAlso, as a side note, the next release will have pointer stability when emplacing. You can already try it on branch `experimental`."
      }
    ]
  },
  {
    "number": 706,
    "title": "Questions about resource_handle",
    "created_at": "2021-05-17T05:17:48Z",
    "closed_at": "2021-07-20T14:36:47Z",
    "labels": [
      "question",
      "solved"
    ],
    "url": "https://github.com/skypjack/entt/issues/706",
    "body": "1. Is there a way I can clear the reference of resource_handle just like std::shared_ptr::reset?\r\n2. There seems no == operator overloading, how can I compare two resource_handles?\r\nThanks!",
    "comments_url": "https://api.github.com/repos/skypjack/entt/issues/706/comments",
    "author": "hls333555",
    "comments": [
      {
        "user": "skypjack",
        "created_at": "2021-05-17T06:48:26Z",
        "body": "1. `handle = {}`?\r\n2. Do you want to compare the contained objects or their addresses?\r\n    ```cpp\r\n    bool obj = *h1 == *h2;\r\n    bool addr = std::addressof(*h1) == std::addressof(*h2);\r\n    ```"
      },
      {
        "user": "hls333555",
        "created_at": "2021-05-17T10:44:19Z",
        "body": "I want to fully simulate what std::shared_ptr does so I choose to compare their addresses. Here's what I write:\r\n```\r\ntemplate<typename T>\r\nbool operator==(const entt::resource_handle<T>& lhs, const entt::resource_handle<T>& rhs)\r\n{\r\n    return std::addressof(*lhs) == std::addressof(*rhs);\r\n}\r\n```\r\nBut this will cause an assertion if any of them has null resource assigned. Any ideas? Thanks!"
      },
      {
        "user": "skypjack",
        "created_at": "2021-05-17T10:46:38Z",
        "body": "Handles convert to bool. You can check if both are valid before getting the elements."
      },
      {
        "user": "hls333555",
        "created_at": "2021-05-17T11:06:47Z",
        "body": "> Handles convert to bool. You can check if both are valid before getting the elements.\r\n\r\nSo I just modify like this\r\n```\r\ntemplate<typename T>\r\nbool operator==(const Asset<T>& lhs, const Asset<T>& rhs)\r\n{\r\n    if (lhs && rhs) return std::addressof(*lhs) == std::addressof(*rhs);\r\n    if (!lhs && !rhs) return true;\r\n    return false;\r\n}\r\n```"
      },
      {
        "user": "skypjack",
        "created_at": "2021-05-18T06:10:12Z",
        "body": "Yeah, exactly, something like:\r\n```cpp\r\nreturn (!lhs && !rhs) || (lhs && rhs && std::addressof(*lhs) == std::addressof(*rhs));\r\n```"
      },
      {
        "user": "hls333555",
        "created_at": "2021-06-05T09:20:12Z",
        "body": "Hey~\r\nIs there a way I can assign `entt::resource_handle<Derived>` to `entt::resource_handle<Base>`?\r\n\r\nI have an abstract asset class called IAsset, and a derived class called SceneAsset. I want to implement a getter somewhere to get the appropriate asset with a virtual function like below:\r\n```C++\r\nvirtual entt::resource_handle<IAsset> GetAsset() = 0;\r\n```\r\nBut I cannot get the following to work (it says \"no suitable conversion exists\"):\r\n```C++\r\nvirtual entt::resource_handle<IAsset> GetAsset() override { return m_SceneAsset; /* Its type is entt::resource_handle<SceneAsset> */ }\r\n```\r\n\r\nThanks!"
      },
      {
        "user": "skypjack",
        "created_at": "2021-06-05T21:06:27Z",
        "body": "There is no built-in method to do that with the default implementation of a handle.\r\nHowever, it looks like a good addition. I invite you to create a new issue for that. \ud83d\ude42 \r\n\r\nThat said, in the meantime you can get around it by specializing the handle class.\r\nIt's more cumbersome than a built-in solution but it can get the job done if you can't wait."
      },
      {
        "user": "skypjack",
        "created_at": "2021-06-22T16:55:15Z",
        "body": "Can you tell me if the conversion functions available on branch `wip` work as expected? Thanks."
      },
      {
        "user": "GavinNL",
        "created_at": "2021-07-02T14:52:40Z",
        "body": "Hi @skypjack , is it possible to add a function to resource_handle to return the shared_ptr's `use_count()`?\r\n\r\n"
      },
      {
        "user": "hls333555",
        "created_at": "2021-09-25T04:13:27Z",
        "body": "> Can you tell me if the conversion functions available on branch `wip` work as expected? Thanks.\r\n\r\n\r\n> Hey~\r\n> Is there a way I can assign `entt::resource_handle<Derived>` to `entt::resource_handle<Base>`?\r\n> \r\n> I have an abstract asset class called IAsset, and a derived class called SceneAsset. I want to implement a getter somewhere to get the appropriate asset with a virtual function like below:\r\n> \r\n> ```c++\r\n> virtual entt::resource_handle<IAsset> GetAsset() = 0;\r\n> ```\r\n> \r\n> But I cannot get the following to work (it says \"no suitable conversion exists\"):\r\n> \r\n> ```c++\r\n> virtual entt::resource_handle<IAsset> GetAsset() override { return m_SceneAsset; /* Its type is entt::resource_handle<SceneAsset> */ }\r\n> ```\r\n> \r\n> Thanks!\r\n\r\nI have tested this conversion. It works pretty well in 3.8.0_single_include file! Thanks!\r\nCould you please add another conversion function like std::dynamic_pointer_cast<> as down_cast is also important to me. Thanks a lot!"
      },
      {
        "user": "skypjack",
        "created_at": "2021-09-25T16:21:59Z",
        "body": "I strongly suggest to open a dedicated issue for this @hls333555 I can't promise I won't forget about it otherwise. \ud83d\ude05 "
      }
    ]
  },
  {
    "number": 691,
    "title": "What happened to entt::registry.has?",
    "created_at": "2021-04-11T06:50:06Z",
    "closed_at": "2021-04-11T22:28:37Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/skypjack/entt/issues/691",
    "body": "I used to be able to use registry.has, and it is still present in the single include. However, in the most updated version of entt, no such function exists. I can't seem to find an alternative, does anyone know what it is?",
    "comments_url": "https://api.github.com/repos/skypjack/entt/issues/691/comments",
    "author": "hazeled",
    "comments": [
      {
        "user": "Green-Sky",
        "created_at": "2021-04-11T14:27:48Z",
        "body": "It has been renamed to `all_of`.\r\n\r\n@skypjack I told you to deprecate it first! :'D\r\n\r\nedit: @hazeled this is related to #690 , next time search for issues first ^^"
      }
    ]
  },
  {
    "number": 645,
    "title": "Component using aligned type like Eigen::Matrix3d",
    "created_at": "2021-01-28T19:05:57Z",
    "closed_at": "2021-01-28T22:48:50Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/skypjack/entt/issues/645",
    "body": "Hello! I am looking into using entt and want to know about storing an aligned type, like an Eigen::Matrix3d, as a component type in an entt::registry. I have seen multiple mentions that the only requirement for a component is that the type is movable. But eigen alignment issues have been a pain for me (outside of entt) for a while, so I just wanted to check and see about the consequences of using an aligned type as a component.\r\n\r\nThanks for making entt available!",
    "comments_url": "https://api.github.com/repos/skypjack/entt/issues/645/comments",
    "author": "pwm1234-sri",
    "comments": [
      {
        "user": "sunnlok",
        "created_at": "2021-01-28T19:49:48Z",
        "body": "AFAIK the master branch of eigen as well as the next version of it should support cpp17s aligned new which should solve this problem in general with containers.\r\nOtherwise you would need to write a custom pool implementation for your eigen types. "
      },
      {
        "user": "skypjack",
        "created_at": "2021-01-28T22:01:26Z",
        "body": "Indeed. The rule of thumb is: if it works in an `std::vector`, it works with the default pool of `EnTT`.\r\nOtherwise, `EnTT` offers the possibility to design your own pool for all types or on a per-type and per-traits basis.\r\nSo, one way or the other, you should be able to get it work."
      }
    ]
  },
  {
    "number": 614,
    "title": "Search by Component",
    "created_at": "2020-12-19T17:14:55Z",
    "closed_at": "2020-12-26T15:58:21Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/skypjack/entt/issues/614",
    "body": "I'm reimplementing a certain game, and try to map its logical system to entt. In this system, most objects (but not all) have a certain ID, which is used for example for accessing them through scripts. I realized this ID through an additional component, and now my question is what is the \"standard\" way of searching an entity by a component?",
    "comments_url": "https://api.github.com/repos/skypjack/entt/issues/614/comments",
    "author": "Nostritius",
    "comments": [
      {
        "user": "Green-Sky",
        "created_at": "2020-12-19T17:23:19Z",
        "body": "This sounds very inefficient...\r\nI would create a separate data-structure for GAME_ID -> ENTT_ID lookup, like a unordered_map."
      },
      {
        "user": "skypjack",
        "created_at": "2020-12-19T22:18:35Z",
        "body": "Searching an entity by a component or by a value of a data member in a component?\r\nBecause in the first case you can just use a `view`."
      },
      {
        "user": "Nostritius",
        "created_at": "2020-12-23T16:46:47Z",
        "body": "I'm searching for an component by value. View seems to work fine, thanks. Just out of interest, since I found entt::to_entity, which works on the component by reference, why is there no method like this which works by value?"
      },
      {
        "user": "skypjack",
        "created_at": "2020-12-23T22:36:31Z",
        "body": "`to_entity` relies on pointer arithmetic, it dosen't iterate a view. You can't do the same if searching by value. That's all. \ud83d\ude42 "
      }
    ]
  },
  {
    "number": 567,
    "title": "size() of multi component view seems wrong?",
    "created_at": "2020-10-09T10:31:11Z",
    "closed_at": "2020-10-09T13:05:30Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/skypjack/entt/issues/567",
    "body": "```c++\r\n#include <entt/entt.hpp>\r\n\r\nstruct A {};\r\nstruct B {};\r\nstruct C {};\r\n\r\nint main() {\r\n   entt::registry registry;\r\n\r\n   {\r\n      auto A_and_B = registry.create();\r\n      registry.emplace<A>(A_and_B);\r\n      registry.emplace<B>(A_and_B);\r\n   }\r\n   {\r\n      auto A_and_C = registry.create();\r\n      registry.emplace<A>(A_and_C);\r\n      registry.emplace<C>(A_and_C);\r\n   }\r\n\r\n   const auto before = registry.view<A, B>().size(); // 1\r\n   {\r\n      auto only_B = registry.create();\r\n      registry.emplace<B>(only_B);\r\n   }\r\n   const auto after = registry.view<A, B>().size(); // 2\r\n\r\n   return 0;\r\n}\r\n```\r\nAs I understand it, multi component views mean entities that contain *all* the components. Quoting from `view.hpp`: \"Multi component views iterate over those entities that have at least all the given components in their bags\". So why is the view size two when there was no second entity added with both A and B? I'm probably understanding something wrong.",
    "comments_url": "https://api.github.com/repos/skypjack/entt/issues/567/comments",
    "author": "s9w",
    "comments": [
      {
        "user": "skypjack",
        "created_at": "2020-10-09T10:34:29Z",
        "body": "In fact, it's a _size hint_ and it has already been renamed to `size_hint` for the next version, to avoid errors.\r\nThe view estimates only the maximum amount of entities that can be returned during an iteration."
      },
      {
        "user": "s9w",
        "created_at": "2020-10-09T10:36:30Z",
        "body": "I see, so is there a way to get the actual number of such entities other than iterating?"
      },
      {
        "user": "skypjack",
        "created_at": "2020-10-09T11:55:22Z",
        "body": "Groups know the exact number of multi-type sets. Multi-type views do not, unless ofc you iterate them. Single type views know it instead, for obvious reasons."
      }
    ]
  },
  {
    "number": 563,
    "title": "Is it possible to create a view from begin/end iterators?",
    "created_at": "2020-10-02T16:29:41Z",
    "closed_at": "2020-10-04T06:32:48Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/skypjack/entt/issues/563",
    "body": "I have a vector of entities that are a subset of all entities within my registry. These entities contain `>=1` component I am interested in viewing. Is this code possible?\r\n\r\n```C++\r\nstd::vector<entt::entity> ids;\r\n...\r\nauto begin = std::begin(ids);\r\nauto end   = std::end(ids);\r\n\r\n// Does something like this exist? (constructing a view from a pair of iterators)\r\nauto view = registry.view<ComponentA, ComponentB>(begin, end);\r\n```\r\n\r\nI know it's possible to do this manually like so: \r\n```C++\r\nfor (auto const id : ids)\r\n{\r\n    auto const& ca = registry.get<ComponentA>(id);\r\n    auto const& cb = registry.get<ComponentB>(id);\r\n    ...\r\n}\r\n```\r\n\r\nHowever this feels like I'm programming at a lower level, instead of programming what I want to do, it feels like I'm programming how to do it. I'm sorry again if I missed a way to do this that's spelled out in the wiki / inline documentation, if it's there I haven't been able to find it.\r\n\r\nThanks :)",
    "comments_url": "https://api.github.com/repos/skypjack/entt/issues/563/comments",
    "author": "bjadamson",
    "comments": [
      {
        "user": "skypjack",
        "created_at": "2020-10-03T16:59:04Z",
        "body": "Hit there,\n\nIt's not possible actually.\nI think the main problem is that the view cannot be sure that those entities really have the components.\n\nWhy don't you just iterate the vector and get the components from the view instead? Something like:\n```\nauto view = registry.view<Component A, ComponentB>();\n\nfor(auto id: ids) {\n    auto [ca, cb] = view.get(id);\n    // ...\n}\n```"
      }
    ]
  },
  {
    "number": 492,
    "title": "std::hash is not specialized for entt::hashed_string",
    "created_at": "2020-05-22T16:49:02Z",
    "closed_at": "2020-05-22T17:12:46Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/skypjack/entt/issues/492",
    "body": "Hi there,\r\n\r\nas far as I can tell, there is no specialization of `std::hash` for `entt::hashed_string`, making the simple construction of an `std::unordered_map<hashed_string, T>` impossible without defining a custom hash functor. Is this an oversight or intended? And if it is the latter, why?\r\n\r\nThanks in advance,\r\nScarabytes",
    "comments_url": "https://api.github.com/repos/skypjack/entt/issues/492/comments",
    "author": "Scarabytes",
    "comments": [
      {
        "user": "Innokentiy-Alaytsev",
        "created_at": "2020-05-22T17:03:34Z",
        "body": "Hello!\r\n\r\nKeep in mind that `entt::hashed_string` doesn't store the string data - it only references it. I don't know if it's important for your use case or not. I would just use `entt::hashed_string::value()` as a key in the dictionary."
      },
      {
        "user": "skypjack",
        "created_at": "2020-05-22T17:06:34Z",
        "body": "It's intended actually. `hashed_string` _converts_ to `entt::id_type`, that is, an integral type.\r\nSo, you should rather use `std::unordered_map<entt::id_type, T>` and generate the integral representation both at compile-time or runtime according with your needs.\r\n\r\n@Innokentiy-Alaytsev \r\n>doesn't store the string data\r\n\nProbably the time is come to undertake also this part but it would mean `strcmp` or similar. Not sure I want that all over since in 90% of cases I don't even need to use the string once hashed. "
      }
    ]
  },
  {
    "number": 488,
    "title": "Clarify constructor/destructor calls in documentation",
    "created_at": "2020-05-14T21:21:54Z",
    "closed_at": "2020-05-15T08:52:08Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/skypjack/entt/issues/488",
    "body": "Currently it's not very clear when constructors/destructors are called for components in the ECS wiki text. Could this be clarified?\r\n\r\nFrom my understanding (I could be wrong), component constructors are called before `on_construct` is ever emitted, and `on_destroy` is emitted before destructors are called. Is that correct/guaranteed?",
    "comments_url": "https://api.github.com/repos/skypjack/entt/issues/488/comments",
    "author": "Qix-",
    "comments": [
      {
        "user": "skypjack",
        "created_at": "2020-05-14T21:50:51Z",
        "body": "Not sure what I should clarify exactly. The documentation says that listeners are invoked after components have been assigned to entities. To assign a component to an entity, you've to construct it. So, yeah, constructors are necessarily invoked before any listener is invoked.\r\nThe same applies to destructors. Listeners are invoked before the component is removed and therefore before its destructor is invoked.\r\nIn both cases, the goal is to provide listeners with valid instances of components to use."
      },
      {
        "user": "Qix-",
        "created_at": "2020-05-14T22:07:06Z",
        "body": "Right, but are constructor/destructors invoked when components are replaced? Also, it's not _completely_ unreasonable to assume the the constructors/destructors are not called at all for performance reasons. Could just be me, but I thought the construct/destroy callbacks were in lieu of the constructors and destructors since components could be re-used."
      },
      {
        "user": "skypjack",
        "created_at": "2020-05-14T22:23:05Z",
        "body": ">Right, but are constructor/destructors invoked when components are replaced?\r\n\r\nOf course, before the listeners are invoked. The component is replaced with a new object created as a temporary, so you've a chain of constructor, move constructor, destructor of an object that is in an unspecified but safe state (well, if your objects give this guarantee as stated by the standard, of course).\r\n\r\n>it's not completely unreasonable to assume the the constructors/destructors are not called at all for performance reasons\r\n\r\nIndeed, it is not. However, in case I didn't invoke the constructor, all your objects would be in an invalid state and you couldn't use them after an `emplace`. Am I wrong?\r\n\r\n>Could just be me, but I thought the construct/destroy callbacks were in lieu of the constructors and destructors since components could be re-used.\r\n\r\nOh, no. You can even pass the arguments to use with a constructor when you invoke `emplace`.\r\nThe scope of the listeners isn't this one. To be honest, in C++ it would be odd if I asked to users to attach listeners that perform the construction/destruction of objects.\r\nThese callbacks are meant to perform all other kinds of set up and tear down for components. For example, resource management and such. Also, you can attach the member functions of the registry to the listeners and therefore for example trigger an `emplace` of `T` when you `remove` a `U` from an entity. \r\n"
      }
    ]
  },
  {
    "number": 460,
    "title": "invoking an entt::meta function doesn't change caller by-ref parameter ",
    "created_at": "2020-04-10T23:55:57Z",
    "closed_at": "2020-04-11T08:50:49Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/skypjack/entt/issues/460",
    "body": "Hi, \r\n  I was implementing a JsonRPC web-socket server based on entt::meta when I fell into this flaws (??):\r\npassing the parameter by reference (to be mutated) yields no change in the caller's instance.\r\n\r\nBecause I trust reproducibility is still a value, I've written a couple of unit tests which behaves differently, but should (??) be interchangeable in my opinion.\r\n\r\ng++ _Ubuntu 7.5.0-3ubuntu1~18.04_\r\n\r\n```\r\n#include <gtest/gtest.h>\r\n#include <entt/entt.hpp>\r\n\r\nstruct Base {\r\n    virtual ~Base() = 0;\r\n\r\n    static constexpr auto jsonrpc = \"2.0\";\r\n};\r\n\r\ninline Base::~Base() = default;\r\n\r\nstruct get_last_hour_data : public Base {\r\n    static get_last_hour_data create(std::string const &jsonValue);\r\n\r\n    [[nodiscard]] static bool exec(std::string &s);\r\n\r\n    [[nodiscard]] static bool exec_ptr(std::shared_ptr<std::string> &s);\r\n\r\nprivate:\r\n    [[nodiscard]] static bool init(std::string const &options);\r\n};\r\n\r\nget_last_hour_data get_last_hour_data::create(std::string const &jsonValue) {\r\n    get_last_hour_data glhd;\r\n    if(!get_last_hour_data::init(jsonValue)) {\r\n        return {};\r\n    }\r\n    return glhd;\r\n}\r\n\r\nbool get_last_hour_data::exec(std::string &s) {\r\n    s += \".\";\r\n    return true;\r\n}\r\n\r\nbool get_last_hour_data::exec_ptr(std::shared_ptr<std::string> &s) {\r\n    *s += \".\";\r\n    return false;\r\n}\r\n\r\nbool get_last_hour_data::init(std::string const &options) {\r\n    return true;\r\n}\r\n\r\nTEST(EnTTMeta, MutateByRef) {\r\n    entt::meta<get_last_hour_data>().alias(\"/getLastHourData\"_hs).template base<Base>().\r\n            template func<&get_last_hour_data::exec>(\"exec\"_hs).\r\n                                            template ctor<&get_last_hour_data::create>();\r\n    auto type = entt::resolve(\"/getLastHourData\"_hs);\r\n    assert (type);\r\n\r\n    auto func = type.func(\"exec\"_hs);\r\n    assert (func);\r\n\r\n    auto any = type.construct(std::string{});\r\n    assert (any);\r\n\r\n    std::string s;\r\n    auto any_2 = func.invoke(any, s);\r\n    assert (any_2);\r\n    ASSERT_EQ(\".\", s);\r\n}\r\n\r\nTEST(EnTTMeta, MutateBySharedPtrRef) {\r\n    entt::meta<get_last_hour_data>().template func<&get_last_hour_data::exec_ptr>(\"exec_ptr\"_hs);\r\n\r\n    auto type = entt::resolve(\"/getLastHourData\"_hs);\r\n    assert (type);\r\n\r\n\r\n    auto func = type.func(\"exec_ptr\"_hs);\r\n    assert (func);\r\n\r\n    auto any = type.construct(std::string{});\r\n    assert (any);\r\n\r\n    auto s = std::make_shared<std::string>();\r\n    auto any_2 = func.invoke(any, s);\r\n    assert (any_2);\r\n    ASSERT_EQ(\".\", *s);\r\n}\r\n```",
    "comments_url": "https://api.github.com/repos/skypjack/entt/issues/460/comments",
    "author": "stefanofiorentino",
    "comments": [
      {
        "user": "indianakernick",
        "created_at": "2020-04-11T00:20:59Z",
        "body": "Did you try invoking with a reference wrapper? (`std::ref`)"
      },
      {
        "user": "skypjack",
        "created_at": "2020-04-11T08:58:43Z",
        "body": "Yeah, the doc for meta should be updated.\n\nThere are two ways to pass something by reference:\n* Using an `std::ref` if it's a plain variable.\n* By dereferencing it if it's in a `meta_any` (eg `*any`).\n\nIn other terms, you can always get modified the values in the outer context if you need it, no matter what. :+1:\nIt's up to the user to decide when to pass something by copy or by value at the call site."
      },
      {
        "user": "stefanofiorentino",
        "created_at": "2020-04-11T09:01:03Z",
        "body": "> you can always get modified the values in the outer context if you need it\r\n\r\nThis definitely makes sense. "
      }
    ]
  },
  {
    "number": 427,
    "title": "Unexpected behaviour when iterating a view",
    "created_at": "2020-02-25T06:42:58Z",
    "closed_at": "2020-02-25T08:05:16Z",
    "labels": [
      "invalid",
      "question"
    ],
    "url": "https://github.com/skypjack/entt/issues/427",
    "body": "Sorry if I'm massively misunderstanding here, but I'm getting some quite unexpected behaviour from running the following code (part of my test suite, but I've put together a Minimal Reproducible Example):\r\n\r\n```cpp\r\n#include <iostream>\r\n\r\n#include <entt/entt.hpp>\r\n\r\nstruct Parent\r\n{\r\n    unsigned int children = 0;\r\n    entt::entity first = entt::null;\r\n};\r\n\r\nstruct Child\r\n{\r\n    entt::entity parent = entt::null;\r\n    entt::entity next = entt::null;\r\n};\r\n\r\nint main()\r\n{\r\n    entt::registry registry;\r\n\r\n    const auto parent_entity = registry.create();\r\n    const auto child_entity_1 = registry.create();\r\n    const auto child_entity_2 = registry.create();\r\n\r\n    auto &parent_component = registry.assign<Parent>(parent_entity);\r\n    auto &child_component_1 = registry.assign<Child>(child_entity_1);\r\n    auto &child_component_2 = registry.assign<Child>(child_entity_2);\r\n\r\n    parent_component.children = 2;\r\n    parent_component.first = child_entity_1;\r\n\r\n    child_component_1.next = child_entity_2;\r\n    child_component_1.parent = parent_entity;\r\n    child_component_2.parent = parent_entity;\r\n\r\n    registry.view<Child>().each([&](const auto entity, const auto &child) {\r\n        if (!registry.valid(child.parent))\r\n        {\r\n            registry.destroy(entity);\r\n        }\r\n    });\r\n\r\n    std::cout << registry.valid(child_entity_1) << \"\\n\";\r\n    std::cout << registry.valid(child_entity_2) << \"\\n\";\r\n    std::cout << registry.valid(parent_entity) << \"\\n\";\r\n}\r\n```\r\n\r\nOutput:\r\n```\r\n1\r\n1\r\n0\r\n```\r\n\r\nDuring the `registry.view<Child>().each()` call, first `child_entity_1` is visited, but then `parent_entity` is visited (even though it doesn't have a `Child` component!). This results in `parent_entity` being destroyed. `child_entity_2` is never visited.\r\n\r\nAm I misunderstanding something concept here? I was under the impression that all the entities with a `Child` component should be visited, and since they all have a valid parent entity they shouldn't be destroyed.",
    "comments_url": "https://api.github.com/repos/skypjack/entt/issues/427/comments",
    "author": "Omegastick",
    "comments": [
      {
        "user": "skypjack",
        "created_at": "2020-02-25T07:45:20Z",
        "body": "You're doing a common mistake in C++, it has nothing to do with `EnTT`.\r\nImagine this:\r\n```\r\nstd::vector<int> vec{};\r\nauto &ref = vec.emplate_back(1);\r\nvec.emplate_back(2);\r\n```\r\nIs `ref` still valid after the last line? It's not guaranteed, it may be or may be not invalidated. This depends on the fact that the vector reallocated, thus invalidating the reference.\r\n\r\nYou've exactly the same issue here:\r\n```\r\nauto &child_component_1 = registry.assign<Child>(child_entity_1);\r\nauto &child_component_2 = registry.assign<Child>(child_entity_2);\r\n```\r\nIs `child_component_1` still valid after the second line? If it's not, then you've an UB when you modify it and this means that everything could happen.\r\nPools of components are just containers. They can reallocate as any other container.\r\n\r\nThe following version works as expected:\r\n```\r\nint main()\r\n{\r\n    entt::registry registry;\r\n\r\n    const auto parent_entity = registry.create();\r\n    const auto child_entity_1 = registry.create();\r\n    const auto child_entity_2 = registry.create();\r\n\r\n    registry.assign<Parent>(parent_entity, 2, child_entity_1);\r\n    registry.assign<Child>(child_entity_1, parent_entity, child_entity_2);\r\n    registry.assign<Child>(child_entity_2, parent_entity);\r\n\r\n    registry.view<Child>().each([&](const auto entity, const auto &child) {\r\n        if (!registry.valid(child.parent))\r\n        {\r\n            registry.destroy(entity);\r\n        }\r\n    });\r\n\r\n    std::cout << registry.valid(child_entity_1) << \"\\n\";\r\n    std::cout << registry.valid(child_entity_2) << \"\\n\";\r\n    std::cout << registry.valid(parent_entity) << \"\\n\";\r\n}\r\n```\r\n\r\nIf you don't want to pass arguments on construction, then:\r\n* Initialize your components before creating new ones to avoid using potentially dangling pointers.\r\n* Get (as in `registry::get<T>(entity)`) the component when you want to use it, so that you are guaranteed that the returned reference is a valid one."
      }
    ]
  },
  {
    "number": 387,
    "title": "In which cases would sorting a full-owning group cause an assertion to fail?",
    "created_at": "2020-01-10T17:52:34Z",
    "closed_at": "2020-01-11T00:58:07Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/skypjack/entt/issues/387",
    "body": "Apologies for so many tickets \ud83d\ude43 \r\n\r\nI have a full-owning group of components called `global_transform_group` that holds a three-component tuple of components. I also have a nested group called `global_render_group` that has the same three components, along with an additional render-related component.\r\n\r\nWith any more than 1 entity belonging to those groups (0 works fine, too), I either get an assertion failure when calling `global_transform_group.sort()` or `false` when calling `global_transform_group.sortable()`.\r\n\r\nThe documentation seems to contradict itself:\r\n\r\n> Sorting owned components is no longer allowed once the group has been created. However, full-owning groups can be sorted by means of their sort member functions. Sorting a full-owning group affects all its instances.\r\n\r\nWhich, at least to me, starts by saying you cannot sort, but then goes on to say that full-owning groups _can_ sort, which leaves me a bit confused \ud83d\ude05 \r\n\r\nSo, in which circumstances can I sort a full-owning group? Should I eliminate the nested group and just use a single full-owning group with all four components?\r\n\r\nIt's worth mentioning I'm using a custom sort function.",
    "comments_url": "https://api.github.com/repos/skypjack/entt/issues/387/comments",
    "author": "Qix-",
    "comments": [
      {
        "user": "skypjack",
        "created_at": "2020-01-10T21:21:32Z",
        "body": "When you use groups, you can sort only the most restrictive ones, that is the one with the higher number of rules.\r\nFrom your example:\r\n```\r\nauto global_transform_group = registry.group<A, B, C>();\r\nauto global_render_group = registry.group<A, B, C, D>();\r\n```\r\nThis is allowed, they are nested groups. In this case, `global_render_group` is more restrictive because it sets more constraints on the entities that want to enter it. Therefore, it will be fully contained within `global_transform_group` by construction.\r\nNow, consider what would happen if you sorted `global_transform_group`. Since it's _larger_ that `global_render_group`, the elements contained by the latter could be moved around and exit it during the sort. This isn't an option of course.\r\nWhat happens if you sort `global_render_group`? Since it's fully contained within `global_transform_group`, it doesn't matter how it's elements are arranged, they cannot exit the _outer_ group in any case.\r\nTherefore, it's allowed to sort `global_render_group` and this is the reason for which `global_render_group.sortable()` returns true while `global_transform_group` isn't sortable.\r\n\r\n---\r\n\r\nIf you want to sort both, you can't make all them full-owning group.\r\nThere doesn't exist an architecture that allows you to sort stuff and reaches the maximum performance at the same time. Long story short, this is because we need to arrange things in a specific way to get the best from the data and you cannot shuffle them for your purposes.\r\nIf sorting is more important than iterating 1M entities in 0.005ms rather 0.006ms (I guess so), you can define the two groups as partially owning ones in such a way that they don't overlap on owned components. In this case, both will be sortable."
      }
    ]
  },
  {
    "number": 383,
    "title": "Is there a reason why you can't do single-component full-owning groups?",
    "created_at": "2020-01-04T04:09:36Z",
    "closed_at": "2020-01-04T20:07:10Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/skypjack/entt/issues/383",
    "body": "I have a group of components I'd like packed together and fully-owned via an `entt::group` but the API doesn't like that there's only one component in the `registry.group<component>()` template specifier.\r\n\r\nThis seems like a deliberate design decision, leading me to believe I'm missing something about groups.\r\n\r\nIs what I'm doing an anti-pattern for some reason?",
    "comments_url": "https://api.github.com/repos/skypjack/entt/issues/383/comments",
    "author": "Qix-",
    "comments": [
      {
        "user": "skypjack",
        "created_at": "2020-01-04T17:42:55Z",
        "body": "Uhm... I think you misunderstood how groups work. They are meant to arrange components from different pools in such a way that multi-component iterations are then linear, with no jumps nor branches (the so called _perfect SoA_).\r\nNot sure what you're trying to do but it seems to me it's something more on the line of - _I want to group the entities that have component `position` for which `x` is within 10 and 100_. Am I wrong? "
      },
      {
        "user": "Qix-",
        "created_at": "2020-01-04T19:18:59Z",
        "body": "No, I don't care about filtering based on the component's data.\r\n\r\nI have a particular component that is iterated over for _all_ entities (that have it) unconditionally, but is not paired with any other component at all. I want to make iterating over _all_ instances of that component as fast as possible, so I'd like it to be packed into its own list similar to how groups seem to do so.\r\n\r\nNow that I'm writing this, I'm realizing that this is probably the default way entt structures instances of components, anyway...\r\n\r\nAnyway, I guess the X-Y question is really: _how do I iterate over **all** instances of **a single** component in the most efficient way possible_? \ud83d\ude05 "
      },
      {
        "user": "skypjack",
        "created_at": "2020-01-04T20:00:16Z",
        "body": "Well, in this case, a single component view is what you want. It iterates all instances at once with no jumps nor branches. :+1:\nIf you want even more performance and you don't plan to add or remove instances of the same component during iterations, you can also use the raw access (`data<T>`, `raw<T>` and `size<T>`) to iterate directly the internal arrays of entities and components for the given type.\nThis is the best you can expect overall, no matter what. You're iterating a plain array from 0 to N-1 in this case. :wink:"
      }
    ]
  },
  {
    "number": 369,
    "title": "Signature change question",
    "created_at": "2019-12-03T21:31:39Z",
    "closed_at": "2019-12-04T10:50:52Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/skypjack/entt/issues/369",
    "body": "Hi,\r\n\r\nThis is more of a \"how can I do this better\" question. I just went from 3.1.1 -> 3.2.1 and it went mostly smoothly with one exception, and I was hoping I could get some insight as to what is going on under the hood. The signature to some of my functions have changed, and I'm keen to know why. I've only been using cpp for a few months so excuse my ignorance. Is the `entt::exclude_t` required here?\r\n\r\n```cpp\r\n// 3.1.1\r\nglm::vec3 rule1(entt::basic_view<entt::entity, position, velocity, fish> &sortedFish, entt::entity &ourEntity) {\r\n    // do stuff\r\n}\r\n\r\n// 3.2.1\r\nglm::vec3 rule1(entt::basic_view<entt::entity, entt::exclude_t<>, position, velocity, fish> &sortedFish, entt::entity &ourEntity) {\r\n    // do stuff\r\n}\r\n```\r\n\r\nThanks!",
    "comments_url": "https://api.github.com/repos/skypjack/entt/issues/369/comments",
    "author": "arlyon",
    "comments": [
      {
        "user": "skypjack",
        "created_at": "2019-12-03T21:42:58Z",
        "body": "HI, v3.1.1 didn't have support for exclusion lists on views while v3.2.1 added it.\r\nIn other terms, you can now do this:\r\n```\r\nauto view = registry.view<A, B>(entt::exclude<C>);\r\n```\r\nThe view will return all entities that have both `A` and `B` but don't have `C`.\r\nThis is the reason for which that `entt::exclude_t<>` appeared in your signature.\r\n\r\nBecause you use `entt::entity`, you can use `entt::view` rather than `entt::basic_view` (see `fwd.hpp` for the forward declarations):\r\n```\r\nentt::view<entt::exclude_t<>, position, velocity, fish>\r\n```\r\n\r\nThere isn't much more you can do there. To support exclusion lists, the _types_ of the excluded components are required and thus part of the view type. Because of how parameter packs work in C++, we need to enclose one of them in a type list, in this case `entt::exclude_t`. This has the drawback that an empty type list is still required when no types are excluded.\r\n\r\nLet me know if it's not clear enough."
      }
    ]
  },
  {
    "number": 239,
    "title": "Polymorphic components?",
    "created_at": "2019-05-02T06:44:11Z",
    "closed_at": "2019-05-02T07:17:02Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/skypjack/entt/issues/239",
    "body": "Is there a way to have polymorphic components, where a component can do something like:\r\n```cpp\r\nstruct behaviour {\r\n  virtual void print() {}\r\n};\r\n\r\nstruct printer: public behaviour {\r\n  void print() override {\r\n    // Perform print action.\r\n  }\r\n};\r\n\r\n// Later...\r\nentt::registry registrar;\r\nentt::entity e0 = registrar.create();\r\nregistrar.assign<printer>(e0);\r\n\r\n// Even later...\r\nregistrar.view<behaviour>().each([](auto& component) {\r\n  component.print();\r\n});\r\n```\r\n\r\nI've tried this and it didn't work, and after reading the docs I'm not sure what the correct way to do this would be. I could use a bit of guidance to making this work. And I believe I understand why it doesn't work but I'd appreciate it if you could also explain why it doesn't.",
    "comments_url": "https://api.github.com/repos/skypjack/entt/issues/239/comments",
    "author": "SoraKatadzuma",
    "comments": [
      {
        "user": "indianakernick",
        "created_at": "2019-05-02T06:45:51Z",
        "body": "You could use `std::unique_ptr<behaviour>` but polymorphism in a \"pure\" ECS architecture is done a bit differently.\r\n\r\n```C++\r\n// components\r\nstruct printer {};\r\nstruct other_printer {};\r\n// other classes that used to derive from behaviour...\r\n\r\n// systems\r\nvoid printer_print(entt::registry &registrar) {\r\n  registrar.view<printer>().each(auto& component) {\r\n    // Perform print action with printer\r\n  });\r\n}\r\nvoid other_printer_print(entt::registry &registrar) {\r\n  registrar.view<other_printer>().each(auto& component) {\r\n    // Perform print action with other_printer\r\n  });\r\n}\r\n\r\n// setup\r\nentt::registry registrar;\r\nentt::entity e0 = registrar.create();\r\nregistrar.assign<printer>(e0);\r\nentt::entity e1 = registrar.create();\r\nregistrar.assign<other_printer>(e1);\r\n\r\n// game loop\r\nwhile (true) {\r\n  printer_print(registrar);\r\n  other_printer_print(registrar);\r\n}\r\n```\r\n\r\nThis is considerably faster because all of the `printer`s are processed together then all of the `other_printer`s are processed together.\r\n\r\nEnTT doesn't force you to write code in a specific way but it might be easier to you stick to a \"pure\" approach."
      },
      {
        "user": "skypjack",
        "created_at": "2019-05-02T07:01:14Z",
        "body": "You can also use a single component and rely on type erasure techniques by mixing non-capturing lambdas and pointers to functions. More or less on the line of the _OOP in C_ book.  \r\nThis way you've **only** `behavior` as a component but different `print`s for different instances."
      }
    ]
  },
  {
    "number": 187,
    "title": "Why is it bad to store a view? ",
    "created_at": "2019-02-19T20:23:28Z",
    "closed_at": "2019-02-19T21:21:01Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/skypjack/entt/issues/187",
    "body": "Hi,\r\n\r\nI want to ask you for a clarification about views. It's mentioned in the code documentation \r\n\r\n> As a rule of thumb, storing a view should never be an option.\r\n\r\nHowever, the main documentation states that:\r\n\r\n> Views and Groups\r\n> [...]\r\n> Briefly, they are a good tool to enforce single responsibility. A system that has access to a registry can create and destroy entities, as well as assign and remove components. On the other side, a system that has access to a view or a group can only iterate entities and their components, then read or update the data members of the latter. \r\n\r\nHow a system can have access to a view and only a view if it can't store it? Also why shouldn't I store a view? The documentation only mentions that creating a view is quick and cheap but not why storing a view is bad.\r\n\r\nI see solutions but they are less obvious than just storing an instance of a view.\r\n\r\nTo give a better context, let's imagine an `AudioSystem` in an entity-based environment. I don't want that system to be able to create/remove entities. If I can't store a view, the right solution is to pass a lambda (e.g. `[&registry] { return registry.view<CanProduceSound>(); }` over a view (e.g. `entt::view<CanProduceSound>&&`)?\r\n\r\nThanks.\r\n\r\n",
    "comments_url": "https://api.github.com/repos/skypjack/entt/issues/187/comments",
    "author": "Dimrok",
    "comments": [
      {
        "user": "skypjack",
        "created_at": "2019-02-19T21:06:25Z",
        "body": ">How a system can have access to a view and only a view if it can't store it?\r\n\r\nHow can a system have access to a view to store aside? A system can receive the view as a parameter of an hypothetical `update` function, as well as an argument to the constructor. No need to ask for the registry.\r\n\r\n>The documentation only mentions that creating a view is quick and cheap but not why storing a view is bad.\r\n\r\nFor what concerns runtime views, the documentation says (emphasis mine):\r\n\r\n>Runtime view are extremely cheap to construct and should not be stored around in any case. They should be used immediately after creation and then they should be thrown away. **The reasons for this go far beyond the scope of this document**.\r\n\r\nShortly, it could happen that the underlying data structures required for the view don't exist yet when a registry generates the view itself. Because of that, the view is somehow _broken_ and will behave as if it's empty at each invocation. There is no way to literally _fix it_ once the ownership is transferred. Therefore, all what you can do is to throw it away.  \r\nOf course, there is a workaround for that (not mentioned in the documentation). Moreover, runtime views are beasts rarely used and in different contexts.\r\n\r\nFrom what concerns compile-time views, the current implementation allows you to store them aside actually. However, I cannot guarantee they won't bind to (let me say) _unstable_ underlying data structures of the registry in future (mainly things that can move around and thus invalidate pointers). It's unlikely to happen to be honest, but who knows?  \r\nBecause of that, mine is an advice for as _safe use_ of a view now and forever, but feel free to not follow it. Most likely you'll never ever have problems, don't worry.\r\n\r\n---\r\n\r\nThat being said, I invite you to join the gitter channel if you have other questions like this one. There are smart developers that can really help you there. Also, don't forget to star the project if you like and use it. I hope it fits with your requirements.\r\n\r\nIf you received your answer, please close the issue. Otherwise feel free to continue the discussion."
      },
      {
        "user": "indianakernick",
        "created_at": "2019-02-19T21:06:35Z",
        "body": "Conceptually, a system is just behavior so I declare systems like this:\r\n\r\n```\r\nvoid playSounds(entt::registry &reg, AudioContext &ctx) {\r\n  // Create a view, iterate CanProduceSound components, play sounds\r\n}\r\n```\r\n\r\nThat's my two cents. It doesn't really answer your question though!"
      },
      {
        "user": "skypjack",
        "created_at": "2019-02-19T21:09:05Z",
        "body": "Yeah @Kerndog73 I use to have free functions as systems too. However, sometimes they ask directly for a view as a parameter and I submit the registry through the `as_view` utility to satisfy the requirement. This way I'm guaranteed that the system won't create entities and components any time soon."
      },
      {
        "user": "indianakernick",
        "created_at": "2019-02-19T21:14:42Z",
        "body": "@skypjack Oh, using `as_view` seems like a really smart idea. You can avoid having to type out the list of components in the calling code. Genius! Although, you still have the component list in two places (header and implementation).\r\n\r\nI like the idea of ensuring that a system can only iterate components but I'm not really a fan of enforcing **which** particular components can be iterated."
      }
    ]
  },
  {
    "number": 164,
    "title": "Get Owner of Component",
    "created_at": "2018-12-05T09:56:47Z",
    "closed_at": "2018-12-05T14:34:24Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/skypjack/entt/issues/164",
    "body": "Assuming that I only have a reference to a component available, would there be any way for that component to get the entity it belongs to, and through that access other components? The best solution I've come up with so far is iterating all entities with the component until the one I want appears, but perhaps I've overlooked a better way of doing this that already exists. Couldn't find anything in the wiki or in other issues.\r\n\r\n```C++\r\ntemplate<typename ComponentType>\r\nuint32_t getOwner(const ComponentType& component)\r\n{   \r\n    auto view = registry.view<ComponentType>();\r\n    for (auto e : view)\r\n    {\r\n        if (&view.get(e) == &component)\r\n        {\r\n            return e;\r\n        }\r\n    }\r\n\r\n    /* It should never come here as all components logically should have an owner */\r\n    return entt::null;\r\n}\r\n```\r\nI'm not sure if this is something you want to have as a part of the library at all, but I had a use for it, so thought I'd ask! Thanks a lot for your great work!",
    "comments_url": "https://api.github.com/repos/skypjack/entt/issues/164/comments",
    "author": "carlfindahl",
    "comments": [
      {
        "user": "indianakernick",
        "created_at": "2018-12-05T10:10:20Z",
        "body": "There is no mapping from the component to the entity ID. If you only have the address of the component you're looking for, the only way to get the entity ID is to iterate.\r\n\r\nHowever, it is recommended that instead of holding onto component references, you hold onto entity IDs. There is a fast mapping from entity ID to component.\r\n\r\n```C++\r\ninstances[reverse[entity & traits_type::entity_mask]]\r\n```\r\n\r\nA bitwise `&` and two array lookups. It's fast! Holding onto a reference to the component isn't much faster than storing the entity ID.\r\n\r\nHolding onto a reference means that you run the risk of having a dangling reference. When you assign a component to an entity, a `std::vector` will be resized and potentially reallocated, leaving you with a dangling reference. An entity ID doesn't suffer from this problem."
      },
      {
        "user": "skypjack",
        "created_at": "2018-12-05T12:01:26Z",
        "body": ">would there be any way for that component to get the entity it belongs to, and through that access other components?\n\nThere is a trick to do that actually but 1) you didn't star the project, so I won't tell you :smile: 2) @Kerndog73 pointed out the right problem.\n\n>Assuming that I only have a reference to a component available\n\nYou should never ever store aside references or pointers to components, they aren't guaranteed to be consistent in time. Use entity identifiers instead.  \nKeep in mind that `EnTT` does reallocate elements in the pools when needed in order to give you fast iterations and some nice-to-have features like a pointer to a packed array of components.\n\n>I'm not sure if this is something you want to have as a part of the library at all, but I had a use for it\n\nBefore to tell you how to do that, may I ask you what's your use case?"
      },
      {
        "user": "carlfindahl",
        "created_at": "2018-12-05T14:12:48Z",
        "body": ">  1) you didn't star the project, so I won't tell you\r\n\r\nWell I fixed that, as this definitely deserves one!\r\n\r\nStoring the entity ID seems like the better options now that it has been pointed out. @Kerndog73 is `instances` and `entity_mask` part of the library? \r\n\r\n> Before to tell you how to do that, may I ask you what's your use case?\r\n\r\nAll right, at the moment some of my components have some member-functions (they are all structs), but I use member functions to bind functionality to LUA, so anyone scripting can't change just anything on components. And some of those functions trigger events that  contain data about which entity fired it, which is the reason I had to find a way to get the entity from within a component. This is my first project using a proper ECS, so it might not be perfectly idiomatic, but it gets the job done. Within C++ I just access members directly, and it's a non-issue.\r\n\r\nThank you very much for swift replies and some great tips on how to better use the library!"
      },
      {
        "user": "skypjack",
        "created_at": "2018-12-05T14:34:24Z",
        "body": "You're welcome!! Feel free also to join us on gitter if you want to discuss your doubts with other users.  \r\nI confirm that I'd use the entity identifier if I was you, because you don't know if the component is going to be moved during its lifetime.  \r\nMoreover, identifiers contain a version and you can test them at any time to know if they are still valid or have been destroyed/recycled in the meantime. :+1: \r\n\r\nI'm closing the issue as invalid. Feel free to reopen it if you think you didn't get a proper answer.\r\n\r\nEnjoy `EnTT`. :+1: "
      }
    ]
  }
]