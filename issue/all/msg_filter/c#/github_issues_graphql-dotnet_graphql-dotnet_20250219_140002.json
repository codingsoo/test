[
  {
    "number": 3557,
    "title": "InputObjectGraphType doesn't resolve fieldName correctly",
    "created_at": "2023-03-01T03:44:33Z",
    "closed_at": "2023-03-01T05:09:39Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/3557",
    "body": "## Description\r\n\r\nWhen I define an InputObjectGraphType with a field\r\n\r\n```\r\nField<GuidGraphType>(\"id\")\r\n    .Description(\"Some description.\")\r\n    .Resolve(context => context.Source.SomeGuid)\r\n    .NonNull();\r\n```\r\nThe Id is set to it's default value, even though the value is set.  If I change the field name to match the actually property name it works just fine, ie\r\n\r\n```\r\nField<GuidGraphType>(\"someGuid\")\r\n    .Description(\"Some description.\")\r\n    .Resolve(context => context.Source.SomeGuid)\r\n    .NonNull();\r\n```\r\n\r\n### Steps to reproduce\r\n\r\nIn the mutation ObjectGraphType, I setup a field like so:\r\n\r\n```\r\nField<MyGraphType, MyObject>(\"setAccessGroup\")\r\n    .Description(\"Some description.\")\r\n    .Argument<NonNullGraphType<MyInputGraphType>>(\"input\")\r\n    .ResolveAsync(async context =>\r\n    {\r\n        // This next line is where it fails\r\n        var input = context.GetArgument<MyInputGraphType>(\"input\");\r\n        // database call\r\n        return result;\r\n    });\r\n\r\n### Expected result\r\n\r\nIt should map \"id\" to SomeGuid\r\n\r\n### Actual result\r\n\r\nIt only maps \"someGuid\" to SomeGuid\r\n\r\n### Environment\r\n\r\n.NET Framework 4.8\r\n",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/3557/comments",
    "author": "andrewboyd-envirosuite",
    "comments": [
      {
        "user": "Shane32",
        "created_at": "2023-03-01T04:46:15Z",
        "body": "By design, field resolvers are ignored for input objects.  Use this syntax instead:\r\n\r\n```cs\r\nField(\"id\", x => x.SomeGuid, false)\r\n    .Description(\"test\");\r\n```\r\n\r\nSupplying an expression will allow GraphQL.NET to tie the field to the proper member.\r\n\r\nYou may also use the optional `type` parameter to manually specify a graph type such as `type: typeof(NonNullGraphType<GuidGraphType>)`.\r\n"
      },
      {
        "user": "Shane32",
        "created_at": "2023-03-01T04:50:29Z",
        "body": "In a future version of GraphQL.NET, we hope to split input objects off to a separate base class which will not include methods that do not apply to input objects.  But presently the `Field` methods are defined on `ComplexGraphType` which is the base class for both `InputObjectGraphType` and `ObjectGraphType`."
      },
      {
        "user": "andrewboyd-envirosuite",
        "created_at": "2023-03-01T05:03:13Z",
        "body": "Thanks, @Shane32 for the quick response!  So I tried this and I get the error `Cannot implicitly convert type 'System.Guid' to 'GraphQL.Types.GuidGraphType'`"
      },
      {
        "user": "Shane32",
        "created_at": "2023-03-01T05:04:32Z",
        "body": "You cannot use `Field<GuidGraphType>(\"id\", x => x.SomeGuid)` syntax.  You must use the syntax I stated above."
      },
      {
        "user": "Shane32",
        "created_at": "2023-03-01T05:05:13Z",
        "body": "```cs\r\n//non-null, explicit type\r\nField(\"id\", x => x.SomeGuid, false, typeof(NonNullGraphType<GuidGraphType>))\r\n    .Description(\"test\");\r\n\r\n//nullable, explicit type\r\nField(\"id\", x => x.SomeGuid, true, typeof(GuidGraphType))\r\n    .Description(\"test\");\r\n\r\n//non-null, implicit type\r\nField(\"id\", x => x.SomeGuid)\r\n    .Description(\"test\");\r\n\r\n//nullable, implicit type\r\nField(\"id\", x => x.SomeGuid, true)\r\n    .Description(\"test\");\r\n```"
      }
    ]
  },
  {
    "number": 3462,
    "title": "Question: How to create static Connection field",
    "created_at": "2022-12-23T07:07:04Z",
    "closed_at": "2023-04-24T07:15:24Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/3462",
    "body": "I  create connection like below code \r\n\r\n`  public static Connection<News> Data1()\r\n    {\r\n        return new Connection<News>();\r\n    }\r\n`\r\n`\r\n    public static Connection<ArticlePicture> Data2()\r\n    {\r\n        return new Connection<ArticlePicture>();\r\n    }`\r\n\r\nbut get error\r\n\r\n`[Error] \"Unable to register GraphType 'AutoRegisteringObjectGraphType<Connection<ArticlePicture>>' with the name 'Connection'. The name 'Connection' is already registered to 'AutoRegisteringObjectGraphType<Connection<News>>'. Check your schema configuration.\"`\r\n\r\nif only Data1 field remove Data2 field, no error.\r\n\r\n I use GraphQL Server version is GraphQL.Server.All 7.2.0 \r\n\r\nHow to create static connection correctly?\r\n\r\nCan anybody help? many thanks!\r\n",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/3462/comments",
    "author": "need",
    "comments": [
      {
        "user": "Shane32",
        "created_at": "2022-12-23T20:34:56Z",
        "body": "The easiest way is to create a derived class of `Connection<News>` such as `class NewsConnection : Connection<News> { }`.\r\n\r\nThe second easiest answer is mark a custom type for this field with the `[OutputType]` attribute such as `[OutputType(typeof(ConnectionType<AutoRegisteringObjectGraphType<News>>))]`\r\n\r\nSince the auto-registering handler doesn't create unique names for generic types, and doesn't have any special code to recognize `Connection<T>` types, it is creating conflicting names for your schema."
      },
      {
        "user": "need",
        "created_at": "2022-12-26T03:44:41Z",
        "body": "Thanks for your reply.\r\n\r\nI try way 1 get below error\r\n`[Error] Unable to register GraphType 'AutoRegisteringObjectGraphType<Edge<ArticlePicture>>' with the name 'Edge'. The name 'Edge' is already registered to 'AutoRegisteringObjectGraphType<Edge<News>>`\r\n\r\nway 2 get below error\r\n`[Error] \"Unable to register GraphType 'ConnectionType<AutoRegisteringObjectGraphType<ArticlePicture>>' with the name 'AutoRegisteringObjectConnection'. The name 'AutoRegisteringObjectConnection' is already registered to 'ConnectionType<AutoRegisteringObjectGraphType<News>>'`\r\n\r\n\r\n"
      },
      {
        "user": "Shane32",
        "created_at": "2022-12-26T05:26:05Z",
        "body": "Hmm... you're right\r\n\r\nWell, unfortunately i'd probably just create the edge type and connection type and name each of the types.  Perhaps in the next version of GraphQL.NET we can change the automatic naming algorithm for connection types.\r\n\r\n```cs\r\npublic class NewsConnectionType : ConnectionType<AutoRegisteringObjectGraphType<News>, NewsEdgeType>\r\n{\r\n    public NewsConnectionType()\r\n    {\r\n        Name = \"NewsConnection\";\r\n    }\r\n}\r\n\r\npublic class NewsEdgeType : EdgeType<AutoRegisteringObjectGraphType<News>>\r\n{\r\n    public NewsEdgeType()\r\n    {\r\n        Name = \"NewsEdge\";\r\n    }\r\n}\r\n\r\n// [OutputType(typeof(NewsConnectionType))]\r\n// or\r\n// [OutputType(typeof(NonNullGraphType<NewsConnectionType>))]\r\n```\r\n\r\nAn alternate method is to create a concrete type for `News`:\r\n\r\n```cs\r\n// note: be sure to end this name in \"GraphType\"\r\npublic class NewsGraphType : AutoRegisteringObjectGraphType<News>\r\n{\r\n}\r\n\r\n// [OutputType(typeof(ConnectionType<NewsGraphType>))]\r\n// or\r\n// [OutputType(typeof(NonNullGraphType<ConnectionType<NewsGraphType>>))]\r\n\r\n// but will need to be sure the CLR type mapping is registered properly so other references to `News`\r\n// map to the same NewsGraphType\r\n// e.g. .AddClrTypeMappings() during DI configuration\r\n// or this.RegisterTypeMapping<News, NewsGraphType>() during schema configuration\r\n```\r\n\r\nYou can also register the type mapping for `Connection<News>` so you don't need to use `[OutputType]`\r\n\r\n```cs\r\n// in schema constructor, or within ConfigureSchema:\r\nschema.RegisterTypeMapping<Connection<News>, NewsConnectionType>();\r\n// or ConnectionType<News> depending on the solution picked above\r\n```\r\n\r\nIn this way nullability is automatically determined.\r\n"
      }
    ]
  },
  {
    "number": 3449,
    "title": "Exception when I iterate through the types of a schema before defining any resolvers etc",
    "created_at": "2022-12-09T20:22:42Z",
    "closed_at": "2022-12-09T21:17:19Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/3449",
    "body": "I am trying to read a string as a `Schema` and then print out all of the type names in that schema. \r\n\r\nHere is my script:\r\n\r\n```fsharp\r\n#r \"nuget: GraphQL, 7.2.1\"\r\n#r \"nuget: GraphQL.SystemTextJson\"\r\n\r\nopen GraphQL\r\nopen GraphQL.Types\r\nopen GraphQL.SystemTextJson\r\n\r\nlet definition =\r\n  \"\"\"type User {\r\n  id : ID!\r\n  handle : String!\r\n  bio : String\r\n  karma : Int!\r\n}\r\n\r\nunion CommentParent = Post | Comment\r\n\r\ntype Post {\r\n  id : ID!\r\n  created : String!\r\n  title : String!\r\n  url : String!\r\n  posterId : ID!\r\n  poster : User\r\n  karma : Int!\r\n}\r\n\r\ntype Comment {\r\n  id : ID!\r\n  created : String!\r\n  commenterId : ID!\r\n  commenter : User\r\n  parent : CommentParent\r\n  content : String!\r\n  karma : Int!\r\n}\r\n\r\ntype Query {\r\n  posts(page : Int! = 0) : [Post!]!\r\n  profile(id : ID!) : User\r\n}\r\n\"\"\"\r\n\r\nlet schema = Schema.For(definition)\r\n\r\nprintfn \"Found these GraphQL types: \"\r\n\r\nfor graphQLType in schema.AllTypes do\r\n  match graphQLType with\r\n  | :? GraphQL.Types.INamedType as namedType ->\r\n    printfn $\" - {namedType.Name}\"\r\n  | _ -> ()\r\n\r\nprintfn \"Done. \"\r\n```\r\n\r\nIt throws an error:\r\n\r\n```\r\nSystem.InvalidOperationException: Union type 'CommentParent' does not provide a 'resolveType' function and possible Type 'CommentParent' does not provide a 'isTypeOf' function. There is no way to resolve this possible type during execution.\r\n   at GraphQL.Types.SchemaTypes.ApplyTypeReference(IGraphType type) in /_/src/GraphQL/Types/Collections/SchemaTypes.cs:line 842\r\n   at GraphQL.Types.SchemaTypes.ApplyTypeReferences() in /_/src/GraphQL/Types/Collections/SchemaTypes.cs:line 790\r\n   at GraphQL.Types.SchemaTypes.Initialize(ISchema schema, IServiceProvider serviceProvider, IEnumerable`1 graphTypeMappings) in /_/src/GraphQL/Types/Collections/SchemaTypes.cs:line 225\r\n   at GraphQL.Types.SchemaTypes..ctor(ISchema schema, IServiceProvider serviceProvider, IEnumerable`1 graphTypeMappings) in /_/src/GraphQL/Types/Collections/SchemaTypes.cs:line 133\r\n   at GraphQL.Types.SchemaTypes..ctor(ISchema schema, IServiceProvider serviceProvider) in /_/src/GraphQL/Types/Collections/SchemaTypes.cs:line 118\r\n   at GraphQL.Types.Schema.CreateSchemaTypes() in /_/src/GraphQL/Types/Schema.cs:line 471\r\n   at GraphQL.Types.Schema.CreateAndInitializeSchemaTypes() in /_/src/GraphQL/Types/Schema.cs:line 442\r\n   at GraphQL.Types.Schema.Initialize() in /_/src/GraphQL/Types/Schema.cs:line 210\r\n   at <StartupCode$FSI_0002>.$FSI_0002.main@() in /home/njlr/Repro.fsx:line 8\r\nStopped due to error\r\n```\r\n\r\nIs there a way to examine the types of a schema parsed from a string?",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/3449/comments",
    "author": "njlr",
    "comments": [
      {
        "user": "Shane32",
        "created_at": "2022-12-09T20:39:29Z",
        "body": "You can parse the SDL using the GraphQLParser project and iterate through the type definitions there.  Call `GraphQLParser.Parser.Parse(definitions)`\r\n"
      },
      {
        "user": "njlr",
        "created_at": "2022-12-09T21:17:19Z",
        "body": "> You can parse the SDL using the GraphQLParser project and iterate through the type definitions there. Call `GraphQLParser.Parser.Parse(definitions)`\r\n\r\nWorks a treat!\r\n\r\n```fsharp\r\n#r \"nuget: GraphQL, 7.2.1\"\r\n#r \"nuget: GraphQL.SystemTextJson\"\r\n\r\nopen GraphQLParser\r\nopen GraphQLParser.AST\r\n\r\nlet definition =\r\n  \"\"\"type User {\r\n  id : ID!\r\n  handle : String!\r\n  bio : String\r\n  karma : Int!\r\n}\r\n\r\nunion CommentParent = Post | Comment\r\n\r\ntype Post {\r\n  id : ID!\r\n  created : String!\r\n  title : String!\r\n  url : String!\r\n  posterId : ID!\r\n  poster : User\r\n  karma : Int!\r\n}\r\n\r\ntype Comment {\r\n  id : ID!\r\n  created : String!\r\n  commenterId : ID!\r\n  commenter : User\r\n  parent : CommentParent\r\n  content : String!\r\n  karma : Int!\r\n}\r\n\r\ntype Query {\r\n  posts(page : Int! = 0) : [Post!]!\r\n  profile(id : ID!) : User\r\n}\r\n\"\"\"\r\n\r\nlet doc = Parser.Parse(definition)\r\n\r\nprintfn \"Found these GraphQL types: \"\r\n\r\nfor node in doc.Definitions do\r\n  match node with\r\n  | :? GraphQLTypeDefinition as typeDefinition ->\r\n    printfn $\" - {typeDefinition.Name}\"\r\n  | _ -> ()\r\n\r\n```\r\n\r\n```\r\nFound these GraphQL types: \r\n - User\r\n - CommentParent\r\n - Post\r\n - Comment\r\n - Query\r\n\r\n```"
      }
    ]
  },
  {
    "number": 3365,
    "title": "Intercepting Resolver in a FieldBuilder extension",
    "created_at": "2022-10-19T19:49:15Z",
    "closed_at": "2022-10-19T22:48:49Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/3365",
    "body": "Hi, \r\nI want to create a FieldBuilder extension that will be applied after Resolve and conditionally can override Resolve behavior. \r\nIn the example below, the extension is called WithComment. \r\nit:\r\n- Adds an argument called comment if not already provided.\r\n- In the resolver, it checks if comment is needed (here the logic is only for demo)\r\n- If comment is needed and not provided, it returns response with error.\r\n- if comment is need and also provided, it should fall back to the original resolver execution.\r\n\r\nI came up with the following approach and wondering if you can advise if it is correct ot there is any better way.\r\n(Only look at the implementation of WithComment extension)\r\n\r\n```csharp\r\nasync Task Main()\r\n{\r\n\tvar schema = new Schema { Query = new TestQuery() };\r\n\tvar result1 = await schema.ExecuteAsync(_ =>\r\n\t\t\t{\r\n\t\t\t\t_.Query = \"{ test1 { status, id, errorMessage } }\";\r\n\t\t\t}\r\n\t);\r\n\r\n\tvar result2 = await schema.ExecuteAsync(_ =>\r\n\t\t\t{\r\n\t\t\t\t_.Query = \"{ test2 { status, id, errorMessage } }\";\r\n\t\t\t}\r\n\t);\r\n\r\n\r\n\tresult1.Dump();\r\n\tresult2.Dump();\r\n}\r\n\r\npublic class TestQuery : ObjectGraphType\r\n{\r\n\tpublic TestQuery()\r\n\t{\r\n\t\tField<TestResponseType, TestResponse>(\"test1\")\r\n\t\t\t.Resolve(context =>\r\n\t\t\t{\r\n\t\t\t\treturn new TestResponse();\r\n\t\t\t})\r\n\t\t\t.WithComment(1);\r\n\r\n\t\tField<TestResponseType, TestResponse>(\"test2\")\r\n\t\t\t.Resolve(context =>\r\n\t\t\t{\r\n\t\t\t\treturn new TestResponse();\r\n\t\t\t})\r\n\t\t\t.WithComment(2);\r\n\r\n\t}\r\n}\r\n\r\npublic static class FieldBuilderExtensions\r\n{\r\n\tpublic static readonly string COMMENT_ARGUMENT = \"comment\";\r\n\r\n\tpublic static FieldBuilder<TSourceType, TReturnType> WithComment<TSourceType, TReturnType>(\r\n\t\t\tthis FieldBuilder<TSourceType, TReturnType> builder, int value) where TReturnType : BaseResponse, new()\r\n\t{\r\n\t\tif (builder.FieldType.Resolver == null) {\r\n\t\t\tthrow new Exception(\"Resolve must be used before WithComment\");\r\n\t\t}\r\n\t\t\r\n\t\tif (builder.FieldType.Arguments == null)\r\n\t\t{\r\n\t\t\tbuilder.FieldType.Arguments = new QueryArguments();\r\n\t\t}\r\n\r\n\t\tif (!builder.FieldType.Arguments.Any(f => f.Name == COMMENT_ARGUMENT))\r\n\t\t{\r\n\t\t\tbuilder.FieldType.Arguments.Add(new QueryArgument<StringGraphType>\r\n\t\t\t{\r\n\t\t\t\tName = COMMENT_ARGUMENT\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\tvar currentResolver = builder.FieldType.Resolver;\r\n\r\n\t\tbuilder.FieldType.Resolver = new FuncFieldResolver<TSourceType, TReturnType>((IResolveFieldContext<TSourceType> context) =>\r\n\t\t{\r\n\t\t\tvar needsComment = value % 2 == 0;\t//Dummy logic here for demo\r\n\t\t\tvar comment = context.GetArgument<string>(COMMENT_ARGUMENT);\r\n\r\n\t\t\tif (needsComment && comment == null)\r\n\t\t\t{\r\n\t\t\t\treturn new TReturnType() {\r\n\t\t\t\t\tStatus = \"Fail\",\r\n\t\t\t\t\tErrorMessage = \"Comment must be provided\"\r\n\t\t\t\t};\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\treturn (TReturnType)currentResolver.ResolveAsync(context).Result;\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\treturn builder;\r\n\t}\r\n}\r\n\r\npublic class TestResponseType : BaseResponseType<TestResponse>\r\n{\r\n\tpublic TestResponseType()\r\n\t{\r\n\t\tField<StringGraphType>(\"Id\");\r\n\t}\r\n}\r\n\r\npublic class BaseResponseType<T> : ObjectGraphType<T>\r\n{\r\n\tpublic BaseResponseType()\r\n\t{\r\n\t\tField<StringGraphType>(\"status\");\r\n\t\tField<StringGraphType>(\"errorMessage\");\r\n\t}\r\n}\r\n\r\npublic class TestResponse : BaseResponse\r\n{\r\n\tpublic string Id { get; set; }\r\n\tpublic TestResponse()\r\n\t{\r\n\t\tId = \"0\";\r\n\t}\r\n}\r\n\r\npublic class BaseResponse\r\n{\r\n\tpublic string Status { get; set; } = \"success\";\r\n\tpublic string ErrorMessage { get; set; } = \"\";\r\n}\r\n```",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/3365/comments",
    "author": "rmeshksar",
    "comments": [
      {
        "user": "Shane32",
        "created_at": "2022-10-19T22:35:22Z",
        "body": "I think it looks good.  Here's a couple other ideas also, just FYI:\r\n\r\n1. If the comment argument was a non-null argument, validation would fail if the comment was not provided, so you might not need to overwrite the field resolver.  Validation has a benefit that the query does not execute if validation fails.  In your example above, you indicated that the comment was only conditionally required based on runtime logic, so this might not work for you.\r\n\r\nAlso, it seems that you are returning error messages within the GraphQL response.  I would personally recommend using GraphQL errors instead, and unify error responses with validation errors.\r\n\r\n2. If the comment is not used in the resolver but is simply there for logging, you could likely provide it \"out of bounds\" as a directive or comment, and write a validation rule that ensures that the directive or comment exists.  So for example it is possible to validate this within a validation rule:\r\n\r\n```gql\r\n{\r\n  something {\r\n    # a comment here <-- validation code ensures there is a comment here prior to execution of 'child' below\r\n    child { id }\r\n  }\r\n}\r\n```\r\n\r\nHowever, the example above probably violates spec as comments should be treated as whitespace during execution."
      },
      {
        "user": "sungam3r",
        "created_at": "2022-11-12T20:03:13Z",
        "body": "> you could likely provide it \"out of bounds\" as a directive or comment\r\n\r\nOf course directive  can help here\r\n\r\n```graphql\r\n{\r\n  something {\r\n    child @comment(\"Hello world!\") { id }\r\n  }\r\n}\r\n```\r\nDirective looks more promising, structured (unlike comments). You **may** go this way but prepare to fight with some difficulties - exposing directives via introspection, using GraphQL clients that aware of directives, write validation rule checking directive. The official specification has not yet been able to fully reveal all the possibilities of directives."
      }
    ]
  },
  {
    "number": 3355,
    "title": "Inject a query if a directive is present.",
    "created_at": "2022-10-11T13:17:41Z",
    "closed_at": "2022-10-12T14:04:52Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/3355",
    "body": "I have created a custom directive, placed on a mutation field that would instruct the mutation as follows:\r\n\r\nThe mutation's resolver is capable of forming, based on the mutation, a \"smart query\" that would retrieve the items affected by the mutation.  The directive would tell the mutation to \"append/inject\" this smart query into the mutation's response as if the client had been knowledgeable enough to send the query in the first place.  The client would specify, using the custom field directive, that it would like the server to execute in this manner.\r\n\r\nI have injected into the DI system an object where this \"smart query\" could be get/set.\r\n\r\nI have a few questions:\r\n1. If this behavior occurs only when the directive is present, does this violate the GraphQL protocol?\r\n2. Is using FieldMiddleware the best way to do this...I could not get a DirectiveVisitor to work?\r\n3. I saw in issue #2649 how to create the \"smart query\" document, but I don't know how to modify the executing document to add the smart query AST elements.  Would you offer any suggestions?",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/3355/comments",
    "author": "keithcarter5",
    "comments": [
      {
        "user": "Shane32",
        "created_at": "2022-10-11T20:59:37Z",
        "body": "Can you provide a sample GraphQL request and response that you are attempting to implement?"
      },
      {
        "user": "keithcarter5",
        "created_at": "2022-10-11T21:23:33Z",
        "body": "Mutation:\r\n```graphql\r\nmutation {\r\n  module {\r\n    setUserName(name: \"KeithsModule\") @performQuery {\r\n      result {\r\n        code\r\n      }\r\n    }\r\n  }\r\n}\r\n```\r\nImagining this mutation affected \"userName\", \"userDescription\", and \"catalogNumber\", the mutation would (using a DI suggestQuery service) specify \"{ module { userName userDescription } module { catalogNumber } }\" as the \"suggestedQuery\". \r\n The @performQuery directive would signal the server to retrieve the suggestedQuery (via the serviceProvider) insert the query into the executing document.\r\n"
      },
      {
        "user": "Shane32",
        "created_at": "2022-10-11T21:38:16Z",
        "body": "Ok so just for clarification can you post the combined query that you\u2019d like it to execute?\r\n\r\nnote that you can have GitHub format the code by typing something like this:\r\n\r\n````\r\n```gql\r\nquery {\r\n  sample\r\n}\r\n```\r\n````\r\n\r\nwhich will look like this:\r\n\r\n```gql\r\nquery {\r\n  sample\r\n}\r\n```"
      },
      {
        "user": "keithcarter5",
        "created_at": "2022-10-11T23:33:58Z",
        "body": "the client enters the following mutation:\r\n```gql\r\nmutation {\r\n    module {\r\n        setUserName(name: \"KeithsModule\") @performSuggestedQuery {\r\n            result {\r\n                code\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nin addition to resolving the mutation and returning the mutation's response result code, the resolver inserts into the mutation's response the suggested query:\r\n```gql\r\n{\r\n    module {\r\n        userName userDescription\r\n    }\r\n    module {\r\n        catalogNumber\r\n    }\r\n}\r\n```\r\nthe graphql response to the mutation would be:\r\n```json\r\n{\r\n  \"data\": {\r\n    \"module\": {\r\n      \"setUserName\": {\r\n        \"result\": {\r\n          \"code\": 0\r\n        },\r\n        \"suggestedQuery\": {\r\n          \"module\": {\r\n            \"userName\": \"KeithsModule\",\r\n            \"userDescription\": \"Keiths Module Description\",\r\n            \"catalogNumber\": \"2198-EW\"\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n```"
      },
      {
        "user": "Shane32",
        "created_at": "2022-10-12T00:48:45Z",
        "body": "Rather than a directive, have you considered this instead:\r\n\r\n```gql\r\nmutation {\r\n    module {\r\n        setUserName(name: \"KeithsModule\") {\r\n            result {\r\n                code\r\n            }\r\n            suggestedQuery\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nThen `suggestedQuery` is a `JsonScalarType` or similar (a custom scalar graph type), which is a legal GraphQL scalar which returns structured data in the format you described:\r\n\r\n```json\r\n{\r\n  \"data\": {\r\n    \"module\": {\r\n      \"setUserName\": {\r\n        \"result\": {\r\n          \"code\": 0\r\n        },\r\n        \"suggestedQuery\": {\r\n          \"module\": {\r\n            \"userName\": \"KeithsModule\",\r\n            \"userDescription\": \"Keiths Module Description\",\r\n            \"catalogNumber\": \"2198-EW\"\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n```\r\n\r\nThe above could be implemented by having the `suggestedQuery` field call another GraphQL call internally to execute whatever suggested query was dictated by your DI-injected service.  You can use `.ToValue()` or similar to convert the internal GraphQL response back into a dictionary to return from the `suggestedQuery` resolver.  You will need to consider what happens if the internal execution returns an error, of course -- perhaps just returning null is sufficient.\r\n\r\nNow, all of this assumes that the caller will know what the format of the suggested query would be.  Which begs the question: if the caller knows what the suggested query is, why doesn't the schema know what it is and assign the correct GraphQL type to the field?  I'll assume you have a good answer for this question, and offer a suggestion as a solution: include the suggested query text in the response, as shown below:\r\n\r\n```gql\r\nmutation {\r\n    module {\r\n        setUserName(name: \"KeithsModule\") {\r\n            result {\r\n                code\r\n            }\r\n            suggestedQuery\r\n            suggestedQueryResponse\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nwhich returns:\r\n\r\n```json\r\n{\r\n  \"data\": {\r\n    \"module\": {\r\n      \"setUserName\": {\r\n        \"result\": {\r\n          \"code\": 0\r\n        },\r\n        \"suggestedQuery\": \"{ module { userName userDescription } module { catalogNumber } }\",\r\n        \"suggestedQueryResponse\": {\r\n          \"module\": {\r\n            \"userName\": \"KeithsModule\",\r\n            \"userDescription\": \"Keiths Module Description\",\r\n            \"catalogNumber\": \"2198-EW\"\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n```\r\n\r\nNow I wouldn't want callers to have to parse the `suggestedQuery` field to decipher the `suggestedQueryResponse` field, but I guess it is possible to do so."
      },
      {
        "user": "Shane32",
        "created_at": "2022-10-12T00:59:04Z",
        "body": "Here are some other things I've done in the past which you may be able to pull ideas from:\r\n\r\n1. The GraphQL type of the `setUserName` mutation is the `ModuleType` so that any property from the updated module can be returned\r\n\r\n```gql\r\nmutation {\r\n    module {\r\n        setUserName(name: \"KeithsModule\") {\r\n            userName\r\n            userDescription\r\n            catalogNumber\r\n            # any other fields of the updated module can be selected here\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n2. Add a `query` field to the root of the `MutationType` which points to `QueryType` so that any query can be run in conjunction with the mutation.  These queries could execute within the same SQL transaction as the mutation, for example.  And since according to GraphQL spec, mutations execute serially, the caller can define if the query can run before or after the mutation:\r\n\r\n```gql\r\nmutation {\r\n    module {\r\n        setUserName(name: \"KeithsModule\") {\r\n            result { code }\r\n        }\r\n    }\r\n    query {\r\n        module(name: \"KeithsModule\") {\r\n            userName\r\n            userDescription\r\n            catalogNumber\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nSince GraphQL spec allows querying the same field multiple times via aliases, it is even possible to return any arbitrary data from both before and after the mutation, like this:\r\n\r\n```gql\r\nmutation {\r\n    queryBefore: query {\r\n        module(name: \"KeithsModule\") {\r\n            userName\r\n            userDescription\r\n            catalogNumber\r\n        }\r\n    }\r\n    module {\r\n        setUserName(name: \"KeithsModule\") {\r\n            result { code }\r\n        }\r\n    }\r\n    queryAfter: query {\r\n        module(name: \"KeithsModule\") {\r\n            userName\r\n            userDescription\r\n            catalogNumber\r\n        }\r\n    }\r\n}\r\n```\r\n"
      },
      {
        "user": "Shane32",
        "created_at": "2022-10-12T01:04:45Z",
        "body": "Back to your original question regarding using a directive to inject query results into the mutation results, within GraphQL.NET this would be difficult to implement in the exact manner you described.  Basically, I'm not sure how or if you could inject into the results.  Best bet would be to injecting a field into the request (i.e. the `suggestedQuery` field that I first suggested above), and letting it process exactly as if the `suggestedQuery` field was requested directly from the caller.  At that point it seems a little pointless to use a directive at all.  However, if it was a requirement, you could implement a schema filter to hide `suggestedQuery` from introspection queries and simply inject the hidden field when the directive was used.  I don't really have a better answer there."
      },
      {
        "user": "Shane32",
        "created_at": "2022-10-12T01:33:42Z",
        "body": "Oh, as to your other questions:\r\n\r\n> If this behavior only occurs when the directive is present, does this violate the GraphQL protocol?\r\n\r\nWell, maybe, but I don't know that it matters.  Directives are meant to alter server behavior.  You can think of this directive as enabling an experimental feature, for example.  Not really a big deal, even if technically it does not meet spec.  It just means you may not be able to use typical clients with this directive as they may ignore the extra data.\r\n\r\n> Is using FieldMiddleware the best way to do this...I could not get a DirectiveVisitor to work? \r\n\r\nNot sure exactly; I do not use directives.  @sungam3r would be the one to ask for questions on directives."
      },
      {
        "user": "keithcarter5",
        "created_at": "2022-10-12T13:34:07Z",
        "body": "I think your idea about the form of the mutation is better than the directive idea I had...certainly more straightforward.  As in:\r\n```gql\r\nmutation {\r\n    module {\r\n        setUserName(name: \"KeithsModule\") {\r\n            result {\r\n                code\r\n            }\r\n            suggestedQuery\r\n            suggestedQueryResponse\r\n        }\r\n    }\r\n}\r\n```\r\nIn one of your responses, you stated \r\n>The above could be implemented by having the suggestedQuery field call another GraphQL call internally to execute whatever suggested query was dictated...\r\n\r\nWould you mind providing an example on how to do that?\r\n\r\nAlso, you mentioned that in this case, the `suggestedQueryResponse` could be a `JsonScalarType` which allows structured json like that returned by the server.  I looked up #474 and saw references to a `AnyScalarGraphType`, but I could not find anything in the repo on `JsonScalarType`.  Would you elaborate a little more on this?\r\n\r\nOne other thing, you asked if the caller would understand the format of the `suggestedQueryResponse` json.  I'm thinking that since this field contains a response to a valid GraphQL query, which conforms to an existing schema, then the caller would be able to process that field with the same code with which it would process the actual query response (had the caller actually sent the query).\r\n"
      },
      {
        "user": "Shane32",
        "created_at": "2022-10-12T13:55:06Z",
        "body": "> JsonScalarType\r\n\r\n#474 relates to what I was talking about.  I wrote `ComplexScalarGraphType` in #3257 to serve that purpose, but honestly `AnyGraphType` is all you need here.  Although designed for GraphQL federation, it will serve your purpose nicely.  `ComplexScalarGraphType` has `ToAST` implemented where `AnyGraphType` does not, but this does not matter for your needs.\r\n\r\nIf you look through the open PRs you will also see #3246 -- this represents stringified JSON and is not what I was talking about."
      },
      {
        "user": "Shane32",
        "created_at": "2022-10-12T14:06:12Z",
        "body": "Well since I already am half done answering it...something like this:\r\n\r\n```cs\r\npublic async Task<object?> ExecuteSubquery(IResolveFieldContext context, string suggestedQuery)\r\n{\r\n    try {\r\n        var executer = context.RequestServices.GetRequiredService<IDocumentExecuter<ISchema>>();\r\n        var result = await executer.ExecuteAsync(new ExecutionOptions {\r\n            Query = suggestedQuery,\r\n            RequestedServices = context.RequestServices,\r\n            User = context.User,\r\n            CancellationToken = context.CancellationToken,\r\n            //Root = root,\r\n        });\r\n        if (!result.Executed || result.Data == null || result.Errors != null)\r\n            return null;\r\n        return ((ExecutionNode)result.Data).ToValue();\r\n    } catch {\r\n        return null;\r\n    }\r\n}\r\n```"
      },
      {
        "user": "Shane32",
        "created_at": "2022-10-12T14:07:34Z",
        "body": "You might or might not want to create a service scope for the subquery execution.  Probably not I'm guessing."
      }
    ]
  },
  {
    "number": 3193,
    "title": "AutoSchema, is it possible to combine (merge) queries or mutations from several classes?",
    "created_at": "2022-06-23T04:36:20Z",
    "closed_at": "2022-06-23T23:27:45Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/3193",
    "body": "Hello, \r\n\r\nI found that `AddAutoSchema` was very useful for the code-first approach, but I found it not so clean to make a class contains all of the queries (and also for mutations). When number of queries and mutations grows it's a little bit hard to manage the code. \r\n\r\nIs it possible to group them for something like this?\r\n\r\n```c#\r\npublic class UserQuery \r\n{\r\n    IList<User> Users(int limit, int offset) {}\r\n    IList<User> User(int id) {}\r\n}\r\n\r\npublic class UserMutation \r\n{\r\n    User CreateUser(User user) {}\r\n    User UpdateUser(int id, User user) {}\r\n    bool DeleteUser(int id) {}\r\n}\r\n\r\npublic class PostQuery \r\n{\r\n    IList<Post> Posts(int limit, int offset) {}\r\n    IList<Post> Post(int id) {}\r\n}\r\n\r\npublic class PostMutation \r\n{\r\n    Post CreatePost(Post post) {}\r\n    Post UpdatePost(int id, Post post) {}\r\n    bool DeletePost(int id) {}\r\n}\r\n```",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/3193/comments",
    "author": "ktutnik",
    "comments": [
      {
        "user": "Revazashvili",
        "created_at": "2022-06-23T12:59:16Z",
        "body": "you can do something like that\r\n```c#\r\npublic interface IQuery{}\r\n\r\npublic class Query : ObjectGraphType<object>\r\n{\r\n    private static readonly Lazy<List<Type>> GraphTypes = new(() =>\r\n        Assembly.GetExecutingAssembly().GetTypes()\r\n            .Where(type => typeof(IQuery).IsAssignableFrom(type) && type.IsClass).OrderBy(type => type.Name)\r\n            .ToList());\r\n    public Query()\r\n    {\r\n        Name = nameof(Query);\r\n        foreach (var type in GraphTypes.Value)\r\n            Field(type, type.Name, resolve: context => new object());\r\n    }\r\n}\r\n\r\npublic class UserQuery : ObjectGraphType<User>,IQuery\r\n{\r\n    IList<User> Users(int limit, int offset) {}\r\n    IList<User> User(int id) {}\r\n}\r\n\r\npublic class PostQuery : ObjectGraphType<Post>,IQuery\r\n{\r\n    IList<Post> Posts(int limit, int offset) {}\r\n    IList<Post> Post(int id) {}\r\n}\r\n```"
      },
      {
        "user": "Shane32",
        "created_at": "2022-06-23T13:17:38Z",
        "body": "If you're looking for a schema like this:\r\n\r\n```gql\r\ntype Query {\r\n  users: UserQuery!\r\n  posts: PostQuery!\r\n}\r\n\r\ntype Mutation {\r\n  users: UserMutation!\r\n  posts: PostMutation!\r\n}\r\n```\r\n\r\nYou can do this:\r\n\r\n```cs\r\npublic class Query\r\n{\r\n    public static UserQuery Users => new UserQuery();\r\n    public static PostQuery Posts => new PostQuery();\r\n}\r\n\r\npublic class Mutation\r\n{\r\n    public static UserMutation Users => new UserMutation();\r\n    public static PostMutation Posts => new PostMutation();\r\n}\r\n\r\n// .AddAutoSchema<Query>(o => o.WithMutation<Mutation>())\r\n```\r\n\r\nAlong with your other classes listed above, of course."
      },
      {
        "user": "Shane32",
        "created_at": "2022-06-23T13:36:15Z",
        "body": "If you want to merge different auto-generated classes together, for a schema like this:\r\n\r\n```gql\r\ntype Query {\r\n  user(id: Int!): [User!]!\r\n  users(limit: Int!, offset: Int!): [User!]!\r\n  post(id: Int!): [Post!]!\r\n  posts(limit: Int!, offset: Int!): [Post!]!\r\n}\r\n\r\n# and similar for mutation\r\n```\r\n\r\nThen I would do something similar to @Revazashvili 's sample, like this probably:\r\n\r\n```cs\r\npublic interface IQuery { }\r\n\r\n// use code-first to generate the query type\r\npublic class Query : ObjectGraphType\r\n{\r\n    public Query()\r\n    {\r\n        var types = Assembly.GetExecutingAssembly().GetTypes()\r\n            .Where(type => typeof(IQuery).IsAssignableFrom(type) && type.IsClass).OrderBy(type => type.Name)\r\n            .ToList();\r\n\r\n        // with the list of types that need to be combined,\r\n        foreach (var type in types)\r\n        {\r\n            // construct an \"auto-registering\" (aka type-first) graph type for each type\r\n            var constructedType = typeof(AutoRegisteringObjectGraphType<>).MakeGenericType(type);\r\n            var graphType = (IComplexGraphType)Activator.CreateInstance(constructedType);\r\n            // and add all the fields it generates into this graph type\r\n            foreach (var field in graphTypes.Fields)\r\n                AddField(field);\r\n        }\r\n    }\r\n}\r\n\r\npublic class UserQuery : IQuery\r\n{\r\n    IList<User> Users(int limit, int offset) {}\r\n    IList<User> User(int id) {}\r\n}\r\n\r\npublic class PostQuery : IQuery\r\n{\r\n    IList<Post> Posts(int limit, int offset) {}\r\n    IList<Post> Post(int id) {}\r\n}\r\n\r\n// and similar for mutation, using IMutation\r\n\r\n// use code-first to create the schema\r\npublic class MySchema : Schema\r\n{\r\n    public MySchema(IServiceProvider provider) : base(provider)\r\n    {\r\n        Query = new Query();\r\n        Mutation = new Mutation();\r\n    }\r\n}\r\n\r\n// .AddSchema<MySchema>()\r\n// .AddAutoClrMappings()\r\n```\r\n"
      },
      {
        "user": "Shane32",
        "created_at": "2022-06-23T13:45:49Z",
        "body": "You can also do without the `IQuery` and etc a bit more simply:\r\n\r\n```cs\r\npublic class Query : ObjectGraphType\r\n{\r\n    public Query()\r\n    {\r\n        AddFields<UserQuery>();\r\n        AddFields<PostQuery>();\r\n\r\n        void AddFields<T>()\r\n        {\r\n            var graphType = new AutoRegisteringObjectGraphType<T>();\r\n            foreach (var field in graphType.Fields)\r\n                AddField(field);\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nI didn't test all this code, but I think it will work."
      },
      {
        "user": "Shane32",
        "created_at": "2022-06-23T13:55:12Z",
        "body": "And finally, the easiest answer is to just use partial classes:\r\n\r\n```cs\r\n// Query.Users.cs\r\npublic partial class Query\r\n{\r\n    IList<User> Users(int limit, int offset) {}\r\n    IList<User> User(int id) {}\r\n}\r\n\r\n// Query.Posts.cs\r\npublic partial class Query\r\n{\r\n    IList<Post> Posts(int limit, int offset) {}\r\n    IList<Post> Post(int id) {}\r\n}\r\n\r\n// .AddAutoSchema<Query>()\r\n```"
      },
      {
        "user": "Revazashvili",
        "created_at": "2022-06-23T14:39:41Z",
        "body": "if i'am not wrong, my example's sdl will be:\r\n```\r\nschema {\r\n  query: Query\r\n}\r\n\r\ntype Query {\r\n  UserQuery: UserQuery\r\n  PostQuery: PostQuery\r\n}\r\n\r\ntype UserQuery{\r\n  user(id: Int!): [User!]!\r\n  users(limit: Int!, offset: Int!): [User!]!\r\n}\r\n\r\n```\r\nand query will be like that \r\n```\r\nquery {\r\n  UserQuery{\r\n    user(id:1)\r\n  }\r\n}\r\n```"
      }
    ]
  },
  {
    "number": 3109,
    "title": "Operation is not valid due to the current state of the object error",
    "created_at": "2022-04-28T23:31:21Z",
    "closed_at": "2023-04-03T19:55:35Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/3109",
    "body": "Hello, yesterday I had a question related to variables and ended up making this change,\r\n\r\nI changed Variables to,\r\n```\r\npublic JsonElement Variables\r\n{\r\n    get; set;\r\n}\r\n```\r\nand changed,\r\n```\r\nopts.Variables = serializer.ReadNode<Inputs>(request?.Variables);\r\n```\r\n\r\nHowever, today just the build with this change seems to be giving me an \r\n`Operation is not valid due to the current state of the object error` in the GraphQLMiddleware. I was wondering if I've missed something else during the variable upgrade ? Thank you",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/3109/comments",
    "author": "giy",
    "comments": [
      {
        "user": "giy",
        "created_at": "2022-04-28T23:46:39Z",
        "body": "So, I am going back to the other way,\r\n```\r\n[JsonConverter(typeof(ObjectDictionaryConverter))]\r\n        public Dictionary<string, object> Variables\r\n        {\r\n            get; set;\r\n```\r\n\r\nI tried replacing `ObjectDictionaryConverter` with \r\n```\r\n[JsonConverter(typeof(InputsJsonConverter))]\r\n        public Dictionary<string, object> Variables\r\n```\r\n\r\nBut that gives me an error too,\r\n```\r\n The converter specified on ...Api.Kestrel.GraphQLRequest.Variables' is not compatible with the type 'System.Collections.Generic.Dictionary`2[System.String,System.Object]'\r\n```\r\n\r\nWhat is the right way for me to replace `ObjectDictionaryConverter` ?"
      },
      {
        "user": "giy",
        "created_at": "2022-04-29T01:32:39Z",
        "body": "Added,\r\n```\r\nif (request?.Variables != null && request.Variables.ValueKind != JsonValueKind.Undefined)\r\n{\r\n    variables = serializer.ReadNode<Inputs>(request.Variables);\r\n}\r\n``` but just want to make sure this looks right for all cases"
      },
      {
        "user": "Shane32",
        "created_at": "2022-04-29T02:02:10Z",
        "body": "```cs\r\n[JsonConverter(typeof(InputsJsonConverter))]\r\npublic Inputs Variables { get; set; }\r\n```"
      },
      {
        "user": "Shane32",
        "created_at": "2022-04-29T02:02:47Z",
        "body": "Then `opts.Variables = request.Variables;`"
      }
    ]
  },
  {
    "number": 2885,
    "title": "accessor.Context is null when using DataLoader with a custom document executor",
    "created_at": "2022-01-27T12:31:58Z",
    "closed_at": "2022-01-27T14:06:29Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/2885",
    "body": "## Summary\r\n\r\nIn my Startup file I have the following configuration:\r\n```cs\r\n        public class CustomDocumentExecuter : DocumentExecuter { }\r\n\r\n        public void ConfigureServices(IServiceCollection services)\r\n        {\r\n            GraphQL.MicrosoftDI.GraphQLBuilderExtensions\r\n                .AddGraphQL(services)\r\n                .AddServer(true)\r\n                .AddSystemTextJson()\r\n                .AddErrorInfoProvider(opt => opt.ExposeExceptionStackTrace = Environment.IsDevelopment())\r\n                .AddDocumentExecuter<CustomDocumentExecuter>()\r\n                .AddSchema<StarWarsSchema>()\r\n                .AddGraphTypes(typeof(StarWarsSchema).Assembly)\r\n                .AddDataLoader();\r\n        }\r\n```\r\n\r\nThe StarWarsSchema contains a field that uses the DataLoader in the usual way:\r\n```\r\n            Field<StringGraphType>(\r\n                \"batchedName\",\r\n                resolve: context => accessor.Context.GetOrAddBatchLoader<string, string>(\r\n                    \"LoadName\", data.NameById).LoadAsync(context.Source.Id)\r\n                );\r\n```\r\n\r\nEverything works as expected if I leave out the `AddDocumentExecuter` call in the configuration, or if I add the standard `DocumentExecuter`. However, when I add the `CustomDocumentExecuter` above, even though it does not override anything, the dataloader accessor does not work any more - the `accessor.Context` then always gives `null`. The rest seems to work, only the fields using DataLoader show the problem.\r\n\r\nAm I doing anything wrong or is this a bug? How can I use a custom DocumentExecuter together with the DataLoader?\r\n\r\n### Environment\r\n\r\n```\r\n    <TargetFramework>net6.0</TargetFramework>\r\n```\r\n```\r\n    <PackageReference Include=\"GraphQL\" Version=\"4.7.1\" />\r\n    <PackageReference Include=\"GraphQL.DataLoader\" Version=\"4.7.1\" />\r\n    <PackageReference Include=\"GraphQL.MicrosoftDI\" Version=\"4.7.1\" />\r\n    <PackageReference Include=\"GraphQL.Server.Core\" Version=\"5.2.0\" />\r\n    <PackageReference Include=\"GraphQL.Server.Transports.AspNetCore\" Version=\"5.2.0\" />\r\n    <PackageReference Include=\"GraphQL.Server.Transports.AspNetCore.SystemTextJson\" Version=\"5.2.0\" />\r\n```",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/2885/comments",
    "author": "Cito",
    "comments": [
      {
        "user": "Shane32",
        "created_at": "2022-01-27T13:14:00Z",
        "body": "Just guessing but your custom document executor probably doesn\u2019t have the proper constructor that allows dependency injection to inject all the necessary classes. You need the most complex one available for proper operation. "
      },
      {
        "user": "Cito",
        "created_at": "2022-01-27T14:01:16Z",
        "body": "Thanks for reminding me that in C# the constructors are not inherited. After adding the most complex one, as you suggested, it works now.\r\n\r\nActually all I want to do is change the ExecutionStrategy for Queries from Parallel to Serial. So I'm using the following class now as DocumentExecuter. Is there a simpler way to achieve this?\r\n\r\n```cs\r\n    public class SerialDocumentExecuter : DocumentExecuter\r\n    {\r\n        public SerialDocumentExecuter(\r\n            IDocumentBuilder documentBuilder, IDocumentValidator documentValidator,\r\n            IComplexityAnalyzer complexityAnalyzer, IDocumentCache documentCache,\r\n            IEnumerable<IConfigureExecution>? configurations)\r\n            : base(documentBuilder, documentValidator, complexityAnalyzer, documentCache, configurations) { }\r\n\r\n        protected override IExecutionStrategy SelectExecutionStrategy(ExecutionContext context)\r\n        {\r\n            return context.Operation.OperationType switch\r\n            {\r\n                OperationType.Query => SerialExecutionStrategy.Instance,\r\n                OperationType.Mutation => SerialExecutionStrategy.Instance,\r\n                OperationType.Subscription => throw new NotSupportedException(\r\n                    \"DocumentExecuter does not support executing subscriptions.\"),\r\n                _ => throw new InvalidOperationException(\r\n                    $\"Unexpected OperationType {context.Operation.OperationType}\")\r\n            };\r\n        }\r\n    }\r\n```\r\n"
      },
      {
        "user": "Shane32",
        "created_at": "2022-01-27T14:02:39Z",
        "body": "No, that is the recommended pattern."
      }
    ]
  },
  {
    "number": 2727,
    "title": "Incorrect resolver return type when using batch loader and GraphQL.MicrosoftDI",
    "created_at": "2021-12-06T09:08:11Z",
    "closed_at": "2021-12-06T17:22:08Z",
    "labels": [
      "question",
      "data loader"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/2727",
    "body": "## Summary\r\nWithout GraphQL.MicrosoftDI it works:\r\n\r\n```csharp\r\nField<NonNullGraphType<OrgType>, OrgProto>()\r\n    .Name(\"org\")\r\n    .Description(\"Organization details\")\r\n    .ResolveAsync(context => accessor.Context\r\n        .GetOrAddBatchLoader<long, OrgProto>(\r\n            loaderKey: context.Path + context.FieldAst.Name,\r\n            fetchFunc: batchLoaders.Orgs(context))\r\n        .LoadAsync(context.Source.OrgId)); // LoadAsync returns IDataLoaderResult<Org>\r\n```\r\n\r\nHowever when using GraphQL.MicrosoftDI and .WithService() I get compile error:\r\n\r\n```csharp\r\nField<NonNullGraphType<OrgType>, OrgProto>()\r\n    .Name(\"org\")\r\n    .Description(\"Organization details\")\r\n    .Resolve() // <=== Resolve\r\n    .WithService<BatchLoaders>() // <=== WithService\r\n    .ResolveAsync((context, batchLoaders) => accessor.Context\r\n        .GetOrAddBatchLoader<long, OrgProto>(\r\n            loaderKey: context.Path + context.FieldAst.Name,\r\n            fetchFunc: batchLoaders.Orgs(context))\r\n        .LoadAsync(context.Source.OrgId));\r\n```\r\n\r\nI get following compile error:\r\n```\r\nCannot convert expression type 'GraphQL.DataLoader.IDataLoaderResult<Flymachine.Proto.Orgs.Org>' \r\nto return type 'System.Threading.Tasks.Task<Flymachine.Proto.Orgs.Org>'\r\n```\r\n\r\nWhy I get this error? It seems I can fix this by using `.LoadAsync(...).GetResultAsync()` but I am not sure if it won't break batch loader functionality?:\r\n\r\n```csharp\r\nField<NonNullGraphType<OrgType>, OrgProto>()\r\n    .Name(\"org\")\r\n    .Description(\"Organization details\")\r\n    .Resolve() // <=== Resolve\r\n    .WithService<BatchLoaders>() // <=== WithService\r\n    .ResolveAsync((context, batchLoaders) => accessor.Context\r\n        .GetOrAddBatchLoader<long, OrgProto>(\r\n            loaderKey: context.Path + context.FieldAst.Name,\r\n            fetchFunc: batchLoaders.Orgs(context))\r\n        .LoadAsync(context.Source.OrgId).GetResultAsync()); // <=== .GetResultAsync(), no compile error\r\n```\r\n\r\n~~Is it okay to return `IDataLoaderResult.GetResultAsync()` here? I had no chance yet to test it properly as I am rewriting pretty big schema which fails to compile for now...~~ - finally managed to compile and run the schema and for sure `GetResultAsync()` can't be used because it causes batch-loaders to execute separately and not in batch. So the problem is with types when using `Resolve().WithService<Service>().ResolveAsync(...)`.\r\n\r\n### Environment (if relevant)\r\n\r\nGraphQL.net 4.5.0\r\n.net 5.0\r\nC# 9\r\n",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/2727/comments",
    "author": "alekbarszczewski",
    "comments": [
      {
        "user": "Shane32",
        "created_at": "2021-12-06T15:11:15Z",
        "body": "Technically the data loader's LoadAsync method is a synchronous method, not asynchronous.  So properly it should not have been called `LoadAsync` at all, which is what makes this confusing.\r\n\r\nJust change your code like this and all will be fine:\r\n\r\n```cs\r\nField<NonNullGraphType<OrgType>, IDataLoaderResult<OrgProto>>()\r\n    .Name(\"org\")\r\n    .Description(\"Organization details\")\r\n    .Resolve() // <=== Resolve\r\n    .WithService<BatchLoaders>() // <=== WithService\r\n    .Resolve((context, batchLoaders) => accessor.Context\r\n        .GetOrAddBatchLoader<long, OrgProto>(\r\n            loaderKey: context.Path + context.FieldAst.Name,\r\n            fetchFunc: batchLoaders.Orgs(context))\r\n        .LoadAsync(context.Source.OrgId));\r\n```\r\n\r\nI don't see a real easy to write an extension method to 'fix' this.  FYI, the reason the other syntax works is because there are a number of extension methods in `DataLoaderExtensions.cs` defined to allow that and similar syntax."
      }
    ]
  },
  {
    "number": 2610,
    "title": "how does the defaultValue of GetArgument work?",
    "created_at": "2021-07-15T12:41:41Z",
    "closed_at": "2021-07-19T10:22:19Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/2610",
    "body": "Hey guys,\r\n\r\nI'm a bit confused about the defaultValue of the GetArgument function.\r\n\r\n`var myArgument = resolveFieldContext.GetArgument(\"myArgument\", string.Empty);`\r\n\r\nI would expect that `myArgument` has an empty string (`\"\"`) as value when no argument is passed. instead the result is `null`. \r\nWhat do I miss here?\r\n\r\n`var myArgument = resolveFieldContext.GetArgument(\"myArgument\") ?? \"\";` works as expected.",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/2610/comments",
    "author": "thezeronine",
    "comments": [
      {
        "user": "Shane32",
        "created_at": "2021-07-15T15:32:54Z",
        "body": "I'd need to see the exact query.  If the field argument was passed null, then null will be returned.  If the field argument is set to a variable, and the variable was set to null, then null will be returned.  If the field argument was set to a variable, and variable default's value is null, and the variable was not specified, then null will be returned.  If the field argument was completely unspecified, then the field argument's default value will be examined and returned if it is not null.  Only if the field argument was completely unspecified and there is no default value set for the field argument will the default value be taken from GetArgument.  If you simply want null values to be replaced with empty strings, then you want to use the syntax you already mentioned (`?? \"\"`) rather than specifying a default value to GetArgument.\r\n\r\nNote that there is no way to set a field argument's default value to a specific value of null -- in that case null by definition is unspecified within GraphQL.NET."
      }
    ]
  },
  {
    "number": 2594,
    "title": "AutoRegisteringObjectGraphType<> doesnt create default expression resolvers for the auto generated fields?",
    "created_at": "2021-07-08T15:07:17Z",
    "closed_at": "2021-07-14T13:38:03Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/2594",
    "body": "Does AutoRegisteringObjectGraphType<> not create the default expression resolvers for the auto generated fields?\r\nIf not ,then how do we update these fields? \r\n\r\nMy scenario is that I'm creating the corresponding graphtypes at runtime using classes that are dynamically created at run time. I'm having these runtime created graphtypes inherit from AutoRegisteringObjectGraphType<>. I guess that since the resolvers for these fields are missing,graphql is not able to filter these fields from the output. \r\n\r\nIs there a way by which I can programmatically update the expression resolvers for these autogenerated fields after the graphtype has been generated at runtime?",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/2594/comments",
    "author": "truptivishe-gep",
    "comments": [
      {
        "user": "Shane32",
        "created_at": "2021-07-08T15:30:28Z",
        "body": "You'd probably want to exclude fields that you were going to define manually from the auto-generation process.  You can do so by passing a `params` list of expressions to the `AutoRegisteringObjectGraphType` constructor (the base constructor).  Does that answer your question?"
      },
      {
        "user": "truptivishe-gep",
        "created_at": "2021-07-09T07:01:58Z",
        "body": "Is there no way to have AutoRegisteringObjectGraphType generate the default resolvers?"
      },
      {
        "user": "Shane32",
        "created_at": "2021-07-09T07:19:44Z",
        "body": "I\u2019m not sure what your question is. For the fields it auto creates, yes it creates resolvers for them. "
      },
      {
        "user": "truptivishe-gep",
        "created_at": "2021-07-09T09:20:47Z",
        "body": "The resolvers are not getting created for me when I'm generating the class in the below manner :\r\n\r\nMy main method -\r\n`\r\nType dataModelType = dataModelTypes.GetValueOrDefault(dataModelTypeClassName);\r\nTypeBuilder typeBuilder = CreateClassBuilder(dataModelTypeClassName, dataModelType);\r\nCreateConstructor(typeBuilder);\r\nType type = typeBuilder.CreateType();\r\n`\r\n\r\nOther methods to generate the graphQL type class - \r\n\r\n`\r\n        private TypeBuilder CreateClassBuilder(string className, Type classType)\r\n        {\r\n            TypeBuilder typeBuilder = moduleBuilder.DefineType(className + \"GraphType\"\r\n                                , TypeAttributes.Public |\r\n                                TypeAttributes.Class |\r\n                                TypeAttributes.AutoClass |\r\n                                TypeAttributes.AnsiClass |\r\n                                TypeAttributes.BeforeFieldInit |\r\n                                TypeAttributes.AutoLayout\r\n                                , null);\r\n            typeBuilder.SetParent(typeof(AutoRegisteringObjectGraphType<>).MakeGenericType(classType));\r\n            //typeBuilder.SetParent(typeof(ObjectGraphType<>).MakeGenericType(classType));\r\n            return typeBuilder;\r\n        }\r\n\r\n        private void CreateConstructor(TypeBuilder typeBuilder)\r\n        {\r\n            typeBuilder.DefineDefaultConstructor(MethodAttributes.Public | MethodAttributes.SpecialName | MethodAttributes.RTSpecialName);\r\n        }\r\n`\r\n\r\nAfter registering the mapping for these classes in the Schema, when I check the Schma->AllTypes->the fieldtypes generated for these do not contain the resolvers\r\n\r\n"
      },
      {
        "user": "Shane32",
        "created_at": "2021-07-09T12:58:59Z",
        "body": "Are you saying that the Resolver property for the field is null? That\u2019s normal. During execution, fields with a null resolver property will resolve the field by matching the field name to a property of the context.Source - which is what the AutoRegisteringObjectGraphType used to create the field to begin with. So it will resolve properly even though the resolver property is null. "
      }
    ]
  },
  {
    "number": 2582,
    "title": "Why IDataLoaderResult instead of Task from DataLoader?",
    "created_at": "2021-06-30T09:56:31Z",
    "closed_at": "2021-08-27T12:28:28Z",
    "labels": [
      "question",
      "data loader"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/2582",
    "body": "In previous versions (I'm coming from 2.x) the dataloader method 'LoadSync' returned a task. This was nice because that if I needed to make multiple calls the the same dataloader in one field I could just run something like:\r\n\r\n```\r\nawait Task.WhenAll(dataLoadersTasks);\r\n```\r\n\r\nNow with the new IDataLoaderResult I have to chain them with `.Then(...)`. If I want to make many calls to dataloaders that chain would be long. In node/javascript we have moved away from this type of syntax chaining in favor for the async/await stuff.\r\n\r\nIn one of my fields in the gql api I get a list of articleids for which I want to fetch prices for. The batch loaders `LoadAsync` method takes one id as input but now I have a list of ids. Before I just ran `await Task.WhenAll(dataLoadersTasks)` for all these calls to the dataloader. How can I do the same with a list of IDataLoaderResult?\r\n\r\nI also have another problem. I have a interface like:\r\n\r\n```\r\npublic interface IPricingService : ICommerceService\r\n    {\r\n        IDataLoaderResult<Price> GetPrice(string articleId); //Now\r\n        Task<Price> GetPrice(string articleId); //Previously\r\n    }\r\n```\r\n\r\nI have multiple implementations (multiple ecom systems for different markets) of this service. One of them is using a datalaoder and another is not. It depends on the ecom system if there is any need for the dataloader.\r\n\r\nSo now the interface of this service has to return a IDataLoaderResult since the graphql field needs to have the dataloader returned for it to work.\r\n\r\nIs there any way to convert the dataloader to a task so I can batch them and still have the exection strategy trigger the loading at the end of the graphql request so that batch loaders are actually batched.\r\n\r\nI tried the `GetResultAsync` method that returns a task but it also triggers the underlying fetch function so stuff are no longer batched.\r\n\r\nDoes my questions/inputs make any since? :)\r\n",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/2582/comments",
    "author": "magnusottosson",
    "comments": [
      {
        "user": "magnusottosson",
        "created_at": "2021-06-30T10:05:40Z",
        "body": "I just found this extension. That would solve the \"load many\" instead of chaining issue I guess.\r\n\r\n```\r\n/// <summary>\r\n        /// Asynchronously load data for the provided given keys\r\n        /// </summary>\r\n        /// <param name=\"dataLoader\">The dataloader to use</param>\r\n        /// <param name=\"keys\">Keys to use for loading data</param>\r\n        /// <returns>\r\n        /// A task that will complete when the DataLoader has been dispatched,\r\n        /// or a completed task if the result is already cached.\r\n        /// </returns>\r\n        public static IDataLoaderResult<T[]> LoadAsync<TKey, T>(this IDataLoader<TKey, T> dataLoader, IEnumerable<TKey> keys)\r\n        {\r\n            var results = new List<IDataLoaderResult<T>>();\r\n\r\n            foreach (var key in keys)\r\n            {\r\n                results.Add(dataLoader.LoadAsync(key));\r\n            }\r\n\r\n            return new DataLoaderResultWhenAll<T>(results);\r\n        }\r\n\r\n        private class DataLoaderResultWhenAll<T> : IDataLoaderResult<T[]>\r\n        {\r\n            private readonly IEnumerable<IDataLoaderResult<T>> _dataLoaderResults;\r\n\r\n            public DataLoaderResultWhenAll(IEnumerable<IDataLoaderResult<T>> dataLoaderResults)\r\n            {\r\n                _dataLoaderResults = dataLoaderResults ?? throw new ArgumentNullException(nameof(dataLoaderResults));\r\n            }\r\n\r\n            public Task<T[]> GetResultAsync(CancellationToken cancellationToken = default)\r\n                => Task.WhenAll(_dataLoaderResults.Select(x => x.GetResultAsync(cancellationToken)));\r\n\r\n            async Task<object> IDataLoaderResult.GetResultAsync(CancellationToken cancellationToken)\r\n                => await GetResultAsync(cancellationToken).ConfigureAwait(false);\r\n        }\r\n```"
      },
      {
        "user": "Shane32",
        "created_at": "2021-06-30T14:40:08Z",
        "body": "I wrote the new data loaders and can explain why the new data loaders are designed the way they are, and provide some possible solutions.\r\n\r\nIn short, the task-based data loaders were insufficient because the execution was immediately awaited upon within the execution strategy.  To prevent the data loader from executing right away, the data loader would be paused until triggered by a document execution listener.  But this meant that a deadlock would always occur in either of these two scenarios:\r\n\r\n1. A field resolver awaits a data loader to retrieve information and then awaits another data loader.\r\n2. Within the field resolver, an asynchronous task is awaited prior to awaiting the data loader.\r\n\r\nThe prior design also meant:\r\n\r\n- It was incompatible with serial execution strategies, as the execution strategy knew nothing of data loaders and would execute each field resolver sequentially.  Support for the serial execution strategy is very important to anyone using Entity Framework as the underlying ORM (although there are workarounds).\r\n- It did not work within mutations (since mutations run with a serial execution strategy by default)\r\n- It was very slow (seen when loading 100s of data loaders in one execution).\r\n- It had an issue with federation.\r\n- A canceled GraphQL request could cause a pending data loader node to hang.\r\n\r\nAll of these issues have been solved with the new design, even though it may not be as elegant to use.  (See PR #1511)\r\n\r\nWith the new design, `IDataLoaderResult<>` is simply a thin wrapper around a delegate that returns a `Task<>` so that the execution strategy can identify that the result should not be executed immediately, and instead run and await the data loader after all other code has been executed.\r\n\r\nYou can easily \"convert\" a data loader result to a `Task<>` by calling `IDataLoaderResult.GetResultAsync<>`.  It will execute immediately of course, as you already have seen.  You can also turn any async delegate \"into a dataloader\" (so it will run at the appropriate time during the execution strategy) by calling `new SimpleDataLoader(asyncDelegate)`.  Then the delegate will be called at the correct time.  You cannot \"turn a Task into a data loader\".  The Task has already begun; it cannot be queued to run later.\r\n\r\nI think the idea to grasp here is that .NET always intended a `Task` to represent an execution that has already started and is either completed or pending completion.  Not one that has been 'paused' or 'not started'.  And delegates were designed to represent an execution that has not occurred yet.  The new design matches the .NET philosophy (with a thin wrapper around the delegate), rather than trying to get Tasks to do something they were never designed for.  I do grant you that the old design was easier to use -- but only in the specific scenarios supported by the framework.\r\n\r\nYou can certainly write your own code within v3/v4 to 'pause' a Task until triggered by a `DocumentExecutionListener`'s `OnBeforeExecutionStepAwaitedAsync` step, just as occurred in v2, or even copy the entire previous DataLoader v2 implementation in to v3/v4 -- but `OnBeforeExecutionStepAwaitedAsync` is deprecated and is planned to be removed in v5.\r\n\r\nLet me know if you have a specific scenario for which you would like a suggestion or have a question."
      },
      {
        "user": "Shane32",
        "created_at": "2021-06-30T14:52:50Z",
        "body": "We have also moved all the data loader code to its own library; you can write your own if you have specific needs.  The only data-loader specific functionality within the main library is to look for `IDataLoaderResult` objects returned from field resolvers, and execute `GetResultAsync` after all other nodes have executed.  And the interface is only this:\r\n\r\n```cs\r\n    public interface IDataLoaderResult\r\n    {\r\n        Task<object> GetResultAsync(CancellationToken cancellationToken = default);\r\n    }\r\n```\r\nEverything else is built on top of that.  And, until v5, the old v2 data loaders would work (to the extent they ever worked) within v3/v4 if you copy the code over."
      },
      {
        "user": "magnusottosson",
        "created_at": "2021-08-18T08:59:07Z",
        "body": "Hi, thanks for the very detailed explanation. I think that my problem is that I have the dataloader code a bit seperated from the graphl code.\r\n\r\nSo its like:\r\n\r\nthe graphql filed `price` tries to fetch prices, further down in a \u00b4PriceService` it looks as some config code and depending on the settings the code goes into a price service implementation that wants to batch load prices from another system. After the price if fetched the logic contiues and it performs some formatting etc... so I guess I will have to put all of this code within the batch loader right?\r\n\r\nSo the field resolver doesnt actually know that it needs to use a dataloader. If I create a `SimpleDataLoader` instance I need to return that in the field resolver otherwise it will never be triggered right?"
      },
      {
        "user": "Shane32",
        "created_at": "2021-08-18T15:58:14Z",
        "body": "> so I guess I will have to put all of this code within the batch loader right?\r\n\r\nI think so.\r\n\r\n> If I create a SimpleDataLoader instance I need to return that in the field resolver otherwise it will never be triggered right?\r\n\r\nRight\r\n\r\nThe obvious suggestion is to change the signature of the method in `PriceService` to return a `IDataLoaderResult<>` (or `Task<IDataLoaderResult<>>`).  Any code that executes after a data loader call needs to be chained with `Then` or similar.  I understand this is probably a pain if you have multiple layers of business logic, but I don't have a better suggestion.  At that point, you have two choices for your `PriceService` implementation:\r\n\r\n1. If the data is immediately available, such as if it's in a cache, return a `DataLoaderResult<>` containing the data.  If not, return an actual data loader that will retrieve the data.  Keep in mind that the remainder of the method call will not run immediately, but will execute after any pending calls have completed, in parallel with any other data loader executions.  (Or in series for a serial execution strategy.)\r\n2. Move all the logic into the data loader.  Within the data loader you can return results for data that is immediately available (such as cached data), and make your DB call or similar for the remaining keys.  All results will need to wait for the data loader to complete, even if the data was immediately available.  (Of course, if all data is immediately available, no DB call would exist and there would be no additional wait.)\r\n\r\nYou do have another option.  You can return type `object` from your service, which can be an immediate value (such as 23.44) or a data loader like `IDataLoaderResult<float>`.  This would be a real pain to chain with other calls, however; I wouldn't recommend it.\r\n\r\nFinally, you can always import the GraphQL.NET 2.x data loader code and use it with very few changes.  Even if the `OnBeforeExecutionStepAwaitedAsync` method is removed in GraphQL.NET 5.x, you could copy the applicable execution strategy class and add the necessary code without much effort to keep the old data loader design operating.  It may sound like a lot of hacking, but going forward you'd really only need to maintain the duplicate `ParallelExecutionStrategy` (or `SerialExecutionStrategy`) from the main project, which is only about 100 lines of code; the rest would then be your own data loader implementation.  But as of 4.x you would not need to modify the execution strategy."
      },
      {
        "user": "magnusottosson",
        "created_at": "2021-08-27T12:28:28Z",
        "body": "Thanks, we will change our interface so that we are returnin a IDataLoaderResult instead of a Task. A bit less generic but it will work. Thank you so much for you help!"
      }
    ]
  },
  {
    "number": 2506,
    "title": "In FieldMiddleware how to access FileldDefinitions (and metadata) of all fields in a query?",
    "created_at": "2021-04-16T05:43:09Z",
    "closed_at": "2021-04-17T15:08:47Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/2506",
    "body": "## Summary\r\n\r\nMy use case is that on root query/mutation level I need to traverse all selected field types and access their metadata before initial/root resolver is called. For example for query `query { a { b { c, d } } }` before executing resolver of `a` I need to gather metadata from `a`, `b`, `c` and `d` fields.\r\n\r\n## Relevant information\r\n\r\n```c#\r\nusing System;\r\nusing System.Linq;\r\nusing System.Threading.Tasks;\r\nusing GraphQL;\r\nusing GraphQL.Instrumentation;\r\nusing GraphQL.Language.AST;\r\n\r\nnamespace MyProject\r\n{\r\n    public class MyMiddleware : IFieldMiddleware\r\n    {\r\n        public async Task<object> Resolve(IResolveFieldContext context, FieldMiddlewareDelegate next)\r\n        {\r\n            if (context.Parent == null)\r\n            {\r\n                // context.FieldDefinition.Metadata; // <- here I can access root field metadata (\"a\" in example)\r\n                var b = context.SubFields[\"b\"];\r\n                \r\n                Console.WriteLine(b.Name); // prints \"b\"\r\n                \r\n                // but how to access FieldDefinition / metadata of \"b\"?\r\n            }\r\n            return await next(context);\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/2506/comments",
    "author": "alekbarszczewski",
    "comments": [
      {
        "user": "sungam3r",
        "created_at": "2021-04-16T10:34:28Z",
        "body": "Maybe to use `context.Schema` to get all requested fields and their metadata ?"
      },
      {
        "user": "alekbarszczewski",
        "created_at": "2021-04-17T15:08:09Z",
        "body": "Thanks, using `context.Schema` I was able to get all fields metadata:\r\n\r\n```c#\r\npublic class AuthContextResolver : IFieldMiddleware\r\n    {\r\n        public async Task<object> Resolve(IResolveFieldContext context, FieldMiddlewareDelegate next)\r\n        {\r\n            if (context.Parent == null)\r\n            {\r\n                VisitFields(context.ParentType, context.FieldAst, (fieldType, field) =>\r\n                {\r\n                    // you can access fieldType.Metadata here\r\n                    return true;\r\n                });\r\n            }\r\n            return await next(context);\r\n        }\r\n\r\n        private void VisitFields(IObjectGraphType objectType, Field field, Func<FieldType, Field, bool> visitor)\r\n        {\r\n            var fieldType = objectType.Fields.First(type => type.Name == field.Name);\r\n            if (!visitor(fieldType, field))\r\n            {\r\n                return;\r\n            }\r\n            foreach (var selection in field.SelectionSet.Selections)\r\n            {\r\n                if (selection is Field && fieldType.ResolvedType is IObjectGraphType)\r\n                {\r\n                    VisitFields((IObjectGraphType) fieldType.ResolvedType, (Field) selection, visitor);\r\n                }\r\n            }\r\n        }\r\n    }\r\n```"
      }
    ]
  },
  {
    "number": 2503,
    "title": "Using output type in the response of mutations",
    "created_at": "2021-04-15T06:06:26Z",
    "closed_at": "2021-04-15T07:28:48Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/2503",
    "body": "## Summary\r\nI want to send a field of `ObjectGraph` type in the response of a mutation. I am using apollo GraphQL on the client-side. Returning this way helps with the caching.\r\nI tried to add a field for `ItemGraph` inside `ItemInputGraph`.  But, it will throw an exception since `ItemInputGraph` is of `IInputObjectGraphType` type. Is it possible to add this only at the response of a mutation?\r\n\r\n`mutation MarkAsCompleted($item:ItemInputGraph!){\r\n    markAsCompleted(item: $item){\r\n        success\r\n        item { # this should be the same output type used for querying item\r\n            id\r\n            name\r\n            type\r\n            isCompleted\r\n            completedOn\r\n            completedBy\r\n        }\r\n    }\r\n}`\r\n\r\n\r\n",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/2503/comments",
    "author": "athomasec",
    "comments": [
      {
        "user": "Shane32",
        "created_at": "2021-04-15T06:22:19Z",
        "body": "Input types and output types are distinct according to the GraphQL specification. An input type cannot be used for returning data and an output type cannot be used for a field argument. GraphQL.NET enforces this rule.\r\n\r\nYou can however create matching input and output types that map to the same fields of the same type of object. \r\n\r\nThere is also no issue having the item field of the mutation result match the same type as a query for the item. You might simply be adding the field to the wrong graph - rather than adding it to the input graph, you want to add it to the return type of the mutation graph. "
      }
    ]
  },
  {
    "number": 2496,
    "title": "How to create single request object from multiple queries input arguments?",
    "created_at": "2021-04-10T18:22:46Z",
    "closed_at": "2022-02-04T23:33:35Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/2496",
    "body": "I am working on migrating legacy use cases to our new `GraphQL` service. \r\n\r\n- Internally all our requests gets mapped to single `ProcessRequest` object which holds all input arguments being passed from Schema. \r\n- Then we pass this `ProcessRequest` object to underlying methods which in turn returns back `ProcessResponse` object which has response for that request.\r\n\r\nBelow is `ProcessRequest` class:\r\n\r\n    public interface IProcess\r\n    {\r\n        int ClientId { get; set; }\r\n        int LanguageId { get; set; }\r\n        int CustomerId { get; set; }\r\n    }\r\n\r\n    public interface IData\r\n    {\r\n        IList<Filter> Filters { get; set; }\r\n        KeywordsTemplate KeywordsTemplate { get; set; }\r\n    }\r\n\r\n    public class Filter\r\n    {\r\n        public string Key { get; set; }\r\n        public int Value { get; set; }\r\n    }\r\n\r\n    public class KeywordsTemplate\r\n    {\r\n        public string Query { get; set; }\r\n        public string UserQuery { get; set; }\r\n    }\r\n\r\n    public class ClientType\r\n    {\r\n        public string ClientKey { get; set; }\r\n    }\r\n\r\n    public class Shop\r\n    {\r\n        public double CartAmount { get; set; }\r\n        public double PromoAmount { get; set; }\r\n        public IList<int> ClientIds { get; set; }\r\n    }\r\n\r\n    public class ListingRequest\r\n    {\r\n        public IList<Filter> Filters { get; set; }\r\n        public int ClientNumber { get; set; }\r\n        public string PotType { get; set; }\r\n        public IList<int> ClientIds { get; set; }\r\n    }\r\n\r\n    public class ListingsRequest\r\n    {\r\n        public IList<ListingRequest> Listings { get; set; }\r\n    }\r\n\r\n    public class ProcessRequest : IData, IProcess\r\n    {\r\n        public DetailsRequest DetailsRequest { get; set; }\r\n        public ClientType ClientType { get; set; }\r\n        public ListingsRequest ListingsRequest { get; set; }\r\n        public ProtoRequest ProtoRequest { get; set; }\r\n\r\n        public IList<Filter> Filters { get; set; }\r\n        public KeywordsTemplate KeywordsTemplate { get; set; }\r\n        public int ClientId { get; set; }\r\n    }\r\n\r\nFor my below `GraphQL` query - I map input arguments to my `ProcessRequest` class and then call corresponding methods to get `ProcessResponse` object. Then I created a corresponding model `LandingGroup` from `ProcessResponse` class which exactly matches with what I need in `GraphQL` response for my below `contentRequest` query and then I use that in my `ContentResponseType` class to get what I need.\r\n\r\n    {\r\n      contentRequest(clientId: 123, filters: [{key: \"abc\", value: \"98\"}], clientKey: \"process\") {\r\n        title\r\n        id\r\n        name\r\n      }\r\n    }\r\n\r\nBelow is how I am using my Query -\r\n\r\n    public class TitanQuery : ObjectGraphType<object>\r\n    {\r\n        public TitanQuery(....)\r\n        {\r\n            Name = \"Query\";\r\n\r\n            FieldAsync<ListGraphType<ContentResponseType>>(\r\n                \"contentRequest\",\r\n                arguments: new QueryArguments(\r\n                        new QueryArgument<NonNullGraphType<IntGraphType>>\r\n                        {\r\n                            Name = \"clientId\",\r\n                            Description = \"Client Id of the request\"\r\n\r\n                        },\r\n                        new QueryArgument<ListGraphType<FilterType>>\r\n                        {\r\n                            Name = \"filters\",\r\n                            Description = \"Filters\"\r\n                        },\r\n                        new QueryArgument<StringGraphType>\r\n                        {\r\n                            Name = \"clientKey\",\r\n                            DefaultValue = \"abc\",\r\n                            Description = \"some stuff\"\r\n                        }\r\n                    ),\r\n\r\n                resolve: async context =>\r\n                {\r\n                    var clientId = context.GetArgument<int>(\"clientId\");\r\n                    var filters = context.GetArgument<List<Filter>>(\"filters\");\r\n                    var clientKey = context.GetArgument<string>(\"clientKey\");\r\n\r\n                    // mapping all the arguments to ProcessRequest class\r\n                    ProcessRequest processRequest = new ProcessRequest()\r\n                    {\r\n                        ClientId = clientId,\r\n                        Filters = filters,\r\n                        ClientType = new ClientType()\r\n                        {\r\n                            ClientKey = clientKey\r\n                        },\r\n                        ProtoRequest = new ProtoRequest()\r\n                    };\r\n\r\n                    // below line returns 'ProcessResponse' object by using 'processRequest' object\r\n                    var processResponse = await metadataService.ProcessData(processRequest);\r\n\r\n                    var dataGroups = processResponse.LandingResponse.DataGroups.Select(dataGroup => new LandingGroup\r\n                    {\r\n                        DataGroup = dataGroup,\r\n                        TileContext = processResponse.TileContext\r\n                    });\r\n\r\n                    return dataGroups;\r\n                }\r\n            );\r\n        }\r\n    }\r\n\r\n**Problem Statement**\r\n\r\nEverything works fine for my above single schema use case. Now I have a very different use case with multiple schemas as shown below. I am not able to figure out on how to do it or whether it is even possible to do it? As you can see below I have three different schemas. \r\n\r\n- All the input arguments from below queries maps to single `ProcessRequest` object. \r\n- And then I get single `ProcessResponse` object back from `ProcessRequest` object like the same old way as shown above in the `TitanQuery` class.\r\n- All the GraphQL response fields for each schema is already there in `ProcessResponse` object so I need to find a way to return all those fields back to `GraphQL` response for each query.\r\n- `clientId`, `filters` will be there in all the schemas with same values. They will map to corresponding field in `ProcessRequest` class.\r\n\r\nBelow is my query with multiple schemas:\r\n\r\n    {\r\n      contentRequest(clientId: 123, filters: [{key: \"hello\", value: \"98\"}], clientKey: \"process\") {\r\n        title\r\n        id\r\n        name\r\n      }\r\n      find(queryString: \"\", filters: [{key: \"hello\", value: \"98\"}], clientId: 1234) {\r\n        metricx {\r\n          name\r\n          key\r\n        }\r\n        prodCount\r\n      }\r\n      itemListings(pots: [{potType: \"KITE_1\", filters: [{key: \"c\", value: \"1341\"}]}, {potType: \"KITE_2\", filters: [{key: \"c\", value: \"9812\"}]}], filters: [{key: \"hello\", value: \"98\"}], clientId: 1234, clientKey: \"process\") {\r\n        potType\r\n        productAlgo\r\n        count\r\n        listingEndpoint\r\n      }\r\n    }\r\n\r\nNow my question is how can I make single `ProcessRequest` object by extracting input arguments from all my above queries? And then from single `ProcessResponse` object I need to extract all those fields which each of my query needs in `GraphQL` response. Also I am not sure if we can have different models from `ProcessResponse` object for different combinations of schemas and use them?\r\n\r\n**Note:**\r\n\r\n- I have simplified my response fields for each query to make it easier for understanding but in general they are complicated with lot of fields but all of those fields for each query are part of `ProcessResponse` object only.\r\n- Also this is our legacy use case which we are migrating to our new `GraphQL` service and that legacy service passes queries in that format as of now so we are trying to follow the same format if we can.\r\n",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/2496/comments",
    "author": "TechGeeky",
    "comments": [
      {
        "user": "Shane32",
        "created_at": "2021-04-11T16:07:00Z",
        "body": "Sure it is possible.  I have something similar in my own implementation.\r\n\r\nFor the sake of discussion, and since it will be easier to implement, let's add a layer to the query:\r\n\r\n```gql\r\n{\r\n  multipleQueryRequest {\r\n    contentRequest(clientId: 123, filters: [{key: \"hello\", value: \"98\"}], clientKey: \"process\") {\r\n      title\r\n      id\r\n      name\r\n    }\r\n    find(queryString: \"\", filters: [{key: \"hello\", value: \"98\"}], clientId: 1234) {\r\n      metricx {\r\n        name\r\n        key\r\n      }\r\n      prodCount\r\n    }\r\n    itemListings(pots: [{potType: \"KITE_1\", filters: [{key: \"c\", value: \"1341\"}]}, {potType: \"KITE_2\", filters: [{key: \"c\", value: \"9812\"}]}], filters: [{key: \"hello\", value: \"98\"}], clientId: 1234, clientKey: \"process\") {\r\n      potType\r\n      productAlgo\r\n      count\r\n      listingEndpoint\r\n    }\r\n  }\r\n}\r\n```\r\n\r\nThen you need to write code in the resolver method of `multipleQueryRequest` to examine all of the requested child fields and formulate a response.  The child graph objects then just pull from their source objects, ignoring the arguments passed to them. \r\n It ain't pretty, but it's possible.  I've written a sample to demonstrate:\r\n\r\n```cs\r\n    public class Test123Child\r\n    {\r\n        public int Child1a { get; set; }\r\n    }\r\n\r\n    public class Test123ChildGraphType : ObjectGraphType<Test123Child>\r\n    {\r\n        public Test123ChildGraphType()\r\n        {\r\n            Field(x => x.Child1a);\r\n        }\r\n    }\r\n    public class Test123\r\n    {\r\n        public Test123Child Child1 { get; set; }\r\n        public Test123Child Child2 { get; set; }\r\n    }\r\n    public class Test123GraphType : ObjectGraphType<Test123>\r\n    {\r\n        public Test123GraphType()\r\n        {\r\n            Field<Test123ChildGraphType, Test123Child>(\"Child1\")\r\n                .Argument<IntGraphType>(\"arg\");\r\n            Field<Test123ChildGraphType, Test123Child>(\"Child2\")\r\n                .Argument<IntGraphType>(\"arg\");\r\n        }\r\n    }\r\n    public class MyQuery : ObjectGraphType\r\n    {\r\n        public MyQuery()\r\n        {\r\n            Field<Test123GraphType>(\r\n                \"test123\",\r\n                resolve: ctx =>\r\n                {\r\n                    var thisGraphType = (Test123GraphType)ctx.FieldDefinition.ResolvedType.GetNamedType();\r\n\r\n                    var test123 = new Test123();\r\n                    var children = ctx.SubFields;\r\n                    if (children.ContainsKey(\"child1\"))\r\n                    {\r\n                        var child = children[\"child1\"];\r\n                        var args = thisGraphType.GetField(\"child1\").Arguments;\r\n                        var arguments = GraphQL.Execution.ExecutionHelper.GetArgumentValues(args, child.Arguments, ctx.Variables);\r\n                        var val = arguments.TryGetValue(\"arg\", out var argumentValue) ? (int)(argumentValue.Value ?? 0) : 0;\r\n                        test123.Child1 = new Test123Child { Child1a = val };\r\n                    }\r\n                    if (children.ContainsKey(\"child2\"))\r\n                    {\r\n                        var child = children[\"child2\"];\r\n                        var args = thisGraphType.GetField(\"child2\").Arguments;\r\n                        var arguments = GraphQL.Execution.ExecutionHelper.GetArgumentValues(args, child.Arguments, ctx.Variables);\r\n                        var val = arguments.TryGetValue(\"arg\", out var argumentValue) ? (int)(argumentValue.Value ?? 0) : 0;\r\n                        test123.Child2 = new Test123Child { Child1a = val };\r\n                    }\r\n                    return test123;\r\n                });\r\n        }\r\n    }\r\n\r\n        [Fact]\r\n        public void RunTest()\r\n        {\r\n            var queryString = \"query($arg: Int! = 2, $arg2: Int! = 3) { test123 { child1(arg: $arg) { child1a } child2(arg: $arg2) { child1a } } }\";\r\n            var expectedAnswer = @\"{ \"\"test123\"\": { \"\"child1\"\": { \"\"child1a\"\": 2 }, \"\"child2\"\": { \"\"child1a\"\": 3 } } }\";\r\n            AssertQuerySuccess(queryString, expectedAnswer, null);\r\n        }\r\n```\r\n\r\nAs you can see, most of the helper methods are unavailable to you because there is no `IResolveFieldContext` instance for the child fields.  Moreover, trying to examine the children of those children is still harder, because `SubFields` is not available.  And this implementation does not handle requests with aliases properly.  For instance, this request is entirely valid:\r\n\r\n```gql\r\n{\r\n  multipleQueryRequest {\r\n    hello: contentRequest(clientId: 123, filters: [{key: \"hello\", value: \"98\"}], clientKey: \"process\") {\r\n      title\r\n      id\r\n      name\r\n    }\r\n    widget: contentRequest(clientId: 123, filters: [{key: \"widget\", value: \"98\"}], clientKey: \"process\") {\r\n      title\r\n      id\r\n      name\r\n    }\r\n  }\r\n}\r\n```\r\n\r\nBut my sample code does not properly handle this request.  To properly handle this request also, you'd need to change the `Test123` class into a dictionary and store values into it based on the alias.  Then in the resolver of the child, it would need to pull the child object from the source (a dictionary), using the field alias as the dictionary key.  Finally, I didn't check to see if my sample works properly for fragments."
      },
      {
        "user": "TechGeeky",
        "created_at": "2021-04-12T01:15:11Z",
        "body": "@Shane32 Do we really need to add layer to the request like `multipleQueryRequest` you added? In my scenario I can have single query or multiple queries in the request depending on the use case as it's not fixed. \r\n\r\nOur customers can call us by passing single query in the request for some use case or multiple queries in the request for some other use case and I need to build `ProcessRequest` object accordingly so is there any way to do this without using any root layer like `multipleQueryRequest`? "
      },
      {
        "user": "Shane32",
        "created_at": "2021-04-12T01:25:14Z",
        "body": "Well sure you can write your own document executer implementation and examine the document before it calls the execution strategy. Then set the root object on the execution context before calling the execution strategy, so the source object is set in the context of the root query object. \r\n\r\nOf course if you keep the extra layer that doesn\u2019t mean it wouldn\u2019t work for a single request."
      },
      {
        "user": "TechGeeky",
        "created_at": "2021-04-12T01:39:22Z",
        "body": "Yeah it will work for a single request for sure. The reason I was asking is because as of now our customers call our **old service** like this for single query request - \r\n\r\n    {\r\n      contentRequest(clientId: 123, filters: [{key: \"hello\", value: \"98\"}], clientKey: \"process\") {\r\n        title\r\n        id\r\n        name\r\n      }\r\n    }\r\n\r\nor like this for multiple query request -\r\n\r\n    {\r\n      contentRequest(clientId: 123, filters: [{key: \"hello\", value: \"98\"}], clientKey: \"process\") {\r\n        title\r\n        id\r\n        name\r\n      }\r\n      find(queryString: \"\", filters: [{key: \"hello\", value: \"98\"}], clientId: 1234) {\r\n        metricx {\r\n          name\r\n          key\r\n        }\r\n        prodCount\r\n      }\r\n      itemListings(pots: [{potType: \"KITE_1\", filters: [{key: \"c\", value: \"1341\"}]}, {potType: \"KITE_2\", filters: [{key: \"c\", value: \"9812\"}]}], filters: [{key: \"hello\", value: \"98\"}], clientId: 1234, clientKey: \"process\") {\r\n        potType\r\n        productAlgo\r\n        count\r\n        listingEndpoint\r\n      }\r\n    }\r\n\r\nAnd for both the above cases, I need to map the arguments from each query to `ProcessRequest` class. Since we migrating them from **old service (uses javascript)** to **new service (uses dotnet)** so was trying to make sure they don't have to the change their request at all. This way they can just call new GraphQL endpoint with same requests and everything will work as it is.\r\n\r\nNow if we have to change the query request then I need to ask them to wrap their query with another static layer which I will use to extract child objects I guess. I can do that too but just trying to figure out if there is a way to do that without asking them to change anything?\r\n\r\nAlso **old service** is written in `Javascript` and uses `GraphQL` as well so does `Javascript` allows that to extract child objects without using any extra layer like we are adding here? This is just for my knowledge. @Shane32 "
      },
      {
        "user": "Shane32",
        "created_at": "2021-04-12T04:02:33Z",
        "body": "Certainly if you have an existing graphql schema then you would not want to change it.\r\n\r\nThere's another way you can implement your schema that would probably work much better: use a batch data loader to group up a number of requests and return them to each of the field resolvers.  Here's how I would set it up:\r\n\r\n1. Create a dummy interface and classes containing the request parameters each type of query.\r\n\r\n```cs\r\npublic interface IRequest\r\n{\r\n}\r\n\r\npublic class ContentRequest : IRequest\r\n{\r\n    public int ClientId { get; set; }\r\n    public List<Filter> Filters { get; set; }\r\n    public string ClientKey { get; set; }\r\n}\r\n\r\npublic class FindRequest : IRequest\r\n{\r\n    public string QueryString { get; set; }\r\n    // other query parameters\r\n}\r\n\r\npublic class ItemListingsRequest : IRequest\r\n{\r\n    // see above\r\n}\r\n```\r\n\r\n2. Create a custom data loader where the key is the dummy interface, and it returns an object.  The \"data loader\" can group all of the requests together server-side and respond with data for each of them.  Be sure caching is turned off.\r\n\r\n```cs\r\npublic class MyDataRequestor : DataLoaderBase<IRequest, object>\r\n{\r\n    private readonly IDataService _dataService; // <-- example service\r\n\r\n    public MyDataRequestor(IDataService dataService) : base(false)  // no caching\r\n    {\r\n        // pull DI services as necessary here\r\n        _dataService = dataService;\r\n    }\r\n\r\n    protected override async Task FetchAsync(IEnumerable<DataLoaderPair<IRequest, object>> list, CancellationToken cancellationToken)\r\n    {\r\n        // process all of the requests, calling SetResult on each of the pairs\r\n        // below is a simplified example that executes the requests sequentially, but you can change this as desired\r\n        foreach (var pair in list)\r\n        {\r\n            pair.SetResult(pair.Key switch\r\n                {\r\n                    // if the request is a ContentRequest, return a List<ContentResponse>\r\n                    ContentRequest contentRequest => await _dataService.ProcessContentRequestAsync(contentRequest, cancellationToken),\r\n\r\n                    FindRequest findRequest => await _dataService.ProcessFindRequestAsync(findRequest, cancellationToken),\r\n\r\n                    ItemListingsRequest itemListingsRequest => await _dataService.ProcessItemListingsRequestAsync(itemListingsRequest, cancellationToken),\r\n\r\n                    _ => throw new NotSupportedException()\r\n                });\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n3. Register the data loader in your DI container as a singleton or scoped, depending on your needs.  If you are going to register it as a singleton, be sure that data loader caching is turned off, or else it will eventually use all of the memory on your server as there is no technique to clear the cache.  Caching won't be useful anyway because without `Equals` being implemented on the class, none of the `IRequest` objects will equal each other.  (It is something that could be implemented, however.)\r\n\r\n4. Call the data loader from the `contentRequest`, `find`, and `itemListings` field resolvers.  If the data loader is registered as a singleton, you can include a reference in the graph type constructor.  If not, you will need to obtain a reference from `context.RequestServices`.  I am going to assume it is scoped in the below example.\r\n\r\n```cs\r\npublic class TitanQuery : ObjectGraphType<object>\r\n{\r\n    public TitanQuery(....)\r\n    {\r\n        Name = \"Query\";\r\n\r\n        FieldAsync<ListGraphType<ContentResponseType>>(\r\n            \"contentRequest\",\r\n            arguments: new QueryArguments(\r\n                    new QueryArgument<NonNullGraphType<IntGraphType>>\r\n                    {\r\n                        Name = \"clientId\",\r\n                        Description = \"Client Id of the request\"\r\n\r\n                    },\r\n                    new QueryArgument<ListGraphType<FilterType>>\r\n                    {\r\n                        Name = \"filters\",\r\n                        Description = \"Filters\"\r\n                    },\r\n                    new QueryArgument<StringGraphType>\r\n                    {\r\n                        Name = \"clientKey\",\r\n                        DefaultValue = \"abc\",\r\n                        Description = \"some stuff\"\r\n                    }\r\n                ),\r\n\r\n            resolve: async context =>\r\n            {\r\n                var dataLoader = context.RequestServices.GetRequiredService<MyDataRequestor>();\r\n                var request = new ContentRequest {\r\n                    ClientId = context.GetArgument<int>(\"clientId\"),\r\n                    Filters = context.GetArgument<List<Filter>>(\"filters\"),\r\n                    ClientKey = context.GetArgument<string>(\"clientKey\"),\r\n                };\r\n\r\n                // after being processed by the dataloader, will return a List<ContentResponse>\r\n                return dataLoader.LoadAsync(request);\r\n            }\r\n        );\r\n    }\r\n}\r\n```\r\n\r\nFYI, how data loaders work is that they will execute all nodes possible until none remain that can be executed.  Then it will execute/trigger all pending data loader nodes at once.  See `SerialExecutionStrategy` and `ParallelExecutionStrategy` source code for specifics.\r\n\r\nAlso, I'd be real careful about registering the data loader as a singleton.  Specifically, let's say two request come in at the same time like this:\r\n\r\n```gql\r\n# request A\r\n\r\nquery {\r\n  contentRequest { ... }\r\n}\r\n\r\n# request B\r\n\r\nquery {\r\n  contentRequest { ... }\r\n  find { ... }\r\n}\r\n```\r\n\r\nThen what can happen is that the two `contentRequest` queries can get grouped into the same dataloader call, while the second half of request B (the `find` query) gets put into a separate call.  Worse yet, the first group of requests gets called from the context of request A, so if there is any code that relies on `IHttpContextAccessor`, it will return the wrong http context for the second content request. Similar issues can occur with any async-local data.  I had these problems in one of my live environments; it was very hard to track down since the probability of it happening is rare.  Now if that is perfectly fine (no issues with authentication or anything else), then sure, I guess...  But also if the `FetchAsync` code in the data loader depends on any scoped services, you'll need the data loader to be a scoped service.\r\n\r\nI think this solution should work well for you.  It also can fully handle any valid graphql query, whether it uses aliases, fragments, etc."
      },
      {
        "user": "TechGeeky",
        "created_at": "2021-04-13T00:20:27Z",
        "body": "You meant `FetchAsync` right in your return line in `TitanQuery` class? I cross checked `DataLoaderBase` abstract class so I believe it should be `FetchAsync` but just making sure.\r\n\r\n> return dataLoader.LoadAsync(request);\r\n\r\nAlso as of now it gives me an error on that line - \r\n\r\n`'MyDataRequestor.FetchAsync(IEnumerable<DataLoaderPair<IRequest, object>>, CancellationToken)' is inaccessible due to its protection level`\r\n\r\n"
      },
      {
        "user": "Shane32",
        "created_at": "2021-04-13T00:33:16Z",
        "body": "No, `LoadAsync` is correct."
      },
      {
        "user": "Shane32",
        "created_at": "2021-04-13T00:45:22Z",
        "body": "Here's the gory details:\r\n\r\n`LoadAsync` queues the key (the `IRequest` in your case) as a new `DataLoaderPair<IRequest, object>` within a `DataLoaderList` and returns the `DataLoaderPair` an `IDataLoaderResult<object>` interface.  Once the execution strategy determines that only data loader nodes are remaining to be processed, it will call `await IDataLoaderResult.GetResultAsync(cancellationToken)`.  The `DataLoaderPair` in turn holds a reference of the queued requests in the form of a `DataLoaderList` instance and calls the `DispatchAsync` method.  The `DataLoaderList.DispatchAsync` method holds a reference to the `DataLoaderBase` and calls the abstract `FetchAsync` method to load the results into the list for all of the pending nodes.  The `FetchAsync` method contains only your own code and calls the `DataLoaderPair.SetResult` methods once the information requested has been retrieved.  Once the `DispatchAsync` method finishes, the `DataLoaderPair.GetResultAsync` method returns the data back to the execution strategy.\r\n\r\nFor the other pending data loader nodes, one of two things happen:\r\n1.  If the `DispatchAsync` method has already completed, then the `IsResultSet` property of the pair is already `true`, and so the `GetResultAsync` method can immediately return the correct data.\r\n2. If not, it calls `DispatchAsync`, which returns a reference to the same `Task` that represents the completion of the `FetchAsync` method on the other thread.  Once that task is complete, the `IsResultSet` property will be `true` and the data can be returned from the pair."
      },
      {
        "user": "TechGeeky",
        "created_at": "2021-04-13T01:18:01Z",
        "body": "Yeah my bad. I missed `LoadAsync` in `DataLoaderBase` class. Went through the doc and got some clarity. \r\n\r\nI am kinda confuse on your second solution and not sure how it will fit to what I need unless I am understanding it wrong. This is what I am trying to do and let me know if your second solution helps me with that -\r\n\r\nWhen customer passes query like this - \r\n\r\n    {\r\n      contentRequest(clientId: 123, filters: [{key: \"hello\", value: \"98\"}], clientKey: \"process\") {\r\n        title\r\n        id\r\n        name\r\n      }\r\n    }\r\n\r\nthen I want to create `ProcessRequest` object like below.\r\n\r\n    var processRequest = new ProcessRequest {\r\n        ClientId = context.GetArgument<int>(\"clientId\"),\r\n        Filters = context.GetArgument<List<Filter>>(\"filters\"),\r\n        ClientKey = context.GetArgument<string>(\"clientKey\"),\r\n    };\r\n\r\nBut if customer passes multiple queries in single request like this - \r\n\r\n    {\r\n      contentRequest(clientId: 123, filters: [{key: \"hello\", value: \"98\"}], clientKey: \"process\") {\r\n        title\r\n        id\r\n        name\r\n      }\r\n      find(queryString: \"\", filters: [{key: \"hello\", value: \"98\"}], clientId: 1234) {\r\n        metricx {\r\n          name\r\n          key\r\n        }\r\n        prodCount\r\n      }\r\n      itemListings(pots: [{potType: \"KITE_1\", filters: [{key: \"c\", value: \"1341\"}]}, {potType: \"KITE_2\", filters: [{key: \"c\", value: \"9812\"}]}], filters: [{key: \"hello\", value: \"98\"}], clientId: 1234, clientKey: \"process\") {\r\n        potType\r\n        productAlgo\r\n        count\r\n        listingEndpoint\r\n      }\r\n    }\r\n\r\nthen I want to create request object like this by extracting arguments from all those queries. `clientId`, `filters`, `clientKey` will be there in all the schemas with same values mostly.\r\n\r\n    var processRequest = new ProcessRequest {\r\n        ClientId =    'clientId from any query arguments',\r\n        Filters =     'filters from any query arguments',\r\n        ClientKey =   'clientKey from any query arguments',\r\n        QueryString = 'queryString from \"find\" query arguments',\r\n        Pots =        'pots from \"itemListings\" query arguments'\r\n    };\r\n\r\nBasically arguments from each query is mapped to some object or variables in `ProcessRequest` class. Single query or multiple query makes one `ProcessRequest` object. Once I make `processRequest` object either from single query or multiple query then I pass this object to underlying methods of services to get `ProcessResponse` object just like I have in my original question - \r\n\r\n> var processResponse = await metadataService.ProcessData(processRequest);\r\n\r\nOnce I have `ProcessResponse` object which has all the data either from single query or multiple queries then I need to get corresponding fields for each query type from it. Basically we make one call to underlying services by passing single `processRequest` object to get data out of it.\r\n\r\nNow in our code base, we already have `ProcessRequest` and `ProcessResponse` defined. We just need to create `ProcessRequest` from either single query or multiple query arguments and then from that get `ProcessResponse`  object which will be use to return data for corresponding query fields depending on what they need.\r\n\r\nNow if I see your example of `FetchAsync` method then it looks like we are creating different input request object for each query arguments but in my case I need single `ProcessRequest` object from all those query arguments and use that to get `ProcessResponse` object. \r\n\r\nDo you think `DataLoader` can still be used here? Maybe `FetchAsync` method can be modified to make one `ProcessRequest` object from all input arguments in multiple queries and then call `await metadataService.ProcessData(processRequest)` to get data and then return multiple response type for each resolvers? Is that possible to do by any chance?\r\n\r\nAs of now when I was testing the code, I am seeing NPE from this line. \r\n\r\n```\r\nvar dataLoader = context.RequestServices.GetRequiredService<MyDataRequestor>();\r\n...\r\n```\r\n\r\nStacktrace:\r\n\r\n```\r\nSystem.ArgumentNullException: Value cannot be null. (Parameter 'provider')\r\n   at GraphQL.Utilities.ServiceProviderExtensions.GetRequiredService(IServiceProvider provider, Type serviceType) in /_/src/GraphQL/Utilities/ServiceProviderExtensions.cs:line 33\r\n   at GraphQL.Utilities.ServiceProviderExtensions.GetRequiredService[T](IServiceProvider provider) in /_/src/GraphQL/Utilities/ServiceProviderExtensions.cs:line 18\r\n```\r\n\r\nI have added it as scoped:\r\n\r\n`services.AddScoped<MyDataRequestor>();`\r\n\r\n"
      },
      {
        "user": "Shane32",
        "created_at": "2021-04-13T07:41:30Z",
        "body": "The NPE is because `ExecutionOptions.RequestServices` isn't set when calling the `DocumentExecutor`."
      },
      {
        "user": "Shane32",
        "created_at": "2021-04-13T07:59:39Z",
        "body": "> Now if I see your example of FetchAsync method then it looks like we are creating different input request object for each query arguments but in my case I need single ProcessRequest object from all those query arguments and use that to get ProcessResponse object.\r\n\r\nYes, but you can change the code in FetchAsync however you want. For example:\r\n\r\n```cs\r\n    protected override async Task FetchAsync(IEnumerable<DataLoaderPair<IRequest, object>> list, CancellationToken cancellationToken)\r\n    {\r\n        //1. find the different types of requests, and ensure that only max of one is requested for each type\r\n        //  (because according to graphql spec there could be multiple of a single one)\r\n        var contentRequestPair = list.SingleOrDefault(x => x.Key is ContentRequest);\r\n        var contentRequest = (ContentRequest)contentRequestPair?.Key;\r\n        //ditto for findRequest and itemListingsRequest\r\n\r\n        //2. pull the common variables\r\n        var clientId = contentRequest?.ClientId ?? findRequest?.ClientId ?? itemListingsRequest?.ClientId;\r\n        //ditto for filters and clientkey\r\n\r\n        //optional: throw an exception if clientId is different for contentRequest vs findRequest vs itemListingsRequest, or similar logic\r\n\r\n        //3. initialize the process request\r\n        var request = new ProcessRequest {\r\n            //common properties\r\n            ClientId = clientId,\r\n            ClientKey = clientKey,\r\n            Filters = filters,\r\n            //properties specific to the type of request\r\n            QueryString = findRequest?.Find,\r\n            ...\r\n        };\r\n\r\n        // 4. todo: execute your request (async or sync)\r\n        var processResponse = await ExecuteProcessRequestAsync(processRequest, cancellationToken);\r\n\r\n        // 5. set the results\r\n        if (contentRequestPair != null)\r\n        {\r\n            // create the data model for the graph\r\n            var contentResponse = processResponse.whatever;\r\n            // set the answer\r\n            contentRequestPair.SetResult(contentResponse);\r\n        }\r\n        listRequestPair?.SetResult(processResponse.answer2);\r\n        // ditto for the other objects\r\n    }\r\n```\r\n\r\nSome more idea: group the `list` variable by the common properties, so e.g. if there are different clientIds specified it will execute separate requests rather than execute one of the two with the wrong clientid.  Apply similar logic if there are multiple `contentRequest`s queried, so it will execute separate requests rather than throwing an error during `SingleOrDefault`.\r\n"
      },
      {
        "user": "Shane32",
        "created_at": "2021-04-13T08:01:44Z",
        "body": "> Do you think DataLoader can still be used here? Maybe FetchAsync method can be modified to make one ProcessRequest object from all input arguments in multiple queries and then call await metadataService.ProcessData(processRequest) to get data and then return multiple response type for each resolvers? Is that possible to do by any chance?\r\n\r\nYes exactly.  This is your responsibility now to implement `FetchAsync` any way you want.  Group the queries together into one call, or issue separate calls, whatever."
      }
    ]
  },
  {
    "number": 2286,
    "title": "How to use FieldAsync here bcoz my methods signatures are \"async Task<...>\"",
    "created_at": "2021-02-15T01:48:46Z",
    "closed_at": "2021-02-22T15:09:11Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/2286",
    "body": "I have a resolve method like this in which I need to use `await` two times because `BuildRequest` and `ProcessData` method signatures are `async Task<....>` -\r\n\r\n    Field<HumanType>(\r\n        \"human\",\r\n        arguments: new QueryArguments(\r\n            new QueryArgument<NonNullGraphType<StringGraphType>> { Name = \"id\", Description = \"id of the human\" }\r\n        ),\r\n        resolve: context =>\r\n        {\r\n            var human = context.GetArgument<string>(\"id\");\r\n            var requestContext = await clientService.BuildRequest(.....);\r\n            var response = await metadataService.ProcessData(....);\r\n\r\n            return response;\r\n        }\r\n    );\r\n\r\nIs this the right way to use resolve like this? Or is there any async implementations which I can use here?",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/2286/comments",
    "author": "TechGeeky",
    "comments": [
      {
        "user": "sungam3r",
        "created_at": "2021-02-15T17:20:58Z",
        "body": "Use `FieldAsync`:\r\n```graphql\r\n FieldAsync<__Type>(\r\n                \"mutationType\",\r\n                \"If this server supports mutation, the type that mutation operations will be rooted at.\",\r\n                resolve: async context =>\r\n                {\r\n                    return await context.Schema.Filter.AllowType(context.Schema.Mutation).ConfigureAwait(false)\r\n                        ? context.Schema.Mutation\r\n                        : null;\r\n                });\r\n```"
      },
      {
        "user": "TechGeeky",
        "created_at": "2021-02-15T18:02:28Z",
        "body": "You mean something like this?\r\n\r\n```\r\nFieldAsync<HumanType>(\r\n    \"human\",\r\n    arguments: new QueryArguments(\r\n        new QueryArgument<NonNullGraphType<StringGraphType>> { Name = \"id\", Description = \"id of the human\" }\r\n    ),\r\n    resolve: async context =>\r\n    {\r\n        var human = context.GetArgument<string>(\"id\");\r\n        var requestContext = await clientService.BuildRequest(.....);\r\n        var response = await metadataService.ProcessData(....);\r\n\r\n        return response;\r\n    }\r\n);\r\n```\r\n\r\nOr I need something else here?"
      }
    ]
  },
  {
    "number": 2278,
    "title": "Field scalar value and extension method",
    "created_at": "2021-02-11T18:19:20Z",
    "closed_at": "2021-02-13T13:02:44Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/2278",
    "body": "I have an extension method on a decimal type like this \r\n```c#\r\n    public static class Conversion\r\n    {\r\n        public static decimal MegaJouleToKcal(this decimal value) => value * Constantes.MegaJouleToKcal;\r\n\r\n    }\r\n``` \r\nBut when i want to use it in an objectType constructor, the second line throw a error\r\n```c#\r\nField(i => i.DEJGoal);\r\nField(i => i.DEJGoal.MegaJouleToKcal(), nullable: true, type: typeof(DecimalGraphType)).Name(\"dejGoalKcal\");\r\n```\r\nlike this \r\n>Cannot infer a Field name from the expression: 'i.DEJGoal.MegaJouleToKcal()' on parent GraphQL type: 'PatientType'.\r\n\r\nIf i don\u00b4t use the extention method it works.\r\nHow can i achieve this ? I simply want to have the same value 'dejGoal' with a different unit.\r\nThanks.\r\n",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/2278/comments",
    "author": "grean",
    "comments": [
      {
        "user": "Shane32",
        "created_at": "2021-02-11T20:53:03Z",
        "body": "Try:\r\n```cs\r\nField(\"dejGoalKcal\", i => i.DEJGoal.MegaJouleToKcal(), nullable: true, type: typeof(DecimalGraphType));\r\n```"
      }
    ]
  },
  {
    "number": 2256,
    "title": "DataLoaderContext Is Null",
    "created_at": "2021-02-05T13:32:26Z",
    "closed_at": "2021-02-05T14:10:41Z",
    "labels": [
      "question",
      "data loader"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/2256",
    "body": "I'm using GraphQL v 3.3.2 and I'm trying to make work the DataLoader but everytime I try to access the `Context` property inside the injected `IDataLoaderContextAccessor` instance, it is null. I've went through the documentation but didn't find anything useful so unstuck me. I'm not using directly in my code `DocumentExecuter` so the advice in the documentation doesn't seem to apply to my case\r\n\r\n## Startup\r\n\r\nThere is nothing fancy here\r\n\r\n```\r\nservices\r\n                .AddGraphQL(o => { o.EnableMetrics = true; })\r\n                .AddNewtonsoftJson()\r\n                .AddErrorInfoProvider(opt => opt.ExposeExceptionStackTrace = _environment.IsDevelopment())\r\n                .AddDataLoader() \r\n                .AddGraphTypes(ServiceLifetime.Scoped);\r\n```\r\n\r\nMy type\r\n\r\n```\r\npublic class FondsCatalogType : ObjectGraphType<CatalogFondsRepresentation>\r\n    {\r\n        public FondsCatalogType(IDataLoaderContextAccessor dataLoaderContextAccessor)\r\n        {\r\n            Field(t => t.Id, type: typeof(IdGraphType));\r\n\r\n            // more irrelevant field declarations...                    \r\n  \r\n        }\r\n    }\r\n```\r\n\r\nSo I'm getting correctly the instance of `IDataLoaderContextAccessor` but the context is `null`\r\n\r\nIs there something else to configure? \r\n\r\nIf I understand correctly internally the  `DataLoaderDocumentListener` is added to the execution context.",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/2256/comments",
    "author": "tjaskula",
    "comments": [
      {
        "user": "Shane32",
        "created_at": "2021-02-05T13:50:28Z",
        "body": "The context will only hold a value within a field resolver, not in the type constructor, Can you supply a sample of the field declaration whose results should come from the data loader?"
      }
    ]
  },
  {
    "number": 1934,
    "title": "ReadonlyResolveFieldContext  in 3.0.0.2026",
    "created_at": "2020-10-22T22:13:13Z",
    "closed_at": "2020-10-23T13:30:54Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/1934",
    "body": "In earlier versions I was able to modify the global ResolveFieldContext as follows:\r\n```\r\n public object Resolve(IResolveFieldContext rfc)\r\n....\r\nrfc.Arguments = new Dictionary<string, object>(rfc.Arguments,StringComparer.InvariantCultureIgnoreCase);\r\n.....\r\n```\r\n\r\nThe goal being to allow for arguments to be case-insensitive.\r\nThe current version, because it is read-only, I'm not able to make this modification anymore.\r\n\r\nIs there any way around this problem - ideally this would just be like a configuration setting or something.\r\n\r\nLet me know - thanks for your time!\r\n\r\n",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/1934/comments",
    "author": "OpenSpacesAndPlaces",
    "comments": [
      {
        "user": "sungam3r",
        "created_at": "2020-10-22T22:27:43Z",
        "body": "By the way we still have `ResolveFieldContext` with setters.\r\nI see one way to quickly resolve your issue on your side - just get `_arguments` field from `ReadonlyResolveFieldContext` with Reflection and set the new value. @Shane32 do we want to provide a case-insensitive option for getting arguments? I doubt."
      },
      {
        "user": "Shane32",
        "created_at": "2020-10-22T22:57:03Z",
        "body": "@OpenSpacesAndPlaces Be aware that calls to `GetArgument` will run the provided argument name through the schema's `NameConverter`, which in its default configuration converts names to camel case.  So, calling `GetArgument<string>(\"Test\")` will match on an argument with the name of `test`.\r\n\r\nThere had been a bug where `HasArgument(\"Test\")` would not match, but this was fixed in #1549 \r\n\r\nAs it relates to your needs, you can of course use reflection to patch your old code as @sungam3r described.  You can also use middleware to wrap the `IResolveFieldContext` with a custom implementation that returns a case-insensitive version of the dictionary when requested.\r\n\r\nIf you were writing new code, I would suggest using `GetArgument` and `HasArgument`, or writing your own extension methods as necessary.  Since `ResolveFieldContext` is now an interface, extension methods will apply to any derived class, which is very nice.  `Arguments` is really only designed for access to the raw list of arguments provided to the field.\r\n\r\n@sungam3r I would consider making `Arguments` return a case-insensitive dictionary **if** the graphql spec requires argument names to be unique by more than just case.  We still need to pass names through the name converter in case more has changed than case.  Similarly, people should use the `GetArgument` and `HasArgument` methods so that it runs through the name converter regardless of whether only the case has changed.  Looking at the other side of the argument, returning a case-insensitive dictionary would probably be a nice feature for certain uses.  For example, I have code that passes the entire dictionary of arguments through to the `Source` property of a child graph.  `GetArgument` and `HasArgument` are not accessible in that scenario.  A case-insensitive match would be convenient, although not necessary.\r\n\r\n"
      },
      {
        "user": "sungam3r",
        "created_at": "2020-10-23T11:51:16Z",
        "body": "I am inclined to believe that we should not do support for this particular case. We already have name converters. If someone need special processing for args, then he can take the `Arguments` dictionary directly from resolve context and do whatever. In fact `ResolveFieldContextExtensions` is just extensions."
      },
      {
        "user": "OpenSpacesAndPlaces",
        "created_at": "2020-10-23T18:56:08Z",
        "body": "I wanted to a tiny bit more background in-case this comes again.\r\nThe remembered reason was because - often people declare classes in Pascal, but then they are auto-converted Camel.\r\n\r\nThen coming back in it's now camel vs. pascal (unless you convert or the other).\r\n\r\nBut as you mentioned - it sounds like 1549 covers the base case - the only residual problem is any customization/existence checking."
      }
    ]
  },
  {
    "number": 1750,
    "title": "How to access Field-level arguments in .Net code",
    "created_at": "2020-07-29T21:52:24Z",
    "closed_at": "2020-07-31T16:09:44Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/1750",
    "body": "In the documentation, I see how to access arguments and am doing that successfully.  However, I can't seem to find any guidance on how to access the field-level arguments in code.  For instance, I have the following:\r\n\r\n```\r\npublic HoldType ()\r\n        {\r\n            Name = \"Hold\";\r\n\r\n            Field(h => h.HoldId, type: typeof(LongGraphType)).Description(\"Id of the Hold\");            \r\n            Field(h => h.Status)\r\n                .Argument<ListGraphType<IntGraphType>>(\"exclude\", \"List of status codes to exclude from the result\")\r\n                .Description(\"Current status of the Hold\");\r\n        }\r\n```\r\n\r\nThen in my Query definition, I have:\r\n```\r\nField<ListGraphType<HoldType>>(\r\n  \"holds\",\r\n  arguments: new QueryArguments(\r\n    new QueryArgument<ListGraphType<IntGraphType>> { Name = \"exclude\", DefaultValue = new int[] { 999 }, Description = \"Status codes to exclude from the results\" }\r\n  ),\r\n  resolve: context =>\r\n  {\r\n    var exclude = context.GetArgument<int[]>(\"exclude\");  // this works for a parent-level argument - holds(exclude:999)\r\n  });\r\n```\r\n\r\nI want to be able to pass in a list of values to exclude from the query on the status field.    So something like...\r\n\r\n```\r\nquery {\r\n  holds {\r\n    holdId\r\n    status(exclude:999,998,100)\r\n  }\r\n}\r\n```\r\n\r\nAm I going about this the right way?  If so, how do I access the values during resolution?  If I need to pass it at parent level, that's fine, but I know GQL supports field-level arguments so I'm wondering if that's possible.",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/1750/comments",
    "author": "dochoss",
    "comments": [
      {
        "user": "dochoss",
        "created_at": "2020-07-30T17:08:06Z",
        "body": "Thanks for following up. I'm not sure I really understand what the field-level resolver is doing.  Is it applying the lambda to each record on retrieval?  If so, should I use something like this? \r\n\r\n```\r\nField(h => h.Status)\r\n  .Resolve(resolver =>\r\n  {\r\n    var exclude = resolver.GetArgument<int[]>(\"exclude\");\r\n    var status = resolver.Source.Status;\r\n                    \r\n    return !exclude.Contains(status) \r\n      ? resolver.Source.Status \r\n      : -1;\r\n    })\r\n    .Argument<ListGraphType<IntGraphType>>(\"exclude\", \"List of status codes to exclude from the result\")\r\n    .Description(\"Current status of the Hold\");\r\n```\r\n\r\nIf not, how should I accomplish what I'm trying to do?  I'm trying to get a record to not appear in the output if the value of Status is included in the \"exclude\" argument."
      },
      {
        "user": "sungam3r",
        "created_at": "2020-07-30T17:36:53Z",
        "body": "Resolver returns object used for subsequent resolution of inner fields in case of non-leaf parent (current) field. Does `Status` property have `List<int>` type?"
      },
      {
        "user": "dochoss",
        "created_at": "2020-07-30T18:11:37Z",
        "body": "Status is an int, basically a code for the current status of an item.  `Exclude` will be a list of status codes to exclude from the result set.  \r\n\r\nFor clarity, here's an example...\r\n\r\nData set:\r\n```\r\n{ \"holdId\": 1, \"status\": 1 },  \r\n{ \"holdId\": 2, \"status\": 5 }, \r\n{ \"holdId\": 3, \"status\": 999 } \r\n```\r\n\r\nGQL query (desired state):\r\n```\r\nquery {\r\n  holds {\r\n    holdId\r\n    status(exclude:5,999)\r\n  }\r\n}\r\n```\r\n\r\nThe query should only return the hold with holdId = 1"
      },
      {
        "user": "dochoss",
        "created_at": "2020-07-30T18:36:04Z",
        "body": "Sorry, computer had a little meltdown and ate part of my comment.  \r\n\r\nI'm still not quite clear on how to use the data I get from the field resolver.  When I get the data into my query resolver, will the updated value from the field resolver be used in place of the raw data?\r\n\r\n```\r\nquery {\r\n  holds {\r\n    holdId\r\n    status(exclude:5,999)\r\n  }\r\n}\r\n```\r\n\r\n```\r\n// query resolver\r\nresolve: context => {\r\n  var holds = database.Holds;\r\n  foreach (var hold in holds) \r\n  {\r\n    // what is the value of hold.Status here if Status == 999?\r\n    // database value or -1? (does the field resolver execute first?)\r\n  }\r\n}\r\n```\r\n"
      },
      {
        "user": "dochoss",
        "created_at": "2020-07-30T18:40:52Z",
        "body": "I just tested with a breakpoint in the query resolver and in the field resolver.  The field resolver hits after the query, so it's not obvious how I can get an item to be excluded.  I can change the value of `Status` but that doesn't help me since the record is still sent in the output."
      },
      {
        "user": "sungam3r",
        "created_at": "2020-07-31T15:42:04Z",
        "body": "GraphQL yields data level by level from top to bottom. First top, then bottom. Your resolver return some object (or array/list/enumerable) which then will be passed to the next level of resolution process until the process comes to primitive values - scalars. If you want to filter some holds you should do it where you have access to them - in resolver for `holds`, not in resolver for `status` so move `exclude` argument to `holds` field."
      }
    ]
  },
  {
    "number": 1668,
    "title": "Inheritance of graph types",
    "created_at": "2020-05-05T19:50:33Z",
    "closed_at": "2020-06-06T22:27:57Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/1668",
    "body": "I have a question about inheritance of graph types that I have been unable to solve. Imagine the following scenario:\r\n```csharp\r\npublic class Foo\r\n{ \r\n    public int FooProp { get; set; }\r\n}\r\n\r\npublic class Bar : Foo\r\n{ \r\n    public int BarProp { get; set; }\r\n}\r\n\r\npublic class FooGraphType : ObjectGraphType<Foo>\r\n{\r\n    public FooGraphType()\r\n    {\r\n        Field(p => p.FooProp);\r\n     }\r\n}\r\n\r\npublic class BarGraphType : ObjectGraphType<Bar>\r\n{\r\n    public BarGraphType()\r\n    {\r\n        Field(p => p.FooProp);\r\n        Field(p => p.BarProp);\r\n     }\r\n}\r\n```\r\n\r\nMy issue is that I have to redeclare the FooProp field in BarGraphType, which is just a minor annoyance in this example but when Foo has a lot of fields with resolver code etc it gets very attractive to have them in Foo only and not duplicate them in Bar.\r\n\r\nSo my question is, is there some way for BarGraphType to inherit from FooGraphType, get all the fields defined there, and still be able to use it's own model for additional fields?\r\n\r\nI've been looking through the docs and examples but unable to find anything, so I thought I would ask here.",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/1668/comments",
    "author": "kenewbie",
    "comments": [
      {
        "user": "sungam3r",
        "created_at": "2020-05-05T20:32:10Z",
        "body": "If you want to inherit from two different generic types the answer is NO. This is a limitation of the .NET type system, not GraphQL.NET. But you can always move field declarations inside some method and use this method in your type hierarchy. Also you can inherit from `AutoRegisteringObjectGraphType`."
      },
      {
        "user": "kenewbie",
        "created_at": "2020-05-06T06:08:38Z",
        "body": "Yes I am aware of the limitations on multiple inheritance. I was hoping that there might be some variation of `ObjectGraphType<T>` that looks at the base of T, and if a GraphType is found that uses the base as a model then the fields from that are applied to the GraphType of T as well. \r\n\r\nI'll take a look at the AutoRegistering version and see if that helps me."
      },
      {
        "user": "sungam3r",
        "created_at": "2020-05-06T06:37:37Z",
        "body": "Given `TDerived : TBase`\r\n\r\n`ObjectGraphType<TDerived>` and `ObjectGraphType<TBase>` are not connected in any way. Generic parameter is only needed to provide expression configuration capabilities and typed resolvers."
      },
      {
        "user": "KreativJos",
        "created_at": "2020-05-06T11:55:28Z",
        "body": "Wouldn't your problem be solved if you'd make a generic base class, like this (note: written in free-hand, not tested):\r\n\r\n```\r\npublic class Foo\r\n{ \r\n    public int FooProp { get; set; }\r\n}\r\n\r\npublic class Bar : Foo\r\n{ \r\n    public int BarProp { get; set; }\r\n}\r\n\r\npublic abstract class BaseFooGraphType<T> : ObjectGraphType<T>\r\n    where T : Foo\r\n{\r\n    protected BaseFooGraphType()\r\n    {\r\n        Field(p => p.FooProp);\r\n    }\r\n}\r\n\r\npublic class FooGraphType : BaseFooGraphType<Foo>\r\n{\r\n    public FooGraphType()\r\n        : base()\r\n    { }    \r\n}\r\n\r\npublic class BarGraphType : BaseFooGraphType<Bar>\r\n{\r\n    public BarGraphType()\r\n        : base()\r\n    {\r\n        Field(p => p.BarProp);\r\n    }\r\n}\r\n```"
      }
    ]
  },
  {
    "number": 1630,
    "title": "How do I register a generic base interface without name collisions?",
    "created_at": "2020-03-31T17:49:24Z",
    "closed_at": "2020-04-01T09:56:14Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/1630",
    "body": "## Summary\r\n\r\nI want to do the following:\r\n\r\n- Register an ``InterfaceGraphType<T> where T: IBaseEntity`` where ``IBaseEntity`` contains some very generic fields (Id, Created and Updated)\r\n- Create an abstract generic base object to inherit from so that my object types does not have to implement the same fields over and over again\r\n- Inherit this base object class from different types \r\n- I want the interface be the same for all objects implementing it. That is, i want them all to implement ``BaseEntityInterface`` and not ``BaseEntityInterface<TypeName>``.\r\n    - I want to be able to click on the ``BaseEntityInterface`` in a documentation explorer and list all the types implementing this interface. That will not happen if a generic typename is generated for each implementation. Then there will be only one per interface.\r\n  \r\nRight now, if I use this approach I get a name collision telling me that the name is already registered (if I don\u00b4t generate unique names). So I guess I'm going about this in the wrong way...any hints? \r\n\r\nAnd I do, of course want to use the benefits of having generics so things get typechecked by the compiler.\r\n\r\nI think the actions in #510, and #1284 prevents my use case (which I think is legit)?\r\n\r\n## Relevant information\r\n\r\n```csharp\r\n public class BaseEntityInterface<T> : InterfaceGraphType<T> where T: IBaseEntity\r\n    {\r\n        public BaseEntityInterface()\r\n        {\r\n            this.Description = \"An entity with a id and created/updated timestamps\";\r\n\r\n            this.Field(x => x.Id)\r\n                .Description(\"The unique identifier of the entitity.\");\r\n            this.Field(x => x.Created)\r\n                .Description(\"Timestamp when the entity was first created.\");\r\n            this.Field(x => x.Updated)\r\n                .Description(\"Timestamp when the entity was last updated.\");\r\n        }\r\n    }\r\n\r\n public abstract class BaseEntityObject<T> : ObjectGraphType<T> where T: IBaseEntity\r\n    {\r\n        public BaseEntityObject()\r\n        {\r\n            this.Description = \"An entity with a id and created/updated timestamps\";\r\n\r\n\r\n            this.Field(x => x.Id)\r\n                .Description(\"The unique identifier of the entity.\");\r\n            this.Field(x => x.Created)\r\n                .Description(\"Timestamp when the entity was first created.\");\r\n            this.Field(x => x.Updated)\r\n                .Description(\"Timestamp when the entity was last updated.\");\r\n\r\n            this.Interface<BaseEntityInterface<T>>();\r\n            this.IsTypeOf = obj => obj is IBaseEntity;\r\n        }\r\n    }\r\n\r\n// Sample implementation type\r\npublic class InvoiceArticleObject: BaseEntityObject<InvoiceArticle>\r\n    {\r\n        public InvoiceArticleObject()\r\n        {\r\n            this.Description = \"Invoice article.\";\r\n\r\n           // ...\r\n\r\n            this.Interface<BaseEntityInterface<InvoiceArticle>>();\r\n            this.IsTypeOf = obj => obj is InvoiceArticle;\r\n        }\r\n    }\r\n   \r\n```",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/1630/comments",
    "author": "andrejohansson",
    "comments": [
      {
        "user": "BenjaBobs",
        "created_at": "2020-03-31T18:24:14Z",
        "body": "With the current code the interface is being registered multiple times due to the generics. What you could do is interface with the base type instead:\r\n`this.Interface<BaseEntityInterface<IBaseEntity>>()`\r\n\r\nThat way, the type being registered will be the same, so it will only be registered once, and that should solve your name collision problem while still allowing you to access the needed fields, provided that they are present on `IBaseEntity`."
      },
      {
        "user": "sungam3r",
        "created_at": "2020-03-31T18:50:20Z",
        "body": "All types in GraphQL **must have unique names**. Which ones? You choose yourself. I see that you do not specify them, so the names are inferred by default from the type are used. You can set type name with just `Name = \"blablabla\";` to avoid any conflicts. For a better understanding of what schem\u0430 you have (names), you can open it with GraphQL Playgroud, GraphiQL, Altair or any other UI tool."
      }
    ]
  },
  {
    "number": 1591,
    "title": "How can I gain access to the HttpRequest object in n ObjectGraphType Field Resolve Function",
    "created_at": "2020-03-05T08:35:06Z",
    "closed_at": "2020-03-06T08:24:20Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/1591",
    "body": "This is the code for my GraphQL controller;\r\n\r\n    [Route(\"[controller]\")]\r\n    public class GraphQLController : Controller\r\n    {\r\n        private readonly IDocumentExecuter _documentExecuter;\r\n        private readonly ISchema _schema;\r\n\r\n        public GraphQLController(ISchema schema, IDocumentExecuter documentExecuter)\r\n        {\r\n            _schema = schema;\r\n            _documentExecuter = documentExecuter;\r\n        }\r\n\r\n        [HttpPost]\r\n        public async Task<IActionResult> Post([FromBody] GraphQLQuery query)\r\n        {\r\n            if (query == null) { throw new ArgumentNullException(nameof(query)); }\r\n            var inputs = query.Variables.ToInputs();\r\n            //I can get the Request Object here\r\n            var executionOptions = new ExecutionOptions\r\n            {\r\n                Schema = _schema,\r\n                Query = query.Query,\r\n                Inputs = inputs\r\n            };\r\n\r\n            var result = await _documentExecuter.ExecuteAsync(executionOptions).ConfigureAwait(false);\r\n\r\n            if (result.Errors?.Count > 0)\r\n            {       \r\n                return BadRequest(result);\r\n            }\r\n\r\n            return Ok(result);\r\n        }\r\n    }\r\n\r\nI would like to be able to access the HttpRequest object (obtained in the controller action) in a resolve function of am ObjectGraphType field;\r\n\r\n            Field<FooGraphType>(\r\n                \"baz\",\r\n                resolve: context =>\r\n                {\r\n                    //Get the Request here\r\n                });\r\n\r\nMore generally, is there a method for including additional information in the \"context\" or by some other means, so that it can be accessed in the resolve function?",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/1591/comments",
    "author": "monkeyTrainer",
    "comments": [
      {
        "user": "sungam3r",
        "created_at": "2020-03-05T13:35:47Z",
        "body": "1. Inject `IHttpContextAccessor`\r\nor\r\n2. Store something into `UserContext` property, it's dictionary of user defined additional information."
      }
    ]
  },
  {
    "number": 1560,
    "title": "Get requested fields",
    "created_at": "2020-02-23T08:37:54Z",
    "closed_at": "2020-03-29T09:47:50Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/1560",
    "body": "Hi.\r\nIn node version you can access to \"info\" field of GraphQLResolveInfo, to get what fields are requested in query.\r\n\r\nHow can you do in graphql .net core?\r\nIt can be usefull to decide what sql queries I need to do to resolve all requested fields.\r\n\r\nThanks",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/1560/comments",
    "author": "fenomeno83",
    "comments": [
      {
        "user": "sungam3r",
        "created_at": "2020-02-23T08:40:46Z",
        "body": "`IResolveFieldContext.SubFields`, `IResolveFieldContext.Path`"
      },
      {
        "user": "fenomeno83",
        "created_at": "2020-02-23T08:45:39Z",
        "body": "Can you give me example?\r\n\r\nThis is a my test query\r\n\r\n    public class TestGroupQueries : ObjectGraphType\r\n    {\r\n        public TestGroupQueries(ITestOperations testOperations)\r\n        {\r\n            Name = \"testQueries\";\r\n\r\n            FieldAsync<StringGraphType>(\r\n            \"test\",\r\n                resolve: async context => await testOperations.Test<object>());\r\n\r\n        }\r\n      }\r\n\r\nHow can I get query requested fields"
      },
      {
        "user": "sungam3r",
        "created_at": "2020-02-23T08:47:47Z",
        "body": "`context.SubFields`"
      },
      {
        "user": "sungam3r",
        "created_at": "2020-02-23T08:48:34Z",
        "body": "or `context.Document` in case of the whole query text"
      }
    ]
  },
  {
    "number": 1520,
    "title": "Get GraphQL Schema when using GraphType First",
    "created_at": "2020-02-04T14:31:33Z",
    "closed_at": "2020-02-04T14:52:23Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/1520",
    "body": "We are building our api using a GraphType first approach, however it would be useful to be able to export this to a GraphQL schema as this is easier to discuss with others. I cannot find any documentation or obvious methods that seem to allow me to do this. Am I missing it or is this not possible currently?\r\n\r\nFor example, I was hoping to be able to do something like:\r\n```\r\nusing System;\r\nusing System.Threading.Tasks;\r\nusing GraphQL;\r\nusing GraphQL.Types;\r\n\r\npublic class Droid\r\n{\r\n  public string Id { get; set; }\r\n  public string Name { get; set; }\r\n}\r\n\r\npublic class DroidType : ObjectGraphType<Droid>\r\n{\r\n  public DroidType()\r\n  {\r\n    Field(x => x.Id).Description(\"The Id of the Droid.\");\r\n    Field(x => x.Name).Description(\"The name of the Droid.\");\r\n  }\r\n}\r\n\r\npublic class StarWarsQuery : ObjectGraphType\r\n{\r\n  public StarWarsQuery()\r\n  {\r\n    Field<DroidType>(\r\n      \"hero\",\r\n      resolve: context => new Droid { Id = \"1\", Name = \"R2-D2\" }\r\n    );\r\n  }\r\n}\r\n\r\npublic class Program\r\n{\r\n  public static async Task Main(string[] args)\r\n  {\r\n    var schema = new Schema { Query = new StarWarsQuery() };\r\n\r\n    var gqlSchema = await schema.ToGraphQLSchema();\r\n\r\n    Console.WriteLine(gqlSchema);\r\n  }\r\n}\r\n```\r\n\r\nWhich would give:\r\n```\r\ntype Droid {\r\n    id: String!\r\n    name: String!\r\n  }\r\n\r\n  type Query {\r\n    hero: Droid\r\n  }\r\n```",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/1520/comments",
    "author": "simonbu11",
    "comments": [
      {
        "user": "sungam3r",
        "created_at": "2020-02-04T14:37:07Z",
        "body": "`new SchemaPrinter(yourSchema).Print();`"
      }
    ]
  },
  {
    "number": 1445,
    "title": "Classes derived from InputObjectGraphType *sometimes* return error when given a name and a field is given a description.",
    "created_at": "2019-12-02T15:25:07Z",
    "closed_at": "2019-12-03T05:49:28Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/1445",
    "body": "After a ton of testing to figure out exactly why my mutations were sometimes working and sometimes not I've finally isolated the problem down to whether or not the InputObjectGraphType class has been given a name and a field in that class has a description but this only seems to matter _sometimes_ as bizarre as that is.\r\n\r\nFor example, this\r\n```\r\n    public class WololoInputType : InputObjectGraphType\r\n    {\r\n        public WololoInputType()\r\n        {\r\n            Name = \"Enemies are red, allies are blue, WOLOLO, now you're blue too.\";\r\n            /// Attribute Fields\r\n            FieldAsync<NonNullGraphType<EntityReferenceInputType>, EntityReferenceType>(\"customerid\").Description == \"PepperoniPizza\";\r\n        }\r\n    }\r\n```\r\n\r\nGives me this error:\r\n\r\n```\r\n{\r\n    \"errors\": [\r\n        {\r\n            \"message\": \"GraphQL.Validation.ValidationError: Variable \\\"salesorder\\\" cannot be non-input type \\\"SalesOrderCreateInput\\\".\",\r\n            \"locations\": [\r\n                {\r\n                    \"line\": 1,\r\n                    \"column\": 10\r\n                }\r\n            ],\r\n            \"extensions\": {\r\n                \"code\": \"5.7.3\"\r\n            }\r\n        },\r\n        {\r\n            \"message\": \"GraphQL.Validation.ValidationError: Unknown type SalesOrderCreateInput.\",\r\n            \"locations\": [\r\n                {\r\n                    \"line\": 1,\r\n                    \"column\": 23\r\n                }\r\n            ],\r\n            \"extensions\": {\r\n                \"code\": \"5.4.1.2\"\r\n            }\r\n        }\r\n    ]\r\n}\r\n```\r\n\r\nHowever this:\r\n\r\n```\r\n    public class WololoInputType : InputObjectGraphType\r\n    {\r\n        public WololoInputType()\r\n        {\r\n            /// Attribute Fields\r\n            FieldAsync<NonNullGraphType<EntityReferenceInputType>, EntityReferenceType>(\"customerid\");\r\n        }\r\n    }\r\n```\r\n\r\nWill perform the mutation as expected.\r\n\r\nThe _strangest_ part about this error is that if I delete just the field description, rebuild the solution and run it, I still get the above error. However, if I delete both of them, rebuild it and then _add name back to class_ it runs fine, only failing yet again if I add Description back to any field.\r\n",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/1445/comments",
    "author": "bigbizze",
    "comments": [
      {
        "user": "sungam3r",
        "created_at": "2019-12-02T18:09:32Z",
        "body": "Name is a GraphType's name, not description. Name must have only alphanumeric symbols. Try the latest preview version and you will see runtime error about that when schema is built."
      }
    ]
  },
  {
    "number": 1331,
    "title": "ObjectGraphType meaning",
    "created_at": "2019-10-07T13:56:21Z",
    "closed_at": "2019-10-20T07:40:11Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/1331",
    "body": "I wonder about the need for an `ObjectGraphType` type:\r\n```c#\r\npublic class ObjectGraphType : ObjectGraphType<object>\r\n{\r\n}\r\n```\r\nIt is a degenerate type that does not carry any logic, the so-called type-alias. In general, such types are not recommended. Is there any reason to have this type explicitly given? I see that the vast majority of its use is in the test project. Is it possible to move it there, and in the main project use `ObjectGraphType<object>` instead?\r\n",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/1331/comments",
    "author": "sungam3r",
    "comments": [
      {
        "user": "sungam3r",
        "created_at": "2019-10-20T06:14:03Z",
        "body": "Also the same thoughts about `InputObjectGraphType`."
      },
      {
        "user": "joemcbride",
        "created_at": "2019-10-20T07:40:11Z",
        "body": "Those types were the original ones provided by this project.  The generic type came later.  There are a lot of cases where you don\u2019t care about the type, as proved by all those tests that don\u2019t use one.  Removing those types is not a breaking change I want to make at this time."
      },
      {
        "user": "sungam3r",
        "created_at": "2019-10-20T11:59:35Z",
        "body": "> Those types were the original ones provided by this project. The generic type came later. \r\n\r\nAh, now I get the point. Yes, in this case, of course, they must be preserved."
      }
    ]
  },
  {
    "number": 1314,
    "title": "Why won't dependency injection work in my Type classes? trying to inject IDataLoaderContextAccessor",
    "created_at": "2019-09-25T15:57:06Z",
    "closed_at": "2019-09-25T17:05:29Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/1314",
    "body": "I am using GraphQL.NET 3.5.0-alpha0027 in a asp.net core 2.2 api project\r\n\r\nmy ConfigureServices is as follows\r\n\r\n        public void ConfigureServices(IServiceCollection services)\r\n        {\r\n            services.AddMvc();\r\n            services.AddDbContext<BodySystemContext>();\r\n            services.AddSingleton<IServiceProvider>(c => new FuncServiceProvider(type => c.GetRequiredService(type)));\r\n            services.AddScoped<GraphQLSchema>();\r\n            services.AddGraphQL(o => { o.ExposeExceptions = true; o.EnableMetrics = true; })\r\n                .AddGraphTypes(ServiceLifetime.Scoped)\r\n                .AddDataLoader();\r\n        }\r\n\r\nmy Configure is as follows\r\n\r\n        public void Configure(IApplicationBuilder app, IHostingEnvironment env)\r\n        {\r\n            app.UseGraphQL<GraphQLSchema>();\r\n            app.UseGraphQLPlayground(new GraphQLPlaygroundOptions());\r\n        }\r\n\r\nmy type class is as follows\r\n\r\n    public class BodySystemType : ObjectGraphType<BodySystem>\r\n    {\r\n        public BodySystemType(IDataLoaderContextAccessor dataLoaderAccessor)\r\n        {\r\n            Field(f => f.Id, type: typeof(IdGraphType));\r\n            Field(f => f.Name);\r\n            Field(f => f.Description, nullable: true);\r\n            Field(f => f.RowVersion, type: typeof(ListGraphType<ByteGraphType>));\r\n            Field<ListGraphType<BodySystemTranslationType>>(\r\n                \"BodySystemTranslations\",\r\n                resolve: context =>\r\n                {\r\n                    var loader =\r\n                        dataLoaderAccessor.Context.GetOrAddCollectionBatchLoader<short, BodySystemTranslation>(\r\n                            \"GetBodySystemTranslationByBodySystem\", GetBodySystemTranslationByBodySystemId);\r\n                    return loader.LoadAsync(context.Source.Id);\r\n                });\r\n        }\r\n\r\n        public async Task<ILookup<short, BodySystemTranslation>> GetBodySystemTranslationByBodySystemId(IEnumerable<short> bodySystemIds)\r\n        {\r\n            var bodySystemTranslations = await (new BodySystemContext()).BodySystemTranslation.Where(a => bodySystemIds.Contains(a.BodySystemId)).ToListAsync();\r\n            return bodySystemTranslations.ToLookup(x => x.BodySystemId);\r\n        }\r\n    }\r\n\r\nmy project compiles and runs playground alright but it won't show a schema and when i try to query it fails with error about needing a type with a parameterless constructor\r\n\r\n\"errors\": [\r\n    {\r\n      \"message\": \"GraphQL.ExecutionError: Failed to call Activator.CreateInstance. Type: Api.GraphQL.Types.BodySystemType ---> System.Exception: Failed to call Activator.CreateInstance. Type: Api.GraphQL.Types.BodySystemType ---> System.MissingMethodException: No parameterless constructor defined for this object.\\r\\n   at System.RuntimeTypeHandle.CreateInstance(RuntimeType type, Boolean publicOnly, Boolean wrapExceptions, Boolean& canBeCached, RuntimeMethodHandleInternal& ctor)\\r\\n   at System.RuntimeType.CreateInstanceSlow(Boolean publicOnly, Boolean wrapExceptions, Boolean skipCheckThis, Boolean fillCache)\\r\\n   at System.Activator.CreateInstance(Type type, Boolean nonPublic, Boolean wrapExceptions)\\r\\n   at GraphQL.DefaultServiceProvider.GetService(Type serviceType)\\r\\n   --- End of inner exception stack trace ---\\r\\n   at GraphQL.DefaultServiceProvider.GetService(Type serviceType)\\r\\n   at GraphQL.Utilities.ServiceProviderExtensions.GetRequiredService(IServiceProvider provider, Type serviceType)\\r\\n   at GraphQL.Types.Schema.<CreateTypesLookup>b__59_1(Type type)\\r\\n   at GraphQL.Types.GraphTypesLookup.AddTypeIfNotRegistered(Type type, TypeCollectionContext context)\\r\\n   at GraphQL.Types.GraphTypesLookup.HandleField(Type parentType, FieldType field, TypeCollectionContext context)\\r\\n   at GraphQL.Types.GraphTypesLookup.AddType(IGraphType type, TypeCollectionContext context)\\r\\n   at GraphQL.Types.GraphTypesLookup.Create(IEnumerable`1 types, IEnumerable`1 directives, Func`2 resolveType, IFieldNameConverter fieldNameConverter, Boolean seal)\\r\\n   at GraphQL.Types.Schema.CreateTypesLookup()\\r\\n   at System.Lazy`1.ViaFactory(LazyThreadSafetyMode mode)\\r\\n   at System.Lazy`1.ExecutionAndPublication(LazyHelper executionAndPublication, Boolean useDefaultConstructor)\\r\\n   at System.Lazy`1.CreateValue()\\r\\n   at GraphQL.Types.Schema.get_AllTypes()\\r\\n   at GraphQL.Instrumentation.FieldMiddlewareBuilder.ApplyTo(ISchema schema)\\r\\n   at GraphQL.DocumentExecuter.ExecuteAsync(ExecutionOptions options)\\r\\n   --- End of inner exception stack trace ---\",\r\n      \"extensions\": {\r\n        \"code\": \"MISSING_METHOD\"\r\n      }\r\n    }\r\n\r\nafter some searching i figured that it cannot resolve the IDataLoaderContextAccessor ... is that right ? and if yes how can i solve this ? and how can i use the dataloader IDataLoaderContextAccessor  without injection !!!",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/1314/comments",
    "author": "Walid-Abdulrazik",
    "comments": [
      {
        "user": "joemcbride",
        "created_at": "2019-09-25T16:14:21Z",
        "body": "How is your Schema defined?  Is it setup to inject the `IServiceProvider`?\r\n\r\n```csharp\r\npublic MySchema(IServiceProvider provider)\r\n    : base(provider)\r\n{}\r\n```"
      },
      {
        "user": "Walid-Abdulrazik",
        "created_at": "2019-09-25T17:05:29Z",
        "body": "> How is your Schema defined? Is it setup to inject the `IServiceProvider`?\r\n> \r\n> ```cs\r\n> public MySchema(IServiceProvider provider)\r\n>     : base(provider)\r\n> {}\r\n> ```\r\n\r\n@joemcbride , Actually yes, it was injecting the IServiceProvider but unfortunately it was not passing it to base class, like follows\r\n\r\n```\r\npublic MySchema(IServiceProvider provider)\r\n{\r\n}\r\n```\r\n\r\nbut after i modified it to pass the IServiceProvider to the base class like you suggested, it now works like a champ ...\r\n\r\nThank you very much, i appreciate the help \r\n"
      },
      {
        "user": "sungam3r",
        "created_at": "2019-09-25T18:02:59Z",
        "body": "@Walid-Abdulrazik You can remove this line\r\n```c#\r\nservices.AddSingleton<IServiceProvider>(c => new FuncServiceProvider(type => c.GetRequiredService(type)));\r\n```\r\n\r\nMS DI has builtin support for `IServiceProvider`"
      }
    ]
  },
  {
    "number": 988,
    "title": "Can I add a QueryArgument than can accept either string or List<string> for incoming values?",
    "created_at": "2019-01-23T01:52:44Z",
    "closed_at": "2019-01-23T05:11:36Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/988",
    "body": "Can I add a QueryArgument than can accept either string or List<string> for incoming values?\r\n\r\nnew QueryArgument< StringGraphType   > { Name = \"fType\"},\r\nnew QueryArgument<  ListGraphType  <  StringGraphType  >> { Name = \"fType\"},\r\n\r\nAn input data type which is more as IEnumerable\r\n\r\nUse case: To make something backward compatible during data type change for an incoming QueryArgument\r\nquery UseCaseExample {\r\n QueryField(fType:\"ValueA\" fType__AsList:[\"Value1\" \"Value2\"] ) {\r\n\r\ncan be handled as either\r\nquery UseCaseExample {\r\n QueryField(fType:\"ValueA\") {\r\n\r\nOR\r\nquery UseCaseExample {\r\n QueryField(fType:[\"Value1\" \"Value2\"] ) {\r\n\r\n",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/988/comments",
    "author": "pravinhabbu4u",
    "comments": [
      {
        "user": "joemcbride",
        "created_at": "2019-01-23T05:11:36Z",
        "body": "No, that is not possible due to the strong type safety that is defined in the GraphQL specification.  You will need to deprecate the old argument and provide a new one."
      }
    ]
  },
  {
    "number": 958,
    "title": "Deserialize arguments to a type with private constructor",
    "created_at": "2018-12-30T19:34:08Z",
    "closed_at": "2019-01-01T04:08:35Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/958",
    "body": "In the following example, my `Test` model has a parameterless private constructor. That's why it throws an exception saying, `System.MissingMethodException: 'No parameterless constructor defined for this object.'` while deserializing the arguments to the specified type.\r\n\r\n```\r\nField<TestType>(\"test\", \"create test\",\r\n                arguments: new QueryArguments(\r\n                    new QueryArgument<NonNullGraphType<TestInputType>> {Name = \"test\", Description = \"test input\"}\r\n                ),\r\n                resolve: context =>\r\n                {\r\n                    var test = context.GetArgument<Test>(\"test\");\r\n                    return repository.AddAsync(test);\r\n                });\r\n```\r\n\r\nQuestion: Is there any way to make it work while keeping the parameterless constructor private?\r\n\r\nN.B: Json.Net can handle non public default constructor for deserialization i.e.  \r\n```\r\nJsonSerializerSettings settings = new JsonSerializerSettings \r\n{ \r\n    ConstructorHandling = ConstructorHandling.AllowNonPublicDefaultConstructor \r\n};\r\n```",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/958/comments",
    "author": "fiyazhasan",
    "comments": [
      {
        "user": "joemcbride",
        "created_at": "2018-12-31T00:41:04Z",
        "body": "Not at this time, no.  You can use JSON.NET yourself to accomplish that today, something like this:\r\n\r\n```csharp\r\nresolve: context =>\r\n{\r\n    var jObject = JObject.FromObject(context.Arguments[\"test\"]);\r\n    var serializer = new JsonSerializer\r\n    {\r\n      ConstructorHandling =  ConstructorHandling.AllowNonPublicDefaultConstructor\r\n    };\r\n    var test = jObject.ToObject<Test>(serializer);\r\n    return repository.AddAsync(test);\r\n}\r\n```"
      }
    ]
  },
  {
    "number": 864,
    "title": "How to map input object to complex object",
    "created_at": "2018-10-16T19:29:24Z",
    "closed_at": "2020-03-01T22:21:03Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/864",
    "body": "## Summary\r\nI would like to know how to map the following mutation (PersonInput) to the models Person having an Account, using GraphQL.NET 2.0\r\n\r\n```\r\nmutation createPerson ($person: PersonInput!){\r\n  createPerson(person: $person)\r\n  {\r\n\tid\r\n  }\r\n}\r\n```\r\n\r\n```\r\n{\r\n \"person\": {\r\n\t\"firstName\": \"Sjaak\",\r\n\t\"lastName\": \"Trekhaak\",\r\n\t\"email\": \"jan@test.com\",\r\n\t\"password\": \"sjanie\"\r\n  }\r\n}\r\n```\r\n\r\n```\r\npublic class PersonInputObject : InputObjectGraphType\r\n{\r\n\tpublic RentePersonInputObject InputObject()\r\n\t{\r\n\t\tthis.Name = \"PersonInput\";\r\n\t\t\r\n\t\tthis.Field(typeof(StringGraphType), \"firstName\");\r\n\t\t\r\n\t\tthis.Field(typeof(StringGraphType), \"lastName\");\r\n\t\t\r\n\t\tthis.Field(typeof(StringGraphType), \"password\");\r\n\t\t\r\n\t\tthis.Field(typeof(StringGraphType), \"email\");\r\n\t}\r\n}\r\n\r\npublic class Person\r\n{\r\n\tpublic int Id { get; set; }\r\n\tpublic string FirstName { get; set; }\r\n\tpublic string LastName { get; set; }\r\n\r\n\tpublic Account Account { get; set; }\r\n}\r\n\r\npublic class Account\r\n{\r\n\tpublic string Email { get; set; }\r\n\tpublic string Password { get; set; }\r\n}\r\n```\r\n\r\nThis is my mutation object.\r\n\r\n```\r\npublic MutationObject()\r\n{\r\n\tthis.Name = \"Mutation\";\r\n\tthis.Description = \"The mutation type, represents all updates we can make to our data.\";\r\n\r\n        \r\n\r\n\tthis.FieldAsync<PersonObject, Person>(\r\n\t\t\"createPerson\",\r\n\t\t\"Create a person.\",\r\n\t\targuments: new QueryArguments(\r\n\t\t\tnew QueryArgument<NonNullGraphType<PersonInputObject>>()\r\n\t\t\t{\r\n\t\t\t\tName = \"person\",\r\n\t\t\t\tDescription = \"The person you want to create.\",\r\n\t\t\t}),\r\n\t\tresolve: context =>\r\n\t\t{\r\n\t\t\tvar person= context.GetArgument<Person>(\"person\");\r\n// dostuff\r\n\t\t\t\r\n\t\t\treturn person;\r\n\t\t}\r\n\t);\r\n}\r\n```\r\n\r\nOr should I resolve everything by hand in the mutation's resolver?\r\n\r\nAny examples available?\r\n\r\n",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/864/comments",
    "author": "zjean",
    "comments": [
      {
        "user": "joemcbride",
        "created_at": "2018-10-17T08:16:33Z",
        "body": "There is currently nothing built-in to transform the input in this way.  This would need to be a manual transform that you do yourself from the `Arguments` dictionary."
      },
      {
        "user": "rose-a",
        "created_at": "2018-10-24T13:45:55Z",
        "body": "You can let `Newtonsoft.Json` do the conversion like so:\r\n\r\n```c#\r\nvar personArg = ctx.GetArgument<object>(\"person\");\r\nvar person = personArg != null\r\n    ? JToken.FromObject(personArg).ToObject<Person>()\r\n    : null;\r\n```\r\n\r\nWorks pretty well by default in most situations, you can even leverage a potentially already written custom JsonConverter for complexer objects."
      },
      {
        "user": "joemcbride",
        "created_at": "2018-10-25T16:28:46Z",
        "body": "Perhaps a slightly better version (with a little less processing):\r\n\r\n```csharp\r\nvar personArg = ctx.Arguments[\"person\"];\r\nvar person = personArg != null\r\n    ? JToken.FromObject(personArg).ToObject<Person>()\r\n    : null;\r\n```"
      },
      {
        "user": "rose-a",
        "created_at": "2018-10-26T10:55:42Z",
        "body": "Just to be thorough, here are some ready to use extension methods:\r\n\r\n```c#\r\npublic static class ResolveFieldContextExtensions\r\n{\r\n    public static TObject ConvertArgumentToObject<TObject>(this ResolveFieldContext ctx, string argumentName)\r\n        => _convertArgument<TObject>(ctx.Arguments, argumentName);\r\n\r\n    public static TObject ConvertArgumentToObject<TObject>(this ResolveFieldContext<object> ctx, string argumentName)\r\n        => _convertArgument<TObject>(ctx.Arguments, argumentName);\r\n\r\n    public static TObject ConvertArgumentToObject<TObject, TSource>(this ResolveFieldContext<TSource> ctx, string argumentName)\r\n        => _convertArgument<TObject>(ctx.Arguments, argumentName);\r\n\r\n    private static TObject _convertArgument<TObject>(IReadOnlyDictionary<string, object> arguments, string argumentName)\r\n    {\r\n        return arguments[argumentName] != null\r\n            ? JToken.FromObject(arguments[argumentName]).ToObject<TObject>()\r\n            : default;\r\n    }\r\n}\r\n```\r\n\r\nto be used like this:\r\n\r\n```c#\r\nvar person = ctx.ConvertArgumentToObject<Person>(\"person\");\r\n```\r\n\r\n@joemcbride \r\nMaybe this could be delivered with the library? \r\n\r\nIs there a reason the generic `ResolveFieldContext<TSource>` does not inherit from `ResolveFieldContext`? This would eliminate the need of creating separate extension methods for them (not just in this case)..."
      },
      {
        "user": "joemcbride",
        "created_at": "2018-11-13T23:19:12Z",
        "body": "@rose-a I don't want to have multiple ways to transform the data.  This is an often requested feature though so I think we should provide some way to do it.  I'm not sure what that looks like yet, but I'm stewing on it."
      },
      {
        "user": "BenjaBobs",
        "created_at": "2018-11-14T07:41:45Z",
        "body": "I second @rose-a question about the inheritance chain.\r\n\r\n```c#\r\npublic class ResolveFieldContext\r\n{\r\n\t//...\r\n\tpublic object Source { get; set; }\r\n}\r\n\r\npublic class ResolveFieldContext<TSource> : ResolveFieldContext\r\n{\r\n\tpublic new TSource Source \r\n\t{ \r\n\t\tget => (TSource)base.Source; \r\n\t\tset => base.Source = value;\r\n\t}\r\n}\r\n```\r\n\r\nIf we design it like this, we can make generic (in the Source-type agnostic sense) solutions by creating solutions for the `ResolveFieldContext`.\r\nI think it would simplify the code."
      },
      {
        "user": "benmccallum",
        "created_at": "2019-08-12T06:10:21Z",
        "body": "Hey @SimonCropp, I've got a situation like above where I wanna use an input type with an inner complex input type. Solution above seems nice enough for me utilising `Newtonsoft.Json` to deserialize input into an object. I was thinking of extending @rose-a's example by adding a line to fire the fluent validation like so:\r\n`ArgumentValidation.Validate(context.GetCache(), typeof(TArgument), argument, context.UserContext);`, but `ArgumentValidation` is private. Can you make it public? "
      },
      {
        "user": "indeavr",
        "created_at": "2019-09-10T05:00:02Z",
        "body": "And what about using AutoMapper for this purpose ?\r\n"
      },
      {
        "user": "sungam3r",
        "created_at": "2019-09-10T06:32:31Z",
        "body": "I would not want to drag it into the project. This is an extra dependency, dragging along a bunch of unnecessary functionality. I have been working with the AutoMapper for a long time and cannot say that I am delighted with it."
      },
      {
        "user": "sungam3r",
        "created_at": "2020-02-27T22:35:22Z",
        "body": "> Is there a reason the generic ResolveFieldContext<TSource> does not inherit from ResolveFieldContext? This would eliminate the need of creating separate extension methods for them (not just in this case)...\r\n\r\nDone in other PRs."
      },
      {
        "user": "sungam3r",
        "created_at": "2020-02-29T17:44:05Z",
        "body": ">  I don't want to have multiple ways to transform the data. This is an often requested feature though so I think we should provide some way to do it. I'm not sure what that looks like yet, but I'm stewing on it.\r\n\r\n@joemcbride it's done in #1582 \r\n\r\n> This would eliminate the need of creating separate extension methods for them \r\n\r\n@rose-a you're right, with changes from #1582 you can continue to use `GetArgument` API through your codebase.\r\n"
      },
      {
        "user": "sungam3r",
        "created_at": "2020-03-01T22:25:02Z",
        "body": "@zjean Done in #1582 . You can try the latest preview."
      }
    ]
  },
  {
    "number": 766,
    "title": "Disable Introspection Query",
    "created_at": "2018-08-02T21:24:04Z",
    "closed_at": "2018-08-03T19:00:14Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/766",
    "body": "Is there any way to disable the introspection query in an specific environment (production, in my case)?",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/766/comments",
    "author": "wendelnascimento",
    "comments": [
      {
        "user": "joemcbride",
        "created_at": "2018-08-02T21:49:32Z",
        "body": "There is nothing build-in, but you could inspect the request to determine it is introspection and not allow it.  Either by using a validation rule (probably the easiest) or you can build the `Document` yourself and inspect it.\r\n\r\n```csharp\r\nvar documentBuilder = new GraphQLDocumentBuilder();\r\nvar document = documentBuilder.Build(options.Query);\r\n\r\n// loop through operations + fields and see if it is introspection\r\n\r\n// pass Document to executor so it doesn't have to build it again\r\nschema.Execute(_ =>\r\n{\r\n    _.Query = options.Query;\r\n    _.Document = document;\r\n});\r\n```\r\n\r\nValidation rules already loop through operations + fields for you.\r\n\r\n```csharp\r\npublic class IntrospectionNotAllowed : IValidationRule\r\n{\r\n    public INodeVisitor Validate(ValidationContext context)\r\n    {\r\n        return new EnterLeaveListener(_ =>\r\n        {\r\n            var myContext = context.UserContext as MyGraphQLContext;\r\n\r\n            if(!myContext.IsProduction()) return;\r\n\r\n            _.Match<Field>(\r\n                enter: field =>\r\n                {\r\n                    // don't recall the exact properties off-hand\r\n                    if (field...)\r\n                    {\r\n                        var error = new ValidationError(\r\n                            context.OriginalQuery,\r\n                            \"code1\",\r\n                            \"Not allowed\",\r\n                            field);\r\n                        context.ReportError(error);\r\n                    }\r\n                });\r\n        });\r\n    }\r\n}\r\n```"
      },
      {
        "user": "joemcbride",
        "created_at": "2021-07-28T20:22:41Z",
        "body": "Code updated for latest validation rules structure.\r\n\r\nThis fails on any query that uses GraphQL types that starts with `__`. If you want to allow some introspection queries, such as `__type` but disallow others, such as `__schema`, update the `IsIntrospectionType` function in this example.\r\n\r\n```csharp\r\n    /// <summary>\r\n    /// Introspection is not allowed in production.\r\n    /// </summary>\r\n    public class IntrospectionNotAllowed : IValidationRule\r\n    {\r\n        /// <summary>\r\n        /// Returns a static instance of this validation rule.\r\n        /// </summary>\r\n        public static readonly IntrospectionNotAllowed Instance = new IntrospectionNotAllowed();\r\n\r\n        /// <inheritdoc/>\r\n        /// <exception cref=\"ScalarLeafsError\"/>\r\n        public Task<INodeVisitor> ValidateAsync(ValidationContext context) => _nodeVisitor;\r\n\r\n        private static readonly Task<INodeVisitor> _nodeVisitor =\r\n            new MatchingNodeVisitor<Field>((f, context) => Field(context.TypeInfo.GetLastType(), f, context))\r\n                .ToTask();\r\n\r\n        private static void Field(IGraphType? type, Field field, ValidationContext context)\r\n        {\r\n            if (type == null)\r\n            {\r\n                return;\r\n            }\r\n\r\n            var myContext = context.UserContext as MyGraphQLContext;\r\n            if(!myContext.IsProduction()) return;\r\n\r\n            if (type?.IsIntrospectionType())\r\n                context.ReportError(new IntrospectionNotAllowedError(context, field, type));\r\n        }\r\n    }\r\n\r\n    [Serializable]\r\n    public class IntrospectionNotAllowedError : ValidationError\r\n    {\r\n        internal const string NUMBER = \"0\";\r\n\r\n        /// <summary>\r\n        /// Initializes a new instance with the specified properties.\r\n        /// </summary>\r\n        public IntrospectionNotAllowedError(ValidationContext context, Field node, IGraphType type)\r\n            : base(context.Document.OriginalQuery!, NUMBER, \"Introspection is not allowed.\", node)\r\n        {\r\n        }\r\n    }\r\n\r\n    // <summary>\r\n    /// Provides extension methods for working with graph types.\r\n    /// </summary>\r\n    public static class Extensions\r\n    {\r\n        /// <summary>\r\n        /// Determines if this graph type is an introspection type.\r\n        /// </summary>\r\n        public static bool IsIntrospectionType(this IGraphType type) => type?.Name?.StartsWith(\"__\", StringComparison.InvariantCulture) ?? false;\r\n    }\r\n```"
      }
    ]
  },
  {
    "number": 759,
    "title": "Why does the generic EnumerationGraphType<TEnum> use the name of TEnum as the graphql type name? - inconsistent with ObjectGraphType",
    "created_at": "2018-08-01T16:45:34Z",
    "closed_at": "2018-08-11T18:12:14Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/759",
    "body": "This is regarding a line in `graphql-dotnet/src/GraphQL/Types/EnumerationGraphType.cs`  that sets the name to the name of the underlying TEnum\r\n```\r\npublic EnumerationGraphType()\r\n{\r\n    var type = typeof(TEnum);\r\n\r\n    Name = Name ?? StringUtils.ToPascalCase(type.Name);\r\n...\r\n```\r\n\r\nI'm not sure why that name is being set there. Here is an example of it causing a problem:\r\n```\r\npublic class Organisation\r\n{\r\n    public enum AccessLevel { Admin, Member }\r\n}\r\n\r\npublic class Project\r\n{\r\n    public enum AccessLevel { Admin, Member, ReadOnly }\r\n}\r\n\r\npublic class OrganisationAccessLevelEnum : EnumerationGraphType<Organisation.AccessLevel>\r\n{\r\n    public AccessLevelEnum()\r\n    {\r\n        AddValue(\"ADMIN\", \"\", Organisation.AccessLevel.Admin);\r\n        AddValue(\"MEMBER\", \"\", Organisation.AccessLevel.Member);\r\n    }\r\n}\r\n\r\npublic class ProjectAccessLevelEnum : EnumerationGraphType<Project.AccessLevel>\r\n{\r\n    public AccessLevelEnum()\r\n    {\r\n        AddValue(\"ADMIN\", \"\", Organisation.AccessLevel.Admin);\r\n        AddValue(\"MEMBER\", \"\", Organisation.AccessLevel.Member);\r\n        AddValue(\"READ_ONLY\", \"\", Organisation.AccessLevel.ReadOnly);\r\n    }\r\n}\r\n```\r\nBoth of those enums will get named \"AccessLevel\".\r\n\r\nI'm able to avoid it by removing the generic like this:\r\n```\r\npublic class ProjectAccessLevelEnum : EnumerationGraphType\r\n{\r\n    public AccessLevelEnum()\r\n    {\r\n        AddValue(\"ADMIN\", \"\", Organisation.AccessLevel.Admin);\r\n        AddValue(\"MEMBER\", \"\", Organisation.AccessLevel.Member);\r\n        AddValue(\"READ_ONLY\", \"\", Organisation.AccessLevel.ReadOnly);\r\n    }\r\n}\r\n```\r\nwhich will use the name \"ProjectAccessLevelEnum\"\r\n\r\nMy question is: Why does the generic version of EnumerationGraphType work this way? -  the generic version of ObjectGraphType does not do this. ",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/759/comments",
    "author": "saborrie",
    "comments": [
      {
        "user": "joemcbride",
        "created_at": "2018-08-01T18:35:33Z",
        "body": "The generic version of `EnumerationGraphType` tries to add all the enum values for you so you don't have to duplicate them.  This is helpful in most cases.\r\n\r\nYou should be able to just override the `Name` and it will still set all the enum values for you?\r\n\r\n```\r\npublic class OrganisationAccessLevelEnum : EnumerationGraphType<Organisation.AccessLevel>\r\n{\r\n    public AccessLevelEnum()\r\n    {\r\n        Name = \"OrganizationAccessLevelEnum\";\r\n    }\r\n}\r\n```\r\n\r\nNote that with using the non-generic version you will still be required to set the `Name`."
      },
      {
        "user": "saborrie",
        "created_at": "2018-08-01T19:24:09Z",
        "body": "Thank you for the quick reply.\r\n\r\n> The generic version of EnumerationGraphType tries to add all the enum values for you so you don't have to duplicate them. This is helpful in most cases.\r\n\r\nCool, that's really useful!\r\n\r\n> You should be able to just override the Name and it will still set all the enum values for you?\r\n\r\nOk, yeah I didn't realise I could just set the name.\r\n\r\nHowever:\r\n> Note that with using the non-generic version you will still be required to set the Name.\r\n\r\nThis didn't seem the case for me, the non generic one worked as expected\r\n"
      }
    ]
  },
  {
    "number": 737,
    "title": "How can i use DataTables with ObjectGraphType?",
    "created_at": "2018-07-15T20:49:14Z",
    "closed_at": "2018-07-19T11:46:29Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/737",
    "body": "My issue is that i have legacy functions returning .net DataTables and writing POCOs for each datatable is a tedious task. How can i integrate Datatables and Datasets into the root query.\r\nI'm thinking something like this.\r\n```\r\n//Example field\r\nField<DataTable>(\r\n                \"Employees\",\r\n                resolve: context => GetAllEmployees();\r\n\r\n//And the Legacy Data access layer\r\npublic Datatable GetAllEmployees( ){ \r\n// Legacy code executing sql queries \r\n}\r\n```\r\nPlease help me , i'm stuck in this issue.",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/737/comments",
    "author": "HHK01",
    "comments": [
      {
        "user": "joemcbride",
        "created_at": "2018-07-16T05:18:33Z",
        "body": "It's been a very long time since I had to deal with a `DataTable`, though I think you should be able to create a `IFieldResolver` that knows how to work with a `DataRow`.\r\n\r\n```csharp\r\npublic class QueryGraphType : ObjectGraphType\r\n{\r\n    public QueryGraphType()\r\n    {\r\n        Name = \"Query\";\r\n        Field<ListGraphType<EmployeeGraphType>>(\r\n            \"employees\",\r\n            // notice that the 'DataTable.Rows' are being returned\r\n            // the GraphQL library should loop over those rows (hopefully)\r\n            resolve: context => GetAllEmployees().Rows\r\n        );\r\n    }\r\n\r\n    public DataTable GetAllEmployees()\r\n    {\r\n        return ...;\r\n    }\r\n}\r\n\r\npublic class EmployeeGraphType : ObjectGraphType\r\n{\r\n    public EmployeeGraphType()\r\n    {\r\n        Name = \"Employee\";\r\n        // new extension method for your custom field type\r\n        this.DataRowField<IdGraphType>(\"Id\");\r\n        this.DataRowField<StringGraphType>(\"Name\");\r\n    }\r\n}\r\n\r\npublic static class ObjectGraphTypeExtensions\r\n{\r\n    public static void DataRowField<TGraphType>(\r\n        this ObjectGraphType type,\r\n        string name,\r\n        string description = null,\r\n        QueryArguments arguments = null,\r\n        string deprecationReason = null)\r\n        where TGraphType : IGraphType\r\n    {\r\n        // create a new FieldType with your custom DataRowResolver\r\n        type.AddField(new FieldType\r\n        {\r\n            Name = name,\r\n            Description = description,\r\n            Type = typeof(TGraphType),\r\n            Arguments = arguments,\r\n            DeprecationReason = deprecationReason,\r\n            Resolver = new DataRowResolver()\r\n        });\r\n    }\r\n}\r\n\r\npublic class DataRowResolver : IFieldResolver\r\n{\r\n    public object Resolve(ResolveFieldContext context)\r\n    {\r\n        var row = context.Source as DataRow;\r\n        // context.Name is the name of the field\r\n        // registered on FieldType\r\n        return row[context.Name];\r\n    }\r\n}\r\n```"
      }
    ]
  },
  {
    "number": 695,
    "title": "Using FieldAsync to resolve an async mutation ",
    "created_at": "2018-06-14T12:17:15Z",
    "closed_at": "2018-06-14T16:07:18Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/695",
    "body": "Is this the correct way to make a mutation resolver async?\r\nUsing GraphQL Version 0.17.3\r\n\r\n```csharp\r\n// in startup\r\n    var result = await _documentExecuter.ExecuteAsync(_ =>\r\n    {\r\n        _.Schema = new Schema \r\n            {\r\n                Query = new Query();\r\n                Mutation = new Mutation();\r\n            }\r\n        // ...\r\n    });\r\n\r\n// mutation using FieldAsync\r\npublic class Mutation : ObjectGraphType\r\n{\r\n    public Mutation()\r\n    {\r\n        Name = \"Mutation\";\r\n\r\n        // note that createTransaction is async\r\n        FieldAsync<TransactionNode>(\"createTransaction\",\r\n            // arguments: new QueryArguments {...}\r\n            resolve: async ctx => await TransactionInput.CreateTransaction();\r\n        // ...\r\n    }\r\n}\r\n\r\n// async mutation resolver\r\npublic class TransactionInput : InputObjectGraphType\r\n{\r\n    // ...\r\n    public static async Task<TransactionNode> CreateTransaction()\r\n    { \r\n        // ...\r\n        await _httpClient.SendAsync()\r\n        // ...\r\n    }\r\n    // ...\r\n}\r\n```\r\nThanks",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/695/comments",
    "author": "masduo",
    "comments": [
      {
        "user": "joemcbride",
        "created_at": "2018-06-14T14:53:55Z",
        "body": "You only need to use FieldAsync if you need/want to use the async keyword.  You can return a Task and it will be awaited for you with the other overloads."
      },
      {
        "user": "masduo",
        "created_at": "2018-06-14T15:55:06Z",
        "body": "Thanks @joemcbride \r\nBut is my sample above the recommended way to use the library if i need need/want async? Otherwise do you have an example of how to use it? \r\n\r\nAlso is this what you mean by\r\n> ... return a Task and it will be awaited for you with the other overloads.\r\n\r\n```csharp\r\n// mutation\r\nField<TransactionNode>(\"createTransaction\",\r\n    // arguments: new QueryArguments {...}\r\n    resolve: ctx => TransactionInput.CreateTransaction();\r\n\r\n// resolver's still async and returns a Task\r\n public static async Task<TransactionNode> CreateTransaction() \r\n{ \r\n    await _httpClient.SendAsync(...);\r\n}\r\n```\r\n"
      },
      {
        "user": "joemcbride",
        "created_at": "2018-06-14T16:00:14Z",
        "body": "> is this what you mean\r\n\r\nYes. These are functionally equivalent.  One just allows you to use the `async` keyword in the `resolve:` declaration.\r\n\r\n```csharp\r\nField<TransactionNode>(\"createTransaction\",\r\n    resolve: ctx => TransactionInput.CreateTransaction();\r\n\r\nFieldAsync<TransactionNode>(\"createTransaction\",\r\n    resolve: async ctx => await TransactionInput.CreateTransaction();\r\n```"
      }
    ]
  },
  {
    "number": 667,
    "title": "[Question] - nested mutations or multiple files",
    "created_at": "2018-05-24T11:19:54Z",
    "closed_at": "2018-06-12T07:15:54Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/667",
    "body": "Hi guys,\r\n\r\nI'm trying to figure out how to do nested mutations if it's even possible? \r\n\r\nI want to have better, logical spearation.\r\n**Schema.Mutation** is type **IObjectGraphType**. \r\nSo I created corresponding file. Everything is fine when I have all mutations in one file, but it's stupid for anything bigger than example project. I want to split mutations logical into separate file, but how to wrap it and make it work ? ",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/667/comments",
    "author": "sgwozdz",
    "comments": [
      {
        "user": "chwarwick",
        "created_at": "2018-05-24T20:01:47Z",
        "body": "@sgwozdz A simple option that you can use is to put a marker Interface on all your individual Mutation classes and then inject them into the main Mutation.  Then you just just loop through and add all it's fields\r\n```\r\npublic Mutation(IEnumerable<IMutation> mutationClasses)\r\n{\r\n    foreach (var mutationClass in mutationClasses)\r\n    {\r\n         foreach (var field in mutationClass.Fields)\r\n         {\r\n             AddField(field);\r\n         }\r\n    }\r\n}\r\n```\r\n"
      },
      {
        "user": "joemcbride",
        "created_at": "2018-05-25T18:22:25Z",
        "body": "Here is one \"trick\" you can do - you can \"group\" them under a subfield.  Something like this:\r\n\r\n```\r\nField<PersonMutation>(\"people\", resolve: ctx => new {});\r\n\r\nmutation CreatePersonMutation {\r\n  people {\r\n    createPerson(name: \"Joe\") {\r\n      id\r\n      name\r\n    }\r\n  }\r\n}\r\n```\r\n\r\nNot the best perhaps, but an option."
      }
    ]
  },
  {
    "number": 655,
    "title": "Resolving objects inside other objects",
    "created_at": "2018-05-09T02:33:22Z",
    "closed_at": "2018-05-09T03:16:22Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/655",
    "body": "I'm attempting to build a schema with two objects: Assets and Actors.\r\n\r\n```cs\r\n    public class Asset\r\n    {\r\n        public string Id { get; set; }\r\n        public Actor Owner { get; set; }\r\n        public string Location { get; set; }\r\n        public string Variety { get; set; }\r\n        public string Quantity { get; set; }\r\n    }\r\n```\r\n\r\n```cs\r\n    public class Actor\r\n    {\r\n        public string Id { get; set; }\r\n        public string Name { get; set; }\r\n        public string Address { get; set; }\r\n    }\r\n```\r\n\r\nBut I run into an issue running queries to select Assets. For example, this query gives the error \"Field owner of type Actor must have a sub selection\".\r\n\r\n```json\r\nquery {\r\n    asset(id: \"1\")\r\n    {\r\n        id,\r\n        owner,\r\n        location\r\n}\r\n```\r\n\r\nI really have no idea how to deal with this \ud83d\ude28 \r\n\r\nMy asset type:\r\n\r\n```cs\r\n        public AssetType(GeoraData data)\r\n        {\r\n            Name = \"Asset\";\r\n\r\n            Field(a => a.Id).Description(\"The ID of the asset\");\r\n            Field(a => a.Owner).Description(\"The owner of the asset\");\r\n            Field(a => a.Location).Description(\"The location where the asset is stored\");\r\n            Field(a => a.Variety).Description(\"The variety of the asset\");\r\n            Field(a => a.Quantity).Description(\"The quantity of the asset in mt\");\r\n        }\r\n```\r\n\r\nMy query:\r\n```cs\r\n        public Query(Data data)\r\n        {\r\n            Name = \"Query\";\r\n\r\n            Field<AssetType>(\r\n                \"asset\",\r\n                arguments: new QueryArguments(\r\n                    new QueryArgument<NonNullGraphType<StringGraphType>>\r\n                    {\r\n                        Name = \"id\",\r\n                        Description = \"ID of the asset\"\r\n                    }),\r\n                resolve: context => data.GetAssetByIdAsync(context.GetArgument<string>(\"id\")));\r\n\r\n            Field<ActorType>(\r\n                \"actor\",\r\n                arguments: new QueryArguments(\r\n                    new QueryArgument<NonNullGraphType<StringGraphType>>\r\n                    {\r\n                        Name = \"id\",\r\n                        Description = \"ID of the actor\"\r\n                    }),\r\n                resolve: context => data.GetActorByIdAsync(context.GetArgument<string>(\"id\")));\r\n        }\r\n```\r\n\r\nAny help fixing the issue would be very appreciated, as I have no idea where to start!\r\n",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/655/comments",
    "author": "kdelwat",
    "comments": [
      {
        "user": "joemcbride",
        "created_at": "2018-05-09T02:49:12Z",
        "body": "Because `owner` on `Asset` is a complex type, you have to provide what fields on that `GraphType` you want to query.\r\n\r\n```\r\nquery {\r\n    asset(id: \"1\")\r\n    {\r\n        id\r\n        owner {\r\n            id\r\n            name\r\n        }\r\n        location\r\n}\r\n```\r\n\r\nAlso because it is a complex type you will need to configure what `GraphType` it is.\r\n\r\n```diff\r\n-Field(a => a.Owner).Description(\"The owner of the asset\");\r\n\r\n+Field(a => a.Owner, type: typeof(ActorType)).Description(\"The owner of the asset\");\r\n```\r\n\r\nor\r\n\r\n```diff\r\n-Field(a => a.Owner).Description(\"The owner of the asset\");\r\n\r\n+Field<ActorType>(\"owner\", resolve: ctx => ctx.Source.Owner);\r\n```\r\n\r\nor\r\n\r\n```diff\r\nField(a => a.Owner).Description(\"The owner of the asset\");\r\n\r\n+GraphTypeRegistry.Register(typeof(Actor), typeof(ActorType));\r\n```"
      }
    ]
  },
  {
    "number": 653,
    "title": "Issue Resolving Dependencies in context.GetArgument<T>",
    "created_at": "2018-05-07T15:53:48Z",
    "closed_at": "2018-05-07T15:58:53Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/653",
    "body": "I am running into an error when trying to get an argument from a mutation\r\n\r\n```namespace Performance.GraphQl\r\n{\r\n    public class PerformanceMutation :ObjectGraphType<object>\r\n    {\r\n        public PerformanceMutation(PerformanceService service, Core core)\r\n        {\r\n            Field<SessionType>(\r\n                \"createSession\",\r\n                arguments: new QueryArguments(\r\n                    new QueryArgument<NonNullGraphType<SessionInputType>> { Name = \"session\" }\r\n                ),              \r\n                resolve: context =>\r\n                {\r\n                    var session = context.GetArgument<PerformanceSession>(\"session\"); //System.MissingMethodException: 'No parameterless constructor defined for this object.'\r\n                    var test = new PerformanceSession(core);//this works fine\r\n                    return service.AddSession(test); //As does this.\r\n                }\r\n            );\r\n        }\r\n    }\r\n\r\n }\r\n```\r\n\r\nThe PerformanceSession Object by my company's design needs a constructor that takes a Core object\r\n```\r\nnamespace Performance.Data\r\n{\r\n    public class PerformanceSession : ModelBase\r\n    {\r\n        public PerformanceSession(Core core) : base(core)\r\n        {\r\n        }\r\n\r\n        public override IModelPersistenceBase GetPersistence()\r\n        {\r\n            return new PerformanceSessionPersistence(UlineCore);\r\n        }\r\n///OTHER LOGIC///\r\n    }\r\n```\r\n\r\nIs having a DI dependent class in the context.GetArguments<T> method not supported?  \r\n\r\nHere is my Schmea in case that is needed to help, but I pretty much copied from the StarWars example.\r\n```\r\nnamespace Performance.GraphQl\r\n{\r\n    public class PerformanceSchema : Schema\r\n    {\r\n        public PerformanceSchema(IDependencyResolver resolver): base(resolver)\r\n        {\r\n            Query = resolver.Resolve<PerformanceQuery>();\r\n            Mutation = resolver.Resolve<PerformanceMutation>();\r\n            \r\n        }\r\n    }\r\n}\r\n```\r\n\r\nAnd the Resolver\r\n```namespace Performance\r\n{\r\n    public class UnityResolver : IDependencyResolver\r\n    {\r\n        protected IUnityContainer container;\r\n\r\n        public UnityResolver(IUnityContainer container)\r\n        {\r\n            if (container == null)\r\n            {\r\n                throw new ArgumentNullException(\"container\");\r\n            }\r\n            this.container = container;\r\n        }\r\n\r\n        public object GetService(Type serviceType)\r\n        {\r\n            try\r\n            {\r\n                return container.Resolve(serviceType);\r\n            }\r\n            catch (ResolutionFailedException)\r\n            {\r\n                return null;\r\n            }\r\n        }\r\n\r\n        public IEnumerable<object> GetServices(Type serviceType)\r\n        {\r\n            try\r\n            {\r\n                return container.ResolveAll(serviceType);\r\n            }\r\n            catch (ResolutionFailedException)\r\n            {\r\n                return new List<object>();\r\n            }\r\n        }\r\n\r\n        public IDependencyScope BeginScope()\r\n        {\r\n            var child = container.CreateChildContainer();\r\n            return new UnityResolver(child);\r\n        }\r\n\r\n        public void Dispose()\r\n        {\r\n            Dispose(true);\r\n        }\r\n\r\n        protected virtual void Dispose(bool disposing)\r\n        {\r\n            container.Dispose();\r\n        }\r\n    }\r\n}```\r\n\r\nThanks for any help you can provide\r\n",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/653/comments",
    "author": "Historyman",
    "comments": [
      {
        "user": "joemcbride",
        "created_at": "2018-05-07T15:56:43Z",
        "body": "Arguments are not setup to support DI.  They are designed to use basic DTOs.  So you would need to create a DTO with a parameterless constructor that represents your arguments."
      },
      {
        "user": "joemcbride",
        "created_at": "2018-05-07T16:01:04Z",
        "body": "Argument are just a `Dictionary<string, object>`, so you could write your own mapper if you really like, though having a DTO is a bit easier."
      }
    ]
  },
  {
    "number": 636,
    "title": "[Question] about value objects",
    "created_at": "2018-04-20T20:49:35Z",
    "closed_at": "2018-04-23T21:59:37Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/636",
    "body": "i have an object with a value object email and i need query the email as string. \u00bfHow can i do this whitout use a DTO class?",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/636/comments",
    "author": "miguelcaravantes",
    "comments": [
      {
        "user": "joemcbride",
        "created_at": "2018-04-20T21:02:17Z",
        "body": "`ResolveFieldContext.Arguments` is a dictionary with arguments.   Should be able to pull values from there.  If it is multiple levels deep then you would have to do some additional casting to/from `Dictionary<string,object>()`."
      },
      {
        "user": "miguelcaravantes",
        "created_at": "2018-04-20T21:34:50Z",
        "body": "the problem is not pull arguments, the problem is sending values to the client, my email value object is not sended as string"
      },
      {
        "user": "joemcbride",
        "created_at": "2018-04-20T21:37:22Z",
        "body": "Ah - you could create your own scalar type to do that.  To convert it from your value object to a string."
      },
      {
        "user": "joemcbride",
        "created_at": "2018-04-20T21:45:13Z",
        "body": "Something like this:\r\n\r\n```\r\nField<EmailGraphType>(\"email\", resolve: context =>\r\n{\r\n    return new Email{ Value = \"me@me.com\"};\r\n});\r\n\r\n    public class Email\r\n    {\r\n        public string Value { get; set; }\r\n    }\r\n\r\n    public class EmailGraphType : ScalarGraphType\r\n    {\r\n        public override object ParseLiteral(IValue value)\r\n        {\r\n            if(value is StringValue)\r\n            {\r\n                return ParseValue(((StringValue)value).Value);\r\n            }\r\n\r\n            return null;\r\n        }\r\n\r\n        public override object ParseValue(object value)\r\n        {\r\n            if(value is string)\r\n            {\r\n                return new Email { Value = value.ToString() };\r\n            }\r\n\r\n            return null;\r\n        }\r\n\r\n        public override object Serialize(object value)\r\n        {\r\n            return ((Email)value).Value;\r\n        }\r\n    }\r\n```"
      }
    ]
  },
  {
    "number": 616,
    "title": "IDependencyResolver obsolete, how do I properly setup schema using .net core 2.0 DI and GraphQL ?",
    "created_at": "2018-04-05T16:10:50Z",
    "closed_at": "2018-06-15T15:57:23Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/616",
    "body": "I am setting up my  .net core environment to use .net core DI with GraphQL . The sample code (starwars) does this: \r\n\r\nservices.AddSingleton<ISchema>(  s => new StarWarsSchema(new FuncDependencyResolver(type => (IGraphType)s.GetRequiredService(type))));\r\n\r\nHowever, the IDependencyResolver interface is not available in the GraphQL version I am using (latest at this time: 0.17.3) so I can't use that code. Is there any example of how to do this with this latest version of graphQL or should I revert to some previous version instead?. ",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/616/comments",
    "author": "peyoquintero",
    "comments": [
      {
        "user": "joemcbride",
        "created_at": "2018-04-05T17:13:45Z",
        "body": "That example is using the 2.0 pre-release which is newer than 0.17.3.  So you can upgrade to the pre-release or use the setup that is required in 0.17.3, which is just removing the `FuncDependencyResolver` type.\r\n\r\n2.x\r\n```\r\nservices.AddSingleton(\r\n  s => new StarWarsSchema(new FuncDependencyResolver(type => (IGraphType)s.GetRequiredService(type))));\r\n```\r\n\r\n0.x\r\n```\r\nservices.AddSingleton( \r\n  s => new StarWarsSchema((type) => (IGraphType)s.GetRequiredService(type)));"
      },
      {
        "user": "fiyazbinhasan",
        "created_at": "2018-04-09T13:41:16Z",
        "body": "Hi @joemcbride , what if I configure the default container the following way,\r\n\r\n    services.AddSingleton<StartWarsQuery>();\r\n    services.AddSingleton<ISchema, StarWarsSchema();\r\n\r\nAnd apply constructor injection to pass in the query or mutation,\r\n\r\n    public class StarWarsSchema : Schema \r\n    {\r\n        public StarWarsSchema(StartWarsQuery query)\r\n        {\r\n            Query = query;\r\n        }\r\n    }\r\n\r\nWill it be any different from,\r\n\r\n    services.AddSingleton(s => new StarWarsSchema(new FuncDependencyResolver(type => (IGraphType)s.GetRequiredService(type))));"
      },
      {
        "user": "joemcbride",
        "created_at": "2018-04-09T17:54:40Z",
        "body": "@fiyazbinhasan Yes, if you do not provide a dependency resolver to your Schema then if you attempt to do constructor injection in any other GraphTypes in the graph then it will fail.  By default, if no dependency resolver is provided, it attempts to use `Activator.CreateInstance` to create the graph types."
      }
    ]
  },
  {
    "number": 287,
    "title": "Need Advice - Passing Headers received on request to resolver method",
    "created_at": "2017-03-01T19:50:09Z",
    "closed_at": "2017-03-01T20:10:33Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/graphql-dotnet/graphql-dotnet/issues/287",
    "body": "@joemcbride I am trying to capture the headers received on /graphql request and then make them available in resolve methods so that this information can be used for passing to next API calls made by graphql server for resolving fields.\r\n\r\nBased on my understanding I am planning capture headers in Middleware and then pass it to the request using _.UserContext method:\r\n```\r\n            return await new DocumentExecuter().ExecuteAsync(_ =>\r\n            {\r\n                _.Schema = schema;\r\n                _.Query = graphqlRequest.Query;\r\n                _.Inputs = inputs;\r\n                _.OperationName = graphqlRequest.OperationName;\r\n                _.UserContext = request.Headers;\r\n                _.FieldNameConverter = new DefaultFieldNameConverter();\r\n                \r\n            }).ConfigureAwait(false);\r\n```\r\n\r\nThis becomes available in query / root field. However, how can I access these in resolver method built by me. Do I need to pass a reference or context is supposed to be auto available there:\r\n\r\n```\r\n\tField<TestAPIReturnType>( \"TestAPI\",\r\n\t\targuments: new  QueryArguments(new QueryArgument<NonNullGraphType<StringGraphType>> { Name = \"id\"}),\r\n\t\t\t\tresolve: context => {\r\n                                      var Headers = context.UserContext;\r\n\t\t\t\t\tstring __id =  context.GetArgument<string>(\"IdentityID\");\r\n\t\t\t\t\tif(String.IsNullOrWhiteSpace(__id)){return null;}\r\n\t\t\t\t\treturn TestAPIResolver.GetSingle_Resolver(__id);\r\n\t\t\t\t}\r\n\t\t\t);\r\n```",
    "comments_url": "https://api.github.com/repos/graphql-dotnet/graphql-dotnet/issues/287/comments",
    "author": "pravinhabbu4u",
    "comments": [
      {
        "user": "joemcbride",
        "created_at": "2017-03-01T19:56:26Z",
        "body": "You have it right.  `context.UserContext` in resolvers will be populated with the value assigned to `_.UserContext`.\r\n\r\nI would suggest to create a class so you can add other information later if needed, and you won't have to go back and edit everything.\r\n\r\n```csharp\r\npublic class GraphQLUserContext\r\n{\r\n    public IHeaderDictionary Headers { get; set; }\r\n}\r\n\r\n_.UserContext = new GraphQLUserContext { Headers = request.Headers };\r\n```"
      },
      {
        "user": "santoshpatro",
        "created_at": "2018-11-07T18:38:43Z",
        "body": "Hi Joe/Pravinhabbu4u,\r\n\r\nI have the same requirement as mentioned  in this question. After reading your suggestions, I created a class: GraphQLUserContext as mentioned by you and registered in the ConfigureServices method in the Startup.cs class.I see that even the UserContext is set with the headers in the GraphQLController but on using it in the TestQuery class, resolve method it is still returning null and leading to error. In short I am not getting the headers in the TestQuery class resolve method.\r\n\r\nCan you please help me how to fix this issue. \r\n\r\nOne more small request like in my current project where I am using Graphql.NET to create the new endpoints, I have to always pass the locale data by reading the incoming request headers to the business logic via the resolve methods. Since this is going to be repeated in almost every resolve method can you please guide me how to encapsulate it in one centralized place and implement it instead of repeating the duplicating the code in every resolve method.\r\n\r\nAny help on this is much appreciated.\r\n\r\n```\r\n// Utilties\r\npublic interface IGraphQLUserContext\r\n{\r\n\tIHeaderDictionary Headers\r\n\t{\r\n\t\tget;\r\n\t\tset;\r\n\t}\r\n//string GetCookieId();\r\n}\r\n\r\npublic class GraphQLUserContext : IGraphQLUserContext\r\n{\r\n\tpublic IHeaderDictionary Headers\r\n\t{\r\n\t\tget;\r\n\t\tset;\r\n\t}\r\n}\r\n\r\n// GraphQLController\r\n[HttpPost]\r\npublic async Task<IActionResult> Post([FromBody] GraphQLQuery query)\r\n{\r\n\tif (query == null)\r\n\t{\r\n\t\tthrow new ArgumentNullException(nameof(query));\r\n\t}\r\n\r\n\tvar inputs = query.Variables.ToInputs();\r\n\tvar executionOptions = new ExecutionOptions{Schema = _schema, Query = query.Query, Inputs = inputs, UserContext = new GraphQLUserContext{Headers = Request.Headers}};\r\n\tvar result = await _documentExecuter.ExecuteAsync(executionOptions).ConfigureAwait(false);\r\n\tif (result.Errors?.Count > 0)\r\n\t{\r\n\t\treturn BadRequest(result);\r\n\t}\r\n\r\n\treturn Ok(result);\r\n}\r\n\r\n// Startup.cs\r\npublic class Startup\r\n{\r\n\tpublic Startup(IConfiguration configuration)\r\n\t{\r\n\t\tConfiguration = configuration;\r\n\t}\r\n\r\n\tpublic IConfiguration Configuration\r\n\t{\r\n\t\tget;\r\n\t}\r\n\r\n\t// This method gets called by the runtime. Use this method to add services to the container.\r\n\tpublic void ConfigureServices(IServiceCollection services)\r\n\t{\r\n\t\tservices.AddMvc().SetCompatibilityVersion(CompatibilityVersion.Version_2_1);\r\n\t\tservices.AddScoped(provider =>\r\n\t\t{\r\n\t\t\tvar connectionString = Configuration.GetConnectionString(\"TestDb\");\r\n\t\t\treturn new CMSDbContext(connectionString);\r\n\t\t}\r\n\r\n\t\t);\r\n\t\tservices.AddSingleton<IGraphQLUserContext, GraphQLUserContext>();\r\n\t\tservices.AddSingleton<ITestService, TestService>();\r\n\t\tservices.AddSingleton<IDocumentExecuter, DocumentExecuter>();\r\n\t\tservices.AddSingleton<TestSchema>();\r\n\t\tvar sp = services.BuildServiceProvider();\r\n\t\tservices.AddSingleton<ISchema>(new TestSchema(new FuncDependencyResolver(type => sp.GetService(type))));\r\n\t}\r\n\r\n\t// This method gets called by the runtime. Use this method to configure the HTTP request pipeline.\r\n\tpublic void Configure(IApplicationBuilder app, IHostingEnvironment env)\r\n\t{\r\n\t\tif (env.IsDevelopment())\r\n\t\t{\r\n\t\t\tapp.UseDeveloperExceptionPage();\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tapp.UseHsts();\r\n\t\t}\r\n\r\n\t\tapp.UseGraphiQl();\r\n\t\tapp.UseHttpsRedirection();\r\n\t\tapp.UseMvc();\r\n\t}\r\n}\r\n\r\n// TestQuery\r\npublic class TestQuery : ObjectGraphType<object>\r\n{\r\n\tpublic TestQuery(ITestService testService, IGraphQLUserContext graphUserContext)\r\n\t{\r\n\t\tField<TestResultType>(\"result\", resolve: context =>\r\n\t\t{\r\n\t\t\tvar headers = graphQLUserContext.Headers;\r\n\t\t\t// Process headers to get the locale\r\n\t\t\treturn testService.GetDetailsForLocation(locale);\r\n\t\t}\r\n\r\n\t\t, description: \"Location details data\");\r\n\t}\r\n}\r\n```\r\n\r\n"
      }
    ]
  }
]