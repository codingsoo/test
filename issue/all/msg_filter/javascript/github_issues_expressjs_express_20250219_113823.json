[
  {
    "number": 6025,
    "title": "Raw Body Not Passed Correctly to Svix Webhook Verification",
    "created_at": "2024-10-05T17:56:43Z",
    "closed_at": "2024-10-09T21:47:11Z",
    "labels": [
      "help wanted",
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/6025",
    "body": "\r\nHi Express team,\r\n\r\nI'm encountering an issue while trying to verify a webhook payload using Svix in my Express.js app. Despite following the recommended approach from both the Svix documentation and Express documentation, I continue to receive an error stating:\r\n\r\n```\r\nError verifying the webhook: Expected payload to be of type string or Buffer.\r\n\r\n```\r\n**Context**:\r\nNode.js version: v20.17.0\r\nExpress version: 4.21.0\r\nbody-parser: I'm using bodyParser.raw({ type: \"application/json\" }) to pass the raw payload as recommended by Svix.\r\nSvix version: 1.35.0\r\n\r\nCode Snippet:\r\n\r\n```\r\nimport express from \"express\";\r\nimport { Webhook } from \"svix\";\r\nimport bodyParser from \"body-parser\";\r\n\r\nconst router = express.Router();\r\n\r\nrouter.post(\r\n  \"/webhook\",\r\n  bodyParser.raw({ type: \"application/json\" }), // Using raw body-parser\r\n  async (req, res, next) => {\r\n    const WEBHOOK_SECRET = process.env.WEBHOOK_SECRET;\r\n\r\n    if (!WEBHOOK_SECRET) {\r\n      return next(new Error(\"WEBHOOK_SECRET is missing in the environment.\"));\r\n    }\r\n\r\n    const payload = req.body;\r\n    const headers = req.headers;\r\n\r\n    const wh = new Webhook(WEBHOOK_SECRET);\r\n\r\n    try {\r\n      const evt = wh.verify(payload, headers);\r\n      // Further webhook processing...\r\n      return res.status(200).json({ success: true });\r\n    } catch (err) {\r\n      console.error(\"Webhook verification failed:\", err.message);\r\n      return res.status(400).json({\r\n        success: false,\r\n        message: \"Webhook verification failed.\",\r\n      });\r\n    }\r\n  }\r\n);\r\n\r\nexport default router;\r\n```\r\n\r\n**Problem**:\r\nAccording to the Svix documentation, the raw JSON payload must be passed directly to the Webhook.verify() method, without modification. However, Express appears to deserialize the JSON body into a JavaScript object, which causes the verification to fail because Svix expects a string or Buffer.\r\n\r\nOddly, the verification works when I manually wrap the payload in JSON.stringify():\r\n\r\n```\r\nconst evt = wh.verify(JSON.stringify(payload), headers);\r\n```\r\nHowever, this workaround is not ideal and could lead to other issues (as noted by Svix). I believe this issue arises from how Express handles the request body, even when using bodyParser.raw.\r\n\r\n**Expected Behavior:**\r\nExpress should provide the raw JSON payload to req.body when using bodyParser.raw({ type: \"application/json\" }).\r\n\r\n**Actual Behavior:**\r\nThe payload appears to be deserialized into a JavaScript object, causing the webhook verification to fail with the error: Expected payload to be of type string or Buffer.\r\n\r\nCould you provide insight on whether this is an issue with the body-parser, Express itself, or if there is a recommended approach to ensure the raw JSON body is passed to Svix?\r\n\r\nThank you!\r\n\r\n\r\n\r\n",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/6025/comments",
    "author": "MichaelvdVeer",
    "comments": [
      {
        "user": "dpopp07",
        "created_at": "2024-10-07T15:34:23Z",
        "body": "I'm unable to reproduce this. Using a bare app with your router, I receive the body as a `Buffer`, as expected.\r\n\r\nIs it possible that you have JSON-parsing middleware earlier in your application? If you have something like `app.use(express.json())` before your router is added the application, the body will already be parsed as JSON before it hits your router's middleware and it won't be parsed again (i.e. it will remain a JS object and won't be converted to a `Buffer`)."
      },
      {
        "user": "MichaelvdVeer",
        "created_at": "2024-10-07T15:59:30Z",
        "body": "Hi @dpopp07 Thank you for your feedback! You were absolutely right. Upon reviewing my code, I realized that I had app.use(express.json()) declared before the webhook route. This was causing the body to be parsed as JSON before it reached the middleware that expects a raw Buffer.\r\n\r\nI've now moved the app.use(express.json()) to be placed after the webhook route, and that resolved the issue. Thanks again for pointing me in the right direction!"
      }
    ]
  },
  {
    "number": 5532,
    "title": "Import syntax error with express.Router() import",
    "created_at": "2024-03-13T04:40:44Z",
    "closed_at": "2024-03-13T15:23:32Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/5532",
    "body": "### Need help figuring out why this would error.\r\nI am using bun and not node for the runtime. I don't think that affects anything here. I am using express JS 5.0 BETA 1\r\nI just feel there is a better way than actually doing (despite Node/Bun caching modules I still feel like this is redundant):\r\n```\r\nimport express from 'express';\r\nconst viewRouter = express.Router();\r\n```\r\n* The Code\r\n```\r\nimport { Router as viewRouter } from 'express';\r\nviewRouter.get('/', (req, res) => {\r\n    res.render('index.ejs');\r\n});\r\nmodule.exports = viewRouter;\r\n```\r\n* The Error\r\n```\r\nSyntaxError: Unexpected token '{'. import call expects one or two arguments.\r\n      at <parse> (/mnt/z/sic-web/src/server/routes/viewRouter.js:1:1)\r\n1 | import {Router as viewRouter} from 'express';\r\n    ^\r\n```",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/5532/comments",
    "author": "cainba",
    "comments": [
      {
        "user": "cainba",
        "created_at": "2024-03-13T05:07:47Z",
        "body": "One thing I made an oopsie here with is the `module.exports= viewRouter` line which is commonJS . \r\nChange it to default export viewRouter and I get the following error:\r\n```\r\nTypeError: argument handler must be a function\r\n      at /mnt/z/sic-web/src/node_modules/router/lib/route.js:211:15\r\n      at /mnt/z/sic-web/src/node_modules/express/lib/application.js:474:5\r\n      at /mnt/z/sic-web/src/sicapp.js:11:1\r\n206 | \r\n207 |     for (var i = 0; i < callbacks.length; i++) {\r\n208 |       var fn = callbacks[i]\r\n209 | \r\n210 |       if (typeof fn !== 'function') {\r\n211 |         throw new TypeError('argument handler must be a function')\r\n                    ^\r\nTypeError: argument handler must be a function\r\n      at /mnt/z/sic-web/src/node_modules/router/lib/route.js:211:15\r\n      at /mnt/z/sic-web/src/node_modules/express/lib/application.js:474:5\r\n      at /mnt/z/sic-web/src/sicapp.js:11:1\r\n^C\r\ncain@cain-pc:/mnt/z/sic-web/src$ bun run dev\r\n$ bun --hot sicapp.js\r\n206 | \r\n207 |     for (var i = 0; i < callbacks.length; i++) {\r\n208 |       var fn = callbacks[i]\r\n209 | \r\n210 |       if (typeof fn !== 'function') {\r\n211 |         throw new TypeError('argument handler must be a function')\r\n                    ^\r\nTypeError: argument handler must be a function\r\n      at /mnt/z/sic-web/src/node_modules/router/lib/route.js:211:15\r\n      at /mnt/z/sic-web/src/node_modules/express/lib/application.js:474:5\r\n      at /mnt/z/sic-web/src/sicapp.js:12:1\r\n206 | \r\n207 |     for (var i = 0; i < callbacks.length; i++) {\r\n208 |       var fn = callbacks[i]\r\n209 | \r\n210 |       if (typeof fn !== 'function') {\r\n211 |         throw new TypeError('argument handler must be a function')\r\n                    ^\r\nTypeError: argument handler must be a function\r\n      at /mnt/z/sic-web/src/node_modules/router/lib/route.js:211:15\r\n      at /mnt/z/sic-web/src/node_modules/express/lib/application.js:474:5\r\n      at /mnt/z/sic-web/src/sicapp.js:12:1\r\n```"
      },
      {
        "user": "wesleytodd",
        "created_at": "2024-03-13T15:23:32Z",
        "body": "I am nearly positive even if you get this issue worked out you will just hit other issues. Express couples deeply to Node.js api's which are likely different enough to matter. Just don't want to provide an answer on the errors without pointing out you are likely in for a world of pain \ud83e\udd23. Additionally I don't think it has been discussed yet, but we likely do not have any plans to support Bun, so YMMV on this effort even in the longer term.\r\n\r\nThat said, it looks to me like something else is up with your code as I am not sure how the runtime difference could cause a typeof check to fail. And since that is the case, I am going to close this since we do not do technical support in here. If you can prove this is a bug of some sort in express please re-open this, but otherwise I would ask on Reddit or StackOverflow."
      },
      {
        "user": "joeyguerra",
        "created_at": "2024-03-13T16:45:27Z",
        "body": "I agree with Wes.\r\n\r\nI'll add this to give you some suggestion though.\r\n\r\n```javascript\r\nimport { Router as viewRouter } from 'express'\r\nviewRouter().get('/', (req, res) => {\r\n  res.render('index')\r\n})\r\nexport default viewRouter\r\n```\r\n\r\n`Router` is a function.\r\n\r\nI would suggest the following instead for `viewRouter.js`\r\n\r\n```javascript\r\nexport default app => {\r\n  app.get('/', (req, res) => {\r\n    res.render('index')\r\n  })\r\n}\r\n```\r\n\r\nand in `sicapp.js`, \r\n\r\n\r\n```javascript\r\nimport express from 'express'\r\nimport viewRouter from './routes/viewRouter.js'\r\n// other code\r\n...\r\n\r\nconst app = express()\r\n....\r\nviewRouter(app)\r\n\r\n```"
      }
    ]
  },
  {
    "number": 5331,
    "title": "Cannot route to a specific route",
    "created_at": "2023-11-23T18:11:28Z",
    "closed_at": "2023-11-25T14:26:00Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/5331",
    "body": "> This is the route that I want the express to route\r\n```\r\napp.use('/griev', require('./routes/api/grievance'));\r\n\r\napp.all('*', (req, res) => {\r\n    res.status(404);\r\n    if (req.accepts('html')) {\r\n        res.sendFile(path.join(__dirname, 'views', '404.html'));\r\n    } else if (req.accepts('json')) {\r\n        res.json({ \"error\": \"404 Not Found\" });\r\n    } else {\r\n        res.type('txt').send(\"404 Not Found\");\r\n    }\r\n});\r\n```\r\n> This is my grievance api route\r\n\r\n```\r\nconst express = require('express');\r\nconst router = express.Router();\r\nconst grievController = require('../../controllers/grievController');\r\nconst ROLES_LIST = require('../../config/roles_list');\r\nconst verifyRoles = require('../../middleware/verifyRoles');\r\n\r\nconsole.log(\"griev route\")\r\n\r\nif (verifyRoles(ROLES_LIST.User)) {\r\n    router.post(grievController.createIssue);\r\n}\r\nelse\r\n    console.log(\"could not verify\");\r\n\r\n\r\nmodule.exports = router;\r\n```\r\n**All I get is 404 error whenever I make a post request to ```/griev``` route** ",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/5331/comments",
    "author": "premsai-konduru",
    "comments": [
      {
        "user": "AverageY",
        "created_at": "2023-11-23T20:03:32Z",
        "body": "Does adding a route to the post fix it?\n\n```\nrouter.post('/' , controller);\n```"
      }
    ]
  },
  {
    "number": 5060,
    "title": "`item[]` format is parsed differently in express v5 compared to v4",
    "created_at": "2022-12-09T19:05:34Z",
    "closed_at": "2022-12-09T19:12:11Z",
    "labels": [
      "5.x",
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/5060",
    "body": "In express v4, if request contained query parameters suffixed with `[]` such as `items[]`. It would automatically be parsed into an array. This is no longer the case with express v5. \r\n\r\n",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/5060/comments",
    "author": "searchableguy",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2022-12-09T19:12:11Z",
        "body": "Hi @searchableguy this is correct, as the default parser was changed. You can get the old behavior using `app.set('query parser', 'extended')`."
      },
      {
        "user": "searchableguy",
        "created_at": "2022-12-09T20:10:39Z",
        "body": "Is there a place where I can also read more about the decision to move the parser from extended? \r\n\r\nIs it for security reasons? @dougwilson "
      },
      {
        "user": "dougwilson",
        "created_at": "2022-12-09T23:43:49Z",
        "body": "Hi @searchableguy there were many reasons, all spread out through issues in the issue tracker here. The decision was ultimately \"due to popular demand\". "
      }
    ]
  },
  {
    "number": 4879,
    "title": "The router restore function can incorrectly set variables to undefined",
    "created_at": "2022-04-03T14:26:13Z",
    "closed_at": "2022-04-03T16:13:04Z",
    "labels": [
      "question",
      "module:router"
    ],
    "url": "https://github.com/expressjs/express/issues/4879",
    "body": "I found a case where `request.params` becomes undefined. Here is a concrete test case to reproduce the case:\r\n\r\n```javascript\r\n// test/app.router.js\r\n\r\nit('should have req.params in finish event after handler2 calls next', function(done){\r\n  var app = express();\r\n\r\n  function handler1(req, res, next) {\r\n    res.once('finish', function() {\r\n      setTimeout(function() {\r\n        assert(req.params.id);\r\n      })\r\n    })\r\n\r\n    next()\r\n  }\r\n\r\n  function handler2(req, res, next){\r\n    res.end(req.params.id);\r\n    next()\r\n  }\r\n\r\n  app.get('/user/:id', handler1, handler2);\r\n\r\n  request(app)\r\n  .get('/user/1')\r\n  .expect(200, '1', done);\r\n})\r\n```\r\n\r\nThe test runs fine if there is no `next` call in `handler2`. The `setTimeout` in `handler1` ensures that the test fails.\r\n\r\nAs I understand it, the last `next` will cause the function `done` to be called in the router:\r\n\r\n```javascript\r\n// lib/router/index.js\r\n\r\n// no more matching layers\r\nif (idx >= stack.length) {\r\n    setImmediate(done, layerError);\r\n    return;\r\n}\r\n```\r\n\r\nThe problem is that `done` is not working correctly in this case. If there are middlewares and no router the `done` function will replace `baseUrl`, `next`, and `params` with the value `undefined`.\r\n\r\n```javascript\r\n// lib/router/index.js\r\n\r\n// restore vals\r\nfor (var i = 0; i < props.length; i++) {\r\n    obj[props[i]] = vals[i];\r\n}\r\n```\r\n\r\nHence the `setTimeout` in the `handler1`. Without a timeout, the `handler1` function mostly finishes successfully before `done` is called in the next iteration of the event loop.\r\n\r\nMy proposal to fix the problem would be to check for `undefined`:\r\n\r\n```javascript\r\n// lib/router/index.js\r\n\r\n// restore vals\r\nfor (var i = 0; i < props.length; i++) {\r\n  if (vals[i] !== undefined) {\r\n    obj[props[i]] = vals[i];\r\n  }\r\n}\r\n```\r\n\r\nBefore creating a pull request I would like to hear if I missed some details or a better solution.\r\n\r\nI think better would if the `done` function would not try to restore anything if there is no router at all. But I could not figure out a good way to do that.",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/4879/comments",
    "author": "floftar",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2022-04-03T16:13:04Z",
        "body": "This is working as designed. When the code path exits the router, all the values are cleared."
      },
      {
        "user": "dougwilson",
        "created_at": "2022-04-06T16:53:25Z",
        "body": "Hi @floftar because inside the `handle` function, those are the only properties that are manipulated, so it is being responsible for restoring those properties back to the values they were when the `req` first entered into that `handle` function."
      }
    ]
  },
  {
    "number": 4808,
    "title": "EADDRINUSE code in express",
    "created_at": "2022-02-04T16:59:02Z",
    "closed_at": "2022-02-04T17:02:22Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/4808",
    "body": "\r\n```js\r\n// using nodejs we can write code to retry to listen on port using\r\nconst server = http.createServer().listen(3000);\r\nserver.on('error',function(err) {\r\n    if (err.code === 'EADDRINUSE') {\r\n        console.log('Address in use, retrying...');\r\n        setTimeout(() => {\r\n            server.close();\r\n            server.listen(3000, 'localhost');\r\n        }, 1000);\r\n    }\r\n});\r\n```\r\nhow to do this same thing in express \r\n```js\r\nconst app = require('express')();\r\napp.on('err',function(err) {\r\nconsole.log('error occured'); // this doesnt work\r\n});\r\n```",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/4808/comments",
    "author": "tarunsinghh",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2022-02-04T17:02:22Z",
        "body": "It would be the same way you do with Node.js, as `app.listen()` returns the node.js server object. You can also provide `app` as the first argument to `http.createServer()`."
      },
      {
        "user": "dougwilson",
        "created_at": "2022-02-04T19:21:58Z",
        "body": "`const server = http.createServer(app)`"
      },
      {
        "user": "tarunsinghh",
        "created_at": "2022-02-04T19:27:38Z",
        "body": "okay, this part\r\n```js\r\napp.listen = function listen() {\r\n  var server = http.createServer(this);\r\n  return server.listen.apply(server, arguments);\r\n};  \r\n```\r\nthis is request handler only and then whole code looks like\r\n```js\r\nconst app = require('express')();\r\nconst server  = http.createServer(app);\r\nserver.listen(3000);\r\nserver.on('error',function(err) {\r\n    if (err.code === 'EADDRINUSE') {\r\n        console.log('Address in use, retrying...');\r\n        setTimeout(() => {\r\n            server.close();\r\n            server.listen(3000, 'localhost');\r\n        }, 1000);\r\n    }\r\n});\r\n```\r\nThanks."
      }
    ]
  },
  {
    "number": 4677,
    "title": "Regex as path not functioning as expected",
    "created_at": "2021-08-15T23:09:39Z",
    "closed_at": "2021-08-15T23:15:08Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/4677",
    "body": "In my express app, I have the following code:\r\n```js\r\napp.all(/\\/port\\/(([1-9]\\d{0,3}|[1-5]\\d{4}|6[0-4]\\d{3}|65[0-4]\\d{2}|655[0-2]\\d|6553[0-5]))\\/.*/g,(req,res,next){\r\n   // ...\r\n})\r\n```\r\nHalf the time, when going to /port/3001 it 404s, the other half of the time it works. It seems like the regex system used by Express is the cause as testing this using \r\n```js\r\n/\\/port\\/(([1-9]\\d{0,3}|[1-5]\\d{4}|6[0-4]\\d{3}|65[0-4]\\d{2}|655[0-2]\\d|6553[0-5]))\\/.*/g.test('/port/3001')\r\n``` \r\nreturns true.",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/4677/comments",
    "author": "williamhorning",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2021-08-15T23:15:08Z",
        "body": "You should not have the global flag on your regexp, as that is how the global flag works. You can see this in plan JavaScript:\r\n```js\r\nvar re = /\\/port\\/(([1-9]\\d{0,3}|[1-5]\\d{4}|6[0-4]\\d{3}|65[0-4]\\d{2}|655[0-2]\\d|6553[0-5]))/g\r\nconsole.log(re.test('/port/3001')) // => true\r\nconsole.log(re.test('/port/3001')) // => false\r\n\r\nvar re = /\\/port\\/(([1-9]\\d{0,3}|[1-5]\\d{4}|6[0-4]\\d{3}|65[0-4]\\d{2}|655[0-2]\\d|6553[0-5]))/ // no global flag\r\nconsole.log(re.test('/port/3001')) // => true\r\nconsole.log(re.test('/port/3001')) // => true\r\n\r\n```\r\n\r\nIf you remove the global flag, then each test will always start from the start of the string, which is what you are expecting. If you didn't want that behavior, you would have the global flag on, but from your report, you are expecting the opposite behavior of the global flag. This is how regular expressions work in javascript, unrelated to Express. I hope that helps."
      }
    ]
  },
  {
    "number": 4655,
    "title": "data is not coming on server",
    "created_at": "2021-07-23T13:25:36Z",
    "closed_at": "2021-07-23T16:20:10Z",
    "labels": [
      "question",
      "module:body-parser"
    ],
    "url": "https://github.com/expressjs/express/issues/4655",
    "body": "i was trying node.js in typescript and code is same as JS but data is not coming on server\r\n\r\n\r\napp.ts file\r\n```\r\nimport express from 'express'\r\nimport bodyParser from 'body-parser'\r\nimport config from '../config/config'\r\nimport logging from '../config/logger'\r\nimport { connectDB } from './utils/DB'\r\n// init express variable to app ==========\r\nconst app = express()\r\n\r\n\r\nconst NAMESPACE = 'server'\r\n\r\n\r\n// body parser ===========================\r\napp.use(express.json())\r\napp.use(express.urlencoded({ extended: false }))\r\n\r\nconnectDB()\r\n\r\n// logger ===================================\r\napp.use((req, res, next) => {\r\n    logging.info(NAMESPACE, `METHOD - [${req.method}], URL - [${req.url}], IP - [${req.socket.remoteAddress}]`)\r\n    res.on('finish', () => {\r\n        logging.info(NAMESPACE, `METHOD - [${req.method}], URL - [${req.url}], IP - [${req.socket.remoteAddress}], STATUS - [${res.statusCode}]`)\r\n    })\r\n    next()\r\n})\r\n\r\n\r\n// routes ======================================\r\nimport loginRoutes from './routes/login'\r\n\r\napp.use('/api/login', loginRoutes)\r\n\r\n\r\n\r\n// error handling ===============================\r\napp.use((req, res, next) => {\r\n    const error = new Error('Page not found');\r\n    return res.json({ message: error.message, statusCode: 404 }).status(404);\r\n})\r\n\r\n\r\n// server start =================================\r\napp.listen(config.server.port, () => {\r\n    console.log(`Server started on port ${config.server.port}`);\r\n})\r\n```\r\n\r\n\r\nroute/login.ts file\r\n```\r\nimport express from 'express'\r\nimport login_contollers from '../controllers/login'\r\nconst loginAPI = express.Router()\r\n\r\nloginAPI.post('/user', login_contollers.login)\r\n\r\n\r\nexport default loginAPI\r\n```\r\n\r\ncontroller/login.ts file\r\n\r\n```\r\nimport jwt from \"jsonwebtoken\";\r\n\r\ndeclare var process: {\r\n    env: {\r\n        JWT_SECRET_KEY: string,\r\n        JWT_EXPIRE_TIME: number\r\n    }\r\n}\r\n\r\n\r\nconsole.log(process.env.JWT_EXPIRE_TIME)\r\n\r\n// creating jsonwebtoken\r\n\r\nconst getToken = async (id: String) => {\r\n    console.log('from getToken', id)\r\n    return jwt.sign({ id }, process.env.JWT_SECRET_KEY, {\r\n        // in what time token expire\r\n        expiresIn: process.env.JWT_EXPIRE_TIME\r\n    })\r\n}\r\n\r\n\r\n// interface req {\r\n//     body: string,\r\n// }\r\n\r\n\r\nconst login = async (req: any, res: any, next: any) => {\r\n    console.log(req.body)\r\n     if (!id) {\r\n         return res.json({message:'please add id'}).status(200)\r\n     } else {\r\n         const token = await getToken(id)\r\n         console.log(token)\r\n         return res.json({ message: 'hello', token })\r\n     }\r\n    next()\r\n}\r\n\r\nconst LOGIN_API = {\r\n    login\r\n}\r\n\r\nexport default LOGIN_API\r\n```\r\n\r\n**in terminal it showing blank array like this {}**\r\n\r\nbut it did't work so i try bodyParser but that is also not working....\r\n\r\n",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/4655/comments",
    "author": "arunsingh28",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2021-07-23T15:05:23Z",
        "body": "Can you put `console.log(req.headers)` right above the output of req.body and paste the output of that here?"
      },
      {
        "user": "arunsingh28",
        "created_at": "2021-07-23T16:17:17Z",
        "body": "its showing the headers \r\n\r\n```\r\n[2021-07-23T16:15:59.835Z] [INFO] [server] METHOD - [POST], URL - [/api/login/user], IP - [::1]\r\n{\r\n  'content-type': 'text/plain',\r\n  'user-agent': 'PostmanRuntime/7.28.2',\r\n  accept: '*/*',\r\n  'postman-token': '744012c2-31fb-485b-9927-0e986da8d27e',\r\n  host: 'localhost:8080',\r\n  'accept-encoding': 'gzip, deflate, br',\r\n  connection: 'keep-alive',\r\n  'content-length': '28'\r\n}\r\n```"
      },
      {
        "user": "dougwilson",
        "created_at": "2021-07-23T16:20:10Z",
        "body": "So the issue is unrelated to your typescript usage. You used two different body prasers, neither of which parse `text/plain` bodies. For that, you want to use the text paraer (`express.text()`)."
      }
    ]
  },
  {
    "number": 4569,
    "title": "Answering before routes are registered",
    "created_at": "2021-04-19T17:43:54Z",
    "closed_at": "2021-04-19T17:59:18Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/4569",
    "body": "**My environment:**\r\n-Node app with Express\r\n-Nginx with nginx-mod-passenger (Phusion Passenger open source)\r\n-Ubuntu 18.04 on an virtual private server\r\n\r\n**My problem is:**\r\nPhusion Passenger seems to have a sleep mode that pauses the Node.JS app after a bit time without requests. When I now make a request and the app is woken up, express immediatly returns 404. To access the routes I have set, I must make a second request as soon as the routes are loaded.\r\n\r\n**My proposal:**\r\nAs long as not all routes are loaded, express should wait instead of responding.  ",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/4569/comments",
    "author": "MatsG23",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2021-04-19T17:45:35Z",
        "body": "Hi @MatsG23 can you show an example? Express.js cannot answer requests until you call `app.listen`. Are you invoking that method too early in your code?"
      },
      {
        "user": "dougwilson",
        "created_at": "2021-04-19T17:52:07Z",
        "body": "That is still fine, as that is essentially what `app.listen` does. So by the time you make your `server.listen` call there, have you finished registering your routes? If not, you probably want to add some kind of mechanism that is aware of when your code completes the route registration and then call `server.listen` at that point."
      },
      {
        "user": "MatsG23",
        "created_at": "2021-04-19T17:57:28Z",
        "body": "Oh in my router I'm postponing direct registration by wrapping the router.post/router.get/... in an async parenthesis. I think this is the error!"
      },
      {
        "user": "dougwilson",
        "created_at": "2021-04-19T17:59:18Z",
        "body": "No problem @MatsG23 ! Express.js does not know when you are finished adding routes, of course. The only way it would know is just whenever you call the `.listen` to start the server. If you start it before you finish, you'll get the behavior."
      }
    ]
  },
  {
    "number": 4529,
    "title": "Router only response first route if using dependency injection on router",
    "created_at": "2021-02-18T07:23:22Z",
    "closed_at": "2021-02-18T07:36:57Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/4529",
    "body": "This is related to #4528 \r\n\r\nFull codes are as per following:\r\n\r\n<details>\r\n<summary>/index.js</summary>\r\n\r\n```js\r\nconst express = require('express');\r\nconst app = express();\r\n\r\napp.use('/buy',require('./routes/buy'))\r\napp.use('/sell',require('./routes/sell'))\r\n\r\napp.listen(5000,()=>{\r\n  console.log('Server start')\r\n})\r\n```\r\n</details>\r\n\r\n<details>\r\n<summary>/routes/buy.js</summary>\r\n\r\n```js\r\nconst express = require('express')\r\nconst router = express.Router()\r\nconst buyController = require('../controller/buy.js')\r\n\r\nrouter.use('/:id/log', require('./log')(router, 'BuyModel'))\r\nrouter.route('/').get(buyController.fetchBuys)\r\n\r\nmodule.exports = router\r\n```\r\n</details>\r\n\r\n<details>\r\n<summary>/routes/sell.js</summary>\r\n\r\n```js\r\nconst express = require('express')\r\nconst router = express.Router()\r\n\r\nrouter.use('/:id/log', require('./log')(router, 'SaleModel'))\r\n\r\nmodule.exports = router\r\n```\r\n</details>\r\n\r\n<details>\r\n<summary>/routes/log.js</summary>\r\n\r\n```js\r\nconst logController = require('../controller/log')\r\n\r\nmodule.exports = function(router, model){\r\n  router.route('/')\r\n    .get(logController.fetchLogs(model))\r\n  return router\r\n}\r\n```\r\n</details>\r\n\r\n<details>\r\n<summary>/controller/log.js</summary>\r\n\r\n```js\r\nexports.fetchLogs = model => (req, res, next) => {\r\n  console.log('fetch logs');\r\n  console.log('base_url:', req.baseUrl);\r\n  console.log('...');\r\n\r\n  return res.status(200).send('done')\r\n}\r\n```\r\n</details>\r\n\r\n<details>\r\n<summary>/controller/buy.js</summary>\r\n\r\n```js\r\nexports.fetchBuys = (req, res, next) => {\r\n  console.log('base_url:', req.baseUrl);\r\n  console.log('result: fetch buys');\r\n  console.log('...')\r\n  res.status(200).send()\r\n}\r\n\r\n```\r\n</details>\r\n\r\n---\r\n\r\nCurrent code consoles:\r\n\r\n**GET: /buy**\r\nfetch logs\r\nbase_url: /buy\r\n\r\n**GET: /buy/123/log**\r\nfetch logs\r\nbase_url: /buy/123/log\r\n\r\n---\r\n\r\nWhat I hope is:\r\n\r\n**GET: /buy**\r\nfetch buys\r\nbase_url: /buy\r\n\r\n**GET: /buy/123/log**\r\nfetch logs\r\nbase_url: /buy/123/log\r\n\r\n---\r\n\r\nIf I reverse the route sequence in /routes/buy.js like following\r\n\r\n```js\r\nrouter.route('/').get(buyController.fetchBuys)\r\nrouter.use('/:id/log', require('./log')(router, 'BuyModel'))\r\n```\r\n\r\n**GET: /buy**\r\nfetch buys\r\nbase_url: /buy\r\n\r\n**GET: /buy/123/log**\r\nfetch buys\r\nbase_url: /buy/123/log\r\n\r\n---\r\n\r\nWould like to know how can I make it work if I still want to use dependency injection in router",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/4529/comments",
    "author": "orzinc",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2021-02-18T07:36:57Z",
        "body": "The issue is that in your `/routes/log.js` file, it has a function that accepts a `router` and attaches the fetchLogs to the GET / route on that router. Of course, you are passing the router that belongs to the buys route in `/routes/buy.js`, so the GET / ends up pointing there. The reason it changes when you arrange lines is because you changed which of the two GET / you have on the same router.\r\n\r\nThere are two ways to fix this:\r\n\r\n1. Change line 5 in `/routes/buy.js` to `router.use('/:id/log', require('./log')(express.Router(), 'BuyModel'))`\r\n2. Change line 5 in `/routes/buy.js` to `router.use(require('./log')(router, 'BuyModel'))` and then change line 4 in `/routes/log.js` to `router.route('/:id/log')` (and of course change line 4 in `/routes/sell.js` to the `app.use` as well.\r\n\r\nI hope this helps!"
      }
    ]
  },
  {
    "number": 4525,
    "title": "Expressjs dealing with high traffic",
    "created_at": "2021-02-08T13:12:00Z",
    "closed_at": "2021-02-09T22:56:55Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/4525",
    "body": "So I want to know how do I wait for response to be sent to the user ?\r\n\r\nlets say my code has some sort of external requests that takes few seconds to response so using async functions the code waits for the response of that request then process it and sends the result back to the user, but it works only for 1 user meaning that if i request like 100 requests per time I will be getting a response but with conflicts of the entered data\r\nlike the request number 62 had the response of the request number 33 and so.\r\nhow do I mange this ? are there any libraries or methods to overcome it or it's just some sort of errors in my code ? ",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/4525/comments",
    "author": "moezemara",
    "comments": [
      {
        "user": "rodion-arr",
        "created_at": "2021-02-08T20:49:56Z",
        "body": "Hi @moezemara! Requests are saving theirs contexts during async operations, so you shouldn\u2019t face such kind of issues. If you\u2019ll be able to provide some reproducible example - it will be interesting to check "
      },
      {
        "user": "moezemara",
        "created_at": "2021-02-09T07:35:51Z",
        "body": "> Hi @moezemara! Requests are saving theirs contexts during async operations, so you shouldn\u2019t face such kind of issues. If you\u2019ll be able to provide some reproducible example - it will be interesting to check\r\n\r\nthis is the request of the outer website\r\n```js\r\nconst fetch = require(\"node-fetch\");\r\nconst config = require(\"../../../config/configs\")\r\n\r\nasync function getquestion(questionid){\r\n\tvar url =  config.url\r\n  const options = {\r\n    headers: {\r\n    'Authorization': config.Authorization,\r\n    'Accept': config.Accept,\r\n    }\r\n  };\r\n\r\n\ttry {\r\n    const response = await fetch(url, options);\r\n      json = await response.json();\r\n      return await json\r\n  }catch(error){\r\n      console.log(error);\r\n  }\r\n}\r\n\r\nmodule.exports = {\r\n\tgetquestion\r\n}\r\n```\r\n```js\r\nasync function asyncer(id){\r\n    question = await getquestion(id);\r\n    question = await question.result.content.content\r\n    return [question, answer]\r\n}\r\n```\r\nThen the user gets response using this\r\n```js\r\nqa = await asyncer(id)\r\nif (qa){\r\n return await res.status(200).json({\r\n      success: 1,\r\n      question: qa[0],\r\n      answer: qa[1]\r\n })\r\n}\r\n```\r\n"
      },
      {
        "user": "rodion-arr",
        "created_at": "2021-02-09T16:25:25Z",
        "body": "I assume your issue raised due  to not all variables declared in lexical scope. It is not an issue with `express` nor Node.js - it is a nature of pure JS: you need to use `var/let/const` for variables - otherwise global variables will be created implicitly.\r\n\r\nPlease try following updated code with proper variables declaration:\r\n```javascript\r\nconst fetch = require(\"node-fetch\");\r\nconst config = require(\"../../../config/configs\")\r\n\r\nasync function getquestion (questionid) {\r\n  const url = config.url\r\n  const options = {\r\n    headers: {\r\n      'Authorization': config.Authorization,\r\n      'Accept': config.Accept,\r\n    }\r\n  };\r\n\r\n  try {\r\n    const response = await fetch(url, options);\r\n    const json = await response.json();\r\n    return json;\r\n  } catch (error) {\r\n    console.log(error);\r\n  }\r\n}\r\n\r\nmodule.exports = {\r\n  getquestion\r\n}\r\n```\r\n\r\n```javascript\r\nasync function asyncer(id){\r\n  const response = await getquestion(id);\r\n  const question = response.result.content.content\r\n  const answer = null; // answer should be defined in case it not global variable\r\n  return [question, answer]\r\n}\r\n```\r\n\r\n```javascript\r\nconst qa = await asyncer(id)\r\nif (qa) {\r\n return await res.status(200).json({\r\n      success: 1,\r\n      question: qa[0],\r\n      answer: qa[1]\r\n })\r\n}\r\n```"
      }
    ]
  },
  {
    "number": 4357,
    "title": "localhost cannot read property 'name' of undefined nodejs",
    "created_at": "2020-07-23T08:04:09Z",
    "closed_at": "2020-07-23T10:16:16Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/4357",
    "body": "`TypeError: Cannot read property 'fName' of undefined\r\n    at C:\\Users\\Aishwarya Gupta\\Desktop\\WebDevProject\\Newsletter-Signup\\app.js:20:28\r\n    at Layer.handle [as handle_request] (C:\\Users\\Aishwarya Gupta\\Desktop\\WebDevProject\\node_modules\\express\\lib\\router\\layer.js:95:5)\r\n    at next (C:\\Users\\Aishwarya Gupta\\Desktop\\WebDevProject\\node_modules\\express\\lib\\router\\route.js:137:13)\r\n    at Route.dispatch (C:\\Users\\Aishwarya Gupta\\Desktop\\WebDevProject\\node_modules\\express\\lib\\router\\route.js:112:3)\r\n    at Layer.handle [as handle_request] (C:\\Users\\Aishwarya Gupta\\Desktop\\WebDevProject\\node_modules\\express\\lib\\router\\layer.js:95:5)\r\n    at C:\\Users\\Aishwarya Gupta\\Desktop\\WebDevProject\\node_modules\\express\\lib\\router\\index.js:281:22\r\n    at Function.process_params (C:\\Users\\Aishwarya Gupta\\Desktop\\WebDevProject\\node_modules\\express\\lib\\router\\index.js:335:12)\r\n    at next (C:\\Users\\Aishwarya Gupta\\Desktop\\WebDevProject\\node_modules\\express\\lib\\router\\index.js:275:10)\r\n    at C:\\Users\\Aishwarya Gupta\\Desktop\\WebDevProject\\node_modules\\body-parser\\lib\\read.js:130:5\r\n    at invokeCallback (C:\\Users\\Aishwarya Gupta\\Desktop\\WebDevProject\\node_modules\\raw-body\\index.js:224:16)`\r\n\r\nHere's my code in app.js\r\n`const express = require('express');\r\nconst bodyParser = require('body-parser');\r\nconst request = require('request');\r\nconst app = express();\r\napp.use(express.static('public'));\r\napp.use(bodyParser.urlencoded({ extended: true }));`\r\n\r\nPost request code:\r\n`app.post('/', function (req, res) {\r\n  var firstName = res.body.fName;\r\n  var lastName = res.body.lName;\r\n  var emailID = res.body.fEmail;\r\n  console.log(firstName, lastName, emailID);\r\n});`",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/4357/comments",
    "author": "aishwarya07g",
    "comments": [
      {
        "user": "rodion-arr",
        "created_at": "2020-07-23T08:31:09Z",
        "body": "Hi, `body` is property of request `req`. You are using `res` instead."
      }
    ]
  },
  {
    "number": 4344,
    "title": "How to set error.name in extended class Error in Node.js?",
    "created_at": "2020-07-11T00:14:42Z",
    "closed_at": "2020-07-14T01:13:26Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/4344",
    "body": "I'm trying to set the error name `err.name = 'ExpressValidatorError';` \r\n\r\nof an custom Error class `class AppError extends Error` \r\n\r\nthat is passed to centralErrorHandler to filter and handle errors by `err.name`.\r\n\r\nI have did a lot of research but still couldn't figure out why `err.name` in centralErrorHandler console logs as `undefined`.\r\n\r\nWhen I change `return next(err);` in auth.controller.js to `throw err;`, the `err.name` does console log as `'ExpressValidatorError'` but i'm not sure if using throw is correct.\r\n\r\n\r\n\r\ncentralErrorHandler.js\r\n```\r\nmodule.exports = (err, req, res, next) => {           \r\n        console.log(err.name);\r\n        if(err.name === 'ExpressValidatorError') err = handleExpressValidatorError(err);            \r\n}\r\n\r\n```\r\n\r\nauth.controller.js\r\n```\r\nconst {validationResult} = require('express-validator');\r\n\r\nexports.signup = (req, res) => {     \r\n    const errors = validationResult(req); \r\n   \r\n      if (!errors.isEmpty()) {\r\n        let err = new AppError(`Invalid login credentials.`, 422);\r\n        err.name = 'ExpressValidatorError';            \r\n             \r\n        return next(err);\r\n      }\r\n\r\n    res.status(200).send(req.user);          \r\n}\r\n```\r\n\r\nappError.js\r\n```\r\nclass AppError extends Error {\r\n    constructor(message, statusCode){\r\n        super(message);\r\n\r\n        this.statusCode = statusCode;\r\n        this.status = `${statusCode}`.startsWith('4') ? 'fail' : 'error';        \r\n        this.isOperational = true;        \r\n\r\n        Error.captureStackTrace(this, this.constructor);\r\n    }\r\n}\r\n\r\nmodule.exports = AppError;\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/4344/comments",
    "author": "KaizenTamashi",
    "comments": [
      {
        "user": "mastermatt",
        "created_at": "2020-07-11T04:12:59Z",
        "body": "In your signup controller you're calling `return next(err);`, however, you haven't included `next` as a param for the handler.\r\nWhen I run your code, the error I get is `ReferenceError: \"next is not defined\"`. And updating the handler signature to `exports.signup = (req, res, next) => { ...` logs as you expect in `centralErrorHandler`. "
      },
      {
        "user": "f0rnasier",
        "created_at": "2022-01-26T17:28:45Z",
        "body": "I am trying to implement almost the same code but I am getting the error \"Invalid status code: error\""
      }
    ]
  },
  {
    "number": 4333,
    "title": "Router doens't match with an route",
    "created_at": "2020-06-30T13:20:31Z",
    "closed_at": "2020-07-02T02:32:54Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/4333",
    "body": "So, I have a following index.js file, where I define the default route and another endpoint that points to a router.\r\n\r\nTherefore, **when I try to access the endpoint /endpoint/something points to the default route, that is '/'.** I don't know what could happen.\r\n\r\nActivating the debug options shows that the new layer, in that case, endpoint was created, but I cannot figure out how to access it.\r\n\r\nSomeone could help? Thanks in advance.\r\n\r\n```js\r\nimport express from 'express';\r\nimport bodyParser from 'body-parser';\r\nimport dotenv from 'dotenv';\r\nimport endpointRouter from './src/endpoint/endpoint.router';\r\n\r\ndotenv.config();\r\n\r\nconst app = express();\r\napp.use(bodyParser.json());\r\napp.use(bodyParser.urlencoded({ extended: true }));\r\n\r\n// routes\r\napp.use('/', (req, res) => res.status(200).send({message: 'Welcome'}));\r\napp.use('/endpoint', endpointRouter);\r\n\r\napp.listen(process.env.PORT, process.env.IPCONFIG, () => console.log(`Process listening on ${process.env.PORT}`));\r\n\r\nexport default app;\r\n```",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/4333/comments",
    "author": "lukaswilkeer",
    "comments": [
      {
        "user": "losanni",
        "created_at": "2020-06-30T16:13:39Z",
        "body": "Try this. \r\n\r\n```\r\nconst express = require('express');\r\nconst bodyParser = require('body-parser');\r\nconst dotenv = require('dotenv');\r\nconst endpointRouter = require('./src/endpoint/endpoint.router');\r\n\r\ndotenv.config();\r\n\r\nconst app = express();\r\napp.use(bodyParser.json());\r\napp.use(bodyParser.urlencoded({ extended: true }));\r\n\r\n// routes\r\napp.get('/', (req, res) => res.status(200).send({message: 'Welcome'}));\r\napp.use('/endpoint', endpointRouter);\r\n\r\napp.listen(process.env.PORT, () => console.log(`Process listening on ${process.env.PORT}`));\r\n\r\n```"
      }
    ]
  },
  {
    "number": 4279,
    "title": "Wrong render path",
    "created_at": "2020-05-15T23:18:45Z",
    "closed_at": "2020-05-17T02:52:44Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/4279",
    "body": "Hi, I am taking post id parameter to show blog content, everything is fine on here but there is a problem, it is on code or express rendering I don't know exactly.\r\nExpress trying to send my js/css/img files in 'public/post/', but I want to it send from only 'public' path.\r\n\r\nI tried these;\r\n- I tried to change 'path.join'(express.static) but it is also didn't work.\r\n-> `path.join(__dirname + '../', 'public')` or etc...\r\n- I tried to specify path to router but it didn't.\r\n-> (In app.js) app.use('/', mainRouter, here express.path)\r\n- I searched on google, express docs but I couldn't find any solution to this.\r\n\r\n**Routers:**\r\nOnly one router: _main.js_\r\n\r\n**Public Folder:**  classic express generator\r\n\r\n**Codes:**\r\n```\r\n// Show Post By ID\r\n// 5ebabf454b74f711141a5aa4 -> Test Database ID, It exists.\r\nrouter.get('/post/:postid', (req, res, next) => {\r\n    Post.findById(req.params.postid).then((doc) => {\r\n        res.render('post', { title: devblog.name, post: doc });\r\n    }).catch((err) => {\r\n        next(createError(404, err));\r\n    });\r\n});\r\n```\r\n**Console:**\r\n```\r\nGET /post/5ebabf454b74f711141a5aa4 304 3191.975 ms - -\r\nGET /post/stylesheets/bootstrap.min.css 404 500.526 ms - 2295\r\nGET /post/stylesheets/style.css 404 562.285 ms - 2295\r\nGET /post/javascripts/jquery-3.4.1.slim.min.js 404 1438.587 ms - 2295\r\nGET /post/javascripts/bootstrap.bundle.min.js 404 2100.498 ms - 2295\r\n```\r\nHere is the problem: \r\n> /post/stylesheets/\r\n\r\nHow i can change this to normal? **What should I do?**\r\n> /post/stylesheets/ => /stylesheets/\r\n\r\nSorry for syntax, bad English sentences, If there are many flaws, please forgive me.",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/4279/comments",
    "author": "ipatavatsizz",
    "comments": [
      {
        "user": "jonchurch",
        "created_at": "2020-05-16T19:49:01Z",
        "body": "This is probably an issue with how you're linking to these files from your template.\r\n\r\nUsually it's forgetting to add a forward slash `/` to the resource's path:\r\n\r\nIf the URL of your page is `/post/1234` and you use a stylesheet link like the following:\r\n\r\n```html\r\n<link rel=\"stylesheet\" type=\"text/css\" href=\"css/mystyle.css\">\r\n```\r\nIt will try to load `/post/1234/css/mystle.css`\r\n\r\nBut if you use a forward slash in the html tag, it will try to load from the root of the website:\r\n\r\n```html\r\n<link rel=\"stylesheet\" type=\"text/css\" href=\"/css/mystyle.css\">\r\n```\r\n\r\nFrom the same page, that tag will try to load `/css/mystle.css`"
      }
    ]
  },
  {
    "number": 4252,
    "title": "Cookie's don't clear if maxAge is set",
    "created_at": "2020-04-24T20:14:01Z",
    "closed_at": "2020-04-24T20:23:28Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/4252",
    "body": "If a cookie with a `maxAge` is set, performing `res.clearCookie()` will not clear the cookie.\r\n\r\nWe update the expiry in `clearCookie()` so the `expires` property is overriden to a past date:\r\n```javascript\r\nres.clearCookie = function clearCookie(name, options) {\r\n  var opts = merge({ expires: new Date(1), path: '/' }, options);\r\n\r\n  return this.cookie(name, '', opts);\r\n};\r\n```\r\n\r\nBut then when `this.cookie()` is called, it sees the cookie has a `maxAge` property, which will override the expiry date in this code:\r\n\r\n```javascript\r\n  if ('maxAge' in opts) {\r\n    opts.expires = new Date(Date.now() + opts.maxAge);\r\n    opts.maxAge /= 1000;\r\n  }\r\n```\r\n\r\nand the cookie therefore wouldn't be cleared *(In fact, it would actually cause the cookie's expiry date to be further into the future)*.",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/4252/comments",
    "author": "harryjamesuk",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2020-04-24T20:18:43Z",
        "body": "Hm, I'm not sure I'm understanding what you're saying. Can you provide an example reproduction? I just tried it out in Chrome and `res.clearCookie` cleared it just fine, but perhaps I am misunderstanding the report. An example app that demonstrates the issue would help a lot so we know what is being called with what values."
      },
      {
        "user": "harryjamesuk",
        "created_at": "2020-04-24T20:21:05Z",
        "body": "> Hm, I'm not sure I'm understanding what you're saying. Can you provide an example reproduction? I just tried it out in Chrome and `res.clearCookie` cleared it just fine, but perhaps I am misunderstanding the report. An example app that demonstrates the issue would help a lot so we know what is being called with what values.\r\n\r\nAn example would be\r\n```javascript\r\nres.cookie(\"example\", \"value\", {maxAge: 600000});\r\nres.clearCookie(\"example\", {maxAge: 600000});\r\n```\r\n\r\nIn this case, the cookie `example` would not be cleared.\r\n"
      },
      {
        "user": "dougwilson",
        "created_at": "2020-04-24T20:22:02Z",
        "body": "Ah.. So that is currently intentional, and would be a breaking change to fix. There is another thread this was discussed in, as folks are currently abusing this \"feature\" to clear the value of the cookie (vs just delete the cookie)."
      },
      {
        "user": "dougwilson",
        "created_at": "2020-04-24T20:23:28Z",
        "body": "Basically the `res.clearCookie` API will delete the cookie _unless_ you provide a `maxAge` or an `expires`, in which case it only clears the _value_ of the cookie. This is as designed currently."
      },
      {
        "user": "dougwilson",
        "created_at": "2020-04-24T20:33:22Z",
        "body": "> but providing expires will also expire the cookie to Thu, 01 Jan 1970 00:00:00 GMT rather than the user supplied expires\r\n\r\nHm, that is strange. I tried that out and that is not the behavior I'm seeing. But, perhaps I'm not understanding what you mean. Can you provide code that reproduces that issue? A user-supplied `expires` to `res.clearCookie` should be what is used in the final `Set-Cookie` header (unless `maxAge` is also provided, in which case `maxAge` takes precedence)."
      }
    ]
  },
  {
    "number": 4094,
    "title": "[Feature]dynamic set and delete route",
    "created_at": "2019-11-03T14:36:24Z",
    "closed_at": "2019-11-05T23:16:25Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/4094",
    "body": "When running a application, I set some routes like this:\r\n```js\r\n[some arrays].forEach(route => {\r\n   app.post(route.path, (req, res) => {\r\n       //...\r\n   })\r\n})\r\n```\r\nwhen I change a route's path in that array, new route is available, \r\n**but old route is available too.**\r\n\r\nhow to let the old routes invalidate.\r\n",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/4094/comments",
    "author": "kybetter",
    "comments": [
      {
        "user": "wesleytodd",
        "created_at": "2019-11-05T23:16:25Z",
        "body": "Hi @kybetter, a better approach to this would be to create a new router which you mount like this:\r\n\r\n```javascript\r\nlet router\r\nfunction updateRoutes () {\r\n  router = new express.Router()\r\n  [some arrays].forEach(route => {\r\n     router.post(route.path, (req, res) => {\r\n         //...\r\n     })\r\n  })\r\n}\r\n\r\nsetTimeout(updateRoutes, ...)\r\n\r\napp.use((req, res, next) => {\r\n  router.handle(req, res, next)\r\n})\r\n```\r\n\r\nMake sense?"
      },
      {
        "user": "wmasfoe",
        "created_at": "2022-01-07T03:02:30Z",
        "body": "hello @wesleytodd \r\nI also encountered the same problem. I have a variable `routerName`. I want to change it in the code, and the name of the route will be updated dynamically.\r\nMy code is like this:\r\n\r\n```js\r\nlet routerNames = ['/test']\r\nlet realRouter\r\n\r\nfunction updateRouter () {\r\n  realRouter = new express.Router()\r\n  routerNames.forEach(routerName => {\r\n    realRouter.all(routerName, (req, res) => {\r\n      res.send('routerName === ' + routerNames)\r\n    })\r\n  })\r\n}\r\n\r\nsetTimeout(updateRouter, 300)\r\n\r\napp.use((req, res, next) => {\r\n  realRouter.handle(req, res, next)\r\n})\r\n\r\napp.all('/changeName', (req, res) => {\r\n  routerNames[0] += 's' // change routerName\r\n  res.send('new name === ' + routerNames)\r\n})\r\n```\r\n\r\nWhen I try to access `/changeName` to change the value of routername, the variable changes, the route does not change, and `/test` takes effect `/tests` does not take effect.\r\n\r\nHelp me \ud83d\ude2d\ud83d\ude2d\ud83d\ude2d"
      }
    ]
  },
  {
    "number": 3998,
    "title": "OPTIONS request doesn't follow the order of route declaration",
    "created_at": "2019-07-02T06:15:04Z",
    "closed_at": "2019-07-02T06:20:00Z",
    "labels": [
      "question",
      "module:router"
    ],
    "url": "https://github.com/expressjs/express/issues/3998",
    "body": "I just notice that an OPTIONS request doesn't follow the order of route declaration and applies for all the routes that are defined using the same instance. \r\nI am not sure if it's bug or an intended behaviour since I don't fully understand the nature of OPTIONS request.\r\n\r\nHere are 2 code snippets\r\n\r\n```js\r\nconst app = require('express')();\r\n\r\napp.use((req, res, next) => {\r\n  res.send('Blocked');\r\n});\r\n\r\napp.get('/route1', (req, res) => {\r\n  res.send('route1');\r\n});\r\n\r\napp.get('/route2', (req, res) => {\r\n  res.send('route2')\r\n});\r\n\r\napp.listen(3000, () => {\r\n  console.log('Server started on port: 3000');\r\n});\r\n```\r\n\r\n```js\r\nconst app = require('express')();\r\n\r\napp.get('/route1', (req, res) => {\r\n  res.send('route1');\r\n});\r\n\r\napp.use((req, res, next) => {\r\n  res.send('Blocked');\r\n});\r\n\r\napp.get('/route2', (req, res) => {\r\n  res.send('route2')\r\n});\r\n\r\napp.listen(3000, () => {\r\n  console.log('Server started on port: 3000');\r\n});\r\n```\r\n\r\nIn first case, both GET and OPTIONS request to any of the 2 routes returns the message \"blocked\" as expected since the middleware is defined prior to both and hence any request to either of these will first pass through it.\r\n\r\nIn second case, both GET and OPTIONS request to the second route return the message \"blocked\". Again as expected.  But for the first route, the GET request return the message \"route1\" while the OPTIONS request returns the message \"Blocked\". \r\n\r\nWhy did the GET request was successfully served but the OPTIONS request first passed through the middleware that was defined after that route?\r\n\r\nI'm using v4.17.1",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/3998/comments",
    "author": "abhishekjain2604",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2019-07-02T06:20:00Z",
        "body": "The reason is that the default OPTIONS handling only comes into play if the request reached the end of your declarations and never encountered anything that handled it. Since in your second example the .use handled the OPTIONS request (by not calling next()) the default handling was never invoked.\r\n\r\nYou can think of it in that the OPTIONS auto response is not an aspect of your app.get (i.e. it does not respond at the moment of the app.get declaration for the named route) and is instead an alternative of the 404 response (i.e. only runs if no other route handled the OPTIONS request).\r\n\r\nI hope that helps explain the behavior."
      }
    ]
  },
  {
    "number": 3980,
    "title": "Client Cannot GET /xxx.html before accessing main ",
    "created_at": "2019-06-11T02:37:33Z",
    "closed_at": "2019-06-11T11:29:30Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/3980",
    "body": "I have the following server side code:\r\n\r\n```\r\nvar app = express();\r\napp.get('/', function (req, res) {\r\n\tres.redirect('/main');\r\n});\r\napp.get('/main', function (req, res) {\r\n\tvar d = new Date();\r\n\tres.sendFile(path.join(__dirname + '/main.html'));\r\n\tInfo(req.ip + ' - Session to main.html built successfully! ');\r\n\tapp.use(express.static(__dirname));\r\n});\r\n```\r\n\r\nAlso there are some other html files in the same directory, e.g. xxx.html.  \r\nI found the following behavior that confuses, if I build a new session, try to access localhost:7778/xxx.html, the client cannot get: Cannot GET /xxx.html:\r\n\r\n```\r\nFailed to load resource: the server responded with a status of 404 (Not Found)\r\n```\r\n\r\nOn the other hand, after accessed localhost:7778/, and then try to access localhost:7778/xxx.html, will succeed.\r\n\r\nCan anyone explain the behavior? Can I set the localhost/xxx.html be able to directly accessed?\r\n\r\nThanks a lot!",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/3980/comments",
    "author": "ctlkkc",
    "comments": [
      {
        "user": "r0mflip",
        "created_at": "2019-06-11T03:24:40Z",
        "body": "Your `app.use(express.static(__dirname));` shouldn't be in the route handler."
      }
    ]
  },
  {
    "number": 3962,
    "title": "trust-proxy function not called?",
    "created_at": "2019-05-17T09:36:34Z",
    "closed_at": "2019-05-17T19:52:03Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/3962",
    "body": "My Express server is running in a docker container with an nginx docker container proxying request to it.\r\n\r\n```\r\nRequest -> (nginx) -> (express)\r\n```\r\n\r\nI've been trying to set up Express so it only trusts the one nginx proxy, but so far I've not been able to get the `trust-proxy` setting to work.\r\nThe function I pass to the `trust-proxy` setting seems to never get called in my application.\r\n\r\n```ts\r\napp.set('trust proxy', (ip: string) => {\r\n    console.error(`PROXY ADDR: ${ip}`);\r\n    return false;\r\n});\r\n```\r\nWith this configuration, the `console.error` never appears in the logs.\r\n\r\nAm I doing something wrong here with my configuration, or is `trust proxy` not working as intended?\r\n\r\nMinimal reproduction:\r\n```ts\r\nconst app = express();\r\n\r\napp.set('trust proxy', (ip: string) => {\r\n    console.error(`PROXY ADDR: ${ip}`);\r\n    return false;\r\n});\r\n\r\napp.use('*', (_req: express.Request, res: express.Response) => {\r\n    return res.send('Hi');\r\n});\r\n\r\nconst webServer = createServer(app);\r\nwebServer.listen(3731);\r\n```",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/3962/comments",
    "author": "Ionaru",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2019-05-17T13:59:41Z",
        "body": "Hi @Ionaru . The trust proxy function is called when trust of addresses needs to be established. In your example, there is no code that needs to know anything about the upstream, so for optimization reasons, it will not get invoked.\r\n\r\nIf you add something like `req.ip`, `req.hostname` etc to your example, your function should then get called, as Express tries to determine the address."
      }
    ]
  },
  {
    "number": 3957,
    "title": "Routing Issue",
    "created_at": "2019-05-15T02:18:52Z",
    "closed_at": "2019-05-15T02:27:59Z",
    "labels": [
      "question",
      "module:router"
    ],
    "url": "https://github.com/expressjs/express/issues/3957",
    "body": "Hello,\r\n\r\nI've been using the Router function for a bit now and have an endpoint that does two different functions, one gets the current user /users/me and one gets a user that is searched /users/:id, sadly these endpoints conflict for some reason, can someone please help me in finding a solution? These endpoints are BOTH in the same file.",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/3957/comments",
    "author": "ghost",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2019-05-15T02:21:22Z",
        "body": "There are two main solutions:\r\n\r\n1. Since the router matches in the strict order in which they are declared, just declare the more specific route first (the `/users/me` router).\r\n2. If the `:id` parameter is only certain characters, like just digits, you can restrict that route to only those characters like `/users/:id([0-9]+)`"
      },
      {
        "user": "ghost",
        "created_at": "2019-05-15T02:22:40Z",
        "body": "@dougwilson call me blind but is there a way in express to route it (2nd way) with just numbers?"
      },
      {
        "user": "dougwilson",
        "created_at": "2019-05-15T02:24:29Z",
        "body": "I'm sorry, I'm not sure I understand your question. What do you mean by to route it with just numbers?"
      },
      {
        "user": "ghost",
        "created_at": "2019-05-15T02:25:34Z",
        "body": "Sorry, I didn't write that quite correctly, this /users/:id is only numbers, does express offer a way to lockdown the endpoint to only numbers?"
      },
      {
        "user": "dougwilson",
        "created_at": "2019-05-15T02:27:05Z",
        "body": "If I'm understanding correctly: `/users/:id([0-9]+)`"
      }
    ]
  },
  {
    "number": 3890,
    "title": "How to render mySQL Data using Express and EJS",
    "created_at": "2019-02-22T20:16:32Z",
    "closed_at": "2019-02-23T01:10:49Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/3890",
    "body": "Hi I can't figure out how to display my mySQL data on an HTML page. Right now I am using Express, mySQL, and EJS as my template engine. My project is to create a Jeopardy web application. I have my mySQL database called Jeopardy set up with themes, categories, and questions tables. I want to use Express (Node.js) to read in all the data. Then I want to send that data to the ejs file to render HTML. I want to display all my table data on the html page. Can someone help me?\r\n\r\nHere is my current error. When I go to localhost:3000 this same error pops up in the webpage and the console. I don't know why this is happening. I used res.render() to define obj as a variable for the ejs file to use but it's not recognizing it. Is there anything else you guys think I should fix? I am using all these languages/frameworks for the first time so I've very inexperienced.\r\n```\r\nReferenceError: /Users/Ruthvik/Downloads/Jeopardy/views/index.ejs:7\r\n    5|   </head>\r\n    6|   <body>\r\n >> 7|     <h1><%= obj %></h1>\r\n    8|     <p>Welcome to <%= obj %></p>\r\n    9|   </body>\r\n    10| </html>\r\n\r\nobj is not defined\r\n    at eval (eval at compile (/Users/Ruthvik/Downloads/Jeopardy/node_modules/ejs/lib/ejs.js:592:12), <anonymous>:11:26)\r\n    at returnedFn (/Users/Ruthvik/Downloads/Jeopardy/node_modules/ejs/lib/ejs.js:623:17)\r\n    at tryHandleCache (/Users/Ruthvik/Downloads/Jeopardy/node_modules/ejs/lib/ejs.js:251:36)\r\n    at View.exports.renderFile [as engine] (/Users/Ruthvik/Downloads/Jeopardy/node_modules/ejs/lib/ejs.js:480:10)\r\n    at View.render (/Users/Ruthvik/Downloads/Jeopardy/node_modules/express/lib/view.js:135:8)\r\n    at tryRender (/Users/Ruthvik/Downloads/Jeopardy/node_modules/express/lib/application.js:640:10)\r\n    at Function.render (/Users/Ruthvik/Downloads/Jeopardy/node_modules/express/lib/application.js:592:3)\r\n    at ServerResponse.render (/Users/Ruthvik/Downloads/Jeopardy/node_modules/express/lib/response.js:1008:7)\r\n    at Query.<anonymous> (/Users/Ruthvik/Downloads/Jeopardy/server.js:26:21)\r\n    at Query.<anonymous> (/Users/Ruthvik/node_modules/mysql/lib/Connection.js:502:10)\r\n```\r\n\r\n\r\nserver.js\r\n```\r\nconst express = require('express');\r\nconst app = express();\r\nconst mysql = require('mysql');\r\n\r\nvar con = mysql.createConnection({\r\n    host: \"localhost\",\r\n    user: \"root\",\r\n    password: \"Federer5\",\r\n    database: \"Jeopardy\"\r\n});\r\n\r\napp.engine('html', require('ejs').renderFile);\r\napp.set('view engine', 'ejs');\r\n\r\nvar obj = {};\r\napp.get('/', function(req, res) {\r\n    con.connect(function (err) {\r\n        if (err) throw err;\r\n        console.log(\"Connected\");\r\n        var sql = \"SELECT * FROM questions\";\r\n        con.query(sql, function (err, result) {\r\n            if (err) {\r\n                throw err;\r\n            } else {\r\n                obj = {print: result};\r\n                res.render('index', obj);\r\n            }\r\n        });\r\n    });\r\n});\r\n\r\napp.listen(3000, function () {\r\n    console.log('listening on port', 3000);\r\n});\r\n```\r\n\r\nindex.ejs\r\n```\r\n<!DOCTYPE html>\r\n<html>\r\n  <head>\r\n    <link rel='stylesheet' href='/stylesheets/style.css' />\r\n  </head>\r\n  <body>\r\n    <h1><%= obj %></h1>\r\n    <p>Welcome to <%= obj %></p>\r\n  </body>\r\n</html>\r\n\r\n```",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/3890/comments",
    "author": "ghost",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2019-02-23T01:07:53Z",
        "body": "Hi @ruthvikkonda , so in the `ejs` template, it's expecting a value named `obj`. I see you have a `obj` in your JS code, but you end up passing it to `res.render` without a name. Try the following instead:\r\n\r\n```js\r\nres.render('index', {obj: obj});\r\n```"
      },
      {
        "user": "antoine6191",
        "created_at": "2020-12-15T12:59:10Z",
        "body": "someone to explain how access to join data in the template with ejs? like <%= product.idcategorie.name %>\r\ni include categorie in controller query, i have the data that i want in the variable but impossible to access in the template\r\nthank"
      },
      {
        "user": "JoysonPeter006",
        "created_at": "2022-01-17T11:28:50Z",
        "body": "> Hi @ruthvikkonda , so in the `ejs` template, it's expecting a value named `obj`. I see you have a `obj` in your JS code, but you end up passing it to `res.render` without a name. Try the following instead:\r\n> \r\n> ```js\r\n> res.render('index', {obj: obj});\r\n> ```Even after giving like above my ejs file when displayed doesnt show values from database instead only showing object object. Why is it so?\r\n\r\n"
      }
    ]
  },
  {
    "number": 3889,
    "title": "Routing by Variable",
    "created_at": "2019-02-22T16:58:02Z",
    "closed_at": "2019-02-23T08:52:18Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/3889",
    "body": "I have the fear it's a totally basic-question. But I got stuck at this point ..  :(\r\n\r\nMy usecase:\r\n\r\nThe root-website is running as a \"show-room\", where no input is possible (it is presenteds to the public on multiple screens). The \"show-room\" asks periodically via ajax for data. \r\n\r\nNo it should be possible to switch from another client (with another website, e.g. /setup) the routing to another view and also give some additional information to it. Beside the ajax-transfer I also have already the POST-Datas in the index.js\r\n\r\nOne more time: The root-page shows \" website A\" and over another website I can tell the server, that it should show \"website B\". The Reload could be managed by Javascript/AJAX.\r\n\r\nMy thought was just changing the Routing, but that does not work. Yes, indeed, I did not understand all the mechanism.... ;)\r\n\r\nMy first try in index.js:\r\n```js\r\n// ...\r\napp.get('/', view01.view01Action);\r\n// ...\r\n\r\n// Getting the form-datas    \r\napp.post('/setuppost', function(req, res) {\r\n        res.render('./../setup01/views/setup.handlebars');\r\n        \r\n// Reacting to the form-datas\r\n        if(req.body.selectedView=='view05'){\r\n            app.get('/', view05.view05Action);\r\n            (... handlebars-helpers and so on...)\r\n        }\r\n```\r\n\r\nCould anybody please tell me, how to solve my usecase? THX a lot!",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/3889/comments",
    "author": "alcero",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2019-02-23T01:12:17Z",
        "body": "Hi @alcero welcome! There are various ways to achieve what you're trying to do.\r\n\r\nBased on your current example above, what I would do is just save the view action function in a variable, add a handler that calls that variable, and then have your post just swap out that variable. Here is your example changed to do just that:\r\n```js\r\n// ...\r\nvar viewAction = view01.view01Action\r\n// ...\r\napp.get('/', (req, res, next) => viewAction(req, res, next));\r\n// ...\r\n\r\n// Getting the form-datas    \r\napp.post('/setuppost', function(req, res) {\r\n        res.render('./../setup01/views/setup.handlebars');\r\n        \r\n// Reacting to the form-datas\r\n        if(req.body.selectedView=='view05'){\r\n            viewAction = view05.view05Action;\r\n            (... handlebars-helpers and so on...)\r\n        }\r\n```"
      }
    ]
  },
  {
    "number": 3837,
    "title": "Is it a bad practise to wrap an express app by a user defined object?",
    "created_at": "2018-12-27T15:43:14Z",
    "closed_at": "2019-01-03T14:53:52Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/3837",
    "body": "Hi guys. \r\n\r\nI am implementing a middleware which will check whether the given request contains all the required params/body. \r\n\r\n```javascript\r\napp.use(checkRequestData);\r\n\r\napp.post(\"/user\", controller.addUser);\r\napp.get(\"/user/:id\", controller.getUser);\r\n```\r\n\r\nNow in **checkRequestData**, I can get **req.body** but **req.params.id** is returning *undefined*. To get the req.params.id, I have written the following function\r\n```javascript\r\n\r\nexports.checkRequestData = (req, res, next) => {\r\n    /**\r\n     * check whether request carries required data\r\n     */\r\n    next();\r\n};\r\n\r\nexports.applyMiddleware = (app) => (...middleware) => {\r\n    return new class {\r\n\r\n        middeware(req, res, next){            \r\n            middlewares.forEach((mw) => {\r\n                mw(req, res, next);\r\n            });\r\n        }\r\n\r\n        get(route, controller){\r\n            return app.get(route, this.middeware, controller);\r\n        }\r\n\r\n        post(route, controller){\r\n            return app.post(route, this.middeware, controller);\r\n        }\r\n    }\r\n}; \r\n```\r\n\r\nAnd the server file is modified as follows:\r\n\r\n```javascript\r\nconst _app = applyMiddleware(app)(checkRequestData);\r\n\r\n_app.post(\"/user\", controller.addUser);\r\n_app.get(\"/user/:id\", controller.getUser);\r\n```\r\n\r\nUsing this method I am able to get the request data. \r\n\r\nIs this the right approach of using express middlewares? Will this cause any issues to the in-built express methods?",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/3837/comments",
    "author": "softlore",
    "comments": [
      {
        "user": "wesleytodd",
        "created_at": "2018-12-27T18:12:27Z",
        "body": "Hi @gmk292.  This is probably not the way I would do it, but that is not to say it is wrong.  One other approach you might take is to create an array of reusable middleware and use it on each route.  The reason `params` is missing is because no route has been matched for that middleware.  You could get around this like so:\r\n\r\n```javascript\r\napp.post(\"/user\", checkRequestData, controller.addUser);\r\napp.get(\"/user/:id\", checkRequestData, controller.getUser);\r\n```\r\n\r\nIf you have multiple of these middleware you can group them in an array like this:\r\n\r\n```javascript\r\nconst middleware = [checkRequestData, handleRequestDataErrors];\r\n\r\napp.post(\"/user\", middleware, controller.addUser);\r\napp.get(\"/user/:id\", middleware, controller.getUser);\r\n```\r\n\r\nThis composition approach gets rid of the custom wrapper, and sticks with just usage of the express api.  Usually this makes for easier debugging in the future for you and anyone else who works on your project.  Good luck."
      }
    ]
  },
  {
    "number": 3800,
    "title": "How to rewrite url when using routers",
    "created_at": "2018-11-13T20:43:24Z",
    "closed_at": "2018-11-14T05:55:36Z",
    "labels": [
      "4.x",
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/3800",
    "body": "Hello, trying to rewrite the url to redirect requests but having some problems when the url doesn't have a trailing slash. Here is a minimal app to demonstrate.\r\n\r\n```js\r\nconst express = require('express')\r\nconst app = express()\r\nconst port = 3000\r\nconst router = express.Router()\r\n\r\nconst subFolder = '/forum'\r\n\r\napp.use(subFolder, rewrite);\r\n\r\nfunction rewrite(req, res, next) {\r\n    console.log(req.path)\r\n    if (req.path !== '/') {\r\n        return next()\r\n    }\r\n    req.url = '/categories'\r\n    app.handle(req, res, next);\r\n}\r\n\r\nrouter.get('/regular-page', (req, res) => res.send('Hello World!'))\r\nrouter.get('/categories', (req, res) => res.send('Categories'));\r\napp.use(subFolder, router);\r\n\r\napp.listen(port, () => console.log(`Example app listening on port ${port}!`))\r\n```\r\n\r\nThe goal is to redirect `localhost:3000/forum` and `localhost:3000/forum/` to `localhost:3000:/forum/categories`. Right now only `localhost:3000/forum/` works. The other just 404s.\r\n\r\nThanks.\r\n",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/3800/comments",
    "author": "barisusakli",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2018-11-13T20:46:17Z",
        "body": "I can help fix your code, but need to know: given the url /forum/foo do you want that not rewritten or rewritten to /categories/foo ?"
      },
      {
        "user": "barisusakli",
        "created_at": "2018-11-13T20:50:36Z",
        "body": "Hi @dougwilson `/forum/foo` should just go to `/forum/foo` only want to rewrite `/forum` and `/forum/` everything else should go to their regular handlers, so `/forum/regular-page` says `Hello World!`"
      },
      {
        "user": "dougwilson",
        "created_at": "2018-11-14T05:55:36Z",
        "body": "Hi @barisusakli there is a lot going on between your examples that may be causing the mix up. For example, when you `app.use(path, fn)`, the `req.url` with in the `fn` will have the `path` chopped off it, and if you alter the `req.url` property within that `fn`, you're only going to alter that portion of the url, as after `fn` exits, the `path` is still restored back to the front of the URL. This is by design.\r\n\r\nIn your second example, you've moved the `.use(path, fn)` from the `app` and onto the `router` that is mounted under `/forum` and then are looping the request back through the top of your app. This it's great because (1) it will re-invoke all your middlewares, which may not be desirable and (2) it can cause a loop condition.\r\n\r\nIdeally, you'll want to do the URL rewrite in a `.use` that is mounted at the point of the rewrite. Since you are trying to rewrite `/forum` to `/forum/category`, the point of the rewrite can just be be `/forum`, so you can mount it there.\r\n\r\nBecause you're using a router pattern, and `/forum` will always enter into the mount point with a non-empty path, you can just put a `.use` at the top of your router to change `/` to `/categories`:\r\n\r\n```js\r\nrouter.use(function rewrite(req, res, next) {\r\n    if (req.url === '/') req.url = '/categories'\r\n    next()\r\n})\r\n```\r\n\r\nHere is the completed app:\r\n```js\r\nconst express = require('express')\r\nconst app = express()\r\nconst port = 3000\r\nconst router = express.Router()\r\n\r\nconst subFolder = '/forum'\r\n\r\nrouter.use(function rewrite(req, res, next) {\r\n    if (req.url === '/') req.url = '/categories'\r\n    next()\r\n})\r\nrouter.get('/regular-page', (req, res) => res.send('Hello World!'))\r\nrouter.get('/categories', (req, res) => res.send('Categories'));\r\napp.use(subFolder, router);\r\n\r\napp.listen(port, () => console.log(`Example app listening on port ${port}!`))\r\n```\r\n\r\nI hope this helps!"
      }
    ]
  },
  {
    "number": 3744,
    "title": "npm ERR! code EJSONPARSE",
    "created_at": "2018-09-13T18:06:36Z",
    "closed_at": "2018-09-13T18:08:13Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/3744",
    "body": "Help I am getting this error\r\n> C:\\Users\\Admin\\Desktop\\bot>npm install discord.io winston -save.\r\n> npm ERR! file C:\\Users\\Admin\\Desktop\\bot\\package.json\r\n> npm ERR! code EJSONPARSE\r\n> npm ERR! JSON.parse Failed to parse json\r\n>  pm ERR! JSON.parse Unexpected token \ufffd in JSON at position 0 while parsing near '\ufffd\ufffd{\r\n> npm ERR! JSON.parse  \u001c n a m e \u001d ...'\r\n> npm ERR! JSON.parse Failed to parse package.json data.\r\n> npm ERR! JSON.parse package.json must be actual JSON, not just JavaScript.\r\n> \r\n> npm ERR! A complete log of this run can be found in:\r\n> npm ERR!     C:\\Users\\Admin\\AppData\\Roaming\\npm-cache\\_logs\\2018-09-13T17_55_13_036Z-debug.log\r\n> \r\n\r\n\r\nHere is the log:\r\n\r\n> 0 info it worked if it ends with ok\r\n> 1 verbose cli [ 'C:\\\\Program Files\\\\nodejs\\\\node.exe',\r\n> 1 verbose cli   'C:\\\\Program Files\\\\nodejs\\\\node_modules\\\\npm\\\\bin\\\\npm-cli.js',\r\n> 1 verbose cli   'install',\r\n> 1 verbose cli   'discord.io',\r\n> 1 verbose cli   'winston',\r\n> 1 verbose cli   '-save.' ]\r\n> 2 info using npm@6.4.1\r\n> 3 info using node@v10.10.0\r\n> 4 verbose npm-session c92302b61857a70f\r\n> 5 silly install loadCurrentTree\r\n> 6 silly install readLocalPackageData\r\n> 7 timing stage:rollbackFailedOptional Completed in 15ms\r\n> 8 timing stage:runTopLevelLifecycles Completed in 89ms\r\n> 9 verbose stack Error: Failed to parse json\r\n> 9 verbose stack Unexpected token \ufffd in JSON at position 0 while parsing near '\ufffd\ufffd{ \r\n>  \r\n> 9 verbose stack  \u001c n a m e \u001d ...'\r\n> 9 verbose stack     at parseError (C:\\Program Files\\nodejs\\node_modules\\npm\\node_modules\\read-package-json\\read-json.js:452:11)\r\n> 9 verbose stack     at parseJson (C:\\Program Files\\nodejs\\node_modules\\npm\\node_modules\\read-package-json\\read-json.js:104:26)\r\n> 9 verbose stack     at C:\\Program Files\\nodejs\\node_modules\\npm\\node_modules\\read-package-json\\read-json.js:51:5\r\n> 9 verbose stack     at C:\\Program Files\\nodejs\\node_modules\\npm\\node_modules\\graceful-fs\\graceful-fs.js:78:16\r\n> 9 verbose stack     at FSReqWrap.readFileAfterClose [as oncomplete] (internal/fs/read_file_context.js:53:3)\r\n> 10 verbose cwd C:\\Users\\Admin\\Desktop\\bot\r\n> 11 verbose Windows_NT 10.0.17134\r\n> 12 verbose argv \"C:\\\\Program Files\\\\nodejs\\\\node.exe\" \"C:\\\\Program Files\\\\nodejs\\\\node_modules\\\\npm\\\\bin\\\\npm-cli.js\" \"install\" \"discord.io\" \"winston\" \"-save.\"\r\n> 13 verbose node v10.10.0\r\n> 14 verbose npm  v6.4.1\r\n> 15 error file C:\\Users\\Admin\\Desktop\\bot\\package.json\r\n> 16 error code EJSONPARSE\r\n> 17 error JSON.parse Failed to parse json\r\n> 17 error JSON.parse Unexpected token \ufffd in JSON at position 0 while parsing near '\ufffd\ufffd{ \r\n>  \r\n> 17 error JSON.parse  \u001c n a m e \u001d ...'\r\n> 18 error JSON.parse Failed to parse package.json data.\r\n> 18 error JSON.parse package.json must be actual JSON, not just JavaScript.\r\n> 19 verbose exit [ 1, true ]\r\n> \r\n\r\nWhat should I do?\r\n",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/3744/comments",
    "author": "CubecCubehead",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2018-09-13T18:08:13Z",
        "body": "The error is from the command `npm install discord.io winston -save`, which is `npm`. It states that the file `C:\\Users\\Admin\\Desktop\\bot\\package.json` is not valid JSON."
      }
    ]
  },
  {
    "number": 3629,
    "title": "Adding database models to the request object?",
    "created_at": "2018-04-20T18:49:03Z",
    "closed_at": "2018-05-05T15:57:41Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/3629",
    "body": "I have a question about what the request object can be used for within Express. In particular, I'm considering creating a middleware that adds a database model to the request object, something like this:\r\n\r\n```javascript\r\nconst express = require('express');\r\nconst db = require('./databaseModel.js');\r\n\r\nconst app = express();\r\n\r\napp.use((req, res, next) => {\r\n    req.db = db;\r\n    next();\r\n}\r\n\r\napp.get('/store', (req, res) => {\r\n    req.db.getAllStoreItems()\r\n    .then(storeItems => res.send(storeItems))\r\n    .catch(error => res.sendStatus(500));\r\n}\r\n```\r\n\r\nIs this an appropriate use of the request object? I'm considering this approach because it will make it easier to test my route controllers (I can just pass in a mocked database without needing to monkey patch the models), but I haven't seen this usage pattern much online so I'm not sure if there are performance implications/other gotchas that I'm not considering.\r\n\r\nThanks for the help!",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/3629/comments",
    "author": "edahlseng",
    "comments": [
      {
        "user": "wesleytodd",
        "created_at": "2018-04-20T18:54:44Z",
        "body": "While this is a very common approach, it is actually not the best way.  The best way would be to use one of three other approaches:\r\n\r\n1. `app.set`:  you could do `app.set('myModel', model)` then in the handler function `req.app.get('myModel')`.\r\n2. `app.locals.myModel = model`: Similar to above, but would also make them available in the view rendering\r\n3. `res.locals.myModel = model`: Similar to 2 but you could selectively do it for different routes, where as the app ones are global to the application\r\n\r\nLet me know if you need more details on these, or examples.\r\n\r\nNow for the main reason not to do `req.db = myModel`.  It is a performance antipattern.  In an http server the request and response objects are probably the most commonly created objects.  So the runtime will optimize things for this.  But if you modify its shape by adding a key it will deopt it.  Specifically the app settings, app.locals and res.locals are made for this because deopting them is not such a big deal.  I have some benchmarks which I used to compare this and found that just one modification to req can cut perf in half in a basic reduced test case."
      }
    ]
  },
  {
    "number": 3588,
    "title": "Phantom console.error",
    "created_at": "2018-03-13T23:04:04Z",
    "closed_at": "2018-03-13T23:33:56Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/3588",
    "body": "I'm getting a strange output in my error logs, just a random \"200\" on it's own line without a stack trace or anything. I tracked it down to:\r\n\r\n    EventEmitter.logerror (lib/application.js:606:43)\r\n\r\nAny ideas what could be causing this?\r\n\r\nThanks",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/3588/comments",
    "author": "jwerre",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2018-03-13T23:07:18Z",
        "body": "Werid. There are many ways to cause this, since it's the error logger, including something as simple as \"next(200)\" since the number 200 is being passed back to Express as an error. You should be able to attach a debugger and put a break point there to see where it comes from. I can also help out if you're able to provide an example app doing this :+1:"
      },
      {
        "user": "jwerre",
        "created_at": "2018-03-13T23:15:51Z",
        "body": "That bit of insight actually helped. I was calling next(200) twice. The second was probably being caught by `logerror`. Thanks for the quick reply."
      },
      {
        "user": "dougwilson",
        "created_at": "2018-03-13T23:33:56Z",
        "body": "No problem. Yea, the if you keep calling `next(err)` it will end up in our catch-all so they don't get silently swallowed."
      }
    ]
  },
  {
    "number": 3565,
    "title": "Post request flood?",
    "created_at": "2018-02-14T08:47:11Z",
    "closed_at": "2018-02-15T11:22:27Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/3565",
    "body": "Introduction\r\n================\r\nI\u00b4ve a nodejs application with express that have some post and get request. The whole website works just fine without problems.\r\n\r\nProblem\r\n============\r\nIf I call the post request to much in time the site will crash. It will not respond to other requests. Doesn\u00b4t matter if it\u00b4s get or post request. I just can close the tab and open the site in a new one. Then it work again.\r\n\r\nMy Code\r\n===========\r\n\r\n## Client side ##\r\nIt\u00b4s a easy post request to set a client permission. There is no callback defined.\r\n\r\n    $.post(\r\n       '/clients/set/client/permission',\r\n       {\r\n          permName: globPermissionTable[permName],\r\n          value: checked,\r\n          id: '<%= data[0].id %>'\r\n       }\r\n    );\r\n\r\n----------\r\n\r\n## Server side ##\r\nJust a easy post segment. Even if I will uncomment all in the request it will be not response.\r\n\r\n    app.post('/clients/set/client/permission', function(req, res) {\r\n\t   // Permissioncheck\r\n\t   /*var permName = req.body.permName, val = req.body.value, id = req.body.id;\r\n\t   if(helper.checkParams([permName, val, id])) {\r\n\t\t     database.SetClientPermissions(parseInt(id), permName, (val === 'true') ? true : false);\r\n\t   };*/\r\n    });",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/3565/comments",
    "author": "lgund",
    "comments": [
      {
        "user": "lgund",
        "created_at": "2018-02-14T08:58:33Z",
        "body": "I found out now that if a write _res.send('finished');_ this problem doesn\u00b4t happen. If it\u00b4s that important to always send something back?\r\n\r\n-----------\r\nFull Code:\r\n`app.post('/clients/set/client/permission', function(req, res) {\r\n   res.send('finished');\r\n});`"
      },
      {
        "user": "wesleytodd",
        "created_at": "2018-02-14T21:50:51Z",
        "body": "Yes, you always need to send a response.  Otherwise the connection will remain open waiting for that response.  If you are not going to handle a request in a middleware, you can also just call `next` and allow express to respond for you with a 404:\r\n\r\n```\r\napp.post('/foo', function (req, res, next) {\r\n  if (something) {\r\n    return res.send('response');\r\n  }\r\n  next();\r\n});\r\n```"
      }
    ]
  },
  {
    "number": 3433,
    "title": "error handled at unknown error handler",
    "created_at": "2017-09-27T18:28:29Z",
    "closed_at": "2017-09-27T19:00:58Z",
    "labels": [
      "4.x",
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/3433",
    "body": "express version : 4.15,\r\nnode version: 8.1.4\r\n\r\nim currently experiencing an odd behavior within my application, I have nested routes and im defining my routes like this\r\n\r\n```js\r\nconst router = require('express').Router();\r\nconst m = require('../modules/index').v1;\r\n\r\nrouter.route('/')\r\n  .post(m.create)\r\n  .get(m.list)\r\n  .all(m.transformer);\r\n\r\nrouter.route('/:id')\r\n  .all(m.middlewareById)\r\n  .put(m.editById)\r\n  .delete(m.deleteById)\r\n  .get(m.getById)\r\n  .all(m.transformer);\r\nmodule.exports = router;\r\n```\r\nIm currently developing m.create API controller, and when and error occurs that is not handled sends me a response of HTML page with error object. \r\n```html\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n    <head>\r\n        <meta charset=\"utf-8\">\r\n        <title>Error</title>\r\n    </head>\r\n    <body>\r\n        <pre>[object Object]</pre>\r\n    </body>\r\n</html>\r\n```\r\nI want to eliminate this behavior and response with JSON only, but somehow its by passing my defined request handlers, and instead of getting handled at a middle ware that I specify, or the one at `app.js` \r\nits is being handled somewhere else mysteriously, i've been express user for 3 or more years and this is the first time im facing such behavior.\r\nhas something changed in new Express version? \r\n\r\n_app.js_\r\n```js\r\nconst express = require('express');\r\nconst path = require('path');\r\n// const favicon = require('serve-favicon');\r\nconst logger = require('morgan');\r\nconst cookieParser = require('cookie-parser');\r\n...\r\n\r\napp.use('/', index);\r\napp.use('/systemadmin', systemAdminRoutes);\r\n\r\n// catch 404 and forward to error handler\r\napp.use((req, res, next) => {\r\n  const err = new Error('Not Found');\r\n  err.status = 404;\r\n  next(err);\r\n});\r\n\r\n// error handler\r\napp.use((err, req, res) => {\r\n  // next is the last argument in above function\r\n  // set locals, only providing error in development\r\n  // res.locals.message = err.message;\r\n  // res.locals.error = req.app.get('env') === 'development' ? err : {};\r\n  debug(err); // nothing logs here \r\n  debug(err.message);\r\n  debug(err.name);\r\n  debug(err.errorCode);\r\n  debug(err.stack);\r\n  // render the error page\r\n  res.status(err.status || 500);\r\n  res.send({error: err.message}); //this never gets called\r\n});\r\n\r\nmodule.exports = app;\r\n```",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/3433/comments",
    "author": "muhammadfaizan",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2017-09-27T18:31:28Z",
        "body": "Maybe you ran a linter on your code recently? Your code above you have\r\n```js\r\napp.use((err, req, res) => {\r\n```\r\n\r\nBut (which has always been in the case), it MUST have 4 arguments in order to work:\r\n```js\r\napp.use((err, req, res, next) => {\r\n```"
      }
    ]
  },
  {
    "number": 3432,
    "title": "In-place Express update to 4.15.5 still has old forwarded",
    "created_at": "2017-09-27T16:54:34Z",
    "closed_at": "2017-09-28T17:46:29Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/3432",
    "body": "Hello, I'm writing to request an update for the dependency proxy-addr to a version, like version 2.0.2, that has the security patched version of forwarded in it's dependencies., 0.1.2. \r\n\r\nThanks!",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/3432/comments",
    "author": "JaneCoder",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2017-09-27T18:06:09Z",
        "body": "The semver range already covers the patched version. Simply upgrading to 4.15.5 will force the new version of the dependency."
      },
      {
        "user": "dougwilson",
        "created_at": "2017-09-27T18:07:47Z",
        "body": "The plan is to include proxy-addr 2.0.2 in Express.js 4.16 on Monday Oct 2, but until then installing a fresh Express.js 4.15.5 will drop you forwarded 0.1.2 in your tree."
      },
      {
        "user": "dougwilson",
        "created_at": "2017-09-27T18:12:28Z",
        "body": "If it helps, here is what the `forwarded` tree looks like for an install of Express 4.15.5:\r\n```\r\n$ npm i express\r\n+ express@4.15.5\r\nadded 42 packages in 3.213s\r\n\r\n$ npm ls forwarded\r\nexpress-3432\r\n\u2514\u2500\u252c express@4.15.5\r\n  \u2514\u2500\u252c proxy-addr@1.1.5\r\n    \u2514\u2500\u2500 forwarded@0.1.2 \r\n```\r\n\r\nLet me know if there is still something you need or if there is something preventing you from picking up the correct version of `forwarded` in your installation of 4.15.5, and I'm happy to get you onto the correct version \ud83d\udc4d "
      },
      {
        "user": "dougwilson",
        "created_at": "2017-09-27T18:27:38Z",
        "body": "Ok, so I've been experimenting a bit, and definitely with npm@5 getting a simple command to bump `forwarded` on a non-clean express install is not straight forward. The only command that actually worked was `npm i --no-save forwarded@0.1.2`, but that assumes what you actually need to do.\r\n\r\nI think that even if this causes the \"mime\" fixed to be delayed, juggling around the dependencies more and getting an Express 4.15.6 that have all semver ranges to not allow `forwarded < 0.1.2` may be the only ideal way to resolve this for a lot of folks."
      },
      {
        "user": "dougwilson",
        "created_at": "2017-09-27T18:51:28Z",
        "body": "This certainly will make me think about bothering with semver ranges at all any more. Having ranges instead of a specific version adds risk to the install, but it's generally been argued that the trade off of getting security updates is worth it. This seems to indicate that it really only helps users who don't already have it installed, and the existing user base cannot take advantage of it as easily :("
      },
      {
        "user": "dougwilson",
        "created_at": "2017-09-28T19:53:11Z",
        "body": "Express.js 4.16.0 is out now where the `forwarded` ranges don't include anything below 0.1.2 \ud83c\udf89 "
      }
    ]
  },
  {
    "number": 3420,
    "title": "Defining a router-specific error handler",
    "created_at": "2017-09-20T17:44:59Z",
    "closed_at": "2017-09-20T20:41:48Z",
    "labels": [
      "4.x",
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/3420",
    "body": "hi there,\r\n\r\nI would like a little advice on the correct way to define a error handler for a specific router (my use case is a webapp with \"normal\" html routes, and a route `/api` where a new Router instance is attached that only deals in JSON output):\r\n\r\nI am using `Express v4.15.3`, is the following conceptually what I should be doing? :\r\n\r\n```js\r\nconst r = Router;\r\n\r\nr.get('/users', (req, res, next) { res.send({ users : []}); }\r\n\r\n// ... more routes ...\r\n\r\n// add error handler last so that all errors fall into it\r\nr.use((req, res, next, err) { res.send(outputJsonApiError(err)); });\r\n\r\napp.use('/api', r);\r\n```\r\n\r\n\r\nP.S. I have searched the docs and the issues lists but failed to have a \"lightbulb moment\"(tm) ... sorry for the noise (I always struggle a bit with express error handling - in the past I have ended up with a footgun more than once!)",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/3420/comments",
    "author": "iamjochem",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2017-09-20T18:40:06Z",
        "body": "Yea, that would work. Just kind in mine that the routes will run in the order you declared, so you may want to swap the `r.use` with the `r.get` in your example above so the error handler is the last thing in your router so errors that occur in your routes will fall into the error handler."
      }
    ]
  },
  {
    "number": 3381,
    "title": "Question: Why does the express router call the params keys?",
    "created_at": "2017-08-01T19:50:47Z",
    "closed_at": "2017-09-25T06:14:27Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/3381",
    "body": "So I am debugging how to test an express router object. Essentially to have 100% coverage. Anyways, what I noticed while debugging is that the router object creates a stack of routes. Cool, except when I look at the stack, `params` are undefined while `keys` is an array of my params. Pretty misleading. Then in my service, I can request these so called `keys` as `req.params`.\r\n\r\nJust wonder why the params do not get populated here. Is this params property only for inherited params? like from `router.param`",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/3381/comments",
    "author": "JemiloII",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2017-08-01T19:56:49Z",
        "body": "Well, the names of those properties were from before I managed Express.js so I don't know why, only that they are and changing them is not simple with a lot of code floating around using those properties. "
      },
      {
        "user": "kevinkassimo",
        "created_at": "2017-08-03T10:10:59Z",
        "body": "Do you mean `router.params`? This contains only all callbacks added through `router.param()`. In `lib/router/index.js`\r\n```javascript\r\nproto.param = function param(name, fn) {\r\n    //...\r\n    (this.params[name] = this.params[name] || []).push(fn);\r\n    return this;\r\n}\r\n```\r\nOr do you mean `layer.params` of each layer stored on `router.stack`? In this case, in `function Layer()` of `lib/router/layer.js`\r\n```javascript\r\nthis.regexp = pathRegexp(path, this.keys = [], opts); // regexp group fills this.keys with parameter names\r\n```\r\n`layer.params` is only populated as `layer.params[paramName] === paramValue` when `layer.match()` is called in `router.handle()` (aka `router()`), and that a match exist to the corresponding path. I am not quite sure what could have been the problem, but I would suggest checking the source code of `Layer.prototype.match()` in `lib/router/layer.js` and possibly `proto.handle()` in `lib/router/index.js`, to get a better understanding of them.\r\n\r\n"
      },
      {
        "user": "JemiloII",
        "created_at": "2017-08-06T21:38:28Z",
        "body": "@kevinkassimo so the in the stack the params will get populated once the route is being navigated to? While the keys are simply there for reference? Also thanks for the direction of where to read."
      },
      {
        "user": "kevinkassimo",
        "created_at": "2017-08-07T04:14:21Z",
        "body": "@JemiloII In `Layer.prototype.match()` of `router/layer.js`,\r\n```javascript\r\nLayer.prototype.match = function match(path) {\r\n  var match\r\n\r\n  if (path != null) {\r\n    //...\r\n    match = this.regexp.exec(path) // try match the path\r\n  }\r\n\r\n  if (!match) { // current match failed, layer.params is undefined and not populated\r\n    this.params = undefined;\r\n    this.path = undefined;\r\n    return false;\r\n  }\r\n  // If matched\r\n  var keys = this.keys;\r\n  var params = this.params;\r\n\r\n  for (var i = 1; i < match.length; i++) {\r\n    var key = keys[i - 1];\r\n    var prop = key.name;\r\n    var val = decode_param(match[i]) // using the grouping of regexp\r\n\r\n    if (val !== undefined || !(hasOwnProperty.call(params, prop))) {\r\n      params[prop] = val; // populate layer.params HERE!\r\n    }\r\n  }\r\n  return true;\r\n}\r\n```\r\nAlso after reviewing the logic of `router.handle()`, I believe the steps could indeed be understood as:  \r\n1. `router.handle()` is invoked with a new given path that requires inspection  \r\n2. A path match on some layer stored on the stack is found  \r\n2.1 before this path match returned true, `layer.params` is populated using the param names stored in `layer.keys` as keys to establish key value mappings  \r\n3. `router.handle` then merges current `layer.params` into `req.params`  \r\n3.1 `router.handle` first try processing all param handlers added through `router.param()`  \r\n3.2 `router.handle` then calls your provided path handlers, by internally calling `layer.handle_request(req, res, next)`, and that all param data could be accessed through `req.params`  \r\n4. if you call `next()` in your provided handler, the `router.handle()` continues tracing down the `router.stack`. For each extra match, goto 2. Else done.\r\n\r\nSo basically I believe you are correct."
      }
    ]
  },
  {
    "number": 3376,
    "title": "Regex-based subrouter cannot route anything",
    "created_at": "2017-07-28T08:31:06Z",
    "closed_at": "2017-07-29T07:53:46Z",
    "labels": [
      "4.x",
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/3376",
    "body": "Hello,\r\nI'm experiencing a routing unavailability at `router2` in the code below. This code can route `/api/awesome` but not `mypage`. This code is of course simplified and the part of bigger system, so it is difficult to change the routing structure of `router1` and `router2`.\r\n\r\nWill there be any idea to resolve this while keeping this subrouter structure?\r\n\r\n```js\r\nconst express = require('express');\r\nconst app = express();\r\n\r\nconst router1 = express.Router();\r\nconst router2 = express.Router();\r\n\r\nrouter2.get('/mypage', function(req, res, next) {\r\n\tres.json('mypage');\r\n\tnext();\r\n});\r\n\r\nrouter1.use(/^\\/(?!api).*/, router2);\r\n\r\nrouter1.get('/api/awesome', function(req, res, next) {\r\n\tres.json('awesome');\r\n\tnext();\r\n});\r\n\r\napp.use(router1);\r\n\r\napp.listen(8080);\r\n```\r\n\r\nExpress version: 4.15.3\r\nNode.js version: 8.2.1",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/3376/comments",
    "author": "Kivol",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2017-07-28T14:22:26Z",
        "body": "Hi @Kivol the reason your `/mypage` route is not matching is because the way `.use` works is that it will cut off whatever matched as it passes down (so you only need to write the rest of the path, not the full path over and over). Your regular expression, `/^\\/(?!api).*/`, since it ends with `.*` will always match the entire url, which in turn means the entire thing is trimmed out, making `router2` only see `req.url` as `/`, which won't match `/mypage`.\r\n\r\nYou can correct this my making the regular expression match nothing on success for what you're trying to do. Example: `/^(?!\\/api)/`. Here is the full example with this change made:\r\n\r\n```js\r\nconst express = require('express');\r\nconst app = express();\r\n\r\nconst router1 = express.Router();\r\nconst router2 = express.Router();\r\n\r\nrouter2.get('/mypage', function(req, res, next) {\r\n\tres.json('mypage');\r\n});\r\n\r\nrouter1.use(/^(?!\\/api)/, router2);\r\n\r\nrouter1.get('/api/awesome', function(req, res, next) {\r\n\tres.json('awesome');\r\n});\r\n\r\napp.use(router1);\r\n\r\napp.listen(8080);\r\n```"
      }
    ]
  },
  {
    "number": 3319,
    "title": "why is 'next' in createApplication needed?",
    "created_at": "2017-05-25T03:09:01Z",
    "closed_at": "2017-05-25T03:26:45Z",
    "labels": [
      "3.x",
      "4.x",
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/3319",
    "body": "```js\r\nfunction createApplication() {\r\n  var app = function(req, res, next) {\r\n    app.handle(req, res, next);\r\n  };\r\n```\r\nI deleted it in my local env,it turns out fine.\r\nAnd It seems no way to assaign it , how to use this 'next' here?",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/3319/comments",
    "author": "ginobilee",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2017-05-25T03:26:45Z",
        "body": "Hi @ginobilee it is used when you mount apps on each other. For example:\r\n```js\r\nvar app  = express()\r\nvar app1 = express()\r\n\r\napp.use(app1)\r\n```"
      }
    ]
  },
  {
    "number": 3283,
    "title": "Testing for express version",
    "created_at": "2017-04-18T10:24:33Z",
    "closed_at": "2017-04-19T03:16:48Z",
    "labels": [
      "3.x",
      "4.x",
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/3283",
    "body": "Hello, I couldn't find in the documentation anywhere if there was a `require('express').version` or `app.version`.\r\n\r\nI have a middleware that has to change how it implements certain code depending on **Express 3.*** vs **Express 4.***.\r\n\r\nFYI: it regards the depreciated usage of path as an array in 3.* but allowed in 4.* and I didn't want to make a express3-module and express4-module for a single if statement.",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/3283/comments",
    "author": "WORMSS",
    "comments": [
      {
        "user": "blakeembrey",
        "created_at": "2017-04-18T16:10:29Z",
        "body": "You could do `require('express/package')`. Or you could try feature detection of the express instance. Or you could just export two versions of the library as `express` and `express3`."
      },
      {
        "user": "dougwilson",
        "created_at": "2017-04-19T03:16:48Z",
        "body": "Yea, we don't explicitly export the version because `require('express/package').version` works great and is universal to all npm packages to boot :)"
      }
    ]
  },
  {
    "number": 3282,
    "title": "inspect an action/handle/route function before i do with something",
    "created_at": "2017-04-12T22:19:35Z",
    "closed_at": "2017-04-19T16:21:27Z",
    "labels": [
      "4.x",
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/3282",
    "body": "i am trying to create a handering API with my routes.\r\nbut i cannot restrict everything. i add a decorator on the function like:\r\n\r\n```javascript\r\napp.use((req, res, next) => {\r\n   // i got the app inside...\r\n  // if it is decorated the handle/route/function it does it self\r\n  if (app.handle.decorated === true) {\r\n    next();\r\n }\r\n ... verify auth ...\r\n})\r\n\r\nconst decorate.auth = () => {};\r\ndecorate.auth.decorated = true;\r\n\r\n// a decorated auth,  so the middleware should skip\r\nroute.get('/something', decorate.auth('public', (req, res) => {\r\n  res.send('ok');\r\n}\r\n```\r\nThe problem is I want to restrict except the ones that are decorated, but i cannot find the handle/route before it is fired. ",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/3282/comments",
    "author": "patrikx3",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2017-04-12T22:42:03Z",
        "body": "Hi @patrikx3 I'm not 100% sure on what you're trying to do exactly, but it sounds like a pattern for doing granular auth restrictions per route. If that is right, one pattern you can try is to use a middleware pattern to skip, for example:\r\n```js\r\n// 1. Let's assume that you have a middleware that looks up a user's access level\r\napp.use((req, res, next) => {\r\n   req.user.accessLevel = 'public'\r\n})\r\n\r\n// 2. Then you could make an access level checker\r\nfunction requireAccessLevel(level) {\r\n  return (req, res, next) => {\r\n    if (req.user && req.user.accessLevel === level) next()\r\n    else next('route')\r\n  }\r\n}\r\n\r\n// 3. Then you would define your route\r\nroute.get('/something', requireAccessLevel('private'), (req, res) => {\r\n  res.send('ok')\r\n}\r\n```"
      },
      {
        "user": "patrikx3",
        "created_at": "2017-04-12T22:49:09Z",
        "body": "the problem is that i am trying to do everything in reverse. i try to restrict everything, but i try to allow a few routes with public access, but the problem since i already forbid everything my middleware doesnt' got access to my route.\r\n\r\ni can restrict , that is ok.\r\nbut i try to restrict everything automatically, but add a few public route like public, role2, role1. \r\nlike hardening.\r\nsince you created do you have a little idea when you get a little chance how it would be to every action/function/route before i do it?\r\n\r\n**but i would decorate a child app, router, or a route as well.**\r\n\r\nif it has no authorization decorator, forbid.\r\n:) \r\n\r\nciao if you have a little time! thanks so much!"
      },
      {
        "user": "dougwilson",
        "created_at": "2017-04-13T02:08:30Z",
        "body": "Hi @patrikx3 gotcha. I definitely didn't fully understand what you are asking, as I suspected may be the case. I'm still a little fuzzy on what you're trying to do, but I think I may understand this time (?). Typically if you wanted to have a route layout of fully accessible + generally restricted, you could just place the few accessible routes physically before the auth check restriction:\r\n```js\r\n// 1. Declare the routes available to everyone\r\napp.get('/', ..);\r\n\r\n// 2. Add your auth restriction\r\napp.use(blockNonAdmins());\r\n\r\n// 3. Declare the restricted routes\r\napp.get('/control_panel', ...);\r\n```"
      }
    ]
  },
  {
    "number": 3274,
    "title": "TypeError: Router.use() requires middleware function but got a Object",
    "created_at": "2017-04-08T16:12:50Z",
    "closed_at": "2017-04-10T07:24:23Z",
    "labels": [
      "4.x",
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/3274",
    "body": "macOS Sierra 10.12.4\r\nnode v7.8.0\r\nnpm 4.2.0\r\n\r\nindex.js\r\n```javascript\r\nconst express = require('express')\r\nconst bodyParser = require('body-parser')\r\nconst session = require('express-session')\r\nconst mongoose = require('mongoose')\r\nconst MongoStore = require('connect-mongo')(session)\r\nconst morgan = require('morgan')\r\nconst csrf = require('lusca').csrf()\r\nconst fs = require('fs')\r\nconst path = require('path')\r\nconst rfs = require('rotating-file-stream')\r\n\r\nmongoose.connect('mongodb://localhost/test')\r\n\r\nconst app = express()\r\n\r\nconst logDir = path.join(__dirname, 'log')\r\nfs.existsSync(logDir) || fs.mkdirSync(logDir)\r\nconst accessLogStream = rfs('access.log', {\r\n  interval: '1d',\r\n  path: logDir\r\n})\r\n\r\napp.use(bodyParser.json())\r\napp.use(bodyParser.urlencoded({extended: true}))\r\napp.use(session({\r\n  secret: 'ohmy411',\r\n  store: new MongoStore({\r\n    mongooseConnection: mongoose.connection\r\n  })\r\n}))\r\napp.use(morgan('combined'), { stream: accessLogStream })\r\napp.use((req, res, next) => csrf(req, res, next))\r\n\r\napp.get('/', (req, res) => res.send('hello world'))\r\n\r\napp.listen(3000)\r\n```\r\n\r\nerror info\r\n```\r\n\u279c  server (master) \u2717 node index.js\r\nexpress-session deprecated undefined resave option; provide resave option index.js:26:9\r\nexpress-session deprecated undefined saveUninitialized option; provide saveUninitialized option index.js:26:9\r\n/Users/simonqian/Work/ohmy411/server/node_modules/express/lib/router/index.js:458\r\n      throw new TypeError('Router.use() requires middleware function but got a ' + gettype(fn));\r\n      ^\r\n\r\nTypeError: Router.use() requires middleware function but got a Object\r\n    at Function.use (/Users/simonqian/Work/ohmy411/server/node_modules/express/lib/router/index.js:458:13)\r\n    at Function.<anonymous> (/Users/simonqian/Work/ohmy411/server/node_modules/express/lib/application.js:220:21)\r\n    at Array.forEach (native)\r\n    at Function.use (/Users/simonqian/Work/ohmy411/server/node_modules/express/lib/application.js:217:7)\r\n    at Object.<anonymous> (/Users/simonqian/Work/ohmy411/server/index.js:32:5)\r\n    at Module._compile (module.js:571:32)\r\n    at Object.Module._extensions..js (module.js:580:10)\r\n    at Module.load (module.js:488:32)\r\n    at tryModuleLoad (module.js:447:12)\r\n    at Function.Module._load (module.js:439:3)\r\n    at Module.runMain (module.js:605:10)\r\n    at run (bootstrap_node.js:423:7)\r\n    at startup (bootstrap_node.js:147:9)\r\n    at bootstrap_node.js:538:3\r\n```\r\n\r\ndependencies\r\n```json\r\n  {\r\n    \"body-parser\": \"^1.17.1\",\r\n    \"connect-mongo\": \"^1.3.2\",\r\n    \"express\": \"^4.15.2\",\r\n    \"express-session\": \"^1.15.2\",\r\n    \"lusca\": \"^1.4.1\",\r\n    \"mongoose\": \"^4.9.2\",\r\n    \"morgan\": \"^1.8.1\",\r\n    \"rotating-file-stream\": \"^1.2.1\",\r\n    \"uuid\": \"^3.0.1\"\r\n  }\r\n```\r\n\r\nWhere is it wrong?",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/3274/comments",
    "author": "simonqian",
    "comments": [
      {
        "user": "willyelm",
        "created_at": "2017-04-08T16:25:28Z",
        "body": "here:\r\n\r\n```javascript\r\napp.use(morgan('combined'), { stream: accessLogStream })\r\n```\r\n\r\nseems like you are trying to use 2 middleware where the second is a Object `{ stream: accessLogStream }`. you should have:\r\n\r\n```javascript\r\napp.use(morgan('combined', { stream: accessLogStream }))\r\n```\r\n"
      }
    ]
  },
  {
    "number": 3238,
    "title": "How to render from string?",
    "created_at": "2017-03-06T19:10:33Z",
    "closed_at": "2017-03-07T02:11:22Z",
    "labels": [
      "4.x",
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/3238",
    "body": "Hello.\r\n\r\nHow to render from string?\r\n\r\nindex.js\r\n```\r\nres.render('index', {\"hello\": \"world\"});\r\n```\r\nindex.ejs\r\n```\r\n<%- hello %>\r\n```\r\n\r\nWe need so:\r\n```\r\nvar hello = '<%- hello %>';\r\nres.render(hello, {\"hello\": \"world\"});\r\n```\r\n\r\nIt's possible?",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/3238/comments",
    "author": "extensionsapp",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2017-03-06T19:15:41Z",
        "body": "Depending on the case, typically you would just use the engine directly. For example:\r\n```js\r\nvar hello = '<%- hello %>';\r\nres.send(ejs.render(hello, {\"hello\": \"world\"}));\r\n```"
      }
    ]
  },
  {
    "number": 3234,
    "title": "Creating a custom renderer for a JS file",
    "created_at": "2017-03-04T08:29:07Z",
    "closed_at": "2017-03-04T08:38:09Z",
    "labels": [
      "4.x",
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/3234",
    "body": "Not sure if this has been asked here before or on SO but I thought I'd post here incase we need to convert to an issue.\r\n\r\nI have the following route;\r\n\r\n```javascript\r\napp.get('/embed/:id.js', (req, res) => {\r\n  res.header('Content-Type', 'text/javascript')\r\n\r\n  res.sendFile(__dirname + '/views/embedTemplate.js', {\r\n    embedId: req.params.id\r\n  })\r\n})\r\n\r\n```\r\n\r\nObviously `sendFile` doesn't permit modifying the file as it's just the `fs` returning the file. So, instead of creating a custom engine to replace `#embedId#` for example, if there a way to `render` the file and modify the contents?\r\n\r\nMy first guess at something like based on the examples would be \r\n\r\n```javascript\r\napp.get('/embed/:id.js', (req, res) => {\r\n  res.header('Content-Type', 'text/javascript')\r\n\r\n  var filePath = __dirname + '/views/embedTemplate.js'\r\n\r\n  var fileToRender = fs.readFile(filePath, function (err, content) {\r\n    if (err) return callback(err)\r\n\r\n    var rendered = content.toString().replace('#embedId#', req.params.id)\r\n    return rendered\r\n  })\r\n\r\n  res.send(fileToRender)\r\n})\r\n```\r\n\r\nAm I missing something that is built into Express?",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/3234/comments",
    "author": "notrab",
    "comments": [
      {
        "user": "notrab",
        "created_at": "2017-03-04T08:38:08Z",
        "body": "Ok so I figured this out.\r\n\r\nI also moved the render into the readFile callback to prevent thread blocking.\r\n\r\n```javascript\r\napp.get('/embed/:id.js', (req, res) => {\r\n  var filePath = Path.join(__dirname, '/views/embedTemplate.js')\r\n\r\n  fs.readFile(filePath, function (err, content) {\r\n    if (err) return callback(err)\r\n\r\n    var rendered = content.toString().replace('#embedId#', req.params.id)\r\n\r\n    res.setHeader('Content-Type', 'text/javascript')\r\n    res.write(rendered, 'binary')\r\n    res.end()\r\n  })\r\n})\r\n```\r\n\r\nI've never done this with Express before - Maybe an example I can submit a PR for \ud83d\ude0f"
      },
      {
        "user": "dougwilson",
        "created_at": "2017-03-04T21:16:14Z",
        "body": "You could reduce your last example down to the following:\r\n```js\r\napp.get('/embed/:id.js', (req, res) => {\r\n  var filePath = Path.join(__dirname, '/views/embedTemplate.js')\r\n\r\n  fs.readFile(filePath, function (err, content) {\r\n    if (err) return callback(err)\r\n    res.type('js').send(content.toString().replace('#embedId#', req.params.id))\r\n  })\r\n})\r\n```\r\n\r\nBut even then, it would be nice to do it in some more generic way. You may want to even consider thinking about that file as really not a JS file at all, but as a template. You could then use the `res.render` process directly, perhaps to render a \"tjs\" file (was thinking template js, idk). In that case, you could just use an existing template engine, like handlebars, ejs, pug, whatever, and attach that to handle tjs extensions. Then the only additional thing is that you want to send it with the correct content type:\r\n```js\r\napp.get('/embed/:id.js', (req, res) => {\r\n  res.render('embedTemplate.tjs', { endedId: req.params.id }, function (err, content) {\r\n    if (err) return callback(err)\r\n    res.type('js').send(content)\r\n  })\r\n})\r\n```"
      }
    ]
  },
  {
    "number": 3219,
    "title": "parser.incoming._addHeaderLines is not a function",
    "created_at": "2017-02-21T17:36:49Z",
    "closed_at": "2017-02-21T17:41:15Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/3219",
    "body": "I tried running express with uws and I get this error : \r\n\r\n> _http_common.js:138\r\n>       parser.incoming._addHeaderLines(headers, headers.length);\r\n>                       ^\r\n> \r\n> TypeError: parser.incoming._addHeaderLines is not a function\r\n>     at HTTPParser.parserOnMessageComplete (_http_common.js:138:23)\r\n> \r\n> npm ERR! Darwin 16.1.0\r\n> npm ERR! argv \"/usr/local/bin/node\" \"/usr/local/bin/npm\" \"run\" \"start:dev\"\r\n> npm ERR! node v7.5.0\r\n> npm ERR! npm  v4.1.2\r\n> npm ERR! code ELIFECYCLE\r\n> npm ERR! AdminMeepV2@0.1.0 start:dev: `npm run resetdb && node server.js`\r\n> npm ERR! Exit status 1\r\n> npm ERR! \r\n> npm ERR! Failed at the AdminMeepV2@0.1.0 start:dev script 'npm run resetdb && node server.js'.\r\n> npm ERR! Make sure you have the latest version of node.js and npm installed.\r\n> npm ERR! If you do, this is most likely a problem with the AdminMeepV2 package,\r\n> npm ERR! not with npm itself.\r\n> npm ERR! Tell the author that this fails on your system:\r\n> npm ERR!     npm run resetdb && node server.js\r\n> npm ERR! You can get information on how to open an issue for this project with:\r\n> npm ERR!     npm bugs AdminMeepV2\r\n> npm ERR! Or if that isn't available, you can get their info via:\r\n> npm ERR!     npm owner ls AdminMeepV2\r\n> npm ERR! There is likely additional logging output above.\r\n> \r\n> npm ERR! Please include the following file with any support request:\r\n> npm ERR!     /Users/gatsbill/Desktop/meepV2/server/npm-debug.log\r\n> Aureliens-MBP:server gatsbill$ \r\n\r\nHere is my code : \r\n\r\n```js\r\n'use strict';\r\n\r\nconst express = require('express');\r\n\r\nObject.setPrototypeOf(express.request, require('uws').http.getRequestPrototype());\r\nObject.setPrototypeOf(express.response, require('uws').http.getResponsePrototype());\r\n\r\nconst app = express();\r\nconst server = require('http').createServer(app);\r\n\r\nconst config = require('./config');\r\nconst setGlobalMiddlewares = require('./middlewares/middlewares');\r\nconst routes = require('./routes');\r\n\r\n// set global middlewares\r\nsetGlobalMiddlewares(app);\r\n\r\n// route controller\r\napp.use(routes);\r\n\r\n// start http server\r\nserver.listen(config.server.port, () => {\r\n   console.log('server listen on port ' + config.server.port);\r\n});\r\n```\r\n\r\nDunno if you need all the middleware ",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/3219/comments",
    "author": "billouboq",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2017-02-21T17:39:29Z",
        "body": "I'm not sure. That error is coming from Node.js core (`_http_common.js:138`), not from this module. Can you share the code you used? Do you have a full stack trace? Perhaps there is a bug somewhere in `uws`? Not sure."
      },
      {
        "user": "dougwilson",
        "created_at": "2017-02-21T17:41:15Z",
        "body": "Ah, you edited the original post. Looks like the issue is your line\r\n```js\r\nconst server = require('http').createServer(app);\r\n```\r\n\r\nYou need to use the `uws` module to create the server, not Node.js core. I believe that line should be:\r\n```js\r\nconst server = require('uws').http.createServer(app);\r\n```"
      },
      {
        "user": "wesleytodd",
        "created_at": "2017-02-21T17:41:24Z",
        "body": "Looks like the server you are using is core `http` with the req/res from uws.  That is probably never going to work.  You MIGHT be able to do it with the uws server.\r\n\r\nEDIT: looks like Doug beat me to it :)"
      }
    ]
  },
  {
    "number": 3167,
    "title": "Why is `new Layer(path...)` used inside `Router` instead of `Layer(path...)`",
    "created_at": "2017-01-05T08:19:21Z",
    "closed_at": "2017-01-06T01:12:10Z",
    "labels": [
      "4.x",
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/3167",
    "body": "I'm going through the source code and I've noticed the following. \r\nIn the `router/index.js` the layer is created like this:\r\n\r\n```\r\n    var layer = new Layer(path, {\r\n      sensitive: this.caseSensitive,\r\n      strict: false,\r\n      end: false\r\n    }, fn);\r\n```\r\nWhile, in `router/route` the layer is created like this:\r\n\r\n`      var layer = Layer('/', {}, handle);`\r\n\r\nBased on the implementation of `Layer`:\r\n\r\n```\r\nfunction Layer(path, options, fn) {\r\n  if (!(this instanceof Layer)) {\r\n    return new Layer(path, options, fn);\r\n  }\r\n```\r\nboth calls do the same. Why use different initializations?\r\n",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/3167/comments",
    "author": "maxkoretskyi",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2017-01-06T01:12:10Z",
        "body": "Honestly it's to get the code coverage up until Express 5.0 when this is already removed & addressed :)"
      }
    ]
  },
  {
    "number": 3148,
    "title": "Is this usecase recommended or discouraged?",
    "created_at": "2016-12-09T10:37:53Z",
    "closed_at": "2016-12-10T17:59:15Z",
    "labels": [
      "4.x",
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/3148",
    "body": "I created some modules for normalizing URLs in different ways (+ there are some others out there), so I would like to bundle them into a single module. This works right now:\r\n\r\n```js\r\napp.use((req, res, next) => {\r\n  req.app.use((req, res, next) => {\r\n    console.log(\"I am called!\");\r\n    next();\r\n  });\r\n  req.app.use((req, res, next) => {\r\n    console.log(\"Me too!\");\r\n    next();\r\n  });\r\n  console.log(\"Great\");\r\n  next();\r\n});\r\n```\r\n\r\nWhich correctly outputs:\r\n\r\n```\r\nGreat\r\nI am called!\r\nMe too!\r\n```\r\n\r\nHowever I worry that this is abusing express functionality/original intent. So I'd like to ask if this is frowned upon or perfectly valid within express' API.",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/3148/comments",
    "author": "franciscop",
    "comments": [
      {
        "user": "blakeembrey",
        "created_at": "2016-12-09T20:55:22Z",
        "body": "This is not a good way to do it, you're creating a memory leak by mounting applications every single request loop which means that for each request, you have one extra set of middleware mounted (and a new function for each middleware instance too == more memory overhead). \r\n\r\nIt sounds like what you want to do is to look up how Express routers work. It allows you to do this:\r\n\r\n```js\r\nconst router = express.Router();\r\n\r\nrouter.use((req, res, next) => {\r\n  console.log(\"I am called!\");\r\n  next();\r\n});\r\n\r\nrouter.use((req, res, next) => {\r\n  console.log(\"Me too!\");\r\n  next();\r\n});\r\n\r\napp.use(router);\r\n```\r\n\r\nBasically, you can create any instance you'd like and accept `(req, res, next)` - inside that you can do whatever you'd like - be that routing, request management, etc. I wouldn't mess with the application instance itself as you will create a memory leak adding too many instances of middleware."
      },
      {
        "user": "dougwilson",
        "created_at": "2016-12-10T01:18:36Z",
        "body": "And to build on what @blakeembrey said, from a strict sense of the question \"So I'd like to ask if this is frowned upon or perfectly valid within express' API.\": all of that is valid use of the Express API that is public & supported, though it does seem odd."
      }
    ]
  },
  {
    "number": 3136,
    "title": "res.redirect(404, '/path/') Not working. ",
    "created_at": "2016-11-21T23:00:49Z",
    "closed_at": "2016-11-21T23:09:51Z",
    "labels": [
      "4.x",
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/3136",
    "body": "This does not work.\r\n\r\n```res.redirect(404, '/path/to/404/page/')```\r\n\r\nThis does. \r\n\r\n```\r\nres.sendStatus(404)'\r\nres.redirect('/path/to/404/page/')\r\n```\r\n\r\nNot sure if that's by design in the case of a 404? Other status codes like `302` work fine. ",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/3136/comments",
    "author": "solocreativeco",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2016-11-21T23:09:51Z",
        "body": "In the first example, the response has a 404 status and basically no browser will do anything besides display the redirect page, as 4xx are not redirect codes.\r\n\r\nIn your second example, even though you put the status as 404, the redirect call will overwrite it with 302.\r\n\r\nUltimately it is up to the web browser to actually follow the redirect, and they will only do it for the redirect codes."
      }
    ]
  },
  {
    "number": 3107,
    "title": "unix socket support",
    "created_at": "2016-10-20T15:35:29Z",
    "closed_at": "2016-10-21T13:16:07Z",
    "labels": [
      "4.x",
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/3107",
    "body": "Is it possible to use express with unix socket instead of `host:port` ?\n\nThe `listen` signature just call underlying server `listen` method, so I tried with:\n\n``` node\nserver = require('net').createServer(express());\nserver.listen('/tmp/sock', function() {\n  fs.chmodSync('/tmp/sock', 0777);\n});\n```\n\nBut then when, through nginx, I try to access a page, express crashes with the following error:\n\n```\n[...]/node_modules/express/lib/router/index.js:140\n  var search = 1 + req.url.indexOf('?');\n                          ^\n\nTypeError: Cannot read property 'indexOf' of undefined\n    at Function.handle ([...]/node_modules/express/lib/router/index.js:140:27)\n    at EventEmitter.handle ([...]/node_modules/express/lib/application.js:173:10)\n    at Server.app ([...]/node_modules/express/lib/express.js:38:9)\n    at emitOne (events.js:77:13)\n    at Server.emit (events.js:169:7)\n    at Pipe.onconnection (net.js:1431:8)\n```\n",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/3107/comments",
    "author": "magne4000",
    "comments": [
      {
        "user": "LinusU",
        "created_at": "2016-10-20T15:55:57Z",
        "body": "I think that this is already supported:\n\n``` js\nconst express = require('express')\nconst app = express()\n\n// ...\n\napp.listen('/tmp/sock', () => {\n  console.log('Now listening on /tmp/sock')\n})\n```\n"
      },
      {
        "user": "hacksparrow",
        "created_at": "2016-10-20T17:39:10Z",
        "body": "@magne4000 you will need to use `http`, not `net`.\n"
      },
      {
        "user": "dougwilson",
        "created_at": "2016-10-21T02:42:13Z",
        "body": "Yes, @magne4000 , your code incorrectly used the `net` module; if you simply replace your `require('net')` with `require('http')` it works just fine. In addition, you can just pass in the socket path to `app.listen` and Express.js will handle the rest for you. I'm simply summarizing the great replies from @LinusU and @hacksparrow since there hasn't been a response. @magne4000 please let us know if this works for you and we can close the issue, otherwise we can try to figure out why you can't get your UNIX socket working.\n"
      },
      {
        "user": "magne4000",
        "created_at": "2016-10-21T07:31:26Z",
        "body": "Ok my bad ... it seems rather logical to use `http` instead of `net`.\nNow perhaps we need a note in `listen` documentation to mention that socket are also supported ?\n"
      }
    ]
  },
  {
    "number": 3098,
    "title": "Used app / router does not exec `params` middleware without call from within app / router",
    "created_at": "2016-10-12T05:11:05Z",
    "closed_at": "2016-10-12T05:47:40Z",
    "labels": [
      "4.x",
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/3098",
    "body": "I was just creating a router with only a param in it and found out the hard way that it doesn't execute in the `app` it's `app.use` in.\n\nHere's the code:\n\n``` js\nfunction myRouter () {\n  const router = Router({mergeParams: true})\n  router.param('appId', async (req, res, next, appId) => {\n    console.log('hi')\n    return next()\n  })\n  router.all('/:appId/*', (req, res, next) => {\n    return next()\n  })\n  return router\n}\n```\n\nThis will not log `hi` without.\n\n``` js\n  router.all('/:appId/*', (req, res, next) => {\n    return next()\n  })\n```\n\nWhich seems a bit unintuitive.\n",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/3098/comments",
    "author": "reggi",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2016-10-12T05:18:04Z",
        "body": "Right, the `router.param`s are confined to the router they were declared in. This is one of the purposes for creating new routers rather than reusing existing routers: because you want to create your own parameters. This allows for each router to have it's own parameter scope and allows for composability by not having routers interfere with each other.\n"
      }
    ]
  },
  {
    "number": 3086,
    "title": "Access native Node.js ClientRequest and ServerResponse objects",
    "created_at": "2016-09-14T07:43:51Z",
    "closed_at": "2016-09-14T07:59:15Z",
    "labels": [
      "4.x",
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/3086",
    "body": "Hello there! Sorry if this question was raised before. How can I access native Node.js request and response objects? For example in `koa` it's possible through getters `context.req = request.req = response.req` and `context.res = request.res = response.res` for request and response respectively.\n\nThanks\n",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/3086/comments",
    "author": "roman-vanesyan",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2016-09-14T07:54:47Z",
        "body": "The only objects are the native ones, just we added our own methods and properties to them.\n"
      },
      {
        "user": "roman-vanesyan",
        "created_at": "2016-09-14T07:58:52Z",
        "body": "Thanks, I just poorly looked into the documentation and didn't notice the note:\n\n```\nThe req object is an enhanced version of Node\u2019s own request object and supports all built-in fields and methods.\n```\n"
      }
    ]
  },
  {
    "number": 3082,
    "title": "Set max SSL fragment size in Express",
    "created_at": "2016-09-11T03:38:22Z",
    "closed_at": "2016-09-12T13:14:49Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/3082",
    "body": "I'm using express to set up an HTTPS server for some embedded devices. However, due to the lack of computing capabilities, the default SSL fragment size 16384 is too large for these devices. I wonder how I can change this size in express.\nI found that in tls modules, TLSSocket class has a method _tlsSocket.setMaxSendFragment(size)_ which may work, but I can't find out how to use it in Express.\nThis is how my server is established:\n\n```\nvar app = require('express')();\nvar cert_path = '/home/houlu/Programs/Node/http/ssl/';\nvar privateKey = fs.readFileSync(cert_path+'server.key', 'utf8');\nvar certificate = fs.readFileSync(cert_path+'server.crt', 'utf8');\nvar credentials = {key: privateKey, cert: certificate};\n\nhttpsServer = https.createServer(credentials, app);\n```\n\nThanks a lot!  :-)\n",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/3082/comments",
    "author": "houluy",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2016-09-11T03:52:30Z",
        "body": "Since this is a socket-level option, this would be handled outside of Express, since Express is request/response-level (multiple request/response pairs can share a single socket).\n\nI think the following would work (not 100% sure, as the Node.js documentation isn't very clear, and I'm not at a computer to test), assuming you wanted all sockets to have this setting:\n\n``` js\nvar app = require('express')();\nvar cert_path = '/home/houlu/Programs/Node/http/ssl/';\nvar privateKey = fs.readFileSync(cert_path+'server.key', 'utf8');\nvar certificate = fs.readFileSync(cert_path+'server.crt', 'utf8');\nvar credentials = {key: privateKey, cert: certificate};\n\nvar httpsServer = https.createServer(credentials, app);\n\nhttpsServer.on('connection', function (tlsSocket) {\n  tlsSocket.setMaxSendFragment(/* whatever size */);\n});\n```\n"
      },
      {
        "user": "houluy",
        "created_at": "2016-09-11T12:41:19Z",
        "body": "Thanks a lot, I'll have a try and let you know the results.\nBesides, I think it should be 'secureConnection' instead of 'connection' in HTTPS context.\n:)\n"
      }
    ]
  },
  {
    "number": 3058,
    "title": "express.Router()",
    "created_at": "2016-08-17T06:43:11Z",
    "closed_at": "2016-08-17T06:53:26Z",
    "labels": [
      "4.x",
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/3058",
    "body": "A function with a name starting with an uppercase letter should only be used as a constructor.\n\nThe sentence `const router = express.Router();` issues with AirBnb eslint.\n",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/3058/comments",
    "author": "cuni0716",
    "comments": [
      {
        "user": "blakeembrey",
        "created_at": "2016-08-17T06:47:42Z",
        "body": "Can you provide more context? This isn't really a bug, just an issue with your chosen linting. Why not just use `new`?\n"
      },
      {
        "user": "dougwilson",
        "created_at": "2016-08-17T06:53:26Z",
        "body": "Yea, looks like a non-issue to me :) `express.Router` _is a constructor_; you can do `new express.Router()`. The `new` is optional, just like many of the object constructors in JavaScript itself (i.e. `Error('oh no!')` and `new Error('oh no!')` are identical, as the `new` keyword is optional).\n"
      }
    ]
  },
  {
    "number": 2969,
    "title": "Parse Json Strings",
    "created_at": "2016-04-13T16:42:02Z",
    "closed_at": "2016-04-13T17:05:43Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/2969",
    "body": "The solution provided in #2460 does not work. Returns \n`URIError: URI malformed`\n\nIn my case for example, my queries should be something of the sort:\n\n`where={%22name%22:%20{%22$like%22:%20%22%bari%22}}`\n\nWhich translates to: \n\n`\n\"where\": {\n  \"name\": {\n    \"$like\": \"%bar\"\n  }\n}\n`\n\nAny help would be appreciated. #2460 is the most similar problem I could find but did not work for me.\n",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/2969/comments",
    "author": "ybrodsky",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2016-04-13T17:05:43Z",
        "body": "Hi! The solution works, just your URI itself is invalid. You have a literal `%` in there, and `%` has a special meaning in a URI, so it has to be encoded. The correct query string should look like the following:\n\n```\nwhere={%22name%22:%20{%22$like%22:%20%22%25bar%22}}\n```\n"
      },
      {
        "user": "ybrodsky",
        "created_at": "2016-04-13T17:17:34Z",
        "body": "Thanks for the help.\nYou were right, nevertheless I am getting a different error now. \n`SyntaxError: Unexpected token w`\n\nIt's because of the 'where=' part when it tries to parse the json object. \nAny idea how could I go around this, without getting rid of the 'where='\n"
      },
      {
        "user": "dougwilson",
        "created_at": "2016-04-13T17:20:53Z",
        "body": "If you are actually using a query string with name value pairs, then the issue you referenced actually didn't have anything to do with your issue :) You can just use the `req.query` object and parse the string that is in the `where` property:\n\n``` js\nvar obj = JSON.parse(req.query.where)\n```\n"
      }
    ]
  },
  {
    "number": 2911,
    "title": "Modifying req.params",
    "created_at": "2016-02-26T12:39:43Z",
    "closed_at": "2016-02-26T14:21:10Z",
    "labels": [
      "4.x",
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/2911",
    "body": "I am having some issues adding properties to `req.params`. It seems the params get wiped out when stepping to the next middleware:\n\n```\nfunction foobarRouter(type) {\n  var router = express.router();\n  router.use(function (req, res, next) {\n    req.params.type = type;\n    next();\n  });\n  router.get('/',         renderPage('foobars'));\n  router.get('/new',      renderPage('foobar_edit'));\n  router.get('/:id',      renderPage('foobar'));\n  router.get('/:id/edit', renderPage('foobar_edit'));\n}\napp.use('/foo', foobarRouter('foo'));\napp.use('/bar', foobarRouter('bar'));\n```\n\nDespite explicitly setting `req.params.type`, it is undefined in `renderPage`.\n\nI had a look at `mergeParams: true`, but it seems that this only preserves the params from the parent, which doesn't work in this case because the parent (the `app.use`) doesn't have any real params.\n\nIt would work if I did, `app.use('/:type', foobarRouter());`, but the route needs to be restricted to specific types only.\n\nHow can I modify the `req.params` for a sub-router so that it looks like they came from the parent?\n\nThanks.\n",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/2911/comments",
    "author": "SystemParadox",
    "comments": [
      {
        "user": "tunniclm",
        "created_at": "2016-02-26T13:28:13Z",
        "body": "AFAIK `req.params` is populated by the route based on `:` tokens or regexp  capture groups within the route definition and is not for storing general values. Typically middleware will store values as properties directly on the `req` object. Be careful not to chose a property that clashes with the base request object or any other middleware you are using though.\n"
      },
      {
        "user": "SystemParadox",
        "created_at": "2016-02-26T14:08:17Z",
        "body": "Adding properties directly to the `req` object isn't any better than passing them to `renderPage` directly, I still have to handle them manually.\n\nIt's a bit frustrating that params can only be added by the URL parser and not in code anywhere.\n"
      },
      {
        "user": "dougwilson",
        "created_at": "2016-02-26T14:21:10Z",
        "body": "Hi @SystemParadox, in your example, you are actually modifying `req.params` just fine, but perhaps asking the question \"where did the object `req.params` come from?\" may help understand why your modification disappears in another route.\n\n`req.params` is not like `res.locals`, which is a global object set at the start of Express, rather `req.params` is actually being set as a result of the URL parse. This means that when you where in `router.use(function (req, res, next) {`, the `req.params` object was the result of parsing the URL against `/\\/?/`, which means `req.params = {}`.\n\nNow, you adding a new property to that object in your middleware, which is nice and all, and actually continues to exist... until the next URL parse, because guess what? Express needs to signal what params it found on the current URL parse.\n\nYour code example is not enough to understand the goal you are trying to achieve by setting `req.params.type`, but perhaps you want to use `res.locals.type` instead, as this is one of the global bags Express provides for you to store things between middlewares and routes.\n\n**Edit** Meant `res.locals`, but accidentally originally wrote `req.locals`.\n"
      },
      {
        "user": "SystemParadox",
        "created_at": "2016-02-26T15:45:02Z",
        "body": "Yes I realise why the `req.params` is being overwritten. However, there is `mergeParams: true` which is half way there, I'm just unable to manually set the params early enough for `mergeParams` to work.\n\nWhat I'm trying to achieve is something akin to this:\n\n```\nvar router = express.Router({ mergeParams: true });\napp.use('/:type', router);\n```\n- (Where `:type` is available to handlers defined on `router`)\n- **BUT** the router should only be traversed for specific types, because there is no way to back-out of a sub-router once in it (apart from making none of the routes inside it match, which is pointless)\n\nI was hoping I was just missing something, but at the moment it seems like this is not possible. I guess I will just have to do it the less concise way. I'm not even sure what changes I would propose to make express handle this, unless anyone else has any suggestions?\n\nThanks.\n"
      },
      {
        "user": "dougwilson",
        "created_at": "2016-02-26T16:00:01Z",
        "body": "Hi @SystemParadox, from your description of the goal, it sounds like what you want is the following:\n\n``` js\nvar router = express.Router({ mergeParams: true });\napp.use('/:type', typeRouter('foo', router)); // only runs router when /foo\n\nfunction typeRouter(type, router) {\n  return function (req, res, next) {\n    if (req.params.type !== type) return next();\n    router(req, res, next);\n  };\n}\n```\n"
      },
      {
        "user": "dougwilson",
        "created_at": "2016-02-26T16:04:32Z",
        "body": "The `mergeParams` in my example is not needed for it to function, I just included it because you had it. It would only be necessary if you wanted `req.params.type === 'foo'` inside the router itself. The example is also the exact way Express is design to handle the use-case you've provided, and ideally at some point these kinds of design patterns that Express looks for can be documented, as it's only discover-able currently once you fully understand the concepts of Express.\n"
      },
      {
        "user": "tunniclm",
        "created_at": "2016-02-26T16:06:27Z",
        "body": "@dougwilson Would `app.use('/:type(foo|bar)', router);` also be a reasonable solution?\n"
      },
      {
        "user": "dougwilson",
        "created_at": "2016-02-26T16:08:51Z",
        "body": "@tunniclm, indeed! Didn't even think about that :) That's even simpler if the reduced regular expressions provides the necessary match :)\n"
      }
    ]
  },
  {
    "number": 2910,
    "title": "Blank PDF when served from Express",
    "created_at": "2016-02-25T20:31:06Z",
    "closed_at": "2016-02-25T21:51:56Z",
    "labels": [
      "4.x",
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/2910",
    "body": "Similar to #1555 but that one was closed so not sure if my comment will get any attention.\nCopying my comment from there.\n\nI am running into similar issue with my first ever nodejs service. I have following:\n\n``` javascript\n\nvar headers = {} \n///Setting some custom headers for authentication\n\nvar urlObj = new URL( url );\nvar options = {\n            host: urlObj.host,\n            path: urlObj.pathname + urlObj.query,\n            headers: headers\n };\n http.get( options, function( response ) {\n            var body = '';\n            response.on( 'data', function( data ) {\n                body += data;\n             } );\n\n             response.on( 'end', function() {\n                  res.set( 'Content-Type', 'application/pdf' );\n                  res.send( new Buffer( body, 'binary' ) );\n             } );\n } );\n```\n\nBut I see a blank PDF with the correct number of pages and browser renders it as a PDF but all pages are empty.\nAccessing the `url` directly shows the right pdf so the pdf is fine.\nAny input will be really appreciated.\n\nThanks\n",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/2910/comments",
    "author": "vinodmehta",
    "comments": [
      {
        "user": "wesleytodd",
        "created_at": "2016-02-25T21:40:20Z",
        "body": "For stuff like this I usually use the `request` module, you could try something like this:\n\n``` javascript\nvar request = require('request');\nvar app = require('express')();\n\napp.get('/my-pds.pds', function (req, res) {\n  var opts = {} // ...\n  request.get(opts).pipe(res);\n});\n```\n\nRequest and express handle the rest.\n\nAlso, fyi, people who follow the repo also get notifications for comments on closed issues, so your other comment would get seen.\n"
      },
      {
        "user": "dougwilson",
        "created_at": "2016-02-25T21:51:56Z",
        "body": "And of course, just to iterate on the answer from @wesleytodd, hopefully his answer should fix your issue, @vinodmehta. The reason you are seeing odd behavior is because the way you are piping the PDF file ends up corrupting the file, because the operation `body += data;` will actually cause the `data` Buffer to get decoded as if it was UTF-8 into a string, which will corrupt binary data.\n\nThe `request` module is a really good approach, and I would recommend that, as it's very straight-forward and simple :)\n\nIf you wanted to tweak your original code to see where you went wrong, here is a simple tweak that should address the binary data corruption:\n\n``` js\nvar headers = {} \n///Setting some custom headers for authentication\n\nvar urlObj = new URL( url );\nvar options = {\n            host: urlObj.host,\n            path: urlObj.pathname + urlObj.query,\n            headers: headers\n };\n http.get( options, function( response ) {\n            var body = []; // we're going to store all the chunks of binary data\n            response.on( 'data', function( data ) {\n                body.push(data); // build up an array of Buffers\n             } );\n\n             response.on( 'end', function() {\n                  res.set( 'Content-Type', 'application/pdf' );\n                  res.send( Buffer.concat(body) ); // join all the buffers together as a binary blob\n             } );\n } );\n```\n"
      },
      {
        "user": "vinodmehta",
        "created_at": "2016-02-26T00:03:53Z",
        "body": "Thanks. Yes `request` module really simplified the code a lot to basically one liner.\n\n``` javascript\nrequest.get( { url: url, headers: headers } ).pipe( res );\n```\n"
      }
    ]
  },
  {
    "number": 2830,
    "title": "charset=utf8 inserted between two phrase media type in response header",
    "created_at": "2015-12-17T23:32:52Z",
    "closed_at": "2015-12-17T23:56:07Z",
    "labels": [
      "3.x",
      "4.x",
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/2830",
    "body": "Hi,\n\nExpress is mangling the response header I'm trying to set for a two phrase media type\n\nWe are establishing a HATEOAS convention where we have a generic collection type, designated as a vnd, and various media types which might be collected there, also a vnd. \n\n```\nres.set('content-type', 'application/vnd.samcorp.collection;content=\"application/vnd.samcorp.foo\"');\n\n```\n\nRead this as - we are sending you a samcorp collection of samcorp.foos. \n\nExpress renders the header as:\n\n```\nHTTP/1.1 200 OK\nX-Powered-By: Express\nContent-Type: application/vnd.samcorp.collection; charset=utf-8; content=\"application/vnd.samcorp.foo\"\n...\n```\n\nIs there a way I can get rid of the intruding charset header?\n\nIt's worth noting that I had to do a lot of googling to discover how to include the content specifier. Using what is below results in an invalid parameter error from Express, so the double quotations in what was above became necessary.\n\n```\n res.set('content-type', 'application/vnd.samcorp.collection;content=application/vnd.samcorp.foo');\n\n```\n\nThanks,\nNicholas\n",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/2830/comments",
    "author": "nicholasf",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2015-12-17T23:56:06Z",
        "body": "Hi! This is expected behavior and is 100% to the HTTP specification to how the `Content-Type` header works. If your client is confused by the re-formatting, then it has a buggy implementation and does not follow the HTTP specifications correctly.\n\nThat said, if you simply want to avoid us adding the `charset` parameter to your `Content-Type` header, you have to methods:\n1. Provide a `Buffer` object to `res.send` instead of a string. We will not add the `charset` parameter, because we are not doing any encoding to your response.\n2. Skip using `res.send` altogether and use the lower-level Node.js `res.write`/`res.end` methods.\n\nI hope this helps!\n"
      },
      {
        "user": "dougwilson",
        "created_at": "2015-12-18T00:03:59Z",
        "body": "No problem! This is a case where Express is adding sugar through things like `res.send` and `res.json`, and trying to ensure that your responses are a spec-compliant as possible (which is why you also had to quote the second type, as it contained characters that were not valid as a parameter value unless quoted), is conflicting with something you are trying to achieve.\n\nThe way we usually recommend attacking this is to report here so we can double-check that it makes sense from a spec point-of-view (which it looks like it does based on your report) and offer the methods to avoid the sugar :)\n"
      }
    ]
  },
  {
    "number": 2770,
    "title": "Each request is calling linux stat",
    "created_at": "2015-09-30T14:39:19Z",
    "closed_at": "2015-09-30T16:42:58Z",
    "labels": [
      "4.x",
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/2770",
    "body": "Hi,\nWe added some monitoring to our servers lately after finding some unexpected latency on some times, and saw on our calls to the servers latency is caused by calling linux stat command.\nWe are still investigating to see if this may be related to other used services, but can it be express related issue? \n",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/2770/comments",
    "author": "eranbrill",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2015-09-30T14:47:54Z",
        "body": "The express.static will call stat to see if a file exists or not. If you are using express.static to serve files, then yes, you will see a stat. Ideally your express.static should be .use()d after your routes to avoid unnecessary stat calls.\n"
      }
    ]
  },
  {
    "number": 2740,
    "title": "Middleware conflicts - question",
    "created_at": "2015-08-21T19:20:01Z",
    "closed_at": "2015-08-21T19:23:40Z",
    "labels": [
      "4.x",
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/2740",
    "body": "Following scenario:\n\n``` js\nvar middlewre = function(){\n    return function(req, res, next){\n        // do somthing\n        next();\n   }\n}\n```\n\nthen you use it twice:\n\n``` js\napp.use('/', middleware());\napp.use('/SomePath', middleware());\n```\n\nIf request comes to '/SomePath' the middleware will run twice. does it make sense? I would expect that '/' is superset and the middleware will run only once.\n",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/2740/comments",
    "author": "kfiron",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2015-08-21T19:23:40Z",
        "body": "Hi! Yes, this is exactly as designed. We always run in declared order, and do not do anything special for de-duplicating or prioritizing in the default router.\n\nIf you need them to only run once, the solution we offer is to attach a flag to `req` or similar:\n\n``` js\nvar middlewre = function(){\n    return function(req, res, next){\n        if (req.middlewareRan) return next();\n        req.middlewareRan = true;\n        // do somthing\n        next();\n   }\n}\n```\n"
      }
    ]
  },
  {
    "number": 2707,
    "title": "Is there a way to let exceptions bubble up instead of passing to finalhandler",
    "created_at": "2015-07-16T03:55:04Z",
    "closed_at": "2015-07-16T04:03:00Z",
    "labels": [
      "4.x",
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/2707",
    "body": "I'm trying to do some exception handling in my app built on express and it's being problematic that every time I throw an exception it gets printed to the screen.\n\nIs this configurable?\n",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/2707/comments",
    "author": "ericuldall",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2015-07-16T03:56:09Z",
        "body": "Are you talking about getting printed to your web browser, or to the console you are running Node.js on?\n"
      },
      {
        "user": "ericuldall",
        "created_at": "2015-07-16T04:01:54Z",
        "body": "basically i'm using `process.on('uncaughtException')` and my thrown errors aren't getting there.\n"
      },
      {
        "user": "dougwilson",
        "created_at": "2015-07-16T04:03:00Z",
        "body": "The main two configurations are the following:\n\n``` js\n// don't print errors on your node console window\napp.set('env', 'test')\n\n// don't print errors to your web browser\napp.set('env', 'production')\n```\n\nBy default Express assumes development mode, which is what causes the stack traces to head to your web browser.\n\nAlso by default, Express will dump stack traces to your STDERR handle, which is standard when running the server and redirecting STDERR to an error log (as in `node app.js 2> error.log`).\n\n> I think you just addressed this question on finalhandler issues. Does that answer stand?\n\nYes, it does :) especially if you want it to be extremely configurable :) Another thing you can do is the following to use `finalhandler` but turn those two features off:\n\n``` js\nvar express = require('express')\nvar finalhander = require('finalhandler')\nvar http = require('http')\n\nvar app = express()\n\n// declare things on app\n\nvar server = http.createServer(function (req, res) {\n  app(req, res, finalhandler(req, res, {\n    env: 'production', // no stack traces; option name will be better in 1.0\n    onerror: function (err) {\n      throw err; // rethrow to your uncaughtException handler, but i _highly_ don't suggest this\n    }\n  }))\n})\n\nserver.listen(3000)\n```\n"
      }
    ]
  },
  {
    "number": 2669,
    "title": "IP address as a url param error",
    "created_at": "2015-06-03T17:47:46Z",
    "closed_at": "2015-06-03T19:36:35Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/2669",
    "body": "When declaring an IP address as a URL parameter `req.params` incorrectly parses the value. \n\nAdd the following param to the URL  `:ip((?:[0-9]{1,3}\\.){3}[0-9]{1,3})`\n\nUse the value 192.168.1.2 for ip\n\nThen check  `req.params.ip` it will return as 1. \n\n```\nconsole.log('req.originalUrl',req.originalUrl);\nconsole.log('(req.params.ip',req.params.ip);\n```\n",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/2669/comments",
    "author": "DaleCox",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2015-06-03T17:54:54Z",
        "body": "Hi, Can you supply a full app that reproduces the error (as there are many things that can influence this?\n\nAlso, it may just be because your param definition does not work with `path-to-regexp` module. Try using `:ip([0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3})`\n"
      },
      {
        "user": "dougwilson",
        "created_at": "2015-06-03T23:58:33Z",
        "body": "Gotcha. If the updated reg ex worked, then it looks like it's just a limitation in `path-to-regexp` that we use, which is what I thought (you cannot use `(?:` in the reg ex).\n"
      }
    ]
  },
  {
    "number": 2659,
    "title": "params in middleware not work",
    "created_at": "2015-05-24T05:41:16Z",
    "closed_at": "2015-05-24T05:46:51Z",
    "labels": [
      "4.x",
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/2659",
    "body": "I have a router with a middleware for manage entry , but not recognize all params from the request,\n\nby example  I have a route like /:username/:idMessage , then the middleware only recognize the username param but not the idMessage\n\n``` javascript\nvar router = express.Router({mergeParams: true});\nrouter.use(function (req, res, next) {\n    console.log(req.params.username);\n    //juliocanares\n\n    console.log(req.params.idMessage);\n    //undefined\n\n    next();\n});\n\n//localhost:3000/juliocanares\nrouter.get('/', function (req, res) {\n    console.log(req.params.username);\n    //juliocanares\n    return res.json({username: req.params.username});\n});\n\n//localhost:3000/juliocanares/10\nrouter.get('/:idMessage', function (req, res) {\n    console.log(req.params.idMessage);\n    //10\n    return res.json({idMessage: req.params.idMessage});\n});\n\napp.use('/:username', router);\n```\n",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/2659/comments",
    "author": "juliocanares",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2015-05-24T05:46:51Z",
        "body": "This is working as designed. Your `router` will only ever see the params as defined for it, and in your example, this is `app.use('/:username', router);`, thus `router` will only ever have `req.params.username`.\n"
      },
      {
        "user": "dougwilson",
        "created_at": "2015-05-24T05:48:00Z",
        "body": "You can always redefine\n\n``` js\nrouter.use(function (req, res, next) {\n    console.log(req.params.username);\n    //juliocanares\n\n    console.log(req.params.idMessage);\n    //undefined\n\n    next();\n});\n```\n\nto be the following instead:\n\n``` js\nrouter.use('/:idMessage', function (req, res, next) {\n    console.log(req.params.username);\n    //juliocanares\n\n    console.log(req.params.idMessage);\n    //10\n\n    next();\n});\n```\n"
      }
    ]
  },
  {
    "number": 2595,
    "title": "/lib/response.js -> undefined is not a function at this.get()",
    "created_at": "2015-03-16T02:14:46Z",
    "closed_at": "2015-03-16T02:20:37Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/2595",
    "body": "I honestly don't even know what information to provide.\nAll I know is my stack trace says:\n\n_Possibly unhandled TypeError: undefined is not a function... lib\\response.js:130:17_\n\nI am using _bluebird_ promise library and the error is being generated when I try:\n\n```\n.then(response.send, next);\n```\n\nbut not when I do:\n\n```\n.then(function(result) {\n    response.send(result)\n}, next);\n```\n",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/2595/comments",
    "author": "lukeavsec",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2015-03-16T02:19:07Z",
        "body": "I'm also unsure. Best thing for both of us would be if you could provide an app that reproduces this issue that I can cut-and-paste and run on my own machine. Please note the versions of Bluebird, Express, and Node.js you are seeing this in as well. I honestly don't know anything about Bluebird, but if I could run this on my local, I can probably figure it out. It may be an issue here, or it could simply be an issue of using Bluebird incorrectly.\n"
      },
      {
        "user": "dougwilson",
        "created_at": "2015-03-16T02:20:36Z",
        "body": "Oh, spoke to soon, I figured it out: you're just using JavaScript itself incorrectly. See, `.send` is a method, so you cannot pass it like a function. Your line should be:\n\n``` js\n.then(response.send.bind(response), next);\n```\n"
      }
    ]
  },
  {
    "number": 2593,
    "title": "Router mergeParams=true does not work ",
    "created_at": "2015-03-14T17:41:11Z",
    "closed_at": "2015-03-14T17:57:04Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/2593",
    "body": "express 4.12.2. According to the Router doc about `mergeParams` option:\n\n> Preserve the `req.params` values from the parent router. If the parent and the child have conflicting param names, the child\u2019s value take precedence.\n\nMay be I miss something, but it does not behave in that way at all:\n\n``` javascript\nvar express = require('express');\nvar app = express();\n\n\napp.get('/users/:username', function(req, res, next) {\n        console.log('> app.get');\n\n    if (req.params.username !== 'alice') {\n        throw new Error('app.get: username != alice');\n    }\n\n    next();\n});\n\nvar router1 = express.Router({mergeParams: true});\napp.use(router1);\n\nrouter1.get('*', function(req, res, next) {\n        console.log('> router1.get');\n\n        // This throws.  \n    if (req.params.username !== 'alice') {\n        throw new Error('router1.get: username != alice');\n    }\n\n    next();\n});\n\napp.listen(5000, '0.0.0.0');\n```\n\nNow send a GET request with url \"/users/alice\" and it will print:\n\n```\n> app.get\n> router.get\nError: router1.get: username != alice\n```\n",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/2593/comments",
    "author": "ibc",
    "comments": [
      {
        "user": "ibc",
        "created_at": "2015-03-14T17:55:55Z",
        "body": "May be `mergeParams` just work when declaring a named param in the mount path of the router?\n"
      },
      {
        "user": "dougwilson",
        "created_at": "2015-03-14T21:17:08Z",
        "body": "> Yes, sorry for the noise.\n\nI'm not sure if there is such thing as \"noise\" :) So to answer this, what `mergeParams` does is merge any `req.params` that _exists at the time the router is entered_. The reason it wasn't doing anything in your example above is because `app.use(router1);` does not have any parameters. You can see this by doing something like `app.use(function (req, res, next) { console.dir(req.params); next() })` and seeing it as nothing there.\n\nTo expand on your example, there are two possible solutions to achieve this, and the correct one for your situation depends on exactly how you are looking for the sub router to behave:\n\n``` js\nvar express = require('express');\nvar app = express();\n\napp.get('/users/:username', function(req, res, next) {\n        console.log('> app.get');\n\n    if (req.params.username !== 'alice') {\n        throw new Error('app.get: username != alice');\n    }\n\n    next();\n});\n\nvar router1 = express.Router({mergeParams: true});\n// now router1 will actually inherit parameters, since it's defined on a path with them\napp.all('/users/:username', router1);\n\nrouter1.get('*', function(req, res, next) {\n        console.log('> router1.get');\n\n    if (req.params.username !== 'alice') {\n        throw new Error('router1.get: username != alice');\n    }\n\n    next();\n});\n\napp.listen(5000, '0.0.0.0');\n```\n"
      },
      {
        "user": "seyedasfar",
        "created_at": "2019-04-14T09:28:33Z",
        "body": "What is the purpose of using mergeParams?"
      },
      {
        "user": "abdoerrahiem",
        "created_at": "2020-07-07T09:08:42Z",
        "body": "> What is the purpose of using mergeParams?\r\n\r\nto use route in another route"
      }
    ]
  },
  {
    "number": 2566,
    "title": "Is there a way to register a function/layer after the app.get function",
    "created_at": "2015-02-24T08:35:45Z",
    "closed_at": "2015-03-01T08:31:43Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/2566",
    "body": "I want to do the cleanup thing after each get or post route is done, since `route.use` is called before the `route.$httpmethod`, so I wonder is there a way to register a function which is called **_after**_ the `route.$httpmethod`.\n",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/2566/comments",
    "author": "louis-she",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2015-03-01T04:08:00Z",
        "body": "So, there currently isn't really a built-in way, since all Express offers is to run a bunch of functions in a specific order. You can accomplish this using something like the `on-finished` module, though:\n\n``` js\nvar onFinished = require('on-finished')\n\n// Put this _before_ your routes\napp.use(function (req, res, next) {\n  onFinished(res, function () {\n    // Perform cleanup here, which is fired after any response that passes through this middleware\n  })\n  next()\n})\n```\n"
      }
    ]
  },
  {
    "number": 2531,
    "title": "Loosing params consistency in child routes with mergeParams",
    "created_at": "2015-02-06T14:00:29Z",
    "closed_at": "2015-02-06T14:15:55Z",
    "labels": [
      "4.x",
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/2531",
    "body": "Hi folks,\n\nI'm facing an issue which is that if I nest 2 routers like in the example below, my modifications on the `req.params` object are not kept in the child route. Any thought on how to resolve it ?\n\n``` js\nvar express = require('express');\n\nmodule.exports = function(app) {\n\n    var myRouter = express.Router();\n    var mySpecificRouter = express.Router({\n        mergeParams: true\n    });\n\n    myRouter.all('*', app.requestHelper.verifyToken);\n\n    myRouter.route('/')\n        .get(app.controller.my.list);\n\n    myRouter\n        .use('/:id', function(req, res, next) {\n            if (/^[0-9]+$/.test(req.params.id)) {\n                console.log('parent params before parsing', req.params);\n                req.params.id = parseInt(req.params.id, 10);\n                console.log('parent params', req.params);\n                next();\n            } else {\n                app.status(400).send({error:'bad request'});\n            }\n        }, mySpecificRouter);\n\n    mySpecificRouter\n        .route('/')\n        .get(function(req, res, next) {\n            console.log('child params', req.params);\n            app.status(200).send({});\n        });\n\n    app.use('/route', myRouter);\n};\n```\n\nSo the console log of a get request on /route/101 give me the following:\n\n```\nparent params before parsing {id: '100'}\nparent params {id: 100}\nchild params {id: '101'}\n```\n\nWhen I check in the `parentParams` in the index of the router I see the original object instead of the altered one...\n\nThanks !\n",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/2531/comments",
    "author": "YouriT",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2015-02-06T14:15:55Z",
        "body": "It's because `req.params` is not just a \"bag-o-things\"; you have to modify it within a `app.param`/`router.param` declaration, rather than a `.use()`:\n\n``` js\nvar express = require('express');\n\nmodule.exports = function(app) {\n\n    var myRouter = express.Router();\n    var mySpecificRouter = express.Router({\n        mergeParams: true\n    });\n\n    myRouter\n        .param('id', function(req, res, next, val) {\n            if (/^[0-9]+$/.test(val)) {\n                console.log('parent params before parsing', req.params);\n                req.params.id = parseInt(req.params.id, 10);\n                next();\n            } else {\n              res.status(400).send({error:'bad request'});\n            }\n        })\n        .use('/:id', mySpecificRouter);\n\n    mySpecificRouter\n        .route('/')\n        .get(function(req, res, next) {\n            console.log('child params', req.params);\n            res.status(200).send({});\n        });\n\n    app.use('/route', myRouter);\n};\n```\n"
      }
    ]
  },
  {
    "number": 2529,
    "title": "Deprecated message thrown when using res.status",
    "created_at": "2015-02-04T05:12:05Z",
    "closed_at": "2015-02-04T05:24:28Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/2529",
    "body": "I have been aware that since express@4.x, `res.send(201, obj)` format has been deprecated. But I am running into a situation where in 4.x I would want to send an `id` back, as shown as follows:\n\n``` js\nvar app = express();\n\napp.use(function(req, res) {\n  res.statusCode(201).send(1111); // where this is the ID.\n});\n\nrequest(app)\n   .get('/')\n   .expect(1111)\n   .expect(201, done);\n```\n\nBut I would get the deprecated message:\n\n`express deprecated res.send(status)`\n\nI was wondering if how should I approach this situation in `express` where I would want to send an integer back without having to do the following:\n\n``` js\napp.use(function(req, res) {\n  res.statusCode(201).send({ id: 1111 }); // where this is the ID.\n});\n```\n",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/2529/comments",
    "author": "limianwang",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2015-02-04T05:19:12Z",
        "body": "It's an unfortunate edge-case, and a prime sample of why this is deprecated :) `res.send(1111)` actually tries to send a response with the status code of 1111. To signify that you want the number as the body, simply wrap it in `String`: `res.status(201).send(String(1111))`; if you wanted to send JSON, `res.status(201).json(1111)`\n"
      },
      {
        "user": "dougwilson",
        "created_at": "2015-02-04T05:24:28Z",
        "body": "No problem. It wound be necessary even if there was no deprecation at all :) The deprecation means that it finally _won't_ be necessary in 5.0 :D\n"
      }
    ]
  },
  {
    "number": 2510,
    "title": "route can not use in chinese",
    "created_at": "2015-01-23T04:09:55Z",
    "closed_at": "2015-01-23T05:16:57Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/2510",
    "body": "work good/articles/:type(%E8%B6%8B%E5%8A%BF|%E8%A7%82%E7%82%B9|%E6%A1%88%E4%BE%8B)\n\nwrong:   /articles/:type(\u8d8b\u52bf|\u89c2\u70b9|\u6848\u4f8b)?\n",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/2510/comments",
    "author": "suzukua",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2015-01-23T04:16:39Z",
        "body": "When you put strings in the path, they are matches against the literal URL, rather than the decoded component. You can use `req.param` to validate against the decoded value as a work-around:\n\n``` js\napp.param('type', function (req, res, next, val) {\n  var match = type === '\u8d8b\u52bf' || type === '\u89c2\u70b9' || type === '\u6848\u4f8b'\n  next(match ? null : 'route')\n})\n\napp.get('/articles/:type', function (req, res) {\n  res.end()\n})\n```\n"
      }
    ]
  },
  {
    "number": 2392,
    "title": "Deprecated should only log once",
    "created_at": "2014-10-11T14:13:27Z",
    "closed_at": "2014-10-11T14:17:00Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/2392",
    "body": "We're seeing a lot of\n\n```\nexpress deprecated res.send(status, body): Use res.status(status).send(body) instead at node_modules/toobusy-middleware/index.js:76:13\n```\n\nin our logs. It'd be great if express would only log this once, and state something like 'logging of this deprecation warning is now turned off' to avoid filling the logs with nothing but deprecated warnings.\n\nThanks!\n",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/2392/comments",
    "author": "analytically",
    "comments": [
      {
        "user": "analytically",
        "created_at": "2014-10-11T14:17:00Z",
        "body": "NO_DEPRECATION=express, nevermind :-)\n"
      },
      {
        "user": "dougwilson",
        "created_at": "2014-10-11T15:08:11Z",
        "body": "Yes, that will suppress it :) As for frequency, it logs once per call site (of course, per process as well). This means if the deprecated call occurs in 50 different places, it'll log all 50 of them, which allows them to be fixed without just see the fist n, fixing those, restarting, fixing the next n, and repeating that over and over.\n\nThough I assume those are coming from a module you did not create, correct?\n"
      },
      {
        "user": "dougwilson",
        "created_at": "2014-10-11T18:41:19Z",
        "body": "Thanks :) But yea, I asked because I think I should update depd such that if you are using a module you don't control the code for, you probably don't event want to see warnings from it, since you cannot take action to correct them.\n"
      },
      {
        "user": "analytically",
        "created_at": "2014-10-11T18:43:56Z",
        "body": "Well I sorta do want to see them (in dev), since then I can potentially fork or create an issue and hope. The deprecation might hide a performance issue. For me NO_DEPRECATION solves this nicely, since I can set that in production.\n"
      }
    ]
  },
  {
    "number": 2387,
    "title": "Router: Cannot use literal characters \\] and \\) in Regex",
    "created_at": "2014-10-09T14:17:28Z",
    "closed_at": "2014-10-09T15:04:34Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/expressjs/express/issues/2387",
    "body": "I know is horrible having special characters in URLs but I sadly have to manage them, so I tried to use this route:\n\n``` javascript\nrouter.get(\"/thumb/:file([a-zA-Z\\-0-9\\/ \\._\\%,&\\[\\]]+)/:size\", function (req, res) {\n   //do stuff\n});\n```\n\nto handle an URL like: `/thumb/canada/news-events/event-list/185-Roma_Ghezzi[1].jpg/75x75`\n\nAdding the character `\\\\]` will make the route stop working, even if the URL doesn't contain those characters.\n\nEven worst when you try adding the characters `\\\\(` or `\\\\)` because it crashes the process with the error:\n\n```\nSyntaxError: Invalid regular expression: /^\\/thumb\\/(?:([a-zA-Z-0-9\\/ \\._%,&[]))]+)\\/(?:([^\\/]+?))\\/?$/: Unmatched ')'\n    at new RegExp (<anonymous>)\n```\n\nI'd really prefer to use this a rule like the following one:\n\n``` javascript\nrouter.get(\"/thumb/:file(.+)/:size\", function (req, res) {\n   //do stuff\n});\n```\n\nbut the expression `(.+)` doesn't match a string like: `folder/subfolder/file` because the slashes `/` are considered a stop character (I guess).\n",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/2387/comments",
    "author": "darkoromanov",
    "comments": [
      {
        "user": "dougwilson",
        "created_at": "2014-10-09T14:28:14Z",
        "body": "Correct, it is a limitation, and our dependency has an update that may fix it, but it's not backwards-compatible, so it can never land inside express 4.\n\nAnother thing is that the URL above, `/thumb/canada/news-events/event-list/185-Roma_Ghezzi[1].jpg/75x75` should be coming into your server as `/thumb/canada/news-events/event-list/185-Roma_Ghezzi%5B1%5D.jpg/75x75`, which you would be able to match using a regular express in your URL.\n\nFor one thing, you can never match on `/` within the part regular expressions, as they only are supposed to span a single path component. You may be interested in the `*` character in the path, which may satisfy your needs:\n\n``` js\nrouter.get(\"/thumb/:file*/:size\", function (req, res) {\n   //do stuff\n});\n```\n\nAs a last resort, the path itself can be whatever regular expression you like:\n\n``` js\nrouter.get(/^\\/thumb\\/(.+?)\\/([^\\/]+)\\/?$/, function (req, res) {\n   //do stuff\n});\n```\n"
      },
      {
        "user": "darkoromanov",
        "created_at": "2014-10-09T15:04:34Z",
        "body": "Ok I understand, URLencoding the file name is a good point. However, this regex:\n\n``` javascript\nrouter.get(\"/thumb/:file*/:size\", function (req, res) {\n   //do stuff\n});\n```\n\ndoesn't work as expected as it returns these params:\n\nURL: /thumb/canada/news-events/event-list/1.jpg/75x75\n\n``` javascript\n{ '0': '75x75',\n  file: 'canada',\n  size: '/news-events/event-list/1.jpg' }\n```\n\nInstead, this rule \n\n``` javascript\nrouter.get(/^\\/thumb\\/(.+?)\\/([^\\/]+)\\/?$/, function (req, res) {\n//do stuff\n});\n```\n\nworks perfectly as it produces:\n\n``` javascript\n{ '0': 'canada/news-events/event-list/1.jpg', '1': '75x75' }\n```\n\nThanks!\n"
      }
    ]
  },
  {
    "number": 5403,
    "title": "Inconsistent Logging Order for GET and POST Requests",
    "created_at": "2024-01-23T10:50:40Z",
    "closed_at": "2024-01-24T20:16:34Z",
    "labels": [
      "help wanted",
      "good first contribution"
    ],
    "url": "https://github.com/expressjs/express/issues/5403",
    "body": "**Issue Description:**\r\nI have implemented middleware in my Express application to log request details and response time. The main application code is provided below:\r\n\r\n```javascript\r\nconst path = require('path');\r\nconst express = require('express');\r\n\r\nconst friendsRouter = require('./routes/friends.router');\r\nconst messagesRouter = require('./routes/messages.router');\r\n\r\nconst app = express();\r\nconst publicPath = path.join(__dirname, 'public');\r\n\r\nconst PORT = 3000;\r\n\r\napp.use((req, res, next) => {\r\n  const start = Date.now();\r\n  next();\r\n\r\n  const delta = Date.now() - start;\r\n  console.log(`${req.method} ${req.baseUrl}${req.url} ${delta}ms`);\r\n});\r\n\r\napp.use(express.json());\r\napp.use('/static', express.static(publicPath));\r\n\r\napp.use('/friends', friendsRouter);\r\napp.use('/messages', messagesRouter);\r\n\r\napp.listen(PORT, () => {\r\n  console.log(`Server listening on port ${PORT}`);\r\n});\r\n```\r\n\r\nIn friendsRouter, I have an extra middleware to log the ip address:\r\n```javascript\r\nfriendsRouter.use((req, res, next) => {\r\n  console.log('ip address', req.ip);\r\n  next();\r\n});\r\n```\r\n\r\nWhen I send a GET request, the logs are as expected:\r\n```bash\r\nGET /friends/ 2ms\r\nip address ::1\r\n```\r\n\r\nHowever, when I send a POST request, the order of logs is not consistent:\r\n```bash\r\nPOST /friends 4ms\r\nip address ::1\r\n```\r\n\r\n**Expected Behavior:**\r\nConsistent order of logs is expected for both GET and POST requests since the order of middleware functions is not changed.\r\n\r\n**Actual Behavior:**\r\nThe order of logs is inconsistent for GET and POST requests, and there's a noticeable difference in the path format for POST requests.\r\nFor a POST request, there is no / at the end.\r\n\r\n**Additional Information:**\r\nExpress version: 4.18.2\r\nNode.js version: 20.10.0\r\nOperating System: WSL2",
    "comments_url": "https://api.github.com/repos/expressjs/express/issues/5403/comments",
    "author": "ThomasCode92",
    "comments": [
      {
        "user": "ammyroy119",
        "created_at": "2024-01-24T11:07:11Z",
        "body": "The inconsistency in the order of logs and the difference in the path format for GET and POST requests may be due to the fact that the delta logging is done outside of the asynchronous operation in the middleware stack. When using asynchronous operations like next() or async middleware, the timing of logging might be affected.\r\n\r\nTo address this issue, you can modify the logging middleware to ensure that the delta logging is done after the asynchronous operations complete. One way to achieve this is by using the response event emitted by Express after the response has been sent.\r\n\r\nHere's an updated version of your logging middleware:\r\n```\r\n`app.use((req, res, next) => {\r\n  const start = Date.now();\r\n\r\n  res.on('finish', () => {\r\n    const delta = Date.now() - start;\r\n    console.log(`${req.method} ${req.baseUrl}${req.url} ${delta}ms`);\r\n  });\r\n\r\n  next();\r\n});\r\n```\r\nBy attaching the logging code to the finish event of the response, you ensure that it will be executed after the response has been sent, regardless of any asynchronous operations in the middleware stack.\r\n\r\nAfter making this change, the order of logs for both GET and POST requests should be consistent."
      }
    ]
  }
]