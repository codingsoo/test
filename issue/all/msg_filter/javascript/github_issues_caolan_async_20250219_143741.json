[
  {
    "number": 1724,
    "title": "help converting old async 2.6.2 callback to new async/await 3.2.0",
    "created_at": "2020-08-28T04:20:37Z",
    "closed_at": "2020-08-28T13:27:12Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/caolan/async/issues/1724",
    "body": "I am trying to convert old async 2.6.2 codebase (node v8) which is written with callbacks to new async/await 3.2.0 with node v12\r\n\r\nAs examples with async/await for 3.2.0 are unavailable I am having hard time converting the old codebase, can somebody help me convert below example code to newer version?\r\n\r\n```\r\n//2.6.2\r\nvar async = require('async'); \r\nvar fs = require('fs');\r\n\r\nvar taskObj = {\r\n    task1: \"test1\",\r\n    task2: \"test2\"\r\n};\r\n\r\nasync.series([\r\n    function (cb) {\r\n        async.eachOf(taskObj, function (item, key, cbe) {\r\n            console.log(\"working on key: \" + key);\r\n            someAsyncFunction1(item, key, cbe);\r\n        }, cb);\r\n    },\r\n    function (cb) {\r\n        async.parallel([\r\n            function(cbp){\r\n                console.log(\"working on sp1 in parallel\");\r\n                someAsyncFunction2(taskObj, \"sp1\", cbp);\r\n            },\r\n            function(cbp){\r\n                console.log(\"working on sp2 in parallel\");\r\n                someAsyncFunction3(taskObj, \"sp2\", cbp);\r\n            }\r\n        ], cb);\r\n    }\r\n], function (error) {\r\n    console.log('done');\r\n});\r\n\r\nfunction someAsyncFunction1(item, key, callback) {\r\n    fs.writeFile( key + \"-sAF1.txt\", JSON.stringify(item), callback);\r\n}\r\n\r\nfunction someAsyncFunction2(item, key, callback) {\r\n    fs.writeFile( key + \"-sAF2.txt\", JSON.stringify(item), callback);\r\n}\r\n\r\nfunction someAsyncFunction3(item, key, callback) {\r\n    fs.writeFile( key + \"-sAF3.txt\", JSON.stringify(item), callback);\r\n}\r\n```\r\n\r\nBelow note is taken from async v3 docs but I am not sure, do we need to use ```async.asyncify()```  for converting above code?\r\n\r\n> We can only detect native async functions, not transpiled versions (e.g. with Babel). Otherwise, you can wrap async functions in async.asyncify().\r\n\r\nNot sure how to write this without callbacks\r\n\r\n```\r\n//3.2.0\r\nvar async = require('async'); \r\nvar fs = require('fs');\r\n\r\nvar taskObj = {\r\n    task1: \"test1\",\r\n    task2: \"test2\"\r\n};\r\n\r\nawait async.series([\r\n    await async.eachOf(taskObj, async (item, key) => {\r\n        someAsyncFunction1(item, key, ?)\r\n    }),\r\n    await async.parallel([\r\n    await someAsyncFunction1(item, key, ?),\r\n    await someAsyncFunction1(item, key, ?)\r\n    ])\r\n], function(error){\r\n    console.log('done');\r\n});\r\n\r\nfunction someAsyncFunction1(item, key, ?) {\r\n    fs.writeFile( key + \"-sAF1.txt\", JSON.stringify(item), ?);\r\n}\r\n```",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/1724/comments",
    "author": "viyatgandhi",
    "comments": [
      {
        "user": "aearly",
        "created_at": "2020-08-28T06:29:16Z",
        "body": "A lot of this is native JS now:\r\n\r\n```js\r\nvar async = require('async');\r\nvar fs = require('fs/promises'); // note the promises\r\n\r\nasync function main() { // top-level await coming in node 14\r\n  await async.eachOf(itemObj, async (item, key) => {\r\n    return someAsyncFunction(item, key)\r\n  }))\r\n  await Promise.all([\r\n    someAsyncFunction1(item, key),\r\n    someAsyncFunction1(item, key)\r\n  ]}\r\n}\r\n\r\nmain();\r\n\r\nasync function someAsyncFunction1(item, key) {\r\n    return fs.writeFile( key + \"-sAF1.txt\", JSON.stringify(item), ?);\r\n}\r\n```"
      }
    ]
  },
  {
    "number": 1693,
    "title": "Missed callback detection",
    "created_at": "2019-10-21T17:03:24Z",
    "closed_at": "2019-10-25T21:15:30Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/caolan/async/issues/1693",
    "body": "This is a general question about methods to diagnose scenarios in which an async based waterfall or other control flow does not complete. \r\n\r\nBackground is that we have a Job framework periodically running job definitions, which are just AMD modules exposing a method that executes an async based control flow, and over time we're noticing that some of these jobs sometimes do not complete - they do not crash or otherwise fail - they simply never report success or failure - and the circumstances are not directly repeatable but seem to depend on external factors like network or database load etc. \r\n\r\nOur working hypothesis is that there is some error pathway in our job definition in which a callback is never called etc, and I'm looking for techniques or any built in facilities that might help diagnose these scenarios, ie is there anything like a waterfall or other control flow timeout option etc? ",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/1693/comments",
    "author": "gregory-h",
    "comments": [
      {
        "user": "aearly",
        "created_at": "2019-10-21T20:35:51Z",
        "body": "The only way I've found to diagnose things like this is to use a timeout -- there is `async.timeout` which you can use to wrap steps that might never call callbacks."
      }
    ]
  },
  {
    "number": 1543,
    "title": "transform processes input in parallel",
    "created_at": "2018-06-10T05:00:06Z",
    "closed_at": "2018-07-02T01:29:40Z",
    "labels": [
      "question",
      "wont fix"
    ],
    "url": "https://github.com/caolan/async/issues/1543",
    "body": "<!--\r\nThis template is for bug reports. If you are reporting a bug, please continue on. If you are here for another reason (such as a feature request, change, or question) you can disregard this template\r\n-->\r\n\r\n**What version of async are you using?**\r\nasync 2.6.1.\r\n\r\n**Which environment did the issue occur in (Node version/browser version)**\r\nNode.js v8.11.2.\r\n\r\n**What did you do? Please include a minimal reproducable case illustrating issue.**\r\n\r\n```js\r\nconst async = require('async');\r\n\r\nfunction delay(cb) {\r\n  setTimeout(cb, Math.floor(Math.random() * 20));\r\n}\r\n\r\nfunction exerciseTransform(times, cb) {\r\n  console.info(`Running transform ${times} times...`);\r\n  async.times(times, (n, nextTime) =>\r\n    async.transform([1, 2, 3, 4, 5], [], (acc, item, index, next) =>\r\n      delay(() => { acc.push(item); next(); }), nextTime),\r\n    (err, results) => { console.info(results); cb(); });\r\n}\r\n\r\nfunction exerciseReduce(times, cb) {\r\n  console.info(`Running reduce ${times} times...`);\r\n  async.times(times, (n, nextTime) =>\r\n    async.reduce([1, 2, 3, 4, 5], [], (memo, item, next) =>\r\n      delay(() => { memo.push(item); next(null, memo); }), nextTime),\r\n    (err, results) => { console.info(results); cb(); });\r\n}\r\n\r\nasync.series([\r\n  async.apply(exerciseTransform, 5),\r\n  async.apply(exerciseReduce, 5),\r\n], () => {});\r\n```\r\n\r\n**What did you expect to happen?**\r\nBecause transform is a relative of reduce, I would expect it to process the input array serially.\r\n\r\n**What was the actual result?**\r\nTransform processes the input array in parallel.\r\n\r\n```\r\nRunning transform 5 times...\r\n[ [ 3, 1, 5, 4, 2 ],\r\n  [ 1, 3, 4, 2, 5 ],\r\n  [ 2, 4, 5, 3, 1 ],\r\n  [ 1, 4, 5, 3, 2 ],\r\n  [ 4, 5, 2, 1, 3 ] ]\r\nRunning reduce 5 times...\r\n[ [ 1, 2, 3, 4, 5 ],\r\n  [ 1, 2, 3, 4, 5 ],\r\n  [ 1, 2, 3, 4, 5 ],\r\n  [ 1, 2, 3, 4, 5 ],\r\n  [ 1, 2, 3, 4, 5 ] ]\r\n```\r\n\r\nI'm not sure if anyone might depend on the current behavior, so maybe this is really a request for a transformSeries function.",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/1543/comments",
    "author": "uusdfg",
    "comments": [
      {
        "user": "aearly",
        "created_at": "2018-07-02T01:29:40Z",
        "body": "`transform` was created mainly as a way to process objects, where key ordering doesn't matter, and also to be the parallel cousin of `reduce`.\r\n\r\nMaintaining order in the accumulator is the job of the `iteratee` function.  Your example would work as expected if you did:\r\n\r\n```js\r\nfunction exerciseTransform(times, cb) {\r\n  console.info(`Running transform ${times} times...`);\r\n  async.times(times, (n, nextTime) =>\r\n    async.transform([1, 2, 3, 4, 5], [], (acc, item, index, next) =>\r\n      delay(() => { acc[index] = item; next(); }), nextTime), // <--\r\n    (err, results) => { console.info(results); cb(); });\r\n}\r\n```"
      },
      {
        "user": "uusdfg",
        "created_at": "2018-07-02T04:59:39Z",
        "body": "I'm sorry, I didn't realize that `transform` was intended to run in parallel. I had expected the same left-to-right semantics as `reduce`.\r\n\r\nI think it would help if the documentation for `transform` called out this distinction explicitly. The documentation currently says that `transform`, \"iterates over each element in series,\" which suggests that it's supposed to be serial."
      }
    ]
  },
  {
    "number": 1493,
    "title": "How can I remove a task from the queue after a certain time?",
    "created_at": "2017-11-06T22:29:27Z",
    "closed_at": "2017-11-07T15:36:36Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/caolan/async/issues/1493",
    "body": "Hi,\r\n\r\nI'd like to remove a task from the queue after a certain time, but for some reason the `remove` method of the `Queue` object is never called. Here's my code:\r\n\r\n```js\r\nconst Queue = require('async/queue');\r\n\r\nconst q = new Queue((data, callback) => {\r\n    setTimeout(() => {\r\n        console.log('working');\r\n        callback();\r\n    }, 3000);\r\n}, 1);\r\n\r\nlet data = {id: 1};\r\n\r\nq.push(data, () => {\r\n    console.log('inside callback');\r\n});\r\n\r\n// works -- the task is removed from the queue\r\n// q.remove((worker) => {\r\n//     console.log('inside worker test', worker.data.id);\r\n//     if (worker.data.id == 1) {\r\n//         console.log('removing 1');\r\n//         return true;\r\n//     }\r\n//     return false;\r\n// });\r\n\r\n// doesn't work -- the test function never gets executed\r\nsetTimeout(() => {\r\n    console.log('inside setTimeout');\r\n    q.remove((worker) => {\r\n        console.log('inside worker test', worker.data.id);\r\n        if (worker.data.id == 1) {\r\n            console.log('removing 1');\r\n            return true;\r\n        }\r\n        return false;\r\n    });\r\n}, 1);\r\n```\r\n\r\nAs you can see above, `q.remove` is never called when it's inside a timeout, but works fine when it's outside. Is it because the worker has already started and cannot be removed even though the callback hasn't been called yet?\r\n\r\nMy node version is 8.8.1 and async version is 2.5.0.",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/1493/comments",
    "author": "kodchi",
    "comments": [
      {
        "user": "aearly",
        "created_at": "2017-11-07T06:44:36Z",
        "body": "`q.remove()` only works for items that are in the queue, not items that are running.  In this example, your item would have been shifted off and be processing after the delay -- the queue is checked for processing on the next tick after a `q.push()`.  After the timeout, the queue is empty, with one task running."
      }
    ]
  },
  {
    "number": 1478,
    "title": "Support question - read remaining number of tasks in async.queue",
    "created_at": "2017-09-30T18:59:23Z",
    "closed_at": "2017-10-01T20:49:52Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/caolan/async/issues/1478",
    "body": "I am using async.queue like so:\r\n\r\n```js\r\nconst q = async.queue((task, cb => task(cb));\r\n```\r\n\r\nHow can I find out during debugging how many tasks remain on the queue (and maybe how many have completed?)?\r\n\r\nI used `util.inspect()` to get the properties on the queue\r\n\r\n```\r\n { _tasks: DLL { tail: null, head: null, length: 0 },\r\n  concurrency: 3,\r\n  payload: 1,\r\n  saturated: [Function: noop],\r\n  unsaturated: [Function: noop],\r\n  buffer: 0.75,\r\n  empty: [Function: noop],\r\n  drain: [Function],\r\n  error: [Function: noop],\r\n  started: false,\r\n  paused: false,\r\n  push: [Function: push],\r\n  kill: [Function: kill],\r\n  unshift: [Function: unshift],\r\n  remove: [Function: remove],\r\n  process: [Function: process],\r\n  length: [Function: length],\r\n  running: [Function: running],\r\n  workersList: [Function: workersList],\r\n  idle: [Function: idle],\r\n  pause: [Function: pause],\r\n  resume: [Function: resume] }\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/1478/comments",
    "author": "ORESoftware",
    "comments": [
      {
        "user": "ORESoftware",
        "created_at": "2017-09-30T19:10:43Z",
        "body": "also, as an aside, curious about how to remove the drain callback, maybe like so?\r\n\r\n```js\r\nq.drain = function(){\r\n   q.drain = null; // this doesn't seem quite right?\r\n};\r\n```\r\nalso wondering if there is a way to use multiple drain callbacks.\r\n\r\nthanks\r\n"
      },
      {
        "user": "aearly",
        "created_at": "2017-10-01T20:49:52Z",
        "body": "`q.length()` will return the length of the queue. `q._tasks.toArray()` will give you a list of tasks in the queue.  There's no way to tell how many have completed, unless you track that yourself.\r\n\r\nTo remove the drain callback:  \r\n\r\n```js\r\nq.drain = function () {}\r\n```\r\n\r\nNo way to use multiple drain callbacks, but you can call multiple functions in the single drain callback."
      },
      {
        "user": "ORESoftware",
        "created_at": "2017-10-01T21:26:26Z",
        "body": "@aearly thanks, got it, except:\r\n\r\nq.length() will return the length of the queue. q._tasks.toArray()\r\n\r\nwhat's the difference between those two? the length and the number of tasks? aren't they the same?"
      },
      {
        "user": "aearly",
        "created_at": "2017-10-01T21:32:51Z",
        "body": "They are the same.  Length of the queue = number of tasks in the queue."
      },
      {
        "user": "ORESoftware",
        "created_at": "2019-07-28T02:23:59Z",
        "body": "Still don't know what the diff is between q.length() and q.running()"
      }
    ]
  },
  {
    "number": 1474,
    "title": "async.reflect -> error.message is undefined",
    "created_at": "2017-09-22T20:11:35Z",
    "closed_at": "2017-09-23T08:25:08Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/caolan/async/issues/1474",
    "body": "<!--\r\nThis template is for bug reports. If you are reporting a bug, please continue on. If you are here for another reason (such as a feature request, change, or question) you can disregard this template\r\n-->\r\n\r\n**What version of async are you using?**\r\n2.5.0\r\n\r\n**Which environment did the issue occur in (Node version/browser version)**\r\nNode 6.11.1\r\n\r\n**What did you do? Please include a minimal reproducable case illustrating issue.**\r\n```\r\nasync.series([\r\n    async.reflect(callback => callback(null, 'one')),\r\n    async.reflect(callback => callback(new Error('bad stuff happened'))),\r\n    async.reflect(callback => callback(null, 'two'))\r\n  ],\r\n  (err, results) => {\r\n    console.log(results[1].message)\r\n  });\r\n```\r\n\r\n**What did you expect to happen?**\r\noutput should be `bad stuff happened`\r\n\r\n**What was the actual result?**\r\noutput is `undefined`\r\n\r\nasync without `async.reflect`:\r\n\r\n```\r\nasync.series([\r\n    callback => callback(null, 'one'),\r\n    callback => callback(new Error('bad stuff happened')),\r\n    callback => callback(null, 'two')\r\n  ],\r\n  (err, results) => {\r\n    console.log(err.message)\r\n  });\r\n```\r\nOutput contains `bad stuff happened`",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/1474/comments",
    "author": "AlexZeitler",
    "comments": [
      {
        "user": "aearly",
        "created_at": "2017-09-22T21:50:23Z",
        "body": "You should be looking for `results[1].error.message`, not `results[1].message`.  `reflect` makes the wrapped function callback with `{ error: error }` or `{ value: value }`"
      }
    ]
  },
  {
    "number": 1458,
    "title": "async.auto & the curious case of try ... catch",
    "created_at": "2017-07-26T20:08:39Z",
    "closed_at": "2017-07-26T21:23:22Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/caolan/async/issues/1458",
    "body": "<!--\r\nThis template is for bug reports. If you are reporting a bug, please continue on. If you are here for another reason (such as a feature request, change, or question) you can disregard this template\r\n-->\r\n\r\n**What version of async are you using?**\r\nv2.5.0\r\n**Which environment did the issue occur in (Node version/browser version)**\r\nv6.10.3\r\n**What did you do? Please include a minimal reproducable case illustrating issue.**\r\n```javascript\r\nasync.auto({\r\n  returnOne: (callback) => callback(null, 1),\r\n  tryCatch: [\"returnOne\", (results, callback) => {\r\n    try {\r\n      assert(results.returnOne === 1);\r\n      return callback(null);\r\n    } catch (err) {\r\n      console.log(`Caught an error: ${err.message}`);\r\n      return callback(err);\r\n    }\r\n  }],\r\n}, (err, results) => {\r\n  assert(results.returnOne !== 1);\r\n  console.log(`All Done!`);\r\n});\r\n```\r\n**What did you expect to happen?**\r\nThe assert inside the final aync.auto callback fails and throws an error which is not caught and stops the Node.js process. In my real world example of this, we are testing a block of code within Mocha, which handles the error and reports that the test failed with information about the assertion that caused the failure.\r\n\r\n**What was the actual result?**\r\nTry / Catch from the previous auto step catches the error and calls the tryCatch callback a second time, resulting in a different error:\r\n```\r\nasync/dist/async.js:903\r\n        if (fn === null) throw new Error(\"Callback was already called.\");\r\n                         ^\r\nError: Callback was already called.\r\n```",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/1458/comments",
    "author": "trvra",
    "comments": [
      {
        "user": "aearly",
        "created_at": "2017-07-26T21:06:02Z",
        "body": "```js\r\ntry {\r\n  //...\r\n  return callback(null, result)\r\n} catch (e) {\r\n  //..\r\n  return callback(e)\r\n}\r\n```\r\n\r\nIs a huge anti-pattern because if something throws later in the callback chain (e.g. your assert), it will be caught in the `try` block, causing a double callback in the `catch`.  Correct way:\r\n\r\n```js\r\nlet err, result\r\ntry {\r\n  result = doSomething()\r\n} catch (e) {\r\n  err = e\r\n}\r\ncallback(err, result)\r\n```"
      }
    ]
  },
  {
    "number": 1431,
    "title": "Final callback not executed!!",
    "created_at": "2017-06-08T12:44:22Z",
    "closed_at": "2017-06-08T16:54:58Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/caolan/async/issues/1431",
    "body": "\r\nVersion: 2.4.1\r\n\r\nEnvironment: Browser\r\n\r\n**What did you do? Please include a minimal reproducable case illustrating issue.**\r\n```ts\r\nasync.each(seriesArray, (series1: SeriesConfig) => {\r\n                    this.dataStore.series[series1.name] = this.setSerieData(series1);               \r\n            }, (error?: Error) => {\r\n                if(error) console.error(error.message);\r\n                this.setState({ dataStore: this.dataStore, isLoaded: true });\r\n            });\r\n```\r\nThe final callback is not executed!\r\n``` ts\r\n           (error?: Error) => {\r\n                // tslint:disable-next-line no-console\r\n                if(error) console.error(error.message);\r\n                this.setState({ dataStore: this.dataStore, isLoaded: true });\r\n            });\r\n```\r\n\r\n**What did you expect to happen?**\r\nI expected the state to be updated with new dataStore\r\n**What was the actual result?**\r\nThe final callback is never executed",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/1431/comments",
    "author": "djkwagala",
    "comments": [
      {
        "user": "aearly",
        "created_at": "2017-06-08T16:44:01Z",
        "body": "You're missing a callback in your iteratee function."
      }
    ]
  },
  {
    "number": 1387,
    "title": "How can use implicit args in auto and autoinject ",
    "created_at": "2017-03-18T06:47:22Z",
    "closed_at": "2017-03-19T11:23:18Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/caolan/async/issues/1387",
    "body": "\r\nHi,\r\nHow can i use implicit args list for auto and autoinject.\r\nI use async 2.1.5 and nodeJs 4.2.6\r\n\r\neg:\r\n\r\nvar args = [ 'arg1', 'arg2', 'arg3' ] ,\r\n      funcList = {\r\n                 arg1: function(cb){ cb(null,'xyz')  },\r\n                 arg2: function(cb){ cb(null,'xyz')  },\r\n                 arg3: function(cb){ cb(null,'xyz')  }\r\n            }\r\n\r\nfuncList[ 'arg4' ] = [args, function( r, cb ){\r\n     // use or change  r[ args[0] ] or r[ args[1] ] ...\r\n}]\r\n\r\nasync.auto(funcList, callback);\r\n\r\nat the run time i get Error: async.auto task `arg4` has a non-existent dependency `arg1, arg2, arg3` in arg1, arg2, arg3",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/1387/comments",
    "author": "mjafarpour",
    "comments": [
      {
        "user": "aearly",
        "created_at": "2017-03-18T08:59:10Z",
        "body": "Change it to:\r\n\r\n```js\r\nfuncList[ 'arg4' ] = args.concat(function( r, cb ){\r\n  // use or change r[ args[0] ] or r[ args[1] ] ...\r\n})\r\n```"
      },
      {
        "user": "aearly",
        "created_at": "2017-03-18T19:09:19Z",
        "body": "You can't have dynamic args in autoInject.  All args have to be explicit in the function definitions."
      }
    ]
  },
  {
    "number": 1337,
    "title": "Control Flow times - RangeError: Maximum call stack size exceeded",
    "created_at": "2016-12-06T10:24:25Z",
    "closed_at": "2016-12-06T18:41:37Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/caolan/async/issues/1337",
    "body": "Async v2.1.4 / Node v4.1.1\r\n\r\nRunning the code from the documentation with a large n (1500) for **times(n, iteratee, callback)**:\r\n\r\n```javascript\r\nvar async = require('async');\r\n\r\n// Pretend this is some complicated async factory\r\nvar createUser = function(id, callback) {\r\n    callback(null, {\r\n        id: 'user' + id\r\n    });\r\n};\r\n\r\n// generate 5 users\r\nasync.times(1500, function(n, next) {\r\n    createUser(n, function(err, user) {\r\n        next(err, user);\r\n    });\r\n}, function(err, users) {\r\n    console.log(users.length)\r\n});\r\n```\r\n\r\nI get:\r\n\r\n```bash\r\nRangeError: Maximum call stack size exceeded\r\n      at forEach (test/disk-test.js:49:7)\r\n      at node_modules/async/dist/async.js:1008:9\r\n      at replenish (node_modules/async/dist/async.js:882:17)\r\n      at iterateeCallback (node_modules/async/dist/async.js:867:17)\r\n      at node_modules/async/dist/async.js:840:16\r\n      at node_modules/async/dist/async.js:1010:13\r\n```\r\n\r\nBefore in version v1.5.x, I was able to create testing arrays of 250K but with this version I can only create max 1400.\r\n\r\nIs there a better way to do it?\r\n\r\n",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/1337/comments",
    "author": "mcmartins",
    "comments": [
      {
        "user": "aearly",
        "created_at": "2016-12-06T18:41:37Z",
        "body": "That error happens when you don't defer your callback.  Either use something like `setImmediate`, or perhaps Lodash's `_.times`.  It appears you don't need Async at all."
      }
    ]
  },
  {
    "number": 1323,
    "title": "First callback of two nested Async.map() doesn't work",
    "created_at": "2016-11-13T10:00:13Z",
    "closed_at": "2016-11-14T06:56:51Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/caolan/async/issues/1323",
    "body": "I have used two Async methods as below in my class so I need to pass the result inside `ASync.map` to `Async.mapValues` but it doesn't work.\r\n```javascript\r\n  request_async (testCase, bodies, method, url, cb) {    \r\n    Async.map(bodies, (item, request_cb) => {\r\n      if(item.values !== undefined ) {\r\n        const _this = this\r\n        const data = {\r\n          method: method,\r\n          uri: url,\r\n          formData: item.values,\r\n          jar: this.jar\r\n        }\r\n        Request(data, (err, response, body) => {\r\n          this.tests_count--\r\n          if (err)\r\n            throw(err)\r\n          const _this = this\r\n          testCase.compare(response.statusCode, body, item, url, function(message) {\r\n            console.log(message)\r\n            if (!message)\r\n              console.log(null, message)\r\n            else {\r\n              request_cb(message)\r\n              if (_this.first_error) {\r\n                request_cb(message, false)\r\n              }\r\n              else {\r\n                _this.errors.push(message)\r\n                request_cb(false)\r\n              }\r\n            }\r\n          })\r\n        });       \r\n      }\r\n    }, (err, result) => {\r\n      console.log('Parent callback', cb)\r\n      cb(false, result)\r\n    })\r\n  }\r\n  make_bodies_async (testCase, method, uri) {\r\n    Async.mapValues(this.schemas, (item, key, cb) => {\r\n      let schemas\r\n      if (item.query)\r\n        schemas = Joi.describe(item.query)\r\n      else\r\n        schemas = Joi.describe(item.payload)\r\n\r\n      const bodies = testCase.make_bodies(schemas, item.defaults, key)\r\n      const parts   = _.split(key, '/')\r\n      const method  = parts[0].toUpperCase()\r\n      const url     = this.baseUrl + '/' + _.join(parts.slice(1),'/')\r\n\r\n      this.request_async(testCase, bodies, method, url, cb)\r\n\r\n    }, (err, result) => {\r\n      //console.logs won't work\r\n      console.log('bodies async')\r\n      console.log(err, result)\r\n    })\r\n  }\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/1323/comments",
    "author": "saeidalidadi",
    "comments": [
      {
        "user": "megawac",
        "created_at": "2016-11-14T03:17:13Z",
        "body": "> result inside ASync.map to Async.mapValues but it doesn't work\n\nThat's not very specific and not helping me give advice\n\nOne thing I notice\n\n``` js\nelse {\n      _this.errors.push(message)\n      request_cb(false)\n}\n```\n\nthis doesn't work `request_cb(false)` doens't get registered as an error. Consider `request_cb(error_msg)`\n"
      },
      {
        "user": "hargasinski",
        "created_at": "2016-11-14T05:02:10Z",
        "body": "In addition to what @megawac said, just something to consider. You have:\n\n``` js\nif(item.values !== undefined ) {\n    // your function\n}\n```\n\nbut you never handle the `item.values === undefined` case (or have code to call `request_cb` in that case). `map` will never invoke it's final callback (the one where you log `Parent callback`) if one of the iterations never calls it's callback (in this case `request_cb`). Could that be what's causing the issue here?\n"
      }
    ]
  },
  {
    "number": 1313,
    "title": "Setting up Event Handlers using Async",
    "created_at": "2016-10-24T23:39:21Z",
    "closed_at": "2016-10-27T20:44:28Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/caolan/async/issues/1313",
    "body": "I'm having trouble using async in one of my integration tests that involves event handlers. The problem is that the event handler needs to be set up (with a reference to an async provided callback) before the event is emitted. However the event handler code needs an extra callback right away. \n\nHere is a simplified example showing the problem:\n\n``` javascript\nasync.auto({\n  // This needs to run first, but it will finish second\n  event: [(next) => {\n    emitter.once('awesome', next);\n  }],\n\n  // This needs to finish near the end\n  checkResults: ['event', (results, next) => {\n    assert(results.event.status == 200);\n    assert(results.event.msg == 'cool');\n\n    // Do other async stuff...\n    somethingAsync(next);\n  }],\n\n  // This has to start second, but before the first one finishes\n  emit: ['event', (results, next) => {\n    event.emit('awesome', {msg: 'cool'}, next);\n  }],\n\n  checkEmit: ['emit', (results, next) => {\n    // some sort of check that can be async\n  },\n], done);\n```\n\n`event` has to start first, but won't finish until the `emit` occurs. `emit` needs to wait for `event` to start, but not finish (aka just set up the handler). Thus this won't finish.\n\nIs there a way to do this with the current async library? (in a clean manner)\n\nHeres a solution I would like, assuming this could be implemented in async\n\n``` javascript\nasync.auto({\n  listen: [(next, done) => {\n    client.on(done);\n    return next();\n  },\n\n  ...\n}, callback);\n```\n\nI could use parallel, running the emitters and the listeners (of which there can be multiple in a test) as an array of tasks. Taking the results, and running the checks as a second part. However, technically parallel isn't required to kick-off the tasks in order (though it likely will). Also, the code becomes less flat, especially in more complicated setups.\n",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/1313/comments",
    "author": "Saevon",
    "comments": [
      {
        "user": "hargasinski",
        "created_at": "2016-10-25T19:39:03Z",
        "body": "Hi @Saevon, thanks for the question!\n\nA quick, clean way of doing that would be:\n\n``` js\nasync.auto({\n    // This needs to finish near the end\n  checkResults: [(next) => {\n    return next(null, (results, next) => {\n      assert(results.event.status == 200);\n      assert(results.event.msg == 'cool');\n\n      // Do other async stuff...\n      // somethingAsync(next);\n    });\n  }],\n\n  // This needs to run first, but it will finish second\n  event: ['checkResults', (handler, next) => {\n    emitter.once('awesome', handler.checkResults);\n    return next();\n  }],\n\n  // This has to start second, but before the first one finishes\n  emit: ['event', (results, next) => {\n    // Should this be emitter.emit instead of event.emit?\n    event.emit('awesome', {msg: 'cool'}, next);\n  }],\n\n  checkEmit: ['emit', (results, next) => {\n    // the results of `checkResults` will be in `results.emit`\n    // as the handler on 'awesome' was passed the `next`\n    // callback from `emit`\n\n    // some sort of check that can be async\n    yourChecks(next);\n  }]\n}, function done(err) {\n    // everything finished running, unless `err` !== `null`\n});\n```\n\nEssentially, you're just swapping the `event` and `checkResults` dependency, which actually might be a little cleaner, as `event` depends on the handler in `checkResults`. `checkResults` is now just passing the handler to `event`.\n\nThe execution order would be:\n`checkResults --> event --> emit --> handler (passed to event from checkResults) --> checkEmit --> done`.\n\nLet me know if anything's unclear.\n"
      },
      {
        "user": "aearly",
        "created_at": "2016-10-29T22:52:58Z",
        "body": "Agreed.  Usually async callbacks and event emitters don't mix well...\n"
      }
    ]
  },
  {
    "number": 1305,
    "title": "Pass parameters to called function in async.retry",
    "created_at": "2016-10-14T11:21:19Z",
    "closed_at": "2016-10-14T22:12:52Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/caolan/async/issues/1305",
    "body": "I am trying to pass parameters to the function that retry calls but i get \n\n**Error: Invalid arguments for async.retry**\n\nMy code:\n\n``` js\n\n    async.waterfall([\n        async.apply(queryGenerator.generateQuery, user),\n      **//  async.retry(5, async.apply(googleOperations.reportingRequest, user)),\n        async.retry(5, googleOperations.reportingRequest(user)),**\n        googleOperations.parseGoogleResponse,\n        async.apply(slackOperations.postMessage, user.slack.token, '#general')\n    ]\n```\n\nI tried both but none works. Any clue?\n",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/1305/comments",
    "author": "mKontakis",
    "comments": [
      {
        "user": "aearly",
        "created_at": "2016-10-14T17:56:35Z",
        "body": "Looks like you want `retryable` instead of `retry`.  The commented-out line should work otherwise.\n"
      }
    ]
  },
  {
    "number": 1298,
    "title": "Odd result from waterfall",
    "created_at": "2016-10-06T06:20:23Z",
    "closed_at": "2016-10-06T07:29:10Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/caolan/async/issues/1298",
    "body": "**What version of async are you using?**\n2.0.1\n\n**Which environment did the issue occur in (Node version/browser version)**\nNode 6.7.0\n\n**What did you do? Please include a minimal reproducable case illustrating issue.**\n\n``` javascript\nrequire(\"async\").waterfall([\n    (callback) => callback()\n], (error) => console.log(error));\n```\n\n**What did you expect to happen?**\nIn `async@1.5.2`, in the above case `error` is undefined. \n\n**What was the actual result?**\nIn `async@2.0.1`, in the above case `error` is `null`. The final callback is somehow called with `callback(null)` which probably should have been `callback()`.\n\nThis may be working as indended, but its just something I noticed had changed recently.\n",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/1298/comments",
    "author": "ath88",
    "comments": [
      {
        "user": "hargasinski",
        "created_at": "2016-10-06T07:29:09Z",
        "body": "Thanks for the report @ath88! This is working as expected. The reason for this change was to standardise the value of `error` passed to the final callback, if an error was not detected during execution. Many of the other functions in `v1.5.x` that ran tasks in series, similar to `waterfall`, like `mapSeries`, `eachOfSeries`, etc..., were already passing `null` to the final callback, even if a different, falsy value was passed into `callback` on the final iteration. `Waterfall` was an exception. \n\nThis was standardised in `v2.0`, so that all functions pass `null` to their final callback if they don't detect an error during execution. The reason for standardising it is that it will allow us to implement a number of cool, new features in the future. For instance, breaking out of a flow early if a value of `false` was explicitly passed as `error`.\n"
      }
    ]
  },
  {
    "number": 1215,
    "title": "async.applyEach callback is not working",
    "created_at": "2016-07-04T06:33:48Z",
    "closed_at": "2016-07-04T19:40:45Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/caolan/async/issues/1215",
    "body": "I am using v2.2.0 of async.js and I am using it on client side.\n\nI am trying basic example of async.applyEach\n\n```\nvar enableSearch = function(string){\n  console.info(string);\n};\nvar updateSchema = function(string){\n  console.warn(string);\n};\n\nasync.applyEach([enableSearch, updateSchema], 'New msg', function(){\n  console.log('It is done...');\n});\n```\n\nI suppose I should expect results to be...\n\n```\nNew msg\nNew msg\nIt is done\n```\n\nbut some reason I am not getting `It is done`. That means callback is no firing. Anything I am doing wrong here...\n",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/1215/comments",
    "author": "thatisuday",
    "comments": [
      {
        "user": "thatisuday",
        "created_at": "2016-07-04T06:59:31Z",
        "body": "And `async.applyEachSeries` calls only first function in the stack with no callback. i.e. `enableSearch`\n"
      },
      {
        "user": "aearly",
        "created_at": "2016-07-04T18:57:19Z",
        "body": "Your `enableSearch` and `updateSchema` functions don't actually call any callback, so the final callback will never be called.\n"
      },
      {
        "user": "anusree-mmlab",
        "created_at": "2018-01-25T09:52:48Z",
        "body": "I have 2 callbacks on each enableSearch and updateSchema.\r\nBut the  final callback is called with the enableSearch callback. #"
      }
    ]
  },
  {
    "number": 1150,
    "title": "Throwing an error in callback results in \"Unhandled rejection Error: Callback was already called.\"",
    "created_at": "2016-05-08T11:36:00Z",
    "closed_at": "2016-05-11T19:53:18Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/caolan/async/issues/1150",
    "body": "Throwing an error in callback results in \"Unhandled rejection Error: Callback was already called.\"\nThis prevents user from seeing actual error message, created by assertions in tests. \nThis hasn't been happening in 2.0.0-rc3. Is this expected behaviour in rc4?\n\nHere's the example code\n\n``` js\nasync.waterfall([\n  (next) => {\n    apiClient\n      .post('/some-url')\n      .send({prop: 'value'})\n      .expect(200)\n      .end(next);\n  }\n], (err) => {\n  assert.ifError(err);\n  throw new Error('Some Error');\n});\n```\n",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/1150/comments",
    "author": "pziemkowski",
    "comments": [
      {
        "user": "aearly",
        "created_at": "2016-05-09T20:01:52Z",
        "body": "Looks like there's a Promise inside your `apiClient` thats catching the error you're trying to throw, and calling the `.end()` callback twice.\n"
      },
      {
        "user": "pziemkowski",
        "created_at": "2016-05-12T10:36:16Z",
        "body": "ApiClient is a regular SuperAgent client. How would it even be possible for a function in waterfall, which is executed previously to catch error thrown in callback?\n"
      },
      {
        "user": "aearly",
        "created_at": "2016-05-12T20:16:07Z",
        "body": "It's a common pitfall with continuation-passing style.  Consider this:\n\n```\nfunction someAsyncFn(arg, callback) {\n  try {\n    var foo = doSomething(arg);\n    callback(null, foo);\n  } catch (e) {\n    callback(e);\n  }\n}\n\nsomeAsyncFn(1, function(err, val) {\n  throw new Error();\n})\n```\n\nThe error thrown in the callback will be caught by `someAsyncFn`, which will then call the callback again.  Promises wrap their resolved/rejected handlers in a try/catch, so this comes up often.  There's a promise somewhere in your code handling the error.\n"
      },
      {
        "user": "pziemkowski",
        "created_at": "2016-05-14T14:36:41Z",
        "body": "You of course have been right. Pushing it down the loop with nextTick does seem to make it work.\nThank you for pointing it out, I falsely assumed that this was already happening with callback.\n\nIs there a better way to do it instead of adding additional flow function every time?\n\nI mean this:\n\n``` js\nasync.waterfall([\n  (next) => {\n    apiClient\n      .post('/some-url')\n      .send({prop: 'value'})\n      .expect(200)\n      .end(next);\n  },\n  (res, next) => async.nextTick(next, null, res)\n], (err) => {\n  assert.ifError(err);\n  throw new Error('Some Error');\n});\n```\n"
      }
    ]
  },
  {
    "number": 1104,
    "title": "How can I dynamically push functions with different arguments to an array? I need to process those functions using Async.js (parallel or race mode)",
    "created_at": "2016-04-07T23:27:23Z",
    "closed_at": "2016-04-08T20:19:49Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/caolan/async/issues/1104",
    "body": "Currently I am trying to run in parallel the same function with different arguments using Node.JS\n\nFor this I use Async.js and i am struggling trying to push/stack functions to an array. \nThe problem is that the functions are executed with the same arguments. This is what I have:\n\n``` js\nvar async = require(\"async\");\nvar array = [];\nvar x = [1,2,3,4];\n\n// This portion of code works perfect and the arguments are passed perfectly\n// The results that i am getting are: [100, 200, 300, 400]\narray.push(function(callback){ callback(null,calculate(x[0]))});\narray.push(function(callback){ callback(null,calculate(x[1]))});\narray.push(function(callback){ callback(null,calculate(x[2]))});\narray.push(function(callback){ callback(null,calculate(x[3]))});\n\n// This portion of code does not work and I dont know why ... \n// The results that i am getting are: [400, 400, 400, 400]\n// Obviusly the function is receiving the same argument a=4 everytime is called\nfor (i=0;i<3;i++){\n    array.push(function(callback){ callback(null,calculate(x[i]))});\n}\n\nasync.parallel(array,function(err,result){\n    if (err) {\n        console.log(err);\n        return;\n    }\n    console.log(\"Results are: \" + result);\n});\n\n\nfunction calculate(a) {\n  return a*100\n}\n```\n\nAny idea?\nThanks\n",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/1104/comments",
    "author": "alfredoborrero",
    "comments": [
      {
        "user": "aearly",
        "created_at": "2016-04-08T01:41:59Z",
        "body": "Lots of stuff here, including basic JS variable scoping quirks.  The short answer to your question is that you can use `async.map`, it runs in parallel too:\n\n``` js\nasync.map([1, 2, 3, 4], function(x, callback){\n  callback(null,calculate(x))\n}, function(err,result){\n    if (err) {\n        console.log(err);\n        return;\n    }\n    console.log(\"Results are: \" + result);\n});\n```\n\nBut the real answer is that you  don't need Async at all:\n\n``` js\nvar result = [1, 2, 3, 4].map(calculate)\n```\n"
      },
      {
        "user": "alfredoborrero",
        "created_at": "2016-04-09T03:24:56Z",
        "body": "Hi Caolan,\nThank you so much for the help, it worked perfectly, however I would like to know how I can implement the \"race\" mode.\nI already tried several times and I am getting errors. \nI just want to run all my functions in parallel and get the result of whoever finishes first.\nAny idea on how to implement  Async.race ?\nRegards, \nAlfredo Borrero\nDate: Thu, 7 Apr 2016 18:42:25 -0700\nFrom: notifications@github.com\nTo: async@noreply.github.com\nCC: alf_bor@hotmail.com\nSubject: Re: [caolan/async] How can I dynamically push functions with different arguments to an array? I need to process those functions using Async.js (parallel or race mode) (#1104)\n\nLots of stuff here, including basic JS variable scoping quirks.  The short answer to your question is that you can use async.map, it runs in parallel too:\n\nasync.map([1, 2, 3, 4], function(x, callback){\n  callback(null,calculate(x))\n}, function(err,result){\n    if (err) {\n        console.log(err);\n        return;\n    }\n    console.log(\"Results are: \" + result);\n});\n\nBut the real answer is that you  don't need Async at all:\n\nvar result = [1, 2, 3, 4].map(calculate)\n\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly or view it on GitHub\n"
      },
      {
        "user": "alfredoborrero",
        "created_at": "2016-04-16T07:08:07Z",
        "body": "Hi Caolan,\n\nThank you so much for the help, it worked perfectly, however I would like to know how I can implement the \"race\" mode. I already tried several times and I am getting errors. \nI just want to run all my functions in parallel and get the result of whoever finishes first.\nAny idea on how to implement  Async.race ?\n\nRegards, \n"
      }
    ]
  },
  {
    "number": 969,
    "title": "each and eachSeries not passing back values to results array - why?",
    "created_at": "2015-12-01T05:11:11Z",
    "closed_at": "2015-12-01T07:22:01Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/caolan/async/issues/969",
    "body": "This is probably my misunderstanding, but there's a small chance of a bug\n\n``` javascript\n\nasync.each([1,2,3], function(value,cb){\n    setTimeout(function(){\n        cb(null,value);\n    },200);\n\n},function complete(err, results) {\n    console.log(err,results);  //results is undefined here, err is null\n});\n\n\nasync.eachSeries([1,2,3], function(value,cb){\n    setTimeout(function(){\n        cb(null,value);\n    },200);\n\n},function complete(err, results) {\n    console.log(err,results); //results is undefined here, err is null as expected\n});\n```\n\nfor the async.series and async.parallel apis, we have the results argument being populated as an array, but with async.each and async.eachSeries, this does not seem to be the case.\n\nis there something I am missing?\n\nthanks!\n",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/969/comments",
    "author": "ORESoftware",
    "comments": [
      {
        "user": "ex1st",
        "created_at": "2015-12-01T06:43:16Z",
        "body": "async.each is asynchronous equivalent for native Array.forEach. \nYou need use async.map for passing result.\n"
      },
      {
        "user": "aearly",
        "created_at": "2015-12-01T07:22:01Z",
        "body": ":arrow_up: What he said.  `each` is just for control flow, `map` is for gathering the results.\n"
      }
    ]
  },
  {
    "number": 939,
    "title": "Does the async.each() method return the array in the same order?",
    "created_at": "2015-10-22T18:17:40Z",
    "closed_at": "2015-10-22T23:16:17Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/caolan/async/issues/939",
    "body": "This may seem like a silly question but I want to ensure I understand it correctly. I understand that the iterator will obviously take a different amount of time per function in the array. But, is the returned array mapped in the initial order, or in the order in which the async callbacks were returned?\n\nThank you!!\n",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/939/comments",
    "author": "DaddyWarbucks",
    "comments": [
      {
        "user": "aearly",
        "created_at": "2015-10-22T18:27:48Z",
        "body": "`async.each` and family don't return arrays at all -- just an error if one occurred.  If you want to ensure the order of results a parallel fashion, use `async.map`.\n"
      }
    ]
  },
  {
    "number": 919,
    "title": "How to re-push failed task?",
    "created_at": "2015-09-28T16:34:20Z",
    "closed_at": "2015-09-29T00:58:52Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/caolan/async/issues/919",
    "body": "Hi ..\n\nany idea how to re-push failed task, inside my async.queue, i've try something like this, but not work ..\n\n``` js\nvar q = async.queue(function(task, nextQueue) {\n    // do something\n\n    if (err) {\n        q.push(task)\n    }\n})\n```\n\nThanks\n",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/919/comments",
    "author": "fer-ri",
    "comments": [
      {
        "user": "aearly",
        "created_at": "2015-09-29T00:26:55Z",
        "body": "Try this:\n\n``` js\nvar q = async.queue(function(task, nextQueue) {\n    // do something\n});\n\nfunction pushWithRetry(data) {\n  q.push(data, function (err) {\n    if (err) {\n      pushWithRetry(data);\n    }\n  });\n}\n\npushWithRetry({whatever...});\n```\n"
      }
    ]
  },
  {
    "number": 901,
    "title": "How to send arguments in async.auto in its first method",
    "created_at": "2015-09-04T17:06:11Z",
    "closed_at": "2015-09-05T04:53:24Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/caolan/async/issues/901",
    "body": "``` js\nvar signup=function(user){\nAsync.auto({\n            verifyPassword:verifyPassword,\n            saveUser:['verifyPassword',saveUser]\n            })\n}\nvar verifyPassword=function(user,next ){\n\n}\n```\n\nNow I want to send user object into verifyPassword function\n",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/901/comments",
    "author": "abhaygarg",
    "comments": [
      {
        "user": "aearly",
        "created_at": "2015-09-04T18:06:34Z",
        "body": "You can use `async.apply` to partially apply `verifyPassword`:\n\n``` js\n    verifyPassword: async.apply(verifyPassword, user),\n```\n"
      }
    ]
  },
  {
    "number": 878,
    "title": "forEachOf is not implemented ?",
    "created_at": "2015-08-09T11:04:45Z",
    "closed_at": "2015-08-16T19:35:31Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/caolan/async/issues/878",
    "body": "Hello.\nthe docs of async shows the function forEachOf\nit seems that this function doesn't exist in async.\n\nany ideas ?\n",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/878/comments",
    "author": "kfirufk",
    "comments": [
      {
        "user": "aearly",
        "created_at": "2015-08-09T22:10:56Z",
        "body": "What version are you using?  It was added after v 1.0\n"
      }
    ]
  },
  {
    "number": 788,
    "title": "series/waterfall callback is added to stack of last fn's done() call",
    "created_at": "2015-06-13T19:23:05Z",
    "closed_at": "2015-06-16T04:57:11Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/caolan/async/issues/788",
    "body": "Can't seem to find this problem in the docs/issues, it seems the last fn's call to done() sits beneath the callback function in the stack, meaning its able to try/catch any errors encountered in the callback. Simple example:\n\n```\nasync.series([function(done) {\n    try {\n        done();\n    } catch(e) {\n        console.log('caught error from callback')\n    }\n}], function(err, result) {\n    throw new Error('callback threw');\n});\n```\n\nIn my case, I'm using the \"wd\" library and my last fn in the series array is:\n\n```\nbrowser.init({browserName: 'chrome'}).then(done);\n```\n\nIn my callback, I'm calling mocha.run() which throws an error if the coffeescript modules cannot compile. With the async + wd/q stack, the error is being swallowed.\nIs there another way I can use the async lib to prevent this, and ensure that all thrown errors in the callback function always bubble up to the process? thanks!\n",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/788/comments",
    "author": "mattfysh",
    "comments": [
      {
        "user": "aearly",
        "created_at": "2015-06-13T23:18:11Z",
        "body": "This is a tricky problem because `q` and other promise implementations wrap the `onResolved` handler in try/catch, which is a bad idea if you call a callback in the handler, for the exact problem you're running in to.\n\nOne thing to do would be to defer the actual `done()` call:\n\n``` js\nbrowser.init({browserName: 'chrome'}).then(function ()  {\n  setTimeout(done, 0);\n});\n```\n\nThat way, the `mocha.run()` call gets a new call stack and the error will bubble all the way up.\n"
      },
      {
        "user": "aearly",
        "created_at": "2015-06-16T04:57:11Z",
        "body": "I'd rather not do that -- it adds an unnecessary deferral, and I've been trying to minimize those.  Also, `try`/`catch`ing your callback call is bad practice.  I'm always trying to weigh ease of use with disallowing bad practices, but this one comes with a performance hit....\n\nYou can easily define a decorator to apply the deferral workaround more broadly:\n\n``` js\nfunction newStack(fn) {\n  return function () {\n    setImmediate(fn);\n  };\n}\n\n//...\nbrowser.init({browserName: 'chrome'}).then(newStack(done));\n```\n"
      }
    ]
  },
  {
    "number": 787,
    "title": "how to do a simple for loop",
    "created_at": "2015-06-13T17:32:25Z",
    "closed_at": "2015-06-13T19:00:57Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/caolan/async/issues/787",
    "body": "I've been trying to figure out how to do a simple for loop, say, from 1 to 10, and have a callback when the loop is done. For example:\n\n```\nfor(i=1; i<=10;i++) {\n    User.insert({ username: \"user\" + i }, callback)\n}\n\nrunWhenDoneInserting();\n```\n\nI figured that it could be done using the `async.each` method, but that would mean building an array with all the elements I wanna loop, and that seems both wasteful (what if I want to execute a loop 1M times?), and also the array building code is quite declarative...\n\n```\nvar i = [];\nfor(var j = 1; j<=10;j++) {\n   i.push(j);\n}\n\nasync.each(i,foo,callback);\n```\n\n Is there any way to accomplish the above without having to manually create the iteration array?\nThanks!\n",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/787/comments",
    "author": "perrin4869",
    "comments": [
      {
        "user": "aearly",
        "created_at": "2015-06-13T19:00:57Z",
        "body": "`async.times` will do what you want.  Just make sure to call the passed callback for each iteration.\n"
      }
    ]
  },
  {
    "number": 757,
    "title": "iterator counter issue",
    "created_at": "2015-05-19T09:10:32Z",
    "closed_at": "2015-05-20T23:05:32Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/caolan/async/issues/757",
    "body": "any idea how to solve the following issue?\n\nvar index = 1;\nvar parallel = [];\n\nfor(i=0; i < 3; i++){\n\n  parallel.push(function(callback){\n        console.log(index); -> here should give me 1, 2, 3, but it give me only 3 instead. Any idea?\n   }); \n\nindex++;\n}\n\nasync.parallel(parallel, callback);\n",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/757/comments",
    "author": "martingg88",
    "comments": [
      {
        "user": "aearly",
        "created_at": "2015-05-19T16:22:05Z",
        "body": "It's a common closure scope problem caused by defining functions in loops.  The `index` variable is shared by all the parallel functions.\n\nYou'll have to capture it:\n\n```\nfor(i=0; i < 3; i++){\n  (function (index) \n    parallel.push(function(callback){\n      console.log(index);\n    });\n\n  }(i));\n}\n```\n\nor do something else:\n\n```\nvar parallel = _.range(3).map(function (index) {\n  return function (callback) {\n    console.log(index);\n  }\n});\n```\n"
      }
    ]
  },
  {
    "number": 698,
    "title": "check if last item in list?",
    "created_at": "2015-01-11T09:26:57Z",
    "closed_at": "2015-05-19T19:19:14Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/caolan/async/issues/698",
    "body": "Is there a way with `async.each` to know inside the callback if you're processing the last item in the list or not?\n",
    "comments_url": "https://api.github.com/repos/caolan/async/issues/698/comments",
    "author": "ralyodio",
    "comments": [
      {
        "user": "aearly",
        "created_at": "2015-01-12T00:50:53Z",
        "body": "Not unless you keep track of it yourself.\n"
      }
    ]
  }
]