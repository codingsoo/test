[
  {
    "number": 4302,
    "title": "11 vulnerabilities (4 moderate, 7 high)",
    "created_at": "2024-12-20T10:28:56Z",
    "closed_at": "2024-12-20T10:32:38Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/lovell/sharp/issues/4302",
    "body": "Running `npm install sharp` on macOS 15.1 using node 20.17.0 warns about vulnerabilities. Any plans to resolve these?\r\n\r\n```\r\nnpm install sharp --save-dev\r\n\r\nadded 8 packages, removed 70 packages, and audited 1139 packages in 17s\r\n\r\n193 packages are looking for funding\r\n  run `npm fund` for details\r\n\r\n11 vulnerabilities (4 moderate, 7 high)\r\n```",
    "comments_url": "https://api.github.com/repos/lovell/sharp/issues/4302/comments",
    "author": "saeid-elio",
    "comments": [
      {
        "user": "lovell",
        "created_at": "2024-12-20T10:32:38Z",
        "body": "> audited 1139 packages in 17s\r\n\r\nYou're running an audit on all of your dependencies, not just sharp.\r\n\r\n```\r\n$ npm i sharp\r\nadded 11 packages in 3s\r\n\r\n$ npm audit\r\nfound 0 vulnerabilities\r\n```"
      }
    ]
  },
  {
    "number": 4295,
    "title": "Changing exif data question",
    "created_at": "2024-12-13T19:31:47Z",
    "closed_at": "2024-12-14T08:06:41Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/lovell/sharp/issues/4295",
    "body": "Hi, could you please explain how to change ExifImageWidth and ExifImageHeight? I use withMetadata() and Ideally I want to copy all metadata except ExifImageWidth, ExifImageHeight. ImageHeight and ImageWidth copied too and it's not correct when I change orientation. Please help.",
    "comments_url": "https://api.github.com/repos/lovell/sharp/issues/4295/comments",
    "author": "ihopciklumer",
    "comments": [
      {
        "user": "lovell",
        "created_at": "2024-12-13T20:42:51Z",
        "body": "Please try something like the following:\r\n```js\r\n.withExif({\r\n  IFD0: {\r\n    PixelXDimension: \"123\",\r\n    PixelYDimension: \"456\"\r\n  }\r\n})\r\n```"
      }
    ]
  },
  {
    "number": 3849,
    "title": "Something went wrong installing the \"sharp\" module (libhdf5)",
    "created_at": "2023-11-10T14:47:18Z",
    "closed_at": "2023-11-10T15:47:23Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/lovell/sharp/issues/3849",
    "body": "There seems to be issue when trying to run a project that has 'sharp' module, npm install was fine, but it is when I run my project this blows up:\r\n\r\n```\r\nError: \r\nSomething went wrong installing the \"sharp\" module\r\n\r\ndlopen(/Users/me/myproj/node_modules/sharp/build/Release/sharp-darwin-arm64v8.node, 0x0001): Library not loaded: /opt/homebrew/opt/hdf5/lib/libhdf5.200.dylib\r\n  Referenced from: <34EC9DD4-F027-30F1-ABD4-70161DA46595> /opt/homebrew/Cellar/libmatio/1.5.23/lib/libmatio.11.dylib\r\n  Reason: tried: '/opt/homebrew/opt/hdf5/lib/libhdf5.200.dylib' (no such file), '/System/Volumes/Preboot/Cryptexes/OS/opt/homebrew/opt/hdf5/lib/libhdf5.200.dylib' (no such file), '/opt/homebrew/opt/hdf5/lib/libhdf5.200.dylib' (no such file), '/usr/local/lib/libhdf5.200.dylib' (no such file), '/usr/lib/libhdf5.200.dylib' (no such file, not in dyld cache), '/opt/homebrew/Cellar/hdf5/1.14.2/lib/libhdf5.200.dylib' (no such file), '/System/Volumes/Preboot/Cryptexes/OS/opt/homebrew/Cellar/hdf5/1.14.2/lib/libhdf5.200.dylib' (no such file), '/opt/homebrew/Cellar/hdf5/1.14.2/lib/libhdf5.200.dylib' (no such file), '/usr/local/lib/libhdf5.200.dylib' (no such file), '/usr/lib/libhdf5.200.dylib' (no such file, not in dyld cache)\r\n  ```\r\n  \r\n  It is complaining about not finding libhdf5.200, I've checked the folder, and I can see I have the following one (newer one?!):\r\n  \r\n  ```\r\nlibhdf5.310.dylib\r\n  ```\r\n\r\n\r\nI am running M1 macbook, node v18.18.0, npmjs 10.1.0,\r\n\r\n",
    "comments_url": "https://api.github.com/repos/lovell/sharp/issues/3849/comments",
    "author": "chr4ss12",
    "comments": [
      {
        "user": "lovell",
        "created_at": "2023-11-10T15:13:34Z",
        "body": "This looks like a local Homebrew misconfiguration, please try running `brew update && brew upgrade`"
      }
    ]
  },
  {
    "number": 3729,
    "title": "How to resize images when composite",
    "created_at": "2023-07-19T04:51:07Z",
    "closed_at": "2023-07-22T12:18:25Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/lovell/sharp/issues/3729",
    "body": "I am trying to merge images using 'sharp'.\r\nThere are 6 images, size is 1536x1536px.\r\n\r\nThe size of the combined image will be 1536x9216.\r\nI would like to know how to write a merged image to be reduced to 256x1536.\r\n\r\nindex.ts\r\n```typescript\r\nimport sharp from \"sharp\";\r\n\r\nasync function main() {\r\n\r\n  const imagePaths = [\"images/1.jpeg\", \"images/2.jpeg\", \"images/3.jpeg\",\"images/4.jpeg\", \"images/5.jpeg\", \"images/6.jpeg\"];\r\n  const outputImgWidth = 1536;\r\n  const outputImgHeight = 9216;\r\n \r\n    let totalHeight = 0;\r\n    const compositeParams = imagePaths.map(image => {\r\n      const top = totalHeight;\r\n      totalHeight += outputImgWidth;\r\n      \r\n      return {\r\n        input: image,\r\n        gravity: \"northwest\",\r\n        left: 0,\r\n        top: top\r\n      };\r\n    });\r\n  \r\n    await sharp({\r\n      create: {\r\n        width: outputImgWidth,\r\n        height: outputImgHeight,\r\n        channels: 4,\r\n        background: { r: 255, g: 255, b: 255, alpha: 0 }\r\n      }\r\n    })\r\n      .composite(compositeParams);\r\n      .toFile(`preview.jpg`,(err, info)=>{\r\n          if(err){ throw err }\r\n          console.log(info)\r\n        });\r\n}\r\n\r\nmain().then();\r\n``` \r\n\r\n\r\n",
    "comments_url": "https://api.github.com/repos/lovell/sharp/issues/3729/comments",
    "author": "HarunoOi",
    "comments": [
      {
        "user": "lovell",
        "created_at": "2023-07-19T09:15:39Z",
        "body": "Hi, in this example, because all the dimensions are known up-front, I'd suggest images are resized before composition:\r\n```diff\r\n-        input: image,\r\n+        input: await image.resize({ width: 256, height: 256 }).toBuffer(),\r\n```\r\n"
      },
      {
        "user": "HarunoOi",
        "created_at": "2023-07-21T05:01:32Z",
        "body": "I changed it to this writing style.\r\n`input: await sharp(image).resize(256).toBuffer(),`\r\n\r\nThen an error occurred in the following section.\r\n`.composite(compositeParams)`\r\n\r\nerror\r\n```\r\nArgument of type 'Promise<{ input: Buffer; left: number; top: number; }>[]'  is not assignable to parameter of type 'OverlayOptions[]' \r\nProperty  'Promise<{ input: Buffer; left: number; top: number; }>'  is missing in type 'OverlayOptions' \r\n```\r\n"
      },
      {
        "user": "lovell",
        "created_at": "2023-07-21T10:59:48Z",
        "body": "If your map function is `async` then you'll probably need to `await` it approximately here:\r\n```diff\r\n-     const compositeParams = imagePaths.map(async image => {\r\n+     const compositeParams = await Promise.all(imagePaths.map(async image => {\r\n```"
      }
    ]
  },
  {
    "number": 3696,
    "title": "Is it possible to access trim offsets for all sides and not just top and left?",
    "created_at": "2023-06-12T18:44:45Z",
    "closed_at": "2023-06-12T19:20:04Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/lovell/sharp/issues/3696",
    "body": "## Question about an existing feature\r\n\r\n### What are you trying to achieve?\r\n\r\nFor my specific use case I need to have access to the size that was trimmed from all sides and not just top and left (trimOffsetTop, trimOffsetLeft) returned by the trim method.\r\n\r\nThe main reason is that I need to save the original position that the actual content had within the transparent background in its original canvas, so that I'm able to \"recreate\" the image if needed for example, by repositioning the content in a different canvas later.\r\n\r\nIn my cases there is no guarantee the top/bottom transparent space are equal, and the same applies to left/right as well.\r\n\r\nIs it possible to achieve this with sharp right now? I could not find any related issues or discussions and I'm yet to read through the source code.\r\n\r\nSomething tells me I should be able to achieve this without sharp, before trimming, but I didn't want to come up with a solution that acts different than the `trim` and end up with inconsistent saved data vs output.\r\n\r\nThanks!\r\n",
    "comments_url": "https://api.github.com/repos/lovell/sharp/issues/3696/comments",
    "author": "gugiserman",
    "comments": [
      {
        "user": "lovell",
        "created_at": "2023-06-12T18:57:18Z",
        "body": "You can calculate this using the input and output dimensions.\r\n```\r\nright offset = input width - output width - left offset\r\nbottom offset = input height - output height - top offset\r\n```"
      }
    ]
  },
  {
    "number": 3403,
    "title": "How do I output multiple resized images in multiple formats?",
    "created_at": "2022-10-11T01:19:02Z",
    "closed_at": "2022-10-11T16:31:03Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/lovell/sharp/issues/3403",
    "body": "So far I have been able to figure out how to take in an image and output multiple sizes, like so:\r\n\r\n```js\r\nconst sharp = require('sharp')\r\n\r\nconst image = `beach`;\r\nconst format = `jpg`;\r\n\r\nconst resize = size => sharp(`${image}.jpg`)\r\n  .resize({ width: size })\r\n  .toFile(__dirname + `/processed/${image}-${size}.${format}`)\r\n;\r\n\r\nPromise\r\n  .all([2160, 1920, 1440, 1080, 720, 480, 320].map(resize))\r\n  .then(() => {\r\n    console.log('Image resizing is complete.');\r\n  });\r\n```\r\n\r\n...and it works just fine.\r\n\r\nNow I want to be able to output multiple formats of each resized image as well (`avif` is the preferred choice, but `jpg` is the fallback kind of thing), but can't figure it out...\r\n\r\nI've tried this so far:\r\n\r\n```js\r\nconst sharp = require('sharp')\r\n\r\nconst image = `beach`;\r\nconst format = [`jpg`, `avif`]\r\n\r\nconst resize = size => sharp(`${image}.jpg`)\r\n  .resize({ width: size })\r\n  .toFile(__dirname + `/processed/${image}-${size}.${format[0]}`)\r\n  .toFile(__dirname + `/processed/${image}-${size}.${format[1]}`)\r\n;\r\n\r\nPromise\r\n  .all([2160, 1920, 1440, 1080, 720, 480, 320].map(resize))\r\n  .then(() => {\r\n    console.log('Image resizing is complete.');\r\n  });\r\n```\r\n\r\n...but it seems that I cannot chain two `toFile`'s together?\r\n\r\nBeen googling around but have not found anything yet...\r\n\r\nAny help is greatly appreciated, thank you XD",
    "comments_url": "https://api.github.com/repos/lovell/sharp/issues/3403/comments",
    "author": "rchrdnsh",
    "comments": [
      {
        "user": "lovell",
        "created_at": "2022-10-11T07:33:22Z",
        "body": "Perhaps try something like (untested):\r\n```js\r\nconst resize = (width) =>\r\n  Promise.all(\r\n    format.map((f) =>\r\n      sharp(`${image}.jpg`)\r\n        .resize({ width })\r\n        .toFile(__dirname + `/processed/${image}-${width}.${f}`)\r\n    )\r\n  );\r\n```\r\n"
      }
    ]
  },
  {
    "number": 3299,
    "title": "How sharpness works with multi-page PDFs?",
    "created_at": "2022-07-20T15:12:38Z",
    "closed_at": "2022-07-21T07:40:12Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/lovell/sharp/issues/3299",
    "body": "Hi,\r\nFirst of all, thank you for this library, it's really great!\r\n\r\nI'm wondering how is the sharpness calculated for PDF file?\r\n\r\nFor example, I have a PDF file with a few pages inside, I read it with `sharp` and convert to one large image. \r\nWhen I check it for the sharpness, what will I get: some average value for all the pages, minimal sharpness of the most blurred page or something else?\r\n\r\nSorry if there is an answer somewhere, couldn't find it.\r\nBest regards!",
    "comments_url": "https://api.github.com/repos/lovell/sharp/issues/3299/comments",
    "author": "4m4rel",
    "comments": [
      {
        "user": "lovell",
        "created_at": "2022-07-21T07:25:15Z",
        "body": "The following will calculate the sharpness of all pages combined (imagine they have been stitched together top to bottom).\r\n```js\r\nconst { sharpness } = await sharp(input, { pages: -1 }).stats();\r\n```\r\nIf you want averages/min/max etc., you'll need to make one call per page and calculate yourself:\r\n```js\r\nconst sharpnessFirstPage = (await sharp(input, { page: 0 }).stats()).sharpness;\r\nconst sharpnessSecondPage = (await sharp(input, { page: 1 }).stats()).sharpness;\r\n...\r\n```"
      }
    ]
  },
  {
    "number": 3089,
    "title": "Reducing memory usage",
    "created_at": "2022-02-11T19:20:45Z",
    "closed_at": "2022-03-12T09:37:46Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/lovell/sharp/issues/3089",
    "body": "### What are you trying to achieve?\r\nI'm processing batches of 200-400MB TIFF files on an instance with 1GB of memory. It is occasionally not enough. I'm trying to understand what I can do better to manage memory.\r\n\r\n### Have you searched for similar questions?\r\nYes, I've landed on #138 and related issues regarding streaming. But I'm not sure if this is the best approach.\r\n\r\nMy use case requires me to clone and downsample the entire image to be analyzed. I then use the analysis results for processing the full-size image. If I am to change the file to a stream, I may not be able to split it into two parts (one, downsized, for analysis and one for processing).\r\n\r\nI currently start the instance on `node:14-alpine` container with `--optimize_for_size --max_old_space_size=320 --gc_interval=50`. Other than streaming, I'm also considering adding an artificial delay between jobs to ensure that the memory has time to empty out.\r\n\r\nI would really appreciate some guidance here. Thank you so much!\r\n\r\n### Are you able to provide a minimal, standalone code sample that demonstrates this question?\r\n```javascript\r\n\r\n// create a reduced-size image sample\r\nconst data = await sharp(image).clone().resize(500).toBuffer();\r\n\r\n// this object will store values that will be used for full-size image manipulation\r\nconst prescriptions = {};\r\n\r\n// determine values for full-size image manipulation\r\nconst channelNames = [\"red\", \"green\", \"blue\"];\r\nconst prescriptionsCalculators = channelNames.map(async (channel) => {\r\n  const forAnalysis = await sharp(data)\r\n  .extractChannel(channel)\r\n  .toColorspace(\"b-w\")\r\n  .blur(1)\r\n  .toBuffer();\r\n\r\n  const stats = await sharp(forAnalysis).stats();\r\n  const { channels } = stats;\r\n\r\n  const range = [channels[0].min, channels[0].max];\r\n  const linear = levels(range[0], range[1]);\r\n\r\n  prescriptions[channel] = { linear, range };\r\n  return await linear;\r\n});\r\nawait Promise.all(prescriptionsCalculators);\r\n\r\n// use the above data to process full-size image\r\nconst channels = {};\r\nconst channelEffects = channelNames.map(async (channel) => {\r\n  const result = sharp(reversed)\r\n    .extractChannel(channel)\r\n    .toColorspace(\"b-w\")\r\n    .linear(...prescriptions[channel].linear)\r\n    .toBuffer();\r\n  channels[channel] = result;\r\n  return result;\r\n});\r\nawait Promise.all(channelEffects);\r\n\r\n// reassemble channels into RGB\r\nconst positive = sharp(await channels[\"red\"]).joinChannel([\r\n  await channels[\"green\"],\r\n  await channels[\"blue\"],\r\n]);\r\n\r\nreturn positive;\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/lovell/sharp/issues/3089/comments",
    "author": "dmitrizzle",
    "comments": [
      {
        "user": "lovell",
        "created_at": "2022-02-18T21:34:14Z",
        "body": "The quickest way to reduce memory usage would be to switch from RAM to filesystem. Have you tried replacing any of the `toBuffer` calls with `toFile`?"
      }
    ]
  },
  {
    "number": 2975,
    "title": "pipeline await and toBuffer",
    "created_at": "2021-11-15T18:59:31Z",
    "closed_at": "2021-12-12T20:52:23Z",
    "labels": [
      "question",
      "cookbook"
    ],
    "url": "https://github.com/lovell/sharp/issues/2975",
    "body": "I am trying to pipe an input stream to a sharp pipeline and get a buffer out of it.\r\nTo be able to handle the input stream errors, i thought i could do this:\r\n\r\n```\r\nconst sharp = require('sharp');\r\nconst pipeline = require('util').promisify(require('stream').pipeline);\r\nconst got = require('got');\r\n\r\nasync function getThumbnailBuffer(uri) {\r\n\tconst pil = sharp().resize({\r\n\t\tfit: \"inside\",\r\n\t\theight: 64\r\n\t}).toFormat('webp', {\r\n\t\tquality: 50\r\n\t});\r\n\tconst pipe = await pipeline(got.stream(uri), pil);\r\n\tconst buf = await pil.toBuffer();\r\n\treturn buf; // i know i can return pil.toBuffer(), i do this to show where we wait\r\n};\r\n```\r\n\r\nhowever that doesn't work - `await pipeline` doesn't return when no error is thrown.\r\nOn the other hand, it correctly (meaning `try { await getThumbnailBuffer(url); }` works) throws an error (from got.stream) when there is one.\r\n\r\nI also tried this but toBuffer is not a stream, so it can't work:\r\n```\r\n\treturn await pipeline(got.stream(uri), pil.toBuffer());\r\n```\r\n\r\nInstead i had to do that:\r\n\r\n```\r\nconst sharp = require('sharp');\r\nconst pipeline = require('util').promisify(require('stream').pipeline);\r\nconst got = require('got');\r\n\r\nmodule.exports = async function (uri) {\r\n\tconst pil = sharp().resize({\r\n\t\tfit: \"inside\",\r\n\t\theight: 64\r\n\t}).toFormat('webp', {\r\n\t\tquality: 50\r\n\t});\r\n\tlet toBuff;\r\n\tsetTimeout(async () => {\r\n\t\ttoBuff = pil.toBuffer();\r\n\t});\r\n\tawait pipeline(got.stream(uri), pil);\r\n\tconst buf = await toBuff;\r\n\treturn buf; // i know i can return toBuff, i do this to show where we wait\r\n};\r\n```\r\n\r\nthis works and also catches (in a way compatible with async/await) errors.\r\nHowever it's ugly.\r\nIt's hard to tell if it comes from\r\n- node\r\n- got\r\n- sharp\r\nbut right now i'm inclined to think the need to call \"toBuffer\" to trigger the stream is odd.\r\n",
    "comments_url": "https://api.github.com/repos/lovell/sharp/issues/2975/comments",
    "author": "kapouer",
    "comments": [
      {
        "user": "lovell",
        "created_at": "2021-11-15T19:24:15Z",
        "body": "A `sharp` instance implements a `Duplex` stream so won't emit the `close` event (and therefore resolve the \"promisified\" logic here) until it knows the destination of the output, as this might be another `WritableStream`.\r\n\r\nPerhaps an alternative approach might be to `await` the input and output sides concurrently, something like (untested):\r\n```js\r\nconst [pipe, buf] = await Promise.all([\r\n  pipeline(got.stream(uri), pil),\r\n  pil.toBuffer()\r\n]);\r\n```"
      },
      {
        "user": "kapouer",
        "created_at": "2021-11-15T20:57:11Z",
        "body": "Yes ! that's so much nicer ! Even better, this works too:\r\n```\r\nconst [buf] = await Promise.all([\r\n  pil.toBuffer(),\r\n  pipeline(got.stream(uri), pil)\r\n]);\r\n```\r\nmaybe it would help so much if it was given as an example somewhere in the documentation.\r\nEDIT: i made sure this actually works and also actually throws correctly in case of input stream error."
      }
    ]
  },
  {
    "number": 2973,
    "title": "Sharp get crash when run on docker with node:12-alpine",
    "created_at": "2021-11-15T11:44:47Z",
    "closed_at": "2021-11-15T14:09:41Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/lovell/sharp/issues/2973",
    "body": "\r\nI'm using the sharp version 0.26.3 to resize my images, when I run my application on local (using Windows 11), it working fine but when I deploy the code to server using docker with node:12-alpine image, my application crash when sharp resize uploaded image without any exception.\r\nI was tried to set cache to false or set cache to  sharp.cache({ memory: 0, files: 0, items: 0 }) but nothing helpful.\r\nMy size image code\r\n const image = await sharp(`${destPath}/${fileName}`)\r\n              .resize({ height })\r\n              .toFormat('jpeg')\r\n              .toFile(localStoragePath);",
    "comments_url": "https://api.github.com/repos/lovell/sharp/issues/2973/comments",
    "author": "sonnguyenjom",
    "comments": [
      {
        "user": "lovell",
        "created_at": "2021-11-15T11:49:27Z",
        "body": "This is probably #2570, please can you upgrade to the latest version."
      }
    ]
  },
  {
    "number": 2853,
    "title": "sharp.format.avif returns undefined",
    "created_at": "2021-08-20T12:53:17Z",
    "closed_at": "2021-08-20T15:07:36Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/lovell/sharp/issues/2853",
    "body": "I am using latest version of sharp (0.29.0) and I noticed that ``sharp.format.avif`` returns undefined. Would you please investigate?\r\n\r\nBest regards,\r\nAngel Kiryazov",
    "comments_url": "https://api.github.com/repos/lovell/sharp/issues/2853/comments",
    "author": "akiryazov",
    "comments": [
      {
        "user": "lovell",
        "created_at": "2021-08-20T15:05:13Z",
        "body": "Hi, please see the `sharp.format.heif` property (AVIF files are HEIF files that use AV1 compression).\r\n```sh\r\n$ node -p \"require('sharp').format.heif\"\r\n{\r\n  id: 'heif',\r\n  input: { file: true, buffer: true, stream: true },\r\n  output: { file: true, buffer: true, stream: true }\r\n}\r\n```"
      }
    ]
  },
  {
    "number": 2776,
    "title": "PNG to JPEG: how to keep high quality",
    "created_at": "2021-06-30T15:19:13Z",
    "closed_at": "2021-06-30T19:35:23Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/lovell/sharp/issues/2776",
    "body": "Hello ! \r\n\r\nI'm trying to convert PNG image buffer to a JPEG image buffer.\r\nIt's working but I have a quality loss when I'm displaying the JPEG from Buffer.\r\n\r\nHere my simple code to convert PNG to JPEG:\r\n```javascript\r\nformatted = await sharp(pngImgBuffer)\r\n      .toFormat('jpeg')\r\n      .jpeg({ quality: 100, chromaSubsampling: '4:4:4', force: true })\r\n      .toBuffer(); // JPEG buffer\r\n```\r\n\r\nAnd the reading part (with resize):\r\n```javascript\r\nresized = await sharp(jpegImgBuffer)\r\n      .resize(width, height)\r\n      .toFormat('jpeg')\r\n      .jpeg({ quality: 100, chromaSubsampling: '4:4:4', force: true })\r\n      .toBuffer();\r\n```\r\n\r\nIs there something wrong in my code ? Or something else to do to improve the quality of the result ?",
    "comments_url": "https://api.github.com/repos/lovell/sharp/issues/2776/comments",
    "author": "simon-tannai",
    "comments": [
      {
        "user": "lovell",
        "created_at": "2021-06-30T15:39:13Z",
        "body": "PNG is a lossless format whereas JPEG is a lossy format, so you'll always lose some detail when encoding with the latter, even at maximum \"quality\".\r\n\r\n(This applies to all software that creates JPEG images, not just sharp.)"
      },
      {
        "user": "lovell",
        "created_at": "2021-06-30T18:27:35Z",
        "body": "If preventing any loss of original detail is important in your scenario, then yes, the use of PNG or lossless WebP will meet that need."
      }
    ]
  },
  {
    "number": 2718,
    "title": " VipsJpeg: Corrupt JPEG data: premature end of data segment",
    "created_at": "2021-05-16T18:24:59Z",
    "closed_at": "2021-05-16T18:44:44Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/lovell/sharp/issues/2718",
    "body": "I am trying to resize an array of images here is my code:\r\nconst Sharp = require('sharp');\r\nconst fs = require('fs');\r\n\r\nconst transformer = Sharp().resize(300);\r\n\r\n\r\nconst addFoto = async (request, h) => {\r\n  const fotos = [].concat(request.payload.fotoFile);\r\n  const smallerFotos = Promise.all(fotos.map(async (foto) => {\r\n    const writeStream = fs.createWriteStream(foto.hapi.filename);\r\n    return foto.pipe(transformer).pipe(writeStream);\r\n  }));\r\nthe code works when the array length is one\r\nbut fails when more than file is in the array \r\nfiles are jpeg\r\nthanks\r\n",
    "comments_url": "https://api.github.com/repos/lovell/sharp/issues/2718/comments",
    "author": "mibuen",
    "comments": [
      {
        "user": "lovell",
        "created_at": "2021-05-16T18:33:20Z",
        "body": "You'll need to create a new sharp instance per input.\r\n```diff\r\n- const transformer = Sharp().resize(300);\r\n+ const transformer = () => Sharp().resize(300);\r\n\r\n  const addFoto = async (request, h) => {\r\n  const fotos = [].concat(request.payload.fotoFile);\r\n  const smallerFotos = Promise.all(fotos.map(async (foto) => {\r\n  const writeStream = fs.createWriteStream(foto.hapi.filename);\r\n- return foto.pipe(transformer).pipe(writeStream);\r\n+ return foto.pipe(transformer()).pipe(writeStream);\r\n  }));\r\n```"
      }
    ]
  },
  {
    "number": 2698,
    "title": "Error: extract_area: bad extract area if display not main display in Windows",
    "created_at": "2021-05-06T16:06:54Z",
    "closed_at": "2021-05-07T14:24:22Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/lovell/sharp/issues/2698",
    "body": "Hello. \r\n\r\n**Issue**: On a windows machine, when I am working with 2 displays, when I try to `extract` and then save `toBuffer` on a display which is not the main display, I get the following error: `Error: extract_area: bad extract area` . However, the same code works perfectly fine if I make that display as my main display.\r\n\r\n**Expected Behavior**: I want to be able to `extract` and save `toBuffer` on a display which is not the main display.\r\n\r\n**Sample Code**\r\n\r\n```\r\n    let bounds = { x: 2496, y: 25, width: 968, height: 702 }\r\n    const cropped = await sharp(screenshotImg);\r\n    const metadata = await cropped.metadata();\r\n    const height = Math.min(metadata.height,bounds.height);\r\n    const width = Math.min(metadata.width, bounds.width);\r\n    const left = Math.max(0, bounds.x);\r\n    const top = Math.max(0, bounds.y);\r\n    const result = cropped.extract({ left: left, top: top, width, height });\r\n    const bufferResult = await result.toBuffer();  // This line gives Error: extract_area: bad extract area\r\n    return sharp(bufferResult, { height, width, channels: 3 });\r\n```\r\nI checked that the extraction bounds are within the limits of the image that I am trying to extract from. \r\n\r\nAny help is appreciated. Please let me know if you require more info. Thanks",
    "comments_url": "https://api.github.com/repos/lovell/sharp/issues/2698/comments",
    "author": "samarth-bola",
    "comments": [
      {
        "user": "lovell",
        "created_at": "2021-05-06T17:38:18Z",
        "body": "Please can you provide a sample input image that fails in this manner. Based on the sample code provided it should be at least 3464x727 in dimensions."
      },
      {
        "user": "samarth-bola",
        "created_at": "2021-05-06T18:13:14Z",
        "body": "> Please can you provide a sample input image that fails in this manner. Based on the sample code provided it should be at least 3464x727 in dimensions.\r\n\r\nThe input image is the screenshot of the display screen (resolution: 1200x1920) in .png format. So the dimensions of the input image is 1200x1920. That would be the same if its the main display or the secondary display. "
      },
      {
        "user": "lovell",
        "created_at": "2021-05-06T18:38:25Z",
        "body": "> I checked that the extraction bounds are within the limits of the image that I am trying to extract from.\r\n\r\nThe value of `left` in the code above will be 2496, which is already out of bounds for a 1200px wide image.\r\n\r\nPerhaps you could provide a sample repo with code and images that allows someone else to reproduce this."
      },
      {
        "user": "samarth-bola",
        "created_at": "2021-05-07T14:24:22Z",
        "body": "> > I checked that the extraction bounds are within the limits of the image that I am trying to extract from.\r\n> \r\n> The value of `left` in the code above will be 2496, which is already out of bounds for a 1200px wide image.\r\n> \r\n> Perhaps you could provide a sample repo with code and images that allows someone else to reproduce this.\r\n\r\nThe value of `left` was definitely the issue. It was out of bounds which was giving the error in the first place. Thanks a bunch for pointing it out."
      }
    ]
  },
  {
    "number": 2638,
    "title": "Metadata before and after Resize",
    "created_at": "2021-03-25T08:32:38Z",
    "closed_at": "2021-03-25T14:05:22Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/lovell/sharp/issues/2638",
    "body": "Hello, \r\n\r\nIs possible to get both metada from image resized in a single step ?\r\nIn other words, two metadata for same image, before and after resize, in a single step.\r\n\r\nTo get metadata after resize I use :\r\n\r\n```\r\n    sharp(imageBuffer)                              \r\n    \t.resize(800, 900, {                                           \r\n    \t\tfit: 'inside',                                              \r\n    \t\twithoutEnlargement: true                                    \r\n    \t})\r\n        .jpeg({ quality: 80 })\r\n    \t.toBuffer({ resolveWithObject: true })\r\n    \t.then(data => {\r\n               console.log(data);\r\n \t    })\r\n    \t.catch(err => {if (err) \r\n    \t{\r\n    \t    console.log(err);\r\n    \t    throw err;\r\n    \t}\r\n    });\r\n```\r\n\r\nTo get metada before resize I use `.metadata()`.\r\n\r\nBut how to get both metadata in a single step ?",
    "comments_url": "https://api.github.com/repos/lovell/sharp/issues/2638/comments",
    "author": "softy2k",
    "comments": [
      {
        "user": "lovell",
        "created_at": "2021-03-25T12:25:21Z",
        "body": "Perhaps try something like the following (untested):\r\n```js\r\nconst [ before, after ] = await Promise.all([\r\n  sharp(imageBuffer).metadata(),\r\n  sharp(imageBuffer).resize({ ... }).toBuffer({ resolveWithObject: true })\r\n]);\r\n```"
      }
    ]
  },
  {
    "number": 2442,
    "title": "Webp vs. JPEG sizes?",
    "created_at": "2020-11-15T21:45:42Z",
    "closed_at": "2020-11-27T14:00:23Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/lovell/sharp/issues/2442",
    "body": "I am a newbie for image processing.  To my understanding, webp is supposed to have smaller size than jpeg.  However, from my experiment, this is not the case after converting to both format using Sharp.\r\n\r\nI am actually getting smaller sizes when converting to JPEG.  \r\nHere is my configurations:\r\n```\r\nsharp().resize({ width: 300 }).jpeg({ quality: 100 })\r\nsharp().resize({ width: 300 }).webp({ lossless: true })\r\n```\r\nOriginal PNG size is 937 KB.\r\nConverted JPEG is 408.7 KB\r\nConverted WEBP is 584.9 KB\r\n\r\nFor resized smaller images are the same result.  \r\nAm I missing something or this is expected?\r\n\r\n",
    "comments_url": "https://api.github.com/repos/lovell/sharp/issues/2442/comments",
    "author": "RoosterH",
    "comments": [
      {
        "user": "lovell",
        "created_at": "2020-11-16T11:59:58Z",
        "body": "Hi, JPEG is always lossy, even at a \"quality\" of 100.\r\n\r\nA fairer comparison might be:\r\n```diff\r\n  sharp().resize({ width: 300 }).jpeg({ quality: 100 })\r\n- sharp().resize({ width: 300 }).webp({ lossless: true })\r\n+ sharp().resize({ width: 300 }).webp({ quality: 100 })\r\n```"
      }
    ]
  },
  {
    "number": 2392,
    "title": "await does not work?",
    "created_at": "2020-10-02T00:45:11Z",
    "closed_at": "2020-10-02T16:02:17Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/lovell/sharp/issues/2392",
    "body": "My code:\r\n\r\n```\r\nconst fs = require('fs');\r\nconst sharp = require('sharp');\r\n\r\nconst src = '/tmp/input.jpg';\r\nconst dst = '/tmp/output.jpg';\r\n\r\n(async () => {\r\n    await sharp(src).resize(100, 100).toFile(dst);\r\n    await fs.chmod(dst, 0o666);\r\n})();\r\n\r\n```\r\nI have got an error:\r\n`exception: Error: ENOENT: no such file or directory, chmod '/tmp/output.jpg'`\r\n\r\nIt looks like chmod runs before the sharp has been done its job.\r\n\r\nAny ideas?",
    "comments_url": "https://api.github.com/repos/lovell/sharp/issues/2392/comments",
    "author": "m00nk",
    "comments": [
      {
        "user": "lovell",
        "created_at": "2020-10-02T08:47:42Z",
        "body": "Hi, `fs.chmod` does not return a Promise, so this might be the cause. Perhaps add a try/catch block around each use of `await`?"
      },
      {
        "user": "m00nk",
        "created_at": "2020-10-02T11:26:10Z",
        "body": "I have tried this:\r\n\r\n```\r\n(async () => {\r\n    await sharp(src).resize(100, 100).toFile(dst);\r\n    await fs.promises.chmod(dst, 0o666);\r\n})();\r\n```\r\n\r\nand had the same result - chmod runs before the output file has been created."
      },
      {
        "user": "lovell",
        "created_at": "2020-10-02T11:42:58Z",
        "body": "Please can you provide complete information about the versions, platform, OS etc. involved."
      },
      {
        "user": "m00nk",
        "created_at": "2020-10-02T12:39:44Z",
        "body": "Linux Mint (Ubuntu), Node 12.18, sharp 0.26.0"
      },
      {
        "user": "lovell",
        "created_at": "2020-10-02T12:59:06Z",
        "body": "Thanks, I cannot reproduce this. Is there anything unusual about the /tmp filesystem on this machine? Does using a non-tmp path work? What happened when you added the separate try/catch blocks around each use of await?"
      },
      {
        "user": "m00nk",
        "created_at": "2020-10-02T14:03:02Z",
        "body": "I have found very strange behavior. The code:\r\n\r\n```js\r\nconsole.log('START');\r\n\r\nconst proc = sharp(srcImg);\r\n// some other code is here\r\nproc\r\n\t.toFile(dstImg)\r\n\t.then(info => { console.log('INFO', info);})\r\n\t.catch(err => { console.log('ERR', err);});\r\n\r\ntry{\r\n\tawait proc;\r\n\tconsole.log('DONE PROC');\r\n}\r\ncatch(e){ console.log('EXCEPTION', e); }\r\n\r\nconsole.log('FINISHED');\r\n```\r\n\r\nI have got:\r\n```\r\nSTART\r\nDONE PROC\r\nFINISHED\r\nINFO {\r\n   format: 'jpeg',\r\n   width: 250,\r\n   height: 90,\r\n   channels: 3,\r\n   premultiplied: false,\r\n   size: 8098\r\n }\r\n```\r\n\r\nSo last console.log runs before the image has been created. But if I use \"the chain\" like:\r\n\r\n```js\r\nconst proc = sharp(srcImg)\r\n\t.toFile(dstImg)\r\n\t.then(info => {\tconsole.log('INFO', info);\t})\r\n\t.catch(err => {\tconsole.log('ERR', err);\t});\r\n```\r\ninstead of\r\n```js\r\nconst proc = sharp(srcImg);\r\nproc.toFile(dstImg)\r\n\t.then(info => { console.log('INFO', info);})\r\n\t.catch(err => { console.log('ERR', err);});\r\n```\r\nI have got:\r\n\r\n```\r\nSTART\r\nINFO {\r\n   format: 'jpeg',\r\n   width: 250,\r\n   height: 90,\r\n   channels: 3,\r\n   premultiplied: false,\r\n   size: 8098\r\n}\r\nDONE PROC\r\nFINISHED\r\n```\r\n\r\nIn this way all works right - last console.log runs AFTER the image has been created.\r\n\r\nCan you explain this behaviour? I am not very good in JS, so maybe I do something wrong, but in my opinion that behoviour is very odd. \r\n\r\nThank you.\r\n\r\nPS.\r\nAll code above placed inside async function. "
      },
      {
        "user": "lovell",
        "created_at": "2020-10-02T14:12:50Z",
        "body": "Your code is mixing up Promise chains and await/try/catch notation.\r\n\r\nThe call to `toFile()` returns a Promise, so that's what you must `await`, e.g. `await proc.toFile(dstImg)`\r\n\r\nYou can't await a sharp instance itself, so e.g. `await proc` is incorrect (it resolves straight away)."
      }
    ]
  },
  {
    "number": 2278,
    "title": "base64\u7f16\u7801\u5b57\u7b26\u4e32\u4e0d\u6b63\u786e\u7684\u65f6\u5019\uff0ctry/catch\u6ca1\u6709\u6355\u83b7\u5230error",
    "created_at": "2020-07-03T08:55:37Z",
    "closed_at": "2020-07-04T11:00:37Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/lovell/sharp/issues/2278",
    "body": "\u5ba2\u6237\u7aef\r\nlet buff = fs.readFileSync(fileName)\r\nlet base64Str = buff.toString('base64')\r\nbase64Str = base64Str.substring(0, base64Str.length - 100) \uff08base64Str.length > 100)\r\n\r\n\u670d\u52a1\u7aef\r\ntry {\r\n  let buffer = Buffer.from(base64Str, 'base64')\r\n  let img = sharp(buffer)\r\n  await img.metadata()\r\n  sharp(buffer).resize(width, height)\r\n} catch (error) {\r\n  \r\n}\r\n\r\n\u6709\u8f93\u51fa\r\nUncaught Error: VipsJpeg: Premature end of JPEG file\r\nVipsJpeg: out of order read at line 1008\r\n\r\n\u4f46\u662f\u6211\u6ca1\u6709\u5728catch\u91cc\u9762\u6355\u83b7\u5230error\uff0c\u8bf7\u95ee\u4e0b\u662f\u4ec0\u4e48\u539f\u56e0\uff1f",
    "comments_url": "https://api.github.com/repos/lovell/sharp/issues/2278/comments",
    "author": "tangna",
    "comments": [
      {
        "user": "lovell",
        "created_at": "2020-07-03T13:05:41Z",
        "body": "Does the following change, to `await` a call to `toBuffer`, ensure the error is caught?\r\n```diff\r\n- sharp(buffer).resize(width, height)\r\n+ await sharp(buffer).resize(width, height).toBuffer()\r\n```\r\nIf not, please provide a complete, standalone code sample and image that allows someone else to reproduce this problem."
      },
      {
        "user": "lovell",
        "created_at": "2020-07-03T20:42:35Z",
        "body": "The use of Stream-based output means you can no longer \"catch\" errors, instead you'll need to listen for the error event.\r\n```diff\r\n- sharp(buffer).resize(width, height)\r\n+ sharp(buffer).resize(width, height).on('error', err => { ... })\r\n```\r\n\r\n(This is a Node.js concept rather than being specific to sharp.)"
      }
    ]
  },
  {
    "number": 2184,
    "title": "Can't compress a 24 bit jpg to an 8 bit jpg",
    "created_at": "2020-04-27T07:50:22Z",
    "closed_at": "2020-04-27T21:19:35Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/lovell/sharp/issues/2184",
    "body": "What are you trying to achieve?\r\ncompress a 24 bit jpg to an 8 bit jpg\r\n\r\nHave you searched for similar feature requests?\r\nyes, couldn't find anything\r\n\r\nWhat would you expect the API to look like?\r\n\r\nawait sharp(in).depth(8).toFile(out);\r\n\r\nWhat alternatives have you considered?\r\npngquant but it's only for png files\r\n\r\nIs there a sample image that helps explain?\r\nno",
    "comments_url": "https://api.github.com/repos/lovell/sharp/issues/2184/comments",
    "author": "quinton-ashley",
    "comments": [
      {
        "user": "lovell",
        "created_at": "2020-04-27T09:07:59Z",
        "body": "Hi, JPEG images use 8 bits per channel, so a 24-bit JPEG is three-channel RGB and an 8-bit JPEG is single-channel greyscale.\r\n\r\n(JPEG images can also use 12 bits per channel, but those are very rare and most software does not support them.)"
      }
    ]
  },
  {
    "number": 2163,
    "title": "Conversion some time leading to blur on images",
    "created_at": "2020-04-13T19:19:03Z",
    "closed_at": "2020-04-14T05:52:38Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/lovell/sharp/issues/2163",
    "body": "TLDR; Using blur filter randomly blurs the images which are not to be blurred.\r\nI am converting images into 5 resolutions and blurring the lowest resolution on i.e. 200px wid only. but some how some random images gets blurred. Using blur is high priority to reduce images size. Calling convert image function using calbackify.\r\n`\r\nvar WebpOptions = {\r\n    reductionEffort: 4,\r\n    quality: 70,\r\n}\r\n\r\nvar JpegOptions = {\r\n    quantisationTable: 8,\r\n    quality: 60,\r\n    trellisQuantisation: true,\r\n    overshootDeringing: true,\r\n    chromaSubsampling: '4:2:0'\r\n}\r\nasync function convertImage(Map) {\r\n\r\n    var promises = [];\r\n    var logs = [];\r\n\r\n    if (typeof (Map) !== 'object')\r\n        throw Error(`Given Map ${Map} data is not in the form of an object`);\r\n\r\n    for (let [key, value] of Object.entries(Map)) {\r\n\r\n        var files = fs.readdirSync(key);\r\n\r\n        for (let i = 0; i < files.length; i++) {\r\n            let ls = fs.lstatSync(`${key}${files[i]}`)\r\n            if (ls.isFile())\r\n                files[i] = {\r\n                    name: files[i],\r\n                    path: `${key}${files[i]}`,\r\n                    size: ls.size\r\n                };\r\n            else\r\n                files[i] = null;\r\n        }\r\n\r\n        for (var i = 0; i < files.length; i++) {\r\n            if (files[i] === null)\r\n                continue;\r\n            var filename = path.basename(files[i].name).split('.');\r\n            filename[0] = filename[0].replace(/ /g, '_');\r\n\r\n            var res = [2000, 1000, 800, 600, 100];\r\n\r\n            for (let j = 0; j < res.length; j++) {\r\n                let target = path.resolve(`${value}${res[j]}/`);\r\n                if (!fs.existsSync(target)) {\r\n                    console.log(`MKDIR ${target}`);\r\n                    fs.mkdirSync(target, { recursive: true });\r\n                }\r\n            }\r\n\r\n            var Image = sharp(files[i].path).resize(res[0]);\r\n            \r\n            var pipeline = Image.clone().webp(WebpOptions)\r\n\r\n            for (let j = 0; j < res.length; j++) {\r\n                let target = `${value}${res[j]}/${filename[0]}.webp`;\r\n                if (res[j] == 100) {\r\n\r\n                    let rendition = pipeline;\r\n                    let size = res[j]\r\n                    promises.push(blurImage(rendition, size, target))\r\n                }\r\n                else {\r\n\r\n                    let rendition = pipeline;\r\n                    let size = res[j]\r\n                    promises.push(fineImage(rendition, size, target))\r\n\r\n                }\r\n            }\r\n\r\n            pipeline = Image.clone().jpeg(JpegOptions)\r\n\r\n            for (let j = 0; j < res.length; j++) {\r\n                let target = `${value}${res[j]}/${filename[0]}.jpg`;\r\n                if (res[j] == 100) {\r\n\r\n                    let rendition = pipeline;\r\n                    let size = res[j]\r\n                    promises.push(blurImage(rendition, size, target))\r\n                }\r\n                else {\r\n\r\n                    let rendition = pipeline;\r\n                    let size = res[j]\r\n                    promises.push(fineImage(rendition, size, target))\r\n\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    function fineImage(rendition, size, target) {\r\n        return rendition\r\n            .clone()\r\n            .metadata()\r\n            .then(metadata => rendition\r\n                .resize(size, null, { fastShrinkOnLoad: false })\r\n                .toFile(target)\r\n                .then(info => { return { info, target, metadata, shape : 'fine' }; }))\r\n            .catch(err => console.log(err));\r\n    }\r\n\r\n    function blurImage(rendition, size, target) {\r\n        return rendition\r\n            .clone()\r\n            .metadata()\r\n            .then(metadata => rendition\r\n                .resize(size, null, { kernel: sharp.kernel.cubic, fastShrinkOnLoad: true })\r\n                .blur(20)\r\n                .toFile(target)\r\n                .then(info => { return { info, target, metadata, shape : 'blur' }; }))\r\n            .catch(err => console.log(err));\r\n    }\r\n\r\n    return await Promise.all(promises)\r\n        .then((values) => {\r\n            values.forEach((value) => console.log(value.target+ ' ' + value.shape))\r\n            return differenceTime(Benchmark)\r\n        });\r\n}\r\n`\r\n\r\nSystem:\r\n    OS: Linux 5.3 Ubuntu 18.04.4 LTS (Bionic Beaver)\r\n    CPU: (4) x64 Intel(R) Core(TM) i5-6200U CPU @ 2.30GHz\r\n    Memory: 6.45 GB / 15.48 GB\r\n    Container: Yes\r\n    Shell: 4.4.20 - /bin/bash\r\n  Binaries:\r\n    Node: 12.16.1 - ~/.nvm/versions/node/v12.16.1/bin/node\r\n    npm: 6.14.4 - ~/.nvm/versions/node/v12.16.1/bin/npm\r\n\r\nSome random webp and Jpg Images are coming blurred. If you use blur filter. If you dont use blur filter all images are fine.\r\n\r\n",
    "comments_url": "https://api.github.com/repos/lovell/sharp/issues/2163/comments",
    "author": "navanshu",
    "comments": [
      {
        "user": "lovell",
        "created_at": "2020-04-13T20:02:14Z",
        "body": "Hi, there's a race condition in this code. The `rendition` object passed to the `blurImage` function is modified asynchronously.\r\n\r\n```diff\r\nfunction blurImage(rendition, size, target) {\r\n    return rendition\r\n        .clone()\r\n        .metadata()\r\n        .then(metadata => rendition\r\n+           .clone()\r\n            .resize(size, null, { kernel: sharp.kernel.cubic, fastShrinkOnLoad: true })\r\n```"
      }
    ]
  },
  {
    "number": 1940,
    "title": "Get metadata from resized/modified image.",
    "created_at": "2019-10-28T02:20:55Z",
    "closed_at": "2019-10-29T03:30:15Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/lovell/sharp/issues/1940",
    "body": "What are you trying to achieve?\r\nI want to get width, height and size in file system from a resized image. I've tried using the `metadata` method, but it gives me information about the original image, not the resized image. I wonder if that is possible without having to re-open the image after storing it.\r\n\r\nHave you searched for similar questions?\r\nYes :)\r\n\r\nAre you able to provide a standalone code sample that demonstrates this question?\r\n```\r\n// Resize the image.\r\nvar transform = await sharp().resize(resizeOptions).jpeg({ quality: 90 }).toFormat('jpg')\r\nfile.stream.pipe(transform)\r\n\r\n// Save the image on the file system.\r\nawait Drive.disk('spaces').put(path, transform, {\r\n  ACL: 'public-read',\r\n  ContentType: 'image/jpg'\r\n})\r\n\r\n// Get image metadata\r\nconst metadata = await transform.metadata()\r\nconsole.log(metadata) // This gives me the original image metadata\r\n```\r\n\r\nAre you able to provide a sample image that helps explain the question?\r\nI don't believe it is necessary.\r\n",
    "comments_url": "https://api.github.com/repos/lovell/sharp/issues/1940/comments",
    "author": "maverick504",
    "comments": [
      {
        "user": "lovell",
        "created_at": "2019-10-28T10:33:36Z",
        "body": "Hi, in your sample code, `transform` refers to the input sharp instance rather than the output JPEG data. You'll need to add a call to `toBuffer()` to generate the output image, something like (untested):\r\n\r\n```diff\r\n  // Resize the image.\r\n- var transform = await sharp().resize(resizeOptions).jpeg({ quality: 90 }).toFormat('jpg')\r\n+ const transform = sharp().resize(resizeOptions).jpeg({ quality: 90 }).toFormat('jpg')\r\n  file.stream.pipe(transform)\r\n+ const output = await transform.toBuffer()\r\n\r\n  // Save the image on the file system.\r\n- await Drive.disk('spaces').put(path, transform, {\r\n+ await Drive.disk('spaces').put(path, output, {\r\n    ACL: 'public-read',\r\n    ContentType: 'image/jpg'\r\n  })\r\n\r\n  // Get image metadata\r\n- const metadata = await transform.metadata()\r\n+ const metadata = await sharp(output).metadata()\r\n```"
      }
    ]
  },
  {
    "number": 1930,
    "title": "Build against a more recent ilmbase?",
    "created_at": "2019-10-22T09:43:18Z",
    "closed_at": "2019-10-23T01:43:37Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/lovell/sharp/issues/1930",
    "body": "Upon updating Arch Linux, Sharp has missing libraries:\r\n\r\n```\r\nldd node_modules/sharp/build/Release/sharp.node\r\nlibIlmImf-2_3.so.24 => not found\r\nlibImath-2_3.so.24 => not found\r\nlibHalf.so.24 => not found\r\nlibIex-2_3.so.24 => not found\r\nlibIexMath-2_3.so.24 => not found\r\nlibIlmThread-2_3.so.24 => not found\r\n```\r\n\r\nFiles like the following are now present:\r\n/usr/lib/libIlmImf-2_4.so.24\r\n\r\n",
    "comments_url": "https://api.github.com/repos/lovell/sharp/issues/1930/comments",
    "author": "ethernomad",
    "comments": [
      {
        "user": "ethernomad",
        "created_at": "2019-10-22T09:53:39Z",
        "body": "I was able to fix this locally by creating symlinks in my /usr/lib dir."
      },
      {
        "user": "lovell",
        "created_at": "2019-10-22T20:04:20Z",
        "body": "Hi, sharp does not provide prebuilt binaries that include ilmbase so I suspect you're using a global libvips compiled with OpenEXR support. You'll need to either run `ldconfig` or recompile sharp if there are minor/major version increments to globally-installed shared libraries upon which libvips depends."
      }
    ]
  },
  {
    "number": 1902,
    "title": "Extract after extract",
    "created_at": "2019-10-05T13:37:02Z",
    "closed_at": "2019-10-06T20:14:45Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/lovell/sharp/issues/1902",
    "body": "Is it possible?\r\n\r\nI have one image and want to exctract region one after one.\r\n\r\n````\r\nconst image = () => sharp(data).extract({\r\n          left: paddingLeft,\r\n          top: paddingTop,\r\n           width: W,\r\n          height: H\r\n       });\r\n\r\nimage().toFile(destination);\r\nimage().extract({ \r\nleft: pleft, \r\ntop: pTop,\r\n width: pw, height: ph\r\n            }).toFile(destination2);\r\n````\r\n\r\nbut second instans do not see the first extract(). It crops original image.\r\n\r\n  ",
    "comments_url": "https://api.github.com/repos/lovell/sharp/issues/1902/comments",
    "author": "Alexufo",
    "comments": [
      {
        "user": "lovell",
        "created_at": "2019-10-06T19:56:59Z",
        "body": "Hi, you'll need to use two pipelines for this, something like (untested):\r\n```javascript\r\nconst image1 = await image().toBuffer();\r\nsharp(image1).extract({ ... }).toFile(destination2);\r\n```"
      },
      {
        "user": "Alexufo",
        "created_at": "2019-10-06T20:14:45Z",
        "body": "Yes. Thanks. I did\r\n\r\n```\r\n                const cropped = await sharp(data).extract({\r\n                    left: paddingLeft,\r\n                    top: paddingTop,\r\n                    width: pW,\r\n                    height: pH\r\n                }).toBuffer();\r\n\r\n                const img1 = await sharp(cropped).toFile()\r\n                const Img2 = await sharp(cropped).extract({}).toFile()\r\n```"
      }
    ]
  },
  {
    "number": 1808,
    "title": "Error: Input buffer contains unsupported image format on composite",
    "created_at": "2019-07-25T22:40:57Z",
    "closed_at": "2019-07-31T15:17:00Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/lovell/sharp/issues/1808",
    "body": "Hi\r\nI have created a function which gets an image buffer(jpeg, png...).\r\nIt should resize images and depending from options also make them circle.\r\nThe code is working on my local machine.\r\nIt's also working on the server without circle block, but getting following error on the server for circle images:\r\n` Error: Input buffer contains unsupported image format `\r\nCan you please help me? Is it happening because of some packages versions difference?\r\n\r\n```\r\nconst sharp = require('sharp');\r\n\r\nmodule.exports = async function (image, options) {\r\n    let img = sharp(image);\r\n    const imgInfo = await img.metadata();\r\n    let format = options.format || imgInfo.format;\r\n\r\n    if (options.circle) {\r\n        const circle = new Buffer(\r\n            `<svg style=\"background-color: white\">\r\n                <circle cy=\"${options.height / 2}\" cx=\"${options.width / 2}\" r=\"${options.width / 2}\" />\r\n            </svg>`\r\n        );\r\n\r\n        format = 'png';\r\n        img.composite([{ input: circle, blend: 'dest-in' }]);\r\n    }\r\n\r\n    switch (format) {\r\n        case 'png':\r\n            img = img.png({ quality: options.quality || 100 });\r\n            break;\r\n        default:\r\n            img = img.jpeg({ quality: options.quality || 100 });\r\n    }\r\n\r\n    return img\r\n        .resize(options.width, options.height)\r\n        .toBuffer();\r\n};\r\n```",
    "comments_url": "https://api.github.com/repos/lovell/sharp/issues/1808/comments",
    "author": "susannaHayrapetyan",
    "comments": [
      {
        "user": "lovell",
        "created_at": "2019-07-26T08:36:25Z",
        "body": "The output of `console.log(sharp.format)` will tell you which image formats are supported at runtime.\r\n\r\nIf you're using the prebuilt binaries these include librsvg. If you're relying on a globally-installed libvips this may be different."
      }
    ]
  },
  {
    "number": 1779,
    "title": "code only seems to work if intermediate file is used?",
    "created_at": "2019-07-04T16:41:18Z",
    "closed_at": "2019-07-08T16:40:53Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/lovell/sharp/issues/1779",
    "body": "I have a chunk of code as follows:\r\n\r\n```\r\n      var img = sharp(path)\r\n  \r\n      // Extract the grayscale channel?\r\n      // and save as 'newGrey.png'\r\n      var grey = img.extractChannel(0)\r\n      await grey.toColorspace(\"b-w\")\r\n(1)        .toFile(\"newGrey-\"+ client.clientID + client.counter +\".png\")\r\n\r\n      // Load new alpha and join\r\n      let filename = 'transparencies/'+client.rasterConfig.transparency+'.png'\r\n      //console.log(filename)\r\n(2)      await sharp('newGrey-'+ client.clientID + client.counter + '.png')\r\n        .toColorspace(\"b-w\")\r\n        .joinChannel(filename)\r\n        .toBuffer((err, data, info) => { \r\n\r\n```\r\n\r\nThis code works.  \r\n\r\nBut as you can see, I'm basically writing the file to a temp image at point (1), then reload that same temp image at point (2).  This seems totally like it should be redundant.  But if I remove the toFile at (1) and the load at (2), I don't get the same resultant image.\r\n\r\nWhat am I misunderstanding here?\r\n\r\nThanks\r\n",
    "comments_url": "https://api.github.com/repos/lovell/sharp/issues/1779/comments",
    "author": "avpavp",
    "comments": [
      {
        "user": "lovell",
        "created_at": "2019-07-06T12:47:26Z",
        "body": "Hi, if you're using the channel operations then yes, intermediate images will be required. You could use raw, uncompressed pixel data, something like:\r\n```javascript\r\nconst { width, height } = await sharp(path)\r\n  .metadata();\r\n\r\nconst greyscale = await sharp(path)\r\n  .extractChannel(0)\r\n  .toColorspace(\"b-w\")\r\n  .raw()\r\n  .toBuffer();\r\n\r\nconst result = await sharp(greyscale, { raw: { width, height, channels: 1 })\r\n  .toColorspace(\"b-w\")\r\n  .joinChannel(filename)\r\n  .toBuffer();\r\n```"
      }
    ]
  },
  {
    "number": 1778,
    "title": "Usage with Axios?",
    "created_at": "2019-07-04T14:39:06Z",
    "closed_at": "2019-07-05T06:15:53Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/lovell/sharp/issues/1778",
    "body": "I'm currently trying to download an image using Axios and then resize the result and save it locally via Node in a GraphQL resolver.\r\n\r\nThis is the block of code I'm working with:\r\n```javascript\r\naxios.get(url)\r\n                .then((response) => {\r\n                    const { set, collector_number } = response.data;\r\n                    const sourceUrl = response.data.image_uris.border_crop;\r\n                    const filename = `${set}/${collector_number}.png`;\r\n                    axios.get(sourceUrl, { responseType: 'arraybuffer' })\r\n                        .then((res) => {\r\n                            console.log(`Resizing Image!`)\r\n                            sharp(res)\r\n                                .resize(226, 321)\r\n                                .toFile(`../cardimg/${filename}`)\r\n                                .then(() => {\r\n                                    console.log(`Image downloaded and resized!`)\r\n                                })\r\n                                .catch((err) => {\r\n                                    console.log(`Couldn't process: ${err}`);\r\n                                })\r\n                        })\r\n                })\r\n```\r\n\r\nWhen I execute the code (via GraphQL Mutation), it throws an error saying that states `Input file is missing`.\r\n\r\nNot sure if it's misuse of Axios, or if I'm doing something wrong with Sharp.\r\n\r\nAny suggestions?   I was originally worried that I needed to mess with the format of the response coming from the HTTP request, but from what I can gather, I'm doing it correctly.  \r\n\r\nThanks in advance!\r\n\r\nI've used `console.log` to ensure that it's definitely grabbing an image and the URL is correct, so that's already been tested, so the `sourceUrl` is indeed grabbing an image, I'm just not sure how to properly do anything -with-  the data that I'm grabbing.",
    "comments_url": "https://api.github.com/repos/lovell/sharp/issues/1778/comments",
    "author": "czbak3r",
    "comments": [
      {
        "user": "lovell",
        "created_at": "2019-07-04T15:06:24Z",
        "body": "I think Axios returns an object on which the `data` property is of interest:\r\n\r\n```diff\r\n-    .then((res) => {\r\n+    .then(({ data }) => {\r\n```"
      }
    ]
  },
  {
    "number": 1765,
    "title": "toFile() does not warn if folder does not exist",
    "created_at": "2019-06-25T07:43:24Z",
    "closed_at": "2019-06-25T09:41:12Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/lovell/sharp/issues/1765",
    "body": "What is the output of running `npx envinfo --binaries --languages --system --utilities`?\r\n  System:\r\n    OS: Linux 4.9 Alpine Linux undefined\r\n    CPU: (2) x64 Intel(R) Core(TM) i7-6500U CPU @ 2.50GHz\r\n    Memory: 1.45 GB / 1.93 GB\r\n    Container: Yes\r\n    Shell: Unknown - /bin/ash\r\n  Binaries:\r\n    Node: 10.15.3 - /usr/bin/node\r\n    npm: 6.4.1 - /usr/bin/npm\r\n\r\nUsing latest gazf/alpine-sharp docker image.\r\n\r\n### What are the steps to reproduce?\r\n\r\nUse sharp().composite.toFile(file) where the file path is a directory that does not exist.\r\nThe file outputting fails, without error or warning.\r\n\r\n### What is the expected behaviour?\r\n\r\nI feel like I should have got some feedback that the output was failing because the folder did not exist.\r\n\r\n### Are you able to provide a standalone code sample, without other dependencies, that demonstrates this problem?\r\n\r\n```\r\nasync function compositeDiff(file, width) {\r\n  var margin = 10;\r\n  sharp(diffDir + file)\r\n      .extend({\r\n        top: 0,\r\n        bottom: 0,\r\n        left: 0,\r\n        right: ((width + margin) * 2)\r\n      })\r\n      .composite([\r\n          {\r\n            input: referenceDir + resizedDir + file,\r\n            left: width + margin,\r\n            top: 0\r\n          },\r\n          {\r\n            input: testDir + resizedDir + file,\r\n            left: (width + margin) * 2,\r\n            top: 0\r\n          },\r\n      ])\r\n      .toFile(comparisonDir + file)\r\n}\r\n```\r\n\r\nCalling this function in a script that is called from a docker-compose command using the gazf/alpine-sharp image produces no error or warning output, but outputs no file.\r\nInserting a mkdir at the start of the function fixes the problem of no file being outputted.\r\n",
    "comments_url": "https://api.github.com/repos/lovell/sharp/issues/1765/comments",
    "author": "jonathanjfshaw",
    "comments": [
      {
        "user": "lovell",
        "created_at": "2019-06-25T07:52:09Z",
        "body": "Hi, I see the following error when attempting to write to a non-existent directory via `toFile()`:\r\n```\r\nError: vips__file_open_write: unable to open file \"does-not-exist/output.jpg\" for writing\r\nunix error: No such file or directory\r\n```\r\nPerhaps some error handling is required in the code that calls the `compositeDiff()` function shown in this example? In addition, you're not returning the promise chain - try the following:\r\n\r\n```diff\r\n-  sharp(diffDir + file)\r\n+  return sharp(diffDir + file)\r\n```\r\nor \r\n```diff\r\n-  sharp(diffDir + file)\r\n+  await sharp(diffDir + file)\r\n```\r\n\r\nPlease see #639 #874 #1052"
      }
    ]
  },
  {
    "number": 1695,
    "title": "How to skip images unsupported format",
    "created_at": "2019-05-11T03:21:15Z",
    "closed_at": "2019-05-13T17:51:14Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/lovell/sharp/issues/1695",
    "body": "Hi\r\n\r\n\r\nI am getting the **Input file contains unsupported image format** Error. How can I skip images that supposedly are not the correct format?\r\n\r\n\r\n",
    "comments_url": "https://api.github.com/repos/lovell/sharp/issues/1695/comments",
    "author": "stefanomonteiro",
    "comments": [
      {
        "user": "lovell",
        "created_at": "2019-05-11T09:57:38Z",
        "body": "You'll probably need to add some error handling to your code.\r\n\r\nYou've not provided any sample code here but `toFile()` or `toBuffer()` will either reject or pass an error to the callback depending on the context in which they are used."
      },
      {
        "user": "stefanomonteiro",
        "created_at": "2019-05-11T17:18:00Z",
        "body": "Thanks\r\n\r\nI used node `path.extname(file)` and conditioned the code to run if the file is of extension I want to work with.\r\n\r\n```\r\nfs.readdir(path, function(err, files) {\r\n    files.forEach(function(file) {\r\n      if (path.extname(file) === \".jpg\" || path.extname(file) === \".png\") {\r\n          ////CODE\r\n      }\r\n```"
      }
    ]
  },
  {
    "number": 1675,
    "title": "Upgrading from 0.21.3 to 0.22.1 leads to: \"undefined symbol: cairo_tag_end\" - When using LD_PRELOAD with Electron",
    "created_at": "2019-04-28T00:05:07Z",
    "closed_at": "2019-04-29T22:39:22Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/lovell/sharp/issues/1675",
    "body": "### What is the output of running `npx envinfo --binaries --languages --system --utilities`?\r\n\r\n```\r\n  System:\r\n    OS: Linux 4.10 Linux Mint 18.3 (Sylvia)\r\n    CPU: (2) x64 Intel(R) Core(TM) i5-4690K CPU @ 3.50GHz\r\n    Memory: 1.16 GB / 3.84 GB\r\n    Container: Yes\r\n    Shell: 4.3.48 - /bin/bash\r\n  Binaries:\r\n    Node: 10.15.1 - /usr/bin/node\r\n    Yarn: 1.13.0 - /usr/bin/yarn\r\n    npm: 6.4.1 - /usr/bin/npm\r\n  Utilities:\r\n    Make: 4.1 - /usr/bin/make\r\n    GCC: 5.4.0 - /usr/bin/gcc\r\n    Git: 2.7.4 - /usr/bin/git\r\n  Languages:\r\n    Bash: 4.3.48 - /bin/bash\r\n    Perl: 5.22.1 - /usr/bin/perl\r\n    Python: 2.7.12 - /usr/bin/python\r\n    Ruby: 2.3.1 - /usr/bin/ruby\r\n\r\n```\r\n\r\n### What are the steps to reproduce?\r\n\r\n`cross-env LD_PRELOAD=./node_modules/sharp/vendor/lib/libz.so electron [some args]`\r\n\r\n### What is the expected behaviour?\r\n\r\nLD_PRELOAD magically fixes everything like it did with `Sharp@0.21.3`, if that's possible.\r\n\r\n### Are you able to provide a standalone code sample, without other dependencies, that demonstrates this problem?\r\n\r\nYes I believe so. If a fix or workaround aren't immediately apparent, I think I can put together a repo for this. This doesn't seem to be reproducible though when using LD_PRELOAD on a machine with `zlib@1.2.11` already installed though, so actually such a repo might have OS level requirements to reproduce.\r\n\r\n### Are you able to provide a sample image that helps explain the problem?\r\n\r\nThings don't get that far.\r\n\r\n### Other info\r\n\r\n**Electron** 4.1.5\r\n\r\nLove the prebuilt images for Electron 4 and 5! I found some references to this error on the web, but nothing that seemed to point me towards anything actionable",
    "comments_url": "https://api.github.com/repos/lovell/sharp/issues/1675/comments",
    "author": "Nantris",
    "comments": [
      {
        "user": "lovell",
        "created_at": "2019-04-29T10:22:18Z",
        "body": "Hi, this error relates to cairo. Are you using `node-canvas` also? If so, how is it's cairo dependency installed?"
      },
      {
        "user": "Nantris",
        "created_at": "2019-04-29T17:15:37Z",
        "body": "Thanks for your reply @lovell. We're not using of `node-canvas`.\r\n\r\nIn case there's anything we can do to work-around Cairo, we're just using `Sharp` for conversion of `jpg` and `png` to `webp` and nothing more.\r\n\r\nWould putting together a repo be the best next step to figure this out? Is there anything else that comes to mind? \r\n\r\nThanks again @lovell!"
      },
      {
        "user": "lovell",
        "created_at": "2019-04-29T17:47:32Z",
        "body": "Thanks, I can see that it is the `electron` binary itself that depends on the Linux system's libcairo shared libraries:\r\n```sh\r\n$ npm install electron\r\n$ ldd node_modules/electron/dist/electron | grep cairo\r\n\tlibpangocairo-1.0.so.0 => /usr/lib/x86_64-linux-gnu/libpangocairo-1.0.so.0 (0x00007f8797a95000)\r\n\tlibcairo.so.2 => /usr/lib/x86_64-linux-gnu/libcairo.so.2 (0x00007f8797902000)\r\n\tlibcairo-gobject.so.2 => /usr/lib/x86_64-linux-gnu/libcairo-gobject.so.2 (0x00007f87953d2000)\r\n```\r\nIf you're already setting `LD_PRELOAD` then try adding sharp's libcairo to it also (I think multiple paths are space-delimited)."
      },
      {
        "user": "Nantris",
        "created_at": "2019-04-29T22:39:22Z",
        "body": "@lovell, you are amazing!\r\n\r\nThat got me 99% of the way there! When I preloaded just those though, I got `undefined symbol: pango_font_description_get_variations`. Tacking `libpango` to the front of my `LD_PRELOAD` was the final missing link.\r\n\r\nFor anyone else who runs into this, the full `LD_PRELOAD` you'll need is probably:\r\n\r\n```\r\nLD_PRELOAD=node_modules/sharp/vendor/lib/libpango-1.0.so.0:node_modules/sharp/vendor/lib/libcairo.so.2:node_modules/sharp/vendor/lib/libpangocairo-1.0.so.0:node_modules/sharp/vendor/lib/libcairo-gobject.so.2:node_modules/sharp/vendor/lib/libz.so\r\n```\r\n\r\nI'm pretty sure you can whitespace to separate multiple paths, but I used colons. \r\n\r\nThank you again so much for everything!\r\n\r\nPS, to anyone using the code I included, I don't really know if I followed best practices with linking to `.so.0`, or if I should have just linked to `.so`. I just stopped tinkering when it worked. So far, no issues."
      }
    ]
  },
  {
    "number": 1642,
    "title": "Detecting whether withoutEnlargement is fired or not",
    "created_at": "2019-04-04T15:35:22Z",
    "closed_at": "2019-04-05T09:02:03Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/lovell/sharp/issues/1642",
    "body": "## What are you trying to achieve?\r\nI am trying to create a set of sizes under the original size.  \r\n\r\nThe withoutEnlargement option works in that it does not scale up the image, however, ideally there would be a flag or something when doing toFile/toBuffer to say that the image was larger than the original image. \r\n\r\nThe problem I have at the moment is that I'm doing the following;\r\n\r\n```js\r\nsharp(tmpFilePath)\r\n        .resize(width, null, {\r\n          withoutEnlargement: true\r\n        })\r\n        .toFile(thumbPath)\r\n        .then((a) => {\r\n// Upload file to GCS\r\n});\r\n```\r\n\r\nAnd I would like to NOT create the new file in GCS if it is just the same as the original size, that way I don't have a file called '2000-image.jpg' when the width is actually 1500.\r\n\r\nIs there something I'm missing, or an extra callback parameter or something that would allow me to know in the `then` function so I could decide not to upload it. \r\n\r\n## Have you searched for similar questions?\r\nYes\r\n\r\n## Are you able to provide a standalone code sample that demonstrates this question?\r\nNot immediately, but I can if needed.\r\n\r\n## Are you able to provide a sample image that helps explain the question?\r\nAny image under the size you're trying to resize to. \r\n",
    "comments_url": "https://api.github.com/repos/lovell/sharp/issues/1642/comments",
    "author": "Dayjo",
    "comments": [
      {
        "user": "lovell",
        "created_at": "2019-04-04T18:09:50Z",
        "body": "Hello, in your code example the `a` parameter passed to `then()` is an object that includes the post-resize dimensions. Perhaps add a test for `a.width` being less than `width`?"
      }
    ]
  },
  {
    "number": 1635,
    "title": "resize() after composite() cause error",
    "created_at": "2019-03-29T17:33:36Z",
    "closed_at": "2019-04-03T08:36:57Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/lovell/sharp/issues/1635",
    "body": "Hi,\r\n\r\nThere is a wierd issue when Im trying to `resize()` after `composite()`, the source is:\r\n\r\n```javascript\r\nsharp({\r\n    create: {\r\n        width: 789,\r\n        height: 789,\r\n        channels: 4,\r\n        background: '#bfff00'\r\n    }\r\n}).png().composite([{ input: content }]).resize(192).toBuffer((err, data) => {\r\n    if (err)\r\n        return callback(err);\r\n    this.emitFile(target, data);\r\n    callback(null, '');\r\n});\r\n```\r\n\r\nAnd it halted with *Image to composite must have same dimensions or smaller*.\r\n\r\nIf I deleted `.resize(192)`, it works fine.\r\n\r\nIf I deleted `.png()`, the same error would be occurred again.",
    "comments_url": "https://api.github.com/repos/lovell/sharp/issues/1635/comments",
    "author": "snakevil",
    "comments": [
      {
        "user": "lovell",
        "created_at": "2019-03-30T10:26:55Z",
        "body": "You'll need to break this into two pipelines, something like (untested):\r\n```javascript\r\nsharp({\r\n  create: {\r\n    width: 789,\r\n    height: 789,\r\n    channels: 4,\r\n    background: '#bfff00'\r\n  }\r\n})\r\n  .composite([{\r\n    input: content\r\n  }])\r\n  .png()\r\n  .toBuffer()\r\n  .then(data => sharp(data)\r\n    .resize(192)\r\n    .toBuffer()\r\n  )\r\n  .then( ... );\r\n```"
      },
      {
        "user": "djardine",
        "created_at": "2020-01-08T02:00:08Z",
        "body": "Think @johannwagner is correct above, but regardless of the call order, to me it would seem to make more sense if the resize() is applied to the final composite image, not just the input base image, but not sure how others feel about that....?"
      },
      {
        "user": "slikts",
        "created_at": "2020-05-08T09:48:50Z",
        "body": "This is somewhat non-intuitive; a logical expectation would be that compositing images together would also allow them being processed together."
      }
    ]
  },
  {
    "number": 1604,
    "title": "Error: Input file is missing or of an unsupported image format on some requests",
    "created_at": "2019-03-09T17:20:46Z",
    "closed_at": "2019-03-11T11:21:54Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/lovell/sharp/issues/1604",
    "body": "Hello,\r\nThis code for image upload and compression works in most cases but some requests fail ((Number of fails increase in load testing) with error: 'Error: Input file is missing or of an unsupported image format'\r\n\r\nI checked the path whenever this error appears. The file really exists and is usable. Also this error does not appear for all requests. The exception occurs when I give the temp file path (saved to disk via streams to reduce memory footprint) to sharp.\r\n\r\n```\r\n'use strict';\r\n\r\nconst fs = require('fs');\r\nconst fsx = require('fs-extra');\r\nconst path = require('path');\r\nconst sharp = require('sharp');\r\nconst Config = require('../config/image');\r\nconst Rand = require('../utils/random');\r\nconst TAG = '\\services\\image';\r\nfunction readImageStream(buffer, owner, tempFileName){\r\n\tconst tempFilepath = Config.UPLOAD_PATH+'tmp\\\\'+owner+'\\\\'+tempFileName;\r\n\treturn new Promise(function(resolve, reject){\r\n\t\t//const readStream = fs.createReadStream(buffer);\r\n\t\tconst readStream = buffer;\r\n\t\tconst writeStream = fs.createWriteStream(tempFilepath);\r\n\t\tlet output;\r\n\t\treadStream.on('data', function(chunk){\r\n\t\t\twriteStream.write(chunk, {flags: 'a', encoding:null, mode:0o666});\r\n\t\t});\r\n\t\treadStream.on('end', function(){\r\n\t\t\tconst path = writeStream.path;\r\n\t\t\twriteStream.end();\r\n\t\t\tresolve(path);\r\n\t\t});\r\n\t\treadStream.on('error', function(err){\r\n\t\t\tconsole.log(\"Error in reading image stream \" + TAG, err);\r\n\t\t\treject(err);\r\n\t\t});\r\n\t});\r\n}\r\n\r\nfunction checkImageDimensions(owner, filename){\r\n\tconst path = Config.UPLOAD_PATH + \"tmp\\\\\"+ owner + \"\\\\\" + filename;\r\n\treturn new Promise(function(resolve, reject){\r\n\t\t\r\n\t\tsharp(path)\r\n\t\t\t.metadata()\r\n\t\t\t.then(function(info){\r\n\t\t\t\tif(info.width < 100 || info.height <100 || \r\n\t\t\t      (info.width / info.height < 0.5) ||\r\n\t\t\t\t  (info.height / info.width < 0.5)){\r\n\t\t\t\t\t\treject('Bad image size');\r\n\t\t}\r\n\t\telse{\r\n\t\t\tresolve();\r\n\t\t}\r\n\t\t})\r\n\t\t.catch(function(err){\r\n\t\t\tconsole.log(\"Error in image size check \" + TAG, err);\r\n\t\t\treject(err);\r\n\t\t})\r\n\t}); \r\n}\r\n\r\nexports.Save = async function(owner, buffer){\r\n\tconst tempDir = Config.UPLOAD_PATH+\"tmp\\\\\"+owner;\r\n\tconst tempFileName1 = Rand.UUID() + Config.EXTENSION; //Creates UUID for filename\r\n\tconst tempFileName2 = Rand.UUID() + Config.EXTENSION;\r\n\tconst tempPath = tempDir + \"\\\\\"+tempFileName1;\r\n\tconst ensureDirExists = await fsx.ensureDir(Config.UPLOAD_PATH+ \"tmp\\\\\"+owner);\r\n\t//await checkMaxTempSize(owner);\r\n\tawait readImageStream(buffer, owner, tempFileName1);\r\n\tawait checkImageDimensions(owner, tempFileName1);\r\n\ttry{\r\n\t\tawait sharp(tempPath)\r\n\t\t\t\t\t.resize(800, 494, {\r\n\t\t\t\t\t\t\t\t\t\tkernel: sharp.kernel.nearest,\r\n\t\t\t\t\t\t\t\t\t\tfit: 'contain',\r\n\t\t\t\t\t\t\t\t\t\tbackground: { r: 255, g: 255, b: 255}\r\n\t\t\t\t\t\t\t\t\t}).toFile(Config.UPLOAD_PATH+ \"tmp\\\\\"+owner+ \"\\\\\" + tempFileName2, {quality:80});\r\n\t\t\t\treturn {\r\n\t\t\t\t\t\tfilename: tempFileName2\r\n\t\t\t\t};\r\n\t}\r\n\tcatch(err){\r\n\t\tconsole.log(\"Error in image compression \" + TAG, err);\r\n\t\treturn err;\r\n\t}\r\n} \r\n```",
    "comments_url": "https://api.github.com/repos/lovell/sharp/issues/1604/comments",
    "author": "danialkhansari",
    "comments": [
      {
        "user": "lovell",
        "created_at": "2019-03-09T20:18:38Z",
        "body": "Hi, there's a race condition in the following section of your code, unrelated to sharp:\r\n```javascript\r\nreadStream.on('end', function(){\r\n\tconst path = writeStream.path;\r\n\twriteStream.end();\r\n\tresolve(path);\r\n});\r\n```\r\nThe call to `writeStream.end()` is not synchronous so `resolve` could occur before `writeStream` has finished writing to and closing the underlying file descriptor.\r\n\r\nInstead listen for the `close` event on `writeStream` before resolving."
      },
      {
        "user": "gergo0720",
        "created_at": "2019-03-09T23:31:23Z",
        "body": "Hi, I've experienced the same issue. In some cases it works properly, but it often happens to get the error mentioned above. I've tried to check the details of a \"working\" image and a \"non-working\" image. The only difference is the file-type. For not working images we have:\r\n\r\nFile Type: JPEG image data, **JFIF standard 1.02**\r\n\r\nMy current settings to resize is:\r\n\r\n`sharp(filePath)\r\n\t\t\t.withMetadata()\r\n\t\t\t.resize(200, 200, {\r\n\t\t\t\twithoutEnlargement: true\r\n\t\t\t})\r\n\t\t\t.png()\r\n\t\t\t.toFile(newFilePath);`\r\n\r\nI am using the latest version, but also tried an earlier one (0.20.5). The result was the same.\r\n\r\nI hope we can figure this out, and thanks in advance."
      },
      {
        "user": "lovell",
        "created_at": "2019-03-09T23:41:14Z",
        "body": "@gergo0720 Please open a new issue with a standalone code sample and example input image that consistently fails."
      }
    ]
  },
  {
    "number": 1584,
    "title": "Resize -> extract -> rotate leads to no rotate",
    "created_at": "2019-02-19T13:28:44Z",
    "closed_at": "2019-02-24T10:08:11Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/lovell/sharp/issues/1584",
    "body": "We have the following code:\r\n```js\r\nsharp()\r\n  .resize(600, 600)\r\n  .extract({ width: 200, height: 50, left: 0, top: 0 })\r\n  .rotate(90);\r\n```\r\n\r\nResult should be 50x200 however, it is 200x50 (rotate not applied).\r\n\r\nWhen we do `resize` in a different instance, then the result is 50x200 as expected:\r\n```js\r\nconst instance1 = sharp().resize(600, 600);\r\n  \r\nconst instance2 = sharp()\r\n  .extract({ width: 200, height: 50, left: 0, top: 0 })\r\n  .rotate(90);\r\n\r\ninstance1.pipe(instance2);\r\n```\r\n\r\nIs this an expected behaviour? If yes, what's the reason for this?\r\n\r\nSharp version: 0.21.3",
    "comments_url": "https://api.github.com/repos/lovell/sharp/issues/1584/comments",
    "author": "deftomat",
    "comments": [
      {
        "user": "lovell",
        "created_at": "2019-02-19T14:26:37Z",
        "body": "Hello, the ordering of applying both a rotate and extract operation post-resize is currently fixed so the two-pipeline approach you suggest is correct. Please see #241 for discussion about a future possible additional API."
      },
      {
        "user": "deftomat",
        "created_at": "2019-02-21T07:34:27Z",
        "body": "Oh, thats sad. We need to construct pipelines dynamically and using a lot of new instances hit the CPU really badly. In our code it is like 30ms with 1 instance and 550ms with 3 instances \ud83d\ude22 "
      },
      {
        "user": "lovell",
        "created_at": "2019-02-22T22:08:05Z",
        "body": "I suspect much of that time will be spent in the (de)compression round trips. If you've not already done so, it'd be worth experimenting with raw, uncompressed data for the intermediate stages.\r\n\r\n```javascript\r\nconst instance1 = sharp().resize(600, 600).raw();\r\n  \r\nconst instance2 = sharp({ raw: { width: 600, height: 600, channels: 3 }})\r\n  .extract({ width: 200, height: 50, left: 0, top: 0 })\r\n  .rotate(90);\r\n\r\ninstance1.pipe(instance2);\r\n```"
      }
    ]
  },
  {
    "number": 1461,
    "title": "store an image 2 times",
    "created_at": "2018-11-15T15:19:36Z",
    "closed_at": "2018-11-15T21:03:17Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/lovell/sharp/issues/1461",
    "body": "I have to resize an image 2 times and store it in different files\r\nand most importantly i want them to be Promise based so i can await them\r\n\r\ncurrently i use this method which i doubt to be correct:\r\n\r\n```\r\nawait sharp(my_file)\r\n\t.jpeg({quality: 90, chromaSubsampling: '4:4:4'})\r\n\t.resize(200, 200)\r\n\t.toFile('200x200.jpg', (err, info) => {}); // save\r\n\r\nawait sharp(my_file)\r\n\t.jpeg({quality: 90, chromaSubsampling: '4:4:4'})\r\n\t.resize(40, 40)\r\n\t.toFile('40x40.jpg', (err, info) => {}); // save\r\n```\r\n\r\n\r\n\r\n",
    "comments_url": "https://api.github.com/repos/lovell/sharp/issues/1461/comments",
    "author": "Mehdi-Azmoudeh",
    "comments": [
      {
        "user": "Daiz",
        "created_at": "2018-11-15T15:57:14Z",
        "body": "`.toFile` returns a Promise when a callback isn't specified.\r\n\r\nIf you want to encode the two different varieties in parallel, you can just do the following:\r\n\r\n```javascript\r\nasync function encode(my_file) {\r\n  const src = sharp(my_file).jpeg({quality: 90, chromaSubsampling: \"4:4:4\"});\r\n  const i200 = src.resize(200, 200).toFile(\"200x200.jpg\");\r\n  const i40 = src.resize(40, 40).toFile(\"40x40.jpg\");\r\n  return Promise.all([i200, i40]);\r\n}\r\n```\r\n\r\nYou can also `await Promise.all([i200, i40])` in the above example, naturally, if you want it as part of a bigger function or pipeline."
      }
    ]
  },
  {
    "number": 1449,
    "title": "GLib-GObject-WARNING and GLib-GObject-CRITICAL",
    "created_at": "2018-11-06T20:47:20Z",
    "closed_at": "2018-11-10T22:49:38Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/lovell/sharp/issues/1449",
    "body": "Although my code executes fine and generates the file 100%, I am getting the following error messages:\r\n\r\n```\r\n(sharp:157048): GLib-GObject-WARNING **: 21:49:04.120: invalid uninstantiatable type '(null)' in cast to 'GObject'\r\n\r\n(sharp:157048): GLib-GObject-CRITICAL **: 21:49:04.120: g_object_set_qdata: assertion 'G_IS_OBJECT (object)' failed\r\n```\r\n\r\nMy code is as follow:\r\n\r\n```\r\nvar sharpImg = sharp('file1.png');\r\nsharpImg.metadata().then(function (metadata) {\r\n\tvar origWidth = metadata.width;\r\n\tvar origHeight = metadata.height;\r\n\treturn sharpImg.resize(Math.round(origWidth / 2), Math.round(origHeight / 2));\r\n}).then(function (data) {\r\n\tdata.toFile('file2.png', function (err, info) {\r\n\t\t// Done with err == null (No errors here)\r\n\t});\r\n});\r\n```",
    "comments_url": "https://api.github.com/repos/lovell/sharp/issues/1449/comments",
    "author": "1Map",
    "comments": [
      {
        "user": "lovell",
        "created_at": "2018-11-07T11:47:27Z",
        "body": "Hello, this looks like #1320 - are you using the latest version?"
      },
      {
        "user": "1Map",
        "created_at": "2018-11-07T15:38:22Z",
        "body": "I am using Sharp version ^0.20.8"
      },
      {
        "user": "lovell",
        "created_at": "2018-11-10T22:39:01Z",
        "body": "Are you able to reproduce with the latest v0.21.0 version?"
      }
    ]
  },
  {
    "number": 1415,
    "title": "Possible buffer memory leak on fedora/centos systems ",
    "created_at": "2018-10-18T14:29:43Z",
    "closed_at": "2018-12-04T21:33:39Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/lovell/sharp/issues/1415",
    "body": "I'm writing a application to index large amount of images.\r\n\r\nI'm getting large RSS (1.5 - 2gb after few hundred images) usage and it' is not going down. Heap is about 70mb.\r\n\r\nIf I run this code on my machine the RSS will just keep on growing.\r\n\r\ncurrent system: Fedora release 28 (Twenty Eight)\r\n http_parser: '2.8.0',\r\n  node: '10.1.0',\r\n  v8: '6.6.346.27-node.6',\r\n  uv: '1.20.2',\r\n  zlib: '1.2.11',\r\n  ares: '1.14.0',\r\n  modules: '64',\r\n  nghttp2: '1.29.0',\r\n  napi: '3',\r\n  openssl: '1.1.0h',\r\n  icu: '61.1',\r\n  unicode: '10.0',\r\n  cldr: '33.0',\r\n  tz: '2018c' \r\n\r\n\r\n```\r\nconst sharp = require('sharp');\r\nconst path = require('path');\r\nconst fs = require('fs');\r\nconst async = require('async');\r\nsharp.cache(false);\r\n\r\n\r\nconst filePath  = process.argv.pop();\r\n\r\n\r\nfunction createArray(len){\r\n  const array = [];\r\n\r\n  for (let i = 0; i < len; i++){\r\n    array.push(i);\r\n  }\r\n\r\n  return array;\r\n}\r\n\r\nconst arr = createArray(10000);\r\n\r\nconst sourceBuffer = fs.readFileSync(filePath);\r\n\r\nasync function resize(source){\r\n  const image = sharp(source).toBuffer();\r\n  source = null;\r\n  return image;\r\n}\r\n\r\nfunction logMemory(){\r\n  const pr = process.memoryUsage();\r\n  const logObject = {};\r\n  for (let key in pr){\r\n    logObject[key] =  parseInt((pr[key] / 1024 / 1024).toFixed(0));\r\n  }\r\n\r\n  console.log(logObject)\r\n\r\n}\r\n\r\nasync.forEachLimit(arr, 1, async function (i){\r\n  let resizedImage = await resize(sourceBuffer);\r\n\r\n  resizedImage = null;\r\n  logMemory();\r\n}, function (err){\r\n\r\n  console.log('done', err)\r\n  setTimeout(logMemory, 3000)\r\n})\r\n```\r\n\r\nThe image is 24mb TIFF image\r\n\r\nusage is : node test.js 'file.tiff'",
    "comments_url": "https://api.github.com/repos/lovell/sharp/issues/1415/comments",
    "author": "agustik",
    "comments": [
      {
        "user": "agustik",
        "created_at": "2018-10-18T14:49:06Z",
        "body": "@lovell Well, i read it like few hours ago .. \r\n\r\nBut sharp.concurrency(); seems to do the trick keeping the memory down ..\r\n\r\n\r\nI't might fix the issue. I'm going to commit the code on my procject and deploy on my test servers.. "
      },
      {
        "user": "agustik",
        "created_at": "2018-10-18T15:14:01Z",
        "body": "RSS is about 500-700mb in production right now (more than just sharp)\r\n\r\nconcurrency is 1;\r\nand cache is default enabled.\r\n\r\n"
      },
      {
        "user": "agustik",
        "created_at": "2018-11-19T22:58:58Z",
        "body": "No problems that I know off after i set concurrency to 1. I'll check the stats on the production system"
      },
      {
        "user": "lovell",
        "created_at": "2018-12-04T21:33:39Z",
        "body": "Sounds like this problem has gone away but please re-open with more details if not."
      }
    ]
  },
  {
    "number": 1397,
    "title": "when I map data with code, both png and jpeg are converted with a white background though I have a condition to only do that when output ext is  jpeg or jpg",
    "created_at": "2018-10-01T16:15:39Z",
    "closed_at": "2018-10-02T19:53:23Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/lovell/sharp/issues/1397",
    "body": "I'm trying to convert a transparent logo to jpg and png.  As you can see in my code below, I check to see if the file output ext is jpeg or jpg and if it is, it change the background to white and flatten it. \r\n\r\nFor some strange reason, when I map data with function, both png and jpeg are converted with a white background though I have a condition to only do that when output ext is  jpeg or jpg\r\n\r\n\r\n\r\n\r\n```\r\nlet local_file = '/tmp/output/295aadfd-f837-4ffb-b3a0-4a407cca54e0.png'\r\n\r\nlet data = [[700,\r\n    null,\r\n    'width',\r\n    '/tmp/output/295aadfd-f837-4ffb-b3a0-4a407cca54e0_10',\r\n    'png'],\r\n    [700,\r\n        null,\r\n        'width',\r\n        '/tmp/output/295aadfd-f837-4ffb-b3a0-4a407cca54e0_10',\r\n        'jpg'],\r\n    [1000,\r\n        null,\r\n        'width',\r\n        '/tmp/output/295aadfd-f837-4ffb-b3a0-4a407cca54e0_10',\r\n        'png'],\r\n    [1000,\r\n        null,\r\n        'width',\r\n        '/tmp/output/295aadfd-f837-4ffb-b3a0-4a407cca54e0_10',\r\n        'jpg']]\r\n\r\n\r\nPromise.all(data.map(convert_image_sharp(local_file))).then(() => {\r\n                    console.log('image convert done');\r\n                });\r\n\r\n\r\n```\r\n\r\n\r\n```\r\nfunction convert_image_sharp(image_path) {\r\n    let image = sharp(image_path);\r\n    return data => image\r\n        .metadata()\r\n        .then(function (metadata) {\r\n            let inputs = beatify_input(data);\r\n            if (inputs['crop']) {\r\n                image.extract(inputs['crop'][0], inputs['crop'][1], inputs['crop'][2], inputs['crop'][3])\r\n            }\r\n            image.resize(inputs['width'], inputs['height']);\r\n            if (['jpg', 'jpeg'].includes(inputs['ext'])){\r\n                console.log(inputs['ext']);\r\n                image.background('white');\r\n                image.flatten();\r\n            }\r\n            return image.toFile(inputs['write_path']);\r\n        })\r\n\r\n}\r\n\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/lovell/sharp/issues/1397/comments",
    "author": "wobeng",
    "comments": [
      {
        "user": "lovell",
        "created_at": "2018-10-01T17:45:24Z",
        "body": "Hello, it's unclear what `data` refers to in the `convert_image_sharp` function. Are you able to provide a standalone, working code sample?"
      },
      {
        "user": "wobeng",
        "created_at": "2018-10-01T17:48:09Z",
        "body": "Hi @lovell I updated what data is"
      },
      {
        "user": "lovell",
        "created_at": "2018-10-01T19:05:24Z",
        "body": "The shared `image` instance is being mutated by each function invocation. You'll need to move the `sharp(image_path)` constructor into the anonymous function returned by `convert_image_sharp` to create a new sharp instance per function invocation.\r\n\r\n```diff\r\nfunction convert_image_sharp(image_path) {\r\n-    let image = sharp(image_path) ;\r\n-    return data => image\r\n+    return data => sharp(image_path)\r\n        .metadata()\r\n```"
      },
      {
        "user": "wobeng",
        "created_at": "2018-10-01T19:23:13Z",
        "body": "If I move the sharp(image_path) constructor into the anonymous function returned by convert_image_sharp, who can I access metadata? can you show me an example with metadata included"
      },
      {
        "user": "lovell",
        "created_at": "2018-10-01T20:22:35Z",
        "body": "The code sample provided doesn't appear to use `metadata` as provided by the call to `metadata()` so I'm not sure I understand what is needed. This might be more of a question for StackOverflow."
      },
      {
        "user": "wobeng",
        "created_at": "2018-10-01T20:26:45Z",
        "body": "Question:\r\n\r\nAfter I do sharp(image_path).metadata(), to get the sharp object back, do I need to use the constructor sharp(image_path) again\r\n"
      },
      {
        "user": "lovell",
        "created_at": "2018-10-02T19:51:51Z",
        "body": "Here's a possible (untested) version of `convert_image_sharp` that should behave in a way that I have understood your `data.map` logic to expect.\r\n```javascript\r\nfunction convert_image_sharp(image_path) {\r\n  return () => {\r\n    const image = sharp(image_path);\r\n    const { crop, ext, width, height, write_path } = beatify_input(data);\r\n    if (crop) {\r\n      image.extract(...crop);\r\n    }\r\n    image.resize(width, height);\r\n    if (['jpg', 'jpeg'].includes(ext)) {\r\n      image.background('white').flatten();\r\n    }\r\n    return image.toFile(write_path);\r\n  };\r\n}\r\n```\r\nThis question is not really specific to sharp and is more of a general JavaScript coding question suited to a site such as StackOverflow."
      }
    ]
  },
  {
    "number": 1367,
    "title": "How to close the file?",
    "created_at": "2018-09-04T07:32:03Z",
    "closed_at": "2018-09-04T10:02:54Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/lovell/sharp/issues/1367",
    "body": "sharp('input.jpg')\r\n\r\nThe file is always locked\r\nUnable to delete\r\nHow to close an object?\r\n",
    "comments_url": "https://api.github.com/repos/lovell/sharp/issues/1367/comments",
    "author": "yyx1111",
    "comments": [
      {
        "user": "yyx1111",
        "created_at": "2018-09-04T09:59:44Z",
        "body": "before  sharp.cache( { files: 0 } );  It doesn't solve the problem\r\nsharp.cache(false);  ok\r\nThank you for your prompt reply."
      },
      {
        "user": "RichardBradley",
        "created_at": "2023-06-19T14:22:24Z",
        "body": "It would be nice if there were a way to explicitly close the file handle and dealloc the memory, separately from `cache(false)`, which I think isn't exactly the same thing"
      },
      {
        "user": "lovell",
        "created_at": "2023-06-19T15:30:05Z",
        "body": "@RichardBradley Use `sharp.cache({ files: 0 })` before you open any files to prevent file handles from being cached in the first place."
      }
    ]
  },
  {
    "number": 1292,
    "title": "Remove alpha channel from png output",
    "created_at": "2018-07-11T14:35:08Z",
    "closed_at": "2018-07-22T19:49:44Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/lovell/sharp/issues/1292",
    "body": "Hi I try to compose an `icon.png` (with 4 channels) onto a background.\r\nRight now my solution is like this\r\n```js\r\nconst icon = sharp('icon.png').resize(size)\r\nsharp({ create: { width, height, background, channels: 4 } })\r\n  .overlayWith(await icon.toBuffer())\r\n  .toFile('output.png')\r\n```\r\n\r\nNow I sometimes need to remove the alpha channel from the `output.png`,\r\nI tried using `.flatten()` but the output image still has 4 channels.\r\nIt only worked when I also `.flatten()` the `icon` but then I get problems with the overlay.\r\n\r\nIs there a solution for this or do I have thought error somewhere?\r\nThank you for your help.",
    "comments_url": "https://api.github.com/repos/lovell/sharp/issues/1292/comments",
    "author": "dertieran",
    "comments": [
      {
        "user": "lovell",
        "created_at": "2018-07-11T16:38:30Z",
        "body": "Hello, sharp will flatten before adding the overlay. To flatten after, something like the following should work (untested):\r\n\r\n```javascript\r\nconst rgbaImage = await sharp({ create: { width, height, background, channels: 4 } })\r\n  .overlayWith(await icon.toBuffer())\r\n  .toBuffer();\r\n\r\nsharp(rgbaImage)\r\n  .flatten()\r\n  .toFile('output.png')\r\n```"
      },
      {
        "user": "dertieran",
        "created_at": "2018-07-12T16:00:40Z",
        "body": "Thanks a lot that worked \ud83d\udc4d \r\nI just needed to add `.png()` before converting it to a buffer otherwise I would get the\r\n```\r\nInput buffer contains unsupported image format\r\n```\r\nSo now it looks like this:\r\n```js\r\nconst icon = sharp('icon.png').resize(size)\r\nconst buffer = await sharp({ create: { width, height, background, channels: 4 } })\r\n  .overlayWith(await icon.toBuffer())\r\n  .png()\r\n  .toBuffer()\r\n\r\nsharp(buffer)\r\n  .flatten()\r\n  .toFile('output.png')\r\n```"
      }
    ]
  },
  {
    "number": 1280,
    "title": "Metadata not updated after rotate()",
    "created_at": "2018-06-28T03:44:35Z",
    "closed_at": "2018-06-28T18:14:49Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/lovell/sharp/issues/1280",
    "body": "If I have a file of dimensions 1999x1124, exif orientation=8, and I run it through sharp:\r\n```js\r\nsharp(file).rotate().metadata().then(metadata => console.log(metadata))\r\n```\r\nI get the original metadata.  I would have expected to see the new dimensions: (1124x1999)  I tried inserting `sharp.cache(false)` after rotating, but that had no effect.\r\n\r\nI suspect this is because the metadata function works \"without decoding any compressed image data,\" and it would need to read the buffer in order to redetermine it?  This seems broken to me.  Shouldn't the rotate() function update whatever source it's pulling this metadata from?\r\n\r\nPerhaps one non-breaking solution to this could be accepting a second options argument to the rotate method with a \"resolveWithObject\" flag that would work just like toBuffer, resolving an additional data object containing the new size after rotation.  I don't particularly like this idea design-wise, just brainstorming.\r\n\r\nMy use-case is, I need to resize an overlay image down to match the *rotated* image, prior to applying it.  I've had to resort to calling toBuffer twice: once to just fetch the dimensions, and then again after applying the overlay.  It's just really ugly and inefficient.  Here's the simplified version:\r\n```js\r\nfunction applyOverlay(file, overlayFile) {\r\n    return sharp(file)\r\n        .rotate()\r\n        .toBuffer({resolveWithObject: true})\r\n        .then(async ({data, info}) => {\r\n            const newWidth  = info.width;\r\n            const newHeight = info.height;\r\n\r\n            const overlay = await sharp(overlayFile)\r\n                .resize(newWidth, newHeight)\r\n                .max()\r\n                .toBuffer();\r\n\r\n            return sharp(data)\r\n                .overlayWith(overlay)\r\n                .toBuffer();\r\n        });\r\n}\r\n```\r\nIf there's some easier way to do this that I'm missing, by all means let me know where I've gone wrong.  Thanks!",
    "comments_url": "https://api.github.com/repos/lovell/sharp/issues/1280/comments",
    "author": "hackel",
    "comments": [
      {
        "user": "lovell",
        "created_at": "2018-06-28T08:43:03Z",
        "body": "Hello, to perform a calculation based on EXIF Orientation without decoding pixel data, try something like the following (untested):\r\n```javascript\r\nsharp(file)\r\n  .metadata()\r\n  .then(({ width, height, orientation }) => {\r\n    const [newWidth, newHeight] = orientation < 5\r\n      ? [width, height]\r\n      : [height, width];\r\n    ...\r\n  });\r\n```"
      },
      {
        "user": "CptMaumau",
        "created_at": "2021-09-23T10:12:40Z",
        "body": "I recommend to do the opposite in case the metadata doesn't contain the orientation flag\r\n```\r\nconst [newWidth, newHeight] = orientation > 5\r\n  ? [metadata.height, metadata.width]\r\n  : [metadata.width, metadata.height];\r\n```"
      },
      {
        "user": "Apidcloud",
        "created_at": "2023-06-15T15:45:45Z",
        "body": "For what it's worth, just noticed the above snippet is not exactly the opposite (and therefore not entirely correct), as it missing the number 5 itself.\r\n\r\nIt should then be:\r\n```\r\nconst [newWidth, newHeight] = orientation >= 5\r\n  ? [metadata.height, metadata.width]\r\n  : [metadata.width, metadata.height];\r\n  ```"
      }
    ]
  },
  {
    "number": 1210,
    "title": "Error: The specified procedure could not be found.",
    "created_at": "2018-04-27T09:48:02Z",
    "closed_at": "2018-04-28T09:01:22Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/lovell/sharp/issues/1210",
    "body": "I have two Electron projects using sharp. I have a small testing project for testing sharp but it gave me an initialization DLL error at first. The commands I used were these and it got fixed.\r\n\r\n```\r\nnpm install --save-dev electron-rebuild\r\nnpm install sharp\r\n.\\node_modules\\.bin\\electron-rebuild.cmd\r\n```\r\nI can use sharp now and tested it with some code which generated cropped output from the original image.\r\n\r\n```\r\nsharp('input.jpg')\r\n  .resize(300, 200)\r\n  .toFile('output.jpg', function(err) {\r\n  });\r\n```\r\n\r\nThe bigger project (electron-builder/yarn) where I want to implement sharp gives me this error. \r\n```\r\nError: The specified procedure could not be found.\r\n  \\\\?\\C:\\Users\\Noblesse\\Documents\\GitHub\\desktop-gen-electron - kopie\\node_modules\\sharp\\build\\Release\\sharp.node\r\n      at process.module.(anonymous function) [as dlopen] (ELECTRON_ASAR.js:172:20)\r\n      at Object.Module._extensions..node (module.js:598:18)\r\n      at Object.module.(anonymous function) [as .node] (ELECTRON_ASAR.js:172:20)\r\n      at Module.load (module.js:503:32)\r\n      at tryModuleLoad (module.js:466:12)\r\n      at Function.Module._load (module.js:458:3)\r\n      at Module.require (module.js:513:17)\r\n      at require (internal/module.js:11:18)\r\n      at Object.<anonymous> (C:\\Users\\Noblesse\\Documents\\GitHub\\desktop-gen-electron - kopie\\node_modules\\sharp\\lib\\constructor.js:10:15)\r\n      at Object.<anonymous> (C:\\Users\\Noblesse\\Documents\\GitHub\\desktop-gen-electron - kopie\\node_modules\\sharp\\lib\\constructor.js:256:3)\r\n```\r\n\r\nI use the yarn way in this one but it doesn't work. There certainly is sharp.node in sharp/build/release/.\r\n```\r\nyarn add --dev electron-rebuild\r\nyarn add sharp\r\n.\\node_modules\\.bin\\electron-rebuild.cmd\r\n```",
    "comments_url": "https://api.github.com/repos/lovell/sharp/issues/1210/comments",
    "author": "OualidYousfi",
    "comments": [
      {
        "user": "lovell",
        "created_at": "2018-04-27T10:40:26Z",
        "body": "Does the \"bigger project\" include `node-canvas` as a dependency? If so, please see #1157"
      },
      {
        "user": "OualidYousfi",
        "created_at": "2018-04-28T00:26:24Z",
        "body": "It did, actually. As well as `text2png` which required `node-canvas`. Removed the two as they weren't essential to the project. Got no errors anymore. I implemented the .tiff() method to be sure (because JIMP doesn't seem to have an option for reducing the file size for TIFFs) and all my images are ~50 KB now instead of ~5 MB.\r\n\r\nThanks for the quick tip!"
      }
    ]
  },
  {
    "number": 1179,
    "title": "ForceSet deprecation warnings in v8 while building",
    "created_at": "2018-04-04T06:58:10Z",
    "closed_at": "2018-04-04T09:23:53Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/lovell/sharp/issues/1179",
    "body": "I'm getting many of these in various files with the latest version of node:\r\n```\r\n  CXX(target) Release/obj.target/sharp/src/utilities.o\r\nIn file included from ../../nan/nan.h:192:0,\r\n                 from ../src/utilities.cc:19:\r\n../../nan/nan_maybe_43_inl.h: In function 'Nan::Maybe<bool> Nan::ForceSet(v8::Local<v8::Object>, v8::Local<v8::Value>, v8::Local<v8::Value>, v8::PropertyAttribute)':\r\n../../nan/nan_maybe_43_inl.h:112:73: warning: 'v8::Maybe<bool> v8::Object::ForceSet(v8::Local<v8::Context>, v8::Local<v8::Value>, v8::Local<v8::Value>, v8::PropertyAttribute)' is deprecated: Use CreateDataProperty / DefineOwnProperty [-Wdeprecated-declarations]\r\n   return obj->ForceSet(isolate->GetCurrentContext(), key, value, attribs);\r\n                                                                         ^\r\nIn file included from /root/.node-gyp/9.10.1/include/node/v8.h:26:0,\r\n                 from /root/.node-gyp/9.10.1/include/node/node.h:63,\r\n                 from ../src/utilities.cc:18:\r\n/root/.node-gyp/9.10.1/include/node/v8.h:3165:29: note: declared here\r\n                 Maybe<bool> ForceSet(Local<Context> context, Local<Value> key,\r\n                             ^\r\n/root/.node-gyp/9.10.1/include/node/v8config.h:318:3: note: in definition of macro 'V8_DEPRECATED'\r\n   declarator __attribute__((deprecated(message)))\r\n   ^~~~~~~~~~\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/lovell/sharp/issues/1179/comments",
    "author": "jwater7",
    "comments": [
      {
        "user": "lovell",
        "created_at": "2018-04-04T07:56:49Z",
        "body": "Hello, does the most recent version of sharp, namely v0.20.1, exhibit this behaviour also?"
      },
      {
        "user": "jwater7",
        "created_at": "2018-04-04T09:23:53Z",
        "body": "v0.20.1 does in fact fix the issue, sorry - this was a misunderstanding on my part how the node packages were getting updated and I thought I was getting the latest version.  I'll resolve the issue, thanks for the tip."
      }
    ]
  },
  {
    "number": 1136,
    "title": "Throw error on problem",
    "created_at": "2018-02-23T14:29:38Z",
    "closed_at": "2018-02-23T17:56:20Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/lovell/sharp/issues/1136",
    "body": "Some problematic files (e.g. a `.png` file that is accidentally a `.html` file because a download didn't 404 but 302 to html) cause `sharp` to hang indefinitely.\r\n\r\nI think this should throw an Error in stead.\r\n\r\n```javascript\r\ntry {\r\n\tsharp(src, {failOnError: true})\r\n\t\t.resize(width, height)\r\n\t\t.background(bg)\r\n\t\t.embed()\r\n\t\t.toFile(dest, cb)\r\n}\r\ncatch (err) {\r\n\t// Never fires\r\n\tconsole.error(err.stack)\r\n\tcb()\r\n}\r\n```",
    "comments_url": "https://api.github.com/repos/lovell/sharp/issues/1136/comments",
    "author": "Redsandro",
    "comments": [
      {
        "user": "lovell",
        "created_at": "2018-02-23T14:49:52Z",
        "body": "Hello, `toFile()` is asynchronous and any error during image processing will be passed as the first parameter to the provided callback function, `cb` in your example.\r\n\r\nIf you want try/catch behaviour you'll need to use async/await.\r\n\r\n```javascript\r\ntry {\r\n\tawait sharp(src, {failOnError: true})\r\n\t\t.resize(width, height)\r\n\t\t.background(bg)\r\n\t\t.embed()\r\n\t\t.toFile(dest)\r\n}\r\ncatch (err) {\r\n\tconsole.error(err.stack)\r\n}\r\n```"
      }
    ]
  },
  {
    "number": 1084,
    "title": "Alpine: which dependencies are unnecessary at runtime?",
    "created_at": "2018-01-04T15:54:13Z",
    "closed_at": "2018-01-06T03:55:41Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/lovell/sharp/issues/1084",
    "body": "It doesn't work on the alpine-based docker image when I delete the vips-dev.",
    "comments_url": "https://api.github.com/repos/lovell/sharp/issues/1084/comments",
    "author": "zhcsyncer",
    "comments": [
      {
        "user": "lovell",
        "created_at": "2018-01-04T20:18:34Z",
        "body": "Hello, the `vips` and `vips-dev` packages are required at `npm install` (compile) time but only the `vips` package is required at runtime when using Alpine."
      },
      {
        "user": "zhcsyncer",
        "created_at": "2018-01-06T03:55:41Z",
        "body": "thks.\r\nWhen I used `apk add vips-dev` to install `vips-dev`, `vips` was installed as a dependency of `vips-dev`, so when `apk del vips-dev` was executed, `apk` was also deleted by `apk`. \r\n"
      }
    ]
  },
  {
    "number": 1057,
    "title": "Using overlayWith before a rotate call throws an error",
    "created_at": "2017-12-09T08:22:44Z",
    "closed_at": "2017-12-12T08:06:59Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/lovell/sharp/issues/1057",
    "body": "I'm working on a project where I need to extract a piece of an image and then mask the extracted image with a polygon shape and then rotate it. I am using an SVG string buffer as the mask.\r\n\r\nWhen I run this line of code with rotate() I get an error:\r\n\"Overlay image must have same dimensions or smaller\"\r\n\r\n```\r\nsharp(imageData)\r\n    .extract({left: left, top: top, width: width, height: height})\r\n    .overlayWith(mask, {cutout: true})\r\n    .flip(isMirrored)\r\n    .rotate(rotation)\r\n    .png()\r\n    .toFile(filePath);\r\n```\r\n\r\nWhen I run it without the rotate call, it runs without error. I am not sure if this is an actual bug or if I may be doing something wrong. I am assuming that the overlayWith is happening after the rotation and that may be what is causing the error.\r\n\r\nI also want to thank you for creating this library. It is brilliant!",
    "comments_url": "https://api.github.com/repos/lovell/sharp/issues/1057/comments",
    "author": "zachzurn",
    "comments": [
      {
        "user": "lovell",
        "created_at": "2017-12-10T20:03:32Z",
        "body": "Hello, your guess is correct, the overlay is applied at the end. You'll probably need to split this into two pipelines, something like:\r\n```javascript\r\nsharp(imageData)\r\n  .extract({left: left, top: top, width: width, height: height})\r\n  .overlayWith(mask, { cutout: true })\r\n  .raw()\r\n  .toBuffer({ resolveWithObject: true })\r\n  .then(({ data, info }) => sharp(data, { raw: info })\r\n    .flip(isMirrored)\r\n    .rotate(rotation)\r\n    .png()\r\n    .toFile(filePath)\r\n  );\r\n```\r\n"
      }
    ]
  },
  {
    "number": 1052,
    "title": "Create folder with `.toFile`?",
    "created_at": "2017-12-04T16:02:11Z",
    "closed_at": "2017-12-04T17:11:54Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/lovell/sharp/issues/1052",
    "body": "If the folder doesn't exist `sharp` throws me an error\r\nIs there's a way to sharp to create such folder if it doesn't exist?\r\n\r\n```js\r\n.toFile(`./public/uploads/${'resize-' + req.body.file}`)\r\n```\r\n```\r\nError: vips__file_open_write: unable to open file \"./public/uploads/greyscale-67badcb0-8a98-4126-828a-4e9fe152979b.jpeg\" for writing\r\nunix error: No such file or directory\r\n```",
    "comments_url": "https://api.github.com/repos/lovell/sharp/issues/1052/comments",
    "author": "hackuun",
    "comments": [
      {
        "user": "hackuun",
        "created_at": "2017-12-05T15:39:35Z",
        "body": "@lovell got it. So you suggest something like this: first check is directory is exist, if not then create it with `mkdirp` and only after fire up `sharp`? Can I see basic clean example, because right now it looks little messed for me."
      },
      {
        "user": "papandreou",
        "created_at": "2017-12-05T18:44:15Z",
        "body": "```js\r\nconst mkdirp = require('mkdirp-promise');\r\nconst sharp = require('sharp');\r\n(async () => {\r\n  await mkdirp('public/uploads');\r\n\r\n  await sharp()\r\n    // ...\r\n    .toFile(`./public/uploads/${'resize-' + req.body.file}`);\r\n})();\r\n```\r\n"
      }
    ]
  },
  {
    "number": 1049,
    "title": "Multiple operations doesn't work",
    "created_at": "2017-11-30T19:56:54Z",
    "closed_at": "2017-11-30T20:12:37Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/lovell/sharp/issues/1049",
    "body": "Hello. I am trying to resize and then grayscale image, but console gives me an error\r\n\r\n```js\r\nsharp(req.file.buffer)\r\n    .resize(800)\r\n    .toFile(`./public/uploads/${'resize-' + req.body.file}`)\r\n    .grayscale()\r\n    .toFile(`./public/uploads/${'grayscale-' + req.body.file}`)\r\n```\r\n\r\nIs it possible? Or this savings should be separate operations?",
    "comments_url": "https://api.github.com/repos/lovell/sharp/issues/1049/comments",
    "author": "hackuun",
    "comments": [
      {
        "user": "lovell",
        "created_at": "2017-11-30T20:10:38Z",
        "body": "Hello, `toFile` returns a `Promise` so try something like the following (untested):\r\n\r\n```javascript\r\nPromise.all([\r\n  sharp(req.file.buffer)\r\n    .resize(800)\r\n    .toFile(`./public/uploads/resize-${req.body.file}`),\r\n  sharp(req.file.buffer)\r\n    .resize(800)\r\n    .grayscale()\r\n    .toFile(`./public/uploads/grayscale-${req.body.file}`)\r\n]).then( ... );\r\n```"
      }
    ]
  },
  {
    "number": 997,
    "title": "how to get metadata width and height after trim",
    "created_at": "2017-10-18T20:59:25Z",
    "closed_at": "2017-10-19T12:42:05Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/lovell/sharp/issues/997",
    "body": "Is there a way to get width and height metadata after trim?\r\n\r\n```\r\nlet transform = sharp()\r\n    .trim()\r\n    .metadata()\r\n    .then(function(metadata) {\r\n        console.log(metadata)\r\n    })\r\n\r\nreturn readableStream\r\n            .pipe(transform)\r\n```\r\n\r\nThis doesn't seem to work\r\n\r\n\r\nThanks",
    "comments_url": "https://api.github.com/repos/lovell/sharp/issues/997/comments",
    "author": "jaekunchoi",
    "comments": [
      {
        "user": "lovell",
        "created_at": "2017-10-19T10:51:53Z",
        "body": "Hello, `metadata()` operates on the input but it looks like you need to generate the output.\r\n\r\n`toBuffer()` provides the output dimensions via `info`, so try something like (untested):\r\n\r\n```javascript\r\nconst trimmer = sharp()\r\n  .trim()\r\n  .toBuffer((err, data, info) => {\r\n    console.log(info)\r\n  })\r\nreturn readableStream\r\n  .pipe(trimmer)\r\n```"
      },
      {
        "user": "jaekunchoi",
        "created_at": "2017-10-19T11:31:48Z",
        "body": "thanks. How do I then pass the info to the next `pipe`?"
      },
      {
        "user": "lovell",
        "created_at": "2017-10-19T11:54:53Z",
        "body": "When using Stream-based output, the data piped from a sharp instance is the (compressed) image.\r\n\r\nThe instance will emit an `info` event with the data you need, which can be used to update another variable in an outer scope, something like:\r\n\r\n```javascript\r\n// Define this within a scope that writableStream can access\r\nlet trimmedInfo\r\n\r\nconst trimmer = sharp()\r\n  .trim()\r\n  .on('info', info => {\r\n    trimmedInfo = info\r\n  })\r\n\r\nreadableStream\r\n  .pipe(trimmer)\r\n  .pipe(writableStream);\r\n```"
      },
      {
        "user": "jaekunchoi",
        "created_at": "2017-10-19T11:58:41Z",
        "body": "thanks I mean I want to be able to do something like:\r\n\r\n```\r\nlet trimmedInfo = { width: 0, height: 0 }\r\n\r\nconst trimmer = sharp()\r\n  .trim()\r\n  .on('info', info => {\r\n    trimmedInfo = info\r\n  })\r\n  .extend({ top: trimmedInfo.height, bottom: trimmedInfo.height, left: trimmedInfo.width, right: trimmedInfo.width })\r\n  .background(background)\r\n\r\nreadableStream\r\n  .pipe(trimmer)\r\n```\r\n\r\nIt seems width and height is 0 how can I pass them through as they are not updated?"
      },
      {
        "user": "lovell",
        "created_at": "2017-10-19T12:00:20Z",
        "body": "Thanks for the extra context. You'll need to separate this into two operations with two sharp instances, one for the trim, and a second for the extend."
      },
      {
        "user": "lovell",
        "created_at": "2017-10-19T12:29:58Z",
        "body": "Thank you for even more context. In the above example, `padding_width` has a value of `0` when `extend()` is called on `transformer3`.\r\n\r\nYou'll probably want to defer this assignment, something like:\r\n\r\n```javascript\r\nconst transformer3 = sharp()\r\n  .background(background)\r\n\r\nconst transformer2 = sharp()\r\n  .trim()\r\n  .on('info', trimmed_metadata => {\r\n    ...\r\n    transformer3.extend({ ... })\r\n  })\r\n```\r\n"
      }
    ]
  },
  {
    "number": 994,
    "title": "Silent crash when calling sharp without arguments",
    "created_at": "2017-10-17T17:58:01Z",
    "closed_at": "2017-10-17T20:06:25Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/lovell/sharp/issues/994",
    "body": "Minimal test case:\r\n\r\n```js\r\nconst sharp = require('sharp')\r\nconst main = async () => {\r\n  const image = sharp()\r\n  const info = await image.metadata()\r\n  console.log('done')\r\n}\r\n\r\nmain()\r\n```\r\n\r\nThe process simply exits with status 0.  There is no error message, and 'done' is never logged to the console.",
    "comments_url": "https://api.github.com/repos/lovell/sharp/issues/994/comments",
    "author": "whmountains",
    "comments": [
      {
        "user": "lovell",
        "created_at": "2017-10-17T18:16:31Z",
        "body": "Hello, the parameter-less constructor is for Stream-based input.\r\n\r\n> \"JPEG, PNG, WebP, GIF, SVG, TIFF or raw pixel image data can be streamed into the object when not present.\" \r\n\r\nIn your example, this might look like the following:\r\n```diff\r\n  const image = sharp()\r\n+ readableSteam.pipe(image)\r\n  const info = await image.metadata()\r\n```"
      }
    ]
  },
  {
    "number": 808,
    "title": "how to get metadata of output image?",
    "created_at": "2017-05-16T15:21:49Z",
    "closed_at": "2017-05-16T16:57:49Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/lovell/sharp/issues/808",
    "body": "the current example only get input image metadata, not output, if the input image's size is 1200x1200, we get  `{width: 1200, height: 1200, ...}` not `{width: 400, height: ?, ...}`\r\n\r\n\r\n```js\r\n      const sharpInstance = sharp(buf).resize(400);\r\n      const resizedBuf = await sharpInstance.toBuffer();\r\n      const metadata = await sharpInstance.metadata();\r\n```",
    "comments_url": "https://api.github.com/repos/lovell/sharp/issues/808/comments",
    "author": "hbakhtiyor",
    "comments": [
      {
        "user": "lovell",
        "created_at": "2017-05-16T16:52:22Z",
        "body": "Hello, I think you're looking for the metadata of the processed image, which would be:\r\n```javascript\r\nconst metadata = await sharp(resizedBuf).metadata();\r\n```\r\n\r\nFrom v0.17.3+, you could also use:\r\n```javascript\r\nconst { data, info } = await sharpInstance.toBuffer({ resolveWithObject: true });\r\n```"
      },
      {
        "user": "ajhool",
        "created_at": "2018-08-02T02:36:49Z",
        "body": "Can this be achieved without calling toBuffer? It seems like a common use-case that somebody would need to know the metadata of the transformed file."
      },
      {
        "user": "lovell",
        "created_at": "2018-08-02T08:17:33Z",
        "body": "@ajhool Please can you provide a code sample demonstrating how you think this might be improved."
      },
      {
        "user": "kghost",
        "created_at": "2018-12-21T14:10:00Z",
        "body": "@lovell\r\nEg, I want to convert an unknown sized image to 200\\*100 with { fit: inside }. after resize call, the size of processed image is unknown, I need to calculate paddings and call extend to extend the image to 200\\*100.\r\n\r\n\r\nI don't know if it is a bug. After\r\n\r\n```\r\nimg.resize(200,100,{fit:sharp.fit.inside})\r\n``` \r\n\r\nI got an 100*100 image when input is square."
      }
    ]
  },
  {
    "number": 688,
    "title": "Error: extract_area: bad extract area",
    "created_at": "2017-01-19T13:00:31Z",
    "closed_at": "2017-01-19T13:54:46Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/lovell/sharp/issues/688",
    "body": "Hello, I'm using 512x512 image. First I resize it then extract and expecting readable stream data but it shows me \"Error: extract_area: bad extract area\" error.\r\nHere's the code;\r\n\r\n```\r\ntest2(x, y, zoom) {\r\n        const width = 500;\r\n        const height = 500;\r\n\r\n        return this.image\r\n            .metadata()\r\n            .then((metadata) => {\r\n                var resizedWidth = metadata.width * zoom;\r\n                var resizedHeight = metadata.height * zoom;\r\n                var left = parseInt(resizedWidth * x);\r\n                var top = parseInt(resizedHeight * y);\r\n                return this.image\r\n                    .resize(resizedWidth, resizedHeight)\r\n                    .extract({left: left, top: top, width: width, height: height})\r\n                    .jpeg()\r\n                    .resize(500);\r\n            });\r\n}\r\n```\r\nThanks.",
    "comments_url": "https://api.github.com/repos/lovell/sharp/issues/688/comments",
    "author": "erhankilic",
    "comments": [
      {
        "user": "erhankilic",
        "created_at": "2017-01-19T13:06:21Z",
        "body": "Ahhh, I must say, resizedWidth = 1024, resizedHeight = 1024 (because i used zoom = 0,5) and left = 204, right = 204 (because i used x = 0,2 and y = 0,2). Extract area is valid."
      },
      {
        "user": "lovell",
        "created_at": "2017-01-19T13:39:45Z",
        "body": "Hello, I think the problem here is that `.resize(500)` will replace the values passed to `.resize(resizedWidth, resizedHeight)`. Whilst you can chain `extract` with `resize` (with `extract`), you can't chain `resize` with itself.\r\n\r\nIf you need the output image to always be 500 pixels wide, you might be able to extract-then-resize via `.extract(...).resize(500, resizedHeight)`, making sure to alter your `resizedHeight` calculation accordingly."
      },
      {
        "user": "erhankilic",
        "created_at": "2017-01-19T13:54:46Z",
        "body": "Ahhh, thanks,\r\n\r\nI fixed it with this codes.\r\n\r\n```\r\nreturn this.image\r\n            .metadata()\r\n            .then((metadata) => {\r\n                var resizedWidth = metadata.width * zoom;\r\n                var resizedHeight = metadata.height * zoom;\r\n                var left = parseInt(resizedWidth * x);\r\n                var top = parseInt(resizedHeight * y);\r\n                return this.image\r\n                    .jpeg()\r\n                    .resize(resizedWidth, resizedHeight)\r\n                    .toBuffer()\r\n                    .then((data) => {\r\n                        return sharp(data)\r\n                            .extract({left: left, top: top, width: width, height: height})\r\n                            .resize(width, height);\r\n                    })\r\n            });\r\n```"
      },
      {
        "user": "imCorfitz",
        "created_at": "2020-10-18T08:10:44Z",
        "body": "I know this may be an old thread - but I experienced this issue recently, and it was due to the orientation of the image on the server, not being equivalent of the interpreted orientation in the browser. Say I took a picture with my iPhone, then safari and the phone knew how to properly orient the photo, but the server no.\r\n\r\nIn order to fix that, I simply initialised the sharp procedure with `.rotate()`, which took care of that. \r\n\r\n`sharp('image data goes here').rotate().extract({left: left, top: top, width: width, height: height}).resize(width, height);`.\r\n\r\nJust as a note for future visitors, as this issue pops up as the first result when searching in Google."
      },
      {
        "user": "hunzaGit",
        "created_at": "2021-06-24T19:15:59Z",
        "body": "Thanks to @imCorfitz 's comment I solved the problem, for some strange reason Sharp (v0.25.4) interprets some rotated images, in particular a vertical image taken from the smartphone's gallery. If the frontend of the app gets the picture (vertical or horizontal) from the camera everything works fine.\r\n\r\nIn my case, simply comparing the Sharp Metadata with the original dimensions of the photo fixed it.\r\n\r\nAs a simple code example for future visitors:\r\n```\r\nif(dimOriginal.width === metadata.height && dimOriginal.height === metadata.width){\r\n    console.log(\"image is rotated\");\r\n    promiseImg = promiseImg.rotate()\r\n}\r\n```"
      }
    ]
  },
  {
    "number": 636,
    "title": "Advice Needed: How to create deep zoom image if I already have tiles?",
    "created_at": "2016-11-27T19:51:53Z",
    "closed_at": "2016-12-08T18:16:47Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/lovell/sharp/issues/636",
    "body": "If I had a single large .tif, my understanding is that I could create a Deep Zoom image from this single large file quite easily by using the `tile` method\r\n\r\nHowever, my large image is already split up into a regular grid of non-overlapping tiles. One approach would be to stitch this array of tiles into a single large .tif first. If I were to go that approach, I'm not sure that `sharp` has a method to stitch so many files, and if it did, I'm not sure that it exposes a way to do it without needing to have the entire final image in memory at some point. I'd love to be wrong on both of these points!\r\n\r\nEssentially, I need to treat these tiles as the full-resolution image somehow, and then have the images further split and compressed to generate the various resolutions necessary for the Deep Zoom format. Do you have any advice on how to go about this with Sharp?\r\n\r\nMany thanks.\r\n\r\n",
    "comments_url": "https://api.github.com/repos/lovell/sharp/issues/636/comments",
    "author": "Taytay",
    "comments": [
      {
        "user": "lovell",
        "created_at": "2016-11-27T21:45:40Z",
        "body": "Hi Taylor, rather than use sharp, `vips_arrayjoin` is probably your friend here. When vips is installed you can use it via the command line, for example the following will stitch 4 tiles into a 2x2 grid:\r\n\r\n```sh\r\nvips arrayjoin 1.png 2.png 3.png 4.png 2x2.png --across 2\r\n```\r\n"
      }
    ]
  },
  {
    "number": 625,
    "title": "Mysticism: sharp reacalls old type-related buffer from somewhere?",
    "created_at": "2016-11-15T10:15:57Z",
    "closed_at": "2016-11-15T13:11:20Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/lovell/sharp/issues/625",
    "body": "My app uploads jpg/png files (type is restricted in app) to server, source image is saved to certain path (it works).\r\nThen I apply following resize routine:\r\n\r\n ```\r\n//Processing logo\r\n              sharp(logoPath + '/logo_upload')\r\n                .resize(640,120)\r\n                .max()\r\n                .toFormat('jpeg')\r\n                .toFile(logoPath + '/logo.jpg', function(err, info) {\r\n                  if (err) {console.error(err); throw (err)}\r\n                  console.log('120 info: ', info)\r\n                });\r\n```\r\n\r\nThe issue is **very** strange:\r\n1) I upload \"1.jpg\", sharp works - 1.jpg image resized/saved, no problem\r\n2) upload \"2.png\", sharp works as well -  image resized/saved (always under the same name - logo.jpg)\r\n3) upload \"3.jpg\", sharp resizes and saves \"1.jpg\" content (WTF?! from where?) \r\nAfter that no matter what I upload (source file logo_upload changes every time - I double-checked) - sharp output stays the same, \"1.jpg\" ((\r\nVersions: sharp - 0.16.2, node - 4.4.5\r\n\r\nGuys, what I'm doing wrong? What to consider to check in approach?\r\n",
    "comments_url": "https://api.github.com/repos/lovell/sharp/issues/625/comments",
    "author": "greenais",
    "comments": [
      {
        "user": "lovell",
        "created_at": "2016-11-15T10:56:19Z",
        "body": "Hello, it looks like the input filename remains the same so you're probably seeing the effects of libvips' operation cache serving the previous contents to the processing pipeline.\r\n\r\nPerhaps try adding the following before any processing:\r\n\r\n``` javascript\r\nsharp.cache({files: 0});\r\n```\r\n"
      },
      {
        "user": "greenais",
        "created_at": "2016-11-15T13:11:20Z",
        "body": "Wow, you are right - that cache plays tricks.\nTried your suggestion, \n`sharp.cache({files: 0});`\ndoesn't work.\n\n`sharp.cache({items: 0});`\ndoes.\n\nProbably it's a good idea to put this in FAQ.\nThank you for your great job and support.\n"
      }
    ]
  },
  {
    "number": 585,
    "title": "Resizing image with larger dimension and size",
    "created_at": "2016-09-26T19:01:52Z",
    "closed_at": "2016-10-12T18:54:46Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/lovell/sharp/issues/585",
    "body": "Like to have some suggestions regarding the issue i'm facing currently.\n\nWe are allowing image upload and user can choose larger dimension images and large in size.\n\nAs of now  we are giving some fixed dimension to resize. is there a way to figure out  preferred  `height` and `width`  which to be resized based on the image we upload.\n\n```\nex  var dim1 = getPrefferedSize(4000,5500)  // 1024, 1400\nex  var dim2 = getPrefferedSize(2040,1500)  // 904, 720\n```\n",
    "comments_url": "https://api.github.com/repos/lovell/sharp/issues/585/comments",
    "author": "tomalex0",
    "comments": [
      {
        "user": "lovell",
        "created_at": "2016-09-26T19:33:56Z",
        "body": "Hello, I'm not quite sure I understand the requirement here. Are the numbers in the comments input dimensions or expected output dimensions? A fully worked example would help me :)\n"
      },
      {
        "user": "tomalex0",
        "created_at": "2016-09-26T20:23:53Z",
        "body": "@lovell  sorry for not to be clear\n\nWhen we upload  a larger image (4000 x 5000), can we give some `percentage` instead of `width and height`, so that it will be  resized into lets say `1024 x 1200`.   Its kind of hard to figure out  to which size it should be resized.\n\nI'm looking  for a solution so that user will still upload larger images but in node layer we will take care of resizing, considering users can upload different size of images\n"
      },
      {
        "user": "lovell",
        "created_at": "2016-09-26T22:11:20Z",
        "body": "If the output dimensions are to be a percentage of input dimensions then something like the following (untested) should work:\n\n``` javascript\nconst percentage = 25;\nsharp(input).metadata()\n  .then(info => {\n    const width = Math.round(info.width * percentage / 100);\n    const height = Math.round(info.height * percentage / 100);\n    return sharp(input).resize(width, height).toBuffer();\n  })\n  .then(output => {\n     ...\n  });\n```\n"
      },
      {
        "user": "jrock2468",
        "created_at": "2019-12-16T02:43:10Z",
        "body": "> If the output dimensions are to be a percentage of input dimensions then something like the following (untested) should work:\r\n> \r\n> ```js\r\n> const percentage = 25;\r\n> sharp(input).metadata()\r\n>   .then(info => {\r\n>     const width = Math.round(info.width * percentage / 100);\r\n>     const height = Math.round(info.height * percentage / 100);\r\n>     return sharp(input).resize(width, height).toBuffer();\r\n>   })\r\n>   .then(output => {\r\n>      ...\r\n>   });\r\n> ```\r\n\r\nThis would be an awesome example to include in the documentation.  I searched for something similar for a long time."
      }
    ]
  },
  {
    "number": 528,
    "title": "How to prevent crash on unhandled errors when using streams?",
    "created_at": "2016-07-25T21:06:32Z",
    "closed_at": "2016-07-27T18:43:15Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/lovell/sharp/issues/528",
    "body": "Hi,\n\nwhat is the recommended way of preventing a crash of the application if I'm using sharp as follows and the buffer data is undefined or has unsupported image data in it?\nThe 'error' event is not being fired in this case. Do I need to incorporate a try/catch block somehow?\n\n``` js\nvar pipeline = sharp()\n.on('error', err => console.log('error'))\n.pipe(fs.createWriteStream('filename.jpg'));\n\nvar readStream = new stream.PassThrough();\nreadStream.end(someBuffer);\n\nreadStream.pipe(pipeline);\n```\n\nWhen `someBuffer` is undefined, I get this error and the app crashes.\n\n```\n     Error: Input file is missing or of an unsupported image format\n        at Error (native)\n```\n",
    "comments_url": "https://api.github.com/repos/lovell/sharp/issues/528/comments",
    "author": "dsine-de",
    "comments": [
      {
        "user": "lovell",
        "created_at": "2016-07-26T09:02:38Z",
        "body": "Piping `undefined` into a `sharp` instance will (currently) result in a zero-length Buffer being processed by libvips. This situation can be improved, but I would expect it to still emit the `error` event. I'll need to take a closer look.\n"
      },
      {
        "user": "lovell",
        "created_at": "2016-07-27T15:43:55Z",
        "body": "If you change your example to call `pipe` on the pipeline rather than the return value of the call to `on` it correctly emits the expected error.\n\n``` diff\n- .on('error', err => console.log('error'))\n- .pipe(fs.createWriteStream('filename.jpg'));\n+ .on('error', err => console.log('error'));\n+ pipeline.pipe(fs.createWriteStream('filename.jpg'));\n```\n\nMy best guess would be that this is something to do with to node's `stream.Duplex` object inheriting from `stream.Readable` but not `stream.Writable` (due to the lack of multiple inheritance).\n"
      },
      {
        "user": "papandreou",
        "created_at": "2016-07-28T09:10:49Z",
        "body": "`on` is chainable, but `pipe` returns the target (writable) stream, so the original snippet pipes the readable stream directly into the writable stream.\n"
      },
      {
        "user": "afrozl",
        "created_at": "2016-08-08T21:50:13Z",
        "body": "I'm trying to follow this example, but I am clearly missing something as I am unable to trap the error. \nmy pipeline looks like:\n\n```\n var remoteWriteStream = bucket.file('assets/images/lead/' + file).createWriteStream({metadata: { contentType: 'image/jpeg'}});\n var pipeline = sharp('./public/images/tmp/' + file)\n .resize(1280, 800)\n .crop(sharp.gravity.north)\n .quality(85)\n .on('error', err => console.log('error');\n pipeline.pipe(remoteWriteStream)\n\nsharp error: Error: Input file is missing or \nof an unsupported image format\n\n```\n"
      },
      {
        "user": "lovell",
        "created_at": "2016-08-09T08:56:51Z",
        "body": "@afrozl Perhaps try using an absolute path instead of the relative `./public/images/...` (as paths are relative to the working directory, which isn't always the same as the directory containing your script).\n"
      }
    ]
  },
  {
    "number": 453,
    "title": "Library not loaded: /usr/local/opt/orc/lib/liborc-0.4.0.dylib",
    "created_at": "2016-06-05T05:15:27Z",
    "closed_at": "2016-06-05T10:58:21Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/lovell/sharp/issues/453",
    "body": "Unable to run the module due to an error of `Library not loaded: /usr/local/opt/orc/lib/liborc-0.4.0.dylib`.\n\nI used `brew install homebrew/science/vips` to install all dependancies. Everything was installed correctly (after around 10 minutes), yet the module still fails to run.\n\nAny idea on how to fix this?\n",
    "comments_url": "https://api.github.com/repos/lovell/sharp/issues/453/comments",
    "author": "zilions",
    "comments": [
      {
        "user": "lovell",
        "created_at": "2016-06-05T09:11:13Z",
        "body": "Hello, this looks like #323. Please can you try:\n\n``` sh\nbrew update && brew upgrade\nbrew unlink orc && brew link orc\n```\n"
      },
      {
        "user": "tiendq",
        "created_at": "2016-08-12T03:43:02Z",
        "body": "@lovell I got the same error yesterday on my OSX and your trick worked, thanks :)\n\nError ==========================\n\n1): Library not loaded: /usr/local/opt/libpng/lib/libpng16.16.dylib\n  Referenced from: /usr/local/opt/vips/lib/libvips-cpp.42.dylib\n  Reason: Incompatible library version: libvips-cpp.42.dylib requires version 40.0.0 or later, but libpng16.16.dylib provides version 38.0.0\n"
      }
    ]
  },
  {
    "number": 422,
    "title": "Can't install sharp v0.12.2 with node 6",
    "created_at": "2016-04-30T16:53:53Z",
    "closed_at": "2016-04-30T17:37:55Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/lovell/sharp/issues/422",
    "body": "Error shown when I tried to install:\n\nnpm ERR! Darwin 15.4.0\nnpm ERR! argv \"/usr/local/bin/node\" \"/usr/local/bin/npm\" \"install\"\nnpm ERR! node v6.0.0\nnpm ERR! npm  v3.8.6\nnpm ERR! code ELIFECYCLE\n\nnpm ERR! sharp@0.12.2 install: `node-gyp rebuild`\nnpm ERR! Exit status 1\nnpm ERR! \nnpm ERR! Failed at the sharp@0.12.2 install script 'node-gyp rebuild'.\nnpm ERR! Make sure you have the latest version of node.js and npm instal\n",
    "comments_url": "https://api.github.com/repos/lovell/sharp/issues/422/comments",
    "author": "MichaelBuen",
    "comments": [
      {
        "user": "lovell",
        "created_at": "2016-04-30T16:58:54Z",
        "body": "Please can you try with v0.14.1, the latest version.\n"
      }
    ]
  },
  {
    "number": 389,
    "title": "incompatible library version",
    "created_at": "2016-04-01T04:33:42Z",
    "closed_at": "2016-04-01T10:13:45Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/lovell/sharp/issues/389",
    "body": "I got this error when i tried to run.\n\n\"Reason: Incompatible library version: libvips-cpp.42.dylib requires version 38.0.0 or later, but libpng16.16.dylib provides version 35.0.0\"\n",
    "comments_url": "https://api.github.com/repos/lovell/sharp/issues/389/comments",
    "author": "SuThaw",
    "comments": [
      {
        "user": "lovell",
        "created_at": "2016-04-01T08:00:23Z",
        "body": "Hello, running `brew update && brew upgrade` and/or `brew unlink libpng && brew link libpng` might help. See #323 too.\n"
      }
    ]
  },
  {
    "number": 328,
    "title": "preinstall: cache build folders for faster ci tests",
    "created_at": "2015-12-22T22:08:15Z",
    "closed_at": "2015-12-22T23:07:02Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/lovell/sharp/issues/328",
    "body": "currently, on circleci, compiling libvips with the preinstall.sh script takes 2 minutes, which is more than 50% of the entire test. it takes so long because it's compiling libvips from source.\n\nan optimization would be to check whether the cache folders already exist (ex. `vips-8.1.1`) and simplify install it, skipping the rest of the script. this would make installations much faster.\n\nof course, in your CI test suite, you have to add the cache folder to your config.\n\nany thoughts or ideas on this?\n",
    "comments_url": "https://api.github.com/repos/lovell/sharp/issues/328/comments",
    "author": "jonathanong",
    "comments": [
      {
        "user": "lovell",
        "created_at": "2015-12-22T22:44:15Z",
        "body": "Hello, which version of sharp are you using?\r\n\r\nv0.12.0+ should use a pre-compiled libvips on Circle CI's Ubuntu 12.04 via `npm install` without the need to run the almost-deprecated `preinstall.sh` script\r\n"
      },
      {
        "user": "lovell",
        "created_at": "2015-12-22T23:10:08Z",
        "body": "No worries. I say \"almost deprecated\" because Centos 6.\n"
      }
    ]
  },
  {
    "number": 181,
    "title": "Set image resolution (dpi)",
    "created_at": "2015-03-19T10:23:24Z",
    "closed_at": "2015-03-19T11:01:26Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/lovell/sharp/issues/181",
    "body": "I think that my search skills are failing me...\n\nIs it possible to manually set the desired dpi of an image?\n\nI have a set of big TIFFs at 300 dpi and I would like to convert them into 300 dpi and 72 dpi JPEGs, is it possible?\n\nThanks!\n",
    "comments_url": "https://api.github.com/repos/lovell/sharp/issues/181/comments",
    "author": "Couto",
    "comments": [
      {
        "user": "lovell",
        "created_at": "2015-03-19T10:53:42Z",
        "body": "As far as I know, and if I understand your question correctly, the concept of DPI doesn't mean anything in the land of JPEG.\n\nYou should be able to achieve the equivalent of a 300DPI to 72DPI conversion by resizing to smaller dimensions, e.g. resize a source 1000x1000 pixel square image to a `1000 * 72 / 300` = 240x240 pixel image.\n"
      }
    ]
  },
  {
    "number": 119,
    "title": "Perf question",
    "created_at": "2014-11-18T08:18:50Z",
    "closed_at": "2014-12-02T11:28:26Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/lovell/sharp/issues/119",
    "body": "First of all, thank you for the great binding.  \nPlease help.  I'm not sure if I'm doing something wrong.  Libvip and sharp is great for processing one image at a time.  But when I have lots concurrent requests, it doesn't seem to perform on the same level as graphics magick.  \nHere's my sample code \n\n```\nvar util = require('util');\nvar fs = require('fs');\nvar Promise = require('es6-promise').Promise;\nvar _ = require('underscore');\nvar sharp = require('sharp');\n\nvar totalTime = 0;\nvar count = 100;\n\n// concurrency does not help\n//sharp.concurrency(32);\n\nvar originalImage = fs.readFile('./lib/test.jpg', function(err, data) {\n    var promises = [];\n    if(err) {\n        return console.log(' ERROR in reading file ' + err);\n    }\n    for(var i = 0; i < count; i++ ) {\n        promises[i] = sharpResize(data, _.random(400) + 1, _.random(400) + 1);\n    }\n\n    Promise.all(promises)\n    .then(function() {\n        console.log('  Final avg time is ' + totalTime / count);\n    }).catch(function(err) {\n        console.log('  Final ERROR ' + err);\n    });\n});\n\nfunction sharpResize(data, width, height) {\n    return new Promise(function (resolve, reject) {\n        var start = Date.now();\n        var counter = sharp.counters();\n        console.log('  counter stats ' + util.inspect(counter));\n        var stats = sharp.cache();\n        console.log('  cache stats ' + util.inspect(stats));\n\n        var pipeline = sharp(data)\n        .resize(width, height)\n        .embed()\n        .toBuffer(function sharpDone(err, buffer, info) {\n            var timeDelta = (Date.now() - start);\n            if (err) {\n                return reject('failed ' + err);\n            }\n            console.log(' success time ' + timeDelta.toFixed(0));\n            totalTime += timeDelta;\n            resolve(buffer);\n        });\n    });\n}\n```\n\nand this is my output\nsuccess time 143\n success time 147\n success time 147\n success time 168\n...\n...\nsuccess time 2926\nsuccess time 2930\nsuccess time 2943\nsuccess time 2949\n  Final avg time is 1542.15\n\nThe queue stacks up, and the number of working process doesn't really get past 4 (even if I increase the concurrency value).  (I'm on a 8 core Mac laptop).  \nSo, am I missing something?  \n\nThank you.  (btw.. I'm not sure if this is the place to ask question)\n",
    "comments_url": "https://api.github.com/repos/lovell/sharp/issues/119/comments",
    "author": "jsongHBO",
    "comments": [
      {
        "user": "lovell",
        "created_at": "2014-11-18T09:59:35Z",
        "body": "If you're only seeing 4 concurrent processes (`sharp.counters()` can confirm) then it sounds like libuv thinks you only have 4 CPUs. To force it to use 8 worker threads, try adding this as the first line of the script:\n\n```\nprocess.env.UV_THREADPOOL_SIZE=8;\n```\n\nThe value passed to `sharp.concurrency(...)` is used by libvips to spawn that many threads per resize operation. Large reductions will benefit from more threads, but go too high and you get too much thread-management overhead.\n\nI recommend a max value of the number of cores and you may find that no threading (a value of 1) is more performant - it depends on the situation.\n\nIf your input is a file on the filesystem, passing the filename as the input may be faster to take advantage of libvips (and OS) caching.\n"
      },
      {
        "user": "lovell",
        "created_at": "2014-12-02T11:28:26Z",
        "body": "Great, thanks for confirming.\n\nFor the future benefit of anyone else discovering this question:\n1. the value of `UV_THREADPOOL_SIZE` limits the maximum number of concurrent tasks, and\n2. the value passed to `sharp.concurrency` controls the number of threads working on each task.\n\nBoth values default to the number of CPU cores, which may or may not not provide the best performance for a given workload - YMMV.\n"
      }
    ]
  },
  {
    "number": 104,
    "title": "Is HTML5 Canvas DataURL format Supported?",
    "created_at": "2014-10-20T16:56:56Z",
    "closed_at": "2014-10-20T20:19:12Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/lovell/sharp/issues/104",
    "body": "Hi Guys,\n\nI am trying to find a solution where I convert an image upload on the front-end into a data string format, which is essentially a base64 style string, using HTML5 Canvas API.\n\nI then send  this string to the back-end. What I wanted to ask is if there is a way for me to use the 'sharp' library so that it can load and process this data string so I can perform some operations (mainly resize in to new images).\n\nIs this possible?\n",
    "comments_url": "https://api.github.com/repos/lovell/sharp/issues/104/comments",
    "author": "iq-dot",
    "comments": [
      {
        "user": "lovell",
        "created_at": "2014-10-20T18:06:52Z",
        "body": "The `toDataURL()` method of an HTML5 canvas returns base64-encoded PNG image data (you can request JPEG data by using `toDataURL('image/jpeg')`.\n\nAssuming `image` is a String containing base64-encoded data, either PNG or JPEG, then you should be able to use something like the following:\n\n`sharp(new Buffer(image, 'base64')).resize(width, height).toBuffer(function(err, data) { ... })`\n"
      },
      {
        "user": "iq-dot",
        "created_at": "2014-10-20T19:24:47Z",
        "body": "Ah fantastic, I currently do use JPEG data using 'image/jpeg'.\n\nOne last clarification, will the toBuffer give back the same format JPEG data in base64 so that I can send it back as is to the front-end for rendering?\n"
      },
      {
        "user": "lovell",
        "created_at": "2014-10-20T20:08:59Z",
        "body": "If you'd like the output image data to be a base64-encoded string you can use `data.toString('base64')`.\n\nIf you simply need the browser to display the output JPEG image then you can send the Buffer directly. Here's an example using Express:\n\n```\nroute.get(..., function(req, res) {\n  ...\n  sharp(...).resize(...).toBuffer(function(err, data) {\n    res.header('Content-Type', 'image/jpeg').send(data);\n  });\n});\n```\n"
      }
    ]
  }
]