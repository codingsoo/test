[
  {
    "number": 3666,
    "title": "Type Error with html 5 canvas ",
    "created_at": "2015-06-04T19:13:44Z",
    "closed_at": "2015-06-04T19:27:31Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/jashkenas/backbone/issues/3666",
    "body": "Hello, I get a type error with backbone 1.2 from the cdnjs when rendering a model from within a view...\n$(document).ready(function(){\nvar Box = Backbone.Model.extend({defaults: {x: 0,y: 0, w: 1,h: 1,}\n});\nvar BoxSet = Backbone.Collection.extend({model:Box });\nvar BoxView= Backbone.View.extend({\n    render : function() {var model=this.model, ctx=this.options.ctx;}\n});\nvar SetView= Backbone.View.extend({ \n    initialize: function() {this.collection.on(\"all\",this.render,this);},\n    render: function() {var canvas=this.$el.get(0) , ctx=canvas.getContext(\"2d\");}\n});  \nvar c=new BoxSet();\nc.add({x:10,y:10,w:100,h:100});  \nvar v=new SetView({el:$(\"canvas\"),collection :c});\nv.render();\n})\n",
    "comments_url": "https://api.github.com/repos/jashkenas/backbone/issues/3666/comments",
    "author": "billyholt",
    "comments": [
      {
        "user": "jridgewell",
        "created_at": "2015-06-04T19:27:31Z",
        "body": "We no longer attach `options` to the view. You're error is in your `#render` trying to access the `ctx` property.\n"
      }
    ]
  },
  {
    "number": 3608,
    "title": "modelId getter doesn't work with polymorphic Model getter",
    "created_at": "2015-05-15T14:38:03Z",
    "closed_at": "2015-05-15T14:43:43Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/jashkenas/backbone/issues/3608",
    "body": "I think i found a bug inside the 1.2.0 version. My Collection contains different Models, so i've used a getter to solve this.\n\n```\nnew Collection(\n   model: function(attrs){\n      if (attrs.foo) {\n          return new FooModel(attrs);\n      }\n      else {\n         return new BarModel(attrs);\n      }\n   }\n)\n```\n\nafter upgrading i had some trobles with my app because the collection couldnt find already exsiting models inside of it `collection.get(1) # => undefined`. So I've digged into the source and found this \"bug\".\n`this.model` isn't always a Model it can be function sometimes. \n\n```\n    modelId: function (attrs) {\n      return attrs[this.model.prototype.idAttribute || 'id'];\n    },\n```\n\nSo I think everybody who is using a function in `this.model` and has a custom idAttribute defined, backbone won't find already existing models.\n\n```\n  modelId: function (attrs, options) {\n    return this.model(attrs, options).id;\n  },\n```\n\nThis is the overridden function i'm using inside my collection now, and it works for me.\nSo maybe the `modelId` function needs something like this:\n\n```\n  if (_.isFunction(this.model)) { \n    return this.model(attrs, options).id;\n  } \n  else {\n    return attrs[this.model.prototype.idAttribute || 'id'];\n  }\n```\n",
    "comments_url": "https://api.github.com/repos/jashkenas/backbone/issues/3608/comments",
    "author": "antpaw",
    "comments": [
      {
        "user": "akre54",
        "created_at": "2015-05-15T14:43:36Z",
        "body": "If `this.model` is a plain function, its `prototype.idAttribute` will be undefined and that line will fall back to `'id'`, catching the common case. If your models have a more advanced idAttribute you have to override `modelId` too (though I wouldn't recommend creating a new model instance just to get its id property).\n"
      }
    ]
  },
  {
    "number": 3557,
    "title": "Router.execute doesn't return anything",
    "created_at": "2015-04-04T17:49:38Z",
    "closed_at": "2015-04-05T16:36:40Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/jashkenas/backbone/issues/3557",
    "body": "If the route callback returns false, a route event is not supposed to be fired. i.e.\n`if (router.execute(callback, args, name) !== false) {//trigger 'route' event...}`\n\nHowever, execute() doesn't actually return the callback functions return value:\n`if (callback) callback.apply(this, args);`\n\nShouldn't this be:\n`if (callback) return callback.apply(this, args);`\n\nIs this by design, or am I missing something?\n",
    "comments_url": "https://api.github.com/repos/jashkenas/backbone/issues/3557/comments",
    "author": "emersonyu",
    "comments": [
      {
        "user": "akre54",
        "created_at": "2015-04-05T16:36:40Z",
        "body": "Nope, this is in place so folks can override `execute` in their apps to act as a `beforeAction`-like method (see #3016). We don't want the route handler's return value to affect the transition. \n"
      }
    ]
  },
  {
    "number": 3230,
    "title": "events selector by name or complex id names",
    "created_at": "2014-07-21T10:36:07Z",
    "closed_at": "2014-07-21T10:41:47Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/jashkenas/backbone/issues/3230",
    "body": "I have an input with this complex name:\n\n``` html\n<input ... name=\"bic_voucher_entitybundle_company[name]\" id=\"bic_voucher_entitybundle_company[name]\" >\n```\n\nThe problem comes when I want to assign this name or id to an event:\n\n``` js\n        events: {\n            'click #bic_voucher_entitybundle_company[name]': 'limitLength',\n            'click [name=\"bic_voucher_entitybundle_company[name]\"]': 'limitLength',\n```\n\nBoth do not work.\n",
    "comments_url": "https://api.github.com/repos/jashkenas/backbone/issues/3230/comments",
    "author": "bichotll",
    "comments": [
      {
        "user": "braddunbar",
        "created_at": "2014-07-21T10:41:47Z",
        "body": "Hi @bichotll!  I believe you'll need to escape the inner brackets with slashes.\n\n``` js\nevents: {\n  'click #bic_voucher_entitybundle_company\\\\[name\\\\]': 'limitLength',\n  'click [name=\"bic_voucher_entitybundle_company\\\\[name\\\\]\"]': 'limitLength'\n}\n```\n"
      }
    ]
  },
  {
    "number": 3166,
    "title": "Backbone's View constructor is adding a call to this.delegateEvents in the min version and the dev version is not",
    "created_at": "2014-05-28T03:34:11Z",
    "closed_at": "2014-05-28T13:43:17Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/jashkenas/backbone/issues/3166",
    "body": "```\nvar View = Backbone.View = function(options) {\n        this.cid = _.uniqueId('view');\n        options || (options = {});\n        _.extend(this, _.pick(options, viewOptions));\n        this._ensureElement();\n        this.initialize.apply(this, arguments);\n};\n\nvar w = e.View = function (t) {\n        this.cid = i.uniqueId(\"view\");\n        t || (t = {});\n        i.extend(this, i.pick(t, E));\n        this._ensureElement();\n        this.initialize.apply(this, arguments);\n        this.delegateEvents()\n};\n```\n",
    "comments_url": "https://api.github.com/repos/jashkenas/backbone/issues/3166/comments",
    "author": "markwise",
    "comments": [
      {
        "user": "tgriesser",
        "created_at": "2014-05-28T03:45:41Z",
        "body": "Yes, this change was added in #3060 in master but is not yet on the current release (and therefore not in the minified version). Are there any  issues you see with this change in behavior?\n"
      },
      {
        "user": "markwise",
        "created_at": "2014-05-28T04:03:56Z",
        "body": "I recently inherited a codebase that is using views as abstract classes.\n\nFor example:\n\n``` js\nvar AbstractView = Backbone.View.extend({\n    initialize: function () {\n        _.extend(self.events || (self.events = {}), {\n            'click .element': 'handler'\n        }\n    }\n});\n\nvar MyView = AbstractView.extend({\n    initialize: function () {\n        AbstractView.prototype.initialize.apply(this);    \n    }\n});\n```\n\nThe AbstractView events get attached with the min version, but not the dev version.\n"
      },
      {
        "user": "akre54",
        "created_at": "2014-05-28T05:03:14Z",
        "body": "Better to set those in an `events` method on the AbstractView:\n\n``` js\nvar AbstractView = Backbone.View.extend({\n    events: function() {\n        return {\n            'click .element': 'handler'\n        };\n    }\n});\n\nvar MyView = AbstractView.extend({\n    events: function() {\n      return _.extend(AbstractView.prototype.events.call(this), {\n        ...\n      });\n    }\n});\n```\n\nLooks even nicer in CoffeeScript:\n\n``` coffeescript\nclass AbstractView extends Backbone.View\n  events: ->\n    'click .element': 'handler'\n\nclass MyView extends AbstractView\n  events: ->\n    _.extend super, \n      'click .otherelement': 'other handler'\n```\n"
      },
      {
        "user": "markwise",
        "created_at": "2014-05-28T15:43:41Z",
        "body": "I agree that the above solution is a better way to handle attaching events in an abstract view. However, I think you guys are missing the point here. The dev and min version should be the same and they are not. This begs the question of how many other things are different between the two. This is indeed a bug and can result in different behavior based on my example above despite the suggested work around.\n"
      },
      {
        "user": "braddunbar",
        "created_at": "2014-05-28T15:45:07Z",
        "body": "> The dev and min version should be the same and they are not.\n\nThe minified file is only updated for releases to keep commit noise to a minimum.\n"
      },
      {
        "user": "markwise",
        "created_at": "2014-05-28T16:10:37Z",
        "body": "Can I assume the dev version is correct and this.delegateEvents was removed from the  Backbone.View constructor?\n"
      },
      {
        "user": "braddunbar",
        "created_at": "2014-05-28T16:30:43Z",
        "body": "@markwise That's right.  `#delegateEvents` is already called in `#setElement` so we found it redundant to call it twice.  Sorry about the breakage.\n\nIf you need to call it anyway you can always add it in an override of the constructor while you migrate.\n"
      }
    ]
  },
  {
    "number": 3050,
    "title": "Control over PUT vs POST for models with supplied IDs",
    "created_at": "2014-03-07T14:51:55Z",
    "closed_at": "2014-03-07T15:37:51Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/jashkenas/backbone/issues/3050",
    "body": "``` javascript\n\nvar UserModel = Backbone.Model.extend({\n    idAttribute: \"username\",\n    urlRoot: \"/userapi\"\n});\n\nvar newUser = new UserModel();\nnewUser.set('username','v0idnull');\nnewUser.save();\n```\n\nI can not create a new user with this code.\n\nBackbone makes the assumption that whatever API you are calling, the unique identifier for resource you're manipulating is generated on creation. But this is not always the case. In this above example, the unique identifier is the username, and so the ID is provided.\n\nBut that code will always try to do a PUT request on /userapi/v0idnull and it will always fail with a 404.\n\nI think there are many different ways of solving this, from providing create() and update() methods on the model (that save() can use), to changing\n\n``` javascript\nmethod = this.isNew() ? 'create' : (options.patch ? 'patch' : 'update');\n```\n\nto exposing the method through the options hash of the save() method:\n\n``` javascript\nmethod = options.method ? options.method : (this.isNew() ? 'create' : (options.patch ? 'patch' : 'update');\n```\n\nWith a change like this, I can do one of two things:\n\nMy application is aware of when I'm creating a user and when I'm updating a user and call the appropriate method / set the appropriate option\n\nOR\n\nI call save normally which tries a PUT, gets a 404, and an error handler tries save again, forcing a POST.\n\nThoughts?\n",
    "comments_url": "https://api.github.com/repos/jashkenas/backbone/issues/3050/comments",
    "author": "alex-dow",
    "comments": [
      {
        "user": "jashkenas",
        "created_at": "2014-03-07T15:37:51Z",
        "body": "> But that code will always try to do a PUT request on /userapi/v0idnull\n\nThat's correct. PUT vs POST isn't about create vs update. If you know the URL where your resource should belong, it's as simple as PUT-ing a representation of it there.\n\nFeel free to override sync if you'd like to do something different.\n"
      },
      {
        "user": "magalhas",
        "created_at": "2014-03-07T15:57:12Z",
        "body": "Or just override the isNew method if needed.\n"
      }
    ]
  },
  {
    "number": 3033,
    "title": "Accessing view options during `el` construction",
    "created_at": "2014-03-03T14:07:02Z",
    "closed_at": "2014-03-03T14:25:42Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/jashkenas/backbone/issues/3033",
    "body": "Hi,\n\n`View#options` has been removed since Backbone 1.1.0, and the usual recommandation is to set it ourselves if we need to inside the initialize constructor. That's what we're doing currently.\n\nHowever, we have a few views with this kind of pattern :\n\n``` js\nPopupView.extend( {\n\n    el : function ( ) {\n        return Templates.get( 'popups/upload/settings', {\n            filename : this.options.filename\n        } );\n    }\n\n} );\n```\n\nAs you can see, the root element constructor is currently requiring the options to be functional. Since the initialize constructor is only called after creating the node, it fails.\n\nFor what it worth, this error can be somewhat fixed by overloading the entire `View` constructor :\n\n``` js\nvar View = ( function ( ) {\n\n    var View = function ( options ) {\n        this.options = options;\n        Backbone.View.apply( this, arguments );\n    };\n\n    var F = function ( ) { };\n    F.prototype = Backbone.View.prototype;\n    View.prototype = new F( );\n\n    return View;\n\n} ( ) );\n```\n\nBut I think we agree to say that it's not the best code snippet ever :)\n\nWhat do you think of this issue ? Should it be solved ?\n",
    "comments_url": "https://api.github.com/repos/jashkenas/backbone/issues/3033/comments",
    "author": "arcanis",
    "comments": [
      {
        "user": "wyuenho",
        "created_at": "2014-03-03T14:13:30Z",
        "body": "Can you do this?\n\n``` javascript\nvar MyView = Backbone.View.extend({\n  initialize: function(options) {\n    this.setElement(Templates.get('popups/upload/settings', {\n      filename: options.filename\n    }));\n  }\n});\n```\n"
      },
      {
        "user": "cobbweb",
        "created_at": "2014-03-04T01:18:01Z",
        "body": "If it makes it any easier for you @arcanis you can override the constructor like this:\n\n``` js\nvar MyView = Backbone.View.extend({\n  constructor: function() {\n    console.log('test');  \n    Backbone.View.prototype.constructor.apply(this, arguments);\n  }\n});\n```\n"
      },
      {
        "user": "mllocs",
        "created_at": "2014-03-21T10:37:11Z",
        "body": "I'm having the same issue defining `className`, `attributes`, `id` or `tagName` as a function. It's specially handy to use the passed `options` to customise the class or attributes of the element. The workaround is to set the classes or attributes in the `onRender` method... :disappointed: \n"
      },
      {
        "user": "wyuenho",
        "created_at": "2014-03-21T11:08:16Z",
        "body": "@mllocs You can still pass the functions as options to the constructor.\n\n``` javascript\nnew View({id: function () { return 'foo'; }});\n```\n"
      },
      {
        "user": "mllocs",
        "created_at": "2014-03-21T11:17:32Z",
        "body": "I meant using the passed `options` in those functions. After the 1.1.0 update you no longer have `options` automatically attached to the context before calling those methods. \n"
      },
      {
        "user": "wyuenho",
        "created_at": "2014-03-21T11:21:57Z",
        "body": "Save `options` in your overridden initialize method or the constructor.\n"
      },
      {
        "user": "mllocs",
        "created_at": "2014-03-21T11:32:48Z",
        "body": "Initialize is called afterwards...\n\n``` javascript\n  var View = Backbone.View = function(options) {\n    this.cid = _.uniqueId('view');\n    options || (options = {});\n    _.extend(this, _.pick(options, viewOptions));\n    this._ensureElement(); // here we resolve className, id, attributes and tagName\n    this.initialize.apply(this, arguments);  // initialize... \n    this.delegateEvents();\n  };\n```\n\nand overriding the constructor looks too much for what I need to accomplish... \n"
      },
      {
        "user": "braddunbar",
        "created_at": "2014-03-21T11:36:15Z",
        "body": "Nah, overriding the constructor is a good plan.  It's pretty common and should be moreso.  :+1:\n"
      },
      {
        "user": "mllocs",
        "created_at": "2014-03-21T13:02:53Z",
        "body": "Overriding the constructor in every view declaration seems too much boilerplate to me... there was any reason to remove `options` from the context or to not pass it to the `ensureElement` methods? I would like to understand this change... for me this was a pretty common pattern:\n\n``` javascript\nvar MyView = Backbone.View.extend({\n  attributes: function() {\n    return {'tabindex': this.options.tabindex};\n  }\n});\n```\n\nany 'bad practice' in this pattern?\n"
      },
      {
        "user": "arcanis",
        "created_at": "2014-03-21T13:14:32Z",
        "body": "For my use case, every view in my application comes from a Backbone indirection. Something like this :\n\n``` js\nvar View = Backbone.View.extend( {\n    constructor : function ( options ) {\n        this.options = options;\n        Backbone.View.apply( this, arguments );\n    }\n} );\n\nvar UserView = View.extend( {\n} );\n\nvar CommentView = View.extend( {\n} );\n\n...\n```\n"
      },
      {
        "user": "braddunbar",
        "created_at": "2014-03-21T13:49:12Z",
        "body": "@mllocs Yes, I would say accessing `this.options.foo` is an anti-pattern.  Instead, use `options` as a vehicle and attach properties directly as follows.\n\n``` js\nvar MyView = Backbone.View.extend({\n  constructor: function(options) {\n    _.extend(this, _.pick(options, 'tabindex', 'foo', 'bar', 'baz'));\n    Backbone.View.apply(this, arguments);\n  }\n  attributes: function() {\n    return {'tabindex': this.tabindex};\n  }\n});\n```\n\nThere's a great deal more detail in #2458 if you're interested.\n"
      }
    ]
  },
  {
    "number": 2809,
    "title": "collection's 'create' method seems to need 'index' option.",
    "created_at": "2013-10-15T05:16:22Z",
    "closed_at": "2013-10-15T11:53:03Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/jashkenas/backbone/issues/2809",
    "body": "While collection's 'add' method supports 'index' option,\nbut 'create' method doesn't seem to support it. \nIs there any way to set the index position when creating a model in collection?\nIf no, it seems to need 'index' option.\n",
    "comments_url": "https://api.github.com/repos/jashkenas/backbone/issues/2809/comments",
    "author": "oigil",
    "comments": [
      {
        "user": "akre54",
        "created_at": "2013-10-15T05:42:40Z",
        "body": "There's no `index` option, but there's an `at` option which you can pass in through options (`Collection#create` uses `add` under the hood.) Give it a try.\n"
      }
    ]
  },
  {
    "number": 2754,
    "title": "collection.on(\"myevent\") original model?",
    "created_at": "2013-09-10T15:21:14Z",
    "closed_at": "2013-09-10T15:42:30Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/jashkenas/backbone/issues/2754",
    "body": "Hi guys,\n\nIs there any way I can get the original model who trigger an event inside a collection without having to passing it ?\n\n``` javascript\nvar collection = new Backbone.Collection();\nvar myModel = new Backbone.Model({});\ncollection.add(myModel);\nmyModel.trigger(\"foo\", 42);\n// ...\ncollection.on(\"foo\", function (number) {\n  // how can I get the original model object here?\n});\n```\n\nThis is a limitation I experiment on different projects, Is there an existing way to get that model without having to pass it at the trigger time?\n\nThe workaround of this I found is quite boring:\nsomething like:\n\n``` javascript\nfunction bindModel (model) {\n  model.on(\"foo\", function (number) {\n    // model in the scope\n  });\n}\nfunction unbindModel (model) {} // erf need to keep somewhere the original reference of the bound function...\ncollection.each(bindModel);\ncollection.on(\"add\", bindModel);\ncollection.on(\"remove\", unbindModel);\n```\n",
    "comments_url": "https://api.github.com/repos/jashkenas/backbone/issues/2754/comments",
    "author": "gre",
    "comments": [
      {
        "user": "caseywebdev",
        "created_at": "2013-09-10T15:32:05Z",
        "body": "What's the problem with simply passing the model as the first arg? It's the convention Backbone uses everywhere in core.\n\n``` js\ncollection.add(model).on('foo', function (model, n) { ... });\nmodel.trigger('foo', model, 42);\n```\n"
      }
    ]
  },
  {
    "number": 2739,
    "title": "Problem with parse and create",
    "created_at": "2013-08-30T06:24:22Z",
    "closed_at": "2013-09-11T17:16:08Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/jashkenas/backbone/issues/2739",
    "body": "I want to add a model to a collection and immediately trigger the 'add' event so that a view is instantly rendered.\n\nHowever, I also want it to be persisted and saved as well.\n\nI do not want to wait for save to return before add is triggered.\n\nAll of this should be fine, except that I have data in the model that needs to be created on parse.  An example is a url to a map whose value is dependent on the client's browser type.\n\nIf I call `collection.create(model)`, the model will be added to the collection, parsed, then saved.\n\nThe problem is that I want that parsing to be done, but I don't want that parsed data to be saved to the server.\n\nI can fix this by doing `collection.create(model, {wait: true})`, but then there is a delay from when the model is created until the view is rendered.\n\nAny ideas on this?  Essentially I want the data created in `parse` in the model to never be persisted to the server, just accessed locally.\n",
    "comments_url": "https://api.github.com/repos/jashkenas/backbone/issues/2739/comments",
    "author": "ghost",
    "comments": [
      {
        "user": "j03w",
        "created_at": "2013-08-30T11:38:24Z",
        "body": "How about override `model.toJSON()`?\n"
      },
      {
        "user": "tgriesser",
        "created_at": "2013-08-30T13:38:26Z",
        "body": "@blairvanderhoof - might be easier if you just saved & added...\n\n``` js\nvar model = new collection.model(data)\nmodel.save(data);\ncollection.add(model.parse());\n```\n\nor if you just set the attributes you don't want saved as properties on the model rather than in the model's attributes hash.\n"
      },
      {
        "user": "jashkenas",
        "created_at": "2013-09-11T17:16:08Z",
        "body": "That works. It's also a not-very-great way to create a client-side-only view onto your data. Simply having a method on the model that generates the URL for you is _way_ nicer than having to keep data in sync.\n\n```\nmodel.urlForBrowser()\n```\n"
      }
    ]
  },
  {
    "number": 2722,
    "title": "couldn't pass string as an argument to Backbone View",
    "created_at": "2013-08-14T13:47:09Z",
    "closed_at": "2013-08-14T13:52:26Z",
    "labels": [
      "wontfix",
      "question"
    ],
    "url": "https://github.com/jashkenas/backbone/issues/2722",
    "body": "e.g. new MyView(\"Hello\");\nTypeError: invalid 'in' operand n\nBackbone version: 1.0.0\n\nThrows the above javascript error from Underscore.js, on passing string as an argument to backbone view. Accepts only object. Worked for Version 0.9.2, but not 1.0.0.\n",
    "comments_url": "https://api.github.com/repos/jashkenas/backbone/issues/2722/comments",
    "author": "shanvel26",
    "comments": [
      {
        "user": "braddunbar",
        "created_at": "2013-08-14T13:52:26Z",
        "body": "Hi @shanvel26!  That's correct, `Backbone.View` accepts an object as an argument.  The fact that it previously allowed a string is just coincidence.  I'd recommend using `new View({key: 'value'})` instead.\n"
      }
    ]
  },
  {
    "number": 2653,
    "title": "Backbone.history.start does not find route ",
    "created_at": "2013-07-03T21:48:15Z",
    "closed_at": "2013-07-04T12:15:50Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/jashkenas/backbone/issues/2653",
    "body": "Suppose I have a web page called `test.html` and I want my `Backbone.Router` to be capable of handling routes like `test.html?new` and also `new`. I've written sth like:\n\n```\nroutes: {\n  'new': function(){alert('new');},\n  'test.html?new': function(){alert('test.html?new');}\n}\n```\n\nBut if I visit `test.html?new` nothing happens. In particular \n\n```\nconsole.log(Backbone.history.start({pushState:true})); // returns false\n```\n\nHowever both:\n\n```\nBackbone.history.navigate('test.html?new', {trigger:true})\nBackbone.history.navigate('new', {trigger:true})\n```\n\ntriggers the route.\n",
    "comments_url": "https://api.github.com/repos/jashkenas/backbone/issues/2653/comments",
    "author": "neojski",
    "comments": [
      {
        "user": "braddunbar",
        "created_at": "2013-07-04T12:15:50Z",
        "body": "Hi @neojski!  Backbone routers ignore the query string entirely in favor of using the path name (`/test.html/new`, or similar).  Check out #891 if you want all the gory details.  :)\n"
      }
    ]
  },
  {
    "number": 2580,
    "title": "Options no longer accessible in Views",
    "created_at": "2013-05-31T14:50:09Z",
    "closed_at": "2013-05-31T14:54:07Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/jashkenas/backbone/issues/2580",
    "body": "I recently upgraded from 0.9.9 to 1.0. \n\nIt seems that in version 1.0, the options object on a view is no longer existing.\n\nAny code within a view that tries to access this.options.property always fails and this.options is always undefined.\n\nI am using Underscore 1.4.3 and also tried 1.4.4 with no difference. Rolling back to Backbone 0.9.9 makes everything work again.\n",
    "comments_url": "https://api.github.com/repos/jashkenas/backbone/issues/2580/comments",
    "author": "tysonnero",
    "comments": [
      {
        "user": "tysonnero",
        "created_at": "2013-05-31T14:53:14Z",
        "body": "Note: I am experiencing this issue when using the version from this Github repo.\n\nIf I use the version from backbonejs.org, it works.\n"
      },
      {
        "user": "tgriesser",
        "created_at": "2013-05-31T14:54:07Z",
        "body": "@tysonnero yep, it looks like you upgraded to the edge version, not the 1.0.0 release, see #2458 for a bit more info.\n"
      }
    ]
  },
  {
    "number": 2532,
    "title": "Router: Query Parameters are being ignored when using pushState but not when using hashChange.",
    "created_at": "2013-05-14T14:06:06Z",
    "closed_at": "2013-05-14T14:15:19Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/jashkenas/backbone/issues/2532",
    "body": "Since Backbone 1.0.0 the router ignores all the query parameters sent as ?something=something when using the pushState mode, but when using the hashChange mode (on pushState incompatible browsers, such as IE 9) the query strings are not ignored and when they are sent, they won't match any route.\n\neg.\nroute: 'books/backbone'\n\nurl: '#books/backbone?utm_source=twitter'\n\nThe url does not match the route because it has query strings in it.\n",
    "comments_url": "https://api.github.com/repos/jashkenas/backbone/issues/2532/comments",
    "author": "juuliaans",
    "comments": [
      {
        "user": "braddunbar",
        "created_at": "2013-05-14T14:15:19Z",
        "body": "Hi @juliansantaana!  Query parameters are in fact ignored, but the url `#books/backbone?utm_source=twitter` does not contain any, only a hash fragment that looks like it.  If you use this url instead `?utm_source=twitter#books/backbone` I think you'll have better results.  Hope that helps.  :)\n"
      },
      {
        "user": "juuliaans",
        "created_at": "2013-05-14T14:18:42Z",
        "body": "@braddunbar \nOh, i get what you mean.\nIs there any way of using query parameters with backbone? Is there any particular reason they are being ignored?\n"
      },
      {
        "user": "braddunbar",
        "created_at": "2013-05-14T14:20:13Z",
        "body": "There are quite a few reasons, most of which are outlined in #891.  That thread also includes solutions using the fragment instead.\n"
      },
      {
        "user": "juuliaans",
        "created_at": "2013-05-14T15:56:18Z",
        "body": "@braddunbar \nThanks, that helped a lot. I ended up using the parameters that i was sending as query string as pretty urls. I have a question regarding this, do you know any way of \"creating\" or linking to URL that has parameters in that way, the thing is i need to change my URL on the fly depending on a date range selected, so for example the url is /something/date=20110205 and when a calendar is changed i need to change my url with router.navigate(), is there any way to replace that date= parameter that's built in with backbone?\n"
      },
      {
        "user": "braddunbar",
        "created_at": "2013-05-15T20:08:31Z",
        "body": "@juliansantaana Nothing in particular.  I generally just generate the url over again based on the UI parameters.\n"
      }
    ]
  },
  {
    "number": 2510,
    "title": "Model.save() with options and no key/val",
    "created_at": "2013-05-01T19:49:21Z",
    "closed_at": "2013-05-01T20:03:14Z",
    "labels": [
      "invalid",
      "question"
    ],
    "url": "https://github.com/jashkenas/backbone/issues/2510",
    "body": "Using backbone 1.0.0.\n\nI have not been able to figure out how to call Model.save and pass options (success, error) and have it skip the key/val logic.\n\nWhat I've done for now is override Model.save changing the following line (50) in from:\n      if (key == null || typeof key === 'object') {\nTo:\n      if (key === null || typeof key === 'object') {\n\nThis allows me to call save as Model.save(undefined, undefined, {succes: mySuccess, error: myError}); and not have the options wiped out in the parameter logic of save.\n\nMaybe there is another way around this but I was unable to find it.\n",
    "comments_url": "https://api.github.com/repos/jashkenas/backbone/issues/2510/comments",
    "author": "cfator",
    "comments": [
      {
        "user": "tgriesser",
        "created_at": "2013-05-01T19:56:39Z",
        "body": "@cfator is there a reason you're saving as `Model.save(undefined, undefined, opts)` rather than `Model.save(undefined, opts)`? The latter should work just fine.\n"
      },
      {
        "user": "braddunbar",
        "created_at": "2013-05-01T19:57:57Z",
        "body": "Or `model.save(null, {...})`, which is a bit shorter.  :)\n"
      }
    ]
  },
  {
    "number": 2474,
    "title": "Pass all $.ajax options for fetch, save, and destroy",
    "created_at": "2013-04-11T19:24:28Z",
    "closed_at": "2013-04-11T19:26:41Z",
    "labels": [
      "invalid",
      "question"
    ],
    "url": "https://github.com/jashkenas/backbone/issues/2474",
    "body": "It seems like success and error callbacks are the only options passed to $.ajax. What is the benefit of this? I'm finding it very hard to add a custom header to a single API call because the only thing that has worked so far is $.ajaxSetup, but then the custom header is added to every subsequent API call. Is there an easier way to add a custom header for a single ajax call?\n",
    "comments_url": "https://api.github.com/repos/jashkenas/backbone/issues/2474/comments",
    "author": "briansorahan",
    "comments": [
      {
        "user": "braddunbar",
        "created_at": "2013-04-11T19:26:41Z",
        "body": "Hi @briansorahan!  Actually, all options passed to `fetch`/`save`/`destroy` are already passed through to `$.ajax`.  Enjoy!\n\n``` js\nmodel.fetch({complete: function(){ ... }});\n```\n"
      }
    ]
  },
  {
    "number": 2349,
    "title": "delegating events on inherited views",
    "created_at": "2013-03-08T14:40:31Z",
    "closed_at": "2013-03-08T14:56:55Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/jashkenas/backbone/issues/2349",
    "body": "I have a BaseView which defines some events delegation specifying an events hash.\n\nThen I have a CustomView (extending BaseView) that also defines their own events, by also specifying an event hash.\n\nIf I'm not wrong, BaseView's event hash is overwritten, so theirs events are not processed by delegateEvent.\n\nThe documentation says to use an events function instead of a hash to handle this case.\n\nI solved it with something like this:\n\non the parent's render method I mix the parent's events with those from the child\n\n``` javascript\n    this.delegateEvents(_.merge(this.events, {\n      'show .accordion': 'collapsePanelGroup',\n      'hide .accordion': 'collapsePanelGroup'\n    }));\n```\n\nI guess this could be a pretty common scenario, so I was wondering if it's worth the effort to add something like this to delegateEvents:\n\n``` javascript\ndelegateEvents: function(events, preserve) {\n```\n\nPassing a preserve = true, would just add this.events to events and then process, or maybe define some addEvent method\n\nWhat would be the most appropriate to hadle this scenario?\n",
    "comments_url": "https://api.github.com/repos/jashkenas/backbone/issues/2349/comments",
    "author": "opensas",
    "comments": [
      {
        "user": "dgbeck",
        "created_at": "2013-03-08T14:44:25Z",
        "body": "In the CustomView class definition, you can do:\n\n``` javascript\nevents : { return _.extend( {}, BaseView.prototype.events, {\n   'show .accordion': 'collapsePanelGroup',\n   'hide .accordion': 'collapsePanelGroup'\n} ); },\n```\n\nNot super pretty, but gets the job done!\n"
      },
      {
        "user": "braddunbar",
        "created_at": "2013-03-08T14:56:55Z",
        "body": "Hi @opensas!  I often use the approach @dgbeck suggests as well.  By using a function for `events`, you can choose to extend the parent view or not.\n\n``` js\nvar Parent = Backbone.View.extend({\n  events: function() {\n    return {...};\n  }\n});\n\nvar Child = Parent.extend({\n  events: function() {\n    return _.extend(Parent.prototype.events.call(this), {\n      ...\n    });\n  }\n});\n```\n\nIf you dig through the issues you'll find a good deal of discussion on this topic and probably some good tips.\n"
      }
    ]
  },
  {
    "number": 2229,
    "title": "sync event firing",
    "created_at": "2013-01-31T21:33:18Z",
    "closed_at": "2013-02-01T17:14:27Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/jashkenas/backbone/issues/2229",
    "body": "I want an event like 'sync' to be triggered before the success function so that I can bind the event in the success function without it being executed right away\n",
    "comments_url": "https://api.github.com/repos/jashkenas/backbone/issues/2229/comments",
    "author": "jkbailey",
    "comments": [
      {
        "user": "jkbailey",
        "created_at": "2013-01-31T21:39:07Z",
        "body": "maybe something like a 'response' event\n\n``` javascript\n...\n    var success = options.success;\n    options.success = function(resp) {\n++      model.trigger('response', model, resp, options);\n      if (success) success(model, resp, options);\n      model.trigger('sync', model, resp, options);\n    };\n...\n```\n"
      },
      {
        "user": "tgriesser",
        "created_at": "2013-01-31T21:52:23Z",
        "body": "Would the `request` event work? This is called by `Backbone.sync` before every request regardless of success/error.\n\n> \"request\" (model, xhr, options) \u2014 when a model (or collection) has started a request to the server.\n\nOtherwise, you could just trigger an event in your success handler:\n\n``` js\nmodel.fetch({\n  success: function (model, resp, options) {\n    model.trigger('response', model, resp, options);\n    //... rest of your success handler here\n  }\n});\n```\n"
      },
      {
        "user": "jkbailey",
        "created_at": "2013-01-31T22:13:06Z",
        "body": "Well, the request event won't work because i don't it to trigger if there is an error.\n\nHere is my dilemma, I have a collection of messages. I initially fetch the messages and in the success of that fetch I create a new view to display those messages. On the init of that view I want to attach a trigger so that whenever a new messages is added to the collection and successfully saved to the DB it updates my list of messages. So I could use the add event, but that is triggered before the data is saved to the DB. That is why I chose to use the 'sync' event, but then realized that right after the view is initialized (from the success function of fetch) the sync event is firing. Does that make sense?\n"
      },
      {
        "user": "tgriesser",
        "created_at": "2013-01-31T22:27:08Z",
        "body": "It sounds like what you probably want to do is add `wait:true` in the options when you're creating the new model, so the add event isn't fired until it syncs with the database.\n\n> Pass {wait: true} if you'd like to wait for the server before adding the new model to the collection.\n"
      },
      {
        "user": "jkbailey",
        "created_at": "2013-01-31T22:42:04Z",
        "body": "from my experience the `add` event doesn't fire a database sync, does it?\n"
      },
      {
        "user": "tgriesser",
        "created_at": "2013-01-31T23:13:54Z",
        "body": "The `create` method on the collection does an `add` and `save` at the same time, I assumed that's what you'd be using, then you would just listen on add rather than `sync`.\n"
      },
      {
        "user": "jkbailey",
        "created_at": "2013-02-01T17:11:27Z",
        "body": "I had this in the init of my collection...\n\n```\n        t.on('add',function(msg,opt) {\n\n            msg.save(msg.attributes,{\n                success: function(m,r,x) {\n                    m.trigger('response', m, r, x);\n                    console.log('message sent successfully');\n                },error: function() {\n                    console.log('error saving message');\n                }\n            });\n\n        });\n```\n"
      }
    ]
  },
  {
    "number": 2225,
    "title": "'Fetch' can't be bound to a 'change' event",
    "created_at": "2013-01-31T10:38:01Z",
    "closed_at": "2013-01-31T13:19:27Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/jashkenas/backbone/issues/2225",
    "body": "Hi,\n\nI have a collection that listens to changes in a model to then update itself, like this:\n\n```\nthis.listenTo(this.user, \"change:addresses\", this.fetch);\n```\n\nAnd it was getting back the user's own data, instead of the expected. After some probing I figured that `change` events pass `(model, value, options)` to the callbacks, which in this case meant `sync` was eventually getting the user model as it's `option` param.\n\nThe user model has its own url, and 8478567 means it is then overriding the collection's url for the request.\n\nI understand this is an edge case, and can be easily circumvented by using `function(){ this.fetch(); }` instead, but maybe it deserves some looking into. Specially since I believe this also means `fetch` can't be bound to any event.\n\nRight now I can't think of a good way to solve it that won't break 8478567, though. Maybe needing to explicitly state you want to override the request settings in `sync`?\n",
    "comments_url": "https://api.github.com/repos/jashkenas/backbone/issues/2225/comments",
    "author": "Dhekke",
    "comments": [
      {
        "user": "braddunbar",
        "created_at": "2013-01-31T13:19:26Z",
        "body": "Mornin' @Dhekke!  Thanks for pointing this out.  I don't think there's any action Backbone should take here though.  You'll have to deal with function arguments in any case and the extra wrapper function is a pretty standard pattern.  I often create a separate handler, which I think is cleaner sometimes, but it's really just adding a bit of indirection.\n\n``` js\ninitialize: function() {\n  this.listenTo(this.user, 'change:addresses', this.changed);\n},\nchanged: function() {\n  this.fetch();\n}\n```\n"
      }
    ]
  },
  {
    "number": 2160,
    "title": "Weird behavior when model.save if option.validate is not set",
    "created_at": "2013-01-18T19:45:06Z",
    "closed_at": "2013-01-18T20:34:59Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/jashkenas/backbone/issues/2160",
    "body": "When validate is not set when calling model.save, it will call 'model.set' in 'model.save' with option passed in, so no validation. Later, option will be extended with {validate : true}, which makes 'model.save' fail. However, since the 'model.set' is done, the data presented wrongly in the view.\n\nI think the behaviors should be consistent, maybe. If no validate: true in option, it doesn't extend the option and check when save.\n",
    "comments_url": "https://api.github.com/repos/jashkenas/backbone/issues/2160/comments",
    "author": "LLLLKKKK",
    "comments": [
      {
        "user": "tgriesser",
        "created_at": "2013-01-18T20:22:46Z",
        "body": "@LLLLKKKK - I believe the best way to go about this would be to pass `wait:true` into the `model.save` so that the `set` call isn't applied until the model is both validated and a success is returned by the server. The other option, if you don't want to wait on the server call, would be to get a copy of the attributes, and if the `model.save` returns false, reset the model to those attributes.\n\n``` js\nvar currentAttr = _.clone(model.attributes);\nif (!model.save(attr)) {\n  model.clear({silent:true}).set(currentAttr);\n}\n```\n"
      }
    ]
  },
  {
    "number": 2078,
    "title": "Collection fetch does not render on \"add\" event",
    "created_at": "2013-01-06T14:43:46Z",
    "closed_at": "2013-01-12T18:24:12Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/jashkenas/backbone/issues/2078",
    "body": "I've set up this AppView that triggers the overall Backbone's application!\nI want to fetch my collection and dynamically add items when the \"add\" event is thrown!\n\n```\nvar AppView = Backbone.View.extend({\n    el: $('#pics'),\n\n    initialize: function () {\n\n        // Fetch contents\n        this.collection = new PLibrary;\n        this.collection.on(\"add\", this.renderMessage, this);\n\n        $.ajaxSetup({async: false});\n        this.collection.fetch({update: true});  // fires an \"add\" event for every new model\n        $.ajaxSetup({async: true});\n\n        _.bindAll(this, 'render');\n    },\n\n    renderMessage: function(p){\n        var mV = new PRow({model: p});\n        this.$el.append(mV.render().el);\n    }\n\n});\n```\n\nThe code above sends the Ajax request to the server, but nothing gets displayed.\nInstead... If I make use of render() like this... the application works.\n\n```\nvar AppView = Backbone.View.extend({\n    el: $('#pics'),\n\n    initialize: function () {\n\n        // Fetch contents\n        this.collection = new PLibrary;\n        this.collection.on(\"add\", this.renderMessage, this);\n\n        $.ajaxSetup({async: false});\n        this.collection.fetch();\n        $.ajaxSetup({async: true});\n\n        _.bindAll(this, 'render');\n        this.render();\n    },\n\n    renderMessage: function(p){\n        var mV = new PRow({model: p});\n        this.$el.append(mV.render().el);\n    },\n\n    render: function() {\n        var self = this;\n        _.each(this.collection.models, function (item) {\n            self.renderMessage(item);\n        }, this);\n    }\n\n});\n```\n\nIt seems that the \"add\" event doesn't get thrown!\nHelp me please\n",
    "comments_url": "https://api.github.com/repos/jashkenas/backbone/issues/2078/comments",
    "author": "omsoft",
    "comments": [
      {
        "user": "yuku",
        "created_at": "2013-01-06T16:14:17Z",
        "body": "`Collection#fetch` uses `Collection#reset` internally by default and it triggers `\"reset\"` event on the collection instance but doesn't tigger `\"add\"` event.\nIf `{update: true}` is given to `Collection#fetch` then `Collection#update` is executed and it may trigger `\"add\"`, `\"remove\"` and `\"change\"` events.\nSo, there are two solutions.\n1. Set `render` as callback of collection's `\"reset\"` event\n2. Give `{update: true}` to `Collection#fetch`\n\nI like 1. Because it is easy to implement and `update` is a little heavier than `reset`.\n"
      },
      {
        "user": "omsoft",
        "created_at": "2013-01-06T17:14:04Z",
        "body": "If you take a closer look at my first code snippet, you'll see the call fetch({update: true}).\nMy question is, infact, why it doesn't work?\n"
      },
      {
        "user": "yuku",
        "created_at": "2013-01-06T18:50:54Z",
        "body": "Oh, excuse me. The first code looks correct. ummm\nCould you show me the console string of following code?\n\n``` javascript\nconsole.log(Backbone.VERSION);\nvar collection = new PLibrary();\ncollection.on('all', function () { console.log(arguments); }); \ncollection.fetch({update: true, async: false});\ncollection.fetch();\n```\n\nExpect:\n\n```\n0.9.9\n['add', ModelObject, CollectionObject, OptionObject]\n['add', ModelObject, CollectionObject, OptionObject]\n...\n['reset', CollectionObject, OptionObject]\n```\n\n`Model#update`was added at 0.9.9.\n"
      }
    ]
  },
  {
    "number": 2070,
    "title": "When upgrade to 0.99, the console report an error: \"_.pick is not a function\"  ",
    "created_at": "2013-01-04T16:18:36Z",
    "closed_at": "2013-01-04T18:00:36Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/jashkenas/backbone/issues/2070",
    "body": "Hello.\nWhen upgrade to 0.99, the console report an error: \"_.pick is not a function\"  . Why?\nPrevious version: 0.9.1\n\nRegards\n",
    "comments_url": "https://api.github.com/repos/jashkenas/backbone/issues/2070/comments",
    "author": "vicenrele",
    "comments": [
      {
        "user": "braddunbar",
        "created_at": "2013-01-04T16:21:14Z",
        "body": "Hi @vicenrele!  Have you updated your copy of underscore as well?  Backbone 0.9.9 requires underscore 1.4.3 or higher.\n"
      }
    ]
  },
  {
    "number": 1935,
    "title": "listenTo on jQuery objects?",
    "created_at": "2012-12-14T14:48:35Z",
    "closed_at": "2012-12-14T15:17:59Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/jashkenas/backbone/issues/1935",
    "body": "I just started doing my upgrade for event listening, listenTo is a great addition to Backbone! \n\nI had a question about usage though. I listen for click events on DOM objects in some cases and attempted to translate the listeners from:\n\n$('#div').on(event, callback) \n\nto \n\nview.listenTo($('#div'), event, callback)\n\nand it doesn't seem to work.\n\nUsing jQuery 1.8.3, I'm getting the following error:\n\n``` javascript\n((jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply is not a function\n    at dispatch(Object) (/iBEnergyCore/js/libs/jquery/jquery-1.8.3.js:3058)\n    at eventHandle(MouseEvent) (/iBEnergyCore/js/libs/jquery/jquery-1.8.3.js:2676)\n```\n\nIf the listenTo function will not work with jQuery objects that's fine. Just wasn't sure if I uncovered a bug.\n\nThanks again for the update!!\n\n-Tim\n",
    "comments_url": "https://api.github.com/repos/jashkenas/backbone/issues/1935/comments",
    "author": "tsneed290",
    "comments": [
      {
        "user": "tgriesser",
        "created_at": "2012-12-14T15:06:15Z",
        "body": "Sorry, listenTo only applies to objects that have the Backbone.Events mixed in, so it would work on a `Backbone.View`, `Backbone.Collection`, or `Backbone.Model`, but not on a jQuery object.\n"
      },
      {
        "user": "jashkenas",
        "created_at": "2012-12-14T15:17:58Z",
        "body": "Right -- Backbone.Events methods work with Backbone.Events -- not DOM events. You've got jQuery for that.\n"
      },
      {
        "user": "davidfou",
        "created_at": "2013-12-30T15:10:34Z",
        "body": "Hi,\n\nI'm using Backbone before the magic `listenTo` method. Right now I'm migrating from my custom `bindTo` library to `Backbone.Events`. Using `listenTo` on a jQuery element would be perfect to prevent memory leak. Any workaround to do that ?\n\nBest,\nDavid\n"
      },
      {
        "user": "akre54",
        "created_at": "2014-01-02T17:40:06Z",
        "body": "Hey @dfournier, try using namespaces for this (which `View#delegate` and `View#undelegate` use under the hood.) Removing all jQuery events bound by your View is as easy as calling `this.$el.off('.delegateEvents' + this.cid)` from within your view instance for example. (You can use any custom namespace you want for your events too)\n"
      }
    ]
  },
  {
    "number": 1883,
    "title": "Problem with IE8 and sorted models in collection detected in Version 0.9.2",
    "created_at": "2012-12-09T12:43:03Z",
    "closed_at": "2012-12-09T17:04:59Z",
    "labels": [
      "invalid",
      "question"
    ],
    "url": "https://github.com/jashkenas/backbone/issues/1883",
    "body": "IE8 displays: error on page\n\nNumber expected\nbackbone.js  Line: 724 (it's the \"sort\" function)\nCode: 0   Char: 9\nif I use a sorted collection with:\n\n```\ncomparator: function() {\n    return this.get('pageNo');\n},\n```\n## \n\npageNo is an integer in the model\n\nthis error doesn't occur in IE9 or Firefox but every time in IE8\nmy workaround was to throw out the comparator function and use the where clauses to find the correct model\n",
    "comments_url": "https://api.github.com/repos/jashkenas/backbone/issues/1883/comments",
    "author": "lka",
    "comments": [
      {
        "user": "caseywebdev",
        "created_at": "2012-12-09T17:02:19Z",
        "body": "What you want is\n\n``` js\ncomparator: function(model) {\n    return model.get('pageNo');\n},\n```\n\nThe comparator function isn't called with the model context, it's called with the collection context. It is passed the model as the first argument, however, which is what you want.\n"
      },
      {
        "user": "caseywebdev",
        "created_at": "2012-12-09T18:21:36Z",
        "body": "And actually on `master` (not 0.9.2) you can do this\n\n``` js\ncomparator: 'pageNo',\n```\n\nwhich is some pretty sweet sugar if you ask me :+1:\n"
      }
    ]
  },
  {
    "number": 1728,
    "title": "Question - Assign index to models on instantiation",
    "created_at": "2012-10-12T09:39:41Z",
    "closed_at": "2012-10-12T09:49:33Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/jashkenas/backbone/issues/1728",
    "body": "Is there anyway to let the newly instantiated model know of its 0-based index inside its collection, and assign it? Something like:\n\n``` javascript\n    var m = Backbone.Model.extend({\n        initialize: function() {\n            this.set('index', '// 0-based index inside the parent collection//');\n        }\n    });\n```\n",
    "comments_url": "https://api.github.com/repos/jashkenas/backbone/issues/1728/comments",
    "author": "gsklee",
    "comments": [
      {
        "user": "vincentbriglia",
        "created_at": "2012-10-12T09:44:45Z",
        "body": "You can get the index of a model on a collection by using indexOf\n\n``` javascript\ncollection.indexOf(model)\n```\n\nor if you don't have access to the collection in your view but you know the model is inside a particular collection, you can always get the collection like this:\n\n``` javascript\nmodel.collection.indexOf(model)\n```\n\nI wouldn't recommend storing the index on a model, because then each time you add an additional model you will have to update the index values for each model on a collection.\n"
      }
    ]
  },
  {
    "number": 1721,
    "title": ".fetch({add: true}) attaching phantom object into collection",
    "created_at": "2012-10-10T11:11:14Z",
    "closed_at": "2012-10-10T16:00:31Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/jashkenas/backbone/issues/1721",
    "body": "`collection.fetch({add: true})` currently adds an empty object `{}` into the original collection even if the fetched response is `undefined` or `null`:\n\n``` javascript\n[..., {\"id\" : 39, attr: \"whatever\"}, {}]\n```\n\nThis can lead to unexpected errors when processing the collection data. Is this intended?\n",
    "comments_url": "https://api.github.com/repos/jashkenas/backbone/issues/1721/comments",
    "author": "gsklee",
    "comments": [
      {
        "user": "caseywebdev",
        "created_at": "2012-10-10T15:54:24Z",
        "body": "It's because `Collection#add(undefined | null | false | 0 | '' | {})` all add an empty model to the collection. What you want is `Collection#add([])` which means you have an array of models, but it's empty, so nothing is added. The question is why isn't your fetched JSON returning `[]`?\n"
      },
      {
        "user": "braddunbar",
        "created_at": "2012-10-10T16:00:30Z",
        "body": "Quite right.  You can use `Collection#parse` to ensure that undefined results return an empty array.  Thanks @caseywebdev!\n"
      }
    ]
  },
  {
    "number": 1715,
    "title": "By reference inheritance",
    "created_at": "2012-10-05T23:05:36Z",
    "closed_at": "2012-10-05T23:08:40Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/jashkenas/backbone/issues/1715",
    "body": "Have a question, potentially a bug - hopefully just a question.\n\nTrying to create a slightly enhanced view, and then create instances of that view as below.\n\n// enhanced view\nvar Enhanced = Backbone.View.extend({\nfoo: [],\ntest: function () {\nthis.foo.push(Math.random());\n}\n});\n\n// couple of new objects\nvar Foo = Enhanced.extend({});\nvar Bar = Enhanced.extend({});\n\n// instantiating\nvar foo = new Foo();\nvar bar = new Bar();\n\n// trying to push a random number into foo\nfoo.test();\nbar.test();\n\n// expecting to see something like [0.11767047128388153][0.8575983647365905]\nconsole.log(foo.foo, bar.foo);\n\nOne would expect to see 2 different values for the output above, however one gets the same array of length 2 with identical values in both instances.\n\nLooking @ the code around line 1400, one can see the following:\n\nctor.prototype = parent.prototype;\n\nIn order to create a truly new instance wouldn't:\n\nctor.prototype = $.extend(true,{},parent.prototype);\n\nbe suited better?\n\nThat would solve the problem I described above. As is, array foo feels like a static, not instance variables.\n\nI know that the prescribed version is to use \"initialize\" for instance variables, but why would the above suggested \"fix\" be wrong?\n\nThanks!\n",
    "comments_url": "https://api.github.com/repos/jashkenas/backbone/issues/1715/comments",
    "author": "ndanson",
    "comments": [
      {
        "user": "braddunbar",
        "created_at": "2012-10-05T23:08:40Z",
        "body": "Hi @ndanson!  Give this a try instead:\n\n``` js\nvar View = Backbone.View.extend({\n  initialize: function() {\n    this.foo = [Math.random()];\n  }\n});\n```\n\nPrototype properties are indeed shared between javascript instances.  For a unique value on each instance, you'll need to set it explicitly as above.\n"
      },
      {
        "user": "ndanson",
        "created_at": "2012-10-05T23:25:10Z",
        "body": "Suppose we have the following:\n\nvar Foo = View.extend({\n    initialize: function () {\n        console.log('toast is yummy!');\n    }\n});\n\nvar foo = new Foo();\n\nView's initialize will be overwritten by Foo's initialize, thereby variable foo won't be available in Foo anymore. Is that by design?\n"
      },
      {
        "user": "braddunbar",
        "created_at": "2012-10-05T23:27:04Z",
        "body": "It is, but you can always call the method on the prototype like so:\n\n``` js\nvar Sub = View.extend({\n  initialize: function() {\n    View.prototype.initialize.apply(this, arguments);\n    // \u2026\n  }\n});\n```\n"
      },
      {
        "user": "braddunbar",
        "created_at": "2012-10-05T23:36:06Z",
        "body": "Glad to help.  :)\n\nI'm not sure what boilerplate you're talking about.  If you're referring to the super call, that's just the reality of inheritance in javascript.  Calling super methods is rather verbose.\n"
      },
      {
        "user": "braddunbar",
        "created_at": "2012-10-05T23:47:40Z",
        "body": "> To rephrase even more, what would be the real world scenario where objects X and Y that extend Foo would share the same instance variables (within Backbone views for example) - not JavaScript in general.\n\nIn all the examples above, each instance shares prototype variables for `initialize`, so functions are one example.  Also, default values such as `disabled` or `hidden` are good examples, assuming you need them.\n"
      },
      {
        "user": "tgriesser",
        "created_at": "2012-10-06T00:00:22Z",
        "body": "@ndanson - only objects and arrays are passed by reference when they are object properties (as they are on the prototype), so those are the only items that you'll need to set explicitly per instance. Deep copying is very costly from a performance standpoint (and in almost every case a different solution would be better suited) - if it's something you still want to do, you'll have to find something other than backbone to do it with.\n"
      }
    ]
  },
  {
    "number": 1703,
    "title": "Can't Pass \"data-\" attributes within View's Attributes method",
    "created_at": "2012-10-03T21:07:26Z",
    "closed_at": "2012-10-03T21:08:40Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/jashkenas/backbone/issues/1703",
    "body": "I am a fan of setting attributes within a view as such...\n\n<pre>Backbone.View.extend({\n    attributes: {\n        data-attr: 'mydata'\n    }\n});\n</pre>\n\n\n... however, this throws an error due to the hyphen in the key \"data-attr\".\n\n<pre>Uncaught SyntaxError: Unexpected token -</pre>\n\n\nI realize this is an illegal token in a JavaScript key-value object, however I was hoping Backbone offered some work around for this, given the fact that passing data attributes is one of the most likely scenarios.\n\nI have been working around it by setting the attribute within the render function using jQuery:\n\n<pre>render: function () {\n    this.$el.attr( 'data-attr', 'mydata\"');\n}\n</pre>\n\n\nThis works, but I thought to ask if there is another option.\n",
    "comments_url": "https://api.github.com/repos/jashkenas/backbone/issues/1703/comments",
    "author": "ghost",
    "comments": [
      {
        "user": "jashkenas",
        "created_at": "2012-10-03T21:08:35Z",
        "body": "Yep -- it's just a JavaScript object. Use quoted keys.\n\n```\nattributes: {\n    \"data-attr\": \"mydata\"\n}\n```\n"
      },
      {
        "user": "ghost",
        "created_at": "2012-10-03T21:15:45Z",
        "body": "What do you suggest for passing a data attribute to the View's DOM element from the attributes within the View's Model? As such...\n\n<pre>\nattributes: {\n    \"data-attr\": this.model.foo\n}\n</pre>\n\nI am losing scope for reference to \"this\".\n\n<pre>\nUncaught TypeError: Cannot read property 'model' of undefined \n</pre>\n"
      },
      {
        "user": "braddunbar",
        "created_at": "2012-10-03T21:16:49Z",
        "body": "You can use a function like so:\n\n``` js\nattributes: function() {\n  return {\n    'data-attr': this.model.foo\n  };\n}\n```\n"
      }
    ]
  },
  {
    "number": 1702,
    "title": "Alternative to events: { \"trigger select\" : \"functor\" }?",
    "created_at": "2012-10-03T18:31:37Z",
    "closed_at": "2012-10-03T18:45:48Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/jashkenas/backbone/issues/1702",
    "body": "Hi,\n\nI was wondering if there was an alternative to the standard Backbone.View.extend({ events: { \"trigger selector\" : \"functor\", ...} ... }).\n\nIs there a special alternative function that gets called that lets you bind events for that specific view without having to mix the trigger and CSS selector into a string, and without having to pass the callback as a string rather than as a reference?\n\nThe latter's less important than the former: if there's a way to at least do even binding in a way that keeps the trigger and the view selector separate, that would be awesome. Is there such an alternative?\n",
    "comments_url": "https://api.github.com/repos/jashkenas/backbone/issues/1702/comments",
    "author": "Pomax",
    "comments": [
      {
        "user": "braddunbar",
        "created_at": "2012-10-03T18:39:57Z",
        "body": "> Is there a special alternative function that gets called that lets you bind events for that specific view without having to mix the trigger and CSS selector into a string\n\nI'm afraid not.  Is there a reason you would rather not concatenate the event and the selector?  I've found that the object syntax is rather succinct.\n\n> and without having to pass the callback as a string rather than as a reference?\n\nYou can pass a function instead of a string as the callback.\n\n``` js\nvar View = Backbone.View.extend({\n  events: {\n    click: function(e) {\n      e.preventDefault();\n      // ...\n    }\n  }\n});\n```\n\nThis will also work when calling `delegateEvents` directly.\n\n``` js\nview.delegateEvents({click: function(){...}});\n```\n"
      },
      {
        "user": "jashkenas",
        "created_at": "2012-10-03T18:45:43Z",
        "body": "Just use jQuery?\n\n```\n$(view.el).on('click', '.target', function(){ ... })\n```\n"
      },
      {
        "user": "Pomax",
        "created_at": "2012-10-03T19:13:24Z",
        "body": "the syntax is succinct, but it puts two completely different things in the same string, effectively making it a mystery string (the first word is a trigger, then there's whitespace, then there's a selector, but how do you get the trigger back out? split on whitespace? is that always going to be true? maybe, maybe not).\n\nUsing jQuery for the el is a good suggestion, thank you!\n"
      }
    ]
  },
  {
    "number": 1690,
    "title": "Concerned about Model security?",
    "created_at": "2012-10-01T13:52:44Z",
    "closed_at": "2012-10-01T13:58:31Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/jashkenas/backbone/issues/1690",
    "body": "Hi,\n\nI have a simple Backbone Model/View combo that is validating a login field and then calling `.save` so the data is sent to the server to process. \n\nThe problem I've just realised is that when inspecting the Model after calling `.save` I can see the password is being stored in the Model as plain text so all a developer has to do is dynamically change the JavaScript via the standard built-in browser developer tools to see the user's password.\n\nHow can I implement a username/password login securely with Backbone?\n\nMy current Model/View code is as follows...\n## Model:\n\n``` js\ndefine(['Backbone'], function(){\n\n    return Backbone.Model.extend({\n        url: '/login/',\n\n        validate: function (attributes) {\n            var errors = [];\n\n            if (attributes.account.indexOf('@') === -1) {\n                errors.push({\n                    field: 'account',\n                    value: attributes.account\n                });\n            }\n\n            if (attributes.password === '') {\n                errors.push({\n                    field: 'password',\n                    value: attributes.password\n                });\n            }\n\n            if (errors.length) {\n                return errors\n            }\n        }\n    });\n\n});\n```\n## View:\n\n``` js\ndefine(['../Models/CustomerLogin', 'Backbone'], function (CustomerLogin) {\n\n    return Backbone.View.extend({\n        initialize: function(){\n            // Store the form element and hide it\n            this.form = this.$el.find('form');\n\n            // Store the Model object for easy reference\n            this.model = new CustomerLogin();\n\n            // Store reference to error message box\n            this.error_message = $('#js-loginerror')\n        },\n\n        // The containing element\n        el: $('#js-customerlogin'),\n\n        // Selectors are scoped to the parent element\n        events: {\n            'click #js-loginbtn': 'toggle_display',\n            'submit form': 'store_user_details'\n        },\n\n        toggle_display: function(){\n            this.form.slideToggle();\n        },\n\n        store_user_details: function (e) {\n            // I stored this hash in a variable as it looked cleaner passing it to `save` method below\n            var fields = {\n                account: this.form[0].elements[0].value,\n                password: this.form[0].elements[1].value\n            };\n\n            // Scope of `this` is lost within the error callback below\n            var self = this;\n\n            // When we call `save` it automatically validates all data\n            // So if there are any errors with what we're trying to save then it'll fail\n            this.model.save(fields, {\n                error: function(){\n                    self.error_message.addClass('is-error');\n                },\n                success: function(data){\n                    self.error_message.removeClass('is-error');\n                    alert('LOG USER IN - WARNING!!! Backbone.Model has plain text storage of password!!!');\n                    console.log(self.model.attributes, 'ALL DEVELOPER HAS TO DO IS CHANGE JS DYNAMICALLY AND HE HAS PASSWORD!');\n                }\n            });\n\n            e.preventDefault();\n        }\n    });\n\n});\n```\n",
    "comments_url": "https://api.github.com/repos/jashkenas/backbone/issues/1690/comments",
    "author": "Integralist",
    "comments": [
      {
        "user": "jashkenas",
        "created_at": "2012-10-01T13:58:21Z",
        "body": "I'm afraid this has nothing to do with Backbone. Any insecure JavaScript on your website is able to sniff passwords. Don't allow insecure JavaScript on your site (XSS, third party scripts, etc.), use HTTPS, and don't store the password on the client side for a moment longer than it takes you to send it to the server to be hashed.\n"
      },
      {
        "user": "Integralist",
        "created_at": "2012-10-01T14:04:24Z",
        "body": "@jashkenas so what's the best procedure for using Backbone with a logon area when you don't have HTTPS?\n\nI totally understand that passwords shouldn't be stored - hence why my concern when I realised what this Model code was actually doing.\n\nWhat I'm getting at is: how should this be handled using the concepts of Models/Views?\n\nI was using a Model so I could validate the data (username/password) and make sure it was in the correct format. But should I even have a Model? Should I have just a View and I manually validate fields and then not use AJAX to send data to the server but have the form's POST action handle that in the standard/traditional way?\n\nIf I did have HTTPS available would it be safe AJAX'ing the data across? I assume not because the JavaScript is still client side and can be intercepted. Unless I'm missing something here.\n"
      },
      {
        "user": "jashkenas",
        "created_at": "2012-10-01T14:21:54Z",
        "body": "Do **not** have a login form under HTTP. The password can be sniffed by a man in the middle, or by anyone on the same unencrypted wifi network as you. Ideally, your entire site runs under HTTPS -- but certainly, any page that provides logged-in functionality needs to.\n\nAs for Backbone -- again -- it has nothing to do with this. Having your password present in an `<input type=\"password\">` field is no more or less secure than having it present in a model on the same page.\n"
      },
      {
        "user": "Integralist",
        "created_at": "2012-10-01T14:32:10Z",
        "body": "@jashkenas no problem, I understand this is not a Backbone issue - but can I ask that you take a brief moment to look at the following code and advise whether this would be safe (under the assumption that I was running HTTPS on the site). \n\nEffectively I'm not storing the form fields any where (I no longer have a Model). I'm literally validating and letting the form submit itself to the server as per traditional POST method...\n\n``` js\ndefine(['../Models/CustomerLogin', 'Backbone'], function (CustomerLogin) {\n\n    return Backbone.View.extend({\n        model: new CustomerLogin(),\n\n        initialize: function(){\n            // Store the form element and hide it\n            this.form = this.$el.find('form');\n\n            // Store reference to error message box\n            this.error_message = $('#js-loginerror');\n        },\n\n        // The containing element\n        el: $('#js-customerlogin'),\n\n        // Selectors are scoped to the parent element\n        events: {\n            'click #js-loginbtn': 'toggle_display',\n            'submit form': 'validate_fields'\n        },\n\n        toggle_display: function(){\n            this.form.slideToggle();\n        },\n\n        validate_fields: function (e) {\n            var errors = false;\n            var username = this.form[0].elements[0].value;\n            var password = this.form[0].elements[1].value;\n\n            if (username.indexOf('@') === -1) {\n                errors = true;\n            }\n\n            if (password === '') {\n                errors = true;\n            }\n\n            if (errors) {\n                this.error_message.addClass('is-error');\n            } else {\n                this.error_message.removeClass('is-error');\n                this.form.submit();\n            }\n\n            e.preventDefault();\n        }\n    });\n\n});\n```\n"
      },
      {
        "user": "jashkenas",
        "created_at": "2012-10-01T14:34:05Z",
        "body": "Yep -- if you use HTTPS from end-to-end on your site, and don't have any XSS holes, then sending over the password to the server should be fine. It doesn't matter if you keep it around temporarily in a model, or not.\n"
      }
    ]
  },
  {
    "number": 1552,
    "title": "Delegate event in View does not return original event",
    "created_at": "2012-08-15T10:48:20Z",
    "closed_at": "2012-08-15T12:08:39Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/jashkenas/backbone/issues/1552",
    "body": "To process some attributes i need access to $(this) in event callback, but receive only event object. This event object contain target (child html element) but does not contain the original event.\n\nFor example\n\n```\n<div class=\"test\"><div class=\"sub\">TEXT</div></div>\n\nevents: {\n    \"click .test\": \"func\"\n}\n```\n\nThis backbone uses \n\n```\nvar eventName = match[1], selector = match[2];\nmethod = _.bind(method, this);\n```\n\nyes, it is okay. But maybe the original \"this\" should returned too as 2d argument?\n\nit can be dome for example as $.delegate eventData\n\nps of course i can get access to parent by jquery parents() but it adds some complexity\n",
    "comments_url": "https://api.github.com/repos/jashkenas/backbone/issues/1552/comments",
    "author": "artyomtrityak",
    "comments": [
      {
        "user": "braddunbar",
        "created_at": "2012-08-15T12:01:44Z",
        "body": "Mornin' @artyomtrityak, thanks for opening an issue!  I'm not sure which element you're trying to get to, but I'm fairly certain that you can grab a reference to it using one of the following:\n- event.target\n- event.currentTarget\n- event.delegateTarget\n\nCould you be a bit more specific?  Maybe some extra context in the code would help me understand the issue.\n"
      }
    ]
  },
  {
    "number": 1450,
    "title": "route & page reload on IE",
    "created_at": "2012-06-25T10:35:14Z",
    "closed_at": "2012-06-25T16:26:27Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/jashkenas/backbone/issues/1450",
    "body": "Hi guys \nI have the following issue I am not sure if this is how backbone is supposed to behave\n\nI start Backbone history on my auth path \n\n``` javascript\nBackbone.history.start({pushState: true, root: '/auth/'});\n```\n\nwhen IE users hit /auth/join backbone switch the url to #auth/join as the browser does not support the history api. But this \nalso reload the page. Can't this be done without reloading the page ?\n",
    "comments_url": "https://api.github.com/repos/jashkenas/backbone/issues/1450/comments",
    "author": "pgherveou",
    "comments": [
      {
        "user": "jashkenas",
        "created_at": "2012-06-25T16:26:23Z",
        "body": "Nope -- there's absolutely no way to change the URL without reloading the page in old IEs. That's exactly the problem that `pushState` solves.\n"
      }
    ]
  },
  {
    "number": 1198,
    "title": "collection.sortedIndex does not use collection.comparator",
    "created_at": "2012-04-06T01:37:17Z",
    "closed_at": "2012-04-06T14:15:11Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/jashkenas/backbone/issues/1198",
    "body": "`collection.sortedIndex` does not use `collection.comparator`, so it always returns 0\n",
    "comments_url": "https://api.github.com/repos/jashkenas/backbone/issues/1198/comments",
    "author": "mikepb",
    "comments": [
      {
        "user": "aterris",
        "created_at": "2012-04-06T03:15:24Z",
        "body": "I hadn't actually had a use for sortedIndex yet and I don't use the comparators all that often, so I just spent the last few minutes playing around in the console.\n\nsince sortedIndex is just a proxied underscore method writing `collection.sortedIndex` is essentially just syntax sugar for `_.sortedIndex(collection.models, ...`\n\nIt looks like you are actually expecting it to automatically pass the comparator on to sortedIndex, but these methods are simply proxied with the models being passed as the first argument.  You will need to just pass it yourself.\n\nHere is the final code that I ran in the backbone docs site console that I feels recreates your issue and shows how to get the correct result.\n\n```\nc = new Backbone.Collection();\nc.comparator = function(model){ return model.get('score')}\n\nc.add(new Backbone.Model({score: 3}));\nc.add(new Backbone.Model({score: 0}));\nc.add(new Backbone.Model({score: 9}));\nc.add(new Backbone.Model({score: 6}));\n\nc.pluck('score');\n# [0,3,6,9]\n\nc.sortedIndex(new Backbone.Model({score: 7}));\n# 0 \n\nc.sortedIndex(new Backbone.Model({score: 7}), c.comparator);\n# 3\n\n```\n\nBecause the underscore method are passed models, it will never be able to figure out the order (will always return 0) unless a comparator of some kind is passed, so it knows what \"sorting the models\" even means.  This is actually the correct behavior, and I think it makes sense to keep it the same as every other proxy method.\n\nI am pretty sure that should addresses your issue, but if I missed something or I am way off base with what you are talking about just lemme know :+1:\n"
      }
    ]
  },
  {
    "number": 998,
    "title": "Collection.add event callbacks trigger after all models are added in 0.9.1 instead of serially like 0.5.3",
    "created_at": "2012-02-13T21:28:11Z",
    "closed_at": "2012-03-19T20:58:53Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/jashkenas/backbone/issues/998",
    "body": "Something in my code broke with the recent update from 0.5.3 -> 0.9.1 and I believe I've traced it down to a difference in how Collection.add works.\n\nIn 0.5.3, when the \"add\" event fired on a collection, the state of the collection was such that the last model in the collection was the one being passed through the add. Put another way, in the add callback on a collection the length was accurate and in sync with the model being added. Does that make sense?\n\nThe code was like:\nfor (var i = 0, l = models.length; i < l; i++) {\n          this._add(models[i], options);\n        }\n\nSo when the add callback say hits a viewer listening for 'add' the length of the collection would increment on each add callback.\n\nNow, the code is more decoupled and the collection is fully populated when add events are triggered.\n\nsplice.apply(this.models, [index, 0].concat(models));\n      if (this.comparator) this.sort({silent: true});\n      if (options.silent) return this;\n      for (i = 0, length = this.models.length; i < length; i++) {\n        if (!cids[(model = this.models[i]).cid]) continue;\n        options.index = i;\n        model.trigger('add', model, this, options);\n      }\n\nThis seems like strange behavior - meaning that add callbacks aren't really callbacks per add but rather a batch after all the models have been added.\n\nThoughts?\n",
    "comments_url": "https://api.github.com/repos/jashkenas/backbone/issues/998/comments",
    "author": "elsigh",
    "comments": [
      {
        "user": "elsigh",
        "created_at": "2012-02-13T21:35:17Z",
        "body": "I do see that you can compare options.index to collection.length but still feel like the state connection between the add event and the collection is off now.\n"
      },
      {
        "user": "braddunbar",
        "created_at": "2012-02-14T02:55:14Z",
        "body": "Would you mind providing more specifics on the nature of your problem?  You're correct that the semantics of `add` have changed and I have several concerns here as well.\n\nBy the way, #81 states the reasons for the change, which I think are good.  Hopefully we can address both sides of the issue.\n"
      },
      {
        "user": "elsigh",
        "created_at": "2012-02-14T05:32:16Z",
        "body": "I can effectively do what I need to do with options.index, but anyhow here was my situation.\n\nI have collection and a view for that collection.\nThe collection reads out a list of items to add from a server and then adds a bunch in from a sync call.\nI'd bound \"add\" events to a function which looked at the length of the models array to determine whether or not to set the last element in my collection to a selected state(which did something to its view).\nBut now in my add callback, the collection.length is not incrementing with each add, it's the resulting total length of the collection.\nSo it feels wrong inasmuch as it's not a serial callback on each add it's a bulk callback on each one after they've all been added.\nEasy enough fix for me - it's just not intuitive feeling.\n"
      },
      {
        "user": "braddunbar",
        "created_at": "2012-02-14T14:39:26Z",
        "body": "In taking a closer look, there are several bugs with nested events.  For instance, adding or removing another model during the `'add'` or `'remove'` events can cause models to be skipped or index out of range errors:\n\n``` javascript\nvar c = new Backbone.Collection();\nvar m1 = new Backbone.Model({id: 1});\nvar m2 = new Backbone.Model({id: 2});\nvar m3 = new Backbone.Model({id: 3});\nc.on('add', function(model, collection, options) {\n  if (model === m1) c.add(m3, {at: 1});\n});\nc.add([m1, m2]);\n```\n\nI'm not sure how to reconcile this type of problem.  It seems that reporting the index and adding with one sort operation are at odds.\n"
      },
      {
        "user": "jashkenas",
        "created_at": "2012-03-19T20:51:08Z",
        "body": "@braddunbar: Have those particular issues been addressed in the past month or are we still at an impasse on this? If push comes to shove, I don't think we need to be religious about being able to handle every possible recursive `add` pattern.\n"
      },
      {
        "user": "braddunbar",
        "created_at": "2012-03-19T20:57:25Z",
        "body": "No, I haven't been able to resolve this.  I'm still not sure how to address it and I'm inclined to agree with you that handling the recursive cases isn't necessarily desirable.\n"
      },
      {
        "user": "jashkenas",
        "created_at": "2012-03-19T20:58:52Z",
        "body": "Alright, then given that the `index` value solves this particular ticket, let's leave this be for now -- and entertain pull requests, if anyone has use cases for the combinations you listed.\n"
      }
    ]
  },
  {
    "number": 962,
    "title": "Models not available in Collection.initialize()",
    "created_at": "2012-02-06T12:28:24Z",
    "closed_at": "2012-02-06T15:00:56Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/jashkenas/backbone/issues/962",
    "body": "In 0.5.3, the Collection's constructor used to set the models before calling `initialize()`. However, with 0.9, the models get set only after `initialize()`. \n\nOur existing `initialize()` code relies on models existing in order to run some aggregate calculations. Now, all that is broken. Why the change?\n\nAdditionally, when `reset()` is called to set the models, it is done silently, so we can't even listen to the \"reset\" event to perform the calculations.\n",
    "comments_url": "https://api.github.com/repos/jashkenas/backbone/issues/962/comments",
    "author": "anush",
    "comments": [
      {
        "user": "jashkenas",
        "created_at": "2012-02-06T15:00:45Z",
        "body": "The change was made so that the collection can dynamically set it's `model` attribute and others during initialization, before any models have been created.\n\nAlthough there are use cases for doing it both ways, the change was deemed to be correct, because a collection should be fully initialized before it receives its first model.\n\nHopefully, you can fix your code by writing:\n\n```\nvar collection = new Collection(models);\ncollection.performCalculations();\n```\n"
      },
      {
        "user": "anush",
        "created_at": "2012-02-06T15:42:03Z",
        "body": "Would you be open to adding a new \"ready\" event, once the collection is fully initialized... models and all?\n\nDoing the calculations outside the collection's initialize is quirky because then the collection is no longer self-sufficient.\n"
      },
      {
        "user": "jashkenas",
        "created_at": "2012-02-06T15:46:34Z",
        "body": "> Would you be open to adding a new \"ready\" event, once the \n> collection is fully initialized... models and all?\n\nNo. Firstly because it's not an evented thing -- you're in control of when you create a collection. If the two-liner doesn't float your boat, why not just create your own method?\n\n```\nCollection.create = function(models, options) {\n  var col = new Collection(models, options);\n  col.trigger(\"ready\"); // or whatever...\n  return col;\n};\n```\n"
      }
    ]
  },
  {
    "number": 888,
    "title": "Removal of \"_add\" and \"_remove\"",
    "created_at": "2012-01-24T16:56:19Z",
    "closed_at": "2012-01-24T17:26:13Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/jashkenas/backbone/issues/888",
    "body": "I'd like to discuss the removal of `Collection._add` and `Collection._remove`. I realize these methods were not part of the \"public\" API of course, but they were quite useful nonetheless.\n\nThese methods exposed functionality that is not otherwise available in Backbone, and were therefore very useful as hook points for extensions (not least of all for me in Backbone-relational). Both of these took a single snippet of data (either a model, or an object that might contain an `id` somewhere... or not) and return the model operated upon. Since both `add` and `remove` simply return the complete collection, they can not be used to determine this, especially when passing in JSON.\n\nI have a sort-of-working workaround for Backbone-relational (using `_.clone(this.models)` before adding, then calling `add`, using `_.difference( this.models, clone )` afterwards and iterating over the diff), but this is quite a performance penalty when compared to the current situation. Especially considering many people use relational  exactly because it automates the handling of a very large amount of models, and this whole process is repeated for every single addition.\n\nAny chance these two could be re-instated?\n",
    "comments_url": "https://api.github.com/repos/jashkenas/backbone/issues/888/comments",
    "author": "PaulUithol",
    "comments": [
      {
        "user": "jashkenas",
        "created_at": "2012-01-24T17:26:08Z",
        "body": "I'm afraid they can't be -- part of the point of the new change is to be able to optimize `add` and `remove` by slicing in the list of models in a single operation. Breaking out `_add` and `_remove` into individual functions, as previous, would revert this improvement. \n\nHopefully, there's a better override you'll be able to come up with ;) Perhaps you can wrap `add` and `remove`, record the ids to the models to be added or removed beforehand, and then proceed from there?\n"
      },
      {
        "user": "PaulUithol",
        "created_at": "2012-01-24T17:59:28Z",
        "body": "\"they can't be\" - well, that sounds dramatic enough alright :).\n\nSome optimization will probably be possible, but it's going to be quite tricky - since it's far from uncommon to be adding stuff that doesn't have an `id` yet, or isn't even a `Backbone.Model` yet (just a plain object that'll only have a `cid` afterwards).\n"
      },
      {
        "user": "jashkenas",
        "created_at": "2012-01-24T18:54:17Z",
        "body": "Another idea for you ... override `prepareModel` so that you know when new models are coming in. Then, when `add` finishes, you can run through all the recorded new ones.\n"
      },
      {
        "user": "braddunbar",
        "created_at": "2012-01-24T19:01:13Z",
        "body": "@PaulUithol I have been able to work around this by overriding `add` and calling `_prepareModel` on each object passed in.  This essentially renders the call to `_prepareModel` in `add` to a noop and gives you a list of added models.\n\nLet me know if this solution doesn't work for you.  I'd be very interested in the reasons.\n"
      }
    ]
  },
  {
    "number": 855,
    "title": "model.destroy don't send id in request header",
    "created_at": "2012-01-12T12:46:13Z",
    "closed_at": "2012-01-12T17:21:11Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/jashkenas/backbone/issues/855",
    "body": "I use default behavior (REST) with PHP server\n\nI defined url for my model and everything is right with create and update.\n\nBut with delete method, ID is not send in the header like for others methods\n\nIn the source code, I find : \n\n```\nif (!params.data && model && (method == 'create' || method == 'update')) {\n  params.contentType = 'application/json';\n  params.data = JSON.stringify(model.toJSON());\n}\n```\n\nWhy dont include delete method ?\n\n```\nif (!params.data && model && (method == 'create' || method == 'update' || method == 'delete' )) {\n```\n",
    "comments_url": "https://api.github.com/repos/jashkenas/backbone/issues/855/comments",
    "author": "dcz-switcher",
    "comments": [
      {
        "user": "jashkenas",
        "created_at": "2012-01-12T17:21:09Z",
        "body": "Yes, delete requests have no body -- the URL itself should contain the ID of the model being deleted.\n"
      },
      {
        "user": "dcz-switcher",
        "created_at": "2012-01-13T10:41:33Z",
        "body": "Thanks for your reply,\n\nI understand now, but it works only with urlRoot, not with url ?!?\n\nso, I can't call destroy() method from a model in a collection\n\nmyCollection.get( id ).destroy() ; //don't work (the ID is not in the URL\n\nBut ...\nmyCollection.get(id).save({name : 'newName' }) ; //works\n\nThanks again\n"
      },
      {
        "user": "jashkenas",
        "created_at": "2012-01-13T15:37:09Z",
        "body": "The ID should be in the URL -- unless you've overridden the `url()` function to prevent it from being there.\n"
      }
    ]
  },
  {
    "number": 832,
    "title": "Weird behaviour of Collection.without",
    "created_at": "2011-12-30T16:26:38Z",
    "closed_at": "2011-12-30T21:28:37Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/jashkenas/backbone/issues/832",
    "body": "Hi,\n\nI noticed a weird behaviour for `without` method on collections with the following code.\n\n``` coffee\nremainingTerritories = allTerritories.without(territoriesToReject)\n```\n\nBoth `allTerritories` and `territoriesToReject` are `Territories` collections containing Territory objects, and some of these territories to reject come from the pool of territories, matching with `===`).\n`remainingTerritories` contains a regular Array containing all the Territory objects  no one is filtered out.\nI would expect to get all the territories minus the ones to reject.\n\nTo achieve my goal, I had to write:\n\n``` coffee\nremainingTerritories = new Territories(allTerritories.reject (t)-> territoriesToReject.include(t))\n```\n\nIt's not a big deal but I would be glad to know why, and if I can help fixing that if it's not the expected behaviour.\n",
    "comments_url": "https://api.github.com/repos/jashkenas/backbone/issues/832/comments",
    "author": "Sephi-Chan",
    "comments": [
      {
        "user": "nordyke",
        "created_at": "2011-12-30T20:50:14Z",
        "body": "@Sephi-Chan  `allTerritories.without` expects `territoriesToReject` to be an array.  Have you tried \n\n`remainingTerritories = allTerritories.without(territoriesToReject.models)`?\n"
      },
      {
        "user": "jashkenas",
        "created_at": "2011-12-30T21:28:31Z",
        "body": "Yep -- you have to pass an array to `without`.\n"
      }
    ]
  },
  {
    "number": 830,
    "title": "Callback vs event handler priority",
    "created_at": "2011-12-30T02:11:23Z",
    "closed_at": "2011-12-30T14:04:36Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/jashkenas/backbone/issues/830",
    "body": "What's the reasoning for event handlers getting priority over the passed in callback?\n\n```\n# taken from destroy method\n...\noptions.success = function(resp) {\n   model.trigger('destroy', model, model.collection, options);\n   if (success) success(model, resp);\n};\n...\n```\n\nThe callback is provided by the object making the call in the first place, so it seems natural that it would get first rights to act on the result and then any event handlers would be handled second.  No?\n",
    "comments_url": "https://api.github.com/repos/jashkenas/backbone/issues/830/comments",
    "author": "rymohr",
    "comments": [
      {
        "user": "jashkenas",
        "created_at": "2011-12-30T14:04:31Z",
        "body": "I'm afraid not. The `destroy` event and the `success` callback aren't quite the same thing. The former notifies listeners that the model has been destroyed, the latter is a callback that indicates that the operation (including the `destroy` handlers) have finished successfully. You certainly wouldn't want the `success` callback to fire if one of the `destroy` handlers raised an exception. \n"
      }
    ]
  },
  {
    "number": 793,
    "title": "Supporting polymorphic collections",
    "created_at": "2011-12-16T19:09:28Z",
    "closed_at": "2011-12-19T16:05:09Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/jashkenas/backbone/issues/793",
    "body": "Howdy!\n\nRight now backbone seems to only support collections of one type, we're working on a stream with many polymorphic types that all quack the same.\n\nIt'd be nice to implement this via inheritance(extend), rather than our current technique of creating proxies/mixins in the base class.\n\nbackbone collection seems to have a hardcoded new this.model in it,\n\nI was thinking about doing something like:\n\n```\nmodelClass : function(){\n   return  this[postType]\n}\n```\n\n   this.model = this.model || this.modelClass()\n\n```\nnew this.model\n```\n\nis this a change you would like to have implemented, or are you opposed to it for an ideological reason?\n\nIf you want it, I'll implemented, as it will help me on a couple projects I'm working on.\n",
    "comments_url": "https://api.github.com/repos/jashkenas/backbone/issues/793/comments",
    "author": "dnsco",
    "comments": [
      {
        "user": "jashkenas",
        "created_at": "2011-12-19T16:04:59Z",
        "body": "Fortunately, because of the (in my opinion, buggy) way that JavaScript constructors work, you can already do collections with polymorphic models. Like so:\n\n```\nvar Library = Backbone.Collection.extend({\n\n  model: function(attrs, options) {\n    if (condition) {\n      return new PublicDocument(attrs, options); \n    } else {\n      return new PrivateDocument(attrs, options);\n    }\n  }\n\n});\n```\n"
      }
    ]
  },
  {
    "number": 774,
    "title": "Collection Reset",
    "created_at": "2011-12-04T19:10:37Z",
    "closed_at": "2011-12-05T15:42:53Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/jashkenas/backbone/issues/774",
    "body": "I'm using the suggested method of loading data models from the backend, to prevent fetching data from the server twice on a page load like this:\n\n``` javascript\n<script>\n  collection.reset(<%= @accounts.to_json %>);\n</script>\n```\n\nThe issue is my models are being rendered in my php views, the code above just adds the models to the collection, therefore no views rendering is happening when collection.reset is called, however I do have a view for this model but it's only rendered when collection.add is called with some click events in it, so the click events are obviously  not being called with the already rendered html because backbone.js didn't render the views itself.\n\nIs there a way of taking the already rendered html tags and bind it to my views so the click events I have work for those tags ?\nCheers\n",
    "comments_url": "https://api.github.com/repos/jashkenas/backbone/issues/774/comments",
    "author": "pablofierro",
    "comments": [
      {
        "user": "judofyr",
        "created_at": "2011-12-06T10:49:35Z",
        "body": "You can also bind reset: `collection.bind('reset', \u2026)`.\n"
      },
      {
        "user": "pablofierro",
        "created_at": "2011-12-09T21:45:36Z",
        "body": "collection.bind('reset') is what I'm currently using to render the views, what I meant is if I can make backbone.js take a bash of ALREADY rendered html tags, i.e:\n\n``` HTML\n<div class=\"item\">\n <a href=\"#\" class=\"trash\"></a>\n</div>\n<div class=\"item\">\n <a href=\"#\" class=\"trash\"></a>\n</div>\n```\n\nAnd use that within the view to bind events such as \"click\"\n"
      },
      {
        "user": "pablofierro",
        "created_at": "2012-04-24T07:03:06Z",
        "body": "I still haven't got a solution for this, let me give you an example, let's say you need to render html in the backend for indexing purposes(google), how can i force backbone to bind these existing html elements to my views ? so binded click events work on these **already** rendered html elements.\n\nI could think of a way of doing this but it would require to render in the backend and then re-render in the frontside, which i think it's very inefficient.\n\nHas anyone else faced this issue ?\n"
      },
      {
        "user": "braddunbar",
        "created_at": "2012-04-24T11:45:19Z",
        "body": "You can certainly attach Backbone views to existing html.  For instance, the following code would work for your html snippet above.\n\n``` javascript\nvar View = Backbone.View.extend({\n\n  events: {\n    'click .trash': 'trash'\n  },\n\n  trash: function() {\n    ...\n  }\n\n});\n\nvar views = $(html).map(function(i, el) {\n  return new View({el: el});\n});\n```\n\nAny reason you can't do something like that?\n"
      },
      {
        "user": "pablofierro",
        "created_at": "2012-06-02T04:48:34Z",
        "body": "Well, It works, but I guess my problem is when handling models with those views.\n\nHow is backbone.js going to know which models from a given collection correspond to the already existing html (views). ?\n"
      },
      {
        "user": "braddunbar",
        "created_at": "2012-06-02T09:42:39Z",
        "body": "That's a good question, and could certainly be handled several ways.  Off the top of my head, you can either re-render the list on the client with fresher data or you can store an `id` in the html that you then match up with a model.\n\n```\n<div data-model='5117'>...</div>\n<div data-model='6192'>...</div>\n```\n"
      }
    ]
  },
  {
    "number": 526,
    "title": "[question] how to handle scroll event for window?",
    "created_at": "2011-08-02T00:51:08Z",
    "closed_at": "2011-08-03T18:39:40Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/jashkenas/backbone/issues/526",
    "body": "``` javascript\nevents: {\n  \"scroll\": \"loadMore\"\n}\n```\n\nI'm not sure how to do it.\n",
    "comments_url": "https://api.github.com/repos/jashkenas/backbone/issues/526/comments",
    "author": "amrnt",
    "comments": [
      {
        "user": "jeremyckahn",
        "created_at": "2011-08-02T01:48:14Z",
        "body": "I'm assuming that this is an `events` key for a `View` bound to the window?  If so, then that looks like it should work.  `loadMore` just needs to be a method of that View Object.\n\nIf not, I think you have to manually bind the scroll event to the window:\n\n``` javascript\nvar example = Backbone.View.extend({\n  initialize: function () {\n    var self = this;\n\n    $(window).bind('scroll', function (ev) {\n      self.loadMore(ev);\n    });\n  },\n\n  loadMore: function () {\n    console.log('Loading more.');\n  }\n});\n```\n"
      },
      {
        "user": "amrnt",
        "created_at": "2011-08-02T08:55:45Z",
        "body": "in the first case, the `el` of the view should be `window` right?\n"
      },
      {
        "user": "amrnt",
        "created_at": "2011-08-03T23:36:04Z",
        "body": "``` javascript\nclass window.MainView extends Backbone.View\n  el: \"window\"\n  events:\n    \"scroll\": \"render\"\n\n  initialize: ->\n    _.bindAll(@, \"render\")\n    @render()\n\n  render: ->\n    console.log \"scroll\"\n```\n\n``` javascript\n  routes:\n    '': 'welcome'\n\n  welcome: ->  \n    new MainView\n```\n\nWhen loading the main page, it will appear on console \"scroll\". but when scroll nothing happened.\n"
      },
      {
        "user": "jeremyckahn",
        "created_at": "2011-08-04T12:46:11Z",
        "body": "Try removing the code you have in `initialize` - just leave that blank.\n\nLet me make sure I'm understanding this; the `render` method gets called once, only on page load?  That's because you have an explicit call to `render` in your `initialize` method.  Try removing all the code you have in `initialize`.  Also, I think you need to replace this line:\n\n``` javascript\nel: \"window\"\n```\n\nwith this:\n\n``` javascript\nel: $(window)\n```\n\nI'm pretty unfamiliar with CoffeeScript's syntax, so perhaps that's implicit or I missed something else.  In either case, I believe that `el` needs to be a jQuery Object, not a raw DOM node or `window` Object.\n"
      }
    ]
  },
  {
    "number": 369,
    "title": "backbone doesn't find objects in (sub?)collections when saved with {silent: true}",
    "created_at": "2011-05-25T15:12:49Z",
    "closed_at": "2011-05-26T17:46:16Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/jashkenas/backbone/issues/369",
    "body": "Hi, say we have a Dokuments collection and a Notes collection within Dokuments.\nI added this note and saved it later on silently. The id is returned from the server and is copied to the object, but it can't be found by get:\n\n> > > dok = Dokuments.get('4ddd0c2de8e6870c5e00000c')\n> > > dok.notes.get('4ddd1359e8e6870c5e00013f')\n> > > undefined\n\nbut:\n\n> > > dok.notes.last().get('id')\n> > > \"4ddd1359e8e6870c5e00013f\"\n\nThank you in advance for any hints\n--Frank\n",
    "comments_url": "https://api.github.com/repos/jashkenas/backbone/issues/369/comments",
    "author": "fwoeck",
    "comments": [
      {
        "user": "jashkenas",
        "created_at": "2011-05-26T17:46:11Z",
        "body": "That's correct -- the model's id isn't considered to have changed until the next \"change\" event fires. The model can still be found by its old id until that happens. If you'd like to trigger the \"change\" event yourself, just call `model.change()`.\n"
      }
    ]
  },
  {
    "number": 353,
    "title": "the latest code not published to npm? o_O",
    "created_at": "2011-05-11T21:20:07Z",
    "closed_at": "2011-05-26T18:38:02Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/jashkenas/backbone/issues/353",
    "body": "I was looking at the source on github and the file length is ~1100 lines -- but when I do\n\n```\n$ npm install backbone\n```\n\nMy backbone.js file is only ~ 1011 lines (as well as there being some minor differences in the source)\n\nThe package.json in github's master says the version = \"0.3.3\"\n\nand when i npm ls i also get 0.3.3 ...\n\nam i crazy? \n",
    "comments_url": "https://api.github.com/repos/jashkenas/backbone/issues/353/comments",
    "author": "fat",
    "comments": [
      {
        "user": "jashkenas",
        "created_at": "2011-05-26T18:37:30Z",
        "body": "You're not crazy. \n\n**master**, and now the **0.5.0** branch, is a good bit ahead of **0.3.3**. When it's released, it'll be pushed to npm.\n"
      }
    ]
  },
  {
    "number": 306,
    "title": "Nested Views",
    "created_at": "2011-04-04T16:20:55Z",
    "closed_at": "2011-04-05T09:17:42Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/jashkenas/backbone/issues/306",
    "body": "I have a situation where one of my views is nested inside another. The relationship between the models is not nested. One of my views is a tr and the other view is a single td inside that tr.\n\nI cannot bind events to the td because they get consumed by the tr and as far as I know there is no option not consume the event with my handler.\n",
    "comments_url": "https://api.github.com/repos/jashkenas/backbone/issues/306/comments",
    "author": "linusnorton",
    "comments": [
      {
        "user": "juggy",
        "created_at": "2011-04-04T18:43:28Z",
        "body": "View events in backbone are the same as a jQuery event. So you can stop the propagation but you can let it continue if needed. Have a look at how to handle events in jQuery and you should be all good to go.\n"
      }
    ]
  },
  {
    "number": 160,
    "title": "Can't get view events to bind",
    "created_at": "2010-12-31T03:53:25Z",
    "closed_at": "2010-12-31T20:16:48Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/jashkenas/backbone/issues/160",
    "body": "I've been trying many different approaches, but I can't get the click function to bind.\n\nHere is the view I'm using:\n<code>\nsfProjectView = Backbone.View.extend({\n  el: $(\"#header-project\"),\n      events: {\n      \"click .click-project\": \"linkProject\"\n        },\n      linkProject: function() {\n      sfController.changeObject(currentTab(),this.model.sfAttrib(\"project\"));\n    },\n      superHtml: function() {\n      var supers = this.model.get(\"superprojects\");\n      var output = \"\";\n      if (supers) {\n         _.each(supers, function(super) {\n             output = output + \"<a href'#'>\" + sfObjects.get(super).get(\"name\") + \" > \" + \"</a>\";\n           });\n         return output;\n      } else {\n        return \"&nbsp;\";\n      }\n    },\n      initialize: function() {\n      _.bindAll(this, \"render\", \"linkProect\");\n      this.render();\n    },\n      render: function() {\n\n```\n  var project = this.model.sfGet(\"project\");\n  var projectActiveP = this.model.sfActive(\"project\");\n  var projectType = this.model.sfGet(\"projectType\");\n  var projectDom = \"#ajaxProject\";\n  var projectTypeDom = \"#projectType\";\n  var superProjectsDom = \"#superProjects\";\n  if (project) {\n    $(projectDom).text(project).css(\"display\",\"block\");\n    $(superProjectsDom).html(this.superHtml());\n    if (projectActiveP) {\n      $(projectDom).removeClass(\"inactive\");\n      $(projectDom).addClass(\"active\");\n      $(projectTypeDom + \" span:eq(1)\").html(\"\");\n    } else {\n      $(projectDom).removeClass(\"active\");\n      $(projectDom).addClass(\"inactive\");\n      $(projectTypeDom + \" span:eq(1)\").html(\"&nbsp;Project Complete\").addClass(\"green\");\n    }\n    if (projectType) {\n      $(projectTypeDom).css(\"display\",\"block\");\n      $(projectTypeDom + \" span:eq(0)\").text(\"Type:\");\n      $(projectTypeDom + \" a\").text(projectType);\n    }\n  } else {\n    $(this.id).css(\"display\",\"none\");\n  }\n  return this;\n}\n```\n\n</code>\nAny ideas greatly appreciated!\n",
    "comments_url": "https://api.github.com/repos/jashkenas/backbone/issues/160/comments",
    "author": "gibsonf1",
    "comments": [
      {
        "user": "jashkenas",
        "created_at": "2010-12-31T04:12:38Z",
        "body": "Are you sure that `#header-project` is actually a DOM element on the page at the time that the JS is first loaded?\n"
      },
      {
        "user": "gibsonf1",
        "created_at": "2010-12-31T07:42:32Z",
        "body": "Yes, I moved all the Backbone code after document ready at one point, and also tried with id, none of which worked.  I'm stumped.  What is going on conceptually in achieving the binding?\n"
      },
      {
        "user": "jashkenas",
        "created_at": "2010-12-31T12:16:33Z",
        "body": "What's going on is that you're replacing `this.el` with a new element manually -- probably something you don't want to be doing. Try removing the line:\n\n```\nel: $(\"#header-project\")\n```\n\nAnd adding this to the bottom of `initialize` instead, right before calling `this.render()`.\n\n```\n$(\"#header-project\").append(this.el);\n```\n"
      },
      {
        "user": "gibsonf1",
        "created_at": "2010-12-31T13:54:01Z",
        "body": "Wow, that almost did it.  Backbone made a new div subordinate to the selector with the event, but it was unclickable.  I changed it to this:\n <code>  \n initialize: function() {\n      _.bindAll(this, \"render\");\n      this.render();\n      $(\"#ajaxProject\").wrap(this.el);\n    },\n</code>\nUsing this wrap, I now have events!  I had to narrow the selector of the wrap to the element I wanted to have clicked only.  Is this new element strictly made for event rendering and the view displays itself regardless?\n\nThanks Jeremy!\n"
      }
    ]
  },
  {
    "number": 126,
    "title": "Collection.create does not return a server response in the success callback",
    "created_at": "2010-12-08T08:15:03Z",
    "closed_at": "2010-12-08T22:23:30Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/jashkenas/backbone/issues/126",
    "body": "After creating a new model (using 'create'), I want to assign an id to the model that corresponds to the id the server generated. Unfortunately there is currently a bug in the create function that removes the response from the model.save success callback.\n\nIt's easy to fix but is there a specific reason for doing this that I'm missing? Should server-generated id's be assigned to models in a different way?\n",
    "comments_url": "https://api.github.com/repos/jashkenas/backbone/issues/126/comments",
    "author": "dickbrouwer",
    "comments": [
      {
        "user": "jashkenas",
        "created_at": "2010-12-08T14:23:20Z",
        "body": "There's a couple things here... `create` should not be throwing away the `success` callback.\n\n```\ncollection.create(attrs, {success: function(model, response){ ... }});\n```\n\nBut, also, if your server responds with a JSON representation of the model, all of the attributes you send down, including the `id`, should be set on the model for you. There's no need to use the `success` callback for this -- only for triggering some side-effect.\n"
      }
    ]
  },
  {
    "number": 122,
    "title": "model.previous() example abuses scope in change event callback",
    "created_at": "2010-12-07T06:47:29Z",
    "closed_at": "2010-12-08T00:06:29Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/jashkenas/backbone/pull/122",
    "body": "The example uses `bill.previos(\"name\")` instead of `model.previous(\"name\")` in the `change` callback defined on `bill`.\n\nThe example works just fine, but the callback will not work if `bill` is redefined or lost from scope (pardon if I'm wrong, I'm not as intricately knowledgable in JS as I'd like).\n",
    "comments_url": "https://api.github.com/repos/jashkenas/backbone/issues/122/comments",
    "author": "mtodd",
    "comments": [
      {
        "user": "jashkenas",
        "created_at": "2010-12-07T16:06:13Z",
        "body": "Hey Matt.\n\nIn JavaScript, using either `model` or `bill` is fine here. `bill` is closed over by the anonymous function, and cannot be lost from its scope. I chose to use `bill` in this example because it's a slightly more descriptive word than `model`, but both are interchangeable.\n"
      }
    ]
  },
  {
    "number": 90,
    "title": "Access a collection from a model",
    "created_at": "2010-11-23T19:36:47Z",
    "closed_at": "2010-11-24T04:24:33Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/jashkenas/backbone/issues/90",
    "body": "I need to access a collection from a model, and I get an error\n\nRelevant code:\n\n```\n$( function() {\n    var namespace = window;\n\n    namespace.Move = Backbone.Model.extend({\n        markable: function(){\n            var below = namespace.Moves.find(function(move) { // <= HERE !!!\n                return move.get(\"i\") === that.get('i')-1;\n            });\n            if(below !== undefined && !below.isNew()) return true;\n            return false;\n        }\n    });\n\n    namespace.Moves = Backbone.Collection.extend({\n        model: Move,\n        localStorage: new Store(\"moves\")\n    });\n});\n```\n\nStack trace (chromium):\n\n```\nUncaught TypeError: Object function (){return a.apply(this,arguments)} has no method 'find'\nj.c.each.c.forEach:9292/javascripts/vendor/underscore-min.js:9\nnamespace.RowView.Backbone.View.extend.render:9292/javascripts/views.js:30\nc.bind:9292/javascripts/vendor/underscore-min.js:16\nnamespace.AppView.Backbone.View.extend.add:9292/javascripts/views.js:72\nc.bind:9292/javascripts/vendor/underscore-min.js:16\nnamespace.AppView.Backbone.View.extend.render:9292/javascripts/views.js:66\nc.bind:9292/javascripts/vendor/underscore-min.js:16\nnamespace.AppView.Backbone.View.extend.initialize:9292/javascripts/views.js:60\ne.View:9292/javascripts/vendor/backbone-min.js:22\nr.d:9292/javascripts/vendor/backbone-min.js:26\n(anonymous function):9292/javascripts/views.js:77\nc.extend.ready:9292/javascripts/vendor/jquery-1.4.2.min.js:26\nL\n```\n",
    "comments_url": "https://api.github.com/repos/jashkenas/backbone/issues/90/comments",
    "author": "clyfe",
    "comments": [
      {
        "user": "clyfe",
        "created_at": "2010-11-23T19:51:07Z",
        "body": "Note that Model#markable gets called from an `_.template()` via `this.model.markable()`\n\n```\nnamespace.MoveView = Backbone.View.extend({\n    tagName:  \"td\",\n    template: _.template($('#move-template').html()),\n    initialize: function() {\n        _.bindAll(this, \"render\");\n    },\n    render: function() {\n        $(this.el).html(this.template(this.model.toJSON()));\n        return this;\n    }\n});\n\n\n<script type=\"text/html\" id=\"move-template\">\n\n    <%= console.log(this.model.cid) %>\n    <%= console.log(this.model.markable()) %>\n\n  <div\n    id=\"square-<%= i %>-<%= j %>\"\n    class=\"square square-row-<%= i %> square-column-<%= j %>\"\n    ><%= mark %></div>\n\n</script>\n```\n"
      },
      {
        "user": "jashkenas",
        "created_at": "2010-11-23T20:24:16Z",
        "body": "Looks like `Moves` doesn't actually have a `find` method defined. Right? Are you looking for `detect`?\n"
      },
      {
        "user": "clyfe",
        "created_at": "2010-11-24T09:41:51Z",
        "body": "Changing `find` with `detect` doesn't work either\n\n```\nUncaught TypeError: Object function (){return a.apply(this,arguments)} has no method 'detect'\n```\n\nThe thing is either the `namespace.Moves` from inside `Move#markable` is not the same with the later-on-defined `namespace.Moves`, in witch case this seems like a \"chicken and egg\" issue, either `namespace.Moves` is hidden behind some proxy function somewhere...\n"
      },
      {
        "user": "jashkenas",
        "created_at": "2010-11-24T13:14:19Z",
        "body": "Oh, of course. `namespace.Moves` is the collection class (the constructor function) -- not an instance of the collection. If you'd like to make an instance of it, you'll need:\n\n```\nnew namespace.Moves\n```\n"
      }
    ]
  },
  {
    "number": 58,
    "title": "Can't update model from within a change callback",
    "created_at": "2010-11-05T15:37:20Z",
    "closed_at": "2010-11-06T02:58:30Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/jashkenas/backbone/issues/58",
    "body": "I'm trying to figure out how to act on a changed select dropdown. My view renders multiple select controls and changing each one might trigger a change in subsequent ones (think \"Country\" -> \"City\" select sequence).\n\nProblem is, according to \"cautionary notes\" in the docs, \"change\", \"submit\", and \"reset\" events do not bubble in current versions of Internet Explorer. Which means I can't use the view's event delegation, I suppose.\n\nSo, I tried attaching my change handler directly to the select element:\n\n```\n.change(function(e) { currentView.model.set({selectedAttribute: $(this).val()}); })\n```\n\nThis doesn't work, because I end up in a render function that has \"this\" set to the model (?), not the view. The call stack is:\n\nmy view's render function (this is where I end up)\nbackbone.js:92\nbackbone.js:291\nbackbone.js:168\nmy .change() function\n\nSo it seems that changing the model triggers an immediate re-rendering of the view (which is fine), but I end up with this.model being undefined, because this points to my model.\n\nI'm surely doing something wrong, but any pointers appreciated.\n",
    "comments_url": "https://api.github.com/repos/jashkenas/backbone/issues/58/comments",
    "author": "jwr",
    "comments": [
      {
        "user": "jashkenas",
        "created_at": "2010-11-05T19:58:20Z",
        "body": "Give this a try:\n\n```\n.change(function(e) { \n  currentView.model.set({selectedAttribute: $(e.target).val()}); \n})\n```\n"
      },
      {
        "user": "jwr",
        "created_at": "2010-11-05T20:18:38Z",
        "body": "No, that doesn't change anything.\n\nPerhaps I haven't explained precisely what happens. What I get is:\n\"TypeError: Result of expression 'this.model' [undefined] is not an object.\"\n\nin my render function. Same view that has the select control and that defines the change() event handler.\n\nFrom what I understand, the change event fires for the select control, which causes the model to get updated, which causes the model's change event to fire, which causes the view's render function to get called. This is all fine. What I don't understand is why this.model is undefined within the render function. It is only undefined if render is triggered by the change event.\n\nPerhaps I'm doing something really stupid \u2014 but I can't figure out another way to have select controls that update the model (which should cause the view to change).\n"
      },
      {
        "user": "jashkenas",
        "created_at": "2010-11-05T20:24:37Z",
        "body": "Ahh, I'm sorry. Try adding this line to your `initialize` function (which will bind `render` to the current instance).\n\n```\n_.bindAll(this, 'render');\n```\n\nYou can add any other functions to that call, to ensure that their `this` is preserved. Take a look at the docs on Underscore's `bindAll` for the details.\n"
      },
      {
        "user": "jashkenas",
        "created_at": "2010-11-05T20:45:46Z",
        "body": "It depends on how you call it from within the event handler. If you're calling it like this:\n\n```\nbind(\"event\", model.render);\n```\n\n... you'll have to bind it in advance. If you're calling it like this:\n\n```\nbind(\"event\", function(){ model.render(); });\n```\n\n... you'll have no such problem.\n"
      }
    ]
  },
  {
    "number": 32,
    "title": "Is there a specific reason why filter/map/reject/etc don't return new Collections?",
    "created_at": "2010-10-19T19:53:46Z",
    "closed_at": "2010-10-20T03:01:15Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/jashkenas/backbone/issues/32",
    "body": "I would expect those methods to return new Collections, because generally when you map over something, you return a new type of that same something. For example, I would expect `stillAlive` to be a collection:\n\n```\nvar coll = new MyCollection([foo, bar, baz, quux]);\nvar stillAlive = coll.filter(function (o) { return o.get(\"HP\") > 0; });\n```\n\nIs this by design?\n\nAside: I really wish Github would make mailing lists or forums for projects, so that these types of issues wouldn't clog up the issues page...\n",
    "comments_url": "https://api.github.com/repos/jashkenas/backbone/issues/32/comments",
    "author": "fitzgen",
    "comments": [
      {
        "user": "jashkenas",
        "created_at": "2010-10-19T20:00:58Z",
        "body": "I figured that because the series of Underscore functions can return different types of things, it was more useful to return the naked array of filter'd, or reject'd models. And actually, those are the only methods that it would make sense to return a collection for. If you map a collection of Books:\n\n```\nvar titles = Books.map(function(book){ return book.get('title'); });\n```\n\nYou expect an array of strings, not a collection of models containing a single attribute.\n\nAnd finally, the Collection's constructor function might have some sort of important side effect or Ajax call it performs -- we can't just call it willy-nilly.\n"
      }
    ]
  },
  {
    "number": 22,
    "title": "App specific base classes",
    "created_at": "2010-10-18T19:21:49Z",
    "closed_at": "2010-10-19T02:29:28Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/jashkenas/backbone/issues/22",
    "body": "This question/problem is probably due to my complete deficiency in Javascript skills, but hopefully you will know the answer :) I want to create a base Model, that sets up the conventions for my application, and then create individual models from that base that simply overrides where needed. If I do this:\n\napp.view.MyBase = Backbone.Model.extend({ ..});\n\nWhat I want to do is this:\n\napp.view.NewModel = app.view.MyBase.extend({...});\n\nBut I get an error that .extend isn't a method on app.view.MyBase. Is there a simple way to achieve what I'm after? Thanks for your time. \n",
    "comments_url": "https://api.github.com/repos/jashkenas/backbone/issues/22/comments",
    "author": "PlasticLizard",
    "comments": [
      {
        "user": "jashkenas",
        "created_at": "2010-10-18T19:29:21Z",
        "body": "Because Backbone properly sets up the prototype chain, you should be able to extend subclasses of Model, View, and Collection as far as you see fit. If this isn't working, something screwy is going on. For example:\n\n```\nvar Base = Backbone.Model.extend({a: 1});\nvar Sub = Base.extend({});\nalert((new Sub).a);  // alerts \"1\".\n```\n\nHope that helps -- check for typos in your code.\n"
      }
    ]
  }
]