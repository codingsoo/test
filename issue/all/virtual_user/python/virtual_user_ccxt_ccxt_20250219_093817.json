[
  {
    "id": "https://github.com/ccxt/ccxt/issues/24949",
    "source": {
      "issue_number": 24949
    },
    "initial_question": {
      "title": "myokx.fetchOHCLV wrong candles ohcl",
      "body": "### Operating System\n\n_No response_\n\n### Programming Languages\n\n_No response_\n\n### CCXT Version\n\nlast\n\n### Description\n\nHi,\n\nI'm using the myokx exchange with the \"BTC/USD\" pair, I also use a 1d timeframe.\nBut the candles values are all the sames, I do not know why.... here is an extract of the result that I got:\n\n[1733097600000, 92000, 99000, 92000, 99000, 0.0002933],\n[1733184000000, 99001.2, 99001.2, 99001, 99001, 0.0001],\n[1733270400000, 99001, 99001, 99001, 99001, 0],\n[1733356800000, 99001, 99001, 99001, 99001, 0],\n[1733443200000, 99001, 99001, 99001, 99001, 0],\n[1733529600000, 99001, 99001, 99001, 99001, 0],\n[1733616000000, 99001, 99001, 99001, 99001, 0],\n[1733702400000, 99001.2, 99001.2, 99001.2, 99001.2, 0.00005],\n[1733788800000, 99001.2, 99001.2, 99001.2, 99001.2, 0],\n[1733875200000, 99001.2, 99001.2, 99001.2, 99001.2, 0],\n[1733961600000, 99001.2, 99001.2, 99001.2, 99001.2, 0],\n[1734048000000, 99001.2, 99001.2, 99001.2, 99001.2, 0],\n[1734134400000, 99001.2, 99001.2, 99001.2, 99001.2, 0],\n[1734220800000, 99001.2, 99001.2, 99001.2, 99001.2, 0],\n[1734307200000, 99001.2, 99001.2, 99001.2, 99001.2, 0],\n[1734393600000, 99001.2, 99001.2, 99001.2, 99001.2, 0],\n[1734480000000, 99001.2, 99001.2, 99001.2, 99001.2, 0],\n[1734566400000, 99001.2, 99001.2, 99001.2, 99001.2, 0],\n[1734652800000, 99001.2, 99001.2, 99001.2, 99001.2, 0],\n[1734739200000, 99001.2, 99001.2, 99001.2, 99001.2, 0],\n[1734825600000, 99001.2, 99001.2, 99001.2, 99001.2, 0],\n[1734912000000, 99001.2, 99001.2, 99001.2, 99001.2, 0],\n[1734998400000, 99001.2, 99001.2, 99001.2, 99001.2, 0],\n[1735084800000, 99001.2, 99001.2, 99001.2, 99001.2, 0],\n[1735171200000, 99001.2, 99001.2, 99001.2, 99001.2, 0],\n[1735257600000, 99001.2, 99001.2, 99001.2, 99001.2, 0],\n[1735344000000, 99001.2, 99001.2, 99001.2, 99001.2, 0],\n\n...\n\nYou see, it is a flat line !\n\nBTW, here I test in \"sandbox\" mode, but even the live mode is weird !\n\n### Code\n\n```\n      const symbol = 'BTC/USD';\n      const timeframe = '1d';\n      const since = 1719957600000;\n      const limit = 204;\n      return await exchange.fetchOHLCV(symbol, timeframe, since, limit);     \n\n```\n"
    },
    "satisfaction_conditions": [
      "API returns data for the requested time range"
    ],
    "created_at": "2025-01-19T20:08:43Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/24442",
    "source": {
      "issue_number": 24442
    },
    "initial_question": {
      "title": "Issue with auth on Paradex",
      "body": "### Operating System\r\n\r\nwidows\r\n\r\n### Programming Languages\r\n\r\nPython\r\n\r\n### CCXT Version\r\n\r\n4.3.35\r\n\r\n### Description\r\n\r\nParadex on ccxt uses privateKey to auth, create JWT token etc.\r\nSometimes the starknet privatekey can be 63 length (65 with \"0x\" prefix). I believe it can causes issues with ccxt code that expects an hexadecimal key : \"binascii.Error: Non-base16 digit found\" when trying to retrieve balance of the account.\r\n\r\nccxt\\async_support\\paradex.py\", line 914 :\r\n```\r\n    def sign_message(self, message, privateKey):\r\n        return self.sign_hash(self.hash_message(message), privateKey[-64:])\r\n```\r\nyou can see the [-64] that doesn't work with 65 len privatekeys\r\nI tried replacing \"0x\" by \"0x0\" to have a hexadecimal key but it leads to an error : ccxt.base.errors.BadRequest: paradex {\"error\":\"NOT_ONBOARDED\",\"message\":\"user has never called the /onboarding endpoint\"}\r\nwhile the paradex account already exists so the user should be already onboarded I guess.\r\n\r\nI don't understand everything of this but what I am almost sure is that I get a privateKey with a length of 65 and without any modifications, it may not be suited for the signature fonctions that expects a 66 length:\r\n\r\nccxt\\async_support\\paradex.py\"\r\n```\r\n    def sign_hash(self, hash, privateKey):\r\n        signature = self.ecdsa(hash[-64:], privateKey[-64:], 'secp256k1', None)\r\n        r = signature['r']\r\n        s = signature['s']\r\n        v = self.int_to_base16(self.sum(27, signature['v']))\r\n        return '0x' + r.rjust(64, '0') + s.rjust(64, '0') + v\r\n\r\n    def sign_message(self, message, privateKey):\r\n        return self.sign_hash(self.hash_message(message), privateKey[-64:])\r\n```\r\n\r\nthank you\r\n\r\n\r\n\r\n"
    },
    "satisfaction_conditions": [
      "Authentication succeeds using the correct private key type",
      "User successfully passes onboarding verification",
      "Signature generation completes successfully"
    ],
    "created_at": "2024-12-04T10:02:40Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/24373",
    "source": {
      "issue_number": 24373
    },
    "initial_question": {
      "title": "Error setting margin type and leverage setting",
      "body": "### Operating System\n\nWin10\n\n### Programming Languages\n\nPython\n\n### CCXT Version\n\n4.4.33\n\n### Description\n\nError setting margin type and leverage setting 1- 'binance' object has no attribute 'fapiPrivate_post_margintype' 2- 'binance' object has no attribute 'fapiPrivate_post_leverage'\n\n### Code\n\n```# Setting margin\r\ndef set_margin_type(symbol, margin_type='ISOLATED'):\r\n    try:\r\n        market = binance.market(symbol)\r\n        params = {\r\n            'symbol': market['id'],\r\n            'marginType': margin_type,\r\n        }\r\n        response = binance.fapiPrivate_post_margintype(params)\r\n        print(f\"Margin type for {symbol} set at {margin_type}\")\r\n    except Exception as e:\r\n        print(f\"Error when setting margin type: {e}\")\r\n\r\n# leverage setting\r\ndef set_leverage(symbol, leverage):\r\n    try:\r\n        market = binance.market(symbol)\r\n        params = {\r\n            'symbol': market['id'],\r\n            'leverage': leverage,\r\n        }\r\n        response = binance.fapiPrivate_post_leverage(params)\r\n        print(f\"Leverage for {symbol} set at {leverage}x\")\r\n    except Exception as e:\r\n        print(f\"Error leverage setting : {e}\")\r\n\r\n# TESTS\r\ndef run_tests():\r\n    sync_time()\r\n    test_balance()  # Balance check\r\n    fetch_ohlcv('ETH/USDT', '1H')  \r\n    test_order('ETH/USDT', 0.05) \r\n    set_margin_type('ETH/USDT', 'ISOLATED')  \r\n    set_leverage('ETH/USDT', 10)  \r\n\r\nif __name__ == '__main__':\r\n    run_tests()\r\n\u2002\u2002\r\n\r\n```\r\n"
    },
    "satisfaction_conditions": [
      "The code must handle futures-specific endpoints rather than spot trading endpoints",
      "The code must properly handle API errors and exceptions"
    ],
    "created_at": "2024-11-25T23:33:43Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/24358",
    "source": {
      "issue_number": 24358
    },
    "initial_question": {
      "title": "bybit perpetual contract unable to fetch ohlcv",
      "body": "### Operating System\n\nWindows\n\n### Programming Languages\n\nPython\n\n### CCXT Version\n\n_No response_\n\n### Description\n\nUnable to retrieve ohlcv for ticker in linear but no spot.\r\n\r\nticker sample: MAJORUSDT , USUALUSDT\r\nBoth ticker was able to extract from exchange.fetch_tickers but getting error \"ccxt.base.errors.BadSymbol: bybit does not have market symbol MAJORUSDT\"\r\n\n\n### Code\n\n```python\r\nimport ccxt\r\nimport pprint\r\n\r\n# Initialize Bybit exchange\r\nexchange = ccxt.bybit({\r\n    'enableRateLimit': True,\r\n})\r\n\r\n# Function to get the symbol list ending with USDT\r\ndef get_symbol_list():\r\n    try:\r\n        # Fetch all tickers with category 'linear'\r\n        tickers = exchange.fetch_tickers(params={'category': 'linear'})\r\n\r\n        processed_symbols = [symbol for symbol in tickers.keys() if symbol.endswith(\"USDT\")]\r\n\r\n        return processed_symbols\r\n\r\n    except ccxt.NetworkError as e:\r\n        print(f\"Network error: {e}\")\r\n    except ccxt.ExchangeError as e:\r\n        print(f\"Exchange error: {e}\")\r\n    except Exception as e:\r\n        print(f\"An error occurred: {e}\")\r\n\r\n# Get the list of linear symbols with USDT\r\nsymbols = get_symbol_list()\r\ndef get_kline_data(symbol, interval='1m', limit=1):\r\n    exchange.load_markets()\r\n    return exchange.fetch_ohlcv(symbol, timeframe=interval, limit=limit,params={'category': 'linear'})\r\nfor symbol in symbols:\r\n    pprint.pprint(get_kline_data(symbol))\r\n```"
    },
    "satisfaction_conditions": [
      "Market data is successfully retrieved for perpetual contracts using correct symbol format",
      "Exchange market data is current and properly cached",
      "CCXT library is at a version that supports the required functionality"
    ],
    "created_at": "2024-11-24T13:30:57Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/24323",
    "source": {
      "issue_number": 24323
    },
    "initial_question": {
      "title": "Futures disabled for Spanish accounts",
      "body": "### Operating System\n\n_No response_\n\n### Programming Languages\n\n_No response_\n\n### CCXT Version\n\n_No response_\n\n### Description\n\nIt seems that futures are not allowed anymore in Spain, so I can\u00b4t access to the fapi anymore. It is possible to configure ccxt to use sapi instead?\n\n### Code\n\n```\r\n\u2002\u2002\r\n\r\n```\r\n"
    },
    "satisfaction_conditions": [
      "Trading API requests must successfully complete without geographical restrictions",
      "System must successfully retrieve trade history for permitted market types",
      "Trading interface must respect regional regulatory restrictions",
      "API endpoint selection must automatically adapt based on the market type being traded"
    ],
    "created_at": "2024-11-20T19:35:09Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/23797",
    "source": {
      "issue_number": 23797
    },
    "initial_question": {
      "title": "HTX watchTicker does not return bid and ask",
      "body": "### Operating System\n\n_No response_\n\n### Programming Languages\n\nJavaScript\n\n### CCXT Version\n\n4.3.91\n\n### Description\n\nHTX watchTicker(\"\") does not return bid and ask. Returns undefined.\n\n### Code\n\n```\r\n\u2002\u2002\r\n\r\n```\r\n"
    },
    "satisfaction_conditions": [
      "User understands that bid/ask data unavailability is due to API limitations",
      "Response demonstrates actual API output showing undefined bid/ask values",
      "Response shows complete ticker data structure including available fields",
      "Response includes raw API data in 'info' field for verification"
    ],
    "created_at": "2024-09-24T07:40:03Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/23650",
    "source": {
      "issue_number": 23650
    },
    "initial_question": {
      "title": "Gateio futures does not work with CCXT Pro",
      "body": "### Operating System\n\nWindows 11\n\n### Programming Languages\n\nPHP\n\n### CCXT Version\n\n4.3.96\n\n### Description\n\nHello! When I use 'defaultType' => 'swap' in the constructor parameters and then use the create_order_ws method, I get an open position on spot market instead of futures. Is this a bug? Thank you.\n\n### Code\n\n```\r\n$config = [\r\n    'apiKey' => $this->key,\r\n    'secret' => $this->secret,\r\n    'options' => [\r\n        'defaultType' => 'swap' // for perpetual futures\r\n    ],\r\n];\r\n$this->gateWs = new \\ccxt\\pro\\gateio($config);\r\n\r\n/* some other code*/\r\n\r\n$data = yield $this->gateWs->create_order_ws(\r\n    'XRP/USDT',\r\n    'market',\r\n    'buy',\r\n    10,\r\n    $this->tickers['XRP']\r\n); // This opens an order on the spot market, not futures\r\n\r\n```\r\n"
    },
    "satisfaction_conditions": [
      "Trading operations target the correct market type (futures/swap instead of spot)",
      "Market symbol format correctly identifies futures/swap markets",
      "WebSocket order creation successfully completes without type mismatch errors"
    ],
    "created_at": "2024-09-05T22:51:29Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/23610",
    "source": {
      "issue_number": 23610
    },
    "initial_question": {
      "title": "bybit market transaction fee is wrong",
      "body": "### Operating System\n\nwindows 11\n\n### Programming Languages\n\nJavaScript\n\n### CCXT Version\n\n4.3.93\n\n### Description\n\ntaker fee from exchange.markets[symbol] returns 0.006 while from bybit it should be 0.0550 % or 0.0440 % (after discount).\r\n\r\nsymbol is of any linear perpetual.\r\n\n\n### Code\n\n```\r\n\u2002\u2002\r\n\r\n```\r\n"
    },
    "satisfaction_conditions": [
      "Accurate trading fee information is retrieved",
      "User-specific fee rates are obtained",
      "Fee information is retrieved via appropriate API endpoint"
    ],
    "created_at": "2024-09-01T11:09:13Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/23393",
    "source": {
      "issue_number": 23393
    },
    "initial_question": {
      "title": "Binance fetchLedger () supports contract wallets only",
      "body": "### Operating System\n\nWindows\n\n### Programming Languages\n\n_No response_\n\n### CCXT Version\n\n4.3.79\n\n### Description\n\nUsing C#, since is timestamp\r\n\r\nCalling\r\n```\r\nDictionary<string, object> paramEx = new Dictionary<string, object>\r\n{ \r\n    { \"paginate\", true }\r\n};\r\nledger = await exchange.fetchLedger(null, since, null, paramEx) as List<object>\r\n```\r\nI receive\r\nExchangeErrorbinance fetchLedger() supports contract wallets only\r\n\r\nNeither in Binance nor in ccxt docs I was able to find what that means or what contract wallets would be. I would require a solution to pull ALL kinds of movements from Binance including funding, deposits, withdrawals and trades. Thank you !\n\n### Code\n\n```\r\nDictionary<string, object> paramEx = new Dictionary<string, object>\r\n{ \r\n    { \"paginate\", true }\r\n};\r\nledger = await exchange.fetchLedger(null, since, null, paramEx) as List<object>\r\n```\r\n"
    },
    "satisfaction_conditions": [
      "All types of wallet transactions must be retrievable",
      "Alternative API methods must be used instead of fetchLedger()"
    ],
    "created_at": "2024-08-12T09:28:21Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/23352",
    "source": {
      "issue_number": 23352
    },
    "initial_question": {
      "title": "load_markets().keys() differ from fetch_tickers()",
      "body": "### Operating System\n\nWin 10\n\n### Programming Languages\n\nPython\n\n### CCXT Version\n\n4.3.73\n\n### Description\n\nI expect the code below to produce the same numbers (2542/2542), but it actually prints (2542/437). Why is this happening? It\u2019s particularly strange because the markets from load_markets are currently trading, yet fetch_tickers does not display them. This function (fetch_tickers) should be used for active tickers.\n\n### Code\n\n```\r\nasync def debug():\r\n    exchange = ccxt.bybit({logging_data})\r\n    markets = await exchange.load_markets(True)\r\n    tickers = await exchange.fetch_tickers()\r\n    print(len(markets.keys()))\r\n    print(len(tickers))\r\n    await exchange.close()\r\nasyncio.run(debug())\r\n\r\n```\r\nresult\r\n```\r\n2542\r\n437\r\n```"
    },
    "satisfaction_conditions": [
      "All market types must be retrievable from the exchange",
      "The solution must handle different market type parameters",
      "Data retrieval must be compatible with async operations"
    ],
    "created_at": "2024-08-07T13:52:52Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/23323",
    "source": {
      "issue_number": 23323
    },
    "initial_question": {
      "title": "kucoin Invalid KC-API-TIMESTAMP",
      "body": "### Operating System\r\n\r\n10\r\n\r\n### Programming Languages\r\n\r\nPHP\r\n\r\n### CCXT Version\r\n\r\n4.3.73\r\n\r\n### Description\r\n\r\nSince today an error started to appear when requesting a balance from KuCoin exchange:\r\nccxt\\InvalidNonce\r\nkucoin Invalid KC-API-TIMESTAMP\r\n\r\nThe method `$exchange->load_time_difference();` does not help\r\n\r\n### Code\r\n\r\n```PHP\r\n$exchangeClass = \"\\\\ccxt\\\\kucoin\";\r\n$exchange      = new $exchangeClass([\r\n  'apiKey'   => $account['api_key'],\r\n  'secret'   => $account['api_secret'],\r\n  'password' => $account['api_password'],\r\n]);\r\n\r\n$timeDifference = $exchange->load_time_difference();\r\n// print_r($timeDifference); // returns: 5528\r\n\r\n$balance = $exchange->fetchBalance([\r\n  'type' => 'trade',\r\n]);\r\nprint_r($balance);\r\n// ccxt\\InvalidNonce\r\n// kucoin Invalid KC-API-TIMESTAMP\r\n```\r\n"
    },
    "satisfaction_conditions": [
      "System clock must be accurately synchronized with UTC time",
      "Time difference between local system and exchange server must be minimal",
      "API requests must complete successfully without timestamp validation errors",
      "Balance data must be retrievable from the exchange"
    ],
    "created_at": "2024-08-04T13:19:26Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/23034",
    "source": {
      "issue_number": 23034
    },
    "initial_question": {
      "title": "dont understand the error message and what to do with / please help in details",
      "body": "### Operating System\n\nWindows 11\n\n### Programming Languages\n\n_No response_\n\n### CCXT Version\n\n4.1.78.\n\n### Description\n\nHello Team!\r\n\r\nI use orders, limits, markets, stop limits, stop markets as well.\r\nSomehow I have issue with - not all the time, but sometimes - with simple market order.\r\n\r\nThe order structure is this:\r\n\r\nexchange.createOrder(symbol, 'market', order_side, amount, params={'positionSide': pos_side})\r\n\r\nAll the referenced variables have proper values that match with exchange requirements.\r\n\r\nThe error message I receive is this:\r\n  File \"C:\\Users\\Gabor\\PycharmProjects\\ccxt\\venv\\lib\\site-packages\\ccxt\\binance.py\", line 4279, in create_order\r\n    request = self.create_order_request(symbol, type, side, amount, price, params)\r\n  File \"C:\\Users\\Gabor\\PycharmProjects\\ccxt\\venv\\lib\\site-packages\\ccxt\\binance.py\", line 4457, in create_order_request\r\n    request['quantity'] = self.amount_to_precision(symbol, amount)\r\n  File \"C:\\Users\\Gabor\\PycharmProjects\\ccxt\\venv\\lib\\site-packages\\ccxt\\base\\exchange.py\", line 3950, in amount_to_precision\r\n    raise InvalidOrder(self.id + ' amount of ' + market['symbol'] + ' must be greater than minimum amount precision of ' + self.number_to_string(market['precision']['amount']))\r\nccxt.base.errors.InvalidOrder: binanceusdm amount of SOL/USDC:USDC must be greater than minimum amount precision of 2\r\n\r\nI use amount precision with this code:\r\ndef adjust_amount(symbol, amount):\r\n    exchange.load_markets()\r\n    symbol_formatted = symbol.replace(\"USDC\", \"/USDC:USDC\")\r\n    market = exchange.markets[symbol_formatted]\r\n    amount_precision = market['precision']['amount']\r\n    # Calculate the power of 10 for the required precision\r\n    power_of_ten = 10 ** amount_precision\r\n    # Adjust the amount using ceil and power of 10\r\n    adjusted_amount = math.ceil(amount * power_of_ten) / power_of_ten\r\n    return adjusted_amount\r\n\r\nCan you please help me to understand what I do wrong?\r\nActually I dont understand the problem exactly.\r\nIf you can give me detailed explanation what is the background of the issue, like the concept behind it, I would appreciate so much!\r\n\r\nThank you!\r\n\r\nKind regards,\r\nGabor\n\n### Code\n\nexchange.createOrder(symbol, 'market', order_side, amount, params={'positionSide': pos_side})\r\n\r\n\r\ndef adjust_amount(symbol, amount):\r\n    exchange.load_markets()\r\n    symbol_formatted = symbol.replace(\"USDC\", \"/USDC:USDC\")\r\n    market = exchange.markets[symbol_formatted]\r\n    amount_precision = market['precision']['amount']\r\n    # Calculate the power of 10 for the required precision\r\n    power_of_ten = 10 ** amount_precision\r\n    # Adjust the amount using ceil and power of 10\r\n    adjusted_amount = math.ceil(amount * power_of_ten) / power_of_ten\r\n    return adjusted_amount"
    },
    "satisfaction_conditions": [
      "Symbol format must match exchange's expected format",
      "Market data must be properly loaded before order creation"
    ],
    "created_at": "2024-07-09T13:50:36Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/22930",
    "source": {
      "issue_number": 22930
    },
    "initial_question": {
      "title": "Retrieving open orders from different markets",
      "body": "### Operating System\r\n\r\nwindows 11\r\n\r\n### Programming Languages\r\n\r\n_No response_\r\n\r\n### CCXT Version\r\n\r\nlast\r\n\r\n### Description\r\n\r\nHello! i'm trying to get open orders from several exchanges, I'm using fetchOpenOrders method. Without ticker it works correctly on Bybit, but on Binance ccxt returns such error: _binance fetchOpenOrders\\(\\) WARNING: fetching open orders without specifying a symbol is rate-limited to one call per 1525 seconds. Do not call self method frequently to avoid ban. Set binance.options[\"warnOnFetchOpenOrdersWithoutSymbol\"\\] \\= False to suppress self warning message._ \r\nOn swap market it is not a problem, because I can get currently opened positions tickers and retrieve open stop orders,\r\n```\r\nfor ticker in open_positions:\r\n    await update_open_stop_orders(user, market, ticker)\r\n```\r\n while on spot such decision for limit sell orders obviously doesnt work. How is it better to handle that issue?\r\n\r\n"
    },
    "satisfaction_conditions": [
      "Open orders must be successfully retrieved without triggering rate limit bans",
      "System must handle different rate limit requirements for spot vs futures markets",
      "Solution must track which symbols have open orders",
      "Rate limit quota consumption must be optimized"
    ],
    "created_at": "2024-06-29T12:42:03Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/22871",
    "source": {
      "issue_number": 22871
    },
    "initial_question": {
      "title": "What is the best way to re-connect",
      "body": "### Operating System\n\nlinux\n\n### Programming Languages\n\nPython\n\n### CCXT Version\n\nAll\n\n### Description\n\nWhen I have any error in a webscoket stream or any forever loop what is the best practice to re-connect with exchange, for eg a network error.\r\nRight Now I am doing this: closing in case of exception and again instantiation ccxt.okx for eg.\n\n### Code\n\n```\r\n\u2002\u2002    async def stream_balance_update(self, symbol,cb):\r\n        while True:\r\n            bl = None\r\n            try:\r\n                bal = await self.exch.watch_balance(params={\"extraParams\": '{\"updateInterval\": 0}'})\r\n                bl = {}\r\n                for d in list(bal[\"free\"].keys()):\r\n                    d = Balance().load(d, bal)\r\n                    bl[d.asset] = d\r\n                # logger.info(bl)\r\n                await cb(bl) if cb else None\r\n            except Exception as e:\r\n                logger.info(type(e).__name__, e)\r\n                logger.info('stream_account_update:', bal)\r\n                logger.info(traceback.format_exc())\r\n                await self.exch.close()\r\n                self.connect()\r\n\r\n    def connect(self):\r\n        if self.exchange_name == 'okx':\r\n            self.exch = ccxt.okx({\r\n                'enableRateLimit': True,\r\n                'logger': None,\r\n                'apiKey': self.api_key,\r\n                'secret': self.secret,\r\n                \"password\": self.passphrase,\r\n            })\r\n        else:\r\n            raise Exception('Exchange not supported')\r\n\r\n\r\n```\r\n"
    },
    "satisfaction_conditions": [
      "Websocket connection automatically recovers after errors",
      "Existing resources are properly cleaned up before reconnection",
      "Continuous data stream is maintained"
    ],
    "created_at": "2024-06-23T09:55:43Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/22779",
    "source": {
      "issue_number": 22779
    },
    "initial_question": {
      "title": "C# WatchOrders Hyperliquid Subscriptions",
      "body": "### Operating System\r\n\r\nUbuntu 22.04\r\n\r\n### Programming Languages\r\n\r\n_No response_\r\n\r\n### CCXT Version\r\n\r\n4.3.42\r\n\r\n### Description\r\n \r\nNone of following code results in order status being received for Hyperliquid. I am using C#. I am providing walletAddress to exchange in parameters of exchange object. Has this function been tested? Does it work properly? May there be something that I am missing?\r\n\r\n### Code\r\n\r\n```\r\n\u2002\u2002var ordersTask = this.exchange.WatchOrders();\r\n   ordersTask.Wait();\r\n   Logger.Debug($\"Orders received: {ordersTask.Result.Count()}.\");\r\n\r\n   var ordersTask = this.exchange.WatchOrders(\"SOL/USDC:USDC\");\r\n   ordersTask.Wait();\r\n   Logger.Debug($\"Orders received: {ordersTask.Result.Count()}.\");\r\n\r\n\r\n```\r\n"
    },
    "satisfaction_conditions": [
      "The WebSocket connection successfully receives order status updates",
      "The system correctly identifies the wallet address for order monitoring",
      "Order updates contain required trading information",
      "The subscription to order updates remains active",
      "The system properly deserializes received order data"
    ],
    "created_at": "2024-06-11T08:33:28Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/22447",
    "source": {
      "issue_number": 22447
    },
    "initial_question": {
      "title": "Cancelling orders does not work on OKX",
      "body": "### Operating System\r\n\r\nMac OS Sonoma 14.1.1\r\n\r\n### Programming Languages\r\n\r\nPython\r\n\r\n### CCXT Version\r\n\r\n4.3.18\r\n\r\n### Description\r\n\r\nUsing the test code to open and cancel an order, it leaves an order uncancelled. Thank you for your help ahead of time.\r\n\r\n### Code\r\n\r\n```\r\n\u2002\u2002\r\ndef close_positions():\r\n    # Fetch open orders\r\n    open_orders = exchange.fetch_open_orders()\r\n\r\n    # Cancel all open orders\r\n    for order in open_orders:\r\n        exchange.cancel_order(order['id'], order['symbol'])\r\n\r\n\r\ndef test_orders():\r\n    order = exchange.create_order(symbol= symbol, type = \"market\", side = \"buy\", amount=10.0)\r\n    time.sleep(10)\r\n    #exchange.cancel_order(order['id'], symbol)\r\n    close_positions()\r\n    print(\"test complete\")\r\n\r\ntest_orders()\r\n```\r\n"
    },
    "satisfaction_conditions": [
      "Order status verification must occur after appropriate delay"
    ],
    "created_at": "2024-05-09T14:17:59Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/22179",
    "source": {
      "issue_number": 22179
    },
    "initial_question": {
      "title": "Are users meant to update frequently?",
      "body": "\r\n\r\nThere is a mapping between CCXT symbols and particular exchanges and it is not clear to me whether this mapping is updated through hardcoding in the library code or dynamically though some server?\r\n\r\nIf things are hardcoded in library, does this mean we are meant to stay up to date every day or so?\r\n\r\nThanks,\r\n\r\n\r\n"
    },
    "satisfaction_conditions": [
      "Market symbol information is accessible and current",
      "Symbol mapping updates occur automatically during operation",
      "Library updates are beneficial but not mandatory for symbol mapping",
      "Market information is retrieved per-exchange"
    ],
    "created_at": "2024-04-16T22:41:13Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/21862",
    "source": {
      "issue_number": 21862
    },
    "initial_question": {
      "title": "ClosedOrders does not work on Binance Swap - ExchangeError: binance {\"code\":-4166,\"msg\":\"Search window is restricted to recent 90 days only.\"}",
      "body": "### Operating System\r\n\r\n_No response_\r\n\r\n### Programming Languages\r\n\r\n_No response_\r\n\r\n### CCXT Version\r\n\r\n4.2.79 \r\n\r\n### Description\r\n\r\nTry to load closed orders but doesn't work for me\r\n\r\n### Code\r\n\r\n```\r\nfetchCanceledAndClosedOrders('FET/USDT:USDT', 1705857391, 10)\r\nor\r\nfetchClosedOrders('FET/USDT:USDT', 1705857391, 10)\r\n\r\nbut SPOT pair \r\nfetchClosedOrders('FET/USDT', 1705857391, 10)\r\ndoes work\r\n\r\n```\r\n"
    },
    "satisfaction_conditions": [
      "Different handling for SPOT vs SWAP market types"
    ],
    "created_at": "2024-03-21T17:19:33Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/21595",
    "source": {
      "issue_number": 21595
    },
    "initial_question": {
      "title": " calculate_fee() missing 1 required positional argument: 'self'",
      "body": "### Operating System\n\nubuntu 20.04\n\n### Programming Languages\n\nPython\n\n### CCXT Version\n\n4.2.48\n\n### Description\n\nExample to reproduce : \r\n\r\nTraceback (most recent call last):\r\n  File \"/home/localuser/calculation.py\", line 30, in <module>\r\n    returned=ccxt.binance.calculate_fee(symbol=symbol, type=type, side=side,\r\nTypeError: calculate_fee() missing 1 required positional argument: 'self'\r\n\n\n### Code\n\n```\r\n\u2002exchange = ccxt.binance({\r\n    \"apiKey\": API_KEY,\r\n    \"secret\": API_SECRET\r\n})\r\n\r\nexchange.load_markets()\r\n\r\n\r\n#BUY BUY SELL\r\nsymbol = 'ETH/BTC'\r\ntype = 'limit'\r\nside = 'buy'\r\namount=0.1\r\nprice=0.05704\r\ntotal=float(amount*price)\r\n\r\nreturned=ccxt.binance.calculate_fee(symbol=symbol, type=type, side=side, amount=amount, price=price)\r\nprint(returned)\u2002\r\n\r\n```\r\n"
    },
    "satisfaction_conditions": [
      "All required fee calculation parameters must be provided",
      "Function returns valid fee calculation data",
      "Exchange markets must be loaded before fee calculation"
    ],
    "created_at": "2024-03-07T18:33:35Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/21290",
    "source": {
      "issue_number": 21290
    },
    "initial_question": {
      "title": "How to update pair list for specific exchange ?",
      "body": "### Operating System\r\n\r\nubuntu 20.04\r\n\r\n### Programming Languages\r\n\r\nPython\r\n\r\n### CCXT Version\r\n\r\nccxt-4.2.47\r\n\r\n### Description\r\n\r\nHi all,\r\n\r\nI'm looking for how to update the pair available on spot market for binance exchange : \r\n\r\nCCXT trying to post an order on : XMR/ETH,XMR/BTC,PAXG/BNB or these pair are not available on binance spot market\r\n\r\nHow can i update the available pair ?\r\n\r\nin my below example :  **'spot': True,** its wrong, binance deleted XMR from market list\r\n\r\nThanks\r\n\r\n### Code\r\n\r\n```py\r\nexchange.load_markets()\r\nprint(exchange.markets['XMR/ETH'])\r\n\u2002\r\n{'id': 'XMRETH', 'lowercaseId': 'xmreth', 'symbol': 'XMR/ETH', 'base': 'XMR', 'quote': 'ETH', 'settle': None, 'baseId': 'XMR', 'quoteId': 'ETH', 'settleId': None, 'type': 'spot', 'spot': True, 'margin': False, 'swap': False, 'future': False, 'option': False, 'index': None, 'active': False, 'contract': False, 'linear': None, 'inverse': None, 'subType': None, 'taker': 0.001, 'maker': 0.001, 'contractSize': None, 'expiry': None, 'expiryDatetime': None, 'strike': None, 'optionType': None, 'precision': {'amount': 3, 'price': 5, 'cost': None, 'base': 8, 'quote': 8}, 'limits': {'leverage': {'min': None, 'max': None}, 'amount': {'min': 0.001, 'max': 9000000.0}, 'price': {'min': 1e-05, 'max': 1000.0}, 'cost': {'min': 0.001, 'max': 9000000.0}, 'market': {'min': 0.0, 'max': 225.56396694}}, 'created': None, 'info': {'symbol': 'XMRETH', 'status': 'BREAK', 'baseAsset': 'XMR', 'baseAssetPrecision': '8', 'quoteAsset': 'ETH', 'quotePrecision': '8', 'quoteAssetPrecision': '8', 'baseCommissionPrecision': '8', 'quoteCommissionPrecision': '8', 'orderTypes': ['LIMIT', 'LIMIT_MAKER', 'MARKET', 'STOP_LOSS_LIMIT', 'TAKE_PROFIT_LIMIT'], 'icebergAllowed': True, 'ocoAllowed': True, 'quoteOrderQtyMarketAllowed': True, 'allowTrailingStop': True, 'cancelReplaceAllowed': True, 'isSpotTradingAllowed': True, 'isMarginTradingAllowed': False, 'filters': [{'filterType': 'PRICE_FILTER', 'minPrice': '0.00001000', 'maxPrice': '1000.00000000', 'tickSize': '0.00001000'}, {'filterType': 'LOT_SIZE', 'minQty': '0.00100000', 'maxQty': '9000000.00000000', 'stepSize': '0.00100000'}, {'filterType': 'ICEBERG_PARTS', 'limit': '10'}, {'filterType': 'MARKET_LOT_SIZE', 'minQty': '0.00000000', 'maxQty': '225.56396694', 'stepSize': '0.00000000'}, {'filterType': 'TRAILING_DELTA', 'minTrailingAboveDelta': '10', 'maxTrailingAboveDelta': '2000', 'minTrailingBelowDelta': '10', 'maxTrailingBelowDelta': '2000'}, {'filterType': 'PERCENT_PRICE_BY_SIDE', 'bidMultiplierUp': '5', 'bidMultiplierDown': '0.2', 'askMultiplierUp': '5', 'askMultiplierDown': '0.2', 'avgPriceMins': '5'}, {'filterType': 'NOTIONAL', 'minNotional': '0.00100000', 'applyMinToMarket': True, 'maxNotional': '9000000.00000000', 'applyMaxToMarket': False, 'avgPriceMins': '5'}, {'filterType': 'MAX_NUM_ORDERS', 'maxNumOrders': '200'}, {'filterType': 'MAX_NUM_ALGO_ORDERS', 'maxNumAlgoOrders': '5'}], 'permissions': ['SPOT', 'TRD_GRP_015', 'TRD_GRP_016', 'TRD_GRP_023', 'TRD_GRP_024', 'TRD_GRP_025'], 'defaultSelfTradePreventionMode': 'EXPIRE_MAKER', 'allowedSelfTradePreventionModes': ['EXPIRE_TAKER', 'EXPIRE_MAKER', 'EXPIRE_BOTH']}, 'percentage': True, 'feeSide': 'get', 'tierBased': False}\r\n\u2002\r\n\r\n```\r\n"
    },
    "satisfaction_conditions": [
      "Market data must reflect current trading status",
      "Trading status must be determinable for any given pair",
      "Market data must be refreshable to show current state",
      "System must distinguish between listed pairs and tradeable pairs"
    ],
    "created_at": "2024-02-20T09:25:47Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/20727",
    "source": {
      "issue_number": 20727
    },
    "initial_question": {
      "title": "Bitrue exchange market order does not return details of completed order",
      "body": "### Operating System\n\nMacOS\n\n### Programming Languages\n\nPython\n\n### CCXT Version\n\n4.1.84\n\n### Description\n\nBitrue Exchange market order successfully places order and fulfils the order but does not return the completed order details.  the return object states the order status=open and amost of the other fields/attributes are null.\n\n### Code\n\n```\r\n\u2002\u2002order_buy = exchange.create_market_buy_order('symbol, amount, {\"newClientOrderId\": clientOrderId})\r\n\r\n```\r\n"
    },
    "satisfaction_conditions": [
      "Complete order details must be retrievable after market order placement",
      "System must handle exchange-specific response variations"
    ],
    "created_at": "2024-01-08T15:45:21Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/20372",
    "source": {
      "issue_number": 20372
    },
    "initial_question": {
      "title": "fetch_bids_asks not working for Bitrue exchange",
      "body": "### Operating System\n\nMacOS\n\n### Programming Languages\n\nPython\n\n### CCXT Version\n\n4.1.83\n\n### Description\n\nThe executing the function call fetch_bids_asks it is throwing an exception error.\r\n\r\nException has occurred: BadSymbol       (note: full exception trace is shown but execution is paused at: _run_module_as_main)\r\nbitrue does not have market symbol W\r\n  File \"/python3.11/site-packages/ccxt/base/exchange.py\", line 3905, in market\r\n    raise BadSymbol(self.id + ' does not have market symbol ' + symbol)\r\n  File \"/python3.11/site-packages/ccxt/base/exchange.py\", line 2979, in market_symbols\r\n    market = self.market(symbols[i])\r\n             ^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/3.11.7/lib/python3.11/site-packages/ccxt/bitrue.py\", line 1419, in fetch_bids_asks\r\n    symbols = self.market_symbols(symbols, None, False)\r\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/trader_bot/trader_bot.py\", line 53, in main\r\n    bids_asks = exchange.fetch_bids_asks(\"WTK/USDT\")\r\n                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n### Code\n\n# Initialise the ccxt exchange for bitrue\r\n  exchange = ccxt.bitrue({\r\n    \"apiKey\": bitrue_key,\r\n    \"secret\": bitrue_secret\r\n  })\r\n\r\n#Get bids and asks\r\n    bids_asks = exchange.fetch_bids_asks(\"WTK/USDT\")\r\n"
    },
    "satisfaction_conditions": [
      "The fetch_bids_asks function must receive symbols as a list/array parameter",
      "The trading pair symbol must be valid and available on the Bitrue exchange",
      "The function must successfully return the latest bid/ask data",
      "For multiple price levels of bids/asks, a different API method (fetchOrderBook) must be used"
    ],
    "created_at": "2023-12-14T10:20:29Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/20243",
    "source": {
      "issue_number": 20243
    },
    "initial_question": {
      "title": "Phemex hedge mode wont let me place a market order",
      "body": "### Operating System\n\nWindows 11\n\n### Programming Languages\n\nPython\n\n### CCXT Version\n\n4.1.75\n\n### Description\n\nEverytime i run the the code i get this error \r\n\r\n**Error placing order: phemex {\"code\":20004,\"msg\":\"TE_ERR_INCONSISTENT_POS_MODE\",\"data\":null}**\n\n### Code\n\n```\r\nexchange = ccxt.phemex({\r\n    'apiKey': api_key,\r\n    'secret': api_secret,\r\n    'enableRateLimit': True,\r\n})\r\n\r\nsymbol1 = 'BTCUSDT'\r\nexchange.set_position_mode(True, symbol1) # set pos mode to hedge\r\norder = exchange.create_order(symbol1,'market','sell',0.001)\r\n\r\n\r\n\r\n\r\n\r\n```\r\n"
    },
    "satisfaction_conditions": [
      "Order placement succeeds in hedge mode without position mode errors",
      "Position side is properly specified for hedged orders",
      "Exchange API parameters are properly configured for hedge mode operation",
      "Market order functionality remains accessible in hedge mode"
    ],
    "created_at": "2023-12-05T13:16:42Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/19740",
    "source": {
      "issue_number": 19740
    },
    "initial_question": {
      "title": "Clarification on gate and gateio identifiers for Gate.io exchange",
      "body": "### Operating System\r\n\r\nUbuntu\r\n\r\n### Programming Languages\r\n\r\nJS\r\n\r\n### CCXT Version\r\n\r\n^4.1.13\r\n\r\n### Description\r\n\r\nHello CCXT team and community,\r\n\r\nI have been working with the CCXT library and noticed that there are two identifiers, `gate` and `gateio`, that both seem to refer to the Gate.io exchange. I am able to interact with the exchange using either identifier, and was wondering if there is a preferred or more accurate identifier to use when interacting with Gate.io through CCXT.\r\n\r\nCould you please clarify the difference between `gate` and `gateio`, if any, and advise on which identifier is recommended for use? Are there any particular considerations or functionalities that are exclusive to one identifier over the other?\r\n\r\nThank you in advance for your assistance and clarification on this matter.\r\n\r\nBest regards\r\n\r\n\r\n### Code\r\n\r\n```\r\n\u2002\u2002\r\n\r\n```\r\n"
    },
    "satisfaction_conditions": [
      "Clarification that both identifiers are functionally equivalent",
      "Confirmation that either identifier can be used interchangeably",
      "Explanation of the relationship between the identifiers"
    ],
    "created_at": "2023-10-30T13:49:16Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/19666",
    "source": {
      "issue_number": 19666
    },
    "initial_question": {
      "title": "Bitmex fetch positions doesn't show information anymore",
      "body": "### Operating System\n\nWindows 10\n\n### Programming Languages\n\nPython\n\n### CCXT Version\n\n4.1.20\n\n### Description\n\nHello,\r\n\r\nsuddenly, probably after ccxt update I get no Information from \r\n\r\nBitmex.fetch.positions anymore. \r\n\r\nOutput is --> []  None\r\n\r\nWas there any change on ccxt for Bitmex or is it a bug? \r\n\r\nMy account was liquidated because of this problem. Luckily it was just play money :-)... \r\n\r\n\n\n### Code\n\n```\r\nbitmex = ccxt.bitmex({'enableRateLimit': True,\r\n                       'apiKey': bitmexconfig.api_key,\r\n                       'secret': bitmexconfig.api_secret,})\r\n\r\n\r\nsymbol = 'XBTUSD'\r\nparams={\"type\":\"swap\",\"code\":\"XBT\"}\r\n\r\nbitmex_pos = bitmex.fetch_positions([symbol], params)\r\nprint(bitmex_pos)\r\n\r\n```\r\n"
    },
    "satisfaction_conditions": [
      "The fetch_positions API call must return non-empty position data",
      "Position data must be retrievable after recent CCXT updates",
      "The API call must correctly handle symbol filtering"
    ],
    "created_at": "2023-10-25T13:07:11Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/19595",
    "source": {
      "issue_number": 19595
    },
    "initial_question": {
      "title": "Python fetch_markets() does not return future markets",
      "body": "### Operating System\r\n\r\nWindows 11\r\n\r\n### Programming Languages\r\n\r\nPython 3.11.6\r\n\r\n### CCXT Version\r\n\r\n4.1.14\r\n\r\n### Description\r\n\r\nI wanna get all Binance Future USDT markets. I think there is 100+ future markets, but most of them are missing in fetch_markets()\r\n\r\n### Code\r\n```\r\nbinance = ccxt.binance(config={\r\n    'apiKey': config['ACCESS_KEY'],\r\n    'secret': config['SECRET_KEY'],\r\n    'enableRateLimit': True,\r\n    'options': {'defaultType': 'future'}\r\n})\r\n\r\nmarkets = binance.fetch_markets()\r\ncount = 0\r\nfor coin_info in markets:\r\n    if coin_info['quote'] != 'USDT':\r\n        continue\r\n    if not coin_info['active']:\r\n        continue\r\n    if coin_info['future'] or coin_info['type'] == 'future':\r\n        count += 1\r\n\r\nprint(f\"Count: {count}\") # Count: 4\r\n```"
    },
    "satisfaction_conditions": [
      "Returns complete list of USDT-quoted perpetual swap markets",
      "Correctly distinguishes between different types of futures markets",
      "Market data includes correct market type classification"
    ],
    "created_at": "2023-10-17T05:16:14Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/19522",
    "source": {
      "issue_number": 19522
    },
    "initial_question": {
      "title": "Bingx gbp/jpy symbol not available in markets",
      "body": "### Operating System\n\nOSX\n\n### Programming Languages\n\nJavaScript\n\n### CCXT Version\n\n4.0.3\n\n### Description\n\nHi everyone,\r\n\r\nI'm new to this library and the documentation is great. I am trying to create the foundation for my code to execute some orders for FOREX, which is available in BingX, however when i instantiate my client and I use loadMarkets() I don't get any of the forex, stocks, indices, etc. Why is that? What am I missing? are they just not supported? What would happen if i know the symbol is GBP/JPY and i just create an order with that? would that work?\r\n\r\nCheers and thanks for an awesome project.\n\n### Code\n\n```\r\n\u2002\u2002\r\n\r\n```\r\n"
    },
    "satisfaction_conditions": [
      "User must be informed about BingX API's FOREX trading limitations",
      "User must be informed about CCXT's exchange coverage limitations for FOREX/STOCKS"
    ],
    "created_at": "2023-10-11T10:06:58Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/19506",
    "source": {
      "issue_number": 19506
    },
    "initial_question": {
      "title": "OKX BrokerId and clientOrderId",
      "body": "### Operating System\r\n\r\nUbuntu 22.04\r\n\r\n### Programming Languages\r\n\r\nPython\r\n\r\n### CCXT Version\r\n\r\n4.0.49\r\n\r\n### Description\r\n\r\nHi everyone\r\nI was working on OKX and wanted to provide both a client order id and a broker id\r\nI found this in your code that is blocking me, is it intended? \r\nThanks in advance\r\n\r\n### Code\r\n\r\n```\r\n        if clientOrderId is None:\r\n            brokerId = self.safe_string(self.options, 'brokerId')\r\n            if brokerId is not None:\r\n                request['clOrdId'] = brokerId + self.uuid16()\r\n                request['tag'] = brokerId\r\n        else:\r\n            request['clOrdId'] = clientOrderId\r\n            params = self.omit(params, ['clOrdId', 'clientOrderId'])\r\n\r\n```\r\n"
    },
    "satisfaction_conditions": [
      "The system must allow simultaneous use of both brokerId and clientOrderId",
      "Parameter values provided in params must take precedence over default values",
      "The tag parameter must be configurable through the params object",
      "Parameters provided to unified methods must persist through to the sign function"
    ],
    "created_at": "2023-10-10T12:57:37Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/19325",
    "source": {
      "issue_number": 19325
    },
    "initial_question": {
      "title": "kucoinfutures empty fetchPosition - error.",
      "body": "### Operating System\n\nubuntu 23.04\n\n### Programming Languages\n\nPython\n\n### CCXT Version\n\nccxt-4.0.100\n\n### Description\n\nIf the position is empty, it returns an error (data = []):\r\nTraceback (most recent call last):\r\n    self._position = self.exchange.fetchPosition(symbol) \r\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \".../python3.11/site-packages/ccxt/kucoinfutures.py\", line 904, in fetch_position\r\n    return self.parse_position(data[0], market)\r\n                               ~~~~^^^\r\nmaybe we should fix it this way.\r\nif len(data) > 0:\r\n            return self.parse_position(data[0], market)\r\n        else:\r\n            return {}\n\n### Code\n\n```\r\n\u2002\u2002\r\n\r\n```\r\n"
    },
    "satisfaction_conditions": [
      "System correctly identifies empty positions",
      "Position data structure remains consistent",
      "Empty position handling preserves API contract"
    ],
    "created_at": "2023-09-19T06:47:28Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/19177",
    "source": {
      "issue_number": 19177
    },
    "initial_question": {
      "title": "symbol BTC/FDUSD leverage not working",
      "body": "### Operating System\r\n\r\nWindows11\r\n\r\n### Programming Languages\r\n\r\nPython\r\n\r\n### CCXT Version\r\n\r\n4.0.78\r\n\r\n### Description\r\n\r\nHi, \r\n\r\nWe are working on binance BTC/FDUSD symbol trading with leverage. \r\nThis symbol is working totally fine without leveraging (e.g. binance.fetch_ticker, binance.create_market_buy_order), while when calling binance.markets[ 'BTC/FDUSD' ], the return leverage limit is None.\r\n\r\nWe've checked that the return of leverage with binance.markets[ 'BTC/USDT' ] is working while binance.markets[ 'BTC/FDUSD' ] and binance.markets[ 'FDUSD/BTC' ] are not (returns None), also binance.fapiPrivate_post_leverage is not working with 'FDUSD' symbols.\r\n\r\nWe've also confirmed with binance support that 'FDUSD' symbols endpoints are fine on binance side, so we suppose the issue is on the ccxt tool, thanks.\r\n\r\n### Code\r\n\r\n```\r\nsymbol = 'BTC/FDUSD'\r\nself.binance = ccxt.binance({ })\r\n\r\nresult = float(self.binance.fetch_ticker(symbol)['bid']) # Works\r\norder = self.binance.create_market_buy_order(symbol, amount) # Works\r\norder = self.binance.create_market_sell_order(symbol, amount) # Works\r\n\r\nself.binance.load_markets()\r\nmarket = self.binance.markets[ symbol ]  # returns None in leverage limit\r\nself.binance.fapiPrivate_post_leverage(symbol) # Not working\r\n```\r\n"
    },
    "satisfaction_conditions": [
      "Basic trading operations (fetch_ticker, create_market_buy/sell_order) must continue functioning"
    ],
    "created_at": "2023-09-11T09:13:01Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/18893",
    "source": {
      "issue_number": 18893
    },
    "initial_question": {
      "title": "AttributeError: 'binance' object has no attribute 'fapiPrivate_get_positionside_dual'",
      "body": "### Operating System\r\n\r\nubuntu\r\n\r\n### Programming Languages\r\n\r\nPython\r\n\r\n### CCXT Version\r\n\r\ninstalled ccxt-4.0.61\r\n\r\n### Description\r\n\r\nAttributeError: 'binance' object has no attribute 'fapiPrivate_get_positionside_dual'\r\n\r\n### Code\r\n\r\n```\r\n\u2002\u2002response = self._exchange.fapiPrivate_get_positionside_dual()\r\n\r\n```\r\n"
    },
    "satisfaction_conditions": [
      "The API method name follows the correct case convention supported by the CCXT library",
      "The code successfully retrieves position side information from Binance futures API",
      "No AttributeError is raised when executing the code"
    ],
    "created_at": "2023-08-15T15:45:53Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/18857",
    "source": {
      "issue_number": 18857
    },
    "initial_question": {
      "title": "Bybit stop limit orders cannot be canceled",
      "body": "### Operating System\n\nWindows\n\n### Programming Languages\n\nJavaScript\n\n### CCXT Version\n\n4.0.57\n\n### Description\n\nWhen placing stop loss orders, using the CCXT unified method, on Bybit spot market (using a Unified Bybit account), it is not possible to cancel those orders. As an example, this is what I did:\r\n\r\n`await exchange.createOrder('BTC/USDT', 'limit', 'sell', 0.001, 28500, { stopLossPrice: 29000 });`\r\n\r\nWhen using `exchange.cancelAllOrders('BTC/USDT')`, the order is not canceled. No exception is thrown, but I still see the open order on the exchange.\r\n\r\nWhen using `exchange.cancelOrder(<id>, 'BTC/USDT')`, using the id that is returned when creating the order, does not work either. In that case I get the following exception:\r\n\r\nOrderNotFound: bybit {\"retCode\":170213,\"retMsg\":\"Order does not exist.\",\"result\":{},\"retExtInfo\":{},\"time\":1691743905604}\r\n    at bybit.throwExactlyMatchedException (C:\\code\\crypto-coding-course\\code\\cc-bot\\node_modules\\ccxt\\dist\\cjs\\src\\base\\Exchange.js:3087:19)\r\n    at bybit.handleErrors (C:\\code\\crypto-coding-course\\code\\cc-bot\\node_modules\\ccxt\\dist\\cjs\\src\\bybit.js:9161:18)\r\n    at C:\\code\\crypto-coding-course\\code\\cc-bot\\node_modules\\ccxt\\dist\\cjs\\src\\base\\Exchange.js:766:51\r\n    at processTicksAndRejections (node:internal/process/task_queues:96:5)\r\n    at async bybit.fetch2 (C:\\code\\crypto-coding-course\\code\\cc-bot\\node_modules\\ccxt\\dist\\cjs\\src\\base\\Exchange.js:2666:16)\r\n    at async bybit.request (C:\\code\\crypto-coding-course\\code\\cc-bot\\node_modules\\ccxt\\dist\\cjs\\src\\base\\Exchange.js:2669:16)\r\n    at async bybit.cancelUnifiedAccountOrder (C:\\code\\crypto-coding-course\\code\\cc-bot\\node_modules\\ccxt\\dist\\cjs\\src\\bybit.js:4690:26)\r\n    at async bybit.cancelOrder (C:\\code\\crypto-coding-course\\code\\cc-bot\\node_modules\\ccxt\\dist\\cjs\\src\\bybit.js:4874:20)\r\n\r\n\r\nAm I doing something wrong, or is this a bug?\n\n### Code\n\n```\r\n\u2002\u2002\r\n\r\n```\r\n"
    },
    "satisfaction_conditions": [
      "Stop/trigger orders must be successfully cancelable",
      "No OrderNotFound exceptions occur when canceling valid stop orders",
      "Solution works with the exchange's specific stop order endpoints",
      "Maintains compatibility across multiple exchanges"
    ],
    "created_at": "2023-08-11T09:05:59Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/18762",
    "source": {
      "issue_number": 18762
    },
    "initial_question": {
      "title": "Need advice for getting Binance a group of symbols data",
      "body": "### Operating System\n\nWindows 10\n\n### Programming Languages\n\nJavaScript\n\n### CCXT Version\n\n4.0.49\n\n### Description\n\nHi, \r\nI want to write some JavaScript to get about 20 to 30 symbols OHLC data, like: BTC/USDT; ETH/USDT \u2026\r\nCCXT has the fetchOrderbook function, but this function will fetch data for only one pair, like: BTC/USDT.\r\nIf I want to fetch such data for 20 pairs, what I should do: I use a loop to fetch each pair\u2019s order book?\r\nI want to keep the JS code running to fetch such data every minute, but I don\u2019t know if this will break the rate limit.\r\nI see CCXT has also websocket data for Binance, but I don\u2019t know if I can use websocket to get 20 or 30 pairs data, if it is possible, show me some code examples.\r\nThanks,\n\n### Code\n\n```\r\nconst orderbook = await exchange.fetchOrderBook(pair1);\r\n\r\n```\r\n"
    },
    "satisfaction_conditions": [
      "Multiple cryptocurrency symbol data must be retrieved simultaneously",
      "OHLC (Open, High, Low, Close) price data must be accessible for each symbol",
      "Data must be retrievable at regular time intervals",
      "Operation must respect API rate limits",
      "Data retrieval must work with Binance exchange"
    ],
    "created_at": "2023-08-03T10:40:47Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/18498",
    "source": {
      "issue_number": 18498
    },
    "initial_question": {
      "title": "fetchPositionsRisk() requires an array argument for symbols",
      "body": "### Operating System\n\nLinux\n\n### Programming Languages\n\npython\n\n### CCXT Version\n\n4.0.13\n\n### Description\n\nSeems like the bug from 18131 is still not solved in 4.0.13. Below code gives \r\n>binance fetchPositionsRisk() requires an array argument for symbols\r\n\r\nSame error when one adds params={'type': 'future'} \r\n\r\n\n\n### Code\n\n```\r\nsymbol = \"LTC/USDT:USDT\"\r\nposResult = await exchange.fetchPositions(symbols = symbol)\r\n```\r\n"
    },
    "satisfaction_conditions": [
      "The trading symbol format must be preserved correctly"
    ],
    "created_at": "2023-07-07T13:03:59Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/18359",
    "source": {
      "issue_number": 18359
    },
    "initial_question": {
      "title": "CCXT Pro 'create_order_ws' on Kraken",
      "body": "### Operating System\n\nMacOS\n\n### Programming Languages\n\n_No response_\n\n### CCXT Version\n\nCCXT Pro 1.0.33\n\n### Description\n\nI am trying to submit an order with CCXT Pro on Kraken using web socket (Python).\r\n\r\n`order = await exchange.create_order_ws(symbol=\"UNI/USD\", type=\"market\", side=\"buy\", amount=1 )`\r\n\r\nBut I receive the following error:\r\n\r\n`AttributeError: 'kraken' object has no attribute 'create_order_ws'`\r\n\r\nDoes it mean that not all the WS methods in CCXT Pro work for supported exchanges or am I missing something?\r\n\r\nThank you for your help!\n\n### Code\n\n```\r\n\u2002\u2002\r\n\r\n```\r\n"
    },
    "satisfaction_conditions": [
      "Exchange must support websocket order creation",
      "Method syntax must match exchange's implementation"
    ],
    "created_at": "2023-06-27T11:14:56Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/17822",
    "source": {
      "issue_number": 17822
    },
    "initial_question": {
      "title": "watch_ohlcv always returns a single value",
      "body": "### Operating System\n\nEndeavourOS\n\n### Programming Languages\n\npython\n\n### CCXT Version\n\nCCXT Pro 3.0.79\n\n### Description\n\nI've been trying to run the `binance-watch-ohlcv.py` example and expected it to return more candles, however, it only seems to return one, no matter the limits I set. As I've understood, this method should return more candles, depending on the limit parameter that is set.\n\n### Code\n\n```\r\n\u2002\u2002\r\n\r\nimport ccxt.pro\r\nfrom asyncio import run\r\n\r\nprint('CCXT Pro version', ccxt.pro.__version__)\r\n\r\n\r\ndef table(values):\r\n    first = values[0]\r\n    keys = list(first.keys()) if isinstance(first, dict) else range(0, len(first))\r\n    widths = [max([len(str(v[k])) for v in values]) for k in keys]\r\n    string = ' | '.join(['{:<' + str(w) + '}' for w in widths])\r\n    return \"\\n\".join([string.format(*[str(v[k]) for k in keys]) for v in values])\r\n\r\n\r\nasync def main():\r\n    exchange = ccxt.pro.binance({\r\n        'options': {\r\n            'OHLCVLimit': 1000, # how many candles to store in memory by default\r\n        },\r\n    })\r\n    symbol = 'ETH/USDT'  # or BNB/USDT, etc...\r\n    timeframe = '1m'  # 5m, 1h, 1d\r\n    limit = 10  # how many candles to return max\r\n    method = 'watchOHLCV'\r\n    if (method in exchange.has) and exchange.has[method]:\r\n        max_iterations = 100000  # how many times to repeat the loop before exiting\r\n        for i in range(0, max_iterations):\r\n            try:\r\n                ohlcvs = await exchange.watch_ohlcv(symbol, timeframe, None, limit)\r\n                now = exchange.milliseconds()\r\n                print('\\n===============================================================================')\r\n                print('Loop iteration:', i, 'current time:', exchange.iso8601(now), symbol, timeframe)\r\n                print('-------------------------------------------------------------------------------')\r\n                print(table([[exchange.iso8601(o[0])] + o[1:] for o in ohlcvs]))\r\n            except Exception as e:\r\n                print(type(e).__name__, str(e))\r\n                break\r\n        await exchange.close()\r\n    else:\r\n        print(exchange.id, method, 'is not supported or not implemented yet')\r\n\r\n\r\nrun(main())\r\n```\r\nOutput looks like this\r\n```\r\nCCXT Pro version 3.0.79\r\n\r\n===============================================================================\r\nLoop iteration: 0 current time: 2023-05-07T06:42:00.151Z ETH/USDT 1m\r\n-------------------------------------------------------------------------------\r\n2023-05-07T06:41:00.000Z | 1902.53 | 1902.59 | 1902.52 | 1902.59 | 30.4667\r\n\r\n===============================================================================\r\nLoop iteration: 1 current time: 2023-05-07T06:42:03.130Z ETH/USDT 1m\r\n-------------------------------------------------------------------------------\r\n2023-05-07T06:42:00.000Z | 1902.58 | 1902.59 | 1902.58 | 1902.59 | 17.8681\r\n```"
    },
    "satisfaction_conditions": [
      "OHLCV data stream returns expected number of candles based on configuration",
      "Method for accessing historical data is available",
      "Control over update behavior is configurable",
      "Real-time data updates continue to function"
    ],
    "created_at": "2023-05-07T06:51:04Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/17818",
    "source": {
      "issue_number": 17818
    },
    "initial_question": {
      "title": "Setting timeout and reconnect wait time for ws streams",
      "body": "### Operating System\n\nWindows & Linux\n\n### Programming Languages\n\npython\n\n### CCXT Version\n\n-\n\n### Description\n\nIs there a way to programmatically set the timeout property and a reconnect wait time for the websocket streams ? \n\n### Code\n\n```\r\n\u2002\u2002\r\n\r\n```\r\n"
    },
    "satisfaction_conditions": [
      "WebSocket keep-alive interval must be configurable",
      "Connection loss must be detectable",
      "Reconnection timing must be controllable",
      "Solution must work within the exchange's streaming interface"
    ],
    "created_at": "2023-05-06T19:17:57Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/17753",
    "source": {
      "issue_number": 17753
    },
    "initial_question": {
      "title": "unsupported operand type(s) for %: 'int' and 'NoneType' in watchTicker",
      "body": "### Operating System\r\n\r\nLinux\r\n\r\n### Programming Languages\r\n\r\npython\r\n\r\n### CCXT Version\r\n\r\n3.0.78\r\n\r\n### Description\r\n\r\nThe *complete* (just fill in an api and secret) code below throws the \r\n\r\n> unsupported operand type(s) for %: 'int' and 'NoneType' \r\n\r\nerror.\r\n\r\nCould it be there's an error somewhere in the watchTicker function ?\r\n\r\nI tried with symbol = 'ETH/USDT', symbol = 'ETH/USDT:USDT' and 'ETH-USDT'\r\n\r\n### Code\r\n\r\n```\r\n#!/usr/bin/python3.8\r\nimport ccxt\r\nimport ccxt.pro as ccxtpro\r\nimport os, sys, platform, traceback\r\nimport socket, requests\r\nimport pprint\r\nimport asyncio, aiohttp\r\nimport uvloop\r\n\r\nasync def watch_ticker(exchange):\r\n    while True:\r\n        try:\r\n            symbol = 'ETH/USDT'\r\n            print (symbol)\r\n            tck = await exchange.watchTicker(symbol)\r\n            pp.pprint(tck)\r\n        except Exception as e:\r\n            print(f\"{e}\")\r\n            exc_type, exc_obj, exc_tb = sys.exc_info()\r\n            fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]\r\n            print(exc_type, fname, exc_tb.tb_lineno)\r\n            await exchangepro.close()\r\n\r\n######################################\r\n### MAIN PROGRAM STARTS HERE \r\nasync def main():\r\n    tasks = []\r\n\r\n    tasks.append(asyncio.create_task(watch_ticker(exchangepro)))\r\n\r\n    try:\r\n        await asyncio.gather(*tasks)\r\n\r\n    except (ccxt.RequestTimeout, ccxt.NetworkError) as e:\r\n        print(f\"Request error occurred: {e} ...\")\r\n\r\n    except Exception as e:\r\n        print(f\"{e}\")\r\n        exc_type, exc_obj, exc_tb = sys.exc_info()\r\n        fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]\r\n        print(exc_type, fname, exc_tb.tb_lineno)\r\n        await exchangepro.close()\r\n\r\n########################################\r\n### WRAPPER FOR MAIN PROGRAM\r\n\r\nexchangepro = ccxtpro.binance({\r\n    'apiKey': api_key,\r\n    'secret': api_secret,\r\n    'enableRateLimit': False,\r\n})\r\n\u2002\u2002\r\nexchangepro.options = {\r\n    'defaultType': 'future', # or 'margin' or 'spot'\r\n    'adjustForTimeDifference': True,\r\n    'newOrderRespType': 'FULL',\r\n    'defaultTimeInForce': 'GTC'}\r\n\r\ntry:\r\n    if os.name.upper() != 'NT':\r\n        uvloop.install()\r\n    if os.name.upper() == 'NT':\r\n        asyncio.set_event_loop_policy(asyncio.WindowsSelectorEventLoopPolicy())\r\n\r\n    asyncio.run(main(), debug=False)\r\n\r\nexcept KeyboardInterrupt:\r\n    print(\"Program interrupted by user\")\r\n\r\n```\r\n"
    },
    "satisfaction_conditions": [
      "Symbol format must be compatible with exchange's WebSocket API"
    ],
    "created_at": "2023-05-02T16:52:55Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/17718",
    "source": {
      "issue_number": 17718
    },
    "initial_question": {
      "title": "load_markets v/s fetch_markets (pairs dict differences)",
      "body": "### \u061c\n\nCCXT ver 2.2.36 / Win-10 / python 3.7\r\n\r\nGetting available trading-pairs via load_markets may bring less results compared to fetch_markets for some exchanges.\r\nSo far I noticed two types of differences:\r\n\r\nA) Duplicate-pairs (totally identical records) are brought by fetch_market (while load_market doesn't). Example: For bitFlier exchange BTC_JPY and ETH_BTC pairs, occuring 3 times each in fetch_market result.\r\n\r\nB) Multiple pairs of the same symbol with different id are all brought by fetch_markets (while load_market brings only one of them). Example: For Binance exchange fetch_markets brings symbol BCH/BTC with 2 different ids (BCHBTC and BCHABCBTC), while load_markets brings only one id (BCHBTC). "
    },
    "satisfaction_conditions": [
      "The difference between load_markets and fetch_markets output format must be clearly explained",
      "Duplicate market entries must be handled appropriately in both methods",
      "Market symbol disambiguation must be maintained",
      "Consistent market identification across different trading types"
    ],
    "created_at": "2023-04-30T08:22:43Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/17631",
    "source": {
      "issue_number": 17631
    },
    "initial_question": {
      "title": "[Question] FetchStatus",
      "body": "### \u061c\n\nHi, \r\n\r\nI have been having trouble to find the answer by myself through the ccxt documentation. So I have no choice to ask it here. \r\nI would like to use exchange.fetchStatus() to do a initial check before running my script. \r\n\r\nBut I wonder, what will be expected response if an exchange goes into maintenance mode? \r\nHow will the 'eta' response be like? In seconds or date time? \r\n\r\nBecause i am implementing a loop that will sleep until the ETA time before running the remaining code if it goes into maintenance mode. \r\n\r\nSorry if this answer can be found, because i really didn't manage to find it. "
    },
    "satisfaction_conditions": [
      "Status response correctly identifies maintenance mode",
      "ETA format is properly interpreted",
      "Script can handle exchanges with or without ETA information",
      "Status check can be performed before main script execution"
    ],
    "created_at": "2023-04-21T21:59:45Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/17608",
    "source": {
      "issue_number": 17608
    },
    "initial_question": {
      "title": "Could not create 'Nonce' for Bigone jwt",
      "body": "### \u061c\n\nHi there,\r\n\r\nI'm trying to read the balance from my Bigone account using a python script.\r\nBeside the API_Key and Secret, there is also an JWT I need. But when I create the jwt, I always get an error:\r\n\r\nccxt.base.errors.AuthenticationError: bigone {\"code\":40004,\"message\":\"nonce expired\"} \r\n\r\nI have try everything, but get still the same error. Here is my code:\r\n\r\n`\r\nbigoneApi = os.environ.get('BIGONE_API_KEY')\r\nbigoneSecret = os.environ.get('BIGONE_SECRET')\r\n\r\nissuedAt = int(time.time())\r\nexpiration = int(time.time()) + 432000 # JWT will expire in 5 days\r\nnonce = int(time.time() * 1000)\r\n\r\npayload = {\r\n    \"type\": \"OpenAPI\",\r\n    \"sub\": bigoneApi,\r\n    \"iat\": issuedAt,\r\n    \"exp\": expiration,\r\n    \"nonce\": nonce\r\n}\r\n\r\nbigoneToken = jwt.encode(payload, bigoneSecret, algorithm='HS256')\r\nbigoneEx = ccxt.bigone({\r\n    'apiKey': bigoneApi,\r\n    'secret': bigoneSecret,\r\n    'headers': {\r\n        'Authorization': 'Bearer ' + bigoneToken\r\n    }\r\n})`\r\n"
    },
    "satisfaction_conditions": [
      "Authentication credentials are properly configured",
      "API request successfully retrieves balance data",
      "CCXT library version is compatible with the implementation",
      "No manual JWT token generation is required"
    ],
    "created_at": "2023-04-19T15:49:53Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/17307",
    "source": {
      "issue_number": 17307
    },
    "initial_question": {
      "title": "exchange.loadMarkets() returns unsupported TUSD pairs for Binance",
      "body": "### Operating System\n\nWindows\n\n### Programming Languages\n\nJS\n\n### CCXT Version\n\n3.0.23\n\n### Description\n\nThe symbols returned when using exchange.loadMarkets() with Binance returns the following TUSD trading pairs:\r\n\r\nADA/TUSD\r\nALGO/TUSD\r\nANKR/TUSD\r\nATOM/TUSD\r\nBAT/TUSD\r\nBCH/TUSD\r\nBCPT/TUSD\r\nBNB/TUSD\r\nBSV/TUSD\r\nBTC/TUSD\r\nBTT/TUSD\r\nEOS/TUSD\r\nETC/TUSD\r\nETH/TUSD\r\nFTM/TUSD\r\nGTO/TUSD\r\nLINK/TUSD\r\nLTC/TUSD\r\nNEO/TUSD\r\nONE/TUSD\r\nPAX/TUSD\r\nPHB/TUSD\r\nTFUEL/TUSD\r\nTRX/TUSD\r\nTUSD/BNB\r\nTUSD/BTC\r\nTUSD/BUSD\r\nTUSD/ETH\r\nTUSD/USDT\r\nTUSDB/TUSD\r\nUSDC/TUSD\r\nUSDS/TUSD\r\nWAVES/TUSD\r\nXLM/TUSD\r\nXRP/TUSD\r\nZEC/TUSD\r\n\r\nOf these, only the following are actually available on Binance:\r\nBNB/TUSD\r\nBTC/TUSD\r\nETH/TUSD\r\nTUSD/USDT\r\n\r\nPerhaps this is a problem on the Binance side, but reporting it just in case.\r\n\n\n### Code\n\n```\r\n\u2002\u2002\r\n\r\n```\r\n"
    },
    "satisfaction_conditions": [
      "Market data correctly indicates trading availability status",
      "Inactive markets are properly distinguished from active ones",
      "Market data structure includes activity status information",
      "Returned market list matches current exchange capabilities"
    ],
    "created_at": "2023-03-22T20:01:41Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/16952",
    "source": {
      "issue_number": 16952
    },
    "initial_question": {
      "title": "Create Order in ccxt bybit Testnet position idx not match position mode",
      "body": "### \u061c\n\nI want create a simple order in Derivates -> USDT Perpetual -> BTCUSDT. \r\n\r\nI have following Balance:\r\n'coin': 'BTC', 'equity': '1.07893293', 'walletBalance': '1.07893293'\r\n\r\nHere is my code:\r\n\r\nimport ccxt\r\n\r\nexchange = ccxt.bybit({\r\n    'apiKey': 'apiKey',\r\n    'secret': 'secretKey',\r\n    'enableRateLimit': True,\r\n    'options': {\r\n        'recvWindow': 10000,\r\n    }\r\n})\r\nexchange.set_sandbox_mode(True)\r\nexchange.options[\"defaultType\"] = 'swap'\r\nsymbol = 'BTC/USDT:USDT'\r\norder = exchange.createOrder(symbol=symbol, type='Market', side='buy', amount=0.01)\r\n\r\nBut i get this error:\r\nbybit {\"retCode\":10001,\"retMsg\":\"position idx not match position mode\",\"result\":{},\"retExtInfo\":{},\"time\":1677246036932}\r\n\r\nHave somebody a solution?\r\nThanks"
    },
    "satisfaction_conditions": [
      "Order creation request must include position mode information",
      "Order parameters must be compatible with Bybit's USDT Perpetual trading system",
      "Order creation must successfully execute on Bybit's testnet environment",
      "Order creation must support market orders for the BTC/USDT pair"
    ],
    "created_at": "2023-02-24T13:43:11Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/16929",
    "source": {
      "issue_number": 16929
    },
    "initial_question": {
      "title": "Kucoin fetchBalance method returning empty data",
      "body": "### \u061c\r\n\r\nI think this is a stupid question.\r\nBut I don't know why. please help me.\r\nFor testing purpose, I deposited 55$ to kucoin main account and can check it.\r\n\r\n0.00230737BTC\u2248 55.03USD(Loans: 0.00 BTC)\r\n\r\nI also created an API key.\r\n```\r\nKey : 63f666faf2ac4300019c0de5\r\nAPI Restrictions : General, Trade\r\nPeriod of Validity : 30 days\r\nIP Restriction : No\uff08less secure; binding an IP address is recommended)\r\n\r\nKeys and secrets are correct.\r\n\r\nconst kucoin = new ccxt.kucoin({\r\n    'apiKey': config.kucoin_apiKey,\r\n    'secret': config.kucoin_secret,\r\n    'password' : config.kucoin_password,\r\n    'enableRateLimit': true,\r\n    'trust': true // enable trust option\r\n});\r\nconsole.log (await kucoin.fetchBalance ())\r\n\r\nresult is : \r\n{\r\n  info: { code: '200000', data: [] },\r\n  timestamp: undefined,\r\n  datetime: undefined,\r\n  free: {},\r\n  used: {},\r\n  total: {}\r\n}\r\n\r\nwhen I test with fetchDeposits(), the result is correct.\r\n\r\nOS : Windows 10\r\nProgramming Language version: Node JS 14.18.1\r\nCCXT version : 2.4.96\r\n"
    },
    "satisfaction_conditions": [
      "API authentication credentials must be properly configured"
    ],
    "created_at": "2023-02-22T20:31:54Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/16898",
    "source": {
      "issue_number": 16898
    },
    "initial_question": {
      "title": "Kucoinfutures fetch open orders shows no data anymore",
      "body": "### \u061c\n\nOS: Windows 10\r\nProgramming Language version: Python\r\nCCXT version: 2.8.16\r\n\r\n\r\nHello, \r\n\r\nsince a few days kucoinfutures doesn't show any data if I try to fetch open orders when STOP ORDER is placed. Issue occurs at linear and inverse contracts.   If a limit order above price is placed it works. \r\nAlso here I didn't change anything, it has worked fine for months now, but suddenly it doesn't work anymore. \r\n\r\n\r\nkucoin = ccxt.kucoinfutures({'enableRateLimit': True,\r\n                       'apiKey': kucoinconfig.api_key,\r\n                       'secret': kucoinconfig.api_secret,\r\n                       'password' : 'xxxxxxxxxxx',})\r\n\r\nsymbol = 'ETH/USDT:USDT'\r\npos_size = 1\r\n\r\norders = kucoin.fetch_open_orders(symbol)\r\n        print(orders)\r\n\r\nOutput is this --> []\r\n\r\n\r\n\r\n"
    },
    "satisfaction_conditions": [
      "Stop orders must be retrievable from the exchange API",
      "API request must include appropriate parameters to distinguish stop orders"
    ],
    "created_at": "2023-02-19T15:55:05Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/16878",
    "source": {
      "issue_number": 16878
    },
    "initial_question": {
      "title": "The parameters of orders are null",
      "body": "### \u061c\n\nhello, this is what I get after calling\r\n\r\n`write(order=exchange.create_market_order(symbol, side, size, params))`\r\n\r\nwhere write is a function that dumps a json in a json file\r\n\r\n`{\r\n    \"info\": {\r\n        \"orderId\": \"2c471e2c-7160-40e0-842b-6234a0333e2a\",\r\n        \"orderLinkId\": \"\"\r\n    },\r\n    \"id\": \"2c471e2c-7160-40e0-842b-6234a0333e2a\",\r\n    \"clientOrderId\": null,\r\n    \"timestamp\": null,\r\n    \"datetime\": null,\r\n    \"lastTradeTimestamp\": null,\r\n    \"symbol\": null,\r\n    \"type\": null,\r\n    \"timeInForce\": null,\r\n    \"postOnly\": null,\r\n    \"side\": null,\r\n    \"price\": null,\r\n    \"stopPrice\": null,\r\n    \"triggerPrice\": null,\r\n    \"amount\": null,\r\n    \"cost\": null,\r\n    \"average\": null,\r\n    \"filled\": null,\r\n    \"remaining\": null,\r\n    \"status\": null,\r\n    \"fee\": null,\r\n    \"trades\": [],\r\n    \"fees\": [],\r\n    \"reduceOnly\": null\r\n}`\r\n\r\nwhy are all the attributes null? what am I doing wrong?"
    },
    "satisfaction_conditions": [
      "Order creation request returns a valid order ID",
      "Additional order details can be retrieved in a separate step",
      "System handles asynchronous order processing appropriately",
      "Order creation response structure remains intact"
    ],
    "created_at": "2023-02-17T11:53:11Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/16650",
    "source": {
      "issue_number": 16650
    },
    "initial_question": {
      "title": "python async speed slower",
      "body": "### Operating System\n\nubuntu\n\n### Programming Languages\n\npython\n\n### CCXT Version\n\n2.6.94\n\n### Description\n\nWhile I was trying to migrate my code to async I noticed that my execution was slower.\r\n\r\nI wrote a small code to compare the async vs sync speed. \r\n\r\nAverage execution time of both is written below in seconds in one of my test runs. On average async takes rougly 2x longer . Similar results when tested in other methods such as \"fetch_tickers\".\r\n\r\nasync mean: 1.1664345026016236\r\nsync mean: 0.5469205617904663\n\n### Code\n\n```\r\nimport asyncio\r\nimport time\r\n\r\nimport ccxt.async_support as ccxta  \r\nimport ccxt\r\nimport os\r\nfrom dotenv import load_dotenv\r\nload_dotenv()\r\n\r\nbinance_keys = {\r\n        \"apikey\" : os.getenv(\"BINANCE_APIKEY\"),\r\n        \"secret\" : os.getenv(\"BINANCE_SECRET\")\r\n    }\r\n\r\nasync def get_balance_async(exchange):\r\n    balance = await exchange.fetch_balance()\r\n    await exchange.close()\r\n    return balance\r\n\r\nexchange_async = ccxta.binance({\r\n        'apiKey': binance_keys[\"apikey\"],\r\n        'secret': binance_keys[\"secret\"],\r\n    })\r\n\r\nexchange_sync = ccxt.binance({\r\n        'apiKey': binance_keys[\"apikey\"],\r\n        'secret': binance_keys[\"secret\"],\r\n    })\r\n\r\ntime_sync = []\r\ntime_async = []\r\n\r\nloop = asyncio.get_event_loop()\r\nfor i in range(10):\r\n\r\n    start = time.time()\r\n    loop.run_until_complete(get_balance_async(exchange_async))\r\n    time_async.append(time.time() - start)\r\n    time.sleep(0.2)\r\n\r\n    start = time.time()\r\n    balance = exchange_sync.fetch_balance()\r\n    time_sync.append(time.time() - start)\r\n    time.sleep(0.2)\r\n\r\nprint(\"Async data: \", time_async)\r\nprint(\"Sync data: \", time_sync)\r\nprint(f\"async mean: {sum(time_async)/len(time_async)}\")\r\nprint(f\"sync mean: {sum(time_sync)/len(time_sync)}\")\r\n\u2002\u2002\r\n\r\n```\r\n"
    },
    "satisfaction_conditions": [
      "Rate limiting configuration is adjustable",
      "API functionality remains unchanged",
      "Performance difference is measurable and reproducible"
    ],
    "created_at": "2023-01-27T07:36:29Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/16500",
    "source": {
      "issue_number": 16500
    },
    "initial_question": {
      "title": "How to fetchCurrencies workes?",
      "body": "### Operating System\r\n\r\nWindows 10 \r\n\r\n### Programming Languages\r\n\r\nNodejs\r\n\r\n### CCXT Version\r\n\r\n2.5.47\r\n\r\n### Description\r\n\r\nThis is not exactly a bug request, more of a question. I'm sorry, I couldn't find the question section. The thing is, I can't get the currency structure. In the documentation, this method is listed as public, but I saw a similar question where the developers said that the structure of the token, the commission and the network can only be obtained with an API key. How can I get Currency Structure? I also tried the example directly from the documentation, but it's most likely for python, or I'm using it incorrectly\r\n\r\n### Code\r\n\r\n```\r\n\u2002\u2002\r\nconst ccxt = require(\"ccxt\");\r\n\r\n(async function () {\r\n  let binance = new ccxt.binance();\r\n  await binance.loadMarkets;\r\n  let cur= await binance.fetchCurrencies[\"ETH\"];\r\n  console.log(cur);  // undefined\r\n})();\r\n\r\n// Example from docs\r\n(async function () {\r\n  let binance = new ccxt.binance();\r\n  await binance.loadMarkets();\r\n  let cur= binance.currencies[\"ETH\"][\"fee\"];\r\n  console.log(cur);  // undefined\r\n})(); /\r\n\r\n//I want this Currency Structure\r\n\r\n{\r\n    'id':       'btc',       \r\n    'code':     'BTC',       \r\n    'name':     'Bitcoin',   \r\n    'active':    true,       \r\n    'fee':       0.123,      \r\n    'precision': 8,         \r\n    'deposit':   true      \r\n    'withdraw':  true        \r\n    'limits': {              \r\n        'amount': {\r\n            'min': 0.01,     \r\n            'max': 1000,     \r\n        },\r\n        'withdraw': { ... },\r\n        'deposit': {...},\r\n    },\r\n    'networks': {...}        \r\n    'info': { ... },    \r\n}"
    },
    "satisfaction_conditions": [
      "Currency data structure must be successfully retrieved",
      "Markets must be loaded before accessing currency data",
      "Method must handle specific currency symbol parameters",
      "Asynchronous operations must be properly handled"
    ],
    "created_at": "2023-01-15T21:24:48Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/16406",
    "source": {
      "issue_number": 16406
    },
    "initial_question": {
      "title": "[Python] set TP and SL in Bybit ",
      "body": "### Operating System\r\n\r\nLinux\r\n\r\n### Programming Languages\r\n\r\npython\r\n\r\n### CCXT Version\r\n\r\n2.5.56\r\n\r\n### Description\r\n\r\nAny way to set TP and SL with bybit in python?\r\nI keep getting errors like\r\n\r\n```\r\nERROR:root:bybit {\"retCode\":10001,\"retMsg\":\"expect Failling, but trigger_price[5980000] \\u003e= current[1361500]??1\",\"result\":{},\"retEx\r\n``` \r\n\r\nor \r\n\r\n```\r\nERROR:root:bybit {\"retCode\":10001,\"retMsg\":\"expect Rising, but trigger_price[1249500] \\u003c= current[1363000]??1\",\"result\":{},\"retExtI\r\n```\r\nboth for shorts and longs\r\n\r\n### Code\r\n\r\n```\r\n\u2002\u2002bybit.create_order(symbol=position.symbol,\r\n                                   type='limit',\r\n                                   side=position.direction,\r\n                                   amount=size,\r\n                                   price=float(position.entry),\r\n                                   params={\r\n                                    'leverage': LEVER,\r\n                                    'stopLossPrice': float(position.sl),\r\n                                    'takeProfitPrice': float(position.tp),\r\n                                    })\r\n\r\n```\r\n"
    },
    "satisfaction_conditions": [
      "Order creation must successfully set both stop loss and take profit levels simultaneously",
      "Parameter names must match the exchange's expected format",
      "Price values must be provided in a format accepted by the exchange"
    ],
    "created_at": "2023-01-10T03:11:55Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/16348",
    "source": {
      "issue_number": 16348
    },
    "initial_question": {
      "title": "CCXT OKEX fetchorders not showing stoploss orders",
      "body": "### Operating System\r\n\r\n\r\n_No response_\r\n\r\n### Programming Languages\r\nPython3\r\n\r\n### CCXT Version\r\n1.79.95\r\n\r\n### Description\r\nfor okex, fetch_open_orders() outputs my limit orders but not my stoploss/takeprofit orders\r\n\r\nhow can i get my stoploss/takeprofit orders? it's driving me nuts!\r\n\r\n### Code\r\nokex = ccxt.okex({\r\n     \"apiKey\": xxx,\r\n     \"secret\": xxx,\r\n     \"password\": xxx,\r\n     'enableRateLimit': True,\r\n     'options': {\r\n         'defaultType': 'swap',\r\n         'swap': True# \u2190-------------- quotes and 'future'\r\n     }\r\n})\r\n\r\n```\r\nokex.fetch_open_orders() #shows limit orders but not SL/TP orders\r\n\r\nparams = {'stop':True} \r\nokex.fetch_open_orders(params=params) \r\n\r\n#outputs ccxt.base.errors.BadRequest: okex {\"code\":\"51000\",\"data\":[],\"msg\":\"Parameter ordType  error\"}\r\n\u2002\u2002\r\n\r\n```\r\n"
    },
    "satisfaction_conditions": [
      "API request includes valid order type specification",
      "Works within OKEX's API constraints for conditional orders"
    ],
    "created_at": "2023-01-05T20:25:58Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/16040",
    "source": {
      "issue_number": 16040
    },
    "initial_question": {
      "title": "Asyncio workflow",
      "body": "- Programming Language version: Python 3.10.5\r\n- CCXT version: 2.2.91\r\n\r\nIf I understand the asyncio functionality correctly , the workflow for this code is as following:\r\n```\r\nimport asyncio\r\nimport ccxt.pro\r\n\r\n\r\nasync def loop(exchange, symbol):\r\n    while True:\r\n        orderbook = await exchange.fetch_order_book(symbol)\r\n        # code without call exchange method\r\n        if condition:\r\n            await exchange.create_order(symbol, ...)\r\n\r\n\r\nasync def main():\r\n    exchange = ccxt.pro.binance()\r\n    symbols = ['symbol1', 'symbol2', 'symbolN']\r\n    await asyncio.gather(*[loop(exchange, symbol) for symbol in symbols])\r\n\r\n\r\nasyncio.run(main())\r\n```\r\n1. All loop functions execute code until 'fetch_order_book' call.\r\n2. Execute 'fetch_order_book' and execute code until 'fetch_order_book' if condition not True else until 'create_order'\r\n3. From symbol1 to symbolN in the order, execute 'fetch_order_book' or 'create_order'\r\n\r\nIs it right? \r\nSo my question is how can I execute the 'create_order' function immediately after 'fetch_order_book' if condition is True.\r\n\r\nThe purpose of my question is in case of you have lot of symbol in symbols list. If only the last symbol has condition True, you need to wait all symbol to fetch him orderbook before post your order. I would like to minimize the time between the execution of 'fetch_order_book_ and the execution of the trade.\r\n\r\nThanks you very much for your help.\r\n\r\n"
    },
    "satisfaction_conditions": [
      "Asynchronous operations for different symbols must execute independently and in parallel",
      "Order creation must execute immediately after orderbook fetch when conditions are met",
      "System must support continuous monitoring of multiple trading symbols simultaneously",
      "Implementation must be compatible with both polling and streaming orderbook data methods"
    ],
    "created_at": "2022-12-10T11:14:02Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/16022",
    "source": {
      "issue_number": 16022
    },
    "initial_question": {
      "title": "Can I use the repo to receive tokens to and from different networks?",
      "body": "- OS: Windows 10 PRO\r\n- Programming Language version: Node.js (version 19.2.0)\r\n- CCXT version: 2.2.84\r\n\r\nHi,\r\n\r\nI know I can use CCXT to withdraw tokens to any address if they are in ERC20, BEP20, SPL, TRC20 networks.\r\nBut I want to know if I can use some wallet, like Exodus which has desktop version, I create a wallet and I have the private key. I can withdraw tokens from my account in exchange to my wallet and can I use CCXT with the private key to send tokens from my wallet address to another my account in another exchange.\r\n\r\nFor example: \r\n\r\nLet\u2019s say I setup Exodus wallet for Windows 10, and I have the address with the private key.\r\n\r\nIf I want to withdraw some USDT from my Binance account via ERC20 network, after I receive the USDT from my Binance account, can I use CCXT with the Exodus wallet private key, after paying the gas fees, send USDT to my Huobipro account via BEP20 network?\r\n\r\nI think receiving the USDT should work,  as it just a different address as any other exchange address.\r\n\r\nPlease advise if I can send USDT from wallet address with private key to another account in different exchange.\r\nThanks,\r\n"
    },
    "satisfaction_conditions": [
      "The solution must clarify CCXT's scope of operation with exchanges",
      "The solution must address the distinction between exchange-based and blockchain-based transactions",
      "The solution must explicitly state whether cross-network token transfers using wallet private keys are possible through CCXT",
      "The solution must explain CCXT's role as a middleware for exchange APIs"
    ],
    "created_at": "2022-12-08T13:37:02Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/16006",
    "source": {
      "issue_number": 16006
    },
    "initial_question": {
      "title": "Kraken's response has little information",
      "body": "- OS:\r\n- Programming Language version:\r\n- CCXT version:\r\n\r\n```\r\n order = kraken.createOrder(symbol_name, type,side,quantity, price)\r\n```\r\nThis is the response I get:\r\n```\r\n{'id': 'XXXXXXXXXXX', 'clientOrderId': None, 'info': {'txid': ['XXXXXXXXX'], 'descr': {'order': 'sell 0.00178900 XBTUSD @ limit 16776.3'}}, 'timestamp': None, 'datetime': None, 'lastTradeTimestamp': None, 'status': None, 'symbol': 'BTC/USD', 'type': 'limit', 'timeInForce': None, 'postOnly': None, 'side': 'sell', 'price': 16776.3, 'stopPrice': None, 'cost': None, 'amount': 0.001789, 'filled': None, 'average': None, 'remaining': None, 'fee': None, 'trades': [], 'fees': []} \r\n```\r\nI looked up Kraken's REST API and they seem to have information about the trade when it's open and when it's closed but the response inside CCXT is just all NONE which does not help at all.\r\n\r\nThe following is the open orders response from Kraken:\r\n{\r\n  \"result\": {\r\n    \"open\": {\r\n      \"txid1\": {\r\n        \"refid\": \"string\",\r\n        \"userref\": \"string\",\r\n        \"status\": \"pending\",\r\n        \"opentm\": 0,\r\n        \"starttm\": 0,\r\n        \"expiretm\": 0,\r\n        \"descr\": {\r\n          \"pair\": \"string\",\r\n          \"type\": \"buy\",\r\n          \"ordertype\": \"market\",\r\n          \"price\": \"string\",\r\n          \"price2\": \"string\",\r\n          \"leverage\": \"string\",\r\n          \"order\": \"string\",\r\n          \"close\": \"string\"\r\n        },\r\n        \"vol\": \"string\",\r\n        \"vol_exec\": \"string\",\r\n        \"cost\": \"string\",\r\n        \"fee\": \"string\",\r\n        \"price\": \"string\",\r\n        \"stopprice\": \"string\",\r\n        \"limitprice\": \"string\",\r\n        \"trigger\": \"last\",\r\n        \"misc\": \"string\",\r\n        \"oflags\": \"string\",\r\n        \"trades\": [\r\n          \"string\"\r\n        ]\r\n      },\r\n      \"txid2\": {\r\n        \"refid\": \"string\",\r\n        \"userref\": \"string\",\r\n        \"status\": \"pending\",\r\n        \"opentm\": 0,\r\n        \"starttm\": 0,\r\n        \"expiretm\": 0,\r\n        \"descr\": {\r\n          \"pair\": \"string\",\r\n          \"type\": \"buy\",\r\n          \"ordertype\": \"market\",\r\n          \"price\": \"string\",\r\n          \"price2\": \"string\",\r\n          \"leverage\": \"string\",\r\n          \"order\": \"string\",\r\n          \"close\": \"string\"\r\n        },\r\n        \"vol\": \"string\",\r\n        \"vol_exec\": \"string\",\r\n        \"cost\": \"string\",\r\n        \"fee\": \"string\",\r\n        \"price\": \"string\",\r\n        \"stopprice\": \"string\",\r\n        \"limitprice\": \"string\",\r\n        \"trigger\": \"last\",\r\n        \"misc\": \"string\",\r\n        \"oflags\": \"string\",\r\n        \"trades\": [\r\n          \"string\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"error\": [\r\n    \"EGeneral:Invalid arguments\"\r\n  ]\r\n}\r\n\r\nIt seems like you guys have a lot on your plate so I do appreciate any help possible. Thank you"
    },
    "satisfaction_conditions": [
      "Complete order information must be retrievable after order creation",
      "Order status and execution details must be accessible",
      "Order ID from initial creation must be usable for subsequent queries",
      "Solution must bridge the gap between CCXT's limited response and Kraken's full API data"
    ],
    "created_at": "2022-12-07T18:04:53Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/15948",
    "source": {
      "issue_number": 15948
    },
    "initial_question": {
      "title": "Bybit fetch_deposit_address doesn't work",
      "body": "Hey guys.\r\nCommands \r\n```\r\nbybit.fetch_deposit_address(\"USDT\")\r\nbybit.fetch_deposit_address(\"USDT\", {\"network\":\"ERC20\"})\r\n```\r\nboth lead to `TypeError: argument of type 'NoneType' is not iterable`"
    },
    "satisfaction_conditions": [
      "Markets data must be loaded before attempting to fetch deposit addresses",
      "The function must return a valid deposit address object",
      "The function must handle both basic and network-specific deposit address requests",
      "Authentication/credentials must be properly configured"
    ],
    "created_at": "2022-12-04T09:01:12Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/15696",
    "source": {
      "issue_number": 15696
    },
    "initial_question": {
      "title": "Can we dynamic the exchange selection on npm library",
      "body": "I'm working on a project where we need to implement a function that lets users choose which exchange to select from the api; is there any way we can dynamically update the exchange selection procedure in the library?\r\n\r\nThis is the method i applyed and i want that `ccxt.{someExchange}({})` part dynamic if there is a way please help me.\r\n` const binanceData = new ccxt.binance({})`\r\n`        let binanceTicker = await binanceData.fetchTicker(pair);`\r\n\r\n\r\nOS: Ubuntu\r\nProgramming Language version: Node.JS latest\r\nCCXT version: latest\r\nExchange: All\r\nMethod: All"
    },
    "satisfaction_conditions": [
      "Exchange selection must be modifiable at runtime",
      "Exchange instance must be successfully created with the dynamic selection",
      "Solution must be compatible with CCXT library's architecture"
    ],
    "created_at": "2022-11-15T13:35:07Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/15462",
    "source": {
      "issue_number": 15462
    },
    "initial_question": {
      "title": "bybit fetchOrders is not supported while hasFetchOrders is true",
      "body": "`exchange.fetchOrders` is not supported on Bybit exchange.\r\n\r\n- OS: Win 10 x64\r\n- Programming Language version: Node.js 18\r\n- CCXT version: 2.0.67\r\n\r\n```JavaScript\r\nexchange.hasFetchOrders      // <-- true\r\nexchange.has['fetchOrders']  // <-- true\r\n\r\nexchange.fetchOrders('BTCUSDT') // <-- error\r\n```\r\n\r\n```JavaScript\r\n/home/user/www/node-trading-bot/node_modules/ccxt/js/bybit.js:3447\r\n            throw new NotSupported (this.id + ' fetchOrders() does not support ' + market['type'] + ' markets or USDC markets, use exchange.fetchOpenOrders () and exchange.fetchClosedOrders () instead');\r\n                  ^\r\n\r\nNotSupported: bybit fetchOrders() does not support spot markets or USDC markets, use exchange.fetchOpenOrders () and exchange.fetchClosedOrders () instead\r\n    at bybit.fetchOrders (/home/user/www/node-trading-bot/node_modules/ccxt/js/bybit.js:3447:19)\r\n    at processTicksAndRejections (node:internal/process/task_queues:96:5)\r\n    at async run (/home/user/www/node-trading-bot/src/testing.js:70:14) {\r\n  constructor: [class NotSupported extends ExchangeError]\r\n}\r\n```\r\n"
    },
    "satisfaction_conditions": [
      "Alternative methods (fetchOpenOrders and fetchClosedOrders) are available when fetchOrders is not supported for specific market types",
      "Clear error message indicating market type compatibility"
    ],
    "created_at": "2022-10-30T04:38:16Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/15377",
    "source": {
      "issue_number": 15377
    },
    "initial_question": {
      "title": "bybit Can't get any info of usdc perp",
      "body": "Hi, I have search and try method about options type already but still no clue. I can't access to any USDC perpetual symbol or balance. Its only show future balance&pair(USDT). I want to trade in usdc perpetual sir but \r\n```\r\nccxt.base.errors.BadSymbol: bybit does not have market symbol BTCPERP\r\n```\r\n\r\nThis is header\r\n```\r\nbybit = ccxt.bybit({\r\n\"apiKey\": \"xxxx\",\r\n\"secret\": \"xxxx\",\r\n\"options\": {'defaultType': 'future'}\r\n})\r\nprint(bybit.fetchMarkets())\r\n```\r\n\r\nIs bybit USDC perp contracts have some specific type for it?\r\n\r\nps. Sorry for trouble"
    },
    "satisfaction_conditions": [
      "USDC perpetual market data is accessible",
      "USDC wallet balance is retrievable",
      "Correct market symbol format is used",
      "Trading limitations are clearly identified",
      "Settlement currency is properly specified"
    ],
    "created_at": "2022-10-21T13:57:03Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/15374",
    "source": {
      "issue_number": 15374
    },
    "initial_question": {
      "title": "CCXTPRO removed dependence",
      "body": "- OS: Mac OS\r\n- Programming Language version: Python\r\n- CCXT version:  2.0.53\r\n- CCXT version:  1.2.36\r\n\r\n\r\n```\r\nfrom ccxt.async_support.eqonex import eqonex                              # noqa: F401\r\n```\r\nin the newest version of ccxt was removed dependence  which ccxtpro is still requiring\r\n"
    },
    "satisfaction_conditions": [
      "WebSocket functionality remains accessible",
      "Application maintains existing WebSocket-based functionality"
    ],
    "created_at": "2022-10-21T09:48:09Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/15306",
    "source": {
      "issue_number": 15306
    },
    "initial_question": {
      "title": "How to implement fetchCurrency?",
      "body": "- OS: Windows 10 (Version 21H2)\r\n- Programming Language version: Node.js (version 18.10.0)\r\n- CCXT version: 2.0.19\r\n\r\n```JavaScript\r\nuse strict';\r\nconst ccxt = require('ccxt');\r\n\r\n(async function () {\r\n    console.log(ccxt.version)\r\n    const exchange = new ccxt.binance({\r\n        apiKey: 'My_API_Key',\r\n        secret: 'My_Secret_Key',\r\n        verbose: false,\r\n        defaultType: 'spot',\r\n        adjustForTimeDifference: true,\r\n        'options': {\r\n            'fetchCurrencies': true,\r\n        },\r\n    })\r\n    try \r\n    {\r\n    const currencies = await exchange.fetchCurrencies();\r\n    console.log(currencies);\r\n    } catch (error) {\r\n        console.log(error)\r\n    }\r\n})();\r\n```\r\n\r\nHello:\r\nI want to know if I can use `fetchCurrencies()` to implement `fetchCurrency()` for a single currency.\r\nFor example, in exchange Binance, it has so many currencies, but only a few of them are important, like: BTC, USDT, ETH.\r\nThe other currencies are not used often, so I want to know if I can implement `fetchCurrency()` to get information for only one currency, like \u2018USDT\u2019.\r\nPlease advise,\r\n"
    },
    "satisfaction_conditions": [
      "Returns detailed information for a single specified currency",
      "Must successfully authenticate with the exchange",
      "Returns structured currency data including basic properties and network details",
      "Must work with the exchange's API after market data is loaded"
    ],
    "created_at": "2022-10-15T11:25:48Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/15234",
    "source": {
      "issue_number": 15234
    },
    "initial_question": {
      "title": "Fetching orders on Bybit futures",
      "body": "\r\n\r\n- OS: macOS 12.6\r\n- Programming Language version: python 3.8.13\r\n- CCXT version: 1.95.28\r\n\r\n```\r\nbybit = ccxt.bybit({\r\n    'apiKey': ***,\r\n    'secret': ***,\r\n    'options': {\r\n        'defaultType': 'future',\r\n    },\r\n})\r\n\r\npair_order = 'BTC/USDT:USDT'\r\nenter_amount_in_symbol = 20\r\nopen_order_price = 19555\r\n\r\norder = bybit.create_order(pair_order, 'LIMIT', 'sell', enter_amount_in_symbol, open_order_price, {'base_price': open_order_price, 'stop_px': open_order_price})\r\n\r\nprint(bybit.fetch_order(order['id'], pair_order))\r\n\r\nprint(bybit.fetch_order_trades(order['id'], pair_order))\r\n\r\n```\r\n\r\n```\r\nOrderNotFound: bybit fetchOrder() order 91a5eefa-4345-4ec6-8f06-a1b997eb6ab7 not found\r\n\r\n\r\n[{'id': '9cd501fa-b6b8-59ae-ac38-6bf068b49ed1',\r\n  'info': {'order_id': '91a5eefa-4345-4ec6-8f06-a1b997eb6ab7',\r\n   'order_link_id': '',\r\n   'side': 'Sell',\r\n   'symbol': 'BTCUSDT',\r\n   'exec_id': '9cd501fa-b6b8-59ae-ac38-6bf068b49ed1',\r\n   'price': '18502',\r\n   'order_price': '18502',\r\n   'order_qty': '0.001',\r\n   'order_type': 'Market',\r\n   'fee_rate': '0.0006',\r\n   'exec_price': '19476.5',\r\n   'exec_type': 'Trade',\r\n   'exec_qty': '0.001',\r\n   'exec_fee': '0.0116859',\r\n   'exec_value': '19.4765',\r\n   'leaves_qty': '0',\r\n   'closed_size': '0',\r\n   'last_liquidity_ind': 'RemovedLiquidity',\r\n   'trade_time': '1665332280',\r\n   'trade_time_ms': '1665332280182'},\r\n  'timestamp': 1665332280182,\r\n  'datetime': '2022-10-09T16:18:00.182Z',\r\n  'symbol': 'BTC/USDT:USDT',\r\n  'order': '91a5eefa-4345-4ec6-8f06-a1b997eb6ab7',\r\n  'type': 'market',\r\n  'side': 'sell',\r\n  'takerOrMaker': 'taker',\r\n  'price': 19476.5,\r\n  'amount': 0.001,\r\n  'cost': 19.4765,\r\n  'fee': {'cost': 0.0116859, 'currency': 'USDT', 'rate': 0.0006},\r\n  'fees': [{'currency': 'USDT', 'cost': 0.0116859, 'rate': 0.0006}]}]\r\n\r\n```\r\n\r\nHello,\r\n\r\ni'm trying to get information about filled order on Bybit, but here's something strange. Fetch_order doesn't see an order id and I can't find it in fetch_orders request too. But when I try to call fetch_order_trades, I can see all data about this order. How can I receive this information via fetch_order?\r\n\r\nOn Binance such request worked perfectly.\r\n"
    },
    "satisfaction_conditions": [
      "Order information must be successfully retrieved for stop orders",
      "API request must include correct parameters for the specific order type",
      "Trade execution details must be accessible through the API response"
    ],
    "created_at": "2022-10-09T16:35:32Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/15212",
    "source": {
      "issue_number": 15212
    },
    "initial_question": {
      "title": "MBX_WEIGHT_1M header parameter, know your 1min limits ",
      "body": "Hi, I am using ccxt version 1.81.14 in php. I just talk to Binance customer support and find out that I can know whenever I am going to hit the hard-limits like 1200 weight per 1min. There is a parameter in header, MBX_WEIGHT_1M, from Binance api's response. \r\n\r\nSo my question is, how can we get the header parameter response from ccxt? \r\n\r\nbtw i am using this list of functions:\r\nfor future, i am using $exchange->market, $exchange->fapiPrivate_post_leverage, $exchange->fetchTicker, and $exchange->create_order()\r\n\r\nfor spot, i am just using $exchange->create_market_buy_order\r\n\r\n"
    },
    "satisfaction_conditions": [
      "Access to Binance API response headers must be enabled",
      "Header information must be retrievable after API calls",
      "Weight limit monitoring must be possible during runtime"
    ],
    "created_at": "2022-10-07T07:43:49Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/15165",
    "source": {
      "issue_number": 15165
    },
    "initial_question": {
      "title": "exchange.markets['BTC/USDT']['limits']['leverage']['max'] returns None",
      "body": "I tried to check the MAX Leverage of Binance Future. But my code returns None. I have no idea why I can not see it. Is this bug or am I missing something? I tried 10 different symbols, but every output was None.  I have 200USDT in my Binance Future account.\r\n\r\n- OS: Ubuntu 20.04.5 LTS\r\n- Programming Language version: Python 3.9.6\r\n- CCXT version: 1.94.16\r\n\r\n```\r\nexchange = ccxt.binance({\"apiKey\": key1, \"secret\": key2,\\\r\n                        'options': {'defaultType': 'future'},\\\r\n                        'enableRateLimit': True})\r\n\r\nexchange.load_markets()\r\n\r\nprint(exchange.markets['BTC/USDT']['limits']['leverage']['max'])\r\n```\r\noutput\r\n```\r\nNone\r\n```\r\nIf you know what's going on. Please help me :("
    },
    "satisfaction_conditions": [
      "User understands that leverage information may not be available through the API",
      "User understands this is expected behavior, not a bug"
    ],
    "created_at": "2022-10-02T18:27:23Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/15160",
    "source": {
      "issue_number": 15160
    },
    "initial_question": {
      "title": "Fetching balance state on Bybit returns an empty list",
      "body": "- OS: Windows 10 (WSL2 Ubuntu 20.04)\r\n- Programming Language version: Node.js 18\r\n- CCXT version: 1.92.89\r\n\r\nFetching a balance returns all 0. It does not work both on mainnet and testnet.\r\n\r\nBalance amount for all symbols is returned as 0. API key and secret is a correct one.\r\nSwitching from bybit to binance exchange successfully returns a correct amount of balance, but not on bybit.\r\n\r\nMy actual balance on testnet is: 112,294.98 USD (\u22485.82435910 BTC)\r\n\r\n```\r\nconst ccxt = require('ccxt')\r\n\r\n(async () => {\r\n  const exchange = new ccxt.bybit({\r\n    apiKey: 'xxx',\r\n    secret: 'xxx'\r\n  })\r\n  \r\n  const balance = await exchange.fetchBalance()\r\n  console.log(balance)\r\n})()\r\n```\r\n\r\n```\r\n{\r\n  info: {\r\n    ret_code: '0',\r\n    ret_msg: 'OK',\r\n    result: {\r\n      USDT: [Object],\r\n      DOT: [Object],\r\n      LTC: [Object],\r\n      BIT: [Object],\r\n      MANA: [Object],\r\n      BTC: [Object],\r\n      ETH: [Object],\r\n      EOS: [Object],\r\n      XRP: [Object],\r\n      SOL: [Object],\r\n      ADA: [Object]\r\n    },\r\n    ext_code: '',\r\n    ext_info: '',\r\n    time_now: '1664624408.371975',\r\n    rate_limit_status: '117',\r\n    rate_limit_reset_ms: '1664624408367',\r\n    rate_limit: '120'\r\n  },\r\n  USDT: { free: 0, used: 0, total: 0 },\r\n  DOT: { free: 0, used: 0, total: 0 },\r\n  LTC: { free: 0, used: 0, total: 0 },\r\n  BIT: { free: 0, used: 0, total: 0 },\r\n  MANA: { free: 0, used: 0, total: 0 },\r\n  BTC: { free: 0, used: 0, total: 0 },\r\n  ETH: { free: 0, used: 0, total: 0 },\r\n  EOS: { free: 0, used: 0, total: 0 },\r\n  XRP: { free: 0, used: 0, total: 0 },\r\n  SOL: { free: 0, used: 0, total: 0 },\r\n  ADA: { free: 0, used: 0, total: 0 },\r\n  free: {\r\n    USDT: 0,\r\n    DOT: 0,\r\n    LTC: 0,\r\n    BIT: 0,\r\n    MANA: 0,\r\n    BTC: 0,\r\n    ETH: 0,\r\n    EOS: 0,\r\n    XRP: 0,\r\n    SOL: 0,\r\n    ADA: 0\r\n  },\r\n  used: {\r\n    USDT: 0,\r\n    DOT: 0,\r\n    LTC: 0,\r\n    BIT: 0,\r\n    MANA: 0,\r\n    BTC: 0,\r\n    ETH: 0,\r\n    EOS: 0,\r\n    XRP: 0,\r\n    SOL: 0,\r\n    ADA: 0\r\n  },\r\n  total: {\r\n    USDT: 0,\r\n    DOT: 0,\r\n    LTC: 0,\r\n    BIT: 0,\r\n    MANA: 0,\r\n    BTC: 0,\r\n    ETH: 0,\r\n    EOS: 0,\r\n    XRP: 0,\r\n    SOL: 0,\r\n    ADA: 0\r\n  }\r\n}\r\n```\r\n"
    },
    "satisfaction_conditions": [
      "API credentials successfully authenticate and maintain functionality",
      "Balance data structure maintains expected format"
    ],
    "created_at": "2022-10-01T11:52:12Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/15154",
    "source": {
      "issue_number": 15154
    },
    "initial_question": {
      "title": "OKX batch orders",
      "body": "- OS: Ubuntu 20.04\r\n- Programming Language version: PHP 7.4\r\n- CCXT version: 1.91.22\r\n\r\nJust a simple question: Does CCXT support to place batch orders in one request for OKX exchange? Thanks.\r\n\r\nKind regards.\r\nKai\r\n"
    },
    "satisfaction_conditions": [
      "CCXT must successfully execute batch orders in a single request to OKX exchange",
      "The batch order functionality must be compatible with the OKX API endpoint for batch orders",
      "The order parameters must be properly formatted in the request"
    ],
    "created_at": "2022-09-30T12:24:50Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/15097",
    "source": {
      "issue_number": 15097
    },
    "initial_question": {
      "title": "ccxt.base.errors.ExchangeError: bybit markets not loaded",
      "body": "Hello,\r\n\r\nHow come this doesnt work, and get error : ccxt.base.errors.ExchangeError: bybit markets not loaded\r\n\r\nimport ccxt\r\nsymbol = 'BTCUSDT'\r\nprint(exchange.market(symbol)['precision']['amount'])\r\n\r\nbut this works:\r\n\r\nimport ccxt\r\nsymbol = 'BTCUSDT'\r\nprint(exchange.fetch_ohlcv(symbol, timeframe='1m', limit=1))\r\nprint(exchange.market(symbol)['precision']['amount'])\r\n\r\n- OS: win10\r\n- Programming Language version: python 3.8\r\n- CCXT version: 1.93.43"
    },
    "satisfaction_conditions": [
      "Markets data must be loaded before accessing market details",
      "Market precision information is accessible after proper initialization",
      "The solution maintains the correct execution order"
    ],
    "created_at": "2022-09-24T07:14:43Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/14664",
    "source": {
      "issue_number": 14664
    },
    "initial_question": {
      "title": "Get FTX Future coins list?",
      "body": "Hi I'm looking for a list of coins ending with -PERP for the FTX exchange. \r\n\r\nI tried \r\n\r\n```\r\ncoins = ccxt.ftx({'options': { 'defaultType': 'future', }}).load_markets()\r\n```\r\n\r\nbut it just gives a list of coins with USDT and USD and it's 800 length as opposed to FTX amount of futures (less than 150). \r\n\r\nThis code works for binance, if I just switch ftx() to binance()."
    },
    "satisfaction_conditions": [
      "Returns only perpetual futures markets from FTX exchange",
      "Returns approximately 150-200 markets",
      "Successfully connects to and retrieves data from FTX exchange",
      "Distinguishes between spot and futures markets",
      "Returns valid trading pairs/symbols"
    ],
    "created_at": "2022-08-12T04:47:05Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/14608",
    "source": {
      "issue_number": 14608
    },
    "initial_question": {
      "title": "FTX websockets stream on perpetual very slow ",
      "body": "- OS: Windows\r\n- Programming Language version: Python 3.9.13\r\n- CCXT version: ccxtpro 1.2.10\r\n\r\nThe data recieved from ftx perp pairs is once every 2 seconds(roughly). Which is extremely slow comparing it to the regular BTC/USD pair on FTX which averaged out to 0.053 seconds over a 20 min sample (which in my experience is still on the slow side). I was wondering why it is taking roughly 2 seconds per tick and if i could do anything to make this a lot quicker. Let me know, appreciate your time.\r\n\r\n```\r\nimport ccxtpro\r\nfrom asyncio import run\r\n\r\nasync def main():\r\n    FTX = ccxtpro.ftx({'newUpdates': True})\r\n    while x == True:\r\n        start = time.time()\r\n        orderbook = await FTX.watch_order_book('BTC-PERP') #also used BTC/USD:USD same effect\r\n        print(FTX.iso8601(FTX.milliseconds()), 'BTC/USD:USD', orderbook['bids'][0], orderbook['asks'][0])\r\n        await FTX.close()\r\n\r\nrun(main())\r\n```\r\n\r\n```\r\n2022-08-06T16:59:55.505Z BTC/USD:USD [23157.0, 8.5341] [23158.0, 5.0993]\r\n2022-08-06T16:59:57.518Z BTC/USD:USD [23157.0, 4.196] [23158.0, 15.8474]\r\n2022-08-06T16:59:59.539Z BTC/USD:USD [23157.0, 2.615] [23158.0, 11.1582]\r\n2022-08-06T17:00:01.573Z BTC/USD:USD [23157.0, 0.099] [23158.0, 18.0891]\r\n2022-08-06T17:00:03.598Z BTC/USD:USD [23151.0, 8.7448] [23152.0, 34.0551]\r\n2022-08-06T17:00:05.668Z BTC/USD:USD [23145.0, 0.6389] [23146.0, 18.9104]\r\n2022-08-06T17:00:07.693Z BTC/USD:USD [23142.0, 6.9215] [23143.0, 32.0178]\r\n2022-08-06T17:00:09.728Z BTC/USD:USD [23138.0, 19.8388] [23139.0, 0.2147]\r\n2022-08-06T17:00:11.772Z BTC/USD:USD [23138.0, 22.1469] [23139.0, 0.4077]\r\n2022-08-06T17:00:13.754Z BTC/USD:USD [23142.0, 2.4671] [23143.0, 23.4715]\r\n2022-08-06T17:00:15.797Z BTC/USD:USD [23142.0, 3.4958] [23143.0, 20.8941]\r\n2022-08-06T17:00:17.827Z BTC/USD:USD [23138.0, 3.3549] [23139.0, 30.4348]\r\n```\r\n\r\n"
    },
    "satisfaction_conditions": [
      "WebSocket connection remains persistent between data updates",
      "Data updates are received at intervals of approximately 30-50 milliseconds",
      "Order book data structure remains intact and readable",
      "Timestamp sequence remains chronologically ordered"
    ],
    "created_at": "2022-08-06T17:01:12Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/14584",
    "source": {
      "issue_number": 14584
    },
    "initial_question": {
      "title": "Phemex `fetch_positions` does not support phemex official symbol",
      "body": "Phemex `fetch_positions` does not support phemex official symbol\r\n\r\n## versions\r\n* OS: Debian 11\r\n* Programming Language version: python 3.8.12\r\n* CCXT version: 1.91.68\r\n\r\n## code to reproduce\r\n\r\n### setup\r\n```\r\nimport ccxt\r\n\r\nccxt_exchange = ccxt.phemex({\r\n    'apiKey': ...,\r\n    'secret': ...,\r\n})\r\n```\r\n\r\n### fetch_positions does not support uXXXUSD format\r\n```\r\nccxt_exchange.fetch_positions(symbols=['uBTCUSD']) # => returns `[]`\r\nccxt_exchange.fetch_positions(symbols=['BTC/USD:USD']) # => returns position structured response\r\n```\r\n\r\n### fetch_positions does not support neither inverse formats\r\n```\r\nccxt_exchange.fetch_positions(symbols=['BTCUSD']) # => returns `[]`\r\nccxt_exchange.fetch_positions(symbols=['BTC/USD:BTC']) # => returns `[]`\r\n```"
    },
    "satisfaction_conditions": [
      "Linear contract positions are retrievable using both unified (BTC/USD:USD) and exchange-specific (uBTCUSD) symbol formats",
      "Inverse contract positions are accessible when the correct settlement currency is specified",
      "The API response returns structured position data when valid parameters are provided",
      "The system differentiates between linear and inverse contract types"
    ],
    "created_at": "2022-08-03T15:05:36Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/14556",
    "source": {
      "issue_number": 14556
    },
    "initial_question": {
      "title": "upbit createDepositAddress Error",
      "body": "OS:Windows 10\r\nProgramming Language version:Python\r\nCCXT version:1.90.66\r\nExchange: Upbit\r\nMethod: createDepositAddress\r\n\r\n\r\nAddressPending: upbit is generating BTC deposit address, call fetchDepositAddress or createDepositAddress one more time later to retrieve the generated address\r\n\r\n\r\nI'd like to know why the code exits with that message when generating an address.\r\n\r\nAfter the code ends, I can check in Upbit that the address has been created\r\nBut I can't check it when I create it in python\r\n\r\nI couldn't find it after searching after #6452 for this problem.\r\nI'm a beginner in programming, so I don't know if it's a bug or my skill problem.\r\n"
    },
    "satisfaction_conditions": [
      "Successfully handles asynchronous address generation",
      "Distinguishes between immediate and pending address responses",
      "Retrieves the final deposit address",
      "Handles AddressPending exception appropriately",
      "Implements appropriate retry mechanism"
    ],
    "created_at": "2022-07-31T17:11:34Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/14457",
    "source": {
      "issue_number": 14457
    },
    "initial_question": {
      "title": "Kucoin Futures error retrieving data",
      "body": "- OS: Windows 10\r\n- Programming Language version: Python 3.1\r\n- CCXT version: 1.91.2\r\n\r\n\r\ntrying to fetch my current positing contractsize, amount of contracts and current margin value:\r\n\r\n\r\n```\r\ndef open_positions():\r\n    params = {'type':'swap', 'code':'USD'}\r\n    symbol = 'BTC/USDT:USDT'\r\n    ku_bal = kucoin.fetch_positions(symbols=[symbol], params=params)\r\n    open_positions = ku_bal[0]\r\n    open_positions = ku_bal['info']['data']['maintMargin']\r\n    openpos_side = open_positions[0]['contracts']\r\n    openpos_size = open_positions[0]['contractSize']\r\n```\r\n\r\n```\r\nTraceback (most recent call last):\r\n  File \"reeee\", line 310, in <module>\r\n    bot()\r\n  File \"reeeee\", line 251, in bot\r\n    pnl_close() #checking if we hit pnl\r\n  File \"reeeeee\", line 233, in pnl_close\r\n    kill_switch()\r\n  File \"reeeeeee\", line 136, in kill_switch\r\n    openposi = open_positions()[1]\r\n  File \"reeeeee\", line 112, in open_positions\r\n    open_positions = ku_bal['info']['data']['maintMargin']\r\nTypeError: list indices must be integers or slices, not str\r\n\r\n```\r\n"
    },
    "satisfaction_conditions": [
      "Data retrieval from Kucoin API must complete without TypeError exceptions",
      "Maintenance margin value must be successfully extracted from the API response",
      "Code must handle the actual response structure from the Kucoin API",
      "Position data must be accessed using valid array/object notation"
    ],
    "created_at": "2022-07-23T23:56:13Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/13831",
    "source": {
      "issue_number": 13831
    },
    "initial_question": {
      "title": "How to set market take profit?",
      "body": "The code as follows:\r\n```\r\nimport ccxt\r\nimport time\r\nfrom pprint import pprint\r\nftx = ccxt.ftx({\r\n    'apiKey': 'my_apikey',\r\n    'secret': 'my_secret',\r\n})\r\n\r\nsymbol = 'BTC/USD:USD'\r\nftx.load_markets()\r\nmarket = ftx.market(symbol)\r\nbtc_maket_price = float(market['info']['price'])\r\nbtc_amount = 20 / btc_maket_price\r\ncreate_order = ftx.create_order(symbol, 'market', 'buy', btc_amount)\r\n\r\ntype = 'takeProfit'\r\nside = 'sell'\r\nrise_btc_price = btc_maket_price + btc_maket_price * 0.015\r\nparams = {\r\n    'stopPrice': rise_btc_price,\r\n}\r\norder = ftx.create_order(symbol, type, side, btc_amount, params)\r\n```\r\n\r\nThe errors as follows:\r\nTraceback (most recent call last):\r\n  File \"C:\\Users\\fxu50\\PycharmProjects\\pythonProject1\\contract.py\", line 26, in <module>\r\n    order = ftx.create_order(symbol, type, side, btc_amount, params)\r\n  File \"C:\\Users\\fxu50\\PycharmProjects\\pythonProject1\\ccxt\\ftx.py\", line 1625, in create_order\r\n    raise InvalidOrder(self.id + ' createOrder() does not support order type ' + type + ', only limit, market, stop, trailingStop, or takeProfit orders are supported')\r\nccxt.base.errors.InvalidOrder: ftx createOrder() does not support order type takeProfit, only limit, market, stop, trailingStop, or takeProfit orders are supported"
    },
    "satisfaction_conditions": [
      "Market data must be successfully retrieved before order placement",
      "Take profit price must be calculated and formatted correctly"
    ],
    "created_at": "2022-06-13T18:47:53Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/13818",
    "source": {
      "issue_number": 13818
    },
    "initial_question": {
      "title": "In bybit, fetch_order returns None",
      "body": "- OS: Ubuntu\r\n- Programming Language version: Python\r\n- CCXT version: 1.85.51\r\n\r\n```\r\nimport ccxt\r\nbybit = ccxt.bybit({...})\r\n\r\nsymbol = 'GLMR/USDT:USDT'\r\nresult1 = bybit.create_order(symbol=symbol)\r\nresult2 = bybit.fetch_order(id=result1['id'], symbol=symbol)\r\nprint(result2)\r\n```\r\n\r\n```\r\nNone\r\n```\r\n"
    },
    "satisfaction_conditions": [
      "fetch_order() must return valid order data instead of None",
      "CCXT library version must be compatible with the Bybit API implementation",
      "Order retrieval must work for the specified trading pair format (SYMBOL/QUOTE:QUOTE)",
      "Order fetch must work after order creation in sequence"
    ],
    "created_at": "2022-06-13T08:54:52Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/13712",
    "source": {
      "issue_number": 13712
    },
    "initial_question": {
      "title": "Total balance of a account",
      "body": "Hi, I am not very good in programming so I tried googling on how to use CCXT to get the overall account balance using the \"balance\" function, but no luck. \n\nSo I wonder if anyone can help me out. \nI am trying to get the overall account balance of any exchange, instead of just 1 assets. \n\nThank you in advance."
    },
    "satisfaction_conditions": [
      "Retrieves non-zero balances for all assets in the account",
      "Converts all asset balances to a common currency denomination",
      "Handles both free (available) and locked balances",
      "Handles cases where direct price conversion is unavailable",
      "Produces a single numerical total representing overall account value"
    ],
    "created_at": "2022-06-08T14:40:50Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/13255",
    "source": {
      "issue_number": 13255
    },
    "initial_question": {
      "title": "Is it a joke? MECX futures login",
      "body": "I have code\r\n```\r\nmexc_futures = ccxt.mexc({\r\n    \"apiKey\": config.MEXC_API_KEY,\r\n    \"secret\": config.MEXC_SECRET_KEY,\r\n    \"options\": {'defaultType': 'future' }\r\n})\r\n```\r\nAnd got\r\n```\r\nccxt.base.errors.ExchangeError: mexc does not support 'future' type, set exchange.options['defaultType'] to 'spot', 'margin', 'delivery' or 'future'\r\n```\r\nWhat am i supposed to do?)"
    },
    "satisfaction_conditions": [
      "Valid API credentials must be provided"
    ],
    "created_at": "2022-05-15T10:50:23Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/12943",
    "source": {
      "issue_number": 12943
    },
    "initial_question": {
      "title": "Why fee an trades aren't reported when an order is filled at Binance ?",
      "body": "Hello,\r\n\r\nI try to understand why `fee`, `fees` and `trades` keys are empty in the dictionary returned by the exchange after an order is filled (method `fetchOrder`). Sometime the keys contain data. Please find below two orders executed on ETH/USDT spot market of Binance. One order has values but not the other. What could be the reason ?\r\n\r\nAs you can see both orders have status `FILLED`. One is `sell` the other is `buy`.\r\n\r\n`fee` is null\r\n\r\n`{\"id\": \"8664222318\", \"fee\": null, \"cost\": 18.07068, \"fees\": [], \"info\": {\"side\": \"SELL\", \"time\": \"1650610804472\", \"type\": \"LIMIT\", \"price\": \"3011.78000000\", \"status\": \"FILLED\", \"symbol\": \"ETHUSDT\", \"orderId\": \"8664222318\", \"origQty\": \"0.00600000\", \"isWorking\": true, \"stopPrice\": \"0.00000000\", \"icebergQty\": \"0.00000000\", \"updateTime\": \"1650610829617\", \"executedQty\": \"0.00600000\", \"orderListId\": \"-1\", \"timeInForce\": \"GTC\", \"clientOrderId\": \"6qgr8\", \"origQuoteOrderQty\": \"0.00000000\", \"cummulativeQuoteQty\": \"18.07068000\"}, \"side\": \"sell\", \"type\": \"limit\", \"price\": 3011.78, \"amount\": 0.006, \"filled\": 0.006, \"status\": \"closed\", \"symbol\": \"ETH/USDT\", \"trades\": [], \"average\": 3011.78, \"datetime\": \"2022-04-22T07:00:04.472Z\", \"postOnly\": false, \"remaining\": 0.0, \"stopPrice\": null, \"timestamp\": 1650610804472, \"timeInForce\": \"GTC\", \"clientOrderId\": \"6qgr8\", \"lastTradeTimestamp\": null}`\r\n\r\n`fee` contains data \r\n\r\n`{\"id\": \"8665290466\", \"fee\": {\"cost\": 2.99e-05, \"currency\": \"ETH\"}, \"cost\": 89.71196, \"fees\": [{\"cost\": 2.99e-05, \"currency\": \"ETH\"}], \"info\": {\"side\": \"BUY\", \"type\": \"LIMIT\", \"fills\": [{\"qty\": \"0.02990000\", \"price\": \"3000.40000000\", \"tradeId\": \"807983332\", \"commission\": \"0.00002990\", \"commissionAsset\": \"ETH\"}], \"price\": \"3000.40000000\", \"status\": \"FILLED\", \"symbol\": \"ETHUSDT\", \"orderId\": \"8665290466\", \"origQty\": \"0.02990000\", \"executedQty\": \"0.02990000\", \"orderListId\": \"-1\", \"timeInForce\": \"GTC\", \"transactTime\": \"1650618004892\", \"clientOrderId\": \"8iMM1\", \"cummulativeQuoteQty\": \"89.71196000\"}, \"side\": \"buy\", \"type\": \"limit\", \"price\": 3000.4, \"amount\": 0.0299, \"filled\": 0.0299, \"status\": \"closed\", \"symbol\": \"ETH/USDT\", \"trades\": [{\"id\": \"807983332\", \"fee\": {\"cost\": 2.99e-05, \"currency\": \"ETH\"}, \"cost\": 89.71196, \"fees\": [{\"cost\": \"0.00002990\", \"currency\": \"ETH\"}], \"info\": {\"qty\": \"0.02990000\", \"price\": \"3000.40000000\", \"tradeId\": \"807983332\", \"commission\": \"0.00002990\", \"commissionAsset\": \"ETH\"}, \"side\": \"buy\", \"type\": \"limit\", \"order\": \"8665290466\", \"price\": 3000.4, \"amount\": 0.0299, \"symbol\": \"ETH/USDT\", \"datetime\": null, \"timestamp\": null, \"takerOrMaker\": null}], \"average\": 3000.4, \"datetime\": \"2022-04-22T09:00:04.892Z\", \"postOnly\": false, \"remaining\": 0.0, \"stopPrice\": null, \"timestamp\": 1650618004892, \"timeInForce\": \"GTC\", \"clientOrderId\": \"8iMM1\", \"lastTradeTimestamp\": null}`\r\n\r\n"
    },
    "satisfaction_conditions": [
      "Trade and fee information must be retrievable for all executed orders",
      "System must handle both maker and taker orders correctly",
      "Multiple trades within a single order must be properly aggregated",
      "Fee information must be accessible regardless of the API method used to query the order",
      "System must handle cases where fee information is not directly included in order data"
    ],
    "created_at": "2022-04-22T10:50:23Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/12576",
    "source": {
      "issue_number": 12576
    },
    "initial_question": {
      "title": "Transfer USDT between spot and futures",
      "body": "- OS: Windows \r\n- Programming Language version: 3.10\r\n- CCXT version: 1.77.62\r\n\r\n```\r\nimport time\r\nstart = time.time()\r\nexchange.sapi_post_futures_transfer({\r\n    'asset': 'USDT',\r\n    'amount': '10',\r\n    'type': 2,\r\n})\r\nend = time.time()\r\n```\r\nI want to take a long position in the spot market and a short position in the future market. To do that, I have to make a USDT transfer between spot and future wallets. My question is:\r\n\r\nExecution time of the above transfer code is around 1 second. Except for USDT transfer between wallets, my entire code, including creating orders, takes milliseconds. Since USDT transfer takes 1 second, is there a risk that the order execution code runs before USDT transfer so the order can not be implemented due to lack of funds? If so, what would be the best solution?\r\n\r\nMaybe I should clarify my question\r\nLet's say that I am in full long position and I receive short signal. So I have to close all long positions, transfer USDT to future wallet and open short positions. Transferring USDT takes around 1 second. I wonder if there is a risk that execution order code(opening short positions) runs before money transfer? If it happens there wont be enough funds to open short position.\r\n"
    },
    "satisfaction_conditions": [
      "USDT transfer must complete before order execution",
      "Code execution sequence must be guaranteed regardless of transfer duration",
      "Trading operations must handle varying transfer latencies"
    ],
    "created_at": "2022-03-31T13:52:37Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/12512",
    "source": {
      "issue_number": 12512
    },
    "initial_question": {
      "title": "In using CCXT for FTX exchange, is there a simple/smart way to retrieve the values of current account Leverage, Total collateral and Free collateral?",
      "body": "In using CCXT for FTX exchange, is there a simple/smart way to retrieve the values of current Leverage, Total collateral and Free collateral?"
    },
    "satisfaction_conditions": [
      "Successfully retrieves current leverage value from the account",
      "Successfully retrieves total collateral value",
      "Successfully retrieves free collateral value",
      "Maintains proper authentication with FTX exchange",
      "Returns data in a structured format that distinguishes between different collateral types"
    ],
    "created_at": "2022-03-27T11:12:40Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/12034",
    "source": {
      "issue_number": 12034
    },
    "initial_question": {
      "title": "Question: precision of assets",
      "body": "Got a question regarding precision of assets.\r\nIt's not clear to me if precision of the same asset/currency if always the same all exchange markets. Or can it be different?\r\nCan I use precision from Currency or should I always use precision from Market (base or quote depending where my currency is). \r\n\r\nFor example, is it possible that BTC on WAVES/BTC (as quote) has precision 8 and on BTC/LTC (as base) has precision 7? \r\nAnyone? Thank you in advance!\r\n"
    },
    "satisfaction_conditions": [
      "System must handle varying precision levels for the same asset across different market pairs on the same exchange",
      "System must distinguish between trading precision and withdrawal precision",
      "System must correctly determine precision based on both market-level and currency-level specifications",
      "System must have a fallback mechanism when currency-specific precision is not provided"
    ],
    "created_at": "2022-02-20T07:29:48Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/11176",
    "source": {
      "issue_number": 11176
    },
    "initial_question": {
      "title": "How to pass sub account argument to Binance exchange instantiation",
      "body": "I can't find anywhere the syntax to tell Binance to load data (.fetchBalance(), .fetch_positions()) only on a subaccount?\r\nOn FTX, I would add the below to the parameters dict:\r\n'headers': {'FTX-SUBACCOUNT': 'YOURSUBACCOUNTNAME'}\r\n\r\nI've tried replacing the headers key by 'BINANCE-SUBACCOUNT', or 'SUBACCOUNT', but everytime I get error 2015:\r\n{AuthenticationError}binance {\"code\":-2015,\"msg\":\"Invalid API-key, IP, or permissions for action.\"}"
    },
    "satisfaction_conditions": [
      "Compatible with Binance's API authentication model"
    ],
    "created_at": "2022-01-08T17:02:23Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/10751",
    "source": {
      "issue_number": 10751
    },
    "initial_question": {
      "title": "[okex] Networks indexed improperly",
      "body": "Dear fellows,\r\nokex.js -> options\r\n\r\n```                \r\n'networks': {\r\n    'ETH': 'ERC20',\r\n    'TRX': 'TRC20',\r\n    'OMNI': 'Omni',\r\n},\r\n```\r\nare indexed wrongly, the networks in other parts of ccxt (exchange.currencies.networks for example) are indexed by ERC20, TRC20, etc.\r\nI suggest to unify it (e.g. binance, kucoin, etc):\r\n```javascript\r\nbinance: \r\n                'networks': {\r\n                    'ERC20': 'ETH',\r\n                    'TRC20': 'TRX',\r\n                    'BEP2': 'BNB',\r\n                    'BEP20': 'BSC',\r\n                    'OMNI': 'OMNI',\r\n                    'EOS': 'EOS',\r\n                    'SPL': 'SOL',\r\n                },\r\nkucoin:\r\n\r\n                'networks': {\r\n                    'ETH': 'eth',\r\n                    'ERC20': 'eth',\r\n                    'TRX': 'trx',\r\n                    'TRC20': 'trx',\r\n                    'KCC': 'kcc',\r\n                    'TERRA': 'luna',\r\n                },\r\n```\r\n\r\nThere is also issue with default value in withdraw function, which allows invalid network ID to get into withdrawal requests:\r\n```javascript\r\n        network = this.safeString (networks, network, network); // handle ETH>ERC20 alias\r\n```\r\n\r\nEDIT: the options might just need to by extended with ERC20, TRC20, etc."
    },
    "satisfaction_conditions": [
      "Network identifiers must be bi-directionally mappable between exchange-specific and unified formats",
      "API methods must accept both unified and exchange-specific network identifiers",
      "Network mapping system must maintain consistency with exchange's API requirements",
      "System must handle unknown network identifiers gracefully"
    ],
    "created_at": "2021-12-01T13:27:01Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/10495",
    "source": {
      "issue_number": 10495
    },
    "initial_question": {
      "title": "what is the proper way to fetchfunctios with a single binance apikey",
      "body": "OS: Ubuntu 20.04\r\nProgramming Language version: Javascript Node js\r\nCCXT version: 1.60.10\r\n\r\nHow many cctx object I need to create to get all my positions. In the documentation to get the linear positions I need to create a \r\n`\r\n            exchangeusdm = new ccxt.binanceusdm\r\n`\r\n\r\nwhile for the coin base futures, I need to create a \r\n`\r\n           exchangecoinm = new ccxt.binancecoinm\r\n`\r\nI checked the code and I see that both extend from finance\r\nI am creating a code that needs to get all positions, balance, and all assets of a user\r\nmy questions are: \r\nDo I need to create both objects with the same API key to get the inverted and linear positions ?\r\nIs there a situation where I also need to create  the usual binance object\r\n`\r\n           exchangecoinm = new ccxt.binance\r\n`"
    },
    "satisfaction_conditions": [
      "Separate exchange instances must be created for different market types (spot, USDM futures, COINM futures)",
      "The same API key must work across all required exchange instances",
      "All user positions must be accessible across different market types",
      "Exchange instances must maintain distinct market type contexts"
    ],
    "created_at": "2021-11-05T19:03:13Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/10439",
    "source": {
      "issue_number": 10439
    },
    "initial_question": {
      "title": "ByBit Close Position",
      "body": "\r\n- OS: MacOs\r\n- Programming Language version: Python 3.9.4\r\n- CCXT version: 1.60.9\r\n\r\n```\r\nsymbol = 'SOLUSDT'\r\ntrade_res = exchange.create_order(symbol, amount=1, type='Market', side='Buy')\r\n```\r\n\r\nThe above snippet buys 1 SOL against USDT. When I try to close the position by placing a sell order, I see that ByBit placed another Short position on SOL without closing the Long one (2 positions appear in the console)\r\n\r\nHow do I close a current open position on ByBit using ccxt?\r\n"
    },
    "satisfaction_conditions": [
      "Position closure must result in a single closed position rather than creating an opposing position",
      "Order parameters must explicitly indicate position closure intent",
      "Solution must work within ByBit's API constraints"
    ],
    "created_at": "2021-11-02T12:27:58Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/9886",
    "source": {
      "issue_number": 9886
    },
    "initial_question": {
      "title": "How to set leverage for Binance SPOT Trades  ?",
      "body": "\r\n- OS: WIndows\r\n- Programming Language version: Python\r\n- CCXT version: 1.55.15\r\n   \r\ncode:\r\n              leverage=exchange.set_leverage(symbol='BTC/USDT, leverage=2)\r\n              print(lev)\r\n\r\nError :\r\n              binance setLeverage() supports linear and inverse contracts only\r\n\r\n\r\nNote: It's working fine for future or delivery. ( 'defaultType':  'delivery', # 'future', )\r\n\r\n"
    },
    "satisfaction_conditions": [
      "Market type configuration must match the intended trading operation",
      "User must understand market type compatibility"
    ],
    "created_at": "2021-08-27T14:21:56Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/9880",
    "source": {
      "issue_number": 9880
    },
    "initial_question": {
      "title": "Python ratelimiter broken",
      "body": "The python rateLimiter is broken in the newest version.\r\nI tested this on python 3.7 and 3.8 (Debian and CentOS)\r\n\r\nThe following snippet should return, but it is stuck after the first loop.\r\n\r\n```\r\nimport asyncio\r\nimport ccxt.async_support\r\n\r\n\r\nasync def main():\r\n    exchange1 = ccxt.async_support.hitbtc({\"enableRateLimit\": True})\r\n    exchange2 = ccxt.async_support.hitbtc({\"enableRateLimit\": True})\r\n    for i in range(0, 20):\r\n        await exchange1.throttle(exchange1.rateLimit)\r\n        await exchange2.throttle(exchange2.rateLimit)\r\n        print(\"Round done\")\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    asyncio.run(main())\r\n```"
    },
    "satisfaction_conditions": [
      "Rate limiting functionality executes without getting stuck",
      "Proper throttling delay is applied based on exchange requirements",
      "Multiple exchange instances can be rate limited concurrently",
      "Rate limiting accepts cost parameter instead of rateLimit"
    ],
    "created_at": "2021-08-26T09:34:50Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/9321",
    "source": {
      "issue_number": 9321
    },
    "initial_question": {
      "title": "Transfer between Binance wallets return status, datetime and timestamp = None",
      "body": "Hello all,\r\n\r\nI noticed that transfer between Binance wallets return some missing information, please find an example:\r\n\r\n```\r\nb.transfer('USDT', 1, 'future', 'spot')\r\n\r\n{'info': {'tranId': '65052934028'},\r\n 'id': '65052934028',\r\n 'timestamp': None,\r\n 'datetime': None,\r\n 'currency': 'USDT',\r\n 'amount': 1,\r\n 'fromAccount': 'future',\r\n 'toAccount': 'spot',\r\n 'status': None}\r\n```\r\n\r\nAs you can see status, timestamp and datetime are set to None even when transfer is successful. It's a minor issue but it's useful to have these data in order to monitor transfers.\r\n\r\nBest,\r\nKinzowa\r\n\r\n"
    },
    "satisfaction_conditions": [
      "Timestamp data must be obtainable when needed",
      "Solution must handle missing API response fields gracefully",
      "Transfer monitoring functionality must remain possible",
      "Solution must be compatible with exchange API limitations"
    ],
    "created_at": "2021-06-05T10:17:15Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/9207",
    "source": {
      "issue_number": 9207
    },
    "initial_question": {
      "title": "FTX: Can't cancel opened Order / Can't get Order ID's of open Orders (PHP)",
      "body": "i can successfully create orders with :\r\n\r\n`$exchange->create_order($symbol, $type, $side, $amount, $price, $params);`\r\n```\r\nArray\r\n(\r\n    [info] => Array\r\n        (\r\n            [id] => 44022042\r\n            [market] => BTC-PERP\r\n            [future] => BTC-PERP\r\n            [side] => sell\r\n            [type] => take_profit\r\n            [orderPrice] => 48100.0\r\n            [triggerPrice] => 47000.0\r\n            [size] => 0.001\r\n            [status] => open\r\n            [createdAt] => 2021-05-18T20:09:03.654365+00:00\r\n            [triggeredAt] => \r\n            [orderId] => \r\n            [error] => \r\n            [reduceOnly] => \r\n            [trailValue] => \r\n            [trailStart] => \r\n            [cancelledAt] => \r\n            [cancelReason] => \r\n            [retryUntilFilled] => \r\n            [orderType] => limit\r\n        )\r\n\r\n    [id] => 44022042\r\n    [clientOrderId] => \r\n    [timestamp] => 1621368543654\r\n    [datetime] => 2021-05-18T20:09:03.654Z\r\n    [lastTradeTimestamp] => \r\n    [symbol] => BTC-PERP\r\n    [type] => take_profit\r\n    [timeInForce] => \r\n    [postOnly] => \r\n    [side] => sell\r\n    [price] => 47000\r\n    [stopPrice] => 47000\r\n    [amount] => 0.001\r\n    [cost] => \r\n    [average] => \r\n    [filled] => \r\n    [remaining] => \r\n    [status] => open\r\n    [fee] => \r\n    [trades] => \r\n)\r\n\r\n```\r\n\r\nbut if i want to close this order with\r\n`$exchange->cancel_order(44022042)`\r\n\r\n\r\ni get an error\r\n\r\n`ccxt\\OrderNotFound: ftx {\"success\":false,\"error\":\"Order not found\"}`\r\n\r\n\r\n\r\nalso \r\n\r\n`$exchange->fetch_open_orders() `returns an empty array even though i have open orders\r\n\r\n\r\n\r\n"
    },
    "satisfaction_conditions": [
      "Conditional orders must be identifiable as distinct from regular orders when canceling",
      "Conditional open orders must be retrievable through the API",
      "Position status must be determinable from response data"
    ],
    "created_at": "2021-05-18T20:15:36Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/9188",
    "source": {
      "issue_number": 9188
    },
    "initial_question": {
      "title": "What Time Does The Day Roll Over?",
      "body": "Quick question: When do daily 'candles' roll over in ccxt? I am pulling daily data on a US server and for my system I need to know when the date stamps roll over into the new day/date. My understanding thus far is that it happens at 0:00 GMT. \r\n\r\nIf correct then the roll over would be e.g. at 8:00pm in NYC, and 1:00am in London.\r\n\r\nCan you please confirm or correct?"
    },
    "satisfaction_conditions": [
      "Timestamp synchronization matches UTC standard",
      "Daily candle rollovers occur at 00:00 UTC",
      "Local time conversions accurately reflect UTC offset",
      "Time standard remains consistent regardless of DST changes"
    ],
    "created_at": "2021-05-16T09:57:11Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/9103",
    "source": {
      "issue_number": 9103
    },
    "initial_question": {
      "title": "exchange.timeframes['1d'] missing from ByBit",
      "body": "When i try using **exchange.timeframes['1d']** for ByBit exchange - i see this error: **[ExceptionsHandler] timeframe unit D is not supported**\r\n\r\n```typescript\r\n          for (const date of dates) {\r\n            await sleep(exchange.rateLimit); // milliseconds\r\n            const fData = await exchange.fetchOHLCV(\r\n              symbol,\r\n              exchange.timeframes['1d'],\r\n              exchange.parse8601(`${date}T00:00:00Z`),\r\n              1,\r\n            );\r\n```\r\nHow fix this problem, i need 1 day timeframe? I'm using last version of ccxt 1.49.21"
    },
    "satisfaction_conditions": [
      "The OHLCV data request must successfully execute without timeframe errors",
      "The retrieved data must represent daily (1-day) intervals",
      "The solution must be compatible with the ByBit exchange API",
      "The existing date parsing and rate limiting functionality must remain intact"
    ],
    "created_at": "2021-05-01T10:27:21Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/9046",
    "source": {
      "issue_number": 9046
    },
    "initial_question": {
      "title": "Stale Price Feed from Binance USDT Futures & FTX",
      "body": "Hi Kroitor,\r\n\r\nI think I'm getting a stale/delayed price feed from Binance USDT Futures and FTX. I only need the Best Bid & Offer from each of the exchanges pushed in real-time (I don't need orderbooks). Sometimes the FTX price or the Binance price just stops updating. Is there anything in the code you can see that would be causing this?\r\n\r\nimport threading\r\nimport asyncio\r\nimport ccxtpro\r\nimport loggin_util\r\nfrom definitions.exchanges import Exchanges\r\nfrom definitions.trading_util import ConnectionState\r\nimport ccxtpro_exchanges\r\nimport definitions.app_values as apv\r\n\r\n\r\n# from principal import Principal\r\n\r\n\r\nclass DataFeedManager(threading.Thread):\r\n    def __init__(self, exchange: Exchanges, symbol_name: str, data_coin_command, print_info: bool,\r\n                 entry_delta: float, exit_delta: float, entry_size: float, _data_feed_stopped,\r\n                 _executing_methods_event, assigned_pair_id):\r\n        threading.Thread.__init__(self)\r\n        self.exchange = exchange\r\n        self.symbol_name = symbol_name\r\n        self.print_info = print_info\r\n        self.print_info = False  # for testing\r\n        self.bid = 0.0\r\n        self.ask = 0.0\r\n        self.entry_delta = entry_delta\r\n        self.exit_delta = exit_delta\r\n        self.entry_size = entry_size\r\n        self.logger = loggin_util.create_logger(__name__ + '_' + self.exchange.name + '_' +\r\n                                                self.symbol_name.replace('/', ''))\r\n        self.conn_state = ConnectionState.DISCONNECTED\r\n        self.data_coin_command = data_coin_command\r\n        self.data_feed_enabled = True\r\n        self.data_feed_stopped = _data_feed_stopped\r\n        self.executing_methods_event = _executing_methods_event\r\n        self.binance_pro = ccxtpro.binance({'enableRateLimit': True,\r\n                                            'options': {\r\n                                                'defaultType': 'future',\r\n                                            }})\r\n        self.ftx_pro = ccxtpro.ftx({'enableRateLimit': True})\r\n        self.assigned_pair_id = assigned_pair_id\r\n\r\n        # print(self.symbol_id.replace('/', ''))\r\n\r\n    async def get_tick(self):\r\n        exchange_switcher = {\r\n            Exchanges.binance: ccxtpro.binance({'enableRateLimit': True,\r\n                                                'apiKey': apv.binance_api_key,\r\n                                                'secret': apv.binance_secret_key,\r\n                                                'options': {\r\n                                                    'defaultType': 'future',\r\n                                                    'watchTicker': {\r\n                                                        'name': 'bookTicker'\r\n                                                    }\r\n                                                }}),\r\n            Exchanges.ftx: ccxtpro.ftx({'enableRateLimit': True}),\r\n        }\r\n        exchange = exchange_switcher.get(self.exchange)\r\n        while self.data_feed_stopped.wait():\r\n\r\n            if not self.data_feed_enabled:\r\n                print(\"Stopping Data Feed\")\r\n                self.data_feed_stopped.clear()\r\n                print(\"Data Feed Stopped? %s\" % self.data_feed_stopped)\r\n                break\r\n\r\n            if self.print_info: print(\"----------------------\")\r\n            if self.print_info: print(\"data_feed_enabled: %s\" % self.data_feed_enabled)\r\n            if self.print_info: print(exchange.id)\r\n            if self.print_info: print(\"Symbol: \", self.symbol_name)\r\n\r\n            try:\r\n                # order_book = await exchange.watch_order_book(self.symbol_name)\r\n                order_book = await exchange.watch_ticker(self.symbol_name)\r\n            except Exception as e:\r\n                self.conn_state = ConnectionState.DISCONNECTED\r\n                self.logger.error('Disconnected')\r\n                print(\"Exception: \", e)\r\n                continue\r\n            if self.conn_state == ConnectionState.DISCONNECTED:\r\n                self.logger.info('Connected')\r\n                self.conn_state = ConnectionState.CONNECTED\r\n\r\n            # self.bid = order_book['bids'][0][0] if len(order_book['bids']) > 0 else None\r\n            # self.ask = order_book['asks'][0][0] if len(order_book['asks']) > 0 else None\r\n            self.bid = order_book['bid'] if order_book['bid'] is not None else self.bid\r\n            self.ask = order_book['ask'] if order_book['ask'] is not None else self.ask\r\n            spread = (self.ask - self.bid) if (self.bid and self.ask) else None\r\n            mid = (self.bid + self.ask) / 2 if (self.bid and self.ask) else None\r\n            if self.print_info: print(\"bid: \", self.bid)\r\n            if self.print_info: print(\"ask: \", self.ask)\r\n            if self.print_info: print(\"spread: \", spread)\r\n            if self.print_info: print(\"mid: \", mid)\r\n            self.data_coin_command(self.symbol_name,\r\n                                   self.bid,\r\n                                   self.ask,\r\n                                   self.entry_delta,\r\n                                   self.exit_delta,\r\n                                   self.entry_size,\r\n                                   self.executing_methods_event,\r\n                                   self.assigned_pair_id)\r\n\r\n    def run(self):\r\n        asyncio.run(self.get_tick())"
    },
    "satisfaction_conditions": [
      "Best Bid and Offer (BBO) data must be consistently available",
      "Connection state must be properly monitored and handled",
      "Multiple exchange feeds must operate concurrently",
      "Error states must not cause complete system failure"
    ],
    "created_at": "2021-04-22T08:03:42Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/8739",
    "source": {
      "issue_number": 8739
    },
    "initial_question": {
      "title": "Is it safe to use prices from the orderdepths directly in regard of price precision",
      "body": "OS: Windows Server 2019 Datacenter\r\nProgramming Language version: Node.js 15.3.0\r\nCCXT version: 1.38.89\r\nExchange: All Exchanges\r\nMethod: precision and limits\r\n\r\nHello!\r\n\r\nI have a question about the precision when it comes to prices for a symbol when creating limit and marketorders.\r\n\r\nFor example we can get the orderbook like below:\r\n```\r\n(async () => {\r\nconst exchange = new ccxt.bitfinex({ enableRateLimit: true, agent, 'timeout': 10000 });\r\nconst orderbook = await exchange.fetchOrderBook(\"ETH/BTC\", 5);\r\nconsole.log(orderbook);\r\n})()\r\n```\r\nThis gives a structure like this with price and volume per orderdepth:\r\n```\r\n    [ 0.030365, 7.76077035 ],\r\n    [ 0.030366, 7 ],\r\n    [ 0.030368, 0.069 ],\r\n    [ 0.03037, 1.19718266 ],\r\n    [ 0.030376, 12 ]\r\n```\r\n\r\nMy question is how safe it would be to directly just use the price from any of the orderdepths when `createOrder(...)`\r\nWhat I mean, would it be safe to just take a price without using the `exchange.decimalToPrecision` to round it to correct precision.\r\n\r\nWould it be safe to just take the prices from the orderdepths from all exchanges or should one anyway use `exchange.decimalToPrecision` function for safety?\r\n\r\nThank you!\r\n\r\n"
    },
    "satisfaction_conditions": [
      "Order prices from orderbook depths must be accepted by the exchange when used in order creation",
      "Price precision must match exchange requirements without additional formatting",
      "CCXT library must handle any necessary price formatting automatically"
    ],
    "created_at": "2021-03-28T20:10:02Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/8515",
    "source": {
      "issue_number": 8515
    },
    "initial_question": {
      "title": "Currencies precision returning None [Binance, BitMEX]",
      "body": "- OS: Linux Ubuntu 18.04 LTS\r\n- Programming Language version: Python 3.9.1\r\n- CCXT version: 1.42.29\r\n\r\nWhen calling for the loaded currencies, the precision is returning None;\r\n```\r\nself._client.currencies.items()\r\n```\r\n\r\n```\r\n{'id': 'AAVE', 'numericId': None, 'code': 'AAVE', 'precision': None}\r\n```\r\n\r\nI think this started from around  1.42.18\r\nTested on Binance spot and BitMEX\r\n"
    },
    "satisfaction_conditions": [
      "Currency precision values must be correctly populated when markets are active",
      "System must handle inactive markets appropriately",
      "Currency data structure must maintain consistent format",
      "Precision values must match the exchange's specifications"
    ],
    "created_at": "2021-02-24T19:55:08Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/8379",
    "source": {
      "issue_number": 8379
    },
    "initial_question": {
      "title": "Issue with timestamp parse of data feed needs help",
      "body": "Hi,\r\nI have some problems to read the timestamp from the datafeed download from CCXT. No matter what I tried, it can't parse the datetime info.\r\n\r\nPandas code:\r\n\r\n> dataframe = pandas.read_csv(\r\n        datapath,\r\n        skiprows=1,\r\n        header=1,\r\n        date_parser=parsedate,\r\n        parse_dates=True,\r\n        index_col=0,\r\n    )\r\n\r\n\r\n\r\ndata feed format:\r\n>  Timestamp,Open,High,Low,Close,Volume\r\n    1611658800000,32247.2,32249.98,32105.36,32139.29,616.047753\r\n    1611659700000,32139.29,32186.61,31807.19,31968.65,804.456726\r\n    1611660600000,31968.65,32048.88,31733.0,32040.8,680.101376\r\n  \r\nFirstly, pandas default date parser couldn't process it and returned error\r\n```\r\n  dt = tstamp.to_pydatetime()\r\nAttributeError: 'numpy.int64' object has no attribute 'to_pydatetime'\r\n```\r\n\r\nSecondly I defined a parser function but returned error :\r\n```\r\nValueError: year 53041 is out of range\r\n```\r\n\r\n parser function:\r\n\r\n>  def parsedate(timestamp):\r\n    if type(timestamp) is str: timestamp = int(timestamp)  # put up with timestamp being in string format\r\n    if timestamp > 1e10: timestamp // 1000 # put up with timestamp being in microseconds\r\n    return datetime.utcfromtimestamp(float(timestamp)).replace(tzinfo=tz.tzutc())\r\n\r\n\r\n- OS: Mac\r\n- Programming Language version: python3\r\n- CCXT version: newest\r\n"
    },
    "satisfaction_conditions": [
      "Timestamp values must be correctly converted from milliseconds to valid datetime objects",
      "Parsed dates must fall within reasonable chronological range",
      "Solution must work within pandas read_csv date parsing framework"
    ],
    "created_at": "2021-02-02T05:15:59Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/8374",
    "source": {
      "issue_number": 8374
    },
    "initial_question": {
      "title": "'ccxt' has no attribute ...",
      "body": "Something wrong, just installed ccxt and tried demo code to print ccxt.version or ccxt.exchanges, but doesn't work\r\n\r\n- OS:\r\n- Programming Language version: python 3.9.1\r\n- CCXT version: ccxt-1.41.31\r\n\r\n```\r\nimport ccxt\r\nprint(ccxt.exchanges) # print a list of all available exchange classes\r\n```\r\n\r\n```\r\nAttributeError: partially initialized module 'ccxt' has no attribute 'version' (most likely due to a circular import)\r\n```\r\n"
    },
    "satisfaction_conditions": [
      "CCXT package is properly installed and accessible",
      "Python environment has all required dependencies"
    ],
    "created_at": "2021-01-31T14:47:44Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/8366",
    "source": {
      "issue_number": 8366
    },
    "initial_question": {
      "title": "Missing symbols on Binance",
      "body": "Hi there,\r\nthere seems to be missing symbols on Binance, specifically running `[s for s in exchange.symbols if 'BTC' in s]` in python returns only `['BTC/BUSD', 'BTC/USDT']`. The same holds for `[s for s in exchange.markets.keys() if 'BTC' in s]`. Other exchanges seem to be ok.\r\n\r\nccxt version: 1.41.19\r\npython: 3.8.7\r\nos: win 10"
    },
    "satisfaction_conditions": [
      "All expected BTC trading pairs are visible in the exchange symbols list",
      "The exchange configuration correctly specifies the intended market type",
      "The exchange.symbols query returns the complete set of available trading pairs for the specified market type",
      "The exchange initialization parameters produce consistent results across different CCXT versions"
    ],
    "created_at": "2021-01-29T17:10:43Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/8339",
    "source": {
      "issue_number": 8339
    },
    "initial_question": {
      "title": "Inconsistent symbol names for Binance Futures",
      "body": "\r\n- OS: Linux\r\n- Programming Language version: Python 3.8.6 and Python 3.8.5\r\n- CCXT version: 1.40.83\r\n- \r\nCode:\r\n```\r\nexchange.load_markets()\r\nsymbols = exchange.symbols\r\nprint(symbols)\r\n```\r\nIn my workstation it gives: \r\n```\r\n['1INCHUSDT', 'AAVEUSDT', 'ADAUSDT', 'AKROUSDT', 'ALGOUSDT', 'ALPHAUSDT', 'ATOMUSDT', 'AVAXUSDT', 'AXSUSDT', 'BALUSDT', 'BANDUSDT', 'BATUSDT', 'BCHUSDT', 'BELUSDT', 'BLZUSDT', 'BNBUSDT', 'BTCBUSD', 'BTCUSDT', 'BZRXUSDT', 'CHZUSDT', 'COMPUSDT', 'CRVUSDT', 'CTKUSDT', 'CVCUSDT', 'DASHUSDT', 'DEFIUSDT', 'DOGEUSDT', 'DOTECOUSDT', 'DOTUSDT', 'EGLDUSDT', 'ENJUSDT', 'EOSUSDT', 'ETCUSDT', 'ETHUSDT', 'FILUSDT', 'FLMUSDT', 'FTMUSDT', 'GRTUSDT', 'HNTUSDT', 'ICXUSDT', 'IOSTUSDT', 'IOTAUSDT', 'KAVAUSDT', 'KNCUSDT', 'KSMUSDT', 'LINKUSDT', 'LRCUSDT', 'LTCUSDT', 'MATICUSDT', 'MKRUSDT', 'NEARUSDT', 'NEOUSDT', 'OCEANUSDT', 'OMGUSDT', 'ONTUSDT', 'QTUMUSDT', 'RENUSDT', 'RLCUSDT', 'RSRUSDT', 'RUNEUSDT', 'SKLUSDT', 'SNXUSDT', 'SOLUSDT', 'SRMUSDT', 'STORJUSDT', 'SUSHIUSDT', 'SXPUSDT', 'THETAUSDT', 'TOMOUSDT', 'TRBUSDT', 'TRXUSDT', 'UNIUSDT', 'VETUSDT', 'WAVESUSDT', 'XLMUSDT', 'XMRUSDT', 'XRPUSDT', 'XTZUSDT', 'YFIIUSDT', 'YFIUSDT', 'ZECUSDT', 'ZENUSDT', 'ZILUSDT', 'ZRXUSDT']\r\n\r\n```\r\nBut in the server (with same ccxt version but python 3.8.5) it gives:\r\n\r\n```\r\n['1INCH/USDT', 'AAVE/USDT', 'ADA/USDT', 'AKRO/USDT', 'ALGO/USDT', 'ALPHA/USDT', 'ATOM/USDT', 'AVAX/USDT', 'AXS/USDT', 'BAL/USDT', 'BAND/USDT', 'BAT/USDT', 'BCH/USDT', 'BEL/USDT', 'BLZ/USDT', 'BNB/USDT', 'BTC/BUSD', 'BTC/USDT', 'BZRX/USDT', 'CHZ/USDT', 'COMP/USDT', 'CRV/USDT', 'CTK/USDT', 'CVC/USDT', 'DASH/USDT', 'DEFI/USDT', 'DOGE/USDT', 'DOT/USDT', 'DOTECO/USDT', 'EGLD/USDT', 'ENJ/USDT', 'EOS/USDT', 'ETC/USDT', 'ETH/USDT', 'FIL/USDT', 'FLM/USDT', 'FTM/USDT', 'GRT/USDT', 'HNT/USDT', 'ICX/USDT', 'IOST/USDT', 'IOTA/USDT', 'KAVA/USDT', 'KNC/USDT', 'KSM/USDT', 'LINK/USDT', 'LRC/USDT', 'LTC/USDT', 'MATIC/USDT', 'MKR/USDT', 'NEAR/USDT', 'NEO/USDT', 'OCEAN/USDT', 'OMG/USDT', 'ONT/USDT', 'QTUM/USDT', 'REN/USDT', 'RLC/USDT', 'RSR/USDT', 'RUNE/USDT', 'SKL/USDT', 'SNX/USDT', 'SOL/USDT', 'SRM/USDT', 'STORJ/USDT', 'SUSHI/USDT', 'SXP/USDT', 'THETA/USDT', 'TOMO/USDT', 'TRB/USDT', 'TRX/USDT', 'UNI/USDT', 'VET/USDT', 'WAVES/USDT', 'XLM/USDT', 'XMR/USDT', 'XRP/USDT', 'XTZ/USDT', 'YFI/USDT', 'YFII/USDT', 'ZEC/USDT', 'ZEN/USDT', 'ZIL/USDT', 'ZRX/USDT']\r\n\r\n```\r\nThis is currently breaking my deployment, any idea how to fix?\r\n\r\nEdit:\r\n\r\nAlso on one place it's saying symbol is BTC/USDT and on another place it's saying the symbol is BTCUSDT:\r\n\r\n```\r\n'id': 'BTCUSDT',\r\n\t\t'lowercaseId': 'btcusdt',\r\n\t\t'symbol': 'BTC/USDT',\r\n\t\t'base': 'BTC',\r\n\t\t'quote': 'USDT',\r\n\t\t'baseId': 'BTC',\r\n\t\t'quoteId': 'USDT',\r\n\t\t'info': {\r\n\t\t\t'symbol': 'BTCUSDT',\r\n...\r\n\r\n```"
    },
    "satisfaction_conditions": [
      "Symbol mapping remains functionally equivalent"
    ],
    "created_at": "2021-01-24T17:00:22Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/8310",
    "source": {
      "issue_number": 8310
    },
    "initial_question": {
      "title": "Precision in markets where the buy order is given in quote currency",
      "body": "Hello,\r\n\r\nI have a question regarding the market precision dictionary in exchanges where the buy order amount must be provided in quote currency. \r\n\r\nEven if the buy amount must be provided in quote currency, the precision dictionary of these markets does not include the 'cost' key, which is basically the amount in quote currency. They only provide the 'amount' (the amount in base currency) and 'price' keys. Therefore, I do not understand which one should I pick (or transform) to check the precision of the market in quote currency.\r\n\r\nThis problem does not exist in exchanges where every (buy and sell) amount must be provided in base currency as the precision dictionary does include the 'amount' key which is expressed in base currency.\r\n\r\nThank you very much in advance,\r\n\r\nUnai\r\n"
    },
    "satisfaction_conditions": [
      "The solution must provide a way to determine precision for quote currency amounts",
      "The precision handling must work for markets where buy orders are specified in quote currency",
      "The solution must work with the available precision dictionary fields",
      "The precision determination must be consistent with the exchange's requirements"
    ],
    "created_at": "2021-01-19T13:50:26Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/8179",
    "source": {
      "issue_number": 8179
    },
    "initial_question": {
      "title": "[binance] -2011 error handling",
      "body": "We currently have `'-2011': OrderNotFound` in binance.  This error happens when you use an orderId in a cancel operation, but that ID is not in the binance database yet.  Basically, it appears that the Rest API talks to a database that lags behind slightly, so the order is legitimate, but it's just not in the db yet.  Is OrderNotFound the correct thing to use?"
    },
    "satisfaction_conditions": [
      "Error code -2011 must be handled appropriately for temporary order not found states",
      "Error handling must acknowledge the ambiguity between temporary and permanent order not found states",
      "Error message must accurately reflect the order's not found status",
      "Error handling must be compatible with Binance's REST API behavior"
    ],
    "created_at": "2020-12-30T11:36:45Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/7996",
    "source": {
      "issue_number": 7996
    },
    "initial_question": {
      "title": "[Binance] get X-MBX-USED-WEIGHT and X-MBX-ORDER-COUNT from http response headers",
      "body": "Hi,\r\n\r\nMay I know if ccxt supports getting http header from the response?\r\nI want to fetch some info from that header (as title).\r\n\r\nThanks,\r\nHien"
    },
    "satisfaction_conditions": [
      "HTTP response headers must be accessible from the API response",
      "Header access method must persist across multiple API calls",
      "Header access must be possible within the CCXT library context"
    ],
    "created_at": "2020-11-19T14:53:21Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/7979",
    "source": {
      "issue_number": 7979
    },
    "initial_question": {
      "title": "Limit order always executes at maximum set limit price",
      "body": "There is smth I don't understand about limit orders and how they are executed on binance. I am led to believe that a limit order will execute at the limit set **_or better_**. But based on numerous tests, I see it always executes at the limit set, no matter how high it is set. Here is an example for a buy order, where I set the limit at 10% higher (which is ridiculously high just to make the point) than the ask price. \r\n\r\n```\r\nprice:\r\n{'ask': 0.003907, 'bid': 0.003904}\r\n\r\norders:\r\n[{'info': {'symbol': 'LTCBTC', 'orderId': 437641845, 'orderListId': -1, 'clientOrderId': 'some-id', 'transactTime': 1605473031619, 'price': '0.00429700', 'origQty': '0.65000000', 'executedQty': '0.65000000', 'cummulativeQuoteQty': '0.00253912', 'status': 'FILLED', 'timeInForce': 'GTC', 'type': 'LIMIT', 'side': 'BUY'}, 'id': '437641845', 'clientOrderId': 'fjkfdjfdjk', 'timestamp': 1605473031619, 'datetime': '2020-11-15T20:43:51.619Z', 'lastTradeTimestamp': None, 'symbol': 'LTC/BTC', 'type': 'limit', 'side': 'buy', 'price': 0.004297, 'amount': 0.65, 'cost': 0.00253912, 'average': 0.003906338461538462, 'filled': 0.65, 'remaining': 0.0, 'status': 'closed', 'fee': None, 'trades': None}]\r\n```\r\nask price: 0.003907\r\nexecuted price: 0.004297 -> 10% increase \r\n\r\nIs there smth I don't understand? "
    },
    "satisfaction_conditions": [
      "The actual execution price must be visible and distinguishable from the limit price",
      "The average execution price must be less than or equal to the limit price for buy orders",
      "Order data must show both the original limit price and the actual execution details",
      "For orders filled with multiple trades, individual trade prices must be accessible",
      "The average price field must accurately reflect the weighted average of all trades that filled the order"
    ],
    "created_at": "2020-11-15T20:45:38Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/7961",
    "source": {
      "issue_number": 7961
    },
    "initial_question": {
      "title": "FTX conditional order price update",
      "body": "Programming Language version: Python 3.7 ( 64bit)\r\nCCXT version: 1.37.59\r\nFTX market\r\n\r\nHi\r\nHow can i update the price of conditional trigger orders without delete it ?\r\nI am using the Stop limit order and try to update the price.\r\n\r\nThis is my place trigger method\r\n`                    side = input1\r\n                    stopPrice = input2\r\n                    quantity = input3\r\n                    orderid=0\r\n                    limitPrice=None\r\n                   `\r\n\r\n\r\n` orderid = self.exchange.createOrder(self.symbol, \"stop\", side, quantity, limitPrice, { \"triggerPrice\": stopPrice })[\"info\"][\"id\"]`"
    },
    "satisfaction_conditions": [
      "Conditional trigger order price must be successfully updated",
      "CCXT library must be compatible with the FTX exchange API",
      "Solution must handle order ID changes",
      "Original order attributes must be preserved except for the modified price"
    ],
    "created_at": "2020-11-12T08:31:38Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/7830",
    "source": {
      "issue_number": 7830
    },
    "initial_question": {
      "title": "[binance] Is it possible to access coin-margined (delivery) futures?",
      "body": "I can access binance USDT futures with {'defaultType': 'future'}\r\nBut is it possible to access binance COIN futures ? (ex. BTCUSD Quarterly 1225)\r\n"
    },
    "satisfaction_conditions": [
      "Access to coin-margined futures markets is established",
      "Market symbols for coin-margined futures are retrievable",
      "Configuration allows switching from default futures to delivery futures",
      "Integration maintains compatibility with existing Binance API functionality"
    ],
    "created_at": "2020-10-19T13:38:26Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/7507",
    "source": {
      "issue_number": 7507
    },
    "initial_question": {
      "title": "Do the recent metainfo update PRs suggest incoming deprecation?",
      "body": "I noticed that @An-Net has updated many `has` dicts of different exchanges, sometimes e.g. adding `'fetchTicker': true` despite it already being defaulted in the Exchange base class. Does this mean there is a plan to default all to `False`? (I'm asking because in that case I'll have to make some changes in my own repos)."
    },
    "satisfaction_conditions": [
      "Clarification provided about the purpose of metainfo updates",
      "Impact on existing code base is addressed",
      "Explanation of metainfo documentation practices is provided"
    ],
    "created_at": "2020-08-24T10:27:20Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/7469",
    "source": {
      "issue_number": 7469
    },
    "initial_question": {
      "title": "phemex decimal issue watch_order_book",
      "body": "- OS: macOS 10.13.6\r\n- Programming Language version: 3.6.0\r\n- CCXT version: ccxt 1.33.15 | ccxtpro 0.3.43\r\n\r\n```\r\nclient = ccxtpro.phemex()\r\nwhile True:\r\n    ccxt_orderbook = await client.watch_order_book(\r\n        \"ETH/USD\",\r\n        params={}\r\n    )\r\n```\r\n\r\n```\r\nTraceback (most recent call last):\r\n  File \"execution.py\", line 1669, in subscribe_book\r\n    params={}\r\n  File \"python3.6/site-packages/ccxtpro/phemex.py\", line 280, in watch_order_book\r\n    await self.load_markets()\r\n  File \"python3.6/site-packages/ccxt/async_support/base/exchange.py\", line 180, in load_markets\r\n    raise e\r\n  File \"python3.6/site-packages/ccxt/async_support/base/exchange.py\", line 176, in load_markets\r\n    result = await self.markets_loading\r\n  File \"python3.6/site-packages/ccxt/async_support/base/exchange.py\", line 165, in load_markets_helper\r\n    currencies = await self.fetch_currencies()\r\n  File \"python3.6/site-packages/ccxt/async_support/phemex.py\", line 692, in fetch_currencies\r\n    maxAmount = float(self.decimal_to_precision(maxValueEv * precision, ROUND, 0.00000001, self.precisionMode))\r\n  File \"python3.6/site-packages/ccxt/base/decimal_to_precision.py\", line 74, in decimal_to_precision\r\n    missing = abs(dec) % precision_dec\r\ndecimal.InvalidOperation: [<class 'decimal.DivisionImpossible'>]\r\n```\r\n"
    },
    "satisfaction_conditions": [
      "The exchange.load_markets() function executes successfully",
      "The system can successfully fetch and process currency information from Phemex"
    ],
    "created_at": "2020-08-15T18:21:21Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/7116",
    "source": {
      "issue_number": 7116
    },
    "initial_question": {
      "title": "Kucoin fetchBalance method returning empty data",
      "body": "Hello,\r\nI have 2 accounts at Kucoin, when trying to call the fetchBalance method in one of them, the API returns the balance to me normally, but when calling this same method in another account, it returns me a json with empty data, why does this happen? I checked the Key / Secret / Phrase API and it is correct, because I am getting the status 200000\r\n\r\n- OS: CentOS 7\r\n- Programming Language version: JavaScript\r\n- CCXT version: 1.28.95\r\n\r\n```\r\nasync getBalance() {\r\n        let balance = []\r\n        try {\r\n            balance = await this.kucoin.fetchBalance()\r\n        } catch (e) {\r\n            let error = {\r\n                error: this.extractErrorMessage(e.message)\r\n            }\r\n            return error\r\n        }\r\n        return balance\r\n    }\r\n```\r\n\r\n```\r\n{ info: { code: '200000', data: [] },\r\n  free: {},\r\n  used: {},\r\n  total: {} }\r\n```\r\n\r\n\r\n"
    },
    "satisfaction_conditions": [
      "API authentication is successful",
      "API response contains expected balance data structure",
      "Method handles both populated and empty balance scenarios",
      "Error handling preserves API response integrity"
    ],
    "created_at": "2020-06-14T01:34:20Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/7110",
    "source": {
      "issue_number": 7110
    },
    "initial_question": {
      "title": "How to use test api?",
      "body": "Hi, I notice that many exchanges have test accounts or apis such as Bitmex, thus their ccxt exchange instance have test url too. So is there a way for ccxt to use the test api automatically, instead of any error of bad Apikey or something else?"
    },
    "satisfaction_conditions": [
      "Test/sandbox API environment is successfully activated",
      "Exchange instance connects to test URL instead of production",
      "Configuration can be applied before making API calls"
    ],
    "created_at": "2020-06-13T06:25:05Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/7033",
    "source": {
      "issue_number": 7033
    },
    "initial_question": {
      "title": "How to get Huobi bid/ask price with watchTicker?",
      "body": "Language: Python\r\n\r\nHi @kroitor \r\nI have decided to purchase ccxpro!\r\n\r\nTwo things that I have noticed initially:\r\n-The repository cannot be installed using Poetry (pip works fine), it has an exit code 1.\r\n-Huobi `watch_ticker` is not returning the \"ask\" or \"bid\", which is a bummer since I bought CCXTPRO for that reason \ud83e\udd23 .\r\nI can use `watch_order_book`, but it will take me a lot of refactoring to do..\r\n\r\nIs it possible to add `\"ask\"/\"bid\"` to Huobipro? \r\n\r\n"
    },
    "satisfaction_conditions": [
      "Access to real-time bid/ask price data must be achieved through an available data source",
      "Data retrieval method must be compatible with Huobi Pro's API limitations",
      "Package installation must complete successfully",
      "Real-time price monitoring functionality must be maintained"
    ],
    "created_at": "2020-05-28T13:16:00Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/6995",
    "source": {
      "issue_number": 6995
    },
    "initial_question": {
      "title": "Binance watchOrders / watchBalance not returning a value immediately",
      "body": "I try to use `watchOrders()` and `watchBalance()` but both with node.js and in the browser, after connecting to the websocket for private methods, there does not seem to be any communication. When I change below method from `watchBalance()` to `fetchBalance()` it does work fine.\r\n\r\n- OS: macOS 10.15.4\r\n- Programming Language version: NodeJS v12.16.3\r\n- CCXT version: pro 0.2.13\r\n\r\n```JavaScript\r\n'use strict';\r\n\r\nconst ccxtpro = require('.');\r\n\r\n(async () => {\r\n\r\n    const exchange = new ccxtpro.binance({ enableRateLimit: true })\r\n\r\n    exchange.apiKey = 'x';\r\n    exchange.secret = 'x';\r\n\r\n\r\n    (async () => {\r\n\r\n        while (true) {\r\n            try {\r\n                const balance = await exchange.watchBalance()\r\n                console.log(balance)\r\n            } catch (e) {\r\n                console.log(e)\r\n            }\r\n        }\r\n\r\n    })()\r\n})()\r\n\r\n```\r\n\r\n"
    },
    "satisfaction_conditions": [
      "WebSocket connection successfully receives balance updates when balance changes occur",
      "User understands that initial state is not automatically provided",
      "Application can obtain initial balance state",
      "Continuous WebSocket connection maintenance",
      "Proper authentication for private data access"
    ],
    "created_at": "2020-05-22T16:57:56Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/6993",
    "source": {
      "issue_number": 6993
    },
    "initial_question": {
      "title": "How to use this.hmac for signature generation?",
      "body": "Hi,\r\n\r\nI'm trying to write the sign method to an exchange, yet without success.\r\nThe problem happens in the signature generation.\r\n\r\nIn javascript: \r\n\r\nfunction generateSignature(key, secret, nonce) {\r\n   var message = nonce + key; \r\n   var hash = CryptoJS.HmacSHA256(message, secret);\r\n   var hashInBase64 = CryptoJS.enc.Base64.stringify(hash);\r\n   return hashInBase64;\r\n}\r\n\r\nit works, but I'm in doubt how to write it with ccxt syntax. \r\nBased on the signature of other exchanges(I read binance, kraken, etc), I'm trying hash and hmac:\r\n\r\n         } else {\r\n             this.checkRequiredCredentials ();\r\n             const nonce = this.nonce ().toString ();\r\n             url += path;\r\n             const message = nonce + this.apiKey;\r\n             const hash = this.hash (this.encode (message), 'sha256', 'base64');\r\n             const signature = this.hmac (hash, this.encode (this.secret), 'sha256', 'base64');\r\n             headers = {\r\n                 'Content-Type': 'application/x-www-form-urlencoded',\r\n                 'key': this.apiKey,\r\n                 'nonce': nonce,\r\n                 'signature': signature,\r\n             };\r\n\r\nI'm getting: ccxt.base.errors.ExchangeNotAvailable: POST ...... 400 Bad Request {\"error\":true,\"data\":{\"message\":\"Invalid signature. Verify key and signature.\"}}\r\n\r\nCan anyone help me to translate the above generateSignature to the ccxt syntax?\r\n\r\nThank you.\r\n\r\nErico."
    },
    "satisfaction_conditions": [
      "Message string combines nonce and API key in correct order",
      "Final signature output is Base64 encoded",
      "HMAC-SHA256 algorithm is used with the correct secret key",
      "Request headers contain all required authentication fields"
    ],
    "created_at": "2020-05-22T16:08:56Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/6961",
    "source": {
      "issue_number": 6961
    },
    "initial_question": {
      "title": "Position Open Date",
      "body": "Hi guys, \r\nOn deribit, I would like to know the date (timestamp) a position has been opened at. \r\nI am aware I can get timestamp for trades, but is there any way to do the same for a position ?\r\nThanks in advance for any insight!\r\n"
    },
    "satisfaction_conditions": [
      "Explanation clarifies the relationship between positions and trades",
      "Provides method to determine position opening time",
      "Explains why positions themselves don't have direct timestamps",
      "Addresses the difference between zero and non-zero positions"
    ],
    "created_at": "2020-05-17T13:59:44Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/6765",
    "source": {
      "issue_number": 6765
    },
    "initial_question": {
      "title": "Closing position on Bybit?",
      "body": "Hello, how to close open position using ccxt in bybit"
    },
    "satisfaction_conditions": [
      "Position balance reaches zero after execution",
      "Order quantity matches the original position size",
      "Order direction is opposite to the original position"
    ],
    "created_at": "2020-04-09T20:38:45Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/6674",
    "source": {
      "issue_number": 6674
    },
    "initial_question": {
      "title": "Unable to resolve module './js/btcchina.js'",
      "body": "- OS: Debian 10 android apk 29\r\n- Programming Language version: react-native 0.61.5\r\n- CCXT version: 1.24.96\r\n\r\n```\r\nSimply put var ccxt = require('ccxt'); into any module\r\n```\r\n\r\n```\r\n[Wed Mar 25 2020 11:31:13.196]  BUNDLE  ./index.js \r\n\r\nerror: Error: Unable to resolve module `./js/btcchina.js` from `node_modules/ccxt/ccxt.js`: \r\n\r\nNone of these files exist:\r\n  * node_modules/ccxt/js/btcchina.js(.native|.android.js|.native.js|.js|.android.json|.native.json|.json|.android.ts|.native.ts|.ts|.android.tsx|.native.tsx|.tsx)\r\n  * node_modules/ccxt/js/btcchina.js/index(.native|.android.js|.native.js|.js|.android.json|.native.json|.json|.android.ts|.native.ts|.ts|.android.tsx|.native.tsx|.tsx)\r\n    at ModuleResolver.resolveDependency (/home/marcel/ReactNative/FusionCommerce/node_modules/@react-native-community/cli/node_modules/metro/src/node-haste/DependencyGraph/ModuleResolution.js:163:15)\r\n    at ResolutionRequest.resolveDependency (/home/marcel/ReactNative/FusionCommerce/node_modules/@react-native-community/cli/node_modules/metro/src/node-haste/DependencyGraph/ResolutionRequest.js:52:18)\r\n    at DependencyGraph.resolveDependency (/home/marcel/ReactNative/FusionCommerce/node_modules/@react-native-community/cli/node_modules/metro/src/node-haste/DependencyGraph.js:287:16)\r\n    at Object.resolve (/home/marcel/ReactNative/FusionCommerce/node_modules/@react-native-community/cli/node_modules/metro/src/lib/transformHelpers.js:267:42)\r\n    at dependencies.map.result (/home/marcel/ReactNative/FusionCommerce/node_modules/@react-native-community/cli/node_modules/metro/src/DeltaBundler/traverseDependencies.js:434:31)\r\n    at Array.map (<anonymous>)\r\n    at resolveDependencies (/home/marcel/ReactNative/FusionCommerce/node_modules/@react-native-community/cli/node_modules/metro/src/DeltaBundler/traverseDependencies.js:431:18)\r\n    at /home/marcel/ReactNative/FusionCommerce/node_modules/@react-native-community/cli/node_modules/metro/src/DeltaBundler/traverseDependencies.js:275:33\r\n    at Generator.next (<anonymous>)\r\n    at asyncGeneratorStep (/home/marcel/ReactNative/FusionCommerce/node_modules/@react-native-community/cli/node_modules/metro/src/DeltaBundler/traverseDependencies.js:87:24)\r\n```\r\n"
    },
    "satisfaction_conditions": [
      "Module resolution error for btcchina.js must be eliminated",
      "CCXT library must be properly integrated with React Native project",
      "Project dependencies must be in a clean and consistent state",
      "Application must successfully bundle after changes"
    ],
    "created_at": "2020-03-25T11:36:28Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/6550",
    "source": {
      "issue_number": 6550
    },
    "initial_question": {
      "title": "I got \"amount is invalid\" error when i try to withdraw",
      "body": "- OS: Mac OS Catalina\r\n- Programming Language version: Node.js\r\n- CCXT version: 1.23.1\r\n- Exchange: Bitmex\r\n- Method: withdraw\r\n\r\nThis is my route:\r\n\r\n```\r\nrouter.post('/withdraw', async (req, res, next) => {\r\n  const {code, address, amount, otpToken, currency } = req.body;\r\n\r\n  const exchange = await new ccxt.bitmex();\r\n  exchange.apiKey = \"MY - KEY\";\r\n  exchange.secret = \"MY - SECRET\";\r\n\r\n  await exchange.withdraw (code, amount, address, tag = undefined, params = {}, otpToken)\r\n  .then((response) => console.log(res))\r\n  .catch(ex => console.log(ex))\r\n\r\n});\r\n```\r\n\r\nAnd this is what i am trying to post:\r\n\r\n{\r\n    \"address\": \"THE ADRESS\",\r\n    \"amount\": 0.0022,\r\n    \"code\": \"BTC\",\r\n    \"otpToken\": \"MY TOKEN\"\r\n}\r\n\r\nWhen i execute this route, i get this error:\r\nBadRequest: bitmex {\"error\":{\"message\":\"amount is invalid\",\"name\":\"HTTPError\"}}\r\n\r\nThe key and the secret are OK. The otpToken too. I can fetch everything.\r\nI\u00b4m new on this, and i can\u00b4t figure it out where is the error on my code.\r\n\r\nThank you!!\r\n"
    },
    "satisfaction_conditions": [
      "Withdrawal functionality remains compatible with the exchange's API specifications",
      "Original withdrawal parameters (address, currency, OTP) remain properly handled"
    ],
    "created_at": "2020-03-02T15:36:00Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/6546",
    "source": {
      "issue_number": 6546
    },
    "initial_question": {
      "title": "Limited L2 orderbook does not produce consistent amount of results - CCXT PRO",
      "body": "- OS: Win10\r\n- Programming Language version: Python 3.8\r\n- CCXT version: 0.0.47\r\n- Exchange: Binance, WS\r\n\r\n```\r\nimport ccxtpro\r\nimport asyncio\r\n\r\nasync def main():\r\n    exchange = ccxtpro.binance({'enableRateLimit': True})\r\n    while True:\r\n        orderbook = await exchange.watch_order_book('ETH/BTC', 10) #INCONSISTENT, see below\r\n        print(len(orderbook['asks']), len(orderbook['bids']))\r\n\r\nasyncio.get_event_loop().run_until_complete(main())\r\n\r\n```\r\n\r\nResults:\r\n\r\n```\r\n10 10\r\n10 10\r\n10 9\r\n9 10\r\n10 10\r\n10 10\r\n10 10\r\n10 9\r\n10 10\r\n```\r\n\r\nand:\r\n```\r\n        orderbook = await exchange.watch_order_book('ETH/BTC', 1)\r\n        print(orderbook['asks'][0]), (orderbook['bids'][0])\r\n```\r\nProduces (after some correct results):\r\n```\r\n    print(orderbook['asks'][0]), (orderbook['bids'][0])\r\nIndexError: list index out of range\r\n```"
    },
    "satisfaction_conditions": [
      "Orderbook data retrieval continues without crashing when orders are removed",
      "Number of returned orders must be less than or equal to the requested limit",
      "System clearly communicates the variable nature of orderbook size",
      "Real-time orderbook updates reflect current market state"
    ],
    "created_at": "2020-03-01T14:39:07Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/6499",
    "source": {
      "issue_number": 6499
    },
    "initial_question": {
      "title": "how to make a stoploss in binance?",
      "body": "how can i make a stoplimit order in both futures and spot?\r\nfirst i fetch orderId and call \r\nbinance.fapiPrivate_post_order({type:\"STOP_MARKET/TAKE_PROFIT_MARKET\" }) \r\nis it right?? but don't i need orderId to match quantity for the exact order?\r\nand what about the spot trade stoplimit?\r\n\r\nthanks"
    },
    "satisfaction_conditions": [
      "Stop order parameters must be correctly configured for the appropriate market type (futures vs spot)",
      "Stop order must be created without requiring a reference to an existing order ID",
      "Order parameters must include the required stop price and quantity values",
      "Implementation must use the correct API endpoint for the chosen market type"
    ],
    "created_at": "2020-02-18T05:31:28Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/6252",
    "source": {
      "issue_number": 6252
    },
    "initial_question": {
      "title": "[bitstamp] why is fetchOrder 'emulated'",
      "body": "`fetchOrder` in bitstamp It looks like a proper implementation, why is it market as 'emulated'?"
    },
    "satisfaction_conditions": [
      "The order fetching functionality works as expected"
    ],
    "created_at": "2019-12-11T19:21:35Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/6128",
    "source": {
      "issue_number": 6128
    },
    "initial_question": {
      "title": "Anyone using Lykke?  Is it safe",
      "body": "Their private API doesn't use a private key (or nonce) so the sign method in ccxt doesn't actually sign anything.  The API Key just goes across the wire as a clear text header."
    },
    "satisfaction_conditions": [
      "API communication must be secured against interception",
      "Key rotation mechanism must be available",
      "Sensitive operations must require additional authentication",
      "Security approach must be consistent with industry practices",
      "Risk mitigation procedures must be documented"
    ],
    "created_at": "2019-11-13T12:07:55Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/6057",
    "source": {
      "issue_number": 6057
    },
    "initial_question": {
      "title": "[question] rate limit error type?",
      "body": "Is the `DDoSProtection` network error the one to use if a _rate limit exceeded_ type error is encountered?"
    },
    "satisfaction_conditions": [
      "Error handling must appropriately identify rate limit scenarios",
      "Error type must reflect the protective nature of rate limiting",
      "Error hierarchy must maintain logical inheritance"
    ],
    "created_at": "2019-10-29T10:01:23Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/6032",
    "source": {
      "issue_number": 6032
    },
    "initial_question": {
      "title": "Passing keys to cli.py from keys.json",
      "body": "I've hunted for an answer. Using cli.py\r\n\r\nHow to pass keys from keys.json or keys.local.json to cli.py ? My below attempt failed. \r\n\r\n`    \"bitforex\":      { \"skip\": true },\r\n    \"bithumb\":       { \"skip\": true },\r\n    \"bitmex\":       {\"apiKey\": '****', \"secret\": '****'},\r\n    \"bitibu\":        { \"skip\": true },\r\n    \"bitkk\":         { \"skip\": true },\r\n`\r\n\r\n- OS: Ubuntu 18\r\n- Programming Language version: python\r\n- CCXT version: latest\r\n- Exchange: Bitmex\r\n- Method: keys\r\n"
    },
    "satisfaction_conditions": [
      "JSON file must contain valid JSON syntax",
      "API credentials must be properly structured under exchange name",
      "Configuration file must be in one of the expected locations",
      "Local configuration must override shared configuration"
    ],
    "created_at": "2019-10-24T10:09:15Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/5930",
    "source": {
      "issue_number": 5930
    },
    "initial_question": {
      "title": "Oceanex API has different dynamics. Uses 2048 key.pem to generate key. How to get ccxt to work with oceanex?",
      "body": "Language: Python\r\nCCXT Version: Latest\r\nExchange: ccxt.oceanex()\r\n\r\nGeneral question, Ive successfully created a key on this exchange. Would like some guidance on what to place in the apiKey and secret attributes? Was the 2048 pem key placed as the apiKey attribute? \r\n\r\nThanks."
    },
    "satisfaction_conditions": [
      "API key field contains valid exchange-issued identifier",
      "Secret field contains complete RSA private key in PEM format",
      "PEM key formatting is preserved"
    ],
    "created_at": "2019-10-06T21:39:54Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/5550",
    "source": {
      "issue_number": 5550
    },
    "initial_question": {
      "title": "question: coinfloor ledger parse",
      "body": "The Coinfloor transactions api returns trades and transactions.  When parsing a trade I'm facing with the following:\r\n\r\n         {\r\n             \"datetime\": \"2017-07-25 06:41:24\",\r\n             \"id\": 1500964884381265,\r\n             \"type\": 2,\r\n             \"xbt\": \"0.1000\",\r\n             \"xbt_eur\": \"2322.00\",\r\n             \"eur\": \"-232.20\",\r\n             \"fee\": \"0.00\",\r\n             \"order_id\": 84696745\r\n         }\r\n\r\nShould this result in 2 rows in the ledger (0.1BTC in and 232.2EUR out)?  If so, how do I implement that in `parseLedgerEntry`?"
    },
    "satisfaction_conditions": [
      "Single trade transaction must generate two separate ledger entries",
      "Ledger parsing must maintain data consistency with pagination",
      "Parser must handle both single and multiple entry responses",
      "Resulting ledger entries must be properly aggregated into a single array"
    ],
    "created_at": "2019-07-18T15:36:46Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/5359",
    "source": {
      "issue_number": 5359
    },
    "initial_question": {
      "title": "Format sub-account Binance request",
      "body": "I'm looking into the Implicit API Methods of the manual but can't figure out how to call those sub-account functions for Binance.\r\n\r\nI thought it would be:\r\n\r\n`privateGetSubAccountList()\r\n`\r\n\r\nBut that doesn't work. Tried a few different ones but no luck. Any chance you could steer me in the right direction?\r\n\r\n\r\nLanguage: NodeJs\r\nExchange: Binance"
    },
    "satisfaction_conditions": [
      "API method name correctly maps to Binance's sub-account endpoint",
      "Method name follows CCXT's implicit API naming conventions",
      "Special characters in endpoint paths are properly handled"
    ],
    "created_at": "2019-06-25T12:58:21Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/5345",
    "source": {
      "issue_number": 5345
    },
    "initial_question": {
      "title": "[therock] dealing with delisted currency",
      "body": "I'm getting this error when requesting withdrawals: `therock does not have currency code USD`.\r\n\r\nThat currency used to be supported.  Is there a recommended way to deal with this?  I'm thinking to just pass the `currency` directly."
    },
    "satisfaction_conditions": [
      "System must handle requests for previously supported but now delisted currencies without errors",
      "Currency code recognition must be restored for withdrawal operations",
      "Solution must maintain compatibility with existing exchange API structure",
      "Currency code must be properly mapped to a valid exchange identifier"
    ],
    "created_at": "2019-06-23T17:34:27Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/5296",
    "source": {
      "issue_number": 5296
    },
    "initial_question": {
      "title": "New Exchange: HollaEx",
      "body": "All endpoints added and tested. Failed test for Python, unsure why.\r\n\r\n```\r\n<type 'exceptions.KeyError'> 'hollaex' \r\n\r\n          File \"python/test/test.py\", line 403, in <module>\r\n            main()\r\n\r\n          File \"python/test/test.py\", line 380, in main\r\n            exchange = exchanges[argv.exchange] (explain @ run-tests.js:173)\r\n\r\n\r\nFAIL [\"hollaex\"] (run-tests.js:251)\r\n```\r\n\r\n\r\n\r\n"
    },
    "satisfaction_conditions": [
      "No global CCXT package conflicts with local testing environment",
      "Exchange identifier is properly registered in the testing environment",
      "Testing environment has all required dependencies installed",
      "Exchange configuration is properly loaded before test execution"
    ],
    "created_at": "2019-06-14T01:19:09Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/5260",
    "source": {
      "issue_number": 5260
    },
    "initial_question": {
      "title": "Possible bug in commonCurrencies",
      "body": "- OS: *\r\n- Programming Language version: python\r\n- CCXT version: 1.18.593-643\r\n- Exchange: bitfinex\r\n- Method: commonCurrencies\r\n\r\nHi, I'm using the commonCurrencies in my code for margin trading on bitfinex. It think this has been broken in a recent release. You can see this the following way:\r\n\r\nif I do:\r\n```Python\r\nprint(str(ccxt.bitfinex.commonCurrencies.items()))\r\n```\r\nI get:\r\n```\r\ndict_items([('XBT', 'BTC'), ('BCC', 'BCH'), ('DRK', 'DASH'), ('BCHABC', 'BCH'), ('BCHSV', 'BSV')])\r\n```\r\n\r\nWhile this is not the list found in the bitfinex.py.. My guess is that this is Kraken (?)\r\n\r\nOr am I making a mistake somewhere? "
    },
    "satisfaction_conditions": [
      "Correct currency data is accessed using the appropriate property",
      "Markets are properly loaded before accessing currency data",
      "Exchange-specific currency list is retrieved",
      "Rate limiting is properly configured"
    ],
    "created_at": "2019-06-08T00:00:42Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/5069",
    "source": {
      "issue_number": 5069
    },
    "initial_question": {
      "title": "Bitfinex JS symbols.map is not a functiom",
      "body": "- OS: Javascript\r\n- Programming Language version: v11.13.0\r\n- CCXT version: latest\r\n- Exchange: bitfinex\r\n- Method: fetchTickers\r\n\r\nError: TypeError: symbols.map is not a function\r\n"
    },
    "satisfaction_conditions": [
      "Rate limiting must be properly configured"
    ],
    "created_at": "2019-05-07T04:46:35Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/5028",
    "source": {
      "issue_number": 5028
    },
    "initial_question": {
      "title": "1M gives 1m results",
      "body": "Looks like 1M (monthly timeframes according to docs) gives the minutely interval (1m).\r\nThe demonstration below is done in the node command line and as you can see, the resulting OHLCV data is only 1 minute apart.\r\n\r\n- OS: OSX\r\n- Programming Language version: NodeJS v10.15.3\r\n- CCXT version: 1.18.489\r\n- Exchange: kraken\r\n- Method: fetch_ohlcv()\r\n\r\n```\r\n> var ccxt                  = require ('ccxt');\r\nundefined\r\n> var datasource = new ccxt['kraken']()\r\nundefined\r\n> var promise =  this.datasource.fetch_ohlcv(\"ETH/USD\", \"1M\", 1516150760000)\r\nundefined\r\n> promise\r\nPromise {\r\n  [ [ 1556151180000, 165.71, 165.86, 165.71, 165.86, 6.83113309 ],\r\n    [ 1556151240000, 165.87, 165.89, 165.82, 165.89, 93.13941199 ],\r\n    [ 1556151300000, 165.89, 166.71, 165.89, 166.32, 790.36810312 ],\r\n    [ 1556151360000, 166.32, 166.37, 166.3, 166.33, 131.81207007 ],\r\n    [ 1556151420000, 166.33, 166.33, 165.9, 165.94, 27.16285409 ],\r\n    [ 1556151480000, 165.94, 166.11, 165.89, 166.09, 8.02807113 ],\r\n    [ 1556151540000, 166.09, 166.21, 166.09, 166.21, 0.55489426 ],\r\n    [ 1556151600000, 166.21, 166.22, 166.2, 166.22, 5.37958814 ],\r\n    [ 1556151660000, 166.22, 166.22, 165.9, 165.9, 14.72007301 ],\r\n    [ 1556151720000, 165.97, 165.98, 165.89, 165.9, 7.15311929 ],\r\n    [ 1556151780000, 165.9, 166.02, 165.89, 165.97, 12.7562017 ],\r\n    [ 1556151840000, 165.97, 165.97, 165.8, 165.8, 6.21435547 ],\r\n    [ 1556151900000, 165.8, 165.8, 165.8, 165.8, 6.50588532 ],\r\n    [ 1556151960000, 165.8, 165.83, 165.65, 165.65, 21.70730336 ],\r\n    [ 1556152020000, 165.65, 165.66, 165.61, 165.66, 101.22979868 ],\r\n    [ 1556152080000, 165.71, 165.79, 165.65, 165.65, 63.29969223 ],\r\n    [ 1556152140000, 165.56, 165.69, 165.53, 165.57, 23.3977552 ],\r\n    [ 1556152200000, 165.57, 165.57, 165.55, 165.55, 4.78227673 ],\r\n    [ 1556152260000, 165.55, 165.56, 165.55, 165.55, 5.04401131 ],\r\n    [ 1556152320000, 165.55, 165.55, 165.5, 165.51, 77.24501892 ],\r\n    [ 1556152380000, 165.51, 165.51, 165.5, 165.5, 0.11443401 ],\r\n    [ 1556152440000, 165.5, 165.5, 165.5, 165.5, 3.71300558 ],\r\n    [ 1556152500000, 165.5, 165.56, 165.5, 165.52, 23.28890123 ],\r\n    [ 1556152560000, 165.65, 165.65, 165.6, 165.62, 21.24251921 ],\r\n    [ 1556152620000, 165.62, 165.73, 165.6, 165.6, 153.83321368 ],\r\n    [ 1556152680000, 165.6, 165.6, 165.55, 165.58, 254.47546306 ],\r\n    [ 1556152740000, 165.62, 165.64, 165.59, 165.64, 10.08461208 ],\r\n    [ 1556152800000, 165.64, 166, 165.55, 165.56, 682.23911942 ],\r\n    [ 1556152860000, 165.65, 165.65, 165.5, 165.53, 252.93628685 ],\r\n    [ 1556152920000, 165.52, 165.52, 164.74, 164.74, 187.74177186 ],\r\n    ... 620 more items ],\r\n  domain:\r\n   Domain {\r\n     domain: null,\r\n     _events:\r\n      [Object: null prototype] {\r\n        removeListener: [Function: updateExceptionCapture],\r\n        newListener: [Function: updateExceptionCapture],\r\n        error: [Function: debugDomainError] },\r\n     _eventsCount: 3,\r\n     _maxListeners: undefined,\r\n     members: [] } }\r\n> new Date(1556151180000)\r\n2019-04-25T00:13:00.000Z\r\n> new Date(1556151240000)\r\n2019-04-25T00:14:00.000Z\r\n```\r\n\r\n"
    },
    "satisfaction_conditions": [
      "Timeframe availability is correctly identified for the exchange",
      "Timeframe notation ambiguity is resolved",
      "Supported timeframes are discoverable"
    ],
    "created_at": "2019-04-25T12:26:38Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/4828",
    "source": {
      "issue_number": 4828
    },
    "initial_question": {
      "title": "The \"percentage\" is not returned for all exchanges in loadMarkets()",
      "body": "OS: Windows 10\r\nProgramming Language version: Node.js\r\nCCXT version: #465\r\nExchange: All Exchanges\r\nNode.js 11.9.0 installed\r\nMethod: exchange.loadMarkets()\r\n\r\nHello!\r\n\r\nI have a question about the **\"percentage\"** parameter when requesting:\r\n```javascript\r\nconst markets = await exchange.loadMarkets()\r\n```\r\nI could see that for some exchanges **\"percentage\"** is present in the returnd JSON and other exchanges not. If looking at the below example binance has **\"percentage\"** and coinex doesn't.\r\n\r\nFor coinex, this information is shown. Then I wonder how to think. Is this **\"percentage\"** or not. I am bit confused there?\r\n**\"taker\":0.001,\"maker\":0.001**\r\n\r\n**JSON for binance and coinex:**\r\n**coinex**\r\n\"BBN/BCH\":{\"limits\":{\"amount\":{\"min\":1},\"price\":{\"min\":1e-8}},\"precision\":{\"amount\":8,\"price\":8},\"taker\":0.001,\"maker\":0.001,\"id\":\"BBNBCH\",\"symbol\":\"BBN/BCH\",\"base\":\"BBN\",\"quote\":\"BCH\",\"baseId\":\"BBN\",\"quoteId\":\"BCH\",\"active\":true\r\n\r\n**binance**\r\n\"ETH/BTC\":{\"limits\":{\"amount\":{\"min\":0.001,\"max\":100000},\"price\":{},\"cost\":{\"min\":0.001}},\"precision\":{\"base\":8,\"quote\":8,\"amount\":3,\"price\":6},\"tierBased\":false,\"percentage\":true,\"taker\":0.001,\"maker\":0.001,\"id\":\"ETHBTC\",\"symbol\":\"ETH/BTC\",\"base\":\"ETH\",\"quote\":\"BTC\",\"baseId\":\"ETH\",\"quoteId\":\"BTC\"\r\n\r\n\r\n\r\n"
    },
    "satisfaction_conditions": [
      "Fee values must be correctly interpretable as percentages or absolute values",
      "Consistent fee interpretation across all exchanges",
      "Default behavior must be clearly defined",
      "Fee format must be determinable programmatically"
    ],
    "created_at": "2019-03-13T17:44:19Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/4795",
    "source": {
      "issue_number": 4795
    },
    "initial_question": {
      "title": "questions about order structure",
      "body": "Regarding the order `status`, the docs say:\r\n\r\n>     'status':     'open',         // 'open', 'closed', 'canceled'\r\n\r\nIf an order is partially filled and then cancelled, what should the status be?\r\n\r\nRegarding the `cost`:\r\n\r\n>     'cost':        0.076094524,   // 'filled' * 'price' (filling price used where available)\r\n\r\nIf the _filling price_ isn't available, should this field be left blank?  (I think it should)"
    },
    "satisfaction_conditions": [
      "Order status must be 'canceled' when an order is partially filled then cancelled",
      "Cost field must only be populated when accurate cost data is available",
      "Cost calculation must use the most accurate price data available from the exchange response",
      "Cost field must reflect data from the exchange response only, not from original order parameters",
      "System must handle missing cost/filling price data gracefully"
    ],
    "created_at": "2019-03-05T23:37:29Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/4779",
    "source": {
      "issue_number": 4779
    },
    "initial_question": {
      "title": "Question about: enableRateLimit': true",
      "body": "OS: Windows 10\r\nProgramming Language version: Node.js\r\nCCXT version: #465\r\nExchange: Binance\r\nNode.js 11.9.0 installed\r\nMethod: exchange.fetchOrderBook\r\n\r\nHello!\r\n\r\nI have a working code below to get the orderbooks for 3 symbols in a loop at Binance.\r\n\r\nMy question is about the ratelimit. I know Binance has 1200 requests/minute but I am a bit confused when I see the below ratelimit information.\r\n\r\n**Should I in my code use: 'enableRateLimit': true ?**\r\n\r\nenableRateLimit': true (Takes 3 seconds)\r\n**enableRateLimit': false (Takes 1 second) This is not a good id\u00e9a to do?**\r\n\r\nAssume that I only would run this code once every minute which would be clearly below 1200 requests/minute. Is there Also a limit as the manual says to ONLY do 1 HTTP requests per 2000 milliseconds as this also can get ones IP banned?\r\n\r\n\r\n`**\"rateLimits\": [{\r\n    \"rateLimitType\": \"REQUESTS\",\r\n    \"interval\": \"MINUTE\",\r\n    \"limit\": 1200\r\n  },**\r\n\r\n### _\"rateLimit: A request rate limit in milliseconds. Specifies the required minimal delay between two consequent HTTP requests to the same exchange\"_`\r\n\r\n```javascript\r\n'use strict';\r\nconst ccxt = require('ccxt');\r\nconst fs = require('fs');\r\nconst path = require('path');\r\n\r\n\r\nvar i;\r\nconst exchangename = \"binance\";\r\nconst exchange = new ccxt.binance({\r\n    'enableRateLimit': true\r\n});\r\n\r\n(async () => {\r\n    console.log(`start`);\r\n    const start = Date.now();\r\n\r\n\r\n    var orderbookPromises = []\r\n    var symbols = ['ETH/BTC', 'LTC/BTC', 'ZRX/ETH']\r\n    for (i = 0; i < symbols.length; i++) {\r\n\r\n        const symbol = symbols[i]\r\n        \r\n        try {\r\n                let tickerProcessing = new Promise(async (resolve) => {\r\n                    const orderbook = await exchange.fetchOrderBook(symbol, 5);\r\n\r\n                    const exchangename2 = exchangename + '#' + symbol.replace(\"/\", \"\")\r\n                    const dumpFile = path.join(__dirname, 'orderbooks', `${exchangename2}Orderbook.txt`);\r\n                await fs.promises.writeFile(dumpFile, JSON.stringify(orderbook));\r\n                resolve()\r\n            })\r\n            orderbookPromises.push(tickerProcessing)\r\n\r\n        } catch (e) {\r\n            console.error(e);\r\n        }\r\n    }\r\n\r\n    // wait for all of them to execute or fail\r\n    await Promise.all(orderbookPromises)\r\n\r\n\r\n    const end = Date.now();\r\n    console.log(`Done in ${(end - start) / 1000} seconds`);\r\n})();\r\n\r\n```\r\n"
    },
    "satisfaction_conditions": [
      "Rate limit compliance must be maintained with exchange requirements",
      "Application functionality must complete successfully within acceptable time constraints",
      "Rate limiting configuration must match usage pattern",
      "Exchange connection must remain stable and authorized"
    ],
    "created_at": "2019-03-03T23:25:59Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/4684",
    "source": {
      "issue_number": 4684
    },
    "initial_question": {
      "title": "Add fetchBalance on trade account Kucoin2",
      "body": "At the moment fetchBalance() on Kucoin2 (newly released platform) returns balance from main account with no option to get balance from the trade account. Could this be added please?"
    },
    "satisfaction_conditions": [
      "Balance retrieval function must support trade account access",
      "Method must allow explicit account type selection",
      "Solution must be compatible with Kucoin2 platform"
    ],
    "created_at": "2019-02-18T15:29:43Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/4637",
    "source": {
      "issue_number": 4637
    },
    "initial_question": {
      "title": "Gemini fetchMyTrades requires symbol",
      "body": "Most exchanges use fetchMyTrades to obtain trades for all symbols. Gemini does not: a symbol is required. fetchMyTrades ought to behave uniformly for all exchanges.\r\n\r\nI've updated Gemini.js in two ways. First, the current fetchMyTrades has become fetchMyTradesBySymbol. I'm reasonably certain that is not a naming convention that will stay but its my initial suggestion. Second, I've created a new fetchMyTrades that iterates over the symbols at Gemini and calls fetchMyTradesBySymbol for each one. \r\n\r\nThis may not be ideal behavior as it will send in a number of REST API requests. I looked at the Gemini API specs here. It does indicate to provide a symbol but I have not tested out whether it works without one or not. I do have my own Gemini api js library so I can test it independently, but I may not be able to get to it too soon. \r\n\r\n@kroitor -- please advise if I ought to be raising issues for any/every potential pull request. I have a few more as I'm trying to get uniform access (esp via fetchMyTrades) for the exchanges that I use. Until I hear otherwise, I will raise as an issue first."
    },
    "satisfaction_conditions": [
      "Handle exchanges that require symbol parameter differently than those that don't",
      "Maintain single API request per method call",
      "Provide error handling for missing required parameters"
    ],
    "created_at": "2019-02-09T17:09:51Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/4601",
    "source": {
      "issue_number": 4601
    },
    "initial_question": {
      "title": "fetchMinOrderAmounts is used in wrong location",
      "body": "You scrape the minOrderAmounts nicely fro kraken, but they are per currency, not per pair. As such I would expect them to be populated when I do a call to `fetchCurrencies`, and not in `fetchMarkets`.\r\n\r\n- Programming Language version: es6\r\n- CCXT version: 1.18.190\r\n- Exchange: kraken\r\n- Method: fetchMarkets\r\n"
    },
    "satisfaction_conditions": [
      "Minimum order amounts must be associated with trading pairs (markets) rather than individual currencies",
      "The data structure must support varying minimum order amounts across different trading pairs that use the same currency",
      "The implementation must be generic enough to work across multiple exchanges, not just Kraken",
      "Minimum order amounts must be accessible when retrieving market (trading pair) information"
    ],
    "created_at": "2019-02-01T14:18:44Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/4374",
    "source": {
      "issue_number": 4374
    },
    "initial_question": {
      "title": "Python ujson has much better performance than the std json",
      "body": "Is it possible to use ujson(or yajl) instead of the std json in CCXT?\r\nThanks!\r\n"
    },
    "satisfaction_conditions": [
      "Custom JSON parser must be configurable for exchange instances",
      "Parser must handle standard API responses correctly",
      "Solution must accommodate exchanges requiring pre-parsing normalization",
      "Exchange-specific parsing customization must be possible"
    ],
    "created_at": "2018-12-24T03:10:16Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/4361",
    "source": {
      "issue_number": 4361
    },
    "initial_question": {
      "title": "Kucoin fetchClosedOrders returns order id not fill id",
      "body": "```\r\n{ info:\r\n   { coinType: 'KCS',\r\n     amount: 12.4203,\r\n     dealValue: 0.178902,\r\n     fee: 0.0124203,\r\n     dealDirection: 'SELL',\r\n     coinTypePair: 'ETH',\r\n     oid: '5a5475395e39307a6b8e7876',\r\n     dealPrice: 0.014404,\r\n     orderOid: '5a5475105e39307beec73298',\r\n     feeRate: 0.001,\r\n     createdAt: 1515484473000,\r\n     id: 575992,\r\n     direction: 'BUY',\r\n     status: 'closed' },\r\n  id: '5a5475105e39307beec73298',\r\n  timestamp: 1515484473000,\r\n  datetime: '2018-01-09T07:54:33.000Z',\r\n  lastTradeTimestamp: undefined,\r\n  symbol: 'KCS/ETH',\r\n  type: 'limit',\r\n  side: 'buy',\r\n  price: 0.014404,\r\n  amount: 12.4203,\r\n  cost: 0.178902,\r\n  filled: 12.4203,\r\n  remaining: 0,\r\n  status: 'closed',\r\n  fee: { cost: 0.0124203, rate: 0.001, currency: 'KCS' },\r\n  trades: undefined }\r\n {info:\r\n   { coinType: 'KCS',\r\n     amount: 1.3211,\r\n     dealValue: 0.01902912,\r\n     fee: 0.0013211,\r\n     dealDirection: 'BUY',\r\n     coinTypePair: 'ETH',\r\n     oid: '5a5475115e39307a6b8e786f',\r\n     dealPrice: 0.014404,\r\n     orderOid: '5a5475105e39307beec73298',\r\n     feeRate: 0.001,\r\n     createdAt: 1515484433000,\r\n     id: 575985,\r\n     direction: 'BUY',\r\n     status: 'closed' },\r\n  id: '5a5475105e39307beec73298',\r\n  timestamp: 1515484433000,\r\n  datetime: '2018-01-09T07:53:53.000Z',\r\n  lastTradeTimestamp: undefined,\r\n  symbol: 'KCS/ETH',\r\n  type: 'limit',\r\n  side: 'buy',\r\n  price: 0.014404,\r\n  amount: 1.3211,\r\n  cost: 0.01902912,\r\n  filled: 1.3211,\r\n  remaining: 0,\r\n  status: 'closed',\r\n  fee: { cost: 0.0013211, rate: 0.001, currency: 'KCS' },\r\n  trades: undefined }\r\n```\r\n\r\nThis means that the `id` for each trade will be duplicated. We need to use `info.oid`."
    },
    "satisfaction_conditions": [
      "Order identification must be unique and consistent across related trades",
      "Trade records must maintain relationship with parent order",
      "API response fields must be correctly interpreted based on their context",
      "Data structure must preserve all necessary transaction details"
    ],
    "created_at": "2018-12-19T19:45:56Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/4211",
    "source": {
      "issue_number": 4211
    },
    "initial_question": {
      "title": "API Keys Setup - Any function to know exactly what parameter to pass",
      "body": "I have read the API Keys Setup wiki and understood there are parameters like apiKey, secret, uid and password, but not all exchange require all the parameter.\r\nIs there any function or method that will tell me exactly which parameter to pass for each exchange.\r\n\r\nSomething like:\r\n```\r\n$quoinex = new \\ccxt\\quoinex ();\r\n$quoinex->getParam(); // ------> This will return apiKey and secret\r\n$1btcxe = new \\ccxt\\1btcxe ();\r\n$1btcxe->getParam(); // -------> This will return only apiKey\r\n```\r\n"
    },
    "satisfaction_conditions": [
      "Method provides access to required authentication parameters for each exchange",
      "Information is accessible through the exchange instance object",
      "Returns different parameter requirements for different exchanges",
      "Information is available before authentication"
    ],
    "created_at": "2018-11-22T14:05:29Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/4050",
    "source": {
      "issue_number": 4050
    },
    "initial_question": {
      "title": "bittrex fetchDeposits returns no timestamp and datetime",
      "body": "- OS: Linux\r\n- Programming Language version: PHP\r\n- CCXT version: 1.17.421\r\n- Exchange: bittrex\r\n- Method: fetchDeposit\r\n\r\nThe only timestamp returned from the exchnage for withdrawals is in the 'LastUpdated' field. This should probably be used for the timestamp and datetime. The 'Opened' field that is used for Withdrawals is not available when fetching deposits"
    },
    "satisfaction_conditions": [
      "Timestamp handling must maintain data integrity",
      "Solution must respect exchange's data limitations",
      "Custom timestamp logic must be implementable client-side",
      "Solution must maintain consistency with API design principles"
    ],
    "created_at": "2018-10-26T07:28:05Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/3840",
    "source": {
      "issue_number": 3840
    },
    "initial_question": {
      "title": "deployment error in a google / firebase cloud function",
      "body": "I'm unable to use ccxt in a cloud function.  When I start locally the deployment dies if I add the line `const cctx = require('cctx');`.  The same does not happen for other dependencies such as `const uuid = require('uuid');`\r\n\r\nI've added (both) packages to my _package.json_ file, run `npm install` and I can see them both in my _node_modules_ directory.  I've tried cleaning the cache.\r\n\r\n ```\r\n \"dependencies\": {\r\n    \"ccxt\": \"^1.17.283\",\r\n    \"firebase-admin\": \"^6.0.0\",\r\n    \"firebase-functions\": \"^2.0.5\",\r\n    \"uuid\": \"^3.3.2\"\r\n  },\r\n```\r\n\r\nHere's the error:\r\n\r\n```\r\n$ firebase serve  --only functions\r\n\r\n=== Serving from '/Users/crypro/projects/CrypPro-marketdata/firebase'...\r\n\r\ni  functions: Preparing to emulate functions.\r\n\u26a0  functions: Failed to load functions source code. Ensure that you have the latest SDK by running npm i --save firebase-functions inside the functions directory.\r\n\u26a0  functions: Error from emulator. Error parsing triggers: Cannot find module 'cctx'\r\n\r\nTry running \"npm install\" in your functions directory before deploying.\r\n```\r\n\r\nI'm using:\r\n\r\n```\r\n$ node --version\r\nv6.11.5\r\n$ npm --version\r\n6.4.1\r\n$ firebase --version\r\n4.2.1\r\n```\r\n\r\nI'm guessing there's something different between the _uuid_ npm package and the _ccxt_ one, but I've no idea what.\r\n\r\n"
    },
    "satisfaction_conditions": [
      "All dependencies are properly installed in the functions directory"
    ],
    "created_at": "2018-09-13T12:03:17Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/3746",
    "source": {
      "issue_number": 3746
    },
    "initial_question": {
      "title": "bitflyer markets are missing baseId and quoteId fields",
      "body": "For example:\r\n\r\n```\r\n\"BCH/BTC\": {\r\n    \"precision\": {\r\n      \"price\": 8,\r\n      \"amount\": 8,\r\n      \"cost\": 8\r\n    },\r\n    \"taker\": 0.0025,\r\n    \"maker\": 0.0025,\r\n    \"id\": \"BCH_BTC\",\r\n    \"symbol\": \"BCH/BTC\",\r\n    \"base\": \"BCH\",\r\n    \"quote\": \"BTC\",\r\n    \"type\": \"spot\",\r\n    \"spot\": true,\r\n    \"future\": false,\r\n    \"info\": {\r\n      \"product_code\": \"BCH_BTC\"\r\n    }\r\n  }\r\n```\r\n\r\n\r\n\r\n[EDIT] ... I now see that they are missing missing from most implementations.  Is that expected?"
    },
    "satisfaction_conditions": [
      "Market data structure remains functional without baseId and quoteId fields",
      "System handles both presence and absence of baseId/quoteId fields gracefully",
      "Essential market identification fields (id, symbol, base, quote) are present and correct",
      "Documentation accurately reflects field availability"
    ],
    "created_at": "2018-08-27T09:50:00Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/3623",
    "source": {
      "issue_number": 3623
    },
    "initial_question": {
      "title": "Duplicate information returned by fetch_markets() ",
      "body": "I notice duplicate informations in the object returned by `fetch_markets()`, for example the fees here at BitMEX. What is the reason for this and which one should I use ? same on all exchanges I've checked.\r\n\r\n```\r\n'id': 'LTCU18',\r\n   'symbol': 'LTCU18',\r\n   'base': 'LTC',\r\n   ...\r\n   'taker': 0.0025,        <------ taker fee here\r\n   'maker': -0.0005,\r\n   'type': 'future',\r\n   'spot': False,\r\n   'swap': False,\r\n   'future': True,\r\n   'prediction': False,\r\n   'info': {'symbol': 'LTCU18',\r\n    'rootSymbol': 'LTC',\r\n    ...\r\n    'deleverage': True,\r\n    'makerFee': -0.0005,\r\n    'takerFee': 0.0025,        <------ taker fee here\r\n    'settlementFee': 0,\r\n    ...\r\n    'settledPrice': None,\r\n    'timestamp': '2018-08-10T23:59:45.000Z'}\r\n```"
    },
    "satisfaction_conditions": [
      "Data structure must contain both parsed and raw exchange data",
      "Duplicate information must be consistently represented",
      "Top-level fields must contain parsed, standardized data",
      "Raw exchange data must be preserved in the 'info' field",
      "Data structure must allow optional use of raw data"
    ],
    "created_at": "2018-08-11T10:06:37Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/3616",
    "source": {
      "issue_number": 3616
    },
    "initial_question": {
      "title": "Retrieve response headers",
      "body": "Is it possible to retrieve the response headers on both good and false api calls you make for Bitmex?\r\n\r\n```\r\n{\r\n  \"date\": \"Fri, 10 Aug 2018 09:54:59 GMT\",\r\n  \"content-encoding\": \"gzip\",\r\n  \"x-powered-by\": \"Profit\",\r\n  \"etag\": \"W/\\\"2-l9Fw4VUO7kr8CvBlt4zaMCqXZ0w\\\"\",\r\n  \"x-ratelimit-remaining\": \"149\",\r\n  \"content-type\": \"application/json; charset=utf-8\",\r\n  \"status\": \"200\",\r\n  \"x-ratelimit-reset\": \"1533894900\",\r\n  \"x-ratelimit-limit\": \"150\",\r\n  \"strict-transport-security\": \"max-age=31536000; includeSubDomains\"\r\n}\r\n```"
    },
    "satisfaction_conditions": [
      "All standard HTTP response headers must be retrievable",
      "Headers must be retrievable after the API call is completed",
      "Headers must be accessible in a structured format"
    ],
    "created_at": "2018-08-10T10:00:06Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/3573",
    "source": {
      "issue_number": 3573
    },
    "initial_question": {
      "title": "Bitmex fetch_ohlcv return only old data from 2015",
      "body": "- OS: Mac OS\r\n- Programming Language version: php 7.2\r\n- CCXT version: 1.14.62\r\n- Exchange: Bitmex\r\n- Method: fetch_ohlcv\r\n\r\n\r\nHi! I try get OHLC data from Bitmex with since = null and get always old data, between September 25, 2015, September 29, 2015. If I try use since, I don't receive any data or segment between September 25, 2015, September 29, 2015\r\n\r\n`require_once \"vendor/autoload.php\";`\r\n`$exchange  = new \\ccxt\\bitmex  (array ('apiKey' => 'xxx','secret'=>'yyy'));`\r\n`$limit = 100;`\r\n`$since = $exchange->milliseconds()-$limit*60*1000;`\r\n`$symbol = 'BTC/USD';`\r\n`$timeframe = '1h';`\r\n`$params = array('partial'=> False);`\r\n`$ohlcv = $exchange->fetch_ohlcv('BTC/USD', '1h', $since);`\r\n`print_r($ohlcv);`\r\n\r\nEmpty date!\r\n\r\nif calculate $since like\r\n`$since = microtime()-1000*60*60*24;`\r\nreceive segment between September 25, 2015, September 29, 2015 \r\n\r\n`{`\r\n`     0: {`\r\n`          0: \"2015-09-25T13:00:00.000Z\",`\r\n`          1: \"239.99\",`\r\n`          2: \"239.99\",`\r\n`          3: \"237.36\",`\r\n`          4: \"237.45\",`\r\n`          5: \"11501\"`\r\n`     },`\r\n`     1: {`\r\n`          0: \"2015-09-25T14:00:00.000Z\",`\r\n`          1: \"237.45\",`\r\n`          2: \"237.05\",`\r\n`          3: \"236.08\",`\r\n`          4: \"236.08\",`\r\n`          5: \"22625\"`\r\n`     },`\r\n`     2: {`\r\n`          0: \"2015-09-25T15:00:00.000Z\",`\r\n`          1: \"236.08\",`\r\n`          2: \"236.52\",`\r\n`          3: \"236.1\",`\r\n`          4: \"236.34\",`\r\n`          5: \"17434\"`\r\n`     },`\r\n`     3: {`\r\n`          0: \"2015-09-25T16:00:00.000Z\",`\r\n`          1: \"236.34\",`\r\n`          2: \"236.13\",`\r\n`          3: \"235.44\",`\r\n`          4: \"235.71\",`\r\n`          5: \"26900\"`\r\n`     }`\r\n`...`\r\n\r\n\r\n\r\n"
    },
    "satisfaction_conditions": [
      "Time calculations must use correct millisecond-based timestamps",
      "Timezone settings must be properly configured"
    ],
    "created_at": "2018-08-06T12:11:33Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/3479",
    "source": {
      "issue_number": 3479
    },
    "initial_question": {
      "title": "`cost_to_precision()` uses `markets[symbol]['precision']['price']`?",
      "body": "Is this a typo on line 903 of `ccxt/python/ccxt/base/exchange.py`?\r\n\r\n```\r\n    def cost_to_precision(self, symbol, cost):\r\n        return ('{:.' + str(self.markets[symbol]['precision']['price']) + 'f}').format(float(cost))\r\n\r\n```\r\nI would have expected it to be:\r\n\r\n```\r\n    def cost_to_precision(self, symbol, cost):\r\n        return ('{:.' + str(self.markets[symbol]['precision']['cost']) + 'f}').format(float(cost))\r\n```\r\n\r\nThis is a genuine question. I could imagine scenarios where it could be intentional."
    },
    "satisfaction_conditions": [
      "Cost precision must match the currency's decimal representation requirements",
      "The precision formatting must produce valid numerical output for cost calculations",
      "The implementation must be consistent across different programming language versions",
      "The precision handling must work with all supported exchange APIs"
    ],
    "created_at": "2018-07-24T16:57:01Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/3455",
    "source": {
      "issue_number": 3455
    },
    "initial_question": {
      "title": "Bittrex / python fetch_orders() method gone ..?",
      "body": "Language: Python 3.6\r\nCCXT version: 1.12+ (including newest version 1.16.80)\r\nExchange: Bittrex\r\n\r\nThe fetch_orders method for Bittrex seems to have disappeared at some point after v1.11.180 (I tried to upgrade). Seems like a pretty important method for a fairly well-used exchange... "
    },
    "satisfaction_conditions": [
      "Access to order history must be maintained through alternative method calls",
      "Distinction between open and closed orders must be preserved",
      "API method availability must be accurately reflected in the 'has' property",
      "Backward compatibility impact must be clearly communicated"
    ],
    "created_at": "2018-07-21T20:06:26Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/3263",
    "source": {
      "issue_number": 3263
    },
    "initial_question": {
      "title": "Setting API and Secret Key in PHP version havig no effect",
      "body": "Hi,\r\nAfter creating account and keys for 1Broker, bitbox , coinspot and cointiger exchanges,  I followed the manual for setting these Api key and secret  but still receive the error message from API asking for API key.\r\nFor quick testing I set it like below...Is there a known issue on Php or i am missing something?\r\n\r\n       $string_exchange = '\\\\ccxt\\\\' . $id;\r\n        $ccxt_exchange = new $string_exchange();\r\n\r\n        $exchangeAPI = new ExchangeAPIKey();\r\n        $apiKey = $exchangeAPI->getApiKey($id);\r\n        $secretKey = $exchangeAPI->getSecretKey($id);\r\n        echo ' ApiKey '.$apiKey;\r\n        echo ' SecretKey '.$secretKey;\r\n        if(!empty($apiKey) && !empty($secretKey)){\r\n            $ccxt_exchange->apiKey = $apiKey;\r\n            $ccxt_exchange->secret = $secretKey;\r\n        }else if(!empty($apiKey)){\r\n            $ccxt_exchange->apiKey = $apiKey;\r\n        }\r\n\r\nSetting my keys this way seems having no effect on loadmarket call...or maybe i miss some sleep\r\n\r\n- OS:\r\n- Programming Language version:\r\n- CCXT version: 1.44.211\r\n- Method: loadmarket"
    },
    "satisfaction_conditions": [
      "Exchange instance is properly instantiated with correct namespace"
    ],
    "created_at": "2018-06-26T16:48:35Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/3206",
    "source": {
      "issue_number": 3206
    },
    "initial_question": {
      "title": "Bitrrex wallet status not good fetchCurrencies",
      "body": "\r\n- Ubuntu\r\n- Python: 3.5\r\n- CCXT version: 1.14.189\r\n- Exchange: bittrex\r\n- Method: fetchCurrencies()\r\n\r\nFor example\r\n\r\n```bit.fetchCurrencies()['CANN']``` has de following output: \r\n\r\n``` {'code': 'CANN', 'fee': 0.2, 'status': 'ok', 'precision': 8, 'limits': {'amount': {'max': 100000000.0, 'min': 1e-08}, 'withdraw': {'max': 100000000.0, 'min': 0.2}, 'price': {'max': 100000000.0, 'min': 1e-08}, 'cost': {'max': None, 'min': None}}, 'info': {'MinConfirmation': 300, 'Notice': 'Automated Maintenance.', 'Currency': 'CANN', 'TxFee': 0.2, 'IsActive': False, 'CurrencyLong': 'CannabisCoin', 'BaseAddress': None, 'CoinType': 'BITCOIN'}, 'address': None, 'type': 'BITCOIN', 'active': False, 'name': 'CannabisCoin', 'id': 'CANN'} ```\r\n\r\nAs you can see the wallet is in Automated Maintance and 'IsActive'  is False while the unified status is 'ok'\r\n\r\nI would expect that the status would change to 'disabled' because you cannot withdraw or deposit this coin at the moment\r\n\r\n\r\n"
    },
    "satisfaction_conditions": [
      "Status information must be accessible through a consistent interface",
      "Raw exchange data must be preserved in the info field"
    ],
    "created_at": "2018-06-21T09:31:03Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/2896",
    "source": {
      "issue_number": 2896
    },
    "initial_question": {
      "title": "huobipro withdraw return api-signature-not-valid error",
      "body": "- OS: Win10\r\n- Programming Language version: Python 3.5.4\r\n- CCXT version: 1.14.25\r\n- Exchange: huobipro\r\n- Method: withdraw\r\n\r\nWhen I tested huobipro withdraw, I got 'signature not valid' response as below:\r\n\r\n> ccxt.base.errors.ExchangeError: huobipro {\"err-msg\":\"Signature not valid: \\u6821\\u9a8c\\u5931\\u8d25\",\"status\":\"error\",\"data\":null,\"err-code\":\"api-signature-not-valid\"}\r\n\r\nMeanwhile, huobipro fetch_balance worked fine. So I think it is not a key pair issue. And I also tested withdraw same target address by other market, it also worked fine. So the address should be good.\r\n\r\nAttach my testing code below, hope it will help:\r\n\r\n    f_m = \"huobipro\"\r\n    t_m = \"okex\" \r\n    currency = \"ZEC\"\r\n\r\n    exchange = getattr(ccxt, f_m)({'apiKey': apiconfig['key'], 'secret': apiconfig['secret'], 'nonce': ccxt.Exchange.milliseconds})\r\n    addresses = get_market_addresses(t_m) #get addresses map\r\n    exchange.load_markets()\r\n    response = exchange.fetch_balance()\r\n    print(response) #fetch balance, worked\r\n    response = exchange.withdraw(currency, 1, addresses[currency]['address'], 'Test withdraw', {})\r\n    print(response) #withdraw, failed\r\n\r\nAttach traceback:\r\n\r\n> Traceback (most recent call last):\r\n  File \"testing2.py\", line 36, in <module>\r\n    withdraw_test()\r\n  File \"testing2.py\", line 33, in withdraw_test\r\n    response = exchange.withdraw(currency, 1, addresses[currency]['address'], 'Test withdraw', {})\r\n  File \"C:\\Users\\Administrator\\AppData\\Local\\Programs\\Python\\Python35\\lib\\site-packages\\ccxt\\huobipro.py\", line 661, in withdraw\r\n    response = self.privatePostDwWithdrawApiCreate(self.extend(request, params))\r\n  File \"C:\\Users\\Administrator\\AppData\\Local\\Programs\\Python\\Python35\\lib\\site-packages\\ccxt\\base\\exchange.py\", line 306, in request\r\n    return self.fetch2(path, api, method, params, headers, body)\r\n  File \"C:\\Users\\Administrator\\AppData\\Local\\Programs\\Python\\Python35\\lib\\site-packages\\ccxt\\base\\exchange.py\", line 303, in fetch2\r\n    return self.fetch(request['url'], request['method'], request['headers'], request['body'])\r\n  File \"C:\\Users\\Administrator\\AppData\\Local\\Programs\\Python\\Python35\\lib\\site-packages\\ccxt\\base\\exchange.py\", line 383, in fetch\r\n    self.handle_errors(response.status_code, response.reason, url, method, None, self.last_http_response)\r\n  File \"C:\\Users\\Administrator\\AppData\\Local\\Programs\\Python\\Python35\\lib\\site-packages\\ccxt\\huobipro.py\", line 727, in handle_errors\r\n    raise ExchangeError(feedback)\r\nccxt.base.errors.ExchangeError: huobipro {\"err-msg\":\"Signature not valid: \\u6821\\u9a8c\\u5931\\u8d25\",\"data\":null,\"err-code\":\"api-signature-not-valid\",\"status\":\"error\"}\r\n"
    },
    "satisfaction_conditions": [
      "The withdraw API call must return a successful response without signature validation errors",
      "The tag parameter must be used only when required by the specific cryptocurrency's withdrawal requirements",
      "The exchange authentication (API key and secret) must remain valid for other operations",
      "The withdrawal address must remain valid and accepted by the exchange"
    ],
    "created_at": "2018-05-19T18:43:10Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/2644",
    "source": {
      "issue_number": 2644
    },
    "initial_question": {
      "title": "prompt working in file not working",
      "body": "\r\n- OS: Ubuntu 16.04.4 LTS\r\n- Programming Language version: Python 3.5.2\r\n- CCXT version: 1.13.32\r\n- Exchange: All\r\n- Method: ccxt.exchanges\r\n\r\nI installed it like this:\r\npip install ccxt\r\n\r\nimport ccxt\r\nprint(ccxt.exchanges)\r\n\r\nIt's working in a prompt. But not in a Python file.\r\n"
    },
    "satisfaction_conditions": [
      "CCXT module must be accessible from the Python environment being used"
    ],
    "created_at": "2018-04-22T19:10:18Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/2630",
    "source": {
      "issue_number": 2630
    },
    "initial_question": {
      "title": "Bittex fetchOrders not supported yet. ",
      "body": "Hi @kroitor,\r\n\r\nWith updated version i get this error: \r\n`Bittex fetchOrders not supported yet. `\r\n\r\nSome versions ago it was working fine.\r\nAny info?\r\n\r\n- OS: \r\n- Programming Language version: JS\r\n- CCXT version: 1.13.10\r\n- Exchange: Bittrex\r\n- Method: fetchOrders\r\n"
    },
    "satisfaction_conditions": [
      "User must be able to retrieve order data using alternative API methods",
      "User must understand the reason for the functionality change",
      "Application must work with CCXT version 1.13+",
      "Order retrieval must reflect accurate order status"
    ],
    "created_at": "2018-04-20T11:16:32Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/2619",
    "source": {
      "issue_number": 2619
    },
    "initial_question": {
      "title": "Gdax Sandbox Authentication Error",
      "body": "Hi, \r\nI'm trying to use the api with the Gdax Sandbox, but I get an \"Invalid API Key\" error.\r\n\r\nTo use the sandbox I have changed this line in the code (line 478 in gdax.py):\r\n\r\nFrom: \r\n`url = self.urls['api'] + request `\r\nto:\r\n`url = self.urls['test'] + request `\r\n\r\nIt's weird because I get the error using the sandbox credentials, but if I put the real credentials I get no error. It is like if my change int he code has no effect at all.\r\n\r\nProbably it is just a newbie mistake from me, but I'm stucked with this. \r\n\r\nI'm using python on Ubuntu.\r\n\r\n"
    },
    "satisfaction_conditions": [
      "API endpoint URL must correctly point to sandbox environment",
      "Authentication credentials must match the target environment",
      "Code changes must be made in the application configuration, not the library source"
    ],
    "created_at": "2018-04-19T08:08:52Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/2579",
    "source": {
      "issue_number": 2579
    },
    "initial_question": {
      "title": "Is there any way to set the price to 'ask' using bittrex exchange?",
      "body": "- OS: ubuntu\r\n- Programming Language version: python\r\n- CCXT version: last\r\n- Exchange: bittrex\r\n- Method: execute_order\r\n\r\nSince bittrex only has limit order types there is not way to set a market order. \r\nBut, if I want to be sure that the order is executed, is there any way to set the price to the 'ask' amount in the order_book, without requesting the full order_book previously?\r\n"
    },
    "satisfaction_conditions": [
      "Order execution achieves market price equivalent results",
      "Solution works within Bittrex's limit order constraints",
      "Order execution can be achieved without pre-fetching full orderbook",
      "Solution includes safety verification capability",
      "Implementation works with both buy and sell orders"
    ],
    "created_at": "2018-04-16T00:17:53Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/2368",
    "source": {
      "issue_number": 2368
    },
    "initial_question": {
      "title": "Couldn't get timestamp in `fetch_order_book` method",
      "body": "- OS: mac os\r\n- Programming Language version: python\r\n- CCXT version: 1.12.17 \r\n- Exchange: all exchange\r\n- Method: fetch_order_book\r\n"
    },
    "satisfaction_conditions": [
      "Timestamp data is successfully retrieved from the exchange response",
      "Method works when direct timestamp is not available in order book data",
      "Retrieved timestamp corresponds to the actual order book data request",
      "Solution works with the CCXT library interface"
    ],
    "created_at": "2018-03-28T06:34:36Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/2365",
    "source": {
      "issue_number": 2365
    },
    "initial_question": {
      "title": "How to check whether new candle formed?",
      "body": "- OS: Windows 10\r\n- Programming Language version: Node JS 9.0\r\n- CCXT version: \r\n- Exchange: binance\r\n- Method: fetchOHLCV\r\n\r\non init of my script I going to fetch some quantity of candles,\r\nlater i will call another method periodically\r\n\r\nhow can I check - is new candle now forming, so I need to do something with already formed data. how to check it ?\r\nFor instance, I will use 1-hour timeframe, execute function every minute, how han I check that new candle starts?\r\n"
    },
    "satisfaction_conditions": [
      "System must accurately detect the start of a new candle period",
      "Solution must handle time synchronization discrepancies",
      "Check frequency must be more frequent than the candle timeframe",
      "System must work with UTC-based timestamps"
    ],
    "created_at": "2018-03-27T07:33:41Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/2254",
    "source": {
      "issue_number": 2254
    },
    "initial_question": {
      "title": "Bitmex: fetch_ohlcv optional parameters",
      "body": "- OS: Windows\r\n- Programming Language version: Python 3.6\r\n- CCXT version: 1.11.77\r\n- Exchange: Bitmex\r\n- Method: fetch_ohlcv()\r\n\r\nHi! \r\n  The Bitmex API supports returning only completed candles. However the CCXT library hard codes the request to return partial candles. I guess this is for unification of the method between exchanges?!?\r\n\r\nIs it possible to support specifying the `partial` parameter during the method call? This would be very useful. Perhaps it can be sent in the `params` dict and a check be made to see if `partial` exists? If not, use your default which is `True`?\r\n\r\nHere is the bitmex snippet below. \r\n\r\n```\r\ndef fetch_ohlcv(self, symbol, timeframe='1m', since=None, limit=100, params={}):\r\n        self.load_markets()\r\n        # send JSON key/value pairs, such as {\"key\": \"value\"}\r\n        # filter by individual fields and do advanced queries on timestamps\r\n        # filter = {'key': 'value'}\r\n        # send a bare series(e.g. XBU) to nearest expiring contract in that series\r\n        # you can also send a timeframe, e.g. XBU:monthly\r\n        # timeframes: daily, weekly, monthly, quarterly, and biquarterly\r\n        market = self.market(symbol)\r\n        request = {\r\n            'symbol': market['id'],\r\n            'binSize': self.timeframes[timeframe],\r\n            'partial': True,     # True == include yet-incomplete current bins\r\n            'count': limit,      # default 100, max 500\r\n```\r\n"
    },
    "satisfaction_conditions": [
      "The API request must be able to exclude partial/incomplete candle data when desired",
      "The solution must work within BitMEX's API constraints",
      "The OHLCV data returned must remain stable for completed candles",
      "The functionality must be configurable through the API call parameters"
    ],
    "created_at": "2018-03-14T03:10:31Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/2134",
    "source": {
      "issue_number": 2134
    },
    "initial_question": {
      "title": "inconsistent timeframes format ",
      "body": "The issue is that the format of the exchange property timeframes is NOT consistent. \r\n```\r\nexchange_ids = ['binance', 'bitfinex', 'hitbtc', 'kucoin', 'kraken', 'poloniex', 'gdax', 'gemini', 'huobipro', 'okex']\r\nexchanges = [getattr(ccxt, str.lower())() for str in exchange_ids]\r\n[print(ex.timeframes) for ex in exchanges if hasattr(ex, 'timeframes')]\r\n```\r\n\r\nThe above code prints out some examples in the following:\r\n```\r\n{'1m': '1m', '3m': '3m', '5m': '5m', '15m': '15m', '30m': '30m', '1h': '1h', '2h': '2h', '4h': '4h', '6h': '6h', '8h': '8h', '12h': '12h', '1d': '1d', '3d': '3d', '1w': '1w', '1M': '1M'}\r\n{'1m': '1m', '5m': '5m', '15m': '15m', '30m': '30m', '1h': '1h', '3h': '3h', '6h': '6h', '12h': '12h', '1d': '1D', '1w': '7D', '2w': '14D', '1M': '1M'}\r\n{'1m': '1', '5m': '5', '15m': '15', '30m': '30', '1h': '60', '8h': '480', '1d': 'D', '1w': 'W'}\r\n{'1m': '1', '5m': '5', '15m': '15', '30m': '30', '1h': '60', '4h': '240', '1d': '1440', '1w': '10080', '2w': '21600'}\r\n{'5m': 300, '15m': 900, '30m': 1800, '2h': 7200, '4h': 14400, '1d': 86400}\r\n{'1m': 60, '5m': 300, '15m': 900, '30m': 1800, '1h': 3600, '2h': 7200, '4h': 14400, '12h': 43200, '1d': 86400, '1w': 604800, '1M': 2592000, '1y': 31536000}\r\n{'1m': '1min', '5m': '5min', '15m': '15min', '30m': '30min', '1h': '60min', '1d': '1day', '1w': '1week', '1M': '1mon', '1y': '1year'}\r\n{'1m': '1min', '3m': '3min', '5m': '5min', '15m': '15min', '30m': '30min', '1h': '1hour', '2h': '2hour', '4h': '4hour', '6h': '6hour', '12h': '12hour', '1d': '1day', '3d': '3day', '1w': '1week'}\r\n```\r\n\r\n\r\n`timeframes` is a hash and the values of it do not follow a format across exchanges. For example, some are like '1m' or '5m' that are no different from the keys. Some others are the actual duration in seconds which arguably is the desired format. Some others are just more descriptive keys such as '1min', '1day' and etc. \r\n\r\n\r\n- OS: \r\nOSX 10.13.3\r\n\r\n- Programming Language version: \r\nPython 3.6.4\r\n\r\n- CCXT version:\r\n1.10.760\r\n\r\n- Exchange:\r\nbinance\r\nbitfinex\r\nhitbtc\r\nkucoin\r\nkraken\r\npoloniex\r\ngdax\r\ngemini\r\nhuobipro\r\nokex\r\n\r\n- Method:\r\nthe property timeframes\r\n"
    },
    "satisfaction_conditions": [
      "Timeframe keys must be used for cross-exchange operations instead of values",
      "Duration in seconds must be obtainable when needed",
      "Exchange-specific timeframe values must remain accessible",
      "System must handle all supported timeframe formats without errors"
    ],
    "created_at": "2018-03-06T07:20:37Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/2044",
    "source": {
      "issue_number": 2044
    },
    "initial_question": {
      "title": "Binance receiving error code -2015 while using API keys",
      "body": "Hi,\r\n \r\nI have created a new Binance account and set its API keys (read info, enable trading, IP access unrestricted).\r\nWhile trying to connect to my account programmaticly using CCXT, I get the following authorization error: `ccxt.base.errors.ExchangeError: binance: unknown error code: {\"code\":-2015,\"msg\":\"Invalid API-key, IP, or permissions for action.\"}`\r\nOS: Ubuntu 16 (happens on windows as well)\r\nProgramming language: Python 3.5 \r\nCCXT version: 1.10.1178\r\n\r\nWhen using `python-binance` library, I successfully connect to my account.\r\n\r\nThe code I use:\r\n```\r\nfrom binance.client import Client\r\nimport json\r\nimport ccxt\r\n\r\ndata = json.load(open('binance_auth.json'))\r\n\r\nclient = Client(\r\n    data['secret'],\r\n    data['key'])\r\n\r\napi = {\r\n                'apiKey': data['key'],\r\n                'secret': data['secret'],\r\n                'password': None,\r\n      }\r\nccxtBinance = ccxt.binance(api)\r\n\r\nprint(\"python-binance=\", client.get_account()) # succeeds\r\nprint (\"ccxt=\",ccxtBinance.fetchBalance())     # fails\r\n```\r\n\r\nThanks,\r\nLena"
    },
    "satisfaction_conditions": [
      "API permissions allow the requested operations"
    ],
    "created_at": "2018-02-25T09:09:25Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/2043",
    "source": {
      "issue_number": 2043
    },
    "initial_question": {
      "title": "futures with different contracts",
      "body": "When fetching the ticker or order book of BTC/USD (exchange: okex), I can only get the weekly futures contract. How can I get biweekly and quarterly contract? Or it is currently impossible in ccxt api?\r\n\r\nThx. \r\n"
    },
    "satisfaction_conditions": [
      "API must support retrieving data for different futures contract periods",
      "Method must allow specification of the desired contract type",
      "Solution must work for both ticker and orderbook data retrieval"
    ],
    "created_at": "2018-02-25T08:30:31Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/1831",
    "source": {
      "issue_number": 1831
    },
    "initial_question": {
      "title": "Kucoin fetchOrder only working for open orders",
      "body": "Hi,\r\n\r\nI was just checking kucoin fetchOrder which was added short while ago. But it does return OrderNotFound exception for closed order.\r\n\r\nWorks for Open orders as expected...\r\n\r\nIs this expected ?"
    },
    "satisfaction_conditions": [
      "Order information must be retrievable for both open and closed orders",
      "System must handle API response failures gracefully",
      "Complete order data must be obtainable within API rate limits",
      "Solution must remain functional despite API inconsistencies"
    ],
    "created_at": "2018-02-08T13:33:37Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/1795",
    "source": {
      "issue_number": 1795
    },
    "initial_question": {
      "title": "Please help ",
      "body": "Hi everyone, im a newbie in js and i need your help.So this is my code and the main problem is that it doesnt return me eth and btc balances, just says promise pending and after gives me al info about balance on every currency \r\n\r\n```\r\nlet finalamountbinance\r\nlet getbalancebinance = async() => {\r\n    let count=0;\r\n    let balance\r\n    try{\r\n        balance = await binance.fetchBalance()\r\n        console.log(balance)\r\n    }\r\n    catch(BaseError){\r\n        getbalancebinance()\r\n    }\r\n    if(count==0){\r\n        finalamountbinance = balance.BTC.free\r\n        count++\r\n        final=0\r\n    }\r\n    if(count==1){\r\n        finalamountbinance = balance.ETH.free\r\n        count--\r\n        final=0\r\n    }\r\n}\r\nlet getbalanceyobit = async() => {\r\n    let balance\r\n    try{\r\n        balance = await yobit.fetchBalance()\r\n        console.log(yobit)\r\n    }\r\n    catch(BaseError){\r\n        getbalanceyobit()\r\n    }\r\n    return balance\r\n}\r\n\r\nfunction bot(){\r\n    getbalancebinance()\r\n    console.log(finalamountbinance)\r\n    getbalancebinance()\r\n    console.log(finalamountbinance)\r\n}\r\n\r\nbot()\r\n```"
    },
    "satisfaction_conditions": [
      "Asynchronous balance queries must resolve before values are used"
    ],
    "created_at": "2018-02-06T18:34:34Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/1738",
    "source": {
      "issue_number": 1738
    },
    "initial_question": {
      "title": "Hitbtc2 empty AVH market, payinEnabled, payoutEnabled, crypto and other fields missing",
      "body": "I found this error with Hitbtc2 (but not Hitbtc):\r\n\r\nFile \"/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/site-packages/ccxt/base/exchange.py\", line 844, in load_markets\r\n    currencies = self.fetch_currencies()\r\n  File \"/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/site-packages/ccxt/hitbtc2.py\", line 616, in fetch_currencies\r\n    payin = currency['payinEnabled']"
    },
    "satisfaction_conditions": [
      "The system must handle incomplete currency data without crashing",
      "The application continues to function when receiving partial currency information",
      "The system remains compatible with the exchange API's response format"
    ],
    "created_at": "2018-02-02T20:03:20Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/1733",
    "source": {
      "issue_number": 1733
    },
    "initial_question": {
      "title": "[Bug] Bittrex OHLCV not realtime?",
      "body": "Here's how I'm doing the OHLCV requests:\r\n```\r\n  new ccxt[exchange]().fetchOHLCV(\r\n    'ETH/BTC\", \r\n    '1m',\r\n    undefined\r\n  )\r\n\r\n```\r\n\r\nAnd, here's the output for 3 exchange (binance, bittrex, okex):\r\n```\r\nokex:\r\nFri Feb 02 2018 21:52:00 GMT+0700 (+07) (printCurrent @ index.mjs:32)\r\n\r\nbinance\r\n Fri Feb 02 2018 21:52:00 GMT+0700 (+07) (printCurrent @ index.mjs:32)\r\n\r\nbittrex\r\nFri Feb 02 2018 21:49:00 GMT+0700 (+07) (printCurrent @ index.mjs:32)\r\n```\r\n\r\nNotice how bittrex is lagging? I kept on running the script for a while, and bittrex OHLCV was consistently 3-4 min lagging behind.\r\nIs this a bug in my code, or a bug in the library?"
    },
    "satisfaction_conditions": [
      "Exchange-specific limitations are identified",
      "Data source characteristics are disclosed",
      "Behavior is confirmed as expected rather than erroneous",
      "Verification method is available"
    ],
    "created_at": "2018-02-02T14:56:43Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/1522",
    "source": {
      "issue_number": 1522
    },
    "initial_question": {
      "title": "hasFetchOHLCV result different from exchange.has for multiple exchanges",
      "body": "- OS: Windows 10\r\n- Programming Language version: Python 3.6.4\r\n- CCXT version: 1.10.854\r\n- Exchange: bittrex, gdax, maybe others\r\n- Method: hasFetchOHLCV\r\n```\r\nPython 3.6.4 (v3.6.4:d48eceb, Dec 19 2017, 06:54:40) [MSC v.1900 64 bit (AMD64)] on win32\r\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\r\n>>> import ccxt\r\n>>> bittrex = getattr(ccxt, 'bittrex')({'verbose': True})\r\n>>> bittrex.hasFetchOHLCV\r\nFalse\r\n>>> bittrex.has.get('fetchOHLCV')\r\nTrue\r\n>>> gdax = getattr(ccxt, 'gdax')({'verbose': True})\r\n>>> gdax.hasFetchOHLCV\r\nFalse\r\n>>> gdax.has.get('fetchOHLCV')\r\nTrue```"
    },
    "satisfaction_conditions": [
      "Documentation or responses clearly indicate the preferred/supported method for checking exchange capabilities",
      "Deprecated methods are properly identified"
    ],
    "created_at": "2018-01-27T00:01:17Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/1432",
    "source": {
      "issue_number": 1432
    },
    "initial_question": {
      "title": "HitBTC -> hitbtc $order $amount should be evenly divisible by lot unit size of 1000",
      "body": "Hi, im getting the following error when executing a limit sell order on HitBTC:\r\n\r\n`$hitbtc->createLimitSellOrder('XVG/BTC', '210.49790575916', '0.00000955');`\r\n\r\n`hitbtc $order $amount should be evenly divisible by lot unit size of 1000`\r\n\r\nHow should I interpret this? Which should be divisible by 1000, the total amount of the order? In this specific trade, the trade amount would be 0.002010255 BTC. What should my trade amount be for this trade to continue?\r\n\r\n"
    },
    "satisfaction_conditions": [
      "Trading pair specifications must be retrieved from current exchange settings"
    ],
    "created_at": "2018-01-22T20:55:48Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/1368",
    "source": {
      "issue_number": 1368
    },
    "initial_question": {
      "title": "Quoinex exchange id wrong in manual",
      "body": "Hi, \r\n\r\nper the manual, the id of Quoinex is \"quoinex\"\r\n\r\nHowever, using this code\r\n`let Quoinex = new ccxt.quoinex ({apiKey: API.Quoinex.Key, secret: API.Quoinex.Secret})`\r\n\r\nresults in this error: \r\n\r\n> TypeError: ccxt.quoinex is not a constructor\r\n>     at c:\\Trader\\Logic\\Test.js:68:22\r\n>     at FSReqWrap.readFileAfterClose [as oncomplete] (fs.js:511:3)\r\n\r\nIf I use \"new ccxt.quoine\", it does work.\r\n\r\nSo manual is wrong, (but I would actually prefer the naming to be per the manual, \"quoinex\")\r\n\r\nSo, do I change my code, or do you change yours?"
    },
    "satisfaction_conditions": [
      "The exchange object must be properly initialized with API credentials"
    ],
    "created_at": "2018-01-19T15:14:32Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/1345",
    "source": {
      "issue_number": 1345
    },
    "initial_question": {
      "title": "Question for selling an altcoin for bitcoin",
      "body": "OS:Linux\r\nProgramming Language version:Python\r\nCCXT version:1.10.586\r\nExchange:bleutrade\r\nMethod:create_limit_buy_order\r\n\r\nI want to sell an alt coin for bitcoin but calling create_limit_sell_order or create_limit_buy_order raise the exception of insufficient funds\r\n"
    },
    "satisfaction_conditions": [
      "Trading direction is correctly interpreted based on the currency pair format",
      "Correct order function is used for the desired trading direction",
      "Amount and price parameters are specified in the correct currency units",
      "Trade operation aligns with exchange-supported direction"
    ],
    "created_at": "2018-01-17T18:44:46Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/1097",
    "source": {
      "issue_number": 1097
    },
    "initial_question": {
      "title": "How to determine if bittrex's specific wallet is offline or under maintainance",
      "body": "Hello,\r\nIs there a way to check if a wallet on bittrex is offline or under maintainance etc?\r\n\r\nI used cctx.bittrex.load_markets() for ['FCT/BTC'] and returns \"active\":true even though the wallet is currently offline"
    },
    "satisfaction_conditions": [
      "Must distinguish between trading status and wallet status",
      "Must handle currency-specific queries"
    ],
    "created_at": "2018-01-06T21:01:00Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/1085",
    "source": {
      "issue_number": 1085
    },
    "initial_question": {
      "title": "Flip XRP on The rock",
      "body": "How can I flip EUR/XRP to XRP/EUR on TheRock trading\r\n- OS: any\r\n- Programming Language: python\r\n- CCXT version: latest master\r\n- Exchange: Therock\r\n- Method: fetch_l2_order_book\r\n\r\nCould you suggest me a way to flip the order book to align it with other exchanges ?\r\nactually therock publish data in EUR/XRP and BTC/XRP while the rest of the exchanges are in XRP/EUR do you have any strategy to flip the api ? (order_book would be the first but also the rest of the APIs)\r\nI could then implement it and send you a PR.\r\n"
    },
    "satisfaction_conditions": [
      "Price conversion must account for exchange-specific fee structures",
      "Solution must preserve exchange-specific token policies",
      "Risk factors must be considered in the conversion",
      "Market liquidity differences must be acknowledged"
    ],
    "created_at": "2018-01-06T01:24:24Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/1056",
    "source": {
      "issue_number": 1056
    },
    "initial_question": {
      "title": "What does edit order do",
      "body": "Can someone please explain what does edit order do? And how does it work (an example)?\r\n\r\nI did not find any information about it in the manual. \r\n\r\nThank you so much for this awesome tool!\r\n  "
    },
    "satisfaction_conditions": [
      "Order modification functionality must be available",
      "Original order must be identifiable",
      "Rate limiting must be enabled",
      "Order parameters must be modifiable",
      "Exchange compatibility must be handled"
    ],
    "created_at": "2018-01-03T21:29:06Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/932",
    "source": {
      "issue_number": 932
    },
    "initial_question": {
      "title": "Tracking all order books simultaneously",
      "body": "Is it possible to read the order book for every coin on binance simultaneously, or do I need to loop through to get each one?\r\n\r\n- OS: Macook\r\n- Language: Python\r\n- CCXT version:\r\n- Exchange: Binance\r\n- Method: \r\n\r\n```\r\nbook = exchange.fetch_order_book('Symbol') vs. book = exchange.fetch_order_book(<all_coins>)\r\n```"
    },
    "satisfaction_conditions": [
      "Order book data must be retrievable for all coins on Binance",
      "Data retrieval method must be compatible with the chosen API approach (REST or WebSocket)",
      "System must handle multiple order books according to API limitations"
    ],
    "created_at": "2017-12-22T07:58:51Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/772",
    "source": {
      "issue_number": 772
    },
    "initial_question": {
      "title": "XMR (Monero) Withdrawal and Payment ID example",
      "body": "Hello!\r\n\r\nMany (all?) exchanges require both wallet + payment ID to deposit XMR (Monero).\r\nTherefore, once withdrawing you should specify both wallet address and payment id. I failed to find a code example for payment id param:\r\n`exchange.withdraw (currency, amount, address, params = {})`\r\n\r\nCould you please help it?\r\n\r\nThank you in advance,\r\n\r\n"
    },
    "satisfaction_conditions": [
      "Payment ID must be successfully passed to the withdrawal request",
      "Payment ID must be specified in the exchange-specific format",
      "Withdrawal function must accept all required XMR transaction parameters",
      "Parameters must be properly structured according to the API's expected format"
    ],
    "created_at": "2017-12-07T00:27:11Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/625",
    "source": {
      "issue_number": 625
    },
    "initial_question": {
      "title": "'master' has been diverged",
      "body": "Hi, git noticed that we diverged after 1.10.148 and I'm unable to merge.\r\n\r\n30+ commits are missing from upstream.\r\n\r\nIs it known and I should just reset or it's something unexpected?"
    },
    "satisfaction_conditions": [
      "Commit history accurately reflects authorized authorship"
    ],
    "created_at": "2017-11-18T06:09:06Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/566",
    "source": {
      "issue_number": 566
    },
    "initial_question": {
      "title": "About cancellation of orders",
      "body": "How to find the hang order? How else to cancel the order?"
    },
    "satisfaction_conditions": [
      "Order status retrieval functionality must be available",
      "Order cancellation capability must be implemented",
      "Order status queries must support multiple order states",
      "Order identification must be unambiguous",
      "Market/symbol specification must be supported"
    ],
    "created_at": "2017-11-14T09:34:02Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/527",
    "source": {
      "issue_number": 527
    },
    "initial_question": {
      "title": "Exchanges not returning response dictionary of requests",
      "body": "Hi,\r\n\r\nI trade with some exchanges and regularly, for some buy, sell ou tranfers requests, my order is placed but no response dictionary is returned, so I do not know if the order was really placed. Is there anything I can do about it, or it's a problem with the exchange's server that happens sometimes?\r\n\r\nThanks fou your support."
    },
    "satisfaction_conditions": [
      "System must verify order placement status even when no immediate response is received",
      "System must handle exchange timeouts gracefully",
      "System must be able to recover order state after communication failures",
      "System must maintain accurate order state regardless of response reliability",
      "System must be configurable to accommodate varying exchange response times"
    ],
    "created_at": "2017-11-09T18:59:41Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/486",
    "source": {
      "issue_number": 486
    },
    "initial_question": {
      "title": "Binance: publicGetMarketIdHours",
      "body": "````\r\nhours = 8  # \u2190 your timeframe\r\ntopia.load_markets()\r\n\r\nfor symbol in btccoins:\r\n    market = topia.market(symbol)\r\n    response = topia.publicGetMarketIdHours(topia.extend({\r\n        'id': market['id'],\r\n        'hours': hours,\r\n    }))\r\n    time.sleep(delay)\r\n    ticker = topia.parse_ticker(response['Data'], market)  # How to be sure it returns the 8h past hour market?\r\n    # do whatever you need with the ticker...\r\n    datetime = ticker['datetime']\r\n    timestamp = ticker['timestamp']\r\n    open = ticker['open']\r\n    close = ticker['close']\r\n    print(close, datetime, timestamp)\r\n````\r\nthat's the result: -> timestamp is not 8h ago so how can I know it actually represents the 8h past hours timeframe?\r\n\r\n1.814e-05 2017-11-07T12:32:59.000Z 1510057979383\r\n1.209e-05 2017-11-07T12:33:01.000Z 1510057981017\r\n4.15e-05 2017-11-07T12:33:02.000Z 1510057982474\r\n1.07e-06 2017-11-07T12:33:04.000Z 1510057983791\r\n0.00105061 2017-11-07T12:33:05.000Z 1510057985092\r\n\r\nI'm sorry if I did something wrong in advance. I'm really trying to get this sorted out. thanks\r\n\r\n"
    },
    "satisfaction_conditions": [
      "Timestamp interpretation is correctly understood",
      "UTC time synchronization is maintained"
    ],
    "created_at": "2017-11-07T12:35:42Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/414",
    "source": {
      "issue_number": 414
    },
    "initial_question": {
      "title": "problem with exchange.parse8601()",
      "body": "Hi, this problem happens randomly so I'm not sure if it has something to do with ccxt itself or if it may be a race condition in my threaded program. From time to time, not always, when I call exchange.parse8601(), it shows the following exception:\r\n\r\n```\r\nException in thread Thread-24:\r\nTraceback (most recent call last):\r\n  File \"/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/threading.py\", line 810, in __bootstrap_inner\r\n    self.run()\r\n  File \"/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/threading.py\", line 763, in run\r\n    self.__target(*self.__args, **self.__kwargs)\r\n  File \"nemesis2.py\", line 437, in stream_ohlcv\r\n    from___ = exchange.parse8601(from__) \r\n  File \"/Library/Python/2.7/site-packages/ccxt/exchange.py\", line 589, in parse8601\r\n    dt = datetime.datetime.strptime(string, \"%Y%m%d%H%M%S.%fZ\")\r\nAttributeError: 'module' object has no attribute '_strptime'\r\n```\r\n\r\nMy code is as follows (I'm using relativedelta to extract the last 100 candles since the last time):\r\n\r\n```\r\nnow = datetime.datetime.now()\r\nfrom_ = now - relativedelta (minutes=100)\r\nfrom__='{:%Y-%m-%d %H:%M:%S}'.format(from_)\r\nfrom___ = exchange.parse8601(from__)\r\ndata = exchange.fetch_ohlcv(\"ETH/USD\", \"5m\", from___)\r\n```"
    },
    "satisfaction_conditions": [
      "Time-based data retrieval executes without threading errors",
      "Rate limits are respected across all API calls",
      "Historical data is retrieved for all specified trading pairs and timeframes",
      "Time conversions produce consistent results across multiple threads"
    ],
    "created_at": "2017-10-28T15:24:37Z"
  },
  {
    "id": "https://github.com/ccxt/ccxt/issues/379",
    "source": {
      "issue_number": 379
    },
    "initial_question": {
      "title": "fetch_ohlcv since problem",
      "body": "Hi, I'm not sure if this is a bug or a feature; the following code won't work:\r\n\r\n```\r\nsince=int(datetime.datetime.strptime('2017-10-23 00:00:00', '%Y-%m-%d %H:%M:%S').strftime(\"%s\"))\r\nohlc=polo.fetch_ohlcv(\"ETH/BTC\", '5m', since)\r\n```\r\nIt is needed to do the following: \r\n```\r\nsince=int(datetime.datetime.strptime('2017-10-23 00:00:00', '%Y-%m-%d %H:%M:%S').strftime(\"%s\"))\r\nsince *=1000\r\nohlc=polo.fetch_ohlcv(\"ETH/BTC\", '5m', since)\r\n```\r\nI found this because checking the ccxt source code, I saw that (in Poloniex at least) the start time was calculated doing:\r\n\r\n`'start': int(since / 1000),`\r\n\r\nMay be this is due to an old problem in Poloniex (I'm just guessing) and then Poloniex fixed the problem but the ccxt code still has the old workaround?. Anyway, this is not a problem, I can just multiply, but I'm not sure if I'm missing something."
    },
    "satisfaction_conditions": [
      "Timestamp must be provided in milliseconds format",
      "OHLCV data retrieval must return expected historical data from the specified start time",
      "Solution must work consistently across different cryptocurrency exchanges",
      "Timestamp conversion must maintain sufficient precision"
    ],
    "created_at": "2017-10-23T20:25:01Z"
  }
]