[
  {
    "id": "https://github.com/redisson/redisson/issues/6443",
    "source": {
      "issue_number": 6443
    },
    "initial_question": {
      "title": "Order Guarantees with the Async API",
      "body": "Hey,\nI\u2019m wondering if the following example guarantees execution order:\n```\nRBucket<String> bucket = redisson.getBucket(\"key\");\n\nbucket.setAsync(\"value\"); // Fire SET without waiting\nRFuture<String> future = bucket.getAsync(); \n\nfuture.thenAccept(System.out::println); \n```\nDoes SET always execute before GET, even though SET wasn\u2019t explicitly awaited?\n\n"
    },
    "satisfaction_conditions": [
      "Solution must handle asynchronous operation coordination",
      "Concurrent operations must be properly managed to prevent race conditions"
    ],
    "created_at": "2025-02-18T17:09:07Z"
  },
  {
    "id": "https://github.com/redisson/redisson/issues/5893",
    "source": {
      "issue_number": 5893
    },
    "initial_question": {
      "title": "RLocalCachedMap local cache use?",
      "body": "if the data change on redis server\uff0ccan we get the new data in local cache? or the server will info client the change?\r\n"
    },
    "satisfaction_conditions": [
      "Local cache must detect remote Redis data changes",
      "Local cache must be able to synchronize with updated Redis data",
      "Cache synchronization must work for changes made outside the Redisson client",
      "Cache synchronization configuration must be properly enabled"
    ],
    "created_at": "2024-05-21T09:09:24Z"
  },
  {
    "id": "https://github.com/redisson/redisson/issues/5882",
    "source": {
      "issue_number": 5882
    },
    "initial_question": {
      "title": "Here\u2019s the issue we encountered with `redisson-3.11.5.jar`",
      "body": "\r\nOur service connects to the SLB (Server Load Balancer) using a domain name, which maps through a port to the Redis server nodes.\r\n\r\nFor example:\r\n- Service IP --> Domain A:2700 --> EIP (10.75.10.20):27000 --> Redis server: 10.65.10.30:27000\r\n\r\nThe Redis sentinel nodes are:\r\n- 10.65.10.30:27000\r\n- 10.65.10.40:27000\r\n- 10.65.10.50:27000\r\n\r\nRedisson performs two types of checks: `scheduleSentinelDNSCheck` and `scheduleChangeCheck`. These checks result in the following situations:\r\n\r\n- `redis://10.75.10.20:27000 added`\r\n- `redis://10.75.10.20:27000 was down`\r\n- `redis://10.65.10.30:27000 added`\r\n- `redis://10.65.10.30:27000 was down`\r\n\r\nThis causes a polling effect, even though they ultimately point to the correct sentinel nodes.\r\n\r\n### How to Resolve This Issue\r\n"
    },
    "satisfaction_conditions": [
      "IP address translation between SLB and actual Redis nodes must be consistent"
    ],
    "created_at": "2024-05-20T02:52:53Z"
  },
  {
    "id": "https://github.com/redisson/redisson/issues/5830",
    "source": {
      "issue_number": 5830
    },
    "initial_question": {
      "title": "Issue with Kryo5Codec in combination with org.springframework.cache.support.NullValue",
      "body": "Hi,\r\n\r\nI'm currently having an issue with the Spring Cache implementation in combination with Redisson. \r\nThe JCacheCache class provided by Redisson extends `org.springframework.cache.support.AbstractValueAdaptingCache`. In the method `protected Object fromStoreValue(@Nullable Object storeValue)` of the class AbstractValueAdaptingCache, there is an if condition, that check if the storeValue is equal to NullValue.INSTANCE using ==. \r\n\r\n```\r\nprotected Object fromStoreValue(@Nullable Object storeValue) {\r\n\tif (this.allowNullValues && storeValue == NullValue.INSTANCE) {\r\n\t\treturn null;\r\n\t}\r\n\treturn storeValue;\r\n}\r\n```\r\n\r\nThis condition evaluated to false in my case, because the instance of storeValue was not the same instance as NullValue.INSTANCE. Reason is the deserialisation, that was done by Kryo. It seems, that Kryo changes the constructor to \"public\" using reflections and creates a new instance by calling the constructor. It does not call the \"readResolve()\" method of NullValue class, which would return NullValue.INSTANCE.\r\nIs this a known issue? The only solution I came up with is extending the Kryo5Codec and adding a custom Serializer for NullValue.class. Is there another way to fix this issue?\r\n\r\nBest regards"
    },
    "satisfaction_conditions": [
      "NullValue instance equality must be preserved after serialization and deserialization",
      "Solution must work with Redisson's Kryo5Codec serialization",
      "Spring framework's NullValue handling remains functional"
    ],
    "created_at": "2024-04-30T10:11:54Z"
  },
  {
    "id": "https://github.com/redisson/redisson/issues/5298",
    "source": {
      "issue_number": 5298
    },
    "initial_question": {
      "title": "How to successfully use Live Objects ?",
      "body": "I'm having difficulty with two different parts of the Live Objects feature of Redisson:\r\n\r\n1. Storing a nested `Map<String, String>` as a field of an '@REntity`\r\n2. Using a condition to `find()` instances that I know are stored.\r\n\r\nHere's my live object class (I'm using Lombok, hence the @Getter, etc annotations):\r\n```java\r\n@RequiredArgsConstructor\r\n@NoArgsConstructor(access = PROTECTED)\r\n@REntity(codec = StringCodec.class)\r\npublic class Manifest {\r\n\r\n\t@RId(generator = UUIDGenerator.class)\r\n\t@Getter\r\n\tprivate String id;\r\n\r\n\t@RIndex\r\n\t@Getter\r\n\tprivate String jobId;\r\n\r\n\t@RIndex\r\n\t@Getter\r\n\tprivate String rootFolder;\r\n\r\n\t@RCascade(ALL)  // Not sure this is needed, it doesn't seem to make any difference\r\n\tprivate Map<String, String> entries = new HashMap<>();\r\n\r\n\r\n\tpublic void add(String path, String hash) {\r\n\t\tentries.put(path, hash);\r\n\t}\r\n\r\n\t@Transient\r\n\tpublic int getSize() {\r\n\t\treturn entries.size();\r\n\t}\r\n\r\n}\r\n```\r\n\r\nI'm using this code to initially create and store the live object:\r\n```java\r\n\tRLiveObjectService liveObjects = redisson.getLiveObjectService();\r\n\tvar manifest = new Manifest(jobID, rootPath);\r\n\tmanifest = liveObjects.persist(manifest);\r\n\tliveObjects.asLiveObject(manifest).expire(Duration.ofMinutes(60));\r\n```\r\n\r\nElsewhere I use this code to get the object by ID and add data to its `entries` map:\r\n```java\r\n\tManifest manifest = liveObjects.get(Manifest.class, id);\r\n\tmanifest.add(path, hash);\r\n```\r\n\r\nSomewhere else, I use this code to find the object:\r\n```java\r\n\tpublic static Condition jobIDEquals(String jobID) {\r\n\t\treturn Conditions.eq(\"jobId\", jobID);\r\n\t}\r\n\r\n\tCollection<Manifest> manifests = liveObjects.find(Manifest.class, jobIDEquals(jobID));\r\n```\r\n\r\nWith the code above, the two problems are:\r\n1. The `manifests` collection is empty, even though I can inspect my Redis server (using RedisInsight) and see the hashes stored there with matching `jobId` values.\r\n2. If I load one of the objects directly by its `id`, the `entries` Map is always empty, _even after_ having added values to it. I see in RedisInsight that the value of `entries` is `org.redisson.RedissonReference@7623beea`, but there is no other key in Redis that corresponds to that reference.\r\n\r\nWhat am I doing wrong?"
    },
    "satisfaction_conditions": [
      "Collection field access within methods must use getter methods"
    ],
    "created_at": "2023-09-08T21:31:58Z"
  },
  {
    "id": "https://github.com/redisson/redisson/issues/5285",
    "source": {
      "issue_number": 5285
    },
    "initial_question": {
      "title": "RSorted Map comparator not working correctly",
      "body": "Trying to create a sorted map with a custom comparator for duplicate detection. For some reason  comparator is set, however duplicates are getting added to the sorted set.  \r\n\r\npublic class RedissonMessagingMgrTest {\r\n\r\n    private static MessagingMgr mgr = null;\r\n\r\n    @BeforeAll\r\n    public static void setUp() {\r\n       try {\r\n          mgr = new RedissonMessagingMgr(\"127.0.0.1\",6379,\"nishi\");\r\n       }\r\n       catch (Exception exception) {\r\n          exception.printStackTrace();\r\n       }\r\n    }\r\n\r\n    @Test\r\n    public void  testPublishNoDupQueue100() {\r\n        String queueName = \"NoDupQueue100\";\r\n        int msgCount=1;\r\n        boolean isPublished = false;\r\n        String str = \"This is my string as bytes\";\r\n        \r\n        mgr.createNoDupQueue(queueName, new TestMsgComparator());\r\n        byte[] bytes = null;\r\n        int i=0;\r\n        for ( i=0;i<msgCount;i++) {\r\n            str =  str + i;\r\n            bytes = str.getBytes();\r\n            TestMsg msg = new TestMsg(i,bytes, System.currentTimeMillis() );\r\n            isPublished = mgr.publishNoDupQueue(queueName,msg);\r\n        }\r\n        isPublished = mgr.publishNoDupQueue(queueName,new TestMsg(0,bytes, System.currentTimeMillis()));  \r\n        assertFalse(isPublished,\"No Duplicates Allowed\");\r\n    }\r\n\r\n}\r\n   \r\nMy Comparator class is as below:-\r\n\r\nimport java.util.Comparator;\r\n\r\npublic class TestMsgComparator implements Comparator<TestMsg> {\r\n    \r\n    @Override\r\n    public int compare(TestMsg a, TestMsg b)\r\n    {\r\n        return a.number  - b.number;\r\n    }\r\n}\r\n\r\nThe sorted set will contain objects of TestMsg\r\n\r\npublic class TestMsg implements PubSubMessage,  Serializable {\r\n    private byte[] data;\r\n    public int number;\r\n    private long timestamp;\r\n\r\n    public TestMsg(int number, byte[] data, long ts) {\r\n        this.number = number;\r\n        this.data = data;\r\n        this.timestamp = ts;\r\n    }\r\n\r\n    public long getNumber() {\r\n        return number;\r\n    }\r\n\r\n    public byte[] getData() {\r\n        return data;\r\n    }\r\n\r\n    public long getSortedScore() {\r\n        return timestamp;\r\n    } \r\n}\r\n\r\npublic class RedissonMessagingMgr implements MessagingMgr {\r\n\r\n   private static Logger log = LoggerFactory.getLogger(RedissonMessagingMgr.class);\r\n   private RedissonClient client = null;\r\n\r\n   public RedissonMessagingMgr(String host, int port, String password) throws \r\n   ConnectException {\r\n      log.info(\"[IN] RedissonMessagingMgr Constructor\");\r\n      Config config = new Config();\r\n      StringBuilder messagingAddress = new StringBuilder(\"redis://\");\r\n      messagingAddress.append(host).append(\":\").append(Integer.toString(port));\r\n      config.useSingleServer().setAddress(messagingAddress.toString());\r\n      config.useSingleServer().setPassword(password);\r\n      config.setNettyThreads(0);\r\n      \r\n      log.info(\"[OUT] RedissonCache Constructor\");\r\n   }\r\n}\r\n\r\npublic boolean createNoDupQueue(String name,Comparator comp ) {\r\n      boolean returnValue = false;\r\n      //RScoredSortedSet<PubSubMessage> sortedset = client.getScoredSortedSet(name);\r\n      RSortedSet<PubSubMessage> sortedset = client.getSortedSet(name);\r\n      \r\n      System.out.println(\"Comparator:\"+sortedset.comparator().getClass().getName());\r\n\r\n      try {\r\n         boolean set = sortedset.trySetComparator(comp);\r\n         System.out.println(\"Comparator:\"+sortedset.comparator().getClass().getName());\r\n\r\n      }\r\n      catch(RedisException exception) {\r\n         // ignoring the exception and invoking trySetComparator multiple time will raise this \r\n         // exception.\r\n         exception.printStackTrace();\r\n      }\r\n      if (sortedset != null)  {\r\n         returnValue = true;\r\n      }\r\n      return returnValue;\r\n   }\r\n\r\npublic boolean publishNoDupQueue(String queueName,PubSubMessage message) {\r\n      RScoredSortedSet<PubSubMessage> noDupQueue = client.getScoredSortedSet(queueName);\r\n      return noDupQueue.add(message.getSortedScore(),message);\r\n   }\r\n}"
    },
    "satisfaction_conditions": [
      "The comparison must be based on the number field only"
    ],
    "created_at": "2023-08-30T07:29:11Z"
  },
  {
    "id": "https://github.com/redisson/redisson/issues/4988",
    "source": {
      "issue_number": 4988
    },
    "initial_question": {
      "title": "RedisBusyException when running load tests",
      "body": "```\r\n`\r\nWARN  [2023-04-25 00:10:45,507] org.redisson.client.RedisBusyException: BUSY Redis is busy running a script. You can only call SCRIPT KILL or SHUTDOWN NOSAVE.. channel: [id: 0x99c796a7, L:/10.240.0.18:34142 - R:10.240.0.74/10.240.0.74:6379] data: CommandData [promise=java.util.concurrent.CompletableFuture@51438d95[Not completed, 1 dependents], command=(EVAL), params=[local currentTime = tonumber(table.remove(ARGV, 1)); local ttl = table.remove(ARGV, 1); local ttlNumber = tonumber(ttl); local maxSize = tonumber(redis.call('hget', KEYS[8], 'max-size'));local mode = redis.call('hget', KEYS[8], 'mode'); for i, value in ipairs(ARGV) do if i % 2 == 0 then local key = ARGV[i-1];local v = redis.call('hget', KEYS[1], key);local exists = false;if v ~= false then    local t, val = struct.unpack('dLc0', v);    local expireDate = 92233720368547758;    local expireDateScore = redis.call('zscore', KEYS[2], key);    if expireDateScore ~= false then        expireDate = tonumber(expireDateScore)    end;    if t ~= 0 then        local expireIdle = redis.call('zscore', KEYS[3], key);        if expireIdle ~= false then            expireDate = math.min(expireDate, tonumber(expireIdle))        end;    end;    if expireDate > tonumber(currentTime) then        exists = true;    end;end;if ttlNumber > 0 then     redis.call('zadd', KEYS[2], ttl, key); else     redis.call('zr..., 8, mht_collector, redisson__timeout__set:{mht_collector}, redisson__idle__set:{mht_collector}, redisson_map_cache_created:{mht_collector}, redisson_map_cache_updated:{mht_collector}, redisson__map_cache__last_access__set:{mht_collector}, redisson_map_cache_removed:{mht_collector}, {mht_collector}:redisson_options, ...], codec=org.redisson.codec.SerializationCodec]`\r\n```\r\n\r\nWe seem to get these RedisBusyExceptions at some point whenever we run load tests. On elastic cache side of things we have enough memory and CPU. So we are not bottlenecked by those. Our only doubt is network bandwidth. Any idea for what reasons this exception gets thrown?  \r\n"
    },
    "satisfaction_conditions": [
      "Redis script execution time must be identified and monitored",
      "System performance metrics must be monitored during load tests"
    ],
    "created_at": "2023-04-25T00:21:31Z"
  },
  {
    "id": "https://github.com/redisson/redisson/issues/4890",
    "source": {
      "issue_number": 4890
    },
    "initial_question": {
      "title": "Switching from Redis 4 to 6, will Redisson have compatibility issues?",
      "body": "Hi team, \r\n\r\nWe are going to upgrade Redis 4 to Redis 6. I would like to ask team if there will be compatibility issues between Redission and Redis 6 after upgrading 4 to 6. Or do you know of any known Redission incompatibilities due to Redis 6 upgrades?\r\nAccording to redission documentation, Redission supports Redis 4 and 6. Does this mean that we don't need to modify any client code? \r\n\r\nMany thanks for your support!"
    },
    "satisfaction_conditions": [
      "Redisson client continues to function correctly after Redis upgrade",
      "No client code modifications are required",
      "Version compatibility is explicitly confirmed",
      "Existing Redisson features remain supported"
    ],
    "created_at": "2023-02-22T13:23:12Z"
  },
  {
    "id": "https://github.com/redisson/redisson/issues/4768",
    "source": {
      "issue_number": 4768
    },
    "initial_question": {
      "title": "Classfile version 61 (Java17) change intended?",
      "body": "Is it an intended or accidental change to publish redisson compiled with java17 target and thus break everyone not yet lucky enough to be on 17?\r\nIf so, wouldn't a change like this be good to be documented as incompatible in the release notes?\r\n\r\nAlso i was expecting such a drastic thing to be a major, rather than a minor change (in terms of SemVer)."
    },
    "satisfaction_conditions": [
      "Java bytecode version compatibility is verified",
      "Backward compatibility with Java 8 is maintained"
    ],
    "created_at": "2022-12-29T15:48:50Z"
  },
  {
    "id": "https://github.com/redisson/redisson/issues/4674",
    "source": {
      "issue_number": 4674
    },
    "initial_question": {
      "title": "Expire RRateLimiter",
      "body": "I want to delete RRateLimiter hash from redis, post rate interval is over. e.g. I set rate interval of 10 sec then hash must be removed post 10 sec.\r\nIs there any built in api for this functinality exists? "
    },
    "satisfaction_conditions": [
      "Rate limiter data is automatically removed after the specified interval",
      "Expiration time matches the rate limit interval",
      "Redis storage is cleared without manual intervention"
    ],
    "created_at": "2022-11-15T08:22:44Z"
  },
  {
    "id": "https://github.com/redisson/redisson/issues/4670",
    "source": {
      "issue_number": 4670
    },
    "initial_question": {
      "title": "How to set cache properties for Hibernate scond level cache?",
      "body": "I'm working on a Java spring project where I have multiple entities to be cached using `@Cache` annotation, ex:\r\n`@Cache(usage = CacheConcurrencyStrategy.READ_WRITE ,region = \"cache1\")`\r\n\r\nI have set ` spring.jpa.properties.hibernate.cache.region.factory_class` to be RedissonRegionFactory\r\n\r\nAs I'm using Redis cache as Hibernate second Level cache, I want a way to customize the properties of each cache region in a Java class, by properties I mean the TTL and maxEntriesLocalHeap.\r\n\r\n"
    },
    "satisfaction_conditions": [
      "Cache properties must be configurable per individual entity/region",
      "Configuration must support Hibernate second-level cache integration",
      "Cache configuration must support time-based properties (TTL)",
      "Cache configuration must support size/capacity limits",
      "Configuration must be compatible with Redis cache implementation"
    ],
    "created_at": "2022-11-13T08:38:42Z"
  },
  {
    "id": "https://github.com/redisson/redisson/issues/4667",
    "source": {
      "issue_number": 4667
    },
    "initial_question": {
      "title": "Regarding definition of nettyThreads",
      "body": "`nettyThreads` is defined as _Threads amount shared between all internal redis clients used by Redisson._\r\n\r\nFor e.g. my application connects to 3 different Redis clusters (2 sentinel based clusters, 1 multi-master cluster), all of them are initialized with different connections pool sizes and nettyThreads size. Should I keep  `nettyThreads` same across the redis clients here? "
    },
    "satisfaction_conditions": [
      "Thread pool resources are efficiently allocated across multiple Redis client connections",
      "Resource sharing mechanism is properly configured across Redis clients"
    ],
    "created_at": "2022-11-11T04:35:33Z"
  },
  {
    "id": "https://github.com/redisson/redisson/issues/4585",
    "source": {
      "issue_number": 4585
    },
    "initial_question": {
      "title": "Redisson Client creating more connections to Redis (Elastic cache cluster) than expected",
      "body": "We are using Redisson client(**3.11.5 version**) for distributed lock use-case.\r\nWe are using 8 primary and 8 replica in AWS Elastic cache.\r\nRedisson is a singleton object in our Java application instance.\r\n\r\nWe are noticing Redisson client creating more than max connections configured.  Noticed that 24K+ active connections were created from single application instance\r\nMax master connections configured was 1000.\r\n\r\n{code}\r\n\r\n@Bean\r\npublic Redisson clusterServerRedisson() {\r\n        final StringBuilder serverAddress = new StringBuilder()\r\n                .append(\"rediss://\")\r\n                .append(this.environment.getRequiredProperty(RedisPropertyConstants.REDIS_HOST))\r\n                .append(\":\")\r\n                .append(this.environment.getRequiredProperty(RedisPropertyConstants.REDIS_PORT, Integer.class));\r\n        final String redisPassword = this.environment.getRequiredProperty(RedisPropertyConstants.REDIS_PASSWORD);\r\n\r\n        final Config config = new Config();\r\n\r\n        final ClusterServersConfig clusterServersConfig = config.useClusterServers();\r\n        clusterServersConfig.addNodeAddress(serverAddress.toString());\r\n        if (StringUtils.isNotBlank(redisPassword)) {\r\n            clusterServersConfig.setPassword(redisPassword);\r\n        }\r\n        // Redis cluster scan interval in milliseconds.\r\n        clusterServersConfig.setScanInterval(this.environment.getRequiredProperty(RedisPropertyConstants.REDIS_REDISSON_CLUSTER_SCAN_INTERVAL_TIMEOUTMILLIS, int.class));\r\n\r\n        // Redis 'master' node maximum connection pool size\r\n        clusterServersConfig.setMasterConnectionPoolSize(this.environment.getRequiredProperty(RedisPropertyConstants.REDIS_REDISSON_CONNECTION_MAX_POOL_SIZE, int.class));\r\n\r\n        // Redis 'master' node minimum idle connection amount for each master node\r\n        clusterServersConfig.setMasterConnectionMinimumIdleSize(this.environment.getRequiredProperty(RedisPropertyConstants.REDIS_REDISSON_CONNECTION_MIN_IDLE_SIZE, int.class));\r\n\r\n        // Timeout in milliseconds during connecting to any Redis server.\r\n        clusterServersConfig.setConnectTimeout(this.environment.getRequiredProperty(RedisPropertyConstants.REDIS_REDISSON_CONNECTION_TIMEOUTMILLIS, int.class));\r\n\r\n        // Operation timeout - counter starts once command has been sent to the redis server\r\n        // Redis server response timeout in milliseconds. Starts to countdown when Redis command was succesfully sent.\r\n        clusterServersConfig.setTimeout(this.environment.getRequiredProperty(RedisPropertyConstants.REDIS_REDISSON_OP_TIMEOUTMILLIS, int.class));\r\n\r\n        clusterServersConfig.\r\n        // For connection failures outside of the (jedis) pool\r\n        clusterServersConfig.setRetryAttempts(this.environment.getRequiredProperty(RedisPropertyConstants.REDIS_REDISSON_CONNECTION_MAX_RETRY_COUNT, int.class));\r\n        clusterServersConfig.setRetryInterval(this.environment.getRequiredProperty(RedisPropertyConstants.REDIS_REDISSON_CONNECTION_RETRY_DELAYMILLIS, int.class));\r\n\r\n        // Since we use redis primarily as a messaging conduit (PubSub), we tune the following items\r\n        clusterServersConfig.setSubscriptionsPerConnection(\r\n                this.environment.getRequiredProperty(RedisPropertyConstants.REDIS_REDISSON_SUBSCRIPTION_PER_CONNECTION_SIZE, int.class));\r\n        clusterServersConfig.setSubscriptionConnectionPoolSize(\r\n                this.environment.getRequiredProperty(RedisPropertyConstants.REDIS_REDISSON_SUBSCRIPTION_CONNECTION_MAX_POOL_SIZE, int.class));\r\n\r\n        clusterServersConfig.setClientName(this.environment.getRequiredProperty(RedisPropertyConstants.REDIS_REDISSON_CONNECTION_NAME, String.class));\r\n\r\n        return (Redisson)Redisson.create(config);\r\n    }\r\n\r\n{code}\r\n## Redisson Client for Redis\r\nredis.redisson.cluster.scan.interval.timeoutMillis=30000\r\nredis.redisson.connection.name=MY-APP-REDISSON-POOL\r\nredis.redisson.connection.max.pool.size=1000\r\nredis.redisson.connection.max.retry.count=10\r\nredis.redisson.connection.min.idle.size=100\r\nredis.redisson.connection.retry.delayMillis=1500\r\nredis.redisson.connection.timeoutMillis=60000\r\nredis.redisson.idle.connection.timeoutMillis=10000\r\nredis.redisson.lock.timeoutMillis=10000\r\nredis.redisson.op.timeoutMillis=30000\r\nredis.redisson.subscription.connection.max.pool.size=50\r\nredis.redisson.subscription.per.connection.size=10\r\n\r\n\r\npublic class RedisLock implements DistributableLock {\r\n\r\n    private final RedisConfigManager redisConfigManager;\r\n    private final Redisson redisson;\r\n\r\n    public RedisLock(final Redisson redisson) {\r\n        this.redisson = this.redisConfigManager.getRedisson();\r\n    }\r\n\r\n    @Override\r\n    public void acquireLock(final Object object) {\r\n        getLockInstance(object).lock(this.redisConfigManager.getLockTimeoutInMillis(), TimeUnit.MILLISECONDS);\r\n    }\r\n\r\n    @Override\r\n    public void releaseLock(final Object object) {\r\n        getLockInstance(object).unlock();\r\n    }\r\n\r\n    @Override\r\n    public boolean tryWriteLock(final Object object) {\r\n        return getReadWriteLockInstance(object).writeLock().tryLock();\r\n    }\r\n\r\n    @Override\r\n    public void acquireReadLock(final Object object) {\r\n        getReadWriteLockInstance(object).readLock().lock();\r\n    }\r\n\r\n    @Override\r\n    public void releaseReadLock(final Object object) {\r\n        getReadWriteLockInstance(object).readLock().unlock();\r\n    }\r\n\r\n    @Override\r\n    public void acquireWriteLock(final Object object) {\r\n        getReadWriteLockInstance(object).writeLock().lock(this.redisConfigManager.getLockTimeoutInMillis(), TimeUnit.MILLISECONDS);\r\n    }\r\n\r\n    @Override\r\n    public void releaseWriteLock(final Object object) {\r\n         getReadWriteLockInstance(object).writeLock().unlock();\r\n    }\r\n\r\n    private RLock getLockInstance(final Object object) {\r\n        Assert.notNull(object, \"Cannot lock or unlock a null object\");\r\n\r\n        final RLock rLock = this.redisson.getLock(Integer.toString(object.hashCode()));\r\n        if (rLock == null) {\r\n            throw new IllegalStateException(\"Cannot get lock instance.\");\r\n        }\r\n        return rLock;\r\n    }\r\n\r\n    private RReadWriteLock getReadWriteLockInstance(final Object object) {\r\n        Assert.notNull(object, \"Cannot lock or unlock a null object\");\r\n\r\n        final RReadWriteLock rwLock = this.redisson.getReadWriteLock(Integer.toString(object.hashCode()));\r\n        if (rwLock == null) {\r\n            throw new IllegalStateException(\"Cannot get read write lock instance.\");\r\n        }\r\n        return rwLock;\r\n    }\r\n\r\n}\r\n\r\n\r\nAny help would be highly appreciable. Thanks in advance."
    },
    "satisfaction_conditions": [
      "Distributed lock functionality must continue working correctly"
    ],
    "created_at": "2022-10-07T05:29:34Z"
  },
  {
    "id": "https://github.com/redisson/redisson/issues/4284",
    "source": {
      "issue_number": 4284
    },
    "initial_question": {
      "title": "What difference from `readAllEntrySet` and `getAll` in `RMap`",
      "body": "Hi~ Community:\r\n    When I want to use `hmget` command in redis, I found `rMap.getAll(\"\")`, it returns all fields, so what difference from `readAllEntrySet` and `getAll` in `RMap`?\r\n"
    },
    "satisfaction_conditions": [
      "Explanation clearly distinguishes between selective and complete data retrieval methods",
      "Specifies the scope of data returned by each method"
    ],
    "created_at": "2022-05-10T12:57:00Z"
  },
  {
    "id": "https://github.com/redisson/redisson/issues/4065",
    "source": {
      "issue_number": 4065
    },
    "initial_question": {
      "title": "How to use 'zAdd'?",
      "body": "How to use 'RedisZSetCommands.zAdd(byte[] key, double score, byte[] value)'?\r\nnot implemented\uff1f"
    },
    "satisfaction_conditions": [
      "The zAdd method must be callable with key, score and value parameters",
      "The method must execute without implementation errors",
      "The method must be compatible with the Spring Data Redis version being used"
    ],
    "created_at": "2022-01-10T09:22:53Z"
  },
  {
    "id": "https://github.com/redisson/redisson/issues/4046",
    "source": {
      "issue_number": 4046
    },
    "initial_question": {
      "title": "Reads only happening from Master Node for Redis Cache in Elastic Cache replicated mode",
      "body": "We are using the clustered connection in aws for redis, but the read is always happening from the primary node.\r\n\r\nThe versions we are using:\r\n\r\nRedis engine in aws  : 4.0.10\r\n\r\nClient:\r\n                       <dependency>\r\n\t\t\t\t<groupId>org.redisson</groupId>\r\n\t\t\t\t<artifactId>redisson</artifactId>\r\n\t\t\t\t<version>3.16.6</version>\r\n\t\t\t</dependency>\r\n\r\n\r\nConfig:\r\nURL: aws cluster url\r\nfinal int poolSize = Runtime.getRuntime().availableProcessors() * 2 + 2;\r\n\t\tConfig config = new Config();\r\n\t\tconfig\r\n\t\t\t.useClusterServers()\r\n\t\t\t.setScanInterval(2000)\r\n\t\t\t.addNodeAddress(redisUrl)\r\n\t\t\t.setMasterConnectionPoolSize(poolSize)\r\n\t\t\t.setMasterConnectionMinimumIdleSize(poolSize)\r\n\t\t\t.setSlaveConnectionPoolSize(poolSize)\r\n\t\t\t.setSlaveConnectionMinimumIdleSize(poolSize)\r\n\t\t\t\t.setReadMode(ReadMode.SLAVE);\r\n\r\n\t\tconfig.setCodec(codec);\r\n\t\tredissonClient = Redisson.create(config);\r\n\r\n\r\nCache read:\r\n\r\n                final RMap<String, Config> cache = this.redissonClient.getMap(CONFIG_CACHE);\r\n\t\tif (cache.isEmpty()) {\r\n\t\t\tlog.info(\"found Config cache empty... reloading from database\");\r\n\t\t\treloadPartnerConfig();\r\n\t\t}\r\n\t\treturn cache.get(apiKey);\r\n\r\n\r\n@mrniko  Could you check this once you have some time. I am sure you can provide a relevant answer very fast.\r\n"
    },
    "satisfaction_conditions": [
      "The solution must maintain proper functionality with Redis cluster mode",
      "The solution must be compatible with the Redisson client implementation"
    ],
    "created_at": "2021-12-23T11:38:40Z"
  },
  {
    "id": "https://github.com/redisson/redisson/issues/3925",
    "source": {
      "issue_number": 3925
    },
    "initial_question": {
      "title": "Redisson client injects weird characters at the beginning of strings",
      "body": "I'm using Redisson client to publish String messages on a topic, but for some reasons, the published messages always contain some weird characters at the beginning:\r\n\r\neg: when I publish the string \"{\"event\":\"notification\"}\" at the redis level I end up with this: \"\\x04>\\x18{\"event\":\"notification\"}\"\r\n\r\n1) \"pmessage\"\r\n2) \"*\"\r\n3) \"active_project_users:1\"\r\n4) \"\\x04>\\x18{\\\"event\\\":\\\"notification\\\"}\"\r\n\r\nAny idea how I can make those weird chars go away?\r\n\r\nMy java code looks like this:\r\n\r\n private void publish(String channel, String message) {       \r\n        RTopic topic = redissonClient.getTopic(channel);\r\n        topic.publish(\"{\\\"event\\\":\\\"notification\\\"}\");\r\n    }\r\nI'm using redis:3.2 & radisson-spring-boot-starter 3.16.1\r\n\r\nThanks"
    },
    "satisfaction_conditions": [
      "The solution must be compatible with the existing Redis and Redisson infrastructure"
    ],
    "created_at": "2021-10-29T12:01:41Z"
  },
  {
    "id": "https://github.com/redisson/redisson/issues/3860",
    "source": {
      "issue_number": 3860
    },
    "initial_question": {
      "title": "How does PING influences the BATCH command?",
      "body": "I'm doing a batch command in the following way:\r\n\r\n```\r\n...\r\n  final RBatch rBatch = redissonClient.createBatch();\r\n        for (final String key : keys) {\r\n            rBatch.getMap(key, StringCodec.INSTANCE).getAsync(fieldName);\r\n        }\r\n  final List<?> responses = rBatch.execute().getResponses();\r\n ...\r\n```\r\nFrom time to time we get the following Timeout exception:\r\n```\r\norg.redisson.client.RedisResponseTimeoutException: Redis server response timeout (20 ms) occured after 0 retry attempts. Increase nettyThreads and/or timeout settings. Try to define pingConnectionInterval setting. Command: null, params: null\r\n```\r\n\r\nI'm wondering about the *Try to define pingConnectionInterval setting.* in the WARN message. We use the default setting for PING (the 30s interval). What is the meaning of that sentence in the message? Is the PING necessary? Could we disable the PING?  How does the PING influences the batch command? Any suggestions how this WARN can be avoided?\r\n\r\n\r\nRedis: 5.0.5\r\nRedisson: 3.16.3\r\n"
    },
    "satisfaction_conditions": [
      "Connection health monitoring is appropriately configured for the deployment environment",
      "Connection management strategy matches infrastructure requirements"
    ],
    "created_at": "2021-10-04T09:42:08Z"
  },
  {
    "id": "https://github.com/redisson/redisson/issues/3754",
    "source": {
      "issue_number": 3754
    },
    "initial_question": {
      "title": "Is there any guideline for upgrading the middle value of a version",
      "body": "Will it be an incompatible version when I upgrade from 3.11.x to 3.15.x?\r\nIs there any reason or guideline for the version value?"
    },
    "satisfaction_conditions": [
      "Version compatibility between source and target versions is confirmed",
      "Rationale for version numbering scheme is addressed",
      "Breaking changes status is clearly stated"
    ],
    "created_at": "2021-08-02T05:14:11Z"
  },
  {
    "id": "https://github.com/redisson/redisson/issues/3654",
    "source": {
      "issue_number": 3654
    },
    "initial_question": {
      "title": "Is order of Operations in a RBatch guaranteed?",
      "body": "Sorry if this is obvious, but i did not find any documentstion about this:\r\n\r\nIf i am using **RBatch** and create let's say a Bucket from it, and call setAsync on the bucket 100 times before executing the batch, is the order of the operations in the batch guaranteed to be the order in which\r\n```\r\nsetAsync(Object)\r\n```\r\nhas been called?\r\n\r\nIn other words, is there any way i could end up with anything but the last value i set to the bucket after the RBatch is executed? For instance if the Marshalling of the 99th value took some time?\r\n\r\nBucket is just an example here, i am also using RMaps the same way."
    },
    "satisfaction_conditions": [
      "Operations within a single RBatch must execute in the same order they were added",
      "All batch operations from a single thread must maintain sequence integrity",
      "Final state must reflect the last value set, regardless of marshalling time",
      "Thread-safety considerations must be addressed when using RBatch"
    ],
    "created_at": "2021-06-11T06:09:58Z"
  },
  {
    "id": "https://github.com/redisson/redisson/issues/3626",
    "source": {
      "issue_number": 3626
    },
    "initial_question": {
      "title": "Will RLOS indexed based querying work in cluster enabled Redis?",
      "body": "When we use cluster enabled Redis like AWS EC, it's possible that objects gets stored on different shards. Will the indexed based querying still work here?"
    },
    "satisfaction_conditions": [
      "Index functionality must work correctly across sharded Redis clusters",
      "System must support storage and indexing of billions of objects of the same class",
      "Index distribution must avoid single-shard bottlenecks",
      "Batch operations must maintain data consistency"
    ],
    "created_at": "2021-05-28T05:46:43Z"
  },
  {
    "id": "https://github.com/redisson/redisson/issues/3601",
    "source": {
      "issue_number": 3601
    },
    "initial_question": {
      "title": "RTopic -ERR only (P)SUBSCRIBE / (P)UNSUBSCRIBE / QUIT allowed in this context",
      "body": "Did I use Rtopic incorrectly?\r\nCode:\r\n```\r\n void pubEvent(){\r\n  RTopic topic = redissonClient.getTopic(\"test-topic\")\r\n  topic.publish(new Event(\"hello world\"))\r\n}\r\n\r\n void subEvent(){\r\n   RTopic topic = redissonClient.getTopic(\"test-topic\")\r\n   topic.addListener(new MessageListener<Event>(){\r\n            @Override\r\n            public void onMessage(CharSequence channel, Event event) {\r\n                log.debug(\"channel:{},Event :{}\", channel, event);\r\n            }\r\n  })\r\n}\r\n\r\n public static void main(String[] args){\r\n             Executors.newSingleThreadScheduledExecutor().scheduleWithFixedDelay(this::pubEvent, 1000, 10000, TimeUnit.MILLISECONDS);\r\n             subEvent();\r\n             Thread.sleep(1000000);\r\n }\r\n```\r\n\r\nConfig:\r\n```\r\nspring:\r\n  redis:\r\n    redisson:\r\n      config: |\r\n        singleServerConfig:\r\n          address: \"redis://localhost:6379\"\r\n          connectTimeout: 30000\r\n          pingConnectionInterval: 10000\r\n        codec: !<org.redisson.codec.JsonJacksonCodec> {}\r\n```\r\n\r\nError:\r\n```\r\n2021-05-10 10:56:48.237 ERROR 10184 --- [isson-timer-4-1] o.r.c.handler.PingConnectionHandler      : Unable to send PING command over channel: [id: 0x6657975f, L:/2.0.1.49:54140 - R:/172.19.13.25:6379]\r\norg.redisson.client.RedisException: ERR only (P)SUBSCRIBE / (P)UNSUBSCRIBE / QUIT allowed in this context. channel: [id: 0x6657975f, L:/2.0.1.49:54140 - R:/172.19.13.25:6379] command: (PING), params: []\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:343) ~[redisson-3.14.1.jar:3.14.1]\r\n\tat org.redisson.client.handler.CommandPubSubDecoder.decodeCommand(CommandPubSubDecoder.java:83) ~[redisson-3.14.1.jar:3.14.1]\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:117) ~[redisson-3.14.1.jar:3.14.1]\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:102) ~[redisson-3.14.1.jar:3.14.1]\r\n\tat io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:501) ~[netty-codec-4.1.51.Final.jar:4.1.51.Final]\r\n\tat io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:366) ~[netty-codec-4.1.51.Final.jar:4.1.51.Final]\r\n\tat io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:276) ~[netty-codec-4.1.51.Final.jar:4.1.51.Final]\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379) ~[netty-transport-4.1.51.Final.jar:4.1.51.Final]\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365) ~[netty-transport-4.1.51.Final.jar:4.1.51.Final]\r\n\tat io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357) ~[netty-transport-4.1.51.Final.jar:4.1.51.Final]\r\n\tat io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1410) ~[netty-transport-4.1.51.Final.jar:4.1.51.Final]\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379) ~[netty-transport-4.1.51.Final.jar:4.1.51.Final]\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365) ~[netty-transport-4.1.51.Final.jar:4.1.51.Final]\r\n\tat io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:919) ~[netty-transport-4.1.51.Final.jar:4.1.51.Final]\r\n\tat io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:163) ~[netty-transport-4.1.51.Final.jar:4.1.51.Final]\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:714) ~[netty-transport-4.1.51.Final.jar:4.1.51.Final]\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:650) ~[netty-transport-4.1.51.Final.jar:4.1.51.Final]\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:576) ~[netty-transport-4.1.51.Final.jar:4.1.51.Final]\r\n\tat io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:493) ~[netty-transport-4.1.51.Final.jar:4.1.51.Final]\r\n\tat io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:989) ~[netty-common-4.1.51.Final.jar:4.1.51.Final]\r\n\tat io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74) ~[netty-common-4.1.51.Final.jar:4.1.51.Final]\r\n\tat io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) [netty-common-4.1.51.Final.jar:4.1.51.Final]\r\n\tat java.lang.Thread.run(Thread.java:748) [na:1.8.0_262]\r\n````"
    },
    "satisfaction_conditions": [
      "Redis server version must be compatible with Redisson pub/sub operations"
    ],
    "created_at": "2021-05-10T03:09:25Z"
  },
  {
    "id": "https://github.com/redisson/redisson/issues/3580",
    "source": {
      "issue_number": 3580
    },
    "initial_question": {
      "title": "Async lock thread affinity",
      "body": "Hi,\r\n\r\nI'm working on a kotlin micronaut web app which is attempting to be fully async and we're using redisson for distributed locks.\r\n\r\nI'm somewhat unclear on how to exactly use it correctly.\r\n\r\nThe official documentation says `RLock object behaves according to the Java Lock specification. It means only lock owner thread can unlock it otherwise IllegalMonitorStateException would be thrown. Otherwise consider to use RSemaphore object.` which sounds weird as in an async context, executing on a specific threads is never guaranteed.\r\n\r\nThe code I'm using for now, in a kotlin suspendable func, is like this:\r\n``` kotlin\r\nval lock = rediClinet.getLock(\"lock_name)\r\ntry {\r\n    (lock.lockAsync(50, TimeUnit.SECONDS) as CompletionStage<Void>).await()\r\n    //fancy kotlin async code here.\r\n}\r\nfinally {\r\n    (lock.unlockAsync() as CompletionStage<Void>).await()\r\n}\r\n```\r\n\r\nThe unlock line is not guaranteed to execute on the same thread as the lockAsync line.\r\n\r\nThanks!"
    },
    "satisfaction_conditions": [
      "Lock acquisition and release must be paired with matching identifiers",
      "Lock operations must complete successfully in async context",
      "Lock release must be possible from any thread"
    ],
    "created_at": "2021-04-27T07:42:51Z"
  },
  {
    "id": "https://github.com/redisson/redisson/issues/3544",
    "source": {
      "issue_number": 3544
    },
    "initial_question": {
      "title": "Why ExpirationEntry use LinkedHashMap to save threadId",
      "body": "Reddison watchDog strategy use timerTask to increase key expiration time while set the lock success\r\n\r\n    private void renewExpiration() {\r\n        ExpirationEntry ee = EXPIRATION_RENEWAL_MAP.get(getEntryName());\r\n        if (ee == null) {\r\n            return;\r\n        }\r\n        \r\n        Timeout task = commandExecutor.getConnectionManager().newTimeout(new TimerTask() {\r\n            @Override\r\n            public void run(Timeout timeout) throws Exception {\r\n                ExpirationEntry ent = EXPIRATION_RENEWAL_MAP.get(getEntryName());\r\n                if (ent == null) {\r\n                    return;\r\n                }\r\n                Long threadId = ent.getFirstThreadId();\r\n                if (threadId == null) {\r\n                    return;\r\n                }\r\n                \r\n                RFuture<Boolean> future = renewExpirationAsync(threadId);\r\n                ......\r\n       }\r\n   }\r\n\r\n  First use **entryName** to get ExpirationEntry object. For the same entryName, other threads can't get the key because locked(ps: same thread can get and counter++)\uff0cso why use LinkedHashMap to save thread if there only have one thread?\r\n\r\n`public static class ExpirationEntry {\r\n\r\n        private final Map<Long, Integer> threadIds = new LinkedHashMap<>();\r\n        private volatile Timeout timeout;\r\n\r\n        public ExpirationEntry() {\r\n            super();\r\n        }\r\n\r\n        public synchronized void addThreadId(long threadId) {\r\n            Integer counter = threadIds.get(threadId);\r\n            if (counter == null) {\r\n                counter = 1;\r\n            } else {\r\n                counter++;\r\n            }\r\n            threadIds.put(threadId, counter);\r\n        }\r\n}`"
    },
    "satisfaction_conditions": [
      "Must support multiple concurrent read operations from different threads",
      "Must maintain thread access count accurately",
      "Must preserve thread access order",
      "Must support thread-safe operations"
    ],
    "created_at": "2021-04-09T09:28:20Z"
  },
  {
    "id": "https://github.com/redisson/redisson/issues/3493",
    "source": {
      "issue_number": 3493
    },
    "initial_question": {
      "title": "Transaction in Redis Live Object Service",
      "body": "Hi,\r\n\r\nIs it possible to perform transaction on Redis Live Object?\r\nI want write a new instance of MyClass - only if new instance is newer than previous one. \r\nI need method similar to 'merge' in RMap. \r\n\r\n    @REntity\r\n    public class MyClass {\r\n\r\n        @RId\r\n        private String key;\r\n\r\n        @RIndex\r\n        public Date createDate;\r\n\r\n        @RIndex\r\n        public String externalValue;\r\n     }\r\n\r\nSo I need to compare dates of old and new objects and then save new object only if it newer. It has be executed in one transaction. In other thread someone can update fields in this object."
    },
    "satisfaction_conditions": [
      "Atomic comparison and update of object based on date",
      "Concurrent access protection",
      "Date-based conditional update",
      "Unique object identification"
    ],
    "created_at": "2021-03-16T21:14:11Z"
  },
  {
    "id": "https://github.com/redisson/redisson/issues/3476",
    "source": {
      "issue_number": 3476
    },
    "initial_question": {
      "title": "Caused by: java.lang.ClassNotFoundException: com.fasterxml.jackson.core.TSFBuilder",
      "body": "keep getting this error when i try this\r\nConfig.fromYAML(PropertiesUtil.getResourceAsFile(REDISSON_RESOURCE_NAME));\r\n\r\nthe exception is \r\nCaused by: java.lang.NoClassDefFoundError: com/fasterxml/jackson/core/TSFBuilder\r\n\tat org.redisson.config.ConfigSupport.<init>(ConfigSupport.java:92)\r\n\tat org.redisson.config.Config.fromYAML(Config.java:661)\r\n\tat org.redisson.config.Config.fromYAML(Config.java:657)\r\n\r\nwhen I try to look at the code can't find usage for TSFBuilder at class ConfigSupport"
    },
    "satisfaction_conditions": [
      "Compatible Jackson library versions must be present in the project"
    ],
    "created_at": "2021-03-14T23:59:36Z"
  },
  {
    "id": "https://github.com/redisson/redisson/issues/3398",
    "source": {
      "issue_number": 3398
    },
    "initial_question": {
      "title": "org.redisson.api.RAtomicLong#expireAt(long)  Cause the value to be deleted  ",
      "body": "Redisson:3.15.0\r\nredis:4.0.9\r\n\r\norg.redisson.api.RAtomicLong#expireAt(long)\r\nCannot find the key of aKey after execution\r\n\r\nWhy is this ?\r\n\r\njava code\r\n```\r\n        Config config = new Config();\r\n        config.useSingleServer()\r\n                .setAddress(\"redis://127.0.0.1:6379\")\r\n                .setDatabase(0);\r\n        RedissonClient redissonClient = Redisson.create(config);\r\n\r\n        String aKey = \"aKey\";\r\n        RAtomicLong aAtomic = redissonClient.getAtomicLong(aKey);\r\n        long aValue0 = aAtomic.get();\r\n        LOG.info(\"aKey-value0[{}]\", aValue0);\r\n\r\n        aAtomic.incrementAndGet();\r\n        long aValue1 = aAtomic.get();\r\n        LOG.info(\"aKey-value1[{}]\", aValue1);\r\n        aAtomic.expireAt(1000 * 60 * 60);\r\n\r\n        long aValue2 = aAtomic.get();\r\n        LOG.info(\"aKey-value2[{}]\", aValue2);\r\n\r\n        LOG.info(\"---------------------------------------------------------\");\r\n\r\n        String bKey = \"bKey\";\r\n        RAtomicLong bAtomic = redissonClient.getAtomicLong(bKey);\r\n        long bValue0 = bAtomic.get();\r\n        LOG.info(\"bKey-value0[{}]\", bValue0);\r\n\r\n        bAtomic.incrementAndGet();\r\n        bAtomic.expire(10, TimeUnit.HOURS);\r\n\r\n        long bValue1 = bAtomic.get();\r\n        LOG.info(\"bKey-value1[{}]\", bValue1);\r\n\r\n        LOG.info(\"---------------------------------------------------------\");\r\n\r\n        String cKey = \"cKey\";\r\n        RAtomicLong cAtomic = redissonClient.getAtomicLong(cKey);\r\n        long cValue0 = cAtomic.get();\r\n        LOG.info(\"cKey-value0[{}]\", cValue0);\r\n\r\n        cAtomic.incrementAndGet();\r\n\r\n        long cValue1 = cAtomic.get();\r\n        LOG.info(\"cKey-value1[{}]\", cValue1);\r\n\r\n        redissonClient.shutdown();\r\n```\r\nlog...\r\n```\r\n15:45:35.913 [main] INFO org.redisson.Version - Redisson 3.15.0\r\n15:45:36.804 [redisson-netty-2-17] INFO org.redisson.connection.pool.MasterPubSubConnectionPool - 1 connections initialized for /127.0.0.1:6379\r\n15:45:36.817 [redisson-netty-2-17] INFO org.redisson.connection.pool.MasterConnectionPool - 24 connections initialized for /127.0.0.1:6379\r\n15:45:36.877 [main] INFO RedissonClient - aKey-value0[0]\r\n15:45:36.880 [main] INFO RedissonClient - aKey-value1[1]\r\n15:45:36.881 [main] INFO RedissonClient - aKey-value2[0]\r\n15:45:36.881 [main] INFO RedissonClient - ---------------------------------------------------------\r\n15:45:36.882 [main] INFO RedissonClient - bKey-value0[0]\r\n15:45:36.886 [main] INFO RedissonClient - bKey-value1[1]\r\n15:45:36.887 [main] INFO RedissonClient - ---------------------------------------------------------\r\n15:45:36.887 [main] INFO RedissonClient - cKey-value0[0]\r\n15:45:36.889 [main] INFO RedissonClient - cKey-value1[1]\r\n```\r\n"
    },
    "satisfaction_conditions": [
      "Key must remain accessible until expiration time"
    ],
    "created_at": "2021-02-03T07:55:21Z"
  },
  {
    "id": "https://github.com/redisson/redisson/issues/3390",
    "source": {
      "issue_number": 3390
    },
    "initial_question": {
      "title": "RBatch response order with cluster env ?",
      "body": "> In cluster environment batch executed in map\\reduce way. It aggregates commands for each node and sends them simultaneously, then result got from each node added to common result list.\r\n\r\n```\r\n\r\n    /**\r\n     * Executes all operations accumulated during async methods invocations.\r\n     * <p>\r\n     * If cluster configuration used then operations are grouped by slot ids\r\n     * and may be executed on different servers. Thus command execution order could be changed\r\n     *\r\n     * @return List with result object for each command\r\n     * @throws RedisException in case of any error\r\n     *\r\n     */\r\n    BatchResult<?> execute() throws RedisException;\r\n```\r\n\r\nRead above tips, I was not sure about responses order for origin commands.\r\nCould you help me make sure about this?\r\n\r\n1.When commands send group by slots, but I want know responses order is right with original commands?\r\n\r\n\r\nthx~ "
    },
    "satisfaction_conditions": [
      "Results must be retrievable for all executed commands",
      "Response mapping must be deterministic",
      "Batch execution must handle distributed processing",
      "Results must be accessible individually"
    ],
    "created_at": "2021-01-28T16:31:38Z"
  },
  {
    "id": "https://github.com/redisson/redisson/issues/3374",
    "source": {
      "issue_number": 3374
    },
    "initial_question": {
      "title": "time_to_live and max_idle_time doesn't work in redisson as 2 level cache in hibernate",
      "body": "Hello everybody,\r\nI try to use Redisson  as second level cache in my jpa spring boot application it works fine i see that it cache entities in redis it just i need to set a time to live and time to idle on cache entries i use this configuration below but it doesn't work:\r\n\r\n`spring.jpa.properties.hibernate.cache.use_second_level_cache=true\r\nspring.cache.type=redis\r\n\r\nhibernate.cache.redisson.entity.expiration.time_to_live=1000\r\nhibernate.cache.redisson.entity.expiration.max_idle_time=1000\r\nhibernate.cache.redisson.collection.expiration.time_to_live=1000\r\nhibernate.cache.redisson.collection.expiration.max_idle_time=1000\r\n\r\nspring.jpa.properties.hibernate.cache.region.factory_class=org.redisson.hibernate.RedissonRegionFactory\r\nspring.jpa.properties.hibernate.cache.redisson.config=redisson/redisson-dev.yaml\r\nspring.jpa.properties.hibernate.cache.redisson.fallback=true\r\nspring.jpa.properties.javax.persistence.sharedCache.mode=ENABLE_SELECTIVE\r\n\r\nserver.port=8888\r\nspring.datasource.url=jdbc:h2:mem:testdb\r\nspring.datasource.driverClassName=org.h2.Driver\r\nspring.datasource.username=sa\r\nspring.datasource.password=\r\n\r\nspring.jpa.database-plateform=org.hibernate.dialect.H2Dialect\r\nspring.jpa.hibernate.ddl-auto=update\r\nspring.h2.console.enabled=true\r\nlogging.level.org.hibernate.SQL=DEBUG\r\nlogging.level.org.hibernate.type=TRACE\r\n`\r\n\r\ni use  redisson-hibernate-53  as dependancy\r\n\r\nAny help on this will help ,thank you.\r\n  \r\n\r\n\r\n"
    },
    "satisfaction_conditions": [
      "Cache expiration settings are properly recognized by the application",
      "Configuration properties follow the correct Spring Boot property naming convention",
      "Both entity and collection cache expiration settings are configurable",
      "Second-level cache remains functional while applying expiration settings"
    ],
    "created_at": "2021-01-22T10:31:32Z"
  },
  {
    "id": "https://github.com/redisson/redisson/issues/3108",
    "source": {
      "issue_number": 3108
    },
    "initial_question": {
      "title": "RMap's values(pattern) doesn't seem to work on a simple test",
      "body": "The following simple test doesn't seem to work:\r\n```@Test\r\n    public void test() {\r\n\r\n        String mapName = UUID.randomUUID().toString();\r\n        RMap<String, String> map = redissonClient.getMap(mapName, JsonJacksonCodec.INSTANCE);\r\n\r\n        try {\r\n            map.put(\"prefix_1_1_\", \"1\");\r\n            map.put(\"prefix_1_2_\", \"2\");\r\n            map.put(\"prefix_2_3_\", \"3\");\r\n            map.put(\"prefix_2_4_\", \"4\");\r\n\r\n            Collection<String> entries = map.values(\"prefix*\");\r\n\r\n            assertThat(entries).hasSize(4);\r\n        } finally {\r\n            redissonClient.getMap(mapName).delete();\r\n        }\r\n    }\r\n```\r\nVersion of redisson is 3.13.4\r\nI'm pretty sure I'm missing something here so didn't post it as a bug"
    },
    "satisfaction_conditions": [
      "Map keys must be properly encoded for pattern matching",
      "Values must maintain their JSON serialization capability"
    ],
    "created_at": "2020-10-07T13:18:25Z"
  },
  {
    "id": "https://github.com/redisson/redisson/issues/2897",
    "source": {
      "issue_number": 2897
    },
    "initial_question": {
      "title": "Strange characters on value when read data in other language",
      "body": "Hey there!\r\n\r\nI was wondering if it's possible to perform a simple operation like we do on Redis StackExchange (c#) client:\r\n\r\n```\r\nIDatabase db = redis.GetDatabase();\r\nstring value = \"abcdefg\";\r\nvar expires = 1000;\r\ndb.StringSet(\"mykey\", value, expires);\r\n...\r\nstring value = db.StringGet(\"mykey\");\r\nConsole.WriteLine(value); // writes: \"abcdefg\r\n```\r\n\r\nRight now I'm using a Map but I would like to make it simple as this example on C#. \r\n\r\n```\r\n    override fun put(collection: String, key: String, value: String, expiresInSeconds: Long) {\r\n        logger.info(\"Storing key $key into collection $collection\")\r\n        val cacheMap = getMapCache(collection)\r\n\r\n        cacheMap.put(key, value, 3600, TimeUnit.SECONDS)\r\n    }\r\n\r\n    private fun getMapCache(collection: String) = redissonClient.getMapCache<String, String>(\"any\", StringCodec())\r\n```\r\n\r\nWhen I try to retrieve values fro other clients like C# or Python, I got some strange characters on value like `????????\ufffd\u0003??????myvalue`.\r\n\r\nIs there any option to clear/remove those characters on Redisson and store it as plain string?\r\n\r\nIs there any option to store it simple as we do in C#?"
    },
    "satisfaction_conditions": [
      "Data stored must be readable across different programming language clients without character encoding issues",
      "Storage operation must support key-value pairs with expiration time",
      "Retrieved string values must match exactly what was stored",
      "Storage implementation must use appropriate character encoding codec"
    ],
    "created_at": "2020-07-06T18:45:50Z"
  },
  {
    "id": "https://github.com/redisson/redisson/issues/2888",
    "source": {
      "issue_number": 2888
    },
    "initial_question": {
      "title": "Set Redisson config using AWS ElastiCache as Clustered Mode",
      "body": "Hey there!\r\n\r\nWhat is the proper way to configure Redisson when you have a AWS ElastiCache Redis running as Clustered Mode? I have tried to set using it as follows:\r\n\r\n```\r\n    val nodeAddress = \"redis://test-rest-encryption-0001-001.p0vefj.0001.use1.cache.amazonaws.com:6379\" \r\n    val config = Config()\r\n    val configCluster = config.useClusterServers().addNodeAddress(nodeAddress)\r\n    val client = Redisson.create(config)\r\n```\r\n\r\nNode endpoint: test-rest-encryption-0001-001.p0vefj.0001.use1.cache.amazonaws.com\r\nConfiguration endpoint: test-rest-encryption.p0vefj.clustercfg.use1.cache.amazonaws.com\r\n\r\nFor `nodeAddress`, I have tried to use configuration endpoint and node endpoint but fails in both case (connection timed out):\r\n\r\n```\r\n21:04:39.542 [main] WARN  o.r.cluster.ClusterConnectionManager - connection timed out: test-rest-encryption-0001-001.p0vefj.0001.use1.cache.amazonaws.com/172.31.19.41:6379\r\nException in thread \"main\" org.redisson.client.RedisConnectionException: Can't connect to servers!\r\n\tat org.redisson.cluster.ClusterConnectionManager.<init>(ClusterConnectionManager.java:144)\r\n\tat org.redisson.config.ConfigSupport.createConnectionManager(ConfigSupport.java:237)\r\n\tat org.redisson.Redisson.<init>(Redisson.java:117)\r\n\tat org.redisson.Redisson.create(Redisson.java:156)\r\n\tat aus.web.SessionManagerApplicationKt.main(SessionManagerApplication.kt:23)\r\nCaused by: io.netty.channel.ConnectTimeoutException: connection timed out: test-rest-encryption-0001-001.p0vefj.0001.use1.cache.amazonaws.com/172.31.19.41:6379\r\n\tat io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe$1.run(AbstractNioChannel.java:261)\r\n\tat io.netty.util.concurrent.PromiseTask.runTask(PromiseTask.java:98)\r\n\tat io.netty.util.concurrent.ScheduledFutureTask.run(ScheduledFutureTask.java:170)\r\n\tat io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:164)\r\n\tat io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:472)\r\n\tat io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:500)\r\n\tat io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:989)\r\n\tat io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)\r\n\tat io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)\r\n\tat java.base/java.lang.Thread.run(Thread.java:834)\r\n```\r\n\r\nAm I missing something?\r\n\r\n"
    },
    "satisfaction_conditions": [
      "Support for encryption in transit when enabled"
    ],
    "created_at": "2020-07-02T23:45:55Z"
  },
  {
    "id": "https://github.com/redisson/redisson/issues/2842",
    "source": {
      "issue_number": 2842
    },
    "initial_question": {
      "title": "How to retrieve DelayedQueue by name using getDelayedQueue",
      "body": "Want to understand how to retrieve delayed queue (RDelayedQueue) by name using getDelayedQueue method on org.redisson.api.RedissonClient. \r\n\r\nDoes it require to call redissonClient.getDelayedQueue(destinationQueue) every time before queuing a message as below or retrieve queue once and use it for every message queuing ?\r\n\r\nRDelayedQueue..offer(message, delayInMillisFromCurrent, TimeUnit.MILLISECONDS);"
    },
    "satisfaction_conditions": [
      "RDelayedQueue instance remains functional across multiple message operations",
      "Queue remains identifiable by its assigned name"
    ],
    "created_at": "2020-06-17T02:39:53Z"
  },
  {
    "id": "https://github.com/redisson/redisson/issues/2782",
    "source": {
      "issue_number": 2782
    },
    "initial_question": {
      "title": "How to configure scheduling times? ",
      "body": "When using the periodic scheduling method\uff08e.g. RScheduledExecutorService.scheduleAtFixedRate\uff09, I want to stop scheduling after a specified number of times. What should I do?\r\nThanks!"
    },
    "satisfaction_conditions": [
      "Task execution must stop after reaching a specified count",
      "Task execution count must be tracked accurately across runs",
      "Task must be able to cancel itself",
      "Task must continue normal periodic execution until count is reached"
    ],
    "created_at": "2020-05-19T03:56:55Z"
  },
  {
    "id": "https://github.com/redisson/redisson/issues/2613",
    "source": {
      "issue_number": 2613
    },
    "initial_question": {
      "title": "In a frequent job , sometime lock.tryLock() can not get lock",
      "body": "\t\t<dependency>\r\n\t\t\t<groupId>org.redisson</groupId>\r\n\t\t\t<artifactId>redisson-spring-boot-starter</artifactId>\r\n\t\t\t<version>2.15.2</version>\r\n\t\t</dependency>\r\nIn a spring boot 1.5.6 application , We have a new job which is running every 30 seconds and try to acquire lock to do something . In recent days the job has tried to acquire one specific lock cause of business , We found from 00:13 on Feb 24  the job can not get the lock but after 15:03 the job can get the lock again . The operation on this lock only in this job . \r\nthe code on the lock as below :\r\n\r\n        boolean res = lock.tryLock();\r\n        if (res) {\r\n            try {\r\n                ...\r\n            } finally {\r\n                if (lock.isHeldByCurrentThread())\r\n                    lock.unlock();\r\n            }\r\n        } else {\r\n            LockUtils.logLockError(lockName, amount, null, \"consume balance\");\r\n            msg = String.format(\"acquire merchant account lock (%s)failed\", lockName);\r\n        }\r\n\r\nThanks\r\n\r\n\r\n\r\n\r\n "
    },
    "satisfaction_conditions": [
      "Lock release must occur in the same thread that acquired it",
      "System must provide visibility into lock ownership and state"
    ],
    "created_at": "2020-02-25T15:10:58Z"
  },
  {
    "id": "https://github.com/redisson/redisson/issues/2576",
    "source": {
      "issue_number": 2576
    },
    "initial_question": {
      "title": "How to know if RedissonMap is created at redis end ",
      "body": "Is there a way to know if a map with given name is created at redis end. As per understanding, org.redisson.api.RedissonClient.getMap(java.lang.String name) always gives new RedissonMap and only creates interacts with redis when one does any map operations like get/put. \r\nWhich means Using org.redisson.api.RedissonClient.getMap(java.lang.String name) will not send any request to redis ?\r\nSo how can i know that if a map with given name already exists at redis end using any of the redisson apis? "
    },
    "satisfaction_conditions": [
      "Must be able to verify map existence at Redis server level",
      "Must handle stateless nature of RedissonMap",
      "Must provide synchronous verification capability"
    ],
    "created_at": "2020-02-07T09:29:53Z"
  },
  {
    "id": "https://github.com/redisson/redisson/issues/2538",
    "source": {
      "issue_number": 2538
    },
    "initial_question": {
      "title": "\u6570\u636e\u7c7b\u578b\u95ee\u9898",
      "body": "\u6211\u7528spring\u4e2d\u7684@cacheable\u65f6\uff0c\u4ece\u6570\u636e\u5e93\u4e2d\u53d6\u51fa\u6765\u51c6\u5907\u5e8f\u5217\u5316\u5b58\u5230redis\u4e2d\u7684\u6570\u636e\u662fByte\u7c7b\u578b\uff0c\u4f46\u662f\u518d\u4eceredis\u4e2d\u67e5\u51fa\u6765\u8fd4\u56de\u7684\u5374\u662fInteger\uff0c\u8fd9\u4e2a\u662f\u9700\u8981\u4fee\u6539redisson\u7684\u6570\u636e\u5e8f\u5217\u5316\u65b9\u5f0f\u5417\uff1f\u6211\u8bd5\u4e86\u4e00\u4e0b\u5305\u88c5\u7c7bShort\u3001Byte\u90fd\u4f1a\u53d8\u6210Integer\uff0cCharacter\u4f1a\u53d8\u6210String\uff0cFloat\u4f1a\u53d8\u6210Double\u3002"
    },
    "satisfaction_conditions": [
      "Codec configuration must be compatible with Spring Cache abstraction"
    ],
    "created_at": "2020-01-13T07:40:33Z"
  },
  {
    "id": "https://github.com/redisson/redisson/issues/2488",
    "source": {
      "issue_number": 2488
    },
    "initial_question": {
      "title": "java.lang.ClassNotFoundException: org.springframework.data.redis.connection.RedisStreamCommands ",
      "body": "Hello \r\n         I just submitted two questions that didn't work. The reason is that I pressed the wrong key(ctrl + enter on windows). I'm sorry to be embarrassed. My problem is that I use springboot version 2.1.11.RELEASE and the redisson-spring-boot-starter version is 3.11.  .6, the error is the same as the title. I checked issue 2478 and suggested that he downgrade to redisson-spring-data-21. If it is redisson-spring-boot-starter, what version should he downgrade to?"
    },
    "satisfaction_conditions": [
      "Redis-related class dependencies must be compatible with Spring Boot version",
      "All Spring Data Redis dependencies must be version-compatible with each other"
    ],
    "created_at": "2019-12-18T02:04:35Z"
  },
  {
    "id": "https://github.com/redisson/redisson/issues/1706",
    "source": {
      "issue_number": 1706
    },
    "initial_question": {
      "title": "What is the best practice for setting local caches ttl against Redis caches?",
      "body": "Is it correct if Redis cache ttl is the same as timeToLiveInMillis for local cache?\r\n\r\nMY_CACHE: \r\n ttl: 300000\r\n maxIdleTime: 300000\r\n maxSize: 1000\r\n \r\n localCacheOptions:\r\n    evictionPolicy: \"LRU\"\r\n    reconnectionStrategy: \"CLEAR\"\r\n    syncStrategy: \"INVALIDATE\"\r\n    writeMode: \"WRITE_THROUGH\"\r\n    cacheSize: 1000\r\n    timeToLiveInMillis: 300000\r\n    maxIdleInMillis: 300000"
    },
    "satisfaction_conditions": [
      "Cache configuration must maintain data consistency between local and Redis caches",
      "Cache eviction policies must be properly defined for both local and Redis caches",
      "Synchronization strategy between local and Redis caches must be specified",
      "Write operations must have a clearly defined behavior for cache updates"
    ],
    "created_at": "2018-10-30T07:35:33Z"
  },
  {
    "id": "https://github.com/redisson/redisson/issues/1687",
    "source": {
      "issue_number": 1687
    },
    "initial_question": {
      "title": "Default values for local cache in RedissonSpringLocalCachedCacheManager",
      "body": "What are default values for the mentioned below properties?\r\nAre these values from LocalCachedMapOptions::defaults()?\r\nI see that local caches work, but only ttl, idle and maxSize are defined.\r\n```\r\n localCacheOptions:\r\n    evictionPolicy: \"LRU\"\r\n    reconnectionStrategy: \"CLEAR\"\r\n    syncStrategy: \"UPDATE\"\r\n    writeMode: \"WRITE_THROUGH\"\r\n    cacheSize: 1000\r\n    timeToLiveInMillis: 300000\r\n    maxIdleInMillis: 300000\r\n```"
    },
    "satisfaction_conditions": [
      "All default cache configuration values must be accurately identified",
      "The source of default values must be clearly indicated",
      "All properties from the original configuration must be addressed",
      "Values must reflect the actual initial state before any custom configuration"
    ],
    "created_at": "2018-10-23T14:46:37Z"
  }
]