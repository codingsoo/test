[
  {
    "id": "https://github.com/google/ExoPlayer/issues/11212",
    "source": {
      "issue_number": 11212
    },
    "initial_question": {
      "title": "Skip ads while fast forwarding/ Remove first pre roll ads in resumed content.",
      "body": "hi,\r\nIs there any way that pre-roll ads can be removed in the condition when the user is resuming the content from the continue watching row?\r\nAlso, need to skip the ad when the user if fast forwarding. Is there any way to achieve this."
    },
    "satisfaction_conditions": [
      "Ad playback behavior must be consistent with IMA extension limitations",
      "Seeking behavior during ad playback must be restricted",
      "Ad playback must occur when seeking across cue points",
      "Skippable ads must respect minimum viewing duration"
    ],
    "created_at": "2023-06-15T07:40:17Z"
  },
  {
    "id": "https://github.com/google/ExoPlayer/issues/10946",
    "source": {
      "issue_number": 10946
    },
    "initial_question": {
      "title": "RtspMediaSource with not available RTSP stream will block whole ExoPlayer",
      "body": "Hello,\r\nI try to implement a player which mixes local video files in playlist with public RTSP streams for my project.\r\nI found that if RTSP Server is not accesible (dead) - Exoplayer will lock whole play thread even at playing an earlier local MP4 file in playlist.\r\n\r\nIt will finally, after about 2 minutes, fire ExoPlaybackException\r\n\r\nI cannot find a timeout option to setup.\r\n```\r\nvar mediaSourceRTSP =\r\n    RtspMediaSource.Factory()\r\n        .setForceUseRtpTcp(true)\r\n        .setTimeoutMs(3000)\r\n        .createMediaSource(newMediaItem)\r\n```\r\n\r\nAnd the Exception which fires about 2 minutes later:\r\n\r\n```\r\nE/ExoPlayerImplInternal: Playback error\r\n      com.google.android.exoplayer2.ExoPlaybackException: Source error\r\n        at com.google.android.exoplayer2.ExoPlayerImplInternal.handleIoException(ExoPlayerImplInternal.java:637)\r\n        at com.google.android.exoplayer2.ExoPlayerImplInternal.handleMessage(ExoPlayerImplInternal.java:613)\r\n        at android.os.Handler.dispatchMessage(Handler.java:102)\r\n        at android.os.Looper.loop(Looper.java:223)\r\n        at android.os.HandlerThread.run(HandlerThread.java:67)\r\n     Caused by: java.net.ConnectException: failed to connect to /11.201.0.110 (port 11035) from /:: (port 58066): connect failed: ETIMEDOUT (Connection timed out)\r\n        at libcore.io.IoBridge.connect(IoBridge.java:142)\r\n        at java.net.PlainSocketImpl.socketConnect(PlainSocketImpl.java:142)\r\n        at java.net.AbstractPlainSocketImpl.doConnect(AbstractPlainSocketImpl.java:390)\r\n        at java.net.AbstractPlainSocketImpl.connectToAddress(AbstractPlainSocketImpl.java:230)\r\n        at java.net.AbstractPlainSocketImpl.connect(AbstractPlainSocketImpl.java:212)\r\n        at java.net.SocksSocketImpl.connect(SocksSocketImpl.java:436)\r\n        at java.net.Socket.connect(Socket.java:621)\r\n        at java.net.Socket.connect(Socket.java:570)\r\n        at java.net.Socket.<init>(Socket.java:450)\r\n        at java.net.Socket.<init>(Socket.java:218)\r\n        at javax.net.DefaultSocketFactory.createSocket(SocketFactory.java:279)\r\n        at com.google.android.exoplayer2.source.rtsp.RtspClient.getSocket(RtspClient.java:304)\r\n        at com.google.android.exoplayer2.source.rtsp.RtspClient.start(RtspClient.java:198)\r\n        at com.google.android.exoplayer2.source.rtsp.RtspMediaPeriod.prepare(RtspMediaPeriod.java:158)\r\n        at com.google.android.exoplayer2.source.MaskingMediaPeriod.prepare(MaskingMediaPeriod.java:145)\r\n        at com.google.android.exoplayer2.source.MaskingMediaPeriod.prepare(MaskingMediaPeriod.java:145)\r\n        at com.google.android.exoplayer2.ExoPlayerImplInternal.maybeUpdateLoadingPeriod(ExoPlayerImplInternal.java:1981)\r\n        at com.google.android.exoplayer2.ExoPlayerImplInternal.updatePeriods(ExoPlayerImplInternal.java:1961)\r\n        at com.google.android.exoplayer2.ExoPlayerImplInternal.doSomeWork(ExoPlayerImplInternal.java:961)\r\n        at com.google.android.exoplayer2.ExoPlayerImplInternal.handleMessage(ExoPlayerImplInternal.java:495)\r\n        at android.os.Handler.dispatchMessage(Handler.java:102)\u00a0\r\n        at android.os.Looper.loop(Looper.java:223)\u00a0\r\n        at android.os.HandlerThread.run(HandlerThread.java:67)\u00a0\r\n     Caused by: android.system.ErrnoException: connect failed: ETIMEDOUT (Connection timed out)\r\n        at libcore.io.Linux.connect(Native Method)\r\n        at libcore.io.ForwardingOs.connect(ForwardingOs.java:94)\r\n        at libcore.io.BlockGuardOs.connect(BlockGuardOs.java:138)\r\n        at libcore.io.ForwardingOs.connect(ForwardingOs.java:94)\r\n        at libcore.io.IoBridge.connectErrno(IoBridge.java:156)\r\n        at libcore.io.IoBridge.connect(IoBridge.java:134)\r\n        at java.net.PlainSocketImpl.socketConnect(PlainSocketImpl.java:142)\u00a0\r\n        at java.net.AbstractPlainSocketImpl.doConnect(AbstractPlainSocketImpl.java:390)\u00a0\r\n        at java.net.AbstractPlainSocketImpl.connectToAddress(AbstractPlainSocketImpl.java:230)\u00a0\r\n        at java.net.AbstractPlainSocketImpl.connect(AbstractPlainSocketImpl.java:212)\u00a0\r\n        at java.net.SocksSocketImpl.connect(SocksSocketImpl.java:436)\u00a0\r\n        at java.net.Socket.connect(Socket.java:621)\u00a0\r\n        at java.net.Socket.connect(Socket.java:570)\u00a0\r\n        at java.net.Socket.<init>(Socket.java:450)\u00a0\r\n        at java.net.Socket.<init>(Socket.java:218)\u00a0\r\n        at javax.net.DefaultSocketFactory.createSocket(SocketFactory.java:279)\u00a0\r\n        at com.google.android.exoplayer2.source.rtsp.RtspClient.getSocket(RtspClient.java:304)\u00a0\r\n        at com.google.android.exoplayer2.source.rtsp.RtspClient.start(RtspClient.java:198)\u00a0\r\n        at com.google.android.exoplayer2.source.rtsp.RtspMediaPeriod.prepare(RtspMediaPeriod.java:158)\u00a0\r\n        at com.google.android.exoplayer2.source.MaskingMediaPeriod.prepare(MaskingMediaPeriod.java:145)\u00a0\r\n        at com.google.android.exoplayer2.source.MaskingMediaPeriod.prepare(MaskingMediaPeriod.java:145)\u00a0\r\n        at com.google.android.exoplayer2.ExoPlayerImplInternal.maybeUpdateLoadingPeriod(ExoPlayerImplInternal.java:1981)\u00a0\r\n        at com.google.android.exoplayer2.ExoPlayerImplInternal.updatePeriods(ExoPlayerImplInternal.java:1961)\u00a0\r\n        at com.google.android.exoplayer2.ExoPlayerImplInternal.doSomeWork(ExoPlayerImplInternal.java:961)\u00a0\r\n        at com.google.android.exoplayer2.ExoPlayerImplInternal.handleMessage(ExoPlayerImplInternal.java:495)\u00a0\r\n        at android.os.Handler.dispatchMessage(Handler.java:102)\u00a0\r\n        at android.os.Looper.loop(Looper.java:223)\u00a0\r\n        at android.os.HandlerThread.run(HandlerThread.java:67)\u00a0\r\n```"
    },
    "satisfaction_conditions": [
      "RTSP connection attempts must timeout within a user-configurable period",
      "Player must remain responsive when RTSP stream is unavailable",
      "Connection failures must be properly surfaced as errors"
    ],
    "created_at": "2023-01-26T14:49:34Z"
  },
  {
    "id": "https://github.com/google/ExoPlayer/issues/10897",
    "source": {
      "issue_number": 10897
    },
    "initial_question": {
      "title": "Identify onPlaybackStatsReady callbacks for Ads playback",
      "body": "As mentioned in docs for `PlaybackStatsListener`, `onPlaybackStatsReady` callback is called separately for main playback item and all of the inserted ads (e.g. pre-roll ads). Since `PlaybackStats` for ad playbacks are not important for me, I only want to log stats for the main media item. Is there a way to identify the type of media item for which the  `PlaybackStats` is prepared?"
    },
    "satisfaction_conditions": [
      "Must distinguish between main content and ad playback stats",
      "Must work with the PlaybackStatsListener interface",
      "Must be able to access this information during the onPlaybackStatsReady callback",
      "Must handle pre-roll and other inserted ad scenarios"
    ],
    "created_at": "2023-01-02T13:18:42Z"
  },
  {
    "id": "https://github.com/google/ExoPlayer/issues/10896",
    "source": {
      "issue_number": 10896
    },
    "initial_question": {
      "title": "How to signal that the activation status of an `AudioProcessor` has changed?",
      "body": "As an optimization, I try to avoid \"no-op\" scenarios that would require an expensive copy in my `AudioProcessor` by overriding `isActive` and returning `false` if the `AudioProcessor` has nothing to do. The issue is that the activation status can change during playback, and I've recently realized that ExoPlayer is highly inconsistent in when it checks if the `AudioProcessor` is active. \r\n\r\nFor example, if the `AudioProcessor` was *active*, then became *inactive*, and then became *active* again, ExoPlayer picks up on it immediately. However, if the `AudioProcessor` starts *inactive* and then becomes *active*, ExoPlayer does not pick up on it until the next `MediaItem` plays. This results in really in-explicable issues in my app.\r\n\r\nIs there a way to signal ExoPlayer to always re-check my `AudioProcessor` when it's activation status changes? There should be some way to do it given that `SonicAudioProcessor` could feasibly change it's activation status during playback too. Without this, I'm stuck either with this inconsistent behavior or removing the `isActive` optimization entirely and doing a copy when there's nothing to do, neither of which are desirable in any capacity.\r\n\r\nAny help here would be appreciated."
    },
    "satisfaction_conditions": [
      "Solution must maintain correct audio format consistency throughout the processing chain",
      "Performance impact must be acceptable for audio processing",
      "Audio processor chain integrity must be maintained"
    ],
    "created_at": "2023-01-01T17:56:21Z"
  },
  {
    "id": "https://github.com/google/ExoPlayer/issues/10834",
    "source": {
      "issue_number": 10834
    },
    "initial_question": {
      "title": "SimplePool for Exoplayer",
      "body": "Describe your question in detail:\r\n\r\nHello, my application use extensively Exoplayer and I wanted to make some improvement for my users ( ~440 000 users with phone from API 21 to API 26).\r\n\r\nFor context my app is just like Youtube, so users browse between pages which result in an ever-ending cycle of:\r\n1. creating Exoplayer\r\n2. setting mediaSource + listeners\r\n3. playing/pausing\r\n4. removing listener + releasing Exoplayer\r\n\r\nI was wondering if creating/releasing player is more resource-consuming than creating a Pool with 2 instances of Exoplayer? What's your opinion about using a `SimplePool<Exoplayer>(2)` ?\r\n"
    },
    "satisfaction_conditions": [
      "Player instance management optimizes resource usage for sequential video playback",
      "Only one video playback instance is active at any given time",
      "Player state persists across fragment transitions",
      "Memory footprint remains optimized for mobile devices"
    ],
    "created_at": "2022-12-05T15:56:40Z"
  },
  {
    "id": "https://github.com/google/ExoPlayer/issues/10543",
    "source": {
      "issue_number": 10543
    },
    "initial_question": {
      "title": "Intercepting notification events",
      "body": "I would like to intercept the notification events, so I can implement custom functionality when they are fired. Currently, they are being handled in this `NotificationBroadcastReceiver`:\r\n\r\n```java\r\n @Override\r\n    public void onReceive(Context context, Intent intent) {\r\n      Player player = PlayerNotificationManager.this.player;\r\n      if (player == null\r\n          || !isNotificationStarted\r\n          || intent.getIntExtra(EXTRA_INSTANCE_ID, instanceId) != instanceId) {\r\n        return;\r\n      }\r\n      String action = intent.getAction();\r\n      if (ACTION_PLAY.equals(action)) {\r\n        if (player.getPlaybackState() == Player.STATE_IDLE) {\r\n          player.prepare();\r\n        } else if (player.getPlaybackState() == Player.STATE_ENDED) {\r\n          player.seekToDefaultPosition(player.getCurrentMediaItemIndex());\r\n        }\r\n        player.play();\r\n      } else if (ACTION_PAUSE.equals(action)) {\r\n        player.pause();\r\n      } else if (ACTION_PREVIOUS.equals(action)) {\r\n        player.seekToPrevious();\r\n      } else if (ACTION_REWIND.equals(action)) {\r\n        player.seekBack();\r\n      } else if (ACTION_FAST_FORWARD.equals(action)) {\r\n        player.seekForward();\r\n      } else if (ACTION_NEXT.equals(action)) {\r\n        player.seekToNext();\r\n      } else if (ACTION_STOP.equals(action)) {\r\n        player.stop(/* reset= */ true);\r\n      } else if (ACTION_DISMISS.equals(action)) {\r\n        stopNotification(/* dismissedByUser= */ true);\r\n      } else if (action != null\r\n          && customActionReceiver != null\r\n          && customActions.containsKey(action)) {\r\n        customActionReceiver.onCustomAction(player, action, intent);\r\n      }\r\n    }\r\n```\r\n\r\nSadly, I can't replace the receiver with my own, since it's private:\r\n\r\n`  private final NotificationBroadcastReceiver notificationBroadcastReceiver;`\r\n\r\nI was thinking of maybe overriding `getActions` and `getActionIndicesForCompactView` and make my own custom actions, but the original actions are used in so many cases in functions that are not overridable that I don't think it's possible to mimic when they are called. \r\n\r\nMy final solution is to just make my own notification manager from scratch, but I hope it doesn't come to that.\r\n\r\nIs there a way that I haven't found to intercept those events?"
    },
    "satisfaction_conditions": [
      "Notification action events must be interceptable by custom code",
      "Original player functionality must remain intact",
      "Solution must work with private NotificationBroadcastReceiver"
    ],
    "created_at": "2022-08-22T18:02:13Z"
  },
  {
    "id": "https://github.com/google/ExoPlayer/issues/10533",
    "source": {
      "issue_number": 10533
    },
    "initial_question": {
      "title": "Do not Deprecate Player.Listener.onPlayerStateChanged()",
      "body": "### [REQUIRED] Use case description\r\n\r\nI need to listen for a state where the video is playing. The only way to do that right now is using `Player.Listener.onPlayerStateChanged()`.\r\n\r\n```\r\nexoPlayer.addListener(object : Player.Listener {\r\n            override fun onPlayerStateChanged(playWhenReady: Boolean, playbackState: Int) {\r\n                if (playWhenReady && playbackState == ExoPlayer.STATE_READY) {\r\n                    // The video is playing\r\n                }\r\n            }\r\n        })\r\n```\r\n\r\nHowever, this method is marked as deprecated. `onPlaybackStateChanged(int)` and `onPlayWhenReadyChanged(boolean, int)` are being recommended. However, none of them provides the state that the video is actually playing.\r\n\r\n`onPlaybackStateChanged()` could means it's still loading and `onPlayWhenReadyChanged` could means it's loaded but still paused.\r\n\r\n\r\n\r\n### Proposed solution\r\nWe should un-deprecate `onPlayerStateChanged`\r\n\r\n\r\n\r\n### Alternatives considered\r\nOr adde a new state: `STATE_PLAYING`\r\n"
    },
    "satisfaction_conditions": [
      "Must provide a reliable way to detect when video is actively playing",
      "Must distinguish between ready-to-play and actually-playing states",
      "Must maintain backward compatibility with existing ExoPlayer functionality",
      "Must provide state information through the listener pattern"
    ],
    "created_at": "2022-08-17T16:56:36Z"
  },
  {
    "id": "https://github.com/google/ExoPlayer/issues/10529",
    "source": {
      "issue_number": 10529
    },
    "initial_question": {
      "title": "is there any difference between addMediasource and setMediasource method as in case of setMediaSource method we always need to call player.prepare method? will it affect start time of video?",
      "body": null
    },
    "satisfaction_conditions": [
      "Functional distinction between playlist operations is clearly explained",
      "Player preparation state requirements are specified",
      "Playlist continuation behavior is addressed",
      "Method behavior with respect to player state is explained"
    ],
    "created_at": "2022-08-16T13:31:44Z"
  },
  {
    "id": "https://github.com/google/ExoPlayer/issues/10452",
    "source": {
      "issue_number": 10452
    },
    "initial_question": {
      "title": "How to configure forward and rewind time values for player notification manager?",
      "body": "By default rewind button in the notification seeking player time by 5 seconds but forward button seeking player by 15 seconds. Can't find any direct functions in the player notification manager javadoc."
    },
    "satisfaction_conditions": [
      "Player's seek forward and rewind time intervals must be configurable",
      "Seek controls must function through the notification interface",
      "Seek behavior must be controllable specifically for notification interactions"
    ],
    "created_at": "2022-07-19T09:31:41Z"
  },
  {
    "id": "https://github.com/google/ExoPlayer/issues/10396",
    "source": {
      "issue_number": 10396
    },
    "initial_question": {
      "title": "Intercepting DAI stream URL using the ExoPlayer IMA extension",
      "body": "Hi, \r\n\r\nwe are currently trying out the ExoPlayer IMA extension for IMA server side inserted ad streams in our android app, by using `ImaServerSideAdInsertionMediaSource`. We encountered the following problem and would like to ask you how to best handle it.\r\n\r\nWe have been using the trick to have a placeholder @TOKEN@ configured in ad manager and replace it in our client with the proper auth token. The hook to do this seems to be missing from the IMA extension.\r\nWith a previous IMA SDK integration, the IMA SDK functionality was implemented by our client app, resolving the media URL dynamically in order to get the stitched stream. This allowed us to manipulate the loaded media URL of the stitched stream (via `VideoStreamPlayer.loadUrl(...` callback), so we could replace a stream token placeholder for authorisation, before passing the stitched stream url to the player. \r\n\r\nBy using `ImaServerSideAdInsertionMediaSource`, the stitched stream URL seems to be passed to the player internally, and we were not yet able to find any way to intercept this stitched stream media URL over the new IMA extension API.\r\n\r\nDo you have any suggestions as to how to best handle stream authorisation in the given context?\r\n\r\nThanks in advance!\r\n"
    },
    "satisfaction_conditions": [
      "The solution must allow interception and modification of the stream URL before playback",
      "The solution must be compatible with ImaServerSideAdInsertionMediaSource",
      "The URL modification must occur before the stream is passed to the player",
      "The solution must maintain all existing functionality of the ad insertion system"
    ],
    "created_at": "2022-07-01T14:02:13Z"
  },
  {
    "id": "https://github.com/google/ExoPlayer/issues/10268",
    "source": {
      "issue_number": 10268
    },
    "initial_question": {
      "title": "ForwardingPlayer.setPlayWhenReady is not being called",
      "body": "From migrating a `DefaultControlDispatcher` to `ForwardingPlayer`, do I need to implement something else besides only creating an instance of the `ForwardingPlayer` class? Because I'm not getting called the method `setPlayWhenReady` from the `ForwardingPlayer` but other methods are called as `getPlayWhenReady` and `isPlaying`, for example.\r\n\r\nThis is reproducible in the ExoPlayer Demo app v2.17.1 by just passing a `ForwardingPlayer` object to the `playerView` object through the method `setPlayer()`\r\n\r\nThank you!\r\n"
    },
    "satisfaction_conditions": [
      "Play/pause state changes must be interceptable by the ForwardingPlayer implementation",
      "ForwardingPlayer must maintain proper delegation to the wrapped Player"
    ],
    "created_at": "2022-05-17T21:56:44Z"
  },
  {
    "id": "https://github.com/google/ExoPlayer/issues/10262",
    "source": {
      "issue_number": 10262
    },
    "initial_question": {
      "title": "Method to disable sequential playback on MediaSource level",
      "body": "I am looking for a way to disable sequential playback of mp3s on `MediaSource` level (of course, the MediaSource in my case is a `ConcatenatingMediaSource`). I know about the method `setPauseAtEndOfMediaItems` on exoplayer level. But this disables sequential playback for ALL media sources used by exoplayer. I would like to disable sequential playback on one `MediaSource` while enable it on another `MediaSource`. Is there something like `MediaSource.setPauseAtEndOfMediaItems` ? Thank you!"
    },
    "satisfaction_conditions": [
      "Selective control of sequential playback at MediaSource level",
      "Maintains independent playback control between MediaSources",
      "Preserves existing MediaSource functionality",
      "Compatible with ConcatenatingMediaSource"
    ],
    "created_at": "2022-05-16T09:53:15Z"
  },
  {
    "id": "https://github.com/google/ExoPlayer/issues/10023",
    "source": {
      "issue_number": 10023
    },
    "initial_question": {
      "title": "Custom controller layout not recognizing play and pause buttons.",
      "body": "Hi, I think there is a bug with the custom controller layout.\r\n\r\nI tried to add a custom controller layout to StyledPlayerView on the demo app and it is loaded, but when I override the exo_play and exo_pause buttons they don't work. \r\nWeird thing is that exo_ffwd and exo_rew work as expected (I didn't try others).\r\n\r\nPlayer Activity contains StyledPlayerView\r\n\r\n```\r\n    <com.google.android.exoplayer2.ui.StyledPlayerView\r\n          android:id=\"@+id/player_view\"\r\n          android:layout_width=\"match_parent\"\r\n          android:layout_height=\"match_parent\"\r\n          app:controller_layout_id=\"@layout/exo_player_layout\"/>\r\n```\r\n\r\n\r\nAnd this is exo_player_layout\r\n\r\n\r\n```\r\n     <LinearLayout\r\n            android:id=\"@+id/play_controls\"\r\n            android:layout_width=\"wrap_content\"\r\n            android:layout_height=\"wrap_content\"\r\n            android:gravity=\"center\">\r\n\r\n            <ImageButton\r\n                android:id=\"@id/exo_play\"\r\n                android:layout_width=\"wrap_content\"\r\n                android:layout_height=\"wrap_content\"\r\n                app:srcCompat=\"@drawable/ic_exo_play\" />\r\n\r\n            <ImageButton\r\n                android:id=\"@id/exo_pause\"\r\n                android:layout_width=\"wrap_content\"\r\n                android:layout_height=\"wrap_content\"\r\n                app:srcCompat=\"@drawable/ic_exo_pause\"/>\r\n\r\n        </LinearLayout>\r\n\r\n```\r\n\r\nDoes anyone have any ideas?"
    },
    "satisfaction_conditions": [
      "Play/pause control functionality must work in custom layout",
      "Custom layout must properly integrate with ExoPlayer's control system",
      "Custom button icons/drawables must be correctly displayed",
      "Solution must maintain compatibility with other ExoPlayer controls"
    ],
    "created_at": "2022-03-03T14:33:23Z"
  },
  {
    "id": "https://github.com/google/ExoPlayer/issues/9945",
    "source": {
      "issue_number": 9945
    },
    "initial_question": {
      "title": "Allow LoadControl to prevent loading indefinitely",
      "body": "My use case here is that I would like to prevent loading by overriding DefaultLoadControl if the user switches to a mobile data connection. Due to data caps not everybody wants to use their data towards video streaming. I would like to offer a setting to opt in using mobile data (just like you need to explicitly allow automatic app updates when not on wifi).\r\n\r\nYou can easily reproduce this by overriding `shouldContinueLoading` and always returning `false`.\r\n\r\nApparently there are some legitimate cases where the player could get stuck which is why there is a check for this in `ExoPlayerImplInternal`:\r\n\r\n```\r\nif (!playbackInfo.isLoading\r\n    && playbackInfo.totalBufferedDurationUs < 500_000\r\n    && isLoadingPossible()) {\r\n  // Throw if the LoadControl prevents loading even if the buffer is empty or almost empty. We\r\n  // can't compare against 0 to account for small differences between the renderer position\r\n  // and buffered position in the media at the point where playback gets stuck.\r\n  throw new IllegalStateException(\"Playback stuck buffering and not loading\");\r\n}\r\n```\r\n\r\nIs there a better way to achieve this without running into an Exception? I would like this to be fully recoverable: if the user connects to wifi again streaming should continue without having to prepare the player again.\r\n\r\nIf not I would like to request a configuration flag to override this for my use case. I cannot imagine that I am the only one facing this."
    },
    "satisfaction_conditions": [
      "Playback must pause when mobile data connection is detected (if user hasn't opted in)",
      "Playback must automatically resume from the previous position when WiFi connection is restored",
      "System must allow user opt-in for mobile data streaming",
      "Playlist state must be preserved during connection changes"
    ],
    "created_at": "2022-02-07T13:00:18Z"
  },
  {
    "id": "https://github.com/google/ExoPlayer/issues/9870",
    "source": {
      "issue_number": 9870
    },
    "initial_question": {
      "title": "Unable to fetch the Chunk Size and Latency during playing the video",
      "body": "Hi Team,\r\n\r\nCurrently, I am using the 2.12.1 version and trying to fetch the Chunk Size and Latency by calling the MediaSourceEventListener but I didn't get a call inside the onLoadCompleted Override method.\r\n\r\nPlease find the onLoadCompleted method logic\r\n\r\n@Override\r\n    public void onLoadCompleted(int windowIndex, @Nullable MediaSource.MediaPeriodId mediaPeriodId, LoadEventInfo loadEventInfo, MediaLoadData mediaLoadData) {\r\n        mLatestChunkLatency = loadEventInfo.loadDurationMs;\r\n        mLatestChunkSize = (int) ((mediaLoadData.mediaEndTimeMs - mediaLoadData.mediaStartTimeMs) / 1000);\r\n    }\r\n    \r\n    How to find the Chunk Size and Latency without updating the version?"
    },
    "satisfaction_conditions": [
      "Works with version 2.12.1 without requiring version update"
    ],
    "created_at": "2022-01-18T11:24:15Z"
  },
  {
    "id": "https://github.com/google/ExoPlayer/issues/9751",
    "source": {
      "issue_number": 9751
    },
    "initial_question": {
      "title": "seekToPrevious() in PlayerControlView can't change to the previous mediaItem",
      "body": "I'm used PlayeControlView in the xml layout, when I clicked previous button, it's just seek to the start of current mediaItem.\r\n\r\nI find that there is a method `seekToPreviousMediaItem()` , but in PlayeControlView, it's called `seekToPrevious()`, then it's will get the current playing position and judge is change to previous or seek to 0 of current item.\r\n\r\nI just want to change the previous item, but I can't control it if I use PlayeControlView ,since I can't override the onClick()\r\n\r\n"
    },
    "satisfaction_conditions": [
      "Previous button press navigates to previous media item instead of seeking within current item",
      "Solution maintains compatibility with PlayerControlView in XML layout",
      "Custom previous button behavior can be implemented without direct modification of PlayerControlView",
      "Previous button functionality remains integrated with existing player controls"
    ],
    "created_at": "2021-12-02T10:18:02Z"
  },
  {
    "id": "https://github.com/google/ExoPlayer/issues/9683",
    "source": {
      "issue_number": 9683
    },
    "initial_question": {
      "title": "How to reset the back/forward increments on 2.16.0?",
      "body": "I need to implement **multi-speed** fast-forward/backward when the user multi-tap the forward/backward button. \r\n\r\n> Remove ControlDispatcher and DefaultControlDispatcher. Operations can be customized by using a ForwardingPlayer, or when configuring the player (for example by using ExoPlayer.Builder.setSeekBackIncrementMs).\r\n\r\nThe above is written at the release note for 2.16.0\r\nwe were using the `DefaultControlDispatcher(long fastForwardIncrementMs, long rewindIncrementMs)` or `playerView.setFastForwardIncrementMs(positionOffset)`/`playerView.setRewindIncrementMs(positionOffset)`.\r\n\r\nbut this class is already removed. we should using `ExoPlayer.Builder.setSeekBackIncrementMs` according to the release note. but I can't see how we can reset the increments after the player is built.\r\n\r\nCould you guys please help to figure out it? maybe I am missing sth."
    },
    "satisfaction_conditions": [
      "Player must support dynamic adjustment of seek forward/backward increments after initialization",
      "Multiple speed levels must be supported for forward/backward seeking",
      "Seek operations must respect media duration boundaries",
      "Solution must work with ExoPlayer version 2.16.0 or later"
    ],
    "created_at": "2021-11-11T11:08:53Z"
  },
  {
    "id": "https://github.com/google/ExoPlayer/issues/9656",
    "source": {
      "issue_number": 9656
    },
    "initial_question": {
      "title": "Language Key from .m3u8 file doesn't match language key in track group",
      "body": "In my .m3u8 file, I have a track for subtitles in Indonesian, with language key \"id\". \r\nIt looks like this: \r\n`#EXT-X-MEDIA:TYPE=SUBTITLES,GROUP-ID=\"subs\",NAME=\"Indonesian\",DEFAULT=NO,AUTOSELECT=YES,FORCED=NO,LANGUAGE=\"id\",URI=\"main_id.m3u8\"`\r\n\r\nAfter it's parsed into the player's track group, the language key is \"ms-ind-d\"\r\nIt looks like this: \r\n`Format(subs:Indonesian _ Indonesia, Indonesian _ Indonesia, application/x-mpegURL, text/vtt, null, -1, ms-ind-id, [-1, -1, -1.0], [-1, -1])`\r\n\r\nThe same thing happens with Norwegian. The language key in the .m3u8 file is \"nb\", but when it's parsed by the player, it becomes \"no-nob\".\r\n\r\nWhy does this happen?"
    },
    "satisfaction_conditions": [
      "Language codes from different sources must be normalized to a consistent format",
      "Language code normalization must handle deprecated and modern codes correctly",
      "Language code mapping must preserve the full semantic meaning",
      "Language code handling must support macrolanguage relationships"
    ],
    "created_at": "2021-11-07T06:47:26Z"
  },
  {
    "id": "https://github.com/google/ExoPlayer/issues/9614",
    "source": {
      "issue_number": 9614
    },
    "initial_question": {
      "title": "How can i play RTSP stream without audio codecs?",
      "body": "How can i play RTSP stream without audio codecs? I need only video?I can't start watch stream because camera using g.711 for audio.\r\n"
    },
    "satisfaction_conditions": [
      "Video stream plays successfully without audio",
      "System handles unsupported G.711 audio codec gracefully",
      "Video playback starts without audio-related errors"
    ],
    "created_at": "2021-10-27T12:09:20Z"
  },
  {
    "id": "https://github.com/google/ExoPlayer/issues/9369",
    "source": {
      "issue_number": 9369
    },
    "initial_question": {
      "title": "Check if an error is caused by a Renderer",
      "body": "In version 2.15.0 the **onPlayerError** signature has changed from:\r\n\r\n`public void onPlayerError(ExoPlaybackException error)`\r\n\r\nto:\r\n\r\n`public void onPlayerError(PlaybackException error)`\r\n\r\nWith the older signature we could check if the error was caused by a renderer by querying the error type:\r\n\r\n`if (error.type == ExoPlaybackException.TYPE_RENDERER)`\r\n\r\nHow can now be checked with **PlaybackException**? There is no equivalent in **PlaybackException.errorCode**\r\n\r\n\r\n"
    },
    "satisfaction_conditions": [
      "Code must correctly identify renderer-related errors in the new API version",
      "Solution must work with PlaybackException in version 2.15.0 and later",
      "Code must handle the API breaking change without loss of functionality"
    ],
    "created_at": "2021-09-01T08:09:40Z"
  },
  {
    "id": "https://github.com/google/ExoPlayer/issues/9341",
    "source": {
      "issue_number": 9341
    },
    "initial_question": {
      "title": "Behaviour of `getMinimumLoadableRetryCount` in `DefaultLoadErrorHandlingPolicy`",
      "body": "ExoPlayerVersion: v2.15.0\r\n\r\nI am trying to give retry count for the http calls which Exo is doing internally (Be it manifest, Chunk/Segment, DRM).\r\nFor that, I have my class which extends to `DefaultLoadErrorHandlingPolicy` and I am overriding `getMinimumLoadableRetryCount` in order to achieve it.\r\n\r\n**Question:** I can see that when i pass count 2 then LoadError is coming 3 times and then it gives SourceError. I mean when I give value greater than 1, it always results in +1 LoadError.\r\n\r\nBut when I give 0 or 1 in count, it always results with LoadError 2 times.\r\nI think Exo is internally starting from 0 (with Index). But what is going on with 0 or 1 count value. \r\n\r\nExo is calling it **minLoadableRetryCount**, is there something max as well ? \r\nCan you please suggest on it ? Is this the expected behaviour. \r\n\r\nI have tested in ExoDemo app as well by hard coding the return value in `getMinimumLoadableRetryCount` of `DefaultLoadErrorHandlingPolicy`. It is the same behaviour as explained above.\r\n"
    },
    "satisfaction_conditions": [
      "Retry behavior must respect the minimum retry count while allowing for additional retries",
      "Method must handle edge cases of 0 and 1 retry counts consistently",
      "System must provide a mechanism to limit maximum retries if needed",
      "Error handling must properly propagate final failure state"
    ],
    "created_at": "2021-08-26T09:06:14Z"
  },
  {
    "id": "https://github.com/google/ExoPlayer/issues/9302",
    "source": {
      "issue_number": 9302
    },
    "initial_question": {
      "title": "How to get Proper AdprogressInfo using Exoplayer extension of IMA",
      "body": "How I will get ad player current position when ad is playing. Am able to get ad duration but am not getting ad current position means that how much second being played. Am working on custom ad controller using exoplayer ima extension,  so I required this information. Please help."
    },
    "satisfaction_conditions": [
      "Ad playback position is retrievable during ad playback",
      "Integration works with Exoplayer IMA extension",
      "Information is accessible for custom ad controller implementation",
      "Distinguishes between ad position and content position"
    ],
    "created_at": "2021-08-16T08:25:47Z"
  },
  {
    "id": "https://github.com/google/ExoPlayer/issues/9148",
    "source": {
      "issue_number": 9148
    },
    "initial_question": {
      "title": "How to clear the view and the buffer?",
      "body": "My app is focusing on downloading videos and then playing them with Exoplayer. And obviously Downloading comes together with deleting the file.\r\n\r\nSo the downloading/playing parts work but then I want to be able to clear the player when the user is deleting the video he/she is playing. So I have:\r\n\r\n```\r\nvideoView.player?.stop()\r\nvideoView.player?.release()\r\n```\r\n\r\nHowever, the videoview still shows the image that it was last playing and I'm also guessing that the buffer is still there because when I delete and redownload the same video just after I cannot play it, it gives me this error:\r\n\r\n```\r\nE/ExoPlayerImplInternal: Playback error\r\n      com.google.android.exoplayer2.ExoPlaybackException: Source error\r\n        at com.google.android.exoplayer2.ExoPlayerImplInternal.handleMessage(ExoPlayerImplInternal.java:580)\r\n        at android.os.Handler.dispatchMessage(Handler.java:102)\r\n        at android.os.Looper.loop(Looper.java:246)\r\n        at android.os.HandlerThread.run(HandlerThread.java:67)\r\n     Caused by: com.google.android.exoplayer2.source.UnrecognizedInputFormatException: None of the available extractors (Mp4Extractor, AdtsExtractor) could read the stream.\r\n        at com.google.android.exoplayer2.source.BundledExtractorsAdapter.init(BundledExtractorsAdapter.java:92)\r\n        at com.google.android.exoplayer2.source.ProgressiveMediaPeriod$ExtractingLoadable.load(ProgressiveMediaPeriod.java:1027)\r\n        at com.google.android.exoplayer2.upstream.Loader$LoadTask.run(Loader.java:417)\r\n        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1167)\r\n        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:641)\r\n        at java.lang.Thread.run(Thread.java:923)\r\n```\r\n\r\n(i tried to use all the possible exrtractors)\r\n\r\nHow can I clear view and buffer in this case and then still being able to play the new downloaded video?"
    },
    "satisfaction_conditions": [
      "Player view must be cleared of previous video content",
      "Player must be in a state that allows new video playback",
      "Resources must be properly released when video is deleted",
      "Playlist functionality must be maintained after video removal",
      "Player state must remain consistent after video removal"
    ],
    "created_at": "2021-07-04T13:31:44Z"
  },
  {
    "id": "https://github.com/google/ExoPlayer/issues/8833",
    "source": {
      "issue_number": 8833
    },
    "initial_question": {
      "title": "Equivalent callback for onTimelineChanged with reason TIMELINE_CHANGE_REASON_PREPARED, on versiosn 2.12+",
      "body": "Hi,\r\n\r\nOn my project, when playing a live stream, i need to make a seek to a specific time of the day, when starting playing a new stream. \r\nTo do that, on ExoPlayer 2.11.x i relied the callback for `onTimelineChanged `with reason `TIMELINE_CHANGE_REASON_PREPARED`. \r\nWhen that callback was called, i could get the media duration, and with the offset from the currentTime, calculate the position to pass to the `seekTo `method (`player.duration - System.currentTime - timeOfTheDayToSeekTo`).\r\n\r\nAfter version 2.12.0, `TIMELINE_CHANGE_REASON_PREPARED `was removed, and when the callback is called with reason `TIMELINE_CHANGE_REASON_PLAYLIST_CHANGED`, the player duration still undefined.\r\n\r\nI could rely on the callback being called with `TIMELINE_CHANGE_REASON_SOURCE_UPDATE`, but since that is called multiple times, i need to make extra checks to be sure i only make the seek on the first call after the media is changed, and the `timeOfTheDayToSeekTo `is set.\r\n\r\n\r\nMy question is:\r\nOn versions 2.12.+ is there any equivalent callback to `onTimelineChanged`, with reason `TIMELINE_CHANGE_REASON_PREPARED `on 2.11.x (Only called once, before the first the first frame is rendered, and after the media duration is known) ? \r\n\r\nIs there any way make a relative seek, like seek to 30000ms before the live edge/default position (something like seekTo(-30000) so i can set the seek position right after calling prepare without knowing the media duration?\r\n\r\nThanks in advance"
    },
    "satisfaction_conditions": [
      "Ability to determine when media duration becomes available",
      "Support for relative seeking from live edge",
      "Ability to seek to a specific time of day",
      "Compatibility with ExoPlayer 2.12+ API"
    ],
    "created_at": "2021-04-20T10:32:13Z"
  },
  {
    "id": "https://github.com/google/ExoPlayer/issues/8813",
    "source": {
      "issue_number": 8813
    },
    "initial_question": {
      "title": "Generating Relation Between Offline License and Downloaded Content",
      "body": "Hi,\r\n\r\nI am trying to understand how to create the downloaded license's keySetId and downloaded track. Normally If I am on the latest release that's not an issue. Because we can create a relation between keySetId and download request during the request generation. But since I am on 2.11.4 (due to some other dependencies in the project) I can not find a way to create the relation. \r\n\r\nShould I save the keyset id with the related content id in local storage or some place like that ? Or is there a supportive utility that can manage the keysetId and content relation ? "
    },
    "satisfaction_conditions": [
      "A persistent mapping must be maintained between keySetId and downloaded content",
      "The mapping solution must work with version 2.11.4",
      "The mapping must persist across application sessions",
      "If using DownloadRequest.data, the solution must handle data versioning"
    ],
    "created_at": "2021-04-12T23:49:48Z"
  },
  {
    "id": "https://github.com/google/ExoPlayer/issues/8775",
    "source": {
      "issue_number": 8775
    },
    "initial_question": {
      "title": "add MediaSourceListener using DataSource.Factory ",
      "body": "Hi, since i've migrated to MediaSourceFactory pattern, how can i add a MediaSourceListener if i can't access MediaSource?\r\n\r\ni was able to add listener using the mediaSource.addEventListener(handler, listener) methon and then, prepare the player passing the mediasource: player.prepare(MediaSource mediaSource, boolean resetPosition, boolean resetState)\r\n\r\nBut now, building the player like this, i can't figure out how to listen the mediasource events\r\n```\r\nSimpleExoPlayer player = new SimpleExoPlayer.Builder(context)\r\n    .setMediaSourceFactory(mediaSourceFactory)\r\n    .build();\r\n```\r\n\r\nThank you"
    },
    "satisfaction_conditions": [
      "Events from MediaSource must be successfully monitored",
      "Solution must work with MediaSourceFactory pattern",
      "Events must be accessible after player initialization"
    ],
    "created_at": "2021-03-29T13:47:23Z"
  },
  {
    "id": "https://github.com/google/ExoPlayer/issues/8769",
    "source": {
      "issue_number": 8769
    },
    "initial_question": {
      "title": "How to enableDecoderFallback for ExoPlayerFactory.newSimpleInstance() ?",
      "body": "Let's say there is an app which uses two third-party media players each one internally implemented using ExoPlayer.\r\nLet's refer to the first player as the \"main\" and the second one as \"aux\".\r\n\r\nThe main player plays content and when the user pauses playback it the application starts the \"aux\" player.\r\nThe aux player plays some special \"pause\" content.\r\n\r\nWhen we were using this scenario with ExoPlayer 2.9.4 this worked with a caveat that the aux player was using the software video decoder while the main player was holding on to the hardware video decoder (it is just paused and not stopped or released). \r\n\r\nWhen we switched to ExoPlayer 2.12.3 this stopped working -- the \"aux\" player now fails with an exception that it cannot allocate the _hardware_ video decoder.\r\n\r\nIn ExoPlayer 2.12.3 there is a way to enable decoder fallback, when it is enabled the behavior is similar to what we used to have with 2.9.4.\r\nThe problem however is that \"aux\" player is using ExoPlayerFactory.newSimpleInstance() and there is no way to enable decoder fallback from this level of API (and decoder fallback is disabled by default).\r\n\r\nDo you have any recommendation on how to work around this issue (without asking the \"main\" player vendor to change the player behavior significantly during pause or asking the \"aux\" player vendor to use different API level for ExoPlayer)?\r\n\r\nAny plans to allow enableDecoderFallback with ExoPlayerFactory.newSimpleInstance() ?\r\n\r\n"
    },
    "satisfaction_conditions": [
      "Decoder fallback functionality must be accessible without modifying third-party implementations",
      "Solution must maintain compatibility with ExoPlayer version 2.12.3 or higher",
      "Secondary player must be able to fall back to software decoder when hardware decoder is unavailable"
    ],
    "created_at": "2021-03-29T06:47:22Z"
  },
  {
    "id": "https://github.com/google/ExoPlayer/issues/8666",
    "source": {
      "issue_number": 8666
    },
    "initial_question": {
      "title": "How to know which MediaSource caused ExoPlaybackException (on preloading the next track)?",
      "body": "To handle `ExoPlaybackException` we must implement `EventListener.onPlayerError()`. If for example, we encounter a 403 HTTP error because the track's URL is expired,  we can catch it inside this function and take appropriate actions:\r\n- See which track caused 403 exception.\r\n- Check our application API to see if we have access to a new URL for the track.\r\n- Replace the corresponding MediaSource with a new one having a valid & fresh URL.\r\n- Play the new MediaSource.\r\n\r\nIt isn't clear how we can find which track caused the exception. Currently we are using `player.getCurrentWindowIndex()`. There is a new `mediaPeriodId` in the exception too, but I am not sure how to trace it back to `MediaSource`. Also I am not sure if either of `player.getCurrentWindowIndex()` or ` mediaPeriodId` leads me to the correct `MediaSource`, in case the media source was just preloaded and it is not actually the current playing media source.\r\n"
    },
    "satisfaction_conditions": [
      "Must correctly identify which media source caused the error",
      "Must handle both immediate playback errors and preloaded content errors",
      "Must enable recovery from URL expiration errors",
      "Must maintain correct playback sequence after error recovery",
      "Must provide early error detection capability"
    ],
    "created_at": "2021-03-03T09:44:43Z"
  },
  {
    "id": "https://github.com/google/ExoPlayer/issues/8632",
    "source": {
      "issue_number": 8632
    },
    "initial_question": {
      "title": "TextOutput onCues called multiple times with same cue text with segmented WebVTT subtitles",
      "body": "Our stream provider recently changed the way the subtitles are segmented so that a subtitle segment length is the same as the video segment. So now one .vtt file contains subtitles for a 10 second period. Now there can be multiple subtitle segments that contain the same cue if the cue should be visible in 2 different segments.\r\n\r\nExample .vtt segments:\r\n**seg-38.vtt**\r\nWEBVTT\r\n\r\n28\r\n00:05:47.160 --> 00:05:50.000 \r\nThis line is repeated twice\r\n\r\n**seg-39.vtt**\r\nWEBVTT\r\n\r\n28\r\n00:05:47.160 --> 00:05:50.000 \r\nThis line is repeated twice\r\n\r\n29\r\n00:05:52.680 --> 00:05:54.320 \r\nSome other line that is fine\r\n\r\nThe issue with the onCues getting called twice with the same cue causes problems because we use the onCues callback to feed the cues to the Text-To-Speech engine and now users are complaining that they hear the same line twice. \r\n\r\nI was thinking that I could check if the subtitle number (28 in the example above) matches the previous cue's number and skip the duplicate one based on that but there seems to be no way to get that line number from the cue that's provided in the onCues method.\r\n\r\nDo you have any ideas for a workaround for this issue. At first I was thinking about storing the previous cue and checking if the next cue text matches the previous one and then skipping it if it matches but there may be cases where it is intended to have the same text repeat multiple times in a row so that won't really work. I would need to be able to compare the start/end times or subtitle numbers but those aren't provided to the method.\r\n"
    },
    "satisfaction_conditions": [
      "Duplicate subtitle cues must not trigger multiple text-to-speech outputs",
      "Intentionally repeated subtitles must still be read multiple times",
      "Solution must handle continuous subtitle visibility across segments",
      "Solution must work without access to subtitle sequence numbers"
    ],
    "created_at": "2021-02-25T10:47:10Z"
  },
  {
    "id": "https://github.com/google/ExoPlayer/issues/8607",
    "source": {
      "issue_number": 8607
    },
    "initial_question": {
      "title": "[Question] Previous button is going to the beginning of the stream instead of the previous item in the playlist",
      "body": "I am using the exoplayer to play live streams in a playlist.\r\n\r\nThe previous button instead of going to the previous item in the playlist, it returns to the beginning of the stream of the current item.\r\n\r\nThis happens when I let it play the stream for few seconds then click on the previous button.\r\nIn that case, I need to click twice on the previous button to have it switch to the previous item in the playlist.\r\n\r\nWhat do I need to do in order to force the previous button to ignore the current item's live window and go to the previous item in the playlist?\r\n\r\nThanks"
    },
    "satisfaction_conditions": [
      "Previous button behavior overrides default stream position handling",
      "Custom navigation behavior integrates with existing player controls"
    ],
    "created_at": "2021-02-19T08:37:10Z"
  },
  {
    "id": "https://github.com/google/ExoPlayer/issues/8509",
    "source": {
      "issue_number": 8509
    },
    "initial_question": {
      "title": "MediaCodecVideoRenderer error, index=0, format=Format(1, null, null, video/avc, null, -1, null, [720, 1280, 29.969316], [-1, -1]), format_supported=YES",
      "body": "To be honest, it is the first I use the ExoPlayer. And, a problem happened!\r\nwhen the SimpleExoPlayer.stop() invoked, I want the screen(the SurfaceView) is pur black color, So, I did this.\r\n\r\n      stopBtn.setOnClickListener(new View.OnClickListener() {\r\n            @Override\r\n            public void onClick(View v) {\r\n                simpleExoPlayer.stop(true);\r\n                simpleExoPlayer.clearVideoSurfaceHolder(surfaceView.getHolder());\r\n\r\n                SurfaceHolder holder = surfaceView.getHolder();\r\n                Canvas canvas = holder.lockCanvas();\r\n                canvas.drawColor(Color.BLACK);\r\n                holder.unlockCanvasAndPost(canvas);\r\n\r\n                simpleExoPlayer.setVideoSurfaceHolder(surfaceView.getHolder());\r\n            }\r\n        });\r\n        nextBtn.setOnClickListener(new View.OnClickListener() {\r\n            @Override\r\n            public void onClick(View v) {\r\n                MediaItem mediaItem = MediaItem.fromUri(getString(R.string.media_url_mp4));\r\n                simpleExoPlayer.setMediaItem(mediaItem);\r\n                simpleExoPlayer.prepare();\r\n            }\r\n        });` \r\nI click stop button, it running well.\r\nwhen I click the button what name is nextVideo, Yes\uff0cit is Error.\r\nGuys,please tell me WTF?\r\n\r\n`2021-01-26 16:22:37.780 E/SurfaceUtils: Failed to connect to surface 0x71e8f79010, err -22\r\n2021-01-26 16:22:37.780 E/MediaCodec: nativeWindowConnect returned an error: Invalid argument (-22)\r\n2021-01-26 16:22:37.780 E/MediaCodec: configure failed with err 0xffffffea, resetting...\r\n2021-01-26 16:22:37.788 I/OMXClient: IOmx service obtained\r\n2021-01-26 16:22:37.816 W/MediaCodecRenderer: Failed to initialize decoder: OMX.qcom.video.decoder.avc\r\n      java.lang.IllegalArgumentException\r\n        at android.media.MediaCodec.native_configure(Native Method)\r\n        at android.media.MediaCodec.configure(MediaCodec.java:2023)\r\n        at android.media.MediaCodec.configure(MediaCodec.java:1951)\r\n        at com.google.android.exoplayer2.mediacodec.SynchronousMediaCodecAdapter.configure(SynchronousMediaCodecAdapter.java:43)\r\n        at com.google.android.exoplayer2.video.MediaCodecVideoRenderer.configureCodec(MediaCodecVideoRenderer.java:580)\r\n        at com.google.android.exoplayer2.mediacodec.MediaCodecRenderer.initCodec(MediaCodecRenderer.java:1143)\r\n        at com.google.android.exoplayer2.mediacodec.MediaCodecRenderer.maybeInitCodecWithFallback(MediaCodecRenderer.java:1040)\r\n        at com.google.android.exoplayer2.mediacodec.MediaCodecRenderer.maybeInitCodecOrBypass(MediaCodecRenderer.java:604)\r\n        at com.google.android.exoplayer2.mediacodec.MediaCodecRenderer.onInputFormatChanged(MediaCodecRenderer.java:1470)\r\n        at com.google.android.exoplayer2.video.MediaCodecVideoRenderer.onInputFormatChanged(MediaCodecVideoRenderer.java:640)\r\n        at com.google.android.exoplayer2.mediacodec.MediaCodecRenderer.readToFlagsOnlyBuffer(MediaCodecRenderer.java:994)\r\n        at com.google.android.exoplayer2.mediacodec.MediaCodecRenderer.render(MediaCodecRenderer.java:844)\r\n        at com.google.android.exoplayer2.ExoPlayerImplInternal.doSomeWork(ExoPlayerImplInternal.java:892)\r\n        at com.google.android.exoplayer2.ExoPlayerImplInternal.handleMessage(ExoPlayerImplInternal.java:467)\r\n        at android.os.Handler.dispatchMessage(Handler.java:103)\r\n        at android.os.Looper.loop(Looper.java:224)\r\n        at android.os.HandlerThread.run(HandlerThread.java:67)\r\n2021-01-26 16:22:37.820 E/ExoPlayerImplInternal: Playback error\r\n      com.google.android.exoplayer2.ExoPlaybackException: MediaCodecVideoRenderer error, index=0, format=Format(1, null, null, video/avc, null, -1, null, [720, 1280, 29.969316], [-1, -1]), format_supported=YES\r\n        at com.google.android.exoplayer2.ExoPlayerImplInternal.handleMessage(ExoPlayerImplInternal.java:542)\r\n        at android.os.Handler.dispatchMessage(Handler.java:103)\r\n        at android.os.Looper.loop(Looper.java:224)\r\n        at android.os.HandlerThread.run(HandlerThread.java:67)\r\n     Caused by: com.google.android.exoplayer2.mediacodec.MediaCodecRenderer$DecoderInitializationException: Decoder init failed: OMX.qcom.video.decoder.avc, Format(1, null, null, video/avc, null, -1, null, [720, 1280, 29.969316], [-1, -1])\r\n        at com.google.android.exoplayer2.mediacodec.MediaCodecRenderer.maybeInitCodecWithFallback(MediaCodecRenderer.java:1047)\r\n        at com.google.android.exoplayer2.mediacodec.MediaCodecRenderer.maybeInitCodecOrBypass(MediaCodecRenderer.java:604)\r\n        at com.google.android.exoplayer2.mediacodec.MediaCodecRenderer.onInputFormatChanged(MediaCodecRenderer.java:1470)\r\n        at com.google.android.exoplayer2.video.MediaCodecVideoRenderer.onInputFormatChanged(MediaCodecVideoRenderer.java:640)\r\n        at com.google.android.exoplayer2.mediacodec.MediaCodecRenderer.readToFlagsOnlyBuffer(MediaCodecRenderer.java:994)\r\n        at com.google.android.exoplayer2.mediacodec.MediaCodecRenderer.render(MediaCodecRenderer.java:844)\r\n        at com.google.android.exoplayer2.ExoPlayerImplInternal.doSomeWork(ExoPlayerImplInternal.java:892)\r\n        at com.google.android.exoplayer2.ExoPlayerImplInternal.handleMessage(ExoPlayerImplInternal.java:467)\r\n        at android.os.Handler.dispatchMessage(Handler.java:103)\u00a0\r\n        at android.os.Looper.loop(Looper.java:224)\u00a0\r\n        at android.os.HandlerThread.run(HandlerThread.java:67)\u00a0\r\n     Caused by: java.lang.IllegalArgumentException\r\n        at android.media.MediaCodec.native_configure(Native Method)\r\n        at android.media.MediaCodec.configure(MediaCodec.java:2023)\r\n        at android.media.MediaCodec.configure(MediaCodec.java:1951)\r\n        at com.google.android.exoplayer2.mediacodec.SynchronousMediaCodecAdapter.configure(SynchronousMediaCodecAdapter.java:43)\r\n        at com.google.android.exoplayer2.video.MediaCodecVideoRenderer.configureCodec(MediaCodecVideoRenderer.java:580)\r\n        at com.google.android.exoplayer2.mediacodec.MediaCodecRenderer.initCodec(MediaCodecRenderer.java:1143)\r\n        at com.google.android.exoplayer2.mediacodec.MediaCodecRenderer.maybeInitCodecWithFallback(MediaCodecRenderer.java:1040)\r\n        at com.google.android.exoplayer2.mediacodec.MediaCodecRenderer.maybeInitCodecOrBypass(MediaCodecRenderer.java:604)\u00a0\r\n        at com.google.android.exoplayer2.mediacodec.MediaCodecRenderer.onInputFormatChanged(MediaCodecRenderer.java:1470)\u00a0\r\n        at com.google.android.exoplayer2.video.MediaCodecVideoRenderer.onInputFormatChanged(MediaCodecVideoRenderer.java:640)\u00a0\r\n        at com.google.android.exoplayer2.mediacodec.MediaCodecRenderer.readToFlagsOnlyBuffer(MediaCodecRenderer.java:994)\u00a0\r\n        at com.google.android.exoplayer2.mediacodec.MediaCodecRenderer.render(MediaCodecRenderer.java:844)\u00a0\r\n        at com.google.android.exoplayer2.ExoPlayerImplInternal.doSomeWork(ExoPlayerImplInternal.java:892)\u00a0\r\n        at com.google.android.exoplayer2.ExoPlayerImplInternal.handleMessage(ExoPlayerImplInternal.java:467)\u00a0\r\n        at android.os.Handler.dispatchMessage(Handler.java:103)\u00a0\r\n        at android.os.Looper.loop(Looper.java:224)\u00a0\r\n        at android.os.HandlerThread.run(HandlerThread.java:67)\u00a0`\r\n"
    },
    "satisfaction_conditions": [
      "Screen must display black/blank state when playback is stopped"
    ],
    "created_at": "2021-01-26T08:51:15Z"
  },
  {
    "id": "https://github.com/google/ExoPlayer/issues/8258",
    "source": {
      "issue_number": 8258
    },
    "initial_question": {
      "title": "Why does ExoPlayer call updateSelectedTrack() many times when I modify determineIdealSelectedIndex()?",
      "body": "Hi,\r\nWhen I run your **demo** configuration and watch `Google Play H264 (MP4)`, the `AdaptiveTrackSelection.updateSelectedTrack()` is called 15 times, and the selected qualities are recorded as follows:\r\n_Note_: \r\n```java\r\nThe QualityIdx is determined as `length - newSelectedIndex`\r\npublic static final int DEFAULT_MIN_BUFFER_MS = 20_000;\r\npublic static final int DEFAULT_MAX_BUFFER_MS = 20_000; \r\n```\r\n```\r\n2020-11-20 11:17:23.105 5588-5588/com.google.android.exoplayer2.demo I/MINH: Id\tTime\tEstThroughput\tQualityIdx\tBitrate\tBuffer\r\n2020-11-20 11:17:23.105 5588-5588/com.google.android.exoplayer2.demo I/MINH: 1\t989\t4.139778\t6\t1.834968\t0.0\t\r\n2020-11-20 11:17:23.105 5588-5588/com.google.android.exoplayer2.demo I/MINH: 2\t990\t4.139778\t6\t1.834968\t0.0\t\r\n2020-11-20 11:17:23.106 5588-5588/com.google.android.exoplayer2.demo I/MINH: 3\t990\t23.515743\t6\t1.834968\t5.213468\t\r\n2020-11-20 11:17:23.106 5588-5588/com.google.android.exoplayer2.demo I/MINH: 4\t990\t32.762936\t6\t1.834968\t9.359454\t\r\n2020-11-20 11:17:23.106 5588-5588/com.google.android.exoplayer2.demo I/MINH: 5\t990\t32.762936\t6\t1.834968\t13.740843\t\r\n2020-11-20 11:17:23.107 5588-5588/com.google.android.exoplayer2.demo I/MINH: 6\t991\t28.8144\t\t6\t1.834968\t17.874817\t\r\n2020-11-20 11:17:23.107 5588-5588/com.google.android.exoplayer2.demo I/MINH: 7\t993\t28.8144\t\t6\t1.834968\t19.99352\t\r\n2020-11-20 11:17:23.108 5588-5588/com.google.android.exoplayer2.demo I/MINH: 8\t998\t28.8144\t\t6\t1.834968\t19.996836\t\r\n2020-11-20 11:17:23.108 5588-5588/com.google.android.exoplayer2.demo I/MINH: 9\t1003\t27.448479\t6\t1.834968\t19.99776\t\r\n2020-11-20 11:17:23.109 5588-5588/com.google.android.exoplayer2.demo I/MINH: 10\t1008\t31.993544\t6\t1.834968\t19.997576\t\r\n2020-11-20 11:17:23.109 5588-5588/com.google.android.exoplayer2.demo I/MINH: 11\t1012\t31.993544\t6\t1.834968\t19.995329\t\r\n2020-11-20 11:17:23.109 5588-5588/com.google.android.exoplayer2.demo I/MINH: 12\t1017\t31.585793\t6\t1.834968\t19.999952\t\r\n2020-11-20 11:17:23.110 5588-5588/com.google.android.exoplayer2.demo I/MINH: 13\t1023\t51.726105\t6\t1.834968\t19.996777\t\r\n2020-11-20 11:17:23.110 5588-5588/com.google.android.exoplayer2.demo I/MINH: 14\t1027\t51.726105\t6\t1.834968\t19.990929\t\r\n2020-11-20 11:17:23.110 5588-5588/com.google.android.exoplayer2.demo I/MINH: 15\t1029\t51.726105\t6\t1.834968\t19.996412\t\r\n```\r\n\r\nHowever, when I modify the function `determineIdealSelectedIndex()`\r\n\r\n```java\r\n...\r\nprivate static int minh_count = 0;\r\n...\r\nprivate int determineIdealSelectedIndex(long nowMs) {\r\n    long effectiveBitrate = bandwidthProvider.getAllocatedBandwidth();\r\n    int lowestBitrateAllowedIndex = 0;\r\n    for (int i = 0; i < length; i++) {\r\n      if (nowMs == Long.MIN_VALUE || !isBlacklisted(i, nowMs)) {\r\n        Format format = getFormat(i);\r\n        if (canSelectFormat(format, format.bitrate, playbackSpeed, effectiveBitrate)) { //throughput-based\r\n          // Modify for test - START\r\n          //  return  i;\r\n          minh_count ++;\r\n          return minh_count%length;\r\n          // Modify for test - END\r\n        } else {\r\n          lowestBitrateAllowedIndex = i;\r\n        }\r\n      }\r\n    }\r\n\r\n    return lowestBitrateAllowedIndex;\r\n  }\r\n```\r\nThe `AdaptiveTrackSelection.updateSelectedTrack()` is called 20 times as follows:\r\n```\r\n2020-11-20 11:20:25.514 5744-5744/com.google.android.exoplayer2.demo I/MINH: Id\tTime\tEstThroughput\tQualityIdx\tBitrate\tBuffer\r\n2020-11-20 11:20:25.514 5744-5744/com.google.android.exoplayer2.demo I/MINH: 1\t1172\t4.139778\t5\t1.006977\t0.0\t\r\n2020-11-20 11:20:25.514 5744-5744/com.google.android.exoplayer2.demo I/MINH: 2\t1172\t4.139778\t4\t0.499978\t0.0\t\r\n2020-11-20 11:20:25.514 5744-5744/com.google.android.exoplayer2.demo I/MINH: 3\t1172\t4.139778\t3\t0.257246\t0.0\t\r\n2020-11-20 11:20:25.514 5744-5744/com.google.android.exoplayer2.demo I/MINH: 4\t1172\t4.139778\t2\t0.147097\t0.0\t\r\n2020-11-20 11:20:25.515 5744-5744/com.google.android.exoplayer2.demo I/MINH: 5\t1172\t4.139778\t1\t0.075814\t0.0\t\r\n2020-11-20 11:20:25.515 5744-5744/com.google.android.exoplayer2.demo I/MINH: 6\t1172\t4.139778\t1\t0.075814\t0.0\t\r\n2020-11-20 11:20:25.515 5744-5744/com.google.android.exoplayer2.demo I/MINH: 7\t1172\t4.139778\t1\t0.075814\t5.214\t\r\n2020-11-20 11:20:25.515 5744-5744/com.google.android.exoplayer2.demo I/MINH: 8\t1172\t4.139778\t1\t0.075814\t9.522873\t\r\n2020-11-20 11:20:25.515 5744-5744/com.google.android.exoplayer2.demo I/MINH: 9\t1172\t4.139778\t3\t0.257246\t14.114865\t\r\n2020-11-20 11:20:25.515 5744-5744/com.google.android.exoplayer2.demo I/MINH: 10\t1172\t15.159876\t2\t0.147097\t18.749332\t\r\n2020-11-20 11:20:25.515 5744-5744/com.google.android.exoplayer2.demo I/MINH: 11\t1175\t15.932693\t1\t0.075814\t19.99592\t\r\n2020-11-20 11:20:25.515 5744-5744/com.google.android.exoplayer2.demo I/MINH: 12\t1180\t15.932693\t6\t1.834968\t19.999607\t\r\n2020-11-20 11:20:25.515 5744-5744/com.google.android.exoplayer2.demo I/MINH: 13\t1180\t15.932693\t5\t1.006977\t19.87662\t\r\n2020-11-20 11:20:25.515 5744-5744/com.google.android.exoplayer2.demo I/MINH: 14\t1185\t16.497812\t4\t0.499978\t19.998589\t\r\n2020-11-20 11:20:25.515 5744-5744/com.google.android.exoplayer2.demo I/MINH: 15\t1190\t15.932693\t3\t0.257246\t19.999405\t\r\n2020-11-20 11:20:25.515 5744-5744/com.google.android.exoplayer2.demo I/MINH: 16\t1195\t19.41076\t2\t0.147097\t19.99306\t\r\n2020-11-20 11:20:25.515 5744-5744/com.google.android.exoplayer2.demo I/MINH: 17\t1200\t19.41076\t1\t0.075814\t19.991512\t\r\n2020-11-20 11:20:25.515 5744-5744/com.google.android.exoplayer2.demo I/MINH: 18\t1205\t18.738419\t6\t1.834968\t19.993235\t\r\n2020-11-20 11:20:25.515 5744-5744/com.google.android.exoplayer2.demo I/MINH: 19\t1209\t19.41076\t5\t1.006977\t19.998152\t\r\n2020-11-20 11:20:25.515 5744-5744/com.google.android.exoplayer2.demo I/MINH: 20\t1211\t18.738419\t4\t0.499978\t19.99512\t\r\n```\r\nEspecially, the segment `Id`s: 2, 3, 4, 5 and 12 have the `chunk.getDurationUs() = 0.0` in the function `DefaultDashChunkSource.onChunkLoadCompleted()`, and theses segments are not played on the screen.\r\n\r\nWhy does this happen?\r\nHow can I enforce the ExoPlayer to send requests and plays exactly what `updateSelectedTrack()` determines?\r\n\r\nThank you."
    },
    "satisfaction_conditions": [
      "Player must successfully load initialization data for selected formats",
      "Track selection system must handle format switches correctly",
      "Playback duration must be accurately tracked"
    ],
    "created_at": "2020-11-20T10:44:55Z"
  },
  {
    "id": "https://github.com/google/ExoPlayer/issues/8172",
    "source": {
      "issue_number": 8172
    },
    "initial_question": {
      "title": "CacheEvictionListener",
      "body": "Is there any callbacks for listening to cache eviction? Like when something is being removed from cache we shall observe which item is being removed."
    },
    "satisfaction_conditions": [
      "Cache eviction events must be observable",
      "Event handling must be configurable per cache key",
      "Events must be delivered in a consistent order"
    ],
    "created_at": "2020-11-06T04:13:02Z"
  },
  {
    "id": "https://github.com/google/ExoPlayer/issues/8153",
    "source": {
      "issue_number": 8153
    },
    "initial_question": {
      "title": "Caching S3 signed url",
      "body": "I have implemented pre-caching and it works for unsigned url's. However when s3 signed urls are used it cache's it as new video everytime when loaded instead of loading from cache if cached already (s3 signed url changes on every request but video id on the url will remain the same)\r\n\r\nAny help?"
    },
    "satisfaction_conditions": [
      "Cache key remains consistent across requests for the same video",
      "Cached video content is reused on subsequent requests",
      "Cache system correctly identifies equivalent video resources"
    ],
    "created_at": "2020-11-03T12:05:40Z"
  },
  {
    "id": "https://github.com/google/ExoPlayer/issues/8137",
    "source": {
      "issue_number": 8137
    },
    "initial_question": {
      "title": "How to get the entire content Duration of a MediaItem, not just the clip length? ",
      "body": "### [REQUIRED] Question\r\nI have a list of `MediaItem`s with different start positions. \r\n```java\r\nMediaItem mediaItem = new MediaItem.Builder()\r\n    .setUri(trackUri)\r\n    .setClipStartPositionMs(startPos)\r\n    .setClipEndPositionMs(C.TIME_END_OF_SOURCE)\r\n    .build();\r\n```\r\nWhen a particular MediaItem is being played, the Player is just returning the duration of the clip, not the total length of the track. \r\nIs there a way where I can get the total length of the track, not just the clip length? "
    },
    "satisfaction_conditions": [
      "Must retrieve the total duration of the original media content, regardless of clip settings",
      "Must correctly handle media items with clip start positions",
      "Must provide accurate position information relative to the original media timeline",
      "Must maintain functionality during active playback",
      "Must handle invalid or empty timeline states gracefully"
    ],
    "created_at": "2020-10-29T17:04:48Z"
  },
  {
    "id": "https://github.com/google/ExoPlayer/issues/8118",
    "source": {
      "issue_number": 8118
    },
    "initial_question": {
      "title": "can't get duration of audio file which  extension is .aac",
      "body": "[No information provided]"
    },
    "satisfaction_conditions": [
      "Audio container format must include duration metadata in file header"
    ],
    "created_at": "2020-10-27T03:10:20Z"
  },
  {
    "id": "https://github.com/google/ExoPlayer/issues/7955",
    "source": {
      "issue_number": 7955
    },
    "initial_question": {
      "title": "With v2.12.0 playlist api, how do I know which source causes the onPlayerError",
      "body": "### [REQUIRED] Searched documentation and issues\r\nLooked at StackOverflow and other issues. Could not find anything related\r\n\r\n### [REQUIRED] Question\r\nI using the new playlist API provided with v2.12.0 and loading multiple `MediaItem`s into the player. One of the sources throws an `ExoPlaybackException` of `ExoPlaybackException.TYPE_SOURCE` type.\r\n\r\nHow do I know which media item this relates to?\r\n\r\n### A full bug report captured from the device\r\nNo specific bug is referred to.\r\n\r\n### Link to test content\r\nGeneral question that does not relate to a specific source.\r\n"
    },
    "satisfaction_conditions": [
      "Must identify which media item caused the ExoPlaybackException",
      "Must work with the v2.12.0 playlist API",
      "Must handle TYPE_SOURCE ExoPlaybackException errors",
      "Must work with multiple MediaItems loaded into the player"
    ],
    "created_at": "2020-09-21T08:30:29Z"
  },
  {
    "id": "https://github.com/google/ExoPlayer/issues/7915",
    "source": {
      "issue_number": 7915
    },
    "initial_question": {
      "title": "MediaItem.Builder() doesn't contain StreamType in ExoPlayer 2.12.0",
      "body": "Hello,\r\n\r\nUntil ExoPlayer 2.12.0 i used `MediaInfo.Builder()` where i could set media stream type, for example: `.setStreamType(MediaInfo.STREAM_TYPE_LIVE)` and then i passed all information to the `MediaQueueItem.Builder()` to cast video to Google Chromecast.\r\n\r\nIn the new ExoPlayer 2.12.0 version i have to use `MediaItem.Builder()` now. And it is impossible to set media stream type now.\r\nOr maybe i'm missing something?\r\n\r\nThank you."
    },
    "satisfaction_conditions": [
      "Media stream type information must be successfully transmitted to Chromecast",
      "Media metadata (title, subtitle, image) must be fully transferable to Chromecast",
      "Solution must be compatible with both CastPlayer and SimpleExoPlayer",
      "Custom data must be preserved during media item conversion",
      "Maintains backward compatibility with existing Chromecast functionality"
    ],
    "created_at": "2020-09-15T10:55:40Z"
  },
  {
    "id": "https://github.com/google/ExoPlayer/issues/7782",
    "source": {
      "issue_number": 7782
    },
    "initial_question": {
      "title": "Switch between video and view at given times",
      "body": "I'm looking for a way to stop the video at, let's say 10s, pause the video switch to another view and when the user is finished with that view, start back the video display.\r\n\r\nAfter looking at the dev website, I was wondering if this could be done with IMA ads but I guess it can't be done because I need indefinite time for the in-middle view. \r\n\r\nIs there any way I can do this? Then is there a way to display little vertical yellow bars (at switching position) in the seekbar as you do for ads ?"
    },
    "satisfaction_conditions": [
      "Video playback must pause at specified timestamps",
      "System must support switching between video and alternate view",
      "Visual markers must be displayable on the video progress bar",
      "Switch points must support indefinite duration pauses"
    ],
    "created_at": "2020-08-19T05:15:33Z"
  },
  {
    "id": "https://github.com/google/ExoPlayer/issues/7703",
    "source": {
      "issue_number": 7703
    },
    "initial_question": {
      "title": "Does exoplayer automatically use ABR as per internet connectivity?",
      "body": "Hello there,\r\nHope you are well.\r\n\r\nWith regards, we are developing a video news android app(from our app: we are going to distribute the videos to end-users, only video content).\r\n\r\n**For the same, we are looking to integrate Exoplayer(as a video player to stream the content) but we have a query:**\r\n\r\n-Does Exoplayer automatically use ABR and stream as per Internet connectivity? What I mean over here is: normal MP4 links from AWS/google cloud to the player, no M3U8 links will be provided by AWS/Google cloud to the player & player streams as per internet connectivity of the end-user without getting M3U8 link from AWS )? Does this work? OR \r\n\r\n-Does Exoplayer needs the inputs(in the form of M3U8) from Cloud(like AWS or Google cloud) and then only Exoplayer can stream HLS?\r\n\r\nWill wait to hear from you\r\n\r\nThanks & Regards\r\nKumar Vansh Moondra"
    },
    "satisfaction_conditions": [
      "Player must support adaptive bitrate (ABR) streaming when using adaptive streaming formats (DASH, HLS, SmoothStreaming)",
      "Player must clearly indicate format compatibility for ABR functionality",
      "Player's behavior must be predictable based on input format",
      "Documentation must clarify the relationship between media format and ABR capability"
    ],
    "created_at": "2020-08-02T16:16:42Z"
  },
  {
    "id": "https://github.com/google/ExoPlayer/issues/7564",
    "source": {
      "issue_number": 7564
    },
    "initial_question": {
      "title": "Setting initial startup buffer size/time for Dash playback",
      "body": "### [REQUIRED] Searched documentation and issues\r\n\r\n### [REQUIRED]We have a question of how to set the initial buffer size/time for DASH playback.\r\n\r\nWe are using the below parameter, wanted a confirmation if this is enough. Our chunk size is 4s.\r\n\r\n /**\r\n     * The default duration of media that must be buffered for playback to start or resume following a\r\n     * user action such as a seek, in milliseconds.\r\n     */\r\n    public static final int DEFAULT_BUFFER_FOR_PLAYBACK_MS = 1000; //start after downloading 1 chunk\r\n\r\nIf we use this above value for loadControl, does this mean dash file will start playing after 1s of audio + video data (i.e. 1st chunk) is downloaded?\r\n\r\n"
    },
    "satisfaction_conditions": [
      "Playback must start when the minimum required buffer duration is reached",
      "Buffer duration settings must be independent of segment/chunk size",
      "Solution must support faster startup time without requiring full segment download",
      "Buffer configuration must handle both audio and video streams",
      "Buffer settings must balance startup speed against rebuffering risk"
    ],
    "created_at": "2020-06-30T07:38:12Z"
  },
  {
    "id": "https://github.com/google/ExoPlayer/issues/7525",
    "source": {
      "issue_number": 7525
    },
    "initial_question": {
      "title": "Accessing active datasource in onPositionDiscontinuity",
      "body": "### [REQUIRED] Searched documentation and issues\r\n\r\nI did :)\r\n\r\n### [REQUIRED] Question\r\nI'm having an hard time to get the active datasource when the media change in a ```ConcatenatingMediaSource```.\r\n\r\nI use a specific ```DataSourceFactory``` that extends ```HttpDataSource.BaseFactory``` and prepare the media in the ```open(dataSpec)```.\r\nDuring this preparation the media can be transcoded or not and depending on many factor the resulting may support some things like seeking or not.\r\nI need to be able to access this information to do things like not calling normal seek but restart the transcoding at the new position.\r\n\r\nThe problem is that in ```ConcatenatingMediaSource``` ```open``` can be called to prepare the next media while the active media is still not closed.\r\n\r\nSo the question is how can I access the datasource from the player ```onPositionDiscontinuity``` callback. Or how can I access the ```MediaSource``` from the ```DataSource``` to be able to modify the tag?\r\n"
    },
    "satisfaction_conditions": [
      "Access to transcoding status information must be available when position discontinuity occurs",
      "Information about media properties must be accessible across different threads",
      "Solution must work with concurrent media preparation",
      "Media source and associated properties must remain correctly mapped during playback",
      "Solution must be compatible with playlist functionality"
    ],
    "created_at": "2020-06-18T18:31:36Z"
  },
  {
    "id": "https://github.com/google/ExoPlayer/issues/7450",
    "source": {
      "issue_number": 7450
    },
    "initial_question": {
      "title": "How to remove ICY header request",
      "body": "Hi,\r\n\r\nI was trying to find a way on how to remove the ICY header from the header request. I'm expecting it is causing some issues with certein hosting server.\r\n\r\ni have been trying many things without success e.g. \r\n\r\n```\r\nfinal HttpDataSource.RequestProperties s = dataSourceFactory.getDefaultRequestProperties();\r\ns.remove(IcyHeaders.REQUEST_HEADER_ENABLE_METADATA_NAME);\r\n```\r\n\r\nOR \r\n\r\n```\r\nfinal ProgressiveMediaSource audioSource2 =\r\nnew ProgressiveMediaSource.Factory(() -> {\r\n\tfinal HttpDataSource dataSource = new DefaultHttpDataSource(Util.getUserAgent(this, getString(R.string.app_name)))\r\n\t{\r\n\t\t@Override\r\n\t\tpublic long open(DataSpec dataSpec) throws HttpDataSourceException\r\n\t\t{\r\n\t\t\tdataSpec.httpRequestHeaders.remove(IcyHeaders.REQUEST_HEADER_ENABLE_METADATA_NAME);\r\n\t\t\treturn super.open(dataSpec);\r\n\t\t}\r\n\t};\r\n\t//dataSource.clearRequestProperty(IcyHeaders.REQUEST_HEADER_ENABLE_METADATA_NAME);\r\n\treturn dataSource;\r\n}).createMediaSource(Uri.parse(url));\r\n```\r\n\r\nthe last one throws:\r\n```\r\n2020-05-31 17:45:56.863 9747-10339/com.myapp.audiocataloger E/LoadTask: Unexpected exception loading stream\r\n      java.lang.UnsupportedOperationException\r\n        at java.util.Collections$UnmodifiableMap.remove(Collections.java:1502)\r\n        at com.myapp.audiocataloger.MediaService$4.open(MediaService.java:813)\r\n        at com.google.android.exoplayer2.upstream.StatsDataSource.open(StatsDataSource.java:83)\r\n        at com.google.android.exoplayer2.source.ProgressiveMediaPeriod$ExtractingLoadable.load(ProgressiveMediaPeriod.java:956)\r\n        at com.google.android.exoplayer2.upstream.Loader$LoadTask.run(Loader.java:391)\r\n        at java.util.concurrent.ThreadPoolExecutor.processTask(ThreadPoolExecutor.java:1187)\r\n        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1152)\r\n        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:641)\r\n        at java.lang.Thread.run(Thread.java:784)\r\n```\r\n\r\nI tried as well to override it in TransferListener without success as well\r\n\r\n```\r\nfinal TransferListener transferListener = new TransferListener()\r\n{\r\n\t@Override\r\n\tpublic void onTransferInitializing(DataSource dataSource, DataSpec dataSpec, boolean isNetwork)\r\n\t{\r\n\t\t// Override it here\r\n\t}\r\n\r\n\t@Override\r\n\tpublic void onTransferStart(DataSource dataSource, DataSpec dataSpec, boolean b){}\r\n\r\n\t@Override\r\n\tpublic void onBytesTransferred(DataSource dataSource, DataSpec dataSpec, boolean b, int i){}\r\n\r\n\t@Override\r\n\tpublic void onTransferEnd(DataSource dataSource, DataSpec dataSpec, boolean b){}\r\n};\r\n```\r\n\r\nPlease advise the proper way to do this.\r\n"
    },
    "satisfaction_conditions": [
      "ICY header is successfully removed from HTTP requests",
      "HTTP requests complete successfully without exceptions",
      "Other request headers remain unaffected",
      "Web server accepts and processes the modified requests"
    ],
    "created_at": "2020-05-31T13:53:32Z"
  },
  {
    "id": "https://github.com/google/ExoPlayer/issues/7443",
    "source": {
      "issue_number": 7443
    },
    "initial_question": {
      "title": "onMetadataChanged callback not getting updated properly",
      "body": "### [REQUIRED] Searched documentation and issues\r\nI've looked pretty thoroughly through the documentation but am not able to figure this out.\r\n\r\n### [REQUIRED] Question\r\nI started with the demo app from IO18, \"Building feature-rich media apps with ExoPlayer (Google I/O '18)\". Currently I have my ExoPlayer version 2.9.6 wrapped in a service. It is using MediaSessionConnector and PlayerNotificationManager. The app can add songs to the playlist from any fragment in the app, and they play fine, but the fragments are not receiving correct notifications as to the current song. They receive notifications that a song has changed but the metadata for that song is always the first song added to the playlist, not the current song.\r\n\r\nThe fragment has a MediaControllerCompat that it initializes with the \"global\" session token and registers a MediaControllerCallback instance. It is this callback that doesn't get up-to-date metadata, only the metadata from the the first song played from the playlist.\r\n\r\nSo am I going about this the wrong way, forgetting a step, or did I miss something obvious?\r\n\r\nI am not using a PlayerView. Songs are added via Intents and the ACTION_ADD_TO_PLAYLIST action.\r\n\r\nFor what it is worth, here is my code, warts and all:\r\n\r\n```\r\n\r\npublic class AudioPlayerService extends Service {\r\n\r\n    public static final String TAG = \"AudioPlayerService\";\r\n    public static final int ACTION_START_SERVICE = 0;\r\n    public static final int ACTION_ADD_TO_PLAYLIST = 1;\r\n    public static final String SERVICE_ACTION = \"service_action\";\r\n    public static final String SERVICE_DETAIL = \"service_detail\";\r\n    public static final String BUNDLED_LISTENER = \"bundled_listener\";\r\n    public static final String TOKEN_VAL = \"bundled_token\";\r\n\r\n    private SimpleExoPlayer player;\r\n    private PlayerNotificationManager playerNotificationManager;\r\n    private MediaSessionCompat mediaSession;\r\n    private MediaSessionConnector mediaSessionConnector;\r\n    private final IBinder mBinder = new LocalBinder();\r\n\r\n    ConcatenatingMediaSource concatenatingMediaSource;\r\n    CacheDataSourceFactory cacheDataSourceFactory;\r\n\r\n    private MusicRepo musicRepo;\r\n    private MediaSessionCompat.Token mMediaSessionToken;\r\n\r\n    @Override\r\n    public void onCreate() {\r\n\r\n        super.onCreate();\r\n        Log.i(TAG, \"onCreate\");\r\n        final Context context = this;\r\n\r\n        player = ExoPlayerFactory.newSimpleInstance(context, new DefaultTrackSelector());\r\n\r\n        DefaultDataSourceFactory dataSourceFactory = new DefaultDataSourceFactory(\r\n                context, Util.getUserAgent(context, getString(R.string.app_name)));\r\n\r\n        cacheDataSourceFactory = new CacheDataSourceFactory(\r\n                DownloadUtil.getCache(context),\r\n                dataSourceFactory,\r\n                CacheDataSource.FLAG_IGNORE_CACHE_ON_ERROR);\r\n\r\n        concatenatingMediaSource = new ConcatenatingMediaSource();\r\n\r\n        player.setPlayWhenReady(true);\r\n\r\n        musicRepo = MusicRepo.get(getApplicationContext());\r\n        playerNotificationManager = PlayerNotificationManager.createWithNotificationChannel(\r\n                context,\r\n                PLAYBACK_CHANNEL_ID,\r\n                R.string.playback_channel_name,\r\n                PLAYBACK_NOTIFICATION_ID,\r\n                new MediaDescriptionAdapter() {\r\n                    @Override\r\n                    public String getCurrentContentTitle(Player player) {\r\n\r\n                        //int index = player.getCurrentWindowIndex();\r\n\r\n                        Log.d(TAG, \"Current Tag\" + player.getCurrentTag());\r\n\r\n                        Object mediaTag = player.getCurrentTag();\r\n                        if (mediaTag != null) {\r\n                            Song song = musicRepo.GetSongByMediaId(mediaTag.toString());\r\n                            if (song != null) {\r\n                                return song.title;\r\n                            }\r\n                        }\r\n\r\n                        return null;\r\n                    }\r\n\r\n                    @Nullable\r\n                    @Override\r\n                    public PendingIntent createCurrentContentIntent(Player player) {\r\n                        return null;\r\n                    }\r\n\r\n                    @Nullable\r\n                    @Override\r\n                    public String getCurrentContentText(Player player) {\r\n//                        return SAMPLES[player.getCurrentWindowIndex()].description;\r\n\r\n                        //int index = player.getCurrentWindowIndex();\r\n\r\n                        Log.d(TAG, \"Current Tag\" + player.getCurrentTag());\r\n\r\n                        Object mediaTag = player.getCurrentTag();\r\n                        if (mediaTag != null) {\r\n                            Song song = musicRepo.GetSongByMediaId(mediaTag.toString());\r\n                            if (song != null) {\r\n                                return song.description;\r\n                            }\r\n                        }\r\n\r\n                        return null;\r\n\r\n                    }\r\n\r\n                    @Nullable\r\n                    @Override\r\n                    public Bitmap getCurrentLargeIcon(Player player, BitmapCallback callback) {\r\n                        Log.d(TAG, \"Current Tag\" + player.getCurrentTag());\r\n\r\n                        Object mediaTag = player.getCurrentTag();\r\n                        if (mediaTag != null) {\r\n                            Song song = musicRepo.GetSongByMediaId(mediaTag.toString());\r\n                            if (song != null) {\r\n                                return MusicRepo.getBitmap( getApplicationContext(), song.bitmapResource);\r\n                            }\r\n                        }\r\n\r\n                        return null;\r\n\r\n//                        return Samples.getBitmap(\r\n//                                context, SAMPLES[player.getCurrentWindowIndex()].bitmapResource);\r\n                    }\r\n                }\r\n        );\r\n        playerNotificationManager.setUseChronometer(true);\r\n        playerNotificationManager.setNotificationListener(new NotificationListener() {\r\n            @Override\r\n            public void onNotificationStarted(int notificationId, Notification notification) {\r\n                startForeground(notificationId, notification);\r\n            }\r\n\r\n            @Override\r\n            public void onNotificationCancelled(int notificationId) {\r\n                stopSelf();\r\n            }\r\n        });\r\n\r\n        playerNotificationManager.setUseChronometer(true);\r\n        playerNotificationManager.setPlayer(player);\r\n\r\n        mediaSession = new MediaSessionCompat(context, MEDIA_SESSION_TAG);\r\n        mediaSession.setActive(true);\r\n        mMediaSessionToken = mediaSession.getSessionToken();\r\n        Log.d(TAG, \"Media Session Token: \" + mMediaSessionToken.toString());\r\n        playerNotificationManager.setMediaSessionToken(mMediaSessionToken);\r\n\r\n        mediaSessionConnector = new MediaSessionConnector(mediaSession);\r\n        mediaSessionConnector.setQueueNavigator(new TimelineQueueNavigator(mediaSession) {\r\n            @Override\r\n            public MediaDescriptionCompat getMediaDescription(Player player, int windowIndex) {\r\n                Log.d(TAG, \"getMediaDescription: QueueNavigator: \" + windowIndex);\r\n\r\n                Object tag = player.getCurrentTag();\r\n                if (tag != null) {\r\n                    String mediaId = tag.toString();\r\n                    Song song = musicRepo.GetSongByMediaId(mediaId);\r\n                    if (song != null) {\r\n                        return MusicRepo.getMediaDescription( AudioPlayerService.this, song);\r\n                    }\r\n                }\r\n                //return Samples.getMediaDescription(context, SAMPLES[windowIndex]);\r\n                return null;\r\n            }\r\n\r\n        });\r\n        mediaSessionConnector.setPlayer(player, null);\r\n        //mediaSession.setActive(true);\r\n    }\r\n\r\n    @Override\r\n    public void onDestroy() {\r\n        mediaSession.release();\r\n        mediaSessionConnector.setPlayer(null, null);\r\n        playerNotificationManager.setPlayer(null);\r\n        player.release();\r\n        player = null;\r\n\r\n        super.onDestroy();\r\n    }\r\n\r\n    @Nullable\r\n    @Override\r\n    public IBinder onBind(Intent intent) {\r\n        return mBinder;\r\n    }\r\n\r\n    @Override\r\n    public int onStartCommand(Intent intent, int flags, int startId) {\r\n        int action = intent.getIntExtra(SERVICE_ACTION, ACTION_START_SERVICE);\r\n        switch (action) {\r\n            case ACTION_START_SERVICE:\r\n\r\n                Log.d(TAG, \"onStartCommand: ACTION_START_SERVICE \");\r\n                //don't need this now that service is bound\r\n//                ResultReceiver receiver = intent.getParcelableExtra(AudioPlayerService.BUNDLED_LISTENER);\r\n//                Bundle bundle = new Bundle();\r\n//                bundle.putParcelable(TOKEN_VAL, mMediaSessionToken);\r\n//                receiver.send(Activity.RESULT_OK, bundle);\r\n                return START_STICKY;\r\n\r\n            case ACTION_ADD_TO_PLAYLIST:\r\n\r\n                Log.d(TAG, \"onStartCommand: ACTION_ADD_TO_PLAYLIST \");\r\n                int detailId = intent.getIntExtra(SERVICE_DETAIL, 0) ;\r\n                DetailedSelection detail = DetailedSelection.toDetailedSelection(detailId);\r\n                Log.d(TAG, \"onStartCommand: Adding to playlist \" + detail);\r\n                addToPlaylist(detail);\r\n\r\n            break;\r\n        }\r\n        return START_STICKY;\r\n    }\r\n\r\n    @Override\r\n    public void onLowMemory() {\r\n        super.onLowMemory();\r\n    }\r\n\r\n    private void addToPlaylist(DetailedSelection detail) {\r\n\r\n        Log.d(TAG, \"Adding to playlist detail: \" + detail);\r\n\r\n        MusicRepo musicRepo = MusicRepo.get(this);\r\n\r\n        Song song = musicRepo.GetPrimarySong(detail);\r\n        Log.d(TAG, \"Adding Song: \" + song.mediaId + \" \" + song.title);\r\n\r\n/*\r\n        Samples.Sample sample = null;\r\n        if (detail.getValue() % 2 == 0) {\r\n            sample = SAMPLES[0];\r\n        }\r\n        else {\r\n           sample = SAMPLES[1];\r\n        }\r\n*/\r\n        MediaSource mediaSource = new ExtractorMediaSource.Factory(cacheDataSourceFactory)\r\n                .setTag(song.mediaId)//add in tag for unique identifier of song\r\n                .createMediaSource(song.uri);\r\n\r\n        concatenatingMediaSource.addMediaSource(mediaSource);\r\n        /*\r\n        for (Samples.Sample sample : SAMPLES) {\r\n            MediaSource mediaSource = new ExtractorMediaSource.Factory(cacheDataSourceFactory)\r\n                    .createMediaSource(sample.uri);\r\n            concatenatingMediaSource.addMediaSource(mediaSource);\r\n        }\r\n\r\n        */\r\n\r\n        //player.prepare(concatenatingMediaSource, false, false);\r\n        player.prepare(concatenatingMediaSource);\r\n      //  player.\r\n      //  player.getMetadataComponent().notifyAll();\r\n//        if ( player.getPlaybackState() == Player.STATE_READY && player.getPlayWhenReady()) {\r\n//\r\n//        }\r\n//        else {\r\n//            player.setPlayWhenReady(true);\r\n//        }\r\n\r\n\r\n    }\r\n\r\n    /** method for clients */\r\n    public int Pause() {\r\n        Log.d(TAG, \"Pause: \");\r\n\r\n        return 0;\r\n    }\r\n\r\n    public int Add(DetailedSelection mDetailedSelection) {\r\n\r\n        Log.d(TAG, \"Adding selection \" + mDetailedSelection);\r\n        player.setPlayWhenReady(true);\r\n        return 0;\r\n\r\n    }\r\n\r\n    public static Intent GetFactoryIntent(Context ctx) {\r\n\r\n        Intent intent = new Intent(ctx, AudioPlayerService.class);\r\n        intent.putExtra(SERVICE_ACTION, ACTION_START_SERVICE);\r\n        return intent;\r\n    }\r\n    public static Intent GetAddToPlaylistIntent(Context ctx, DetailedSelection detail ) {\r\n\r\n        Intent intent = new Intent(ctx, AudioPlayerService.class);\r\n        intent.putExtra(SERVICE_ACTION, ACTION_ADD_TO_PLAYLIST);\r\n        intent.putExtra(SERVICE_DETAIL, detail.getValue());\r\n        return intent;\r\n\r\n    }\r\n\r\n    public MediaSessionCompat.Token getMediaSessionToken() {\r\n        return mMediaSessionToken;\r\n    }\r\n\r\n    public class LocalBinder extends Binder {\r\n        public AudioPlayerService getService() {\r\n            return AudioPlayerService.this;\r\n        }\r\n    }\r\n```\r\n\r\nAnd here is the fragment that is not getting updated properly. Right now the songs are started in another fragment, play fine in the NotificationArea, so the buttons don't really mean anything. The session token is shared via a common view model. Mostly I wonder why the code in `onMetadataChanged` is not working as expected.\r\n\r\n```\r\n\r\npublic class HomeFragment extends Fragment {\r\n\r\n    private String TAG = getClass().getSimpleName();\r\n\r\n    private MediaSessionCompat.Token mToken;\r\n    private PlayerView mPlayerView;\r\n    private MediaControllerCompat mMediaController;\r\n    private MediaControllerCallback mControllerCallback;\r\n    private boolean mControllerRegistered = false;\r\n\r\n    private Button btn1;\r\n    private Button btn2;\r\n    private CheckBox checkBox1;\r\n    private CheckBox checkBox2;\r\n\r\n    public View onCreateView(@NonNull LayoutInflater inflater,\r\n                             ViewGroup container, Bundle savedInstanceState) {\r\n\r\n        View root = inflater.inflate(R.layout.fragment_home, container, false);\r\n        final TextView textView = root.findViewById(R.id.text_home);\r\n\r\n\r\n        final Button button = root.findViewById(R.id.button_token);\r\n      //  button.setOnClickListener(v -> Toast.makeText(this, \"Button clicked\", Toast.LENGTH_LONG).show());\r\n        button.setOnClickListener(view -> {\r\n            Activity activity  =  getActivity();\r\n            if (activity != null) {\r\n                if (activity instanceof IMainActivity) {\r\n                    mToken = ((IMainActivity)activity).getSessionToken();\r\n                    if (mToken != null) {\r\n                        Log.i(TAG, mToken.toString());\r\n                    }\r\n                }\r\n            }\r\n        });\r\n\r\n        final Button button_playlist = root.findViewById(R.id.button_playlist);\r\n        button_playlist.setOnClickListener(new View.OnClickListener() {\r\n            @Override\r\n            public void onClick(View view) {\r\n                Log.i(TAG, \"trying to get playlist\");\r\n                try {\r\n                    MediaControllerCompat mcc = new MediaControllerCompat(getContext(), HomeFragment.this.mToken);\r\n                    //mcc.get\r\n                    List<MediaSessionCompat.QueueItem> queue = mcc.getQueue();\r\n                    if (queue != null) {\r\n                        Log.i(TAG, \"queue not null\");\r\n                       //  Log.i(TAG, queue.toString());\r\n                         for (MediaSessionCompat.QueueItem item : queue) {\r\n                             Log.i(TAG, \"qi:\" + item.toString());\r\n                         }\r\n                    }\r\n                    else {\r\n                        Log.i(TAG, \"queue NULL\");\r\n                    }\r\n                } catch (RemoteException e) {\r\n                    e.printStackTrace();\r\n                }\r\n\r\n\r\n            }\r\n        });\r\n      //  mPlayerView = root.findViewById(R.id.player_view);\r\n\r\n        btn1 = root.findViewById(R.id.btn_play_1);\r\n        btn2 = root.findViewById(R.id.btn_play_2);\r\n        checkBox1 = root.findViewById(R.id.chbox_is_playing_1);\r\n        checkBox2 = root.findViewById(R.id.chbox_is_playing_2);\r\n        btn1.setOnClickListener(v -> {\r\n\r\n            Log.i(TAG, \"btn1 Clicked\");\r\n\r\n        });\r\n        btn2.setOnClickListener(v -> {\r\n                Log.i(TAG, \"btn2 Clicked\");\r\n        });\r\n\r\n        return root;\r\n    }\r\n    @Override\r\n    public void onViewCreated(@NonNull View view, Bundle savedInstanceState) {\r\n\r\n        super.onViewCreated(view, savedInstanceState);\r\n        MainViewModel mainVm = new ViewModelProvider (requireActivity()).get(MainViewModel.class);\r\n\r\n        mainVm.getName().observe(getViewLifecycleOwner(), s -> {\r\n            Log.i(TAG, \"Name = \" + s);\r\n        });\r\n        //\r\n        mainVm.getToken().observe(getViewLifecycleOwner(), token -> {\r\n            Log.i(TAG, \"Token = \" + token);\r\n            try {\r\n\r\n                if (mControllerRegistered) {\r\n                    return;\r\n                }\r\n\r\n                mMediaController = new MediaControllerCompat(getActivity(), token);\r\n                if (mControllerCallback == null) {\r\n                    mControllerCallback = new HomeFragment.MediaControllerCallback();\r\n                }\r\n                Log.i(TAG, \"Registered!!!\");\r\n                mMediaController.registerCallback(mControllerCallback);\r\n                mControllerRegistered = true;\r\n           //     registerController();\r\n//                mControllerCallback = new HomeFragment.MediaControllerCallback();\r\n//                mMediaController.registerCallback(mControllerCallback);\r\n//                mControllerRegistered = true;\r\n\r\n\r\n            }\r\n\r\n            catch(RemoteException ex) {\r\n                Log.e(TAG, ex.getMessage());\r\n                ex.printStackTrace();\r\n\r\n            }\r\n\r\n        });\r\n\r\n    }\r\n    @Override\r\n    public void onDestroyView() {\r\n        super.onDestroyView();\r\n        Log.e(TAG, \"View Destroyed\");\r\n        unRegisterController();\r\n    }\r\n    @Override\r\n    public void onAttach(Context context) {\r\n\r\n        super.onAttach(context);\r\n        Log.i(TAG, \"onAttach\");\r\n       // registerController();\r\n\r\n\r\n\r\n    }\r\n\r\n    @Override\r\n    public void onDetach() {\r\n\r\n        super.onDetach();\r\n        Log.i(TAG, \"onDetach\");\r\n        unRegisterController();\r\n\r\n    }\r\n\r\n    private void registerController() {\r\n\r\n\r\n    }\r\n    private void unRegisterController() {\r\n\r\n        if (mControllerRegistered) {\r\n            mMediaController.unregisterCallback(mControllerCallback);\r\n            mControllerRegistered = false;\r\n        }\r\n\r\n    }\r\n    private static class MediaControllerCallback extends MediaControllerCompat.Callback {\r\n\r\n        private static final String TAG = \"HomeFragment:MCC\";\r\n        @Override\r\n        public void onPlaybackStateChanged(@Nullable final PlaybackStateCompat state) {\r\n            Log.i(TAG, \"onPlaybackStateChanged: \" + state.toString());\r\n            long queueId =  state.getActiveQueueItemId();\r\n            Log.i(TAG, \"onPlaybackStateChanged: qid \" + queueId);\r\n        }\r\n        @Override\r\n        public void onMetadataChanged(final MediaMetadataCompat metadata) {\r\n            // Filtering out needless updates, given that the metadata has not changed.\r\n            Log.i(TAG, \"onMetadataChanged\");\r\n            if (metadata != null) {\r\n                Log.i(TAG, \"onMetadataChanged: \" + metadata.toString());\r\n                Set<String> keys = metadata.keySet();\r\n\r\n                String mediaId = metadata.getString(MediaMetadataCompat.METADATA_KEY_MEDIA_ID);\r\n                String title = metadata.getString(MediaMetadataCompat.METADATA_KEY_TITLE);\r\n                Log.i(TAG, \"MediaId: \" +  mediaId);\r\n                Log.i(TAG, \"Title: \" +  title);\r\n            }\r\n        }\r\n        @Override\r\n        public void onQueueChanged (List<MediaSessionCompat.QueueItem> queue) {\r\n            Log.i(TAG, \"onQueueChanged\");\r\n            int queueCount = queue.size();\r\n            for(MediaSessionCompat.QueueItem item : queue) {\r\n\r\n            }\r\n            Log.i(TAG, \"onQueueChanged: size \" + queueCount);\r\n        }\r\n        @Override\r\n        public void onQueueTitleChanged (CharSequence title) {\r\n            Log.i(TAG, \"onQueueTitleChanged: \" + title);\r\n        }\r\n        @Override\r\n        public void onSessionDestroyed ()\r\n        {\r\n            Log.i(TAG, \"onSessionDestroyed: \" );\r\n        }\r\n    }\r\n```"
    },
    "satisfaction_conditions": [
      "Media metadata updates must reflect the currently playing item in the playlist",
      "Media descriptions must be correctly mapped to each item in the player timeline",
      "MediaController callbacks must receive accurate metadata for all playlist position changes",
      "Media session queue must contain accurate descriptions for all playlist items"
    ],
    "created_at": "2020-05-29T01:55:47Z"
  },
  {
    "id": "https://github.com/google/ExoPlayer/issues/7426",
    "source": {
      "issue_number": 7426
    },
    "initial_question": {
      "title": "\"*mp4?type=m3u8\" cause error media source",
      "body": "### [REQUIRED] Searched documentation and issues\r\n\r\n### [REQUIRED] Question\r\nThe movie link end with **\"mp4?type=m3u8\"**, use exo player with `TYPE_OTHER` to watch the movie, and then it caused `UnrecognizedInputFormatException`. But my android platform support the video format, I try again with `TYPE_HLS`, it works well. \r\n**Is there any good ways to solve it?**\r\n\r\n### A full bug report captured from the device\r\n```\r\nExoPlayer: mExoEventListener - onPlayerStateChanged: playWhenReady = true, playbackState = 2\r\nExoPlayer: mExoEventListener: playbackState = STATE_BUFFERING 0 - 0\r\nEventLogger: timeline [eventTime=0.01, mediaPos=0.00, window=0, periodCount=1, windowCount=1, reason=PREPARED\r\nEventLogger:   period [?]\r\nEventLogger:   window [?, false, false]\r\nEventLogger: ]\r\nExoPlayer: mExoEventListener: onTimelineChanged-----timeline com.google.android.exoplayer2.source.SinglePeriodTimeline@214da72\r\nEventLogger: mediaPeriodCreated [eventTime=0.02, mediaPos=0.00, window=0, period=0]\r\nEventLogger: loading [eventTime=0.02, mediaPos=0.00, window=0, period=0, true]\r\nExoPlayer: mExoEventListener: onLoadingChanged-----isLoading true\r\nUsbService.NetworkService: usbFile.exists() =false\r\nEventLogger: internalError [eventTime=2.09, mediaPos=0.00, window=0, period=0, loadError\r\nEventLogger:   com.google.android.exoplayer2.source.UnrecognizedInputFormatException: None of the available extractors (MatroskaExtractor, FragmentedMp4Extractor, Mp4Extractor, Mp3Extractor, AdtsExtractor, Ac3Extractor, TsExtractor, FlvExtractor, OggExtractor, PsExtractor, WavExtractor, AmrExtractor, Ac4Extractor, FlacExtractor) could read the stream.\r\nEventLogger:       at com.google.android.exoplayer2.source.ProgressiveMediaPeriod$ExtractorHolder.selectExtractor(ProgressiveMediaPeriod.java:1090)\r\nEventLogger:       at com.google.android.exoplayer2.source.ProgressiveMediaPeriod$ExtractingLoadable.load(ProgressiveMediaPeriod.java:969)\r\nEventLogger:       at com.google.android.exoplayer2.upstream.Loader$LoadTask.run(Loader.java:391)\r\nEventLogger:       at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1133)\r\nEventLogger:       at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:607)\r\nEventLogger:       at java.lang.Thread.run(Thread.java:761)\r\nEventLogger: ]\r\nExoPlayerImplInternal: Source error\r\nExoPlayerImplInternal:   com.google.android.exoplayer2.source.UnrecognizedInputFormatException: None of the available extractors (MatroskaExtractor, FragmentedMp4Extractor, Mp4Extractor, Mp3Extractor, AdtsExtractor, Ac3Extractor, TsExtractor, FlvExtractor, OggExtractor, PsExtractor, WavExtractor, AmrExtractor, Ac4Extractor, FlacExtractor) could read the stream.\r\nExoPlayerImplInternal:       at com.google.android.exoplayer2.source.ProgressiveMediaPeriod$ExtractorHolder.selectExtractor(ProgressiveMediaPeriod.java:1090)\r\nExoPlayerImplInternal:       at com.google.android.exoplayer2.source.ProgressiveMediaPeriod$ExtractingLoadable.load(ProgressiveMediaPeriod.java:969)\r\nExoPlayerImplInternal:       at com.google.android.exoplayer2.upstream.Loader$LoadTask.run(Loader.java:391)\r\nExoPlayerImplInternal:       at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1133)\r\nExoPlayerImplInternal:       at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:607)\r\nExoPlayerImplInternal:       at java.lang.Thread.run(Thread.java:761)\r\nEventLogger: mediaPeriodReleased [eventTime=2.09, mediaPos=0.00, window=0, period=0]\r\nEventLogger: playerFailed [eventTime=2.09, mediaPos=0.00, window=0, period=0\r\nEventLogger:   com.google.android.exoplayer2.ExoPlaybackException: com.google.android.exoplayer2.source.UnrecognizedInputFormatException: None of the available extractors (MatroskaExtractor, FragmentedMp4Extractor, Mp4Extractor, Mp3Extractor, AdtsExtractor, Ac3Extractor, TsExtractor, FlvExtractor, OggExtractor, PsExtractor, WavExtractor, AmrExtractor, Ac4Extractor, FlacExtractor) could read the stream.\r\nEventLogger:       at com.google.android.exoplayer2.ExoPlayerImplInternal.handleMessage(ExoPlayerImplInternal.java:394)\r\nEventLogger:       at android.os.Handler.dispatchMessage(Handler.java:98)\r\nEventLogger:       at android.os.Looper.loop(Looper.java:154)\r\nEventLogger:       at android.os.HandlerThread.run(HandlerThread.java:61)\r\nEventLogger:   Caused by: com.google.android.exoplayer2.source.UnrecognizedInputFormatException: None of the available extractors (MatroskaExtractor, FragmentedMp4Extractor, Mp4Extractor, Mp3Extractor, AdtsExtractor, Ac3Extractor, TsExtractor, FlvExtractor, OggExtractor, PsExtractor, WavExtractor, AmrExtractor, Ac4Extractor, FlacExtractor) could read the stream.\r\nEventLogger:       at com.google.android.exoplayer2.source.ProgressiveMediaPeriod$ExtractorHolder.selectExtractor(ProgressiveMediaPeriod.java:1090)\r\nEventLogger:       at com.google.android.exoplayer2.source.ProgressiveMediaPeriod$ExtractingLoadable.load(ProgressiveMediaPeriod.java:969)\r\nEventLogger:       at com.google.android.exoplayer2.upstream.Loader$LoadTask.run(Loader.java:391)\r\nEventLogger:       at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1133)\r\nEventLogger:       at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:607)\r\nEventLogger:       at java.lang.Thread.run(Thread.java:761)\r\nEventLogger: ]\r\nExoPlayer: onPlayerError: error type : TYPE_SOURCE, com.google.android.exoplayer2.source.UnrecognizedInputFormatException: None of the available extractors (MatroskaExtractor, FragmentedMp4Extractor, Mp4Extractor, Mp3Extractor, AdtsExtractor, Ac3Extractor, TsExtractor, FlvExtractor, OggExtractor, PsExtractor, WavExtractor, AmrExtractor, Ac4Extractor, FlacExtractor) could read the stream.\r\nExoPlayer: onPlayerError: com.google.android.exoplayer2.source.UnrecognizedInputFormatException: None of the available extractors (MatroskaExtractor, FragmentedMp4Extractor, Mp4Extractor, Mp3Extractor, AdtsExtractor, Ac3Extractor, TsExtractor, FlvExtractor, OggExtractor, PsExtractor, WavExtractor, AmrExtractor, Ac4Extractor, FlacExtractor) could read the stream.\r\nBaseVideoView: [ciel_debug][onError]: what: -10001,extra: 0\r\n```\r\n\r\n### Link to test content\r\nSorry, the test link is private.\r\n"
    },
    "satisfaction_conditions": [
      "Media player correctly identifies and handles HLS stream format",
      "Player successfully plays media content when URL ends with 'mp4?type=m3u8'",
      "Appropriate media source type is used for HLS content"
    ],
    "created_at": "2020-05-26T10:40:30Z"
  },
  {
    "id": "https://github.com/google/ExoPlayer/issues/7366",
    "source": {
      "issue_number": 7366
    },
    "initial_question": {
      "title": "Is it possible to change video duration after changing video speed?",
      "body": "I have used `setPlaybackParameters` method to change speed of video. Player keep same duration when I increased or decreased speed. But if we apply process on video then if speed increased, video duration decreased and speed decreased, video duration increased. I want to show that in preview using exoplayer. \r\n\r\nPlease guide me.\r\n\r\nThanks"
    },
    "satisfaction_conditions": [
      "Video playback duration must reflect the selected speed setting",
      "UI duration display must accurately represent the adjusted playback duration",
      "Seek operations must maintain proportional positioning relative to adjusted duration",
      "Time calculations must properly convert between actual and speed-adjusted durations"
    ],
    "created_at": "2020-05-12T13:28:41Z"
  },
  {
    "id": "https://github.com/google/ExoPlayer/issues/7276",
    "source": {
      "issue_number": 7276
    },
    "initial_question": {
      "title": "PlayerNotificationManager event onNotificationCanceled is never called",
      "body": "### [REQUIRED] Issue description\r\nHi everyone, \r\n\r\nNotification cannot be swiped and onNotificationCanceled is never called.\r\n\r\n### [REQUIRED] Reproduction steps\r\n```\r\n`\r\n@Override\r\npublic void onCreate() {\r\nsuper.onCreate();\r\n\r\nfinal Context context = this;\r\n\r\nplayer = ExoPlayerFactory.newSimpleInstance(context, new DefaultTrackSelector());\r\n\r\n// playlist preparation\r\n\r\n// player.prepare(concatenatedSource, false, false);\r\nplayer.prepare(playlist);\r\nplayer.setPlayWhenReady(true);\r\n\r\nPlayerNotificationManager.MediaDescriptionAdapter notificationAdapter = new PlayerNotificationManager.MediaDescriptionAdapter() {\r\n    // implementation\r\n};\r\n\r\nPlayerNotificationManager.NotificationListener notificationListener = new PlayerNotificationManager.NotificationListener() {\r\n\r\n    @Override\r\n    public void onNotificationCancelled(int notificationId, boolean dismissedByUser) {\r\n        System.out.println(\"onNotificationCancelled dismissedByUser \"+dismissedByUser);\r\n        stopForeground(true);\r\n    }\r\n\r\n    @Override\r\n    public void onNotificationPosted(int notificationId, Notification notification, boolean ongoing) {\r\n        startForeground(notificationId, notification);\r\n    }\r\n};\r\n\r\nIntent dialogIntent = new Intent(this, PlayerActivity.class);\r\ndialogIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\r\n\r\nstartActivity(dialogIntent);\r\nplayerNotificationManager = PlayerNotificationManager.createWithNotificationChannel(\r\n        context, \"channelId\", R.string.player_activity_name, R.string.player_activity_description, 1, notificationAdapter, notificationListener );\r\nplayerNotificationManager.setPlayer(player);\r\n```\r\n`\r\n\r\n### [REQUIRED] Version of ExoPlayer being used\r\ncom.google.android.exoplayer:exoplayer-core:2.10.5\r\n\r\n### [REQUIRED] Device(s) and version(s) of Android being used\r\n    compileSdkVersion 29\r\n    defaultConfig {\r\n        minSdkVersion 16\r\n        targetSdkVersion 29\r\n\r\nMany thanks !!"
    },
    "satisfaction_conditions": [
      "Notification must be swipeable when player is paused",
      "onNotificationCanceled callback must trigger when notification is dismissed",
      "Foreground service state must align with player state",
      "Service cleanup must occur after notification dismissal"
    ],
    "created_at": "2020-04-21T18:08:56Z"
  },
  {
    "id": "https://github.com/google/ExoPlayer/issues/7175",
    "source": {
      "issue_number": 7175
    },
    "initial_question": {
      "title": "IndexOutOfBoundsException - while checking if media isLive",
      "body": "Hi,\r\n\r\nWhile checking the isLive new API  \r\nin the Demo app in v2.11.3 version I get this exception after executing the below code.\r\nrunning this on Pixel 3 android 10\r\n\r\nNo sure what is the best approach here but I was expecting to get false\r\nunless it should be called only after player is READY\r\n\r\nis there a way to add api that checks is there is a window  before calling get, so this  case can be checked before accessing the window?\r\n\r\ndo you think I should stick to our current logic that uses -  `player.isCurrentWindowDynamic()`\r\n```\r\n     player.prepare(mediaSource, !haveStartPosition, false);\r\n    boolean isLive = false;\r\n    \r\n    if (player.getCurrentTimeline() != null) {\r\n      isLive = player.getCurrentTimeline().getWindow(player.getCurrentWindowIndex(), new Timeline.Window()).isLive;\r\n    }\r\n```\r\n\r\n\r\n10x\r\nGilad.\r\n\r\n2020-04-02 18:02:19.419 13123-13123/com.google.android.exoplayer2.demo E/AndroidRuntime: FATAL EXCEPTION: main\r\n    Process: com.google.android.exoplayer2.demo, PID: 13123\r\n    java.lang.IndexOutOfBoundsException\r\n        at com.google.android.exoplayer2.Timeline$1.getWindow(Timeline.java:550)\r\n        at com.google.android.exoplayer2.Timeline.getWindow(Timeline.java:668)\r\n        at com.google.android.exoplayer2.demo.PlayerActivity.initializePlayer(PlayerActivity.java:412)\r\n        at com.google.android.exoplayer2.demo.PlayerActivity.onStart(PlayerActivity.java:240)\r\n        at android.app.Instrumentation.callActivityOnStart(Instrumentation.java:1432)\r\n        at android.app.Activity.performStart(Activity.java:7848)\r\n        at android.app.ActivityThread.handleStartActivity(ActivityThread.java:3294)\r\n        at android.app.servertransaction.TransactionExecutor.performLifecycleSequence(TransactionExecutor.java:221)\r\n        at android.app.servertransaction.TransactionExecutor.cycleToPath(TransactionExecutor.java:201)\r\n        at android.app.servertransaction.TransactionExecutor.executeLifecycleState(TransactionExecutor.java:173)\r\n        at android.app.servertransaction.TransactionExecutor.execute(TransactionExecutor.java:97)\r\n        at android.app.ActivityThread$H.handleMessage(ActivityThread.java:2016)\r\n        at android.os.Handler.dispatchMessage(Handler.java:107)\r\n        at android.os.Looper.loop(Looper.java:214)\r\n        at android.app.ActivityThread.main(ActivityThread.java:7356)\r\n        at java.lang.reflect.Method.invoke(Native Method)\r\n        at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:492)\r\n        at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:930)\r\n\r\n\r\n"
    },
    "satisfaction_conditions": [
      "Timeline window availability is verified before access",
      "Returns correct live status for media"
    ],
    "created_at": "2020-04-02T15:16:45Z"
  },
  {
    "id": "https://github.com/google/ExoPlayer/issues/7091",
    "source": {
      "issue_number": 7091
    },
    "initial_question": {
      "title": "TrackSelectionView.getDialog is deprecated . what should i use instead ?",
      "body": "Hi guys \r\nI am completely newbie with exoplayer . I want to show the list of quality of hls to user and let the user to choose one of them . I found below code but one part is deprecated in version 2.10. Could someone help me on this case please ? I also tried to find solution on demo app . but there is a lot of code and it make me confused .\r\n```\r\nMappingTrackSelector.MappedTrackInfo mappedTrackInfo = trackSelector.getCurrentMappedTrackInfo();\r\n        if (mappedTrackInfo != null) {\r\n            CharSequence title = \"Video\";\r\n            int rendererIndex = 2;\r\n            int rendererType = mappedTrackInfo.getRendererType(rendererIndex);\r\n            boolean allowAdaptiveSelections =\r\n                    rendererType == C.TRACK_TYPE_VIDEO\r\n                            || (rendererType == C.TRACK_TYPE_AUDIO\r\n                            && mappedTrackInfo.getTypeSupport(C.TRACK_TYPE_VIDEO)\r\n                            == MappingTrackSelector.MappedTrackInfo.RENDERER_SUPPORT_NO_TRACKS);\r\n            Pair<AlertDialog, TrackSelectionView> dialogPair =\r\n                    TrackSelectionView.getDialog(this, title, trackSelector, rendererIndex);\r\n            dialogPair.second.setShowDisableOption(true);\r\n            dialogPair.second.setAllowAdaptiveSelections(allowAdaptiveSelections);\r\n            dialogPair.first.show();\r\n        }\r\n    }\r\n```\r\n\r\nTrackSelectionView.getDialog  is deprecated .Thanks in advance."
    },
    "satisfaction_conditions": [
      "Dialog displays available video quality options from HLS stream",
      "Uses non-deprecated ExoPlayer API methods",
      "Correct renderer index is used to access video tracks",
      "Dialog allows user selection of different quality options"
    ],
    "created_at": "2020-03-15T23:01:01Z"
  },
  {
    "id": "https://github.com/google/ExoPlayer/issues/6979",
    "source": {
      "issue_number": 6979
    },
    "initial_question": {
      "title": "different mimeType between FlacExtractor and LibflacAudioRenderer",
      "body": "Hello, I don't figure out that the mimeType is \"audio/raw\" in FlacExtractor of FLAC extension. However, the specific mimeType is \"audio/flac\" in LibflacAudioRenderer. As s result, LibflacAudioRenderer couldn't work for FlacExtractor."
    },
    "satisfaction_conditions": [
      "FLAC audio content must be successfully decoded and played",
      "Selected components must have matching MIME type expectations",
      "Component combination must be officially supported"
    ],
    "created_at": "2020-02-15T04:13:10Z"
  },
  {
    "id": "https://github.com/google/ExoPlayer/issues/6959",
    "source": {
      "issue_number": 6959
    },
    "initial_question": {
      "title": "Calculating total playback time of a media.",
      "body": "**Scenario**: \r\nI want to calculate the total playback time for a media until the user switches to a different media by going to the next or previous media. \r\n\r\n**Problem**:\r\nI have covered all the possible scenarios except one, when the user switches to the next track/media after playing the media for a while, I'm not able to get the **playbackEndTime**. \r\nWhere **playbackEndTime** is the last known position from where the media was discontinued.\r\n\r\nIn this case the `EventTime.currentPlaybackPositionMs` is always 0 in every Callbacks of the AnalyticsListener. \r\n\r\nPlease correct me if my approach is not appropriate. "
    },
    "satisfaction_conditions": [
      "Maintains accurate timing during playback state changes",
      "Resets tracking appropriately for new media items"
    ],
    "created_at": "2020-02-10T11:25:57Z"
  },
  {
    "id": "https://github.com/google/ExoPlayer/issues/6847",
    "source": {
      "issue_number": 6847
    },
    "initial_question": {
      "title": "Blank screen while switching video from portrait to landscape full screen for DRM enabled videos in DASH format",
      "body": "Issue description:\r\nWhile switching a video from portrait to landscape mode a blank black screen is visible for a sec before showing the video frame.This happens while switching from landscape to portrait also.This is occuring only for the videos which are DRM protected.This is seen only in few devices.It appears in the exoplayer demo app as well.\r\n\r\nReproduction steps:\r\n1.In the exoplayer demo app play the video with DASH+DRM\r\n2.Enable auto rotate option in settings.\r\n3.Rotate the phone to landscape.\r\n4.A blank screen is shown for a sec before the video frame shows up.\r\n5.Switch to portrait again and see the same blank screen\r\n\r\nLink to test content\r\nYou can check any drm enabled video from the demo app for dash stream.\r\n\r\nVersion of ExoPlayer being used\r\n2.9.0\r\n\r\nDevice(s) and version(s) of Android being used\r\n1.Mi Note 7 Pro Android version:9.0--Issue arises\r\n2.Asus Zenfone Max Pro M2. Android version:8.0--Issue arises\r\n3.Real Me 2 Pro. Android version 9.0--No issue\r\n4.Lenovo K5 note. Android Version 6.0--Issue Arises\r\n5.Samsung Galaxy J2 Pro. Andorid version 6.0--No Issue\r\n6.Mi A2. Android Version 9.0--No issue\r\n7.Redmi Note 3. Android Version 6.0--No issue \r\n\r\nCould you please check into this issue.\r\n\r\n\r\n"
    },
    "satisfaction_conditions": [
      "Behavior is consistent with DRM content protection requirements",
      "Issue resolution accounts for device-specific variations",
      "DRM security level compatibility is maintained"
    ],
    "created_at": "2020-01-08T07:37:27Z"
  },
  {
    "id": "https://github.com/google/ExoPlayer/issues/6759",
    "source": {
      "issue_number": 6759
    },
    "initial_question": {
      "title": "How to get BufferInfo in ExoPlayer 2?",
      "body": "Hi,\r\n**BufferInfo** was available in ExoPlayer 1 in the **processOutputBuffer** method, But in curently veresion bufferInfo not exist in **processOutputBuffer**\r\nIn version 1 I had access to **BufferInfo** by extending **MediaCodecAudioRenderer** Class and implementing **processOutputBuffer**\r\nAs you can see below\r\n\r\nVersion 1:\r\n```\r\n@Override\r\nprotected boolean processOutputBuffer(long positionUs,\r\n                                      long elapsedRealtimeUs,\r\n                                      MediaCodec codec,\r\n                                      ByteBuffer buffer,\r\n                                      MediaCodec.BufferInfo bufferInfo, //TODO: BufferInfo\r\n                                      int bufferIndex,\r\n                                      boolean shouldSkip)\r\n        throws com.google.android.exoplayer.ExoPlaybackException {\r\n\r\n    //using bufferInfo\r\n\r\n    return super.processOutputBuffer(positionUs,\r\n            elapsedRealtimeUs,\r\n            codec,\r\n            buffer,\r\n            bufferInfo,\r\n            bufferIndex,\r\n            shouldSkip);\r\n}\r\n```\r\nLast Version:\r\n```\r\n    protected boolean processOutputBuffer(long positionUs,\r\n                                          long elapsedRealtimeUs,\r\n                                          MediaCodec codec,\r\n                                          ByteBuffer buffer,\r\n                                          int bufferIndex,\r\n                                          int bufferFlags,\r\n                                          long bufferPresentationTimeUs,\r\n                                          boolean isDecodeOnlyBuffer,\r\n                                          boolean isLastBuffer,\r\n                                          Format format) throws ExoPlaybackException {\r\n\r\n        return super.processOutputBuffer(positionUs,\r\n                elapsedRealtimeUs,\r\n                codec,\r\n                buffer,\r\n                bufferIndex,\r\n                bufferFlags,\r\n                bufferPresentationTimeUs,\r\n                isDecodeOnlyBuffer,\r\n                isLastBuffer,\r\n                format);\r\n    }\r\n```\r\nAs you can see there is no **BufferInfo** inside **processOutputBuffer** method in the last version\r\nI need to get BufferInfo for read '**size**' and '**offset**' and '**presentationTimeUs**', How to do this in the latest version?"
    },
    "satisfaction_conditions": [
      "All buffer metadata from V1 must be accessible in V2",
      "Buffer timing information must be preserved",
      "Buffer boundary information must be retrievable",
      "Solution must work within ExoPlayer V2's architecture"
    ],
    "created_at": "2019-12-12T14:27:12Z"
  },
  {
    "id": "https://github.com/google/ExoPlayer/issues/6710",
    "source": {
      "issue_number": 6710
    },
    "initial_question": {
      "title": "Exoplayer releases itself when in background",
      "body": "#6386 # [REQUIRED] Searched documentation and issues\r\n\r\nTried searching on Google but didn't find anything relevant.\r\n\r\n### [REQUIRED] Question\r\nI have an app that can play videos. I use a single instance of exoplayer that i initialize in a service so that the user can listen and control the video in background. The problem is that when a video is playing, the user goes into background and then pauses the player for 1-2 minutes exoplayer releases itself. So when the app comes back to the foreground all i have is a black screen playerView with no video in it.\r\n\r\n### A full bug report captured from the device\r\n```\r\n2019-11-29 10:26:51.715 23697-26444/app  D/FA: Application backgrounded\r\n2019-11-29 10:26:51.738 23697-26444/app  D/FA: Logging event (FE): app_background(_ab), Bundle[{ga_event_origin(_o)=auto}]\r\n2019-11-29 10:28:13.053 23697-23697/app  I/ExoPlayerImpl: Release 192e8c2 [ExoPlayerLib/2.10.4] [HWSTK-HF, STK-LX1, HUAWEI, 28] [goog.exo.core, goog.exo.ui, goog.exo.hls]\r\n2019-11-29 10:28:13.080 23697-26655/app  D/android.media.AudioTrack: [HSM] AudioTrace stop() uid: 10308, pid: 23697\r\n2019-11-29 10:28:13.084 23697-25116/app W/ACodec: forcing OMX state to Idle when received shutdown in ExecutingState\r\n2019-11-29 10:28:13.136 23697-25115/app  D/SurfaceUtils: disconnecting from surface 0x723f653010, reason disconnectFromSurface\r\n2019-11-29 10:28:13.167 23697-25127/app  W/ACodec: forcing OMX state to Idle when received shutdown in ExecutingState\r\n```\r\n\r\nAs you can see i backgrounded the video and then pause it. After 1.5 minutes without touching the phone  exoplayer released itself. \r\nI can see how this could be done on purpose to free some resources but is there any way to override this?\r\n\r\nThis is what happens when i bring the app to the foreground:\r\n```\r\n2019-11-29 10:58:47.192 23697-23697/app D/ZrHung.AppEyeUiProbe: notify runnable to start.\r\n2019-11-29 10:58:47.192 23697-23750/app D/ZrHung.AppEyeUiProbe: restart watching\r\n2019-11-29 10:58:47.220 23697-27978/app D/FA: Setting user property (FE): _sid, 1575021527\r\n2019-11-29 10:58:47.278 23697-23768/app D/mali_winsys: EGLint new_window_surface(egl_winsys_display *, void *, EGLSurface, EGLConfig, egl_winsys_surface **, EGLBoolean) returns 0x3000\r\n2019-11-29 10:58:47.289 23697-23697/app I/ExoPlayerImpl: Init aaeb70c [ExoPlayerLib/2.10.4] [HWSTK-HF, STK-LX1, HUAWEI, 28]\r\n2019-11-29 10:58:47.296 23697-27978/app D/FA: Logging event (FE): session_start(_s), Bundle[{ga_event_origin(_o)=auto, ga_session_id(_sid)=1575021527}]\r\n2019-11-29 10:58:47.330 23697-27978/app D/FA: Logging event (FE): app_start, Bundle[{method=app_start, ga_event_origin(_o)=app, ga_screen_class(_sc)=MainActivity, ga_screen_id(_si)=5911828178843061323}]\r\n2019-11-29 10:58:47.454 23697-23697/app I/ViewRootImpl: jank_removeInvalidNode all the node in jank list is out of time\r\n2019-11-29 10:58:47.465 23697-23697/app W/InputMethodManager: startInputReason = 1\r\n2019-11-29 10:58:47.500 23697-27978/app D/FA: Connected to remote service\r\n```\r\n\r\nI'm pretty new at this so i don't really understand what all this means or if it's useful at all.\r\nThanks in advance for your time!\r\n"
    },
    "satisfaction_conditions": [
      "Supports both video and audio-only playback modes"
    ],
    "created_at": "2019-11-29T09:55:01Z"
  },
  {
    "id": "https://github.com/google/ExoPlayer/issues/6707",
    "source": {
      "issue_number": 6707
    },
    "initial_question": {
      "title": "Library source does not match the bytecode for class ImaAdsLoader",
      "body": "While displaying ads with IMA extension and the ProgressiveMediaSource, I am getting the following error. The app crashed just after the preroll ad completes.\r\nOn navigating to the class ImaAdsLoader I get the error \"Library source does not match the bytecode for class ImaAdsLoader\"\r\n`\r\njava.lang.NoSuchMethodError: No virtual method getAdGroupIndexAfterPositionUs(J)I in class Lcom/google/android/exoplayer2/source/ads/AdPlaybackState; or its super classes (declaration of 'com.google.android.exoplayer2.source.ads.AdPlaybackState' appears in /data/app/com.example.exomedia-pEwo-P6MjYGRL3PeKbTLiw==/base.apk)\r\n        at com.google.android.exoplayer2.ext.ima.ImaAdsLoader.getContentProgress(ImaAdsLoader.java:758)\r\n        at com.google.ads.interactivemedia.v3.internal.iu.a(IMASDK:4)\r\n        at com.google.ads.interactivemedia.v3.internal.jh.handleMessage(IMASDK:27)\r\n        at android.os.Handler.dispatchMessage(Handler.java:102)\r\n        at android.os.Looper.loop(Looper.java:193)\r\n        at android.app.ActivityThread.main(ActivityThread.java:6692)\r\n        at java.lang.reflect.Method.invoke(Native Method)\r\n        at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:493)\r\n        at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:858)\r\n`\r\nSteps to reproduce : \r\n    Use the following dependencies \r\n\r\n`    implementation 'com.google.android.exoplayer:exoplayer-core:2.10.7'\r\n    implementation 'com.google.android.exoplayer:exoplayer-ui:2.10.7'\r\n    implementation 'com.google.android.exoplayer:extension-ima:2.9.6'\r\n`\r\n\r\nAnd initiate the playback with the following code:\r\n\r\n`     player=ExoPlayerFactory.newSimpleInstance(this,DefaultTrackSelector())\r\n        player_view.player=player\r\n        adsLoader?.setPlayer(player)\r\n\r\n\r\n        val dataSourceFactory = DefaultDataSourceFactory(\r\n            this,\r\n            \"ExoDemo\")\r\n\r\n        val mediaSource:MediaSource=ProgressiveMediaSource.Factory(dataSourceFactory)\r\n            .createMediaSource(Uri.parse(resources.getString(R.string.media_url_mp4)))\r\n\r\n        val adsMediaSource = AdsMediaSource(mediaSource, dataSourceFactory, adsLoader, player_view)\r\n\r\n\r\n        player?.prepare(adsMediaSource)\r\n        player?.setPlayWhenReady(true)`\r\n\r\n\r\nThe works without any error with the following versions of the libraries and using ExtractorMediaSource:\r\n\r\n`    implementation 'com.google.android.exoplayer:exoplayer-core:2.9.6'\r\n    implementation 'com.google.android.exoplayer:exoplayer-ui:2.9.6'\r\n    implementation 'com.google.android.exoplayer:extension-ima:2.9.6'\r\n`\r\n"
    },
    "satisfaction_conditions": [
      "Library version compatibility is maintained across ExoPlayer components",
      "Pre-roll ad playback completes without application crash",
      "ImaAdsLoader class bytecode matches its library source",
      "AdPlaybackState method calls execute successfully"
    ],
    "created_at": "2019-11-28T03:24:52Z"
  },
  {
    "id": "https://github.com/google/ExoPlayer/issues/6651",
    "source": {
      "issue_number": 6651
    },
    "initial_question": {
      "title": "PlayerNotificationManager not cancellable ",
      "body": "I am using PlayerNotificationManager and attaching it to Exoplayer.\r\nI want to make the notification as cancellable when the video/audio is paused.\r\n\r\nI am using stopForeground(false) when my video is paused but still the notification is non cancellable.\r\n\r\n```\r\n  class MediaConsumptionService : Service(), Player.EventListener {\r\n\r\n    private var player: SimpleExoPlayer? = null\r\n    var image: Bitmap? = null\r\n    private lateinit var playerNotificationManager: PlayerNotificationManager\r\n\r\n    private val NOTIFICATION_CHANNEL_ID = \"playback_channel\"\r\n    private val NOTIFICATION_ID = 2\r\n    private var additionalJson: String? = null\r\n    private var trackId = 0L\r\n    private var trackTitle = \"\"\r\n    private var trackThumbUrl = \"\"\r\n\r\n    override fun onBind(intent: Intent?): IBinder? {\r\n        return null\r\n    }\r\n\r\n    override fun onCreate() {\r\n        super.onCreate()\r\n    }\r\n\r\n    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {\r\n\r\n        player = VideoPlayer.getInstance().player\r\n        player?.addListener(this)\r\n        val context = this\r\n\r\n        val bundle = intent?.extras\r\n        if (bundle != null) {\r\n            trackId = bundle.getLong(MVConstants.PLAYBACK_TRACK_ID, 0)\r\n            trackTitle = bundle.getString(MVConstants.PLAYBACK_TRACK_TITLE, \"\")\r\n            trackThumbUrl = bundle.getString(MVConstants.PLAYBACK_TRACK_THUMB, \"\")\r\n            additionalJson = bundle.getString(MVConstants.MEDIA_JSON, \"\")\r\n            Glide.with(context)\r\n                    .asBitmap()\r\n                    .load(trackThumbUrl)\r\n                    .into(object : CustomTarget<Bitmap>() {\r\n\r\n                        override fun onLoadFailed(errorDrawable: Drawable?) {\r\n                            super.onLoadFailed(errorDrawable)\r\n                            addNotificationToPlayer()\r\n                        }\r\n\r\n                        override fun onResourceReady(resource: Bitmap, transition:\r\n                        Transition<in Bitmap>?) {\r\n                            image = resource\r\n                            addNotificationToPlayer()\r\n                        }\r\n\r\n                        override fun onLoadCleared(placeholder: Drawable?) {\r\n                        }\r\n                    })\r\n\r\n        }\r\n\r\n\r\n        return START_NOT_STICKY\r\n    }\r\n\r\n    private fun addNotificationToPlayer() {\r\n        if (player != null) {\r\n\r\n            playerNotificationManager = createWithNotificationChannel(\r\n                    this,\r\n                    NOTIFICATION_CHANNEL_ID,\r\n                    R.string.playback_channel_name,\r\n                    0,\r\n                    NOTIFICATION_ID,\r\n                    object : MediaDescriptionAdapter {\r\n\r\n                        override fun createCurrentContentIntent(player: Player?): PendingIntent? {\r\n                            val intent = VideoPlayer.getInstance().mediaSessionIntent\r\n                            intent.putExtra(MVConstants.MEDIA_JSON, additionalJson)\r\n                            intent.putExtra(MVConstants.PLAYBACK_TRACK_ID, trackId)\r\n                            intent.putExtra(MVConstants.FROM_NOTIFICATION, true)\r\n                            return PendingIntent.getActivity(applicationContext,\r\n                                    2, intent, PendingIntent.FLAG_UPDATE_CURRENT)\r\n                        }\r\n\r\n                        override fun getCurrentContentText(player: Player?): String? {\r\n                            return \"\"\r\n                        }\r\n\r\n                        override fun getCurrentContentTitle(player: Player?): String {\r\n                            return trackTitle\r\n                        }\r\n\r\n                        override fun getCurrentLargeIcon(player: Player?, callback:\r\n                        BitmapCallback?): Bitmap? {\r\n                            return image\r\n\r\n                        }\r\n                    },\r\n                    object : NotificationListener {\r\n\r\n                        override fun onNotificationPosted(notificationId: Int,\r\n                                                          notification: Notification?,\r\n                                                          ongoing: Boolean) {\r\n                            super.onNotificationPosted(notificationId, notification, ongoing)\r\n                            startForeground(notificationId, notification)\r\n                        }\r\n\r\n                        override fun onNotificationCancelled(notificationId: Int,\r\n                                                             dismissedByUser: Boolean) {\r\n                            super.onNotificationCancelled(notificationId, dismissedByUser)\r\n                            stopSelf()\r\n                        }\r\n                    }\r\n            )\r\n            // omit skip previous and next actions\r\n            playerNotificationManager.setUseNavigationActions(false);\r\n            // omit fast forward action by setting the increment to zero\r\n            playerNotificationManager.setFastForwardIncrementMs(0);\r\n            // omit rewind action by setting the increment to zero\r\n            playerNotificationManager.setRewindIncrementMs(0);\r\n\r\n            playerNotificationManager.setSmallIcon(R.drawable.ico_notification_wings)\r\n\r\n            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {\r\n                playerNotificationManager.setColor(ResourceUtils.getColor(R.color.mva_blue))\r\n            }\r\n\r\n            //assign the player to it\r\n            playerNotificationManager.setPlayer(player)\r\n        }\r\n    }\r\n\r\n    override fun onTaskRemoved(rootIntent: Intent) {\r\n        stopService()\r\n        super.onTaskRemoved(rootIntent)\r\n    }\r\n\r\n    /**\r\n     * Stop service and release the video player\r\n     * This is only executed if we remove the app from tasks or memory is low\r\n     */\r\n    private fun stopService() {\r\n        stopSelf()\r\n        VideoPlayer.getInstance().release()\r\n    }\r\n\r\n    override fun onTrimMemory(level: Int) {\r\n        stopService()\r\n        super.onTrimMemory(level)\r\n    }\r\n\r\n    override fun onPlayerStateChanged(playWhenReady: Boolean, playbackState: Int) {\r\n        super.onPlayerStateChanged(playWhenReady, playbackState)\r\n        when (playbackState) {\r\n            Player.STATE_BUFFERING -> {\r\n\r\n            }\r\n            Player.STATE_READY -> {\r\n                val videoPlaying = player?.playWhenReady ?: false\r\n                if (!videoPlaying) {\r\n                    **stopForeground(false)**\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    override fun onDestroy() {\r\n        if (::playerNotificationManager.isInitialized) {\r\n            playerNotificationManager.setPlayer(null)\r\n        }\r\n        //save the last played position for that track\r\n        if (player != null) {\r\n            PreferenceManager.putLong(\"$trackId\",\r\n                    player?.currentPosition ?: 0)\r\n            player?.removeListener(this)\r\n        }\r\n        super.onDestroy()\r\n    }\r\n\r\n\r\n}\r\n```\r\n\r\nMy minimum SDK is 16. I have also tried minimum SDK 21 but still does not works.\r\nMy Target SDK is 28.\r\nI have checked quite a few forums but could not find a solution."
    },
    "satisfaction_conditions": [
      "Notification must remain non-dismissible during active playback",
      "Service state must properly reflect playback status",
      "Notification state changes must respond to playback state transitions"
    ],
    "created_at": "2019-11-14T09:06:30Z"
  },
  {
    "id": "https://github.com/google/ExoPlayer/issues/6304",
    "source": {
      "issue_number": 6304
    },
    "initial_question": {
      "title": "Does Exo player support to set error time out?",
      "body": "When exo player happend `timeout` or `socket timeout` exception, inner player will retry soon, the problem is how can I set the error retry time? Because inner player retry fastly."
    },
    "satisfaction_conditions": [
      "Player retry behavior must be configurable",
      "Retry count must be adjustable to zero or one",
      "Retry timing must be controllable",
      "Solution must handle network-related errors"
    ],
    "created_at": "2019-08-16T09:49:22Z"
  },
  {
    "id": "https://github.com/google/ExoPlayer/issues/6118",
    "source": {
      "issue_number": 6118
    },
    "initial_question": {
      "title": "Audio focus is permanently lost",
      "body": "### [REQUIRED] Use case description\r\nI need a player that plays the video silently, it never holds the audio focus, just plays the video without sound.\r\n\r\n<!-- DO NOT DELETE\r\nvalidate_template=true\r\ntemplate_path=.github/ISSUE_TEMPLATE/feature_request.md\r\n-->\r\n"
    },
    "satisfaction_conditions": [
      "Video playback occurs without triggering audio system activity",
      "Video content displays visually while maintaining complete audio silence",
      "Player does not hold or request audio focus",
      "System audio state remains unaffected by video playback"
    ],
    "created_at": "2019-07-02T07:26:48Z"
  },
  {
    "id": "https://github.com/google/ExoPlayer/issues/6057",
    "source": {
      "issue_number": 6057
    },
    "initial_question": {
      "title": "Getting informed about user actions",
      "body": "### Searched documentation and issues\r\nOfficial ExoPlayer documentation and source code of `MediaControllerCompat`, `MediaSessionConnector`, `MediaSession` classes.\r\n\r\n### Question\r\nIs it possible to get notified about user actions? I'm using `ExoPlayer` and `MediaSessionConnector` for handling MediaSession, so I'm not able to register `MediaSession.Callback`, that would have solved my problem, because it can be registered only once and it is done inside of `MediaSessionConnector` class.\r\n\r\nI would like to be informed about user actions like \"PLAY\", \"PAUSE\", \"SKIP TO NEXT\", \"SKIP TO PREVIOUS\" etc. The only way to do it, I have found, is to register `MediaControllerCompat.Callback`, that has `onPlaybackStateChanged` method. The problem is that after testing it, I have found that only states that are dispatched to this method are `STATE_NONE`, `STATE_PAUSED`, `STATE_PLAYING` and `STATE_BUFFERING`. There are other states like `STATE_SKIPPING_TO_PREVIOUS`, `STATE_SKIPPING_TO_NEXT` I would like to be notified about, but it never happens. \r\n\r\n<!-- DO NOT DELETE\r\nvalidate_template=true\r\ntemplate_path=.github/ISSUE_TEMPLATE/question.md\r\n-->\r\n"
    },
    "satisfaction_conditions": [
      "System must detect and distinguish between user-initiated media transitions and automatic transitions",
      "Solution must work within MediaBrowserServiceCompat environment",
      "System must capture media playback state changes",
      "Solution must be compatible with existing MediaSessionConnector implementation",
      "Data collection must support statistical analysis purposes"
    ],
    "created_at": "2019-06-18T12:58:46Z"
  },
  {
    "id": "https://github.com/google/ExoPlayer/issues/6020",
    "source": {
      "issue_number": 6020
    },
    "initial_question": {
      "title": "Player currentPosition is 0 on PlayerNotificationManager.onNotificationCancelled",
      "body": "### [REQUIRED] Issue description\r\n\r\nThe currentPosition is 0 on dismissing the player from the PlayerNotificationManager with method onNotificationCancelled. Also in the EventListener.onPlayerStateChanged the currentPosition is 0.\r\n\r\n### [REQUIRED] Reproduction steps\r\n\r\n1. Start the ExoPlayer with PlayerNotificationManager\r\n2. Release the player from the notification\r\n3. Check the currentPosition of the player on dismissing the notification and releasing the player.\r\n\r\n###  [REQUIRED] Link to test content\r\n\r\n-\r\n\r\n### [REQUIRED] A full bug report captured from the device\r\n\r\n-\r\n\r\n### Version of ExoPlayer being used\r\nExoPlayer version 2.10.1\r\n\r\n### Device(s) and version(s) of Android being used\r\nAndroid API 28\r\n\r\n<!-- DO NOT DELETE\r\nvalidate_template=true\r\ntemplate_path=.github/ISSUE_TEMPLATE/bug.md\r\n-->\r\n"
    },
    "satisfaction_conditions": [
      "Player position must be captured before reset occurs",
      "Solution must handle notification stop action",
      "Position persistence must survive notification dismissal"
    ],
    "created_at": "2019-06-11T17:57:38Z"
  },
  {
    "id": "https://github.com/google/ExoPlayer/issues/5954",
    "source": {
      "issue_number": 5954
    },
    "initial_question": {
      "title": "Allow to dismiss notification with stopforeground(false) destroying service",
      "body": "### Issue description\r\nI added a listener to the player and inside onPlayerStateChanged() i call stopforeground(false) when playWhenReady is false to allow users to dismiss the notification\r\n` mPlayer.addListener(new Player.EventListener() {\r\n\r\n            @Override\r\n            public void onPlayerStateChanged(boolean playWhenReady, int playbackState) {\r\n                if (playWhenReady) {\r\n                    ContextWrapper contextWrapper = new ContextWrapper(mContext);\r\n                    contextWrapper.startService(mIntent);\r\n                    startForeground(mNotificationId, mNotification);\r\n                } else {\r\n                    stopForeground(false);\r\n                }\r\n            }\r\n        }`\r\n\r\nThe dismiss notification is working correctly, but if a use the back button to navigate to the launcher or lock the phone, after a while with the playback paused, the service is destroyed and this appears on the logs\r\n```\r\n 2019-05-27 14:59:12.928 13863-14904/com.android.voyce V/FA: Inactivity, disconnecting from the service\r\n2019-05-27 15:02:11.525 13863-13863/com.android.voyce I/ExoPlayerImpl: Release c274b39 [ExoPlayerLib/2.10.1] [dreamlte, SM-G950F, samsung, 28] [goog.exo.core, goog.exo.ui, goog.exo.mediasession]\r\n2019-05-27 15:02:11.538 13863-14549/com.android.voyce I/ACodec: [OMX.SEC.mp3.dec] signalFlush\r\n2019-05-27 15:02:11.539 13863-14549/com.android.voyce I/ACodec: [OMX.SEC.mp3.dec] ExecutingState flushing now (codec owns 10/10 input, 0/5 output).\r\n2019-05-27 15:02:11.549 13863-14549/com.android.voyce I/ACodec: [OMX.SEC.mp3.dec] Now Flushing\r\n2019-05-27 15:02:11.556 13863-14549/com.android.voyce I/ACodec: [OMX.SEC.mp3.dec] FlushingState onOMXEvent(0,1,0)\r\n2019-05-27 15:02:11.556 13863-14549/com.android.voyce I/ACodec: [OMX.SEC.mp3.dec] FlushingState onOMXEvent(0,1,1)\r\n2019-05-27 15:02:11.559 13863-14549/com.android.voyce I/ACodec: [OMX.SEC.mp3.dec] Now Executing\r\n2019-05-27 15:02:11.571 13863-14549/com.android.voyce I/ACodec: [OMX.SEC.mp3.dec] Now Executing->Idle\r\n2019-05-27 15:02:11.590 13863-14549/com.android.voyce I/ACodec: [OMX.SEC.mp3.dec] Now Idle->Loaded\r\n2019-05-27 15:02:11.590 13863-14549/com.android.voyce I/ACodec: [OMX.SEC.mp3.dec] Now Loaded\r\n2019-05-27 15:02:11.591 13863-14549/com.android.voyce I/ACodec:  [OMX.SEC.mp3.dec] Now kWhatShutdownCompleted event : 8544\r\n2019-05-27 15:02:11.598 13863-14549/com.android.voyce I/ACodec:  [OMX.SEC.mp3.dec] Now uninitialized\r\n2019-05-27 15:02:11.604 13863-14549/com.android.voyce I/ACodec:  [] Now kWhatShutdownCompleted event : 8544\r\n2019-05-27 15:02:11.604 13863-14549/com.android.voyce I/MediaCodec: Codec shutdown complete\r\n2019-05-27 15:02:11.731 13863-14075/com.android.voyce W/m.android.voyc: Accessing hidden method Ldalvik/system/CloseGuard;->close()V (light greylist, linking) \r\n```\r\n\r\nthis is my NotificationListener code \r\n\r\n```\r\nnew PlayerNotificationManager.NotificationListener() {\r\n                    @Override\r\n                    public void onNotificationCancelled(int notificationId, boolean dismissedByUser) {\r\n                        if (dismissedByUser) {\r\n                            stopSelf();\r\n                        }\r\n                    }\r\n\r\n                    @Override\r\n                    public void onNotificationPosted(int notificationId, Notification notification, boolean ongoing) {\r\n                        mNotification = notification;\r\n                        mNotificationId = notificationId;\r\n                        if (ongoing) {\r\n                            startForeground(notificationId, notification);\r\n                        }\r\n                    }\r\n                }\r\n```\r\n\r\n### Reproduction steps\r\nI create the service with \r\n```\r\n mPlayerServiceIntent = new Intent(this, AudioPlayerService.class);\r\n        bindService(mPlayerServiceIntent, mPlayerServiceConnection, BIND_AUTO_CREATE);\r\n```\r\n\r\non the activity on create, then when the user chooses a song (a simple mp3 url from firebasestorage) then i call `Util.startForegroundService(this, mPlayerServiceIntent);`\r\n\r\nthen i pause the playback and exits the app with the back button, the notification with the paused state stays for a while, then it is destroyed as i mentioned above.\r\n\r\n### Version of ExoPlayer being used\r\nVersion 2.10.1 \r\n\r\n### Device(s) and version(s) of Android being used\r\nSamsung s8, api 28.\r\n\r\n<!-- DO NOT DELETE\r\nvalidate_template=true\r\ntemplate_path=.github/ISSUE_TEMPLATE/bug.md\r\n-->\r\n"
    },
    "satisfaction_conditions": [
      "Service must be removed from foreground state when playback is paused",
      "Notification must be dismissible when playback is paused",
      "Service termination must occur gracefully when notification is dismissed",
      "Notification and service must persist during active playback",
      "System must be allowed to reclaim resources when app is backgrounded and playback is paused"
    ],
    "created_at": "2019-05-27T18:11:40Z"
  },
  {
    "id": "https://github.com/google/ExoPlayer/issues/5871",
    "source": {
      "issue_number": 5871
    },
    "initial_question": {
      "title": "Is there an eventListener for subtitles?",
      "body": "I figured how to load subtitle and merge with `MediaSource`.\r\n\r\nBut I'm wondering if there is an eventListner for loading subtitles.\r\nHere's how I load subtitle\r\n\r\n```\r\nSingleSampleMediaSource.Factory(DefaultHttpDataSourceFactory(\"ua\"))\r\n   .createMediaSource(Uri.parse( subtitleUri ), vttFormat, C.TIME_UNSET)\r\n```\r\n\r\nHow can I set the loadFailedListener....?\r\n\r\n\r\nThank you !"
    },
    "satisfaction_conditions": [
      "Ability to detect subtitle loading events",
      "Support for handling subtitle loading failures",
      "Integration with existing MediaSource implementation",
      "Compatible with the subtitle format being used (VTT)"
    ],
    "created_at": "2019-05-10T12:30:37Z"
  },
  {
    "id": "https://github.com/google/ExoPlayer/issues/5791",
    "source": {
      "issue_number": 5791
    },
    "initial_question": {
      "title": "playlist with PagedList(AAC)",
      "body": "\r\n### [REQUIRED] Searched documentation and issues\r\nI found playlist feature can be implemented using ConcatenatingMediaSource class which be added MediaSource instance.\r\n\r\n\r\n### [REQUIRED] Question\r\nHi, I'm implementing playlist feature that has about 700 songs.\r\nI've implemented using ConcatenatingMediaSource instance.\r\nBut it require to instantiate HlsMediaSource instance about 700 times at once to add there .\r\n\r\nI use PageList class(AAC) to show playlist in view. \r\nIs there any way to use the pageList to exoplayer playlist feature.\r\n\r\nIs any advice in this scenario?\r\n\r\n<!-- DO NOT DELETE\r\nvalidate_template=true\r\ntemplate_path=.github/ISSUE_TEMPLATE/question.md\r\n-->\r\n"
    },
    "satisfaction_conditions": [
      "The solution must handle a large playlist (700+ songs) without excessive initial loading time",
      "Memory usage must remain reasonable when managing the full playlist",
      "The solution must integrate with PagedList functionality",
      "Media sources must be accessible in a way that maintains correct playlist ordering",
      "Resources should only be prepared when needed for playback"
    ],
    "created_at": "2019-04-23T08:07:28Z"
  },
  {
    "id": "https://github.com/google/ExoPlayer/issues/5727",
    "source": {
      "issue_number": 5727
    },
    "initial_question": {
      "title": "Question: How to override the video track selection for multiple videos",
      "body": "Can you change the resolution of all the videos that are playing in the player without having to create a new instance of the player?\r\n\r\nExoplayer version 2.9.4\r\n\r\nTo make the exchange of quality I am using this method\r\n\r\n```\r\nprivate fun applySelection() {\r\n        val trackInfo = trackSelector.currentMappedTrackInfo ?: return\r\n        val trackGroups = trackInfo.getTrackGroups(videoRendererIndex)\r\n\r\n        val parametersBuilder = trackSelector.buildUponParameters()\r\n        parametersBuilder.setRendererDisabled(videoRendererIndex, false)\r\n\r\n        if (overridePlayer != null) {\r\n            parametersBuilder.setSelectionOverride(videoRendererIndex, trackGroups, overridePlayer)\r\n        } else {\r\n            parametersBuilder.clearSelectionOverrides(videoRendererIndex)\r\n        }\r\n\r\n        trackSelector.setParameters(parametersBuilder)\r\n}\r\n```"
    },
    "satisfaction_conditions": [
      "Video quality changes must apply across multiple videos without player recreation",
      "Track selection changes must persist when switching between different videos",
      "Quality selection logic must work with varying track configurations",
      "Track selection changes must take effect immediately when applied"
    ],
    "created_at": "2019-04-04T14:00:08Z"
  },
  {
    "id": "https://github.com/google/ExoPlayer/issues/5655",
    "source": {
      "issue_number": 5655
    },
    "initial_question": {
      "title": "SimpleExoPlayer.prepare(com.google.android.exoplayer2.source.MediaSource)' on a null object reference",
      "body": "### [REQUIRED] Searched documentation and issues\r\nnull\r\n\r\n### [REQUIRED] Question\r\nwhen I init the  SimpleExoPlayer player.the method SimpleExoPlayer.prepare()  will  return a null \r\nobject reference.My uri has no problem,Whyyyyyyyy?\r\n\r\nprivate void initPlayer() {\r\n        if (player!=null) {\r\n            player = ExoPlayerFactory.newSimpleInstance(\r\n                    getActivity(), new DefaultRenderersFactory(getActivity()), new DefaultTrackSelector(), new DefaultLoadControl());\r\n            playerView.setPlayer(player);\r\n            player.setPlayWhenReady(playWhenReady);\r\n            player.seekTo(currentWindow, playbackPosition);\r\n        }\r\n        //\u521b\u5efawav\u6587\u4ef6\r\n        Uri uri=Uri.parse(Environment.getExternalStorageDirectory()+\"/msc/test.wav\");\r\n        DefaultDataSourceFactory dataSourceFactory = new DefaultDataSourceFactory(getActivity(), Util.getUserAgent(getContext(),\"MyApplication\"));\r\n        MediaSource mediaSource=new ExtractorMediaSource.Factory(\r\n                dataSourceFactory).createMediaSource(uri);\r\n        if (mediaSource!=null) {\r\n            player.prepare(mediaSource, false, true);\r\n        }else {\r\n            showTip(\"mediaSource   null\");\r\n        }\r\n\r\n\r\n    }\r\n\r\n<!-- DO NOT DELETE\r\nvalidate_template=true\r\ntemplate_path=.github/ISSUE_TEMPLATE/question.md\r\n-->\r\n"
    },
    "satisfaction_conditions": [
      "MediaSource must be successfully created before being used"
    ],
    "created_at": "2019-03-20T11:10:24Z"
  },
  {
    "id": "https://github.com/google/ExoPlayer/issues/5627",
    "source": {
      "issue_number": 5627
    },
    "initial_question": {
      "title": "Custom Load Error message: available or not?",
      "body": "### Searched documentation and issues\r\nI have been looking around the web, offical Android Dev. website, Medium, in this repository Issue category and in the Source code.\r\n\r\n### Question\r\nI am working with the ExoPlayer error handling. I found that when my Server response is an exception of type \"InvalidResponseCodeException\" I am not able to find the server message, just the default http status message (in the LoadErrorHandlingPolicy custom class as well as for the player listener onPlayerError() method). I am wondering if is there a way to get it or it is a feature not yet implemented.\r\n\r\n<!-- DO NOT DELETE\r\nvalidate_template=true\r\ntemplate_path=.github/ISSUE_TEMPLATE/question.md\r\n-->\r\n"
    },
    "satisfaction_conditions": [
      "Custom error messages from server responses must be accessible in the error handling code",
      "Error messages must be retrievable from non-200 HTTP responses",
      "Solution must work within ExoPlayer's error handling framework",
      "Server-side message updates must be reflected in the client without app updates"
    ],
    "created_at": "2019-03-13T11:54:46Z"
  },
  {
    "id": "https://github.com/google/ExoPlayer/issues/5602",
    "source": {
      "issue_number": 5602
    },
    "initial_question": {
      "title": "ConcateningMedia, RepeatOne and next / previous",
      "body": "I have a question regarding REPEAT_ONE mode, ConcateningMedia and using SimpleExoPlayer.next(), previous() and related methods.\r\n\r\nFrom my understanding, REPEAT_ONE should function by endlessly looping same MediaSource. From what I see in the source code of Timeline.getNextWindowIndex, it should return currentWindowIndex when repeat mode is REPEAT_ONE. But this isn't the case. Instead using simpleExoPlayer.next() moves to next window index and plays next MediaSource. \r\n\r\nIn short, I have a ConcateningMedia with MediaSourceA, MediaSourceB and MediaSourceC.\r\nWhen I set REPEAT_ONE and play MediaSourceA, I expect getPreviousWindowIndex() and getNextWindowIndex() to return same values as getCurrentWindowIndex() and that calling next() replays MediaSourceA. Instead, MediaSourceB is played.\r\n \r\nIs this expected behavior? \r\n\r\n<!-- DO NOT DELETE\r\nvalidate_template=true\r\ntemplate_path=.github/ISSUE_TEMPLATE/question.md\r\n-->\r\n"
    },
    "satisfaction_conditions": [
      "Player navigation methods (next/previous) must allow moving between media sources even in REPEAT_ONE mode",
      "Automatic playback must continuously repeat the current media source in REPEAT_ONE mode without user interaction",
      "Window index query methods must accurately reflect the next/previous navigation targets",
      "Player must maintain distinct behaviors for automatic playback progression versus manual navigation"
    ],
    "created_at": "2019-03-06T13:22:36Z"
  },
  {
    "id": "https://github.com/google/ExoPlayer/pull/5525",
    "source": {
      "issue_number": 5525
    },
    "initial_question": {
      "title": "Make DefaultRenderersFactory subclass-friendly",
      "body": "Change the `private` fields to `protected` so that subclasses can use them. \r\n\r\nAn alternative might can be adding protected/public getters, but that seems to be an overkill.\r\n\r\nCurrently our workaround is having our own copies of private allowedVideoJoiningTimeMs and playClearSamplesWithoutKeys."
    },
    "satisfaction_conditions": [
      "Access method must be compatible with existing renderer creation workflow"
    ],
    "created_at": "2019-02-18T08:28:23Z"
  },
  {
    "id": "https://github.com/google/ExoPlayer/issues/5458",
    "source": {
      "issue_number": 5458
    },
    "initial_question": {
      "title": "Using custom receiver in cast with exoplayer",
      "body": "Hi i am having a question with regards to using cast with exoplayer.\r\nWe are planning to write a custom receiver for cast.The cast sdk mentions that we need to send the receiver app id from the sender app(android app).Where is this to be provided if we are using exoplayer cast extension.\r\n"
    },
    "satisfaction_conditions": [
      "Cast receiver application ID is properly configured in the Android app",
      "Cast options are properly defined and accessible to the ExoPlayer cast extension",
      "Cast configuration is integrated with Android application manifest",
      "Cast session management behavior is defined"
    ],
    "created_at": "2019-01-31T07:01:43Z"
  },
  {
    "id": "https://github.com/google/ExoPlayer/issues/5339",
    "source": {
      "issue_number": 5339
    },
    "initial_question": {
      "title": "Playing mp4 video from assets",
      "body": "I'm trying to use a video that is inside the assets directory, but I always take an exception \r\n com.google.android.exoplayer2.upstream.HttpDataSource$HttpDataSourceException: Unable to connect to assets://vid.mp4\r\n```\r\nExtractorMediaSource.Factory(DefaultDataSourceFactory(context, BuildConfig.USER_AGENT_VALUE)).createMediaSource(Uri.parse(\"assets://vid.mp4\"))\r\n```"
    },
    "satisfaction_conditions": [
      "Video file is stored in a location accessible to the app"
    ],
    "created_at": "2019-01-04T15:06:33Z"
  },
  {
    "id": "https://github.com/google/ExoPlayer/issues/5282",
    "source": {
      "issue_number": 5282
    },
    "initial_question": {
      "title": "How to create AudioProcessor to boost volume",
      "body": "I read issues #3657 where @andrewlewis  is saying that to increase volume above normal limits  one should implement custom AudioProcessor.\r\n\r\nI've made couple of test, but not sure how to implement it, key problem is that input PCM data (16 bit PCM) into my AudioProcessor are already normalized to 16 bit range (so values are already in range 32768 - 32767) , so there is no space to increase amplitude more.\r\n\r\nI tried to change output encoding to PCM 32 bits to have some space for increase, but then got unhanded configuration exception \r\n\r\n(And generally it looks like only PCM 16 bit is supported.\r\nCustom AudioProcessors seem to be used before standard processors - especially SilenceSkippingAudioProcessor, which requires PCM 16 bit as it's input -  so I guess if I'll change resolution to 24 or 32 bits it'll not be working.)\r\n\r\nCan you provide bit more detailed advice how to implement AudioProcessor to boost volume? Or is there any other trick I can use? Any ideas are welcomed.\r\nThanks"
    },
    "satisfaction_conditions": [
      "Audio effect instance must persist throughout playback duration",
      "Solution must work within platform's audio processing constraints"
    ],
    "created_at": "2018-12-19T20:32:09Z"
  },
  {
    "id": "https://github.com/google/ExoPlayer/issues/5267",
    "source": {
      "issue_number": 5267
    },
    "initial_question": {
      "title": "How can I switch the video that I just add to the concatenatingmediasource while the exoplay is runing?",
      "body": "How can I switch the video that I just add to the concatenatingmediasource while the exoplay is runing?\r\nCan make it whihout reprepare the player?"
    },
    "satisfaction_conditions": [
      "Video playback must continue without interrupting the player",
      "New video content must be successfully added to the ConcatenatingMediaSource during playback",
      "Player must correctly navigate to the newly added content"
    ],
    "created_at": "2018-12-18T01:41:52Z"
  },
  {
    "id": "https://github.com/google/ExoPlayer/issues/5175",
    "source": {
      "issue_number": 5175
    },
    "initial_question": {
      "title": "[Question] Custom implementation for raw H.264 Annex B support",
      "body": "#### Scenario\r\nWe are opening a web socket to our backend which is providing a raw H.264 stream. The backend is already splitting the stream into NAL units, so the messages we receive through the socket are already properly split at the NAL headers (0x00000001). What we are trying to do is create custom components that will enable ExoPlayer to play our stream.\r\n\r\n#### What We've Tried\r\nWe did some research and found that #3503 is similar to our situation. Following the advice there, we have successfully created a `DataSource` which wraps a web socket and is receiving the NAL units. We also created an `Extractor` that is modeled after the `Ac3Extractor` but uses an `H264Reader`, as suggested by the previously mentioned issue. Our `Extractor` is receiving the bytes from the `DataSource` and passing them to `H264Reader.consume(ParsableByteArray)`.\r\n\r\n#### Our Problem\r\nAfter finding the first SPS, PPS, and IDR NAL units, the player plays a single frame, but that is all. The `DataSource` and `Extractor` keep running and receiving bytes, but it seems the `H264Reader` is failing to work. Issue #3503 states there are \"...a few more details to work out, like how to set timing information on output samples.\" We believe our issue relates to these \"details\" but are unsure what these details are. We have tried calling `H264Reader.packetStarted(Long, Boolean)` but that doesn't seem to do anything, so we may be dong it incorrectly. What are these \"details\" and how should we go about implementing them?\r\n\r\nI can provide code samples as well as samples of our byte stream if that would be helpful. Looking forward to hearing back!"
    },
    "satisfaction_conditions": [
      "Video frames must be processed beyond the first frame",
      "Proper timestamp sequencing must be established",
      "NAL units must be correctly parsed from the incoming stream",
      "Integration with ExoPlayer's buffer management system must be achieved",
      "Continuous data flow from WebSocket to player must be maintained"
    ],
    "created_at": "2018-11-29T23:45:12Z"
  },
  {
    "id": "https://github.com/google/ExoPlayer/issues/4971",
    "source": {
      "issue_number": 4971
    },
    "initial_question": {
      "title": "Getting the resolution(1080p,430p etc) when a video is played in \"AUTO\" in quality",
      "body": "Is there a way in which we can show the resolution when auto is selected in quality.I just want to show if auto is selected the resolution its selecting to play the video\r\n\r\n"
    },
    "satisfaction_conditions": [
      "Real-time resolution information is accessible while video plays in AUTO quality mode",
      "Resolution changes are detectable during playback",
      "Solution works with HLS video format",
      "Resolution information can be displayed to the user",
      "Works with ExoPlayer-based video player"
    ],
    "created_at": "2018-10-17T08:46:23Z"
  },
  {
    "id": "https://github.com/google/ExoPlayer/issues/4913",
    "source": {
      "issue_number": 4913
    },
    "initial_question": {
      "title": "Sound stop after a while when looping",
      "body": "### Issue description\r\n\r\nUsing ExoPlayer 2.8.2 to play a local .m4a sound file in repeat mode, the sound stop after a while (typically a couple of hours). If playing several files simultaneously, each file stop at a different time. No error is reported in neither the player event listener nor the media source event listener.\r\n\r\nThe error occurs with both `player.setRepeatMode(Player.REPEAT_MODE_ALL);` or by using a LoopingMediaSource object.\r\n\r\nWhen the audio stop, the following lines appears in Logcat:\r\n    1536-1577/? I/AudioFlinger: BUFFER TIMEOUT: remove(4096) from active list on thread 0xf1203680\r\n    1430-1578/? W/audio_hw_generic: Not supplying enough data to HAL, expected position 942828484 , only wrote 934428960\r\n\r\ntoggling player.setPlayWhenReady(...) does not restore the playback.\r\n\r\nWe didn't notice this issue (and none of our users complain) with the previous version of ExoPlayer we were using: r2.4.1. Unfortunately it is not possible to roll back as an audio glitch was audible at the end of each loop.\r\n\r\n### Reproduction steps\r\n\r\nThe following code is running in a service:\r\n\r\n```\r\n...\r\ndataSourceFactory = new DefaultDataSourceFactory(context, Util.getUserAgent(context, \"XXXX\"), null);\r\nplayer = ExoPlayerFactory.newSimpleInstance(context, new DefaultTrackSelector());\r\nMediaSource audioSource = new ExtractorMediaSource.Factory(dataSourceFactory).createMediaSource(audioItem.getUri());\r\nplayer.setRepeatMode(Player.REPEAT_MODE_ALL);\r\nplayer.prepare(audioSource);\r\n...\r\nplayer.setPlayWhenReady(true);\r\n```\r\n\r\nWait until the sound stops\r\n\r\n### Link to test content\r\nSent by email\r\n\r\n### Version of ExoPlayer being used\r\n2.8.2\r\n\r\n### Device(s) and version(s) of Android being used\r\nPixel XL simulator with Android Oreo 8.1\r\nSome of our users complained about the same issue on different devices.\r\n\r\n### A full bug report captured from the device\r\nSent by email\r\n\r\n"
    },
    "satisfaction_conditions": [
      "Audio playback continues indefinitely when in loop mode",
      "Audio timing remains synchronized during extended playback"
    ],
    "created_at": "2018-10-04T23:34:08Z"
  },
  {
    "id": "https://github.com/google/ExoPlayer/issues/4843",
    "source": {
      "issue_number": 4843
    },
    "initial_question": {
      "title": "How to seperate default time bar",
      "body": "hi there, i am looking for default time bar separated even though i make media source ConcatenatingMediaSource. For example, like play music list supposed current bar show only time of current music play instead of combine them all together in on line timeba."
    },
    "satisfaction_conditions": [
      "Time bar displays duration of current track only",
      "Media playback transitions between tracks",
      "Multiple media sources can be queued together",
      "Time display remains accurate per track"
    ],
    "created_at": "2018-09-20T06:25:44Z"
  },
  {
    "id": "https://github.com/google/ExoPlayer/issues/4836",
    "source": {
      "issue_number": 4836
    },
    "initial_question": {
      "title": "VP9 ext crash from libvpx 1.7.0",
      "body": "It seems libvpx 1.7.0 has more neon code added. There was error when I run config. By adding -mfloat-abi=softfp -mfpu=neon to cflag, I have managed to get the so file compiled. However, after the first frame is decoded, the sample app always crashes with: \r\n\r\ncom.google.android.exoplayer2.demo A/libc: Fatal signal 11 (SIGSEGV), code 1, fault addr 0x10 in tid 18160 (Thread-1825)\r\n\r\nMy ExoPlayer version is 2.8.2. The working libvpx is 1.6.2, which is from Jan 2017."
    },
    "satisfaction_conditions": [
      "Library compilation completes successfully"
    ],
    "created_at": "2018-09-18T10:53:04Z"
  },
  {
    "id": "https://github.com/google/ExoPlayer/issues/4802",
    "source": {
      "issue_number": 4802
    },
    "initial_question": {
      "title": "Question: Analytics Listener Play Status + Detect Replay",
      "body": "Using: Exoplayer 2.8.4\r\n\r\nI am trying to implement some tracking from our analytics team, and there are two tracking events that I'm having trouble finding a way to track through the Analytics Listener.\r\n\r\nFirstly, is it possible to detect replays if the video is set to loop when it completes? I tried to listen to:\r\n\r\n```\r\noverride fun onPlayerStateChanged(\r\n        eventTime: AnalyticsListener.EventTime?,\r\n        playWhenReady: Boolean,\r\n        playbackState: Int\r\n    )\r\n```\r\n\r\nbut it doesn't appear as though this event is fired with state ENDED (or anything for that matter) when the video replays.\r\n\r\nSecondly, we would like to track how far into a video a user has watched at certain intervals (e.g. 1s, 5s, 10s, 30s). Is it possible to receive callbacks at certain points in the media's playback? As far as I can see, there's no way to receive callbacks once every second or so. I was thinking that I could implement this via a timer that runs alongside the video, but the problem with that approach is that the second the video has to spend time buffering or the user has seeked, the timer will no longer be accurate to the actual video position.\r\n\r\nThanks"
    },
    "satisfaction_conditions": [
      "Video replay events must be detectable when looping is enabled",
      "Playback progress must be trackable at specific time intervals",
      "Progress tracking must remain accurate during buffering and seeking",
      "Message handlers must function on the correct thread",
      "Tracking events must persist across video seeks"
    ],
    "created_at": "2018-09-11T13:39:22Z"
  },
  {
    "id": "https://github.com/google/ExoPlayer/issues/4692",
    "source": {
      "issue_number": 4692
    },
    "initial_question": {
      "title": "Does onTracksChanged gets called when video track changes due to ABR ?",
      "body": "onTracksChanged is not getting called when video changes due to ABR. I tried getting updated track using `getCurrentTrackSelections`, but it is not returning updated list.\r\n\r\n`player.getVideoFormat()` is giving right format selected, but has incorrect values about bitrate.\r\nexample -  getting bitrate as -1, track id is wrong.\r\n\r\nWhat is the best way to get notified and get all track related info when video track changes."
    },
    "satisfaction_conditions": [
      "System must detect and notify about video track quality changes during adaptive bitrate streaming",
      "Track information (including bitrate and track ID) must be accurately reported",
      "Notification mechanism must trigger specifically for quality selection changes, not just track availability changes",
      "System must provide access to current video format information in real-time"
    ],
    "created_at": "2018-08-20T13:03:25Z"
  },
  {
    "id": "https://github.com/google/ExoPlayer/issues/4613",
    "source": {
      "issue_number": 4613
    },
    "initial_question": {
      "title": "Order of execution of listeners",
      "body": "Hi,\r\n\r\nI am using ExoPlayer 2.8.2 release and trying to implement a feature where I want to use the bandwidth measurement from the latest video segment download to influence the quality of the next segment. This is for Dash videos.\r\nI have extended trackSelection to `CustomTrackSelection` object. But, the problem on several occasions, by the time the `DefaultDashChunkSource` calls `updateSelectedTrack` function, the previous download end event hasn't been processed by my `listener` and I haven't had a chance to register the latest throughput sample. \r\nI guess what's happening is that the `onLoadCompleted` event is processed by `ChunkSampleStream` and it proceeds with the next download start _before_ my listener is invoked.\r\nIs there any way to get around this? Is there any way I can \"wait\" before downloading the next segment if my listener hasn't registered the download end event?\r\n\r\nThanks for your attention and help! I appreciate any pointers."
    },
    "satisfaction_conditions": [
      "Bandwidth measurement from previous segment must be available before next segment quality selection",
      "Event processing order must be deterministic between transfer completion and track selection",
      "Custom bandwidth measurement logic must be able to override default behavior",
      "No race conditions in bandwidth data updates"
    ],
    "created_at": "2018-08-02T23:43:17Z"
  },
  {
    "id": "https://github.com/google/ExoPlayer/issues/4547",
    "source": {
      "issue_number": 4547
    },
    "initial_question": {
      "title": "getWindowIndex() sometime is delay",
      "body": "//Version\r\n2.7.3\r\n\r\n//Description\r\nI'm using ClippingMediaSource and DynamicConcatenatingMediaSource to play multiple video clips, and i need to know the current index of window when onVideoSizeChanged callback, but i found sometime the index is not correct because onPositionDiscontinuity->DISCONTINUITY_REASON_PERIOD_TRANSITION is later than  onVideoSizeChanged.\r\nso i getWindowIndex() is an un correct index.\r\n\r\nMy question is how to get exact window index when onVideoSizeChanged?\r\n"
    },
    "satisfaction_conditions": [
      "Accurate window index retrieval during video size changes",
      "Synchronized event handling between size changes and position transitions",
      "Compatible with ExoPlayer's event system"
    ],
    "created_at": "2018-07-22T15:50:48Z"
  },
  {
    "id": "https://github.com/google/ExoPlayer/issues/4443",
    "source": {
      "issue_number": 4443
    },
    "initial_question": {
      "title": "Adaptive track selection",
      "body": "In class **DefaultTrackSelector** is method:\r\n\r\n```\r\nprivate static boolean isSupportedAdaptiveVideoTrack(\r\n      Format format,\r\n      @Nullable String mimeType,\r\n      int formatSupport,\r\n      int requiredAdaptiveSupport,\r\n      int maxVideoWidth,\r\n      int maxVideoHeight,\r\n      int maxVideoBitrate) {\r\n    return isSupported(formatSupport, false) && ((formatSupport & requiredAdaptiveSupport) != 0)\r\n        && (mimeType == null || Util.areEqual(format.sampleMimeType, mimeType))\r\n        && (format.width == Format.NO_VALUE || format.width <= maxVideoWidth)\r\n        && (format.height == Format.NO_VALUE || format.height <= maxVideoHeight)\r\n        && (format.bitrate == Format.NO_VALUE || format.bitrate <= maxVideoBitrate);\r\n  }\r\n```\r\n\r\nWhy there is ` isSupported(formatSupport, false)` with _false_ ? It does not respect params settings."
    },
    "satisfaction_conditions": [
      "The adaptive track selection must respect device capability limitations during initial track selection",
      "The system must maintain separate handling for initial track selection vs fallback behavior",
      "The system must handle device capability reporting limitations appropriately"
    ],
    "created_at": "2018-06-27T17:23:44Z"
  },
  {
    "id": "https://github.com/google/ExoPlayer/issues/4349",
    "source": {
      "issue_number": 4349
    },
    "initial_question": {
      "title": "Play/Pause button icons after end of file reached",
      "body": "Hi\r\nI have simple exo player view which show video. After video end's play button showing pause icon. How i can refresh play button after end of video in my DefaultEventListener?\r\n\r\nThanks\r\n"
    },
    "satisfaction_conditions": [
      "Play button icon correctly reflects video playback state after video ends",
      "Player UI state updates automatically when video reaches end",
      "ExoPlayer version compatibility supports automatic icon state management"
    ],
    "created_at": "2018-06-06T22:42:23Z"
  },
  {
    "id": "https://github.com/google/ExoPlayer/issues/4217",
    "source": {
      "issue_number": 4217
    },
    "initial_question": {
      "title": "Question on achieving a low latency HLS live stream",
      "body": "I'm using Exoplayer to play HLS live streams with a 30 sec window and 2 second segments, and I'am trying to optimize for low latency.\r\n\r\nEverything works great using all the default settings for `LoadControl` and the default `HlsExtractorFactory`, with playback starting 3 segments before the end of the window as expected. \r\n\r\nThe issue i'm seeing is when I'm on a good connection, I often get into a very short buffering states (around a second) after playing the stream for a few seconds.\r\n\r\nThis happens even more frequently if I lower the resolution of my stream to the lowest possible, and stay on a fast internet connection.\r\n\r\nAfter debugging what's happening, it looks like the renderers are asking for the next segment, but the backend hasn't made that next segment available yet. Almost as if the renderer is ahead of the backend, and when asking for more, instead of just waiting and continuing playback (there's still buffered data to be played), it immediately sets the player state to `Player.STATE_BUFFERING`, until the new segment is available.\r\n\r\nIf I set the stream to start further back in the window, say 4-5 segments from the edge, the problem disappears completely, and my buffer sizes stay healthy, but I obviously loose in latency.\r\n\r\nI'm surprised by this behavior as it seems like a common case for live HLS live streams to try to be as close as possible to the edge of the window.\r\n\r\nI'm trying to understand why I'm getting this behavior, and wondering if I'm missing a configuration setting on the client, or if it's something that needs to be tweaked on the backend.\r\n\r\nThanks in advance!\r\n\r\n### Version of ExoPlayer being used\r\n2.7.3\r\n\r\n### Device(s) and version(s) of Android being used\r\nGoogle Pixel XL 2\r\n\r\n"
    },
    "satisfaction_conditions": [
      "Stream playback maintains continuous flow without frequent buffering interruptions",
      "Low latency streaming is achieved while maintaining stable playback",
      "HLS manifest configuration matches actual segment durations",
      "Player's buffer management strategy prevents unnecessary rebuffering",
      "Media segments are loaded at appropriate intervals matching segment duration"
    ],
    "created_at": "2018-05-07T20:54:04Z"
  },
  {
    "id": "https://github.com/google/ExoPlayer/issues/4031",
    "source": {
      "issue_number": 4031
    },
    "initial_question": {
      "title": "Custom listener to show playback controls",
      "body": "Hi. I want to to show playback controls only when onTouch event is fired. How to prevent control buttons being showed up when on long pressing, dragging etc.?"
    },
    "satisfaction_conditions": [
      "Playback controls only appear on single tap/touch events",
      "Long press gestures do not trigger playback controls",
      "Drag gestures do not trigger playback controls",
      "Controls can be both shown and hidden through user interaction",
      "Solution integrates with existing ExoPlayer functionality"
    ],
    "created_at": "2018-03-24T11:22:17Z"
  },
  {
    "id": "https://github.com/google/ExoPlayer/issues/4023",
    "source": {
      "issue_number": 4023
    },
    "initial_question": {
      "title": "Playback buffer value",
      "body": "I am writing a DASH video player using ExoPlayer demo app as the base for my application. How can I get the actual playback buffer size in seconds, without messing with the actual MediaSource and other  code libraries (and short of maintaining my own variable tracking media downloaded, played, paused and all that mess)? \r\nBy actual playback buffer size, I mean the 'total duration duration of the video chunks that's already buffered' - 'total duration of the video chunks that's been watched'. \r\nFor example, if the player has downloaded 60s worth of data and the renderer has already played 50s of this video, I want to know that there's 10 more seconds to go before the player might hit a re-buffer. I am trying to eventually get to a feature that minimizes re-buffering events.\r\nI want to do this with minimal changes to the existing code and achieve this with event listeners, as much as possible. I know if I write my own trackSelector, this is easy to obtain. But, can I get it at the app layer?\r\nThanks for any pointers."
    },
    "satisfaction_conditions": [
      "Returns accurate playback buffer duration in seconds for currently playing content",
      "Obtains buffer information without modifying core media playback components",
      "Provides real-time buffer information through existing player interfaces",
      "Clearly indicates buffer status for single-item playback",
      "Distinguishes between played and unplayed buffered content"
    ],
    "created_at": "2018-03-22T23:21:12Z"
  },
  {
    "id": "https://github.com/google/ExoPlayer/issues/3993",
    "source": {
      "issue_number": 3993
    },
    "initial_question": {
      "title": "Making my own ABR algorithm in HLS",
      "body": "Hello,\r\n\r\nI am making my own ABR algorithm class in HLS extended from BaseTrackSelection and I am facing with a problem. I need targetDuration in my class but there is no way I can get the information from the application level. Plus, I am making my own LoadController, and it needs bitrate information. In this case, is there simple way that I can pass these information to my class in application level?(like PlayerActivity) \r\n\r\nThank you "
    },
    "satisfaction_conditions": [
      "Access to target duration information is established",
      "Bitrate information is accessible to the LoadController",
      "Information flow from application level to custom components is enabled",
      "Integration with existing HLS player events/lifecycle is maintained"
    ],
    "created_at": "2018-03-15T11:20:15Z"
  },
  {
    "id": "https://github.com/google/ExoPlayer/issues/3980",
    "source": {
      "issue_number": 3980
    },
    "initial_question": {
      "title": "How to listen video position",
      "body": "I'm using ExoPlayer 2.7.0 and I would like to listen player position in order to take actions. I couldn't find specific method for it. Could you please suggest me a proper solution?\r\n\r\nThanks"
    },
    "satisfaction_conditions": [
      "Regular position updates are obtained from the player",
      "Updates occur at a reasonable frequency that balances accuracy and performance",
      "Position information can be used to trigger custom actions",
      "Position tracking can be started and stopped",
      "Position updates reflect actual playback progress"
    ],
    "created_at": "2018-03-13T09:19:08Z"
  },
  {
    "id": "https://github.com/google/ExoPlayer/issues/3946",
    "source": {
      "issue_number": 3946
    },
    "initial_question": {
      "title": "cannot resolve MediaSessionConnector",
      "body": "I am using exoplayer v 2.6.1 but i am facing an issue that MediaSessionConnector is not working.\r\n\r\ngradle exoplayer import:\r\n    compile 'com.google.android.exoplayer:exoplayer:2.6.1'"
    },
    "satisfaction_conditions": [
      "Dependency versions are consistent across ExoPlayer modules"
    ],
    "created_at": "2018-03-06T17:44:51Z"
  },
  {
    "id": "https://github.com/google/ExoPlayer/issues/3943",
    "source": {
      "issue_number": 3943
    },
    "initial_question": {
      "title": "How to notice me when next video playback and get current playback file's URI at the same time ?",
      "body": "I try to find a listener that can notice me when the next or previous video playback.\r\n\r\nfor example: \r\n\r\nI have a List of uri by using *DynamicConcatenatingMediaSource* to ExoPlayer, when I click \"next\" button or auto play the next video, I hope to know this event and to know the current playback video's uri.\r\n\r\n I try to find some useful information from Demo App,but nothing.\r\nplease help me~\r\n\r\n#### Version of ExoPlayer being used\r\n2.6.1\r\n"
    },
    "satisfaction_conditions": [
      "Current video's URI must be retrievable during playback",
      "Solution must work with concatenated media sources",
      "Mapping between media sources and their URIs must be maintained"
    ],
    "created_at": "2018-03-05T14:42:24Z"
  },
  {
    "id": "https://github.com/google/ExoPlayer/issues/3932",
    "source": {
      "issue_number": 3932
    },
    "initial_question": {
      "title": "How to render video into off-screen buffer",
      "body": "I'm wondering if it's possible to do at all.\r\nI want to get decoded video frame and use it as OpenGL ES texture in a game, so I don't want it to be rendered into some 'ui' elements (SurfaceView, TextureView etc)\r\n\r\nIt seem a pair of Surface and SurfaceTexture would help me but it doesn't.\r\nHere is a code snippet (I try to do this in Xamarin.Android but it doesn't matter, any advice for 'native' Android would be appreciated).\r\n```\r\n            _bandwidthMeter = new DefaultBandwidthMeter();\r\n            var videoTrackSelectionFactory = new AdaptiveTrackSelection.Factory(_bandwidthMeter);\r\n            _trackSelector = new DefaultTrackSelector(videoTrackSelectionFactory);\r\n            _player = ExoPlayerFactory.NewSimpleInstance(Application.Context, _trackSelector);\r\n\r\n            // This is the MediaSource representing the media to be played.\r\n            DefaultBandwidthMeter bandwidthMeterA = new DefaultBandwidthMeter();\r\n            var dataSrcFacroty = new DefaultDataSourceFactory(Application.Context, \"blabla\", bandwidthMeterA);\r\n            var chunkSrcFactory = new DefaultDashChunkSource.Factory(dataSrcFacroty);\r\n\r\n            var mediaSource = new HlsMediaSource(_uri, dataSrcFacroty, 1, null, null);\r\n\r\n            _player.Prepare(mediaSource);\r\n            _player.PlayWhenReady = true;\r\n            \r\n            #int[] _textures = new int[1];\r\n            ...\r\n            GL.Enable(EnableCap.Texture2D);\r\n            GL.GenTextures(1, _textures);\r\n            GL.BindTexture(TextureTarget.Texture2D, _textures[0]);\r\n\r\n            GL.TexImage2D(\r\n                TextureTarget.Texture2D,\r\n                0,\r\n                PixelInternalFormat.Rgba,\r\n                Width,\r\n                Height,\r\n                0,\r\n                OpenTK.Graphics.ES20.PixelFormat.Rgb,\r\n                PixelType.UnsignedByte, \r\n                _data);\r\n\r\n            var st = new SurfaceTexture(_textures[0], true);\r\n            _surface = new Surface(st);\r\n           _payer.SetVideoSurface(_surface);\r\n\r\n            GL.BindTexture(TextureTarget.Texture2D, 0);\r\n```\r\n\r\nAlas, I don't see any changes in my texture.\r\nWhat I'm doing wrong?"
    },
    "satisfaction_conditions": [
      "Video frames must be accessible as OpenGL textures",
      "Video rendering must occur without visible UI elements",
      "Correct texture target type must be used for video decoding",
      "Video decoder output must be properly connected to the OpenGL texture system"
    ],
    "created_at": "2018-03-03T12:46:06Z"
  },
  {
    "id": "https://github.com/google/ExoPlayer/issues/3930",
    "source": {
      "issue_number": 3930
    },
    "initial_question": {
      "title": "Failed to resolve: com.google.android.exoplayer:exoplayer-core:r2.7.0 ",
      "body": "Android studio 3.0\r\ngradle version 4.1\r\n\r\nUnable to resolve 2.7.0 dependencies?\r\n\r\n"
    },
    "satisfaction_conditions": [
      "Dependency declaration syntax matches the correct format for the ExoPlayer version",
      "ExoPlayer library is properly referenced according to current version naming conventions"
    ],
    "created_at": "2018-03-03T10:00:54Z"
  },
  {
    "id": "https://github.com/google/ExoPlayer/issues/3894",
    "source": {
      "issue_number": 3894
    },
    "initial_question": {
      "title": "Does ExoPlayer have the OnSeekCompleteListener?",
      "body": "MediaPlayer class has the OnSeekCompleteListener.\r\n\r\nIf not, I can work around it by checking the current position got updated or not after seeking.\r\nFor the cleanliness of my code, I was looking for the OnSeekCompleteListener but could not find it.\r\n\r\nDoes ExoPlayer not have the listener or I am just not finding it?"
    },
    "satisfaction_conditions": [
      "A seek completion notification mechanism exists",
      "The notification mechanism is part of ExoPlayer's official API",
      "The solution provides equivalent functionality to MediaPlayer's OnSeekCompleteListener",
      "The implementation maintains code cleanliness"
    ],
    "created_at": "2018-02-23T22:44:06Z"
  },
  {
    "id": "https://github.com/google/ExoPlayer/issues/3874",
    "source": {
      "issue_number": 3874
    },
    "initial_question": {
      "title": "How to display ads of previous player",
      "body": "Hi!\r\n\r\nMy app:\r\nI have an app that consists of a screen with a list of players with ads. (I am using RecyclerView).\r\nWhen the user scrolls the main screen and a video was playing, I display this video in a smaller player at the bottom of the screen (like youtube).\r\n\r\nTo display the smaller video, I create a new player and update it with content position of previous player.\r\n\r\nMy problem:\r\nWhen the user scrolls and an ads is playing, when updating the new player with content position of previous player, the ads starts to play from the beginning and not from the position that it had stopped in the other player. (I am reusing AdsLoader and )\r\n\r\nMy question:\r\nI would like to know if there is any way I can display ads from the position it stopped in previously player. \r\n\r\nCan someone help me, please?\r\n\r\nSome code:\r\n\r\n```\r\nMediaSource mediaSource = buildMediaSource(Uri.parse(url));\r\nString adTag = getAdsUrl();\r\n\r\n if (adTag != null) {\r\n    if (!reuseAds) {\r\n         releaseAdsLoader();\r\n         mAdsLoader = new ImaAdsLoader(context, Uri.parse(adTag));\r\n    }\r\n    mediaSource = new AdsMediaSource(mediaSource, new AdsMediaSourceFactory(), mAdsLoader, playerView.getOverlayFrameLayout(), null, null);\r\n}\r\n\r\nplayer.seekTo(position);\r\nplayer.setPlayWhenReady(true);\r\n\r\nplayer.prepare(mediaSource,false,false);\r\n```"
    },
    "satisfaction_conditions": [
      "Ad playback must resume from the previous position when transitioning to the smaller player",
      "Previous player instance must be properly cleaned up before new player initialization",
      "Ad loader state must be preserved between player transitions"
    ],
    "created_at": "2018-02-21T11:40:09Z"
  },
  {
    "id": "https://github.com/google/ExoPlayer/issues/3637",
    "source": {
      "issue_number": 3637
    },
    "initial_question": {
      "title": "Continue buffering while in pause",
      "body": "Hi!\r\n\r\nCurrently when player is paused it stops to receive new data in buffer.\r\nIs it possible to continue buffering while player is in pause state?\r\n\r\nIf there is no other options, guess, I could use Cache feature to save data in separate thread and then use cached data to play when it is buffered enough while in pause. If it is the case, could you please explain should I use Downloader to save data in one thread and then use another Cache with the link to the same DataSpec or can I use the same Cache instance in another thread for playback?\r\n\r\nThanks!"
    },
    "satisfaction_conditions": [
      "Media buffering continues while player is paused",
      "Buffer size remains within system memory constraints",
      "Concurrent cache access is handled safely",
      "Buffer size is configurable",
      "Buffering state is independent of playback state"
    ],
    "created_at": "2017-12-24T16:44:31Z"
  },
  {
    "id": "https://github.com/google/ExoPlayer/issues/3585",
    "source": {
      "issue_number": 3585
    },
    "initial_question": {
      "title": "Unable do play content after upgrading to ExoPlayer 2.6.0 from 1.2.X",
      "body": "We were using ExoPlayer 1.2.X for a while now and decided to upgrade to 2.6.0, but our content won't play, returning some toasts:\r\n\r\n\"Media includes video tracks, but none are playable by this device\"\r\n\r\nand\r\n\r\n\"Media includes audio tracks, but none are playable by this device\"\r\n\r\nWe tried playing in several emulators from Android 6 to 8, and on a Samsung Galaxy S8+ running Android 7.0\r\n\r\nHow to reproduce the issue:\r\n\r\nPlayer Version: 2.6.0\r\nDevice: Pixel XL - API 24\r\n\r\n1 - Downloand ExoPlayer version 2.6.0 release.\r\n\r\n2 - Add the given media uri and drm_license_url using the drm_scheme \"widevine\" to the media.exolist.json.\r\n\r\n3 - Run the ExoPlayer and try to play the media.\r\n\r\nThe media uri, proxy url and bugreport file were sent to dev.exoplayer@gmail.com\r\n\r\nThank you in advance for the help!\r\n"
    },
    "satisfaction_conditions": [
      "Media content type must be correctly identified by the player",
      "DRM scheme compatibility must be properly declared in the manifest",
      "Player must be able to verify DRM scheme support before playback",
      "Configuration must include all required streaming parameters"
    ],
    "created_at": "2017-12-13T17:09:36Z"
  },
  {
    "id": "https://github.com/google/ExoPlayer/issues/3563",
    "source": {
      "issue_number": 3563
    },
    "initial_question": {
      "title": "[Question] How to get the startTime and endTime from TextRenderer.Output cues",
      "body": "Hi there!\r\nI'm currently implementing the TextRenderer.Output to received the List of Cues for WebVtt captions, and then I'm displaying those captions in our custom caption view.\r\nThe problem is that WebvttCue class is package-private so we can't cast it, so that we can use the startTime and endTime.\r\nIs there a reason to keep that class as package-private? What alternative do I have?\r\n\r\nThanks!\r\n"
    },
    "satisfaction_conditions": [
      "Captions must display and update correctly based on TextRenderer.Output callbacks",
      "Caption transitions must occur smoothly without manual timing management",
      "Captions must clear appropriately when new cues are received",
      "Solution must work within the public API boundaries",
      "Caption display must maintain synchronization with media playback"
    ],
    "created_at": "2017-12-07T19:28:54Z"
  },
  {
    "id": "https://github.com/google/ExoPlayer/issues/3509",
    "source": {
      "issue_number": 3509
    },
    "initial_question": {
      "title": "EventListener.onTimelineChanged howto get current window",
      "body": "I'm using ExoPlayer 2.6.0 and made a simple Activity which creates a ConcatenatingMediaSource of some ExtractorMediaSource with http URL to Videos. All playing in endless loop without any issues.\r\n\r\nNow i want to get the current window+position when the video changes. So i implement the DefaultEventListener and override the onTimelineChanged method.\r\n\r\nIf i ask my player within this method using player.getCurrentPeriodIndex() and player.getCurrentWindowIndex() i do not get the right values.\r\nAre those values updated after the onTimelineChanged Event is fired? I also tried the onTracksChanged event, but with the same results.\r\n\r\nIs there another way to get the current window directly after a new video was loaded? I looked in the EventLogger from the sample, but i could not find the right spot for my needed information.\r\n\r\nIf i put a Handler with a periodic postDelayed runnable to poll the getCurrentPeriodIndex and getCurrentWindowIndex i get the right results.\r\n\r\nI'd rather not do the polling since i want to syncronise some players via network.\r\n\r\nI'm using an Android TV box running 6.0.1 my App Compile SDK is 26, target 26, min 23. Build Tools Version 26.0.2\r\n\r\n"
    },
    "satisfaction_conditions": [
      "Accurate window index detection when media changes",
      "Real-time window index updates without polling",
      "Event-based notification of media transitions",
      "Compatible with ExoPlayer's concatenated media playback"
    ],
    "created_at": "2017-11-28T01:14:50Z"
  },
  {
    "id": "https://github.com/google/ExoPlayer/issues/3338",
    "source": {
      "issue_number": 3338
    },
    "initial_question": {
      "title": "Determin when video is stalled",
      "body": "Hello! \r\nI wonder can i determine that video is stalled for buffering?\r\nI try check onPlayerStateChanged. But i don't see ability to get real state of player. I see that STATE_BUFFERING don't mean that player stop video.  \r\nI need to track how many times video is stalled for buffering,"
    },
    "satisfaction_conditions": [
      "Player state transitions accurately reflect actual video buffering events",
      "Buffering events can be reliably counted",
      "State transitions are observable and loggable",
      "Distinction between buffering and normal playback states is clear"
    ],
    "created_at": "2017-10-10T15:14:38Z"
  },
  {
    "id": "https://github.com/google/ExoPlayer/issues/3177",
    "source": {
      "issue_number": 3177
    },
    "initial_question": {
      "title": "skipping 10 sec forward of backward",
      "body": "First of all I want to say sorry if this is duplicate question, I couldn't find the same or similar question.\r\n\r\nQuestion:\r\nIs there an option in exoplayer that allows skipping 10 seconds forward or backward? This feature is something like on YouTube when you press right or left arrow( J or L keys).\r\n\r\nThanks"
    },
    "satisfaction_conditions": [
      "Player must be able to advance playback position by 10 seconds",
      "Player must be able to rewind playback position by 10 seconds",
      "Seeking operation must be triggered programmatically",
      "Current playback position must be accessible"
    ],
    "created_at": "2017-08-16T07:55:07Z"
  },
  {
    "id": "https://github.com/google/ExoPlayer/issues/3124",
    "source": {
      "issue_number": 3124
    },
    "initial_question": {
      "title": "Question: Is there a same function in v2 for onDownstreamFormatChanged(v1)",
      "body": "I am upgrading a video app from v1 to v2,  there is a third party logic added in the method onDownstreamFormatChanged as below \r\nfor example in the DemoPlayer in v1:\r\n```\r\n@Override\r\n\tpublic void onDownstreamFormatChanged(int sourceId, Format format, int trigger, long mediaTimeMs) {\r\n\t\tif (infoListener == null) {\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif (sourceId == TYPE_VIDEO) {\r\n\t\t\tvideoBitrate = format.bitrate;\r\n\t\t\tvideoFormat = format;\r\n\t\t\tinfoListener.onVideoFormatEnabled(format, trigger, mediaTimeMs);\r\n\t\t} else if (sourceId == TYPE_AUDIO) {\r\n\t\t\taudioBitrate = format.bitrate;\r\n\t\t\tinfoListener.onAudioFormatEnabled(format, trigger, mediaTimeMs);\r\n\t\t}\r\n\r\n\t\tif (videoBitrate > 0 && audioBitrate > 0) {\r\n\t\t\tAnalyticsManager.onBitrateChange(((audioBitrate + videoBitrate) / 1000));\r\n\t\t}\r\n\t}\r\n```\r\nas you can see there is a piece of code  AnalyticsManager.onBitrateChange(((audioBitrate + videoBitrate) / 1000));   is there function that i can add this code in the exoplayer v2?\r\n\r\nThanks in advance.\r\n\r\n"
    },
    "satisfaction_conditions": [
      "Format change events must be detectable",
      "Compatibility with ExoPlayer v2's architecture"
    ],
    "created_at": "2017-08-01T03:08:45Z"
  },
  {
    "id": "https://github.com/google/ExoPlayer/issues/3065",
    "source": {
      "issue_number": 3065
    },
    "initial_question": {
      "title": "Change Subtitles Style",
      "body": "am developing simple video player with vtt subtitles\r\nI want to change styles for captions by\r\n\r\n      private void configureSubtitleView() {\r\n        int defaultSubtitleColor = Color.argb(255, 218, 218, 218);\r\n        int outlineColor = Color.argb(255, 43, 43, 43);\r\n        Typeface subtitleTypeface = Typeface.createFromAsset(getAssets(), \"fonts/droid.ttf\");\r\n        CaptionStyleCompat style =\r\n                new CaptionStyleCompat(defaultSubtitleColor,\r\n                        Color.TRANSPARENT, Color.TRANSPARENT,\r\n                        CaptionStyleCompat.EDGE_TYPE_OUTLINE,\r\n                        outlineColor, subtitleTypeface);\r\n        subtitleLayout.setStyle(style);\r\n        subtitleLayout.setFractionalTextSize(SubtitleView.DEFAULT_TEXT_SIZE_FRACTION * fontScale);\r\n    }\r\n\r\nand call it in **onCreate** method, but nothing changed. is that an issue or I have missed something."
    },
    "satisfaction_conditions": [
      "Custom subtitle styles are successfully applied and visible during video playback",
      "Default/embedded subtitle styles are properly overridden",
      "Style changes are applied to the correct subtitle view component"
    ],
    "created_at": "2017-07-14T13:19:49Z"
  },
  {
    "id": "https://github.com/google/ExoPlayer/issues/3061",
    "source": {
      "issue_number": 3061
    },
    "initial_question": {
      "title": "Question:How to set max bit rate in exoplayer v2",
      "body": "I am now doing the video app of dash, there is a requirement to let the user choose video quality\r\nthere are 4 types (auto, high, medium,low),  the high, medium,low will be configed in the backend.\r\n\r\nI know there is a method in v1 DashRendererBuilder.setMaxBitrate(maxBitrate); but is there an easy way to set it in v2?\r\nThanks."
    },
    "satisfaction_conditions": [
      "Video quality selection options must be configurable between auto, high, medium, and low settings",
      "Maximum video bitrate must be enforceable during initial playback",
      "Auto mode must allow for maximum available quality"
    ],
    "created_at": "2017-07-13T15:52:23Z"
  },
  {
    "id": "https://github.com/google/ExoPlayer/issues/2990",
    "source": {
      "issue_number": 2990
    },
    "initial_question": {
      "title": "Background music during video playback",
      "body": "\r\n\r\n### Issue description\r\nI want to implement background music during video playback. I thought of MergingMediaSource, but it seems it does not support this scenario.\r\nYou can have multiple AudioTrack run in parallel, the result is fine. \r\n\r\nSimilar issue is #2200 , but it is closed."
    },
    "satisfaction_conditions": [
      "Background music plays simultaneously with video audio",
      "Audio playback matches synchronization requirements"
    ],
    "created_at": "2017-06-23T12:55:20Z"
  },
  {
    "id": "https://github.com/google/ExoPlayer/issues/2823",
    "source": {
      "issue_number": 2823
    },
    "initial_question": {
      "title": "A more convenient access to certain lifecycle event ",
      "body": "Hello,\r\n\r\nThis is a request for a small adjustment.\r\n\r\nIn the `LoadControl` interface lies a certain number of very useful methods related to the exoplayer lifecycle:\r\n\r\nonPrepared()\r\nonReleased()\r\nonStopped()\r\n\r\nHowever at this point, we can only pass one instance of a `LoadControl` implementation into the `ExoPlayerFactory`, and by default this implementation is `DefaultLoadControl`, a class marked as final.\r\n\r\nRight now, the only way I can access these callbacks in my project is by implementing my own `LoadControl` logic (that is copy pasting the DefaultLoadControl class and tweaking it a bit).\r\n\r\nI think these kind of callbacks deserve their own separate interface so they can be accessed more conveniently.\r\n\r\nThanks"
    },
    "satisfaction_conditions": [
      "Player readiness state must be accurately detectable",
      "State detection must be consistent and non-repeating",
      "Detection method must be thread-safe for external logic",
      "Ready state must indicate actual playback readiness"
    ],
    "created_at": "2017-05-14T13:10:45Z"
  },
  {
    "id": "https://github.com/google/ExoPlayer/issues/2764",
    "source": {
      "issue_number": 2764
    },
    "initial_question": {
      "title": "Adding request headers to ExtractorMediaSource ",
      "body": "Hello,\r\n I need to add request headers for playing video with exoplayer. I could see it was available with ExtractorSampleSource and I could not add the same with ExtractorMediaSource. Also i dont see  ExtractorSampleSource part of r2.3.1.  Kindly help"
    },
    "satisfaction_conditions": [
      "Request headers can be successfully added to video playback requests",
      "Solution works with ExtractorMediaSource",
      "Implementation is compatible with ExoPlayer version r2.3.1 or higher"
    ],
    "created_at": "2017-05-03T13:20:53Z"
  },
  {
    "id": "https://github.com/google/ExoPlayer/issues/2504",
    "source": {
      "issue_number": 2504
    },
    "initial_question": {
      "title": "Media Metadata tags",
      "body": "First thanks to this awesome library . \r\n\r\nSecond simply : **how can i get** loaded media(MP3/OGG/..) **meta data**(Artist , name,track no ,year and .. ) ? \r\nWhat about audio file artwork graphic ?"
    },
    "satisfaction_conditions": [
      "Successfully retrieves metadata fields (artist, name, track number, year) from supported audio formats",
      "Provides access to audio file artwork/cover graphics when available",
      "Handles multiple potential metadata sources within a single media file",
      "Works with the library's track selection system",
      "Provides clear indication when metadata is not available"
    ],
    "created_at": "2017-02-26T12:42:32Z"
  },
  {
    "id": "https://github.com/google/ExoPlayer/issues/2460",
    "source": {
      "issue_number": 2460
    },
    "initial_question": {
      "title": "How to hide all control components?",
      "body": "How to hide all controllers  (start button, pause, and so on) that they did not exist, and the screen will always full.\r\n\r\nI looked, there is simpleExoPlayerView.setUseController(true) method;\r\n\r\nBut it deactivate the player ...\r\n\r\n```\r\npublic void setUseController (boolean useController) {\r\n    this.useController = useController;\r\nif (useController) {\r\n      controller.setPlayer(player);\r\n    } else {\r\n      controller.hide();\r\n      controller.setPlayer(null);\r\n    }\r\n}\r\n```\r\nHow to hide or delete these components?"
    },
    "satisfaction_conditions": [
      "Player controls are not visible on screen",
      "Video player remains functional",
      "Changes persist while video is playing"
    ],
    "created_at": "2017-02-16T04:02:53Z"
  },
  {
    "id": "https://github.com/google/ExoPlayer/issues/2407",
    "source": {
      "issue_number": 2407
    },
    "initial_question": {
      "title": "Font color of subtitle is not changing using CaptionStyleCompat",
      "body": "My requirement is to change the font color of Closed caption sub title text. For fulfill requirement I am using\r\n```\r\ncaptionStyleCompat = new CaptionStyleCompat(Color.BLACK, Color.BLUE, Color.TRANSPARENT, CaptionStyleCompat.EDGE_TYPE_DROP_SHADOW, Color.GREEN, null);\r\n\r\nsimpleExoPlayerView.getSubtitleView().setStyle(captionStyleCompat);\r\n```\r\nAs per above method my subtitle font color should be black. but still it is default color that is white where as background color has been changed from black to blue.\r\nWhy font color is not changed to black from its default color? I am also changing different color of first and second parameter. All the time background has been changed but foreground has not been changed.\r\n\r\nAs per documentation there is no any method found to change the font color of subtitle text.\r\n"
    },
    "satisfaction_conditions": [
      "Custom caption styles take precedence over embedded media styles",
      "Background color changes remain functional"
    ],
    "created_at": "2017-02-01T10:46:36Z"
  },
  {
    "id": "https://github.com/google/ExoPlayer/issues/2357",
    "source": {
      "issue_number": 2357
    },
    "initial_question": {
      "title": "set equalizer",
      "body": "Hello! I got following code to play mp3 tracks. What should i do to get audioSessionId correct? When i try with getAudioSessionId() and give result to equalizer constructor it says following:\r\nRuntimeException: Cannot initialize effect engine for type: 0bed4300-ddd6-11db-8f34-0002a5d5c51b Error: -3.\r\n\r\nMy code:\r\n```\r\n private void createPlayer(){\r\n        TrackSelector trackSelector = new DefaultTrackSelector();\r\n        LoadControl loadControl = new DefaultLoadControl();\r\n        player = ExoPlayerFactory.newSimpleInstance(context, trackSelector, loadControl);\r\n        player.addListener(this);\r\n    }\r\n\r\npublic void playTrack(Track track) {\r\n        createPlayer();\r\n        this.track = track;\r\n        this.url = track.getPath();\r\n        Uri builtUri = Uri.parse(url);\r\n        DataSource.Factory dataSourceFactory = new DefaultDataSourceFactory(context, Util.getUserAgent(context, \"yourApplicationName\"));\r\n        ExtractorsFactory extractorsFactory = new DefaultExtractorsFactory();\r\n        MediaSource streamSource = new ExtractorMediaSource(builtUri, dataSourceFactory, extractorsFactory, null, null);\r\n        isNotificated = false;\r\n        type = Player_Fragment.Type.MEMORY;\r\n        setVolumeMax();\r\n        player.prepare(streamSource);\r\n        player.setPlayWhenReady(true);\r\n}\r\n```"
    },
    "satisfaction_conditions": [
      "Audio session ID changes must be detectable by the application"
    ],
    "created_at": "2017-01-22T16:10:22Z"
  },
  {
    "id": "https://github.com/google/ExoPlayer/issues/2286",
    "source": {
      "issue_number": 2286
    },
    "initial_question": {
      "title": "SimpleExoPlayer.setVideoListener() causes rendering issues r2.1.1",
      "body": "Setting SimpleExoPlayer.VideoListener() causes rendering issues (SimpleExoPlayerView does not show any frames). audio plays fine and even the VideoListener's are invoked properly. Am I missing something here?\r\nFollowing code illustrates the problem.\r\n\r\n```\r\n   private void playStream(final Uri mediaUrl) {\r\n        Log.d(LOGTAG, \"Now playing: \" + mediaUrl);\r\n        mUrl.setText(mediaUrl.toString());\r\n        // Measures bandwidth during playback. Can be null if not required.\r\n        DefaultBandwidthMeter bandwidthMeter = new DefaultBandwidthMeter();\r\n        // Produces DataSource instances through which media data is loaded.\r\n        DataSource.Factory dataSourceFactory = new DefaultDataSourceFactory(this, Util.getUserAgent(this, \"yourApplicationName\"), bandwidthMeter);\r\n        // Produces Extractor instances for parsing the media data.\r\n        ExtractorsFactory extractorsFactory = new DefaultExtractorsFactory();\r\n        // This is the MediaSource representing the media to be played.\r\n        MediaSource videoSource;\r\n        if(mediaUrl.getLastPathSegment().contains(\".m3u8\"))\r\n            videoSource = new HlsMediaSource(mediaUrl,dataSourceFactory, 10, null, null);\r\n        else\r\n            videoSource = new ExtractorMediaSource(mediaUrl,dataSourceFactory, extractorsFactory, null, null);\r\n        // Following listener breaks rendering\r\n        player.setVideoListener(new SimpleExoPlayer.VideoListener() {\r\n            @Override\r\n            public void onVideoSizeChanged(int width, int height, int unappliedRotationDegrees, float pixelWidthHeightRatio) {\r\n                Log.e(LOGTAG, \"onVideoSizeChanged: \" + width + \":\" +height);\r\n            }\r\n\r\n            @Override\r\n            public void onRenderedFirstFrame() {\r\n                Log.e(LOGTAG, \"onRenderedFirstFrame \");\r\n            }\r\n        });\r\n        // Prepare the player with the source.\r\n        player.prepare(videoSource);\r\n        player.setPlayWhenReady(true);\r\n    }\r\n```\r\nReplacing setVideoListener() with setVideoDebugListener() solves the issue.\r\nTested on Nexus 9 running 7.0"
    },
    "satisfaction_conditions": [
      "Video frames must render correctly in SimpleExoPlayerView",
      "SimpleExoPlayerView must receive necessary video events",
      "Custom video statistics/debugging must be possible without disrupting playback",
      "Audio playback must remain functional"
    ],
    "created_at": "2017-01-03T14:12:35Z"
  },
  {
    "id": "https://github.com/google/ExoPlayer/issues/2053",
    "source": {
      "issue_number": 2053
    },
    "initial_question": {
      "title": "Playlist refresh UI",
      "body": "onPlayerStateChanged it's not called when a playlist change from one song to another\r\n"
    },
    "satisfaction_conditions": [
      "UI updates correctly when playlist transitions between tracks",
      "Track transition detection is implemented",
      "Current track position/index is accurately retrieved",
      "Solution works with seamless transitions"
    ],
    "created_at": "2016-11-09T20:16:37Z"
  },
  {
    "id": "https://github.com/google/ExoPlayer/issues/1918",
    "source": {
      "issue_number": 1918
    },
    "initial_question": {
      "title": "[Question] Reuse BOTH SimpleExoPlayerView and SimpleExoPlayer after STATE_ENDED",
      "body": "Assuming that I have played a local Video, using those 2 components. After the player reaches STATE_ENDED, it seems that it is not trivial to restart the playback again. What should I do if I want to \"click to one button\" to restart the playback from all over again.\n\nThanks and pardon me if I'm missing some thing.\n"
    },
    "satisfaction_conditions": [
      "Video playback can be restarted after reaching STATE_ENDED",
      "Restart functionality is triggered by a single user action",
      "Video restarts from the beginning position",
      "ExoPlayer components remain reusable"
    ],
    "created_at": "2016-10-09T04:40:11Z"
  },
  {
    "id": "https://github.com/google/ExoPlayer/issues/1501",
    "source": {
      "issue_number": 1501
    },
    "initial_question": {
      "title": "Question: Using existing components with multiple instances of Exoplayer",
      "body": "I'm playing audio from MP3 files and I'm using two instances of Exoplayer, one to play and one to hold and prepare the next track for gapless playback.\n\nMy question is which of the Exoplayer components can be re-used and static and which needs to be recreated?\nSome of the components I'm using:\nOkHttpClient\nOkHttp3.CacheControl\nOkHttpDataSource\nExtractorSampleSource\nMp3Extractor\nMetadataTrackRenderer\nId3Parser\n\nThanks\n"
    },
    "satisfaction_conditions": [
      "Components are properly isolated between Exoplayer instances",
      "Resource management is efficient"
    ],
    "created_at": "2016-05-05T12:18:38Z"
  },
  {
    "id": "https://github.com/google/ExoPlayer/issues/1481",
    "source": {
      "issue_number": 1481
    },
    "initial_question": {
      "title": "Can't suppurt flv format to seek",
      "body": "flvxtractor.java\n\nthe isSeekAble return false.\n"
    },
    "satisfaction_conditions": [
      "Application correctly reports seeking capability"
    ],
    "created_at": "2016-04-28T08:15:50Z"
  },
  {
    "id": "https://github.com/google/ExoPlayer/issues/1469",
    "source": {
      "issue_number": 1469
    },
    "initial_question": {
      "title": "[Question] Tracking Playback in HLS",
      "body": "Hello, \n\nThanks for the great lib. I am streaming HLS (m3u8 files) for an audio app I'm building. I need to be able to track how much of the audio has been listened to. I'm having a difficult time trying to figure out where to hook into the player to gather this information. Is this possible? If so, what class/listener should I look at? Thanks!\n"
    },
    "satisfaction_conditions": [
      "Ability to measure current playback progress",
      "Compatible with HLS streaming format",
      "Real-time tracking capability",
      "Accessible through player interface"
    ],
    "created_at": "2016-04-25T14:30:04Z"
  },
  {
    "id": "https://github.com/google/ExoPlayer/issues/1462",
    "source": {
      "issue_number": 1462
    },
    "initial_question": {
      "title": "Support for different encryption keys for video and audio AdaptionSets",
      "body": "Hi,\n\nThe latest security update from Widevine strongly advises that we need to use a distinct content encryption keys for video and audio tracks.\n\nFurthermore, after discussing directly, it appears that the Chrome CDM will enforce this configuration as mandatory at some point.\n\nI have tested such content against ExoPlayer 1.5.7 and it appears that the player will only currently generate 1 key request per streaming session, regardless of the fact that two different default keyIDs are specified for each AdaptionSet (in my case Audio and Video).\n\nSo my questions are \n1. Are my suppositions correct on this?\n2. Would you consider adding support for this use-case as an enhancement.  If Chrome forces this, we (and others) could potentially have no choice but to generate content that is not compatible with ExoPlayer...\n\nI will send a private mail with details on the content sample I am using to determine my findings.  \n"
    },
    "satisfaction_conditions": [
      "Player must handle content with different encryption keys for audio and video tracks"
    ],
    "created_at": "2016-04-22T13:51:58Z"
  },
  {
    "id": "https://github.com/google/ExoPlayer/issues/1284",
    "source": {
      "issue_number": 1284
    },
    "initial_question": {
      "title": "onPlayerError improvement",
      "body": "Dear colleagues,\nI have an inquire about passing additional information with an error in ExoPlayer.\nI am talking about **StreamingDrmSessionManager.java** and it's method:\n`void onKeyResponse(Object response)`\nIn case of any error with License retrieving, our server returns important information with \"**Object response**\" and this causing exception in next line:\n`mediaDrm.provideKeyResponse(sessionId, (byte[]) response);`\nThat is OK. But, however, we loosing that information form client side.\nSo I am asking, whether it is possible to by-pass response with Exception, so it will be possible to get it in \"onPlayerError\" callback ?\n\nAs possible solution now, we inject custom listener into WidevineMediaDrmCallback.java and parse \n`byte[] executeKeyRequest(final UUID uuid, final MediaDrm.KeyRequest request)`\nresponse in order to intercept message.\n\nThanks a lot in advance.\n"
    },
    "satisfaction_conditions": [
      "Error information from the license server must be accessible in the application code",
      "Error handling must occur in a single location without duplicate error events",
      "DRM license retrieval errors must be properly propagated through the error handling system",
      "Custom error information must be preserved when propagating through ExoPlayer's error system"
    ],
    "created_at": "2016-02-19T04:15:00Z"
  },
  {
    "id": "https://github.com/google/ExoPlayer/issues/1255",
    "source": {
      "issue_number": 1255
    },
    "initial_question": {
      "title": "Get duration of online mp3 file",
      "body": "I wonder when it's safe to `getDuration()` of the audio track. I just need it once as fast as possible. \nWhen I try to get it immediately after `exoPlayer.prepare()` then I get `UNKNOWN_TIME`.\nDidn't find an example in demo project. \nLooks like I need to do it in listener when playback status changed to `ExoPlayer.STATE_READY`, but then there will be useless getDuration on each play/pause action.\n"
    },
    "satisfaction_conditions": [
      "Duration retrieval must occur only once per audio track",
      "Duration retrieval must occur after the audio track is fully loaded and ready"
    ],
    "created_at": "2016-02-11T10:51:01Z"
  },
  {
    "id": "https://github.com/google/ExoPlayer/issues/1248",
    "source": {
      "issue_number": 1248
    },
    "initial_question": {
      "title": "Multiple ExoPlayer instances using one SurfaceHolder",
      "body": "Is it possible to create more than one instance of `ExoPlayer` and use the same `SurfaceHolder`? I have the use case where I need one player for streaming content, and another for streaming client side ads. Only one player is supposed to play/show at a time, and they are directly on top of each other. Is there any way I can do this with just a single SurfaceHolder? I'm pretty sure it's only the `MediaCodec` api complaining with this error:\n\n`E/MediaCodec: native_window_api_connect returned an error: Invalid argument (-22)`\n`E/MediaCodec: configure failed with err 0xffffffea, resetting...`\n\nFollowed by an ExoPlayer exception:\n\n```\nE/ExoPlayerImplInternal: Internal track renderer error.\n    com.google.android.exoplayer.ExoPlaybackException: com.google.android.exoplayer.MediaCodecTrackRenderer$DecoderInitializationException: Decoder init failed: OMX.qcom.video.decoder.avc, MediaFormat(null, video/avc, -1, -1, 704, 396, -1, 1.0, -1, -1, null, -1, false, 1280, 720)\n    at com.google.android.exoplayer.MediaCodecTrackRenderer.notifyAndThrowDecoderInitError(MediaCodecTrackRenderer.java:388)\n    at com.google.android.exoplayer.MediaCodecTrackRenderer.maybeInitCodec(MediaCodecTrackRenderer.java:374)\n    at com.google.android.exoplayer.MediaCodecTrackRenderer.onInputFormatChanged(MediaCodecTrackRenderer.java:729)\n    at com.google.android.exoplayer.MediaCodecVideoTrackRenderer.onInputFormatChanged(MediaCodecVideoTrackRenderer.java:334)\n    at com.google.android.exoplayer.MediaCodecTrackRenderer.readFormat(MediaCodecTrackRenderer.java:496)\n    at com.google.android.exoplayer.MediaCodecTrackRenderer.doSomeWork(MediaCodecTrackRenderer.java:479)\n    at com.google.android.exoplayer.SampleSourceTrackRenderer.doSomeWork(SampleSourceTrackRenderer.java:129)\n    at com.google.android.exoplayer.ExoPlayerImplInternal.doSomeWork(ExoPlayerImplInternal.java:431)\n    at com.google.android.exoplayer.ExoPlayerImplInternal.handleMessage(ExoPlayerImplInternal.java:213)\n    at android.os.Handler.dispatchMessage(Handler.java:98)\n    at android.os.Looper.loop(Looper.java:135)\n    at android.os.HandlerThread.run(HandlerThread.java:61)\n    at com.google.android.exoplayer.util.PriorityHandlerThread.run(PriorityHandlerThread.java:40)\n    Caused by: com.google.android.exoplayer.MediaCodecTrackRenderer$DecoderInitializationException: Decoder init failed: OMX.qcom.video.decoder.avc, MediaFormat(null, video/avc, -1, -1, 704, 396, -1, 1.0, -1, -1, null, -1, false, 1280, 720)\n    at com.google.android.exoplayer.MediaCodecTrackRenderer.maybeInitCodec(MediaCodecTrackRenderer.java:374)\u00a0\n    at com.google.android.exoplayer.MediaCodecTrackRenderer.onInputFormatChanged(MediaCodecTrackRenderer.java:729)\u00a0\n    at com.google.android.exoplayer.MediaCodecVideoTrackRenderer.onInputFormatChanged(MediaCodecVideoTrackRenderer.java:334)\u00a0\n    at com.google.android.exoplayer.MediaCodecTrackRenderer.readFormat(MediaCodecTrackRenderer.java:496)\u00a0\n    at com.google.android.exoplayer.MediaCodecTrackRenderer.doSomeWork(MediaCodecTrackRenderer.java:479)\u00a0\n    at com.google.android.exoplayer.SampleSourceTrackRenderer.doSomeWork(SampleSourceTrackRenderer.java:129)\u00a0\n    at com.google.android.exoplayer.ExoPlayerImplInternal.doSomeWork(ExoPlayerImplInternal.java:431)\u00a0\n    at com.google.android.exoplayer.ExoPlayerImplInternal.handleMessage(ExoPlayerImplInternal.java:213)\u00a0\n    at android.os.Handler.dispatchMessage(Handler.java:98)\u00a0\n    at android.os.Looper.loop(Looper.java:135)\u00a0\n    at android.os.HandlerThread.run(HandlerThread.java:61)\u00a0\n    at com.google.android.exoplayer.util.PriorityHandlerThread.run(PriorityHandlerThread.java:40)\u00a0\n    Caused by: android.media.MediaCodec$CodecException: Error 0xffffffea\n    at android.media.MediaCodec.native_configure(Native Method)\n    at android.media.MediaCodec.configure(MediaCodec.java:580)\n    at com.google.android.exoplayer.MediaCodecVideoTrackRenderer.configureCodec(MediaCodecVideoTrackRenderer.java:328)\n    at com.google.android.exoplayer.MediaCodecTrackRenderer.maybeInitCodec(MediaCodecTrackRenderer.java:363)\n    at com.google.android.exoplayer.MediaCodecTrackRenderer.onInputFormatChanged(MediaCodecTrackRenderer.java:729)\u00a0\n    at com.google.android.exoplayer.MediaCodecVideoTrackRenderer.onInputFormatChanged(MediaCodecVideoTrackRenderer.java:334)\u00a0\n    at com.google.android.exoplayer.MediaCodecTrackRenderer.readFormat(MediaCodecTrackRenderer.java:496)\u00a0\n    at com.google.android.exoplayer.MediaCodecTrackRenderer.doSomeWork(MediaCodecTrackRenderer.java:479)\u00a0\n    at com.google.android.exoplayer.SampleSourceTrackRenderer.doSomeWork(SampleSourceTrackRenderer.java:129)\u00a0\n    at com.google.android.exoplayer.ExoPlayerImplInternal.doSomeWork(ExoPlayerImplInternal.java:431)\u00a0\n    at com.google.android.exoplayer.ExoPlayerImplInternal.handleMessage(ExoPlayerImplInternal.java:213)\u00a0\n    at android.os.Handler.dispatchMessage(Handler.java:98)\u00a0\n    at android.os.Looper.loop(Looper.java:135)\u00a0\n    at android.os.HandlerThread.run(HandlerThread.java:61)\u00a0\n    at com.google.android.exoplayer.util.PriorityHandlerThread.run(PriorityHandlerThread.java:40)\n```\n\nHowever, when I use two separate `SurfaceHolder`'s, it doesn't complain. Has anyone had any similar issues? Or am I possibly doing something wrong?\n\nThanks.\n"
    },
    "satisfaction_conditions": [
      "Multiple video players must be able to render to the same display surface",
      "Only one player can actively use the display surface at any given time",
      "Clean handover of display surface access between players",
      "Previous player must fully release surface before new player can access it"
    ],
    "created_at": "2016-02-10T01:33:26Z"
  },
  {
    "id": "https://github.com/google/ExoPlayer/issues/1208",
    "source": {
      "issue_number": 1208
    },
    "initial_question": {
      "title": "Is there a state in EXO player like player is fast forwarding or rewinding?",
      "body": "Hello,\n\nI want to know is there a specific state when we FF or Reverse the playback. I know that when we FF or Reverse the play back, it comes into the MediaCodecaudioTrackrenderer's \"SeekTo(position)\" function to adjust he play back. \n\nWhat I am doing is, calling player.SeekTo function to adjust it's position to couple of milliseconds but I am not doing FF, so I just want to differentiate when will it actually FF through which function?\n\nThanks\n"
    },
    "satisfaction_conditions": [
      "Solution must maintain state at the application level",
      "System must capture user interaction context"
    ],
    "created_at": "2016-01-28T20:01:02Z"
  },
  {
    "id": "https://github.com/google/ExoPlayer/issues/1186",
    "source": {
      "issue_number": 1186
    },
    "initial_question": {
      "title": "HLS - Handling low buffer and seek with no network connection",
      "body": "I'm using ExoPlayer for audio only, HLS streams. As such, we can buffer quite a bit of audio which we want to continue playing even if the network drops or the device is put into airplane mode. In general that works fine, but there are a couple of no-network scenarios I'm trying to handle:\n1. Play through buffer \n2. Attempt to seek\n\nMy approach so far has been to register listeners with DefaultLoadControl and HlsSampleSource and to move my player into something similar to a buffering state when a load error is encountered. This solves the specific use cases I mentioned, but it doesn't give me very granular understanding of why loading failed. \n\nI realize that to some extent these are business / presentation layer concerns, but I'm wondering if there are recommended ways to address them in the context of ExoPlayer? For example, are there any ways to pause and resume loading? Is there a way to get a 'low buffer' warning before the loader kicks in? \n\nAny insights are greatly appreciated.\n"
    },
    "satisfaction_conditions": [
      "Player must continue playback from existing buffer when network connection is lost",
      "Player must enter appropriate state when buffer is depleted"
    ],
    "created_at": "2016-01-25T22:22:33Z"
  },
  {
    "id": "https://github.com/google/ExoPlayer/issues/1172",
    "source": {
      "issue_number": 1172
    },
    "initial_question": {
      "title": "DASH video track quality is set to max by default",
      "body": "hello.\n\nI am developing a player app using the demo app as reference and bumped into this issue. When launching player activity, selected video track is 1080p, not auto. and video tracks are listed in the following order:\n1080p\nauto\n720p\n480p\nWhat can be the cause? Any fix for this?\n"
    },
    "satisfaction_conditions": [
      "Video tracks must be organized in a logical quality hierarchy with 'auto' as the default option",
      "Different codec streams must be properly grouped in adaptation sets",
      "Device compatibility must be maintained for codec selection",
      "Resolution switching must occur without significant playback interruption",
      "Each codec group must have its own complete resolution ladder"
    ],
    "created_at": "2016-01-21T10:30:03Z"
  },
  {
    "id": "https://github.com/google/ExoPlayer/issues/1168",
    "source": {
      "issue_number": 1168
    },
    "initial_question": {
      "title": "Set Aspect Ratio of Frame",
      "body": "I am having an issue. i am streaming a video from my server where the URL is at passedWorkoutObject.workoutMediaURL. The video plays fine, but I need to scale the frame to the right aspect ratio. onVideoSizeChanged is not called with this code below. How do I get the aspect ratio of the frame so I can scale my frame?\n\n```\n       player = ExoPlayer.Factory.newInstance(2);\n\n\n        Allocator allocator = new DefaultAllocator(BUFFER_SEGMENT_SIZE);\n        DataSource dataSource = new DefaultUriDataSource(this, null, versionName);\n\n        MediaPresentationDescriptionParser parser = new MediaPresentationDescriptionParser();\n        UriDataSource manifestDataSource = new DefaultUriDataSource(this, versionName);\n        ManifestFetcher<MediaPresentationDescription> manifestFetcher = new ManifestFetcher<>(passedWorkoutObject.workoutMediaURL, manifestDataSource, parser);\n        final DefaultBandwidthMeter bandwidthMeter = new DefaultBandwidthMeter();\n\n        ExtractorSampleSource sampleSource = new ExtractorSampleSource(\n        Uri.parse(passedWorkoutObject.workoutMediaURL), dataSource, allocator, BUFFER_SEGMENT_COUNT * BUFFER_SEGMENT_SIZE);\n\n\n        MediaCodecVideoTrackRenderer videoRenderer = new MediaCodecVideoTrackRenderer(\n                this, sampleSource, MediaCodec.VIDEO_SCALING_MODE_SCALE_TO_FIT, 100, null, new MediaCodecVideoTrackRenderer.EventListener() {\n            @Override\n            public void onDroppedFrames(int count, long elapsed) {\n\n            }\n\n            @Override\n            public void onVideoSizeChanged(int width, int height, int unappliedRotationDegrees, float pixelWidthHeightRatio) {\n                videoFrame.setAspectRatio(\n                        height == 0 ? 1 : (width * pixelWidthHeightRatio) / height);\n            }\n\n            @Override\n            public void onDrawnToSurface(Surface surface) {\n\n            }\n\n            @Override\n            public void onDecoderInitializationError(MediaCodecTrackRenderer.DecoderInitializationException e) {\n\n            }\n\n            @Override\n            public void onCryptoError(MediaCodec.CryptoException e) {\n\n            }\n\n            @Override\n            public void onDecoderInitialized(String decoderName, long elapsedRealtimeMs, long initializationDurationMs) {\n\n            }\n        }, 100);\n\n\n        MediaCodecAudioTrackRenderer audioRenderer = new MediaCodecAudioTrackRenderer(sampleSource);\n        player.prepare(videoRenderer, audioRenderer);\n\n        player.sendMessage(videoRenderer, MediaCodecVideoTrackRenderer.MSG_SET_SURFACE, surface);\n\n\n        player.setPlayWhenReady(true);\n        control = new PlayerControl(player);\n```\n"
    },
    "satisfaction_conditions": [
      "Frame aspect ratio must be dynamically adjustable based on video dimensions",
      "Video playback functionality must remain intact"
    ],
    "created_at": "2016-01-20T06:52:21Z"
  },
  {
    "id": "https://github.com/google/ExoPlayer/issues/1122",
    "source": {
      "issue_number": 1122
    },
    "initial_question": {
      "title": "How to get detail information from VideoChunk in DASH streaming",
      "body": "I am playing MPEG DASH streaming using exo player. I need to extract the video chunks and need to know what information are there in video chunks e.g. how long that chunk is, format of that video chunk etc...\n\nI tried to log that information in DemoPlayer.java class's onLoadStarted(int sourceId, long length, int type, int trigger, Format format, long mediaStartTimeMs, long mediaEndTimeMs) method. But it gives me sourceID= 0 & 1, length=-1 and format=com.google.android.exoplayer.chunk.Format@36, @35 & @34. \n\nPlease let me know if I am looking at correct place or is there any other way to extract the chunk information.\n\nThanks in Advance\n"
    },
    "satisfaction_conditions": [
      "Video chunk metadata must be accessible programmatically",
      "Timing information for chunks must be retrievable",
      "Format/encoding details of chunks must be available",
      "Chunk size information must be obtainable after loading",
      "Solution must work within MPEG-DASH streaming context"
    ],
    "created_at": "2016-01-07T20:00:10Z"
  },
  {
    "id": "https://github.com/google/ExoPlayer/issues/1046",
    "source": {
      "issue_number": 1046
    },
    "initial_question": {
      "title": "Decoder init failed DTS",
      "body": "Hi,\n\nI am getting the following error:\n\n``` js\ncom.google.android.exoplayer.ExoPlaybackException: com.google.android.exoplayer.MediaCodecTrackRenderer$DecoderInitializationException: Decoder init failed: [-49999], MediaFormat(1, audio/vnd.dts, -1, 16, -1, -1, -1, -1.0, 2, 48000, und, 0, false, -1, -1)\n```\n\nAm I correct in thinking that this is trying to access the hardware decoder on the device but failing (Nexus 6p) because hardware decode support doesn't exist?\n\nIf so, does exoplayer include software decoding support? Or do we need to fall back to our own?\n\nThanks for your help.\n"
    },
    "satisfaction_conditions": [
      "Audio playback must proceed without decoder initialization errors",
      "Media format compatibility must be correctly identified before playback attempt",
      "Codec information in the media container must accurately reflect the actual audio format",
      "System must handle unsupported audio formats gracefully",
      "Audio format selection must respect device capabilities"
    ],
    "created_at": "2015-12-11T05:04:02Z"
  },
  {
    "id": "https://github.com/google/ExoPlayer/issues/1009",
    "source": {
      "issue_number": 1009
    },
    "initial_question": {
      "title": "Howto read from codec output buffers",
      "body": "I am attempting to play the HLS sample filie BipPop.  I have added code to MediaCodecVideoTrackRenderer. \n\nThe following code can be called in processOutputBuffer or in renderOutputBufferV21 but gets the same buffer freed error regardless (and the video successfully plays despite the buffer supposedly being freed).\n\n```\nprivate Boolean customHack(MediaCodec codec, int bufferIndex) {\nByteBuffer buffer = codec.getOutputBuffer(bufferIndex);\nbyte[] data =  new byte[buffer.remaining()];\n    try {\n      buffer.get(data);\n    }catch(Exception e){\n      Log.e(\"Custom\", \"Error trying to get the buffer\",e);\n      return false;\n    }\n}\n```\n\nMy objective is post-decode modification of the buffer.  I can do this using the regular Android player with non HLS content, but in ExoPlayer, I get the BufferFreed problem.\n"
    },
    "satisfaction_conditions": [
      "Buffer access must not violate MediaCodec's buffer ownership rules",
      "Access to decoded video frame data must be possible without causing buffer freed errors",
      "Video frame metadata (width/height) must be accessible without causing buffer conflicts"
    ],
    "created_at": "2015-11-30T19:56:27Z"
  },
  {
    "id": "https://github.com/google/ExoPlayer/issues/921",
    "source": {
      "issue_number": 921
    },
    "initial_question": {
      "title": "Exoplayer declared permissions",
      "body": "Hi,\nfirst ,thank you for this library  , i was  wondering if i can remove the wirte permission in exoplyer ,because i use it only for online audio streaming \n"
    },
    "satisfaction_conditions": [
      "Application can stream online audio without storage permissions",
      "No functionality loss for streaming use case",
      "Application manifest does not include unnecessary storage permissions"
    ],
    "created_at": "2015-11-03T18:09:25Z"
  },
  {
    "id": "https://github.com/google/ExoPlayer/issues/467",
    "source": {
      "issue_number": 467
    },
    "initial_question": {
      "title": "Unable to connect to local mp4 file by ExtractorSampleSource",
      "body": "Hello!\n\nI am updating the ExoPlayer to 1.3.1 and I am experiencing the issue with  the playback of the local MP4 files:\ncom.google.android.exoplayer.ExoPlaybackException: com.google.android.exoplayer.upstream.HttpDataSource$HttpDataSourceException: Unable to connect to /storage/emulated/0/Android/data/com.getvictorious.staging.eatyourkimchi/files/DCIM/Video/Video-20150518_142803.mp4\n\nI am passing the uri to the ExtractorSampleSource: \nExtractorSampleSource sampleSource = new ExtractorSampleSource(uri, dataSource, extractor, 2,\n                BUFFER_SIZE);\n\nPlease advise what could cause this exception.\n\nThank you in advance!\nEdward\n"
    },
    "satisfaction_conditions": [
      "ExoPlayer version compatibility must be maintained"
    ],
    "created_at": "2015-05-18T21:34:34Z"
  },
  {
    "id": "https://github.com/google/ExoPlayer/issues/257",
    "source": {
      "issue_number": 257
    },
    "initial_question": {
      "title": "[Discussion] Potential race between HlsSampleSource and TsChunk?",
      "body": "This is not an issue, just some discussion about potential TsExtractor's race between HlsSampleSource and TsChunk.\n\nWhen I read the code related to how HlsSampleSource read the chunk data, it's noticed that reading-data from DataSource and getting-sample from Extractor are in two threads:\n- Reading data is in `TsChunk.load()`, which runs in a backgroud thread:\n\n``` java\n      while (bytesRead != -1 && !loadCanceled) {\n        bytesRead = extractor.read(dataSource);\n        if (bytesRead != -1) {\n          loadPosition += bytesRead;\n        }\n      }\n```\n- Getting sample is in `HlsSampleSource.readData()`, which runs in ExoPlayer's event loop. And other functions access the extractor, e.g. \n\n``` java\n    extractor.getSample(track, sampleHolder)\n    extractor.discardUntil(i, timeUs);\n```\n\nI don't see any protection of the two threads accessing extractor;\nAlthough there is `ConcurrentLinkedQueue` to protect the `SampleQueue.internalQueue` in TsExtractor, other members are not protected.\n\nThe question is, can we make sure there is no race accessing TsExtractor?\n"
    },
    "satisfaction_conditions": [
      "All shared data access between threads must be properly synchronized",
      "Reading operations must not interfere with sample extraction operations",
      "Thread safety mechanisms must cover all shared resources"
    ],
    "created_at": "2015-01-22T05:49:40Z"
  }
]