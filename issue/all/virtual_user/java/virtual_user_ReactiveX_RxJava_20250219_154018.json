[
  {
    "id": "https://github.com/ReactiveX/RxJava/issues/7732",
    "source": {
      "issue_number": 7732
    },
    "initial_question": {
      "title": "Observable<T>.scan accumulator seems to be called twice",
      "body": "I am currently debugging why the scan {} accumulator lambda is getting invoked twice, even when only one event is getting emitted. It will however produce the correct result, because t will take correct previous count probably, resulting in the same updated count. I am developing an Android app but I don't know if that matters. Here's the logs:\r\n\r\n```\r\n2024-07-14 18:04:47.640  8672-8672  xyz                     app.example                          D  onEvent\r\n2024-07-14 18:04:47.640  8672-8672  xyz                     app.example                          D  new event: Increment\r\n2024-07-14 18:04:47.640  8672-8672  xyz                     app.example                          D  new event: Increment\r\n2024-07-14 18:04:47.649  8672-8672  xyz                     app.example                          D  got state: CounterState(count=1, message=Counter is greater than 0)\r\n```\r\n\r\nAnd the relevant parts of my codebase:\r\n\r\n```kotlin\r\nabstract class Presenter<S : State<out Event>> {\r\n\r\n  protected val subscriptions = CompositeDisposable()\r\n\r\n  protected val eventSink = PublishSubject.create<CounterEvent>()\r\n\r\n  abstract val mStateObservable: Observable<S>\r\n\r\n  fun onEvent(event: CounterEvent) {\r\n    Log.d(\"xyz\", \"onEvent\")\r\n    eventSink.onNext(event)\r\n  }\r\n}\r\n\r\nclass CounterPresenter : Presenter<CounterState>() {\r\n\r\n  private val count = eventSink.scan(0L) { count, event ->\r\n    Log.d(\"xyz\", \"new event: $event\")\r\n    when (event) {\r\n      CounterEvent.Increment -> count + 1\r\n      CounterEvent.Decrement -> count - 1\r\n    }\r\n  }\r\n\r\n  // ...\r\n\r\n  override val mStateObservable = Observable\r\n    .combineLatest(count, message) { count, message -> \r\n        CounterState(count, message) \r\n    }\r\n}\r\n```\r\n\r\n- version 3.1.8"
    },
    "satisfaction_conditions": [
      "Final state calculation remains accurate",
      "Event processing order is preserved"
    ],
    "created_at": "2024-07-14T16:09:17Z"
  },
  {
    "id": "https://github.com/ReactiveX/RxJava/issues/7555",
    "source": {
      "issue_number": 7555
    },
    "initial_question": {
      "title": "3.x: Different behavior between blockingForEach and forEach",
      "body": "Hello,\r\n\r\nI'm surprise to see that the observable:\r\n```java\r\nObservable.just(0, 1, 2)\r\n    .doOnSubscribe(ignored -> LOG.info(\"On subscribe\"))\r\n    .doOnTerminate(() -> LOG.info(\"On terminate\"))\r\n```\r\n\r\nproduce the following result with `.forEach(i -> LOG.info(\"Data: {}\", i));`:\r\n```\r\n15:30:25.501 [main] INFO manual.NonBlockingTest - On subscribe\r\n15:30:25.501 [main] INFO manual.NonBlockingTest - Data: 0\r\n15:30:25.501 [main] INFO manual.NonBlockingTest - Data: 1\r\n15:30:25.501 [main] INFO manual.NonBlockingTest - Data: 2\r\n15:30:25.501 [main] INFO manual.NonBlockingTest - On terminate\r\n```\r\n\r\nand with `.blockingForEach(i -> LOG.info(\"Data: {}\", i));`:\r\n```\r\n15:32:04.932 [main] INFO manual.BlockingTest - On subscribe\r\n15:32:04.934 [main] INFO manual.BlockingTest - On terminate\r\n15:32:04.935 [main] INFO manual.BlockingTest - Data: 0\r\n15:32:04.936 [main] INFO manual.BlockingTest - Data: 1\r\n15:32:04.936 [main] INFO manual.BlockingTest - Data: 2\r\n```\r\n\r\nI expected to have the same result (subscribe, datas, terminate) with `blockingForEach` as with `forEach` without using any scheduler. I have the same result with `subscribe`.\r\n\r\nI tested with versions 3.1.3 and 3.1.6.\r\n\r\nThe documentation does not mention any difference between the two behaviors except that the blocking behavior blocks the current thread (which is what I want).\r\n\r\nDid I not understand correctly the difference between the two or it is a bug?\r\n\r\nThanks for your time.\r\n"
    },
    "satisfaction_conditions": [
      "The difference in output order between forEach and blockingForEach must be explained",
      "The explanation must account for the blocking nature of blockingForEach",
      "The behavior must be shown to be consistent/intentional rather than a bug",
      "The explanation must address why this behavior occurs specifically in synchronous execution",
      "The answer must explain how terminal signals relate to the data processing sequence"
    ],
    "created_at": "2023-04-17T13:54:15Z"
  },
  {
    "id": "https://github.com/ReactiveX/RxJava/issues/7370",
    "source": {
      "issue_number": 7370
    },
    "initial_question": {
      "title": "Update the object emitted by Single in async way",
      "body": "Hello, Could you please clarify whether I can update the object emitted by Single in async way by several methods?\r\nI have the folliwing code:\r\n```\r\nreturn Single.just(order)\r\n                .flatMap(o -> updateProducerInfo(o))\r\n                .flatMap(o -> updateCustomerInfo(o));\r\n\r\nprivate Single<Order> updateProducerInfo(Order order) {\r\n        // takes a long time\r\n    }\r\nprivate Single<Order> updateCustomerInfo(Order order) {\r\n        // takes a long time\r\n    }\r\n```\r\nIs there a way to execute these methods in parallel to reduce the overall execution time?"
    },
    "satisfaction_conditions": [
      "Operations execute concurrently rather than sequentially",
      "Reactive stream contract is preserved"
    ],
    "created_at": "2021-12-07T13:19:56Z"
  },
  {
    "id": "https://github.com/ReactiveX/RxJava/issues/7327",
    "source": {
      "issue_number": 7327
    },
    "initial_question": {
      "title": "How can I check completion of saving which is processed  in async way?",
      "body": "Hi. could you please clarify how I can wait async execution of saving?\r\nI Have the following methods in repository class.\r\n```\r\npublic Completable save(Book book) {\r\n        // logic to save book in DB\r\n    }\r\n\r\npublic Single<Boolean> exist(Book book) {\r\n        // logic to check if book exists in DB\r\n    }\r\n```\r\nAnd there is method in service that uses _save_ method from repository\r\n```\r\npublic Single<Book> saveBook(Book book) {\r\n        bookRepo.save(book);\r\n        return Sing.just(book);\r\n    }\r\n```\r\n\r\nThe problem is that after _saveBook_ method execution the book may not be in the database as saving is processed  in async way.\r\nHow can I change me _saveBook_ method using _exist_ method to be sure that after _saveBook_ method execution I will have the book in DB?"
    },
    "satisfaction_conditions": [
      "Database write operation completion must be confirmed before proceeding",
      "Solution must handle asynchronous operations without losing data consistency",
      "Operation must have a defined timeout or completion guarantee",
      "Save operation status must be verifiable"
    ],
    "created_at": "2021-08-26T13:36:31Z"
  },
  {
    "id": "https://github.com/ReactiveX/RxJava/issues/7317",
    "source": {
      "issue_number": 7317
    },
    "initial_question": {
      "title": "What\u2018s the reason that \"relaying the upstream's Disposable directly is not allowed in RxJava\"?",
      "body": "Thanks check my question.\r\nWhen I implement `ObservableOperator`, find the comment \"Note that relaying the upstream's Disposable directly is not allowed in RxJava\" above observable operator `lift` sample.\r\nI searched net, but found nobody explains the reason.  If i follow the sample for `lift`\uff0c the class seems complex a little bit, but relay the upstream's Disposable,  the class seems more clean.\r\n```\r\npublic final class CustomObserver<T> implements Observer<T>, Disposable {\r\n\r\n     final Observer<? super String> downstream;\r\n\r\n     Disposable upstream;\r\n\r\n     public CustomObserver(Observer<? super String> downstream) {\r\n         this.downstream = downstream;\r\n     }\r\n\r\n     // In the subscription phase, the upstream sends a Disposable to this class\r\n     // and subsequently this class has to send a Disposable to the downstream.\r\n     // Note that relaying the upstream's Disposable directly is not allowed in RxJava\r\n     @Override\r\n     public void onSubscribe(Disposable d) {\r\n         if (upstream != null) {\r\n             d.dispose();\r\n         } else {\r\n             upstream = d;\r\n             downstream.onSubscribe(this);\r\n         }\r\n     }\r\n\r\n     @Override\r\n     public void onNext(T item) {\r\n         ... do something...\r\n     }\r\n\r\n     @Override\r\n     public void onError(Throwable throwable) {\r\n         downstream.onError(throwable);\r\n     }\r\n\r\n     @Override\r\n     public void onComplete() {\r\n         downstream.onComplete();\r\n     }\r\n\r\n     @Override\r\n     public void dispose() {\r\n         upstream.dispose();\r\n     }\r\n\r\n     @Override\r\n     public boolean isDisposed() {\r\n         return upstream.isDisposed();\r\n     }\r\n }\r\n\r\n```\r\n\r\n```\r\npublic final class CustomObserver<T> implements Observer<T>, Disposable {\r\n\r\n     final Observer<? super String> downstream;\r\n\r\n     Disposable upstream;\r\n\r\n     public CustomObserver(Observer<? super String> downstream) {\r\n         this.downstream = downstream;\r\n     }\r\n\r\n     // Not follow sample says\r\n     @Override\r\n     public void onSubscribe(Disposable d) {\r\n         downstream.onSubscribe(d);\r\n     }\r\n\r\n     @Override\r\n     public void onNext(T item) {\r\n         ... do something...\r\n     }\r\n\r\n     @Override\r\n     public void onError(Throwable throwable) {\r\n         downstream.onError(throwable);\r\n     }\r\n\r\n     @Override\r\n     public void onComplete() {\r\n         downstream.onComplete();\r\n     }\r\n}\r\n```"
    },
    "satisfaction_conditions": [
      "Custom operator must maintain proper operator fusion behavior",
      "Operator must maintain control over disposal chain",
      "Operator must handle multiple subscription attempts correctly",
      "Operator must maintain proper isolation between upstream and downstream"
    ],
    "created_at": "2021-08-24T08:24:13Z"
  },
  {
    "id": "https://github.com/ReactiveX/RxJava/issues/7288",
    "source": {
      "issue_number": 7288
    },
    "initial_question": {
      "title": "Using withLatestFrom completes without values if other publisher is delayed",
      "body": "**Version**:  3.0.12\r\n\r\nI am not sure if this is per-design and specification (could not find this), but is it really expected that:\r\n\r\n```\r\n      Flowable<Integer> integerFlowable = Flowable.just(1, 2, 3);\r\n      Flowable<Integer> delayedFlowable = Flowable.just(10).delay(1, TimeUnit.SECONDS);\r\n\r\n      integerFlowable.withLatestFrom(delayedFlowable, Integer::sum)\r\n              .test()\r\n              .assertValueCount(3)\r\n              .assertComplete();\r\n```     \r\n\r\nfails with:\r\n\r\n```\r\njava.lang.AssertionError: Value counts differ; expected: 3 but was: 0 (latch = 0, values = 0, errors = 0, completions = 1)\r\nExpected :3\r\nActual   :0 (latch = 0, values = 0, errors = 0, completions = 1)\r\n<Click to see difference>\r\n```\r\n\r\nIf it is, then Javadoc needs to be improved, it is not stated anywhere that this will complete with no values of the other publisher is emitting item after a delay. Of course this is a simple example, but you get the point. If these would be two database calls and second comes emits after the first one, you get nothing? :confused: \r\n\r\n"
    },
    "satisfaction_conditions": [
      "Asynchronous operations must complete before assertions are checked",
      "Expected behavior for empty sequences must be documented",
      "All source values must be processed according to the chosen combination strategy"
    ],
    "created_at": "2021-07-01T17:29:38Z"
  },
  {
    "id": "https://github.com/ReactiveX/RxJava/issues/7281",
    "source": {
      "issue_number": 7281
    },
    "initial_question": {
      "title": "Methos to() requires mock in unit test",
      "body": "Hi. could you please clarify question?\r\nI Have the following method\r\n```\r\npublic Single<Book> load(String bookName, String author) {\r\n        return bookRepo.load(bookName)\r\n                .switchIfEmpty(Observable.error(EntityNotFoundException::new))\r\n                .toList()\r\n                .flatMap(books-> bookService.loadbookByAuthor(Observable.fromIterable(books), autor)\r\n                        .switchIfEmpty(Maybe.error(() -> new ValidationErrorException()))\r\n                        .toSingle());\r\n    }\r\n```\r\n\r\nAnd I have unit test for this method. which works\r\n```\r\npublic void shouldValidatePolicyExists() {\r\n        when(bookRepo.load(any())).thenReturn(Observable.empty());\r\n\r\n        testObject.load(request).test()\r\n                .assertError(EntityNotFoundException.class)\r\n    }\r\n```\r\n\r\nI want to get rid of toList() in my method and found the following way\r\n```\r\npublic Single<Book> load(String bookName, String author) {\r\n        return bookRepo.load(bookName)\r\n                .switchIfEmpty(Observable.error(EntityNotFoundException::new))\r\n                .to(books-> bookService.loadbookByAuthor(books, autor)\r\n                        .switchIfEmpty(Maybe.error(() -> new ValidationErrorException()))\r\n                        .toSingle());\r\n    }\r\n```\r\nBut unit test does not work for this method implementation.\r\nIt does not return EntityNotFoundException and requires bookService is mocked.\r\nCould you please clarify why ?"
    },
    "satisfaction_conditions": [
      "Method must throw EntityNotFoundException when bookRepo.load returns empty",
      "Method must avoid collecting all items into a list before processing",
      "Method must maintain compatibility with existing bookService.loadbookByAuthor interface",
      "Method must preserve the original error handling behavior",
      "Method must return a Single<Book> type"
    ],
    "created_at": "2021-06-08T16:17:32Z"
  },
  {
    "id": "https://github.com/ReactiveX/RxJava/issues/7158",
    "source": {
      "issue_number": 7158
    },
    "initial_question": {
      "title": "intervalRange behaviour",
      "body": "As per documentation `intervalRange` : \r\n>The sequence completes immediately after the last value (start + count - 1) has been reached.\r\n\r\nWhich mean `doOnComplete` is called directly once the last interval is reached (and not _completed_)\r\n\r\n```\r\nprivate fun launchQuestionGame() {\r\n        Flowable\r\n            .fromIterable(mQuestions.asIterable()) // mQuestions contains 3 items\r\n\r\n            .zipWith(\r\n                startTimeIntervalAndCancelItUponUnUneButtonClick(mQuestions.size + 1)\r\n\r\n                    .observeOn(AndroidSchedulers.mainThread())\r\n                    .doOnEach {\r\n                        onEachIntervalEmittion(it)\r\n                    }\r\n\r\n                    .repeat(mQuestions.size.toLong()), // repeat the interval mQuestions.size.toLong() times.\r\n\r\n                BiFunction { t1: Question, _: Long ->\r\n                    Timber.d(t1.toString())\r\n                    doOnCompleteEachFile(t1)\r\n                })\r\n\r\n            .doOnComplete {\r\n                Timber.d(\"doOnComplete\")\r\n                doOnCompleteAllFiles()\r\n            }\r\n\r\n            .subscribe()\r\n    }\r\n```\r\n\r\n2021-01-23 18:38:49.526 17549-17549/ Item 1\r\n2021-01-23 18:38:53.531 17549-17549/ Item 2\r\n2021-01-23 18:38:57.527 17549-17549/ Item 3\r\n2021-01-23 18:38:57.544 17549-17549/ doOnComplete\r\n\r\nI tried to delay before `doOnComplete` but it doesn't work.\r\n\r\nIs there anyway to have `doOnComplete` called after the last interval is finished ?"
    },
    "satisfaction_conditions": [
      "The doOnComplete callback must execute after the last interval completes",
      "The time gap between the last item and completion should be consistent with other intervals",
      "The original processing of individual items must remain unchanged",
      "The solution must work within RxJava's reactive stream paradigm"
    ],
    "created_at": "2021-01-23T18:25:25Z"
  },
  {
    "id": "https://github.com/ReactiveX/RxJava/issues/7137",
    "source": {
      "issue_number": 7137
    },
    "initial_question": {
      "title": "2.x: Question about threading and doFinally()",
      "body": "I am using RxJava 2 on Android. The modifyUi() function inside doFinally() should be called from main thread only.\r\n```\r\ntask_1\r\n    .subscribeOn(Schedulers.io())\r\n    .doOnSuccess { ... }\r\n    .flatMap { \r\n        task_2\r\n            .subscribeOn(Schedulers.io()) \r\n    }\r\n    .observeOn(AndroidSchedulers.mainThread())\r\n    .doFinally { modifyUi() }\r\n```\r\nHowever, there are certain edge cases where observeOn() is ignored and doFinally() is fired in background.\r\n\r\nQuestion 1: What these cases can be? So far, I've discovered only one of them - a very fast disposing of the chain. If I add\r\n```\r\n.doOnSubscribe { it.dispose() }\r\n```\r\nright after doFinally(), observeOn() becomes ignored, so doFinally() is fired from background. Why is that and what the other cases can be?\r\n\r\nQuestion 2: Is there any reliable way to clean up the chain once it's done that can be set to a particular thread? As I see, doFinally() fails in some cases. Should I resort to duplicating the cleanup code in onSuccess() and onError() methods of the observer/consumer in subscribe()?"
    },
    "satisfaction_conditions": [
      "Thread context must be controllable for cleanup operations"
    ],
    "created_at": "2020-12-22T10:34:42Z"
  },
  {
    "id": "https://github.com/ReactiveX/RxJava/issues/7056",
    "source": {
      "issue_number": 7056
    },
    "initial_question": {
      "title": "3.x: Observable.window(count, skip) completes windows when there are no observers",
      "body": "RxJava version: 3.0.5\r\nOS: Android\r\n\r\nHi, in addition to #7048. Here are two failed test cases:\r\n\r\n**Test case 1:**\r\n```kotlin\r\n@Test\r\npublic void cancelAfterAbandonmentSize() {\r\n    PublishSubject<Integer> ps = PublishSubject.create();\r\n    AtomicReference<Observable<Integer>> firstWindow = new AtomicReference<>();\r\n    TestObserver<Observable<Integer>> to = ps.window(3, 1)\r\n            .doOnNext((window) -> {\r\n                if (!firstWindow.compareAndSet(null, window)) {\r\n                    window.subscribe();\r\n                }\r\n            })\r\n            .test();\r\n\r\n    assertTrue(ps.hasObservers());\r\n\r\n    ps.onNext(1);\r\n    ps.onNext(2);\r\n\r\n    to.dispose();\r\n\r\n    firstWindow.get()\r\n            .test()\r\n            .assertValues(1, 2);\r\n}\r\n```\r\n\r\nThis test will fail with following description:\r\n`Value count differs; expected: 2 [1, 2] but was: 1 [1] (latch = 0, values = 1, errors = 0, completions = 1)`\r\n\r\n**Test case 2:**\r\n```kotlin\r\n@Test\r\npublic void cancelAfterAbandonmentSize() {\r\n    PublishSubject<Integer> ps = PublishSubject.create();\r\n\r\n    TestObserver<Integer> to = ps.window(3)\r\n            .flatMap((window) -> window.delaySubscription(1, TimeUnit.SECONDS))\r\n            .test();\r\n\r\n    ps.onNext(1);\r\n    ps.onNext(2);\r\n    ps.onNext(3);\r\n\r\n    to.dispose();\r\n\r\n    to.assertValues(1, 2, 3);\r\n}\r\n```\r\n\r\nThis test will fail with following description:\r\n`Value count differs; expected: 3 [1, 2, 3] but was: 0 [] (latch = 1, values = 0, errors = 0, completions = 0, disposed!)`\r\n\r\n**Question**\r\nThis is correct behavior?"
    },
    "satisfaction_conditions": [
      "Windows must complete when they have no observers within their emission timeframe",
      "Disposal of the main sequence must properly handle unsubscribed windows",
      "Window behavior must be documented for race conditions",
      "Windows must maintain unicast behavior",
      "System must handle asynchronous cancellation correctly"
    ],
    "created_at": "2020-08-16T18:36:01Z"
  },
  {
    "id": "https://github.com/ReactiveX/RxJava/issues/7054",
    "source": {
      "issue_number": 7054
    },
    "initial_question": {
      "title": "The worker thread failed to start work using subscribeOn(Schedulers.computation())",
      "body": "**The libraries** that I included:\r\n\r\n    implementation 'io.reactivex.rxjava3:rxandroid:3.0.0'\r\n    implementation 'io.reactivex.rxjava3:rxjava:3.0.5'\r\n    implementation 'com.trello.rxlifecycle4:rxlifecycle-components:4.0.0'\r\n\r\n**My code** is just like this:\r\n\r\n```Java\r\n    private void doLogin() {\r\n        Observable.create((ObservableOnSubscribe<Boolean>) emitter -> {\r\n            Log.i(\"starting\");\r\n            while (true) {\r\n                try {\r\n                    boolean success = mLoginModule.login();\r\n                    if (!success) {\r\n                        KLog.d(\"login failed! No. \" + mLoginTimes + \", \" + ToolKits.getLastError());\r\n\r\n                        mLoginTimes++;\r\n                        emitter.onNext(false);\r\n                    } else {\r\n                        emitter.onNext(true);\r\n                        emitter.onComplete();\r\n                        break;\r\n                    }\r\n\r\n                    if (mLoginTimes > 100) {\r\n                        emitter.onComplete();\r\n                        break;\r\n                    }\r\n\r\n                    Thread.sleep(1000);\r\n                } catch (Exception e) {\r\n                }\r\n            }\r\n        }).subscribeOn(Schedulers.computation())\r\n                .observeOn(AndroidSchedulers.mainThread())\r\n                .compose(bindToLifecycle())\r\n                .subscribe(new Observer<Boolean>() {\r\n                    @Override\r\n                    public void onSubscribe(@NonNull Disposable d) {\r\n                    }\r\n\r\n                    @Override\r\n                    public void onNext(@NonNull Boolean result) {\r\n                        onLoginResult(result);\r\n                    }\r\n\r\n                    @Override\r\n                    public void onError(@NonNull Throwable e) {\r\n                        Log.i(\"onError\");\r\n                    }\r\n\r\n                    @Override\r\n                    public void onComplete() {\r\n                        Log.i(\"onComplete\");\r\n                    }\r\n                });\r\n    }\r\n\r\npublic class MyActivity extends RxAppCompatActivity {\r\n    protected void onCreate(Bundle savedInstanceState) {\r\n          ..........\r\n                 doLogin();\r\n          ..........\r\n\r\n    }\r\n}\r\n\r\n\r\n```\r\n\r\n\r\n**What I encountered** was sometimes the login work just failed to start, even the log output \"starting\" did not come out. But when the activity was destroyed, onComplete got printed out. So I guess there's something wrong with Schedulers.computation. Then I changed it to subscribeOn(Schedulers.newThread()) and it seemed just ok.\r\n\r\nWhat's the problem? Did I misuse something or is there a bug in RxJava or RxAndroid?\r\nThanks!\r\n\r\n\r\n"
    },
    "satisfaction_conditions": [
      "The login operation must execute off the main thread",
      "Results must be properly delivered to the UI thread",
      "The operation must respect the activity lifecycle"
    ],
    "created_at": "2020-08-14T01:34:18Z"
  },
  {
    "id": "https://github.com/ReactiveX/RxJava/issues/7045",
    "source": {
      "issue_number": 7045
    },
    "initial_question": {
      "title": "Is it possible to run a multistage pipeline in parallel?",
      "body": "Hi, suppose I have a query that entails a multi-stage pipeline of operations (e.g., `map(x -> intenseComputation(x)).map(...).map(...)...`)\r\nIs it possible to implement such a query using multiple threads where each thread handles a stage of the computation (e.g., a single `map`)?\r\n\r\nTo illustrate,\r\ninput items -> map1 (assigned to thread1) -> map2 (thread2) -> map3 (thread3) ... -> Observer\r\n\r\nI read the documentation of RxJava and checked many related materials, but now I only found codes and tutorials that taught me how to distribute the input items to multiple threads, where each thread runs the same query (e.g., using `flatMap(o -> ...subscribeOn(...))`).\r\n\r\nCan someone help me to answer this question or refer me to some related materials? \r\nThanks a lot!\r\n\r\nBTW, I am using RxJava version 3.05."
    },
    "satisfaction_conditions": [
      "Pipeline stages execute on different threads",
      "Data flows sequentially through pipeline stages",
      "Works with RxJava 3.x environment"
    ],
    "created_at": "2020-08-02T05:25:22Z"
  },
  {
    "id": "https://github.com/ReactiveX/RxJava/issues/7019",
    "source": {
      "issue_number": 7019
    },
    "initial_question": {
      "title": "App Crash when ObserveOn Android main thread",
      "body": "**Issue** \r\nI try to implement observeOn **AndroidSchedulers.mainThread()** But it always crash \r\nif I remove this line it working fine \r\n\r\n       myObservable = Observable.fromArray(intArray);\r\n       myObservable.subscribeOn(Schedulers.io())\r\n        .observeOn(AndroidSchedulers.mainThread()).\r\n         subscribeWith(getObserver());\r\n\r\n**Error Log** \r\n\r\n        java.lang.BootstrapMethodError: Exception from call site #1 bootstrap method\r\n        at io.reactivex.rxjava3.android.schedulers.AndroidSchedulers.<clinit>(AndroidSchedulers.java:33)\r\n        at io.reactivex.rxjava3.android.schedulers.AndroidSchedulers.mainThread(AndroidSchedulers.java:44)\r\n        at com.example.rxjavasample.SecondActivity.onCreate(SecondActivity.java:38)\r\n\r\n\r\n**Gradle dependencies** \r\n\r\n\r\n    implementation \"io.reactivex.rxjava3:rxjava:3.0.4\"\r\n    implementation 'io.reactivex.rxjava3:rxandroid:3.0.0' "
    },
    "satisfaction_conditions": [
      "RxJava and RxAndroid dependencies are properly integrated"
    ],
    "created_at": "2020-06-28T07:54:41Z"
  },
  {
    "id": "https://github.com/ReactiveX/RxJava/issues/6998",
    "source": {
      "issue_number": 6998
    },
    "initial_question": {
      "title": "3.x Amb operator is not cancelling the other sources once one source completes",
      "body": "Using library io.reactivex.rxjava3:rxjava:3.0.3\r\n\r\nDepending on the order you declare the sources on the amb operator, the source gets cancelled or not. See code snippet below:\r\n```Kotlin\r\n@Test\r\nfun ambTest() {\r\n  var just = Maybe.just(\"test\")\r\n  val cancellable = object : Cancellable {\r\n    var cancelled = false\r\n    override fun cancel() {\r\n      cancelled = true\r\n    }\r\n  }\r\n  val never = Maybe.create<String> { it.setCancellable(cancellable) }\r\n  var value: String? = null\r\n  // This doesn't work\r\n  Maybe.amb(listOf(just, never)).subscribe { value = it }\r\n  // But this works\r\n  // Maybe.amb(listOf(never, just)).subscribe { value = it }\r\n  assertThat(value).isEqualTo(\"test\")\r\n  // The following line fails if you declare just first instead of never.\r\n  assertThat(cancellable.cancelled).isTrue()\r\n}\r\n```\r\nI would expect that regardless of the order in which you pass the MaybeSources to the `amb` operator, whenever one of them completes, the other are cancelled.\r\n\r\nI found this bug by accident when writing another unit test which sometimes worked and sometimes didn't work. It seemed like a race condition but when I reduced it to the above example it is no longer random. In my case I think it was random because I was building the list from a HashSet so maybe the order was randomly changing each time.\r\n\r\nIf there is a workaround for this, that would be great. Maybe using some schedulers fixes it?\r\n\r\nThanks."
    },
    "satisfaction_conditions": [
      "The test must successfully receive the expected value from the first completing source",
      "The test must be able to verify whether unused sources are either cancelled or not subscribed",
      "The test results must be consistent regardless of source order",
      "The test must be able to track subscription status of sources"
    ],
    "created_at": "2020-05-26T22:01:16Z"
  },
  {
    "id": "https://github.com/ReactiveX/RxJava/issues/6933",
    "source": {
      "issue_number": 6933
    },
    "initial_question": {
      "title": "Merge delay error for multiple API calls.",
      "body": "```\r\nlaunchJob {\r\n            Observable.mergeDelayError(\r\n                    getCareUseCase.getAllGetCareItems().toObservable(),\r\n                    appointmentUseCase.getAllAppointment().toObservable()\r\n                        .mergeWith(\r\n                            prescriptionRefillsUseCase.getAllPrescriptionRefills())\r\n                            .mergeWith(billUseCase.getAllPayBills())\r\n                        .mergeWith(careTeamUseCase.getMyCareTeam())\r\n                        .mergeWith(favoriteFacilitiesUseCase.getAllFavoriteFacilities())\r\n                ).iOSubscribeMainThreadObserve()\r\n                .subscribe({\r\n                    mapSection(it)\r\n                    flattenAndEmit()\r\n                }, {\r\n                   Log.e(TAG, \"Failed to load dashboard contents\")\r\n                })\r\n        }\r\n\r\n\r\n```\r\n\r\nIf any of the API is failing entire stream is failing.  Any one knows why?\r\n\r\nThis is my requirement, I want to make all the API calls parallel,  I don't care about the order in which response arrives, I don't care if one fails, which one come fast, I just display in the order that receives. "
    },
    "satisfaction_conditions": [
      "Multiple API calls must execute in parallel",
      "Individual API failures must not terminate the entire stream",
      "Results must be processed in order of arrival",
      "All API responses must be of compatible types for merging",
      "Solution must handle arbitrary number of API sources"
    ],
    "created_at": "2020-03-14T19:05:20Z"
  },
  {
    "id": "https://github.com/ReactiveX/RxJava/issues/6724",
    "source": {
      "issue_number": 6724
    },
    "initial_question": {
      "title": "Observable vs Flowable on Interfaces With Unknown Implementations",
      "body": "We have a base library which provides interfaces for repository / database access and some basic implementations. In the case of getOne, insert, update, and delete, these all make sense as singles / maybes. However in the case of getAll for instance, this could be a ```Single<List<Model>>``` or ```Observable<Model>```. We considered using single, since that's usually how our data is consumed, but these interfaces could hold implementations that support streaming, so using single would essentially prevent those types of implementations from being realized. The consumer can always use the ```toList``` operator if they dont want to consume it like a stream or need all the results for business logic. \r\n\r\nSo now where we are stuck is whether or not these interfaces should return Observables or Flowables. From what I understand, the main difference between the two is that Flowables have added overhead which allow a Consumer to control the rate at which a Producer emits items, where as an Observable does not and will just emit as quickly as possible.\r\n\r\nWould it make sense then to always return lower overhead Observables from these interfaces, and to leave it up to the consumer to use ```toFlowable``` if they need control over the rate of the Producer? Would this even work or would the Observable consume memory with its unbounded buffer (potential out of memory issues) before being converted to a Flowable which has bounded buffers?"
    },
    "satisfaction_conditions": [
      "The chosen reactive type must handle potential memory overflow scenarios",
      "The interface must support both streaming and batch data retrieval patterns",
      "The chosen type must support backpressure when needed",
      "The interface must not artificially limit potential implementations",
      "The solution must maintain acceptable performance overhead"
    ],
    "created_at": "2019-11-20T18:06:06Z"
  },
  {
    "id": "https://github.com/ReactiveX/RxJava/issues/6623",
    "source": {
      "issue_number": 6623
    },
    "initial_question": {
      "title": "Observers run order issue while using observeOn() `2.x`",
      "body": "Library version 2.2.11\r\nI have two `PublishSubject`s and two `Observer`s subscribed respectively. Between `PubslishSubject` and `Subscriber` I switch from [main] thread to [RxSingleScheduler] thread using `observeOn(Schedulers.single())`. I start to publish (`PubslishSubject.onNext()`) on both `PublishSubject`s inside the loop.\r\n\r\n    publishSubject1.onNext(\"next\");\r\n    publishSubject2.onNext(\"next\");\r\nWhat I expected was the both subscribers run in the same order as emissions were published but the results I get is completely different. Subsriber1 handles all it's emissions and then Subscriber2 handles all it's emissions.\r\nI expected emission scheduled and run in publish order. Is there any way to achive this?\r\n```java\r\nimport java.util.concurrent.TimeUnit;\r\n\r\nimport io.reactivex.schedulers.Schedulers;\r\nimport io.reactivex.subjects.PublishSubject;\r\n\r\npublic class ObserveOnApp {\r\n    \r\n    public static void main(String[] args) {\r\n        PublishSubject<String> publishSubject1 = PublishSubject.create();\r\n        PublishSubject<String> publishSubject2 = PublishSubject.create();\r\n        \r\n        publishSubject1\r\n        .observeOn(Schedulers.single())\r\n        .subscribe(next -> {\r\n            System.out.println(\"Subscriber1\");\r\n        });\r\n        \r\n        publishSubject2\r\n        .observeOn(Schedulers.single())\r\n        .subscribe(next -> {\r\n            System.out.println(\"Subscriber2\");\r\n        });\r\n        \r\n        for (int i= 0; i < 10; i++) {\r\n            publishSubject1.onNext(\"next\");\r\n            publishSubject2.onNext(\"next\");\r\n        }\r\n        \r\n        try {\r\n            TimeUnit.SECONDS.sleep(2);\r\n        } catch (InterruptedException e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n}\r\n```"
    },
    "satisfaction_conditions": [
      "Thread switching must occur as specified by the observeOn operator"
    ],
    "created_at": "2019-08-19T09:30:56Z"
  },
  {
    "id": "https://github.com/ReactiveX/RxJava/issues/6617",
    "source": {
      "issue_number": 6617
    },
    "initial_question": {
      "title": "ConcatMap caches value from upstream",
      "body": "This issue was reproduces on RX-Java v2.2.6 and v3.0.0-RC1\r\n\r\nI have this piece of code:\r\n\r\n```java\r\n@Test\r\npublic void concatMapCachedValueTest() throws InterruptedException {\r\n  Flowable\r\n    .interval(0, 1000, TimeUnit.MILLISECONDS, Schedulers.io())\r\n    .onBackpressureDrop()\r\n    .concatMap(aLong -> Flowable.just(aLong)\r\n        .delay(3500, TimeUnit.MILLISECONDS, Schedulers.io())\r\n    )\r\n    .subscribe(aLong -> System.out.println(aLong));\r\n    Thread.sleep(18000);\r\n}\r\n```\r\n\r\nWhen I run it it prints:\r\n0\r\n1\r\n4\r\n5\r\n11\r\n\r\nI would expect it to print:\r\n0\r\n4\r\n8\r\n12\r\n16\r\n\r\nBut it seems that concatMap is caching another value from the upstream while starting processing the Flowable returned by current value.\r\nThis happens even if you set the prefetch parameter of concatMap to 1, setting it to 0 is illegal.\r\n"
    },
    "satisfaction_conditions": [
      "Single active subscription at a time"
    ],
    "created_at": "2019-08-14T09:24:53Z"
  },
  {
    "id": "https://github.com/ReactiveX/RxJava/issues/6568",
    "source": {
      "issue_number": 6568
    },
    "initial_question": {
      "title": "2.2.10: Flowable do not use correct scheduler once bufferSize is reached",
      "body": "Hi, I was playing with Flowable to get a deep understanding on how to handle backpressure without dropping events and running the following code I noticed that the flowable starts to emit events on the subscriber scheduler once bufferSize given to observeOn method is reached.\r\n\r\nHere's the code :\r\n\r\n```\r\n    public static void main(String[] args) throws InterruptedException {\r\n        int maxI = 12;\r\n        int bufferSize = 5;\r\n        CountDownLatch waitForIt = new CountDownLatch(1);\r\n        CompositeDisposable compositeDisposable = new CompositeDisposable();\r\n\r\n        Flowable<Integer> integerFlow = Flowable.<Integer, Integer>generate(\r\n                () -> 0,\r\n                (i, emitter) -> {\r\n                    if (i < maxI) {\r\n                        log(\"Emitting: \" + i);\r\n                        emitter.onNext(i);\r\n                    } else {\r\n                        emitter.onComplete();\r\n                    }\r\n                    return i + 1;\r\n                }).observeOn(Schedulers.io(), false, bufferSize);\r\n\r\n        compositeDisposable.add(\r\n                integerFlow\r\n                        .subscribeOn(Schedulers.computation())\r\n                        .subscribeWith(new DisposableSubscriber<Integer>() {\r\n\r\n                            @Override\r\n                            public void onNext(Integer i) {\r\n                                try {\r\n                                    log(\"Receiving: \" + i);\r\n                                    Thread.sleep(10L);\r\n                                } catch (InterruptedException e) {\r\n                                    e.printStackTrace();\r\n                                }\r\n                            }\r\n\r\n                            @Override\r\n                            public void onError(Throwable throwable) {\r\n\r\n                            }\r\n\r\n                            @Override\r\n                            public void onComplete() {\r\n                                compositeDisposable.remove(this);\r\n                                waitForIt.countDown();\r\n                            }\r\n                        }));\r\n\r\n        System.out.println(compositeDisposable.size());\r\n        log(\"Waiting for finish\");\r\n        waitForIt.await();\r\n        System.out.println(compositeDisposable.size());\r\n    }\r\n\r\n    private static void log(String message) {\r\n        System.out.println(message + String.format(\" (%s)\", Thread.currentThread().getName()));\r\n    }\r\n```\r\nHere's the output:\r\n\r\n```\r\n1\r\nWaiting for finish (main)\r\nEmitting: 0 (RxComputationThreadPool-1)\r\nEmitting: 1 (RxComputationThreadPool-1)\r\nEmitting: 2 (RxComputationThreadPool-1)\r\nEmitting: 3 (RxComputationThreadPool-1)\r\nEmitting: 4 (RxComputationThreadPool-1)\r\nReceiving: 0 (RxCachedThreadScheduler-1)\r\nReceiving: 1 (RxCachedThreadScheduler-1)\r\nReceiving: 2 (RxCachedThreadScheduler-1)\r\nReceiving: 3 (RxCachedThreadScheduler-1)\r\nEmitting: 5 (RxCachedThreadScheduler-1)\r\nEmitting: 6 (RxCachedThreadScheduler-1)\r\nEmitting: 7 (RxCachedThreadScheduler-1)\r\nEmitting: 8 (RxCachedThreadScheduler-1)\r\nReceiving: 4 (RxCachedThreadScheduler-1)\r\nReceiving: 5 (RxCachedThreadScheduler-1)\r\nReceiving: 6 (RxCachedThreadScheduler-1)\r\nReceiving: 7 (RxCachedThreadScheduler-1)\r\nEmitting: 9 (RxCachedThreadScheduler-1)\r\nEmitting: 10 (RxCachedThreadScheduler-1)\r\nEmitting: 11 (RxCachedThreadScheduler-1)\r\nReceiving: 8 (RxCachedThreadScheduler-1)\r\nReceiving: 9 (RxCachedThreadScheduler-1)\r\nReceiving: 10 (RxCachedThreadScheduler-1)\r\nReceiving: 11 (RxCachedThreadScheduler-1)\r\n0\r\n```\r\nI would expect all `Emitting: ...`  log lines to be in an RxComputationThreadPool-x. But once `bufferSize` events have been emitted (and the subscriber starts working), the flowable emits in the same thread has the subscriber.\r\n\r\nIs this normal behavior ?\r\n\r\nThanks, regards"
    },
    "satisfaction_conditions": [
      "Backpressure handling remains functional"
    ],
    "created_at": "2019-07-11T10:00:41Z"
  },
  {
    "id": "https://github.com/ReactiveX/RxJava/issues/6495",
    "source": {
      "issue_number": 6495
    },
    "initial_question": {
      "title": "SwitchIfEmpty on a Subject",
      "body": "I have an issue with the Observable.switchIfEmpty operator. It\u2019s not called properly. See sample code\r\n\r\n```kotlin\r\nclass TestObs {\r\n\r\n    @Test\r\n    fun testSwitchIfEmpty() {\r\n        val subject = BehaviorSubject.create<List<String>>()\r\n        subject.onNext(listOf(\"a\"))\r\n        subject.test().assertValueCount(1)\r\n\r\n        // works\r\n//        Observable.create<List<String>> { emitter ->\r\n//            emitter.onNext(listOf(\"a\"))\r\n//            emitter.onComplete()\r\n//        }\r\n\r\n        // fails\r\n        subject\r\n            .flatMapIterable { it }\r\n            .filter { it == \"c\" }\r\n            .switchIfEmpty(Observable.create { emitter ->\r\n                emitter.onNext(\"c\")\r\n                emitter.onComplete()\r\n            })\r\n            .test()\r\n            .assertValue(\"c\")\r\n    }\r\n}\r\n```\r\n\r\nI just want to filter \"c\" and if there is no \"c\" switch to a new Observable an emit a \"c\". \r\n\r\nThis works if the origin of my rx chain starts with an Observable, but my test fails if my source is a subject. Does this make any sense to you?\r\n\r\nThanks!\r\n\r\nrxJavaVersion = '2.2.6'"
    },
    "satisfaction_conditions": [
      "Final output must emit 'c' when input list doesn't contain 'c'",
      "Original values must be properly filtered before switchIfEmpty is considered",
      "Solution must handle both finite and infinite source streams",
      "Test assertions must pass with expected value count and content"
    ],
    "created_at": "2019-06-04T07:43:33Z"
  },
  {
    "id": "https://github.com/ReactiveX/RxJava/issues/6214",
    "source": {
      "issue_number": 6214
    },
    "initial_question": {
      "title": "RxJava 2.2.2 startsWith subscribes the subsequence streams without subscribing to the upper stream",
      "body": "Hi, I'm not sure if this is a bug or an expected behavior. \r\nSee an example below:\r\n```\r\n        PublishSubject<Integer> subject = PublishSubject.create();\r\n        AtomicBoolean bool = new AtomicBoolean();\r\n        subject\r\n                .doOnSubscribe(s->{}) << not called\r\n                .doOnNext(s->{}) << not called\r\n                .startWith(0)\r\n                .switchMap(o -> Observable\r\n                        .empty()\r\n                        .doOnSubscribe(s -> {\r\n                            if (!bool.get()) {\r\n                                subject.onNext(1); << called\r\n                            }\r\n                        }))\r\n                .subscribe();\r\n```\r\nScenario:\r\nIn my use case, I subscribed to a source that chained with a #startWith operator.\r\nI performed a switchMap, expecting the next value terminates it and starts a new one. \r\nSubject emits something during the switchmap. Happens on both Observable/Flowable.\r\n\r\nExpected: receive the new event\r\nActual: receive nothing due to subject not subscribed yet.\r\n\r\nHave not tested on other version.\r\n\r\nThanks\r\n"
    },
    "satisfaction_conditions": [
      "Subscription order must respect operator sequence completion",
      "Source subscription timing must be predictable"
    ],
    "created_at": "2018-09-16T14:58:16Z"
  },
  {
    "id": "https://github.com/ReactiveX/RxJava/issues/6190",
    "source": {
      "issue_number": 6190
    },
    "initial_question": {
      "title": "Why doesn't Flowable#buffer(long, TimeUnit, int) support backpressure?",
      "body": "Why doesn't Flowable#buffer(long, TimeUnit, int) support backpressure?\r\n\r\nI'm using version 2.2.1, and here's the code for my experiment:\r\n```java\r\n\tpublic static void main(String[] args) throws Exception {\r\n\t\tFlowable.range(0, 10000)\r\n\t\t.buffer(5, TimeUnit.SECONDS, 100)\r\n//\t\t.onBackpressureBuffer()\r\n\t\t.concatMap(list -> {\r\n\t\t\tSystem.out.println(list.size());\r\n\t\t\treturn Flowable.just(list).delaySubscription(500, TimeUnit.MILLISECONDS);\r\n\t\t})\r\n\t\t.blockingSubscribe();\r\n\t}\r\n```\r\nThe code above will cause a `MissingBackpressureException` unless I add `.onBackpressureBuffer()` after `.buffer(5, TimeUnit.SECONDS, 100)`, which is to be expected because the Javadoc for `Flowable#buffer(long, TimeUnit, int)` says `This operator does not support backpressure as it uses time`.\r\n\r\nSo here are my questions:\r\n1. I understand why a size based buffer can support backpressure while a time based buffer cannot. But why can't a time and size based buffer support backpressure like a purely size based buffer does?\r\n2. Is there a way to achieve a backpressured size based buffer with a time based \"kick\"?\r\n"
    },
    "satisfaction_conditions": [
      "The solution must handle both time-based and size-based buffering requirements simultaneously",
      "The solution must handle scenarios where downstream consumers process data slower than it arrives",
      "The solution must maintain time-based guarantees for buffer emission",
      "The solution must provide a clear strategy for handling overflow situations"
    ],
    "created_at": "2018-08-31T19:16:59Z"
  },
  {
    "id": "https://github.com/ReactiveX/RxJava/issues/6184",
    "source": {
      "issue_number": 6184
    },
    "initial_question": {
      "title": "flatmap from observable to completable,onComplete Action no call!",
      "body": "RxJava version:2.1.12\r\n\r\ncode:\r\n``` kotlin\r\nObservable.create<Unit> { it.onNext(Unit) }\r\n                    .observeOn(Schedulers.io())\r\n                    .flatMap { Observable.create<Unit> { it.onNext(Unit) } }\r\n                    .flatMap { Observable.create<Unit> { it.onNext(Unit) } }\r\n                    .flatMap { Observable.create<Unit> { it.onNext(Unit) } }\r\n                    .flatMapCompletable {\r\n                        Completable.create {\r\n                            Thread.sleep(3000)\r\n                            //do something\r\n                            it.onComplete()\r\n                        }\r\n                    }\r\n                    .observeOn(AndroidSchedulers.mainThread())\r\n                    .subscribe(Action {\r\n                        //no call\r\n                        print(\"11111\")\r\n                    }, Consumer {\r\n                        print(\"1111\")\r\n                    })\r\n```\r\nI don't know why, the final onComplete Action is not called. Is there a problem with my usage?\r\nIf you replace all Observable.create with Observable.just() , the final onComplete Action will be called. Why?\r\n\r\n"
    },
    "satisfaction_conditions": [
      "Thread scheduling must maintain proper signal propagation"
    ],
    "created_at": "2018-08-29T09:44:07Z"
  },
  {
    "id": "https://github.com/ReactiveX/RxJava/issues/6169",
    "source": {
      "issue_number": 6169
    },
    "initial_question": {
      "title": "Give Flowable.sequenceEqual()/BiPredicate the option to use Single<Boolean> instead of boolean",
      "body": "I need to compare two `Flowable`s, that unfortunaley, due to `groupBy()` do not complete until all items it contains are subscribed to. \r\n\r\nCurrently, this is not possible since test() in the BiPredicate you can implement for `sequenceEqual()` can only return a `boolean`, it expects the `Flowable` to be comparable one by one. I suggest to overload `test()` so that it can also return `Single<Boolean>` - thus allowing the comparison to happen for all elements of the `Flowable` before expecting it to complete, which lets every item be subscribed to."
    },
    "satisfaction_conditions": [
      "Comparison of Flowables must complete when elements contain nested Flowables",
      "All nested Flowables must be subscribed to concurrently",
      "Comparison must maintain backpressure handling",
      "Final comparison result must be deterministic"
    ],
    "created_at": "2018-08-23T09:15:45Z"
  },
  {
    "id": "https://github.com/ReactiveX/RxJava/issues/6163",
    "source": {
      "issue_number": 6163
    },
    "initial_question": {
      "title": "Why rx throws OnErrorNotImplementedException when I have doOnError",
      "body": "version:\r\n2.2.0\r\n\r\nThe code:\r\n\r\n```java\r\n        Observable.create(new ObservableOnSubscribe<String>() {\r\n            @Override\r\n            public void subscribe(ObservableEmitter<String> emitter) throws Exception {\r\n                Log.d(TAG, \"subscribe: \" + \" 111111111\");\r\n                emitter.onNext(\"success\");\r\n                emitter.onError(new Throwable(\"2222222\"));\r\n            }\r\n        })\r\n                .doOnNext(new Consumer<String>() {\r\n                    @Override\r\n                    public void accept(String s) throws Exception {\r\n                        Log.d(TAG, \"accept: doOnNext \" + s);\r\n                    }\r\n                })\r\n                .doOnError(new Consumer<Throwable>() {\r\n                    @Override\r\n                    public void accept(Throwable throwable) throws Exception {\r\n                        Log.d(TAG, \"accept: doOnError \" + throwable);\r\n                    }\r\n                })\r\n               .subscribe();\r\n```\r\nThe Exception:\r\n\r\nio.reactivex.exceptions.OnErrorNotImplementedException: 2222222\r\n\r\nIf the `doOnError` can not handle the exception, the `doOnError` is design for what?"
    },
    "satisfaction_conditions": [
      "doOnError operations must execute without affecting error propagation"
    ],
    "created_at": "2018-08-18T02:40:36Z"
  },
  {
    "id": "https://github.com/ReactiveX/RxJava/issues/6008",
    "source": {
      "issue_number": 6008
    },
    "initial_question": {
      "title": "2.x: Single, toObservable and share: sometimes NoSuchElementException",
      "body": "Hello. I periodically have a NoSuchElementException. Version 2.1.12.\r\n\r\nCode:\r\n```\r\nSingle<String> single = Single.just(\"12345\")\r\n              .toObservable()\r\n              .share()\r\n              .singleOrError();\r\n      \r\n      for (int i = 0; i < 10; i++) {\r\n         new Thread(() -> {\r\n            single.subscribe((t) -> {\r\n            }, thrw -> {\r\n               if (NoSuchElementException.class.equals(thrw.getClass())) {\r\n                  printStackTrace();\r\n                  return;\r\n               }\r\n            });\r\n         }).start();\r\n\r\n         if (i % 2 != 0) {\r\n            Thread.sleep(4);\r\n         }\r\n      }\r\n\r\n```\r\nStacktrace:\r\n```\r\nat io.reactivex.internal.observers.ConsumerSingleObserver.onError(ConsumerSingleObserver.java:47)\r\n\tat io.reactivex.internal.operators.observable.ObservableSingleSingle$SingleElementObserver.onComplete(ObservableSingleSingle.java:113)\r\n\tat io.reactivex.internal.operators.observable.ObservableRefCount$ConnectionObserver.onComplete(ObservableRefCount.java:145)\r\n\tat io.reactivex.internal.operators.observable.ObservablePublish$PublishObserver.onComplete(ObservablePublish.java:193)\r\n\tat io.reactivex.internal.observers.DeferredScalarDisposable.complete(DeferredScalarDisposable.java:85)\r\n\tat io.reactivex.internal.operators.single.SingleToObservable$SingleToObservableObserver.onSuccess(SingleToObservable.java:73)\r\n\tat io.reactivex.internal.operators.single.SingleJust.subscribeActual(SingleJust.java:30)\r\n\tat io.reactivex.Single.subscribe(Single.java:3220)\r\n\tat io.reactivex.internal.operators.single.SingleToObservable.subscribeActual(SingleToObservable.java:36)\r\n\tat io.reactivex.Observable.subscribe(Observable.java:12005)\r\n\tat io.reactivex.internal.operators.observable.ObservablePublish.connect(ObservablePublish.java:116)\r\n\tat io.reactivex.internal.operators.observable.ObservableRefCount.subscribeActual(ObservableRefCount.java:68)\r\n\tat io.reactivex.Observable.subscribe(Observable.java:12005)\r\n\tat io.reactivex.internal.operators.observable.ObservableSingleSingle.subscribeActual(ObservableSingleSingle.java:35)\r\n\tat io.reactivex.Single.subscribe(Single.java:3220)\r\n\tat io.reactivex.Single.subscribe(Single.java:3206)\r\n```\r\n\r\nIs this a bug or an incorrect code? For cycle is written to demonstrate the problem."
    },
    "satisfaction_conditions": [
      "Solution must maintain thread-safety"
    ],
    "created_at": "2018-05-16T09:38:23Z"
  },
  {
    "id": "https://github.com/ReactiveX/RxJava/issues/5941",
    "source": {
      "issue_number": 5941
    },
    "initial_question": {
      "title": "[RxJava 2.1] Executing blocking operations on IO scheduler switches execution to a single thread",
      "body": "RxJava 2.1.3\r\n\r\nSample that demonstrates the problem:\r\n\r\n```java\r\nimport java.util.concurrent.ConcurrentHashMap;\r\nimport java.util.concurrent.atomic.AtomicInteger;\r\nimport java.util.concurrent.atomic.AtomicLong;\r\n\r\nimport io.reactivex.Observable;\r\nimport io.reactivex.ObservableTransformer;\r\nimport io.reactivex.functions.Action;\r\nimport io.reactivex.schedulers.Schedulers;\r\n\r\npublic class Main {\r\n  private static final int NUM_THREADS = 8;\r\n  private static final int NUM_EVENTS = 200;\r\n\r\n  public static void main(String[] args) throws Exception {\r\n    System.out.println(\"Executing blocking operation...\");\r\n    observe(() -> Thread.sleep((long) (Math.random() * 100)));\r\n\r\n    System.out.println(\"Executing non-blocking operation...\");\r\n    observe(() -> {});\r\n  }\r\n\r\n  private static void observe(Action op) {\r\n    AtomicInteger messageReceived = new AtomicInteger(0);\r\n    AtomicInteger observableComplete = new AtomicInteger(0);\r\n    ConcurrentHashMap<String, AtomicInteger> counters = new ConcurrentHashMap<>();\r\n\r\n    createObservable()\r\n        .compose(createThreadPoolTransformer())\r\n        .compose(performOperation(op))\r\n        .subscribe(\r\n            e -> {\r\n              counters.compute(Thread.currentThread().getName(), (key, ai) -> {\r\n                ai = ai == null ? new AtomicInteger(0) : ai;\r\n                ai.incrementAndGet();\r\n                return ai;\r\n              });\r\n              messageReceived.incrementAndGet();\r\n\r\n              if (messageReceived.get() == NUM_EVENTS) {\r\n                System.out.println(String.format(\"Counts per thread: %s \\n\", counters));\r\n              }\r\n            }, e -> {}, observableComplete::incrementAndGet);\r\n\r\n    while(observableComplete.get() == 0) {\r\n      // wait until it's complete\r\n    }\r\n  }\r\n\r\n  private static Observable<Long> createObservable() {\r\n    return Observable.just(0).repeat(NUM_EVENTS).map(al -> {\r\n      Thread.sleep(10);\r\n      return System.currentTimeMillis();\r\n    });\r\n  }\r\n\r\n  private static ObservableTransformer<Long, Long> createThreadPoolTransformer() {\r\n    AtomicLong counter = new AtomicLong(0);\r\n    return upstream ->\r\n        upstream\r\n            .groupBy(e -> counter.getAndIncrement() % NUM_THREADS)\r\n            .flatMap(g -> g.observeOn(Schedulers.io()));\r\n  }\r\n\r\n  private static ObservableTransformer<Long, Long> performOperation(Action op) {\r\n    return upstream -> upstream\r\n        .map(\r\n            e -> {\r\n              if (Math.random() < 0.5) {\r\n                op.run();\r\n              }\r\n              return e;\r\n            });\r\n  }\r\n}\r\n```\r\nRunning the program should print something like:\r\n```\r\nExecuting blocking operation...\r\nCounts per thread: {RxCachedThreadScheduler-1=200} \r\n\r\nExecuting non-blocking operation...\r\nCounts per thread: {RxCachedThreadScheduler-1=25, RxCachedThreadScheduler-2=25, RxCachedThreadScheduler-3=25, RxCachedThreadScheduler-8=25, RxCachedThreadScheduler-4=25, RxCachedThreadScheduler-5=25, RxCachedThreadScheduler-6=25, RxCachedThreadScheduler-7=25} \r\n```\r\n\r\nIt shows that after scheduling execution of blocking operations on an IO pool, the observable runs all these operations on a single thread instead.\r\n\r\nI would really appreciate any suggestions to retain equal load on all threads even in the presence of blocking operations!"
    },
    "satisfaction_conditions": [
      "Thread scheduling must respect RxJava's observeOn operator behavior"
    ],
    "created_at": "2018-03-31T03:43:40Z"
  },
  {
    "id": "https://github.com/ReactiveX/RxJava/issues/5939",
    "source": {
      "issue_number": 5939
    },
    "initial_question": {
      "title": "2.x: Observable.switchMapCompletable does not call action on completion",
      "body": "Maybe I\u2019m using it wrong though. I\u2019ve prepared some tests.\r\n\r\n```kotlin\r\nimport io.reactivex.Completable\r\nimport io.reactivex.functions.Action\r\nimport io.reactivex.schedulers.TestScheduler\r\nimport io.reactivex.subjects.PublishSubject\r\nimport org.junit.Test\r\nimport org.mockito.Mockito\r\nimport java.util.concurrent.TimeUnit\r\n\r\nclass CompletableTest {\r\n\r\n    private class Environment {\r\n\r\n        private val completableSeconds = 5\r\n\r\n        val timeScheduler = TestScheduler()\r\n        val action = Mockito.mock(Action::class.java)\r\n\r\n        val observable = PublishSubject.create<Unit>()\r\n        val completable = Completable.timer(completableSeconds.toLong(), TimeUnit.SECONDS, timeScheduler)\r\n\r\n        fun trigger() {\r\n            observable.onNext(Unit)\r\n            timeScheduler.advanceTimeBy(completableSeconds.toLong(), TimeUnit.SECONDS)\r\n        }\r\n    }\r\n\r\n    @Test fun pass_directSubscription() {\r\n        val env = Environment()\r\n\r\n        env.observable.subscribe { env.completable.subscribe(env.action) }\r\n\r\n        env.trigger()\r\n\r\n        Mockito.verify(env.action).run()\r\n    }\r\n\r\n    @Test fun fail_switchMapCompletable() {\r\n        val env = Environment()\r\n\r\n        env.observable.switchMapCompletable { env.completable }.subscribe(env.action)\r\n\r\n        env.trigger()\r\n\r\n        Mockito.verify(env.action).run()\r\n    }\r\n}\r\n```\r\n```\r\nWanted but not invoked:\r\naction.run();\r\n-> at CompletableTest.fail_switchMapCompletable\r\nActually, there were zero interactions with this mock.\r\n```"
    },
    "satisfaction_conditions": [
      "Completable must complete only when both the upstream source completes AND the mapped Completable completes",
      "Action execution must occur after successful completion",
      "Observable emissions must trigger Completable mapping"
    ],
    "created_at": "2018-03-30T07:59:47Z"
  },
  {
    "id": "https://github.com/ReactiveX/RxJava/issues/5855",
    "source": {
      "issue_number": 5855
    },
    "initial_question": {
      "title": "Why zip(range(0, 1mi)), range(0, 100)) never finishes, when inverting the order does?",
      "body": "Version: \"2.1.9\"\r\n\r\nI recently ran into a problem where the order of my parameters to the Zip function matters, and now I'm trying to understand why.\r\n\r\nHere's a simplified test:\r\n\r\n```kotlin\r\nval bigRange = Observable.range(0, 1_000_000_000)\r\nval shortRange = Observable.range(0, 100)\r\n\r\nval ts = Observable.zip(shortRange, bigRange, BiFunction<Int, Int, Int> { _, b -> b }).test()\r\n// val ts = Observable.zip(bigRange, shortRange, BiFunction<Int, Int, Int> { a, _ -> a }).test()\r\n\r\nts.awaitTerminalEvent(10, TimeUnit.SECONDS)\r\n```\r\n\r\nIn the test above, the stream completes as expected; with 100 items. However, if I uncomment the other `ts`, then the app hangs.\r\n\r\nFrom the docs it makes me believe that if any of the streams completes, then the whole \"zip\" completes, but this is maybe not the case? Is it something to do with the Observable being a \"pusher\" and not a \"puller\"?\r\n\r\n"
    },
    "satisfaction_conditions": [
      "Maintains correct output size"
    ],
    "created_at": "2018-02-15T23:19:53Z"
  },
  {
    "id": "https://github.com/ReactiveX/RxJava/issues/5829",
    "source": {
      "issue_number": 5829
    },
    "initial_question": {
      "title": "Improve takeUntil method",
      "body": "rxJava version : 2.x\r\n\r\nBoth 'takeUntil' and 'takeWhile' functions have no inclusive functions.\r\nSo It is impossible to make the following code.\r\n\r\n```java\r\nObservable.just(1,2,3,4,-1,1,2,3,4)\r\n.takeUntil(value -> value == -1)\r\n// I wish : 1, 2, 3, 4, -1\r\n// actually : 1, 2, 3, 4\r\n```\r\n\r\nor in real world...\r\n```java\r\nObservable.merge(\r\n    cacheRequest,\r\n    networkRequest\r\n)\r\n.takeUntilInclusive(data -> data.dataType == FROM_NETWORK);\r\n// Load mem/network data. But when it comes to network data, it stops.\r\n```\r\n\r\nhow about create blow functions?\r\n\r\n`takeWhileInclusive`\r\n`takeUntilInclusive`\r\n`skipWhileInclusive`\r\n`skipUntilInclusive`"
    },
    "satisfaction_conditions": [
      "The takeUntil operator must include the terminating element in its output",
      "The sequence must terminate after the condition-matching element",
      "The operator must maintain the original order of elements until termination"
    ],
    "created_at": "2018-01-31T09:26:46Z"
  },
  {
    "id": "https://github.com/ReactiveX/RxJava/issues/5812",
    "source": {
      "issue_number": 5812
    },
    "initial_question": {
      "title": "2.x: Surprising `startWith` scheduling behaviour",
      "body": "Android and RxJava 2.1.8:\r\n\r\nI ran into a surprising behaviour of `startWith` that I'd like to verify. I've boiled it down to a simple example:\r\n```\r\nObservable.just(Unit)\r\n                .observeOn(Schedulers.io())\r\n                .startWith(Unit)\r\n                .switchMap {\r\n                    Observable.create<Unit> { emitter ->\r\n                        Thread.sleep(5000)\r\n                        emitter.onNext(Unit)\r\n                        emitter.onComplete()\r\n                    }\r\n                }\r\n                .observeOn(AndroidSchedulers.mainThread())\r\n                .subscribe()\r\n```\r\n\r\nIn the above example, execution of the observable inside `switchMap` happens on the main scheduler and blocks my UI. \r\n\r\nI would expect that it will happen on the `io` scheduler and it does indeed, as soon as I remove `startWith`. \r\n\r\nI realise I can just add another `observeOn` after `startWith` but it's puzzling. We're already on the `io` scheduler when the `startWith` gets hit, so why would it switch threads?"
    },
    "satisfaction_conditions": [
      "Operations inside switchMap must execute on background thread",
      "All items in the sequence (including those from startWith) must be processed on the intended scheduler",
      "UI thread must remain responsive during operation",
      "Observable chain must maintain expected emission order"
    ],
    "created_at": "2018-01-17T09:13:58Z"
  },
  {
    "id": "https://github.com/ReactiveX/RxJava/issues/5730",
    "source": {
      "issue_number": 5730
    },
    "initial_question": {
      "title": "How to execute a flowable dependent from another?",
      "body": "I want to chain two flowables, when the first one finishes to collect data from the network its result (an array list) must be passed to the second flowable.\r\nThe flowables update the UI as described in the scenario shown below, when an error occurs the execution is stopped.\r\n\r\nI hope to be more clear as possible adding all details about the expected result and the code I wrote\r\n\r\nThe scenario\r\n\r\n1. flowable-1 makes X network calls (X value depends on some condition COND)\r\n2. every network call returns a list of items (size can vary)\r\n3. the UI shows the count of items (eg. \"Retrieved 1 items\", \"Retrieved 5 items\")\r\n4. all calls are done (the condition COND is satisfied)\r\n5. all items collected now must post-processed by flowable-2\r\n6. the UI shows the progress (eg. 'item 1 of 9', 'item 2 of 9', ..., 'item 9 of 9')\r\n\r\nA possible expected output should be\r\n\r\n    Retrieved 1 item(s) |  \r\n    Retrieved 3 item(s) |- printed inside the doOnNext() 'called' by flowable-1\r\n    Retrieved 5 item(s) |  the array contains 9 items (1 + 3 + 5)\r\n\r\n    Item 1 of 9         |\r\n    ...                 |- printed inside the doOnNext() 'called' by flowable-2\r\n    Item 9 of 9         |\r\n      \r\n    Finished            | printed inside the subscribe()\r\n\r\n\r\nI've used Flowable.generate() to collected items from network calls\r\n\r\n```java\r\npublic Flowable<List<String>> fetchFromNetFlowable() {\r\n    offset = 0;\r\n    return Flowable.generate(new Consumer<Emitter<List<String>>>() {\r\n        @Override\r\n        public void accept(Emitter<List<String>> emitter) throws Exception {\r\n            List<String> subset = networkCall(offset);\r\n            boolean loadNext = subset.size() > 0;\r\n            offset += subset.size();\r\n\r\n            final ArrayList<String> validItems = new ArrayList<>();\r\n            for (String dummy : subset) {\r\n                if (conditionMet(dummy)) {\r\n                    validItems.add(dummy);\r\n                } else {\r\n                    loadNext = false;\r\n                    break;\r\n                }\r\n            }\r\n            if (!validItems.isEmpty()) {\r\n                emitter.onNext(validItems);\r\n            }\r\n            if (!loadNext) {\r\n                emitter.onComplete();\r\n            }\r\n        }\r\n    });\r\n}\r\n```\r\n\r\nThe second flowable will be used to update UI from onNext() caller\r\n\r\n```java\r\npublic Flowable secondFlowable(final Iterator<String> iterator) {\r\n    return Flowable.generate((emitter) -> {\r\n        if (iterator.hasNext()) {\r\n            // do some stuff with value\r\n            emitter.onNext(iterator.next());\r\n        } else {\r\n            emitter.onComplete();\r\n        }\r\n    });\r\n}\r\n```\r\n\r\nThen I would use both flowables but I don't understard how to make the second dependent from the first one, the `processTheListCallingTheSecondFlowable()` must be called only when `fetchFromNetFlowable()` has finished\r\n\r\n```java\r\npublic readDataAndProcess() {\r\n    total = 0;\r\n    compositeDisposable.add(postRetrieverRx.readPhotoPosts(blogName)\r\n            .subscribeOn(Schedulers.io())\r\n            .observeOn(AndroidSchedulers.mainThread())\r\n            .toObservable()\r\n            .doOnNext((tumblrPost) -> {\r\n                    total += tumblrPost.size();\r\n                    System.out.println(\"Retrieved \" + total + \" items\");\r\n            })\r\n            .flatMap((posts) -> Observable.fromIterable(posts))\r\n            .toList() // <--- now I have the single list with all items\r\n            // I don't know how to do\r\n            // processTheListCallingTheSecondFlowable() isn't an rx operator\r\n            // consider it only pseudo code\r\n            .processTheListCallingTheSecondFlowable()\r\n            .subscribe((allPosts) -> System.out.println(\"Finished\")\r\n    );\r\n}\r\n```\r\n"
    },
    "satisfaction_conditions": [
      "First flowable must complete all network data collection before second flowable begins",
      "All collected items must be aggregated into a single list before processing by second flowable",
      "UI updates must show real-time progress for both collection and processing phases",
      "Processing must maintain item ordering through both flowables",
      "Thread scheduling must support UI updates without blocking"
    ],
    "created_at": "2017-11-18T15:29:43Z"
  },
  {
    "id": "https://github.com/ReactiveX/RxJava/issues/5727",
    "source": {
      "issue_number": 5727
    },
    "initial_question": {
      "title": "[RxJava 2.1.0] Single with Cache cancellable behaviour",
      "body": "Hi,\r\nI'm using `Single` in the following way,\r\n\r\n           val bleConnection = Single.create({  \r\n             emitter -> // Do some one-time bluetooth connection operation and emit ble connection\r\n             emitter.setCancellable { \r\n                    // close the ble connection as this single is unsubscribed\r\n             }\r\n           }).cache()\r\n\r\n\r\nNow I expected `setCancellable` block to run when all the subscribers are disposed. But that block gets called on `onSuccess` or `onError`. So `Single` terminates itself when either success or error happens. But I want to run some cleanup operation when all my subscribers are disposed. How would I do that with `Single`? This can be easily achieved with `Flowable` or `Observable`. But this is essentially `Single` operation (Not a stream, just an one-time connection value). So I thought `Single` is the correct operator to use in this case."
    },
    "satisfaction_conditions": [
      "Multiple subscribers must be able to share the same connection",
      "The solution must maintain Single-like semantics (one-time value emission)"
    ],
    "created_at": "2017-11-15T17:52:41Z"
  },
  {
    "id": "https://github.com/ReactiveX/RxJava/issues/5588",
    "source": {
      "issue_number": 5588
    },
    "initial_question": {
      "title": "ConnectableObservable.connect() causes NetworkOnMainThreadException",
      "body": "## Versions \r\nRxJava: 2.1.0\r\nRxAndroid: 2.0.1\r\n\r\n## Issue\r\nI'm using the following pattern to allow me to share the result of an expensive network call across two observables, which both transform the result in different ways:\r\n\r\n```java\r\nConnectableObservable<Model> connectableObservable = doExpensiveNetworkCall().publish();\r\n\r\n// Transform in one way.\r\nconnectableObservable\r\n    .filter(...)\r\n    .subscribeOn(mDataManager.getScheduler())\r\n    .observeOn(AndroidSchedulers.mainThread())\r\n    .subscribe(...);\r\n\r\n// Transform in another.\r\nconnectableObservable\r\n    .filter(....)\r\n    .subscribeOn(mDataManager.getScheduler())\r\n    .observeOn(AndroidSchedulers.mainThread())\r\n    .subscribe(...);\r\n\r\n// And connect... Uh oh,  NetworkOnMainThreadException!\r\nconnectableObservable.connect();\r\n```\r\n\r\nThis is a very useful pattern, however, calling `.connect()` causes `NetworkOnMainThreadException` as the expensive network call is then run on the *main thread*, despite all subscribers of the downstream observables being on a separate thread.\r\n\r\nIs there an equivalent of `.connectOn()` or another alternative which can be used to also let the ConnectableObservable know that it should be run on a different thread? Alternatively, if there's a better way of achieving the above, any guidance would be much appreciated!"
    },
    "satisfaction_conditions": [
      "Multiple subscribers must receive the same network response data",
      "Downstream transformations must remain independent"
    ],
    "created_at": "2017-09-06T15:02:52Z"
  },
  {
    "id": "https://github.com/ReactiveX/RxJava/issues/5583",
    "source": {
      "issue_number": 5583
    },
    "initial_question": {
      "title": "how to subscribe BiConsumer with 2.x",
      "body": "Hi,\r\n\r\nHow can I subscribe BiConsumer just like subscribe Consumer?\r\n code like this:\r\n\r\n```java\r\nBiConsumer<Integer, String> biConsumer = new BiConsumer<Integer, String>() {\r\n\r\n            @Override\r\n            public void accept(Integer integer, String s) throws Exception {\r\n\r\n            }\r\n        };\r\nObservable.create().subscribe(biConsumer);\r\n```       \r\n"
    },
    "satisfaction_conditions": [
      "Data must be structured to work with RxJava's single-parameter subscription model",
      "Solution must be compatible with RxJava 2.x API"
    ],
    "created_at": "2017-09-04T10:05:34Z"
  },
  {
    "id": "https://github.com/ReactiveX/RxJava/issues/5562",
    "source": {
      "issue_number": 5562
    },
    "initial_question": {
      "title": "in this case subscribe onNext not working",
      "body": "Thanks for using RxJava but before you post an issue, please consider the following points:\r\n\r\nhere is my retrofit and rxjava version\uff1a\r\n\r\n    //rx\r\n    compile 'io.reactivex.rxjava2:rxjava:2.0.3'\r\n    compile 'io.reactivex.rxjava2:rxandroid:2.0.1'\r\n    //retrofit\r\n    compile 'com.squareup.retrofit2:retrofit:2.2.0'\r\n    compile 'com.squareup.retrofit2:converter-gson:2.0.2'\r\n    compile 'com.squareup.retrofit2:adapter-rxjava2:2.2.0'\r\n    //okhttp3\r\n    compile 'com.squareup.okhttp3:okhttp:3.4.1'\r\n    compile 'com.squareup.okhttp3:logging-interceptor:3.4.1'\r\n    compile 'com.squareup.okio:okio:1.6.0'\r\n\r\n retrofit like this\r\n`    @GET(\"getAppList\")\r\n    Flowable<EBApiResult<List<UserAppInfo>>> testGetUserApp();`\r\n\r\nrxjava like this\r\n\r\n`          Flowable<EBApiResult<List<UserAppInfo>>>  flowable = testGetAppInfos();`\r\n\r\n        flowable.map(new Function<EBApiResult<List<UserAppInfo>>, List<UserAppInfo>>() {\r\n\r\n            @Override\r\n            public List<UserAppInfo> apply(EBApiResult<List<UserAppInfo>> result) throws Exception {\r\n                return result.getResultData();\r\n            }\r\n        }).subscribeOn(Schedulers.io())\r\n                .observeOn(AndroidSchedulers.mainThread())\r\n                .subscribe(new Subscriber<List<UserAppInfo>>() {\r\n                    @Override\r\n                    public void onSubscribe(Subscription s) {\r\n                        Log.i(\"123\");\r\n                    }\r\n\r\n                    @Override\r\n                    public void onNext(List<UserAppInfo> userAppInfos) {\r\n                        uiPresenter.bindAppInfoList(result);\r\n                    }\r\n\r\n                    @Override\r\n                    public void onError(Throwable t) {\r\n                        uiPresenter.errPage(t.getMessage());\r\n                    }\r\n\r\n                    @Override\r\n                    public void onComplete() {\r\n                        uiPresenter.errPage(null);\r\n                    }\r\n                });`\r\n\r\nI can see that onSubscribe is called back\r\nbut onNext onError is not\u3002\r\n\r\nIf I call rxjava like this\r\n\r\n`          Flowable<EBApiResult<List<UserAppInfo>>>  flowable = testGetAppInfos();`\r\n\r\n      flowable.map(new Function<EBApiResult<List<UserAppInfo>>, List<UserAppInfo>>() {\r\n\r\n            @Override\r\n            public List<UserAppInfo> apply(EBApiResult<List<UserAppInfo>> result) throws Exception {\r\n                return result.getResultData();\r\n            }\r\n        }).subscribeOn(Schedulers.io())\r\n                .observeOn(AndroidSchedulers.mainThread())\r\n                .subscribe(new Consumer<List<UserAppInfo>>() {\r\n                    @Override\r\n                    public void accept(List<UserAppInfo> appInfos) throws Exception {\r\n                        storeAppInfos(appInfos);\r\n                        List<UserAppInfo> result = filterListByCurrentCondition(appInfos, CURRENT_NEED_SHOW_APPS);\r\n                        uiPresenter.bindAppInfoList(result);\r\n                    }\r\n                }, new Consumer<Throwable>() {\r\n                    @Override\r\n                    public void accept(Throwable t) throws Exception {\r\n                        uiPresenter.errPage(t.getMessage());\r\n                    }\r\n                }, new Action() {\r\n                    @Override\r\n                    public void run() throws Exception {\r\n                    }\r\n                });`\r\n\r\nevery accept can be reached\r\ni dont know why\u3002\r\nbut i debug with source\uff0cI doubt it because...my Flowable\u2018s implementation is not QueueSubscription\u3002\r\n\r\nI don't know how to fix my problem. I hope you can understand"
    },
    "satisfaction_conditions": [
      "Data flow must be maintained across thread transitions"
    ],
    "created_at": "2017-08-23T03:47:21Z"
  },
  {
    "id": "https://github.com/ReactiveX/RxJava/issues/5561",
    "source": {
      "issue_number": 5561
    },
    "initial_question": {
      "title": "Task order for Observable.combineLatest and Schedulers.computation()",
      "body": "Version: 1.3.0\r\n\r\nHello!\r\n\r\nI have observed strange behavior while I was using combineLatest with Schedulers.computation(). Please take a look at example:\r\n```java\r\n   private static void runSubscription(String prefix, boolean shouldWait, ConcurrentMap<String, Integer> stat) {\r\n        Observable<Long> interval = Observable.interval(1000, TimeUnit.MILLISECONDS);\r\n        Observable.combineLatest(Observable.just(prefix), interval, (s1, s2) -> s1)\r\n            .subscribeOn(Schedulers.computation())\r\n            .observeOn(Schedulers.computation())\r\n            .onBackpressureLatest()\r\n            .subscribe(s -> {\r\n                try {\r\n                    if (shouldWait) {\r\n                        Thread.sleep(4000);\r\n                    }\r\n                } catch (InterruptedException e) {\r\n                    e.printStackTrace();\r\n                }\r\n                stat.merge(s, 1, (v1, v2) -> v1 + v2);\r\n            });\r\n    }\r\n\r\n    public static void main(String[] args) throws Exception {\r\n        ConcurrentMap<String, Integer> stat = new ConcurrentHashMap<>();\r\n\r\n        stat.put(\"1\", 0);\r\n        runSubscription(\"1\", true, stat);\r\n        for (int i = 1; i < Runtime.getRuntime().availableProcessors(); i++) {\r\n            String key = String.valueOf(i + 1);\r\n            stat.put(key, 0);\r\n            runSubscription(key, false, stat);\r\n        }\r\n\r\n        while (!Thread.currentThread().isInterrupted()) {\r\n            // Print invocation statistics\r\n            System.out.println(stat);\r\n            Thread.sleep(4000);\r\n        }\r\n    }\r\n```\r\nThe output shows how many times particular subscriber was invoked. First column - subscriber number, second - invocation count. For version above output is:\r\n```\r\n{1=0, 2=0, 3=0, 4=0}\r\n{1=0, 2=1, 3=1, 4=3}\r\n{1=1, 2=1, 3=1, 4=7}\r\n{1=2, 2=1, 3=1, 4=11}\r\n{1=3, 2=1, 3=1, 4=15}\r\n{1=4, 2=1, 3=1, 4=19}\r\n{1=5, 2=1, 3=1, 4=23}\r\n{1=6, 2=1, 3=1, 4=27}\r\n{1=7, 2=1, 3=1, 4=31}\r\n...\r\n```\r\nThe output is not stable, but every time some of threads invoked less times. \r\nBut when I changed both `Schedulers.computation()` to `Schedulers.io()`, output changed to expected:\r\n```\r\n{1=0, 2=0, 3=0, 4=0}\r\n{1=0, 2=3, 3=3, 4=3}\r\n{1=1, 2=7, 3=7, 4=7}\r\n{1=2, 2=11, 3=11, 4=11}\r\n{1=3, 2=15, 3=15, 4=15}\r\n{1=4, 2=19, 3=19, 4=19}\r\n```\r\nIs it incorrect usage of scheduler, or it is a bug?"
    },
    "satisfaction_conditions": [
      "Task execution order must be preserved when required by the operators"
    ],
    "created_at": "2017-08-22T18:25:28Z"
  },
  {
    "id": "https://github.com/ReactiveX/RxJava/issues/5559",
    "source": {
      "issue_number": 5559
    },
    "initial_question": {
      "title": "Sample operator with BehaviorSubject issue",
      "body": "When trying to use the sample operator with a BehaviorSubject as sampler it didn't work as expected (or understood).\r\nFor instance, this simple unit test fails:\r\n\r\n```java\r\n\u2002@Test\r\n\u2002\u2002\u2002\u2002public void testSampler() {\r\n\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002PublishSubject<Long> generator = PublishSubject.create();\r\n\r\n\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002BehaviorSubject<Boolean> sampler = BehaviorSubject.createDefault(true);\r\n\r\n\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002TestObserver<Long> sampledGeneratorObserver = generator.sample(sampler).test();\r\n\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002generator.onNext(2L);\r\n\r\n\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002sampledGeneratorObserver.assertValueCount(1);\r\n\u2002\u2002\u2002\u2002}\r\n```\r\n\r\nRX version: 2.1.x\r\n"
    },
    "satisfaction_conditions": [
      "Test assertions must verify actual sampling behavior"
    ],
    "created_at": "2017-08-22T15:20:15Z"
  },
  {
    "id": "https://github.com/ReactiveX/RxJava/issues/5532",
    "source": {
      "issue_number": 5532
    },
    "initial_question": {
      "title": "RxJava 2 and async subscriber",
      "body": "Hi, I am using RxJava 2.1.2 and found recently sample code that worked in RxJava 1.x but seems to work differently in RxJava 2.\r\nWhen I execute the code below I assume that each \"subscribe\" code will be run in new thread. However it is run in new but the same thread \"RxNewThreadScheduler-1\". I assume that Schedulers.io() should create a new thread per each long-running task. Please advice.\r\n\r\n```java\r\npublic class SampleRx {\r\n\tpublic static void main(String[] args) throws Exception {\r\n\t\tObservable.fromArray(\"1\", \"2\", \"3\")\r\n\t\t\t.observeOn(Schedulers.io())\r\n\t\t\t.subscribe(item -> { \r\n\t\t\t\tSystem.out.println(\r\n\t\t\t\t\t\tThread.currentThread().getName());\r\n\t\t\tThread.sleep(2000); });\r\n\t\tThread.sleep(7000);\r\n\t}\r\n}\r\n```"
    },
    "satisfaction_conditions": [
      "Multiple subscriptions must execute on different threads",
      "Thread allocation must persist throughout the entire subscription duration",
      "Observable sequence must complete successfully",
      "Thread management strategy must be explicitly configured"
    ],
    "created_at": "2017-08-02T17:16:46Z"
  },
  {
    "id": "https://github.com/ReactiveX/RxJava/issues/5526",
    "source": {
      "issue_number": 5526
    },
    "initial_question": {
      "title": "ParallelFlowable  concatMapDelayError emits items out of order",
      "body": "here is my code  with  parallel operator \r\n\r\n\r\n```\r\ndisposable.add(RxFirebase.observeChildEvent(mDatabase.child(AppConstant.MESSAGES).child(myID_otherID))\r\n                .filter(event -> event.getEventType() == RxFirebaseChildEvent.EventType.ADDED )\r\n                .parallel().runOn(Schedulers.io())\r\n                .concatMapDelayError(messageEvent-> {\r\n\r\n                  \r\n                  Message msg = messageEvent.getValue().getValue(Message.class);\r\n\r\n                    if(msg.getType().equals(AppConstant.MSG_TYPE_VIDEO))\r\n                    {\r\n\r\n                       return Flowable.zip(Flowable.just(msg),AppDatabase.getInstance(getContext()).downloadDoa().getDownloadtem(msg.getVideo_url())\r\n                            .defaultIfEmpty(new DownloadItem(null,null,null,null))\r\n                            .toFlowable().observeOn(AndroidSchedulers.mainThread()),(message, downloadItem) -> {\r\n\r\n                                message.setLocal_video_Path(downloadItem.local_path);\r\n                                message.setStatus(downloadItem.status);\r\n                                return message;\r\n\r\n                        });\r\n\r\n                    }else {\r\n                        return Flowable.just(msg);\r\n                    }\r\n\r\n                },2,true)\r\n                .sequential()\r\n                .observeOn(AndroidSchedulers.mainThread())\r\n                .subscribe(event -> {\r\n                    if(event.getLocal_video_Path() != null)\r\n                    Log.d(TAG, \"setMessagesListener: \"+event.getLocal_video_Path());\r\n\r\n                    messagesAdapter.addItem(event);\r\n                }, Throwable::printStackTrace));\r\n```\r\n\r\nit emit item out of order   but when i remove   .parallel().runOn(Schedulers.io())   and  .sequential()  and add subscribeOn(Schedular.io())  at zip operator  it emit item in order ???\r\n\r\n\r\n"
    },
    "satisfaction_conditions": [
      "System must handle both video and non-video message types correctly",
      "Processing must occur off the main thread",
      "Results must be delivered to the UI thread for display"
    ],
    "created_at": "2017-07-30T19:49:09Z"
  },
  {
    "id": "https://github.com/ReactiveX/RxJava/issues/5510",
    "source": {
      "issue_number": 5510
    },
    "initial_question": {
      "title": "Why doOnComplete / doOnSubscribe / subscribe not called?",
      "body": "Why are `doOnComplete`, `doOnSubscribe` (and also `doFinally`) not called?\r\n\r\n```kotlin\r\n//    val obs = createObservable()\r\nval obs = createCompletable()\r\n\r\n@JvmStatic fun main(args: Array<String>) {\r\n\r\n    obs.doOnSubscribe {\r\n        println(\"on subscribe!\")\r\n    }\r\n\r\n    obs.doOnComplete {\r\n        println(\"complete!\")\r\n    }\r\n\r\n    obs.doFinally{\r\n        println(\"dofinally!\")\r\n    }\r\n\r\n    obs.subscribe{\r\n        println(\"subscribe\")\r\n    }\r\n}\r\n\r\nfun createCompletable(): Completable =\r\n    Completable.create{ emitter ->\r\n        println(\"calling oncomplete\")\r\n        emitter.onComplete()\r\n    }\r\n\r\nfun createObservable(): Observable<Void> =\r\n    Observable.create<Void> { emitter ->\r\n        println(\"calling oncomplete\")\r\n        emitter.onComplete()\r\n    }\r\n```\r\n\r\nAlso, the subscribe block is called only when using `Completable`, with `Observable<Void>` this is also not called, why?\r\n\r\nIt seems that I'm missing something basic but not being able to figure out exactly what it is. \r\n\r\nI assume that the reason `subscribe` is not called when using the observable, is that this reacts only to `onNext` (?), but why isn't `doOnComplete` called either?"
    },
    "satisfaction_conditions": [
      "The final stream must be subscribed to initiate the flow"
    ],
    "created_at": "2017-07-20T21:45:45Z"
  },
  {
    "id": "https://github.com/ReactiveX/RxJava/issues/5412",
    "source": {
      "issue_number": 5412
    },
    "initial_question": {
      "title": "combineLatest(Iterable<Publisher<>>, Function<>) not emitting on empty iterable ",
      "body": "I am using RxJava 2.10 and operator\r\n\r\nio.reactivex.Flowable#combineLatest(java.lang.Iterable<? extends org.reactivestreams.Publisher<? extends T>>, io.reactivex.functions.Function<? super java.lang.Object[],? extends R>)\r\n\r\n but I've seen this behavior in 1.x as well. \r\n\r\nOverload of combineLatests (and combineLatestsDelayError) that takes Iterable of Publishers is not emitting any items and 'combiner' function passed to it is not called when iterable is empty. For this operator I would expect it to scale linearly, that is:\r\n\r\n- If I pass Iterable of size 2 as a first argument I expect an Array of size 2 to be passed to combiner function\r\n- If I pass Iterable of size 1 as a first argument I expect an Array of size 1 to be passed to combiner function\r\n- If I pass Iterable of size 0 as a first argument I expect an Array of size 0 to be passed to combiner function\r\n"
    },
    "satisfaction_conditions": [
      "Empty iterable input must result in immediate completion",
      "Alternative handling must be provided for empty source scenarios",
      "Solution must maintain reactive stream behavior"
    ],
    "created_at": "2017-06-14T10:33:48Z"
  },
  {
    "id": "https://github.com/ReactiveX/RxJava/issues/5402",
    "source": {
      "issue_number": 5402
    },
    "initial_question": {
      "title": "combineLatest with Iterable  not work ",
      "body": "What I am currently using:\r\n```\r\nObservable.combineLatest(countsObslist,objects -> {\r\n            Log.d(\"Rx\",\"check\");\r\n            for (Object obj:objects) {\r\n                if(((CharSequence)obj).length()>0){\r\n                    return true;\r\n                }\r\n            }\r\n            return false;\r\n        }).subscribe(aBoolean -> RxView.enabled(btnOder).accept(aBoolean));\r\n```\r\ncountsObslist is List<Observable<CharSequence>> type\r\n\r\nthis funtion can not run correctly....."
    },
    "satisfaction_conditions": [
      "All EditText fields in the ListView must be monitored for text changes",
      "Button state must update based on ANY EditText having content",
      "Initial state must be properly handled",
      "Observable combination must emit updates when any source changes",
      "Button enabled state must reflect current EditText contents"
    ],
    "created_at": "2017-06-08T19:46:08Z"
  },
  {
    "id": "https://github.com/ReactiveX/RxJava/issues/5398",
    "source": {
      "issue_number": 5398
    },
    "initial_question": {
      "title": "Execute specific (automatic) actions when the client un/subscribe to Flowable.",
      "body": "I was trying to create a `Flowable` that is connected to a source when the client subscribes, and disconnect from the source when the client unsubscribes.\r\n\r\nI tried first using a custom `Flowable`, in this way:\r\n\r\n```\r\npublic final class SensorEventFlowable extends Flowable<RxSensorEvent> {\r\n\r\n    private final SensorManager sensorManager;\r\n    private final Sensor sensor;\r\n    private final int samplingPeriodUs;\r\n\r\n    SensorEventFlowable(SensorManager sensorManager, Sensor sensor, int samplingPeriodUs) {\r\n        this.sensorManager = sensorManager;\r\n        this.sensor = sensor;\r\n        this.samplingPeriodUs = samplingPeriodUs;\r\n    }\r\n\r\n    @Override\r\n    protected void subscribeActual(Subscriber<? super RxSensorEvent> subscriber) {\r\n        Listener listener = new Listener(sensorManager, subscriber);\r\n        subscriber.onSubscribe(listener);\r\n        sensorManager.registerListener(listener, sensor, samplingPeriodUs);\r\n    }\r\n\r\n    static final class Listener implements Subscription, SensorEventListener {\r\n        private final SensorManager sensorManager;\r\n        private final Subscriber<? super RxSensorEvent> subscriber;\r\n\r\n        Listener(SensorManager sensorManager, Subscriber<? super RxSensorEvent> subscriber) {\r\n            this.sensorManager = sensorManager;\r\n            this.subscriber = subscriber;\r\n        }\r\n\r\n        @Override\r\n        public void onSensorChanged(SensorEvent event) {\r\n            subscriber.onNext(new RxSensorEvent(event));\r\n        }\r\n\r\n        @Override\r\n        public void request(long n) { }\r\n\r\n        @Override\r\n        public void cancel() {\r\n            sensorManager.unregisterListener(this);\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n\r\nbut I was suggested to use `Flowable.create()` instead. So I tried to use it:\r\n\r\n```\r\npublic final class SensorEventFlowableFactory {\r\n\r\n    public static Flowable<RxSensorEvent> create(SensorManager sensorManager, Sensor sensor, int samplingPeriodUs) {\r\n        return Flowable.create(e -> {\r\n            Listener listener = new Listener(e);\r\n            sensorManager.registerListener(listener, sensor, samplingPeriodUs);\r\n        }, BackpressureStrategy.MISSING);\r\n    }\r\n\r\n    static final class Listener implements SensorEventListener {\r\n        private final FlowableEmitter<RxSensorEvent> emitter;\r\n\r\n        Listener(FlowableEmitter<RxSensorEvent> emitter) {\r\n            this.emitter = emitter;\r\n        }\r\n\r\n        @Override\r\n        public void onSensorChanged(SensorEvent event) {\r\n            emitter.onNext(new RxSensorEvent(event));\r\n        }\r\n    }\r\n}\r\n\r\n```\r\n\r\nI have some doubts about this code:\r\n\r\n1. In the first implementation I have `cancel` method that will execute `sensorManager.unregisterListener(this);`. How can I make this happens in the second implementation? (when the client unsubscribe from the flowable). I don't want the client to be aware about this.\r\n\r\n2. Actually, if I am not wrong, the method `sensorManager.registerListener(listener, sensor, samplingPeriodUs);` is called when the Flowable is created, and not when the client subscribe. Is that correct? If so, where do I need to place that call (registerListner) in order to be executed only if and when the client subscribes?"
    },
    "satisfaction_conditions": [
      "Sensor listener registration occurs when client subscribes",
      "Client code remains unaware of sensor registration/unregistration details",
      "Sensor events are properly delivered to subscribers while connected",
      "Each subscriber gets an independent sensor connection"
    ],
    "created_at": "2017-06-06T19:07:33Z"
  },
  {
    "id": "https://github.com/ReactiveX/RxJava/issues/5392",
    "source": {
      "issue_number": 5392
    },
    "initial_question": {
      "title": "RxJava 2.1.0 SerialDisposable#isDisposed() return false for Disposables#disposed() initial value",
      "body": "Consider following code:\r\n```java\r\nSerialDisposable disposable = new SerialDisposable(Disposables.disposed());\r\nif (disposable.isDisposed()) {\r\n   // do somesing\r\n}\r\n```\r\nI wanted to set my initial value to be disposed and thought ```isDispossed()``` will return ```true``` for ```Disposable``` returned from ```Disposables.disposed()```, but it actually returns ```false```. Find out thats because ```SerialDisposable#isDisposed()``` just check if current ```Disposable``` equals to ```DisposableHelper#DISPOSED```, which is weird. So to fix this I have to go with this:\r\n```java\r\nSerialDisposable disposable = new SerialDisposable(DisposableHelper.DISPOSED);\r\nif (disposable.isDisposed()) {\r\n   // do somesing\r\n}\r\n```\r\nIs this intended behavior? If so, can you please explicitly indicate this in the documentation?"
    },
    "satisfaction_conditions": [
      "Container's disposed state must be independent of its contained disposable's state",
      "Container must allow replacement of disposed items with new disposables",
      "Container's isDisposed() method must reflect the container's state, not the contained item's state"
    ],
    "created_at": "2017-06-05T12:35:17Z"
  },
  {
    "id": "https://github.com/ReactiveX/RxJava/issues/5380",
    "source": {
      "issue_number": 5380
    },
    "initial_question": {
      "title": "How to abort map() with long running operation after unsubscribe?",
      "body": "Hi,\r\nI am writing to a file (with a while loop) in map().\r\n\r\n I want to cancel this request, so I unsubscribe from the observable, onNext does not come as expected, _however the while cycle in map() keeps going_. \r\n\r\nIs there a way I can have the while loop break upon unsubscribe with map() or do I have to flatmap and create custom observable and check for isUnsubscribe somehow?"
    },
    "satisfaction_conditions": [
      "File writing operation must stop when subscription is cancelled",
      "Observable chain must handle cancellation signals",
      "Observable must support dynamic task addition while running"
    ],
    "created_at": "2017-05-30T21:33:50Z"
  },
  {
    "id": "https://github.com/ReactiveX/RxJava/issues/5375",
    "source": {
      "issue_number": 5375
    },
    "initial_question": {
      "title": "2.0.9 possible bug with Maybe.switchIfEmpty ",
      "body": "So, not sure if it's a bug or am I not using the operator right.\r\n\r\n    Maybe.empty<Int>()\r\n            .switchIfEmpty { Maybe.just(2) }\r\n            .subscribe {\r\n                println(\"got $it\")\r\n            }\r\n\r\nBlock above completes without any results as if `Maybe` is empty. While block below completes successfully with `got 2` output.\r\n\r\n    Maybe.empty<Int>()\r\n            .switchIfEmpty(Maybe.just(2))\r\n            .subscribe {\r\n                println(\"got $it\")\r\n            }\r\n\r\nFrom documentation I expect, that both cases should work the same.\r\n"
    },
    "satisfaction_conditions": [
      "The switchIfEmpty operator must emit values from the fallback source when the original Maybe is empty",
      "Values must be properly delivered to the subscribe callback when present"
    ],
    "created_at": "2017-05-29T11:55:42Z"
  },
  {
    "id": "https://github.com/ReactiveX/RxJava/issues/5311",
    "source": {
      "issue_number": 5311
    },
    "initial_question": {
      "title": "Confusing about request() method in a custom Flowable",
      "body": "Let's say I create a custom `Flowable`:\r\n\r\n```\r\npublic final class CustomFlowable extends Flowable<Integer> {\r\n\r\n    @Override\r\n    protected void subscribeActual(Subscriber subscriber) {\r\n        Listener listener = new Listener(subscriber);\r\n        subscriber.onSubscribe(listener);\r\n    }\r\n\r\n    static final class Listener implements Subscription {\r\n        private final Subscriber<Integer> subscriber;\r\n\r\n\r\n        Listener(Subscriber<Integer> subscriber) {\r\n            this.subscriber = subscriber;\r\n        }\r\n\r\n       public void onSensorChanged(SensorEvent event) {\r\n            subscriber.onNext(event));\r\n        }\r\n\r\n        @Override\r\n        public void request(long n) {\r\n            // how to deal with this method?\r\n        }\r\n\r\n        @Override\r\n        public void cancel() {\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nI have no clue about how to implement the `request(long n)` method in order to handle gracefully the backpressure. \r\nMy guess it is that when the `request()` method is called, I should send a number of items equals to `n` . But, should I stop in the meantime the normal stream of data coming from external source ( sensors)?\r\nDo I have a way for accessing the items in the queue and call a sequence of `onNext()` for those items? "
    },
    "satisfaction_conditions": [
      "The solution must provide flexibility in backpressure strategy selection"
    ],
    "created_at": "2017-04-22T12:16:44Z"
  },
  {
    "id": "https://github.com/ReactiveX/RxJava/issues/5292",
    "source": {
      "issue_number": 5292
    },
    "initial_question": {
      "title": "NPE in defer().flatMap() chain [2.0.6]",
      "body": "I get \"java.lang.NullPointerException: Attempt to invoke interface method 'void io.reactivex.disposables.Disposable.dispose()' on a null object reference\" running following sample code\r\n\r\n`    CompositeDisposable subs = new CompositeDisposable();\r\n\r\n    private Integer getInt() {\r\n        if(true)\r\n            throw new IllegalStateException();\r\n        return 0;\r\n    }\r\n\r\n    private void test() {\r\n        subs.add(Observable.defer(() -> observer -> {\r\n            observer.onNext(1);\r\n            observer.onComplete();\r\n        }).flatMap(o -> Observable.fromCallable(this::getInt))\r\n                .subscribe(integer -> {}, Throwable::printStackTrace)\r\n        );\r\n    }`\r\n\r\nAm I using defer in a wrong way? "
    },
    "satisfaction_conditions": [
      "Observable creation must follow RxJava protocol",
      "Error propagation must be maintained through the chain",
      "Deferred execution must be properly implemented"
    ],
    "created_at": "2017-04-18T20:26:12Z"
  },
  {
    "id": "https://github.com/ReactiveX/RxJava/issues/5272",
    "source": {
      "issue_number": 5272
    },
    "initial_question": {
      "title": "1.x repeatWhen does not call onCompleted on child subscription",
      "body": "Tested using RxJava 1.2.9.\r\n\r\nThe description of `repeatWhen` implies if the `notificationHandler` call an `onComplete` it should pass it onto the child subscription: \"If that Observable calls onComplete or onError then repeatWhen will call onCompleted or onError on the child subscription.\"\r\n\r\nHowever, this doesn't seem to happen. The `onError` seems to work, but `onCompleted` does not. This code illustrates this:\r\n\r\n```java\r\nSubscriber<Integer> subscriber = new Subscriber<Integer>() {\r\n    @Override public void onCompleted() {\r\n        System.out.println(\"completed\");\r\n    }\r\n\r\n    @Override public void onError(Throwable e) {\r\n        System.out.println(\"error\");\r\n    }\r\n\r\n    @Override public void onNext(Integer i) {\r\n\r\n    }\r\n};\r\n\r\n// Does not output anything\r\nObservable.just(1)\r\n        .repeatWhen(observable -> observable.flatMap(ignored -> Observable.empty()))\r\n        .subscribe(subscriber);\r\n\r\n// Prints \"error\" (as expected)\r\nObservable.just(1)\r\n        .repeatWhen(observable -> observable.flatMap(ignored -> Observable.error(new Exception())))\r\n        .subscribe(subscriber);\r\n```"
    },
    "satisfaction_conditions": [
      "The notification handler must use operators that can explicitly terminate the observable sequence",
      "The completion behavior must be distinguishable from 'skipping' behavior",
      "Error propagation must continue to function correctly"
    ],
    "created_at": "2017-04-07T21:37:26Z"
  },
  {
    "id": "https://github.com/ReactiveX/RxJava/issues/5264",
    "source": {
      "issue_number": 5264
    },
    "initial_question": {
      "title": "doOnDispose / doOnLifecycle onDisposed action not being called",
      "body": "Maybe I am doing something wrong, but this just stopped working when I updated version from 2.01 to 2.07 and 2.08.\r\n\r\nThe doOnDispose and the doOnLifecycle onDisposed action are not being called.\r\n\r\nSample code:\r\n\r\n        Observable.fromCallable(() -> \"1\")\r\n                .doOnLifecycle(\r\n                        disposable -> Log.i(TAG, \"1:doOnSubscribe\"),\r\n                        () -> Log.i(TAG, \"1:doOnDispose\")\r\n                )\r\n                .subscribe()\r\n                .dispose();\r\n\r\n        Observable.fromCallable(() -> \"2\")\r\n                .doOnSubscribe(disposable -> Log.i(TAG, \"2:doOnSubscribe\"))\r\n                .doOnDispose(() -> Log.i(TAG, \"2:doOnDispose\"))\r\n                .subscribe()\r\n                .dispose();"
    },
    "satisfaction_conditions": [
      "Observable lifecycle events must be properly captured after completion",
      "Progress indicator state must be correctly managed throughout the observable lifecycle",
      "Solution must work with RxJava version 2.0.5 and later",
      "Events must be captured for both normal completion and premature disposal",
      "Resource cleanup actions must execute reliably in all termination scenarios"
    ],
    "created_at": "2017-04-04T20:31:22Z"
  },
  {
    "id": "https://github.com/ReactiveX/RxJava/issues/5254",
    "source": {
      "issue_number": 5254
    },
    "initial_question": {
      "title": "RxJava 1.2.9 : calling onError without finishing / unsubscribing / onCompleted",
      "body": "my code\uff1a\r\n\r\n```\r\nSubscription subscription = Observable.create(new Observable.OnSubscribe<ProgressModel>() {\r\n            @Override\r\n            public void call(Subscriber<? super ProgressModel> subscriber) {\r\n                try {\r\n                    OkHttpClient httpClient = new OkHttpClient();\r\n                    Call call = httpClient.newCall(new Request.Builder().url(URL).build());\r\n                    Response response = call.execute();\r\n                    if (response.code() == 200) {\r\n\r\n                        makeFileFullPath(savePath);\r\n\r\n                        File file = new File(savePath);\r\n\r\n                        FileOutputStream outputStream = null;\r\n\r\n                        InputStream inputStream = null;\r\n                        try {\r\n\r\n                            inputStream = response.body().byteStream();\r\n                            outputStream = new FileOutputStream(file);\r\n                            byte[] buff = new byte[1024 * 4];\r\n                            long downloaded = 0;\r\n                            long target = response.body().contentLength();\r\n\r\n                            ProgressModel progressModel = new ProgressModel();\r\n                            progressModel.updateData(0, target, false);\r\n                            subscriber.onNext(progressModel);\r\n                            int length = 0;\r\n                            long oldPro = 0;\r\n                            while ((length = inputStream.read(buff)) != -1) {\r\n                                outputStream.write(buff, 0, length);\r\n                                downloaded += length;\r\n\r\n                                long tmp = (downloaded *100 /target);\r\n\r\n                               if(tmp != oldPro) {\r\n                                   progressModel.updateData(downloaded, target, false);\r\n                                   subscriber.onNext(progressModel);\r\n                                   oldPro = tmp;\r\n                               }\r\n\r\n                                if(isStop.get()) {\r\n                                    break;\r\n                                }\r\n                                System.out.println(\"complemnt\"+tmp+\",\"+oldPro);\r\n                            }\r\n                            if (downloaded == target) {\r\n                                subscriber.onCompleted();\r\n                            } else {\r\n                                subscriber.onNext(new ProgressModel(-1,-1,false));\r\n                            }\r\n\r\n                        } catch (IOException ignore) {\r\n                            subscriber.onNext(new ProgressModel(-1,-1,false));\r\n\r\n                        } finally {\r\n                            if (inputStream != null) {\r\n                                inputStream.close();\r\n                            }\r\n                            if(outputStream != null) {\r\n                                outputStream.close();\r\n                            }\r\n                        }\r\n                    } else {\r\n                        subscriber.onNext(new ProgressModel(-1,-1,false));\r\n                    }\r\n                } catch (IOException e) {\r\n                    e.printStackTrace();\r\n                }\r\n\r\n            }\r\n        }).subscribeOn(Schedulers.io())\r\n                .observeOn(AndroidSchedulers.mainThread()).subscribe(new Subscriber<ProgressModel>() {\r\n            @Override\r\n            public void onNext(ProgressModel s) {\r\n                if(s == null) return;\r\n\r\n               if(!progressListener.update(s.already,s.total,s.done)) {\r\n                   System.out.println(\"calback1111111112 kaishi zhixingle\");\r\n                   isStop.set(true);\r\n               }\r\n            }\r\n\r\n            @Override\r\n            public void onCompleted() {\r\n                progressListener.update(-1,-1,true);\r\n            }\r\n\r\n            @Override\r\n            public void onError(Throwable e) {\r\n                System.out.println(\"calback1111111112 kaishi zhixingle\");\r\n            }\r\n        });\r\n        mCompositeSubscription.add(subscription);\r\n```\r\nI did not call the method   ```public void onError(Throwable e)``` ,\r\n, but it was called by itself."
    },
    "satisfaction_conditions": [
      "Resource cleanup occurs properly regardless of completion state"
    ],
    "created_at": "2017-04-01T10:58:49Z"
  },
  {
    "id": "https://github.com/ReactiveX/RxJava/issues/5218",
    "source": {
      "issue_number": 5218
    },
    "initial_question": {
      "title": "FlatMap with Completable ",
      "body": "Basically I want to have the option of converting an Observable from flatMap to use as Completable. I am using RxJava 1.2.1 and trying to migrate to RxJava 2. Following the lead by Jake, I am removing all the Observable<Void> declarations  and replacing them with Completable. Here is the problem where I am stuck\r\n```\r\n public Observable<Void> saveReminder(final Reminder reminder)\r\n    {\r\n        return Observable.fromEmitter((Emitter<DataSnapshot> dataSnapshotAsyncEmitter) ->\r\n        {\r\n            FirebaseApi.getReminderReference().addListenerForSingleValueEvent(new ValueEventListener()\r\n            {\r\n                @Override\r\n                public void onDataChange(DataSnapshot dataSnapshot)\r\n                {\r\n                    dataSnapshotAsyncEmitter.onNext(dataSnapshot);\r\n                    dataSnapshotAsyncEmitter.onCompleted();\r\n                }\r\n\r\n                @Override\r\n                public void onCancelled(DatabaseError databaseError)\r\n                {\r\n                    if (databaseError != null)\r\n                    {\r\n                        dataSnapshotAsyncEmitter.onError(databaseError.toException());\r\n                    }\r\n                }\r\n            });\r\n        }, Emitter.BackpressureMode.LATEST).observeOn(Schedulers.io()).flatMap(reminderCardsSnapshot ->\r\n        {\r\n            try\r\n            {\r\n                return Observable.just(saveData(reminder, reminderCardsSnapshot));\r\n            } catch (Exception e)\r\n            {\r\n                return Observable.error(e);\r\n            }\r\n        });\r\n    }\r\n```\r\nI need to replace **Observable<Void>** with **Completable**. Plz help"
    },
    "satisfaction_conditions": [
      "Firebase event handling must be preserved",
      "Data saving operation must be executed",
      "Error handling must be maintained"
    ],
    "created_at": "2017-03-24T06:38:08Z"
  },
  {
    "id": "https://github.com/ReactiveX/RxJava/issues/5200",
    "source": {
      "issue_number": 5200
    },
    "initial_question": {
      "title": "2.x distinctUntilChanged should not update its value reference unless it changes",
      "body": "RxJava version: 2.0.7\r\n\r\nThe `ObservableDistinctUntilChanged` caches the last emitted value regardless if it changes or not, this can waste memory needlessly if the emits emitted are large. \r\n\r\nFor example, consider this snippet:\r\n```java\r\nObservable.concatArray(loadHeavyResourceFromCache(), observeHeavyResourceFromNetwork())\r\n    .distinctUntilChanged()\r\n    .subscribe(this::showHeavyResource);\r\n```\r\n\r\nAssuming they resources are equal and that `showHeavyResource` stores a reference to the item both the cached value and the network value are kept in memory.\r\nI feel like `ObservableDistinctUntilChanged` probably shouldn't change its internal value if it doesn't change between emissions."
    },
    "satisfaction_conditions": [
      "Memory usage is optimized by not storing duplicate values",
      "Maintains correct distinct-until-changed behavior",
      "Works with infinite streams",
      "Thread-safe value comparison"
    ],
    "created_at": "2017-03-20T09:11:41Z"
  },
  {
    "id": "https://github.com/ReactiveX/RxJava/issues/5166",
    "source": {
      "issue_number": 5166
    },
    "initial_question": {
      "title": "1.x Execute action after flattened observable completes",
      "body": "Hello,\r\n\r\ni'm with a doubt that i don't know how to write a flow that use a connection from database, but closes it a soon as the query ends, and before the downstream consume it's events.\r\n\r\nI'm using vert.x rxfied jdbc client, example code:\r\n\r\n```\r\njdbcClient.getConnectionObservable()\r\n                  .flatMap(conn -> conn.queryWithParamsObservable(\"SQL QUERY ...\", new JsonArray())\r\n                                       .doOnTerminate(conn::close))\r\n                  .map(ResultSet::getRows)\r\n                  .groupBy( // ... )\r\n```\r\n\r\nHow can i make the `conn::close` be classed **BEFORE** `map`, `groupby` and the rest of chian operators execute?\r\n\r\nCurrently, it will run the `doOnTerminate` only when the `subscriber` `unsubscribes`, since i'm returning it to other code, someone could do expensive things with the results, and i don't want the connection to be held due to that.\r\n\r\nOther thing, ideally i will be using `Observable.using` to create generic repository methods, because `getConnectionObservable` isn't lazy, it fetches a connection on calling, but it's not a `hot` observable since it don't pushes the values until subscribed, so, a sampel code would look like this:\r\n\r\n```\r\nObservable.defer(jdbcClient::getConnectionObservable)\r\n                  .flatMap(conn -> Observable.using(() -> {\r\n                                                      log.debug(\"Fetching database connection\");\r\n                                                      return conn;\r\n                                                  },\r\n                                                  // handle the connection here,\r\n                                                  connToClose -> {\r\n                                                      log.debug(\"Returning connection to pool\");\r\n                                                      connToClose.close();\r\n                                                  }));\r\n```\r\n\r\nI need to close the connection after it's used, before the chain ends."
    },
    "satisfaction_conditions": [
      "Database connection must be closed after query execution but before downstream processing begins",
      "Query results must be fully available to downstream operations after connection closure",
      "Observable chain must maintain lazy evaluation",
      "Operation ordering must be deterministic"
    ],
    "created_at": "2017-03-08T20:57:05Z"
  },
  {
    "id": "https://github.com/ReactiveX/RxJava/issues/5118",
    "source": {
      "issue_number": 5118
    },
    "initial_question": {
      "title": "Why is there no share or publish/refcount for single?",
      "body": "RX Java version 2.0.4 - Single doesn't have share/publish/refcount and therefore we can't have hot observables. Is there any reason for the same."
    },
    "satisfaction_conditions": [
      "The Single type must have a way to share/cache its emission across multiple subscribers",
      "The solution must maintain Single's single-item emission contract",
      "The functionality must be achievable within RxJava's existing API",
      "Hot observable behavior must be achievable if needed"
    ],
    "created_at": "2017-02-19T09:04:44Z"
  },
  {
    "id": "https://github.com/ReactiveX/RxJava/issues/5073",
    "source": {
      "issue_number": 5073
    },
    "initial_question": {
      "title": "2.x - groupBy() Parallelization Not Working like in 1.0",
      "body": "Hi David, \r\n\r\nWhile I was writing the Packt book, I think I might have found a problem with RxJava 2.0, unless this was an intended change and I'm missing something. When I do the parallelization pattern with `groupBy()` and a modulus Integer, it works fine in RxJava 1.0. Everything parallelizes across multiple threads as expected. \r\n\r\n```java \r\n\r\nimport rx.Observable;\r\nimport rx.schedulers.Schedulers;\r\nimport java.time.LocalTime;\r\nimport java.util.concurrent.ThreadLocalRandom;\r\nimport java.util.concurrent.atomic.AtomicInteger;\r\n\r\npublic class Launcher {\r\n    public static void main(String[] args) {\r\n\r\n       int coreCount = Runtime.getRuntime().availableProcessors();\r\n       AtomicInteger assigner = new AtomicInteger(0);\r\n\r\n       Observable.range(1,10)\r\n               .groupBy(i -> assigner.incrementAndGet() % coreCount)\r\n               .flatMap(grp -> grp.observeOn(Schedulers.io())\r\n                       .map(i2 -> intenseCalculation(i2))\r\n               )\r\n               .subscribe(i -> System.out.println(\"Received \" + i + \" \"\r\n                       + LocalTime.now() + \" on thread \"\r\n                       + Thread.currentThread().getName()));\r\n\r\n       sleep(20000);\r\n    }\r\n\r\n    public static <T> T intenseCalculation(T value) {\r\n        sleep(ThreadLocalRandom.current().nextInt(3000));\r\n        return value;\r\n    }\r\n    public static void sleep(long millis) {\r\n        try {\r\n            Thread.sleep(millis);\r\n        } catch (InterruptedException e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n**OUTPUT:**\r\n\r\n```\r\nReceived 1 20:17:23.422 on thread RxIoScheduler-2\r\nReceived 3 20:17:23.840 on thread RxIoScheduler-4\r\nReceived 4 20:17:24.053 on thread RxIoScheduler-5\r\nReceived 9 20:17:24.273 on thread RxIoScheduler-2\r\nReceived 5 20:17:24.695 on thread RxIoScheduler-6\r\nReceived 8 20:17:24.950 on thread RxIoScheduler-9\r\nReceived 6 20:17:25.242 on thread RxIoScheduler-7\r\nReceived 7 20:17:25.251 on thread RxIoScheduler-8\r\nReceived 2 20:17:25.324 on thread RxIoScheduler-3\r\nReceived 10 20:17:27.532 on thread RxIoScheduler-3\r\n\r\n```\r\n\r\nBut if I switch to RxJava 2.0, this no longer parallelizes. Everything stays strictly serial and only one thread is used. \r\n\r\n```java\r\n\r\nimport io.reactivex.Observable;\r\nimport io.reactivex.schedulers.Schedulers;\r\n\r\nimport java.time.LocalTime;\r\nimport java.util.concurrent.ThreadLocalRandom;\r\nimport java.util.concurrent.atomic.AtomicInteger;\r\n\r\npublic class Launcher {\r\n    public static void main(String[] args) {\r\n\r\n       int coreCount = Runtime.getRuntime().availableProcessors();\r\n       AtomicInteger assigner = new AtomicInteger(0);\r\n\r\n       Observable.range(1,10)\r\n               .groupBy(i -> assigner.incrementAndGet() % coreCount)\r\n               .flatMap(grp -> grp.observeOn(Schedulers.io())\r\n                       .map(i2 -> intenseCalculation(i2))\r\n               )\r\n               .subscribe(i -> System.out.println(\"Received \" + i + \" \"\r\n                       + LocalTime.now() + \" on thread \"\r\n                       + Thread.currentThread().getName()));\r\n\r\n       sleep(20000);\r\n    }\r\n\r\n    public static <T> T intenseCalculation(T value) {\r\n        sleep(ThreadLocalRandom.current().nextInt(3000));\r\n        return value;\r\n    }\r\n    public static void sleep(long millis) {\r\n        try {\r\n            Thread.sleep(millis);\r\n        } catch (InterruptedException e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n**OUTPUT:**\r\n\r\n```\r\nReceived 1 20:21:03.321 on thread RxCachedThreadScheduler-1\r\nReceived 9 20:21:05.273 on thread RxCachedThreadScheduler-1\r\nReceived 2 20:21:05.559 on thread RxCachedThreadScheduler-1\r\nReceived 10 20:21:07.390 on thread RxCachedThreadScheduler-1\r\nReceived 3 20:21:10.055 on thread RxCachedThreadScheduler-1\r\nReceived 4 20:21:11.962 on thread RxCachedThreadScheduler-1\r\nReceived 5 20:21:12.850 on thread RxCachedThreadScheduler-1\r\nReceived 6 20:21:15.779 on thread RxCachedThreadScheduler-1\r\nReceived 7 20:21:17.927 on thread RxCachedThreadScheduler-1\r\nReceived 8 20:21:20.540 on thread RxCachedThreadScheduler-1\r\n```\r\n\r\nIs there something new that I'm supposed to do? Or is this a possible behavior regression? "
    },
    "satisfaction_conditions": [
      "Multiple threads must be utilized concurrently for processing",
      "Processing time must be reduced compared to serial execution",
      "Each group of items must maintain consistent thread assignment",
      "Solution must work with RxJava 2.x version",
      "Thread scheduling must respect the number of available processors"
    ],
    "created_at": "2017-02-05T02:24:15Z"
  },
  {
    "id": "https://github.com/ReactiveX/RxJava/issues/5022",
    "source": {
      "issue_number": 5022
    },
    "initial_question": {
      "title": "Doubt about the terms Upstream vs Downstream",
      "body": "Hello everyone,\r\n\r\ni'm confused with the terms upstream and downstream, and hope someone could describe better who is who, and maybe illustrate with some examples?\r\n\r\nFor example, the documentation about zipWith in a Flowable:\r\n\r\n`The operator expects backpressure from the sources and honors backpressure from the downstream. (I.e., zipping with interval(long, TimeUnit) may result in MissingBackpressureException, use one of the onBackpressureX to handle similar, backpressure-ignoring sources.`\r\n\r\nHow do i interpret it? The downstream is the source i'm zipping (The parameter of `zipWith`) and the upstream is the `Flowable` i'm calling `zipWith`? "
    },
    "satisfaction_conditions": [
      "Clear distinction between upstream and downstream components must be provided",
      "Explanation must address directional flow of data/operations",
      "Specific context of Flowable operators must be addressed",
      "Relationship between multiple components must be explained"
    ],
    "created_at": "2017-01-26T20:07:36Z"
  },
  {
    "id": "https://github.com/ReactiveX/RxJava/issues/5012",
    "source": {
      "issue_number": 5012
    },
    "initial_question": {
      "title": "2.x: Reusing observers with managing subscriptions/disposables. ",
      "body": "I have the following problem: I have observer for network request, which can be reused in future (user swipe to refresh and etc). The problem is that I want to have ability to unsubscribe from results in any time and don't want to recreate observer each time. Code looks like that.\r\n```java\r\nprotected Observer<Collection<T>> mResponseObserver = new Observer<Collection<T>>() {\r\n        @Override\r\n        public void onSubscribe(Disposable d) {\r\n          // don't know how to store reference in another way     \r\n          mDisposable = d;\r\n        }\r\n     .....................\r\n    };\r\n..........................\r\n// can execute periodically\r\nvoid onRefresh() {\r\n    observableA.subscribe(mResponseObserver);\r\n}\r\n\r\n.........................\r\nvoid dispose() {\r\n    mDisposable.dispose();\r\n}\r\n```\r\nI try variant replacing ``` Observer``` with ```DisposableObserver``` and save disposable using ```subscribeWith()``` method, but it throw ```java.lang.IllegalStateException: Disposable already set!``` which is logical.\r\n\r\nMaybe I'm wrong and I need to create new observer each time ? What is the best practice?"
    },
    "satisfaction_conditions": [
      "Resource cleanup must be possible at any time"
    ],
    "created_at": "2017-01-23T08:44:40Z"
  },
  {
    "id": "https://github.com/ReactiveX/RxJava/issues/5010",
    "source": {
      "issue_number": 5010
    },
    "initial_question": {
      "title": "How can `.buffer(2,1)` ever emit a list with only one item?",
      "body": "Using RxJava version 1.2.5. (kotlin code below) \r\n\r\n```\r\nObservable.just(\"1\")\r\n                .startWith(emptyList<String>())\r\n                .buffer(2, 1)\r\n                .map { Pair(it[0], it[1]) } //throws java.lang.IndexOutOfBoundsException: Index: 1, Size: 1\r\n                .subscribe()\r\n\r\n```\r\n\r\nHow can `.buffer(2,1)` ever emit a list with only one item?\r\n\r\n\r\nOr, if you prefer java\r\n\r\n```\r\npublic class BufferTest {\r\n\r\n    @Test\r\n    public void name() throws Exception {\r\n        Observable.just(\"1\")\r\n                .startWith(new ArrayList<String>(0))\r\n                .buffer(2, 1)\r\n                .map(\r\n                        new Func1<List<String>, Pair>() {\r\n                            @Override\r\n                            public Pair call(List<String> list) {\r\n                                return new Pair(list.get(0), list.get(1)); //throws java.lang.IndexOutOfBoundsException: Index: 1, Size: 1\r\n                            }\r\n                        })\r\n                .subscribe();\r\n    }\r\n\r\n    private static class Pair {\r\n        final String first;\r\n        final String second;\r\n\r\n        Pair(String first, String second) {\r\n            this.first = first;\r\n            this.second = second;\r\n        }\r\n    }\r\n}\r\n\r\n```"
    },
    "satisfaction_conditions": [
      "Buffer operator must emit partial buffers on stream completion",
      "Code must handle partial buffer emissions",
      "Stream completion must trigger final buffer emission"
    ],
    "created_at": "2017-01-20T21:07:28Z"
  },
  {
    "id": "https://github.com/ReactiveX/RxJava/issues/4995",
    "source": {
      "issue_number": 4995
    },
    "initial_question": {
      "title": "Share does not work with just() and from()",
      "body": "Tested with RxJava <= 1.2.5:\r\n\r\nCreating observable with _interval()_:\r\n```java\r\nObservable<Long> interval = Observable.interval(100, TimeUnit.MILLISECONDS);\r\nObservable<Long> source = interval\r\n        .take(2)\r\n        .doOnNext(aLong -> System.out.println(\"Side effect\"));\r\nObservable<Long> published = source.share();\r\nObservable<Zip> zip = Observable.zip(\r\n        published.buffer(2),\r\n        OperatorMinMax.max(published),\r\n        Zip::new\r\n);\r\nzip.toBlocking().single();\r\n```\r\n\r\nresults in (which is **correct** because of the _share()_ operator):\r\n```\r\nSide effect\r\nSide effect\r\n```\r\n\r\nHowever, when creating Observable with _just()_:\r\n```java\r\nObservable<Long> interval = Observable.just(0L, 1L);\r\nObservable<Long> source = interval\r\n        .take(2)\r\n        .doOnNext(aLong -> System.out.println(\"Side effect\"));\r\nObservable<Long> published = source.share();\r\nObservable<Zip> zip = Observable.zip(\r\n        published.buffer(2),\r\n        OperatorMinMax.max(published),\r\n        Zip::new\r\n);\r\nzip.toBlocking().single();\r\n```\r\nthe result is:\r\n```\r\nSide effect\r\nSide effect\r\nSide effect\r\nSide effect\r\n```\r\nwhich is in my opinion **incorrect** as I used the _share()_ operator. The same applies for operators _from()_, _range()_...\r\nIs this a bug, or am I missing something important here?"
    },
    "satisfaction_conditions": [
      "Sharing behavior must persist through method boundaries"
    ],
    "created_at": "2017-01-14T22:46:02Z"
  },
  {
    "id": "https://github.com/ReactiveX/RxJava/issues/4960",
    "source": {
      "issue_number": 4960
    },
    "initial_question": {
      "title": "1.x Documentation issue for .doOnUnsubscribe()",
      "body": "Looking at the javadoc for .doOnUnsubscribe, there's a caveat:\r\n\r\n```\r\nNote that terminal events trigger the action unless the Observable is subscribed to via unsafeSubscribe().\r\n```\r\n\r\nRunning a quick test, this seems wrong:\r\n\r\n```\r\nSubscription subscription = Observable.never()\r\n                .doOnSubscribe(() -> Timber.e(\"Sub\"))\r\n                .doOnUnsubscribe(() -> Timber.e(\"Unsub\"))\r\n                .unsafeSubscribe(new Subscriber<Object>() {\r\n                    @Override\r\n                    public void onCompleted() {}\r\n\r\n                    @Override\r\n                    public void onError(Throwable e) {}\r\n\r\n                    @Override\r\n                    public void onNext(Object o) {}\r\n                });\r\n        subscription.unsubscribe();\r\n```\r\n\r\nprints out:\r\n\r\n```\r\nSub\r\nUnsub\r\n```"
    },
    "satisfaction_conditions": [
      "doOnUnsubscribe() callback executes when unsubscribe() is called",
      "Clear distinction between terminal events and manual unsubscription",
      "Subscription lifecycle events are properly logged"
    ],
    "created_at": "2017-01-05T20:32:20Z"
  },
  {
    "id": "https://github.com/ReactiveX/RxJava/issues/4913",
    "source": {
      "issue_number": 4913
    },
    "initial_question": {
      "title": "2.x: Misbehavior of BehavoirProcessor when converted to Single",
      "body": "io.reactivex.rxjava2:rxandroid:2.0.1\r\n\r\nI believe `BehaviorProcessor` does not work correctly with `Single` observable. I am using `BehaviorProcessor` similarly to how I used `BehaviorSubject` with RxJava1, but this time with a `Single` observable.\r\n\r\nEvent producer\r\n```java\r\nBehaviorProcessor<Event> bp = BehaviorProcessor.create();\r\n\r\npublic Single<Event> getEvent() {\r\n    return bp.singleOrError();\r\n}\r\n\r\nvoid onEventReceived(Event event) {\r\n    bp.onEvent(event);\r\n    bp.onComplete();\r\n}\r\n```\r\n\r\nEvent observer\r\n```java\r\n\r\nproducer.getEvent().subscribeWith(\r\n    new DisposableSingleObserver<Event>() {\r\n        @Override public void onSuccess(Event value) {\r\n            Log.e(TAG, \"success\");\r\n        }\r\n\r\n        @Override public void onError(Throwable e) {\r\n            Log.e(TAG, \"error\");\r\n        }\r\n    }\r\n);\r\n```\r\n\r\nObserved behavior:\r\n1. If observers get subscribed **before** `onEventReceived()` is called, then all observers receive their `onSuccess()` callback, which is OK.\r\n2. If observers get subscribe **after** `onEventReceived()` (meaning after `onEvent()` and `onComplete()` are emitted), then `Single` receives `java.util.NoSuchElementException`. I believe this is NOT OK. Expected behavoir would be receiveing `onSuccess()` with the last value. This is what `BehaviorProcessor` should do for downstream observers, isn't it? Otherwise it appears to be useless for `Single` observers.\r\n\r\nThanks!"
    },
    "satisfaction_conditions": [
      "Single observer must receive exactly one success event",
      "Observable chain must properly terminate"
    ],
    "created_at": "2016-12-09T11:25:11Z"
  },
  {
    "id": "https://github.com/ReactiveX/RxJava/issues/4906",
    "source": {
      "issue_number": 4906
    },
    "initial_question": {
      "title": "The order of `doOnSubscribe` changed in RxJava 2 without documentation",
      "body": "We noticed one of our tests failing because or an ordering issue with `doOnSubscribe`. In RxJava 1 downstream `doOnSubcribe` would be called before upstream but it's the reverse in RxJava 2.\r\n\r\nHere's a code snippet that showcases the problem:\r\n```java\r\nObservable.empty()\r\n\t.doOnSubscribe(() -> System.out.println(\"RX1 upstream\"))\r\n\t.doOnSubscribe(() -> System.out.println(\"RX1 downstream\"))\r\n\t.subscribe();\r\n```\r\nThis will produce the following log statements:\r\n```\r\nRX1 downstream\r\nRX1 upstream\r\n```\r\nwhile the following snippet:\r\n```java\r\nio.reactivex.Observable.empty()\r\n\t.doOnSubscribe(d -> System.out.println(\"RX2 upstream\"))\r\n\t.doOnSubscribe(d -> System.out.println(\"RX2 downstream\"))\r\n\t.subscribe();\r\n```\r\nproduces the following statement:\r\n```\r\nRX2 upstream\r\nRX2 downstream\r\n```\r\n\r\nIs this an intended change?"
    },
    "satisfaction_conditions": [
      "Observable subscription order must be consistent with RxJava version expectations",
      "Counter operations must execute in the correct sequence relative to subscription events",
      "Retry logic must properly handle different error scenarios based on subscription count",
      "Observable chain must maintain expected data flow"
    ],
    "created_at": "2016-12-06T07:10:35Z"
  },
  {
    "id": "https://github.com/ReactiveX/RxJava/issues/4888",
    "source": {
      "issue_number": 4888
    },
    "initial_question": {
      "title": "Should a disposed ConnectableObservable replay() still emit?",
      "body": "I have this test which passes, but I initially expected it (in particular the 2nd `test`) to fail:\r\n\r\n```java\r\n@Test\r\npublic void connectableReplay() throws Exception {\r\n    ConnectableObservable<Integer> just = Observable.just(1).replay();\r\n\r\n    just.test().assertNoValues();\r\n\r\n    Disposable connect = just.connect();\r\n    connect.dispose();\r\n\r\n    just.test()\r\n            .assertValue(1)\r\n            .assertComplete();\r\n}\r\n```\r\n\r\nSo even after a `replay()` ConnectableObservable was disposed it can still emit it's replayed values? Is that the desired behaviour?"
    },
    "satisfaction_conditions": [
      "ConnectableObservable continues to emit cached values after disposal",
      "Disposal affects only upstream connections, not cached data",
      "New subscribers can access historical emissions post-disposal",
      "Complete sequence of cached events is maintained"
    ],
    "created_at": "2016-11-28T10:00:15Z"
  },
  {
    "id": "https://github.com/ReactiveX/RxJava/issues/4869",
    "source": {
      "issue_number": 4869
    },
    "initial_question": {
      "title": "RxJava 1.2.1  retryWhen not working on eclipse\uff0cbut working on Android Studio",
      "body": "The code is as follows:\r\n\r\n```java\r\nstatic int retryCount = 0;\r\n\tprivate static void test5(){\r\n\t\t\r\n\t\tfinal int maxRetries = 3;\r\n\r\n        Observable.create(new Observable.OnSubscribe<Integer>() {\r\n            @Override\r\n            public void call(Subscriber<? super Integer> subscriber) {\r\n                subscriber.onError(new RuntimeException(\"always fails\"));\r\n            }\r\n        })\r\n        .subscribeOn(Schedulers.immediate())\r\n         .retryWhen(new Func1<Observable<? extends Throwable>, Observable<?>>() {\r\n\r\n                    @Override\r\n                    public Observable<?> call(Observable<? extends Throwable> observable) {\r\n                        return observable.flatMap(new Func1<Throwable, Observable<?>>() {\r\n                            @Override\r\n                            public Observable<?> call(Throwable throwable) {\r\n                                if (++retryCount <= maxRetries) {\r\n                                    // When this Observable calls onNext, the original Observable will be retried (i.e. re-subscribed).\r\n                                    System.out.println(\"get error, it will try after \" + 1000 + \" millisecond, retry count \" + retryCount);\r\n                                    return Observable.timer(1000, TimeUnit.MILLISECONDS);\r\n                                }\r\n                                return Observable.error(throwable);\r\n                            }\r\n                        });\r\n                    }\r\n\r\n\r\n                })\r\n                .subscribe(new Subscriber<Integer>() {\r\n\r\n                    @Override\r\n                    public void onCompleted() {\r\n                        System.out.println(\"onCompleted\");\r\n                    }\r\n\r\n                    @Override\r\n                    public void onNext(Integer value) {\r\n                        System.out.println(\"onSuccess value = \" + value);\r\n                    }\r\n\r\n                    @Override\r\n                    public void onError(Throwable error) {\r\n                        System.out.println(\"onError error = \" + error);\r\n                    }\r\n                });\r\n\t\t\r\n\t}\r\n```\r\n\r\n\r\nThank you\uff01"
    },
    "satisfaction_conditions": [
      "Each retry attempt must be observable in the execution output",
      "Final error state must be properly propagated after retries exhaust"
    ],
    "created_at": "2016-11-20T13:17:37Z"
  },
  {
    "id": "https://github.com/ReactiveX/RxJava/issues/4862",
    "source": {
      "issue_number": 4862
    },
    "initial_question": {
      "title": "2.x: RxJavaPlugins.reset() doesn't reset after Schedulers initializaion",
      "body": "I have a query about whether or not the current behavior of`RxJavaPlugins`'s \r\n`setInit<XYZ>SchedulerHandler` hooks are behaving as intended. It seems that it is not possible to revert to the \"out of the box\" `Schedulers` state.\r\n\r\nTake the example of `Scheduler.computation()`. If I set a new default `Scheduler` using `setInitComputationSchedulerHandler` (which, to be applied successfully, must be done prior to accessing the `Schedulers` class), then once set this default cannot be changed; even using `RxJavaPlugins.reset()`.\r\n\r\nTo elaborate, when I override the default `Scheduler` instance, using the aforementioned hook, then the overriding `Function<Callable<Scheduler>>` is assigned to the non-final static field: `RxJavaPlugins.onInitComputationHandler`.\r\n\r\nAs per:\r\n\r\n```java\r\n    public static void setInitComputationSchedulerHandler(Function<Callable<Scheduler>, Scheduler> handler) {\r\n        if (lockdown) {\r\n            throw new IllegalStateException(\"Plugins can't be changed anymore\");\r\n        }\r\n        onInitComputationHandler = handler;\r\n    }\r\n```   \r\n\r\nNow in `Schedulers.java`, the static final field `COMPUTATION` is statically initialized via the result of `RxJavaPlugins.initComputationScheduler()` using the eventual default value of `new ComputationScheduler()` when no override is set. \r\n\r\nIf an override was set via `setInitComputationSchedulerHandler`,then that override is applied, but that result is final, as can be seen below -\r\n\r\n```java\r\nstatic final Scheduler COMPUTATION;\r\n\r\nstatic final class ComputationHolder {\r\n    static final Scheduler DEFAULT = new ComputationScheduler();\r\n}\r\n\r\nstatic {\r\n    COMPUTATION = RxJavaPlugins.initComputationScheduler(new Callable<Scheduler>() {\r\n                @Override\r\n                public Scheduler call() throws Exception {\r\n                    return ComputationHolder.DEFAULT;\r\n                }\r\n            });\r\n    }\r\n``` \r\n\r\nThis means that `COMPUTATION` is permanently assigned to be the override value. When a class accessess `Schedulers.computation()`, they will get the `COMPUTATION` instance by default.\r\n\r\nSee:\r\n\r\n```java\r\n    public static Scheduler computation() {\r\n        return RxJavaPlugins.onComputationScheduler(COMPUTATION);\r\n    }\r\n```\r\n\r\nIf they again call `setInitComputationSchedulerHandler` or `reset()` to clear the `RxJavaPlugins.onInitComputationHandler` field, then regardless, the original `COMPUTATION` value remains.\r\n\r\nNow they *can* call `RxJavaPlugins.setComputationSchedulerHandler()` to change the `Scheduler` that is eventually returned, but my opinion at least, is that it should be possible to revert back to the \"out of the box\" `Schedulers` state. Also being subject to the vagueries of static initialization order timing has the potential to cause debugging headaches for those overriding `Schedulers`.\r\n\r\nWithout suggesting an implementation, I would at least suggest that `RxJavaPlugins.reset()` should at least allow the caller the potential to reassign the default `Scheduler` instance.\r\n\r\nWhat thoughts do you have on the current behavior and my suggested change? "
    },
    "satisfaction_conditions": [
      "Scheduler initialization must prevent unwanted default ExecutorService-based schedulers in restricted environments",
      "Dynamic scheduler overrides must remain functional regardless of initialization state"
    ],
    "created_at": "2016-11-16T17:16:36Z"
  },
  {
    "id": "https://github.com/ReactiveX/RxJava/issues/4861",
    "source": {
      "issue_number": 4861
    },
    "initial_question": {
      "title": "SerializedSubscriber should propagate onStart()",
      "body": "`rx.observers.SerializedSubscriber` should also propagate `onStart()` event to the original subscriber, similar to other `on*()` methods"
    },
    "satisfaction_conditions": [
      "Backpressure request signals must be properly propagated",
      "Multiple initialization calls must be handled safely",
      "Request accumulation must be maintained"
    ],
    "created_at": "2016-11-16T16:00:28Z"
  },
  {
    "id": "https://github.com/ReactiveX/RxJava/issues/4821",
    "source": {
      "issue_number": 4821
    },
    "initial_question": {
      "title": "Question: Observable no longer throwing MissingBackpressureException",
      "body": "Hello, \r\nI understand as with RxJava2.x that Observable is not backpressure aware by default.\r\nI had a piece of code that I was expecting to throw MissingBackpressureException. It did with RxJava1.x\r\n\r\n```\r\nObservable.create(subscriber -> {\r\n            log.info(\"Started emitting\");\r\n\r\n            for (int i = 0; i < 200; i++) {\r\n                log.info(\"Emitting {}\", i);\r\n                subscriber.onNext(i);\r\n            }\r\n\r\n            subscriber.onComplete();\r\n        });\r\nobservable = observable\r\n                .observeOn(Schedulers.io());\r\n        CountDownLatch latch = new CountDownLatch(1);\r\n        observable.subscribe(slowObserver(latch));\r\n        Helpers.wait(latch);\r\n\r\n\r\n    private <T> Observer<T> slowObserver(CountDownLatch latch) {\r\n        return new Observer<T>() {\r\n            @Override\r\n            public void onSubscribe(Disposable d) {\r\n            }\r\n\r\n            @Override\r\n            public void onNext(Object value) {\r\n                log.info(\"Got {}\", value);\r\n                Helpers.sleepMillis(100);\r\n            }\r\n\r\n            @Override\r\n            public void onError(Throwable err) {\r\n                log.error(\"Subscriber got error\", err);\r\n                latch.countDown();\r\n            }\r\n\r\n            @Override\r\n            public void onComplete() {\r\n                log.info(\"Completed\");\r\n                latch.countDown();\r\n            }\r\n        };\r\n    }\r\n```\r\nI see that the buffer size should be Integer.getInteger(\"rx2.buffer-size\", 128) - and it's 128 in my case, however no exception is thrown."
    },
    "satisfaction_conditions": [
      "Observable behavior correctly handles unbounded data streams without throwing MissingBackpressureException",
      "Buffer implementation successfully manages memory without overflow errors",
      "Asynchronous operation between producer and consumer continues uninterrupted",
      "Observable chain completes successfully despite speed differences"
    ],
    "created_at": "2016-11-08T09:57:47Z"
  },
  {
    "id": "https://github.com/ReactiveX/RxJava/issues/4814",
    "source": {
      "issue_number": 4814
    },
    "initial_question": {
      "title": "java.io.InterruptedIOException: thread interrupted ",
      "body": "when i use retrofit and rxjava download file with progress.\r\n``` java\r\n11-03 22:52:35.048 18649-18699/better.hello W/System.err: java.io.InterruptedIOException: thread interrupted\r\n11-03 22:52:35.049 18649-18699/better.hello W/System.err:     at okio.Timeout.throwIfReached(Timeout.java:145)\r\n11-03 22:52:35.049 18649-18699/better.hello W/System.err:     at okio.Okio$2.read(Okio.java:137)\r\n11-03 22:52:35.049 18649-18699/better.hello W/System.err:     at okio.AsyncTimeout$2.read(AsyncTimeout.java:238)\r\n11-03 22:52:35.049 18649-18699/better.hello W/System.err:     at okio.RealBufferedSource.read(RealBufferedSource.java:45)\r\n11-03 22:52:35.049 18649-18699/better.hello W/System.err:     at okhttp3.internal.http.Http1xStream$FixedLengthSource.read(Http1xStream.java:381)\r\n11-03 22:52:35.049 18649-18699/better.hello W/System.err:     at okio.RealBufferedSource.read(RealBufferedSource.java:45)\r\n11-03 22:52:35.049 18649-18699/better.hello W/System.err:     at okio.ForwardingSource.read(ForwardingSource.java:35)\r\n11-03 22:52:35.049 18649-18699/better.hello W/System.err:     at retrofit2.OkHttpCall$ExceptionCatchingRequestBody$1.read(OkHttpCall.java:279)\r\n11-03 22:52:35.049 18649-18699/better.hello W/System.err:     at okio.RealBufferedSource$1.read(RealBufferedSource.java:386)\r\n11-03 22:52:35.049 18649-18699/better.hello W/System.err:     at java.io.InputStream.read(InputStream.java:162)\r\n11-03 22:52:35.049 18649-18699/better.hello W/System.err:     at better.hello.util.FileUtils.writeFile(FileUtils.java:120)\r\n11-03 22:52:35.049 18649-18699/better.hello W/System.err:     at better.hello.common.UiHelper$1$1.call(UiHelper.java:29)\r\n11-03 22:52:35.049 18649-18699/better.hello W/System.err:     at better.hello.common.UiHelper$1$1.call(UiHelper.java:26)\r\n11-03 22:52:35.049 18649-18699/better.hello W/System.err:     at rx.Observable.unsafeSubscribe(Observable.java:10200)\r\n11-03 22:52:35.049 18649-18699/better.hello W/System.err:     at rx.internal.operators.OperatorMerge$MergeSubscriber.onNext(OperatorMerge.java:248)\r\n11-03 22:52:35.049 18649-18699/better.hello W/System.err:     at rx.internal.operators.OperatorMerge$MergeSubscriber.onNext(OperatorMerge.java:148)\r\n11-03 22:52:35.049 18649-18699/better.hello W/System.err:     at rx.internal.operators.OnSubscribeMap$MapSubscriber.onNext(OnSubscribeMap.java:77)\r\n11-03 22:52:35.049 18649-18699/better.hello W/System.err:     at rx.internal.operators.OperatorSubscribeOn$1$1.onNext(OperatorSubscribeOn.java:53)\r\n11-03 22:52:35.049 18649-18699/better.hello W/System.err:     at retrofit2.adapter.rxjava.OperatorMapResponseToBodyOrError$1.onNext(OperatorMapResponseToBodyOrError.java:41)\r\n11-03 22:52:35.049 18649-18699/better.hello W/System.err:     at retrofit2.adapter.rxjava.OperatorMapResponseToBodyOrError$1.onNext(OperatorMapResponseToBodyOrError.java:38)\r\n11-03 22:52:35.049 18649-18699/better.hello W/System.err:     at retrofit2.adapter.rxjava.RxJavaCallAdapterFactory$RequestArbiter.request(RxJavaCallAdapterFactory.java:173)\r\n11-03 22:52:35.050 18649-18699/better.hello W/System.err:     at rx.internal.operators.OperatorSubscribeOn$1$1$1.request(OperatorSubscribeOn.java:80)\r\n11-03 22:52:35.050 18649-18699/better.hello W/System.err:     at rx.Subscriber.setProducer(Subscriber.java:211)\r\n11-03 22:52:35.050 18649-18699/better.hello W/System.err:     at rx.internal.operators.OnSubscribeMap$MapSubscriber.setProducer(OnSubscribeMap.java:102)\r\n11-03 22:52:35.050 18649-18699/better.hello W/System.err:     at rx.internal.operators.OperatorSubscribeOn$1$1.setProducer(OperatorSubscribeOn.java:76)\r\n11-03 22:52:35.050 18649-18699/better.hello W/System.err:     at rx.Subscriber.setProducer(Subscriber.java:205)\r\n11-03 22:52:35.050 18649-18699/better.hello W/System.err:     at retrofit2.adapter.rxjava.RxJavaCallAdapterFactory$CallOnSubscribe.call(RxJavaCallAdapterFactory.java:152)\r\n11-03 22:52:35.050 18649-18699/better.hello W/System.err:     at retrofit2.adapter.rxjava.RxJavaCallAdapterFactory$CallOnSubscribe.call(RxJavaCallAdapterFactory.java:138)\r\n11-03 22:52:35.050 18649-18699/better.hello W/System.err:     at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:48)\r\n11-03 22:52:35.050 18649-18699/better.hello W/System.err:     at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:30)\r\n11-03 22:52:35.050 18649-18699/better.hello W/System.err:     at rx.Observable.unsafeSubscribe(Observable.java:10200)\r\n11-03 22:52:35.050 18649-18699/better.hello W/System.err:     at rx.internal.operators.OperatorSubscribeOn$1.call(OperatorSubscribeOn.java:94)\r\n11-03 22:52:35.050 18649-18699/better.hello W/System.err:     at rx.internal.schedulers.CachedThreadScheduler$EventLoopWorker$1.call(CachedThreadScheduler.java:228)\r\n11-03 22:52:35.050 18649-18699/better.hello W/System.err:     at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:55)\r\n11-03 22:52:35.050 18649-18699/better.hello W/System.err:     at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:422)\r\n11-03 22:52:35.050 18649-18699/better.hello W/System.err:     at java.util.concurrent.FutureTask.run(FutureTask.java:237)\r\n11-03 22:52:35.050 18649-18699/better.hello W/System.err:     at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:152)\r\n11-03 22:52:35.050 18649-18699/better.hello W/System.err:     at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:265)\r\n11-03 22:52:35.050 18649-18699/better.hello W/System.err:     at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1112)\r\n11-03 22:52:35.050 18649-18699/better.hello W/System.err:     at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:587)\r\n11-03 22:52:35.050 18649-18699/better.hello W/System.err:     at java.lang.Thread.run(Thread.java:818)\r\n```\r\nthere is my snippet:\r\n``` java\r\nHttpUtil.downFile(mp4_url).subscribeOn(Schedulers.io()).flatMap(new Func1<ResponseBody, Observable<DownloadInfo>>() {\r\n            @Override\r\n            public Observable<DownloadInfo> call(final ResponseBody body) {\r\n                return Observable.create(new Observable.OnSubscribe<DownloadInfo>() {\r\n                    @Override\r\n                    public void call(Subscriber<? super DownloadInfo> subscriber) {\r\n                        FileUtils.writeFile(subscriber, body, fileName);\r\n                    }\r\n                });\r\n            }\r\n        }).unsubscribeOn(Schedulers.io()).observeOn(AndroidSchedulers.mainThread()).subscribe(new Subscriber<DownloadInfo>() {\r\n            @Override\r\n            public void onCompleted() {\r\n                \r\n            }\r\n\r\n            @Override\r\n            public void onError(Throwable e) {\r\n\r\n            }\r\n\r\n            @Override\r\n            public void onNext(DownloadInfo info) {\r\n\r\n            }\r\n        });\r\n```\r\n``` java\r\npublic static void writeFile(Subscriber<? super DownloadInfo> subscriber, ResponseBody body, String fileName) {\r\n        try {\r\n            File file = getFile(fileName);\r\n            long readSize = 0, length = body.contentLength();\r\n            byte buffer[] = new byte[4096];\r\n            FileOutputStream outputStream = new FileOutputStream(file, true);\r\n            InputStream ins = body.byteStream();\r\n            DownloadInfo info = new DownloadInfo(length);\r\n            while (true) {\r\n                int read = ins.read(buffer);\r\n                if (read <= 0) {\r\n                    subscriber.onCompleted();\r\n                    break;\r\n                }\r\n                outputStream.write(buffer, 0, read);\r\n                readSize += read;\r\n                info.setReadFileSize(readSize);\r\n                info.setProgress(readSize / length);\r\n                subscriber.onNext(info);\r\n                Utils.d(\"Better\", \"\u4e0b\u8f7d\u4e86==\" + readSize + \",total=\" + length);\r\n            }\r\n            if (null != outputStream) {\r\n                outputStream.flush();\r\n                outputStream.close();\r\n            }\r\n            if (null != ins) {\r\n                ins.close();\r\n            }\r\n            if (null!=body){\r\n                body.close();\r\n            }\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n            subscriber.onError(e);\r\n        }\r\n    }\r\n```\r\nif i do not call subscriber.onNext(info) in the while circle  ,everything will be ok ,and the file will be download correctly.The place where the error can occur is subscribe.onNext().I just do not known why.\r\nsomeone can help me ?"
    },
    "satisfaction_conditions": [
      "Network operations and progress updates execute on appropriate threads",
      "Resources are properly closed after download completion or failure"
    ],
    "created_at": "2016-11-06T14:15:01Z"
  },
  {
    "id": "https://github.com/ReactiveX/RxJava/issues/4806",
    "source": {
      "issue_number": 4806
    },
    "initial_question": {
      "title": "Can I force zip opertaer work on AndroidSchedulers.mainThread()",
      "body": "zip combine varlues on the Scheduler which last Observable worked on.\r\nI want zip operate work on AndroidSchedulers.mainThread() or anyone of the Observable Schedulers.\r\n\r\nHow could I do?"
    },
    "satisfaction_conditions": [
      "Operations execute on the main Android thread",
      "Zip operation successfully combines values from multiple Observables",
      "Thread scheduling can be controlled for the zip operation",
      "Observable chain maintains proper data flow"
    ],
    "created_at": "2016-11-04T08:47:24Z"
  },
  {
    "id": "https://github.com/ReactiveX/RxJava/issues/4802",
    "source": {
      "issue_number": 4802
    },
    "initial_question": {
      "title": "Observable depends on other Observable | Needing both values",
      "body": "I have an Observable whose emitted item I need for the next Observable but I can't use flatMap() because the method I need to call in the Subscriber needs the result of both Observables.\r\n\r\n```java\r\nservice.getToken(code)\r\n          .subscribe(new Action1<Token>() {\r\n                        @Override\r\n                        public void call(Token token) {\r\n                            service.getProfile(token.getAccessToken())\r\n                                    .subscribe(\r\n                                    new Action1<Profile>() {\r\n                                        @Override\r\n                                        public void call(Profile profile) {\r\n                                            createAccount(token, profile);\r\n                                        }\r\n                                    });\r\n                        }\r\n                    });\r\n```\r\n\r\nAny better approach then this?"
    },
    "satisfaction_conditions": [
      "Both Token and Profile data must be available for the createAccount method call",
      "Token must be obtained before Profile can be requested",
      "Error handling must be possible for both operations",
      "Code must maintain proper reactive stream principles",
      "Solution must avoid nested subscription patterns"
    ],
    "created_at": "2016-11-03T20:39:01Z"
  },
  {
    "id": "https://github.com/ReactiveX/RxJava/issues/4788",
    "source": {
      "issue_number": 4788
    },
    "initial_question": {
      "title": "RxJava 2.x Single is not extending Publisher",
      "body": "Hi, I think Single should implement also org.reactivestreams.Publisher like Flowable.\r\nRight now in io.reactivex.rxjava2 2.0.0 Single doesn't implement Publisher and this leads to being unable to do the following:\r\n\r\n```\r\nFlowable<String> colors = Flowable.fromArray(\"red\", \"green\", \"blue\",\r\n                \"red\", \"yellow\", \"green\", \"green\");\r\n\r\n        Flowable<GroupedFlowable<String, String>> groupedColorsStream = colors\r\n                                                                           .groupBy(val -> val);\r\n\r\n        Flowable<Pair<String, Long>>\r\n                countedColors = groupedColorsStream\r\n                                        .flatMap(groupedFlow -> groupedFlow\r\n                                                                    .count()\r\n                                                                    .map(countVal -> new Pair<>(groupedFlow.getKey(), countVal))\r\n                                        );\r\n        countedColors.subscribe(System.out::println);\r\n\r\n```\r\n\r\nsince count() returns Single<Long>, and flatMap has the signature:\r\n```\r\n    public final <R> Flowable<R> flatMap(Function<? super T, ? extends Publisher<? extends R>> mapper) {\r\n        return this.flatMap(mapper, false, bufferSize(), bufferSize());\r\n    }\r\n```"
    },
    "satisfaction_conditions": [
      "Type compatibility between Single and Flowable operations must be maintained",
      "Data flow from Single to Flowable must be preserved"
    ],
    "created_at": "2016-10-31T12:26:51Z"
  },
  {
    "id": "https://github.com/ReactiveX/RxJava/issues/4781",
    "source": {
      "issue_number": 4781
    },
    "initial_question": {
      "title": "2.x - the code below Subscription.request(long) in onSubscribe() would't be executed until a flowable were completed",
      "body": "When a flowable works on the main thread, `request(long)` in `onSubscribe(Subscription)` always calls `onNext(T)` and then `onComplete()`.\nTherefore, the code below `request(long)` in `onSubscribe(Subscription)` would be executed after `onNext(T)` and `onComplete()`.\n\n```\nFlowable.just(1, 2, 3).subscribe(new Subscriber<Integer>() {\n\n  @Override\n  public void onSubscribe(Subscription s) {\n    s.request(Long.MAX_VALUE);\n    System.out.println(\"onSubscribe done\");\n  }\n\n  @Override\n  public void onNext(Integer t) {\n    System.out.println(t);\n  }\n  ...\n}\n```\n\nThe result is always like this.\n\n```\n1\n2\n3\nonComplete called\nonSubscribe done\n```\n\nI can avoid this by calling `request(long)` at the end of `onSubscribe()`.\nHowever, this behavior is different from RxJava 1.x.\n\nAlso, there is a problem to override ResourceSubscriber's onStrat().\nSince `request(long)` acts this way, if I want to do something in `onStart()`, I have to put `super.onStart()` on the bottom of `onStart()`.\n\n```\n@Override\nprotected void onStart() {\n  initialize();\n  super.onStart();\n}\n```\n\nIf I write below, `intitalize()` would be called after `onComplete()`.\n\n```\n@Override\nprotected void onStart() {\n  super.onStart();\n  initialize();\n}\n```\n\nI think that this is a problem since developers always have to care about where they writie a request method.\n"
    },
    "satisfaction_conditions": [
      "Thread-safety must be maintained for post-request operations",
      "Subscriber setup sequence must be predictable and controllable",
      "Resource initialization must complete before data processing"
    ],
    "created_at": "2016-10-30T03:51:19Z"
  },
  {
    "id": "https://github.com/ReactiveX/RxJava/issues/4778",
    "source": {
      "issue_number": 4778
    },
    "initial_question": {
      "title": "Error handling when operate observable",
      "body": " when i do operator like Map to observable  ,then  function throws exception ,is there a way to let  the subscriber 's onError know error emit?\n"
    },
    "satisfaction_conditions": [
      "Exception must be propagated to subscriber's onError handler",
      "Checked exceptions must be properly handled to ensure Observable chain continues error propagation",
      "Error information must be preserved through the transformation"
    ],
    "created_at": "2016-10-28T08:44:29Z"
  },
  {
    "id": "https://github.com/ReactiveX/RxJava/issues/4748",
    "source": {
      "issue_number": 4748
    },
    "initial_question": {
      "title": "[2.x] sequenceEqual should return a Single, not an Observable?",
      "body": "sequenceEqual should always emit a single boolean, so should its return value be a Single?\n"
    },
    "satisfaction_conditions": [
      "sequenceEqual operator returns Single type",
      "Consistent return type across all sequenceEqual implementations"
    ],
    "created_at": "2016-10-21T20:05:12Z"
  },
  {
    "id": "https://github.com/ReactiveX/RxJava/issues/4704",
    "source": {
      "issue_number": 4704
    },
    "initial_question": {
      "title": "2.x: Observable.interval() - why doesn't it have backpressure (Flowable) now (after 1.x)?",
      "body": "I used to use `Observable.interval()` with `Observable.zip()` and deal with `backpressure`. Now then `backpressure` is implemented via `Flowable`, `Observable.interval()` still returns `Observable`, not `Flowable`. \nHow can it be `Observable` when it is a hot source?\n"
    },
    "satisfaction_conditions": [
      "Correct understanding of Observable.interval() behavior in RxJava 2.x",
      "Clear distinction between Observable and Flowable behavior",
      "Accurate explanation of Observable.zip() buffering behavior",
      "Correct comparison with RxJava 1.x behavior",
      "Clear explanation of slow consumer impact"
    ],
    "created_at": "2016-10-14T06:38:02Z"
  },
  {
    "id": "https://github.com/ReactiveX/RxJava/issues/4703",
    "source": {
      "issue_number": 4703
    },
    "initial_question": {
      "title": "Subject should throw exception when calling onNext after onComplete",
      "body": "```\nPublishSubject publishSubject = PublishSubject.create();\npublishSubject.onCompleted();\npublishSubject.onNext(new Object());\n```\n\nIn 1.x you can call onNext after onCompleted and no exception will be thrown. \nI think it should throw an exception, but maybe it isn't possible to reliably assert that the observable hasn't completed before calling onNext when dealing with different threads. \n"
    },
    "satisfaction_conditions": [
      "Thread safety guarantees must be explicitly handled",
      "Observable contract compliance must be maintained",
      "Behavior must be consistent with RxJava's error handling approach",
      "Clear mechanism for handling post-completion events"
    ],
    "created_at": "2016-10-13T22:11:05Z"
  },
  {
    "id": "https://github.com/ReactiveX/RxJava/issues/4700",
    "source": {
      "issue_number": 4700
    },
    "initial_question": {
      "title": "Observable.using async resource factory?",
      "body": "Hello,\n\ni have a use case where i will use a resource that need to be released after usage, so i thought the `Observable.using` fit in these case, but i obtain the resource from a `Observable` that could do a network call if it's not available local.\n\nThe resource is a session identifier with expiration time, so when it's not expired i have it local and it's fast, otherwise i do a network call, but the problem is, the `Observable.using` resourceFactory (first param), is a `Func0`, and i don't want to block inside it with `toBlocking.single`, how could i use it? Is there any alternative?\n\nHere is an example code, i wan't to remove the blocking part\n\n``` java\nreturn Observable.using(\n      // create resource\n      () -> getSession().toBlocking().single(), // i don't want to do that!\n      // use it\n      session -> doWork(session), // returns a observable\n      // release\n      session -> // release session,\n      true)\n```\n"
    },
    "satisfaction_conditions": [
      "Resource acquisition must be non-blocking",
      "Resource must be properly released after usage",
      "Solution must handle both local and remote session retrieval",
      "Observable chain must maintain asynchronous behavior",
      "Session must be available for the work operation"
    ],
    "created_at": "2016-10-13T08:17:29Z"
  },
  {
    "id": "https://github.com/ReactiveX/RxJava/issues/4673",
    "source": {
      "issue_number": 4673
    },
    "initial_question": {
      "title": "Subscriber receives value after the unsubscription",
      "body": "I have the following issue\n\n```\n@Test public void testUnsubscribe() throws InterruptedException {\n    PublishSubject<Boolean> mBooleanPublishSubject = PublishSubject.create();\n    Subscription subscription = mBooleanPublishSubject\n            .doOnNext(value -> System.out.println(\"Sending value \" + value))\n            .onBackpressureBuffer()\n            .observeOn(Schedulers.computation())\n            .map(v -> {\n                long sum = 0;\n                for (int i = 0; i < 10000000; i++) {\n                    sum += i;\n                }\n                return sum > 0;\n            })\n            .doOnNext(__ -> System.out.println(\"Before subscribe\"))\n            .subscribe(value -> System.out.println(\"Value received \" + value));\n\n    mBooleanPublishSubject.onNext(true);\n    mBooleanPublishSubject.onNext(true);\n    Thread.sleep(10);\n    System.out.println(\"Unsubscribing\");\n    subscription.unsubscribe();\n    System.out.println(\"Unsubscribed\");\n    Thread.sleep(1000);\n}\n```\n\nOutput\n\n```\nSending value true\nSending value true\nUnsubscribing\nUnsubscribed\nBefore subscribe\nValue received true\n```\n\nIs that expected behaviour?\n"
    },
    "satisfaction_conditions": [
      "Long-running operations must respect unsubscription state",
      "Unsubscription state must be verifiable at any point in the observable chain",
      "Solution must work with asynchronous operations"
    ],
    "created_at": "2016-10-06T07:56:21Z"
  },
  {
    "id": "https://github.com/ReactiveX/RxJava/issues/4670",
    "source": {
      "issue_number": 4670
    },
    "initial_question": {
      "title": "Regarding delayed emissions",
      "body": "In my code bbaPi.getProductsNextPage makes an http call and returns an observable. I generate a range of page numbers and pass this to the api call. I want to make this call after every n seconds but currently, when I use the zip operator, the call is sent for all the page numbers and then the emission of the call is delayed by 2 minutes. How can I delay this call by n seconds?\n\n```\n@Override\n    public Observable<List<Product>> getBbProducts(String category, String city) {\n        return bbApi.getProductsList(category, readCookie(objectMapper))\n                .map(response -> BbMapper.mapResponse(ProductPage.class, objectMapper, response))\n                .onBackpressureBuffer()\n                .filter(productPage -> productPage != null)\n                .flatMap(productPage -> {\n                    int totalPages = productPage.getResponse().getTab_info().get(0).getProduct_info().getTot_pages();\n                    int totalProducts = productPage.getResponse().getTab_info().get(0).getProduct_info().getP_count();\n\n                    return Observable.range(1, totalPages)\n                            .onBackpressureBuffer()\n                            .flatMap(new Func1<Integer, Observable<List<Product>>>() {\n                                         @Override\n                                         public Observable<List<Product>> call(Integer integer) {\n                                             long startTime = System.currentTimeMillis();\n                                             return Observable.zip(\n                                                     Observable.interval(1, TimeUnit.SECONDS)\n                                                             .onBackpressureDrop(),\n// This. I want to delay it by n seconds.\n                                                     bbApi.getProductsNextPage(category, readCookie(objectMapper), integer)\n                                                             .onBackpressureBuffer()\n                                                             .flatMap(new Func1<Response, Observable<List<Product>>>() {\n                                                                 @Override\n                                                                 public Observable<List<Product>> call(Response response) {\n                                                                     long endTime = System.currentTimeMillis();\n                                                                     System.out.println(\"Time taken: \" + (endTime - startTime) + \"Page: \" + integer);\n                                                                     return Observable\n                                                                             .from(BbMapper.mapToProductList(objectMapper, response))\n                                                                             .map(all -> BbMapper.mapToProduct(all, city))\n                                                                             .toList()\n                                                                             .subscribeOn(Schedulers.computation());\n                                                                 }\n                                                             })\n                                                             .onBackpressureBuffer()\n                                                     ,\n                                                     (aLong, products) -> products);\n                                         }\n                                     }\n                            )\n                            .onBackpressureDrop()\n                            .flatMap(new Func1<List<Product>, Observable<List<Product>>>() {\n                                @Override\n                                public Observable<List<Product>> call(List<Product> products) {\n                                    return Observable.just(products);\n                                }\n                            });\n                });\n    }\n```\n"
    },
    "satisfaction_conditions": [
      "API calls must be spaced by n seconds between each page request",
      "All pages must be retrieved sequentially without data loss",
      "Backpressure must be handled appropriately",
      "Rate limiting must allow controlling items per emission",
      "Sequential processing of emissions must be supported"
    ],
    "created_at": "2016-10-05T11:53:45Z"
  },
  {
    "id": "https://github.com/ReactiveX/RxJava/issues/4664",
    "source": {
      "issue_number": 4664
    },
    "initial_question": {
      "title": "2x RxJavaPlugins - 1.x RxJavaHooks using TestScheduler::advanceTimeBy",
      "body": "I have a question regarding the usage of `TestScheduler` and hooks.\n\nThe next text passes using 1.x version:\n\n``` java\n  @Test public void Verify_Test_Scheduler_Rx1() {\n    rx.schedulers.TestScheduler scheduler = new rx.schedulers.TestScheduler();\n    RxJavaHooks.setOnComputationScheduler(current -> scheduler);\n\n    AtomicInteger flag = new AtomicInteger();\n\n    rx.Observable.just(1)\n        .doOnNext(ignored -> flag.getAndIncrement())\n        .delay(3, TimeUnit.SECONDS)\n        .doOnNext(ignored -> flag.getAndIncrement())\n        .subscribe();\n\n    scheduler.advanceTimeBy(4, TimeUnit.SECONDS);\n\n    assertThat(flag.get(), is(2));\n\n    RxJavaHooks.reset();\n  } \n```\n\n But this one fails, being the flag value 1, instead of 2:\n\n``` java\n@Test public void Verify_Test_Scheduler_Rx2() {\n    TestScheduler scheduler = new TestScheduler();\n    RxJavaPlugins.onComputationScheduler(scheduler);\n\n    AtomicInteger flag = new AtomicInteger();\n\n    Observable.just(1)\n        .doOnNext(ignored -> flag.getAndIncrement())\n        .delay(3, TimeUnit.SECONDS)\n        .doOnNext(ignored -> flag.getAndIncrement())\n        .subscribe();\n\n    scheduler.advanceTimeBy(4, TimeUnit.SECONDS);\n\n    assertThat(flag.get(), is(2));\n\n    RxJavaPlugins.reset();\n  }\n```\n\n  What is the correct usage of `TestScheduler` with `RxJavaPlugins` in 2.x to achieve the same effect that the one recreated in 1.x? \n\n  Thanks. \n"
    },
    "satisfaction_conditions": [
      "Test scheduler must control time-based operations",
      "All scheduled operations must execute in the expected sequence",
      "Scheduler configuration must persist throughout the test",
      "Scheduler state must be resettable",
      "Scheduler must integrate with RxJava 2.x plugin system"
    ],
    "created_at": "2016-10-03T23:53:21Z"
  },
  {
    "id": "https://github.com/ReactiveX/RxJava/issues/4657",
    "source": {
      "issue_number": 4657
    },
    "initial_question": {
      "title": "Subscriber unsubscribe doubt",
      "body": "Hello!\n\nI'm with a doubt about the unsubscribe process and memory related stuff, today i faced a simple case that made me wonder, the case is, i have a web Event Stream that i'll send some information when receive a request, but this information is sent with an interval, suppose each 500 milliseconds, and when the request ends, i want to clear all the resources allocated so i don't get a memory leak, the simplified code looks like this:\n\n``` java\nfinal Subscription metricsSubscription = Observable.interval(delay, TimeUnit.MILLISECONDS, scheduler)\n                                                   .map(i -> new DashboardData(HystrixCommandMetrics.getInstances(),\n                                                                               HystrixThreadPoolMetrics.getInstances(),\n                                                                               HystrixCollapserMetrics.getInstances()))\n                                                   .concatMap(dashboardData -> Observable.from(SerialHystrixDashboardData.toMultipleJsonStrings(dashboardData)))\n                                                   .subscribe(metric -> writeMetric(metric, response),\n                                                              ex -> log.error(\"Error sending metrics\", ex));\n```\n\nPretty simple, when the request ends, the client disconnect, i call:\n\n``` java\nmetricsSubscription.unsubscribe();\n```\n\nWhat happens to the interval observable? It'll stop emitting events, but it'll be garbage collected? \n"
    },
    "satisfaction_conditions": [
      "Resources are properly released when unsubscribe is called",
      "Observable stops emitting events after unsubscription",
      "Minimal performance overhead for memory management",
      "Subscription cleanup works reliably on client disconnect"
    ],
    "created_at": "2016-10-02T03:19:13Z"
  },
  {
    "id": "https://github.com/ReactiveX/RxJava/issues/4588",
    "source": {
      "issue_number": 4588
    },
    "initial_question": {
      "title": "2.x: Convert Observable to Single without a default value",
      "body": "With the RC3 changes I don't see an easy way of converting an Observable into a Single without giving a default value.\n\nHow do you feel about adding methods for that?\n"
    },
    "satisfaction_conditions": [
      "Observable must be convertible to Single without requiring a default value",
      "Empty Observable conversion must result in an error rather than a default value",
      "Multiple elements in Observable must be handled appropriately",
      "Error handling must be consistent with RxJava error patterns",
      "API must maintain backward compatibility with existing RxJava patterns"
    ],
    "created_at": "2016-09-23T08:23:13Z"
  },
  {
    "id": "https://github.com/ReactiveX/RxJava/issues/4571",
    "source": {
      "issue_number": 4571
    },
    "initial_question": {
      "title": "Replay + Scan with initial value emits too many values",
      "body": "The following test behaves as expected, emitting a single value to the subscriber:\n\n```\n    @Test\n    public void testExpectedReplayBehavior() {\n        final TestScheduler scheduler = new TestScheduler();\n        final TestSubject<Integer> subject = TestSubject.create(scheduler);\n        final TestSubscriber<Integer> subscriber = new TestSubscriber<>();\n\n        final ConnectableObservable<Integer> sums = subject.scan((a, b) -> a + b).replay(1);\n        sums.connect();\n\n        subject.onNext(1);\n        subject.onNext(2);\n        subject.onNext(3);\n        scheduler.triggerActions();\n\n        sums.subscribe(subscriber);\n\n        subscriber.assertValueCount(1);\n        subscriber.assertValues(6);\n    }\n```\n\nHowever, the second test fails, emitting all of the events from the source subject, rather than replaying the 1 event I requested with `replay(1)`:\n\n```\n    @Test\n    public void testFlakyReplayBehavior() {\n        final TestScheduler scheduler = new TestScheduler();\n        final TestSubject<Integer> subject = TestSubject.create(scheduler);\n        final TestSubscriber<Integer> subscriber = new TestSubscriber<>();\n\n        final ConnectableObservable<Integer> sums = subject.scan(1, (a, b) -> a + b).replay(1);\n        sums.connect();\n\n        subject.onNext(2);\n        subject.onNext(3);\n        scheduler.triggerActions();\n\n        sums.subscribe(subscriber);\n\n        subscriber.assertValueCount(1);\n        subscriber.assertValues(6);\n    }\n```\n\nAm I missing something nonintuitive about either `scan` or `replay`'s behavior that would reconcile these differences? I don't understand why supplying an initial argument for the accumulator would cause a drastic difference in behavior here.\n"
    },
    "satisfaction_conditions": [
      "Final accumulated value is correctly computed and emitted"
    ],
    "created_at": "2016-09-20T20:30:27Z"
  },
  {
    "id": "https://github.com/ReactiveX/RxJava/issues/4559",
    "source": {
      "issue_number": 4559
    },
    "initial_question": {
      "title": "2.x: Single.timeout with Callable<SingleSource<? extends T> other>>",
      "body": "Basically I'd like to have a lazy timeout so that I only need to construct the other Single source once the original Single source 'timeouts'\n"
    },
    "satisfaction_conditions": [
      "Secondary source creation is deferred until timeout occurs"
    ],
    "created_at": "2016-09-15T08:36:57Z"
  },
  {
    "id": "https://github.com/ReactiveX/RxJava/issues/4547",
    "source": {
      "issue_number": 4547
    },
    "initial_question": {
      "title": "replay does not cache if subscribed to using toBlocking().toFuture().get()",
      "body": "Given the following snippet:\n\n```\n    BehaviorSubject<Observable<Integer>> s = BehaviorSubject.create(Observable.just(1));\n\n    Observable<Integer> o = s.flatMap(sp -> sp).replay(1).autoConnect();\n\n    //o.subscribe();\n\n    System.out.println(\"1st = \" + o.first().toBlocking().toFuture().get(0, TimeUnit.SECONDS));\n\n    s.onNext(Observable.just(2));\n\n    System.out.println(\"2st = \" + o.first().toBlocking().toFuture().get(0, TimeUnit.SECONDS));\n```\n\nI expect output: \n\n```\n1st = 1\n2nd = 2 \n```\n\ninstead I get \n\n```\n1st = 1 \n2nd = 1\n```\n\nIf I uncomment o.subscribe(), then the replay value gets updated correctly on 2nd.  Also it works correctly if not using the flatMap().  \n"
    },
    "satisfaction_conditions": [
      "Subscription method must allow complete value propagation",
      "Observable termination must be predictable"
    ],
    "created_at": "2016-09-13T23:20:07Z"
  },
  {
    "id": "https://github.com/ReactiveX/RxJava/issues/4489",
    "source": {
      "issue_number": 4489
    },
    "initial_question": {
      "title": "2.x: SerializedEmitter not implementing Disposable",
      "body": "While looking at the different `Observable`/`Single`/`Completable` Emitters I noticed that the ObservableCreate `SerializedEmitter` is the only one not implementing `Disposable` and thus `#dispose`.\n\nIs this intended?\n"
    },
    "satisfaction_conditions": [
      "SerializedEmitter's lack of Disposable implementation is confirmed as intentional design",
      "Usage pattern for SerializedEmitter is clearly defined"
    ],
    "created_at": "2016-09-06T17:47:50Z"
  },
  {
    "id": "https://github.com/ReactiveX/RxJava/issues/4477",
    "source": {
      "issue_number": 4477
    },
    "initial_question": {
      "title": "2.x TestObserver and TestSubscriber for unit testing",
      "body": "In 1.x I was using `TestSubscriber` to perform assertions in unit tests. But it seems that in 2.x is `TestObserver` the class that we need to use for this matter. Is that correct? And if that's correct, when I should use `TestSubscriber`?\n\nThanks. \n"
    },
    "satisfaction_conditions": [
      "Correct test class is used based on the reactive type being tested",
      "Test assertions can be performed on reactive streams",
      "Compatibility with RxJava 2.x syntax and types",
      "Support for testing all reactive type variations"
    ],
    "created_at": "2016-09-05T15:24:36Z"
  },
  {
    "id": "https://github.com/ReactiveX/RxJava/issues/4473",
    "source": {
      "issue_number": 4473
    },
    "initial_question": {
      "title": "1.x: SingleDoAfterTerminateSubscriber swallowing exception",
      "body": "Isn't `SingleDoAfterTerminateSubscriber` swallowing an exception?\n\ne.g. when action that get's invoked throws an excpetion for instance NullPointerException It'll be just rethrown but not delivered through onError\n\nAlso could not `SingleDoOnEvent` be reused for this behavior of invoking an action when Single has completed or errored? \n"
    },
    "satisfaction_conditions": [
      "Exceptions from afterTerminate actions must be handled appropriately",
      "Maintain proper execution order of termination events",
      "Clear distinction between termination and normal event handling"
    ],
    "created_at": "2016-09-05T12:35:46Z"
  },
  {
    "id": "https://github.com/ReactiveX/RxJava/issues/4440",
    "source": {
      "issue_number": 4440
    },
    "initial_question": {
      "title": "Observable invoked twice on single subscription",
      "body": "Hi,\nI have a simple use case where f1,  f2 and f3 are observable network calls with the dependency order: f2 -> f1 (f2 depends on f1 )and f3 -> f1 (f3 depends on f1). \nWhen I zip f2 and f3 to produce a combined result, f1 is getting called twice but I want it invoked only once otherwise it defeats the purpose. Could you please advise? I am sure I have the wiring wrong but couldn't figure out where and I tried all options on f1 : cache, share, replay \n\nCode:\n\n``` java\npublic static void main(String[] args) {\n    String id = \"abc\";\n    Observable.zip(T2dependency(id ), T3dependency(id ), \n        new Func2<JsonObject, JsonObject, JsonObject>() {\n\n    @Override\n    public JsonObject call(JsonObject t2Response, JsonObject t3Response) {\n\n     // operations on t2 & t3\n\n        return t2Response;\n    }\n\n    })\n    .subscribe(next -> System.out.println(\"final subscribe o/p: \" + new Gson().toJson(next)),\n        error -> error.printStackTrace());\n}\n\n\nprotected Observable<JsonObject> T2dependency(String id) {\n\n    return getT1info(id)\n    .<JsonObject>flatMap(new Func1<JsonObject, Observable<JsonObject>>() {\n\n        @Override\n        public Observable<JsonObject> call(JsonObject t1Response) {\n            System.out.println(\"T2.t1Response\");\n            return Observable.just(t1Response);\n        }\n    });\n}\n\nprotected Observable<JsonObject> T3dependency(String id) {\n\n    return getT1info(id)\n    .<JsonObject>flatMap(new Func1<JsonObject, Observable<JsonObject>>() {\n\n        @Override\n        public Observable<JsonObject> call(JsonObject t1Response) {\n            System.out.println(\"T3.t1Response\");\n            return Observable.just(t1Response);\n        }\n    });\n}\n\nprotected Observable<JsonObject> getT1info(String id) {\n        return ObservableHttp.createGet(url+id, client).toObservable()\n    .<JsonObject>flatMap(\n            response -> {\n\n                System.out.println(\"calling getT1info: \" + count++ );\n                return response.getContent()\n                        .map(s3 ->{\n                            System.out\n                                    .println(new String(s3));\n                            return new JsonParser().parse(new String(s3)).getAsJsonObject();\n                            }\n                        ); \n                    }\n            )\n            .timeout(3000, TimeUnit.MILLISECONDS)\n        .doOnError(throwable ->\n                System.out.println(\"printing throwable (getT1info): \" + throwable.toString())\n        );\n}\n```\n\nAny advise is greatly appreciated,\nThank you.\n"
    },
    "satisfaction_conditions": [
      "Network call to getT1info executes exactly once per subscription",
      "Both T2 and T3 receive the same T1 response data",
      "Final zipped result combines T2 and T3 outputs correctly"
    ],
    "created_at": "2016-08-30T05:17:19Z"
  },
  {
    "id": "https://github.com/ReactiveX/RxJava/issues/4438",
    "source": {
      "issue_number": 4438
    },
    "initial_question": {
      "title": "2.x: Best way to unsubscribe/dispose a Subject subscription?",
      "body": "Since there is no longer a `Subscription` returned when subscribing a `Subject` to an `Observable`, looking for the best way unsubscribe/dispose.\n\n``` java\nObservable<Long> observableA = Observable.interval(200, TimeUnit.MILLISECONDS).map(value -> value);\nObservable<Long> observableB = Observable.interval(200, TimeUnit.MILLISECONDS).map(value -> value * 100L);\n\nBehaviorSubject<Long> subject = BehaviorSubject.create();\nsubject.subscribe(System.out::println);\n\nSystem.out.println(\"Subscribing to observableA\");\nobservableA.subscribe(subject);\n\nTimeUnit.SECONDS.sleep(3);\n\n// TODO: How to unsubscribe the subject from upstream observableA before subscribing it to upstream observableB?\n\nSystem.out.println(\"Subscribing to observableB\");\nobservableB.subscribe(subject);\n\nTimeUnit.SECONDS.sleep(3);\n```\n\nWhat I've come up with so far is to `subscribeWith` an object that extends `DisposableObserver` that forwards `onNext`, `onError`, `onComplete` to the subject and use that to `dispose()` at the appropriate time.\n"
    },
    "satisfaction_conditions": [
      "Subject must be able to stop receiving emissions from the first Observable",
      "Clean resource management without memory leaks",
      "Subject maintains ability to receive new subscriptions",
      "Solution must be compatible with RxJava 2.x API",
      "Subscription cancellation must be explicit and controllable"
    ],
    "created_at": "2016-08-29T19:41:55Z"
  },
  {
    "id": "https://github.com/ReactiveX/RxJava/issues/4408",
    "source": {
      "issue_number": 4408
    },
    "initial_question": {
      "title": "CombineLatest and toList combination.",
      "body": "Hello, \nThe RexactiveX documentation says : \n\n>  CombineLatest emits an item whenever any of the source Observables emits an item (so long as each of the source Observables has emitted at least one item)\n\nbut when I use combineLatest on a stream converted with toList, the output only produces one element even if the other stream (the one not converted with toList) has many values.\n\nGiving this test :\n\n``` java\nimport org.testng.annotations.Test;\nimport rx.Observable;\n\npublic class CombineLastTest {\n\n    @Test\n    public void testZip() {\n        Observable.combineLatest(//\n                Observable.just(1, 2, 3, 4, 5)//\n                     .doOnNext((integerValue) -> System.out.println(\"First stream value  : \" + integerValue))//\n                     .doOnCompleted(() -> System.out.println(\"First stream complete\")),//\n                Observable.just(\"a\", \"b\", \"c\", \"d\", \"e\")//\n                     .doOnNext((stringValue) -> System.out.println(\"Second stream value : \" + stringValue))//\n                     .toList()//\n                     .doOnNext((stringListValues) -> System.out.println(\"Second stream to list : \" + stringListValues))//\n                     .doOnCompleted(() -> System.out.println(\"Second stream complete\")),//\n                (firstStreamLatestStringValue, secondStreamLatestStringListValue) -> firstStreamLatestStringValue + \" \" + secondStreamLatestStringListValue)//\n            .doOnCompleted(() -> System.out.println(\"Stream is completed\")).subscribe(System.out::println);\n    }\n}\n```\n\nI get :\n\n```\nFirst stream value  : 1\nFirst stream value  : 2\nFirst stream value  : 3\nFirst stream value  : 4\nFirst stream value  : 5\nFirst stream complete\nSecond stream value : a\nSecond stream value : b\nSecond stream value : c\nSecond stream value : d\nSecond stream value : e\nSecond stream to list : [a, b, c, d, e]\n5 [a, b, c, d, e]\nSecond stream complete\nStream is completed\n```\n\nI presume I should get : \n\n```\nFirst stream value  : 1\nFirst stream value  : 2\nFirst stream value  : 3\nFirst stream value  : 4\nFirst stream value  : 5\nFirst stream complete\nSecond stream value : a\nSecond stream value : b\nSecond stream value : c\nSecond stream value : d\nSecond stream value : e\nSecond stream to list : [a, b, c, d, e]\n1 [a, b, c, d, e]\n2 [a, b, c, d, e]\n3 [a, b, c, d, e]\n4 [a, b, c, d, e]\n5 [a, b, c, d, e]\nSecond stream complete\nStream is completed\n```\n"
    },
    "satisfaction_conditions": [
      "The order of stream processing must allow the list to be fully formed before combination"
    ],
    "created_at": "2016-08-23T07:28:11Z"
  },
  {
    "id": "https://github.com/ReactiveX/RxJava/issues/4407",
    "source": {
      "issue_number": 4407
    },
    "initial_question": {
      "title": "Unsubscribe not called when using retryWhen",
      "body": "I am not sure if this is expected, but when I run the below test, I get an assertion error:\n\n`java.lang.AssertionError: Not unsubscribed. (1 completion)`\n\nIt does not happen all the time which is why I put it in a loop. I suspect it has something to do with the timer in `retryWhen`. If the timer is set to 0, the test runs successfully. Anything else, it fails. I noticed the timer runs on the computation scheduler and tried adding `observeOn(Schedulers.immediate())` everywhere with no luck. \n\nIs the expected? If so, how can I get this to run reliably?\n\nTested on RxJava v1.1.9 and v1.1.0\n\n``` java\n\n    @Test\n    public void testUnsubscribe_shouldUnsubscribeAfterRetry() {\n        String testValue = \"test\";\n        for (int i = 0; i < 1000; ++i) {\n            TestSubscriber<String> subscriber = new TestSubscriber<>();\n            AtomicBoolean shouldFail = new AtomicBoolean(true);\n\n            Observable.defer(() -> {\n                if (shouldFail.getAndSet(false)) {\n                    return Observable.error(new IOException(\"Network Error\"));\n                } else {\n                    return Observable.just(testValue);\n                }\n            }).retryWhen(this::onErrorTryAgainWithTimer).subscribe(subscriber);\n\n            subscriber.awaitTerminalEvent();\n            subscriber.assertValue(testValue);\n            subscriber.assertNoErrors();\n            subscriber.assertUnsubscribed();  // Fails here\n        }\n    }\n\n    private Observable<?> onErrorTryAgainWithTimer(Observable<? extends Throwable> errors) {\n        return errors.zipWith(Observable.just(10, 1000, 2000), (n, i) -> i)\n                .flatMap(time -> Observable.timer(time, MILLISECONDS));\n    }\n```\n"
    },
    "satisfaction_conditions": [
      "Asynchronous operations must complete before assertions",
      "Test remains consistent across multiple iterations",
      "Maintains correct order of operations"
    ],
    "created_at": "2016-08-23T05:22:14Z"
  },
  {
    "id": "https://github.com/ReactiveX/RxJava/issues/4202",
    "source": {
      "issue_number": 4202
    },
    "initial_question": {
      "title": "Question about takeUntil and Subscription.unsubscribe()",
      "body": "in android ,if I use takeUntil for any network and on activity destroy, I use PublishSubject.onNext(null), the relation is gone; if I use CompositeSubscription.add() for any network and on activity destroy, I use CompositeSubscription.unsubscribe(), the relation is gone. what is different ?\n"
    },
    "satisfaction_conditions": [
      "Subscription must terminate when activity is destroyed",
      "Multiple consumers must be handled appropriately",
      "Solution must work within Android activity lifecycle",
      "Cleanup mechanism must be reusable across multiple subscriptions"
    ],
    "created_at": "2016-07-14T09:17:49Z"
  },
  {
    "id": "https://github.com/ReactiveX/RxJava/issues/4197",
    "source": {
      "issue_number": 4197
    },
    "initial_question": {
      "title": "Question about Observable.using's resourceFactory & disposeAction",
      "body": "I have a resource which I want to release upon unsubscribing of the Observable, and release action must be run on the same thread which I created the resource.\n\nSo I found `Observable.using` and assumed that resourceFactory & disposeAction will run on a same thread which I specified with `subscribeOn`.\n\nAt first it seems working as I expected, but I realized that sometimes disposeAction runs on different thread than I specified with `subscribeOn`\n\n``` java\npublic class UsingResourceSample {\n    public static void main(String[] args) throws InterruptedException {\n    for (int i = 0; i < 10; i++) {\n      Observable.using(() -> {\n            String factoryThread = \"Getting @\" + Thread.currentThread().toString();\n            System.out.println(factoryThread);\n            return factoryThread;\n          },\n          Observable::just,\n          (factoryThread) -> System.out.println(\"Closing @\" + Thread.currentThread().toString() + \", \" + factoryThread))\n          .subscribeOn(Schedulers.io())\n          .subscribe()\n          .unsubscribe();\n    }\n  }\n}\n```\n\nIf I run this code multiple times, most of the time it shows `Closing @ThreadA, Getting @ThreadA`, but sometimes it shows `Closing @ThreadB, Getting @ThreadA`.\n\nSo, here are questions:\n1. is this behavior intentional?\n2. is there any way to run resourceFactory & disposeAction to run on the same thread which I specified with `subscribeOn`?\n"
    },
    "satisfaction_conditions": [
      "Thread scheduling must be controllable/predictable",
      "Resource disposal must trigger upon unsubscription"
    ],
    "created_at": "2016-07-13T13:04:54Z"
  },
  {
    "id": "https://github.com/ReactiveX/RxJava/issues/4164",
    "source": {
      "issue_number": 4164
    },
    "initial_question": {
      "title": "Method for shutdown CachedObservable",
      "body": "I have endless stream (which is not called onComplete at all). And I cache last value in it:\n\n```\nObservable<T> endlessStream = createStream().cache();\n\nSubscription s1 = endlessStream.subscribe(...)\nSubscription s2 = endlessStream.subscribe(...)\n```\n\nBy some condition endlessStream become not valid and I replace it (with switchMap, but it's not important).\n\n```\ns1.unsubscribe()\ns2.unsubscribe()\n```\n\nBut CachedObservable will always store connection to source stream (returned from createStream()). This leads to memory leak. How to disconnect CachedObservable from source observable?\n\nMore information:\n\nCachedObservable contains field state, which contain SerialSubscription to source observables (connection). If I call next hack, everything becomes OK:\n\n```\nprivate void disconnectCachedObservable(CachedObservable<T> observable) {\n    try {\n        Field fieldState = CachedObservable.class.getDeclaredField(\"state\");\n        fieldState.setAccessible(true);\n        Object state = fieldState.get(observable);\n        Field fieldConnection = state.getClass().getDeclaredField(\"connection\");\n        fieldConnection.setAccessible(true);\n        SerialSubscription subscription = (SerialSubscription) fieldConnection.get(state);\n        subscription.unsubscribe();\n    } catch (NoSuchFieldException e) {\n        e.printStackTrace();\n    } catch (IllegalAccessException e) {\n        e.printStackTrace();\n    }\n}\n```\n\nBut reflection isn't good solution:(\n\nMaybe create public method it?\n"
    },
    "satisfaction_conditions": [
      "The endless stream must be properly disconnected from its source when no longer needed",
      "All subscribers must be able to access cached values while the stream is active",
      "The solution must allow explicit cleanup/shutdown of the cached stream",
      "The cleanup method must be accessible through public API",
      "Memory resources must be properly released after cleanup"
    ],
    "created_at": "2016-07-05T07:41:57Z"
  },
  {
    "id": "https://github.com/ReactiveX/RxJava/issues/4161",
    "source": {
      "issue_number": 4161
    },
    "initial_question": {
      "title": "triggerActions doesn't work w/o advanceTimeBy",
      "body": "So I have unit test:\n\n```\n @Test\n    public void interestingTest() {\n        TestSubscriber subscriber = new TestSubscriber();\n\n        List<Item> defaultList = new ArrayList<>();\n        Observable.concat(\n                memory.getItems(0, 20, item -> true),\n                disk.getItems(0, 20)\n                        .filter(items -> items != null && !items.isEmpty())\n                        .observeOn(uiScheduler),\n                cloud.getItems(TEST_USER_ID, 0, 20)\n                        .filter(items -> items != null && !items.isEmpty())\n                        .subscribeOn(ioScheduler)\n                        .observeOn(uiScheduler)\n        )\n                .firstOrDefault(defaultList, items -> items != null && !items.isEmpty())\n                .subscribe(subscriber);\n\n        uiScheduler.advanceTimeBy(0, TimeUnit.NANOSECONDS);\n        ioScheduler.triggerActions();\n        uiScheduler.triggerActions();\n\n        assertTrue(subscriber.getOnNextEvents().get(0) == defaultList);\n    }\n```\n\nmemory/disk/cloud are all mocked to return  Observable.just(new ArrayList<>())) so there is no any domain specific code.\n\nIt will work if I call `uiScheduler.advanceTimeBy(0, TimeUnit.NANOSECONDS)` even if I advance time with 0 {any timeunit}, but if I skip this line - testSubscriber won't get any items and test will fail. What's the reason of this behavior?\n"
    },
    "satisfaction_conditions": [
      "Scheduler execution order must maintain task dependencies",
      "TestSubscriber must receive the expected default list value",
      "Cross-scheduler task propagation must be handled"
    ],
    "created_at": "2016-07-04T13:27:57Z"
  },
  {
    "id": "https://github.com/ReactiveX/RxJava/issues/4159",
    "source": {
      "issue_number": 4159
    },
    "initial_question": {
      "title": "1.x Subscriber receives value after unsubscription",
      "body": "Is it expected that this test case fails?\n\nOr the OnSubscribe is incomplete with this design (missing explicit `isUnsubscribed()` check)?\n\n```\n@Test\npublic void testAfterUnsubscribeNoValue() throws InterruptedException {\n    TestSubscriber<String> ts = new TestSubscriber<>();\n    AtomicBoolean unsubscribed = new AtomicBoolean();\n    CountDownLatch latch = new CountDownLatch(2);\n\n    Observable<String> s1 = Observable.create(s -> {\n\n        Thread t = new Thread(() -> {\n            try {\n                Thread.sleep(1000);\n                s.onNext(\"should not be displayed\");\n                latch.countDown();\n            } catch (InterruptedException ignored) {\n            }\n        });\n\n        s.add(Subscriptions.create(() -> {\n            unsubscribed.set(true);\n            latch.countDown();\n        }));\n        t.start();\n    });\n\n    Subscription subscription = s1.subscribe(ts);\n    subscription.unsubscribe();\n\n    if (latch.await(2000, TimeUnit.MILLISECONDS)) {\n        ts.assertNoValues();\n        assertTrue(unsubscribed.get());\n        assertTrue(subscription.isUnsubscribed());\n    } else {\n        fail(\"timed out waiting for latch\");\n    }\n}\n```\n"
    },
    "satisfaction_conditions": [
      "Unsubscription state must be properly tracked",
      "Cleanup actions must execute upon unsubscription",
      "Test assertions must complete within expected timeframe"
    ],
    "created_at": "2016-07-01T22:44:06Z"
  },
  {
    "id": "https://github.com/ReactiveX/RxJava/issues/3962",
    "source": {
      "issue_number": 3962
    },
    "initial_question": {
      "title": "concatMap and Subject weirdness",
      "body": "Hi,\n\nMaybe I just interpret it wrong but I found some unexpected behaviour.\n\n``` java\nObservable.just(1,2,3).concatMap(new Func1<Integer, Observable<String>>() { //flatmap <-- gets called 3 times\n    @Override\n    public Observable<String> call(Integer integer) {\n        return BehaviorSubject.create(\"one\"); //Observable.just(\"one\"); <-- This gets called 3 times\n    }\n}).subscribe(new Action1<String>() {\n    @Override\n    public void call(String s) {\n        //This gets called once... :(\n    }\n});\n```\n\nThe interesting thing is that if I use flatMap instead of concatMap the callback gets called 3 times. also if I don't use the subject but the Observable.just() it also gets called 3 times what I expect. Can someone describe me this outcome?\n"
    },
    "satisfaction_conditions": [
      "Sequential processing behavior must be maintained"
    ],
    "created_at": "2016-05-24T13:45:34Z"
  },
  {
    "id": "https://github.com/ReactiveX/RxJava/issues/3956",
    "source": {
      "issue_number": 3956
    },
    "initial_question": {
      "title": "Calling to Observable.toBlocking(). Always a bad practice?",
      "body": "Hi.\n\nI have a library which returns observables. And I have another one which require to return the data in a synchronous way. \n\nParticularly, I\u2019m talking about OkHttp Interceptors. I need to retrieve the oauth token in order to add it as header. But this data comes from an observable. \n\n``` java\npublic class TwitterInterceptor implements Interceptor {\n    @Override public Response intercept(Chain chain) throws IOException {\n        Request request = chain.request();\n        Request newRequest = request.newBuilder()\n                .addHeader(\"oauth_token\", RxToken.getTwitterToken().toBlocking().first())\n                .build();\n        return chain.proceed(newRequest);\n    }\n}\n```\n\nCalling `toBlocking().first()` is the only way I can think to solve this problem. But I do not know if calling `toBlocking()` may have some unexpected effects (I mean I know that this observable resolves its task reading from disk or memory, so it is not a really heavy task). But because it seems to be not recommended to use it in production code, as a general rule.\n\nThanks. \n"
    },
    "satisfaction_conditions": [
      "Successfully bridges reactive and synchronous APIs",
      "Maintains interceptor contract functionality",
      "Handles lightweight synchronous operations appropriately"
    ],
    "created_at": "2016-05-20T16:19:57Z"
  },
  {
    "id": "https://github.com/ReactiveX/RxJava/issues/3955",
    "source": {
      "issue_number": 3955
    },
    "initial_question": {
      "title": "concatMap not working",
      "body": "Hello! I'm using a RxJava to login to server. I need to create next logic of login:\n**1. Get version of API from server and create (based on version) server urls\n2. Get tokens from the first server url\n3. If tokens received, I need to check if other servers (that I created in point 1) can be accessed by connecting to them**\n\nI writed next logic: \n\n```\n// getObservable() funcion;\nretrun Observable.create(new Observable.OnSubscribe<Integer>() {\n            @Override\n            public void call(Subscriber<? super Integer> subscriber) {\n                if (subscriber.isUnsubscribed()) return;\n//get version from server\n                int version = ServerAPI.getInstance(mContext).getVersion(User.this);\n                if (version < 5) {\n                    subscriber.onNext(AccountsAdapter.ERROR_OLD_API);\n                    subscriber.onCompleted();                 \n                    return;\n                }\n//get tokens\n                Pair<Integer,Tokens> data = ServerAPI.getInstance(mContext).getTokens(User.this, ServerAPI.GRANT_TYPE_PASSWORD);\n                if (data.first==ServerAPI.CODE_OK&&data.second.isValid()) {\n                    setAccessToken(data.second.getAccessToken());\n                    setRefreshToken(data.second.getRefreshToken());\n                    setUserId(data.second.getUserID());\n                    setApiVersion(data.second.getApiVersion());\n                    setTypeToken(data.second.getTokenType());\n                    setMacAlgorithm(data.second.getMacAlgorithm());\n                    setMacKey(data.second.getMacKey());\n                    setApiServer(createApiLink(version));\n                    setImagesServer(createImagesLink());\n //at this point result retuns to subscriber\n                    subscriber.onNext(data.first);\n                } else if (data.first==ServerAPI.CODE_OK\n                        ||data.first==ServerAPI.CODE_INVALID_RESPONSE_DATA) {\n                    subscriber.onNext(AccountsAdapter.ERROR_LOGIN_OR_PASS_INVALID);\n                } else {\n                    subscriber.onNext(data.first);\n                }\n                subscriber.onCompleted();\n            }\n        })\n               .concatMap(integer -> {\n// this code never called\n                if (integer==ServerAPI.CODE_OK) {\n// checking access to the servers\n                    return Observable.zip(getUserModules(), Observable.just(ServerAPI.getInstance(mContext).checkAccessToImagesServer(User.this)), (strings, aBoolean) -> {\n                        if (SystemUtils.isEmpty(strings)) {\n                            logOut();\n                            return AccountsAdapter.ERROR_INVALID_API_SERVER;\n                        } else if (aBoolean) {\n                            Users.getInstance(mContext).setCurrentUser(User.this);\n                            NotificationsManager.enableAllNotifications(mContext, getUserId());\n                            return ServerAPI.CODE_OK;\n                        } else {\n                            logOut();\n                            return AccountsAdapter.ERROR_INVALID_IMAGES_SERVER;\n                        }\n                    });\n                } else {\n                    return Observable.just(integer);\n                }\n            })\n         .subscribeOn(scheduler);\n```\n\nBut this Observable ignores concatMap and returns result from commented string. How to fix this?\n\nSubscriber is called by `getObservable().observeOn(AndroidSchedulers.mainThread()).subscribe();`\n"
    },
    "satisfaction_conditions": [
      "Observable chain correctly processes API version check, token retrieval, and server access verification in sequence",
      "Observable operators are properly chained to maintain data flow between operations",
      "Error states from each step are properly propagated to the subscriber",
      "Observable executes on the specified scheduler with results delivered to the main thread"
    ],
    "created_at": "2016-05-20T10:24:55Z"
  },
  {
    "id": "https://github.com/ReactiveX/RxJava/issues/3939",
    "source": {
      "issue_number": 3939
    },
    "initial_question": {
      "title": "What's the best way to have a side effect of a different type",
      "body": "I'd like to have an `Observable` that represents some long running action, such as `Observable<ProgressEvent>` where the event holds progress information for the task, such as a status message or percentage completed.\n\nAt the end of the task I'd like to return a value of a different type. A trivial example would be counting the number of mis spelled words in some text. The progress would be processing word X of Y, but the result might be the list of mis-spelled words.\n\nThe first thing I looked at was`Subject`, but that won't work since the thing is really an `Observable` of the events and an `Observable` of the result, rather than an `Observable` an an `Observer` like `Subject`. Then I thought maybe simply extending `Observable` would work; I'd add an extra method `Optional<Result> result()` which would return the result of the computation after `onComplete`. But you \"lose\" the type of the `Observable` if you call other methods on it like a map, then a filter. You can get around that obviously, either extending all of the methods on Observable to return the subtype, or saving the variable, then chaining method calls to it, then finally, getting the result.\n\nI also considered adding the `result` method to the event interface such that the last call to `onNext` would have an event whose `Optional<Result>` is not empty. This seems pretty easy, but did not feel like the cleanest solution.\n\nWondering if there's a mechanism in the framework that I missed, or some best practice for this type of situation that I'm not aware of.\n\nThe reason I don't return an `Observable<Result>` in the first place is I wanted the caller to have the option of subscribing to the event stream to do something like show a progress monitor.\n"
    },
    "satisfaction_conditions": [
      "Must allow streaming of progress events during execution",
      "Must provide a final result of a different type than the progress events",
      "Must maintain type safety throughout the operation chain",
      "Must allow optional subscription to progress events",
      "Must guarantee result availability after completion"
    ],
    "created_at": "2016-05-13T19:04:23Z"
  },
  {
    "id": "https://github.com/ReactiveX/RxJava/issues/3933",
    "source": {
      "issue_number": 3933
    },
    "initial_question": {
      "title": "BackPressure and nested flatMap",
      "body": "Hi, can someone explain why the following code (without nested flatmap)\n\n<div class=\"highlight highlight-source-java\"><pre>\nObservable.from(new IterateOverFloat(1))) //\n                .flatMap(__ -> Observable.create(new OnSubscribeFromIterable<>(new IterateOverFloat(10_000_000)))) //\n                .flatMap(Observable::just) //\n                .observeOn(Schedulers.computation()) //\n                .subscribe();\n</pre></div>\n\ngoes through method `slowPath(long)` of `OnSubscribeFromIterable.IterableProducer`,\n\nwhile the following code (with nested flat map)\n\n<div class=\"highlight highlight-source-java\"><pre>\nObservable.from(new IterateOverFloat(1)) //\n                .flatMap(__ -> Observable.create(new OnSubscribeFromIterable<>(new IterateOverFloat(10_000_000))) //\n                        .flatMap(Observable::just)) //\n                .observeOn(Schedulers.computation()) //\n                .subscribe();\n</pre></div>\n\ngoes through method `fastPath()` ?\n\n`IterateOverFloat` is just a basic iterable that produces the asked number of floats.\n\nI've tested with both RxJava-1.1.0 and 1.1.5 with the same results.\n\nEDIT : ok, I have looked around a bit more, and here is what I have found.\nI have created an Observable with backpressure support, which prints the first number of requested items:\n\n<div class=\"highlight highlight-source-java\"><pre>\nObservable<Long> myObsWithBackPressureSupport = Observable.create(subs -> {\n            subs.setProducer(new Producer() {\n\n                AtomicBoolean bool = new AtomicBoolean(true);\n\n                @Override\n                public void request(long n) {\n                    if(bool.getAndSet(false)){\n                        System.out.println(\"request \" + n);\n                    }\n                    \n                    LongStream.range(0, n).forEach(subs::onNext);\n                }\n                \n            });\n        });\n</pre></div>\n\n\nand I used it the following ways: \n\n<div class=\"highlight highlight-source-java\"><pre>\n// case 1\nmyObsWithBackPressureSupport //\n        .observeOn(Schedulers.computation()) //\n        .subscribe();\n\n// case 2\nmyObsWithBackPressureSupport //\n        .flatMap(l -> Observable.just(l)) //\n        .observeOn(Schedulers.computation()) //\n        .subscribe();\n</pre></div>\n\n\nIn case 1, first request of 128 items.\nIn case 2, first request of Long.MAX_VALUE items.\n\nI have concluded that using `flatMap` disables the backpressure support. Can someone tell me if I am right and if it is an intended behavior ?\n"
    },
    "satisfaction_conditions": [
      "Backpressure behavior must be correctly explained for both nested and non-nested flatMap scenarios",
      "Request size differences between direct and flatMap operations must be demonstrated",
      "Inner vs outer sequence behavior in flatMap must be distinguished",
      "Impact on backpressure support must be clearly identified",
      "Observable behavior must be verifiable through the provided test cases"
    ],
    "created_at": "2016-05-12T10:28:40Z"
  },
  {
    "id": "https://github.com/ReactiveX/RxJava/issues/3929",
    "source": {
      "issue_number": 3929
    },
    "initial_question": {
      "title": ".groupBy should not hold strong references to keys",
      "body": "Actual result: .groupBy maintains internal map with strong references to keys. In case when key is large object, or references another large objects, this can lead to OOM eventually.\n\nExpected result: groupBy keeps week references to keys, which does not prevent GC from collecting the keys.\n"
    },
    "satisfaction_conditions": [
      "Group functionality remains correct and consistent",
      "Resources are properly released when groups are no longer needed",
      "Key identity and accessibility is maintained throughout group lifetime"
    ],
    "created_at": "2016-05-11T09:08:08Z"
  },
  {
    "id": "https://github.com/ReactiveX/RxJava/issues/3869",
    "source": {
      "issue_number": 3869
    },
    "initial_question": {
      "title": "wondering",
      "body": "``` java\nObservable\n.just(mToast)\n.observeOn(AndroidSchedulers.mainThread())\n.subscribe(new Action1<Toast>() {\n    @Override\n    public void call(Toast toast) {\n       if (mToast == null) {\n          mToast = Toast.makeText(MainActivity.this, \"test==================\", Toast.LENGTH_SHORT);\n       } else {\n           mToast.setText(\"test====================\");\n       }\n       mToast.show();\n   }\n}).unsubscribe();\n```\n\nwhy the toast can\u2018t show\uff1f\n"
    },
    "satisfaction_conditions": [
      "UI operations must execute on the main thread without blocking"
    ],
    "created_at": "2016-04-20T10:13:38Z"
  },
  {
    "id": "https://github.com/ReactiveX/RxJava/issues/3847",
    "source": {
      "issue_number": 3847
    },
    "initial_question": {
      "title": "I use scan operator,but it not work when just one value or first event",
      "body": "I use the `rxjava` version `1.1.0`,and use scan operator such as:\n\n```\nObservable.just(\"Hello, world!\").scan(new Func2<String, String, String>() {\n        @Override\n        public String call(String s, String s2) {\n            Log.e(\"test\", s);\n            return s;\n        }\n    }).subscribe(new Action1<String>() {\n        @Override\n        public void call(String s) {\n            Log.e(\"test\", s);\n        }\n    });\n```\n\n the `scan()` not invoke.\n\nor \n\n```\nRxView.clicks(btn).map(new Func1<Void, Integer>() {\n        @Override\n        public Integer call(Void aVoid) {\n            times = times + 1;\n            return times;\n        }\n    }).timestamp().scan(new Func2<Timestamped<Integer>, Timestamped<Integer>,               Timestamped<Integer>>() {\n        @Override\n        public Timestamped<Integer> call(Timestamped<Integer> integerTimestamped, Timestamped<Integer> integerTimestamped2) {\n  Log.e(\"integerTimestamped:\", integerTimestamped.getValue() + \"\");\n  Log.e(\"integerTimestamped\", integerTimestamped.getTimestampMillis() + \"\");\n  Log.e(\"integerTimestamped2:\", integerTimestamped2.getValue() + \"\");\n  Log.e(\"integerTimestamped2\", integerTimestamped2.getTimestampMillis() + \"\");\n  return Timestamped<>(integerTimestamped2.getTimestampMillis(),times);\n        }\n    }).subscribe(new Action1<Timestamped<Integer>>() {\n        @Override\n        public void call(Timestamped<Integer> integerTimestamped) {\n            if (integerTimestamped.getValue() == 5) {\n                firstClickTime = 0;\n                times = 0;\n                Toast.makeText(MainActivity.this,\n                    \"test\",\n                    Toast.LENGTH_LONG).show();\n            }\n\n        }\n    });\n```\n\n when click btn first time ,the `scan()` also not invok\n"
    },
    "satisfaction_conditions": [
      "The scan operator must maintain expected accumulation behavior",
      "The solution must be compatible with RxJava 1.1.0"
    ],
    "created_at": "2016-04-10T15:54:23Z"
  },
  {
    "id": "https://github.com/ReactiveX/RxJava/issues/3844",
    "source": {
      "issue_number": 3844
    },
    "initial_question": {
      "title": "delaySubscription(Observable) breaks upstream unsubscription",
      "body": "This test case is failing (tested with 1.1.2):\n\n``` java\n  @Test\n  public void testWithSubjects() {\n    PublishSubject<Integer> delayUntil = PublishSubject.create();\n    PublishSubject<Integer> interrupt = PublishSubject.create();\n    final AtomicBoolean subscribed = new AtomicBoolean(false);\n\n    Observable.just(1)\n        .doOnSubscribe(() -> subscribed.set(true))\n        .delaySubscription(delayUntil)\n        .takeUntil(interrupt)\n        .subscribe();\n\n    interrupt.onNext(9000);\n    delayUntil.onNext(1);\n\n    assertFalse(subscribed.get());\n  }\n\n```\n\nI stumbled upon this using `Completable.andThen` (which delegates to `delaySubscription`).\n"
    },
    "satisfaction_conditions": [
      "Early termination signals must prevent delayed subscription from occurring"
    ],
    "created_at": "2016-04-08T18:26:09Z"
  },
  {
    "id": "https://github.com/ReactiveX/RxJava/issues/3843",
    "source": {
      "issue_number": 3843
    },
    "initial_question": {
      "title": "Unexpected behavior",
      "body": "``` java\nimport rx.Observable;\n\npublic class RxTest {\n\n    public static void main(String[] args) {\n        Observable.<String>create(subscriber -> {\n            subscriber.onNext(\"as\");\n            subscriber.onNext(\"asd\");\n        })\n                .map(s -> {\n                    if (s.length() < 3) {\n                        throw new RuntimeException(\"\");\n                    }\n                    return 1;\n                })\n                .flatMap(o -> {\n                    System.out.println(\"flatMap\");\n                    return Observable.just(true);\n                })\n                .subscribe(System.out::println, t -> {});\n    }\n}\n```\n\nOutput:\n\n```\nflatMap\n```\n\nBut, if we comment line with `throw new RuntimeException(\"\")` output will be:\n\n```\nflatMap\ntrue\nflatMap\ntrue\n```\n"
    },
    "satisfaction_conditions": [
      "Error handling must prevent subsequent emissions for failed items",
      "Observable must maintain proper emission sequence"
    ],
    "created_at": "2016-04-08T05:57:48Z"
  },
  {
    "id": "https://github.com/ReactiveX/RxJava/issues/3813",
    "source": {
      "issue_number": 3813
    },
    "initial_question": {
      "title": "OnSubscribeCombineLatest#MultiSourceProducer request method get different result?",
      "body": "In request method,there is a line code ':o.unsafeSubscribe(s);' and I find the unsafeSubscribe()'s note is 'Subscribes to an Observable and invokes {@link OnSubscribe} function without any contract protection,error handling, unsubscribe, or execution hooks.'.\nThis is my code:\n\n``` java\nObservable<Long> observable1 = Observable.interval(0, 1000, TimeUnit.MILLISECONDS)\n                    .map(new Func1<Long, Long>() {\n                        @Override\n                        public Long call(Long aLong) {\n                            return aLong * 5;\n                        }\n                    }).take(5);\n            Observable<Long> observable2 = Observable.interval(500, 1500, TimeUnit.MILLISECONDS)\n                    .map(new Func1<Long, Long>() {\n                        @Override\n                        public Long call(Long aLong) {\n                            return aLong * 10;\n                        }\n                    }).take(4);\n            Observable.combineLatest(observable2, observable1, new Func2<Long, Long, Long>() {\n                @Override\n                public Long call(Long aLong, Long aLong2) {\n                    Log.i(\"ppppp\", \"combineLatest aLong = \" + aLong + \"   aLong2 =\" + aLong2);\n                    return aLong + aLong2;\n                }\n            }).subscribe(new Subscriber<Long>() {\n                @Override\n                public void onCompleted() {\n                    System.out.println(\"Sequence complete.\");\n                }\n                @Override\n                public void onError(Throwable e) {\n                    System.err.println(\"Error: \" + e.getMessage());\n                }\n                @Override\n                public void onNext(Long aLong) {\n                    System.out.println(\"combineLatest Next: \" + aLong);\n                }\n            });\n```\n\nI run this code and get two different results.\n(1)\n Next: 0\n Next: 5\n Next: 10\n Next: 20\n Next: 25\n Next: 35\n Next: 40\n Next: 50\n(2)\n Next: 0\n Next: 5\n Next: 15\n Next: 20\n Next: 25\n Next: 35\n Next: 40\n Next: 50\n"
    },
    "satisfaction_conditions": [
      "CombineLatest operator must wait for all source Observables to emit at least one item before producing any output",
      "After all sources have emitted at least once, any new emission from any source must trigger a new combined output",
      "When multiple sources emit simultaneously, the order of combination must be consistent within a single execution but may vary between executions",
      "The combination function must be applied to the most recent values from each source Observable"
    ],
    "created_at": "2016-03-31T09:17:24Z"
  },
  {
    "id": "https://github.com/ReactiveX/RxJava/issues/3811",
    "source": {
      "issue_number": 3811
    },
    "initial_question": {
      "title": "About Subscriber",
      "body": "When I watch the source code of operators, I found that in order to keep the unsubscribe chain, the parent subscriber always created by two way:\n\n```\nSubscriber<T> parent = new Subscriber(child){ ... };\n```\n\nor\n\n```\nSubscriber<T> parent = new Subscriber{ ... };\nchild.add(parent);\n```\n\nI know that the first one can pass through the producer.\nAnd, What else can decide the choosing? \n"
    },
    "satisfaction_conditions": [
      "Unsubscribe chain remains intact and functional",
      "Parent-child subscriber relationship is properly established",
      "Unsubscribe operations do not cause downstream issues",
      "Producer communication path is preserved when needed"
    ],
    "created_at": "2016-03-30T10:25:44Z"
  },
  {
    "id": "https://github.com/ReactiveX/RxJava/issues/3788",
    "source": {
      "issue_number": 3788
    },
    "initial_question": {
      "title": "toList() does not work",
      "body": "I have one Observable below . \n\n```\nComApi.getInstance().getRegionList().compose(RxUtil.background())\n                .filter(resRegionModel -> resRegionModel != null)\n                .map(ResRegionsModel::getData)\n                .flatMap(Observable::from)\n                .filter(dataEntity -> dataEntity != null)\n                .map(this::convert)\n                .doOnNext(adapter::replaceWith)  // this can work, it will receive data one by one.\n                .toList()\n                .doOnNext(adapter::replaceWith) // but this callback will not be called .while after toList()..it can \n                                                                      // not receive data by once. \n                .doOnError(Throwable::printStackTrace)\n                .subscribe();\n```\n\nthis is my first catch problem while I using toList(). I don't know how to fix this issue.\n"
    },
    "satisfaction_conditions": [
      "Data transformation must preserve all required items"
    ],
    "created_at": "2016-03-22T07:48:05Z"
  },
  {
    "id": "https://github.com/ReactiveX/RxJava/issues/3786",
    "source": {
      "issue_number": 3786
    },
    "initial_question": {
      "title": "timeout eats exceptions",
      "body": "If I have a custom Observable that published some exceptions in onError, chaining such observable with timeout(time, units, MyCustomTimeoutException()) hides exceptions that are sent by custom observable.\n\nSome example.\nSecurityException and IllegalArgumentException never reach my subscriber.\n\n```\nfun getLocation(): Observable<Location> {\n        return requestSingleLocation()\n                .subscribeOn(schedulers.loopedIo)\n                .timeout(LOCATION_REQUEST_TIMEOUT,\n                         TimeUnit.SECONDS,\n                         Observable.error(NetworkLocationTimeoutException()))\n                .first()\n    }\n\n    private fun requestSingleLocation(): Observable<Location> {\n        return Observable.create<Location> { subscriber ->\n\n            try {\n                val knownLocation = locationManager.getLastKnownLocation(LocationManager.NETWORK_PROVIDER)\n                knownLocation?.apply {\n                    subscriber.onNext(this)\n                }\n\n                locationManager.requestSingleUpdate(LocationManager.NETWORK_PROVIDER, LocationChangedListener {\n                    subscriber.onNext(it)\n                    subscriber.onCompleted()\n                }, null)\n\n            } catch (securityException: SecurityException) {\n                subscriber.onError(securityException)\n            } catch (illegalArgumentException: IllegalArgumentException) {\n                subscriber.onError(illegalArgumentException)\n            }\n        }\n    }\n\n```\n\nFollowing test fails:\n\n```\n@Test\n    fun getLocationProcessesSecurityException() {\n        // given\n\n        val securityException = SecurityException()\n        given(locationManager.getLastKnownLocation(LocationManager.NETWORK_PROVIDER)).willReturn(location)\n        given(locationManager.requestSingleUpdate(BDDMockito.anyString(), any(), any())).willThrow(securityException)\n        val testSubscriber = TestSubscriber<Location>()\n\n        // when\n        classToTest.getLocation().subscribe(testSubscriber)\n\n        // then\n        testSubscriber.assertError(securityException)\n    }\n```\n"
    },
    "satisfaction_conditions": [
      "Original exceptions must be propagated through the timeout operator when they occur before the timeout period",
      "Timeout exception must be emitted only when the operation actually times out",
      "Observable chain must properly complete when successful",
      "Test cases must wait for asynchronous operations to complete"
    ],
    "created_at": "2016-03-21T09:51:29Z"
  },
  {
    "id": "https://github.com/ReactiveX/RxJava/issues/3776",
    "source": {
      "issue_number": 3776
    },
    "initial_question": {
      "title": "Why does affect not calling subsciber.onCompleted() when applying operator observable.toList()?",
      "body": "Hi!\n\nIf I create an observable using `Observable.create()` and I don\u2019t call onCompleted on its `subscriber`, following chaining operation `toList()` does not get executed.\n\n``` java\nprivate Observable<List<String>> createObservable() {\n        return Observable.create(subscriber -> {\n                subscriber.onNext(\"\");\n                subscriber.onCompleted(); //if onCompleted is not called the operations chained after calling flatMapIterable() -> toList() do not execute\n            })\n            .map(string -> Arrays.asList(\"1\", \"2\", \"3\"));\n    }\n```\n\n``` java\ncreateObservable()\n                .flatMapIterable(strings -> strings)\n                .map(string -> string)\n                .toList()\n                .map(strings -> strings); //this line is not executed if the source observable does not call onCompleted()\n```\n\nIs this the expected behaviour?\n\nThanks!\n"
    },
    "satisfaction_conditions": [
      "Observable stream must properly terminate",
      "All downstream operators must execute"
    ],
    "created_at": "2016-03-17T10:54:04Z"
  },
  {
    "id": "https://github.com/ReactiveX/RxJava/issues/3736",
    "source": {
      "issue_number": 3736
    },
    "initial_question": {
      "title": "How to get filtered POJO when used getXXX()?",
      "body": "```\n.flatMap(new Func1<Area, Observable<Store>>() {\n    @Override\n     public Observable<Store> call(Area area) {\n        return Observable.from(area.getStores());\n     }\n})\n.filter(new Func1<Store, Boolean>() {\n    @Override\n    public Boolean call(Store store) {\n        return store.getName().contains(text);\n    }\n})\n```\n\n> i want to get the filtered **Area**\n"
    },
    "satisfaction_conditions": [
      "Returns Area objects that contain at least one Store matching the text filter",
      "Preserves the original Area object structure",
      "Handles the hierarchical relationship between Area and Store objects",
      "Filters based on Store.getName() string content",
      "Returns unique Area instances"
    ],
    "created_at": "2016-02-27T03:44:59Z"
  },
  {
    "id": "https://github.com/ReactiveX/RxJava/issues/3735",
    "source": {
      "issue_number": 3735
    },
    "initial_question": {
      "title": "observable.toBlocking().toFuture().get(timeout, timeUnit) does not timeout",
      "body": "The use case is pretty simple. Am I getting something wrong or is this a bug ? \n\n```\ndef observable = Observable.from(new CompletableFuture()) // never completes\nobservable.toBlocking().toFuture().get(1, TimeUnit.SECONDS) // never completes either\n```\n\nThis should throw a TimeoutException after a second but actually blocks forever.\n"
    },
    "satisfaction_conditions": [
      "Thread blocking must not prevent timeout mechanism from functioning",
      "Must maintain Java 6 compatibility"
    ],
    "created_at": "2016-02-25T10:10:53Z"
  },
  {
    "id": "https://github.com/ReactiveX/RxJava/issues/3723",
    "source": {
      "issue_number": 3723
    },
    "initial_question": {
      "title": "SerializedBehaviorSubject",
      "body": "Looking at the changes in #2470, a useful `getValue()` method was added to `BehaviorSubject`. This goes away though if you want to serialize it. Would there be feasible to have something like a `SerializedBehaviorSubject` that maintains the API of `BehaviorSubject`?\n"
    },
    "satisfaction_conditions": [
      "Thread-safe access to current value must be maintained",
      "BehaviorSubject API functionality must be preserved"
    ],
    "created_at": "2016-02-19T20:33:24Z"
  },
  {
    "id": "https://github.com/ReactiveX/RxJava/issues/3716",
    "source": {
      "issue_number": 3716
    },
    "initial_question": {
      "title": "flatMapIterable and toList combination issue",
      "body": "In the following code the \"three\" and \"done\" never appears in the output. Looks like the problem is in `toList` call. Am i using it wrong?\n\n```\nPublishSubject<Boolean> mBooleanPublishSubject = PublishSubject.create();\nObservable<Boolean> observable = mBooleanPublishSubject.asObservable().share();\nobservable\n        .doOnNext(__ -> System.out.println(\"one\"))\n        .flatMap(__ -> Observable.just(Arrays.asList(1, 2, 3, 4)))\n        .flatMapIterable(number -> number)\n        .doOnNext(v -> System.out.println(\"two \" + v))\n        .toList()\n        .doOnNext(v -> System.out.println(\"three \" + v))\n        .subscribe(v -> System.out.println(\"done\"));\nmBooleanPublishSubject.onNext(true);\n```\n"
    },
    "satisfaction_conditions": [
      "All items must be properly collected into a single list",
      "Observable chain must maintain correct execution order"
    ],
    "created_at": "2016-02-16T08:42:14Z"
  },
  {
    "id": "https://github.com/ReactiveX/RxJava/issues/3656",
    "source": {
      "issue_number": 3656
    },
    "initial_question": {
      "title": "Take and debounce usage",
      "body": "I have the next test case\n\n``` @Test\n    public void testLimitAndPublishSubject() throws InterruptedException {\n        PublishSubject<Boolean> mBooleanPublishSubject = PublishSubject.create();\n        mBooleanPublishSubject.asObservable()\n                .doOnEach(__ -> System.out.println(\"on value emitted \"+System.currentTimeMillis()))\n                .take(1)\n                .doOnEach(__ -> System.out.println(\"on value emitted 2 \"+System.currentTimeMillis()))\n                .debounce(1000, TimeUnit.MILLISECONDS)\n                .doOnEach(__ -> System.out.println(\"on value emitted 3 \"+System.currentTimeMillis()))\n                .subscribe(__ -> System.out.println(\"done \"+System.currentTimeMillis()));\n        mBooleanPublishSubject.onNext(true);\n        Thread.sleep(1000);\n        mBooleanPublishSubject.onNext(true);\n        Thread.sleep(2000);\n    }\n```\n\nand the output is\n\n```\non value emitted 1454063289770\non value emitted 2 1454063289770\non value emitted 2 1454063289779\non value emitted 3 1454063289780\ndone 1454063289780\non value emitted 3 1454063289780\n```\n\nI can't figure out why the `on value emitted 2` and `on value emitted 3` appears in the log twice and why the debounce delay doesn't work. Can somebody please help?\n"
    },
    "satisfaction_conditions": [
      "First event triggers timer behavior",
      "Subsequent events within timing window are ignored"
    ],
    "created_at": "2016-01-29T10:30:55Z"
  },
  {
    "id": "https://github.com/ReactiveX/RxJava/issues/3611",
    "source": {
      "issue_number": 3611
    },
    "initial_question": {
      "title": "GroupedObservable -> toBlocking() - hang forever",
      "body": "Found an issue where `groupObservable.toBlocking()` hangs.\n\n`rxjava:1.1.0`\n\n```\nObservable\n            .just(1, 1, 2, 3, 4, 4, 5)\n            .groupBy(new Func1<Integer, Boolean>() {\n                @Override\n                public Boolean call(Integer integer) {\n                    return integer % 2 == 0;\n                }\n            }).subscribe(new Action1<GroupedObservable<Boolean, Integer>>() {\n            @Override\n            public void call(GroupedObservable<Boolean, Integer> grouped) {\n                List<Integer> first = grouped.toList().toBlocking().first();\n                Timber.d(first.size() + \" (Even: \" + grouped.getKey() + \")\");\n            }\n        });\n```\n"
    },
    "satisfaction_conditions": [
      "Observable chain must complete without deadlock",
      "All grouped elements must be processed",
      "Group size information must be logged for each group",
      "Group key association must be maintained throughout processing"
    ],
    "created_at": "2016-01-11T13:31:57Z"
  },
  {
    "id": "https://github.com/ReactiveX/RxJava/issues/3608",
    "source": {
      "issue_number": 3608
    },
    "initial_question": {
      "title": "Computation Scheduler stopping/slowing items from processing",
      "body": "I am having a problem with trying to multi-thread my application to improve performance. My actual application follows a similar structure to the code below (except using real data and doing real work). I am using a flatMap so that I can simultaneously process the items on mutliple threads since the map work can potentially take a lot of time. \n\nWhat I am seeing, is when an item takes a long time to process in the map, it stops the items from being processed by other threads in the pool. In this example, I am seeing 11 items waiting till after the \"Done Sleeping...\" to be processed. The point of the multi-threading is for those items to be all processed in parallel with the item that is processing slowly.\n\nI noticed by switching to a FixedThreadPool Scheduler, it works as expected and the other threads pick up all the items remaining to be processed. \n\nWhy does the computation scheduler act like this? Is it a bug, or is there something I am not understanding?\n\nThe code snippet is in Groovy and I am using RxJava 1.1.0.\n\n```\nimport rx.Observable\nimport rx.Scheduler\nimport rx.schedulers.Schedulers\n\nimport java.util.concurrent.CountDownLatch\nimport java.util.concurrent.Executors\n\ndef threadpool = Executors.newFixedThreadPool(8)\ndef latch = new CountDownLatch(1)\n\n// Using a fixed thread pool works\n//Scheduler scheduler = Schedulers.from(threadpool)\n\n// Using the computation thread pool doesn't\nScheduler scheduler = Schedulers.computation()\n\nObservable.from(1..100).flatMap {\n    Observable.just(it).subscribeOn(scheduler).map {\n        if (it == 5) {\n            println \"${Thread.currentThread().name} - Sleeping... ${it}\"\n            // simulate long work here - only on certain items\n            Thread.sleep(15_000)\n            println \"${Thread.currentThread().name} - Done Sleeping... ${it}\"\n        }\n        return it\n    }\n}.subscribe ({\n    println \"${Thread.currentThread().name} - Got a num: ${it}\"\n}, {\n    println \"Error\"\n    it.printStackTrace()\n    threadpool.shutdown()\n    latch.countDown()\n}, {\n    println 'Complete'\n    threadpool.shutdown()\n    latch.countDown()\n})\nlatch.await()\n```\n"
    },
    "satisfaction_conditions": [
      "Preserves sequential processing guarantees within each stream"
    ],
    "created_at": "2016-01-07T16:02:33Z"
  },
  {
    "id": "https://github.com/ReactiveX/RxJava/issues/3598",
    "source": {
      "issue_number": 3598
    },
    "initial_question": {
      "title": "BehaviorSubject deadlocks when using subject.single().toBlocking().single()",
      "body": "When I use `.single().toBlocking().single()` on a `BehaviorSubject` (where a default item has been set), it will deadlock the following test. When `.take(1).toBlocking().single()` is used, the test completes successfully.\n\n``` java\nSystem.out.println(\"take(1) started\");\nBehaviorSubject.create(\"Item\").take(1).toBlocking().single();\nSystem.out.println(\"take(1) finished\");\n\nSystem.out.println(\"single() started\");\nBehaviorSubject.create(\"Item\").single().toBlocking().single(); // Deadlocks here\nSystem.out.println(\"single() finished\");\n```\n\nAm I doing something wrong here?\n"
    },
    "satisfaction_conditions": [
      "Observable must receive both an element and a completion signal",
      "Sequence termination behavior must be predictable and documented"
    ],
    "created_at": "2016-01-05T00:31:43Z"
  },
  {
    "id": "https://github.com/ReactiveX/RxJava/issues/3557",
    "source": {
      "issue_number": 3557
    },
    "initial_question": {
      "title": "onErrorResumeNext/OperatorOnErrorResumeNextViaFunction ignoring unsubscription?",
      "body": "I first wanted to ask, just in case, to check if the behavior I'm going to describe is the expected.\n\nIt happens that using the operator `OperatorOnErrorResumeNextViaFunction` seems to ignore the **unsubscription** event.\n\nI had this code for testing it.\n\n``` java\n        final AtomicBoolean readyToUnsubscribe = new AtomicBoolean(false);\n        final AtomicBoolean readyToFail = new AtomicBoolean(false);\n        final ReentrantLock lock = new ReentrantLock();\n        final Condition rtuCond = lock.newCondition();\n        final Condition rtfCond = lock.newCondition();\n\n\n        Subscription subscribe = Observable.create(\n                new Observable.OnSubscribe<String>() {\n                    @Override\n                    public void call(Subscriber<? super String> subscriber) {\n                        lock.lock();\n                        System.out.println(\"Subscription started: \" + !subscriber.isUnsubscribed());\n                        readyToUnsubscribe.set(true);\n                        rtuCond.signal();\n                        try {\n                            while (!readyToFail.get()) {\n                                rtfCond.await();\n                            }\n                        } catch (InterruptedException e) {\n                            Exceptions.throwIfFatal(e);\n                        } finally {\n                            lock.unlock();\n                        }\n                        System.out.println(\"Gonna fail\");\n                        throw new RuntimeException(\"Yup Crashing Bad!\");\n                    }\n                }\n        )\n                .onErrorResumeNext(\n                        new Func1<Throwable, Observable<? extends String>>() {\n                            @Override\n                            public Observable<? extends String> call(Throwable throwable) {\n                                return Observable.just(\"Recovered from: \" + throwable.getMessage());\n                            }\n                        }\n                )\n                .subscribeOn(Schedulers.io())\n                .subscribe(\n                        new Action1<String>() {\n                            @Override\n                            public void call(String s) {\n                                System.out.println(\"Got message: \" + s);\n                            }\n                        },\n                        new Action1<Throwable>() {\n                            @Override\n                            public void call(Throwable throwable) {\n                                throwable.printStackTrace(System.err);\n                            }\n                        },\n                        new Action0() {\n                            @Override\n                            public void call() {\n                                System.out.println(\"Completed\");\n                            }\n                        }\n                );\n\n        lock.lock();\n        while (!readyToUnsubscribe.get()) {\n            rtuCond.await();\n        }\n        subscribe.unsubscribe();\n        System.out.println(\"Now this is unsubscribed\");\n        readyToFail.set(false);\n        rtfCond.signal();\n        lock.unlock();\n```\n\nWhich gives the output\n\n```\nSubscription started: true\nNow this is unsubscribed\nGonna fail\nGot message: Recovered from: Yup Crashing Bad!\nCompleted\n```\n\nAnd I would have expected none of the Obsever's methods to be called indeed, that is last two lines of output should't be there. But this is my understanding, can somebody confirm if this should be considered a bug, or is it expected behavior of the onErrorResumeNext operator?\n"
    },
    "satisfaction_conditions": [
      "Observable chain's terminal behavior must be predictable"
    ],
    "created_at": "2015-12-04T09:45:35Z"
  },
  {
    "id": "https://github.com/ReactiveX/RxJava/issues/3554",
    "source": {
      "issue_number": 3554
    },
    "initial_question": {
      "title": "Observable.combineLatest ignores onCompleted?",
      "body": "Hello. This is the code:\n\n``` java\nimport rx.Observable;\nimport rx.subjects.PublishSubject;\n\nfinal class OnNextIngored {\n\n   public static void main(final String[] args) {\n\n      final PublishSubject<Integer> publisher = PublishSubject.create();\n\n      // pass any arg to fail the day!\n      final boolean doFail = args.length != 0;\n\n      final Observable<Integer> possiblyFail\n         = Observable.<Integer>create(subscriber\n                                      -> {\n\n                                         if (doFail) {\n                                            subscriber.onError(new RuntimeException(\"blah\"));\n                                         } else {\n                                            subscriber.onNext(2);\n                                            subscriber.onCompleted();\n                                         }\n                                      });\n\n      publisher\n         .startWith(// combine latest ignores onCompleted ?\n                    Observable.combineLatest(possiblyFail ,\n                                             Observable.just(1),\n                                             (l, r) -> r + l)\n                    .take(2))\n         .onErrorResumeNext(Observable.just(4))\n         .subscribe(i -> {\n               log(\"i is: \" + i);\n            },\n            e -> {\n               log(\"error is: \" + e);\n            },\n            () -> {\n               log(\"completed\");\n            } );\n\n      publisher.onNext(5);\n      publisher.onNext( 6 );\n      publisher.onNext(7);\n   }\n\n   private static void log(final String s) {\n      System.out.println(s);\n   }\n}\n```\n\nDepending on value of doFail (which can be changed by passing arg to test app) the conveyor receives or does not receive onCompleted and thus it does or does not ignore onNext:\n\n```\n[elk@qulix-elktop java-rxjava]$ java -cp rxjava-1.0.16.jar:. OnNextIngored 4\ni is: 4\ncompleted\n[elk@qulix-elktop java-rxjava]$ java -cp rxjava-1.0.16.jar:. OnNextIngored \ni is: 3\ni is: 5\ni is: 6\ni is: 7\n```\n\nIs it expected behavior? If yes, why?\n"
    },
    "satisfaction_conditions": [
      "Observable chain must properly handle completion signals based on error state",
      "Observable chain must process subsequent values after initialization",
      "Error handling must result in expected completion behavior"
    ],
    "created_at": "2015-12-03T07:23:10Z"
  },
  {
    "id": "https://github.com/ReactiveX/RxJava/issues/3541",
    "source": {
      "issue_number": 3541
    },
    "initial_question": {
      "title": "Recommended way of applying operators to items in sequence of collections?",
      "body": "When I want to transform the items in collections emitted in a stream, I find myself doing something like this:\n\n``` java\nObservable<List<Integer>> integerLists = \u2026\n// Emits [1, 2, 3], [4, 5, 6]\n\nintegerLists.concatMap(list -> Observable.from(list).map(x -> x * 2).toList())\n// Emits  [2, 4, 6], [8, 10,12]\n```\n\nIs there are cleaner/recommended way to achieve the same that doesn't require the 'Observable.from \u2026 toList' bit?\n"
    },
    "satisfaction_conditions": [
      "Each list in the sequence must be transformed while maintaining list structure",
      "Elements within each list must be individually transformed",
      "Original collections must remain unmodified",
      "Order of elements within each list must be preserved",
      "Sequence order of collections must be maintained"
    ],
    "created_at": "2015-11-26T12:11:41Z"
  },
  {
    "id": "https://github.com/ReactiveX/RxJava/issues/3522",
    "source": {
      "issue_number": 3522
    },
    "initial_question": {
      "title": "Why does the scan operator only emit the initialValue when receiving the first value from the observable (or on completion)?",
      "body": "Hello, I am wondering why the scan() method with an initialValue only emits the initialValue when the first value from the observable arrives. I had expected this to happen instantly upon subscription. \n\nFor now, I worked around this issue by NOT providing an initialValue, and adding \".startWith()\" to the observable I am scanning. \n\nIn the `OperatorScan` class:\n\n``` java\n\n        return new Subscriber<T>(child) {\n            ...\n\n            @Override\n            public void onNext(T currentValue) {\n                emitInitialValueIfNeeded(child);\n                ...\n                child.onNext(this.value);\n            }\n\n            @Override\n            public void onError(Throwable e) {\n                child.onError(e);\n            }\n\n            @Override\n            public void onCompleted() {\n                emitInitialValueIfNeeded(child);\n                child.onCompleted();\n            }\n        }\n```\n\nExample scenario: scan an observable that counts from 0 to 4, emitting a number every second.\n\n``` java\nObservable\n    .create(new Observable.OnSubscribe<Integer>() {\n        @Override\n        public void call(Subscriber<? super Integer> subscriber) {\n            for (int i = 0; i < 5; i++) {\n                try {\n                    Thread.sleep(1000);\n                } catch (InterruptedException e) {\n                    subscriber.onError(e);\n                }\n                subscriber.onNext(i);\n            }\n            subscriber.onCompleted();\n        }\n    })\n    .scan(0, new Func2<Integer, Integer, Integer>() {\n        @Override\n        public Integer call(Integer sum, Integer nextNumber) {\n            return sum + nextNumber;\n        }\n    })\n```\n\nThe timeline of this observable would be:\n\n0ms : subscribe()\n1000ms: 0 <- the initial value\n1001ms: 0 <- the acummulated result of 0 + the initial value\n2000ms: 1 <- the accumulated result of 1 + 0\n3000ms: 3 <- the accumulated result of 2 + 1\n4000ms: 6 <- the accumulated result of 3 + 2\n5000ms: 10 <- the accumulated result of 4 + 6\n\nMy question is: why does this happen lazily. Why not immediately call `child.onNext(initialValue)` when the subscription starts? Why does the given example not produce value 0 at 1 ms? \n\nThank you in advance.\n"
    },
    "satisfaction_conditions": [
      "Subsequent emissions must correctly accumulate values",
      "Library version must handle initial values correctly"
    ],
    "created_at": "2015-11-13T14:20:11Z"
  },
  {
    "id": "https://github.com/ReactiveX/RxJava/issues/3494",
    "source": {
      "issue_number": 3494
    },
    "initial_question": {
      "title": "switchIfEmpty() causes \"more items arrived than were requested\" in bizarre case",
      "body": "This is the simplest reproduction I could conjure up of this problem:\n\n``` java\n    Observable.just(1)\n        .flatMap(n -> {\n          return Observable.just(null, null)\n              .filter(o -> o != null)\n              .switchIfEmpty(Observable.empty().switchIfEmpty(Observable.just(\"Hello\")));\n        })\n        .subscribe(System.out::println);\n```\n\nThis will spit out `onError` with the error message \"more items arrived than were requested\".\n\nThis appears to be a regression. It works on RxJava 1.0.11 but fails on every version since then (including 1.0.15, the latest).\n\nAdding in a `take(1)` seems to fix the problem (as a workaround).\n\nFor completeness, here is the exception:\n\n```\nException in thread \"main\" rx.exceptions.OnErrorNotImplementedException: more items arrived than were requested\n    at rx.Observable$27.onError(Observable.java:7996)\n    at rx.observers.SafeSubscriber._onError(SafeSubscriber.java:158)\n    at rx.observers.SafeSubscriber.onError(SafeSubscriber.java:119)\n    at rx.internal.util.ScalarSynchronousObservable$2$1.onError(ScalarSynchronousObservable.java:140)\n    at rx.internal.operators.OperatorSwitchIfEmpty$AlternateSubscriber.onError(OperatorSwitchIfEmpty.java:116)\n    at rx.internal.operators.OperatorSwitchIfEmpty$AlternateSubscriber.onError(OperatorSwitchIfEmpty.java:116)\n    at rx.Observable.unsafeSubscribe(Observable.java:8178)\n    at rx.internal.operators.OperatorSwitchIfEmpty$ParentSubscriber.subscribeToAlternate(OperatorSwitchIfEmpty.java:78)\n    at rx.internal.operators.OperatorSwitchIfEmpty$ParentSubscriber.onCompleted(OperatorSwitchIfEmpty.java:71)\n    at rx.Observable$EmptyHolder$1.call(Observable.java:1073)\n    at rx.Observable$EmptyHolder$1.call(Observable.java:1070)\n    at rx.Observable$2.call(Observable.java:162)\n    at rx.Observable$2.call(Observable.java:154)\n    at rx.Observable.unsafeSubscribe(Observable.java:8171)\n    at rx.internal.operators.OperatorSwitchIfEmpty$ParentSubscriber.subscribeToAlternate(OperatorSwitchIfEmpty.java:78)\n    at rx.internal.operators.OperatorSwitchIfEmpty$ParentSubscriber.onCompleted(OperatorSwitchIfEmpty.java:71)\n    at rx.internal.operators.OperatorFilter$1.onCompleted(OperatorFilter.java:42)\n    at rx.internal.operators.OnSubscribeFromIterable$IterableProducer.fastpath(OnSubscribeFromIterable.java:129)\n    at rx.internal.operators.OnSubscribeFromIterable$IterableProducer.request(OnSubscribeFromIterable.java:70)\n    at rx.internal.producers.ProducerArbiter.setProducer(ProducerArbiter.java:126)\n    at rx.internal.operators.OperatorSwitchIfEmpty$ParentSubscriber.setProducer(OperatorSwitchIfEmpty.java:63)\n    at rx.Subscriber.setProducer(Subscriber.java:205)\n    at rx.internal.operators.OnSubscribeFromIterable.call(OnSubscribeFromIterable.java:49)\n    at rx.internal.operators.OnSubscribeFromIterable.call(OnSubscribeFromIterable.java:32)\n    at rx.Observable$2.call(Observable.java:162)\n    at rx.Observable$2.call(Observable.java:154)\n    at rx.Observable$2.call(Observable.java:162)\n    at rx.Observable$2.call(Observable.java:154)\n    at rx.Observable.unsafeSubscribe(Observable.java:8171)\n    at rx.internal.util.ScalarSynchronousObservable$2.call(ScalarSynchronousObservable.java:133)\n    at rx.internal.util.ScalarSynchronousObservable$2.call(ScalarSynchronousObservable.java:125)\n    at rx.Observable.subscribe(Observable.java:8266)\n    at rx.Observable.subscribe(Observable.java:8233)\n    at rx.Observable.subscribe(Observable.java:7987)\n    at net.danlew.experiments.Tester.main(Tester.java:40)\n    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n    at java.lang.reflect.Method.invoke(Method.java:483)\n    at com.intellij.rt.execution.application.AppMain.main(AppMain.java:140)\nCaused by: java.lang.IllegalStateException: more items arrived than were requested\n    at rx.internal.producers.ProducerArbiter.produced(ProducerArbiter.java:98)\n    at rx.internal.operators.OperatorSwitchIfEmpty$AlternateSubscriber.onNext(OperatorSwitchIfEmpty.java:122)\n    at rx.internal.util.ScalarSynchronousObservable$1.call(ScalarSynchronousObservable.java:46)\n    at rx.internal.util.ScalarSynchronousObservable$1.call(ScalarSynchronousObservable.java:35)\n    at rx.Observable.unsafeSubscribe(Observable.java:8171)\n    ... 33 more\n```\n"
    },
    "satisfaction_conditions": [
      "Observable chain must handle backpressure correctly",
      "Observable chain must complete without errors"
    ],
    "created_at": "2015-11-04T17:19:06Z"
  },
  {
    "id": "https://github.com/ReactiveX/RxJava/issues/3466",
    "source": {
      "issue_number": 3466
    },
    "initial_question": {
      "title": "SwitchMap with connectable's Replay raise exception",
      "body": "For the following code:\n\n``` java\nConnectableObservable<Long> replayObs = Observable.interval(3, TimeUnit.SECONDS)\n        .startWith(-5L)\n        .switchMap(aLong -> {\n            if (aLong == 2L) {\n                return Observable.error(new NullPointerException());\n            } else {\n                return Observable.just(aLong);\n            }\n        })\n        .replay(1);\n\nreplayObs.connect(Actions.empty());\n\nreplayObs\n        .subscribe(s -> {\n            Log.wtf(\"MainActivity \", \"call \" + s);\n        }, throwable -> {\n            Log.wtf(\"MainActivity \", throwable);\n        });\n```\n\nIt emmits the following:\n\n```\nMainActivity: call -5\nMainActivity: java.lang.IllegalStateException: more items arrived than were requested\nMainActivity:     at rx.internal.producers.ProducerArbiter.produced(ProducerArbiter.java:98)\n```\n\nI realize that the `.connect` is happening before the first `.subscribe` but if I have `.flatpMap` instead, which has a different producer, it doesn't complain.\n\nThis is the simplest way to raise the exception:\n\n``` java\nConnectableObservable<Long> replayObs = Observable.just(1l)\n        .switchMap(Observable::just)\n    //  .onBackpressureBuffer(1)\n        .replay(1);\n```\n\nAdding a onBackpreassureBuffer(1) before the .replay() solves the problem. Is that a correct solution? Is that a bug in the `ProducerArbiter`?\n\n---\n\nFull stacktrace:\n\n```\njava.lang.IllegalStateException: more items arrived than were requested\n    at rx.internal.producers.ProducerArbiter.produced(ProducerArbiter.java:98)\n    at rx.internal.operators.OperatorSwitch$SwitchSubscriber.emit(OperatorSwitch.java:162)\n    at rx.internal.operators.OperatorSwitch$InnerSubscriber.onNext(OperatorSwitch.java:277)\n    at rx.internal.util.ScalarSynchronousObservable$1.call(ScalarSynchronousObservable.java:46)\n    at rx.internal.util.ScalarSynchronousObservable$1.call(ScalarSynchronousObservable.java:35)\n    at rx.Observable.unsafeSubscribe(Observable.java:7710)\n    at rx.internal.operators.OperatorSwitch$SwitchSubscriber.onNext(OperatorSwitch.java:105)\n    at rx.internal.operators.OperatorSwitch$SwitchSubscriber.onNext(OperatorSwitch.java:60)\n    at rx.internal.operators.OperatorMap$1.onNext(OperatorMap.java:55)\n    at rx.internal.util.ScalarSynchronousObservable$1.call(ScalarSynchronousObservable.java:46)\n    at rx.internal.util.ScalarSynchronousObservable$1.call(ScalarSynchronousObservable.java:35)\n    at rx.Observable$2.call(Observable.java:162)\n    at rx.Observable$2.call(Observable.java:154)\n    at rx.Observable$2.call(Observable.java:162)\n    at rx.Observable$2.call(Observable.java:154)\n    at rx.Observable.unsafeSubscribe(Observable.java:7710)\n    at rx.internal.operators.OperatorReplay.connect(OperatorReplay.java:285)\n    at com.lorentzos.rxexperiment.MainActivity.onCreate(MainActivity.java:42)\n    at android.app.Activity.performCreate(Activity.java:5990)\n    at android.app.Instrumentation.callActivityOnCreate(Instrumentation.java:1106)\n    at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:2309)\n    at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:2418)\n    at android.app.ActivityThread.access$900(ActivityThread.java:154)\n    at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1321)\n    at android.os.Handler.dispatchMessage(Handler.java:102)\n    at android.os.Looper.loop(Looper.java:135)\n    at android.app.ActivityThread.main(ActivityThread.java:5289)\n    at java.lang.reflect.Method.invoke(Native Method)\n    at java.lang.reflect.Method.invoke(Method.java:372)\n    at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:904)\n    at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:699)\n```\n"
    },
    "satisfaction_conditions": [
      "Observable chain must maintain item ordering",
      "Error handling must remain functional"
    ],
    "created_at": "2015-10-22T13:31:12Z"
  },
  {
    "id": "https://github.com/ReactiveX/RxJava/issues/3446",
    "source": {
      "issue_number": 3446
    },
    "initial_question": {
      "title": "How can I use OperatorConcat<T>?",
      "body": "I'm trying to write an operator `then<R,T>` which ignores all emissions from the source (except errors), and continues with a second Observable when completed.\n\nSomething like:\n\n```\n// Typical Case\nObservable.just(1, 2, 3, 4, 5)\n   .lift(new then<String, Integer>(Observable.just(\"Hello\")))\n   .subscribe(new Action1<String>() {\n      @Override\n      public void call(String s) {\n         // Called once with \"Hello\"\n      });\n\n// Source Errors\nObservable.<Integer>error(new RuntimeException())\n   .lift(new then<String, Integer>(Observable.just(\"Hello\")))  // <-- the second observable should never be subscribed to since the source error'd\n   .subscribe(new Action1<String>() {\n      @Override\n      public void call(String s) {\n         // Not Called\n\n      }, new Action1<Throwable>() {\n      @Override\n      public void call(Throwable e) {\n        System.out.println(\"Error: \"+e); // Should be called with the RuntimeException from above\n\n      }\n   });\n```\n\nI've come up with an implementation using `ignoreElements` + `map` + `concatWith`:\n\n```\n    public static <R, T> Observable<? extends R> then(Observable<T> source, Observable<R> other) {\n        return source\n                .ignoreElements()\n                .map(new Func1<T, R>() {\n                    @Override\n                    public R call(T integer) {\n                        return null;\n                    }\n                }).concatWith(other);\n    }\n```\n\nI'm quite new to writing custom operators, and I can't quite figure out how to translate that static function into an operator. I've written a few operators by composing the provided Operator\\* types, but I'm having trouble with this one.\n\nAny help would be greatly appreciated :)\n"
    },
    "satisfaction_conditions": [
      "Source emissions must be ignored until completion",
      "Second Observable must only be subscribed to after source completion",
      "Source errors must be propagated immediately",
      "Proper unsubscription handling must be implemented",
      "Type conversion from T to R must be supported"
    ],
    "created_at": "2015-10-14T16:31:52Z"
  },
  {
    "id": "https://github.com/ReactiveX/RxJava/issues/3431",
    "source": {
      "issue_number": 3431
    },
    "initial_question": {
      "title": "Zip$InnerSubscriber does not respect backpressure on RxRingBuffer",
      "body": "This test throws a `MissingBackpressureException` while attempting to call onNext on the internal RxRingBuffer. This can be solved by adding a `.onBackpressureDrop()` to the interval observable before zipping. \n\n``` java\nObservable<Integer> cache = Observable.range(1, 50).cache().repeat();\nObservable<Long> interval = Observable.interval(10_000, TimeUnit.NANOSECONDS);\nObservable.zip(interval, cache, (i, c) ->c).toBlocking().last();\n```\n\nStacktrace:\n\n```\nException in thread \"main\" java.lang.RuntimeException: rx.exceptions.MissingBackpressureException\n    at rx.observables.BlockingObservable.blockForSingle(BlockingObservable.java:455)\n    at rx.observables.BlockingObservable.last(BlockingObservable.java:219)\n    at wtf.WTF.main(WTF.java:31)\nCaused by: rx.exceptions.MissingBackpressureException\n    at rx.internal.util.RxRingBuffer.onNext(RxRingBuffer.java:352)\n    at rx.internal.operators.OperatorZip$Zip$InnerSubscriber.onNext(OperatorZip.java:329)\n    at rx.internal.operators.OnSubscribeTimerPeriodically$1.call(OnSubscribeTimerPeriodically.java:52)\n    at rx.Scheduler$Worker$1.call(Scheduler.java:120)\n    at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:55)\n    at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n    at java.util.concurrent.FutureTask.run(FutureTask.java:266)\n    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180)\n    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293)\n    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)\n    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\n    at java.lang.Thread.run(Thread.java:745)\n```\n"
    },
    "satisfaction_conditions": [
      "The temporal sequence of events must be preserved"
    ],
    "created_at": "2015-10-10T01:16:14Z"
  },
  {
    "id": "https://github.com/ReactiveX/RxJava/issues/3379",
    "source": {
      "issue_number": 3379
    },
    "initial_question": {
      "title": "OnSubscribeCombineLatest#MultiSourceProducer#collectedValues leaks?",
      "body": "It looks to me that it should be cleared when the child `subscriber` is unsubscribed.\n\nThe issue is that when I keep a subscription this automatically mean that I will keep a reference to the latest emitted value even if the subscription is unsubscribed. This prevents us from using `combineLatest` on memory-heavy objects.\n"
    },
    "satisfaction_conditions": [
      "Subscription cleanup must be thread-safe",
      "Subscription cleanup must occur automatically on unsubscription",
      "Solution must maintain RxJava chain integrity",
      "References to subscribers must be properly managed"
    ],
    "created_at": "2015-09-27T18:17:22Z"
  },
  {
    "id": "https://github.com/ReactiveX/RxJava/issues/3344",
    "source": {
      "issue_number": 3344
    },
    "initial_question": {
      "title": "subscribe vs unsafeSubscribe",
      "body": "What's the difference between `subscribe` and `unsafeSubscribe`?\n\nThe javadoc mentions that `unsafeSubscribe` should only be used for `Observable.Operator`, I'm assuming that includes `Observable.OnSubscribe`. Also, it briefly mentions nested subscriptions but it doesn't explain the difference in behavior of `subscribe` and `unsafeSubscribe`.\n\nAlso, is there guidance on when `Subscribers.wrap` should be used?\n\nHere's a snippet that I thought would behave the same, however `unsafeSubscribe` is working and `subscribe` is timing out.\n\n``` java\n  public static Observable<Long> foo() {\n    return Observable.create(subscriber -> {\n      Observable.timer(1, TimeUnit.MILLISECONDS)\n          .unsafeSubscribe(Subscribers.wrap(subscriber));\n    });\n  }\n\n  public static Observable<Long> foo2() {\n    return Observable.create(subscriber -> {\n      Observable.timer(1, TimeUnit.MILLISECONDS)\n          .subscribe(Subscribers.wrap(subscriber));\n    });\n  }\n\n  public static void main(String[] args) {\n    long result = foo().flatMap(value -> foo())\n        .timeout(1, TimeUnit.SECONDS)\n        .toBlocking().single();\n    System.out.println(\"result = \" + result);\n\n\n    long result2 = foo2().flatMap(value -> foo2())\n        .timeout(1, TimeUnit.SECONDS)\n        .toBlocking().single();\n    System.out.println(\"result2 = \" + result2);\n  }\n```\n\n```\nresult = 0\nException in thread \"main\" java.lang.RuntimeException: java.util.concurrent.TimeoutException\n    at rx.observables.BlockingObservable.blockForSingle(BlockingObservable.java:455)\n    at rx.observables.BlockingObservable.single(BlockingObservable.java:331)\n    at Foo.main(Foo.java:39)\n    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n    at java.lang.reflect.Method.invoke(Method.java:483)\n    at com.intellij.rt.execution.application.AppMain.main(AppMain.java:140)\nCaused by: java.util.concurrent.TimeoutException\n    at rx.internal.operators.OperatorTimeoutBase$TimeoutSubscriber.onTimeout(OperatorTimeoutBase.java:169)\n    at rx.internal.operators.OperatorTimeout$1$1.call(OperatorTimeout.java:42)\n    at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:55)\n    at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n    at java.util.concurrent.FutureTask.run(FutureTask.java:266)\n    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180)\n    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293)\n    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)\n    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\n    at java.lang.Thread.run(Thread.java:745)\n```\n"
    },
    "satisfaction_conditions": [
      "The code must handle subscriber lifecycle management correctly",
      "Exception handling must be appropriately implemented",
      "Terminal events must be properly propagated",
      "Performance overhead considerations must be documented"
    ],
    "created_at": "2015-09-14T15:56:04Z"
  },
  {
    "id": "https://github.com/ReactiveX/RxJava/issues/3343",
    "source": {
      "issue_number": 3343
    },
    "initial_question": {
      "title": " Equivalent with CompletableFuture.complete",
      "body": "Hi,\nDose Rxjava Observable has equivalent with CompletableFuture.complete?\nlike: CompletableFuture future=new CompletableFuture();\n       ...do  something...\n       future.complete(xxx)\n"
    },
    "satisfaction_conditions": [
      "Provides a mechanism to create an asynchronous operation that can be completed later",
      "Supports explicit completion signaling",
      "Maintains RxJava's observable pattern",
      "Allows intermediate processing before completion"
    ],
    "created_at": "2015-09-14T06:10:07Z"
  },
  {
    "id": "https://github.com/ReactiveX/RxJava/issues/3338",
    "source": {
      "issue_number": 3338
    },
    "initial_question": {
      "title": "Should withLatestFrom behave like zip in terms of buffering?",
      "body": "I've just picked up withLatestFrom and I expected it to behave a bit like zip in terms of buffering source1 until source2 initially emits.  Am I missing something?  Is there something in the pipeline (for what I appreciate is an experimental operator) or could/ should it be enhanced to behave more like zip?\n\nUsing 1.0.13\n\nExamples of both below:\n# Zip Example Test\n\n```\n        testScenario\n                .given()\n                .theStreamUnderTest((s1, s2) -> s1.zipWith(s2, (z, n) -> z + n))\n\n                .when()\n                .theSubscriber().subscribes()\n                .source1().emits(\"a\")\n                .source1().emits(\"b\")\n                .source1().emits(\"c\")\n                .source2().emits(1)\n                .source2().emits(2)\n                .source2().emits(3)\n                .source1().completes()\n\n                .then()\n                .theSubscribers()\n                .renderedStream().isEqualTo(\"[a1]-[b2]-[c3]-|\");\n\n```\n# WithLatestFrom Test\n\n```\n       testScenario\n                .given()\n                .theStreamUnderTest((s1, s2) -> s1.withLatestFrom(s2, (z, n) -> z + n))\n                .theRenderer(s -> s)\n\n                .when()\n                .theSubscriber().subscribes()\n                .source1().emits(\"a\")\n                .source2().emits(1)\n                .source1().emits(\"b\")\n                .source2().emits(2)\n                .source1().emits(\"c\")\n                .source1().completes()\n\n                .then()\n                .theSubscribers()\n                .renderedStream().isEqualTo(\"[a1]-[b1]-[c2]-|\");\n```\n\nActually emits [b1]-[c2]-|\n"
    },
    "satisfaction_conditions": [
      "Initial emissions from source1 before source2's first emission must be ignored",
      "Output must combine source1 values with the most recent value from source2",
      "Emissions must only occur when source1 emits (after source2's first emission)",
      "The solution must maintain consistency with combineLatest behavior regarding initial values"
    ],
    "created_at": "2015-09-11T08:44:00Z"
  },
  {
    "id": "https://github.com/ReactiveX/RxJava/issues/3187",
    "source": {
      "issue_number": 3187
    },
    "initial_question": {
      "title": "MissingBackpressureException when not using Backpressure",
      "body": "Hey, I'm seeing a crash on my Android app but I'm not sure exactly what's causing the crash (Exception included at the bottom). We don't use or request backpressure anywhere in our app. This is on RxJava `1.0.13`. My only thought would be that maybe some other RX operator is doing this.\n\nFor instance, we have a zip operator:\n\n``` Java\nObservable.zip(\n        new ObservableThatRunsInThread1(),\n        new ObservableThatRunsInThread2(),\n        new ObservableThatRunsInThread3(),\n        new ObservableThatRunsInThread4(),\n        new Func4<Object, Object, Object, Object, Response>() {\n            @Override public Response call(Object o1, Object o2, Object o3, Object o4) {\n                return new Response(o1, o2, o3, o4);\n            }\n        }\n);\n```\n\nCould the multiple threads possibly be causing a race condition, or something of the sort? I'm a bit stuck at this point. Thanks!\n\n``` Java\njava.lang.IllegalStateException: Exception thrown on Scheduler.Worker thread. Add `onError` handling.\n       at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:60)\n       at android.os.Handler.handleCallback(Handler.java:739)\n       at android.os.Handler.dispatchMessage(Handler.java:95)\n       at android.os.Looper.loop(Looper.java:145)\n       at android.app.ActivityThread.main(ActivityThread.java:5835)\n       at java.lang.reflect.Method.invoke(Method.java)\n       at java.lang.reflect.Method.invoke(Method.java:372)\n       at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:1399)\n       at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:1194)\nCaused by: rx.exceptions.OnErrorNotImplementedException\n       at rx.Observable$30.onError(Observable.java:7540)\n       at rx.observers.SafeSubscriber._onError(SafeSubscriber.java:154)\n       at rx.observers.SafeSubscriber.onError(SafeSubscriber.java:111)\n       at rx.internal.operators.OperatorObserveOn$ObserveOnSubscriber.pollQueue(OperatorObserveOn.java:197)\n       at rx.internal.operators.OperatorObserveOn$ObserveOnSubscriber$2.call(OperatorObserveOn.java:170)\n       at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:55)\n       at android.os.Handler.handleCallback(Handler.java:739)\n       at android.os.Handler.dispatchMessage(Handler.java:95)\n       at android.os.Looper.loop(Looper.java:145)\n       at android.app.ActivityThread.main(ActivityThread.java:5835)\n       at java.lang.reflect.Method.invoke(Method.java)\n       at java.lang.reflect.Method.invoke(Method.java:372)\n       at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:1399)\n       at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:1194)\nCaused by: rx.exceptions.MissingBackpressureException\n       at rx.internal.operators.OperatorObserveOn$ObserveOnSubscriber.onNext(OperatorObserveOn.java:138)\n       at rx.internal.operators.OnSubscribeTimerPeriodically$1.call(OnSubscribeTimerPeriodically.java:51)\n       at rx.Scheduler$Worker$1.call(Scheduler.java:120)\n       at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:55)\n       at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:422)\n       at java.util.concurrent.FutureTask.run(FutureTask.java:237)\n       at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:152)\n       at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:265)\n       at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1112)\n       at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:587)\n       at java.lang.Thread.run(Thread.java:818)\n```\n"
    },
    "satisfaction_conditions": [
      "Backpressure handling must be implemented for periodic timer operations",
      "Application must not crash with MissingBackpressureException",
      "Backpressure strategy must be applied before observeOn operator",
      "Observable chain must maintain expected functionality while handling overflow"
    ],
    "created_at": "2015-08-25T16:07:45Z"
  },
  {
    "id": "https://github.com/ReactiveX/RxJava/issues/3146",
    "source": {
      "issue_number": 3146
    },
    "initial_question": {
      "title": "OnSubscribeCombineLatest MultiSourceProducer request method",
      "body": "Why is the AtomicBolean started get and compareAndSet methods both called in the if statement on line 114 of the OnSubscribeCombineLatest class?\n\nif (!started.get() && started.compareAndSet(false, true)) \n\nIs compareAndSet alone not good enough?\n"
    },
    "satisfaction_conditions": [
      "The code must optimize performance for frequent access patterns",
      "The thread-safe state change from false to true must occur exactly once",
      "The performance optimization must be measurable in high-frequency scenarios",
      "The solution must maintain thread-safety guarantees"
    ],
    "created_at": "2015-08-10T21:06:54Z"
  },
  {
    "id": "https://github.com/ReactiveX/RxJava/issues/2958",
    "source": {
      "issue_number": 2958
    },
    "initial_question": {
      "title": "Backpressure and \"nested Observables\"",
      "body": "Hi,\n\nI encountered a behavior with Backpressure that I found weird.\nHere is a working example (in Groovy) with backpressure : \n\n```\nrx.Observable.from([1, 2, 3, 4])\n    .flatMap({ rx.Observable.just(it+1) })\n    .delay(2, java.util.concurrent.TimeUnit.SECONDS)\n    .subscribe(new rx.Subscriber<Integer>() {\n      public void onStart() {\n        request(2);\n      }\n      public void onNext(Integer t) {\n        println(t)\n        request(1);\n      }\n      public void onCompleted() { }\n      public void onError(Throwable e) { }\n    });\n\n// Prints : \n2\n3 //waits 2 seconds here\n4\n5\n```\n\nLet's apply `delay` directly on the Observable into the `flatMap` Operator : \n\n```\nrx.Observable.from([1, 2, 3, 4])\n    .flatMap({rx.Observable.just(it+1).delay(2, java.util.concurrent.TimeUnit.SECONDS)})\n    .subscribe(new rx.Subscriber<Integer>() {\n      public void onStart() {\n        request(2);\n      }\n      public void onNext(Integer t) {\n        println(t)\n        request(1);\n      }\n      public void onCompleted() { }\n      public void onError(Throwable e) { }\n    });\n\n// Prints : \n// waits 2 seconds\n2\n5\n4\n3// In a random order\n```\n\nI can't see why the second one is not acting like the first, printing 2 results, waiting 2 seconds before printing 2 other ones.\nIs this the normal behavior? Why? How should I do to achieve such a thing?\n\nThanks a lot for your hard work and this amazing library ;)\n"
    },
    "satisfaction_conditions": [
      "Processing order must be predictable when delay is applied to the entire stream",
      "Time intervals between emissions must reflect the specified delay duration"
    ],
    "created_at": "2015-05-17T09:09:30Z"
  },
  {
    "id": "https://github.com/ReactiveX/RxJava/issues/2947",
    "source": {
      "issue_number": 2947
    },
    "initial_question": {
      "title": "TestObserver thread-safety",
      "body": "Disclaimer: I understand, that `TestObserver` and `TestSubscriber` were made for Unit testing purposes, but they are pretty convenient because you can record received notifications and emissions, make assertions and so on, so we used them it in our Integration test and faced problem with thread-safety of `TestObserver`.\n\nThe problem is that `TestObserver` uses `ArrayList` to store notifications and received items, in case of multi-threaded `Observable` `ArrayList` may be corrupted and tests can fail randomly.\n\nWhat do you think about using thread-safe list implementation in `TestObserver`? It should not break public API. I can prepare PR for that.\n"
    },
    "satisfaction_conditions": [
      "Observer receives notifications without data corruption",
      "Observable's single-threaded contract is maintained",
      "Test observations remain accurate and consistent",
      "Performance impact is minimized",
      "Concurrent emissions are properly handled"
    ],
    "created_at": "2015-05-14T01:18:16Z"
  },
  {
    "id": "https://github.com/ReactiveX/RxJava/issues/2608",
    "source": {
      "issue_number": 2608
    },
    "initial_question": {
      "title": "Run two observables sequentially, using result from first observable in second observable (question)",
      "body": "I'm probably overlooking something basic (sorry for that), this seems like it should be easy to do.\n\nI have an Identifier class:\n\n```\nclass Identifier {\n    int id;\n    String value;\n    Ticket[] tickets;\n\n    void setTickets(Ticket[] tickets) { this.tickets = tickets; }\n}\n```\n\nAnd two separate API calls, (1) one for retrieving an identifier based on the identifier value (not the id), and (2) one for retrieving the tickets for an identifier using the identifier id:\n1. `Observable<Identifier> getIdentifier(String identifierValue);`\n2. `Observable<Ticket[]> getTickets(int identifierId);`\n\nI want to create a method with the following signature:\n`Observable<Identifier> getIdentifierWithTickets(String identifierValue);`\n\nthat combines the two observables to create an `Observable<Identifier>` that:\n1. Retrieves the identifier based on the identifierValue.\n2. Retrieves the tickets for that identifier and assigns them to that identifier.\n\nI've tried several operators but I can't find the right one. The `zipWith` operator runs the two observables in parallel so that didn't work. I can perhaps use `flatMap` but then I have to create a new observable that transforms `Observable<Ticket[]>` into `Observable<Identifier>`.\n\nLike I said, I feel that I'm missing something very basic here, anyone please help.\n"
    },
    "satisfaction_conditions": [
      "Sequential execution of API calls must be guaranteed",
      "Data from both API calls must be combined into a single Identifier object",
      "Method must return an Observable<Identifier> type",
      "Original Identifier object's state must be preserved while adding tickets"
    ],
    "created_at": "2015-02-05T10:47:15Z"
  },
  {
    "id": "https://github.com/ReactiveX/RxJava/issues/2597",
    "source": {
      "issue_number": 2597
    },
    "initial_question": {
      "title": "scan with retry",
      "body": "Hi, let's say for example I have this code:\n\n``` java\nObservable.range(1,100)\n        .scan(1, (p, i) -> {\n            if (i == 10 && start) {\n                start = false;\n                throw OnErrorThrowable.from(new Exception(\"wow\"));\n            }\n            return p * i;\n        })\n        .retry()\n        .doOnNext(System.out::println)\n        .subscribe();\n```\n\nIts output is:\n\n```\n1\n1\n2\n6\n24\n120\n720\n5040\n40320\n362880\n362880\n1\n1\n2\n6\n24\n120\n720\n5040\n40320\n362880\n3628800\n39916800\n479001600\n1932053504\n...\n```\n\nI want the `retry` operator to cause the observable to start from where it stopped (10 in this case). Is there a way to do this purely, without saving the state etc.?\n"
    },
    "satisfaction_conditions": [
      "Observable stream must continue processing after error events",
      "Error events must be observable/reportable",
      "Normal event processing must continue uninterrupted for non-error events"
    ],
    "created_at": "2015-02-04T09:33:07Z"
  },
  {
    "id": "https://github.com/ReactiveX/RxJava/issues/2525",
    "source": {
      "issue_number": 2525
    },
    "initial_question": {
      "title": "How to stop observable execution",
      "body": "Hi,\n\nI have some set of observable which I am executing in parallel. I need to get the value of observable who is completing first. If the return value meets my requirement then i need to stop the execution of other observables. I couldn't find the example for that. \n\nI could do this scenario through Callable interface and CompletionService interface from concurrent package.\n\nsample code using concurrent package\n\n```\n@Autowired\nprivate CompletionService<Result> cService;\n\nList<Future<Result>> statusList = new ArrayList<Future<Result>>();\ntry{\nfor(String str: strLst){\n        statusList.add(cService.submit(new GetItemOnCallable(msg)));\n    }\n\n    for(int i =0; i < statusList.size(); i++){\n        Result status = cService.take().get();\n        if(null != status){\n         if(staus.equals(Result.SUCCESS))\n         break;\n    }\n}finally{\nfor(Future<Result> statusFuture: statusList){\n    statusFuture.cancel(true);\n}\n}\n```\n\nIs there any way to achieve this using observable?\nCan someone please help on this.\n\nRegards\nPranesh\n"
    },
    "satisfaction_conditions": [
      "First matching result must be retrieved from parallel operations",
      "Remaining operations must be cancelled after finding a match",
      "System must handle cases where no results match criteria",
      "Operations must execute concurrently",
      "Results must be filterable based on custom criteria"
    ],
    "created_at": "2015-01-23T18:45:15Z"
  },
  {
    "id": "https://github.com/ReactiveX/RxJava/issues/1636",
    "source": {
      "issue_number": 1636
    },
    "initial_question": {
      "title": "How to properly terminal Observable sequences",
      "body": "``` java\nObservable<Boolean> obs1;\nObservable<Boolean> obs2;\n\nresult = obs1\n.flatmap(value -> {\n   if (value) {\n      // terminate result observable\n      // the only way i see right now is to do\n      BehaviorSubject<Boolean> terminator = BehaviorSubject.create();\n      terminator.onNext(new TerminateException());\n      return terminator;\n   } else {\n       return obs2;\n   }\n});\n\n```\n"
    },
    "satisfaction_conditions": [
      "Observable sequence terminates when specified condition is met",
      "Downstream operators continue to function as expected after termination",
      "Termination state is clearly communicated",
      "Maintains proper Observable chain composition",
      "Avoids unnecessary complexity"
    ],
    "created_at": "2014-08-27T21:59:04Z"
  },
  {
    "id": "https://github.com/ReactiveX/RxJava/issues/1539",
    "source": {
      "issue_number": 1539
    },
    "initial_question": {
      "title": "Need help with composition of several observables.",
      "body": "``` java\nObservable<String> observable1;\nObservable<Boolean> observable2;\nObservable<Void> observable3;\n```\n\nI need to to create observable3 that will produce values on every change of observable1 when observable2 last value is True.\n\nWill appreciate any help.\n\n(By the way, I'm using Java 6.)\n"
    },
    "satisfaction_conditions": [
      "Observable3 must emit values only when Observable2's most recent value is true",
      "Observable3 must respond to value changes from Observable1",
      "Observable3 must maintain proper subscription to both source observables"
    ],
    "created_at": "2014-08-01T02:38:04Z"
  }
]