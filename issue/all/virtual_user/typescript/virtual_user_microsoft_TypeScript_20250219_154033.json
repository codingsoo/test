[
  {
    "id": "https://github.com/microsoft/TypeScript/issues/60535",
    "source": {
      "issue_number": 60535
    },
    "initial_question": {
      "title": "language services: If tsconfig.json under the ConguredProject project ignores some files, such as d.ts, opening these d.ts will create a new InferredProject. Is it designed like this?",
      "body": "### \ud83d\udd0e Search Terms\n\nIf tsconfig.json under the ConguredProject project ignores some files, such as d.ts, opening these d.ts will create a new InferredProject. Is it designed like this?\n\n### \ud83d\udd57 Version & Regression Information\n\nversion: 5.6.3\n\n### \u23ef Playground Link\n\n_No response_\n\n### \ud83d\udcbb Code\n\n```ts\n// Your code here\n```\n\n\n### \ud83d\ude41 Actual behavior\n\nThe two project paths are the same, but the ProjectKind is different\n\n### \ud83d\ude42 Expected behavior\n\nExpect not to create a new project\n\n### Additional information about the issue\n\n_No response_"
    },
    "satisfaction_conditions": [
      "Files excluded from tsconfig.json must be handled in a separate project context",
      "Opening excluded .d.ts files must result in a functional TypeScript editing experience",
      "The type system must maintain separation between configured project files and excluded files"
    ],
    "created_at": "2024-11-19T06:35:16Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/57789",
    "source": {
      "issue_number": 57789
    },
    "initial_question": {
      "title": "TypeScript only find types",
      "body": "### \ud83d\udd0e Search Terms\n\nTS18042, TS2693, import, exports, types\n\n### \ud83d\udd57 Version & Regression Information\n\n- This is the behavior in every version I tried (_5.4.2_ and _5.0.2_), and I reviewed the FAQ for entries about _exports_.\n\n### \u23ef Playground Link\n\n_No response_\n\n### \ud83d\udcbb Code\n\n- `package.json`\r\n\r\n  ```JSON\r\n  {\r\n    \"name\": \"testcase\",\r\n    \"version\": \"1.0.0\",\r\n    \"type\": \"module\",\r\n    \"dependencies\": {\r\n      \"subproject\": \"./subproject/\",\r\n      \"typescript\": \"5.4.2\"\r\n    }\r\n  }\r\n  ```\r\n\r\n- `index.js`\r\n\r\n  ```JavaScript\r\n  import sub from \"subproject\";\r\n\r\n  console.log(sub.foo);\r\n  ```\r\n\r\n- `subproject/`\r\n  - `package.json`\r\n\r\n    ```JSON\r\n    {\r\n      \"name\": \"subproject\",\r\n      \"version\": \"1.0.0\",\r\n      \"type\": \"module\",\r\n      \"exports\": {\r\n        \".\": {\r\n          \"types\": \"./sub.d.ts\",\r\n          \"default\": \"./sub.js\"\r\n        }\r\n      }\r\n    }\r\n    ```\r\n\r\n  - `sub.js`\r\n\r\n    ```JavaScript\r\n    export default {\r\n      foo: \"bar\",\r\n      baz: 42,\r\n    };\r\n    ```\r\n\r\n  - `sub.d.ts`\r\n\r\n    ```TypeScript\r\n    declare type _default = {\r\n      foo: string;\r\n      baz: number;\r\n    };\r\n\r\n    export default _default;\r\n    ```\r\n\r\n1. `npm install`\r\n2. `npx tsc --noEmit --checkJs --module nodenext index.js`\r\n   or `npx tsc --noEmit --checkJs --module nodenext --moduleResolution nodenext index.js`\n\n### \ud83d\ude41 Actual behavior\n\n```\r\nindex.js:1:8 - error TS18042: 'sub' is a type and cannot be imported in JavaScript files. Use 'import(\"subproject\").sub' in a JSDoc type annotation.\r\n\r\n1 import sub from \"subproject\";\r\n         ~~~\r\n\r\nindex.js:3:13 - error TS2693: 'sub' only refers to a type, but is being used as a value here.\r\n\r\n3 console.log(sub.foo);\r\n              ~~~\r\n\r\n\r\nFound 2 errors in the same file, starting at: index.js:1\r\n```\n\n### \ud83d\ude42 Expected behavior\n\nNo error.\n\n### Additional information about the issue\n\nI also reproduce the bug with `npm pack` and:\r\n\r\n```JSON\r\n{\r\n  \"dependencies\": {\r\n    \"subproject\": \"./subproject/subproject-1.0.0.tgz\",\r\n  }\r\n}\r\n```"
    },
    "satisfaction_conditions": [
      "Package exports configuration must properly resolve both types and implementation"
    ],
    "created_at": "2024-03-15T10:37:46Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/54189",
    "source": {
      "issue_number": 54189
    },
    "initial_question": {
      "title": "Uncaught SyntaxError \":\" in recursive function signature",
      "body": "Uncaught SyntaxError C:\\Users\\Owner\\Documents\\TS\\HelloWorlds\\HelloHanoi\\hanoi.ts:19\r\n  height: number,\r\n        ^\r\n\r\nfunction moveTower(\r\n  height: number,\r\n  fromPole: string,\r\n  toPole: string,\r\n  withPole: string\r\n): void {\r\n  if (height >= 1) {\r\n    // Move tower of height-1 to an intermediate pole, using the destination pole.\r\n    moveTower(height - 1, fromPole, withPole, toPole);\r\n\r\n    // Move the remaining disk to the destination pole.\r\n    console.log(`Move disk from ${fromPole} to ${toPole}`);\r\n\r\n    // Move the tower of height-1 from the intermediate pole to the destination pole using the source pole.\r\n    moveTower(height - 1, withPole, toPole, fromPole);\r\n  }\r\n}\r\n\r\n// Call the function with the initial parameters.\r\nmoveTower(3, \"A\", \"C\", \"B\");"
    },
    "satisfaction_conditions": [
      "Original program logic must remain functionally unchanged"
    ],
    "created_at": "2023-05-08T23:45:10Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/50564",
    "source": {
      "issue_number": 50564
    },
    "initial_question": {
      "title": "Allow to use value as type in some cases",
      "body": "## \ud83d\udd0d Search Terms\r\nts2747, Allow to use value as type\r\n\r\n## \u2b50 Suggestion\r\n\r\nAllow to use value as type in some cases\r\n\r\n## \ud83d\udcbb Use Cases\r\n\r\nSometimes it would be nice to have ability to use value as type:\r\n```\r\nclass A {\r\n    public static classname = 'A';\r\n    public a: number = 2;\r\n    classname = 'A';\r\n    constructor (v: number) {\r\n        this.a = v;\r\n    }\r\n}\r\n\r\nclass B {\r\n    public static classname = 'B';\r\n    public b: number = 2;\r\n    classname = 'B';\r\n    constructor (v: number) {\r\n        this.b = v;\r\n    }\r\n}\r\n\r\nconst list = [new A(1), new A(2), new B(3), new A(4), new B(5)];\r\n\r\n// first case\r\nfunction findByType<T> (source: T[], type: Function): type { // 'type' refers to a value, but is being used as a type here.\r\n    return source.find(e => e instanceof type);\r\n}\r\nconsole.log(findByType(list, A).a + findByType(list, B).b);\r\n\r\n\r\n// second case\r\nfunction isTypeOf<T> (source: T, type: Function): source is type { // 'type' refers to a value, but is being used as a type here.\r\n    return (source as any).classname === (type as any).classname;\r\n}\r\nif (isTypeOf(list[0], A)) console.log(list[0].a);\r\n```\r\nThis is a highly simplified example, but it shows how this feature can be used in real application.\r\n"
    },
    "satisfaction_conditions": [
      "Type checking correctly identifies instances of classes passed as parameters",
      "Type inference allows access to class-specific properties after type checking",
      "Function return types correctly reflect the type of the class parameter",
      "Type checking works with an array of mixed types"
    ],
    "created_at": "2022-08-31T12:13:10Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/48404",
    "source": {
      "issue_number": 48404
    },
    "initial_question": {
      "title": "Update from 4.6.0-Beta to 4.6.1-RC introduced bug with Electron 12",
      "body": "# Bug Report\r\n\r\nAfter updating and compiling the project, the Electron-App (Runniing on Electron v12.0.2) does not load the resulting javascript file but reports an error just a view lines into the code.\r\n`Uncaught SyntaxError: Unexpected token '{'`\r\n\r\n### \ud83d\udd0e Search Terms\r\n\r\n`Uncaught SyntaxError: Unexpected token '{'` Electron 4.6.1-RC\r\n\r\n### \ud83d\udd57 Version & Regression Information\r\n\r\nAfter update from 4.5.0-Beta to 4.6.2, did some research to find it was introduced with 4.6.1-RC\r\n\r\n- This is a crash\r\n- This changed between versions 4.6.0-Beta and 4.6.1-RC\r\n\r\n\r\n### \ud83d\udcbb Code\r\n\r\n<!-- Please post the relevant code sample here as well-->\r\n```ts\r\n    class DebugConsole extends FudgeCore.DebugTarget {\r\n        static { this.delegates = {                                                    // error thrown from this line\r\n            [FudgeCore.DEBUG_FILTER.INFO]: console.info,\r\n            [FudgeCore.DEBUG_FILTER.LOG]: console.log,\r\n            [FudgeCore.DEBUG_FILTER.WARN]: console.warn,\r\n            [FudgeCore.DEBUG_FILTER.ERROR]: console.error,\r\n            [FudgeCore.DEBUG_FILTER.FUDGE]: DebugConsole.fudge,\r\n            [FudgeCore.DEBUG_FILTER.CLEAR]: console.clear,\r\n            [FudgeCore.DEBUG_FILTER.GROUP]: console.group,\r\n            [FudgeCore.DEBUG_FILTER.GROUPCOLLAPSED]: console.groupCollapsed,\r\n            [FudgeCore.DEBUG_FILTER.GROUPEND]: console.groupEnd,\r\n            [FudgeCore.DEBUG_FILTER.SOURCE]: DebugConsole.source\r\n        }; }\r\n```\r\n\r\nPrevious output, which Electron12 was able to run, was\r\n```ts\r\n    class DebugConsole extends FudgeCore.DebugTarget {\r\n          ....\r\n    }\r\n    DebugConsole.delegates = {\r\n            [FudgeCore.DEBUG_FILTER.INFO]: console.info,\r\n             ....\r\n```\r\n\r\n### \ud83d\ude41 Actual behavior\r\n\r\nElectron aborts loading the compiled Javascript file and throws the error \r\n\r\n### \ud83d\ude42 Expected behavior\r\n\r\nLoad the compiled file and run it\r\n"
    },
    "satisfaction_conditions": [
      "Class functionality must remain equivalent to previous working version"
    ],
    "created_at": "2022-03-24T18:50:48Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/37795",
    "source": {
      "issue_number": 37795
    },
    "initial_question": {
      "title": "Better type inference for Frozen const arrays ",
      "body": "Search Terms: Object.freeze, Readonly\r\n\r\nI think typescript should have better type inference when object freeze is used on arrays and The type used is readonly array of the given type, instead the type should be readonly tuple that has the types used in the array.\r\n\r\nExample:\r\n``` javaScript\r\n// The type of the array is: \r\n// readonly Array<string | number>\r\n\r\n// What the type should be:\r\n// readonly [\"Abra\", \"Isma\", 0]\r\nconst b = Object.freeze([\"Abra\", \"Isma\", 0]);\r\n```"
    },
    "satisfaction_conditions": [
      "Type inference must preserve literal types of array elements",
      "Array must be readonly after type inference",
      "Type must be inferred as a tuple rather than a general array",
      "Solution must work with mixed-type arrays"
    ],
    "created_at": "2020-04-05T01:01:08Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/33203",
    "source": {
      "issue_number": 33203
    },
    "initial_question": {
      "title": "Compiler API: getConstantValue() can't get a real value from enum's PropertyAccessExpression",
      "body": "<!-- Please try to reproduce the issue with `typescript@next`. It may have already been fixed. -->\r\n**TypeScript Version:**  3.5.3\r\n\r\n<!-- Search terms you tried before logging this (so others can find this issue more easily) -->\r\n**Search Terms:**\r\n\r\nCompiler API, getConstantValue, PropertyAccessExpression\r\n\r\n**Code**\r\n\r\n```ts\r\nimport * as ts from \"typescript\";\r\n\r\n\r\nlet program = ts.createProgram(['/src/sandbox/test.ts'], {});\r\nlet checker = program.getTypeChecker();\r\n\r\nlet source = program.getSourceFile('/src/sandbox/test.ts')!;\r\n\r\nsource.forEachChild(node => {\r\n  switch (node.kind) {\r\n    case ts.SyntaxKind.EnumDeclaration:\r\n      (() => {\r\n        const real = node as ts.EnumDeclaration;\r\n        real.members.forEach(item => {\r\n          console.log(item.name.getText(), checker.getConstantValue(item))\r\n        })\r\n      })()\r\n      break;\r\n    case ts.SyntaxKind.ExpressionStatement:\r\n      (() => {\r\n        const a = node as ts.ExpressionStatement;\r\n        const real = a.expression as ts.PropertyAccessExpression;\r\n        console.log(checker.getConstantValue(real)) // ------------------------> Undefined\r\n      })()\r\n      break\r\n  }\r\n});\r\n```\r\n\r\nThe '/src/sandbox/test.ts':\r\n```ts\r\nenum Test {\r\n    A = 100,\r\n    B,\r\n}\r\n\r\nTest.A;\r\n```\r\n\r\n**Expected behavior:**\r\n\r\nTell me `100`\r\n\r\n**Actual behavior:**\r\n\r\nReturns `undefined`\r\n"
    },
    "satisfaction_conditions": [
      "The solution must work with property access expressions that reference enum members",
      "The solution must properly resolve references back to their original declarations",
      "The returned value must be accessible through the TypeScript Compiler API"
    ],
    "created_at": "2019-09-03T03:48:37Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/32043",
    "source": {
      "issue_number": 32043
    },
    "initial_question": {
      "title": "Support 'as const' together with type restriction",
      "body": "Would be nice to be able to apply type checking to 'as const' types, currently I have to use the silly trick of using type checks when writing them, then switch to 'as const' afterwards.\r\n\r\n```\r\ntype MyType = {name: string};\r\n\r\nconst x:MyType = {\r\n    name: 'test' // Autocompleted, typesafe. But Type is {name: string}, not \r\n                 // what I want, I want {readonly name: 'test'}\r\n} as const;\r\n\r\nconst x = { name: 'test' } as const; // Gives correct type, but no type check for MyType...\r\n```"
    },
    "satisfaction_conditions": [
      "Type checking against MyType must be preserved",
      "Resulting type must include literal type inference",
      "Properties must be marked as readonly",
      "Solution must work at compile time"
    ],
    "created_at": "2019-06-22T19:32:41Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/31176",
    "source": {
      "issue_number": 31176
    },
    "initial_question": {
      "title": "Type checking of extended mapped type",
      "body": "**Typescript version:** 3.4.5.\r\n\r\nI'm writing the boilerplate code for type-safe Express routes in my projects, possibly even create a npm library, if it works as expected.\r\nThe idea is to make sure all the API responses have the shape\r\n```ts\r\n{result: T, error?: any}\r\n```\r\nwhere T is the Response type of the route, or\r\n```ts\r\n{error: any}\r\n```\r\nif there is an error and declare the type of each routes' request and response types in a declarative way.\r\n\r\nThe API is routed under the `/api` route. I'm accomplishing this with `app.use('/api', indexRouter.router)`, where `indexRouter` is an instance of `WrappedRouter` (which is defined at the end of this bug report) which is imported from the file `routes/index.ts`.\r\n\r\n**Contents of `routes/index.ts`**:\r\n```ts\r\nimport authRouter from './auth';\r\nimport makeRouter from \"../utils/RestRoute\";\r\n\r\nconst router = makeRouter();\r\n\r\nrouter.makeSubRoute('/auth',authRouter);\r\n\r\nexport default router;\r\n```\r\n\r\n**Contents of `routes/auth/types.ts`**:\r\n```ts\r\nimport {ITypes} from '../../utils/RestRoute';\r\n\r\nexport interface Types extends ITypes {\r\n    '/sayHello': {\r\n        request: void,\r\n        response: string\r\n    }\r\n}\r\n```\r\n\r\nThe idea is that I can now write this:\r\n**Contents of `routes/auth/index.ts`**:\r\n```ts\r\nimport makeRouter from '../../utils/RestRoute';\r\nimport {Types} from \"./types\";\r\n\r\nconst router = makeRouter<Types>();\r\n\r\nrouter.route('/sayHello',args => ({\r\n    result: 'Hello World!'\r\n}));\r\n\r\nexport default router.router;\r\n```\r\n____________________________________________________________\r\n\r\n**Contents of `RestRoute.ts`** (which contains the wrapper around Express.JS's Route and most of the boilerplate logic):\r\n\r\n```ts\r\nimport express from 'express';\r\n\r\nexport interface ITypes {\r\n    [key: string]: {\r\n        request: any,\r\n        response: any\r\n    }\r\n}\r\n\r\ninterface HandlerFuncionArgs<Req> {\r\n    cookies: express.Request[\"cookies\"],\r\n    hostname: express.Request[\"hostname\"],\r\n    ip: express.Request[\"ip\"],\r\n    clearCookie: express.Response[\"clearCookie\"],\r\n    cookie: express.Response[\"cookie\"],\r\n    secure: express.Request[\"secure\"],\r\n    body: Req,\r\n    params: express.Request[\"params\"]\r\n}\r\n\r\nexport type APIResultType<T> = {result: T, error?: any} | {error: any};\r\n\r\nexport type HandlerFunction<Req,Res> = (args: HandlerFuncionArgs<Req>)=>APIResultType<Res> & {status?: number};\r\n\r\nclass WrappedRouter<Types extends ITypes> {\r\n    public constructor(public readonly router: express.Router) {}\r\n\r\n    private static proxyFunction<Req,Res>(handlerFunction: HandlerFunction<Req,Res>): express.RequestHandler {\r\n        return (req, res, next) => {\r\n            res.type('application/json');\r\n            try {\r\n                const ret = handlerFunction({\r\n                    cookies: req.cookies,\r\n                    hostname: req.hostname,\r\n                    ip: req.ip,\r\n                    clearCookie: res.clearCookie,\r\n                    cookie: res.cookie,\r\n                    secure: req.secure,\r\n                    body: req.body,\r\n                    params: req.params\r\n                });\r\n                res.status(ret.status || 200);\r\n                delete ret.status;\r\n                res.json(ret as APIResultType<Res>);\r\n            } catch(e) {\r\n                res.status(500);\r\n                res.json({error: e} as APIResultType<Res>);\r\n            } finally {\r\n                res.end();\r\n            }\r\n        };\r\n    }\r\n\r\n    public route<Path extends keyof Types>(path: Path, handlerFunction: HandlerFunction<Types[Path][\"request\"],Types[Path][\"response\"]>):void {\r\n        this.router.post(path as string,WrappedRouter.proxyFunction(handlerFunction));\r\n    }\r\n\r\n    public makeSubRoute(path: string, subRouter: express.Router): void;\r\n\r\n    public makeSubRoute<SubRouterTypes extends ITypes>(path: string, subRouter: WrappedRouter<SubRouterTypes>): void;\r\n\r\n    public makeSubRoute<SubRouterTypes extends ITypes>(path: string, subRouter: express.Router|WrappedRouter<SubRouterTypes>) {\r\n        if(subRouter instanceof WrappedRouter) {\r\n            this.router.use(path,subRouter.router);\r\n        } else {\r\n            this.router.use(path,subRouter);\r\n        }\r\n    }\r\n}\r\n\r\nexport function wrapRouter<Types extends ITypes>(router: express.Router) {\r\n    return new WrappedRouter<Types>(router);\r\n}\r\n\r\nexport function makeRouter<Types extends ITypes>() {\r\n    return new WrappedRouter<Types>(express.Router({caseSensitive: true, mergeParams: true}));\r\n}\r\n\r\nexport default makeRouter;\r\n```\r\n(`ITypes` is supposed to be the generic shape of every route's type: each key, representing a route, should contain an object with \"response\" and \"request\" as its only keys. `ITypes` isn't supposed to be instantiated, only extended by other types)\r\n\r\n**Expected behavior:**\r\nCorrectly checks the types of the request and response of each route **AND** doesn't allow routes which aren't defined in that sub-route's `Type`.\r\n\r\n**Actual behaviour:**\r\nIt works well in checking the types of the route: ie. if I try to return `result: 1` in the `/api/auth/sayHello` route, the compiler fails and says that number isn't compatible with string.\r\nThe problem is when I mistype `/sayHello` for, say, `/sayHelo`. There is no error reported from the compiler _even though_ `WrappedRouter.route`'s first argument is of type `Path extends keyof Types`. It just simply accepts any type in the request and any type in the response... It should be an error because `/sayHelo` __**is not**__ in `keyof Type`, which is equal to `/sayHelo`.\r\n\r\nI'm guessing the problem is in extending the interface because it is first declared as having string keys but doesn't specify the keys' type when it is extended. I think `keyof Types` computes to `\"/sayHello\" | string`.\r\n\r\nI've tried to change the generic type of the `route` function to `<Path extends Exclude<keyof Types, string>>` but it doesn't work because it also deletes `\"/sayHello\"` from the union type. Then the `router.route('/sayHello' (...)` line in the `auth/index.ts` file reports the error `TS2345: Argument of type '\"/sayHello\"' is not assignable to parameter of type 'number'`.\r\n\r\nIs there any workaround or a hacky way of accomplishing this while this isn't fix this in a future version of TS?"
    },
    "satisfaction_conditions": [
      "Response type safety must be enforced for defined routes",
      "API responses must conform to the specified result/error shape",
      "Router must support nested route definitions",
      "Type definitions must be extensible for different routes"
    ],
    "created_at": "2019-04-30T18:49:06Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/30707",
    "source": {
      "issue_number": 30707
    },
    "initial_question": {
      "title": "weird type relationship",
      "body": "problem:\r\n\r\n```ts\r\ndeclare function sureNever<_T extends never>(): void;\r\ntype NeverDifferent<L, R> = L extends R ? R extends L ? never : 'right does not extend left' : 'left does not extend right';\r\nsureNever<NeverDifferent<'a', 'a'>>(); // works\r\nsureNever<NeverDifferent<{}, {}>>(); // works\r\nsureNever<NeverDifferent<'a' | 'b', 'a' | 'b'>>(); // breaks: Type '\"right does not extend left\"' does not satisfy the constraint 'never'\r\n```\r\n\r\nnasty workaround:\r\n\r\n```ts\r\ndeclare function sureIdentical<L, R>(\r\n    asRight: (left: L) => R,\r\n    asLeft: (right: R) => L,\r\n): void;\r\nsureIdentical<'a' | 'b', 'a'>(x => x, x => x); // breaks as expected\r\nsureIdentical<'a', 'a' | 'b'>(x => x, x => x); // breaks as expected\r\nsureIdentical<'a' | 'b', 'a' | 'b'>(x => x, x => x); // works as expected\r\n```"
    },
    "satisfaction_conditions": [
      "Type comparison must handle union types correctly without distributing over them",
      "Type equality check must return 'never' when types are identical",
      "Type inequality check must return appropriate error message string literal type",
      "Type checking must be bidirectional"
    ],
    "created_at": "2019-04-02T16:07:01Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/30641",
    "source": {
      "issue_number": 30641
    },
    "initial_question": {
      "title": "defaultProps in HOC when use React.ComponentType<M>",
      "body": "I have a problem of HOC .  when pass a component with a defaultProps to HOC, the props of component exposed to user become optional as the defaultProps is Partial. see example below\r\n\r\nthe property df1 and df2 is not optional after wrapper by HOC!\r\n\r\nbecause \r\n\r\n```js\r\nconst TabRCT = Tab as React.ComponentType<Props & WithProps>\r\ntype DpProps = typeof TabRCT.defaultProps\r\ntype DpProps1 = typeof Tab.defaultProps\r\n```\r\nDpProps is Partial<Props & WithProps> | undefined\r\nDpProps1 is DefaultTabProps\r\n\r\n\r\nthe complete example\r\n \r\n```js\r\nimport * as React from 'react'\r\n\r\ninterface DefaultTabProps {\r\n  df1: number,\r\n  df2: string\r\n}\r\n\r\ninterface Props extends DefaultTabProps {\r\n  pp1?: number\r\n  pp2: number\r\n}\r\n\r\ninterface WithProps {\r\n  wp: string\r\n}\r\n\r\ninterface InjectProps {\r\n  ij: number\r\n}\r\n\r\nclass Tab extends React.Component<Props & WithProps, any> {\r\n  static defaultProps: DefaultTabProps = {\r\n    df1: 11,\r\n    df2: '12'\r\n  }\r\n  render() {\r\n    return <div />\r\n  }\r\n}\r\n\r\n\r\ntype Merge<M, T> = Pick<M, Exclude<keyof M, keyof T>> & T\r\n\r\n\r\n// \u5e0c\u671bM\u662f\u5904\u7406\u540e\u7684 \uff0c\u5373\u6700\u521dM\u662fProps\uff0c\u6700\u540e\u7ec4\u4ef6\u66b4\u9732\u51fa\u6765\u7684props\u662f{...Props, ...DefaultProps }\uff0c\u800cWithProps\u540e\u66b4\u9732\u51fa\u6765\u7684\u8fd8\u662fProps\uff0c\u5e0c\u671b\u52a0\u4e0aWithProps\r\nfunction WithTest<M>(Cp: React.ComponentType<M & WithProps>) {\r\n  return (props: Merge<M, typeof Cp.defaultProps> & InjectProps) => {\r\n    let params = omit(props, ['ij']) as M\r\n    let wp = (props.ij * 100) + '%'\r\n    return <Cp {...params} wp={wp}/>\r\n  }\r\n}\r\n\r\nconst TabWith = WithTest(Tab)\r\n\r\n\r\nfunction omit<T, K extends keyof T>(obj: T, keys: K[]) {\r\n  const newObj: { [key in keyof OmitType<T, K>]?: T[key] } = {}\r\n\r\n  return (Object.keys(obj) as (keyof OmitType<T, K>)[])\r\n    .filter((curr: any) => !keys.includes(curr))\r\n    .reduce((acc: { [key in keyof OmitType<T, K>]?: T[key] }, curr: (keyof OmitType<T, K>)) => (\r\n      acc[curr] = obj[curr],\r\n      acc\r\n    ), newObj)\r\n}\r\n \r\n\r\nconst obj = {\r\n  A: <TabWith ij={12} pp2={1} /> \r\n}\r\n\r\n```\r\n\r\n\r\n"
    },
    "satisfaction_conditions": [
      "Default props from the original component must be preserved in the wrapped component's type system",
      "The HOC's return type must correctly reflect the defaultProps property",
      "The wrapped component must maintain the same runtime behavior regarding default props as the original component",
      "The solution must work with TypeScript's type inference for React components using ComponentType"
    ],
    "created_at": "2019-03-29T07:59:37Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/30127",
    "source": {
      "issue_number": 30127
    },
    "initial_question": {
      "title": "Is it possible to define a universal default generic type parameter so that a bottom object like `new None()`, can type check any type of None, such as None<number>, None< ()=>any >?",
      "body": "**In short, TypeScripts uses type {} for default generic type parameter, when T is not provided for `new ClassA<T>(...)`** so Applicative data structure would require developers more concious with types, which is a barrier for more advanced data structure.\r\n\r\nIs it possible to define an universal default generic type so that a bottom datastructure like `new None()`, can type check any type of None, such as `None<number>`, `None< ()=>any >`?\r\n\r\n**Details:**\r\n\r\nI was trying to implement an Applicative data structure in TS as the Applicative of Haskell:\r\n\r\n```\r\n(Some f) <*> (Some x) = Some (f x)\r\n(None) <*>(Some x) = None\r\n```\r\n\r\nFirst try is to implement functor/applicative  on Option and subclass Some and None.\r\nBelow is the type and class definition:\r\n\r\n\r\n```\r\nexport const id = (a: any) => a\r\n\r\nexport interface Functor<T> {\r\n  fmap(f: (a: T) => any): Functor<any>\r\n}\r\n\r\nexport interface Applicative<T> extends Functor<T> {\r\n  ffmap(af: Applicative<(a: T) => any>): Applicative<any>\r\n}\r\n\r\nexport abstract class Option<T> implements Functor<T> {\r\n  abstract _a: T | undefined\r\n\r\n  abstract fmap(f: (a: T) => any): Functor<any>\r\n\r\n  *[Symbol.iterator]() {\r\n    yield this._a\r\n  }\r\n}\r\n\r\nexport class Some<T> extends Option<T> {\r\n  _a: T\r\n\r\n  constructor(a: T) {\r\n    super()\r\n    this._a = a\r\n  }\r\n\r\n  fmap(f: (a: T) => any): Option<any> {\r\n    return new Some(f(this._a))\r\n  }\r\n\r\n  ffmap(a: Option<(a: T) => any>): Option<any> {\r\n    if (a instanceof None) return new None()\r\n\r\n    const f = a._a\r\n\r\n    if (f === undefined || f === null) return new None()\r\n    else return new Some(f!(this._a))\r\n  }\r\n}\r\n\r\nexport class None<T> extends Option<T> {\r\n  _a: T | undefined\r\n  constructor() {\r\n    super()\r\n    this._a = undefined\r\n  }\r\n\r\n  fmap(f: (a: T) => any): Option<any> {\r\n    return new None()\r\n  }\r\n\r\n  ffmap(a: Option<(a: T) => any>): Option<any> {\r\n    return new None()\r\n  }\r\n}\r\n\r\n```\r\nI have written some test cases and most work. However when test the case :\r\n\r\n```\r\n  test(' Some.ffmap(None) === None', () => {\r\n    const a = new Some(33)\r\n\r\n    const af = new None()\r\n\r\n    expect(a.ffmap(af)).toEqual(new None())\r\n  })\r\n```\r\n\r\nFollowing error is reported:\r\n```\r\n    src/index.test.ts:116:20 - error TS2345: Argument of type 'None<{}>' is not assignable to parameter of type 'Option<(a: number) => any>'.\r\n      Types of property '_a' are incompatible.\r\n        Type '{} | undefined' is not assignable to type '((a: number) => any) | undefined'.\r\n          Type '{}' is not assignable to type '(a: number) => any'.\r\n            Type '{}' provides no match for the signature '(a: number): any'.\r\n\r\n    116     expect(a.ffmap(af)).toEqual(new None())\r\n```\r\n\r\nSpcifically, TS consider new None() has the type of new None<{}>(), which is no match with applicative parameter, new None< ()=>any>()\r\n\r\nWhen I change the test case to the following, it works:\r\n\r\n```\r\n  test(' Some.fmap(None) = None', () => {\r\n    const a = new None<number>()\r\n\r\n    const f = (a: number) => a + 2\r\n\r\n    expect(a.fmap(f)).toEqual(a)\r\n  })\r\n```\r\n"
    },
    "satisfaction_conditions": [
      "None type must be assignable to Option<T> for any type T",
      "Default type parameter behavior must preserve type safety"
    ],
    "created_at": "2019-02-27T14:33:11Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/29295",
    "source": {
      "issue_number": 29295
    },
    "initial_question": {
      "title": "Extract<keyof T, string> is not assignable to K extends Extract<keyof T, string> when used as K[]",
      "body": "**TypeScript Version:**  3.3.0-dev.20190105\r\n\r\n<!-- Search terms you tried before logging this (so others can find this issue more easily) -->\r\n**Search Terms:** keyof string array, K extends Extract<keyof T, string>\r\n\r\n**Code**\r\n\r\nUsing a generic `K extends Extract<keyof T, string>` generic definition does not work:\r\n\r\n```ts\r\nfunction copyAllExcept<T, K extends Extract<keyof T, string>>(target: any, source: T, skip: K[]) {\r\n    for (const key in source) {\r\n        if (source[key] != null && !skip.includes(key)) {\r\n            target[key] = source[key];\r\n        }\r\n    }\r\n}\r\n```\r\nError at the `!skip.includes(key)` part:\r\n\r\nArgument of type 'Extract<keyof T, string>' is not assignable to parameter of type 'K'.\r\n  Type 'string & keyof T' is not assignable to type 'K'.\r\n    Type 'string' is not assignable to type 'K'.\r\n      Type 'string' is not assignable to type 'K'.\r\n\r\n\r\nUsing `Array<Extract<keyof T, string>>` directly as the argument definition does work though:\r\n\r\n```ts\r\nfunction copyAllExcept<T>(target: any, source: T, skip: Array<Extract<keyof T, string>>) {\r\n    for (const key in source) {\r\n        if (source[key] != null && !skip.includes(key)) {\r\n            target[key] = source[key];\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n"
    },
    "satisfaction_conditions": [
      "Type checking must pass without errors when comparing array elements with object keys",
      "Function must correctly filter object properties based on a skip list",
      "Type definitions must properly handle string-based object keys",
      "Array type definition must allow checking membership of object keys"
    ],
    "created_at": "2019-01-07T20:06:40Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/28191",
    "source": {
      "issue_number": 28191
    },
    "initial_question": {
      "title": "Spread operator with one union-typed key gives type error?",
      "body": "I'm not sure if the following code should be filed as a bug, or it's just me not completely understanding the Typescript type-system.\r\n\r\nIn the following code (testing the playground V3.1), the function `fails` gives a type error, complaining that `Type 'Tag.BAR' is not assignable to type 'Tag.FOO'`.\r\n\r\nHowever, this function just returns the `x` object again, it's just that the `id` key is copied explicitly.\r\n\r\nCan someone explain why this doesn't work, and/or if this is a bug or by design?\r\n\r\n```ts\r\n// Dummy _tag_ key to avoid passing identifiers as plain numbers\r\ntype Identifier<TAG> = number & { readonly _tag_: TAG };\r\n\r\ninterface Entity<TAG> {\r\n  readonly tag: TAG;\r\n  readonly id: Identifier<TAG>;\r\n}\r\n\r\nenum Tag {\r\n  FOO = 0,\r\n  BAR = 1\r\n}\r\n\r\ninterface Foo extends Entity<Tag.FOO> {\r\n    foo: string;\r\n}\r\n\r\ninterface Bar extends Entity<Tag.BAR> {\r\n    bar: boolean;\r\n}\r\n\r\nfunction works(x: Foo | Bar): Foo | Bar {\r\n    return { ...x };\r\n}\r\n\r\nfunction fails(x: Foo | Bar): Foo | Bar {\r\n    return { ...x, id: x.id };\r\n}\r\n```\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    "satisfaction_conditions": [
      "Type relationships between the original object and its spread copy must be preserved"
    ],
    "created_at": "2018-10-28T18:43:19Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/26934",
    "source": {
      "issue_number": 26934
    },
    "initial_question": {
      "title": "Can i declare an Object properties must contain a or b ?",
      "body": "when i declare an Object like this:\r\n`interface obj {\r\n a?:string,\r\n b?string\r\n}\r\n`\r\nbut i want the attribute a not to exist, the attribute b must exist.\r\n`let obj:obj={}`  It is allowed ,i want it is not allowed\r\n`let obj:obj={a:'a'}` or `let obj:obj={b:'b'}`  if i want It is allowed. what should I do?\r\n"
    },
    "satisfaction_conditions": [
      "Type definition must prevent empty object creation",
      "Type definition must allow objects with either property 'a' or 'b'",
      "Type checking must be enforced at compile time",
      "Properties must be of string type when present"
    ],
    "created_at": "2018-09-06T06:36:10Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/25768",
    "source": {
      "issue_number": 25768
    },
    "initial_question": {
      "title": "Stringify like in \"c\" ",
      "body": "Hi ,\r\nHow do we convert object dot walking into string signature.\r\n``` typescript\r\nlet person = {\r\n\tcompany: {\r\n\t\tdepartment: {\r\n\t\t\tmsging: {\r\n\t\t\t\tphone: \"xyz\",\r\n\t\t\t\tfax: \"abc\"\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\tage: 34\r\n}\r\n\r\nfunction evaluateObject(val: string) {\r\n // some logic to evalute\r\n}\r\nevaluateObject(`${person.company.department.msging.phone}`);\r\n```\r\nthis will emit \r\n``` javascript\r\nevaluateObject('xyz');\r\n```\r\nbut I want to emit something like this.\r\n``` javascript\r\nevaluateObject('person.company.department.msging.phone');\r\n```\r\nIs there anyway to achieve this? Any Custom syntax like in \"C\" macros\r\n```typescript\r\nevaluateObject(`#{person.company.department.msging.phone}`);\r\n```\r\n\r\nIs it possible to achieve with any plugin kind of thing?.\r\n-thanks"
    },
    "satisfaction_conditions": [
      "Returns the property access path as a string",
      "Maintains type safety during property access",
      "Supports arbitrary nesting depth",
      "Preserves property name sequence",
      "Works with TypeScript objects"
    ],
    "created_at": "2018-07-18T14:12:27Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/24216",
    "source": {
      "issue_number": 24216
    },
    "initial_question": {
      "title": "Strict keys in HashMap",
      "body": "It's very powerful feature in typescript by strict value type in HashMap declaration. However looks like the same feature is missing for key values. I tried defined as type of string or enums but getting errors.\r\n\r\n\r\n```\r\ntype Keys1 = \"key1\" | \"key2\";\r\nenum Keys2 {key1, key2}\r\nconst map1: {[key: string]: Keys1 | null} = {\r\n    \"key1\": \"key1\",\r\n    \"key2\": \"key2\",\r\n    \"key3\": \"key3\"  //That is working!!!\r\n                    // Property '\"key3\"' is incompatible with index signature.\r\n                    // Type '\"key3\"' is not assignable to type '\"key1\" | \"key2\" | null'.\r\n};\r\n\r\nconst map2: {[key: string]: Keys1 | null} = {\r\n    \"key1\": \"key1\",\r\n    \"key2\": \"key2\",\r\n    \"key3\": null //I would like to strct and get error\r\n};\r\n\r\nconst map3: {[key: Keys1]: boolean} = {  //[ts] An index signature parameter type cannot be a union type. \r\n                                        //Consider using a mapped object type instead.\r\n                                        //(parameter) key: \"key1\" | \"key2\"\r\n    \"key3\": true\r\n};\r\n\r\nconst map4: {[key: Keys2]: boolean} = {  //[ts] An index signature parameter type must be 'string' or 'number'.\r\n                                        //(parameter) key: Keys2\r\n    \"key3\": true\r\n};\r\n```"
    },
    "satisfaction_conditions": [
      "Type system enforces strict key constraints for the HashMap/object",
      "Compile-time error occurs when using unauthorized keys",
      "Supports union types or enums as key constraints",
      "Maintains type safety while allowing object initialization"
    ],
    "created_at": "2018-05-17T19:45:02Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/24092",
    "source": {
      "issue_number": 24092
    },
    "initial_question": {
      "title": "input file override crazytown",
      "body": "I have this config:\r\n\r\n```json\r\n{\r\n  \"compilerOptions\": {\r\n    \"outDir\":\"dist\",\r\n    \"allowJs\": false,\r\n    \"pretty\": true,\r\n    \"skipLibCheck\": true,\r\n    \"declaration\": true,\r\n    \"baseUrl\": \".\",\r\n    \"target\": \"es6\",\r\n    \"module\": \"commonjs\",\r\n    \"noImplicitAny\": true,\r\n    \"removeComments\": true,\r\n    \"allowUnreachableCode\": true,\r\n    \"lib\": [\r\n      \"es2015\",\r\n      \"es2016\",\r\n      \"es2017\"\r\n    ]\r\n  },\r\n  \"compileOnSave\": false,\r\n  \"include\": [\r\n    \"src\"\r\n  ]\r\n}\r\n```\r\n\r\nI keep getting this error:\r\n\r\n> error TS5055: Cannot write file '/Users/alexamil/WebstormProjects/oresoftware/fly/dist/fly.d.ts' because it would overwrite input file.\r\n\r\n\r\nIt's driving me batty lol. `tsc` should know that the `dist` dir is the destination, so no input files should come from there, right? not only that, but the `include` is set to `src` in the config.\r\n\r\n\r\nhere are my versions:\r\n```bash\r\nnodejs version: v9.11.1\r\nnpm version: 5.6.0\r\ntypescript version: Version 2.8.3\r\n```\r\n\r\n"
    },
    "satisfaction_conditions": [
      "The compiler's output directory remains separate from source files"
    ],
    "created_at": "2018-05-14T02:46:07Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/23670",
    "source": {
      "issue_number": 23670
    },
    "initial_question": {
      "title": "static return might fail with switch statement",
      "body": "I have this:\r\n\r\n```js\r\nconst onUpdate = function (v: string, o: any) : Promise<any> {\r\n  \r\n  const finalName = String(v || '').split('.')[1]; // collection name\r\n  const _id = o && o.o2 && o.o2._id;\r\n  let key;\r\n  \r\n  switch (finalName) {\r\n    \r\n    case 'categories':      \r\n      return Category.findOne({_id}).exec().then(function (cat: any) {\r\n         // ....\r\n      });\r\n    \r\n    case 'acquisitions':\r\n        return Acquisition.findOne({_id}).exec().then(function (acq: any) {\r\n         // ...\r\n      });\r\n    \r\n    case 'functionalTeams':\r\n      return FunctionalGroup.findOne({_id}).exec().then(function (ft: any) {\r\n           // ...\r\n      });\r\n    \r\n    default:\r\n      log.error('document collection did not match a pre-defined name');\r\n      // nothing is returned here, but can TS check to see if it does/doesn't\r\n  }\r\n  \r\n};\r\n```\r\n\r\ncan TypeScript check to see if a Promise fails to be returned in the default or after the switch statement? Right now it's compiling even though a Promise is not returned in all cases."
    },
    "satisfaction_conditions": [
      "TypeScript compiler must detect and flag missing Promise returns",
      "All execution paths must have explicit return values",
      "Return type consistency must be enforced across all branches",
      "TypeScript configuration must enable appropriate type checking strictness"
    ],
    "created_at": "2018-04-24T22:42:15Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/22857",
    "source": {
      "issue_number": 22857
    },
    "initial_question": {
      "title": "Union type in JSX IntrinsicElements seems like a bug",
      "body": "```typescript\r\ndeclare namespace JSX {\r\n  interface IntrinsicElements {\r\n    foo: { bar: boolean } | { baz: boolean };\r\n  }\r\n}\r\n\r\nconst one = <foo bar baz />; // ok\r\n```\r\n\r\nHi. Is this a bug? I was expecting this to not compile but it does. \r\n\r\nIn the IntrinsicElements interface the type for `foo` is defined as having a boolean attribute of `foo` **or** `baz` but it compiles when both are set.\r\n\r\nI'm new to typescript so apologies if the issue is just my understanding of the type system."
    },
    "satisfaction_conditions": [
      "Explanation clarifies the difference between OR and XOR behavior in TypeScript union types",
      "Demonstrates that union types allow all properties to be present simultaneously",
      "Acknowledges current TypeScript limitations regarding XOR implementation"
    ],
    "created_at": "2018-03-24T14:14:24Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/22372",
    "source": {
      "issue_number": 22372
    },
    "initial_question": {
      "title": "Using createVariableStatement in a compiler transformer breaks the compiler",
      "body": "**TypeScript Version:**  2.8.0-dev.20180307\r\n\r\n**Search Terms:** createVariableStatement const\r\n\r\n**Code (compiler)**\r\n\r\n```ts\r\n// A *self-contained* demonstration of the problem follows...\r\nimport * as ts from 'typescript';\r\n\r\nfunction transformer(program: ts.Program): ts.TransformerFactory<ts.SourceFile> {\r\n    return (context: ts.TransformationContext) => (file: ts.SourceFile) => transformFile(program, context, file);\r\n}\r\n\r\nfunction transformFile(program: ts.Program, context: ts.TransformationContext, file: ts.SourceFile): ts.SourceFile {\r\n    const transformedFile = ts.visitEachChild(file, child => visit(child, context, file), context);\r\n    return transformedFile;\r\n}\r\nfunction visit(node: ts.Node, context: ts.TransformationContext, file: ts.SourceFile): ts.Node {\r\n    if (ts.isMethodDeclaration(node)) {\r\n        const newNode = ts.createMethod(\r\n            [ts.createToken(ts.SyntaxKind.StaticKeyword)], \r\n            [], \r\n            null, \r\n            node.name, \r\n            null, \r\n            [], \r\n            node.parameters, \r\n            node.type, \r\n            ts.createBlock([ \r\n                ts.createVariableStatement(\r\n                    [ts.createToken(ts.SyntaxKind.ConstKeyword)], \r\n                    [ts.createVariableDeclaration('myConst', null, ts.createLiteral('value'))]\r\n                ),\r\n                ...(node.body ? node.body.statements : [])\r\n            ])\r\n        );\r\n        console.log(ts.createPrinter().printNode(ts.EmitHint.Unspecified, newNode, file));\r\n        return newNode;\r\n    }\r\n    return ts.visitEachChild(node, child => visit(child, context, file), context);\r\n}\r\n\r\nconst program = ts.createProgram([\r\n  '../transformer-issue-src/src/A.ts'\r\n], {\r\n    target: ts.ScriptTarget.ES5,\r\n    module: ts.ModuleKind.CommonJS,\r\n    moduleResolution: ts.ModuleResolutionKind.NodeJs,\r\n    importHelpers: true,\r\n    alwaysStrict: true,\r\n    noImplicitAny: true,\r\n    noImplicitThis: true,\r\n    removeComments: true,\r\n    sourceMap: true,\r\n    outDir: \"../transformer-issue-src/lib\",\r\n    declaration: true,\r\n    declarationDir: \"../transformer-issue-src/lib\",\r\n    lib: [\r\n      \"lib.es2017.d.ts\",\r\n    ],\r\n    experimentalDecorators: true,\r\n    noEmitOnError: true,\r\n});\r\n\r\nconst transformers = {\r\n  before: [\r\n    transformer(program),\r\n  ]\r\n}\r\nconst result = program.emit(undefined, undefined, undefined, false, transformers);\r\n```\r\n\r\n**Code (test program, ../transformer-issue-src/src/A.ts)**\r\n\r\n```ts\r\nexport class A {\r\n    static myMethod() {\r\n        return 'value';\r\n    }\r\n}\r\n```\r\n\r\n**Expected behavior:**\r\nThe .js file should be emitted.\r\nThe `console.log` statement should print the following:\r\n\r\n```ts\r\nstatic myMethod() { const myConst = \"value\"; return 'value'; }\r\n```\r\n\r\n**Actual behavior:**\r\nThe .js file is not emitted due to a compiler exception. Message and stack trace:\r\n\r\n```\r\nTypeError: Cannot read property 'transformFlags' of null\r\n    at aggregateTransformFlagsForNode (d:\\solutions\\transformer-issue-compiler\\node_modules\\typescript\\lib\\typescript.js:54626:18)\r\n    at Object.aggregateTransformFlags (d:\\solutions\\transformer-issue-compiler\\node_modules\\typescript\\lib\\typescript.js:54611:9)\r\n    at visitNode (d:\\solutions\\transformer-issue-compiler\\node_modules\\typescript\\lib\\typescript.js:53754:12)\r\n    at Object.visitEachChild (d:\\solutions\\transformer-issue-compiler\\node_modules\\typescript\\lib\\typescript.js:54053:108)\r\n    at visitVariableDeclaration (d:\\solutions\\transformer-issue-compiler\\node_modules\\typescript\\lib\\typescript.js:61625:30)\r\n    at Object.flatMap (d:\\solutions\\transformer-issue-compiler\\node_modules\\typescript\\lib\\typescript.js:2047:25)\r\n    at visitVariableDeclarationList (d:\\solutions\\transformer-issue-compiler\\node_modules\\typescript\\lib\\typescript.js:61510:39)\r\n    at visitJavaScript (d:\\solutions\\transformer-issue-compiler\\node_modules\\typescript\\lib\\typescript.js:60282:28)\r\n    at visitor (d:\\solutions\\transformer-issue-compiler\\node_modules\\typescript\\lib\\typescript.js:60243:24)\r\n    at visitNode (d:\\solutions\\transformer-issue-compiler\\node_modules\\typescript\\lib\\typescript.js:53755:23)\r\n```\r\n\r\nEven if I remove the `ts.createToken(ts.SyntaxKind.ConstKeyword)` token, this exception is still thrown.\r\n\r\nAlso, the `console.log` statement prints the following (the var keyword is left there):\r\n\r\n```ts\r\nstatic myMethod() { const var myConst = \"value\"; return 'value'; }\r\n```"
    },
    "satisfaction_conditions": [
      "The transformed method must maintain its static modifier and original return statement"
    ],
    "created_at": "2018-03-07T11:15:49Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/21877",
    "source": {
      "issue_number": 21877
    },
    "initial_question": {
      "title": "Salsa Intellisense for parameters of closures with javascript",
      "body": "**Version:**  VS2017\r\n\r\nMy TypeScript project produces a `.d.ts` file. Which is perfect for TS projects:\r\n\r\n```ts\r\ndeclare function myGlobal(param: string): string;\r\ndeclare module myHmi {\r\n    class foo {\r\n        static myStatic(bar: string): string;\r\n    }\r\n}\r\n```\r\n\r\nBut other teams are on JS and wants to use our nice typings. They have the .d.ts file inside the project. VS2017 detects it in the new JS Language Service (Salsa).\r\n\r\n```js\r\nvar myHmi;\r\n(function (myHmi) {\r\n    // Here VS2017 knows myGlobal()\r\n    // Here VS2017 detected myHmi as {}. So it has no knowledge of myHmi.foo.myStatic()\r\n\r\n    main code...\r\n})(myHmi || (myHmi = {}));\r\n\r\n// Here VS2017 knows myGlobal()\r\n// Here VS2017 knows myHmi.foo.myStatic()\r\n\r\n```\r\nCan we use a hint (jsdoc magic?) to tell VS that the inner myHmi is an extension of the outer myHmi?\r\n"
    },
    "satisfaction_conditions": [
      "JavaScript code must have access to TypeScript type definitions",
      "IntelliSense must work for nested module members",
      "Type definitions must be accessible in both outer and inner scopes",
      "Solution must support gradual migration path from JavaScript to TypeScript"
    ],
    "created_at": "2018-02-12T07:14:55Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/21723",
    "source": {
      "issue_number": 21723
    },
    "initial_question": {
      "title": "Export `with` as a property within declaration file",
      "body": "I got a CommonJS module that exports a function by default. The function has a property named `with`, which is a reserved word in JavaScript. JavaScript allows this kind of usage (`with` as a property name), but unfortunately, I can't get it working in TS declaration file.\r\n\r\n## Code\r\n**a.js**\r\n```javascript\r\nmodule.exports = () => 1;\r\nmodule.exports.with = (n: number) => 1 + n;\r\n```\r\n\r\n**a.d.ts**\r\n```ts\r\nexport = GetNumber;\r\n\r\ndeclare function GetNumber(): number;\r\n\r\ndeclare namespace GetNumber {\r\n\texport function with(n: number): number;\r\n}\r\n```\r\n\r\n**b.ts**\r\n```ts\r\nimport * as getNumber from './a';\r\n\r\nconsole.log(getNumber()); // => 1\r\nconsole.log(getNumber.with(2)); // => 3\r\n```\r\n\r\n## Expected behavior:\r\n\r\nDeclaration should be valid for both `getNumber` and `getNumber.with`.\r\n\r\n## Actual behavior:\r\n\r\nGetting an error in compilation:\r\n```\r\n$ tsc a.d.ts\r\na.d.ts(6,19): error TS1003: Identifier expected.\r\na.d.ts(6,25): error TS1005: ')' expected.\r\na.d.ts(6,33): error TS1005: ';' expected.\r\na.d.ts(6,34): error TS1128: Declaration or statement expected.\r\n```"
    },
    "satisfaction_conditions": [
      "TypeScript declaration file must successfully compile without errors",
      "Declaration file must allow access to the main function export",
      "Declaration file must allow access to the 'with' property as a function",
      "TypeScript code importing the module must be able to use both the main function and the 'with' property",
      "Declaration must maintain compatibility with the original CommonJS module structure"
    ],
    "created_at": "2018-02-07T16:28:41Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/21421",
    "source": {
      "issue_number": 21421
    },
    "initial_question": {
      "title": "Mapped type should take a function form as well",
      "body": "According to #12114 mapped types currently support following forms:\r\n\r\n```ts\r\n{ [ P in K ] : T }\r\n{ [ P in K ] ? : T }\r\n{ readonly [ P in K ] : T }\r\n{ readonly [ P in K ] ? : T }\r\n```\r\n\r\nI think it shall also at least support a function form:\r\n\r\n```ts\r\n{ ([ P in K ]) : T }\r\n{ ([ P in K ]) ? : T }\r\n{ ([ P in K])(entities: P[], someBoolean: boolean) ? : T }\r\n```\r\n\r\nCurrently Im trying to implement a `Functionize<T>` interface which forces implementors to implement any property of the T, but make it a function with maybe additional arguments. Example:\r\n\r\n```ts\r\ninterface User {\r\n     name: string;\r\n     age: number\r\n}\r\n```\r\n\r\nI want to do Functionize<User> which I want to give me:\r\n\r\n```ts\r\n{\r\n       name(names: string[]): string;\r\n       age(ages: number[]): number;\r\n}\r\n```\r\n\r\nAnd I'm asking about following method signature:\r\n\r\n```ts\r\ntype Functionize<T> = {\r\n   [P in keyof T](values: T[])?: T[P];\r\n};\r\n```"
    },
    "satisfaction_conditions": [
      "Type definition must support function properties with array parameters",
      "Type checking must enforce parameter type consistency",
      "Resulting type must preserve original property types as return types",
      "Type definition must support optional additional parameters",
      "Type safety must be maintained across the transformation"
    ],
    "created_at": "2018-01-26T06:02:30Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/20747",
    "source": {
      "issue_number": 20747
    },
    "initial_question": {
      "title": "TS doesn't merge members for Window interface",
      "body": "I've tried to add a new property `counter` to the `Window` interface like this in the `main.ts` file:\r\n\r\n```\r\n// main.ts\r\n\r\ninterface Window {\r\n    counter;\r\n}\r\n```\r\n\r\n**Expected behavior:**\r\n\r\nI expected the property to be available on the `window` object:\r\n\r\n```\r\nwindow.counter;\r\n```\r\n\r\n**Actual behavior:**\r\n\r\nHowever, I got the error:\r\n\r\n```\r\nError:(19, 16) TS2339: Property 'counter' does not exist on type 'Window'.\r\n```\r\n"
    },
    "satisfaction_conditions": [
      "TypeScript code must successfully recognize the new property on the Window interface",
      "The property must be accessible globally via the window object",
      "The interface modification must work within a module context",
      "The modification must properly merge with the existing Window interface definition"
    ],
    "created_at": "2017-12-18T08:26:09Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/20668",
    "source": {
      "issue_number": 20668
    },
    "initial_question": {
      "title": "tsc copy filed not included it's parent dir after compiled with setting other dir exclued in tsconfig.json",
      "body": "`tsc 2.6.2`. there is source dir tree:\r\n\r\n```\r\nsrc/\r\n\u251c\u2500\u2500 client\r\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 client.tsx\r\n\u251c\u2500\u2500 server\r\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 actions\r\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 app.ts\r\n\u251c\u2500\u2500 shared\r\n```\r\n\r\nwhere `tsconfig.json` settings:\r\n```json\r\n{\r\n...,\r\n\"outDir\": \"dist\",\r\n\"exclude\": [\r\n    \"./src/shared/**/*\",\r\n    \"./src/client/**/*\",\r\n    \"./src/server/*.tsx\",\r\n    \"./src/server/**/*.tsx\",\r\n],\r\n\"include\": [\r\n    \"./src/**/*\"\r\n  ]\r\n}\r\n```\r\n\r\nexec `tsc -p tsconfig.json`, expected `dist dir tree`:\r\n```\r\nsrc/\r\n\u251c\u2500\u2500 server\r\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 actions\r\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 app.ts\r\n```\r\n\r\nin fact\uff0cit output:\r\n```\r\ndist\r\n\u251c\u2500\u2500 app.js\r\n\u251c\u2500\u2500 app.js.map\r\n\u251c\u2500\u2500 actions\r\n```\r\n\r\nbut,  this's `tsconfig.json` is okay:\r\n```json \r\n{\r\n...,\r\n\"outDir\": \"dist\",\r\n\"exclude\": [\r\n    \"./src/shared/**/*\",\r\n],\r\n\"include\": [\r\n    \"./src/**/*\"\r\n  ]\r\n}\r\n```\r\n\r\nthe output `dist dir  tree`:\r\n```\r\ndist\r\n\u251c\u2500\u2500 client\r\n\u2514\u2500\u2500 server\r\n```\r\n\r\nso, i am confused. that is a bug ?\ud83d\ude37\ud83d\ude37\ud83d\ude37\r\n\r\nThanks."
    },
    "satisfaction_conditions": [
      "Exclude patterns must effectively filter out specified source files",
      "Root directory structure must be correctly determined or explicitly configured"
    ],
    "created_at": "2017-12-13T08:35:54Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/20280",
    "source": {
      "issue_number": 20280
    },
    "initial_question": {
      "title": "Wrong type inferred for nested union",
      "body": "**TypeScript Version:**  2.7.0-dev.20171126\r\n\r\nContext: a method for ember.js which extracts the value from some path, e.g.\r\n```ts\r\nget({ foo: { bar: { baz: 'hello' }}}, 'foo', 'bar', 'baz') // returns \"hello\"\r\n```\r\n\r\nEach value in the path might be some plain object `T` or a `Wrapped<T>` (in which case we return the underlying `T`)\r\n\r\n**Code**\r\n\r\nTypescript can infer the returned type using a union:\r\n\r\n```ts\r\n// working example\r\ninterface Wrapped<T> { value: T }\r\n\r\ntype Props1<T> = {\r\n    [K in keyof T]: Wrapped<T[K]> | T[K];\r\n}\r\n\r\ndeclare function get1<T, K1 extends keyof T>(obj: Props1<T>, k1: K1): T[K1];\r\n\r\ndeclare const obj1: { a: string };\r\nconst v1: string = get1(obj1, 'a'); // works\r\n\r\ndeclare const obj2: { a: Wrapped<string> };\r\nconst v2: string = get1(obj2, 'a'); // works\r\n```\r\n\r\nHowever, it no longer works when the union types are nested:\r\n\r\n```ts\r\n// non-working example\r\ntype Props2<T> = {\r\n    [K in keyof T]: Wrapped<Props1<T[K]>> | Props1<T[K]>\r\n};\r\n\r\ndeclare function get2<T, K1 extends keyof T, K2 extends keyof T[K1]>(obj: Props2<T>, k1: K1, k2: K2): T[K1][K2];\r\n\r\ndeclare const obj3: { a: { b: string } };\r\nconst v3: string = get2(obj3, 'a', 'b'); // works\r\n\r\ndeclare const obj4: { a: Wrapped<{ b: Wrapped<string> }> };\r\nconst v4: string = get2(obj4, 'a', 'b'); // TS2345:Argument of type '\"b\"' is not assignable to parameter of type 'never'.\r\n```\r\n\r\nIf I eliminate the _right side_ of the union from `Props2`, then the `obj4` example works\r\n```ts\r\ntype Props2<T> = {\r\n    [K in keyof T]: Wrapped<Props1<T[K]>> //| Props1<T[K]>\r\n};\r\n```\r\nThe `obj4` example should pick the left side of the union to begin with"
    },
    "satisfaction_conditions": [
      "The function must accept and validate property key paths of at least 2 levels deep",
      "Type checking must validate all provided property keys at compile time",
      "The solution must maintain backward compatibility with existing plain object structures"
    ],
    "created_at": "2017-11-27T18:11:05Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/19529",
    "source": {
      "issue_number": 19529
    },
    "initial_question": {
      "title": "Can TypeScript refer to an instance type over a namespace type?",
      "body": "I have a library whose `.d.ts` file defined something like:\r\n\r\n```\r\ndeclare class Logger extends EventEmitter {\r\n    constructor();\r\n    info(message: string);\r\n    error(message: string);\r\n}\r\n\r\ndeclare namespace Logger {\r\n    const INFO: number;\r\n    const ERROR: number;\r\n}\r\n\r\nexport = Logger;\r\n```\r\n\r\nI'm accessing it with `require()` and loading it in at runtime:\r\n\r\n```\r\nimport LoggerType = require(\"mylogger\");\r\n\r\n...\r\n\r\nlet logger: typeof LoggerType;\r\ntry {\r\n    logger = require(\"mylogger\").createLogger(...);\r\n}\r\ncatch (err) {\r\n    ...\r\n}\r\n\r\nif (logger) {\r\n    logger.info(\"hello world\");\r\n}\r\n```\r\n\r\nBut this doesn't work because TypeScript doesn't see `logger` as an instance of `Logger` but as the namespace `Logger`.  Can it instead refer to the instance of `Logger` so `logger.info()` will not be a type violation?"
    },
    "satisfaction_conditions": [
      "TypeScript correctly recognizes the variable as an instance type rather than a namespace type",
      "Method calls on the logger instance are accepted by the type system",
      "Type declarations maintain compatibility with the original library structure",
      "Runtime functionality remains unchanged"
    ],
    "created_at": "2017-10-27T13:19:56Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/19382",
    "source": {
      "issue_number": 19382
    },
    "initial_question": {
      "title": "Referenced type variable incorrectly inferred as \"{}\" in function calls",
      "body": "**TypeScript Version:**  2.6.0-dev.201xxxxx\r\n\r\n**Code**\r\n\r\n```ts\r\n// Fails:  error TS2339: Property 'a' does not exist on type '{}'.\r\ninfer({ thing: { a: 10 } }).a; \r\n\r\n// With explicit type parameters, it works\r\ninfer<{a:number}, Holder<{a: number}>>({ thing: { a: 10 } }).a; \r\n\r\ninterface Holder<T> {\r\n\tthing: T;\r\n}\r\nfunction infer<T, H extends Holder<T>>(holder: H): T {\r\n\treturn holder.thing;\r\n}\r\n```\r\n\r\n**Expected behavior:**\r\n\r\nThe type parameter `T` should be inferred to be the type of `thing` in the instance of `Holder` passed to the function `infer()`.\r\n\r\nPerhaps there is another way to get this type of inference to work? I'm building a builder-pattern class and really need this to correctly return the right types.\r\n\r\n**Actual behavior:**\r\n\r\nThe type parameter, `T`, is inferred to be `{}` when calling `infer()`\r\n"
    },
    "satisfaction_conditions": [
      "Type parameter T must be correctly inferred from the input object's structure",
      "Function must preserve and return the complete type information of nested properties",
      "Type inference must work without requiring explicit type parameters",
      "Solution must support builder pattern type relationships",
      "Type relationships between generic parameters must be preserved"
    ],
    "created_at": "2017-10-20T19:39:19Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/19186",
    "source": {
      "issue_number": 19186
    },
    "initial_question": {
      "title": "TS2339: Property 'tooltip' does not exist on type '{ label: string; } | { label: string; tooltip: string; }'.",
      "body": "**TypeScript Version:**  typescript@2.6.0-dev.20171014\r\n\r\n**Code**\r\n\r\n```ts\r\nconst cells = [\r\n  { label: '1' },\r\n  { label: '2', tooltip: '2' },\r\n  { label: '3', tooltip: '3' },\r\n  { label: '4' },\r\n  { label: '5' },\r\n  { label: '6' },\r\n]\r\nfor (const cell of cells) {\r\n  if (cell.tooltip) console.log(cell.tooltip)\r\n}\r\n```\r\n\r\n**Expected behavior:**\r\nThat this compiles without error; the error message seems to indicate TS sees a call to cell.tooltip as valid but then forbids it in the second part of the error message.\r\n\r\n**Actual behavior:**\r\n```\r\ntt.ts(10,12): error TS2339: Property 'tooltip' does not exist on type '{ label: string; } | { label: string; tooltip: string; }'.\r\n  Property 'tooltip' does not exist on type '{ label: string; }'.\r\ntt.ts(10,38): error TS2339: Property 'tooltip' does not exist on type '{ label: string; } | { label: string; tooltip: string; }'.\r\n  Property 'tooltip' does not exist on type '{ label: string; }'.\r\n```"
    },
    "satisfaction_conditions": [
      "TypeScript compiler accepts the code without type errors",
      "Code maintains ability to access optional tooltip property",
      "Array elements maintain their original structure",
      "Type system correctly recognizes optional property pattern"
    ],
    "created_at": "2017-10-14T19:27:31Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/19017",
    "source": {
      "issue_number": 19017
    },
    "initial_question": {
      "title": "Type inference by property comparison",
      "body": "**TypeScript Version:**  2.5.3\r\n\r\n**Code**\r\n\r\n```ts\r\ninterface Symbol\r\n{\r\n    kind: \"namespace\"|\"class\"|\"interface\"|\"enum\";\r\n    basename: string;\r\n}\r\n\r\ninterface SymbolClass extends Symbol\r\n{\r\n    kind: \"class\";\r\n    extends: string;\r\n}\r\n\r\nfunction (symbol: Symbol)\r\n{\r\n    if (symbol.kind === \"class\")\r\n    {\r\n        //infer symbol as SymbolClass, is it possible?\r\n        console.log(symbol.extends);\r\n    }\r\n}\r\n```\r\n\r\n**Expected behavior:**\r\nNo error\r\n\r\n**Actual behavior:**\r\nProperty 'extends' does not exist on type 'Symbol'."
    },
    "satisfaction_conditions": [
      "TypeScript must correctly infer the type as SymbolClass when kind === 'class'",
      "All symbol types must share a common base structure with 'kind' and 'basename' properties",
      "Type discrimination must work through the 'kind' property literal values",
      "Access to 'extends' property must be allowed after type narrowing"
    ],
    "created_at": "2017-10-08T12:59:55Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/18973",
    "source": {
      "issue_number": 18973
    },
    "initial_question": {
      "title": "compiler hide errors in tsx files, if there is \"import\"",
      "body": "**TypeScript Version:**  2.5.3\r\n\r\n**Code**\r\n\r\n1.tsx\r\n```ts\r\nimport Test from \"./2\"\r\n\r\ndeclare namespace JSX {\r\n  interface IntrinsicElements {\r\n    foo: { requiredProp: string; optionalProp?: number }\r\n  }\r\n}\r\nclass React {  static Render(a?: any, b?: any, c?: any) {} }\r\n\r\nfunction xxxxx() {\r\n  <foo />;\r\n}\r\n```\r\n2.ts\r\n```ts\r\nexport default class Test {}\r\n```\r\ncommand line\r\n``` tsc 1.tsx --jsx react```\r\n\r\n**Expected behavior:**\r\n```error TS2322: Type '{}' is not assignable to type '{ requiredProp: string; optionalProp?: number; }'.\r\n  Property 'requiredProp' is missing in type '{}'\r\n```\r\n\r\n**Actual behavior:**\r\ncompilation is success\r\n\r\n**Note:**  \r\nif I comment line 'import Test from \"./2\"', I get error as expected."
    },
    "satisfaction_conditions": [
      "JSX namespace declarations must be accessible in the correct scope",
      "Solution must maintain consistent behavior with and without imports"
    ],
    "created_at": "2017-10-05T20:02:24Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/18676",
    "source": {
      "issue_number": 18676
    },
    "initial_question": {
      "title": "Cannot find module 'vue' when 'module' is set to 'umd'",
      "body": "**TypeScript Version:**  2.5.2\r\n\r\nwhen tsc complie `d:/elecapp/one/comp/test.ts`\r\n\r\n**Code**\r\n\r\n```javascript\r\n======== Resolving module 'vue' from 'd:/elecapp/one/comp/test.ts'. ========\r\nModule resolution kind is not specified, using 'Classic'.\r\nFile 'd:/elecapp/one/comp/vue.ts' does not exist.\r\nFile 'd:/elecapp/one/comp/vue.tsx' does not exist.\r\nFile 'd:/elecapp/one/comp/vue.d.ts' does not exist.\r\nFile 'd:/elecapp/one/vue.ts' does not exist.\r\nFile 'd:/elecapp/one/vue.tsx' does not exist.\r\nFile 'd:/elecapp/one/vue.d.ts' does not exist.\r\nFile 'd:/elecapp/vue.ts' does not exist.\r\nFile 'd:/elecapp/vue.tsx' does not exist.\r\nFile 'd:/elecapp/vue.d.ts' does not exist.\r\nFile 'd:/vue.ts' does not exist.\r\nFile 'd:/vue.tsx' does not exist.\r\nFile 'd:/vue.d.ts' does not exist.\r\nDirectory 'd:/elecapp/one/comp/node_modules' does not exist, skipping all lookups in it.\r\nDirectory 'd:/elecapp/one/node_modules' does not exist, skipping all lookups in it.\r\nFile 'd:/elecapp/node_modules/@types/vue.d.ts' does not exist.\r\nDirectory 'd:/node_modules' does not exist, skipping all lookups in it.\r\nFile 'd:/elecapp/one/comp/vue.js' does not exist.\r\nFile 'd:/elecapp/one/comp/vue.jsx' does not exist.\r\nFile 'd:/elecapp/one/vue.js' does not exist.\r\nFile 'd:/elecapp/one/vue.jsx' does not exist.\r\nFile 'd:/elecapp/vue.js' does not exist.\r\nFile 'd:/elecapp/vue.jsx' does not exist.\r\nFile 'd:/vue.js' does not exist.\r\nFile 'd:/vue.jsx' does not exist.\r\n======== Module name 'vue' was not resolved. ========\r\n```\r\n\r\n**Expected behavior:**\r\n\r\n```javascript\r\nFile 'd:/elecapp/node_modules/@types/vue.d.ts' does not exist.\r\nFile 'd:/elecapp/node_modules/vue/types/index.d.ts' exist.\r\n```\r\n\r\n**Actual behavior:**\r\n\r\n```javascript\r\nFile 'd:/elecapp/node_modules/@types/vue.d.ts' does not exist.\r\n```\r\n\r\nIt's only find `@types/vue.d.ts` does not exist , but it didn't find there is `vue/types/index.d.ts` already exists.\r\n\r\ninside /vue/package.json(there is typings):\r\n\r\n```javascript\r\n  \"typings\": \"types/index.d.ts\",\r\n  \"unpkg\": \"dist/vue.js\",\r\n  \"version\": \"2.4.4\"\r\n```\r\n\r\n\r\nps tsconfig.json:\r\n```javascript\r\n{\r\n  \"compilerOptions\": {\r\n    \"target\": \"es5\",\r\n    \"module\": \"umd\",\r\n    \"declaration\": false,\r\n    \"traceResolution\": true,\r\n    \"noImplicitAny\": false, \r\n    \"skipLibCheck\": true, \r\n    \"allowJs\": false,\r\n    \"checkJs\": false,\r\n    \"lib\": [\r\n      \"dom\",\r\n      \"scripthost\",\r\n      \"webworker\",\r\n      \"es5\",\r\n      \"es2015\",\r\n      \"es2016\",\r\n      \"es2017\",\r\n      \"esnext\"\r\n    ]\r\n  },\r\n  \"include\": [\r\n    \"one/*/*.tsx\",\r\n    \"one/*/*.ts\"\r\n  ],\r\n  \"exclude\": []\r\n}\r\n```"
    },
    "satisfaction_conditions": [
      "TypeScript configuration must be compatible with UMD module format"
    ],
    "created_at": "2017-09-22T02:08:27Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/18389",
    "source": {
      "issue_number": 18389
    },
    "initial_question": {
      "title": "Overloading function with literal argument doesn't work",
      "body": "**TypeScript Version:**  2.5.2\r\n\r\n**Code**\r\n```ts\r\nfunction test(p: 'a'): 'a';\r\nfunction test(p: string): string {\r\n    return p;\r\n}\r\n\r\ntest('b');\r\n```\r\n\r\n**Expected behavior:**\r\nno errors\r\n\r\n**Actual behavior:**\r\nArgument of type '\"b\"' is not assignable to parameter of type '\"a\"'.\r\n"
    },
    "satisfaction_conditions": [
      "Function maintains type safety for literal type 'a'"
    ],
    "created_at": "2017-09-11T15:56:31Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/18041",
    "source": {
      "issue_number": 18041
    },
    "initial_question": {
      "title": "keyof strange type casting",
      "body": "TSC 2.4.2\r\n\r\n```ts\r\nfunction foo1<T>(e: T, k: string) {\r\n    let\r\n        v = e[k];   // v: any\r\n}\r\n\r\nfunction foo2<T>(e: T, k: keyof T) {\r\n    let\r\n        v = e[k];   // v: T[keyof T]\r\n}\r\n```\r\n\r\nI would expect that for `foo2` type of `v` should also be `any`"
    },
    "satisfaction_conditions": [
      "Type inference must differentiate between string and keyof T parameters",
      "Type safety must be preserved when accessing object properties",
      "Index access with keyof T must return union of possible value types",
      "Index access with string must indicate potential type unsafety"
    ],
    "created_at": "2017-08-25T12:53:09Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/17854",
    "source": {
      "issue_number": 17854
    },
    "initial_question": {
      "title": "deconstruction of the object ",
      "body": "let obj = {\r\n    p: [\r\n      'Hello',\r\n      { y: 'World' }\r\n    ]\r\n  };\r\n  \r\n  let { p, p: [x, { y }] } = obj;\r\n \r\n\r\nwhy \r\nerror TS2459: Type 'string | {\r\ny: string; }' has no property 'y' and no strin\r\ng index signature.???????????"
    },
    "satisfaction_conditions": [
      "The context must provide sufficient type information for proper inference"
    ],
    "created_at": "2017-08-17T02:44:22Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/17795",
    "source": {
      "issue_number": 17795
    },
    "initial_question": {
      "title": "Type loss when using generic decorators",
      "body": "**TypeScript Version:**  2.4.1\r\n\r\nThe following code aims to restrict the decorator `decorate` to members of a class inheriting from `Base`. However, it seems that `K` ends up only including members in `Base`, not in the inherited class. (This is a minimal reproducible example for other cases, e.g., restricting the decorator to methods within subclasses of `Base` of a certain return type.)\r\n\r\n**Code**\r\n\r\n```ts\r\nabstract class Base {\r\n  base() { return 1; };\r\n}\r\n\r\ntype ProtoOf<T> = Pick<T, keyof T>;\r\n\r\nfunction decorate<T extends Base, K extends keyof ProtoOf<T>, F extends T[K]>() {\r\n  return (proto: ProtoOf<T>, propertyKey: K, descriptor: TypedPropertyDescriptor<F>) => {\r\n    // Do stuff.\r\n  };\r\n}\r\n\r\nclass Test extends Base {\r\n  @decorate()\r\n  bar(): boolean {\r\n    return false;\r\n  }\r\n}\r\n```\r\n\r\n**Expected behavior:**\r\nNo errors when applying `@decorate()` to `bar()`.\r\n\r\n**Actual behavior:**\r\nError: `[ts] Argument of type '\"bar\"' is not assignable to parameter of type '\"base\"'.`"
    },
    "satisfaction_conditions": [
      "Decorator must correctly access properties from both base and derived classes",
      "Type inference must work at decoration time",
      "Decorator must support referencing other class members",
      "Type safety must be maintained for referenced properties"
    ],
    "created_at": "2017-08-15T04:50:06Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/17515",
    "source": {
      "issue_number": 17515
    },
    "initial_question": {
      "title": "tsc is transpiling multiple files, when I just want 1 file transpiled",
      "body": "Not sure if this is a bug or not.\r\n\r\nI have a file like so:\r\n\r\n```typescript\r\n//foo.ts\r\nimport {Client} from \"../../client\";\r\nconsole.log('foo');\r\n```\r\n\r\nI transpile this .ts file like so:\r\n\r\n `tsc ${foo} --outDir \"${OUT_DIR}\"`\r\n\r\nwhat happens, however, is that tsc will transpile multiple files including `../../client`, and write them out to the filesystem.\r\n\r\nI would expect only `${foo}` to get transpiled.\r\n\r\n`${foo}` represents just one file, I double checked.\r\n\r\nAny idea if this is a bug or expected behavior? It's causing problems for me, as is.\r\n\r\n"
    },
    "satisfaction_conditions": [
      "TypeScript compilation command executes without errors"
    ],
    "created_at": "2017-07-30T03:32:41Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/17333",
    "source": {
      "issue_number": 17333
    },
    "initial_question": {
      "title": "Relax rule about `super` followed by member access",
      "body": "I have a method that takes a class type. I can pass an explicit class name to it `Foo`, or I can pass `this`, but I cannot pass `super` because of the ts error:\r\n\r\n> 'super' must be followed by an argument list of member access.\r\n\r\nIs there a specific design goal behind disabling this?\r\n\r\n**TypeScript Version:**  2.4.1\r\n"
    },
    "satisfaction_conditions": [
      "Code must comply with ES6 language specification",
      "Valid ES5 transpilation must be possible",
      "Syntax error must be correctly identified by compiler"
    ],
    "created_at": "2017-07-20T22:33:00Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/17034",
    "source": {
      "issue_number": 17034
    },
    "initial_question": {
      "title": "how to disable 'this' tranform to '_this'\uff0cI want to add linq extension metthod for Array",
      "body": "I want to add linq extension metthod for Array, like c# static Extension method\u3002\r\n\r\nhere is the code\r\n\r\ndeclare interface Array<T> {\r\n    where(predicate: (value?: T, index?: number, list?: T[]) => boolean): T[];\r\n}\r\nArray.prototype.where = (predicate?: (value?: T, index?: number, list?: T[]) => boolean) => {\r\n return this.filter(predicate);\r\n};\r\n\r\nbut the tsc compiled 'this 'into '_this',and code work incorrect."
    },
    "satisfaction_conditions": [
      "Method maintains correct type safety"
    ],
    "created_at": "2017-07-08T16:49:51Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/16927",
    "source": {
      "issue_number": 16927
    },
    "initial_question": {
      "title": "Failed to launch external program tsc -p ts spawn tsc ENOENT",
      "body": "**TypeScript Version:**  2.4.1\r\n**VSCode Version:** 1.3.1\r\n**OS Version:** Linux Mint 18.1\r\n**node:** 6.11.0\r\n**npm:** 5.0.3\r\n\r\nSteps to Reproduce:\r\n\r\nOpen VSCode insider from Nemo or from terminal\r\nTry to run build task **Ctrl+Shift+B** (using tsc -p in task.json 'args')\r\n\r\ntasks.json\r\n```javascript\r\n{\r\n    \"version\": \"0.1.0\",\r\n    \"command\": \"tsc\",\r\n    \"isShellCommand\": true,\r\n    \"args\": [\"-p\", \"ts\"],\r\n    \"showOutput\": \"silent\",\r\n    \"problemMatcher\": \"$tsc\"\r\n}\r\n```\r\n\r\nhelloworld.ts in **ts** folder\r\n```typescript\r\nclass HelloWorld {\r\n    \r\n}\r\n```\r\ntsconfig.json\r\n```javascript\r\n{\r\n    \"compilerOptions\": {\r\n        \"target\": \"es5\",\r\n        \"outFile\": \"../js/app.js\",\r\n        \"sourceMap\": true\r\n    }\r\n}\r\n```\r\n\r\nEmpty folder **js**\r\n\r\n**Expected behavior:**\r\nI believe that this setup should compile the typescrpt files in my project to js files and put them in my js folder.\r\n\r\n**Actual behavior:**\r\nWhen I hit **Ctrl+Shift+B** i get: \r\n**Failed to launch external program tsc -p ts.**\r\n**spawn tsc ENOENT**\r\nin the output window\r\n\r\nIts worth noting that if I run the **tsc** command with args in the VSCode terminal window in my projects root directory (tsc -p ts) it **DOES** seem to work fine(I get the expected behavior). \r\n\r\nThis issues is similar to #8434 \r\nI do have custom code in my .profile and .bashrc, but in my case it does not matter if I open from the terminal or from the file explorer\r\n\r\nrunning process.env.PATH in VScode dev tools console outputs the same path as running echo $PATH from my command line. "
    },
    "satisfaction_conditions": [
      "TypeScript compiler must be accessible to VSCode build task",
      "Build task must successfully compile TypeScript files",
      "Build task must work consistently across different launch methods",
      "Build task configuration must be valid VSCode task format"
    ],
    "created_at": "2017-07-04T16:06:56Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/16629",
    "source": {
      "issue_number": 16629
    },
    "initial_question": {
      "title": "Change return type by type guard",
      "body": "```\r\nclass Foo {\r\n  foo = 123;\r\n}\r\nclass Bar {\r\n  bar = 123;\r\n}\r\nfunction distinguish(arg: Foo | Bar): Foo | Bar {\r\n  if(arg instanceof Foo) {\r\n    return arg\r\n  }\r\n  else {\r\n    return arg\r\n  }\r\n}\r\nlet result: Foo = distinguish(new Foo())\r\n// Type 'Foo | Bar' is not assignable to type 'Foo'\r\n```"
    },
    "satisfaction_conditions": [
      "The function must preserve type information for the specific input type",
      "The return type must be assignable to the expected type without type assertions",
      "The function must handle both Foo and Bar types without losing type safety"
    ],
    "created_at": "2017-06-19T20:54:04Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/16192",
    "source": {
      "issue_number": 16192
    },
    "initial_question": {
      "title": "can any one tell me how to implement extension method for Array in Typescript (Let's suppose i want to write functionality for sorting the array )",
      "body": ""
    },
    "satisfaction_conditions": [
      "Array prototype is successfully extended with new method",
      "New method is accessible in TypeScript with proper type definitions",
      "Method can be imported and used in other TypeScript files",
      "Method maintains chainability with existing array methods"
    ],
    "created_at": "2017-06-01T11:29:42Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/15858",
    "source": {
      "issue_number": 15858
    },
    "initial_question": {
      "title": "React Props validation does not work for extended classes",
      "body": "We have a generic BaseComponent that does some autobinding and transition blocking. \r\n\r\nIf I have a component that extends BaseComponent<Props, State>, the compiler does not recognize error in props validation.\r\n\r\nThe following component does not throw compiler errors.\r\n```jsx\r\ninterface Props {\r\n  notMyField: string,\r\n}\r\n\r\nclass MyComponent extends BaseComponent<Props, any> {\r\n   render() {\r\n      return <div>{this.props.myField}</div>;\r\n   } \r\n}\r\n```\r\n\r\n```jsx\r\nimport * as PropTypes from 'prop-types';\r\nimport * as React from 'react';\r\n\r\n/**\r\n * The base component that autobinds all the methods to this.\r\n */\r\nclass BaseComponent<Props, State> extends React.Component<Props, State> {\r\n  static propTypes;\r\n  static contextTypes = {\r\n    router: PropTypes.object,\r\n  };\r\n\r\n  props;\r\n  unblock;\r\n\r\n  constructor(props: Props) {\r\n    super(props);\r\n    Object.getOwnPropertyNames(Object.getPrototypeOf(this)).forEach((method) => {\r\n      if (typeof this[method] !== 'function') {\r\n        return;\r\n      }\r\n      this[method] = this[method].bind(this);\r\n    });\r\n  }\r\n\r\n  componentDidMount() {\r\n    const {\r\n      props: {\r\n        history\r\n      },\r\n      willTransition\r\n    } = this as any;\r\n    // TODO: Figure out why react/prop-types is warning here.\r\n    /* eslint-disable react/prop-types */\r\n    if (history && willTransition) {\r\n      this.unblock = history.block(willTransition);\r\n    }\r\n    /* eslint-enable react/prop-types */\r\n  }\r\n\r\n  componentWillUnmount() {\r\n    if (this.unblock) {\r\n      this.unblock();\r\n    }\r\n  }\r\n}\r\n\r\nexport default BaseComponent;\r\n```"
    },
    "satisfaction_conditions": [
      "TypeScript compiler correctly identifies prop type mismatches",
      "Props type checking works with inherited components",
      "No implicit 'any' types interfere with prop validation"
    ],
    "created_at": "2017-05-15T22:08:29Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/15801",
    "source": {
      "issue_number": 15801
    },
    "initial_question": {
      "title": "--allowJs Unexpected behavior",
      "body": "Hello mates, \r\nI have a problem, when enable option \"allowJs\" , The ts compiler goes crazy \r\ntrying to compile again and again the same files \ud83d\udc4e \r\n\r\nThey could tell me why, Thanks for your time greetings!\r\n\r\nTypescript 2.3.2 \r\nvscode 1.12.1"
    },
    "satisfaction_conditions": [
      "TypeScript compiler must not enter infinite compilation loops",
      "Output files must not trigger recompilation of source files",
      "Configuration must properly separate source and output directories"
    ],
    "created_at": "2017-05-12T16:54:18Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/15793",
    "source": {
      "issue_number": 15793
    },
    "initial_question": {
      "title": "Object types (Specification)",
      "body": "From specification:\r\n````\r\n3.3 Object Types\r\n\r\nObject types are composed from properties, call signatures, construct signatures, \r\nand index signatures, collectively called members.\r\n3.8.3 Object Type Literals\r\n  ...\r\n  TypeMember:\r\n\u2003\u2003\u2003PropertySignature\r\n\u2003\u2003\u2003CallSignature\r\n\u2003\u2003\u2003ConstructSignature\r\n\u2003\u2003\u2003IndexSignature\r\n\u2003\u2003\u2003MethodSignature\r\n  ...\r\n  Object type members are described in section 3.9.\r\n\r\n3.9 Specifying Members\r\n3.9.5 Method Signatures\r\n\r\n  A method signature is shorthand for declaring a property of a function type.\r\n\r\n````\r\nWhy there is no **method signatures** in the first sentence?\r\n_Object types are composed from properties, call signatures, construct signatures, \r\nand index signatures, collectively called members._\r\n\r\nDoes `properties` mean `method and property signatures` together?\r\nIf so it is not evidently.\r\nMay be it is better to split `properties` into `property and method signatures`,\r\nbecause we will enumerate entities from one domain (signatures).  \r\n\r\n"
    },
    "satisfaction_conditions": [
      "Explanation must clarify the relationship between method signatures and property signatures",
      "Answer must demonstrate functional equivalence between method and property signature syntaxes"
    ],
    "created_at": "2017-05-12T08:21:38Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/15646",
    "source": {
      "issue_number": 15646
    },
    "initial_question": {
      "title": "[2339] Property ... does not exist on type 'typeof (Anonymous class)'",
      "body": "**TypeScript Version:**  2.2.1 stable\r\n\r\n**Code**\r\n\r\n```ts\r\nclass skrolr {\r\n    private static _Array = class extends Array {\r\n        from( obj: HTMLCollection ) {\r\n            let arr = [];\r\n            for( let i=0, len=obj.length; i<len; i++ ) {\r\n                arr[i] = obj[i];\r\n            }\r\n        }\r\n    }\r\n    \r\n    // in another class\r\n    skrolr._Array.from( [HTMLCollection object] );\r\n}\r\n```\r\n\r\n**Expected behavior:**\r\nSuccessful transpiling to ES3\r\n\r\n**Actual behavior:**\r\nError 2339\r\n\r\nBasically just trying to have a simplified polyfill for Array.from(), but I don't want this to be global, so I'm doing it in a subclass. It works as expected in ES6, and the subclass transpiles correctly to ES3, it's just the parser for some reason isn't seeing it."
    },
    "satisfaction_conditions": [
      "Method must be able to process HTMLCollection objects",
      "Implementation must maintain class privacy/scope"
    ],
    "created_at": "2017-05-08T00:34:59Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/15263",
    "source": {
      "issue_number": 15263
    },
    "initial_question": {
      "title": "Typing static class",
      "body": "**TypeScript Version:**  2.2.1\r\n\r\n**Code**\r\n\r\n```ts\r\nimport { Component, DebugElement, Type } from '@angular/core';\r\nimport { ComponentFixture, TestBed } from '@angular/core/testing';\r\n\r\ninterface TestFixture<T> {\r\n  component: T;\r\n  debugElement: DebugElement;\r\n  element: any;\r\n  fixture: ComponentFixture<T>;\r\n}\r\n\r\nexport function createComponent<T>(TestBed: Static<TestBed>, cmpt: Type<T>): TestFixture<T> {\r\n  const fixture = TestBed.createComponent(cmpt);\r\n  const component = fixture.componentInstance;\r\n  const debugElement = fixture.debugElement;\r\n  const element = fixture.nativeElement;\r\n\r\n  return { component, debugElement, element, fixture };\r\n}\r\n```\r\n\r\n**Expected behavior:**\r\n\r\nI propose that we have a good way of typing a static class value in a function argument - in this example, this prevents me from accurately typing `fixture`, `component`, `debugElement`, and `element` without force casting since TypeScript does not appear to support typing static instances.\r\n\r\nIn my example, I am proposing that a syntax such as `Static<TestBed>` represent the static class `TestBed`, which is not meant to be newed.\r\n\r\n**Actual behavior:**\r\n\r\nI get errors such as\r\n```\r\nTS2345: Argument of type 'typeof TestBed' is not assignable to parameter of type 'TestBed'\r\n```"
    },
    "satisfaction_conditions": [
      "Function parameter accepts static class reference without compilation errors",
      "Type definition preserves static method typing",
      "No instance creation requirement",
      "Compatible with third-party class definitions"
    ],
    "created_at": "2017-04-19T02:11:56Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/15215",
    "source": {
      "issue_number": 15215
    },
    "initial_question": {
      "title": "Performance request/question: direct use of \"arguments\" variable inside a function ",
      "body": "**TypeScript Version:**  2.2.2, Linux Ubuntu 16.04 x86_64.\r\n\r\nI find it depressing that I cannot use the arguments variable somehow directly, that I have to see TypeScript creating a horrible duplication of memory, and waste of time. I think/wish/dream we should be able to use \"...arguments\" so that the generated javascript can just use \"arguments\" directly.\r\n\r\nI think I want something like:\r\n\r\n```ts\r\nfunction foo(...arguments) {\r\n   console.log( arguments[0] ); // TS2396\r\n}\r\n```\r\n\r\nso I have to do something like:\r\n\r\n```ts\r\nfunction foo(...args) {\r\n   console.log( args[0] ); // ok\r\n}\r\n```\r\n\r\nbut it generates depressing overhead in the final js:\r\n\r\n```js\r\n// the generated js \r\n    var args = [];\r\n    for (var _i = 0; _i < arguments.length; _i++) {\r\n        args[_i] = arguments[_i];\r\n    }\r\n```\r\n"
    },
    "satisfaction_conditions": [
      "Generated JavaScript code must avoid unnecessary array copying of function arguments",
      "TypeScript compilation must produce clean output without argument array transformation",
      "Function must maintain ability to access variable number of arguments"
    ],
    "created_at": "2017-04-17T06:24:03Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/15025",
    "source": {
      "issue_number": 15025
    },
    "initial_question": {
      "title": "Inexplicable behavior",
      "body": "**Example 1**\r\n\r\n```ts\r\nclass foo {\r\n  readonly 1 // the same with private and static\r\n}\r\n```\r\n\r\n**Error**\r\n\r\nNo\r\n\r\n**Result**:\r\n\r\n```js\r\nvar foo = (function () {\r\n    function foo() {\r\n    }\r\n    return foo;\r\n}());\r\n\r\n```\r\n\r\n**Example 2**\r\n\r\n```ts\r\nclass foo {\r\n  const a () {} \r\n}\r\n```\r\n\r\n**Error**\r\n\r\n```\r\nError:(2, 9) TS1248:A class member cannot have the 'const' keyword.\r\n```\r\n\r\n**Result**:\r\n\r\n```js\r\nvar foo = (function () {\r\n    function foo() {\r\n    }\r\n    foo.prototype.a = function () { };\r\n    return foo;\r\n}());\r\n```\r\n\r\nIs it ok?\r\n"
    },
    "satisfaction_conditions": [
      "TypeScript property declarations without initializers must compile without affecting output JavaScript",
      "Numeric property names must be handled as valid class member keys",
      "Class method declarations with invalid modifiers must produce appropriate compiler errors",
      "TypeScript must generate valid JavaScript output even when reporting compilation errors"
    ],
    "created_at": "2017-04-05T14:54:28Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/14763",
    "source": {
      "issue_number": 14763
    },
    "initial_question": {
      "title": "Readonly tuple function",
      "body": "I want to create a function that returns a tuple with literal types.\r\n\r\nHere is what I got with TS 2.2:\r\n\r\n``` ts\r\nconst tuple2 = <A, B>(tuple: Readonly<[A, B]>): Readonly<[A, B]> => tuple\r\ntuple2(['foo', 'bar']) // actual Readonly<[string, string]>, expected Readonly<['foo', 'bar']>\r\n```\r\n\r\nIs there any way to make this return literal types?"
    },
    "satisfaction_conditions": [
      "Function returns tuple with preserved literal types",
      "Function maintains tuple immutability",
      "Function accepts multiple literal value types",
      "Type inference works without explicit type annotations"
    ],
    "created_at": "2017-03-21T13:24:08Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/14650",
    "source": {
      "issue_number": 14650
    },
    "initial_question": {
      "title": "When using the native method 'defineProperty ' to define a 'Getter' for a class, the compiler error!",
      "body": "**TypeScript Version:**  1.8.0\r\n\r\n**Code:**\r\n\r\n```ts\r\n// a function used to define targetObject's descriptor from SourceObject's properties\r\n\r\nfunction defineGetter(SourceObject, targetObject) {\r\n    \r\n    Object.keys(SourceObject).forEach(function (key) {\r\n        Object.defineProperty(targetObject.prototype, key, {\r\n            get: function () {\r\n                return SourceObject[key]\r\n            },\r\n            enumerable: true,\r\n            configurable: true\r\n        })\r\n    })\r\n}\r\n\r\ninterface IForm {\r\n    name: string;\r\n    label: string;\r\n    value: any;\r\n    sequence: number;\r\n    width: number;\r\n    type: number;\r\n}\r\n\r\n\r\nclass Form {\r\n    constructor(form: IForm) {\r\n        defineGetter(form, Form);\r\n    }\r\n    get info() {\r\n        return `name is ${this.name}, label is ${this.label}`;\r\n    }\r\n}\r\n\r\nlet form = new Form({\r\n       name: '1',\r\n       label: '2',\r\n       value: 3,\r\n       sequence: 4,\r\n       width: 5,\r\n       type: 6\r\n})\r\n```\r\n\r\n\r\n\r\n**Expected behavior & Actual behavior:**\r\nI want to complete my definition of **Getter** with metadata(a Singleton Object) through a **defineGetter ()** method, It seems to be successful. but, When I manually define another Getter (info), the compiler prompts\uff1a\r\n\r\n> \u201c error TS2339: Property 'name' does not exist on type 'Form'\u201d\r\n> \u201c  error TS2339: Property 'type' does not exist on type 'Form'. \u201d\r\n\r\nI just want to use a function to solve my burden of writing the getter repeatedly\uff0cHow can I solve this problem?\r\n\r\n\r\n"
    },
    "satisfaction_conditions": [
      "TypeScript compiler must recognize properties from IForm as valid members of Form class",
      "Class must provide getter access to all IForm properties",
      "Custom getters like 'info' must be able to access IForm properties without type errors",
      "Form instance must maintain the values provided in constructor",
      "Solution must reduce boilerplate code compared to manual getter definitions"
    ],
    "created_at": "2017-03-14T11:31:17Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/14627",
    "source": {
      "issue_number": 14627
    },
    "initial_question": {
      "title": "how can i type-annotate a function that creates an object literal out of a literal key and a value?",
      "body": "i have\r\n```typescript\r\nconst key: 'name' = 'name';\r\nconst value: number = 1;\r\n```\r\n\r\ni need a function that turns these key/value into an object with a property, in JavaScript it would look like:\r\n```javascript\r\n// javascript\r\nfunction(key, value) {\r\n    return { [key]: value };\r\n}\r\n```\r\n\r\nso that:\r\n```typescript\r\nconst data = fn(key, value);\r\n// data is expected to be of type: { name: number; }\r\n```\r\n\r\nis there a way to type-annotate `fn` so that it returns an object of type `{ name: number; }`? if so, how?\r\n"
    },
    "satisfaction_conditions": [
      "Function must accept a literal string key and a value of any type as parameters",
      "Return type must be an object with a single property matching the input key's type",
      "Property value in returned object must preserve the input value's type"
    ],
    "created_at": "2017-03-13T11:38:44Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/14608",
    "source": {
      "issue_number": 14608
    },
    "initial_question": {
      "title": "Unable to parameterize keyof (in function) to access object's fields",
      "body": "I'm having problems understanding how to parameterize **keyof**. I have extracted a simple code that describes the issue I'm facing.\r\n\r\n```ts\r\ninterface INested3 {\r\n    id: number;\r\n    name: string;\r\n}\r\n\r\ninterface INested2a {\r\n    id: number;\r\n    name: string;\r\n    nested3: INested3;\r\n}\r\n\r\ninterface INested2b {\r\n    id: number;\r\n    name: string;\r\n    nested3: INested3;\r\n}\r\n\r\ninterface INested1 {\r\n    id: number;\r\n    name: string;\r\n    nested2a: INested2a;\r\n    nested2b: INested2b;\r\n}\r\n\r\ninterface IFoo {\r\n    id: number;\r\n    name: string;\r\n    nested1: INested1;\r\n}\r\n\r\nfunction get<T, K1 extends keyof T, K2 extends keyof T[K1], K3 extends keyof T[K1][K2]>(obj: T, key1: K1, key2: K2, key3: K3): T[K1][K2][K3] {\r\n    return obj[key1][key2][key3];\r\n}\r\n\r\n// Fine\r\nfunction foo1a(f: IFoo): void {\r\n    console.log(\r\n        get(f, \"nested1\", \"nested2a\", \"nested3\")\r\n    );\r\n}\r\n\r\nfunction foo1b(f: IFoo): void {\r\n    console.log(\r\n        get(f, \"nested1\", \"nested2b\", \"nested3\")\r\n    );\r\n}\r\n\r\n// Not fine - why?\r\n// Argument of type '\"nested3\"' is not assignable to parameter of type '\"toString\" | \"valueOf\"'.\r\nfunction foo1param(f: IFoo, nested2key: keyof INested1): void {\r\n    console.log(\r\n        get(f, \"nested1\", nested2key, \"nested3\")\r\n    )\r\n}\r\n\r\nvar f: IFoo = {\r\n    id: 1,\r\n    name: \"Foo\",\r\n    nested1: {\r\n        id: 1,\r\n        name: \"Nested 1\",\r\n        nested2a: {\r\n            id: 1,\r\n            name: \"Nested 2A\",\r\n            nested3: {\r\n                id: 1,\r\n                name: \"Nested 3\",\r\n            }\r\n        },\r\n        nested2b: {\r\n            id: 1,\r\n            name: \"Nested 2B\",\r\n            nested3: {\r\n                id: 2,\r\n                name: \"Nested 3\",\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// Would like to use it like this\r\nfoo1param(f, \"nested2a\");\r\nfoo1param(f, \"nested2b\");\r\n```\r\n"
    },
    "satisfaction_conditions": [
      "Function must allow access to deeply nested object properties through parameterized keys",
      "Type checking must prevent invalid property access paths",
      "Parameter types must preserve the relationship between nested object levels"
    ],
    "created_at": "2017-03-12T13:05:47Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/14352",
    "source": {
      "issue_number": 14352
    },
    "initial_question": {
      "title": "String not assignable to string enum even when value is known at compile time and is part of the enum.",
      "body": "Typescript@2.1.6\r\n\r\nHere's an example:\r\n\r\n```\r\ninterface Test {\r\n    fun(opts: {foo: 'enum1' | 'enum2'}): void\r\n}\r\n\r\nconst bar: Test = {\r\n    fun: (opts) => { }\r\n}\r\n\r\nconst defaults = {\r\n    foo: 'enum1'\r\n};\r\n\r\nbar.fun(defaults) // Error: Type 'string' is not assignable to type '\"enum1\" | \"enum2\"'\r\n```\r\n\r\nShouldn't `defaults.foo` be inferred to be a subset of the string enum?"
    },
    "satisfaction_conditions": [
      "Type safety must be maintained for mutable variables",
      "Type declarations must be compatible with string literal union types",
      "Type compatibility must be verifiable at compile time"
    ],
    "created_at": "2017-02-28T03:27:45Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/14321",
    "source": {
      "issue_number": 14321
    },
    "initial_question": {
      "title": "locally modifying+testing published definitions is a pain (bug/rant/perhaps-question)",
      "body": "the ```@types``` process is pretty great for consuming .d.ts files (much better than the previous typings or tsd workflows)   \r\n\r\nhowever, I seem to have a big problem as a creator of ```.d.ts``` for publication.    I don't see any way of creating a .d.ts file for local use and testing, and then be able to then publish the file as-is.   \r\n\r\nFor example, if this is a definition I publish to DT:  \r\n\r\n```foo/index.d.ts```:\r\n`\r\ndeclare namespace Foo{ export function foo():void; }\r\nexport = Foo;\r\nexport as namespace Foo;\r\n`\r\n\r\nand usage:\r\n`\r\nimport foo = require(\"foo\");\r\n`\r\n\r\n\r\nHow would I consume my own definitions for ```foo``` locally?  I don't see how to do this with the normal import style.  instead I need to modify my d.ts and consumption usage like:\r\n\r\n```myProject/_dts/foo.ts```\r\n`\r\nexport declare namespace _foo{ export function foo():void; }\r\nexport const Foo: typeof _foo = require(\"foo\");\r\n`\r\nand usage:\r\n`\r\nimport foo = require(\"./_dts/foo\");\r\n`\r\n\r\nBasically this means that I can't easily test and/or modify a definition that I want to share publically, which adds a lot of friction for re-contributing to the community.   Am I doing something wrong?  Is there an easy way to modify and locally reference a published type?\r\n\r\n\r\n\r\n**Note**: I don't know if i'm doing it wrong these days, so please correct my understanding if you see problems with my logic above.\r\n\r\n\r\n"
    },
    "satisfaction_conditions": [
      "Local type definitions must be usable with the same import syntax as published definitions",
      "TypeScript compiler must correctly resolve local type definitions",
      "Transition from local to published definitions must not require code changes",
      "Local type definitions must maintain the same structure as intended for publication"
    ],
    "created_at": "2017-02-26T19:56:07Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/13952",
    "source": {
      "issue_number": 13952
    },
    "initial_question": {
      "title": "Local @types",
      "body": "Hi all,\r\n\r\nI'm developing 2 libraries `A` and `B` in different folders where `A` is exported as target es5 and module commonjs.\r\n\r\nIn `B` I'd like to use `index.d.ts` from `A` among other @types libraries which are in node_modules folder. And then use some classes from `A` via in import like this: `import {MyClass} from \"a\";`.\r\nUnfortunately this doesn't work: a not found in `node_modules/@types/a` etc.\r\nI tried without success with:\r\n \r\n```typescript\r\n\"baseUrl\": \".\",\r\n    \"paths\": {\r\n      \"a\": [\r\n        \"lib/a\"\r\n      ]\r\n    },\r\n```\r\n\r\nHow to setup typescript to find lib/a/index.d.ts without modifying my import with relative path (e.g. `import {MyClass} from \"../lib/a/index\";`)?\r\n"
    },
    "satisfaction_conditions": [
      "TypeScript compiler successfully resolves imports using the package name 'a' without requiring relative paths",
      "TypeScript finds and uses the type definitions (index.d.ts) from library A when used in library B",
      "Configuration maintains the separate folder structure of libraries A and B",
      "TypeScript path resolution configuration correctly maps the package name to the actual file location"
    ],
    "created_at": "2017-02-08T12:49:49Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/13907",
    "source": {
      "issue_number": 13907
    },
    "initial_question": {
      "title": "Avoid \"cannot assign an abstract constructor ...\" through union type",
      "body": "I have this code in TS 2.1:\r\n```ts\r\nabstract class Test { _brand: string; }\r\n\r\nfunction test1<T>(arg: { new(): T }): T { return null!; }\r\nfunction test2<T>(arg: { new(): T } | Function): T { return null!; }\r\n\r\nconst a = test1(Test);\r\nconst b = test2(Test);\r\n```\r\nAs discussed in #5843, `test1` is not supposed to typecheck. However, surprisingly, `test2` does.\r\nTypeScript infers `T` for `a` and `Test` for `b`.\r\nI don't know whether this is intended - can I build upon that behavior?"
    },
    "satisfaction_conditions": [
      "Type inference must correctly handle abstract class constructors",
      "Type information must be preserved when using abstract classes",
      "Must support metadata decoration on classes"
    ],
    "created_at": "2017-02-06T20:28:23Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/13809",
    "source": {
      "issue_number": 13809
    },
    "initial_question": {
      "title": "[request] allow namespaces to become types",
      "body": "How about allowing namespaces to become types?\r\n\r\ne.g.)\r\n\r\n```typescript\r\n// some declaration file I can't touch\r\ndeclare module monaco {   //this is monaco, not 'monaco'. so it's a namespace.\r\n   ...\r\n}\r\n\r\ntype _MonacoNamespaceType = ::monaco; // or any other syntax is fine.\r\n```\r\n--------------------------------\r\nbackground: I'm having problems trying to write d.ts file for react-monaco-editor.\r\n\r\nmonaco-editor's typescript definition has everything in ts namespaces, so I'm stuck trying to get 'monaco' as a type.\r\n\r\nhere's the definition file I'm working on:\r\n```typescript\r\n/// <reference path=\"../../node_modules/monaco-editor/monaco.d.ts\" />\r\n\r\n\r\ndeclare module 'react-monaco-editor' {\r\n  import { Component } from 'react';\r\n  export type ReactMonacoEditorProps = {\r\n    width: string,\r\n    height: string,\r\n    language: string,\r\n    options: monaco.editor.IEditorOptions,\r\n    editorDidMount?: (editor: monaco.editor.ICodeEditor, monaco: any) => any,\r\n  };\r\n  import test = monaco;\r\n  export type ICodeEditor = monaco.editor.ICodeEditor;\r\n  export default class ReactMonacoEditor\r\n      extends Component<ReactMonacoEditorProps, void> { }\r\n}\r\n```\r\nAs you can see on **editorDidMount?: (editor: monaco.editor.ICodeEditor, monaco: any) => any,**\r\nI couldn't give the 'monaco' type on monaco as 'monaco' namespace cannot be a type."
    },
    "satisfaction_conditions": [
      "The solution must allow referencing a namespace as a type in TypeScript type declarations",
      "The type reference must preserve the full structure and type information from the original namespace",
      "The solution must work with external declaration files that cannot be modified",
      "The resulting type must be usable in function parameter type annotations"
    ],
    "created_at": "2017-02-01T06:21:10Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/13530",
    "source": {
      "issue_number": 13530
    },
    "initial_question": {
      "title": "Invoking methods from object iteration",
      "body": "**TypeScript Version:**  2.1.5\r\n\r\n**Code**\r\n\r\n```ts\r\nclass Params {\r\n\tpublic paramsInit () {\r\n\t\tfor ( let prop in this ) {\r\n\t\t\tif ( typeof this[ prop ] === 'function' ) {\r\n\t\t\t\tlet res = this[ prop ]();\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\nclass Test extends Params {\r\n\tconstructor () {\r\n\t\tsuper();\r\n\t\tthis.paramsInit();\r\n\t}\r\n\r\n\tpublic param1 (): void {\r\n\t\tconsole.log( 'param1' );\r\n\t}\r\n}\r\n```\r\n\r\n**Expected behavior:**\r\n\r\nIn TypeScript 2.0 the above compiles without any errors.\r\n\r\n**Actual behavior:**\r\n\r\nIn TypeScript 2.1.5 I get:\r\n\r\n> test.ts(5,15): error TS2349: Cannot invoke an expression whose type lacks a call signature. Type 'Params[keyof this]' has no compatible call signatures.\r\n\r\nI can see why tsc might not like invooking `this[ prop ]`, but I can't see any way to tell it that it is a valid function. I've tried using `as` in various combinations, but with no luck.\r\n\r\nIs there a way to get this to compile in 2.1 without errors?"
    },
    "satisfaction_conditions": [
      "Code must compile successfully in TypeScript 2.1.5 and later versions",
      "Dynamic method invocation through property iteration must execute",
      "Type safety requirements must be explicitly addressed"
    ],
    "created_at": "2017-01-17T12:05:32Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/13399",
    "source": {
      "issue_number": 13399
    },
    "initial_question": {
      "title": "files/dirs that start with a dot (.) do not get copied or transpiled by default",
      "body": "**TypeScript Version:**  2.1.4\r\n\r\n**Code**\r\n\r\n```\r\n/lib\r\n/test\r\n    /.suman\r\n    /test-src\r\n```\r\n\r\nif I build this project with `tsc` and use the outDir option, the .suman directory **won't** get moved/transpiled, presumably because it starts with a dot .\r\n\r\nbased on the above project structure, the resulting _incorrect_ build would look like:\r\n\r\n```\r\n/dist\r\n   /lib\r\n   /test\r\n       /test-src  \r\n```\r\nabove we can see that the .suman dir is missing from the test dir\r\n\r\nif I rename the .suman directory to suman like so:\r\n\r\n```\r\n/lib\r\n/test\r\n    /suman    // renamed from .suman to suman\r\n    /test-src\r\n```\r\n\r\nthen it will get moved to the outDir, because it no longer starts with a dot .\r\n\r\nso the expected result actually happens, which is of course:\r\n\r\n```\r\n/dist\r\n   /lib\r\n   /test\r\n       /suman\r\n       /test-src\r\n```\r\n\r\n\r\n\r\n\r\nhere is my config, which shows that I want to `include` my test dir, in the build.\r\n\r\n```json\r\n{\r\n  \"compilerOptions\": {\r\n    \"compileOnSave\": true,\r\n    \"target\": \"es5\",\r\n    \"noImplicitAny\": false,\r\n    \"removeComments\": true,\r\n    \"preserveConstEnums\": true,\r\n    \"outDir\": \"dist\",\r\n    \"allowJs\": true,\r\n    \"allowUnreachableCode\": true,\r\n    \"lib\": [\"es2015\", \"dom\"]\r\n  },\r\n  \"include\": [\r\n    \"./**/*\"\r\n  ],\r\n  \"exclude\": [\r\n    \"node_modules\"\r\n  ]\r\n}\r\n\r\n```\r\n\r\n**Expected behavior:**\r\n\r\nI would expect it would include files/directories that start with a dot, unless you exclude files/dirs that start with a dot\r\n\r\n**Actual behavior:**\r\n\r\nTS/tsc seems to exclude files/dirs that start with a dot by default, which seems very strange, since users could easily specify with a regex to ignore dirs/files that start with a dot!\r\n\r\n**My question is then, is there a tsconfig.json setting I can use to include the .suman directory with my build?**\r\n"
    },
    "satisfaction_conditions": [
      "Hidden directories (starting with '.') are included in the TypeScript compilation output",
      "Directory structure in output maintains the same hierarchy as source",
      "TypeScript configuration properly handles recursive file inclusion",
      "Build output does not process its own generated files"
    ],
    "created_at": "2017-01-10T20:04:48Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/13311",
    "source": {
      "issue_number": 13311
    },
    "initial_question": {
      "title": "Performance Query - Large String Union Types",
      "body": "## Background \r\n\r\nWe have a 2000 line localization file, and a localize function in our code which pulls out the translation at run-time.\r\n\r\nI am investigating the possibility of auto-generating a large string union type, writing it out to a file, and using it as a type parameter for the localize function.\r\n\r\n## Code\r\n\r\n**TypeScript Version:**  2.1.4\r\n\r\n**Before**\r\n\r\n```ts\r\nfunction localize(id: string) {\r\n   // ...\r\n}\r\n\r\nlocalize('not a real key'); // OK\r\n```\r\n\r\n**After**\r\n\r\n```ts\r\nfunction localize(id: LocalizationKey) {\r\n   // ...\r\n}\r\n\r\nlocalize('not a real key'); // NOT OK\r\n\r\n// auto-generated\r\ntype LocalizationKey =\r\n    \"foo\"\r\n  | \"bar\"\r\n  | ... // 2000+ items.\r\n```\r\n\r\nThis works fine.\r\n\r\n## Question\r\n\r\nWe are concerned about type-checking performance, both at compile time, and in TypeScript language services in our IDEs (VS Code and Visual Studio).\r\n\r\nIs this a valid concern, or will these types be cached in an efficient manner?\r\n\r\nThanks."
    },
    "satisfaction_conditions": [
      "Type checking performance remains acceptable with large string union types",
      "Type safety is enforced for string literal values"
    ],
    "created_at": "2017-01-06T03:35:44Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/13207",
    "source": {
      "issue_number": 13207
    },
    "initial_question": {
      "title": "\u03bb return object",
      "body": "let func=(val:number)=>{x:val};//error\r\nlet func=(val:number)=>{return {x:val};};//ok"
    },
    "satisfaction_conditions": [
      "Function must return an object containing property x with the input value",
      "Syntax must distinguish between function body and object literal",
      "TypeScript compilation must succeed without errors",
      "Function type signature must match number input to object output"
    ],
    "created_at": "2016-12-29T05:43:13Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/13200",
    "source": {
      "issue_number": 13200
    },
    "initial_question": {
      "title": " Conflict between  Intersection types and keyof",
      "body": "**TypeScript Version:**  2.1.4 / nightly (2.2.0-dev.20161228)\r\n\r\n**Code**\r\n\r\n```ts\r\nclass Tween<T>{\r\n\r\n    static get<T>(target: T): Tween<T> {\r\n        return new Tween(target);\r\n    }\r\n\r\n    constructor(private target: T) {\r\n\r\n    }\r\n\r\n    /** \r\n     * modify the value of target from a old number value to new number value;\r\n     * there are two rules props should be followed : \r\n     * 1. key of props must be the key of target \r\n     * 2. every value of props should be number\r\n     */\r\n    public to(props: Partial<T> & { [index: string]: number }) {\r\n\r\n    }\r\n}\r\n\r\n\r\nvar textField = { x: 0, y: 0, text: \"helloworld\" };\r\nvar tween = Tween.get(textField);\r\ntween.to({ \"x\": 100 })\r\ntween.to({ \"xx\": 100 });\r\ntween.to({ \"text\": \"hello,typescript\" });\r\ntween.to({ \"text\": 1 });\r\n\r\n```\r\n\r\n\r\n**Expected behavior:**\r\n```\r\ntween.to({ \"x\": 100 }) // right\r\ntween.to({ \"xx\": 100 });  // report error because 'xx' is not existed in typeof textfield\r\ntween.to({ \"text\": \"hello,typescript\" }); // report error because 'hello,typescript' is not number\r\ntween.to({ \"text\": 1 });// report error because 'text' in typeof textfield should be string\r\n```\r\n\r\n\r\n**Actual behavior:**\r\n\r\n```\r\ntween.to({ \"x\": 100 }) // right\r\ntween.to({ \"xx\": 100 });  // right , why ???????\r\ntween.to({ \"text\": \"hello,typescript\" }); // report error because 'hello,typescript' is not number\r\ntween.to({ \"text\": 1 });// report error because 'text' in typeof textfield should be string\r\n```"
    },
    "satisfaction_conditions": [
      "All property values in the input object must be numbers",
      "Type compatibility between target properties and input values must be enforced",
      "The type definition must correctly handle partial updates",
      "Type errors must be detected at compile time"
    ],
    "created_at": "2016-12-28T13:36:15Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/12877",
    "source": {
      "issue_number": 12877
    },
    "initial_question": {
      "title": "How to convert enum type to Array<Object>",
      "body": "I want convert enum type to Array<Object>.\r\n\r\nexample : \r\n\r\nenum A {\r\n  dog = 1,\r\n  cat = 2,\r\n  ant = 3\r\n}\r\n\r\nconvert to: [{id: 1, name: 'dog'}, {id: 2, name: 'cat'}, {id: 3, name: 'ant'}]\r\n\r\n\r\nthank you."
    },
    "satisfaction_conditions": [
      "Output must be an array of objects with 'id' and 'name' properties",
      "All enum members must be represented in the output array",
      "Enum numeric values must be preserved as 'id' in output objects",
      "Enum keys must be preserved as 'name' in output objects",
      "Original enum structure must remain unmodified"
    ],
    "created_at": "2016-12-13T11:47:34Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/12821",
    "source": {
      "issue_number": 12821
    },
    "initial_question": {
      "title": "Is it safe to access private members by using an element access expression?",
      "body": "**TypeScript Version:**  2.1 / nightly (2.2.0-dev.20161127)\r\n\r\n**Code**\r\n```ts\r\ninterface SomeType { }\r\n\r\nclass A { private m: SomeType; }\r\n\r\nclass B {\r\n\tfoo(a: A) {\r\n\t\tconst n1 = a.m; // (1)\r\n\t\tconst n2 = a[\"m\"]; // (2)\r\n\t}\r\n}\r\n```\r\nAs expected, the property access expression (1) produces a compile error. However, the element access expression (2) does not, even though typescript recognizes that (2) refers to member \"A.m\" as it infers the type \"SomeType\" for n2.\r\n\r\nCan I expect (2) to not produce any compile errors in future typescript versions?"
    },
    "satisfaction_conditions": [
      "Element access expressions (obj['property']) must continue to bypass private member restrictions",
      "Any future changes to this behavior must maintain backward compatibility",
      "If behavior changes are made, they must be optional via compiler configuration"
    ],
    "created_at": "2016-12-10T10:36:12Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/12650",
    "source": {
      "issue_number": 12650
    },
    "initial_question": {
      "title": "Bug or feature?",
      "body": "TypeScript Version:  2.0.10\r\n\r\nThe following code does _not_ produce a syntax error (and I am really hoping this is a feature and not a bug):\r\n```ts\r\nclass MyClass {\r\n    test: { (): number; (_: number): MyClass }\r\n}\r\nlet tmp = new MyClass();\r\ntmp\r\n    .test(22)\r\n    .test()\r\n;\r\n```\r\n\r\n**Expected behavior:**\r\nSyntax error at compilation time on MyClass declaration\r\n\r\n**Actual behavior:**\r\nRuntime error on call to ```tmp.test```\r\n\r\n"
    },
    "satisfaction_conditions": [
      "TypeScript must accept the overloaded function type declaration in class property",
      "Property must support both function signatures: () => number and (num: number) => MyClass",
      "Implementation must properly handle runtime function calls",
      "Property must be assignable to the declared overloaded type"
    ],
    "created_at": "2016-12-04T13:38:05Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/12549",
    "source": {
      "issue_number": 12549
    },
    "initial_question": {
      "title": "bug: type predicates (`V is T`) fails on expressions (`V[K] is T`)",
      "body": "**TypeScript Version:** nightly (2.2.0-dev.20161128)\r\n\r\n**Code**\r\n\r\n```ts\r\npropIs<T, V, K extends keyof V>(type: T, name: K, obj: V): V[K] is T;\r\n```\r\n\r\n**Expected behavior:**\r\nTS being totally cool with `V[K] is T`.\r\n\r\n**Actual behavior:**\r\nNope, many syntax errors.\r\n"
    },
    "satisfaction_conditions": [
      "Type predicate syntax must follow TypeScript's parameter name requirement",
      "Type narrowing must work for accessed properties",
      "Solution must preserve type safety with generic constraints"
    ],
    "created_at": "2016-11-29T04:37:52Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/12385",
    "source": {
      "issue_number": 12385
    },
    "initial_question": {
      "title": "error TS2304: Cannot find name 'UriMapHandlerArray'.",
      "body": "UriMapHandlerArray is defined in the same file, TS cannot find it.\r\n\r\nts v2.0.10\r\n**Code**\r\n\r\n```js\r\ninterface UriMapHandlerArray {\r\n  [index: string]: IUriMapHandler;\r\n}\r\n\r\nexport class Furi {\r\n\r\n  private _get:    IUriMap = { uri_map: UriMapHandlerArray };\r\n```\r\n\r\n```ts\r\n// A *self-contained* demonstration of the problem follows...\r\n\r\n```\r\n\r\n**Expected behavior:**\r\n\r\n**Actual behavior:**\r\n"
    },
    "satisfaction_conditions": [
      "Type declaration and value usage are correctly distinguished",
      "Interface property is assigned a valid object literal",
      "Original interface structure is preserved"
    ],
    "created_at": "2016-11-19T21:03:42Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/11887",
    "source": {
      "issue_number": 11887
    },
    "initial_question": {
      "title": "Typescript error TS5055",
      "body": "**TypeScript Version:**  nightly (2.1.0-dev.20161027)\n\n**Simulation**\n\nCreate a project with the following configuration:\n\n``` json\n{\n  \"compilerOptions\": {\n    \"module\": \"commonjs\",\n    \"target\": \"es5\",\n    \"experimentalDecorators\": true,\n    \"emitDecoratorMetadata\": true,\n    \"noImplicitAny\": true,\n    \"noUnusedParameters\": true,\n    \"noUnusedLocals\": true,\n    \"noEmitOnError\": true,\n    \"skipLibCheck\": true,\n    \"declaration\": true,\n    \"sourceMap\": true,\n    \"outDir\": \"out/\",\n    \"rootDir\": \"src\",\n    \"baseUrl\": \"src\",\n    \"moduleResolution\": \"node\",\n    \"lib\": [\n      \"es5\",\n      \"es2015\",\n      \"dom\"\n    ]\n  },\n  \"exclude\": [\n    \"node_modules\"\n  ]\n}\n```\n\nThe directory structure should be:\n- project\n  - src\n    - index.ts\n    - hello.ts\n  - out\n\nThe content of the `hello.ts` could be:\n\n``` typescript\nexport function hello(name: string) {\n  return `Hello, ${name}`;\n}\n```\n\nThe `index.ts` should re-export the hello module contents:\n\n``` typescript\nexport * from \"./hello\";\n```\n\nAfter that, compile twice using the vscode or the tsc:\n- `tsc -p .`\n- `tsc -p .`\n\n**Expected behavior:**\n\nCompile and produce again the js and the definitions.\n\n**Actual behavior:** \n\nIn the first compilation, it will compile normally. But at the second one, it will file with a message like `error TS5055: Cannot write file '.../hello.d.ts' because it would overwrite input file.\n"
    },
    "satisfaction_conditions": [
      "TypeScript configuration must remain valid for declaration file generation"
    ],
    "created_at": "2016-10-27T12:49:27Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/11792",
    "source": {
      "issue_number": 11792
    },
    "initial_question": {
      "title": "Question: Why are some of the CompilerOptions Internal?",
      "body": "I am upgrading my bundling Typescript compiler to use Typescript 2.x and noticed that a number of CompilerOptions ares now internal ( Diagnostics, ListFiles, Watch, etc ). Is there a reason for this?\n"
    },
    "satisfaction_conditions": [
      "Custom compiler options must remain accessible for third-party tooling",
      "Solution must maintain compatibility with TypeScript 2.x API design",
      "Custom functionality must not interfere with TypeScript's internal compiler options",
      "Implementation must allow for custom property declaration on compiler options"
    ],
    "created_at": "2016-10-22T00:45:52Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/11472",
    "source": {
      "issue_number": 11472
    },
    "initial_question": {
      "title": "Define array of non-nullables",
      "body": "I need to define array of any non-nullable values. Is it possible?\nExample:\n\n``` ts\ndeclare type NonNullable; // this is placeholder for type, which I am looking for\nlet a: NonNullable[] = [];\nlet b: string | null;\na.push(b); // expected compile error;\n```\n"
    },
    "satisfaction_conditions": [
      "Type definition prevents null and undefined values from being assigned to array elements",
      "Compiler raises an error when attempting to add nullable values to the array",
      "Array can still accept valid non-null values of any type",
      "Solution works with TypeScript's type system"
    ],
    "created_at": "2016-10-09T19:20:31Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/11402",
    "source": {
      "issue_number": 11402
    },
    "initial_question": {
      "title": "Unification overly simplifies types resulting in the swallowing of 'undefined'",
      "body": "**TypeScript Version:**  2.0.3\n\nThis is very problematic as it weakens undefined safety _a lot_.\n\n**Code**\n\n``` ts\nfunction bar<A>(c:boolean, a:A, au:A |\u00a0undefined) { // foo return type is inferred to A instead of A | undefined\n    return c ? a : au;\n}\n```\n\n**Expected behavior:**\n\nbar return type is inferred to A | undefined (valid simplification of A | A | undefined)\n\n**Actual behavior:** \n\nbar return type is inferred to A\n\nNote: similar problem with 'null' instead of 'undefined'\n"
    },
    "satisfaction_conditions": [
      "Return type correctly includes undefined when conditional branch may return undefined",
      "Type inference preserves union type information",
      "Compiler configuration enables strict null/undefined checking",
      "Type safety is maintained across conditional operations"
    ],
    "created_at": "2016-10-05T21:33:16Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/11053",
    "source": {
      "issue_number": 11053
    },
    "initial_question": {
      "title": "Redundant rest parameter should be omitted from compiled output",
      "body": "**TypeScript Version:**  2.0.2 (rc)\n\nIn some cases I am iterating through arguments using the arguments object, and don't actually need to reference the paremeters. In these sorts of cases, the only reason to include the rest parameter in the original source is to tell TypeScript that the function may be called with any number of arguments. If the parameter is never actually referenced (particularly if you then access the arguments object), it should be able to infer that the parameter is redundant and drop it from the compiled output.\n\nHaving an intermediate array built, or even just a redundant rest parameter when targeting ES2015, is not ideal when your code is performance-critical. Optimizing compilers might be smart enough to skip an unused rest parameter, but it still feels sloppy, and ES5 output will be worse, of course.\n\nThe example below is contrived of course, but it serves to illustrate the redundant output:\n\n``` ts\nfunction run(...args: any[]) {\n  const values = arguments;\n  for(var i = 0; i < values.length; i++) {\n    console.log(values[i]);\n  }\n}\n```\n\nES5 output:\n\n``` js\nfunction run() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i - 0] = arguments[_i];\n    }\n    var values = arguments;\n    for (var i = 0; i < values.length; i++) {\n        console.log(values[i]);\n    }\n}\n```\n\nand ES2015 output:\n\n``` js\nfunction run(...args) {\n    const values = arguments;\n    for (var i = 0; i < values.length; i++) {\n        console.log(values[i]);\n    }\n}\n```\n"
    },
    "satisfaction_conditions": [
      "Function accepts variable number of arguments at compile time",
      "Compiled output does not create unnecessary array allocation",
      "Original functionality is preserved in runtime execution",
      "TypeScript compilation succeeds without errors",
      "Performance characteristics are maintained in performance-critical scenarios"
    ],
    "created_at": "2016-09-22T01:45:26Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/10854",
    "source": {
      "issue_number": 10854
    },
    "initial_question": {
      "title": "Simultaneous use of export equals and export default in a module",
      "body": "I have some NPM modules written that uses the old default export syntax:\n\n``` ts\ndeclare module 'my-module' {\n    function test(): string;\n    export = test;\n}\n```\n\nTo promote ES import syntax but still keep the old one, I wanted to add both the new and old default export syntax:\n\n``` ts\ndeclare module 'my-module' {\n    function test(): string;\n    export default test;\n    export = test; // An export assignment cannot be used in a module with other exported element\n}\n```\n\nThough it complains that it cannot use an export assignment with other export statements.\n\nI think it is reasonable to support both syntax simultaneously in a module. Because choosing between both syntax. I would choose `export =` before `export default`, simply because of no API breakage.\n"
    },
    "satisfaction_conditions": [
      "Module must be accessible through both CommonJS and ES Module import patterns",
      "TypeScript type declarations must compile without errors",
      "Existing code using 'export =' syntax continues to work",
      "Solution must work without requiring TypeScript compiler flag changes",
      "Module exports must maintain consistent behavior regardless of import method"
    ],
    "created_at": "2016-09-11T12:35:00Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/10779",
    "source": {
      "issue_number": 10779
    },
    "initial_question": {
      "title": "Generics not inferred from union type",
      "body": "Latest 2 beta\n\n``` ts\nconst y = <S, E>(z: S | E) => 1;\ny(5 || 'foo') // generics should be number and string, but are {} and {}\n```\n\nI expect the generics `S` and `E` to be inferred correctly as `number` and `string`, but it seems like TypeScript infers them both as `{}` instead.\n"
    },
    "satisfaction_conditions": [
      "Generic type parameters must have sufficient context to be uniquely determined",
      "Type inference behavior must be consistent with TypeScript's type system rules",
      "The solution must maintain type safety while allowing intended use cases"
    ],
    "created_at": "2016-09-08T14:08:19Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/10655",
    "source": {
      "issue_number": 10655
    },
    "initial_question": {
      "title": "Async map iteration does not work as expected",
      "body": "**TypeScript Version:**  1.8.10\n\n**Code**\n\n``` ts\nvar map = new Map<string, any>();\nmap.set('abc', 123);\nmap.forEach(async (value)=>{\nawait DoSomethingAsyncWithValue(val);\n});\n```\n\n**Expected behavior:**\nShould asynchronously iterate over the map.\n\n**Actual behavior:** \nSynchronously iterates over the map.\n\nThere are no compilation errors from this code, so a developer would assume it'd work the same as an Array forEach.\n"
    },
    "satisfaction_conditions": [
      "Map iteration must maintain correct entry order"
    ],
    "created_at": "2016-08-31T22:37:21Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/10551",
    "source": {
      "issue_number": 10551
    },
    "initial_question": {
      "title": "Generic type constraint for abstract class.",
      "body": "Too constraint a generic type that is a class, we can write `{new():T}`, however it doesn't match an abstract class.\n\n``` typescript\nclass X{};\nabstract class Y{};\nfunction f<T>(x: {new():T});\nf(X);// OK\nf(Y);// Faild\n```\n\nIs there any way overcome this?\n"
    },
    "satisfaction_conditions": [
      "Type constraint must allow abstract class references without instantiation",
      "Type constraint must preserve type information for dependency injection",
      "Solution must compile in TypeScript without type errors",
      "Abstract class must be usable as an identifier in the container system"
    ],
    "created_at": "2016-08-26T02:10:03Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/10156",
    "source": {
      "issue_number": 10156
    },
    "initial_question": {
      "title": "On static method Error TS2339: Property 'then' does not exist on type '() => Promise'",
      "body": "<!-- BUGS: Please use this template. -->\n\n**TypeScript Version:**  1.8.10 and nightly (2.1.0-dev.20160804)\n\n**Code**\n\n``` ts\n/// <reference path=\"typings/globals/core-js/index.d.ts\" />\n\nexport class CryptoService\n{\n  static getToken()\n  {\n    return Promise.resolve('123');\n  }\n\n  static setXsrf()\n  {\n    return this.getToken.then( token  => {} );\n  }\n}\n```\n\n**Not expected error:**\n\n> error TS2339: Property 'then' does not exist on type '() => Promise<string>'.\n"
    },
    "satisfaction_conditions": [
      "Method reference is properly invoked as a function",
      "Promise chain is properly constructed",
      "TypeScript compiler successfully validates the Promise handling",
      "Static method context is preserved"
    ],
    "created_at": "2016-08-04T22:26:53Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/10135",
    "source": {
      "issue_number": 10135
    },
    "initial_question": {
      "title": "Cannot rebuild declarations with declarationDir",
      "body": "**TypeScript Version:**  2.0.0-beta\n\n**Configuration**\n\n``` json\n{\n    \"compilerOptions\": {\n        \"declaration\": true,\n        \"declarationDir\": \"declarations\"\n    }\n}\n```\n\n**Expected behavior:**\nIn the first run, compiler generate declarations. When start second build `.d.ts` files should be updated.\n\n**Actual behavior:** \nAfter second run, I get this error:\n\n``` cmd\nerror TS5055: Cannot write file 'declarations/*.d.ts' because it would overwrite input file.\n```\n\nAnd declarations files not updated.\n"
    },
    "satisfaction_conditions": [
      "Declaration files (.d.ts) can be regenerated without file conflict errors",
      "Declaration output directory is properly excluded from input sources",
      "TypeScript compiler configuration remains valid"
    ],
    "created_at": "2016-08-04T13:03:51Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/10105",
    "source": {
      "issue_number": 10105
    },
    "initial_question": {
      "title": "Use lib/lib.*.d.ts as regular program files",
      "body": "We use the same `tsconfig.json` `compilerOptions` for all code in our monorepo.\nEach target gets to specify only the `files` list.\n\nWe'd like some targets to be able to opt-in for typings like collections. In the past, we did that by including the DefinitelyTyped es6-collections.d.ts in the files.\n\nIf I include one of the `///<reference no-default-lib=true/>` files, though, I get an error:\n\n```\nalexeagle@alexeagle:~/Projects/repro$ cat tsconfig.json \n{\n    \"compilerOptions\": {\n        \"module\": \"commonjs\",\n        \"target\": \"es5\"\n    },\n    \"files\": [\"node_modules/typescript/lib/lib.es2015.collection.d.ts\"]\n}\nalexeagle@alexeagle:~/Projects/repro$ $(npm bin)/tsc\nerror TS2318: Cannot find global type 'Array'.\nerror TS2318: Cannot find global type 'Boolean'.\nerror TS2318: Cannot find global type 'Function'.\nerror TS2318: Cannot find global type 'IArguments'.\nerror TS2318: Cannot find global type 'Number'.\nerror TS2318: Cannot find global type 'Object'.\nerror TS2318: Cannot find global type 'RegExp'.\nerror TS2318: Cannot find global type 'String'.\n```\n\nThis is the case even if other files are included in the compilation. I can solve it by removing the `///ref` but this means we have local modifications to Typescript. Is there another way to defeat the error?\n"
    },
    "satisfaction_conditions": [
      "TypeScript compilation must complete without global type errors",
      "ES2015 collection types must be accessible in the codebase",
      "Solution must work within a monorepo structure using shared compiler options",
      "Type definitions must be properly resolved without requiring local modifications to TypeScript files"
    ],
    "created_at": "2016-08-03T00:20:32Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/10056",
    "source": {
      "issue_number": 10056
    },
    "initial_question": {
      "title": "Mystique Screen interface",
      "body": "Go to playground and type\n\n``` ts\ninterface Screen<T> {}\n```\n\nyou will see error: all declarations of an interface must have identical type parameters.\n\nI have tried it in Chrome and Mozila, OS -windows 8\n\nIt seems to me that some code inside playground in global scope.\n"
    },
    "satisfaction_conditions": [
      "Code must execute in a scope that allows custom type definitions"
    ],
    "created_at": "2016-07-31T19:16:24Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/9811",
    "source": {
      "issue_number": 9811
    },
    "initial_question": {
      "title": "Cannot define declared variable with the same property",
      "body": "**TypeScript Version:**  1.8.0 / nightly (2.0.0-dev.201xxxxx)\n\n**Code**\n\n``` ts\ninterface A {   \n}\n\ndeclare var A: {\n    x: number;\n}\n\nclass AShim implements A {\n    x: number;\n}\n\nvar A: {\n     x: number;\n} = AShim;\n```\n\n**Expected behavior:**\nI expect this to compile successfully.\n\n**Actual behavior:** \n\n```\na.ts(12,5): error TS2322: Type 'typeof AShim' is not assignable to type '{ x: number; }'.\n  Property 'x' is missing in type 'typeof AShim'.\n```\n"
    },
    "satisfaction_conditions": [
      "Instance members in interface must be matched by class instance members"
    ],
    "created_at": "2016-07-19T07:46:15Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/9604",
    "source": {
      "issue_number": 9604
    },
    "initial_question": {
      "title": "Overriding addEventListener to augment event objects",
      "body": "Ultimately, what I want to do is to describe the following trick:\n\n``` js\nconst element = document.createElement(\"div\");\n\nelement.addEventListener(\"click\", event => {\n  event.foo = 123;\n});\n```\n\nAs you see, my `<div>` element intercepts all \"click\" events and adds a new property to them, so whoever attaches a \"click\" listener later will see this new property.\n\nA practical example would be a custom UI element that represents, for instance, a chess board, and adds `row` and `col` properties to every mouse event, as the consumers of the UI element shouldn't need to convert the plain `x` and `y` coordinates to the cell coordinates.\n\nMy attempt to describe this failed:\n\n``` ts\ninterface MyMouseEvent {\n  foo?: number;\n}\n\ninterface MyElement extends HTMLElement {\n  addEventListener(type: \"click\", listener: (ev: MyMouseEvent) => any, capture?: boolean): void;\n}\n```\n\ntsc complains that the HTMLElement interface is incorrectly extended:\n\n```\nTS2430  Interface 'MyElement' incorrectly extends interface 'HTMLElement'.\n  Types of property 'addEventListener' are incompatible.\n    Type '(type: \"click\", listener: (ev: MyMouseEvent) => any, useCapture?: boolean) => void' is not assignable to type '{ (type: \"MSContentZoom\", listener: (ev: UIEvent) => any, useCapture?: boolean): void; (type: \"MS...'.\n      Type '(type: \"click\", listener: (ev: MyMouseEvent) => any, useCapture?: boolean) => void' provides no match for the signature '(type: string, listener: EventListener | EventListenerObject, useCapture?: boolean): void'\n```\n"
    },
    "satisfaction_conditions": [
      "TypeScript interface must maintain full compatibility with original HTMLElement addEventListener functionality",
      "Type definitions must correctly reflect the augmented event object structure"
    ],
    "created_at": "2016-07-11T00:25:45Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/9456",
    "source": {
      "issue_number": 9456
    },
    "initial_question": {
      "title": "Dont require declaration files after compile",
      "body": "I use `import` instead of `<reference ..` to import my `d.ts` files. But after I'd compiled this:\n\n``` ts\nimport 'tests/interfaces/mocha.d.ts';\n```\n\nI've got:\n\n``` js\n\"use strict\";\nrequire('tests/interfaces/mocha.d.ts');\n```\n\nMy config file:\n\n``` json\n{\n    \"compilerOptions\": {\n        \"emitDecoratorMetadata\": true,\n        \"experimentalDecorators\": true,\n        \"module\": \"commonjs\",\n        \"moduleResolution\": \"classic\",\n        \"noImplicitAny\": false,\n        \"outDir\": \"dist\",\n        \"rootDir\": \".\",\n        \"sourceMap\": true,\n        \"target\": \"es5\"\n    }\n}\n```\n\nCan i change this behaviour by config?\n"
    },
    "satisfaction_conditions": [
      "Module import path resolves correctly at runtime",
      "Type definitions remain available during development",
      "Generated JavaScript follows CommonJS module format"
    ],
    "created_at": "2016-06-30T22:09:18Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/9370",
    "source": {
      "issue_number": 9370
    },
    "initial_question": {
      "title": "Allow empty return statements on setters",
      "body": "**TypeScript Version:** \n1.8.10\n\n**Code**\n\n``` ts\nclass Foo {\n  private _value: string = '';\n  set value(newV: string): void {\n    if (newV === this._value) {\n      return;\n    }\n\n    // ...\n  }\n}\n```\n\n**Expected behavior:**\n\nNo errors.\n\n**Actual behavior:** \n\n`A 'set' accessor cannot have a return type annotation.`.\n\nThanks :)\n"
    },
    "satisfaction_conditions": [
      "Setter must compile without return type annotation",
      "Empty return statements must be allowed within the setter"
    ],
    "created_at": "2016-06-27T11:06:27Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/9368",
    "source": {
      "issue_number": 9368
    },
    "initial_question": {
      "title": "should ts avoid to use the this keyworld in class ?",
      "body": "**version**\n1.8.31\n\n``` ts\nclass A {\n    public count: number = 10;\n    public AddOne(): void{\n        this.count += 1;\n    }\n}\n```\n\nand will generate those js\n\n``` js\nvar A = (function () {\n    function A() {\n        this.count = 10;\n    }\n    A.prototype.AddOne = function () {\n        this.count += 1;\n    };\n    return A;\n}());\n\n```\n\nthis is ok when you `let a = new A()`  and `a.AddOne()`  , \nbut when  `let myadd = a.AddOne`  and   `myadd()`\nthe result will be different . because  `this`  became something else.\n\nshould  the output js like this ?\n\n``` js\nvar A = (function () {\n    var _this;\n    function A() {\n        this.count = 10;\n        _this = this;\n    }\n    A.prototype.AddOne = function () {\n        _this.count += 1;  // not use this\n    };\n    return A;\n}());\n```\n"
    },
    "satisfaction_conditions": [
      "Class instance state remains accessible within methods",
      "Solution maintains ES6 class compatibility"
    ],
    "created_at": "2016-06-27T06:16:31Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/9302",
    "source": {
      "issue_number": 9302
    },
    "initial_question": {
      "title": "Typing is clumsy when instancing using class objects derived from an abstract class",
      "body": "Suppose you have an abstract class `A` and two concrete clases `B`, `C` derived from `A`, and you want to store `B` and `C` as first-class values to make instances from these values: \n\n``` ts\nabstract class A  { a: any}\nclass B extends A { b: any}\nclass C extends A { c: any}\n\nlet classes  = [B, C]            // inferred type = (typeof B | typeof C)[]\nlet instance = new classes[1]()  // inferred type = (B | C)\ninstance.a                       // ok, because .a is in B and C\n```\n\nIt will be nice if the previous example inferred the `instance` type as `A` instead of `(B | C)`. But it works. \nThe problem comes when TS can't infer the `classes` type, like when using a `Map` instead of an array:\n\n``` ts\nlet classes2 = new Map([[\"b\", B], [\"c\", C]]) // error TS2453: The type argument for type parameter 'V' cannot be inferred from the usage.\nlet classes3 = new Map<string, typeof A>([[\"b\",B], [\"c\", C]])\nlet classes4 = new Map<string, typeof B | typeof C>([[\"b\",B], [\"c\", C]])\n\nvar instance3 = new (classes3.get(\"c\"))()   // TS2511: Cannot create an instance of the abstract class 'A'.\nvar instance4 = new (classes4.get(\"c\"))()   // inferred type = (B | C)\n```\n\n`classes2` doesn't work because TS can't infer the type. \n`classes3` doesn't work because you can't use it for instancing.\n`classes4` example worked but is very clumsy for a large number of classes, you need to type `(typeof B | typeof C | ...)` for all the classes involved. Maybe this is acceptable but I think there is a need to be able of defining (and inferring) a type like \"all concrete classes derived from A\".\n\nBelow is the same example but using a concrete base class. Note in this case you can use `<typeof A>` as the type of the array / map values:\n\n``` ts\nclass A  {a : any}    // now concrete\nclass B extends A { b: any}\nclass C extends A { c: any}\n\nlet classes0 = [B, C]  // inferred type = (typeof B | typeof C)[]\nlet classes1 = <typeof A[]>[B,C]\n\nlet instance1 = new classes0[1]()  // inferred type = (B | C)\ninstance1.a                        // ok, because .a is in B and C\nlet instance2 = new classes1[1]()  // inferred type = A\ninstance2.a                        // ok, because .a is in A\n\nlet classes2 = new Map([[\"b\", B], [\"c\", C]]) // error TS2453: The type argument for type parameter 'V' cannot be inferred from the usage.\nlet classes3 = new Map<string, typeof A>([[\"b\",B], [\"c\", C]])\nlet classes4 = new Map<string, typeof B | typeof C>([[\"b\",B], [\"c\", C]])\n\nvar instance3 = new (classes3.get(\"c\"))()   // inferred type = A\nvar instance4 = new (classes4.get(\"c\"))()   // inferred type = (B | C)\n```\n\n**TypeScript Version:** \n\n1.9.0-dev.20160616-1.0\n"
    },
    "satisfaction_conditions": [
      "Type system must allow storing and retrieving constructors of concrete classes derived from an abstract base class",
      "Instances created from stored constructors must be properly typed as the abstract base class type",
      "Constructor signatures of derived classes must match the abstract base class"
    ],
    "created_at": "2016-06-21T20:04:57Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/9247",
    "source": {
      "issue_number": 9247
    },
    "initial_question": {
      "title": "Cannot set property 'xyz' of undefined",
      "body": "It would seem like this is a (common?) bug that the compiler could catch for us.\n\nGiven this example class:\n\n``` javascript\nclass Foo {\n    bar: number;\n}\nlet a: Foo;\na.bar = 1;\n```\n\nAt runtime I will get an error 'Cannot set property 'bar' of undefined because I never actually initialized the object. (i.e. `let a: Foo = new Foo();` or `let a = new Foo();`)\nThis seems to me like it could probably be a pretty common developer mistake given the ability to provide types (: Foo), especially since editors will give you full Intellisense on the object just by naming the type of it without initialization.  I'm curious if it's something that the Compiler could catch?  (variable a is undefined; declared, but never initialized)\n"
    },
    "satisfaction_conditions": [
      "Compiler must detect and warn about uninitialized variable usage",
      "Warning/error must occur before runtime execution",
      "Detection must work with typed variables that haven't been instantiated",
      "Solution must be configurable in the development environment"
    ],
    "created_at": "2016-06-18T11:38:15Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/9137",
    "source": {
      "issue_number": 9137
    },
    "initial_question": {
      "title": "Allow to discard code when generating code.",
      "body": "I have JavaScript library , where I have multiple inheritance done with my own functions to extend.\n\nBut for intellisense purpose we have add some interface to allow lookup for function withing the classes and implemented dummy functions for completeness. But when generating the code, I would like to take that out.\n\nCan we added that feature take out some code when generating JS code.\nJust one switch let us say, #NOT_A_CODE #END_NOT_A_CODE ... and ignore the code in between.\n"
    },
    "satisfaction_conditions": [
      "TypeScript code provides accurate IntelliSense/type information",
      "Generated JavaScript output excludes specified type-only code"
    ],
    "created_at": "2016-06-13T18:15:15Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/8890",
    "source": {
      "issue_number": 8890
    },
    "initial_question": {
      "title": "Unable to run Array.map on an Array",
      "body": "**TypeScript Version:** \n\n1.8\n\n**Code**\n\n``` ts\nfunction getARPTable() {\n    return new Promise((resolve, reject) => {\n        arp.table((error, devices) => {\n            if (error) reject(error);\n            else resolve(devices);\n        });\n    });\n}\n\nasync function scanPorts() {\n    let devices = await getARPTable();\n    console.log(Array.isArray(devices)); // true\n    devices = devices.map((device) => device); // error\n                      ^\n    return true;\n}\n\nscanPorts();\n```\n\n**Expected behavior:**\n\nNo error output\n\n**Actual behavior:** \n\n`error TS2339: Property 'map' does not exist on type '{}'.`\n"
    },
    "satisfaction_conditions": [
      "Runtime array operations must work as expected"
    ],
    "created_at": "2016-05-31T07:45:40Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/8867",
    "source": {
      "issue_number": 8867
    },
    "initial_question": {
      "title": "Bad inference when using void and &&",
      "body": "``` javascript\nconst a: void = undefined;\nconst b: number = 33;\n\nconst z = a && b;\n```\n\nz is always inferred to be of the same type as b, even though a is undefined.\n"
    },
    "satisfaction_conditions": [
      "Type safety must be maintained when strictNullChecks is enabled",
      "Solution must be compatible with both TypeScript 1.8 and 2.0+ behavior",
      "Clear distinction between void and undefined types must be maintained"
    ],
    "created_at": "2016-05-27T22:02:23Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/8642",
    "source": {
      "issue_number": 8642
    },
    "initial_question": {
      "title": "Using interface of an enumeration and module merged type as generics type parameter",
      "body": "I found a strange behaviour of enumeration and module merging when using generics. Take a look at the following example:\n\n``` typescript\ninterface IEnumerationType {\n     getNames(): string[];\n}\n\nenum RoleType {\n    ApplicationRole,\n    CompanyRole,\n}\n\nmodule RoleType {\n    export function getNames(): string[] {\n        return [\"ApplicationRole\", \"CompanyRole\"];\n    }\n}\n\nvar r : IEnumerationType = RoleType;\n```\n\nIt compiles without error. The RoleType implements the IEnumerationType, it has a getNames method because of the enum+module merging.\n\nIf I want to use IEnumerationType and RoleType as a generic type parameter, it fails:\n\n``` typescript\ninterface MyInterface<TEnumeration extends IEnumerationType> {\n    enumerationType: TEnumeration;\n}\n\nvar x : MyInterface<RoleType>; // error, why? RoleType implements IEnumerationType\n```\n\nIs this a bug or is it a documented behaviour?\n"
    },
    "satisfaction_conditions": [
      "Type reference correctly distinguishes between enum value type and enum constructor type",
      "Generic type constraint compatibility is maintained",
      "Type system correctly recognizes interface implementation"
    ],
    "created_at": "2016-05-17T09:45:41Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/8498",
    "source": {
      "issue_number": 8498
    },
    "initial_question": {
      "title": "interface optional methods not showing ",
      "body": "**TypeScript Version:** \n\n1.8.30\n\n**Code**\n\n``` ts\ninterface ITest {\n  init?();\n}\n\nclass Test implements ITest {\n  print() {\n    if (typeof this.init == \"function\")\n      this.init();\n  }\n}\n\nclass MyOwnTest extends Test {\n  init() {\n    // boo!  \n  }\n}\n```\n\n**Expected behavior:**\ncompiles without error\n\n**Actual behavior:** \nProperty 'init' does not exist in 'Test'\n\nWhy such construction? \nI would like to provide optional implementation of `init` in user derived type, and check in base class if it was really implemented.\n\ntoday I have to use `this[\"init\"]` - which is not strong type.\n"
    },
    "satisfaction_conditions": [
      "Optional method declaration is type-safe",
      "Base class can detect method implementation",
      "Code compiles without errors",
      "Derived classes can optionally implement the method",
      "Method remains callable when implemented"
    ],
    "created_at": "2016-05-06T12:25:37Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/8475",
    "source": {
      "issue_number": 8475
    },
    "initial_question": {
      "title": "is there a way to declare an interface with a method returning an anonymous class?",
      "body": "``` typescript\nfunction toClass() {\n    return class {}\n}\n\ninterface I {\n    toClass: () => { /* what goes here? */ }\n}\n\nconst i : I = {\n    toClass: toClass\n};\n\n// need the following to work:\nclass MyClass extends i.toClass() {\n\n}\n```\n"
    },
    "satisfaction_conditions": [
      "The interface must define a method that returns a constructable type",
      "The returned type must be assignable to the implementation of toClass()",
      "The returned type must support class inheritance syntax",
      "The type definition must preserve constructor signature compatibility"
    ],
    "created_at": "2016-05-05T16:37:36Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/8260",
    "source": {
      "issue_number": 8260
    },
    "initial_question": {
      "title": "Can't minus two Date object",
      "body": "**TypeScript Version:** \n\n1.8.9\n\n**Code**\n\n``` ts\n\"use strict\";\n\nlet start = new Date()\nlet end = new Date()\nconsole.log(start - end)\n```\n\n**Expected behavior:**\nprint the difference between two date\n**Actual behavior:** \ndon't compile when compile option  `noEmitOnError` is enabled. \nHere is the error message:\n\n``` bash\napp.ts(5,13): error TS2362: The left-hand side of an arithmetic operation must be of type 'any', 'number' or an enum type.\napp.ts(5,21): error TS2363: The right-hand side of an arithmetic operation must be of type 'any', 'number' or an enum type.\n```\n"
    },
    "satisfaction_conditions": [
      "Code must compile successfully with noEmitOnError enabled",
      "Output must be a numeric value representing the time difference between two Date objects",
      "Date objects must be properly converted to numeric values before arithmetic operations",
      "The resulting calculation must maintain mathematical accuracy"
    ],
    "created_at": "2016-04-23T06:31:58Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/8032",
    "source": {
      "issue_number": 8032
    },
    "initial_question": {
      "title": "Empty object or type (`{} | Type`) doesn't work as expected",
      "body": "**TypeScript Version:** \n\n1.8.9\n\n**Code**\n\n``` ts\ninterface IAnimal {\n  legs: Number;\n}\n\ninterface IHouse {\n  cat: {} | IAnimal;\n}\n\nconst obj: IHouse = {\n  cat: {\n    legs: 2,\n  },\n};\n\nobj.cat.legs = 5;   // Property 'legs' does not exist on type '{} | IAnimal'.\nobj.cat = {};\n```\n\n**Expected behavior:**\n\nShould be able to assign `cat.legs` or `{}` interchangeably.\n\n**Actual behavior:** \n\nUnable to assign `legs` of `{} | IAnimal`.\n"
    },
    "satisfaction_conditions": [
      "Type safety must be maintained without runtime errors",
      "Empty object assignment must be allowed without type errors"
    ],
    "created_at": "2016-04-12T19:19:44Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/7790",
    "source": {
      "issue_number": 7790
    },
    "initial_question": {
      "title": "[Question] - Is it possible to cast a type to an entire block?",
      "body": "Hi there,\n\nQuick question (or suggestion if this isn't possible):\n\nWhat I'm interested in doing is casting a type to an entire block (or to the rest of the current block). I do pretty explicit error handling, and I've found that I have to do this overly verbose `as <type>` statement each time. \n\nHere's a very pointless, but descriptive example:\n\n``` ts\ninterface Person {\n  firstname: string\n  lastname: string\n  age: number\n}\n\nfunction myFunc(x: boolean): Person|Error {\n  if (!x) {\n     return new Error('My error message');\n  }\n  return {\n    firstname: 'John',\n    lastname: 'Doe',\n    age: 45,\n  }\n}\n\nlet output = myFunc(true);\n\n// Handle the error\nif ((output as Error).name === 'Error') {\n  throw output;\n} \n\nconsole.log(\n  (output as Person).firstname + ' ' + (output as Person).lastname\n);\n\n```\n\nI'd like to assume that the `output` variable is of type Person after the if block that checks for an error. Is there any way to re-declare that it is type `Person` so that I don't have to do `(output as Person)` for everything thereafter?\n\nI hope that makes sense. Thanks a lot for the clarification! :smile: \n"
    },
    "satisfaction_conditions": [
      "Type narrowing must persist after error check",
      "Type safety must be maintained",
      "Error handling logic must remain functional",
      "Solution must work within block scope",
      "Original union type must be preserved before type check"
    ],
    "created_at": "2016-04-02T22:30:32Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/7659",
    "source": {
      "issue_number": 7659
    },
    "initial_question": {
      "title": "[Question] - Is there a syntax for defining interface properties of the same type on the same line?",
      "body": "Hello, \n\nSorry if this has been asked before. The issue history is massive and I couldn't locate it if it has. I also checked SO but didn't find anything.\n\nI'm coming from Golang and one thing that I like from there is the ability to declare properties of the same type on the same line (It reads cleaner IMO). \n\nIs this possible with Typescript?\n\nHere's how I'd define an interface (struct type) in Go\n\n``` go\ntype person struct {\n        firstName, lastName string\n        age int\n}\n```\n\nHere's how I do the same thing currently in TypeScript\n\n``` ts\ninterface person {\n  firstName : string\n  lastName : string\n  age : number\n}\n```\n\nHere's how I'd like to do it\n\n``` ts\ninterface person {\n  firstName, lastName : string\n  age : number\n}\n```\n\nThanks for the clarification! :smile: \n"
    },
    "satisfaction_conditions": [
      "Each interface property must have an explicitly declared type",
      "Interface property declarations must be individual statements",
      "Type inference must not rely on grouped declarations"
    ],
    "created_at": "2016-03-23T20:29:52Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/7641",
    "source": {
      "issue_number": 7641
    },
    "initial_question": {
      "title": "Possible to add a static method on a union type?",
      "body": "I'm using C like a companion object in Scala:\n\n``` ts\ninterface A {\n  a: number\n}\ninterface B {\n  b: number\n}\nclass C {\n  a: number\n  b: number\n  static c(d: number): number {...}\n}\n```\n\nHow do I express that `C = A|B`? I can do\n\n``` ts\ninterface A {...}\ninterface B {...}\ntype C = A|B\n```\n\nBut then I lose the static method\n"
    },
    "satisfaction_conditions": [
      "Type C must represent a union of types A and B",
      "A static method/function named 'c' must be accessible through C",
      "The function 'c' must accept a number parameter and return a number",
      "The solution must be valid TypeScript syntax"
    ],
    "created_at": "2016-03-22T19:40:35Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/7633",
    "source": {
      "issue_number": 7633
    },
    "initial_question": {
      "title": "Index signature not inherited from interface to class",
      "body": "``` ts\ninterface Foo {\n    [key:string]:any;\n}\n\ninterface Bar extends Foo {\n}\n\nclass Baz implements Foo {\n    [key:string]:any;\n}\n\nclass Qux implements Foo {\n}\n\nconsole.log((<Foo>{})['x']);\nconsole.log((<Bar>{})['x']);\nconsole.log((<Baz>{})['x']);\nconsole.log((<Qux>{})['x']);\n```\n\nOn `(<Qux>{})['x']` compiler fails with `Index signature of object type implicitly has an 'any' type.` message. When it's explicitly added to a class, like with `Baz`, everything works ok. With interfaces it seems to work fine, for example, `Bar` interface behaves as expected.\n"
    },
    "satisfaction_conditions": [
      "Index signatures must be explicitly declared in classes that implement interfaces with index signatures",
      "Interface extension must preserve index signature behavior",
      "Class structure must match interface requirements regardless of 'implements' clause"
    ],
    "created_at": "2016-03-22T09:31:25Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/7430",
    "source": {
      "issue_number": 7430
    },
    "initial_question": {
      "title": "Augmenting re-exported names from ambient module",
      "body": "**TypeScript Version:** \n\nnightly (1.9.0-dev.20160308)\n\n**Code**\n\n``` ts\n// test1.d.ts\ndeclare module 'test1/lib' {\n    export interface Test {\n        a: number;\n    } \n}\n\ndeclare module 'test1' {\n    export * from 'test1/lib';\n}\n\n// augment.d.ts\n\n/// <reference path=\"test1.d.ts\" />\nimport 'test1';\ndeclare module 'test1' {\n    interface Test { // Module augmentation cannot introduce new names in the top level scope. (2665)\n        b: string;\n    }\n}\n```\n\nShouldn't it be allowed?\n"
    },
    "satisfaction_conditions": [
      "Declaration file changes must maintain type system integrity"
    ],
    "created_at": "2016-03-08T15:06:04Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/7357",
    "source": {
      "issue_number": 7357
    },
    "initial_question": {
      "title": "Overloaded array type",
      "body": "I was unable to find this in the documentation or among the existing issues.\n\nIs there any way to have overloaded array types? Something that would look like:\n\n```\ninterface I {\n    [s: string]<T extends Bar>: T;\n    method<T extends Bar>(): T;   // this is allowed\n}\n```\n\nI guess it would also need a syntax at call-sites, which would look weird:\n\n```\ndeclare var array: I\n\n// and in client code:\nclass Foo extends Bar { foo(); }\narray[\"field\"]<Foo>.foo();\n```\n\n(As an aside, I'm not sure how to use the array type syntax)\n\nMy apologies if this is already do-able, I couldn't find a way...\n"
    },
    "satisfaction_conditions": [
      "Type safety must be maintained when accessing array elements",
      "Array elements must be able to store different but related types",
      "Type information must be preserved for IDE/tooling support",
      "Type verification must be possible at runtime",
      "Invalid type conversions must be caught at compile time"
    ],
    "created_at": "2016-03-03T01:27:45Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/7090",
    "source": {
      "issue_number": 7090
    },
    "initial_question": {
      "title": "Union type of string literals",
      "body": "With TypeScript 1.8, this code fails:\n\n```\ntype SomeString = ('string1' | 'string2') & ('string3' | 'string4');\nconst x: SomeString = 'string1';\n```\n\nWith the following error: `Type 'string' is not assignable to type '(\"string1\" | \"string2\") & (\"string3\" | \"string4\")'. Type 'string' is not assignable to type '\"string1\" | \"string2\"'. Type 'string' is not assignable to type '\"string2\"'`.\n\nIs this by design? Should it not be possible to use unions for string literal types?\n"
    },
    "satisfaction_conditions": [
      "String literal union types must be properly formed"
    ],
    "created_at": "2016-02-16T09:28:30Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/6830",
    "source": {
      "issue_number": 6830
    },
    "initial_question": {
      "title": "qualified types in function header only with named parameter",
      "body": "This gives a compile error:\n\n```\n\nmodule b {\n  interface t {}\n}\n\nabstract class A {\n  abstract f(b.t) : void;\n}\n\n```\n\nThis compiles:\n\n```\n\nmodule b {\n  interface t {}\n}\n\nabstract class A {\n  abstract f(x : b.t) : void;\n}\n\n```\n\nQualifying the type t makes it necessary to name the parameter of the function although this should not be necessary.\n\nThis again works:\n\n```\n\nmodule b {\n  interface t {}\n}\n\nabstract class A {\n  type t = b.t;\n  abstract f(t) : void;\n}\n\n```\n"
    },
    "satisfaction_conditions": [
      "Parameter names must be explicitly specified in abstract method declarations",
      "Qualified type references must include parameter names",
      "Code must follow TypeScript's parameter declaration syntax conventions",
      "Parameter declarations must support JSDoc documentation capabilities"
    ],
    "created_at": "2016-02-02T10:21:00Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/6806",
    "source": {
      "issue_number": 6806
    },
    "initial_question": {
      "title": "Question: Interface with _at least one_ defined member?",
      "body": "In RxJS, we have a need for an interface that is basically this:\n\n``` TypeScript\ninterface Observer<T> {\n  next?: (value: T) => void;\n  error?: (err: any) => void;\n  complete?: () => void;\n}\n```\n\nbut you'll notice that it matches `{}` in that case, which isn't what we want. What we _really_ want is _at least one_ of those members.\n\nIt seems like I'd be able to do something with `PartialObserver<T> = NextObserver<T>|ErrorObserver|CompleteObserver`, but I'm honestly not sure how to accomplish this.\n"
    },
    "satisfaction_conditions": [
      "Type definition must require at least one of next, error, or complete methods to be present",
      "Type checking must allow any combination of the three methods (next, error, complete) as long as at least one is present",
      "Type safety must be maintained when accessing optional methods",
      "Type definition must maintain compatibility with RxJS Observer pattern"
    ],
    "created_at": "2016-02-02T00:02:48Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/6641",
    "source": {
      "issue_number": 6641
    },
    "initial_question": {
      "title": "Generics in indexers",
      "body": "Hi,\n\nI was wondering why something like that is not possible:\n\n``` javascript\ninterface IDictionary<TKey, TValue> {\n  [index: TKey]: TValue;\n}\n```\n\nit tells me: index signature parameter must be string or number\n\nI agree, but why I could not get this error when trying to use something else than string or number as TKey? Generics are analyzed at build time right? if so, this should be easy to find.\n\n``` javascript\n  temp: IDictionary<number, ...>;\n```\n\nshould work.\n\nI could even do something like this, to be more precise:\n\n``` javascript\ninterface IDictionary<TKey extends string | number, TValue>\n```\n"
    },
    "satisfaction_conditions": [
      "Index signature type must be explicitly string or number, not a generic type parameter",
      "Type safety must be maintained for object property access",
      "Separate implementations must be provided for string and number indexers",
      "Solution must be verifiable at compile time"
    ],
    "created_at": "2016-01-27T13:55:22Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/6622",
    "source": {
      "issue_number": 6622
    },
    "initial_question": {
      "title": "export types not found",
      "body": "This might be a tad 'anti-typescript' but figured I throw it out anyway. I have a function that reads a array and dynamically creates exports like so:\n\n```\nconst methods = ['head', 'options', 'get', 'post', 'put', 'patch', 'del', 'delete', 'all']\nmethods.forEach(method => {\n  let methName = method.charAt(0).toUpperCase() + method.slice(1);\n  exports[`http${methName}`] = route.bind(null, method);\n});\n```\n\nFor obvs reasons, TypeScripts complains on compiling about this:\n\n```\n\u001b[100;30m\nsrc/api/ApplicationController.ts(1,22): error TS2305: Module '\"src/common/routing\"' has no exported member 'httpGet'.\n```\n\nIs there anything on the roadmap to do this type of dynamic / functional exports?\n"
    },
    "satisfaction_conditions": [
      "TypeScript compilation succeeds without export-related errors",
      "Dynamic HTTP method functions are accessible to importing modules",
      "Maintains compatibility with other exports in the same module",
      "Preserves the function binding with the original method names",
      "Type definitions are statically analyzable"
    ],
    "created_at": "2016-01-26T13:19:47Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/6543",
    "source": {
      "issue_number": 6543
    },
    "initial_question": {
      "title": "Can't get to the instance type of a wrapped class across modules",
      "body": "Ran into this trying to leverage higher-order React components but it doesn't take much to reproduce:\n\nThing.ts\n\n``` typescript\nclass Thing { }\n\nfunction wrap<T>(classType: T): T {\n    return classType;\n}\n\nexport default wrap(Thing);\n```\n\nThingImporter.ts\n\n``` typescript\nimport Thing from \"./Thing\";\n\nlet thingInstance: Thing; //error: Cannot find name 'Thing'\nlet thingConstructor: typeof Thing; //ok\n```\n\nEven though the wrap function returns exactly what it takes in, the type gets changed from `class Thing` to `typeof Thing` and it seems this causes it to lose the class-reference-equals-instance-type magic in other modules.\n\nTS versions: 1.7.5 and 1.8.0-dev.20160119\ntsconfig:\n\n``` json\n{\n  \"compilerOptions\": {\n    \"module\": \"commonjs\",\n    \"target\": \"es5\"\n  }\n}\n```\n"
    },
    "satisfaction_conditions": [
      "Type information of the wrapped class must be accessible in importing modules",
      "Instance type of the original class must be preserved after wrapping",
      "Solution must work with TypeScript's module system",
      "Higher-order function wrapping must not break type inference"
    ],
    "created_at": "2016-01-19T22:58:31Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/6463",
    "source": {
      "issue_number": 6463
    },
    "initial_question": {
      "title": "Cannot define type while destructuring in a $q.all ",
      "body": "<pre>\n$q.all([\n  IPromise&lt;type does not work here&gt;promise1,\n  promise2\n])\n.then([result1: &lt;can't define type here as well&gt;, result2] => { }`\n</pre>\n\n\nI have tried to type cast promise and tried to define type in `.then` as well and it still gives error. I have tried with simple function as well and it does not work for simple functions as well.\n"
    },
    "satisfaction_conditions": [
      "Type definitions are correctly applied to array destructuring in Promise.all results",
      "TypeScript compiler accepts the syntax without type errors",
      "Promise.all array structure is preserved",
      "Destructuring syntax remains functional"
    ],
    "created_at": "2016-01-13T13:43:49Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/6397",
    "source": {
      "issue_number": 6397
    },
    "initial_question": {
      "title": "signature overloading breaking change?",
      "body": "Looks like that in 1.7.5 overloading order became significant in some cases\n\n1) specific first\n\n``` TypeScript\ndeclare class A {\n    f(x:string): any;\n    f(x:{[key: string]: any}): A;\n}\n\nvar a: A;\nvar x = a.f(\"A\") + 1;  // OK in both TS 1.7.5 and TS 1.5.3\n```\n\n2) specific second\n\n``` TypeScript\ndeclare class A {\n    f(x:{[key: string]: any}): A;\n    f(x:string): any;\n}\n\nvar a: A;\nvar x = a.f(\"A\") + 1; // Fails on TS 1.7.5 (Worked on 1.5.3). Inferred f result as A\n```\n\nIs it by design?\n"
    },
    "satisfaction_conditions": [
      "Method overload resolution must correctly handle string parameter types",
      "Overload order must be respected in type resolution",
      "Type inference must produce types that allow expected operations",
      "Changes in behavior between TypeScript versions must be documented or intentional"
    ],
    "created_at": "2016-01-08T10:19:20Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/6360",
    "source": {
      "issue_number": 6360
    },
    "initial_question": {
      "title": "Cannot use type that is re-exported by another module",
      "body": "I'm trying to re-export a class from a module `bar.ts` that has been imported from `foo.ts`. The class itself is usable but its type cannot be used for declaring variables. I'm using latest typescript 1.8.0-dev.20160105 from npm:\n\nfoo.ts (type definition):\n\n```\nexport class Foo {\n}\n```\n\nbar.ts (type re-export):\n\n```\nexport = {\n  Foo: require('./foo')\n};\n```\n\nqux.ts (type usage):\n\n```\nimport Bar = require('./bar');\nvar foo: Bar.Foo;\n```\n\ntsconfig.json:\n\n```\n{\n  \"compilerOptions\": {\n    \"target\": \"es6\",\n    \"module\": \"commonjs\"\n  }\n}\n```\n\nThe actual error:\n\n```\n$ tsc\nqux.ts(2,10): error TS2503: Cannot find namespace 'Bar'.\n```\n\nI haven't found a way to re-export a type. It's useful for me to split up several database models in multiple files, and then aggregate all of them in a single file. However actually I'm losing the types.\n"
    },
    "satisfaction_conditions": [
      "Type definitions are successfully re-exported and accessible",
      "TypeScript compiler successfully compiles the code without type errors",
      "Module structure allows type aggregation from multiple files",
      "Export syntax is compatible with the configured module system"
    ],
    "created_at": "2016-01-05T16:29:34Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/5778",
    "source": {
      "issue_number": 5778
    },
    "initial_question": {
      "title": "Declaring a named module with call signature?",
      "body": "I'm having trouble typing the following scenario.\n\ndefs.d.ts\n\n```\ndeclare module \"my/module\" {\n  export = (arg: string) => any;\n}\n```\n\nmain.ts\n\n```\nimport myModule = require(\"my/module\");\nmyModule(\"hello\");\n```\n\nLine 2 in `main.ts` compiles fine, VS even shows the correct call signature, however, `defs.d.ts` does not compile correctly:\n`error TS2304: Cannot find name 'any'`\n"
    },
    "satisfaction_conditions": [
      "The module must export a callable function that accepts a string argument",
      "The exported function's call signature must be correctly recognized by TypeScript",
      "The module must be importable using require syntax"
    ],
    "created_at": "2015-11-24T21:05:51Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/5629",
    "source": {
      "issue_number": 5629
    },
    "initial_question": {
      "title": "Tests: no way ensuring that super has been called.",
      "body": "When writing tests (using Jasmine in my case), how can one ensure that the super of a class is called?\n\nFor instance, in the following code:\n\n```\nclass Snake extends Animal {\n    constructor(name: string) { super(name); }\n    move(meters = 5) {\n        alert(\"Slithering...\");\n        super.move(meters);\n    }\n}\n```\n\nHow can one write a test ensuring `super.move()` is called when `Snake.move()` is called?\n"
    },
    "satisfaction_conditions": [
      "Method calls on parent class must be detectable and verifiable",
      "Original method functionality must be preserved",
      "Method call verification must work with inheritance hierarchy"
    ],
    "created_at": "2015-11-12T01:39:36Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/5609",
    "source": {
      "issue_number": 5609
    },
    "initial_question": {
      "title": "Destructuring and function properties",
      "body": "Hi,\n\nwe are using Visual Studio 2013 with TS 1.6\n\ni don't get why this is valid:\n\n``` typescript\nfunction foo({bar: string}) {}\n```\n\nbut this leads to a compile error:\n\n``` typescript\nfunction foo({bar: () => string}) {}\n```\n\nCompile error message is \"Cannon find name string\".\n\nFor me this is a defect behavior. What do you guys think?\n\nKind regards,\nTimo\n"
    },
    "satisfaction_conditions": [
      "Function parameter destructuring syntax must be valid for function types",
      "Type annotations must be correctly specified in the destructuring pattern",
      "Destructured parameter must maintain type safety"
    ],
    "created_at": "2015-11-11T09:59:00Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/5570",
    "source": {
      "issue_number": 5570
    },
    "initial_question": {
      "title": "Unable to define async function type",
      "body": "I'm just wondering if I could define an async function type. I want to create an interface where one of the properties of the interface is an async method.\n\n``` typescript\ninterface Setup {\n     asyncMethod: async () => Promise<any>; // cannot find name 'async'.\n}\n```\n\nThe reason I want to await, is so I can await on a function that returns a promise from a JS library. Also await on any type isn't working either.\n"
    },
    "satisfaction_conditions": [
      "Interface method type must be defined as a function returning a Promise",
      "Implementation must be assignable to the interface type",
      "Interface must allow awaitable operations",
      "Type definition must compile without errors"
    ],
    "created_at": "2015-11-09T10:08:09Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/5568",
    "source": {
      "issue_number": 5568
    },
    "initial_question": {
      "title": "Definition file: unable refernce top namespace",
      "body": "This code (.ts) compiles fine\n\n```\nnamespace A {\n    export enum TestEnum { One };\n}\n\nnamespace A {\n    namespace B {\n        namespace A {\n            class Test {\n                main(): TestEnum {\n                    return TestEnum.One;\n                }\n            }\n        }\n    }\n}\n```\n\nThis code (.d.ts) \n\n```\ndeclare namespace A {\n    export enum TestEnum { One }\n}\n\ndeclare namespace A {\n    namespace B {\n        namespace A {\n            class Test {\n                main(): A.TestEnum.One;\n            }\n        }\n    }\n}\n```\n\ncompiles with error `error TS2305: Build: Module 'A.B.A' has no exported member 'TestEnum'.`\n"
    },
    "satisfaction_conditions": [
      "Name shadowing conflicts must be resolved",
      "Type definitions must match implementation"
    ],
    "created_at": "2015-11-09T09:11:24Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/5303",
    "source": {
      "issue_number": 5303
    },
    "initial_question": {
      "title": "Duck typing on anonymous object literals and class objects",
      "body": "Based on new duck typing concept fresh objects can not have access property.\nLike this\n\n``` javascript\nlet a = { name:\"Bill\"};\nlet b = {name:\"Bill\", age:20};\n\na = {name: \"James\", age:30 }; // Error - excess property not allowed\na = b; // No error - works fine\n```\n\nNow the questions is does this concept also applies to class objects\nLike this:\n\n``` javascript\nclass Human {    \n    name: string;    \n    constructor(name: string){\n        this.name = name;\n    }\n}\n\nclass Animal {\n    name: string;\n    age: number;    \n    constructor(name: string, age: number){\n        this.name = name;\n        this.age = age;\n    }\n    eat(){\n        console.log(this.name + \" is a Human and is eating\");\n    }\n}\n\nlet h1 = new Human(\"James\");\nlet a1 = new Animal(\"Dog\", 2);\nh1 = new Animal(\"Cat\", 1); //this is working -- But based on duck typing concept it should not because it has excess property and its fresh object\n```\n\nThe error is same if I remove constructor.\n\nIs there any difference in duck typing concept for anonymous objects and class objects OR may be I'm missing something?\nOr is it really considered as fresh object?\n"
    },
    "satisfaction_conditions": [
      "Object literal freshness checks must detect excess properties",
      "Class instance assignments must follow standard structural typing rules",
      "Type compatibility between classes must be determinable at compile time",
      "Private/protected members must affect assignability"
    ],
    "created_at": "2015-10-17T06:29:13Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/5180",
    "source": {
      "issue_number": 5180
    },
    "initial_question": {
      "title": "sourceRoot should support relative paths and respect folder hirearchy",
      "body": "When supplying sourceRoot, it is just directly copied into the source map file as is. This doesn't work correctly with rootDir and outDir options. For example, if I have the following structure:\n\nrepo/src/www/foo.ts\nrepo/src/bar.ts\n\nand I want to output the files into repo/out/, I tried using sourceRoot: '../src' and that works okay for bar.js, but not www/foo.js. I hope this explanation makes sense.\n"
    },
    "satisfaction_conditions": [
      "Source map files must correctly reference source files regardless of folder depth",
      "Source paths in source maps must maintain correct relative relationships",
      "Source map configuration must work consistently with TypeScript's outDir and rootDir options"
    ],
    "created_at": "2015-10-08T19:12:20Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/4968",
    "source": {
      "issue_number": 4968
    },
    "initial_question": {
      "title": "Cannot export class expressions",
      "body": "```\nvar SomeClass = new (class\n{\n\n});\n```\n\nYields:\nExported variable 'SomeClass' has or is using private name '(Anonymous class)'.\n\nBug? Spec?\n\n(My goal was to use this structure as a singleton class of sorts, rather than making a class and remembering to mark all members as static)\n"
    },
    "satisfaction_conditions": [
      "Code structure must enable singleton-like behavior",
      "Solution must be compatible with TypeScript's module system"
    ],
    "created_at": "2015-09-25T12:58:54Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/4927",
    "source": {
      "issue_number": 4927
    },
    "initial_question": {
      "title": "Inline casting? ",
      "body": "Instead of doing something like the following:\n\n```\nlet myCastedObj = <SomeType>obj\n\nmyCastedObj.doSomething()\n```\n\nCan I do the following?\n\n```\n<<SomeType>obj>.doSomething()\n```\n\nIt _seems_ like I can't but is there a way to achieve this?\n"
    },
    "satisfaction_conditions": [
      "Type casting must be performed before method access",
      "Expression must be syntactically valid in TypeScript",
      "Original object's type must be transformed to SomeType",
      "Method invocation must be possible on the casted result"
    ],
    "created_at": "2015-09-22T14:57:10Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/4863",
    "source": {
      "issue_number": 4863
    },
    "initial_question": {
      "title": "Manually add to SystemJS imports, just like <amd-dependency> does for AMD",
      "body": "I'm developing with Aurelia which uses SystemJS loader. \nThere are cases where I need to use special kind of \"import\" to load CSS dynamically.\nwhile the code below is fine with Babel, it obviously doesn't compile with TypeScript\n`import 'bootstrap/css/bootstrap.css!'`\n\nTo make use of this feature I had to switch to AMD module loader and use `<amd-dependency path=\"bootstrap/css/bootstrap.css!\">` which emits proper code\n\nI'd love to see similar feature for SystemJS\n"
    },
    "satisfaction_conditions": [
      "TypeScript successfully compiles SystemJS-style CSS imports",
      "Generated JavaScript output contains proper SystemJS module registration",
      "CSS files are properly recognized as valid module imports",
      "No manual code modification required after compilation"
    ],
    "created_at": "2015-09-18T19:57:14Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/4710",
    "source": {
      "issue_number": 4710
    },
    "initial_question": {
      "title": "Ability to exclude some compiled .ts files from output",
      "body": "It would be good (and probably necessary for big projects) to have implementation that supports the following (I will provide a concreate example) use case:\n1. I have the terminal.ts file that depends on the core.ts, env.ts files:\n\n```\n///<reference path=\"env\">\n///<reference path=\"core\">\n\n// this is terminal.ts\n```\n1. I already included the compiled version of it in the main index.html file:\n\n``` html\n<html>\n...\n<script src=\"env-core-terminal_merged.js\"></script>\n</html>\n```\n\nThe env-core-terminal_merged.js contains compiled content of the following files: env.ts, core.ts, terminal.ts. I created the env-core-terminal_merged.js file with the following command:\n\n```\ntsc --out public/js/env-core-terminal_merged.js terminal.ts\n```\n\nIn this case the tsc will find all files (env.ts and core.ts) using ///reference directive and merge them into one.\n3. Now for some area of the site I need other files, say editor.ts that depends on env.ts, core.ts and other editor specic files: color.ts, mode.ts:\n\n```\n///<reference path=\"env\">\n///<reference path=\"core\">\n///<reference path=\"color\">\n///<reference path=\"mode\">\n\n// this is editor.ts\n```\n\nI want to include it like this:\n\n``` html\n<html>\n...\n<script src=\"env-core-terminal-merged.js\"></script>\n<script src=\"color-mode-editor_merged.js\"></script>\n</html>\n```\n\nand I created it with the following command:\n\n```\ntsc --out public/js/color-mode-editor_merge.js editor.ts\n```\n\nBut now there is a problem: as the editor.ts depends on the core.ts and env.ts the tsc will paste the compiled content of them into the color-mode-editor_merged.js again. But I need to have only one the compiled content of the core.ts, env.ts be included. I can't include only one file that will have compiled content for the all .ts files and replace the env-core-terminal-merged.js with it, because the site has block architecture and each block can define its own javascript files and have a common part for all blocks (in this case the common part is defined in the env-core-terminal-merged.js) For now to resolve of this problem I can only open the color-mode-editor_merged.js with editor and delete the compiled content of the core.ts and env.ts by hand (manually).\n"
    },
    "satisfaction_conditions": [
      "Modular file structure must be preserved in output",
      "All necessary type information and dependencies must be maintained"
    ],
    "created_at": "2015-09-09T14:33:26Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/4687",
    "source": {
      "issue_number": 4687
    },
    "initial_question": {
      "title": "Declare variable as typeof external module without import",
      "body": "Hey there,\n\nIs it possible to write an external (commonjs) module \"A\", then in another module \"B\"'s code, declare a variable as being typeof module \"A\" without using import which ends up require-ing module \"A\".\n\nThe reason I want to do this is that I will be passing a reference to module \"A\" to the constructor of a class in another module \"B\", because I want module \"A\" to be a singleton. But I want to type the argument in the constructor to that of module \"A\", as if module \"A\" had been imported using import A = require(\"A\");\n\nThe reason I want a singleton module is that this module might contain instances of classes that manage database connections, etc, and I don't really want them re-initialising each time I have to import; I want to be able to pass them around rather than rely on potential \"node-module cache\" magic.\n\nIs there a way to do this? I've thought of other ways I can achieve want I want but this feels like the simplest, if it's possible.\n"
    },
    "satisfaction_conditions": [
      "Type declarations must be possible without triggering module initialization",
      "Type information must match the external module's interface",
      "Type checking must work at compile time"
    ],
    "created_at": "2015-09-08T03:36:12Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/4635",
    "source": {
      "issue_number": 4635
    },
    "initial_question": {
      "title": "Interface in function declaration statement",
      "body": "There is a interface like this:\n\n``` ts\ninterface searchFunc {\n    (source: string, subString: string): boolean;\n}\n```\n\nI know I can use it in **function definition expression**:\n\n``` ts\nvar mySearch: searchFunc = function(src, sub) {\n    var result = src.search(sub);\n    if (result == -1) {\n        return false;\n    }\n    else {\n        return true;\n    }\n}\n```\n\nBut how can I use it in **function declaration statement** like below? Do I need to change the structure of interface?\n\n``` ts\nfunction mySearch(src, sub): searchFunc {\n    var result = src.search(sub);\n    if (result == -1) {\n        return false;\n    }\n    else {\n        return true;\n    }\n}\n```\n\nI'm waiting online,hope a answering.\n"
    },
    "satisfaction_conditions": [
      "Function type interface must be correctly applied to TypeScript code",
      "Code must maintain type safety for function parameters and return value",
      "Clear distinction between function declaration and function expression syntax must be explained"
    ],
    "created_at": "2015-09-04T06:32:18Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/4323",
    "source": {
      "issue_number": 4323
    },
    "initial_question": {
      "title": "outDir compiler option description or function unclear",
      "body": "The description \"Redirect output structure to the directory\" seems to imply mimicing of the source structure in the specified directory. \n\nFor example, I take the above description to mean:\nif source is \"app/app.ts\", then output should be <outDir>/app/app.js\n\nOutputs are placed in directory without structure. What is the correct behavior? \n"
    },
    "satisfaction_conditions": [
      "Output directory structure must preserve source directory hierarchy",
      "Root directory of source files must be correctly identified",
      "Compiled files must be placed in correct relative paths under output directory",
      "Output path generation must work for both single and multiple file scenarios"
    ],
    "created_at": "2015-08-14T23:44:40Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/4171",
    "source": {
      "issue_number": 4171
    },
    "initial_question": {
      "title": "Creating a class whose instances will be instances of Error",
      "body": "Hi,\n\nI'm creating some custom error classes, but ran into an issue when using jasmine's `expect(fn).toThrowError(MyCustomError);`\n\nThe problem is that jasmine's `toThrowError` matcher checks that the exception thrown by `fn` is an instance of `Error`. This is clumsy to satisfy in TypeScript, as in `lib.d.ts` `Error` is an interface.\n\nThus, if one creates `MyCustomError` in the most straightforward and intuitive way supported:\n\n``` javascript\nexport class MyCustomError implements Error { \n  public name: string = 'MyCustomError';\n  public message: string;\n}\n```\n\nand throws an instance of this class, code such as that in jasmine that checks for an instance of `Error` will fail. And yet, their assumption seems quite legitimate.\n\nHere's the code I ended up with:\n\n``` javascript\nexport class MyCustomError implements Error { \n  public name: string = 'MyCustomError';\n  public message: string;\n}\n\nMyCustomError.prototype = Object.create(Error.prototype);\n```\n\nThis will satisfy the `instanceof Error` constraint, but it's fairly unintuitive for what seems like a common task (creating a runtime subtype of `Error`) -- one that shouldn't require setting the `prototype` property manually.\n\nAny thoughts?\n"
    },
    "satisfaction_conditions": [
      "Custom error class instances must pass instanceof Error checks",
      "Custom error class must maintain Error interface compatibility",
      "Custom error class must be usable in TypeScript without type errors"
    ],
    "created_at": "2015-08-05T22:05:25Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/4140",
    "source": {
      "issue_number": 4140
    },
    "initial_question": {
      "title": "Can't define variable using type of typeof",
      "body": "I declared `test` module to export the global mongoose variable as below.\ntest1.d.ts:\n\n``` javascript\n  declare module \"test\" {\n    import _mongoose = require('mongoose');\n    export var export_mongoose: typeof _mongoose;\n  }\n```\n\nI tried to define mongoose.Model using the export_mongoose variable. Please refer to below code:\ntest2.ts:\n\n``` javascript\n  /// \\<reference path=\"test1.d.ts\" /\\>\n  import test = require('test');\n  var model: test.export_mongoose.Model\\<number\\>;  // it doesn't work.\n  var model = test.export_mongoose;  // it works well.\n```\n\nHowever, tsc compiler shows a following error message:\n  TS2305: Module `test` has no exported member `export_mongoose`.\n\nI think the export_mongoose is not proper as type cause defined by `typeof`.\nCan I use the `export_mongoose` as type?\n\nIt would be helpful for me if you have any idea on this.\n"
    },
    "satisfaction_conditions": [
      "TypeScript code must successfully compile without type errors",
      "Exported mongoose variable must be usable both as a value and as a type",
      "Mongoose object must be shareable across multiple files",
      "Type definitions must preserve the full mongoose type interface",
      "Module declaration must properly expose the mongoose functionality through the declared export"
    ],
    "created_at": "2015-08-04T04:37:39Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/3980",
    "source": {
      "issue_number": 3980
    },
    "initial_question": {
      "title": "Class expression inside a generic function bug",
      "body": "This code seems to be valid TS:\n\n``` ts\ninterface ReactClass<P, S> {\n    setState(state: S): void;\n}\n\ninterface Props {}\n\ninterface State {\n    hovered: boolean;\n}\n\nfunction createComponent<P extends Props, S extends State>() {\n    return class Component implements ReactClass<P, S> {\n        constructor() {\n            this.setState({ hovered: true })\n        }\n\n        setState(state: S): void {}\n    }\n}\n```\n\nBut it fails to compile:\n\n```\nissue.tsx(15,27): error TS2345: Argument of type '{ hovered: boolean; }' is not assignable to parameter of type 'S'.\n```\n\nIs it a bug?\n"
    },
    "satisfaction_conditions": [
      "Type compatibility between generic parameter and concrete type must be preserved",
      "Generic type constraints must be properly handled in class constructor",
      "Type safety must be maintained when assigning base types to derived generic types"
    ],
    "created_at": "2015-07-22T15:10:11Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/3933",
    "source": {
      "issue_number": 3933
    },
    "initial_question": {
      "title": "Unable to use combinators on prototypes.",
      "body": "I can not apply combinators to prototype. A combinator is a function that takes a function and returns another function. I use these to divide up functionality. I can use them in TypeScript, but they do not go on the prototype. I struggled to get them on the prototype, but TypeScript always throws an error. Here is an example of what I was trying to do. Inspired by TypeScript unions types I found many cases where I would like to pass T or T[]. I needed to write the code to handle this many places. So I wrote a combinator to handle this. So I would have:\n\n``` javascript\nfunctionThatCanHandleBoth = makeFunctionToHandleArrayAndSingle(handleSingleFunction)\n```\n\nI want to put this on the prototype because I want to use these functions in objects that have many instances.\n"
    },
    "satisfaction_conditions": [
      "Function transformation preserves 'this' context",
      "Function can handle both single and array inputs",
      "Transformed functions are accessible on prototype",
      "TypeScript type safety is maintained",
      "Function transformation is reusable across multiple methods"
    ],
    "created_at": "2015-07-20T19:05:22Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/3785",
    "source": {
      "issue_number": 3785
    },
    "initial_question": {
      "title": "problem with rest params and function overloading",
      "body": "``` ts\nexport function injection(clazz: Class)\n    export function injection(...metadata: Metadata[])\n    export function injection(...value: any[]) {\n\n        if (typeof value === typeof []) {\n            return (clazz: Class) => {\n                Injector.instance.register(clazz, value);\n            }\n        }\n        else {\n            Injector.instance.register(<any>value);\n        }\n    }\n```\n\nI`v got the compilation error\n\n```\nArgument of type 'any[]' is not assignable to parameter of type 'Metadata'.\n```\n\nand \n\n```\nArgument of type 'any[]' is not assignable to parameter of type 'Metadata'.\n  Property 'name' is missing in type 'any[]'.   \n```\n\nHave you any idea?\n"
    },
    "satisfaction_conditions": [
      "Function correctly handles both single Class and multiple Metadata parameters",
      "Accurate type discrimination between array and non-array inputs",
      "Type-safe registration with Injector",
      "Returns decorator function for Metadata array input",
      "Directly registers Class for non-array input"
    ],
    "created_at": "2015-07-08T21:04:47Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/3562",
    "source": {
      "issue_number": 3562
    },
    "initial_question": {
      "title": "Computed properties",
      "body": "``` typescript\nconst nameMember = \"_name\";\n\nclass Cls {\n    private [nameMember]: string;\n\n    constructor(name: string) {\n        this[nameMember] = name;\n    }\n}\n```\n\nCould be wrong, but isn't this now legal syntax? In both ES5 and ES6 modes, this generates the error:\n\n\"_A computed property name in a class property declaration must directly refer to a built-in symbol._\"\n\nComputed properties are listed on the Roadmap for Typescript 1.5 - is that still the case? If so, will ES6 mode be required, or will it work with ES5? Thanks.\n"
    },
    "satisfaction_conditions": [
      "Constant values used in computed properties must be determinable at compile time",
      "Type information must be preserved for computed property access"
    ],
    "created_at": "2015-06-18T19:17:44Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/3422",
    "source": {
      "issue_number": 3422
    },
    "initial_question": {
      "title": "Config to compile `const enum` as `enum` in development / Get SyntaxKind during development",
      "body": "Hi,\n\nWhen I work on the code, I have to change `SyntaxKind` from `const enum` to `enum` so that I can do `write(`kind: ${SyntaxKind[node.kind]}`)`.\n\nIs there a way to config the compiler and jake to treat `const enum` as `enum` so this would work?\nOr is there another way to get the SyntaxKind without doing `SyntaxKind[node.kind]`?\n\nThanks,\n"
    },
    "satisfaction_conditions": [
      "Access to enum member names must be possible during development/debugging",
      "Solution must work with const enums in TypeScript code",
      "Debug output must show human-readable enum member names"
    ],
    "created_at": "2015-06-08T18:30:20Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/3329",
    "source": {
      "issue_number": 3329
    },
    "initial_question": {
      "title": "Function type error in union type",
      "body": "I have been having issues with union types when using a function type as the second type in the union.\n\nAccording to the TypeScript 1.4 Language Specification: (3.4 Union Types, page 29)\n- A | B is equivalent to B | A\n\nThe following example compiles correctly:\n\n``` typescript\nfunction test(x: (y) => boolean | boolean) {\n    //do something with x\n}\n```\n\nBut this one gives an error:\n\n``` typescript\nfunction test(x: boolean | (y) => boolean) {\n    //do something with x\n}\n```\n"
    },
    "satisfaction_conditions": [
      "The type declaration must be unambiguously parsed by the TypeScript compiler",
      "The union type must maintain its intended logical meaning",
      "The type declaration must compile without errors",
      "The type declaration must maintain type equivalence with the original intent"
    ],
    "created_at": "2015-06-01T19:31:47Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/3318",
    "source": {
      "issue_number": 3318
    },
    "initial_question": {
      "title": "How can I debug compilation?",
      "body": "This is less an issue but a request for advice. I try to change the way code for namespaces is emitted.\n\nCurrently the typescript code\n\n```\nnamespace A{\n    var x = 42;\n}\n```\n\nis  emitted as\n\n```\nvar A;\n(function (A) {\n    var x = 42;\n})(A || (A = {}));\n```\n\nwhich I want to change to be emitted as\n\n```\n    var A_x = 42;\n```\n\nObviously, all references to x also need to become A_x .\n\nI walkted through emitter.ts and declarationEmitter.ts but without being able to stepping through the compilation with a debugger it is hard to fully understand the pieces. So my question:\n\n How can I debug compilation ?\n Hints on my namespace hack are also appreciated.     \n"
    },
    "satisfaction_conditions": [
      "Debugger must be able to attach to the TypeScript compilation process",
      "Debugger must support breakpoint functionality",
      "Development environment must be able to access TypeScript compiler source code",
      "Solution must work with the local TypeScript build environment"
    ],
    "created_at": "2015-05-31T13:31:13Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/3290",
    "source": {
      "issue_number": 3290
    },
    "initial_question": {
      "title": "Map,Set ... in ES5 target",
      "body": "After update the typescript compiler from version 1.4.1 to 1.5.0 beta, the source code included in my project became to make error log such as 'Map is not found'.\nThus, I researched this problem, and I reached an conclusion. The lib.d.ts became not to contain Map and Set definitions except ES6 being selected in tsconfig.json.\n\nActually, Map and Set is specification of ES6. It is natural that we can't use Map and Set in the project targeting ES5 or lower.\nBut we could use Map and Set even if I select ES5 as the target before typescript 1.4.1.\nI know that making it being enabled to use Map and Set in the project that is made for ES5 contains risk.\nBecause there is some of browsers not supporting Map and Set.\n\nHowever, I think it is better to make some of property of configuration that is for switching to use these definitions or not. Don't you think so?\n"
    },
    "satisfaction_conditions": [
      "TypeScript code using Map/Set compiles successfully when targeting ES5",
      "Map and Set type definitions are available to the TypeScript compiler",
      "Map and Set interfaces include all standard collection methods and properties",
      "Generic type parameters are properly supported",
      "Solution works with TypeScript 1.5.0 beta and later versions"
    ],
    "created_at": "2015-05-28T08:52:59Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/3243",
    "source": {
      "issue_number": 3243
    },
    "initial_question": {
      "title": "vs plugin, 1.5beta regression: can not extend from class in external import",
      "body": "this works in older versions.\n\nwhen I have the following code in 1.5beta:\n\n```\nimport refs = require(\"../refs\");\nvar xlib = refs.xlib;\n\nexport class PjscBe extends xlib.ClassBase{}\n```\n\nI get the following error:\n`265  Cannot find name 'xlib'.`\n\nthis issue goes away if I remove the extends.  I can use my external module in other ways just fine:\n`var log = new xlib.diagnostics.logging.Logger(__filename);`\n"
    },
    "satisfaction_conditions": [
      "The external module reference must be accessible in type positions",
      "The external module reference must remain usable in value positions",
      "The TypeScript compiler must compile the code without 'Cannot find name' errors",
      "The class inheritance relationship must be properly established"
    ],
    "created_at": "2015-05-21T13:29:24Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/3213",
    "source": {
      "issue_number": 3213
    },
    "initial_question": {
      "title": "Access to static fields via constructor property",
      "body": "This is example of correct code, though compiler raises an error `Property 'bar' does not exist on type 'Function'.`\n\n``` typescript\nclass A {\n    static bar(): void {\n        alert(\"Oh hi!\");\n    }\n\n    foo(): void {\n        this.constructor.bar(); //<-- compiler error\n    }\n}\n```\n"
    },
    "satisfaction_conditions": [
      "Static method access must work from instance methods",
      "Type safety must be maintained across inheritance hierarchies",
      "Constructor reference must be properly typed",
      "Solution must work with TypeScript's type checking"
    ],
    "created_at": "2015-05-19T10:57:45Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/3193",
    "source": {
      "issue_number": 3193
    },
    "initial_question": {
      "title": "type-safe cast",
      "body": "There doesn't seem to be a safe cast in Typescript. (&lt;T&gt; x) does no dynamic check. This is a very common need and is provided in every other optionally and gradually typed language I know of. What is needed is something like:\n\n```\nfunction cast<T>(x: any): T {\n    if (x instanceof T) return x;\n    throw new Error('type cast exception');\n}\n```\n\nexcept that doesn't compile. Is there an alternative solution I'm missing?\n"
    },
    "satisfaction_conditions": [
      "Runtime type verification must be supported",
      "Must handle type casting errors gracefully",
      "Must work with class-based types",
      "Must maintain type safety in TypeScript",
      "Must provide type information to TypeScript compiler"
    ],
    "created_at": "2015-05-18T00:24:07Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/3021",
    "source": {
      "issue_number": 3021
    },
    "initial_question": {
      "title": "Getting \"Maximum call stack size exceeded\" when using \"getDocumentHighlights\" with reference paths and modules in 1.5.0-beta",
      "body": "If I have code that looks something like this: \n\n``` typescript\n/// <reference path=\"nounreachable.test.ts\" />\n\nmodule S {\n  var template = '';\n}\n```\n\nand I try to do getDocumentHighlights on \"template\" in just that one file, I get a \"Maximum call stack size exceeded\" error. Am I doing something wrong? Or can you guys fix this, please? Thanks!\n"
    },
    "satisfaction_conditions": [
      "Language service must handle reference paths without stack overflow",
      "File resolution behavior must be properly controlled",
      "Solution must work with relative paths",
      "File-by-file analysis must be possible"
    ],
    "created_at": "2015-05-04T17:29:01Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/2844",
    "source": {
      "issue_number": 2844
    },
    "initial_question": {
      "title": "Duplicate identifier error in Visual Studio 2015 CTP",
      "body": "Hi\n\nI create the new \"typescript\" project.\nI generate the description file for the app.ts by `tsp --target es5 -d app.ts`\n\nI immediately receive the duplicate identifier error.\nI am not sure how to deal with this issue as I want to have both implementation and description files in my project.\n\nHere are the files `app.ts`\n\n``` javascript\nclass Greeter {\n    element: HTMLElement;\n    span: HTMLElement;\n    timerToken: number;\n\n    constructor(element: HTMLElement) {\n        this.element = element;\n        this.element.innerHTML += \"The time is: \";\n        this.span = document.createElement('span');\n        this.element.appendChild(this.span);\n        this.span.innerText = new Date().toUTCString();\n    }\n\n    start() {\n        this.timerToken = setInterval(() => this.span.innerHTML = new Date().toUTCString(), 500);\n    }\n\n    stop() {\n        clearTimeout(this.timerToken);\n    }\n\n}\n\nwindow.onload = () => {\n    var el = document.getElementById('content');\n    var greeter = new Greeter(el);\n    greeter.start();\n};\n```\n\nand `app.d.ts`\n\n``` javascript\ndeclare class Greeter {\n    element: HTMLElement;\n    span: HTMLElement;\n    timerToken: number;\n    constructor(element: HTMLElement);\n    start(): void;\n    stop(): void;\n}\n```\n"
    },
    "satisfaction_conditions": [
      "Project maintains correct type information for development",
      "Clear separation between implementation and type declaration files",
      "Project structure supports both internal development and external consumption"
    ],
    "created_at": "2015-04-21T07:36:34Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/2755",
    "source": {
      "issue_number": 2755
    },
    "initial_question": {
      "title": "error TS6050: Unable to open file 'tsconfig.json'.",
      "body": "Why?\nI'm not giving reasons for this to happen:\n   1- Running on windows.\n   2- I've closed the tsconfig.json file.\n   2- The command is \"tsc\" under a folder that has the following tsconfig.json file:\n\n```\n{\n    \"files\": [\n        './js/**/*.ts',\n        './modules/**/*.ts'\n    ]\n}\n```\n"
    },
    "satisfaction_conditions": [
      "TypeScript compiler must have read access to tsconfig.json",
      "Configuration file must be properly closed/unlocked by other processes"
    ],
    "created_at": "2015-04-14T02:03:54Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/2609",
    "source": {
      "issue_number": 2609
    },
    "initial_question": {
      "title": "Class decorator parameters",
      "body": "I'm fairly sure I have the syntax right:\n\n``` javascript\n@ClassDecoratorTest(\"Test\")\nclass Test\n{\n}\n\nfunction ClassDecorationTest(target, name)\n{\n}\n```\n\nBut this won't compile. I get the following error on the @ClassDecorator line:\n\nerror TS2346: Supplied parameters do not match any signature of call target.\n"
    },
    "satisfaction_conditions": [
      "Decorator function must return another function that accepts the target class",
      "Decorator syntax must compile without type errors",
      "Decorator must be able to access passed parameters",
      "Decorator must be able to modify the target class"
    ],
    "created_at": "2015-04-03T19:57:28Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/2492",
    "source": {
      "issue_number": 2492
    },
    "initial_question": {
      "title": "tsconfig.json purpose?",
      "body": "Question: tsconfig.json appears to be a reasonable way to specify a compilation context. Why isn't it available from the command line? ( tsc -c tsconfig.json ). I would like to be able to use tsconfig.json within a build system ( gulp based ) rather than it be a build system.\n"
    },
    "satisfaction_conditions": [
      "TypeScript compiler must be able to locate and use the tsconfig.json configuration",
      "Configuration must be usable within external build systems",
      "Command line interface must provide a way to specify the configuration context",
      "Solution must work without requiring tsconfig.json to be a build system itself"
    ],
    "created_at": "2015-03-25T19:00:57Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/2420",
    "source": {
      "issue_number": 2420
    },
    "initial_question": {
      "title": "Unsupported file encoding",
      "body": "Hi, i have a typescript file which provide string translations for Italian in my solution, when i compile the solution, i got follow compile errors:\n\nSeverity    Code    Description Project File    Line\nError       Build: Cannot read file 'D:/workdir/devunits/song_cordova20150227_dev/src/cordova/scripts/app/I18N/it-IT/Strings.ts': Unsupported file encoding.\n\nEnv and Tools i used:\nVS2015 CTP5 (incl. TS 1.4), Cordova project.\n\nHere is the content of cordova/scripts/app/I18N/it-IT/Strings.ts: \n\n\"use strict\";\nexport var Strings = {\n    MsgMarkUpShareFailed: \"Impossibile condividere i markup in OneNote\",\n    Erase: \"Cancella\",\n    TextForSelectJTFolder: \"Selezionare la cartella JT suddivisa\",\n    Error_Printing: \"Errore durante la stampa del modello\",\n    SharedFileNotFoundExceptionMessage: \"Impossibile trovare il file richiesto in OneDrive. Verificare con gli utenti che condividono il file che siano state accordate le necessarie autorizzazioni.\",\n    Property_LastAuthor: \"Ultimo autore\",\n    OpenInJT2Go: \"Apri in JT2Go\",\n    ShowPMI: \"Mostra PMI\",\n    Share: \"Condividi\",\n    MsgBedDepth: \"La  profondit\u00e0 deve essere maggiore di 0.\",\n    Cancel: \"Annulla\",\n    Error_NonPositiveVolume: \"Stampa interrotta. Il modello non ha un volume positivo\",\n    Dimensions: \"Quote\",\n    DrillUp: \"Drill up\",\n    MsgBedHeight: \"L'altezza deve essere maggiore di 0.\",\n    Property: \"Propriet\u00e0\",\n    Note: \"Nota\",\n    MsgPLMXMLWasModified: \"Il markup \u00e8 stato modificato e deve essere salvato. Salvarlo ora?\",\n    Loading: \"Caricamento\",\n    Created: \"creato\",\n    Property_Parts: \"Parti\",\n    OrientTo: \"Orienta verso\",\n    DrillDown: \"Drill down\",\n    Section: \"Sezione: \",\n    Samples: \"Campioni\",\n    Print: \"Stampa\",\n    Property_ProjectName: \"Nome progetto\",\n    AlignToView: \"Allinea a vista\",\n    TakeImage: \"Scegli immagine\",\n    ToLast: \"Vai all'ultimo\",\n    Property_Density: \"Densit\u00e0\",\n    DFS: \"Simboli feature Datum\",\n    Default: \"Predefinita\",\n    MsgPLMXMLNotMatchJTError: \"Questo file plmxml non corrisponde al file jt attualmente aperto. Selezionare il file corretto e riportare.\",\n    MsgFailedCreateHomePage: \"Errore durante la creazione della pagina iniziale.\",\n    Snapshot: \"Istantanea\",\n    BedHeight: \"Altezza (mm)\",\n    PinToStart: \"Aggancia all'avvio\",\n    Property_Unit: \"Unit\u00e0\",\n    PrintBedDepth: \"Profondit\u00e0\",\n    SelectionColor: \"Finestra dei colori\",\n    Home: \"Pagina iniziale\",\n    Pan: \"Sposta\",\n    Text: \"Caricatore di testo\",\n    Property_DocumentNumber: \"Nr. documento\",\n    MsgBedWidth: \"Lo spessore deve essere maggiore di 0.\",\n    TextForSelectJT: \"Selezionare un file JT\",\n    Properties: \"Propriet\u00e0\",\n    DefaultMarkupItemDescription: \"Commenti senza titolo\",\n    Property_TranslationDate: \"Data conversione\",\n    FinishPrinting: \"Dati inviati alla stampante 3D\",\n    FCF: \"Fotogrammi controllo feature\",\n    Error_InvalidModel: \"Stampa interrotta. Il modello non \u00e8 definito correttamente\",\n    Property_Company: \"Azienda\",\n    General: \"Generale\",\n    PMIFilters: \"Filtri PMI\",\n    MeasurementPoints: \"Punti di misurazione\",\n    Save: \"Salva\",\n    Open: \"Apri\",\n    ChooseImage: \"Scegli immagine\",\n    Property_NameOfSavingApplication: \"Nome dell'applicazione da salvare\",\n    BedWidth: \"Larghezza (mm)\",\n    Other: \"Altro\",\n    OneDriveLoadMarkupExceptionMessage: \"Errore durante l'apertura del markup da OneDrive\",\n    SettingLanguage: \"Lingua\",\n    DatumTargets: \"Destinazioni datum\",\n    SpotWelds: \"Punti di unione\",\n    StartPrinting: \"Stampa iniziata. L'operazione potrebbe richiedere alcuni minuti\",\n    HidePMI: \"Nascondi PMI\",\n    ShareToOneNote: \"Condividi in OneNote\",\n    Accept: \"Accetta\",\n    Less: \"Meno\",\n    More: \"Altro\",\n    Property_CADSource: \"Origine CAD\",\n    PMIPanelState: \"Selezionare i tipi PMI da visualizzare\",\n    SelectAll: \"Seleziona tutto\",\n    MsgGreaterThan: \"{0} deve essere maggiore di 0.\",\n    ToggleCamera: \"Attiva/Disattiva  videocamera\",\n    CollapseBar: \"Comprimi barra\",\n    Normal: \"Normale\",\n    DeleteView: \"Elimina vista\",\n    Error_NonManifold: \"Stampa interrotta. Il modello non \u00e8 impermeabile\",\n    OneDriveAuthenticationExceptionMessage: \"Errore durante il caricamento del file richiesto perch\u00e9 le credenziali di autenticazione presentano un'anomalia per quanto riguarda la connessione a OneDrive.\",\n    LanguageTag: \"it-IT\",\n    Property_LastSaveDate: \"Data ultimo salvataggio\",\n    Property_TriangleCount: \"Numero di triangoli\",\n    AppDescription: \"Un'applicazione di rendering 3D per la visualizzazione di file di formato JT.\",\n    View: \"Vista\",\n    Property_Keywords: \"Parole chiave\",\n    LoadFile: \"Carica\",\n    EditDescription: \"Modifica descrizione\",\n    ShowAllPMI: \"Mostra tutte le informazioni PMI\",\n    BedDepth: \"Spessore (mm)\",\n    Delete: \"Elimina\",\n    Property_ApplicationName: \"Nome applicazione\",\n    FullScreen: \"Schermo intero\",\n    Error_LoadPart: \"Impossibile aprire il file JT specificato\",\n    ModelView: \"Vista modello\",\n    Fit: \"Adatta\",\n    SharingStatus: \"Condivisione\",\n    LoadingStatus: \"Caricamento\",\n    RestoreDefaults: \"Ripristina i default\",\n    ExceedPrintableAreaMessage: \"Il modello supera l'area stampabile\",\n    HideAllPMI: \"Nascondi tutte le informazioni PMI\",\n    Recent: \"Recente\",\n    TextForSelectImage: \"Seleziona un file di immagine\",\n    Error: \"Errore\",\n    Property_Geometry: \"Geometria\",\n    Locators: \"Localizzatori\",\n    OneDriveLoginExceptionMessage: \"Impossibile eseguire l'accesso a OneDrive\",\n    Property_Comments: \"Commenti\",\n    Property_Category: \"Categoria\",\n    Property_Attribute: \"Attributo\",\n    Settings: \"Impostazioni\",\n    Spin: \"Rotazione\",\n    Hide: \"Nascondi\",\n    Freehand: \"A mano libera\",\n    PrintBedWidth: \"Larghezza\",\n    Attribute: \"Attributo\",\n    Property_TranslatorVersion: \"Versione convertitore\",\n    Reset: \"Ripristina\",\n    Options: \"Opzioni\",\n    Surface: \"Superficie\",\n    BackgroundColor: \"Colore sfondo\",\n    ViewType: \"Visualizza tipo\",\n    Property_VertexCount: \"Numero di vertici\",\n    LoadFileExceptionMessage: \"Si \u00e8 verificato un errore durante il caricamento del file.\",\n    Status_Pinned_Success: \"JT2Go \u00e8 agganciato allo schermo iniziale\",\n    Property_Length: \"Lunghezza\",\n    FontFamily: \"Segoe UI\",\n    Property_Subject: \"Oggetto\",\n    PMIColor: \"Colore PMI\",\n    PartLoaderExceptionMessage: \"Si \u00e8 verificato un errore durante il caricamento del file JT specificato.\",\n    Property_Author: \"Autore\",\n    MsgMarkUpShareSuccessed: \"Markup condivisi correttamente in OneNote\",\n    ClearAll: \"Cancella tutto\",\n    Property_OriginationDate: \"Data di origine\",\n    OneDriveConnectionExceptionMessage: \"Errore durante il caricamento del file richiesto causato dalla connessione OneDrive.\",\n    MsgExpectedNumber: \"{0} deve essere un numero.\",\n    Part: \"Parte\",\n    Status_Pinned_Failure: \"Errore durante l'aggancio di JT2GO alla schermata iniziale\",\n    LiveCamera: \"Videocamera live\",\n    Legal: \"Legale\",\n    Property_Name: \"Nome\",\n    Property_Width: \"Larghezza\",\n    Discard: \"Elimina\",\n    Decline: \"Calo\",\n    MsgFailedCreateLicensePage: \"Errore durante la creazione della pagina di licenze.\",\n    Geometry: \"Geometria\",\n    ShowAllParts: \"Mostra tutte le parti\",\n    Property_Material: \"Materiale\",\n    ToFirst: \"Vai al primo\",\n    ShatteredFolderIncorrectExceptionMessage: \"Si \u00e8 verificato un problema durante il caricamento della cartella suddivisa. Verificare di aver selezionato la cartella esatta.\",\n    PrivacyPolicy: \"Criteri sulla privacy\",\n    PrintBedHeight: \"Altezza\",\n    Property_Title: \"Titolo\",\n    WaitingStatus: \"Attesa\",\n    Background: \"Sfondo\",\n    CoordinateSystems: \"Sistemi di coordinate\",\n    Property_Height: \"Altezza\",\n    Structure: \"Struttura\",\n    DefaultMarkupItemDescriptionWithUserName: \"Commenti di {0}\",\n    Default3DPrinter: \"Stampante 3D predefinita\",\n    Help: \"Guida\"\n}\n"
    },
    "satisfaction_conditions": [
      "The solution must be compatible with the development environment (VS2015 CTP5, TS 1.4)"
    ],
    "created_at": "2015-03-19T00:46:40Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/2373",
    "source": {
      "issue_number": 2373
    },
    "initial_question": {
      "title": "Passthrough require(\"jsfile\") for commonjs",
      "body": "Hello Typescipters,\n\nI'm using the `Q` library with its typings installed via `tsd`.\nIn a module I'm using\n\n``` typescript\n/// <reference path=\"../typings/q/Q.d.ts\"/>\n// ...\n```\n\ncompiled with\n\n``` bash\ntsc -m commonjs --out test.js test.ts\ntsc --version\nmessage TS6029: Version 1.4.1.0\n```\n\nand would like `test.js` to contain a line like\n\n``` javascript\nvar Q = require(\"path/to/q\"); // to be executed by nodejs\n```\n\nwhere `path/to/q` points to the javascript file and has nothing to do with `../typings/q/Q.d.ts`.\nUsing `import Q = require(\"path/to/q\");` won't work as it probably expects a typescript module.\n\n``` bash\nbuilder.ts(5,32): error TS2307: Cannot find external module './../bower_components/q/q'.\n```\n\nI haven't found how to achieve this without rolling out some hackish _ad-hoc_ source markup/parse/replace. Have I overlooked something?\n\nIn a way I'm trying to \"link\" to the library code (in the C meaning) with node's `require` after having included the declarations (references to the `d.ts`).\n\nIf this is not currently possible, may I suggest a pass-through version of `require()` which kicks in when `-m commonjs` is used? Perhaps `js_require(\"blabla\")` which would be emitted as node's `require(\"blabla\")`. This would make it a lot easier to leverage other tools which analyze `require` statements.\n\nGreetings\n"
    },
    "satisfaction_conditions": [
      "TypeScript code must compile to JavaScript that includes a working require() statement",
      "Type information from .d.ts files must be preserved during development",
      "Generated JavaScript must be executable by Node.js without runtime errors",
      "Module path resolution must work for both TypeScript compilation and Node.js runtime",
      "No duplicate identifier conflicts between type definitions and runtime variables",
      "CommonJS module output must be generated as separate files when using external modules"
    ],
    "created_at": "2015-03-16T16:53:03Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/2189",
    "source": {
      "issue_number": 2189
    },
    "initial_question": {
      "title": "Tuple type vs. array-of-union-type",
      "body": "Have I made a silly mistake here? I thought the tuple type `[string, number]` was roughly equivalent to the array-of-union-type `(string | number)[]`, and that the following was therefore legal:\n\n```\nfunction lengths (xs: string[]): [string, number][] {\n   return xs.map((x: string) => [x, x.length])\n}\n```\n\nHowever tsc 1.4 complains:\n\n```\nConfig.ts(127,11): error TS2322: Type '(string | number)[][]' is not assignable to type '[string, number][]'.      Type '(string | number)[]' is not assignable to type '[string, number]'.\n    Property '0' is missing in type '(string | number)[]'.\n```\n"
    },
    "satisfaction_conditions": [
      "The function must return an array of tuples where each tuple contains a string and its length",
      "The transformation from input strings to output tuples must be type-safe"
    ],
    "created_at": "2015-03-03T08:19:15Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/2149",
    "source": {
      "issue_number": 2149
    },
    "initial_question": {
      "title": "Define variable to match declared variable with 'new'",
      "body": "It is possible to define variable with declared when the function name is not 'new'\n\n``` typescript\ninterface X {\n}\ndeclare var X: {\n    f(): X;\n}\n\n// OK, compatible type\nvar X = {\n    f() { return <X>null; }\n};\n\n\ninterface Y {\n}\ndeclare var Y: {\n    new(): Y;\n}\n\n// Not compatible types\n// new() : Y vs. new() => Y\nvar Y = {\n    new() { return <Y>null; }\n};\n```\n"
    },
    "satisfaction_conditions": [
      "The variable must be callable as a constructor with 'new' operator",
      "The implementation must match the declared type signature exactly",
      "The variable must be defined in global scope without causing reference errors",
      "The implementation must preserve TypeScript type safety",
      "The variable definition must be compatible with strict parsing mode"
    ],
    "created_at": "2015-02-26T10:24:05Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/2147",
    "source": {
      "issue_number": 2147
    },
    "initial_question": {
      "title": "Question, how to make a variable within declared module name",
      "body": "I am writing a test and I have an issue.\nThe test runner doesn't have the global object I need since it is running in a different environment.\nI want to create this object because strict mode complains otherwise, but TypeScript cannot do it.\n\nI have declaration:\n\n``` typescript\ndeclare module Q {\n    function f(): string;\n}\n```\n\nand usage\n\n``` typescript\nvar x = Q.f();\n```\n\nNow in my test I want to mock Q.f and create object of my own.\n\n``` typescript\nvar Q = { ... }\n```\n\nThe TypeScript complains about multiple declarations.\n\nThere is a workaround to access the module through the global 'window' object in the code and then it is possible to test it.\n\n``` typescript\ninterface Window {\n Q: QInterface;\n}\n\ninterface QInterface {\n    function f(): string;\n}\n\n// the code\nvar x = !!window.Q ? window.Q.f() : \"\";\n```\n\nI would like to not use the workaround and find some solution without changing my code.\nThanks.\n"
    },
    "satisfaction_conditions": [
      "Module Q must be mockable in test environment",
      "Solution must work in test runner's environment",
      "Type safety must be maintained"
    ],
    "created_at": "2015-02-26T06:41:20Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/2067",
    "source": {
      "issue_number": 2067
    },
    "initial_question": {
      "title": "--mapRoot doesn't seem to work",
      "body": "`tsc --sourceMap --mapRoot maproot/ --out a.js t.ts`\n\nIt simply places the .js.map files in the same directory as the --out file.\n"
    },
    "satisfaction_conditions": [
      "Source map file reference path in JS file must reflect mapRoot value",
      "Generated source map files remain in same directory as output JS file",
      "Source map references must be configured to match intended deployment structure"
    ],
    "created_at": "2015-02-18T22:21:10Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/1877",
    "source": {
      "issue_number": 1877
    },
    "initial_question": {
      "title": "Different rules for function parameter compatibility when assignment is on a different line to variable declaration.",
      "body": "A function can choose to omit parameters defined in a signature, as shown by function `a` below. Callers of `a` must still supply arguments, but the function does not need to use them.\n\nDespite this, if the same function is assigned later in the program, this no longer applies and the identical function is now not compatible, as shown with function `b`.\n\n``` typescript\ninterface X {\n    (source: number): boolean;\n}\n\nvar a: X = function() { return true; }\n\nvar b: X;\n// Why is this an error?\nvar b = function() { return true; }\n```\n\nShouldn't both of these cases follow the same rules?\n"
    },
    "satisfaction_conditions": [
      "Variable redefinition rules must be clearly explained",
      "Type inference behavior must be accounted for",
      "The distinction between declaration and assignment syntax must be addressed"
    ],
    "created_at": "2015-01-31T19:06:04Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/1867",
    "source": {
      "issue_number": 1867
    },
    "initial_question": {
      "title": "Private variables in definition files",
      "body": "When I produced definition files (.d.ts) for my projects, private variables of classes are also present.\n\nMost of the time, I use internal libraries that require others definition files (jquery.d.ts for example), or definition files that are not present in lib.d.ts (Promises.d.ts and TouchEvent.d.ts for example).\n\nBut as I use private variables in my classes for wich the type is only defined in these definition files, my project generated definition file contains these types.\n\nSo without publish all the other .d.ts files with my project one, it is unusable.\n\nIs there a way to manage it ? Or just remove the private variables to prevent these cases ?\n\nThanks\n"
    },
    "satisfaction_conditions": [
      "Private class members must be handled in a way that preserves type safety",
      "Generated .d.ts files must maintain class inheritance safety",
      "Type information must be complete enough for compiler validation"
    ],
    "created_at": "2015-01-30T12:51:15Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/1763",
    "source": {
      "issue_number": 1763
    },
    "initial_question": {
      "title": "Not generating output for exported const enum makes the enum useless from regular JavaScript",
      "body": "Currently, no JavaScript is generated for const enum declarations (the language spec does not seem to address const enums).\n\nIs there a way to get the benefit of aggressive compile-time enum evaluation while still generating the JS enum object?\n\nIt would be nice if the computed values in the example below would be computed at compile-time like is done for const enum, but retain the generated JS so that the enum can be used from non-typescript applications:\n\n``` typescript\nexport enum Things {\n    ThingA = 0x1,\n    ThingB = 0x2,\n    ThingC = 0x4,\n    Mask = ThingA | ThingB | ThingC,\n}\n```\n\nDesired output:\n\n``` javascript\nvar Things;\n(function (Things) {\n    Things[Things[\"ThingA\"] = 1] = \"ThingA\";\n    Things[Things[\"ThingB\"] = 2] = \"ThingB\";\n    Things[Things[\"ThingC\"] = 4] = \"ThingC\";\n    Things[Things[\"Mask\"] = 7] = \"Mask\";\n})(Things || (Things = {}));\n```\n"
    },
    "satisfaction_conditions": [
      "Generated JavaScript code must include the complete enum definition",
      "Enum must be exportable and usable from regular JavaScript code"
    ],
    "created_at": "2015-01-21T20:56:39Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/1739",
    "source": {
      "issue_number": 1739
    },
    "initial_question": {
      "title": "how to uninstall 1.4",
      "body": ""
    },
    "satisfaction_conditions": [
      "Previous version 1.4 is completely removed from the system",
      "Existing development environment remains functional after removal",
      "Previous version (if needed) is properly restored and operational"
    ],
    "created_at": "2015-01-20T10:33:48Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/1565",
    "source": {
      "issue_number": 1565
    },
    "initial_question": {
      "title": "Null calling pre-compile check",
      "body": "Hi. I'm working on a bit bigger project that is fully driven by TS, and I noticed that compiler doesn't check if variables that have as type object, are filled with instances anywhere. I didn't realize that so now my project is full of variables that were never initialized. So I thought that this would help a lot, and it isn't that hard to check. But I'm a horrible JS programmer. I hate even look at JS. So... just an idea. \n\nThanks for reading.\n"
    },
    "satisfaction_conditions": [
      "Detect uninitialized variables in TypeScript code",
      "Provide compile-time type checking",
      "Work across a large TypeScript project",
      "Identify potential null/undefined values"
    ],
    "created_at": "2014-12-26T18:06:20Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/1487",
    "source": {
      "issue_number": 1487
    },
    "initial_question": {
      "title": "Tuple type checking",
      "body": "I haven't had the time to investigate yet, but was surprised to see the following compile without error with tsc.exe shipped in the VS extension v1.3:\n    var testingzetuple: [number, string] = [1, \"world\", \"foreva\"];\nor\n    var testingzetuple: [number, number] = [1, 2, 3];\nIs that the expected behaviour? Shouldn't tuple type [t1,...,tn] be limited to size n?\n"
    },
    "satisfaction_conditions": [
      "Longer tuples must be assignable to shorter tuple types when their initial elements match the target type",
      "Type checking must validate that the types of the first n elements match the declared tuple type",
      "Additional elements beyond the declared tuple length must be allowed by the type system"
    ],
    "created_at": "2014-12-15T14:33:18Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/1481",
    "source": {
      "issue_number": 1481
    },
    "initial_question": {
      "title": "Can an optional and required field of merged interfaces yield a required field?",
      "body": "I have this case from using the mongoose library, in which my domain object, A, might have a DB _id, but the mongoose.Document always has an _id.\nI use type A when not in the mongoose portions of the app, and type ADocument only within those parts that deal directly with mongoose.  Note that mongoose defines Document to contain _id like this:\n\n```\ninterface Document {\n    _id: string;\n}\n```\n\nI tried to model the A - ADocument relationship like this:\n\n```\ninterface A {\n    _id?: string;\n}\ninterface ADoc extends A, mongoose.Document {   \n}\n```\n\nbut I get this error:\n_Interface 'ADoc' cannot simultaneously extend types 'A' and 'Document':\n Named properties '_id' of types 'A' and 'Document' are not identical._\n\nI can get around this error by making _id be either optional in both definitions, or required in both.\n\nI expect that the compiler can infer that _id is now required in ADoc. \nIs the current behavior of issuing an error the correct behavior? \nIf so, does it make sense to merge such fields so they become required?\n"
    },
    "satisfaction_conditions": [
      "Interface inheritance must resolve property conflicts between optional and required fields",
      "The resulting interface must satisfy TypeScript's type system rules for property inheritance",
      "The final interface must be usable as both a Document type and the original type A",
      "The _id field must be treated as required in the final interface"
    ],
    "created_at": "2014-12-14T19:09:06Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/1023",
    "source": {
      "issue_number": 1023
    },
    "initial_question": {
      "title": "How to append method to Array.prototype with .d.ts",
      "body": "I need to append a method to Array.prototype such as  \n\n```\nArray.prototype.first = function(){\n    //blablabla\n}\n\n```\n\nHow to write this `.d.ts` file .\n\nThanks all \n"
    },
    "satisfaction_conditions": [
      "TypeScript declaration file correctly extends Array prototype",
      "Declaration preserves generic type parameter",
      "Method declaration matches runtime implementation",
      "Declaration merges with existing Array interface"
    ],
    "created_at": "2014-11-01T07:07:15Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/423",
    "source": {
      "issue_number": 423
    },
    "initial_question": {
      "title": "Usage of void type ",
      "body": "Why this is allowed ?\n\n``` typescript\ninterface A<T> {\n f(x:number,a: T);\n}\n\n<A<void>>(null).f(1); \n```\n\nWhile calling the function via variable not ?\n\n``` typescript\nvar a = <A<void>>(null);\na.f(1);\n```\n"
    },
    "satisfaction_conditions": [
      "Function calls with void type parameters must include all required arguments explicitly",
      "Type assertions must use proper parentheses to maintain correct operator precedence",
      "Generic type constraints must be properly enforced when restricting type parameters"
    ],
    "created_at": "2014-08-11T12:05:01Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/54956",
    "source": {
      "issue_number": 54956
    },
    "initial_question": {
      "title": "'Convert named export to default export' removes type-information",
      "body": "Type: <b>Bug</b>\r\n\r\n1. select a  type annotated named export in a tsx file   \r\n1. hit `ctrl+.`\r\n1. select 'Convert named export to default export' \r\n1. observe how your type info is discarded \r\n\r\nbefore:\r\n```tsx \r\nexport const LabelList: React.FC<{ labelIds: number[] }> = ({ labelIds }) => {\r\n  const labels = useSelector<Types.RootState, LabelsState>(\r\n    ({ labels }) => labels,\r\n  );\r\n  return (\r\n    <div>\r\n      {labelIds.length ? (\r\n        labelIds.map(l => labels![l]).map(l => <LabelToken label={l} />)\r\n      ) : (\r\n        <small className={styles.noDescription}>No labels</small>\r\n      )}\r\n    </div>\r\n  );\r\n};\r\n```\r\n\r\nafter:\r\n```tsx\r\nexport default ({ labelIds }) => {\r\n  const labels = useSelector<Types.RootState, LabelsState>(\r\n    ({ labels }) => labels,\r\n  );\r\n\r\n  return (\r\n    <div>\r\n      {labelIds.length ? (\r\n        labelIds.map(l => labels![l]).map(l => <LabelToken label={l} />)\r\n      ) : (\r\n        <small className={styles.noDescription}>No labels</small>\r\n      )}\r\n    </div>\r\n  );\r\n};\r\n```\r\n \r\ninlining the type-annotations in a default export may not be possible (im not sure), but an intemediate variable can be exported as a default  \r\n\r\nVS Code version: Code 1.79.2 (695af097c7bd098fbf017ce3ac85e09bbc5dda06, 2023-06-14T08:59:55.818Z)\r\nOS version: Linux x64 6.2.6-76060206-generic\r\nModes:\r\n\r\n<details>\r\n<summary>System Info</summary>\r\n\r\n|Item|Value|\r\n|---|---|\r\n|CPUs|AMD Ryzen 7 5800U with Radeon Graphics (16 x 3547)|\r\n|GPU Status|2d_canvas: enabled<br>canvas_oop_rasterization: disabled_off<br>direct_rendering_display_compositor: disabled_off_ok<br>gpu_compositing: enabled<br>multiple_raster_threads: enabled_on<br>opengl: enabled_on<br>rasterization: enabled<br>raw_draw: disabled_off_ok<br>video_decode: enabled<br>video_encode: disabled_software<br>vulkan: disabled_off<br>webgl: enabled<br>webgl2: enabled<br>webgpu: disabled_off|\r\n|Load (avg)|2, 1, 1|\r\n|Memory (System)|13.49GB (1.87GB free)|\r\n|Process Argv|--unity-launch --crash-reporter-id f14012b5-d0f7-448a-910a-706fee85982f|\r\n|Screen Reader|no|\r\n|VM|0%|\r\n|DESKTOP_SESSION|pop|\r\n|XDG_CURRENT_DESKTOP|Unity|\r\n|XDG_SESSION_DESKTOP|pop|\r\n|XDG_SESSION_TYPE|x11|\r\n</details><details><summary>Extensions (46)</summary>\r\n\r\nExtension|Author (truncated)|Version\r\n---|---|---\r\njest-snippets|and|1.9.1\r\nvscode-zipfs|arc|3.0.0\r\nvscode-toggle-quotes|Bri|0.3.6\r\nvscode-eslint|dba|2.4.2\r\nes7-react-js-snippets|dsz|4.4.3\r\nprettier-vscode|esb|9.16.0\r\ncode-runner|for|0.12.0\r\nshell-format|fox|7.2.5\r\ngitlab-workflow|Git|3.68.0\r\neasy-snippet|inu|0.6.3\r\nplantuml|jeb|2.17.5\r\nbetter-shellscript-syntax|jef|1.6.1\r\nbash-ide-vscode|mad|1.37.0\r\ndirenv|mkh|0.14.0\r\nvscode-docker|ms-|1.25.1\r\nisort|ms-|2022.8.0\r\npython|ms-|2023.10.1\r\nvscode-pylance|ms-|2023.6.40\r\njupyter|ms-|2023.5.1101742258\r\njupyter-keymap|ms-|1.1.2\r\njupyter-renderers|ms-|1.0.15\r\nvscode-jupyter-cell-tags|ms-|0.1.8\r\nvscode-jupyter-slideshow|ms-|0.1.5\r\nremote-containers|ms-|0.295.0\r\nremote-ssh|ms-|0.102.0\r\nremote-ssh-edit|ms-|0.86.0\r\nremote-explorer|ms-|0.4.0\r\nsqltools|mtx|0.28.0\r\nvscode-jest|Ort|5.2.3\r\nvscode-versionlens|pfl|1.5.0\r\nbash-extension-pack|pin|2.0.0\r\nvscode-react-refactor|pla|1.1.3\r\nansible|red|2.4.78\r\nvscode-yaml|red|1.13.0\r\nvscode-gitweblinks|red|2.9.2\r\nbash-debug|rog|0.3.9\r\nshebang-snippets|rpi|0.1.4\r\njs-snippets|run|0.2.6\r\nrust-analyzer|rus|0.3.1566\r\nvscode-taskexplorer|spm|2.13.2\r\nshellcheck|tim|0.32.6\r\njinja|who|0.0.8\r\nchange-case|wma|1.0.0\r\nJavaScriptSnippets|xab|1.8.0\r\ncursor-align|yo1|1.1.0\r\nmarkdown-pdf|yza|1.4.4\r\n\r\n\r\n</details><details>\r\n<summary>A/B Experiments</summary>\r\n\r\n```\r\nvsliv368:30146709\r\nvsreu685:30147344\r\npython383:30185418\r\nvspor879:30202332\r\nvspor708:30202333\r\nvspor363:30204092\r\nvslsvsres303:30308271\r\nvserr242cf:30382550\r\npythontb:30283811\r\nvsjup518:30340749\r\npythonptprofiler:30281270\r\nvshan820:30294714\r\nvstes263:30335439\r\nvscod805:30301674\r\nbinariesv615:30325510\r\nbridge0708:30335490\r\nbridge0723:30353136\r\nvsaa593:30376534\r\npythonvs932:30410667\r\npy29gd2263:30776702\r\nvsclangdc:30486549\r\nc4g48928:30535728\r\ndsvsc012:30540252\r\npynewext54:30695312\r\nazure-dev_surveyone:30548225\r\nvscccc:30610679\r\n3biah626:30602489\r\npyind779:30671433\r\n89544117:30613380\r\npythonsymbol12:30671437\r\n2i9eh265:30646982\r\nshowlangstatbar:30737416\r\nvsctsb:30748421\r\npythonms35:30701012\r\n03d35959:30757346\r\n57b77579:30736110\r\npythonfmttext:30731395\r\npythoncmv:30756943\r\nfixshowwlkth:30771522\r\npythongtdpath:30769146\r\ni26e3531:30769768\r\ndh2dc718:30776458\r\npythonidxpt:30772539\r\npythondjangotscf:30772537\r\npythonnoceb:30776495\r\n\r\n```\r\n\r\n</details>\r\n\r\n<!-- generated by issue reporter -->"
    },
    "satisfaction_conditions": [
      "Type information is preserved when converting from named export to default export",
      "The refactoring operation produces syntactically valid TypeScript code",
      "The conversion is achievable through VS Code's refactoring tools"
    ],
    "created_at": "2023-06-29T15:00:14Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/30398",
    "source": {
      "issue_number": 30398
    },
    "initial_question": {
      "title": "Can't exponentiate BigInts",
      "body": "In normal JavaScript, this works `BigInt(2) ** BigInt(2)`\r\n\r\nBut writing the above in TypeScript, compiles to `Math.pow(BigInt(2), BigInt(2))`, which doesn't work.\r\n\r\nAccording to MDN:\r\n\r\n> [BigInt] cannot be used with methods in the built-in Math object\r\n\r\n---\r\n\r\nTypeScript code\r\n\r\n```ts\r\nBigInt(2) ** BigInt(2)\r\n```\r\n\r\n**Expected behavior:**\r\nReturn 4.\r\n\r\n**Actual behavior:**\r\n\r\n```\r\nTypeError: Cannot convert a BigInt value to a number\r\n    at Math.pow (<anonymous>)\r\n```"
    },
    "satisfaction_conditions": [
      "Code must compile and run when targeting appropriate ECMAScript versions"
    ],
    "created_at": "2019-03-14T15:50:10Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/30037",
    "source": {
      "issue_number": 30037
    },
    "initial_question": {
      "title": "Poor error messages for properties mis-handled as shorthand property declarations",
      "body": "```ts\r\ndeclare function foo(option: { abcd: number }): void;\r\n\r\nfoo({\r\n    abcd\r\n})\r\n```\r\n\r\n**Today**\r\n\r\n```\r\nCannot find name 'abcd'.\r\n```\r\n\r\n*Ideal**\r\n\r\n```\r\nThis shorthand property declaration is invalid because a local declaration could not be found for 'abcd'. Either declare one or provide an initializer.\r\n```"
    },
    "satisfaction_conditions": [
      "Error message must clearly indicate the shorthand property syntax issue",
      "Error message must suggest possible remediation steps",
      "Error message must integrate with TypeScript's diagnostic system",
      "Updated error message must pass existing TypeScript test suites",
      "Error message must identify the specific problematic property"
    ],
    "created_at": "2019-02-22T02:01:00Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/28086",
    "source": {
      "issue_number": 28086
    },
    "initial_question": {
      "title": "--downlevelIteration errors should mention using later targets",
      "body": "```js\r\n// @ts-check\r\nclass Foo {\r\n  constructor(...args) {}\r\n}\r\nfunction makeFoo() {\r\n  return new Foo(...arguments)\r\n}\r\n```\r\n\r\n**Actual**\r\n\r\n> Type 'IArguments' is not an array type. Use compiler option '--downlevelIteration' to allow iterating of iterators.\r\n\r\n**Expected**\r\n\r\n> Type 'IArguments' is not an array type. Either use the '--downlevelIteration' compiler option to allow iterating on iterators, or set the '--target' option to 'es2015' or above."
    },
    "satisfaction_conditions": [
      "Error message must maintain technical accuracy"
    ],
    "created_at": "2018-10-23T19:37:43Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/10699",
    "source": {
      "issue_number": 10699
    },
    "initial_question": {
      "title": "Fix PromiseConstructor interface",
      "body": "**TypeScript Version:**  master\n\n``` diff\ninterface PromiseConstructor {\n-    reject(reason: any): Promise<never>;\n-    reject<T>(reason: any): Promise<T>;\n+    reject(reason?: any): Promise<never>;\n}\n```\n"
    },
    "satisfaction_conditions": [
      "The reason parameter in Promise.reject must be optional",
      "Existing type casting functionality must be preserved",
      "Promise.reject must maintain assignability to any Promise<T>",
      "Type definitions must accurately reflect runtime behavior"
    ],
    "created_at": "2016-09-04T08:34:43Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/8742",
    "source": {
      "issue_number": 8742
    },
    "initial_question": {
      "title": "tsc truncates type errors longer than 100 chars with triple-dots",
      "body": "I'd like to see the entire error message.\n\nIn `tsc.js`:\n\n```\n        function typeToString(type, enclosingDeclaration, flags) {\n            var writer = ts.getSingleLineStringWriter();\n            getSymbolDisplayBuilder().buildTypeDisplay(type, writer, enclosingDeclaration, flags);\n            var result = writer.string();\n            ts.releaseStringWriter(writer);\n            var maxLength = compilerOptions.noErrorTruncation || flags & 4 ? undefined : 100;\n            if (maxLength && result.length >= maxLength) {\n                result = result.substr(0, maxLength - \"...\".length) + \"...\";\n            }\n            return result;\n        }\n```\n\nBut adding in `tsconfig.json`:\n\n```\n{\n  \"compilerOptions\": {\n    \"noErrorTruncation\": true\n  }\n}\n```\n\nhas no effect.\n\nIt seems that there's no other mention of that `noErrorTruncation` in the file -- I assume it's simply undefined (and I could also find no documentation about it).\n\nAdding to `ts.optionDeclarations` this entry:\n\n```\n        {\n            name: \"noErrorTruncation\",\n            type: \"boolean\"\n        },\n\n```\n\nmakes it work.\n"
    },
    "satisfaction_conditions": [
      "Full error message text is displayed without truncation",
      "Configuration option exists to control error message truncation",
      "Configuration persists across compiler invocations",
      "Long type definitions are completely visible when needed"
    ],
    "created_at": "2016-05-22T20:18:05Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/8101",
    "source": {
      "issue_number": 8101
    },
    "initial_question": {
      "title": "Function expression, which lacks return-type annotation, implicitly has an 'any' return type.",
      "body": "Hi there...\n\nI am using TS version 1.7.4...\n\nall of a sudden I started getting the error:\n\n> Error TS7011  Function expression, which lacks return-type annotation, implicitly has an 'any' return type.\n\nthe offending line of code is:\n\n`setTimeout(() => this.alertMessage = null, 2000);`\n\nnot sure why it suddenly started happening... I have been running this version for a while now... anyway... I don't understand why I am getting this error... the field \"alertMessage\" is defined as such:\n\n`alertMessage: string;`\n\nI guess I am wondering why the compiler is inferring \"any\" instead of \"string\"\n\nThank you\n"
    },
    "satisfaction_conditions": [
      "TypeScript compiler must not produce the TS7011 error for the setTimeout callback",
      "The setTimeout callback's type signature must be properly defined",
      "The assignment operation within setTimeout must maintain type compatibility"
    ],
    "created_at": "2016-04-14T20:22:26Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/4984",
    "source": {
      "issue_number": 4984
    },
    "initial_question": {
      "title": "Trailing whitespace is not removed by formatter on 'empty' lines",
      "body": "The following test fails:\n\n``` typescript\n/// <reference path='fourslash.ts' />\n\n////    /*1*/\n////    /*2*/\n\nformat.document();\nverify.currentFileContentIs(\"\\n\");\n```\n\n_(where the contents before marker 2 are a `\\t` character)_\n\nI notice trailing whitespace is not removed from comments; whilst I would argue trailing whitespace should be removed across the board, I think it should at least be removed from lines only containing whitespace. \n\nThoughts?\n"
    },
    "satisfaction_conditions": [
      "Formatter must preserve whitespace within comments",
      "Formatter must be able to distinguish between comment lines and empty lines"
    ],
    "created_at": "2015-09-26T09:59:52Z"
  },
  {
    "id": "https://github.com/microsoft/TypeScript/issues/1706",
    "source": {
      "issue_number": 1706
    },
    "initial_question": {
      "title": "Union Type inference not working in class (ts version 1.4)",
      "body": "Hi,\nUnion type inference is not working inside classes functions. For example trying to compile the below code : \n\n``` TypeScript\ntype NameOrNameArray = string | string[];\n\nclass NameCreator {\n\n    constructor(public name:NameOrNameArray) {}\n\n    createName():string {\n        if (typeof this.name === \"string\") {\n            return name;\n        }\n        else {\n            this.name.forEach((elem)=>{\n                console.log(elem);\n            });\n            return this.name.join(\" \");\n        }\n    }\n}\n```\n\ngives the error : \n\n```\nProperty 'forEach' does not exist on type 'string | string[]'.\n```\n\nThe same code works well when using a function. Same error in Visual studio and in the Playground.\n"
    },
    "satisfaction_conditions": [
      "Type narrowing must work correctly within class methods when checking union types",
      "Type safety must be maintained across method boundaries",
      "Type guard behavior must be predictable when accessing class properties",
      "Array operations must be accessible when type is narrowed to array type"
    ],
    "created_at": "2015-01-17T13:13:17Z"
  }
]