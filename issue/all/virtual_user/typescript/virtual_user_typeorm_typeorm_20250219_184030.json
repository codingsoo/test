[
  {
    "id": "https://github.com/typeorm/typeorm/issues/8548",
    "source": {
      "issue_number": 8548
    },
    "initial_question": {
      "title": "Preload function doesn't load soft-deleted entities",
      "body": "## Issue Description\r\nWhen i want to preload a soft deleted entity (entities with deleted_at field not null), it returns undefined.\r\nI'm using it to update my entity, so i have a condition in order to throw an error if the preloaded entity is empty.\r\n\r\n### Expected Behavior\r\nI expect that the preload function returns the entity even if the entity is soft deleted.\r\nOR\r\nAdd a parameter that allow us to load soft deleted entities\r\n\r\n### Actual Behavior\r\nThe preload function doesn't load the soft deleted entities  and then it returns undefined.\r\n\r\nMy code:\r\n```typescript\r\nconsole.log({ id });\r\nconst project = await queryRunner.manager.preload(Project, {\r\n        id,\r\n        ...projectDto,\r\n });\r\n\r\nconsole.log({ project });\r\nif (!project) {\r\n   throw new NotFoundException(`Project with id \"${id}\" not found`);\r\n}\r\n```\r\nThe logs:\r\n```\r\n{ id: '85c6d6c2-e279-4993-a0bb-53dafdaed5f2' }\r\n{ project: undefined }\r\nError: Project with id \"85c6d6c2-e279-4993-a0bb-53dafdaed5f2\" not found\r\n```\r\nMy entity (exported as json from my db):\r\n```json\r\n[\r\n\t{\r\n\t\t\"id\": \"85c6d6c2-e279-4993-a0bb-53dafdaed5f2\",\r\n\t\t\"name\": \"Oxygen\",\r\n\t\t\"created_at\": \"2022-01-20 09:10:04.531245+00\",\r\n\t\t\"created_by\": null,\r\n\t\t\"updated_at\": \"2022-01-20 09:10:04.531245+00\",\r\n\t\t\"updated_by\": null,\r\n\t\t\"deleted_at\": \"2022-01-20 09:10:04.53+00\",\r\n\t\t\"deleted_by\": null,\r\n\t\t...\r\n\t}\r\n]\r\n```\r\n\r\n### Steps to Reproduce\r\n1. Create an entity with deleted_at not null in your database\r\n2. Try to preload it\r\n\r\n### My Environment\r\n\r\n<!--\r\n  Please add any other relevant dependencies to this table at the end.\r\n  For example: Electron, React Native, or NestJS.\r\n-->\r\n\r\n| Dependency          | Version  |\r\n| ---                 | ---      |\r\n| Operating System    |  macOs 12.1\r\n| Node.js version     | 16.13.1 \r\n| Typescript version  | 4.5.4 \r\n| TypeORM version     | 0.2.41\r\n| @nestjs/typeorm     | 7.1.5\r\n\r\n### Relevant Database Driver(s)\r\n\r\n| DB Type              | Reproducible  |\r\n| ---                  | ---           |\r\n| `aurora-data-api`    | x            |\r\n| `aurora-data-api-pg` | x            |\r\n| `better-sqlite3`     | x            |\r\n| `cockroachdb`        | x            |\r\n| `cordova`            | x            |\r\n| `expo`               | x            |\r\n| `mongodb`            | x            |\r\n| `mysql`              | x            |\r\n| `nativescript`       | x            |\r\n| `oracle`             | x            |\r\n| `postgres`           | yes            |\r\n| `react-native`       | x            |\r\n| `sap`                | x            |\r\n| `sqlite`             | x            |\r\n| `sqlite-abstract`    | x            |\r\n| `sqljs`              | x            |\r\n| `sqlserver`          | x            |\r\n\r\n\r\n### Are you willing to resolve this issue by submitting a Pull Request?\r\n\r\n - \u2716\ufe0f Yes, I have the time, and I know how to start.\r\n - \u2705 Yes, I have the time, but I don't know how to start. I would need guidance.\r\n - \u2716\ufe0f No, I don\u2019t have the time, but I can support (using donations) development.\r\n - \u2716\ufe0f No, I don\u2019t have the time and I\u2019m okay to wait for the community / maintainers to resolve this issue.\r\n"
    },
    "satisfaction_conditions": [
      "Soft-deleted entities must be retrievable from the database",
      "Solution must work with TypeORM and PostgreSQL"
    ],
    "created_at": "2022-01-20T10:39:40Z"
  },
  {
    "id": "https://github.com/typeorm/typeorm/issues/6816",
    "source": {
      "issue_number": 6816
    },
    "initial_question": {
      "title": "fix: queryRunner.renameTable should not rename enums used by the table",
      "body": "**Issue type:**\r\n\r\n[x] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:** [x] `postgres`\r\n\r\n**TypeORM version:** `latest`\r\n\r\n### Description\r\n\r\nWhen a table is renamed via `queryRunner.renameTable` it will rename the enums used by the table. I think this should not be the case as an enum can be used by multiple tables and by prefixing it with the renamed table name will make it strange to use in the other tables. \r\n\r\n### Steps to reproduce or a small repository showing the problem\r\n\r\nAll 3 step should be added in a different transaction. First the enum needs to be created:\r\n\r\n```ts\r\nawait queryRunner.query(\r\n  `CREATE TYPE enum_resolution AS ENUM ('PT15M', 'PT60M', 'P1D', 'P1M', 'P3M', 'P1Y', 'seasonal', 'intraday')`\r\n);\r\n```\r\nThen create a table using the enum:\r\n```ts\r\nimport { MigrationInterface, QueryRunner, Table } from 'typeorm';\r\n\r\nexport class createTableHourlyTemperature1550570592750 implements MigrationInterface {\r\n  public async up(queryRunner: QueryRunner): Promise<any> {\r\n    await queryRunner.createTable(\r\n      new Table({\r\n        name: 'raw_data.hourly_temperature',\r\n        columns: [\r\n          {\r\n            name: 'resolution',\r\n            type: 'enum_resolution',\r\n          },\r\n        ],\r\n      })\r\n    );\r\n  }\r\n\r\n  public async down(queryRunner: QueryRunner): Promise<any> {\r\n    await queryRunner.dropTable('raw_data.hourly_temperature');\r\n  }\r\n}\r\n```\r\nThen rename the table via `queryRunner.renameTable`:\r\n```ts\r\nimport { MigrationInterface, QueryRunner } from 'typeorm';\r\n\r\nexport class renameHourlyTemperatureTableToTemperature1599484493349 implements MigrationInterface {\r\n  public async up(queryRunner: QueryRunner): Promise<void> {\r\n    await queryRunner.renameTable('raw_data.hourly_temperature', 'temperature');\r\n  }\r\n\r\n  public async down(queryRunner: QueryRunner): Promise<void> {\r\n    await queryRunner.renameTable('raw_data.temperature', 'hourly_temperature');\r\n  }\r\n}\r\n```\r\n\r\nObserve the generated queries: \r\n\r\n```\r\nquery: ALTER TABLE \"raw_data\".\"hourly_temperature\" RENAME TO \"temperature\"\r\nquery: ALTER TABLE \"raw_data\".\"temperature\" RENAME CONSTRAINT \"PK_b30b7b3b3657b819b781b5e95b8\" TO \"PK_7810603e74ca71d654ef434a078\"\r\nquery: ALTER TYPE \"public\".\"enum_resolution\" RENAME TO \"temperature_resolution_enum\"\r\nquery: ALTER TYPE \"public\".\"enum_temperature_source\" RENAME TO \"temperature_source_enum\"\r\nquery: INSERT INTO \"migrations\"(\"timestamp\", \"name\") VALUES ($1, $2) -- PARAMETERS: [1599484493349,\"renameHourlyTemperatureTableToTemperature1599484493349\"]\r\nquery: COMMIT\r\nquery: START TRANSACTION\r\n```"
    },
    "satisfaction_conditions": [
      "Enum types remain accessible to all tables that reference them after table rename operations",
      "Existing enum values and constraints remain valid after table operations"
    ],
    "created_at": "2020-09-30T14:16:21Z"
  },
  {
    "id": "https://github.com/typeorm/typeorm/issues/5470",
    "source": {
      "issue_number": 5470
    },
    "initial_question": {
      "title": "Question: How to continue  to next value ( aport ) if there a duplications error ",
      "body": "**Issue type:**\r\n\r\n[x] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[x] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[ ] `cockroachdb`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\nI'm scraping from multiple websites and I save the data on MySQL type database using nestJS and TypeOrm frameworks. \r\n\r\nI have a cron job that runs that scraper service every day checking for new data available and inserted into my SQL database, the problem I don't wanna duplication data so I did a unique column in my table, so any duplicated data not getting be saved.\r\n\r\nNow I got the `dup error` as I expected but I can't find a way to handle this error to just ignore that row and continue for the rest instead of stopping everything.\r\n\r\nThe code for saving the data: \r\n```typescriprt\r\nasync clonningFromScraper() {\r\n   //my scraper data ( array of objects )\r\n    let articles = await this.articlesScraper.articles('1'); \r\n\r\n    articles = articles.map( article => ({ ...article, key: decodeURIComponent(article.url).substring(0, 255) }));\r\n\r\n // saving the data into my database\r\n    return this.articleRepository\r\n        .save(articles);\r\n}\r\n```\r\n\r\n"
    },
    "satisfaction_conditions": [
      "Database operations continue after encountering duplicate entries",
      "Duplicate records are properly handled without errors stopping execution",
      "Original data integrity is maintained",
      "Batch processing capability is preserved",
      "Compatible with TypeORM and MySQL"
    ],
    "created_at": "2020-02-04T13:37:15Z"
  },
  {
    "id": "https://github.com/typeorm/typeorm/issues/5314",
    "source": {
      "issue_number": 5314
    },
    "initial_question": {
      "title": "getCount(). Perfs issues for multi columns primary key",
      "body": "**Issue type:**\r\n\r\n[X ] question\r\n\r\n**Database system/driver:**\r\n[X ] `postgres`\r\n\r\nVersion 0.2.18\r\n\r\nI'm facing a perf issue when running getCount()\r\nWhy when counting all records of a query, queryBuilder creates a SQL query that concatenates the columns that are part of the primary key ?\r\n\r\n**Typescript  :** \r\n```\r\nconst query: SelectQueryBuilder<TEntity> = dbConnection\r\n\t\t\t\t\t.getRepository<TEntity>(entity)\r\n\t\t\t\t\t.createQueryBuilder(entity.name)\r\n\t\t\t\t\t.where(`\"${entity.name}\".\"${id}\"= :val`, {\r\n\t\t\t\t\t\tval: value.toLowerCase(),\r\n\t\t\t\t\t});\r\n\r\n\t\t\t\tconst totalRecords: number = await query.getCount();\r\n```\r\n\r\n**generated sql**\r\n```\r\nSELECT COUNT(DISTINCT(\r\n\tCONCAT(\r\n\t\t\"u\".\"a\", \r\n\t\t\"u\".\"b\",\r\n\t\t\"u\".\"c\")\r\n\t)\r\n) as \"cnt\" FROM \"sc\".\"tbl\" \"u\"\r\n```\r\n\r\nThat is destroying the performances for a table of 140K records. \r\nCreating an index on CONCAT using is not efficient, hard to maintain with 100 of tables, knowing that for some tables, some primay comumns are timestamp...\r\n\r\nIs there a way or a parameter to set to avoid the concat and just running a kind of (`select count(1) FROM \"sc\".\"tbl\" \"u\"`) ?\r\n\r\nRgds\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    "satisfaction_conditions": [
      "Query performance must be significantly improved compared to original implementation",
      "Solution must work without requiring additional database indexes or schema changes",
      "Must maintain compatibility with existing TypeORM repository patterns"
    ],
    "created_at": "2020-01-10T14:42:25Z"
  },
  {
    "id": "https://github.com/typeorm/typeorm/issues/5274",
    "source": {
      "issue_number": 5274
    },
    "initial_question": {
      "title": "findOne({ someField: undefined }) vs findOne({ someField: null})",
      "body": "**Issue type:**\r\n\r\n[x] question\r\n[x] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[ ] `cockroachdb`\r\n[x] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nWhen calling findOne() on a table with a column that is marked as nullable, if you pass `undefined` for that column in the select condition, the query does find any entry. If you pass `null` instead of `undefined`, there there is a typing error (see below for the exact message)\r\n\r\nHere's a small example to reproduce the problem:\r\n\r\n```typescript\r\n@Entity()\r\nclass Person {\r\n\r\n    @PrimaryGeneratedColumn()\r\n    id!: number\r\n\r\n    @Column()\r\n    name!: string\r\n\r\n    @Column({ nullable: true })\r\n    age?: number\r\n}\r\n\r\n\r\n(async () => {\r\n\r\n    const connection = await createConnection({\r\n        type: \"sqlite\",\r\n        database: \":memory:\",\r\n        synchronize: true,\r\n        logging: true,\r\n        entities: [Person]\r\n    })\r\n\r\n    const repo = connection.getRepository(Person)\r\n    const name = \"John\"\r\n\r\n    await repo.save(repo.create({ name }))\r\n\r\n    const result = [\r\n        await repo.findOne({ name, }),  // (1) works OK\r\n        await repo.findOne({ name, age: undefined }), // (2) returns undefined\r\n        await repo.findOne({ name, age: null }), // (3) does not compile, typing error\r\n    ]\r\n\r\n    console.log(result)\r\n})()\r\n```\r\nWhen you try and run this with ts-node, this you get typing error on (3):\r\n\r\n```\r\n    return new TSError(diagnosticText, diagnosticCodes)\r\n           ^\r\nTSError: \u2a2f Unable to compile TypeScript:\r\nsource/backend/index.ts:92:15 - error TS2769: No overload matches this call.\r\n  Overload 1 of 3, '(id?: string | number | Date | ObjectID | undefined, options?: FindOneOptions<Person> \r\n| undefined): Promise<Person | undefined>', gave the following error.\r\n    Argument of type '{ name: string; age: null; }' is not assignable to parameter of type 'string | number | Date | ObjectID | undefined'.\r\n      Object literal may only specify known properties, and 'name' does not exist in type 'Date | ObjectID'.\r\n  Overload 2 of 3, '(options?: FindOneOptions<Person> | undefined): Promise<Person | undefined>', gave the following error.\r\n    Argument of type '{ name: string; age: null; }' is not assignable to parameter of type 'FindOneOptions<Person>'.\r\n      Object literal may only specify known properties, and 'name' does not exist in type 'FindOneOptions<Person>'.\r\n  Overload 3 of 3, '(conditions?: FindConditions<Person> | undefined, options?: FindOneOptions<Person> | undefined): Promise<Person | undefined>', gave the following error.\r\n    Argument of type '{ name: string; age: null; }' is not assignable to parameter of type 'FindConditions<Person>'.\r\n      Types of property 'age' are incompatible.\r\n        Type 'null' is not assignable to type 'number | FindOperator<number | undefined> | undefined'.    \r\n\r\n92         await repo.findOne({ name, age: null }),\r\n                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n\r\n\r\n    at createTSError (C:\\Code\\mixarr\\node_modules\\ts-node\\src\\index.ts:293:12)\r\n    at reportTSError (C:\\Code\\mixarr\\node_modules\\ts-node\\src\\index.ts:297:19)\r\n    at getOutput (C:\\Code\\mixarr\\node_modules\\ts-node\\src\\index.ts:399:34)\r\n    at Object.compile (C:\\Code\\mixarr\\node_modules\\ts-node\\src\\index.ts:457:32)\r\n    at Module.m._compile (C:\\Code\\mixarr\\node_modules\\ts-node\\src\\index.ts:536:43)\r\n    at Module._extensions..js (internal/modules/cjs/loader.js:995:10)\r\n    at Object.require.extensions.<computed> [as .ts] (C:\\Code\\mixarr\\node_modules\\ts-node\\src\\index.ts:539:12)\r\n    at Module.load (internal/modules/cjs/loader.js:815:32)\r\n    at Function.Module._load (internal/modules/cjs/loader.js:727:14)\r\n    at Function.Module.runMain (internal/modules/cjs/loader.js:1047:10)\r\nerror Command failed with exit code 1.\r\n```\r\n\r\nIf you comment out (3), here's the output:\r\n\r\n```\r\nquery: BEGIN TRANSACTION\r\nquery: SELECT * FROM \"sqlite_master\" WHERE \"type\" = 'table' AND \"name\" IN ('person')\r\nquery: SELECT * FROM \"sqlite_master\" WHERE \"type\" = 'index' AND \"tbl_name\" IN ('person')\r\nquery: SELECT * FROM \"sqlite_master\" WHERE \"type\" = 'table' AND \"name\" = 'typeorm_metadata'\r\nquery: CREATE TABLE \"person\" (\"id\" integer PRIMARY KEY AUTOINCREMENT NOT NULL, \"name\" varchar NOT NULL, \"age\" integer)\r\nquery: COMMIT\r\nquery: BEGIN TRANSACTION\r\nquery: INSERT INTO \"person\"(\"id\", \"name\", \"age\") VALUES (NULL, ?, NULL) -- PARAMETERS: [\"John\"]\r\nquery: COMMIT\r\n\r\n// Here are the generated query\r\nquery: SELECT \"Person\".\"id\" AS \"Person_id\", \"Person\".\"name\" AS \"Person_name\", \"Person\".\"age\" AS \"Person_age\" FROM \"person\" \"Person\" WHERE \"Person\".\"name\" = ? LIMIT 1 -- PARAMETERS: [\"John\"]\r\nquery: SELECT \"Person\".\"id\" AS \"Person_id\", \"Person\".\"name\" AS \"Person_name\", \"Person\".\"age\" AS \"Person_age\" FROM \"person\" \"Person\" WHERE \"Person\".\"name\" = ? AND \"Person\".\"age\" = ? LIMIT 1 -- PARAMETERS: [\"John\",null]\r\n\r\n// Here's the result (1) works, and (2) is undefined\r\n[ Person { id: 1, name: 'John', age: null }, undefined ]\r\n```\r\nSo given a `name`and an `age` (potentially `undefined`), I don't know how to find a match properly:\r\n- if I call `findOne({name,age})` i get `undefined`\r\n- if I call `findOne({name, age: age || null}` i get an error.\r\n\r\nI would expect `findOne({name,age})` to return the match in this case.\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    "satisfaction_conditions": [
      "Query must successfully find records when searching with undefined/null nullable fields",
      "TypeScript compilation must succeed without type errors",
      "Solution must work within TypeORM's type system and query builder"
    ],
    "created_at": "2020-01-01T21:45:47Z"
  },
  {
    "id": "https://github.com/typeorm/typeorm/issues/4718",
    "source": {
      "issue_number": 4718
    },
    "initial_question": {
      "title": "TypeORM tries to drop views that are needed by the pg_stat_statements extension",
      "body": "**Issue type:**\r\n\r\n[x] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[x] `postgres`\r\n[ ] `cockroachdb`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\n1. Enable extension pg_stat_statments\r\n2. Start your application with the synchronize option set to true\r\n\r\nThe error that is caused:\r\n\r\n`QueryFailedError: cannot drop view pg_stat_statements because extension pg_stat_statements requires it`\r\n\r\nWhy is TypeORM trying to drop a view that is needed by the extension? Is TypeORM not compatible with pg_stat_statements?\r\n\r\n<!--\r\n    To answer those questions you need to put \"x\" inside the square brackets, for example:\r\n    [x] `mysql`\r\n    [ ] `postgres`\r\n\r\n    Also, please format your code properly (by taking code blocks into ```ts .... ```)\r\n!>\r\n"
    },
    "satisfaction_conditions": [
      "TypeORM must not interfere with pg_stat_statements extension functionality",
      "Database objects required by PostgreSQL extensions must be preserved during synchronization",
      "Solution must provide a way to exclude specific database objects from TypeORM's synchronization"
    ],
    "created_at": "2019-09-10T08:49:04Z"
  },
  {
    "id": "https://github.com/typeorm/typeorm/issues/4216",
    "source": {
      "issue_number": 4216
    },
    "initial_question": {
      "title": "How do you get mongodb buildConnectionUrl from TypeORM Connection",
      "body": "**Issue type:**\r\n\r\n[x] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[x] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[ ] `cockroachdb`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nIs there any way to get mongodb MongoClient instance or mongodb connection url from below connection.\r\n```typescript\r\nconst connection = await createConnection(connectionOptions);\r\n```\r\n"
    },
    "satisfaction_conditions": [
      "Access to the MongoDB connection/client instance is obtained from the TypeORM connection object",
      "The obtained MongoDB connection allows database operations",
      "The solution works with TypeORM's MongoDB driver",
      "The connection instance provides access to the actual connected database"
    ],
    "created_at": "2019-05-31T05:33:35Z"
  },
  {
    "id": "https://github.com/typeorm/typeorm/issues/4200",
    "source": {
      "issue_number": 4200
    },
    "initial_question": {
      "title": "Multiple unique keys when using one to one",
      "body": "**Issue type:**\r\n\r\n[ ] question\r\n[x] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[x] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[ ] `cockroachdb`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[ ] `latest`\r\n[ ] `@next`\r\n[x] `0.2.17` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nHi guys, I'm trying to have unique keys with foreign key associated with one of them but I think typeorm is creating different unique keys.\r\n\r\nHere is my model file:\r\n\r\n```ts\r\nimport {\r\n  Column,\r\n  Entity,\r\n  JoinColumn,\r\n  OneToOne,\r\n  PrimaryGeneratedColumn,\r\n  Unique,\r\n} from 'typeorm';\r\n\r\nimport { BotModel } from './bot.model';\r\n\r\n@Entity('intent')\r\n@Unique(['botId', 'name'])\r\nexport class IntentModel {\r\n  @PrimaryGeneratedColumn('uuid')\r\n  intentId: string;\r\n\r\n  @Column()\r\n  botId: string;\r\n\r\n  @OneToOne(() => BotModel, { cascade: true })\r\n  @JoinColumn({\r\n    name: 'botId',\r\n    referencedColumnName: 'botId',\r\n  })\r\n  bot: BotModel;\r\n\r\n  @Column({ length: 16 })\r\n  name: string;\r\n\r\n  @Column({\r\n    length: 128,\r\n    nullable: true,\r\n  })\r\n  description: string;\r\n}\r\n```\r\n\r\nMy `create table intent` from mysql:\r\n\r\n```mysql\r\nCREATE TABLE `intent` (\r\n  `intentId` varchar(36) NOT NULL,\r\n  `botId` varchar(255) NOT NULL,\r\n  `name` varchar(16) NOT NULL,\r\n  `description` varchar(128) DEFAULT NULL,\r\n  PRIMARY KEY (`intentId`),\r\n  UNIQUE KEY `REL_94de4914fe0a743917de52fe8e` (`botId`),\r\n  UNIQUE KEY `IDX_94de4914fe0a743917de52fe8e` (`botId`),\r\n  UNIQUE KEY `IDX_78750387b2c61fb51adb75b5ab` (`botId`,`name`),\r\n  CONSTRAINT `FK_94de4914fe0a743917de52fe8e7` FOREIGN KEY (`botId`) REFERENCES `bot` (`botId`) ON DELETE NO ACTION ON UPDATE NO ACTION\r\n) ENGINE=InnoDB DEFAULT CHARSET=latin1\r\n```\r\n\r\nWhen I try to insert different name with id(already inserted) I'm getting this:\r\n```mysql\r\nER_DUP_ENTRY: Duplicate entry '0b387f8b-d330-4b39-93d2-5637f11001b7' for key 'REL_94de4914fe0a743917de52fe8e'\r\n```\r\n\r\nI tried in different ways but no success."
    },
    "satisfaction_conditions": [
      "Composite uniqueness of botId+name must be preserved",
      "Foreign key relationship between intent and bot tables must be maintained"
    ],
    "created_at": "2019-05-27T15:45:43Z"
  },
  {
    "id": "https://github.com/typeorm/typeorm/issues/4197",
    "source": {
      "issue_number": 4197
    },
    "initial_question": {
      "title": "Many to Many relation not using jointable when updating entity",
      "body": "**Issue type:**\r\n\r\n[ ] question\r\n[x] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[x] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[ ] `cockroachdb`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest` (`^0.2.17`)\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nWhen I try to add a group to a user and update the user entity, the update query results in a an error (`ER_BAD_FIELD_ERROR`). \r\n\r\nTypeorm tries to set the user id, which should go into the join table, to the user table itself. The code should explain the problem a little bit better.\r\n\r\n**TinyUser.ts**\r\n```javascript\r\nimport {Entity, JoinTable, ManyToMany, PrimaryGeneratedColumn} from \"typeorm\";\r\nimport {TinyGroup} from \"./TinyGroup\";\r\n\r\n@Entity()\r\nexport class TinyUser {\r\n    /**\r\n     * Contains the unique number for the Page\r\n     *\r\n     * @name id\r\n     * @type number\r\n     */\r\n    @PrimaryGeneratedColumn()\r\n    id: number = 0;\r\n\r\n    /**\r\n     * Contains the user groups\r\n     *\r\n     * @name groups\r\n     * @type TinyGroup[]\r\n     */\r\n    @ManyToMany(() => TinyGroup)\r\n    @JoinTable({\r\n        name: 'tiny_user_groups',\r\n        joinColumn: {referencedColumnName: 'id', name: 'user_id'},\r\n        inverseJoinColumn: {referencedColumnName: 'id', name: 'group_id'}\r\n    })\r\n    groups?: TinyGroup[];\r\n}\r\n```\r\n\r\n**TinyGroup.ts**\r\n```javascript\r\nimport {Entity, JoinTable, ManyToMany, PrimaryGeneratedColumn} from \"typeorm\";\r\nimport {TinyUser} from \"./TinyUser\";\r\n\r\n@Entity()\r\nexport class TinyGroup\r\n{\r\n    /**\r\n     * Contains the unique number for the Page\r\n     *\r\n     * @name id\r\n     * @type number\r\n     */\r\n    @PrimaryGeneratedColumn()\r\n    id: number = 0;\r\n\r\n    /**\r\n     * Contains the user groups\r\n     *\r\n     * @name users\r\n     * @type TinyUser[]\r\n     */\r\n    @ManyToMany(() => TinyUser)\r\n    @JoinTable({\r\n        name: 'tiny_user_groups',\r\n        joinColumn: {referencedColumnName: 'id', name: 'group_id'},\r\n        inverseJoinColumn: {referencedColumnName: 'id', name: 'user_id'}\r\n    })\r\n    users?: TinyUser[];\r\n}\r\n```\r\n\r\n**App.ts**\r\n```javascript\r\nimport {ConnectionOptions, createConnection} from \"typeorm\";\r\nimport {TinyUser} from \"./Models/TinyUser\";\r\nimport {TinyGroup} from \"./Models/TinyGroup\";\r\nimport {MysqlConnectionOptions} from \"typeorm/driver/mysql/MysqlConnectionOptions\";\r\n\r\n(async function ()\r\n{\r\n    const config: MysqlConnectionOptions = {\r\n        \"type\": \"mysql\",\r\n        \"host\": \"localhost\",\r\n        \"port\": 3306,\r\n        \"username\": \"root\",\r\n        \"password\": \"root\",\r\n        \"database\": \"test\",\r\n        \"synchronize\": true\r\n        , entities: [__dirname + '/Models/*.js']\r\n    };\r\n\r\n    const connection = await createConnection(config);\r\n\r\n    const gr = connection.getRepository(TinyGroup);\r\n    const ur = connection.getRepository(TinyUser);\r\n\r\n    const u: TinyUser = new TinyUser();\r\n    const g: TinyGroup = new TinyGroup();\r\n\r\n    await ur.save(u);\r\n    await gr.save(g);\r\n\r\n    u.groups = [g];\r\n\r\n    try {\r\n        await ur.update(u, {id: 1});\r\n    } catch(e) {\r\n        console.error(e);\r\n    }\r\n})();\r\n```\r\n\r\nThis code results in an `ER_BAD_FIELD_ERROR: Unknown column 'user_id' in 'field list'` error.\r\n\r\nMy expectation would be a query like this:\r\n```SQL\r\nINSERT INTO `tiny_user_groups` SET `user_id` = ?, `group_id` = ?\r\n```\r\n\r\nThe generated query however is the following:\r\n```SQL\r\nUPDATE `tiny_user` SET `id` = 1, `user_id` = NULL WHERE `id` = 1\r\n```\r\n"
    },
    "satisfaction_conditions": [
      "Many-to-many relationship data is correctly persisted in the join table",
      "ORM operations preserve relationship mappings",
      "Database schema integrity is maintained",
      "Entity updates properly handle related entities"
    ],
    "created_at": "2019-05-26T21:22:32Z"
  },
  {
    "id": "https://github.com/typeorm/typeorm/issues/3731",
    "source": {
      "issue_number": 3731
    },
    "initial_question": {
      "title": "Question: How to keep all relations when only filtering by one of them",
      "body": "**Issue type:**\r\n\r\n[X] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[X] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[X] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nI have a User table and  a Category table, the relation is many-to-many,\r\n\r\nI want to select all users who are under a specific category.\r\n\r\n```ts\r\n    users = await userRepository\r\n      .createQueryBuilder('user')\r\n      .leftJoinAndSelect('user.categories', 'category')\r\n      .where('category.categoryId = :id', { id: catId})\r\n      .orderBy('user.age', 'DESC', 'NULLS LAST')\r\n      .getMany();\r\n```\r\n\r\nIt filters correct users, but under each user, only the requested category Id is kept. But I want to keep all the categories under each user. I did not find a similar question for this and did not find a solution in the docs.\r\n\r\ni.e.\r\n\r\n```ts\r\nusers = [\r\n{ id = 1, categories: [ cat1, cat2, cat3...] },\r\n{ id = 2, categories: [ cat1, cat2, cat3...] }\r\n...\r\n]\r\n```\r\n\r\nnot \r\n\r\n```ts\r\nusers = [\r\n{ id = 1, categories: [cat2] },\r\n{ id = 2, categories: [cat2] }\r\n...\r\n]\r\n```\r\n\r\nMy current solution is using findByIds with relations, passing in all the userIds got from the previous step,  I can get what I want but I don't think it is optimal.\r\n\r\nDoes anyone know how to handle such query?\r\n\r\nThanks a lot.\r\n\r\n"
    },
    "satisfaction_conditions": [
      "Query returns users who belong to the specified category",
      "Results maintain correct ordering by user age (descending with nulls last)"
    ],
    "created_at": "2019-02-28T10:42:23Z"
  },
  {
    "id": "https://github.com/typeorm/typeorm/issues/3628",
    "source": {
      "issue_number": 3628
    },
    "initial_question": {
      "title": "Order by a computed field/column in createQueryBuilder",
      "body": "**Issue type:**\r\n\r\n[x] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[x] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\nHi guys,\r\n\r\nI need to order my results by a computed field with `createQueryBuilder`.\r\n\r\nIn the docs, I see that `.orderBy` wants a column as a paramenter, but I cannot compute a column (in this case a boolean colum) with `createQueryBuilder`.\r\n\r\nConsider this simple entity:\r\n```ts\r\nclass Store {\r\n    @Column({ type: 'time' })\r\n    from: string;\r\n    \r\n    @Column({ type: 'time' })\r\n    to: string;\r\n\r\n}\r\n```\r\n\r\nNow, i want to retrieve all products from stores and sort them in order to show first all the products available in that moment (so the store has to be open) and after all the products that are not available.\r\n\r\nThis is the raw sql query to find all stores and order them based on the availability at a specific time:\r\n\r\n```sql\r\nSELECT *, (:time BETWEEN stores.from AND stores.to) as is_open\r\nFROM stores\r\nORDER BY is_open DESC\r\n```\r\n\r\nIs it possible to do this without `getRawMany`?\r\n"
    },
    "satisfaction_conditions": [
      "Query results must be ordered by a computed boolean value based on time conditions",
      "Query must return proper entity objects, not raw results",
      "Query must support complex time-based calculations involving multiple related entities",
      "Query must maintain compatibility with TypeORM's entity management"
    ],
    "created_at": "2019-02-12T16:53:30Z"
  },
  {
    "id": "https://github.com/typeorm/typeorm/issues/3614",
    "source": {
      "issue_number": 3614
    },
    "initial_question": {
      "title": "Update Date column from SQL",
      "body": "**Issue type:**\r\n\r\n[x] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[x] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n---\r\n\r\nIs there a way to update `Date` column from SQL. Something like\r\n\r\n```\r\n        await connection\r\n            .createQueryBuilder()\r\n            .update(Session)\r\n            .set({ ip_address: ip, last_login: 'CURRENT_TIMESTAMP'})\r\n            .where('session.user_id = :id', { id: userId })\r\n            .execute()\r\n```\r\n\r\n\r\n`UpdateDateColumn` does not work for me because I need to update the column only in some save actions whereas `UpdateDateColumn` gets triggered in all save actions"
    },
    "satisfaction_conditions": [
      "Date column updates with current timestamp only on specific update operations"
    ],
    "created_at": "2019-02-10T15:19:31Z"
  },
  {
    "id": "https://github.com/typeorm/typeorm/issues/3444",
    "source": {
      "issue_number": 3444
    },
    "initial_question": {
      "title": "Hydration of Embedded (json) types into proper class instances",
      "body": "**Issue type:**\r\n\r\n[x] question\r\n\r\n**Database system/driver:**\r\n\r\n[x] `postgres`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n\r\nWhen working with JSON fields, we end up embedding a lot of objects that aren't just data blobs (but have utility methods attached to them too).\r\n\r\nOne (rather simple) example:\r\n\r\n```\r\n@Entity(\"Tenants\")\r\nexport class Tenant extends Schema {\r\n    @Column(\"varchar\", { length: 64 })\r\n    public slug: string;\r\n\r\n    @Column(\"uuid\")\r\n    public addressId: string;\r\n\r\n    @Column(\"jsonb\", {\r\n        transformer: {\r\n            to: value => value,\r\n            from: value => plainToClass(Organization, value)\r\n        }\r\n    })\r\n    public organization: Organization;\r\n}\r\n```\r\n\r\nWhile the Organization class looks like this\r\n```\r\nexport class Organization {\r\n    public legalName: string;\r\n\r\n    public test(): string {\r\n        return \"test\";\r\n    }\r\n}\r\n```\r\n\r\nThe goal is to be able to do `const tenant = await repo.findOne(someId); tenant.organization.test()` (effectively).\r\n\r\nI tried this:\r\n\r\n```\r\n    @Column(type => Organization)\r\n    public organization: Organization;\r\n```\r\n\r\nBut as the docs state, this isn't what I want (pulls in the fields from Org into the base Tenant class). \r\n\r\nMy query is, is using the transformer the proper way to get the right instance, or does TypeORM have something built in that can assist with this?\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    "satisfaction_conditions": [
      "JSON field data must be accessible as class instances with working methods",
      "Transformation must occur automatically during database retrieval",
      "Entity structure must maintain separate table schema"
    ],
    "created_at": "2019-01-18T00:40:21Z"
  },
  {
    "id": "https://github.com/typeorm/typeorm/issues/3339",
    "source": {
      "issue_number": 3339
    },
    "initial_question": {
      "title": "Unable to run an update using getMongoRepository",
      "body": "**Issue type:**\r\n\r\n[x] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[x] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[ ] `latest`\r\n[ ] `@next`\r\n[x] `0.2.10` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nThe current model looks like this.\r\n\r\n```typescript\r\n\r\nimport { Answer } from \"./Answer\";\r\n\r\n@Entity({ database: DATABASE_MONGO_NAME })\r\n\r\nexport class StudentRecord {\r\n  @ObjectIdColumn()\r\n  _id: ObjectID;\r\n\r\n /* many more columns */\r\n\r\n  @Column()\r\n  answers: Answer[];\r\n\r\n}\r\n\r\n```\r\n\r\nThe `Answer` collection model looks like this\r\n\r\n```typescript\r\n@Entity({ database: DATABASE_MONGO_NAME })\r\n\r\nexport class Answer {\r\n  @ObjectIdColumn()\r\n  _id: ObjectID;\r\n\r\n /* many more columns */\r\n\r\n  @ObjectIdColumn()\r\n  mongo_id_question: ObjectID;\r\n\r\n  @Column()\r\n  selected: string[];\r\n}\r\n\r\n```\r\nSo essentially the data stored in a document looks like this \r\n\r\n```json\r\n{\r\n    \"_id\": {\r\n        \"$oid\": \"5c1e60352f73e9000494e33f\"\r\n    },\r\n    \"answers\": [\r\n        {\r\n            \"_id\": {\r\n                \"$oid\": \"5c0e507f0da2560004c9003e\"\r\n            },\r\n            \"mongo_id_question\": {\r\n                \"$oid\": \"5c0e507f0da2560004c9003e\"\r\n            },\r\n            \"selected\": [\r\n                \"5c0e507f0da2560004c9003b\"\r\n            ]\r\n        }\r\n    ]\r\n}\r\n```\r\n\r\nThe query I am trying to run, sets the `updatedAt` column for an object with a given `mongo_id_question` in the `answers` list based on a given `record_id` \r\n\r\n```typescript\r\nStudentRecordsRepository.update(\r\n      {\r\n        _id: new ObjectID(record_id),\r\n        \"answers.mongo_id_question\": new ObjectID(\"5c0e507f0da2560004c9003e\"),\r\n      },\r\n      { $set: { \"answers.$.updatedAt\": new Date() } },\r\n    );\r\n```\r\nI get the following error in `typescript`\r\n\r\n```typescript\r\nerror TS2345: Argument of type '{ _id: ObjectID; \"answers.mongo_id_question\": ObjectID; }' is not assignable to parameter of type 'string | number | Date | ObjectID | FindConditions<StudentRecord> | string[] | number[] | Date[] | ObjectID[]'.\r\n  Object literal may only specify known properties, and '\"answers.mongo_id_question\"' does not exist in type 'string | number | Date | ObjectID | FindConditions<StudentRecord> | string[] | number[] | Date[] | ObjectID[]'\r\n```\r\n"
    },
    "satisfaction_conditions": [
      "Query correctly identifies both the parent document and the specific array element"
    ],
    "created_at": "2018-12-28T06:49:57Z"
  },
  {
    "id": "https://github.com/typeorm/typeorm/issues/3281",
    "source": {
      "issue_number": 3281
    },
    "initial_question": {
      "title": "Relation entity does not load on findOne",
      "body": "**Issue type:**\r\n[X] bug report\r\n\r\n**Database system/driver:**\r\n[X] `mysql` / `mariadb`\r\n\r\n**TypeORM version:**\r\n[X] `@next`\r\n\r\nOn 2.9.0, with findOne repository method, we can load association with FindOptions **relations**  \r\nSo that code line will return Entity and its association\r\n`await connection.getRepository(Entity).findOne({id: 12}, {relations: ['association']});`\r\n\r\nThe same call **does not work** on on @next branch 3.0.0-alpha22\r\nIt return the entity WITHOUT the association. The only way it works is to give as it first parameter directly the id number. So we can't use query :(\r\n\r\n\r\n\r\n"
    },
    "satisfaction_conditions": [
      "Entity associations must load correctly when using findOne method",
      "Query parameters must be properly structured to work with TypeORM 3.0",
      "Backward compatibility concerns must be addressed"
    ],
    "created_at": "2018-12-18T22:06:16Z"
  },
  {
    "id": "https://github.com/typeorm/typeorm/issues/3274",
    "source": {
      "issue_number": 3274
    },
    "initial_question": {
      "title": "Fail to detect PK existing constraint name on migration:generate",
      "body": "**Issue type:**\r\n\r\n[x] bug report\r\n\r\n**Database system/driver:**\r\n\r\n[x] `postgres`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nI have a psql table created with the following queries:\r\n\r\n```sql\r\nCREATE TABLE users (\r\n    id uuid DEFAULT gen_random_uuid() PRIMARY KEY,\r\n    first_name character varying(50) NOT NULL,\r\n    last_name character varying(50) NOT NULL,\r\n    email character varying(255) NOT NULL UNIQUE,\r\n    password character varying(60) NOT NULL,\r\n    created_at timestamp with time zone DEFAULT now(),\r\n    updated_at timestamp with time zone DEFAULT now()\r\n);\r\n\r\nCREATE UNIQUE INDEX users_pkey ON users(id uuid_ops);\r\nCREATE UNIQUE INDEX users_email_key ON users(email text_ops);\r\n```\r\n\r\nI've created entity that matches the table but right now I want to change type of the `id` field. Everything ok, so far. Now I run command: `typeorm migration:generate -n Init` which creates migration file but it fails to properly detect constraint name. It does not see the ID field with the constraint named as `users_pkey` but instead it just uses random hash. So, the migration query looks like follows:\r\n\r\n```sql\r\nALTER TABLE \"users\" DROP CONSTRAINT \"PK_a3ffb1c0c8416b9fc6f907b7433\"\r\nALTER TABLE \"users\" DROP COLUMN \"id\"\r\nALTER TABLE \"users\" ADD \"id\" BIGSERIAL NOT NULL\r\nALTER TABLE \"users\" ADD CONSTRAINT \"PK_a3ffb1c0c8416b9fc6f907b7433\" PRIMARY KEY (\"id\")\r\n```\r\n\r\nand it should look like this:\r\n\r\n```sql\r\nALTER TABLE \"users\" DROP CONSTRAINT \"users_pkey\"\r\nALTER TABLE \"users\" DROP COLUMN \"id\"\r\nALTER TABLE \"users\" ADD \"id\" BIGSERIAL NOT NULL\r\nALTER TABLE \"users\" ADD CONSTRAINT \"PK_a3ffb1c0c8416b9fc6f907b7433\" PRIMARY KEY (\"id\")\r\n```\r\n\r\nI was trying to provide my own constraint name that would match the old one but it doesn't look like possible for the primary key. Do you know about this bug?"
    },
    "satisfaction_conditions": [
      "Generated migrations must maintain database functionality after execution",
      "Schema synchronization must remain consistent across migrations"
    ],
    "created_at": "2018-12-17T19:17:36Z"
  },
  {
    "id": "https://github.com/typeorm/typeorm/issues/3272",
    "source": {
      "issue_number": 3272
    },
    "initial_question": {
      "title": "How to get changes/diff inside model hooks",
      "body": "**Issue type:**\r\n\r\n[x] question\r\n[ ] bug report\r\n[ ] feature request\r\n[x] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[x] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)z\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nI can't find in the documentation a way to get \"changes\" inside Listeners and/or Subscribers ?\r\n\r\nThe behaviour I'm lookig for is something like this :\r\n```\r\n@Entity()\r\nexport class User extends BaseEntity {\r\n  @BeforeUpdate()\r\n  doSomething(changes: Partial<User>) {\r\n    if (this.field != changes.field) {\r\n      // Then do your thing\r\n    }\r\n  }\r\n}\r\n```"
    },
    "satisfaction_conditions": [
      "Access to both current and pending entity state must be available",
      "Change detection must be possible before updates are committed",
      "Entity field comparisons must be supported",
      "Integration with TypeORM's entity lifecycle system"
    ],
    "created_at": "2018-12-17T17:26:02Z"
  },
  {
    "id": "https://github.com/typeorm/typeorm/issues/3250",
    "source": {
      "issue_number": 3250
    },
    "initial_question": {
      "title": "[psql] Creating migration for already existing table",
      "body": "**Issue type:**\r\n\r\n[x] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[x] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\nI'm trying to create migration that would work with already existing database. I have a table which has two fields:\r\n\r\n```\r\nid BIGSERIAL PRIMARY KEY,\r\norg_id BIGSERIAL UNIQUE,\r\n```\r\n\r\nand in the TS class I have fields defined in the following way:\r\n\r\n```ts\r\n@PrimaryGeneratedColumn()\r\nreadonly id: number;\r\n\r\n@Column(\"bigint\", { name: \"org_id\", unique: true })\r\norgId: number;\r\n```\r\n\r\nand it keeps creating migrations for those two fields. Is there a way to define those two fields that would not create migration?"
    },
    "satisfaction_conditions": [
      "Entity fields map to existing database columns without generating new migrations",
      "Primary key configuration preserves BIGSERIAL type compatibility",
      "Unique constraint on org_id is preserved",
      "Column naming convention is maintained"
    ],
    "created_at": "2018-12-14T00:15:16Z"
  },
  {
    "id": "https://github.com/typeorm/typeorm/issues/3237",
    "source": {
      "issue_number": 3237
    },
    "initial_question": {
      "title": "Still can't get the update result.raw?",
      "body": "**Issue type:**\r\n\r\n[ x] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ x] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[ ] `latest`\r\n[ x] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\n<!--\r\n    To answer those questions you need to put \"x\" inside the square brackets, for example:\r\n    [x] `mysql`\r\n    [ ] `postgres`\r\n\r\n    Also, please format your code properly (by taking code blocks into ```ts .... ```)\r\n!>\r\n\r\nUpdateResult {\r\n  generatedMaps: [],\r\n  raw:\r\n   OkPacket {\r\n     fieldCount: 0,\r\n     affectedRows: 1,\r\n     insertId: 0,\r\n     serverStatus: 2,\r\n     warningCount: 0,\r\n     message: '(Rows matched: 1  Changed: 0  Warnings: 0',\r\n     protocol41: true,\r\n     changedRows: 0 }\r\n}\r\n"
    },
    "satisfaction_conditions": [
      "Query results must provide information about affected records",
      "Operation must return detailed update metadata",
      "Operation must maintain compatibility with MySQL/MariaDB"
    ],
    "created_at": "2018-12-13T03:51:32Z"
  },
  {
    "id": "https://github.com/typeorm/typeorm/issues/3219",
    "source": {
      "issue_number": 3219
    },
    "initial_question": {
      "title": "current URL string parser is deprecated, and will be removed in a future version. To use the new parser, pass option { useNewUrlParser: true } to MongoClient.connect. SERVER IS RUNNING ON localhost:4000",
      "body": "**Issue type:**\r\n\r\n[ ] question\r\n[ ] bug report\r\n[x] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[x] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nHey and again same Issue like the quoted one:\r\n\r\n#2270 \r\n\r\nMongoDb asks to select the **new Url Parser**.\r\n\r\n`(node:25768) DeprecationWarning: current URL string parser is deprecated, and will be removed in a future version. To use the new parser, pass option { useNewUrlParser: true } to MongoClient.connect.` #"
    },
    "satisfaction_conditions": [
      "MongoDB connection must be established without URL parser deprecation warnings",
      "Connection configuration must be compatible with the MongoDB driver version in use",
      "Solution must be applicable within TypeORM's configuration system"
    ],
    "created_at": "2018-12-09T17:02:59Z"
  },
  {
    "id": "https://github.com/typeorm/typeorm/issues/2924",
    "source": {
      "issue_number": 2924
    },
    "initial_question": {
      "title": "BeforeInsert Issue",
      "body": "**Issue type:**\r\n\r\n[ ] question\r\n[x ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[x ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[x ] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[x ] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nPlacing @BeforeInsert() and @AfterInsert do not work\r\n\r\n```\r\n@AfterInsert()\r\n  modifyText() {\r\n    console.log(\"Something is being inserted\");\r\n  }\r\n```\r\n\r\n```\r\n@BeforeInsert()\r\n  modifyText() {\r\n    this.text = `${this.text} was modified before insert`;\r\n  }\r\n```\r\n\r\n```\r\n@BeforeInsert()\r\nhashpassword(){\r\n   this.password = ........\r\n}\r\n```\r\n\r\nI've seen this in other issues and they were closed but the issue was never actually resolved."
    },
    "satisfaction_conditions": [
      "Entity lifecycle hooks (@BeforeInsert, @AfterInsert) must execute when performing database operations",
      "Data modifications defined in lifecycle hooks must be reflected in the saved database record",
      "The entity being saved must be a proper class instance, not just a plain object",
      "Asynchronous operations in hooks must complete before the save operation finishes",
      "The solution must work with TypeORM's repository save operations"
    ],
    "created_at": "2018-10-12T23:56:44Z"
  },
  {
    "id": "https://github.com/typeorm/typeorm/issues/2577",
    "source": {
      "issue_number": 2577
    },
    "initial_question": {
      "title": "Is there a reason why listeners and subscribers would not work at all?",
      "body": "**Issue type:**\r\n\r\n[x] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[x] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\nUsing getRepository(Entity).save(data) or entityManager.save(Entity, data) will not fire the @AfterUpdate or @AfterInsert methods on the entity.\r\n\r\n```\r\n@AfterInsert()\r\n@AfterUpdate()\r\nsomeMethod() { \r\n console.log(\"It worked!\")\r\n}\r\n```\r\n\r\n\r\n<!--\r\n    To answer those questions you need to put \"x\" inside the square brackets, for example:\r\n    [x] `mysql`\r\n    [ ] `postgres`\r\n\r\n    Also, please format your code properly (by taking code blocks into ```ts .... ```)\r\n!>\r\n"
    },
    "satisfaction_conditions": [
      "Save operation must complete successfully"
    ],
    "created_at": "2018-07-24T16:22:46Z"
  },
  {
    "id": "https://github.com/typeorm/typeorm/issues/2425",
    "source": {
      "issue_number": 2425
    },
    "initial_question": {
      "title": "Is there any way to just check if query return a result or nothing ?",
      "body": "**Issue type:**\r\n\r\n[X] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[X] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n\r\n**TypeORM version:**\r\n\r\n[ ] `latest`\r\n[ ] `@next`\r\n[0.2.7] `0.x.x` (or put your version here)\r\n\r\nHi,\r\nFirst of all I'd like to thank you for your job, this tool is really good and easy to use.\r\n\r\nI would like to know if there is any way to know if my query return a result or not\r\n\r\nBasically something like this.\r\n\r\ncheckIfExist(value: string): Promise<boolean> {\r\n        const myRepository = getConnection().getRepository(Entity).createQueryBuilder('entity')\r\n            .where('entity.value= :value', { value: value});\r\n\r\n        return accidentRepository.Any();\r\n    }\r\n\r\nHope you can help me.\r\n\r\nHave a nice day\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\n<!--\r\n    To answer those questions you need to put \"x\" inside the square brackets, for example:\r\n    [x] `mysql`\r\n    [ ] `postgres`\r\n\r\n    Also, please format your code properly (by taking code blocks into ```ts .... ```)\r\n!>\r\n\r\n\r\n"
    },
    "satisfaction_conditions": [
      "Query must return a boolean value indicating presence/absence of matching records",
      "Function must handle asynchronous database operations",
      "Query must support filtering by a specific value parameter",
      "Must work with TypeORM's query builder interface",
      "Must be performant for existence checking"
    ],
    "created_at": "2018-06-28T16:53:34Z"
  },
  {
    "id": "https://github.com/typeorm/typeorm/issues/2080",
    "source": {
      "issue_number": 2080
    },
    "initial_question": {
      "title": "@CreateDateColumn does not auto populate upon insertion.",
      "body": "**Issue type:**\r\n\r\n[x] question\r\n[x] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[x] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n\r\n**TypeORM version:**\r\n\r\n[ ] `latest`\r\n[ ] `@next`\r\n[x] `0.2.2` \r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nSample entity definition.\r\n```\r\nexport class MyEntity {\r\n    @PrimaryGeneratedColumn()\r\n    public id: number;\r\n\r\n    @Column({type: \"int\"})\r\n    public password_reset_id: number;\r\n\r\n    @Column({type: \"varchar\"})\r\n    public password_hash: string;\r\n\r\n    @CreateDateColumn()\r\n    public created_at: Date;\r\n\r\n    @UpdateDateColumn()\r\n    public updated_at: Date;\r\n\r\n    @Column({type: \"timestamp\"})\r\n    public deleted_at: Date;\r\n}\r\n```\r\n\r\nIt would seem that after updating to version `0.2.2` my `created_at` columns are no longer being populated upon record insertion. Has the `@CreateDateColumn()` decorator changed in someway? Am I missing something completely obvious?\r\n"
    },
    "satisfaction_conditions": [
      "The created_at column must be automatically populated with the current timestamp when a new record is inserted",
      "The database schema must have appropriate default value configuration for timestamp columns",
      "The timestamp population must occur consistently across all new record insertions",
      "The implementation must maintain compatibility with TypeORM's entity definition structure"
    ],
    "created_at": "2018-05-04T00:29:39Z"
  },
  {
    "id": "https://github.com/typeorm/typeorm/issues/2009",
    "source": {
      "issue_number": 2009
    },
    "initial_question": {
      "title": "Set sqlite database path programmatically.",
      "body": "**Issue type:**\r\n\r\n[ x ] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[ x ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n\r\n**TypeORM version:**\r\n\r\n[ x ] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nI'm writing an app in electron, and I want to set the path to my sqlite databse like this:\r\n`${require('os').homedir()}/.HyperAI/database.sqlite`\r\n\r\nIs there a code example of how to do this programmatically?\r\n"
    },
    "satisfaction_conditions": [
      "Database path must be dynamically configurable at runtime",
      "Database path must be accessible within the Electron application context",
      "TypeORM connection configuration must accept the dynamic path"
    ],
    "created_at": "2018-04-24T04:25:32Z"
  },
  {
    "id": "https://github.com/typeorm/typeorm/issues/2008",
    "source": {
      "issue_number": 2008
    },
    "initial_question": {
      "title": "\u201cCONSTRAINT PK_payment_vendor PRIMARY KEY (vendor_id ASC)\u201c",
      "body": "**Issue type:**\r\n\r\n[ ] question\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `mysql` / `mariadb`\r\n\r\n**TypeORM version:**\r\n\r\n[ ] `0.1.20` \r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nIn MYSQL, create constraint is: CONSTRAINT PK_payment_vendor PRIMARY KEY (vendor_id ASC)\r\n\r\nhow to write in Typeorm? Thanks!\r\n"
    },
    "satisfaction_conditions": [
      "Primary key constraint is successfully defined for vendor_id column",
      "Solution works within TypeORM's entity definition system"
    ],
    "created_at": "2018-04-24T03:37:44Z"
  },
  {
    "id": "https://github.com/typeorm/typeorm/issues/1945",
    "source": {
      "issue_number": 1945
    },
    "initial_question": {
      "title": "invalid input syntax for uuid for PrimaryGeneratedColumn(\"uuid\") when initializing property",
      "body": "**Issue type:**\r\n\r\n[ ] question\r\n[X] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[X] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `websql`\r\n\r\n**TypeORM version:**\r\n\r\n[ ] `latest`\r\n[X] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\n```ts\r\n\r\nexport class EntityBase {\r\n  @PrimaryGeneratedColumn(\"uuid\") public id: string = \"\"; // NOTICE: I'm initializing this property to \"\"\r\n  @CreateDateColumn() public created: Date = new Date();\r\n  @UpdateDateColumn() public updated: Date = new Date();\r\n  @Column() public inactive: boolean = false;\r\n}\r\n\r\n@Entity(\"user_accounts\")\r\nexport class User extends EntityBase {\r\n  @Index(\"username_unique\", { unique: true })\r\n  @Column()\r\n  public username: string = \"\";\r\n\r\n  @Column() public passwordHash: string = \"\";\r\n  public password: string | undefined;\r\n}\r\n\r\n```\r\n\r\nTrying to insert entries of the above entity type but getting an error when calling `save` on the repository. My TypeScript project is set to `strict: true`, which requires property initialization.  I recently upgraded to `typeorm@next` (currently `0.2.0-alpha.46`) and began having this problem.  Before, I was running an earlier version of 0.2.0 and using `sqlite` instead of `postgres`. \r\n\r\nIn one of my other entities, I was initializing a relation property to empty array (`[]`) and received an error in the console, which was very clear that I shouldn't initialize that property.  \r\n\r\nI remove the initialization code and everything is now working.\r\n\r\nIs this something that TypeOrm could detect and throw a clearer error for?\r\n\r\n```\r\nQueryFailedError: invalid input syntax for uuid: \"\"\r\n    at new QueryFailedError (/src/error/QueryFailedError.ts:7:9)\r\n    at Query.callback (/src/driver/postgres/PostgresQueryRunner.ts:170:26)\r\n    at Query.handleError (/node_modules/pg/lib/query.js:143:17)\r\n    at Connection.connectedErrorHandler (/node_modules/pg/lib/client.js:132:26)\r\n    at emitOne (events.js:116:13)\r\n    at Connection.emit (events.js:211:7)\r\n    at Socket.<anonymous> (/pg/lib/connection.js:117:12)\r\n    at emitOne (events.js:116:13)\r\n    at Socket.emit (events.js:211:7)\r\n    at addChunk (_stream_readable.js:263:12)\r\n```"
    },
    "satisfaction_conditions": [
      "TypeScript strict property initialization requirements must be satisfied",
      "Entity must successfully save to database without UUID syntax errors"
    ],
    "created_at": "2018-04-15T01:01:39Z"
  },
  {
    "id": "https://github.com/typeorm/typeorm/issues/1944",
    "source": {
      "issue_number": 1944
    },
    "initial_question": {
      "title": "Is it possible to use the joined entity instead?",
      "body": "**Issue type:**\r\n\r\n[ x] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[x ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `websql`\r\n\r\n**TypeORM version:**\r\n\r\n[ ] `latest`\r\n[ ] `@next`\r\n[2.0.0] `0.x.x` (or put your version here)\r\n\r\nI wasn't able to gather from the docs and this question go no traction on SO.\r\n\r\n**Question:**\r\n\r\nI've got an auth_token table and user table. I'd like to resolve a user from a given auth token using the query builder. The issue I'm having is that after joining, the return type still thinks it's going to be an AuthToken. Is there a way to tell the query builder to use the joined entity instead?\r\n\r\n```\r\nreturn await this.authTokenRepository\r\n  .createQueryBuilder()\r\n  .where({\r\n    token: token\r\n  })\r\n  .innerJoinAndSelect(User, 'user')\r\n  .getOne();\r\n```\r\n"
    },
    "satisfaction_conditions": [
      "Query returns User entity data instead of AuthToken data",
      "Relationship between User and AuthToken tables is properly maintained in query",
      "Query filters results based on the provided token value",
      "Query returns a single user record",
      "TypeScript return type correctly reflects User entity"
    ],
    "created_at": "2018-04-14T18:58:59Z"
  },
  {
    "id": "https://github.com/typeorm/typeorm/issues/1827",
    "source": {
      "issue_number": 1827
    },
    "initial_question": {
      "title": "Question on query building to select a single column of the original table",
      "body": "```\r\n@Entity()\r\nexport class Script {\r\n    @PrimaryGeneratedColumn()\r\n    id: number;\r\n\r\n    @Column()\r\n    name: string;\r\n\r\n    @OneToMany(type => Session, session => session.script)\r\n    sessions: Session[];\r\n\r\n    @ManyToMany(type => User)\r\n    @JoinTable()\r\n    users: User[];\r\n}\r\n```\r\n\r\n```\r\n@Entity()\r\nexport class User {\r\n    @PrimaryGeneratedColumn()\r\n    id: number;\r\n\r\n    @Column()\r\n    username: string;\r\n\r\n    @OneToMany(type => Session, session => session.user)\r\n    sessions: Session[];\r\n}\r\n```\r\n\r\nI am trying to select the Script.name of users who have Script.\r\n\r\n```\r\n    async findScripts(username: string): Promise<Script[]> {\r\n        return await this.scriptRepository\r\n            .createQueryBuilder('script')\r\n            .select('script.name')\r\n            .leftJoin('script.users', 'user')\r\n            .where('user.username = :name', { name: username })\r\n            .getMany();\r\n    }\r\n```\r\n\r\n```\r\n[\r\n  {\r\n    \"name\": \"Script A\",\r\n    \"users\": [\r\n      \r\n    ]\r\n  },\r\n  {\r\n    \"name\": \"Script B\",\r\n    \"users\": [\r\n      \r\n    ]\r\n  }\r\n]\r\n```\r\n\r\nIt works, only issue is my left join is also adding an unwanted empty users array, I'm sure it is something dumb I overlooked. Any tips?\r\n\r\nBeen playing around with NestJS / TypeORM today overall very pleased and happy with this library, hats off to the contributors this is absolutely fantastic.\r\n\r\nThanks.\r\n"
    },
    "satisfaction_conditions": [
      "Query returns only script names without any user data",
      "Results are filtered by username",
      "Results maintain correct script-user relationship",
      "Results are returned in a flat array of objects with name property"
    ],
    "created_at": "2018-03-26T20:48:43Z"
  },
  {
    "id": "https://github.com/typeorm/typeorm/issues/1688",
    "source": {
      "issue_number": 1688
    },
    "initial_question": {
      "title": "@next QueryBuilder IN clause error",
      "body": "**Issue type:**\r\n\r\n[ ] question\r\n[ x] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[x ] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `websql`\r\n\r\n**TypeORM version:**\r\n\r\n[ ] `latest`\r\n[ x] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce:**\r\nWhen use IN clause using QueryBuilder and pass array of numbers, an error happens:\r\n\r\n```\r\ntypeorm:query:error parameters: [ [ 1, 2, 3 ] ]\r\ntypeorm:query:error error:  { error: invalid input syntax for integer: \"{\"1\",\"2\",\"3\"}\"\r\n```\r\nQuey:\r\n`query.andWhere(\"entity.id IN (:idInParam)\", { idInParam: [1, 2, 3] })`\r\n\r\n"
    },
    "satisfaction_conditions": [
      "Query successfully accepts array parameters without syntax errors",
      "IN clause correctly processes array of numbers",
      "Query syntax is compatible with the TypeORM @next version",
      "PostgreSQL array parameter formatting is correct",
      "Query maintains intended filtering functionality"
    ],
    "created_at": "2018-03-02T01:39:03Z"
  },
  {
    "id": "https://github.com/typeorm/typeorm/issues/1673",
    "source": {
      "issue_number": 1673
    },
    "initial_question": {
      "title": "How to wirte 'decimal(5,2)' in entity?",
      "body": "**Issue type:**\r\n\r\n[ ] question\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `mysql` / `mariadb`\r\n\r\n**TypeORM version:**\r\n\r\n[ ] `latest`\r\n\r\n**How to wirte 'decimal(5,2)' in entity?:**\r\n\r\nI want to set the field in the table. the field type is decimal, store like data: $123.23.\r\n\r\nIn entity, how to wirte?\r\n"
    },
    "satisfaction_conditions": [
      "Entity field definition must result in correct decimal precision and scale in database",
      "Column decorator must accept decimal type configuration",
      "Database schema verification shows correct decimal configuration"
    ],
    "created_at": "2018-02-28T07:42:24Z"
  },
  {
    "id": "https://github.com/typeorm/typeorm/issues/1608",
    "source": {
      "issue_number": 1608
    },
    "initial_question": {
      "title": "Create from nested object with lazy relation",
      "body": "**Issue type:**\r\n\r\n[] question\r\n[ ] bug report\r\n[x] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[x] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `websql`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nGiven\r\n```ts\r\nimport { BaseEntity, ManyToOne, OneToMany } from 'typeorm'\r\n\r\nclass Author extends BaseEntity {\r\n  @Column()\r\n  name: string\r\n\r\n  @OneToMany(() => Post)\r\n  posts: Promise<Post[]>\r\n}\r\n\r\nclass Post extends BaseEntity {\r\n  @ManyToOne(() => Author, 'posts', { cascadeInsert: true })\r\n  author: Promise<Author>\r\n}\r\n\r\nawait Post.create({author: Promise.resolve({name: 'author1'})}).save\r\n```\r\n\r\nGot\r\n```\r\nSTART TRANSACTION\r\nexecuting query:  INSERT INTO \"author\" DEFAULT VALUES  RETURNING \"id\"\r\nquery failed:  INSERT INTO \"author\" DEFAULT VALUES  RETURNING \"id\"\r\nerror:  { error: null value in column \"name\" violates not-null constraint\r\n...\r\n```\r\n\r\nBut eager relation works:  `Post.create({author: {name: 'author1'}})`\r\n\r\n"
    },
    "satisfaction_conditions": [
      "Nested object creation with lazy relations must successfully persist to database",
      "Promise-based lazy relations must be properly resolved during entity creation"
    ],
    "created_at": "2018-02-19T04:30:29Z"
  },
  {
    "id": "https://github.com/typeorm/typeorm/issues/1592",
    "source": {
      "issue_number": 1592
    },
    "initial_question": {
      "title": "get a relation key for side of OneToOne",
      "body": "**Issue type:**\r\n[X ] question\r\n**Database system/driver:**\r\n[X ] `mysql` / `mariadb`\r\n**TypeORM version:**\r\n[X ] `latest`\r\n\r\n**How now it is possible to find out from which column they are related?**\r\n\r\nI performed a search I need links\r\n``` \r\ngetRepository (this.constructor) .metadata.findRelationWithPropertyPath ('l10n');\r\n```\r\n\r\n**Expected Result: id_category**\r\n\r\n```\r\n@Entity(\"categories\", {})\r\nexport class CategoriesModel extends ORM {\r\n\r\n    @OneToOne(type => L10nCategoriesModel, l10n => l10n.categories, {\r\n        eager: true,\r\n        cascadeInsert: true,\r\n        cascadeUpdate: true,\r\n        cascadeRemove: true,\r\n        onDelete: 'CASCADE'\r\n    })\r\n    l10n: L10nCategoriesModel[];\r\n\r\n}\r\n\r\n@Entity(\"l10n-categories\", {})\r\nexport class L10nCategoriesModel extends ORM {\r\n\r\n    /* id_category */\r\n    @OneToOne(type => CategoriesModel, category => category.l10n, {\r\n        onDelete: 'CASCADE'\r\n    })\r\n    @JoinColumn({\r\n        name: 'id_category',\r\n    })\r\n    categories: CategoriesModel;\r\n}\r\n\r\n```"
    },
    "satisfaction_conditions": [
      "The solution must retrieve the foreign key column name from a OneToOne relationship",
      "The solution must work with TypeORM entity metadata",
      "The solution must handle bidirectional OneToOne relationships",
      "The solution must be able to identify the owner side of the relationship"
    ],
    "created_at": "2018-02-14T10:56:57Z"
  },
  {
    "id": "https://github.com/typeorm/typeorm/issues/1586",
    "source": {
      "issue_number": 1586
    },
    "initial_question": {
      "title": "nullable column/relation option set to false only works on undefined",
      "body": "**Issue type:**\r\n\r\n[ ] question\r\n[x] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[x] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `websql`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nI have two fields within my entity that have _nullable_ set to _false_, which will set the field null during an update (both in the relation and column).\r\n\r\n```ts\r\n@Entity('Account')\r\nexport class AccountEntity {\r\n\r\n    @ManyToOne(type => RecordTypeEntity, {\r\n        nullable: false\r\n    })\r\n    @JoinColumn({ name: 'RecordTypeId' })\r\n    recordType: RecordTypeEntity;\r\n\r\n    @Column({\r\n        name: 'Phone',\r\n        type: 'varchar',\r\n        nullable: false\r\n    })\r\n    phone: string;\r\n}\r\n```\r\n\r\nHowever, when running (I'm showing the Jest test I have it in), setting the fields to null will set them null in the database during the update, and the test will fail. **This does happen in the running server, I'm just showing the test because it's more concise.**\r\n\r\n```ts\r\nreturn AccountEntity.save(account).then(() => {\r\n    return AccountEntity.findOneById(account.sfid, {\r\n        join: {\r\n            alias: 'account',\r\n            innerJoinAndSelect: {\r\n                'recordType': 'account.recordType'\r\n            }\r\n        }\r\n    }).then(result => {\r\n\r\n        result.phone = null;\r\n        result.recordType = null;\r\n\r\n        return AccountEntity.save(result).then(() => {\r\n            return AccountEntity.findOneById(account.sfid, {\r\n                join: {\r\n                    alias: 'account',\r\n                    innerJoinAndSelect: {\r\n                        'recordType': 'account.recordType'\r\n                    }\r\n                }\r\n            }).then(result => {\r\n\r\n                expect(result).toBeDefined();\r\n\r\n                expect(result.recordType).toEqual(account.recordType);\r\n                expect(result.phone).toEqual(account.phone);\r\n\r\n            });\r\n        });\r\n\r\n    });\r\n\r\n});\r\n```\r\n\r\nThis is spit out in the logs during the test - so you can see that it's updating the field.\r\n\r\n```console\r\nconsole.log node_modules/typeorm/platform/PlatformTools.js:207\r\nexecuting query:  START TRANSACTION\r\n\r\nconsole.log node_modules/typeorm/platform/PlatformTools.js:207\r\nexecuting query:  UPDATE `Account` SET `Phone`=?, `RecordTypeId`=?  WHERE `Id`=? -- PARAMETERS: [null,null,\"1e6ecbc2-6890-44bd\"]\r\n\r\nconsole.log node_modules/typeorm/platform/PlatformTools.js:207\r\nexecuting query:  COMMIT\r\n```\r\n\r\nThe only way I can get it to work is to set the fields to undefined instead of null\r\n\r\n```ts\r\nresult.phone = undefined;\r\nresult.recordType = undefined;\r\n```\r\n"
    },
    "satisfaction_conditions": [
      "Database schema correctly enforces NOT NULL constraints"
    ],
    "created_at": "2018-02-13T19:54:02Z"
  },
  {
    "id": "https://github.com/typeorm/typeorm/issues/1490",
    "source": {
      "issue_number": 1490
    },
    "initial_question": {
      "title": "Undefined does not affect model objects",
      "body": "When trying to update a user, I mistakenly ran the following commands:\r\n```\r\n      user.resetPasswordToken = undefined;\r\n      user.resetPasswordExpires = undefined;\r\n      userRepo.save(user)\r\n```\r\n\r\nBut I noticed that it wasn't doing anything to the user object. However, when I changed this to:\r\n```\r\n      user.resetPasswordToken = null;\r\n      user.resetPasswordExpires = null;\r\n      userRepo.save(user)\r\n```\r\n\r\nIt had the expected behavior. This could be different from most people's expectations (even if this is expected behavior from the project), and should be clearly documented"
    },
    "satisfaction_conditions": [
      "Database fields must remain unchanged when properties are set to undefined",
      "Database fields must be set to NULL when properties are set to null",
      "Partial updates must be possible without affecting unspecified fields"
    ],
    "created_at": "2018-01-23T04:33:54Z"
  },
  {
    "id": "https://github.com/typeorm/typeorm/issues/1357",
    "source": {
      "issue_number": 1357
    },
    "initial_question": {
      "title": "Bug: invalid reference to FROM-clause entry for table",
      "body": "I have this query for finding an user by email:\r\n\r\n```typescript\r\nthis.repo.findOne({ email: normalizeEmail(email) })\r\n```\r\n\r\nThis query fails with the following error:\r\n\r\n```\r\nquery failed:  SELECT \"Person\".\"createdAt\" AS \"Person_createdAt\", \"Person\".\"updatedAt\" AS \"Person_updatedAt\", \"Person\".\"id\" AS \"Person_id\", \"Person\".\"creationAction\" AS \"Person_creationAction\", \"Person\".\"emailVerified\" AS \"Person_emailVerified\", \"Person\".\"emailVerificationTokenId\" AS \"Person_emailVerificationTokenId\", \"Person\".\"passwordHash\" AS \"Person_passwordHash\", \"Person\".\"passwordResetTokenId\" AS \"Person_passwordResetTokenId\", \"Person\".\"isAdmin\" AS \"Person_isAdmin\", \"Person\".\"firstName\" AS \"Person_firstName\", \"Person\".\"lastName\" AS \"Person_lastName\", \"Person\".\"email\" AS \"Person_email\" \r\nFROM \"person\" \"Person\" WHERE Person.email=$1 -- PARAMETERS: [\"cuwe@natatih.pw\"]\r\nerror:  { error: invalid reference to FROM-clause entry for table \"person\"\r\n  name: 'error',\r\n  length: 189,\r\n  severity: 'ERROR',\r\n  code: '42P01',\r\n  detail: undefined,\r\n  hint: 'Perhaps you meant to reference the table alias \"Person\".',\r\n  position: '612',\r\n  internalPosition: undefined,\r\n  internalQuery: undefined,\r\n  where: undefined,\r\n  schema: undefined,\r\n  table: undefined,\r\n  column: undefined,\r\n  dataType: undefined,\r\n  constraint: undefined,\r\n  file: 'parse_relation.c',\r\n  line: '3233',\r\n  routine: 'errorMissingRTE' }\r\n\r\n```\r\n\r\nThe `WHERE` clause is the problem:\r\n\r\n```sql\r\nWHERE Person.email=$1\r\n```\r\nIt should be:\r\n\r\n```sql\r\nWHERE \"Person\".\"email\"=$1\r\n```\r\nWithout the quotes `Person` refers to the `person` table, which can only be referred to by its alias `\"Person\"`.\r\n\r\nThis query is my current workaround:\r\n\r\n```typescript\r\nreturn this.repo.createQueryBuilder('person')\r\n      .where('person.email = :email', { email: normalizeEmail(email) })\r\n      .getOne()\r\n```\r\n\r\n```\r\nexecuting query:  SELECT \"person\".\"createdAt\" AS \"person_createdAt\", \"person\".\"updatedAt\" AS \"person_updatedAt\", \"person\".\"id\" AS \"person_id\", \"person\".\"creationAction\" AS \"person_creationAction\", \"person\".\"emailVerified\" AS \"person_emailVerified\", \"person\".\"emailVerificationTokenId\" AS \"person_emailVerificationTokenId\", \"person\".\"passwordHash\" AS \"person_passwordHash\", \"person\".\"passwordResetTokenId\" AS \"person_passwordResetTokenId\", \"person\".\"isAdmin\" AS \"person_isAdmin\", \"person\".\"firstName\" AS \"person_firstName\", \"person\".\"lastName\" AS \"person_lastName\", \"person\".\"email\" AS \"person_email\" \r\nFROM \"person\" \"person\" WHERE person.email = $1 -- PARAMETERS: [\"usuzovaw@wiwgi.gov\"]\r\n```\r\n\r\nIt works because then the table alias is the same as the table name.\r\n\r\n- typeorm: ^0.1.9\r\n- postgresql: 10.1-1.pgdg90+1"
    },
    "satisfaction_conditions": [
      "Query must handle email normalization"
    ],
    "created_at": "2017-12-18T14:32:16Z"
  },
  {
    "id": "https://github.com/typeorm/typeorm/issues/1342",
    "source": {
      "issue_number": 1342
    },
    "initial_question": {
      "title": "Left-joining single table multiple time with different conditions",
      "body": "When trying to join a single table multiple times with different conditions, parameter values don't seem to be updated:\r\n\r\n```js\r\n        this.createQueryBuilder('claim')\r\n            .select('claim.id')\r\n            .leftJoin(ClaimHistory, 'repairerDelivery',\r\n                '\"repairerDelivery\".\"claimId\" = claim.id AND \"repairerDelivery\".status = :status',\r\n                { status: 80 })\r\n            .leftJoin(ClaimHistory, 'buyerDelivery',\r\n                '\"buyerDelivery\".\"claimId\" = claim.id AND \"buyerDelivery\".status = :status',\r\n                { status: 100 })\r\n            .where('claim.\"repairerId\" = :id', { id: \"1\" })\r\n            .getRawMany();\r\n```\r\n\r\nGives this query\r\n\r\n```sql\r\nexecuting query:  SELECT \"claim\".\"id\" AS \"claim_id\" FROM \"claim\" \"claim\"\r\nLEFT JOIN \"claim_history\" \"repairerDelivery\" ON \"repairerDelivery\".\"claimId\" = \"claim\".\"id\" AND \"repairerDelivery\".status = $1 \r\nLEFT JOIN \"claim_history\" \"buyerDelivery\" ON \"buyerDelivery\".\"claimId\" = \"claim\".\"id\" AND \"buyerDelivery\".status = $2\r\nWHERE claim.\"repairerId\" = $3 -- PARAMETERS: [80,80,\"1\"] <---\r\n```\r\nIs this expected?"
    },
    "satisfaction_conditions": [
      "Query must maintain correct relationships between tables despite multiple joins"
    ],
    "created_at": "2017-12-14T04:29:00Z"
  },
  {
    "id": "https://github.com/typeorm/typeorm/issues/1322",
    "source": {
      "issue_number": 1322
    },
    "initial_question": {
      "title": "queryBuilder parameters: duplicated parameters name",
      "body": "        const tokens = s.split(' ');\r\n        for (const token of tokens) {\r\n          queryBuilder.andWhere(new Brackets(tokenQb => {\r\n            tokenQb.where('person.name ILIKE :token');\r\n            tokenQb.orWhere('person.lastName ILIKE :token');\r\n          })).setParameters({token: token});\r\n        }\r\n\r\nWhen s = \"foo bar\", I should get the query ... WHERE (person.firstName ILIKE 'foo' OR person.lastName ILIKE 'foo') AND (person.firstName ILIKE 'bar' OR person.lastName ILIKE 'bar').\r\n\r\nHowever, I got ... WHERE (person.firstName ILIKE 'bar' OR person.lastName ILIKE 'bar') AND (person.firstName ILIKE 'bar' OR person.lastName ILIKE 'bar') instead.\r\n\r\nHow can I achieve this?"
    },
    "satisfaction_conditions": [
      "Query parameters must be uniquely identifiable for each token in the input string",
      "Generated SQL query must contain the correct ILIKE conditions for each input token",
      "Each token from the input string must be correctly bound to its corresponding SQL conditions",
      "Query structure must maintain AND relationship between different tokens and OR relationship between name/lastName conditions"
    ],
    "created_at": "2017-12-09T05:52:28Z"
  },
  {
    "id": "https://github.com/typeorm/typeorm/issues/1274",
    "source": {
      "issue_number": 1274
    },
    "initial_question": {
      "title": "Conflicting columns?",
      "body": "I noticed this in the docs:\r\n\r\n```js\r\n// example how to load DM entities\r\nconst users = await userRepository.find({ skip: 2, take: 5 });\r\nconst newUsers = await userRepository.find({ isActive: true });\r\nconst timber = await userRepository.findOne({ firstName: \"Timber\", lastName: \"Saw\" });\r\n```\r\n\r\nWhat happens if there are columns named `skip` or `take`?"
    },
    "satisfaction_conditions": [
      "Query parameters must be correctly interpreted between pagination controls and column filters",
      "A mechanism exists to explicitly specify column filtering when column names conflict with pagination parameters",
      "The query produces expected results when columns have names that match pagination parameters"
    ],
    "created_at": "2017-11-30T10:19:50Z"
  },
  {
    "id": "https://github.com/typeorm/typeorm/issues/1225",
    "source": {
      "issue_number": 1225
    },
    "initial_question": {
      "title": "Property mapping in querybuilder",
      "body": "Does the querybuilder map the entity properties to their database column names when filtering?\r\n\r\n```javascript\r\n@Entity(\"users\")\r\nexport class User {\r\n    @PrimaryGeneratedColumn()\r\n    id:number;\r\n\r\n    @Column(\"varchar\",{\r\n        name: \"first_name\"\r\n    })\r\n    firstName: string;\r\n\r\n    @Column(\"varchar\",{\r\n        name: \"last_name\"\r\n    })\r\n    lastName: string;\r\n}\r\n```\r\n\r\nCan i use ***firstName***  here or do i have to do use the actual column name that is in the database?\r\n\r\n```javascript\r\nconst user = await getManager()\r\n    .createQueryBuilder(User, \"user\")\r\n    .where(\"user.firstName = :bind\", { bind: \"John\" })\r\n    .getOne();\r\n```\r\n\r\n"
    },
    "satisfaction_conditions": [
      "QueryBuilder accepts entity property names in query conditions",
      "Automatic mapping between property names and database column names occurs",
      "Decorators properly establish the property-to-column mapping"
    ],
    "created_at": "2017-11-23T18:17:23Z"
  },
  {
    "id": "https://github.com/typeorm/typeorm/issues/1213",
    "source": {
      "issue_number": 1213
    },
    "initial_question": {
      "title": "How to show rows changed from createQueryBuilder",
      "body": "Given a simple query like this:\r\n\r\n```typescript\r\ntypeorm.connection.manager\r\n       .createQueryBuilder()\r\n       .insert()\r\n       .into(User)\r\n       .values(req.body)\r\n       .execute()\r\n       .then((user: User) => console.info('user =', user, ';'))\r\n```\r\n\r\nIt succeeds, but the output is: `user = [] ;`. How do I show the created rows?\r\n\r\nOr do I need to add a select query in the `.then` callback?"
    },
    "satisfaction_conditions": [
      "The inserted data must be retrievable after the insert operation",
      "The solution must work within the asynchronous flow of the insert operation"
    ],
    "created_at": "2017-11-22T08:19:52Z"
  },
  {
    "id": "https://github.com/typeorm/typeorm/issues/1185",
    "source": {
      "issue_number": 1185
    },
    "initial_question": {
      "title": "Can not use alias in find()",
      "body": "Hi,\r\n\r\ntypeorm:0.0.11\r\n\r\nwhen i use \r\n```\r\n...find({alias: 'test'});\r\n```\r\n\r\nthen typeorm throws unhandled rejections: \r\n```\r\nUnhandled rejection Error: ER_BAD_FIELD_ERROR: Unknown column 'test.alias' in 'where clause'\r\n```\r\n\r\nis it fixed in newest version? i.e. typeorm@0.1.2?"
    },
    "satisfaction_conditions": [
      "Query execution completes without 'ER_BAD_FIELD_ERROR' error",
      "Find operation accepts valid query parameters without requiring alias parameter",
      "TypeORM version compatibility is confirmed"
    ],
    "created_at": "2017-11-15T13:11:32Z"
  },
  {
    "id": "https://github.com/typeorm/typeorm/issues/1127",
    "source": {
      "issue_number": 1127
    },
    "initial_question": {
      "title": "postresql primary column with type \"bigint\" maps property as string",
      "body": "Hello, \r\nI noticed that primary column with type `bigint` maps property as `string` instead of `number`"
    },
    "satisfaction_conditions": [
      "Data type mapping preserves full numeric range of PostgreSQL bigint",
      "Type mapping behavior is consistent with language/framework numeric limitations",
      "Data type conversion maintains exact value representation"
    ],
    "created_at": "2017-11-01T12:13:13Z"
  },
  {
    "id": "https://github.com/typeorm/typeorm/issues/1028",
    "source": {
      "issue_number": 1028
    },
    "initial_question": {
      "title": "Property isModified function?",
      "body": "Mongoose has the `isModified` function to see if a property has been modified. This is really helpful in a pre-save hook (or for typeorm, when extending save()) to make sure a password always gets hashed. \r\n\r\nIs there something like that for typeorm? I couldn't find it in the docs."
    },
    "satisfaction_conditions": [
      "Password field changes are detectable",
      "Compatible with TypeORM architecture",
      "Property access control"
    ],
    "created_at": "2017-10-14T16:58:00Z"
  },
  {
    "id": "https://github.com/typeorm/typeorm/issues/999",
    "source": {
      "issue_number": 999
    },
    "initial_question": {
      "title": "Update/remove all with auto-completion",
      "body": "Is there a simple syntax to update or remove multiple entities via Active Record or Data-Mapper? I'm looking for something like (in sequelize):\r\n\r\n`await User.update({ name: 'a' }, { where: { name: 'b' } });`\r\n`// UPDATE users SET name = 'a' WHERE name = 'b';`\r\n\r\nand\r\n\r\n`await User.update({ name: 'a' });`\r\n`// UPDATE users SET name = 'a';`\r\n\r\nEntityManager throws `Cannot find entity to update by a given criteria` if there are no matches, and only updates one record:\r\n\r\n`await connection.manager.update(User, { name: 'a' }, { name: 'b' });`\r\n`await connection.manager.update(User, { where: { name: 'a'  } }, { name: 'b' });`\r\n\r\nQueryBuilder works, but is verbose and has no type checking on `.where()`:\r\n\r\n```\r\nawait User.createQueryBuilder('user')\r\n      .update({ name: 'b' })\r\n      .where('user.name = :name', { name: 'a' }) // hard to maintain, no type check\r\n      .execute();\r\n```\r\n\r\n\r\n"
    },
    "satisfaction_conditions": [
      "Multiple records must be updated in a single operation",
      "No SELECT query should be executed before the UPDATE",
      "Syntax must be concise and similar to standard ORM patterns"
    ],
    "created_at": "2017-10-05T03:12:53Z"
  },
  {
    "id": "https://github.com/typeorm/typeorm/issues/917",
    "source": {
      "issue_number": 917
    },
    "initial_question": {
      "title": "[Question] findByIds with another field",
      "body": "Hello everyone :)\r\n\r\nAfter some researches I do not find an answer to my question. Thus, I post here.\r\n\r\nIs it possible to use  SQL `IN` in where clause of a query or an equivalent of `findByIds` with another field than id ?\r\n\r\nFor instance, I have Users that have an email. I want to load users where their emails match an email in a list.\r\nIn SQL that will look something like that : \r\n`SELECT * FROM users WHERE email IN ('aa@aa.aa', 'bb@bb.bb');`\r\n\r\nThanks."
    },
    "satisfaction_conditions": [
      "Query must support filtering multiple records based on a list of non-ID field values",
      "Query must return all matching user records",
      "Query syntax must be compatible with the TypeORM framework",
      "Query must accept a dynamic list of email values"
    ],
    "created_at": "2017-09-20T06:21:28Z"
  },
  {
    "id": "https://github.com/typeorm/typeorm/issues/899",
    "source": {
      "issue_number": 899
    },
    "initial_question": {
      "title": "Repository: differents between .save() and .persist() and would a .insert() be possible?",
      "body": "The title more or less says it all, what is the difference right know (or the difference planed) between `.save()` and `.persist()` of a repository? Since looking at the source code, would suggest, that they do the same.\r\nAnd is there a way to just insert the entities without the check beforehand? Because when I try to insert 700 entities at once a select statement is executed for each one of them, which isn't neccesary in every use case. Mine for example is, inserting entities that have been loaded from an api where I can be certain, that they do not exist in the table."
    },
    "satisfaction_conditions": [
      "Clarification of functional equivalence between .save() and .persist() methods is provided",
      "A method for bulk entity insertion without individual existence checks is demonstrated",
      "The bulk insertion method supports multiple entities in a single operation"
    ],
    "created_at": "2017-09-18T06:19:49Z"
  },
  {
    "id": "https://github.com/typeorm/typeorm/issues/877",
    "source": {
      "issue_number": 877
    },
    "initial_question": {
      "title": "How to set Current time stamp as default value",
      "body": "How to set Current time stamp as default value"
    },
    "satisfaction_conditions": [
      "Column must automatically populate with the current timestamp when a new record is created",
      "The timestamp default value must be handled at the database level, not application level",
      "The syntax must be compatible with the specific database being used",
      "The timestamp format must properly handle timezone information if specified",
      "The configuration must not cause unexpected migration behaviors"
    ],
    "created_at": "2017-09-13T12:12:40Z"
  },
  {
    "id": "https://github.com/typeorm/typeorm/issues/876",
    "source": {
      "issue_number": 876
    },
    "initial_question": {
      "title": "How to select appropriate column from join table?",
      "body": "I would like to remove some column from my result, in order to get rid of the user details. I tried with  .select(['uad.*', 'ua.*', 'u.name']) but doesn't work. How should I do?\r\n\r\n\r\n```\r\n    const query = db.getRepository(UserActivityDo)\r\n        .createQueryBuilder('uad')\r\n        .innerJoinAndSelect('uad.idUserActivity', 'ua')\r\n        .innerJoinAndSelect('ua.idUser', 'u')\r\n        // .select(['uad.*', 'ua.*', 'u.name'])\r\n        .where(`ua.idUser IN (${userIds.join(',')})`)       \r\n        .orderBy('uad.created', 'DESC');\r\n\r\n```\r\n\r\nThis is the result I get from the previous query. How can I only keep the user.name of the user relation?\r\n\r\n```\r\n[\r\n            {\r\n                \"idUserActivityDo\": 10,\r\n                \"description\": \"\",\r\n                \"created\": \"2017-09-11T22:13:15.327Z\",\r\n                \"idUserActivity\": {\r\n                    \"idUserActivity\": 21,\r\n                    \"activityName\": \"lolololol\",\r\n                    \"i18n\": \"en_US\",\r\n                    \"created\": \"2017-09-11T22:11:27.855Z\",\r\n                    \"idUser\": {\r\n                        \"idUser\": 41,\r\n                        \"email\": \"ooooo@ooooo.com\",\r\n                        \"hashedPassword\": \"$2a$10$gf3m/6FP/a/8V.Q7K\",\r\n                        \"salt\": \"$2a$10$55SB/gk0.\",\r\n                        \"name\": \"jgfhfhfhfhfj\",\r\n                        \"created\": \"2017-09-10T16:10:36.861Z\",\r\n                        \"pushToken\": \"ExponentPushToken[ssffsdfds]\"\r\n                    }\r\n                }\r\n            },\r\n            {\r\n                \"idUserActivityDo\": 9,\r\n                \"description\": \"\",\r\n                \"created\": \"2017-09-11T22:13:04.320Z\",\r\n                \"idUserActivity\": {\r\n                    \"idUserActivity\": 21,\r\n                    \"activityName\": \"lolololol\",\r\n                    \"i18n\": \"en_US\",\r\n                    \"created\": \"2017-09-11T22:11:27.855Z\",\r\n                    \"idUser\": {\r\n                        \"idUser\": 40,\r\n                        \"email\": \"world@ooooo.com\",\r\n                        \"hashedPassword\": \"$2a$10$gf3m/6FP/a/8V.Q7K\",\r\n                        \"salt\": \"$2a$10$55SB/gk0.\",\r\n                        \"name\": \"jgfhfhfhfhfj\",\r\n                        \"created\": \"2017-09-10T16:10:36.861Z\",\r\n                        \"pushToken\": \"ExponentPushToken[ssffsdfds]\"\r\n                    }\r\n                }\r\n            },\r\n            {\r\n                \"idUserActivityDo\": 8,\r\n                \"description\": \"\",\r\n                \"created\": \"2017-09-11T22:08:12.452Z\",\r\n                \"idUserActivity\": {\r\n                    \"idUserActivity\": 12,\r\n                    \"activityName\": \"fffgghgf\",\r\n                    \"i18n\": \"en_US\",\r\n                    \"created\": \"2017-09-10T19:01:41.373Z\",\r\n                    \"idUser\": {\r\n                        \"idUser\": 42,\r\n                        \"email\": \"helo@ooooo.com\",\r\n                        \"hashedPassword\": \"$2a$10$gf3m/6FP/a/8V.Q7K\",\r\n                        \"salt\": \"$2a$10$55SB/gk0.\",\r\n                        \"name\": \"jgfhfhfhfhfj\",\r\n                        \"created\": \"2017-09-10T16:10:36.861Z\",\r\n                        \"pushToken\": \"ExponentPushToken[ssffsdfds]\"\r\n                    }\r\n                }\r\n            },...\r\n```"
    },
    "satisfaction_conditions": [
      "Query must maintain existing join relationships between tables",
      "Original query functionality (filtering and ordering) must be preserved"
    ],
    "created_at": "2017-09-12T21:03:21Z"
  },
  {
    "id": "https://github.com/typeorm/typeorm/issues/869",
    "source": {
      "issue_number": 869
    },
    "initial_question": {
      "title": "Question - Deep joining",
      "body": "Is the following possible with 1 query?\r\n\r\nI have the following relationship:\r\n\r\n`User` 1-* `Account` 1-* `Expense` *-1 `Project`\r\n\r\nI'm trying to get all the projects a certain user has made expenses for through any of their accounts.\r\n\r\nI can get as far as getting the expenses for each account:\r\n\r\n```\r\n    const user = await this.repo\r\n      .createQueryBuilder('user')\r\n      .innerJoinAndSelect('user.accounts', 'accounts')\r\n      .leftJoinAndSelect('accounts.expenses', 'expenses')\r\n      // next line breaks\r\n      .leftJoinAndSelect('accounts.expenses.projects', 'projects')\r\n      .where('user.id=:user_id')\r\n      .setParameter('user_id', id)\r\n      .getOne()\r\n```\r\n\r\nI've tried multiple variations of the breaking line - but I'm not sure if it's even possible what I'm trying to do."
    },
    "satisfaction_conditions": [
      "Query must successfully retrieve projects linked to a user through multiple relationship levels (User -> Account -> Expense -> Project)",
      "Query must handle the correct relationship cardinality (one-to-many and many-to-one relationships)",
      "Query must execute as a single database operation",
      "Query must filter results for a specific user ID",
      "Query must respect the exact property names in the entity relationships"
    ],
    "created_at": "2017-09-12T10:28:47Z"
  },
  {
    "id": "https://github.com/typeorm/typeorm/issues/859",
    "source": {
      "issue_number": 859
    },
    "initial_question": {
      "title": "Question - entity relations ",
      "body": "What is the expected behavior regarding the update of relations ? Are the inverse relations updated automatically ? What about their RelationId columns (assuming they are explicitly declared on the classes)\r\n\r\nFor example, assuming I have a master - detail relation as below (please note the Author and AuthorId columns - AuthorId exists on the class declaration)\r\n\r\n```ts\r\n@Entity(\"Persons\")\r\nexport class Author {\r\n\r\n    @PrimaryGeneratedColumn()\r\n    Id: number;\r\n\r\n    @Column()\r\n    Name: string;\r\n\r\n    @OneToMany(type => Photo, photo => photo.Author) // Note: we will create author property in the Photo class below\r\n    Photos: Photo[];\r\n}\r\n\r\n@Entity(\"Photos\")\r\nexport class Photo {\r\n\r\n    @PrimaryGeneratedColumn()\r\n    Id: number;\r\n\r\n    @Column({\r\n        length: 800,\r\n        nullable: false\r\n    })\r\n    Name: string;\r\n\r\n    @Column(\"text\")\r\n    Description: string;\r\n\r\n    @Column()\r\n    Filename: string;\r\n\r\n    @ManyToOne(type => Author, author => author.Photos, {\r\n        onDelete: \"CASCADE\"\r\n    })\r\n    Author: Author;\r\n\r\n    @RelationId((photo: Photo) => photo.Author)\r\n    AuthorId: number;\r\n\r\n}\r\n```\r\nAssume that I load an author from DB and a photo using 2 distinct calls from their repositories.\r\nThe photo is not related to this author.\r\n\r\nIf I set the Author property on the photo instance would the AuthorId  contain the Id of the Author instance ? Will this happen automatically or I would have to set it manually ? Also is the Author.Photos updated so that it contains the linked photo ?\r\n\r\nAlso if I push a Photo instance to the author.Photos array, will the inverse relations be updated automatically (Author instance would contain the author and AuthorId will contain the Author.Id)\r\n\r\nThank you\r\n"
    },
    "satisfaction_conditions": [
      "RelationId columns must update automatically when the corresponding relation property changes",
      "Inverse relations must not update automatically to avoid circular dependencies",
      "Each loaded entity must be treated as a unique object instance"
    ],
    "created_at": "2017-09-11T15:08:36Z"
  },
  {
    "id": "https://github.com/typeorm/typeorm/issues/825",
    "source": {
      "issue_number": 825
    },
    "initial_question": {
      "title": "Question - Joining tables.",
      "body": "I'm trying to introduce some privilege control to my project. \r\n\r\nFirst, I have a File entity here. Each file has a owner group, and only members of its owner group can see the file.\r\n\r\n``` typescript\r\n@Entity()\r\nexport class File {\r\n\r\n    @PrimaryGeneratedColumn()\r\n    public id: number;\r\n\r\n    @Column('varchar')\r\n    public content: string;\r\n\r\n    @Column('int')\r\n    public groupId: number,\r\n\r\n}\r\n```\r\n\r\nAnd I have a group_map entity to store the relations between users and groups.\r\n\r\n``` typescript\r\n@Entity()\r\nexport class GroupMap {\r\n\r\n  @PrimaryColumn('int')\r\n  public groupId: number;\r\n\r\n  @PrimaryColumn('int')\r\n  public userId: number;\r\n\r\n}\r\n```\r\n\r\nWhen a particular user tries to list all the files that he could access, I would like to check whether this user belongs to the owner group of the file.  So to achieve this goal I would like to join the second table ON **File.groupId = groupMap.groupId AND groupMap.userId = :currentUserId (passed in as a parameter)**. \r\n\r\nI'm not sure whether this is possible using relations (or something else?) provided by TypeORM.\r\n\r\nAppreciate any help."
    },
    "satisfaction_conditions": [
      "Database schema must support file ownership by groups",
      "Database schema must track user-group memberships",
      "Queries must filter files based on current user's group membership",
      "Group membership must support additional attributes like privilege levels",
      "Database schema must support efficient querying of user-group-file relationships"
    ],
    "created_at": "2017-09-05T05:40:39Z"
  },
  {
    "id": "https://github.com/typeorm/typeorm/issues/794",
    "source": {
      "issue_number": 794
    },
    "initial_question": {
      "title": "Question - What does @JoinTable in @ManyToMany does?",
      "body": "Hi and sorry for the stupid question:\r\n\r\nWhat is the difference between the two connected entities with @ManyToMany ?\r\nWhat does the `owner side` means?"
    },
    "satisfaction_conditions": [
      "The relationship ownership must be clearly established between entities in a many-to-many relationship",
      "A junction/join table must be properly created and configured",
      "The @JoinTable decorator must be used on only one side of the many-to-many relationship",
      "The relationship configuration must result in correct table and column naming",
      "The relationship must allow bidirectional access between entities"
    ],
    "created_at": "2017-08-24T16:20:32Z"
  },
  {
    "id": "https://github.com/typeorm/typeorm/issues/776",
    "source": {
      "issue_number": 776
    },
    "initial_question": {
      "title": "QueryRunnerProviderAlreadyReleasedError for Transaction",
      "body": "Hi,\r\nI'm using typeorm 0.0.11 version. I got below error message when running a transaction. It seems when I was trying to persist to a second table, the database connection is closed:\r\n\r\nIn propse trade, fail in 2nd persit[2017-08-18 14:14:57.577] - INFO - In propse trade, fail in 2nd persit (my error log).\r\n\r\nQueryRunnerProviderAlreadyReleasedError: Database connection provided by a query runner was already released, cannot continue to use its querying methods anymore  (This is error message).\r\n\r\nThe database driver I'm using is mysql. Do we have to implement the connection pool for mysql for this to work?\r\n\r\nHere is partial code:\r\n\r\n     this.db.entityManager.transaction(async transactionalEntityManager => {\r\n                            transactionalEntityManager.persist(table1)\r\n                            .then((result) => {\r\n\r\n                                console.log('successful in 1st persist');\r\n                                let sAction: SAction = new SAction();\r\n                \r\n                                sActionId.Id = result.sId;\r\n                                sActionId.stateId = TS.TRIED;\r\n         \r\n                                transactionalEntityManager.persist(sAction)\r\n                                .then((result) => {\r\n                                    console.log('successful in 2nd persist');\r\n                                  })\r\n                              .catch((err) => {\r\n                                    console.log('fail in 2nd persit');\r\n                                    return reject(err);\r\n                                });\r\n                           })\r\n                           .catch((err) => {\r\n                                return reject(err);                              \r\n                            }); \r\n\r\n\r\n"
    },
    "satisfaction_conditions": [
      "Error states are properly captured and handled",
      "Sequential operations execute in the correct order"
    ],
    "created_at": "2017-08-18T21:32:29Z"
  },
  {
    "id": "https://github.com/typeorm/typeorm/issues/717",
    "source": {
      "issue_number": 717
    },
    "initial_question": {
      "title": "[Question] Subscriber Events using QueryBuilder Update",
      "body": "Hi,\r\n\r\nWondering if it is expected functionality for a subscriber, such as ``afterUpdate`` to be triggered on a Repository ``.save()`` method, but not to be triggered on a QueryBuilder ``.update()`` method?\r\n\r\nThanks!"
    },
    "satisfaction_conditions": [
      "Subscriber events must trigger correctly with Repository.save() method",
      "QueryBuilder.update() behavior regarding subscribers must be understood",
      "Method choice must align with specific use case requirements",
      "Performance implications must be considered in method selection"
    ],
    "created_at": "2017-07-28T14:10:38Z"
  },
  {
    "id": "https://github.com/typeorm/typeorm/issues/700",
    "source": {
      "issue_number": 700
    },
    "initial_question": {
      "title": "Creating a relation with a join table",
      "body": "Hey, This is a great project. Really well done.\r\n\r\nI have a  a many to many relationship between two entities (ex: `Vendor` and `Material`) which creates a join table. I have a separate entity `Quote` that I would like to relate to the join table of the previous relationship. How would I go about achieving that?\r\n\r\nThanks"
    },
    "satisfaction_conditions": [
      "The solution must enable a three-way relationship between Vendor, Material, and Quote entities",
      "The relationship structure must support storing additional data beyond just the basic entity associations",
      "The data model must maintain referential integrity between all three entities",
      "The solution must be implementable within the ORM framework being used"
    ],
    "created_at": "2017-07-24T19:36:32Z"
  },
  {
    "id": "https://github.com/typeorm/typeorm/issues/698",
    "source": {
      "issue_number": 698
    },
    "initial_question": {
      "title": "Raw query with json columns (Postgres)",
      "body": "Folks, I am trying to build a query like this\r\n\r\n  ```\r\n  let query = `SELECT \"incident\".* FROM \"incident\" \"incident\"  \r\n     WHERE incidents::jsonb @> '[{\"name\":$1}]' ORDER BY \"incident\".\"id\" ASC`;\r\n\r\n    const results: any = await repository.query(query, ['Briga']);\r\n```\r\nI want to add the value of the json as a parameter, but I am getting an error\r\n\r\n`error during executing query:error: invalid input syntax for type json\r\n`\r\n\r\nThe final query I want is this one:\r\n```\r\nSELECT \"incident\".* \r\nFROM \"incident\" \"incident\" WHERE incidents::jsonb @> '[{\"name\":\"briga\"}]' \r\nORDER BY \"incident\".\"id\" ASC\r\n```\r\n\r\nI searched in the documentation how to parametrize queries with json fields but could not find anything. Could you help me?"
    },
    "satisfaction_conditions": [
      "Query must successfully handle JSON array containment check in PostgreSQL",
      "Query must maintain proper SQL injection protection"
    ],
    "created_at": "2017-07-23T22:45:26Z"
  },
  {
    "id": "https://github.com/typeorm/typeorm/issues/676",
    "source": {
      "issue_number": 676
    },
    "initial_question": {
      "title": "Junction tables not generated for ManyToMany relation.",
      "body": "Hi there,\r\n\r\nI have a rather simple many to many relationship in my project, some properties have been removed for brevity:\r\n\r\n```\r\n@Entity()\r\nexport class Item {\r\n\r\n    @PrimaryGeneratedColumn()\r\n    public id: number;\r\n    \r\n    @JoinColumn()\r\n    @ManyToMany(type => Location, location => location.items)\r\n    public locations: Location[];\r\n}\r\n```\r\nand\r\n```\r\n@Entity()\r\nexport class Location {\r\n\r\n    @PrimaryGeneratedColumn()\r\n    public id: number;\r\n\r\n    @Column({ length: 128 })\r\n    public name: string;\r\n    \r\n    @JoinColumn()\r\n    @ManyToMany(type => Item, item => item.locations, { \r\n        cascadeInsert: true,\r\n        cascadeUpdate: true\r\n    })\r\n    public items: Item[];\r\n}\r\n```\r\nUnfortunately no junction table is being generated, it seems the properties in question are simply being ignored as the SQL debug output shows.\r\n\r\n```\r\nexecuting query: START TRANSACTION\r\nexecuting query: CREATE TABLE `location` (`id` int(11) NOT NULL PRIMARY KEY AUTO_INCREMENT, `name` varchar(128) NOT NULL, `updated_at` datetime(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6), `created_at` datetime(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6)) ENGINE=InnoDB\r\nexecuting query: CREATE TABLE `item` (`id` int(11) NOT NULL PRIMARY KEY AUTO_INCREMENT, `name` varchar(128) NOT NULL, `description` varchar(512) NOT NULL, `price` int(11) NOT NULL, `updated_at` datetime(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6), `created_at` datetime(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6)) ENGINE=InnoDB\r\nexecuting query: CREATE TABLE `tag` (`id` int(11) NOT NULL PRIMARY KEY AUTO_INCREMENT, `name` varchar(255) NOT NULL, `updated_at` datetime(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6), `created_at` datetime(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6)) ENGINE=InnoDB\r\nexecuting query: COMMIT\r\n```\r\n\r\nPlatform: Windows 10\r\nDatabase: MariaDB\r\nVersion: typeorm@0.1.0-alpha.31\r\n\r\n"
    },
    "satisfaction_conditions": [
      "The many-to-many relationship must be properly mapped in both entity classes",
      "The relationship must allow both entities to reference their related entities"
    ],
    "created_at": "2017-07-16T22:21:01Z"
  },
  {
    "id": "https://github.com/typeorm/typeorm/issues/662",
    "source": {
      "issue_number": 662
    },
    "initial_question": {
      "title": "Updating an entity without selecting beforehand.",
      "body": "Hi there,\r\n\r\nis there a way to update an entity without fetching it beforehand?\r\n\r\nRegards"
    },
    "satisfaction_conditions": [
      "Entity update operation completes without requiring prior fetch",
      "Primary key/identifier is specified for the target entity",
      "Changes persist correctly in the database"
    ],
    "created_at": "2017-07-13T20:56:07Z"
  },
  {
    "id": "https://github.com/typeorm/typeorm/issues/642",
    "source": {
      "issue_number": 642
    },
    "initial_question": {
      "title": "Data type \"boolean\" is not supported in \"mysql\" database.",
      "body": "typeorm `0.1.0-alpha.28` is giving now error `Data type \"boolean\" is not supported in \"mysql\" database.` if using boolean datatype. Running with sqlite this works fine. \r\n\r\nThis used to work with 0.0.11. I suppose I could fallback to tinyint as solution for now."
    },
    "satisfaction_conditions": [
      "Boolean values must be correctly stored and retrieved from MySQL database",
      "TypeORM must correctly map between TypeScript boolean type and database representation",
      "Metadata reflection system must be properly configured",
      "Reflection metadata must be loaded before entity definitions",
      "Application must maintain compatibility with the database's native type system"
    ],
    "created_at": "2017-07-10T09:59:36Z"
  },
  {
    "id": "https://github.com/typeorm/typeorm/issues/635",
    "source": {
      "issue_number": 635
    },
    "initial_question": {
      "title": "Specifying relations to support legacy database",
      "body": "Hi,\r\n\r\nI'm rewriting data-related part of an older application which was created for non-SPA environment with dynamic pages (MVC app with some AJAX parts) approach. I chose to rewrite API with TS & Node.js because of decorators and all the things that make code easily readable. However, I wanted to reconstruct database with entities in typeorm, so in case that application is bootstrapped from zero (without existing DB), the database doesn't need any script to be run in order to initialize it. Database which I'm using is MySQL. To achieve that I need to retain the whole structure of fields in tables, but there must be also defined some foreign keys and other things which are needed to preserve relations. I already rewrote current tables into entities, but the part with relations seems a bit impossible to do for me at the moment. I tried to use `@ManyToOne` decorator for defining foreign key in one table, but I always get another field in table which doesn't have correct name. Here is the example:\r\n\r\nWe have two entities - User and Post. User can create zero or more posts, but post is always created by a single user. So we should have the following two tables:\r\n\r\n- user - user_id (PK), name, username, password, email\r\n- post - post_id (PK), title, content, publish_date, user_id (FK)\r\n\r\nSo we would specify both models as:\r\n```\r\n@Entity()\r\nexport class User {\r\n\r\n  @PrimaryGeneratedColumn()\r\n  user_id: number;\r\n\r\n  @Column({ length: 255 })\r\n  name: string;\r\n\r\n  @Column({ length: 20, unique: true })\r\n  @Index()\r\n  username: string;\r\n\r\n  @Column({ length: 128 })\r\n  password: string;\r\n\r\n  @Column({ length: 255, unique: true })\r\n  email: string;\r\n\r\n}\r\n```\r\n\r\n```\r\n@Entity()\r\nexport class Post {\r\n\r\n  @PrimaryGeneratedColumn()\r\n  post_id: number;\r\n\r\n  @Column({ length: 255 })\r\n  @Index()\r\n  title: string;\r\n\r\n  @Column(\"text\")\r\n  content: string;\r\n\r\n  @Column(\"date\")\r\n  publish_date: Date;\r\n\r\n  @Column(\"int\")\r\n  user_id: number;\r\n\r\n}\r\n```\r\n\r\nAs stated above, I need to retain user_id in Post entity to support the existing state of database entries. I tried to add `@ManyToOne` decorator to Post's user_id as ...\r\n\r\n```\r\n@Column(\"int\")\r\n@ManyToOne(() => User)\r\nuser_id: number;\r\n```\r\n\r\nBut that didn't work well, because then I got the following structure of table:\r\n\r\n- post - post_id (PK), title, content, publish_date, user_id, **userUserId (FK)**\r\n\r\nSo the problem here is that the foreign key is always being inserted at the end of table and has specific naming strategy which isn't ok in my case. So my question here it is - do I have to handle my case manually and run database init script in case of a new environment, or I am missing something and there actually is a way to support such cases?\r\n\r\nAny answer/recommendation will be highly appreciated. Thanks in advance!"
    },
    "satisfaction_conditions": [
      "Foreign key relationship must be established while maintaining existing column name",
      "Database schema must match legacy structure exactly",
      "Entity relationships must support both nullable and non-nullable foreign keys",
      "Lazy loading of relationships must be configurable",
      "Post creation must work with either full User entity or just User ID"
    ],
    "created_at": "2017-07-09T17:40:09Z"
  },
  {
    "id": "https://github.com/typeorm/typeorm/issues/631",
    "source": {
      "issue_number": 631
    },
    "initial_question": {
      "title": "join not working in case of findOptions",
      "body": "\"typeorm\": \"0.1.0-alpha.31\",\r\n\r\nI tried writing join query using entity manager and query builder. It works fine using query builder but  the related table data is not loaded when using findOptions.\r\n\r\nQuerBuilder: `claims` array added to the `roles`\r\n```javascript\r\nconst [roles, count] = await this.roleRepository.createQueryBuilder(\"role\")\r\n            .where(\"role.tenantId = tenantId\", { tenantId: ctx.state.user.tenantId })\r\n            .leftJoinAndSelect(\"role.claims\", \"claims\")\r\n            .offset(offset)\r\n            .limit(limit)\r\n            .getManyAndCount();\r\n```\r\nFindOptions: `claims` array **not** added to the `roles`\r\n```javascript\r\nconst [roles, count] = await this.roleRepository.findAndCount({\r\n            where: { tenantId: ctx.state.user.tenantId },\r\n            alias: \"role\",\r\n            leftJoinAndSelect: {\r\n                \"claims\": \"role.claims\"\r\n            },\r\n            limit: limit,\r\n            offset: offset\r\n        });\r\n```\r\n\r\nFollowing are the entities:\r\n\r\n```javascript\r\n@Entity()\r\nexport class Role extends BaseTenantEntity{\r\n\r\n    @Column({ nullable: false })\r\n    name: string;\r\n\r\n    @Column({ nullable: false })\r\n    description: string;\r\n\r\n    @ManyToMany(type => User, user => user.roles, {\r\n        cascadeInsert: true,\r\n        cascadeUpdate: true\r\n    })\r\n    users: User[]; \r\n    @OneToMany(type => RoleClaim, roleClaim => roleClaim.role, {\r\n        cascadeInsert: true,\r\n        cascadeUpdate: true\r\n    })\r\n    claims: RoleClaim[];\r\n}\r\n\r\n@Entity()\r\nexport class RoleClaim extends BaseEntity {\r\n\r\n    @Column({ nullable: false })\r\n    claimType: string;\r\n\r\n    @Column({ nullable: false })\r\n    claimValue: string;\r\n\r\n    @ManyToOne(type => Role, role => role.claims, {\r\n        cascadeInsert: true,\r\n        cascadeUpdate: true,\r\n        cascadeRemove: true\r\n    })\r\n    role: Role;\r\n}\r\n```"
    },
    "satisfaction_conditions": [
      "Query must respect tenant isolation",
      "Pagination parameters (limit and offset) must be properly applied",
      "Query must return both the results and total count",
      "Join relationship must respect the entity relationships defined in the schema"
    ],
    "created_at": "2017-07-09T11:34:50Z"
  },
  {
    "id": "https://github.com/typeorm/typeorm/issues/581",
    "source": {
      "issue_number": 581
    },
    "initial_question": {
      "title": "QueryBuilder Update seems to generate incorrect SQL statement for MSSQL",
      "body": "QueryBuilder's update() seems to generate:\r\n\r\nUPDATE Table1 Alias SET Column1=\"Value1\" ...\r\n\r\nWhereas I think MSSQL only accepts:\r\n\r\nUPDATE Alias SET Column1=\"Value1\" FROM Table1 Alias ...\r\n"
    },
    "satisfaction_conditions": [
      "Generated SQL syntax must be compatible with MSSQL UPDATE statement requirements",
      "Query must maintain the intended table aliasing functionality",
      "QueryBuilder API must remain functional for basic update operations"
    ],
    "created_at": "2017-06-26T20:51:16Z"
  },
  {
    "id": "https://github.com/typeorm/typeorm/issues/580",
    "source": {
      "issue_number": 580
    },
    "initial_question": {
      "title": "OneToMany with where clause?",
      "body": "So I have two entities that are relevant for this. They are `Organization` and `Group`\r\n\r\n```\r\n@Entity()\r\nexport class Organization extends EntityModel {\r\n    @PrimaryGeneratedColumn()\r\n    id: number;\r\n\r\n    @Column()\r\n    name: string;\r\n\r\n    @OneToMany(type => Group, group => group.organization, { cascadeInsert: true, cascadeUpdate: true })\r\n    groups: Group[];\r\n}\r\n```\r\n\r\n```\r\n@Entity()\r\nexport class Group extends EntityModel {\r\n    @PrimaryGeneratedColumn()\r\n    id: number;\r\n\r\n    @Column()\r\n    name: string;\r\n\r\n    @ManyToOne(type => Group, group => group.subgroups, { cascadeUpdate: true })\r\n    @JoinColumn()\r\n    parent: Group;\r\n\r\n    @OneToMany(type => Group, group => group.parent, { cascadeInsert: true, cascadeUpdate: true })\r\n    subgroups: Group[];\r\n\r\n    @ManyToOne(type => Organization, organization => organization.groups, { cascadeUpdate: true, onDelete: \"SET NULL\" })\r\n    @JoinColumn()\r\n    organization: Organization;\r\n}\r\n```\r\n\r\nAnd this works great! But my issue here is that I am trying to do something that MAY not be supported. Let me know if I've just missed the functionality. If the functionality does not exist then I guess this is a feature request.. \r\n\r\nI have it set up so that a `Group` can contain many `Group`s and each `Group` can have a parent which is a `Group` as well. So I want all groups to have an `Organization` but an organization should only have an array of groups that have that `Organization` as their `Organization`, but **NOT** have any parent group. Does this make sense? \r\n\r\n<hr>\r\n\r\nIn other words, I have the following:\r\n\r\n`Organization`\r\n<table>\r\n<tr><th>id</th><th>name</th></tr>\r\n<tr><td>1</td><td>Org 1</td></tr>\r\n<tr><td>2</td><td>Org 2</td></tr>\r\n</table>\r\n\r\n\r\n`Group`\r\n<table>\r\n<tr><th>id</th><th>name</th><th>parentId</th><th>organizationId</th></tr>\r\n<tr><td>1</td><td>Group 1</td><td>NULL</td><td>1</td></tr>\r\n<tr><td>2</td><td>Group 2</td><td>1</td><td>1</td></tr>\r\n<tr><td>3</td><td>Group 3</td><td>NULL</td><td>2</td></tr>\r\n<tr><td>4</td><td>Group 4</td><td>NULL</td><td>2</td></tr>\r\n</table>\r\n</body>\r\n</html>\r\n\r\n<hr>\r\n\r\nWhen I execute the following:\r\n```\r\nOrganization\r\n.createQueryBuilder(\"organization\")\r\n.leftJoinAndSelect(\"organization.groups\", \"groups\")\r\n.getMany()\r\n.then(organizations => {\r\n      // Do stuff with organizations here\r\n      // organizations should contain 2 values\r\n\r\n      // organizations[0] will be \"Org 1\" \r\n      // organizations[0].group will contain \"Group 1\" and \"Group 2\" but I want it to only contain \"Group 1\"\r\n\r\n      // organizations[1] will be \"Org 2\"\r\n      // organizations[1].group will contain \"Group 3\" and \"Group 4\" as desired\r\n});\r\n```\r\n\r\nMaybe that makes more sense. :)\r\n\r\nSo how could I achieve this? Basically I need to be able to create a `where` clause on the `inverseSide` of `OneToMany`"
    },
    "satisfaction_conditions": [
      "Query returns only top-level groups (groups without parents) for each organization",
      "Organization-to-Group relationship remains intact in the data model",
      "Query results maintain proper organization-group associations",
      "Solution works within the ORM's relationship mapping system"
    ],
    "created_at": "2017-06-26T20:01:54Z"
  },
  {
    "id": "https://github.com/typeorm/typeorm/issues/544",
    "source": {
      "issue_number": 544
    },
    "initial_question": {
      "title": "groupBy() and getCount() cannot be used at the same time",
      "body": "During my development, I found there is literally no way to count the number of kinds of data in a query with Typeorm. The getCount wiil return the fist value of groupBy(). For example, if we have 9 fruits in the db, 4 apples, 3 bananas, and 2 cherries. The getCount after groupBy will return us 4 coz we have 4 apples. Any idea?"
    },
    "satisfaction_conditions": [
      "Query returns correct count of distinct grouped items",
      "Works with GROUP BY operations",
      "Returns numeric count value",
      "Maintains compatibility with existing TypeORM query builder",
      "Handles pagination scenarios correctly"
    ],
    "created_at": "2017-06-15T02:26:52Z"
  },
  {
    "id": "https://github.com/typeorm/typeorm/issues/539",
    "source": {
      "issue_number": 539
    },
    "initial_question": {
      "title": "Allow manual rollback or commit of transaction",
      "body": ""
    },
    "satisfaction_conditions": [
      "Transaction state must be explicitly controlled",
      "Database connection resources must be properly managed",
      "Transaction operations must be atomic"
    ],
    "created_at": "2017-06-14T01:51:23Z"
  },
  {
    "id": "https://github.com/typeorm/typeorm/issues/506",
    "source": {
      "issue_number": 506
    },
    "initial_question": {
      "title": "Schema sync/drop in 0.1.0-alpha.3",
      "body": "I've got some problems with typeorm@0.1.0-alpha.3:\r\n\r\n`typeorm schema:sync`\r\n\r\n`UnhandledPromiseRejectionWarning: Unhandled promise rejection (rejection id: 1): TypeError: this.metadataArgsStorage.filterTables is not a function`\r\n\r\nThe same issue with `schema:drop` command.\r\nnodejs: v6.10.3\r\nenv: windows 10 x64\r\nserver: PostgreSQL 9.4.11 on x86_64-unknown-linux-gnu, compiled by gcc (Debian 4.9.2-10) 4.9.2, 64-bit\"\r\n\r\nBy the way: where can i find the information about debug way for typeorm cli commands?\r\nThanks."
    },
    "satisfaction_conditions": [
      "Configuration file must contain valid connection options in array format",
      "Configuration is compatible with the installed TypeORM version"
    ],
    "created_at": "2017-05-31T14:38:02Z"
  },
  {
    "id": "https://github.com/typeorm/typeorm/issues/461",
    "source": {
      "issue_number": 461
    },
    "initial_question": {
      "title": "Use ManyToMany decorator alongside with PrimaryGeneratedColumn",
      "body": "Let's say I have 3 classes / tables : 'Artist', 'Artwork' and 'Tag'. \r\nArtist and Artwork both have a ManyToMany relation with Tag. What I'd like to do is the following : \r\n\r\n```\r\nclass Tag {\r\n    @PrimaryGeneratedColumn()\r\n    @ManyToMany(type => Artwork, artwork => artwork.tags)\r\n    @ManyToMany(type => Artist, artist => artist.tags)\r\n    id: number;\r\n} \r\n```\r\n\r\n```\r\nclass Artwork {\r\n    @PrimaryGeneratedColumn()\r\n    id: number;\r\n   \r\n    @ManyToMany(type => Tag, tag => tag.id, {\r\n        cascadeInsert: true\r\n    })\r\n    @JoinTable()\r\n    public tags: Tag[];\r\n  \r\n}\r\n```\r\n\r\n```\r\nclass Artist {\r\n    @PrimaryGeneratedColumn()\r\n    id: number;\r\n   \r\n    @ManyToMany(type => Tag, tag => tag.id, {\r\n        cascadeInsert: true\r\n    })\r\n    @JoinTable()\r\n    public tags: Tag[];\r\n    \r\n}\r\n```\r\n\r\nCurrently, it doesn't seem to work: tags are created but relationship between Tag and Artwork / Artist is not saved in 'join' table . How could I manage to setup such a mechanism without having to implement 2 specific Tag classes (one for each class) ? \r\n\r\nBy the way I'm using @next version of typeorm with mysql-driver.\r\n\r\nThank you and keep up the good work !\r\n"
    },
    "satisfaction_conditions": [
      "Many-to-many relationships must be properly bidirectional",
      "Join tables must be created and populated correctly",
      "Single Tag entity must support multiple relationships"
    ],
    "created_at": "2017-05-09T12:59:05Z"
  },
  {
    "id": "https://github.com/typeorm/typeorm/issues/449",
    "source": {
      "issue_number": 449
    },
    "initial_question": {
      "title": "Event subscribers not affecting abstract entities",
      "body": "Tried to create a new abstract entity with created_at and updated_at to be automatically update on change, it's not working, only if I put the columns in the entity itself.\r\n\r\nbtw, is there any built in soft deletes?"
    },
    "satisfaction_conditions": [
      "Abstract entity must be properly registered in configuration",
      "Timestamp fields (created_at, updated_at) must update automatically when configured correctly",
      "Soft delete functionality requires explicit query conditions"
    ],
    "created_at": "2017-05-02T20:34:13Z"
  },
  {
    "id": "https://github.com/typeorm/typeorm/issues/427",
    "source": {
      "issue_number": 427
    },
    "initial_question": {
      "title": "delete via join",
      "body": "Hi,\r\n\r\nI'm trying to delete via join, though with postgres join doesn't work with delete.\r\n\r\nwith this query (assuming `Account` <-> `Project` as 1:many join):\r\n\r\n```\r\nconn.getRepository(Project)\r\n  .createQueryBuilder('p')\r\n  .innerJoin('p.account = account', 'account')\r\n  .where('account.accountId = :accountId', { accountId: 'test' })\r\n  .delete();\r\n```\r\nit generates the following SQL:\r\n\r\n```\r\nDELETE FROM \"projects\" INNER JOIN \"accounts\" \"account\" ON \"account\".\"account_id\"=\"p\".\"account_id\" WHERE \"account\".\"name\" = 'test';\r\n```\r\n\r\nWhich causes postgres to throw the following error:\r\n\r\n```\r\nLINE 1: DELETE FROM \"projects\" INNER JOIN \"accounts\" \"account\" ON \"a...\r\n```\r\n\r\nIt looks like the alias `p` isn't used in the query generation, also, the way to make inner join work for postgres is via `using <alias>`, as follows:\r\n\r\n```\r\nDELETE FROM \"projects\" *USING \"projects\" AS \"p\"* INNER JOIN \"accounts\" \"account\" ON \"account\".\"account_id\"=\"p\".\"account_id\" WHERE \"account\".\"name\" = 'test';\r\n```\r\n\r\nThis can certainly be me not knowing how to use the query builder correctly. Can anyone help verify if I need a different query or if this is not implemented at this time?\r\n\r\nThanks.\r\n"
    },
    "satisfaction_conditions": [
      "Records from the Project table must be deleted based on a related Account condition",
      "All matching Project records must be correctly identified and removed",
      "Data integrity must be maintained during deletion",
      "Operation must be achievable through TypeORM"
    ],
    "created_at": "2017-04-27T23:04:37Z"
  },
  {
    "id": "https://github.com/typeorm/typeorm/issues/355",
    "source": {
      "issue_number": 355
    },
    "initial_question": {
      "title": "InnerjoinAndSelect returns undefined",
      "body": "Hello,\r\n\r\nI have a many to one relation. Every photo has one photoCollectionId and photoCollection and every PhotoCollection has an array of Photo. Now I want to load a collection with its photos:\r\n```typescript\r\n let collection = await this.collectionRepository.findOneById(id\r\n        , {\r\n          alias: \"collection\",\r\n          innerJoinAndSelect: {\r\n            \"photos\": \"collection.photos\"\r\n          }\r\n        });\r\n```\r\nWhen there is no photo related to the collection this returns undefined. However, if there is a related photo, it works as expected. \r\n\r\nFor now I have worked around the issue like this:\r\n```typescript\r\n@Get(\"/:id/photos\")\r\n  async getOne( @Param(\"id\") id: number) {\r\n    let photo = await this.photoRepository.findOne({ photoCollectionId: id });\r\n    if (photo) {\r\n      let collection = await this.collectionRepository.findOneById(id\r\n        , {\r\n          alias: \"collection\",\r\n          innerJoinAndSelect: {\r\n            \"photos\": \"collection.photos\"\r\n          }\r\n        });\r\n      console.log(collection);\r\n      return collection;\r\n    }\r\n    else {\r\n      let collection = await this.collectionRepository.findOneById(id);\r\n      console.log(collection);\r\n      return collection;\r\n    }\r\n  }\r\n```\r\n\r\nHowever, this is probably not how it should be I suppose. Is there a better/easier way to do this?"
    },
    "satisfaction_conditions": [
      "Query returns collection with photos when photos exist",
      "Maintains proper relationship mapping between collections and photos"
    ],
    "created_at": "2017-03-19T15:15:33Z"
  },
  {
    "id": "https://github.com/typeorm/typeorm/issues/351",
    "source": {
      "issue_number": 351
    },
    "initial_question": {
      "title": "execute migrations through code",
      "body": "Is there a way to execute migrations through my code?"
    },
    "satisfaction_conditions": [
      "Migrations can be programmatically triggered",
      "Migration execution is controllable from application code"
    ],
    "created_at": "2017-03-16T15:58:39Z"
  },
  {
    "id": "https://github.com/typeorm/typeorm/issues/303",
    "source": {
      "issue_number": 303
    },
    "initial_question": {
      "title": "Connection pooling doesn't really pool connections",
      "body": "It looks like when you create a connection and have connection pooling on type orm creates a \"pool of 1 connection\", and then when you close the connection type orm ends the pool.  Ideally what we want to do is create a pool of 50 connections in our web api that type orm re-uses across requests.  I'm new to type orm.  Hopefully I'm just missing some way to configure this."
    },
    "satisfaction_conditions": [
      "Connection pool remains active throughout application lifecycle",
      "Multiple simultaneous requests can be processed without connection conflicts",
      "Connection pool manages multiple real database connections",
      "Pool size is configurable",
      "Single connection instance manages multiple database connections"
    ],
    "created_at": "2017-02-22T00:41:50Z"
  },
  {
    "id": "https://github.com/typeorm/typeorm/issues/294",
    "source": {
      "issue_number": 294
    },
    "initial_question": {
      "title": "Troubles with UglifyJS",
      "body": "I use webpack and babel. I pass imported models to the connectionConfig. When I build the app for production with UglifyJsPlugin, an error occurs: `ER_NO_SUCH_TABLE: Table 'posts-app.e' doesn't exist`. How to avoid it without disabling the plugin? I found only one way: pass such options: ```  mangle: {\r\n    except: ['Post','User']\r\n  } ```"
    },
    "satisfaction_conditions": [
      "Database table names must correctly match entity references after code minification",
      "Code minification process must not interfere with database entity naming",
      "Application must successfully build in production mode",
      "Entity-to-table name resolution remains consistent between development and production environments"
    ],
    "created_at": "2017-02-17T21:51:17Z"
  },
  {
    "id": "https://github.com/typeorm/typeorm/issues/238",
    "source": {
      "issue_number": 238
    },
    "initial_question": {
      "title": "How to save an int value to a foreign key ",
      "body": "In the `Post` table, there is a one-to-one foreign key on `user_id` which links to the table `Members`, there is no problem with fetching the data like this:\r\n\r\n`[{ \"post_id\":1,\"user_id\":{\"user_name\":'Someone','user_id':4}, 'comment':'xxxxxx'}]`\r\n\r\nSuppose someone makes a comment, I get his comment and user id from express session, and want to save it to the `Post` table. Since `user_id` uses `Members` type, how can I save an int value to it? \r\nWould you please suggest a solution?\r\n\r\nHere's an example:\r\n\r\n````\r\n@Table()\r\nexport class Post {\r\n    @PrimaryGeneratedColumn()\r\n    post_id: number;\r\n\r\n    @OneToOne(type => Members,entity=>entity.user_id,{\r\n        cascadeRemove: true\r\n    })\r\n    @JoinColumn()\r\n    user_id: Members;\r\n\r\n    @Column()\r\n    comment:string;\r\n}\r\n\r\nexport class Members {\r\n    @PrimaryGeneratedColumn()\r\n    user_id: number;\r\n\r\n    @Column()\r\n    user_name:string;\r\n}\r\n````\r\n\r\n````\r\n    let post = new Post()\r\n    post.comment = \"sadsadsa\"\r\n    post.user_id = 44 <<=== type error!\r\n````\r\n\r\n"
    },
    "satisfaction_conditions": [
      "Foreign key relationship between Post and Members tables must be maintained",
      "Post creation must accept a user identifier as input",
      "Data model must preserve all required fields from both Post and Members entities",
      "TypeScript type safety must be maintained"
    ],
    "created_at": "2017-01-26T09:55:18Z"
  },
  {
    "id": "https://github.com/typeorm/typeorm/issues/186",
    "source": {
      "issue_number": 186
    },
    "initial_question": {
      "title": "Single file @Table definition order is important",
      "body": "It is worth nothing, that if you define all of your Entities (i.e. @Table classes) in a single file, that the order is important. If you reference a Entity as part of a relation (i.e. @OneToOne) before that referenced Entity is defined, you'll receive an error like below:\r\n\r\n```\r\n/Users/Danijel/projects/am/am-api/lib/model/model.js:175\r\n[1]     __metadata(\"design:type\", StoreBillingPlan)\r\n[1]                               ^\r\n[1]\r\n[1] ReferenceError: StoreBillingPlan is not defined\r\n[1]     at Object.<anonymous> (/Users/x/projects/am/am-api/lib/model/model.js:175:31)\r\n[1]     at Module._compile (module.js:571:32)\r\n[1]     at Object.Module._extensions..js (module.js:580:10)\r\n[1]     at Module.load (module.js:488:32)\r\n[1]     at tryModuleLoad (module.js:447:12)\r\n[1]     at Function.Module._load (module.js:439:3)\r\n[1]     at Module.require (module.js:498:17)\r\n[1]     at require (internal/module.js:20:19)\r\n[1]     at Object.<anonymous> (/Users/x/projects/am/am-api/lib/services/auth.js:10:17)\r\n[1]     at Module._compile (module.js:571:32)\r\n```\r\n\r\nIn my case, defining StoreBillingPlan before the above code was run solved my issue.  Is it possible to make order not important? \r\n\r\nNote: For those splitting Entities across files this shouldn't be an issue. "
    },
    "satisfaction_conditions": [
      "Referenced entities must be defined before they are used in decorators/annotations",
      "Code compilation/execution completes without reference errors",
      "Solution works within JavaScript's lexical scoping rules"
    ],
    "created_at": "2017-01-10T05:24:30Z"
  },
  {
    "id": "https://github.com/typeorm/typeorm/issues/142",
    "source": {
      "issue_number": 142
    },
    "initial_question": {
      "title": "innerJoinAndSelect with no matching rows results in rejected promise",
      "body": "Hi,\r\n\r\nThere's a OneToMany relation between \"ent\" (one) and \"some_stuff\" (many).\r\n\r\nI'm doing something similar to this:\r\n\r\n```\r\nentRepository.createQueryBuilder('ent')\r\n\t.innerJoinAndSelect('ent.some_stuff', 'some_stuff')\r\n\t.getOne();\r\n```\r\n\r\nWhenever some_stuff has corresponding rows for ent, it works.\r\nWhenever there're no corresponding rows for ent, the promise is rejected.\r\n\r\nHow can I simply have some_stuff set to an empty array in ent whenever there're no corresponding rows instead of having the promise rejected?"
    },
    "satisfaction_conditions": [
      "Query returns ent entity when no matching some_stuff records exist",
      "Query result maintains the defined entity relationship structure"
    ],
    "created_at": "2016-12-22T22:40:54Z"
  }
]