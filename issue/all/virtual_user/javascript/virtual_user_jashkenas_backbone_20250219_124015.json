[
  {
    "id": "https://github.com/jashkenas/backbone/issues/3608",
    "source": {
      "issue_number": 3608
    },
    "initial_question": {
      "title": "modelId getter doesn't work with polymorphic Model getter",
      "body": "I think i found a bug inside the 1.2.0 version. My Collection contains different Models, so i've used a getter to solve this.\n\n```\nnew Collection(\n   model: function(attrs){\n      if (attrs.foo) {\n          return new FooModel(attrs);\n      }\n      else {\n         return new BarModel(attrs);\n      }\n   }\n)\n```\n\nafter upgrading i had some trobles with my app because the collection couldnt find already exsiting models inside of it `collection.get(1) # => undefined`. So I've digged into the source and found this \"bug\".\n`this.model` isn't always a Model it can be function sometimes. \n\n```\n    modelId: function (attrs) {\n      return attrs[this.model.prototype.idAttribute || 'id'];\n    },\n```\n\nSo I think everybody who is using a function in `this.model` and has a custom idAttribute defined, backbone won't find already existing models.\n\n```\n  modelId: function (attrs, options) {\n    return this.model(attrs, options).id;\n  },\n```\n\nThis is the overridden function i'm using inside my collection now, and it works for me.\nSo maybe the `modelId` function needs something like this:\n\n```\n  if (_.isFunction(this.model)) { \n    return this.model(attrs, options).id;\n  } \n  else {\n    return attrs[this.model.prototype.idAttribute || 'id'];\n  }\n```\n"
    },
    "satisfaction_conditions": [
      "Model ID resolution must work without requiring full model instantiation"
    ],
    "created_at": "2015-05-15T14:38:03Z"
  },
  {
    "id": "https://github.com/jashkenas/backbone/issues/3557",
    "source": {
      "issue_number": 3557
    },
    "initial_question": {
      "title": "Router.execute doesn't return anything",
      "body": "If the route callback returns false, a route event is not supposed to be fired. i.e.\n`if (router.execute(callback, args, name) !== false) {//trigger 'route' event...}`\n\nHowever, execute() doesn't actually return the callback functions return value:\n`if (callback) callback.apply(this, args);`\n\nShouldn't this be:\n`if (callback) return callback.apply(this, args);`\n\nIs this by design, or am I missing something?\n"
    },
    "satisfaction_conditions": [
      "Router.execute() must not propagate the callback's return value",
      "Router.execute() must support custom override functionality"
    ],
    "created_at": "2015-04-04T17:49:38Z"
  },
  {
    "id": "https://github.com/jashkenas/backbone/issues/3230",
    "source": {
      "issue_number": 3230
    },
    "initial_question": {
      "title": "events selector by name or complex id names",
      "body": "I have an input with this complex name:\n\n``` html\n<input ... name=\"bic_voucher_entitybundle_company[name]\" id=\"bic_voucher_entitybundle_company[name]\" >\n```\n\nThe problem comes when I want to assign this name or id to an event:\n\n``` js\n        events: {\n            'click #bic_voucher_entitybundle_company[name]': 'limitLength',\n            'click [name=\"bic_voucher_entitybundle_company[name]\"]': 'limitLength',\n```\n\nBoth do not work.\n"
    },
    "satisfaction_conditions": [
      "Event selector successfully matches the input element with complex name/id containing brackets",
      "JavaScript event binding executes without syntax errors"
    ],
    "created_at": "2014-07-21T10:36:07Z"
  },
  {
    "id": "https://github.com/jashkenas/backbone/issues/3166",
    "source": {
      "issue_number": 3166
    },
    "initial_question": {
      "title": "Backbone's View constructor is adding a call to this.delegateEvents in the min version and the dev version is not",
      "body": "```\nvar View = Backbone.View = function(options) {\n        this.cid = _.uniqueId('view');\n        options || (options = {});\n        _.extend(this, _.pick(options, viewOptions));\n        this._ensureElement();\n        this.initialize.apply(this, arguments);\n};\n\nvar w = e.View = function (t) {\n        this.cid = i.uniqueId(\"view\");\n        t || (t = {});\n        i.extend(this, i.pick(t, E));\n        this._ensureElement();\n        this.initialize.apply(this, arguments);\n        this.delegateEvents()\n};\n```\n"
    },
    "satisfaction_conditions": [
      "Events must be properly delegated for inherited/abstract views",
      "No duplicate event delegation calls should occur",
      "Existing codebases must have a migration path",
      "Version differences must be clearly documented"
    ],
    "created_at": "2014-05-28T03:34:11Z"
  },
  {
    "id": "https://github.com/jashkenas/backbone/issues/3050",
    "source": {
      "issue_number": 3050
    },
    "initial_question": {
      "title": "Control over PUT vs POST for models with supplied IDs",
      "body": "``` javascript\n\nvar UserModel = Backbone.Model.extend({\n    idAttribute: \"username\",\n    urlRoot: \"/userapi\"\n});\n\nvar newUser = new UserModel();\nnewUser.set('username','v0idnull');\nnewUser.save();\n```\n\nI can not create a new user with this code.\n\nBackbone makes the assumption that whatever API you are calling, the unique identifier for resource you're manipulating is generated on creation. But this is not always the case. In this above example, the unique identifier is the username, and so the ID is provided.\n\nBut that code will always try to do a PUT request on /userapi/v0idnull and it will always fail with a 404.\n\nI think there are many different ways of solving this, from providing create() and update() methods on the model (that save() can use), to changing\n\n``` javascript\nmethod = this.isNew() ? 'create' : (options.patch ? 'patch' : 'update');\n```\n\nto exposing the method through the options hash of the save() method:\n\n``` javascript\nmethod = options.method ? options.method : (this.isNew() ? 'create' : (options.patch ? 'patch' : 'update');\n```\n\nWith a change like this, I can do one of two things:\n\nMy application is aware of when I'm creating a user and when I'm updating a user and call the appropriate method / set the appropriate option\n\nOR\n\nI call save normally which tries a PUT, gets a 404, and an error handler tries save again, forcing a POST.\n\nThoughts?\n"
    },
    "satisfaction_conditions": [
      "The solution must maintain proper REST API interaction",
      "The system must handle the custom idAttribute correctly",
      "The solution must be compatible with Backbone's save() operation"
    ],
    "created_at": "2014-03-07T14:51:55Z"
  },
  {
    "id": "https://github.com/jashkenas/backbone/issues/3033",
    "source": {
      "issue_number": 3033
    },
    "initial_question": {
      "title": "Accessing view options during `el` construction",
      "body": "Hi,\n\n`View#options` has been removed since Backbone 1.1.0, and the usual recommandation is to set it ourselves if we need to inside the initialize constructor. That's what we're doing currently.\n\nHowever, we have a few views with this kind of pattern :\n\n``` js\nPopupView.extend( {\n\n    el : function ( ) {\n        return Templates.get( 'popups/upload/settings', {\n            filename : this.options.filename\n        } );\n    }\n\n} );\n```\n\nAs you can see, the root element constructor is currently requiring the options to be functional. Since the initialize constructor is only called after creating the node, it fails.\n\nFor what it worth, this error can be somewhat fixed by overloading the entire `View` constructor :\n\n``` js\nvar View = ( function ( ) {\n\n    var View = function ( options ) {\n        this.options = options;\n        Backbone.View.apply( this, arguments );\n    };\n\n    var F = function ( ) { };\n    F.prototype = Backbone.View.prototype;\n    View.prototype = new F( );\n\n    return View;\n\n} ( ) );\n```\n\nBut I think we agree to say that it's not the best code snippet ever :)\n\nWhat do you think of this issue ? Should it be solved ?\n"
    },
    "satisfaction_conditions": [
      "View options must be accessible during element creation/configuration",
      "Solution must maintain Backbone's view inheritance chain",
      "View initialization order must remain intact",
      "View options must persist throughout the view lifecycle",
      "Solution must work with dynamic element properties"
    ],
    "created_at": "2014-03-03T14:07:02Z"
  },
  {
    "id": "https://github.com/jashkenas/backbone/issues/2809",
    "source": {
      "issue_number": 2809
    },
    "initial_question": {
      "title": "collection's 'create' method seems to need 'index' option.",
      "body": "While collection's 'add' method supports 'index' option,\nbut 'create' method doesn't seem to support it. \nIs there any way to set the index position when creating a model in collection?\nIf no, it seems to need 'index' option.\n"
    },
    "satisfaction_conditions": [
      "Model must be inserted at a specified position in the collection",
      "Model must be successfully created while specifying its position",
      "Solution must work within the collection's create operation context"
    ],
    "created_at": "2013-10-15T05:16:22Z"
  },
  {
    "id": "https://github.com/jashkenas/backbone/issues/2754",
    "source": {
      "issue_number": 2754
    },
    "initial_question": {
      "title": "collection.on(\"myevent\") original model?",
      "body": "Hi guys,\n\nIs there any way I can get the original model who trigger an event inside a collection without having to passing it ?\n\n``` javascript\nvar collection = new Backbone.Collection();\nvar myModel = new Backbone.Model({});\ncollection.add(myModel);\nmyModel.trigger(\"foo\", 42);\n// ...\ncollection.on(\"foo\", function (number) {\n  // how can I get the original model object here?\n});\n```\n\nThis is a limitation I experiment on different projects, Is there an existing way to get that model without having to pass it at the trigger time?\n\nThe workaround of this I found is quite boring:\nsomething like:\n\n``` javascript\nfunction bindModel (model) {\n  model.on(\"foo\", function (number) {\n    // model in the scope\n  });\n}\nfunction unbindModel (model) {} // erf need to keep somewhere the original reference of the bound function...\ncollection.each(bindModel);\ncollection.on(\"add\", bindModel);\ncollection.on(\"remove\", unbindModel);\n```\n"
    },
    "satisfaction_conditions": [
      "Access to triggering model instance must be available in collection event handler",
      "Event handling must maintain proper model-collection relationship"
    ],
    "created_at": "2013-09-10T15:21:14Z"
  },
  {
    "id": "https://github.com/jashkenas/backbone/issues/2739",
    "source": {
      "issue_number": 2739
    },
    "initial_question": {
      "title": "Problem with parse and create",
      "body": "I want to add a model to a collection and immediately trigger the 'add' event so that a view is instantly rendered.\n\nHowever, I also want it to be persisted and saved as well.\n\nI do not want to wait for save to return before add is triggered.\n\nAll of this should be fine, except that I have data in the model that needs to be created on parse.  An example is a url to a map whose value is dependent on the client's browser type.\n\nIf I call `collection.create(model)`, the model will be added to the collection, parsed, then saved.\n\nThe problem is that I want that parsing to be done, but I don't want that parsed data to be saved to the server.\n\nI can fix this by doing `collection.create(model, {wait: true})`, but then there is a delay from when the model is created until the view is rendered.\n\nAny ideas on this?  Essentially I want the data created in `parse` in the model to never be persisted to the server, just accessed locally.\n"
    },
    "satisfaction_conditions": [
      "Model must be added to collection and trigger 'add' event immediately",
      "Model must be persisted to server without browser-specific data",
      "Browser-specific data must be available locally after parsing",
      "No delay between model creation and view rendering",
      "Parsed data must not interfere with server persistence"
    ],
    "created_at": "2013-08-30T06:24:22Z"
  },
  {
    "id": "https://github.com/jashkenas/backbone/issues/2722",
    "source": {
      "issue_number": 2722
    },
    "initial_question": {
      "title": "couldn't pass string as an argument to Backbone View",
      "body": "e.g. new MyView(\"Hello\");\nTypeError: invalid 'in' operand n\nBackbone version: 1.0.0\n\nThrows the above javascript error from Underscore.js, on passing string as an argument to backbone view. Accepts only object. Worked for Version 0.9.2, but not 1.0.0.\n"
    },
    "satisfaction_conditions": [
      "View constructor must receive an object parameter",
      "Code maintains compatibility with Backbone 1.0.0 specifications"
    ],
    "created_at": "2013-08-14T13:47:09Z"
  },
  {
    "id": "https://github.com/jashkenas/backbone/issues/2580",
    "source": {
      "issue_number": 2580
    },
    "initial_question": {
      "title": "Options no longer accessible in Views",
      "body": "I recently upgraded from 0.9.9 to 1.0. \n\nIt seems that in version 1.0, the options object on a view is no longer existing.\n\nAny code within a view that tries to access this.options.property always fails and this.options is always undefined.\n\nI am using Underscore 1.4.3 and also tried 1.4.4 with no difference. Rolling back to Backbone 0.9.9 makes everything work again.\n"
    },
    "satisfaction_conditions": [
      "Compatibility with Underscore 1.4.x maintained"
    ],
    "created_at": "2013-05-31T14:50:09Z"
  },
  {
    "id": "https://github.com/jashkenas/backbone/issues/2532",
    "source": {
      "issue_number": 2532
    },
    "initial_question": {
      "title": "Router: Query Parameters are being ignored when using pushState but not when using hashChange.",
      "body": "Since Backbone 1.0.0 the router ignores all the query parameters sent as ?something=something when using the pushState mode, but when using the hashChange mode (on pushState incompatible browsers, such as IE 9) the query strings are not ignored and when they are sent, they won't match any route.\n\neg.\nroute: 'books/backbone'\n\nurl: '#books/backbone?utm_source=twitter'\n\nThe url does not match the route because it has query strings in it.\n"
    },
    "satisfaction_conditions": [
      "Query parameters must be correctly processed based on URL structure",
      "Dynamic URL updates must maintain proper route matching",
      "Parameter changes must be reflected in browser URL state"
    ],
    "created_at": "2013-05-14T14:06:06Z"
  },
  {
    "id": "https://github.com/jashkenas/backbone/issues/2510",
    "source": {
      "issue_number": 2510
    },
    "initial_question": {
      "title": "Model.save() with options and no key/val",
      "body": "Using backbone 1.0.0.\n\nI have not been able to figure out how to call Model.save and pass options (success, error) and have it skip the key/val logic.\n\nWhat I've done for now is override Model.save changing the following line (50) in from:\n      if (key == null || typeof key === 'object') {\nTo:\n      if (key === null || typeof key === 'object') {\n\nThis allows me to call save as Model.save(undefined, undefined, {succes: mySuccess, error: myError}); and not have the options wiped out in the parameter logic of save.\n\nMaybe there is another way around this but I was unable to find it.\n"
    },
    "satisfaction_conditions": [
      "Model.save() method must accept options parameters without requiring key/value data",
      "Success and error callbacks in options must be properly preserved",
      "Method call syntax must be valid within Backbone 1.0.0's parameter handling"
    ],
    "created_at": "2013-05-01T19:49:21Z"
  },
  {
    "id": "https://github.com/jashkenas/backbone/issues/2474",
    "source": {
      "issue_number": 2474
    },
    "initial_question": {
      "title": "Pass all $.ajax options for fetch, save, and destroy",
      "body": "It seems like success and error callbacks are the only options passed to $.ajax. What is the benefit of this? I'm finding it very hard to add a custom header to a single API call because the only thing that has worked so far is $.ajaxSetup, but then the custom header is added to every subsequent API call. Is there an easier way to add a custom header for a single ajax call?\n"
    },
    "satisfaction_conditions": [
      "Custom AJAX options can be applied to individual API calls",
      "Custom headers can be set for a single request without persisting to subsequent calls",
      "The solution works with Backbone's fetch/save/destroy methods",
      "Configuration options are passed through to the underlying AJAX implementation"
    ],
    "created_at": "2013-04-11T19:24:28Z"
  },
  {
    "id": "https://github.com/jashkenas/backbone/issues/2349",
    "source": {
      "issue_number": 2349
    },
    "initial_question": {
      "title": "delegating events on inherited views",
      "body": "I have a BaseView which defines some events delegation specifying an events hash.\n\nThen I have a CustomView (extending BaseView) that also defines their own events, by also specifying an event hash.\n\nIf I'm not wrong, BaseView's event hash is overwritten, so theirs events are not processed by delegateEvent.\n\nThe documentation says to use an events function instead of a hash to handle this case.\n\nI solved it with something like this:\n\non the parent's render method I mix the parent's events with those from the child\n\n``` javascript\n    this.delegateEvents(_.merge(this.events, {\n      'show .accordion': 'collapsePanelGroup',\n      'hide .accordion': 'collapsePanelGroup'\n    }));\n```\n\nI guess this could be a pretty common scenario, so I was wondering if it's worth the effort to add something like this to delegateEvents:\n\n``` javascript\ndelegateEvents: function(events, preserve) {\n```\n\nPassing a preserve = true, would just add this.events to events and then process, or maybe define some addEvent method\n\nWhat would be the most appropriate to hadle this scenario?\n"
    },
    "satisfaction_conditions": [
      "Child view must be able to handle both its own events and parent view events simultaneously",
      "Event handling must maintain proper inheritance hierarchy",
      "Event bindings must be properly delegated to DOM elements",
      "Solution must work within Backbone's event delegation system"
    ],
    "created_at": "2013-03-08T14:40:31Z"
  },
  {
    "id": "https://github.com/jashkenas/backbone/issues/2229",
    "source": {
      "issue_number": 2229
    },
    "initial_question": {
      "title": "sync event firing",
      "body": "I want an event like 'sync' to be triggered before the success function so that I can bind the event in the success function without it being executed right away\n"
    },
    "satisfaction_conditions": [
      "Error cases must not trigger the event",
      "Event binding must be possible during initialization"
    ],
    "created_at": "2013-01-31T21:33:18Z"
  },
  {
    "id": "https://github.com/jashkenas/backbone/issues/2225",
    "source": {
      "issue_number": 2225
    },
    "initial_question": {
      "title": "'Fetch' can't be bound to a 'change' event",
      "body": "Hi,\n\nI have a collection that listens to changes in a model to then update itself, like this:\n\n```\nthis.listenTo(this.user, \"change:addresses\", this.fetch);\n```\n\nAnd it was getting back the user's own data, instead of the expected. After some probing I figured that `change` events pass `(model, value, options)` to the callbacks, which in this case meant `sync` was eventually getting the user model as it's `option` param.\n\nThe user model has its own url, and 8478567 means it is then overriding the collection's url for the request.\n\nI understand this is an edge case, and can be easily circumvented by using `function(){ this.fetch(); }` instead, but maybe it deserves some looking into. Specially since I believe this also means `fetch` can't be bound to any event.\n\nRight now I can't think of a good way to solve it that won't break 8478567, though. Maybe needing to explicitly state you want to override the request settings in `sync`?\n"
    },
    "satisfaction_conditions": [
      "Event handler must properly handle event arguments without causing unintended parameter passing",
      "Collection must successfully update in response to model changes",
      "Solution must maintain compatibility with existing Backbone event system"
    ],
    "created_at": "2013-01-31T10:38:01Z"
  },
  {
    "id": "https://github.com/jashkenas/backbone/issues/2160",
    "source": {
      "issue_number": 2160
    },
    "initial_question": {
      "title": "Weird behavior when model.save if option.validate is not set",
      "body": "When validate is not set when calling model.save, it will call 'model.set' in 'model.save' with option passed in, so no validation. Later, option will be extended with {validate : true}, which makes 'model.save' fail. However, since the 'model.set' is done, the data presented wrongly in the view.\n\nI think the behaviors should be consistent, maybe. If no validate: true in option, it doesn't extend the option and check when save.\n"
    },
    "satisfaction_conditions": [
      "Model attributes remain consistent if validation fails",
      "Validation results are properly respected",
      "View displays accurate model state",
      "Handles asynchronous validation consistently"
    ],
    "created_at": "2013-01-18T19:45:06Z"
  },
  {
    "id": "https://github.com/jashkenas/backbone/issues/2078",
    "source": {
      "issue_number": 2078
    },
    "initial_question": {
      "title": "Collection fetch does not render on \"add\" event",
      "body": "I've set up this AppView that triggers the overall Backbone's application!\nI want to fetch my collection and dynamically add items when the \"add\" event is thrown!\n\n```\nvar AppView = Backbone.View.extend({\n    el: $('#pics'),\n\n    initialize: function () {\n\n        // Fetch contents\n        this.collection = new PLibrary;\n        this.collection.on(\"add\", this.renderMessage, this);\n\n        $.ajaxSetup({async: false});\n        this.collection.fetch({update: true});  // fires an \"add\" event for every new model\n        $.ajaxSetup({async: true});\n\n        _.bindAll(this, 'render');\n    },\n\n    renderMessage: function(p){\n        var mV = new PRow({model: p});\n        this.$el.append(mV.render().el);\n    }\n\n});\n```\n\nThe code above sends the Ajax request to the server, but nothing gets displayed.\nInstead... If I make use of render() like this... the application works.\n\n```\nvar AppView = Backbone.View.extend({\n    el: $('#pics'),\n\n    initialize: function () {\n\n        // Fetch contents\n        this.collection = new PLibrary;\n        this.collection.on(\"add\", this.renderMessage, this);\n\n        $.ajaxSetup({async: false});\n        this.collection.fetch();\n        $.ajaxSetup({async: true});\n\n        _.bindAll(this, 'render');\n        this.render();\n    },\n\n    renderMessage: function(p){\n        var mV = new PRow({model: p});\n        this.$el.append(mV.render().el);\n    },\n\n    render: function() {\n        var self = this;\n        _.each(this.collection.models, function (item) {\n            self.renderMessage(item);\n        }, this);\n    }\n\n});\n```\n\nIt seems that the \"add\" event doesn't get thrown!\nHelp me please\n"
    },
    "satisfaction_conditions": [
      "Initial data load must trigger appropriate view updates",
      "View rendering must preserve collection item order"
    ],
    "created_at": "2013-01-06T14:43:46Z"
  },
  {
    "id": "https://github.com/jashkenas/backbone/issues/1935",
    "source": {
      "issue_number": 1935
    },
    "initial_question": {
      "title": "listenTo on jQuery objects?",
      "body": "I just started doing my upgrade for event listening, listenTo is a great addition to Backbone! \n\nI had a question about usage though. I listen for click events on DOM objects in some cases and attempted to translate the listeners from:\n\n$('#div').on(event, callback) \n\nto \n\nview.listenTo($('#div'), event, callback)\n\nand it doesn't seem to work.\n\nUsing jQuery 1.8.3, I'm getting the following error:\n\n``` javascript\n((jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply is not a function\n    at dispatch(Object) (/iBEnergyCore/js/libs/jquery/jquery-1.8.3.js:3058)\n    at eventHandle(MouseEvent) (/iBEnergyCore/js/libs/jquery/jquery-1.8.3.js:2676)\n```\n\nIf the listenTo function will not work with jQuery objects that's fine. Just wasn't sure if I uncovered a bug.\n\nThanks again for the update!!\n\n-Tim\n"
    },
    "satisfaction_conditions": [
      "Event listeners must be properly bound to Backbone-compatible objects only",
      "Memory leaks must be prevented when managing event listeners",
      "Error-free execution without the 'apply is not a function' error",
      "Events must be properly scoped to their respective views"
    ],
    "created_at": "2012-12-14T14:48:35Z"
  },
  {
    "id": "https://github.com/jashkenas/backbone/issues/1883",
    "source": {
      "issue_number": 1883
    },
    "initial_question": {
      "title": "Problem with IE8 and sorted models in collection detected in Version 0.9.2",
      "body": "IE8 displays: error on page\n\nNumber expected\nbackbone.js  Line: 724 (it's the \"sort\" function)\nCode: 0   Char: 9\nif I use a sorted collection with:\n\n```\ncomparator: function() {\n    return this.get('pageNo');\n},\n```\n## \n\npageNo is an integer in the model\n\nthis error doesn't occur in IE9 or Firefox but every time in IE8\nmy workaround was to throw out the comparator function and use the where clauses to find the correct model\n"
    },
    "satisfaction_conditions": [
      "Collection sorting must work correctly in IE8",
      "Comparator function must receive correct model data",
      "No JavaScript errors occur when sorting",
      "Collection maintains correct sort order based on pageNo field"
    ],
    "created_at": "2012-12-09T12:43:03Z"
  },
  {
    "id": "https://github.com/jashkenas/backbone/issues/1728",
    "source": {
      "issue_number": 1728
    },
    "initial_question": {
      "title": "Question - Assign index to models on instantiation",
      "body": "Is there anyway to let the newly instantiated model know of its 0-based index inside its collection, and assign it? Something like:\n\n``` javascript\n    var m = Backbone.Model.extend({\n        initialize: function() {\n            this.set('index', '// 0-based index inside the parent collection//');\n        }\n    });\n```\n"
    },
    "satisfaction_conditions": [
      "Model's position in collection must be retrievable",
      "Index value must be 0-based",
      "Index must remain accurate when collection changes",
      "Index must be accessible from within the model context"
    ],
    "created_at": "2012-10-12T09:39:41Z"
  },
  {
    "id": "https://github.com/jashkenas/backbone/issues/1721",
    "source": {
      "issue_number": 1721
    },
    "initial_question": {
      "title": ".fetch({add: true}) attaching phantom object into collection",
      "body": "`collection.fetch({add: true})` currently adds an empty object `{}` into the original collection even if the fetched response is `undefined` or `null`:\n\n``` javascript\n[..., {\"id\" : 39, attr: \"whatever\"}, {}]\n```\n\nThis can lead to unexpected errors when processing the collection data. Is this intended?\n"
    },
    "satisfaction_conditions": [
      "Empty fetch results must be handled gracefully",
      "Empty results must be represented as an empty array of models"
    ],
    "created_at": "2012-10-10T11:11:14Z"
  },
  {
    "id": "https://github.com/jashkenas/backbone/issues/1715",
    "source": {
      "issue_number": 1715
    },
    "initial_question": {
      "title": "By reference inheritance",
      "body": "Have a question, potentially a bug - hopefully just a question.\n\nTrying to create a slightly enhanced view, and then create instances of that view as below.\n\n// enhanced view\nvar Enhanced = Backbone.View.extend({\nfoo: [],\ntest: function () {\nthis.foo.push(Math.random());\n}\n});\n\n// couple of new objects\nvar Foo = Enhanced.extend({});\nvar Bar = Enhanced.extend({});\n\n// instantiating\nvar foo = new Foo();\nvar bar = new Bar();\n\n// trying to push a random number into foo\nfoo.test();\nbar.test();\n\n// expecting to see something like [0.11767047128388153][0.8575983647365905]\nconsole.log(foo.foo, bar.foo);\n\nOne would expect to see 2 different values for the output above, however one gets the same array of length 2 with identical values in both instances.\n\nLooking @ the code around line 1400, one can see the following:\n\nctor.prototype = parent.prototype;\n\nIn order to create a truly new instance wouldn't:\n\nctor.prototype = $.extend(true,{},parent.prototype);\n\nbe suited better?\n\nThat would solve the problem I described above. As is, array foo feels like a static, not instance variables.\n\nI know that the prescribed version is to use \"initialize\" for instance variables, but why would the above suggested \"fix\" be wrong?\n\nThanks!\n"
    },
    "satisfaction_conditions": [
      "Instance-specific data must be initialized when creating new instances",
      "Inheritance hierarchy must be preserved",
      "Performance impact must be reasonable",
      "Shared prototype properties must still work as intended"
    ],
    "created_at": "2012-10-05T23:05:36Z"
  },
  {
    "id": "https://github.com/jashkenas/backbone/issues/1703",
    "source": {
      "issue_number": 1703
    },
    "initial_question": {
      "title": "Can't Pass \"data-\" attributes within View's Attributes method",
      "body": "I am a fan of setting attributes within a view as such...\n\n<pre>Backbone.View.extend({\n    attributes: {\n        data-attr: 'mydata'\n    }\n});\n</pre>\n\n\n... however, this throws an error due to the hyphen in the key \"data-attr\".\n\n<pre>Uncaught SyntaxError: Unexpected token -</pre>\n\n\nI realize this is an illegal token in a JavaScript key-value object, however I was hoping Backbone offered some work around for this, given the fact that passing data attributes is one of the most likely scenarios.\n\nI have been working around it by setting the attribute within the render function using jQuery:\n\n<pre>render: function () {\n    this.$el.attr( 'data-attr', 'mydata\"');\n}\n</pre>\n\n\nThis works, but I thought to ask if there is another option.\n"
    },
    "satisfaction_conditions": [
      "Data attributes with hyphens must be successfully assigned to view elements",
      "The solution must be syntactically valid JavaScript",
      "Data attributes must be accessible during view initialization",
      "Model data must be correctly scoped when used in attributes"
    ],
    "created_at": "2012-10-03T21:07:26Z"
  },
  {
    "id": "https://github.com/jashkenas/backbone/issues/1702",
    "source": {
      "issue_number": 1702
    },
    "initial_question": {
      "title": "Alternative to events: { \"trigger select\" : \"functor\" }?",
      "body": "Hi,\n\nI was wondering if there was an alternative to the standard Backbone.View.extend({ events: { \"trigger selector\" : \"functor\", ...} ... }).\n\nIs there a special alternative function that gets called that lets you bind events for that specific view without having to mix the trigger and CSS selector into a string, and without having to pass the callback as a string rather than as a reference?\n\nThe latter's less important than the former: if there's a way to at least do even binding in a way that keeps the trigger and the view selector separate, that would be awesome. Is there such an alternative?\n"
    },
    "satisfaction_conditions": [
      "Event binding must allow separate specification of event type and selector",
      "Event handler binding must work within the context of a Backbone View",
      "Event binding syntax must be more explicit than string concatenation",
      "Solution must support event delegation for view elements"
    ],
    "created_at": "2012-10-03T18:31:37Z"
  },
  {
    "id": "https://github.com/jashkenas/backbone/issues/1690",
    "source": {
      "issue_number": 1690
    },
    "initial_question": {
      "title": "Concerned about Model security?",
      "body": "Hi,\n\nI have a simple Backbone Model/View combo that is validating a login field and then calling `.save` so the data is sent to the server to process. \n\nThe problem I've just realised is that when inspecting the Model after calling `.save` I can see the password is being stored in the Model as plain text so all a developer has to do is dynamically change the JavaScript via the standard built-in browser developer tools to see the user's password.\n\nHow can I implement a username/password login securely with Backbone?\n\nMy current Model/View code is as follows...\n## Model:\n\n``` js\ndefine(['Backbone'], function(){\n\n    return Backbone.Model.extend({\n        url: '/login/',\n\n        validate: function (attributes) {\n            var errors = [];\n\n            if (attributes.account.indexOf('@') === -1) {\n                errors.push({\n                    field: 'account',\n                    value: attributes.account\n                });\n            }\n\n            if (attributes.password === '') {\n                errors.push({\n                    field: 'password',\n                    value: attributes.password\n                });\n            }\n\n            if (errors.length) {\n                return errors\n            }\n        }\n    });\n\n});\n```\n## View:\n\n``` js\ndefine(['../Models/CustomerLogin', 'Backbone'], function (CustomerLogin) {\n\n    return Backbone.View.extend({\n        initialize: function(){\n            // Store the form element and hide it\n            this.form = this.$el.find('form');\n\n            // Store the Model object for easy reference\n            this.model = new CustomerLogin();\n\n            // Store reference to error message box\n            this.error_message = $('#js-loginerror')\n        },\n\n        // The containing element\n        el: $('#js-customerlogin'),\n\n        // Selectors are scoped to the parent element\n        events: {\n            'click #js-loginbtn': 'toggle_display',\n            'submit form': 'store_user_details'\n        },\n\n        toggle_display: function(){\n            this.form.slideToggle();\n        },\n\n        store_user_details: function (e) {\n            // I stored this hash in a variable as it looked cleaner passing it to `save` method below\n            var fields = {\n                account: this.form[0].elements[0].value,\n                password: this.form[0].elements[1].value\n            };\n\n            // Scope of `this` is lost within the error callback below\n            var self = this;\n\n            // When we call `save` it automatically validates all data\n            // So if there are any errors with what we're trying to save then it'll fail\n            this.model.save(fields, {\n                error: function(){\n                    self.error_message.addClass('is-error');\n                },\n                success: function(data){\n                    self.error_message.removeClass('is-error');\n                    alert('LOG USER IN - WARNING!!! Backbone.Model has plain text storage of password!!!');\n                    console.log(self.model.attributes, 'ALL DEVELOPER HAS TO DO IS CHANGE JS DYNAMICALLY AND HE HAS PASSWORD!');\n                }\n            });\n\n            e.preventDefault();\n        }\n    });\n\n});\n```\n"
    },
    "satisfaction_conditions": [
      "Form validation must occur before submission",
      "User receives feedback on validation errors"
    ],
    "created_at": "2012-10-01T13:52:44Z"
  },
  {
    "id": "https://github.com/jashkenas/backbone/issues/1552",
    "source": {
      "issue_number": 1552
    },
    "initial_question": {
      "title": "Delegate event in View does not return original event",
      "body": "To process some attributes i need access to $(this) in event callback, but receive only event object. This event object contain target (child html element) but does not contain the original event.\n\nFor example\n\n```\n<div class=\"test\"><div class=\"sub\">TEXT</div></div>\n\nevents: {\n    \"click .test\": \"func\"\n}\n```\n\nThis backbone uses \n\n```\nvar eventName = match[1], selector = match[2];\nmethod = _.bind(method, this);\n```\n\nyes, it is okay. But maybe the original \"this\" should returned too as 2d argument?\n\nit can be dome for example as $.delegate eventData\n\nps of course i can get access to parent by jquery parents() but it adds some complexity\n"
    },
    "satisfaction_conditions": [
      "Access to the delegated event's target element must be available",
      "Element access method must work within Backbone's event delegation system"
    ],
    "created_at": "2012-08-15T10:48:20Z"
  },
  {
    "id": "https://github.com/jashkenas/backbone/issues/1450",
    "source": {
      "issue_number": 1450
    },
    "initial_question": {
      "title": "route & page reload on IE",
      "body": "Hi guys \nI have the following issue I am not sure if this is how backbone is supposed to behave\n\nI start Backbone history on my auth path \n\n``` javascript\nBackbone.history.start({pushState: true, root: '/auth/'});\n```\n\nwhen IE users hit /auth/join backbone switch the url to #auth/join as the browser does not support the history api. But this \nalso reload the page. Can't this be done without reloading the page ?\n"
    },
    "satisfaction_conditions": [
      "URL changes must be handled without page reloads in browsers that support HTML5 History API",
      "System must gracefully handle URL changes in legacy IE browsers that don't support pushState",
      "URL format must correctly switch between pushState and hash-based formats based on browser capability",
      "Application must maintain expected routing functionality regardless of URL handling method"
    ],
    "created_at": "2012-06-25T10:35:14Z"
  },
  {
    "id": "https://github.com/jashkenas/backbone/issues/1198",
    "source": {
      "issue_number": 1198
    },
    "initial_question": {
      "title": "collection.sortedIndex does not use collection.comparator",
      "body": "`collection.sortedIndex` does not use `collection.comparator`, so it always returns 0\n"
    },
    "satisfaction_conditions": [
      "The sortedIndex method must return the correct insertion index when provided with a comparator function",
      "The collection's default comparator should not automatically be used by sortedIndex",
      "The method must accept a comparator as an explicit parameter",
      "Without a comparator, the method should return a default value (0)"
    ],
    "created_at": "2012-04-06T01:37:17Z"
  },
  {
    "id": "https://github.com/jashkenas/backbone/issues/998",
    "source": {
      "issue_number": 998
    },
    "initial_question": {
      "title": "Collection.add event callbacks trigger after all models are added in 0.9.1 instead of serially like 0.5.3",
      "body": "Something in my code broke with the recent update from 0.5.3 -> 0.9.1 and I believe I've traced it down to a difference in how Collection.add works.\n\nIn 0.5.3, when the \"add\" event fired on a collection, the state of the collection was such that the last model in the collection was the one being passed through the add. Put another way, in the add callback on a collection the length was accurate and in sync with the model being added. Does that make sense?\n\nThe code was like:\nfor (var i = 0, l = models.length; i < l; i++) {\n          this._add(models[i], options);\n        }\n\nSo when the add callback say hits a viewer listening for 'add' the length of the collection would increment on each add callback.\n\nNow, the code is more decoupled and the collection is fully populated when add events are triggered.\n\nsplice.apply(this.models, [index, 0].concat(models));\n      if (this.comparator) this.sort({silent: true});\n      if (options.silent) return this;\n      for (i = 0, length = this.models.length; i < length; i++) {\n        if (!cids[(model = this.models[i]).cid]) continue;\n        options.index = i;\n        model.trigger('add', model, this, options);\n      }\n\nThis seems like strange behavior - meaning that add callbacks aren't really callbacks per add but rather a batch after all the models have been added.\n\nThoughts?\n"
    },
    "satisfaction_conditions": [
      "Collection event handlers must have access to accurate model position information",
      "Event handlers must be able to determine if they are processing the final model in a batch add operation"
    ],
    "created_at": "2012-02-13T21:28:11Z"
  },
  {
    "id": "https://github.com/jashkenas/backbone/issues/962",
    "source": {
      "issue_number": 962
    },
    "initial_question": {
      "title": "Models not available in Collection.initialize()",
      "body": "In 0.5.3, the Collection's constructor used to set the models before calling `initialize()`. However, with 0.9, the models get set only after `initialize()`. \n\nOur existing `initialize()` code relies on models existing in order to run some aggregate calculations. Now, all that is broken. Why the change?\n\nAdditionally, when `reset()` is called to set the models, it is done silently, so we can't even listen to the \"reset\" event to perform the calculations.\n"
    },
    "satisfaction_conditions": [
      "Collection must be able to perform required calculations after models are loaded",
      "Solution must accommodate the new initialization order where models are set after initialize()",
      "Calculations must be performed at a predictable point after both initialization and model loading"
    ],
    "created_at": "2012-02-06T12:28:24Z"
  },
  {
    "id": "https://github.com/jashkenas/backbone/issues/888",
    "source": {
      "issue_number": 888
    },
    "initial_question": {
      "title": "Removal of \"_add\" and \"_remove\"",
      "body": "I'd like to discuss the removal of `Collection._add` and `Collection._remove`. I realize these methods were not part of the \"public\" API of course, but they were quite useful nonetheless.\n\nThese methods exposed functionality that is not otherwise available in Backbone, and were therefore very useful as hook points for extensions (not least of all for me in Backbone-relational). Both of these took a single snippet of data (either a model, or an object that might contain an `id` somewhere... or not) and return the model operated upon. Since both `add` and `remove` simply return the complete collection, they can not be used to determine this, especially when passing in JSON.\n\nI have a sort-of-working workaround for Backbone-relational (using `_.clone(this.models)` before adding, then calling `add`, using `_.difference( this.models, clone )` afterwards and iterating over the diff), but this is quite a performance penalty when compared to the current situation. Especially considering many people use relational  exactly because it automates the handling of a very large amount of models, and this whole process is repeated for every single addition.\n\nAny chance these two could be re-instated?\n"
    },
    "satisfaction_conditions": [
      "Solution must identify which specific models were added to or removed from the collection",
      "Solution must handle both Model instances and plain objects without IDs",
      "Solution must maintain compatibility with Backbone's collection operations"
    ],
    "created_at": "2012-01-24T16:56:19Z"
  },
  {
    "id": "https://github.com/jashkenas/backbone/issues/855",
    "source": {
      "issue_number": 855
    },
    "initial_question": {
      "title": "model.destroy don't send id in request header",
      "body": "I use default behavior (REST) with PHP server\n\nI defined url for my model and everything is right with create and update.\n\nBut with delete method, ID is not send in the header like for others methods\n\nIn the source code, I find : \n\n```\nif (!params.data && model && (method == 'create' || method == 'update')) {\n  params.contentType = 'application/json';\n  params.data = JSON.stringify(model.toJSON());\n}\n```\n\nWhy dont include delete method ?\n\n```\nif (!params.data && model && (method == 'create' || method == 'update' || method == 'delete' )) {\n```\n"
    },
    "satisfaction_conditions": [
      "DELETE request URL must contain the model ID",
      "URL construction must follow REST conventions for delete operations"
    ],
    "created_at": "2012-01-12T12:46:13Z"
  },
  {
    "id": "https://github.com/jashkenas/backbone/issues/832",
    "source": {
      "issue_number": 832
    },
    "initial_question": {
      "title": "Weird behaviour of Collection.without",
      "body": "Hi,\n\nI noticed a weird behaviour for `without` method on collections with the following code.\n\n``` coffee\nremainingTerritories = allTerritories.without(territoriesToReject)\n```\n\nBoth `allTerritories` and `territoriesToReject` are `Territories` collections containing Territory objects, and some of these territories to reject come from the pool of territories, matching with `===`).\n`remainingTerritories` contains a regular Array containing all the Territory objects  no one is filtered out.\nI would expect to get all the territories minus the ones to reject.\n\nTo achieve my goal, I had to write:\n\n``` coffee\nremainingTerritories = new Territories(allTerritories.reject (t)-> territoriesToReject.include(t))\n```\n\nIt's not a big deal but I would be glad to know why, and if I can help fixing that if it's not the expected behaviour.\n"
    },
    "satisfaction_conditions": [
      "Object equality comparison must work correctly between collections"
    ],
    "created_at": "2011-12-30T16:26:38Z"
  },
  {
    "id": "https://github.com/jashkenas/backbone/issues/830",
    "source": {
      "issue_number": 830
    },
    "initial_question": {
      "title": "Callback vs event handler priority",
      "body": "What's the reasoning for event handlers getting priority over the passed in callback?\n\n```\n# taken from destroy method\n...\noptions.success = function(resp) {\n   model.trigger('destroy', model, model.collection, options);\n   if (success) success(model, resp);\n};\n...\n```\n\nThe callback is provided by the object making the call in the first place, so it seems natural that it would get first rights to act on the result and then any event handlers would be handled second.  No?\n"
    },
    "satisfaction_conditions": [
      "Event handlers must execute before success callbacks",
      "Success callback execution must be conditional on event handlers completing without errors",
      "Event system must maintain proper notification chain",
      "Operation completion status must be accurately reflected"
    ],
    "created_at": "2011-12-30T02:11:23Z"
  },
  {
    "id": "https://github.com/jashkenas/backbone/issues/793",
    "source": {
      "issue_number": 793
    },
    "initial_question": {
      "title": "Supporting polymorphic collections",
      "body": "Howdy!\n\nRight now backbone seems to only support collections of one type, we're working on a stream with many polymorphic types that all quack the same.\n\nIt'd be nice to implement this via inheritance(extend), rather than our current technique of creating proxies/mixins in the base class.\n\nbackbone collection seems to have a hardcoded new this.model in it,\n\nI was thinking about doing something like:\n\n```\nmodelClass : function(){\n   return  this[postType]\n}\n```\n\n   this.model = this.model || this.modelClass()\n\n```\nnew this.model\n```\n\nis this a change you would like to have implemented, or are you opposed to it for an ideological reason?\n\nIf you want it, I'll implemented, as it will help me on a couple projects I'm working on.\n"
    },
    "satisfaction_conditions": [
      "Collection must support multiple model types simultaneously",
      "Model type determination must be dynamic based on attributes",
      "Solution must maintain Backbone's collection functionality",
      "Implementation must work within Backbone's model instantiation process"
    ],
    "created_at": "2011-12-16T19:09:28Z"
  },
  {
    "id": "https://github.com/jashkenas/backbone/issues/774",
    "source": {
      "issue_number": 774
    },
    "initial_question": {
      "title": "Collection Reset",
      "body": "I'm using the suggested method of loading data models from the backend, to prevent fetching data from the server twice on a page load like this:\n\n``` javascript\n<script>\n  collection.reset(<%= @accounts.to_json %>);\n</script>\n```\n\nThe issue is my models are being rendered in my php views, the code above just adds the models to the collection, therefore no views rendering is happening when collection.reset is called, however I do have a view for this model but it's only rendered when collection.add is called with some click events in it, so the click events are obviously  not being called with the already rendered html because backbone.js didn't render the views itself.\n\nIs there a way of taking the already rendered html tags and bind it to my views so the click events I have work for those tags ?\nCheers\n"
    },
    "satisfaction_conditions": [
      "Backbone views must successfully bind to pre-existing HTML elements",
      "Event handlers defined in Backbone views must work on pre-rendered elements",
      "Solution must work with server-side rendered HTML that exists for SEO purposes",
      "Must handle multiple pre-rendered elements on the same page"
    ],
    "created_at": "2011-12-04T19:10:37Z"
  },
  {
    "id": "https://github.com/jashkenas/backbone/issues/526",
    "source": {
      "issue_number": 526
    },
    "initial_question": {
      "title": "[question] how to handle scroll event for window?",
      "body": "``` javascript\nevents: {\n  \"scroll\": \"loadMore\"\n}\n```\n\nI'm not sure how to do it.\n"
    },
    "satisfaction_conditions": [
      "Window scroll events must be successfully detected and handled",
      "The scroll handler function must be properly bound to the view context",
      "The view must have a valid reference to the window object"
    ],
    "created_at": "2011-08-02T00:51:08Z"
  },
  {
    "id": "https://github.com/jashkenas/backbone/issues/369",
    "source": {
      "issue_number": 369
    },
    "initial_question": {
      "title": "backbone doesn't find objects in (sub?)collections when saved with {silent: true}",
      "body": "Hi, say we have a Dokuments collection and a Notes collection within Dokuments.\nI added this note and saved it later on silently. The id is returned from the server and is copied to the object, but it can't be found by get:\n\n> > > dok = Dokuments.get('4ddd0c2de8e6870c5e00000c')\n> > > dok.notes.get('4ddd1359e8e6870c5e00013f')\n> > > undefined\n\nbut:\n\n> > > dok.notes.last().get('id')\n> > > \"4ddd1359e8e6870c5e00013f\"\n\nThank you in advance for any hints\n--Frank\n"
    },
    "satisfaction_conditions": [
      "Model's change event must be triggered for ID updates to take effect"
    ],
    "created_at": "2011-05-25T15:12:49Z"
  },
  {
    "id": "https://github.com/jashkenas/backbone/issues/353",
    "source": {
      "issue_number": 353
    },
    "initial_question": {
      "title": "the latest code not published to npm? o_O",
      "body": "I was looking at the source on github and the file length is ~1100 lines -- but when I do\n\n```\n$ npm install backbone\n```\n\nMy backbone.js file is only ~ 1011 lines (as well as there being some minor differences in the source)\n\nThe package.json in github's master says the version = \"0.3.3\"\n\nand when i npm ls i also get 0.3.3 ...\n\nam i crazy? \n"
    },
    "satisfaction_conditions": [
      "Version discrepancy between GitHub and npm is explained",
      "Release process timing is clarified",
      "Version numbers are consistent with expectations",
      "Development vs published version distinction is clear"
    ],
    "created_at": "2011-05-11T21:20:07Z"
  },
  {
    "id": "https://github.com/jashkenas/backbone/issues/306",
    "source": {
      "issue_number": 306
    },
    "initial_question": {
      "title": "Nested Views",
      "body": "I have a situation where one of my views is nested inside another. The relationship between the models is not nested. One of my views is a tr and the other view is a single td inside that tr.\n\nI cannot bind events to the td because they get consumed by the tr and as far as I know there is no option not consume the event with my handler.\n"
    },
    "satisfaction_conditions": [
      "Events triggered on the nested TD element must be handled independently from the TR element",
      "Event propagation between nested views must be controllable"
    ],
    "created_at": "2011-04-04T16:20:55Z"
  },
  {
    "id": "https://github.com/jashkenas/backbone/issues/160",
    "source": {
      "issue_number": 160
    },
    "initial_question": {
      "title": "Can't get view events to bind",
      "body": "I've been trying many different approaches, but I can't get the click function to bind.\n\nHere is the view I'm using:\n<code>\nsfProjectView = Backbone.View.extend({\n  el: $(\"#header-project\"),\n      events: {\n      \"click .click-project\": \"linkProject\"\n        },\n      linkProject: function() {\n      sfController.changeObject(currentTab(),this.model.sfAttrib(\"project\"));\n    },\n      superHtml: function() {\n      var supers = this.model.get(\"superprojects\");\n      var output = \"\";\n      if (supers) {\n         _.each(supers, function(super) {\n             output = output + \"<a href'#'>\" + sfObjects.get(super).get(\"name\") + \" > \" + \"</a>\";\n           });\n         return output;\n      } else {\n        return \"&nbsp;\";\n      }\n    },\n      initialize: function() {\n      _.bindAll(this, \"render\", \"linkProect\");\n      this.render();\n    },\n      render: function() {\n\n```\n  var project = this.model.sfGet(\"project\");\n  var projectActiveP = this.model.sfActive(\"project\");\n  var projectType = this.model.sfGet(\"projectType\");\n  var projectDom = \"#ajaxProject\";\n  var projectTypeDom = \"#projectType\";\n  var superProjectsDom = \"#superProjects\";\n  if (project) {\n    $(projectDom).text(project).css(\"display\",\"block\");\n    $(superProjectsDom).html(this.superHtml());\n    if (projectActiveP) {\n      $(projectDom).removeClass(\"inactive\");\n      $(projectDom).addClass(\"active\");\n      $(projectTypeDom + \" span:eq(1)\").html(\"\");\n    } else {\n      $(projectDom).removeClass(\"active\");\n      $(projectDom).addClass(\"inactive\");\n      $(projectTypeDom + \" span:eq(1)\").html(\"&nbsp;Project Complete\").addClass(\"green\");\n    }\n    if (projectType) {\n      $(projectTypeDom).css(\"display\",\"block\");\n      $(projectTypeDom + \" span:eq(0)\").text(\"Type:\");\n      $(projectTypeDom + \" a\").text(projectType);\n    }\n  } else {\n    $(this.id).css(\"display\",\"none\");\n  }\n  return this;\n}\n```\n\n</code>\nAny ideas greatly appreciated!\n"
    },
    "satisfaction_conditions": [
      "View's click events successfully bind to DOM elements",
      "View maintains proper relationship with its target DOM elements",
      "View remains responsive after initialization",
      "View's DOM elements exist when events are bound"
    ],
    "created_at": "2010-12-31T03:53:25Z"
  },
  {
    "id": "https://github.com/jashkenas/backbone/issues/126",
    "source": {
      "issue_number": 126
    },
    "initial_question": {
      "title": "Collection.create does not return a server response in the success callback",
      "body": "After creating a new model (using 'create'), I want to assign an id to the model that corresponds to the id the server generated. Unfortunately there is currently a bug in the create function that removes the response from the model.save success callback.\n\nIt's easy to fix but is there a specific reason for doing this that I'm missing? Should server-generated id's be assigned to models in a different way?\n"
    },
    "satisfaction_conditions": [
      "Model attributes must be automatically updated with server response data",
      "Server-generated IDs must be correctly associated with the client-side model"
    ],
    "created_at": "2010-12-08T08:15:03Z"
  },
  {
    "id": "https://github.com/jashkenas/backbone/pull/122",
    "source": {
      "issue_number": 122
    },
    "initial_question": {
      "title": "model.previous() example abuses scope in change event callback",
      "body": "The example uses `bill.previos(\"name\")` instead of `model.previous(\"name\")` in the `change` callback defined on `bill`.\n\nThe example works just fine, but the callback will not work if `bill` is redefined or lost from scope (pardon if I'm wrong, I'm not as intricately knowledgable in JS as I'd like).\n"
    },
    "satisfaction_conditions": [
      "Variable reference remains accessible within callback scope",
      "Previous value retrieval functionality works correctly",
      "Callback executes without scope-related errors",
      "Variable naming maintains code clarity"
    ],
    "created_at": "2010-12-07T06:47:29Z"
  },
  {
    "id": "https://github.com/jashkenas/backbone/issues/58",
    "source": {
      "issue_number": 58
    },
    "initial_question": {
      "title": "Can't update model from within a change callback",
      "body": "I'm trying to figure out how to act on a changed select dropdown. My view renders multiple select controls and changing each one might trigger a change in subsequent ones (think \"Country\" -> \"City\" select sequence).\n\nProblem is, according to \"cautionary notes\" in the docs, \"change\", \"submit\", and \"reset\" events do not bubble in current versions of Internet Explorer. Which means I can't use the view's event delegation, I suppose.\n\nSo, I tried attaching my change handler directly to the select element:\n\n```\n.change(function(e) { currentView.model.set({selectedAttribute: $(this).val()}); })\n```\n\nThis doesn't work, because I end up in a render function that has \"this\" set to the model (?), not the view. The call stack is:\n\nmy view's render function (this is where I end up)\nbackbone.js:92\nbackbone.js:291\nbackbone.js:168\nmy .change() function\n\nSo it seems that changing the model triggers an immediate re-rendering of the view (which is fine), but I end up with this.model being undefined, because this points to my model.\n\nI'm surely doing something wrong, but any pointers appreciated.\n"
    },
    "satisfaction_conditions": [
      "The view's render function must maintain correct context ('this') when triggered by model changes",
      "Event handling must work in Internet Explorer despite bubbling limitations"
    ],
    "created_at": "2010-11-05T15:37:20Z"
  },
  {
    "id": "https://github.com/jashkenas/backbone/issues/32",
    "source": {
      "issue_number": 32
    },
    "initial_question": {
      "title": "Is there a specific reason why filter/map/reject/etc don't return new Collections?",
      "body": "I would expect those methods to return new Collections, because generally when you map over something, you return a new type of that same something. For example, I would expect `stillAlive` to be a collection:\n\n```\nvar coll = new MyCollection([foo, bar, baz, quux]);\nvar stillAlive = coll.filter(function (o) { return o.get(\"HP\") > 0; });\n```\n\nIs this by design?\n\nAside: I really wish Github would make mailing lists or forums for projects, so that these types of issues wouldn't clog up the issues page...\n"
    },
    "satisfaction_conditions": [
      "Methods must return data types appropriate for their intended use case",
      "Return values must preserve data consistency",
      "Method behavior must be predictable across different data transformations",
      "Return values must avoid unnecessary object creation"
    ],
    "created_at": "2010-10-19T19:53:46Z"
  },
  {
    "id": "https://github.com/jashkenas/backbone/issues/22",
    "source": {
      "issue_number": 22
    },
    "initial_question": {
      "title": "App specific base classes",
      "body": "This question/problem is probably due to my complete deficiency in Javascript skills, but hopefully you will know the answer :) I want to create a base Model, that sets up the conventions for my application, and then create individual models from that base that simply overrides where needed. If I do this:\n\napp.view.MyBase = Backbone.Model.extend({ ..});\n\nWhat I want to do is this:\n\napp.view.NewModel = app.view.MyBase.extend({...});\n\nBut I get an error that .extend isn't a method on app.view.MyBase. Is there a simple way to achieve what I'm after? Thanks for your time. \n"
    },
    "satisfaction_conditions": [
      "Base model class must be properly inheritable",
      "Properties from base class must be accessible in child classes",
      "The extend() method must be available on the base class"
    ],
    "created_at": "2010-10-18T19:21:49Z"
  }
]