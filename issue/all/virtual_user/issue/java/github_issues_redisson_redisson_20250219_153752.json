[
  {
    "number": 6443,
    "title": "Order Guarantees with the Async API",
    "created_at": "2025-02-18T17:09:07Z",
    "closed_at": "2025-02-19T09:56:35Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/6443",
    "body": "Hey,\nI\u2019m wondering if the following example guarantees execution order:\n```\nRBucket<String> bucket = redisson.getBucket(\"key\");\n\nbucket.setAsync(\"value\"); // Fire SET without waiting\nRFuture<String> future = bucket.getAsync(); \n\nfuture.thenAccept(System.out::println); \n```\nDoes SET always execute before GET, even though SET wasn\u2019t explicitly awaited?\n\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/6443/comments",
    "author": "barshaul",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2025-02-19T08:58:52Z",
        "body": "Hi,\n\nNo, due to the asynchronous nature of the connections handling. \n\nTo achieve that you can create a Redisson instance with `\u0441onnectionPoolSize = 1`."
      },
      {
        "user": "mrniko",
        "created_at": "2025-02-19T10:50:04Z",
        "body": "@barshaul \n\nTo achieve that you can create a Redisson instance with `\u0441onnectionPoolSize = 1`"
      }
    ]
  },
  {
    "number": 5893,
    "title": "RLocalCachedMap local cache use?",
    "created_at": "2024-05-21T09:09:24Z",
    "closed_at": "2024-05-22T11:38:02Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/5893",
    "body": "if the data change on redis server\uff0ccan we get the new data in local cache? or the server will info client the change?\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/5893/comments",
    "author": "KYV365",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2024-05-21T12:30:52Z",
        "body": "pubsub message should be send after change if data updated without Redisson client."
      },
      {
        "user": "KYV365",
        "created_at": "2024-05-22T01:47:46Z",
        "body": "> pubsub message should be send after change if data updated without Redisson client.\r\n\r\nbut the new data can not get by method cachedValues()"
      },
      {
        "user": "mrniko",
        "created_at": "2024-05-22T05:32:33Z",
        "body": "you need to set `syncStrategy = UPDATE` local cache setting"
      }
    ]
  },
  {
    "number": 5882,
    "title": "Here\u2019s the issue we encountered with `redisson-3.11.5.jar`",
    "created_at": "2024-05-20T02:52:53Z",
    "closed_at": "2024-05-21T06:06:27Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/5882",
    "body": "\r\nOur service connects to the SLB (Server Load Balancer) using a domain name, which maps through a port to the Redis server nodes.\r\n\r\nFor example:\r\n- Service IP --> Domain A:2700 --> EIP (10.75.10.20):27000 --> Redis server: 10.65.10.30:27000\r\n\r\nThe Redis sentinel nodes are:\r\n- 10.65.10.30:27000\r\n- 10.65.10.40:27000\r\n- 10.65.10.50:27000\r\n\r\nRedisson performs two types of checks: `scheduleSentinelDNSCheck` and `scheduleChangeCheck`. These checks result in the following situations:\r\n\r\n- `redis://10.75.10.20:27000 added`\r\n- `redis://10.75.10.20:27000 was down`\r\n- `redis://10.65.10.30:27000 added`\r\n- `redis://10.65.10.30:27000 was down`\r\n\r\nThis causes a polling effect, even though they ultimately point to the correct sentinel nodes.\r\n\r\n### How to Resolve This Issue\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/5882/comments",
    "author": "githuailoveyou",
    "comments": [
      {
        "user": "githuailoveyou",
        "created_at": "2024-05-20T03:09:59Z",
        "body": "scheduleSentinelDNSCheck will add 10.75.10.20 to the sentinels.\r\nscheduleChangeCheck (when it uses 10.65.10.30:27000 to connect and retrieve other sentinels: redis://10.65.10.20:27000, redis://10.75.10.40:27000 and add 10.65.10.30:27000 to a newUris list to form a new set of three sentinels) will remove 10.75.10.20 from the sentinels.\r\n\r\n"
      },
      {
        "user": "mrniko",
        "created_at": "2024-05-20T06:58:52Z",
        "body": "because 10.65.10.30 doesn't have 10.75.10.20 in sentinel list. You can verify this by setting `trace` logging level for `org.redisson` package and check returned sentinels list by each sentinel."
      },
      {
        "user": "githuailoveyou",
        "created_at": "2024-05-20T08:06:50Z",
        "body": "Yes, it seems that Redisson doesn't fully support this SLB-based connection method, right? Although it doesn't directly impact business functionality, it does lead to continuous adjustments in the sentinels variable, otherwise we'll keep seeing \"down added\" occurrences. Now, the issue we're facing is that the service logs continue to record these changes persistently. How should I address this? Should we consider abandoning the use of SLB?"
      },
      {
        "user": "mrniko",
        "created_at": "2024-05-20T08:17:31Z",
        "body": "Does it mean that with SLB the same Redis node has two IPs ? one is defined in sentinel configs and another is used for SLB?"
      },
      {
        "user": "mrniko",
        "created_at": "2024-05-20T08:20:16Z",
        "body": "Did you try `natMapper` setting ? to resolve EIP to a real Redis node IP"
      },
      {
        "user": "githuailoveyou",
        "created_at": "2024-05-20T08:35:08Z",
        "body": "> Does it mean that with SLB the same Redis node has two IPs ? one is defined in sentinel configs and another is used for SLB?\r\n\r\n\"Yes, the reason we use SLB (Server Load Balancer) is because we have multiple Redis instances deployed on the same machine, each with 2 IP addresses.\r\n\r\nAll services are connected via domain names. Most of the Redis instances are in master-slave mode to ensure failover. Therefore, we adopt the SLB approach. We dynamically modify the server addresses under the SLB port after detecting master-slave switches.\""
      },
      {
        "user": "githuailoveyou",
        "created_at": "2024-05-20T08:38:30Z",
        "body": "> Did you try `natMapper` setting ? to resolve EIP to a real Redis node IP\r\n\r\nCan't make your own turn?  We don't really want to change the code"
      },
      {
        "user": "mrniko",
        "created_at": "2024-05-20T09:09:31Z",
        "body": "Unfortunately, it's a specific case. You can define natMapper like below.\r\n\r\n```java\r\n                .setNatMapper(new NatMapper() {\r\n                    @Override\r\n                    public RedisURI map(RedisURI uri) {\r\n                        if (uri.getHost().equals(\"10.75.10.20\")) {\r\n                            return new RedisURI(uri.getScheme(), \"10.65.10.20\", uri.getPort());\r\n                        }\r\n                        ...\r\n                    }\r\n                })\r\n```"
      },
      {
        "user": "mrniko",
        "created_at": "2024-05-21T06:06:25Z",
        "body": "Another solution is to use `org.redisson.api.HostNatMapper` implementation.\r\n\r\n```java\r\nMap<String, String> map = new HashMap<>();\r\nmap.put(\"10.75.10.20\", \"10.65.10.20\");\r\n\r\nconfig.setNatMapper(new HostNatMapper(map))\r\n```"
      }
    ]
  },
  {
    "number": 5830,
    "title": "Issue with Kryo5Codec in combination with org.springframework.cache.support.NullValue",
    "created_at": "2024-04-30T10:11:54Z",
    "closed_at": "2024-12-23T11:00:39Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/5830",
    "body": "Hi,\r\n\r\nI'm currently having an issue with the Spring Cache implementation in combination with Redisson. \r\nThe JCacheCache class provided by Redisson extends `org.springframework.cache.support.AbstractValueAdaptingCache`. In the method `protected Object fromStoreValue(@Nullable Object storeValue)` of the class AbstractValueAdaptingCache, there is an if condition, that check if the storeValue is equal to NullValue.INSTANCE using ==. \r\n\r\n```\r\nprotected Object fromStoreValue(@Nullable Object storeValue) {\r\n\tif (this.allowNullValues && storeValue == NullValue.INSTANCE) {\r\n\t\treturn null;\r\n\t}\r\n\treturn storeValue;\r\n}\r\n```\r\n\r\nThis condition evaluated to false in my case, because the instance of storeValue was not the same instance as NullValue.INSTANCE. Reason is the deserialisation, that was done by Kryo. It seems, that Kryo changes the constructor to \"public\" using reflections and creates a new instance by calling the constructor. It does not call the \"readResolve()\" method of NullValue class, which would return NullValue.INSTANCE.\r\nIs this a known issue? The only solution I came up with is extending the Kryo5Codec and adding a custom Serializer for NullValue.class. Is there another way to fix this issue?\r\n\r\nBest regards",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/5830/comments",
    "author": "MrKanister2000",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2024-04-30T12:12:56Z",
        "body": "> The JCacheCache class provided by Redisson\r\n\r\nSorry, Redisson doesn't implement such class"
      },
      {
        "user": "MrKanister2000",
        "created_at": "2024-04-30T13:07:27Z",
        "body": "> Sorry, Redisson doesn't implement such class\r\n\r\nYep sry, my bad. I got confused with the class names. JCacheCache is part of the Spring package. \r\nNevertheless, the `org.redisson.jcache.JCache` class returns a new instance of NullValue from the cache, because of the Kryo deserialization issue I described. Any hint how to fix this?\r\n"
      },
      {
        "user": "mrniko",
        "created_at": "2024-04-30T13:18:30Z",
        "body": "Can you add the code below into org.redisson.codec.Kryo5Codec#createKryo method and say if it works?\r\n\r\n```java\r\nif (com.esotericsoftware.kryo.util.Util.isClassAvailable(\"org.springframework.cache.support.NullValue\")) {\r\n   kryo.addDefaultSerializer(Class.forName(\"org.springframework.cache.support.NullValue\"), new JavaSerializer());\r\n}\r\n```"
      },
      {
        "user": "MrKanister2000",
        "created_at": "2024-04-30T14:06:05Z",
        "body": "Yes, it works, thanks. Do you see any trade-offs (like performance) when using the JavaSerializer?\r\n\r\nMy first solution was extending the Kryo5Codec class:\r\n\r\n```\r\npublic class MyKryo5Codec extends Kryo5Codec {\r\n\r\n    @Override\r\n    protected Kryo createKryo(ClassLoader classLoader) {\r\n        Kryo kryo = super.createKryo(classLoader);\r\n\r\n        kryo.addDefaultSerializer(NullValue.class, new NullValueSerializer(kryo, NullValue.class));\r\n\r\n        return kryo;\r\n    }\r\n}\r\n```\r\n\r\nand creating a custom NullValueSerializer:\r\n\r\n```\r\npublic class NullValueSerializer extends FieldSerializer<NullValue> {\r\n\r\n    public NullValueSerializer(Kryo kryo, Class type) {\r\n        super(kryo, type);\r\n    }\r\n\r\n    @Override\r\n    public NullValue read(Kryo kryo, Input input, Class type) {\r\n        return (NullValue) NullValue.INSTANCE;\r\n    }\r\n}\r\n```\r\n\r\nBut your solution has a way smaller footprint than mine."
      },
      {
        "user": "mrniko",
        "created_at": "2024-05-01T05:08:01Z",
        "body": "Thanks for testing. In your example Spring become a required dependency because of explicit NullValue class definition which I would like to avoid. It would be great if you rewrite it without explicit NullValue definition."
      }
    ]
  },
  {
    "number": 5298,
    "title": "How to successfully use Live Objects ?",
    "created_at": "2023-09-08T21:31:58Z",
    "closed_at": "2023-09-13T08:13:57Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/5298",
    "body": "I'm having difficulty with two different parts of the Live Objects feature of Redisson:\r\n\r\n1. Storing a nested `Map<String, String>` as a field of an '@REntity`\r\n2. Using a condition to `find()` instances that I know are stored.\r\n\r\nHere's my live object class (I'm using Lombok, hence the @Getter, etc annotations):\r\n```java\r\n@RequiredArgsConstructor\r\n@NoArgsConstructor(access = PROTECTED)\r\n@REntity(codec = StringCodec.class)\r\npublic class Manifest {\r\n\r\n\t@RId(generator = UUIDGenerator.class)\r\n\t@Getter\r\n\tprivate String id;\r\n\r\n\t@RIndex\r\n\t@Getter\r\n\tprivate String jobId;\r\n\r\n\t@RIndex\r\n\t@Getter\r\n\tprivate String rootFolder;\r\n\r\n\t@RCascade(ALL)  // Not sure this is needed, it doesn't seem to make any difference\r\n\tprivate Map<String, String> entries = new HashMap<>();\r\n\r\n\r\n\tpublic void add(String path, String hash) {\r\n\t\tentries.put(path, hash);\r\n\t}\r\n\r\n\t@Transient\r\n\tpublic int getSize() {\r\n\t\treturn entries.size();\r\n\t}\r\n\r\n}\r\n```\r\n\r\nI'm using this code to initially create and store the live object:\r\n```java\r\n\tRLiveObjectService liveObjects = redisson.getLiveObjectService();\r\n\tvar manifest = new Manifest(jobID, rootPath);\r\n\tmanifest = liveObjects.persist(manifest);\r\n\tliveObjects.asLiveObject(manifest).expire(Duration.ofMinutes(60));\r\n```\r\n\r\nElsewhere I use this code to get the object by ID and add data to its `entries` map:\r\n```java\r\n\tManifest manifest = liveObjects.get(Manifest.class, id);\r\n\tmanifest.add(path, hash);\r\n```\r\n\r\nSomewhere else, I use this code to find the object:\r\n```java\r\n\tpublic static Condition jobIDEquals(String jobID) {\r\n\t\treturn Conditions.eq(\"jobId\", jobID);\r\n\t}\r\n\r\n\tCollection<Manifest> manifests = liveObjects.find(Manifest.class, jobIDEquals(jobID));\r\n```\r\n\r\nWith the code above, the two problems are:\r\n1. The `manifests` collection is empty, even though I can inspect my Redis server (using RedisInsight) and see the hashes stored there with matching `jobId` values.\r\n2. If I load one of the objects directly by its `id`, the `entries` Map is always empty, _even after_ having added values to it. I see in RedisInsight that the value of `entries` is `org.redisson.RedissonReference@7623beea`, but there is no other key in Redis that corresponds to that reference.\r\n\r\nWhat am I doing wrong?",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/5298/comments",
    "author": "eric-creekside",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2023-09-09T04:47:34Z",
        "body": "You need to define getters and constructors explicitly"
      },
      {
        "user": "eric-creekside",
        "created_at": "2023-09-10T21:59:48Z",
        "body": "As I tested more, I was still seeing the situation where values I had added to my nested `entries` `Map<>` were not getting persisted, so when a later process loaded the objects with `find()`, `entries` was empty. I discovered that my `Manifest.add()` method had to use the getter to reference `entities`. Specifically, this code did *not* work:\r\n```java\r\n\tpublic void add(String path, String hash) {\r\n\t\tentries.put(path, hash);\r\n\t}\r\n```\r\nbut this code does work:\r\n```java\r\n\tpublic void add(String path, String hash) {\r\n\t\tgetEntries().put(path, hash);\r\n\t}\r\n```\r\n\r\nI think this is another opportunity to improve the documentation and examples by making it clear that collection fields of the live object have to be de-referenced from the proxy in order to have their contents persisted.\r\n\r\nIf possible, it would be good to also detect that situation at runtime and log a warning."
      },
      {
        "user": "mrniko",
        "created_at": "2023-09-13T08:13:57Z",
        "body": "Follow statement added to the documentation: `Getters/setters/constructors can't be generated by byte-code tools like Lombok. Additional methods should use getters and not fields. `"
      }
    ]
  },
  {
    "number": 5285,
    "title": "RSorted Map comparator not working correctly",
    "created_at": "2023-08-30T07:29:11Z",
    "closed_at": "2023-10-04T17:44:37Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/5285",
    "body": "Trying to create a sorted map with a custom comparator for duplicate detection. For some reason  comparator is set, however duplicates are getting added to the sorted set.  \r\n\r\npublic class RedissonMessagingMgrTest {\r\n\r\n    private static MessagingMgr mgr = null;\r\n\r\n    @BeforeAll\r\n    public static void setUp() {\r\n       try {\r\n          mgr = new RedissonMessagingMgr(\"127.0.0.1\",6379,\"nishi\");\r\n       }\r\n       catch (Exception exception) {\r\n          exception.printStackTrace();\r\n       }\r\n    }\r\n\r\n    @Test\r\n    public void  testPublishNoDupQueue100() {\r\n        String queueName = \"NoDupQueue100\";\r\n        int msgCount=1;\r\n        boolean isPublished = false;\r\n        String str = \"This is my string as bytes\";\r\n        \r\n        mgr.createNoDupQueue(queueName, new TestMsgComparator());\r\n        byte[] bytes = null;\r\n        int i=0;\r\n        for ( i=0;i<msgCount;i++) {\r\n            str =  str + i;\r\n            bytes = str.getBytes();\r\n            TestMsg msg = new TestMsg(i,bytes, System.currentTimeMillis() );\r\n            isPublished = mgr.publishNoDupQueue(queueName,msg);\r\n        }\r\n        isPublished = mgr.publishNoDupQueue(queueName,new TestMsg(0,bytes, System.currentTimeMillis()));  \r\n        assertFalse(isPublished,\"No Duplicates Allowed\");\r\n    }\r\n\r\n}\r\n   \r\nMy Comparator class is as below:-\r\n\r\nimport java.util.Comparator;\r\n\r\npublic class TestMsgComparator implements Comparator<TestMsg> {\r\n    \r\n    @Override\r\n    public int compare(TestMsg a, TestMsg b)\r\n    {\r\n        return a.number  - b.number;\r\n    }\r\n}\r\n\r\nThe sorted set will contain objects of TestMsg\r\n\r\npublic class TestMsg implements PubSubMessage,  Serializable {\r\n    private byte[] data;\r\n    public int number;\r\n    private long timestamp;\r\n\r\n    public TestMsg(int number, byte[] data, long ts) {\r\n        this.number = number;\r\n        this.data = data;\r\n        this.timestamp = ts;\r\n    }\r\n\r\n    public long getNumber() {\r\n        return number;\r\n    }\r\n\r\n    public byte[] getData() {\r\n        return data;\r\n    }\r\n\r\n    public long getSortedScore() {\r\n        return timestamp;\r\n    } \r\n}\r\n\r\npublic class RedissonMessagingMgr implements MessagingMgr {\r\n\r\n   private static Logger log = LoggerFactory.getLogger(RedissonMessagingMgr.class);\r\n   private RedissonClient client = null;\r\n\r\n   public RedissonMessagingMgr(String host, int port, String password) throws \r\n   ConnectException {\r\n      log.info(\"[IN] RedissonMessagingMgr Constructor\");\r\n      Config config = new Config();\r\n      StringBuilder messagingAddress = new StringBuilder(\"redis://\");\r\n      messagingAddress.append(host).append(\":\").append(Integer.toString(port));\r\n      config.useSingleServer().setAddress(messagingAddress.toString());\r\n      config.useSingleServer().setPassword(password);\r\n      config.setNettyThreads(0);\r\n      \r\n      log.info(\"[OUT] RedissonCache Constructor\");\r\n   }\r\n}\r\n\r\npublic boolean createNoDupQueue(String name,Comparator comp ) {\r\n      boolean returnValue = false;\r\n      //RScoredSortedSet<PubSubMessage> sortedset = client.getScoredSortedSet(name);\r\n      RSortedSet<PubSubMessage> sortedset = client.getSortedSet(name);\r\n      \r\n      System.out.println(\"Comparator:\"+sortedset.comparator().getClass().getName());\r\n\r\n      try {\r\n         boolean set = sortedset.trySetComparator(comp);\r\n         System.out.println(\"Comparator:\"+sortedset.comparator().getClass().getName());\r\n\r\n      }\r\n      catch(RedisException exception) {\r\n         // ignoring the exception and invoking trySetComparator multiple time will raise this \r\n         // exception.\r\n         exception.printStackTrace();\r\n      }\r\n      if (sortedset != null)  {\r\n         returnValue = true;\r\n      }\r\n      return returnValue;\r\n   }\r\n\r\npublic boolean publishNoDupQueue(String queueName,PubSubMessage message) {\r\n      RScoredSortedSet<PubSubMessage> noDupQueue = client.getScoredSortedSet(queueName);\r\n      return noDupQueue.add(message.getSortedScore(),message);\r\n   }\r\n}",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/5285/comments",
    "author": "nkant17",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2023-08-30T11:24:42Z",
        "body": "Unable to reproduce.\r\n\r\n```java\r\n    public static class TestMsg {\r\n\r\n        int number;\r\n\r\n        String str;\r\n\r\n        public TestMsg(int number, String str) {\r\n            this.number = number;\r\n            this.str = str;\r\n        }\r\n\r\n        public int getNumber() {\r\n            return number;\r\n        }\r\n\r\n        public String getStr() {\r\n            return str;\r\n        }\r\n\r\n        @Override\r\n        public String toString() {\r\n            return \"TestMsg{\" +\r\n                    \"number=\" + number +\r\n                    \", str='\" + str + '\\'' +\r\n                    '}';\r\n        }\r\n    }\r\n\r\n    public static class TestMsgComparator implements Comparator<TestMsg> {\r\n\r\n        @Override\r\n        public int compare(TestMsg a, TestMsg b)\r\n        {\r\n            return a.number  - b.number;\r\n        }\r\n    }\r\n\r\n    @Test\r\n    public void test12() {\r\n        RSortedSet<TestMsg> set = redisson.getSortedSet(\"set\");\r\n\r\n        set.trySetComparator(new TestMsgComparator());\r\n        set.add(new TestMsg(1, \"1\"));\r\n        set.add(new TestMsg(1, \"2\"));\r\n        set.add(new TestMsg(3, \"3\"));\r\n        set.add(new TestMsg(4, \"4\"));\r\n\r\n        assertThat(set).containsExactly(new TestMsg(1, \"1\"), new TestMsg(3, \"3\"), new TestMsg(4, \"4\"));\r\n    }\r\n```"
      }
    ]
  },
  {
    "number": 4988,
    "title": "RedisBusyException when running load tests",
    "created_at": "2023-04-25T00:21:31Z",
    "closed_at": "2023-05-02T07:27:25Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/4988",
    "body": "```\r\n`\r\nWARN  [2023-04-25 00:10:45,507] org.redisson.client.RedisBusyException: BUSY Redis is busy running a script. You can only call SCRIPT KILL or SHUTDOWN NOSAVE.. channel: [id: 0x99c796a7, L:/10.240.0.18:34142 - R:10.240.0.74/10.240.0.74:6379] data: CommandData [promise=java.util.concurrent.CompletableFuture@51438d95[Not completed, 1 dependents], command=(EVAL), params=[local currentTime = tonumber(table.remove(ARGV, 1)); local ttl = table.remove(ARGV, 1); local ttlNumber = tonumber(ttl); local maxSize = tonumber(redis.call('hget', KEYS[8], 'max-size'));local mode = redis.call('hget', KEYS[8], 'mode'); for i, value in ipairs(ARGV) do if i % 2 == 0 then local key = ARGV[i-1];local v = redis.call('hget', KEYS[1], key);local exists = false;if v ~= false then    local t, val = struct.unpack('dLc0', v);    local expireDate = 92233720368547758;    local expireDateScore = redis.call('zscore', KEYS[2], key);    if expireDateScore ~= false then        expireDate = tonumber(expireDateScore)    end;    if t ~= 0 then        local expireIdle = redis.call('zscore', KEYS[3], key);        if expireIdle ~= false then            expireDate = math.min(expireDate, tonumber(expireIdle))        end;    end;    if expireDate > tonumber(currentTime) then        exists = true;    end;end;if ttlNumber > 0 then     redis.call('zadd', KEYS[2], ttl, key); else     redis.call('zr..., 8, mht_collector, redisson__timeout__set:{mht_collector}, redisson__idle__set:{mht_collector}, redisson_map_cache_created:{mht_collector}, redisson_map_cache_updated:{mht_collector}, redisson__map_cache__last_access__set:{mht_collector}, redisson_map_cache_removed:{mht_collector}, {mht_collector}:redisson_options, ...], codec=org.redisson.codec.SerializationCodec]`\r\n```\r\n\r\nWe seem to get these RedisBusyExceptions at some point whenever we run load tests. On elastic cache side of things we have enough memory and CPU. So we are not bottlenecked by those. Our only doubt is network bandwidth. Any idea for what reasons this exception gets thrown?  \r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/4988/comments",
    "author": "formanojhr",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2023-05-02T07:27:25Z",
        "body": "You need to run redis slowlog command to realize which script is running too slow."
      }
    ]
  },
  {
    "number": 4890,
    "title": "Switching from Redis 4 to 6, will Redisson have compatibility issues?",
    "created_at": "2023-02-22T13:23:12Z",
    "closed_at": "2023-02-23T07:23:53Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/4890",
    "body": "Hi team, \r\n\r\nWe are going to upgrade Redis 4 to Redis 6. I would like to ask team if there will be compatibility issues between Redission and Redis 6 after upgrading 4 to 6. Or do you know of any known Redission incompatibilities due to Redis 6 upgrades?\r\nAccording to redission documentation, Redission supports Redis 4 and 6. Does this mean that we don't need to modify any client code? \r\n\r\nMany thanks for your support!",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/4890/comments",
    "author": "yunbozhang-msft",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2023-02-23T07:23:49Z",
        "body": "Hi,\r\n\r\nRedisson is fully compatible with 3.x up to 7.0.x version. No code modification is needed."
      }
    ]
  },
  {
    "number": 4768,
    "title": "Classfile version 61 (Java17) change intended?",
    "created_at": "2022-12-29T15:48:50Z",
    "closed_at": "2023-01-06T07:28:19Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/4768",
    "body": "Is it an intended or accidental change to publish redisson compiled with java17 target and thus break everyone not yet lucky enough to be on 17?\r\nIf so, wouldn't a change like this be good to be documented as incompatible in the release notes?\r\n\r\nAlso i was expecting such a drastic thing to be a major, rather than a minor change (in terms of SemVer).",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/4768/comments",
    "author": "uweschaefer",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2022-12-30T05:34:28Z",
        "body": "Can you point on that class? All classes of 3.19.0 version compiled with java 8 target. Checked it with javap\r\n\r\n```\r\npublic class org.redisson.Redisson implements org.redisson.api.RedissonClient\r\n  minor version: 0\r\n  major version: 52\r\n```\r\n"
      }
    ]
  },
  {
    "number": 4674,
    "title": "Expire RRateLimiter",
    "created_at": "2022-11-15T08:22:44Z",
    "closed_at": "2022-11-17T07:52:58Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/4674",
    "body": "I want to delete RRateLimiter hash from redis, post rate interval is over. e.g. I set rate interval of 10 sec then hash must be removed post 10 sec.\r\nIs there any built in api for this functinality exists? ",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/4674/comments",
    "author": "pat246",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2022-11-17T07:52:56Z",
        "body": "You need to use `expire()` method"
      },
      {
        "user": "pat246",
        "created_at": "2022-11-17T12:41:16Z",
        "body": "Thanks.\r\nActually we are using redisson 3.12.x version, hence I was unable to call `expire()` method. However as workaround I've tried to expire using `RMap`  with expiry value of \"rate interval\" as below\r\n\r\n\r\n`RRateLimiter limiter = redisson.getRateLimiter(name);`\r\n`RMap<Object, Object> keyMap = redisson.getMap(name);`\r\n`keyMap.expire(10, TimeUnit.SECONDS); // 10 sec is rate interval of limitter`"
      }
    ]
  },
  {
    "number": 4670,
    "title": "How to set cache properties for Hibernate scond level cache?",
    "created_at": "2022-11-13T08:38:42Z",
    "closed_at": "2022-12-12T06:04:47Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/4670",
    "body": "I'm working on a Java spring project where I have multiple entities to be cached using `@Cache` annotation, ex:\r\n`@Cache(usage = CacheConcurrencyStrategy.READ_WRITE ,region = \"cache1\")`\r\n\r\nI have set ` spring.jpa.properties.hibernate.cache.region.factory_class` to be RedissonRegionFactory\r\n\r\nAs I'm using Redis cache as Hibernate second Level cache, I want a way to customize the properties of each cache region in a Java class, by properties I mean the TTL and maxEntriesLocalHeap.\r\n\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/4670/comments",
    "author": "AseelAbushhadeh",
    "comments": [
      {
        "user": "OdaybatLFC",
        "created_at": "2022-11-15T08:48:17Z",
        "body": "Hello @AseelAbushhadeh , what I have done in my project is configure each cached entity with my own configuration class. I am also open to hear if there is another way of achieving this."
      },
      {
        "user": "mrniko",
        "created_at": "2022-11-17T07:51:33Z",
        "body": "@OdaybatLFC \r\n\r\nWhy can't you use spring.jpa.properties.hibernate.cache... settings?\r\n\r\n```java\r\nspring.jpa.properties.hibernate.cache.redisson.entity.expiration.time_to_live=\r\nspring.jpa.properties.hibernate.cache.redisson.entity.expiration.max_idle_time=\r\nspring.jpa.properties.hibernate.cache.redisson.collection.expiration.time_to_live=\r\nspring.jpa.properties.hibernate.cache.redisson.collection.expiration.max_idle_time=\r\n```"
      },
      {
        "user": "AseelAbushhadeh",
        "created_at": "2022-11-17T10:37:03Z",
        "body": "thanks for the suggestion, I can use it but this will apply to all caches, I want to customize the properties for each entity cache individually.\r\n\r\n> @OdaybatLFC\r\n> \r\n> Why can't you use spring.jpa.properties.hibernate.cache... settings?\r\n> \r\n> ```java\r\n> spring.jpa.properties.hibernate.cache.redisson.entity.expiration.time_to_live=\r\n> spring.jpa.properties.hibernate.cache.redisson.entity.expiration.max_idle_time=\r\n> spring.jpa.properties.hibernate.cache.redisson.collection.expiration.time_to_live=\r\n> spring.jpa.properties.hibernate.cache.redisson.collection.expiration.max_idle_time=\r\n> ```\r\n\r\n"
      },
      {
        "user": "mrniko",
        "created_at": "2022-11-17T11:24:26Z",
        "body": "You can specify region name as well.\r\n```\r\nspring.jpa.properties.hibernate.cache.redisson.my_object.eviction.max_entries=\r\nspring.jpa.properties.hibernate.cache.redisson.my_object.expiration.time_to_live=\r\nspring.jpa.properties.hibernate.cache.redisson.my_object.expiration.max_idle_time=\r\n\r\nspring.jpa.properties.hibernate.cache.redisson.my_collection.expiration.time_to_live=\r\nspring.jpa.properties.hibernate.cache.redisson.my_collection.expiration.max_idle_time=\r\n```"
      }
    ]
  },
  {
    "number": 4667,
    "title": "Regarding definition of nettyThreads",
    "created_at": "2022-11-11T04:35:33Z",
    "closed_at": "2023-03-27T13:09:55Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/4667",
    "body": "`nettyThreads` is defined as _Threads amount shared between all internal redis clients used by Redisson._\r\n\r\nFor e.g. my application connects to 3 different Redis clusters (2 sentinel based clusters, 1 multi-master cluster), all of them are initialized with different connections pool sizes and nettyThreads size. Should I keep  `nettyThreads` same across the redis clients here? ",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/4667/comments",
    "author": "rgampa",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2023-03-27T13:09:55Z",
        "body": "You can define shared EventLoopGroup through `eventLoopGroup` setting to use a single netty threads pool."
      }
    ]
  },
  {
    "number": 4585,
    "title": "Redisson Client creating more connections to Redis (Elastic cache cluster) than expected",
    "created_at": "2022-10-07T05:29:34Z",
    "closed_at": "2022-10-07T06:16:24Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/4585",
    "body": "We are using Redisson client(**3.11.5 version**) for distributed lock use-case.\r\nWe are using 8 primary and 8 replica in AWS Elastic cache.\r\nRedisson is a singleton object in our Java application instance.\r\n\r\nWe are noticing Redisson client creating more than max connections configured.  Noticed that 24K+ active connections were created from single application instance\r\nMax master connections configured was 1000.\r\n\r\n{code}\r\n\r\n@Bean\r\npublic Redisson clusterServerRedisson() {\r\n        final StringBuilder serverAddress = new StringBuilder()\r\n                .append(\"rediss://\")\r\n                .append(this.environment.getRequiredProperty(RedisPropertyConstants.REDIS_HOST))\r\n                .append(\":\")\r\n                .append(this.environment.getRequiredProperty(RedisPropertyConstants.REDIS_PORT, Integer.class));\r\n        final String redisPassword = this.environment.getRequiredProperty(RedisPropertyConstants.REDIS_PASSWORD);\r\n\r\n        final Config config = new Config();\r\n\r\n        final ClusterServersConfig clusterServersConfig = config.useClusterServers();\r\n        clusterServersConfig.addNodeAddress(serverAddress.toString());\r\n        if (StringUtils.isNotBlank(redisPassword)) {\r\n            clusterServersConfig.setPassword(redisPassword);\r\n        }\r\n        // Redis cluster scan interval in milliseconds.\r\n        clusterServersConfig.setScanInterval(this.environment.getRequiredProperty(RedisPropertyConstants.REDIS_REDISSON_CLUSTER_SCAN_INTERVAL_TIMEOUTMILLIS, int.class));\r\n\r\n        // Redis 'master' node maximum connection pool size\r\n        clusterServersConfig.setMasterConnectionPoolSize(this.environment.getRequiredProperty(RedisPropertyConstants.REDIS_REDISSON_CONNECTION_MAX_POOL_SIZE, int.class));\r\n\r\n        // Redis 'master' node minimum idle connection amount for each master node\r\n        clusterServersConfig.setMasterConnectionMinimumIdleSize(this.environment.getRequiredProperty(RedisPropertyConstants.REDIS_REDISSON_CONNECTION_MIN_IDLE_SIZE, int.class));\r\n\r\n        // Timeout in milliseconds during connecting to any Redis server.\r\n        clusterServersConfig.setConnectTimeout(this.environment.getRequiredProperty(RedisPropertyConstants.REDIS_REDISSON_CONNECTION_TIMEOUTMILLIS, int.class));\r\n\r\n        // Operation timeout - counter starts once command has been sent to the redis server\r\n        // Redis server response timeout in milliseconds. Starts to countdown when Redis command was succesfully sent.\r\n        clusterServersConfig.setTimeout(this.environment.getRequiredProperty(RedisPropertyConstants.REDIS_REDISSON_OP_TIMEOUTMILLIS, int.class));\r\n\r\n        clusterServersConfig.\r\n        // For connection failures outside of the (jedis) pool\r\n        clusterServersConfig.setRetryAttempts(this.environment.getRequiredProperty(RedisPropertyConstants.REDIS_REDISSON_CONNECTION_MAX_RETRY_COUNT, int.class));\r\n        clusterServersConfig.setRetryInterval(this.environment.getRequiredProperty(RedisPropertyConstants.REDIS_REDISSON_CONNECTION_RETRY_DELAYMILLIS, int.class));\r\n\r\n        // Since we use redis primarily as a messaging conduit (PubSub), we tune the following items\r\n        clusterServersConfig.setSubscriptionsPerConnection(\r\n                this.environment.getRequiredProperty(RedisPropertyConstants.REDIS_REDISSON_SUBSCRIPTION_PER_CONNECTION_SIZE, int.class));\r\n        clusterServersConfig.setSubscriptionConnectionPoolSize(\r\n                this.environment.getRequiredProperty(RedisPropertyConstants.REDIS_REDISSON_SUBSCRIPTION_CONNECTION_MAX_POOL_SIZE, int.class));\r\n\r\n        clusterServersConfig.setClientName(this.environment.getRequiredProperty(RedisPropertyConstants.REDIS_REDISSON_CONNECTION_NAME, String.class));\r\n\r\n        return (Redisson)Redisson.create(config);\r\n    }\r\n\r\n{code}\r\n## Redisson Client for Redis\r\nredis.redisson.cluster.scan.interval.timeoutMillis=30000\r\nredis.redisson.connection.name=MY-APP-REDISSON-POOL\r\nredis.redisson.connection.max.pool.size=1000\r\nredis.redisson.connection.max.retry.count=10\r\nredis.redisson.connection.min.idle.size=100\r\nredis.redisson.connection.retry.delayMillis=1500\r\nredis.redisson.connection.timeoutMillis=60000\r\nredis.redisson.idle.connection.timeoutMillis=10000\r\nredis.redisson.lock.timeoutMillis=10000\r\nredis.redisson.op.timeoutMillis=30000\r\nredis.redisson.subscription.connection.max.pool.size=50\r\nredis.redisson.subscription.per.connection.size=10\r\n\r\n\r\npublic class RedisLock implements DistributableLock {\r\n\r\n    private final RedisConfigManager redisConfigManager;\r\n    private final Redisson redisson;\r\n\r\n    public RedisLock(final Redisson redisson) {\r\n        this.redisson = this.redisConfigManager.getRedisson();\r\n    }\r\n\r\n    @Override\r\n    public void acquireLock(final Object object) {\r\n        getLockInstance(object).lock(this.redisConfigManager.getLockTimeoutInMillis(), TimeUnit.MILLISECONDS);\r\n    }\r\n\r\n    @Override\r\n    public void releaseLock(final Object object) {\r\n        getLockInstance(object).unlock();\r\n    }\r\n\r\n    @Override\r\n    public boolean tryWriteLock(final Object object) {\r\n        return getReadWriteLockInstance(object).writeLock().tryLock();\r\n    }\r\n\r\n    @Override\r\n    public void acquireReadLock(final Object object) {\r\n        getReadWriteLockInstance(object).readLock().lock();\r\n    }\r\n\r\n    @Override\r\n    public void releaseReadLock(final Object object) {\r\n        getReadWriteLockInstance(object).readLock().unlock();\r\n    }\r\n\r\n    @Override\r\n    public void acquireWriteLock(final Object object) {\r\n        getReadWriteLockInstance(object).writeLock().lock(this.redisConfigManager.getLockTimeoutInMillis(), TimeUnit.MILLISECONDS);\r\n    }\r\n\r\n    @Override\r\n    public void releaseWriteLock(final Object object) {\r\n         getReadWriteLockInstance(object).writeLock().unlock();\r\n    }\r\n\r\n    private RLock getLockInstance(final Object object) {\r\n        Assert.notNull(object, \"Cannot lock or unlock a null object\");\r\n\r\n        final RLock rLock = this.redisson.getLock(Integer.toString(object.hashCode()));\r\n        if (rLock == null) {\r\n            throw new IllegalStateException(\"Cannot get lock instance.\");\r\n        }\r\n        return rLock;\r\n    }\r\n\r\n    private RReadWriteLock getReadWriteLockInstance(final Object object) {\r\n        Assert.notNull(object, \"Cannot lock or unlock a null object\");\r\n\r\n        final RReadWriteLock rwLock = this.redisson.getReadWriteLock(Integer.toString(object.hashCode()));\r\n        if (rwLock == null) {\r\n            throw new IllegalStateException(\"Cannot get read write lock instance.\");\r\n        }\r\n        return rwLock;\r\n    }\r\n\r\n}\r\n\r\n\r\nAny help would be highly appreciable. Thanks in advance.",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/4585/comments",
    "author": "samanthjain",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2022-10-07T06:16:24Z",
        "body": "Multiple problems with connections were resolved since 3.11.5. Especially in versions 3.12.2, 3.13.3, 3.14.1... You need to update to the latest version."
      }
    ]
  },
  {
    "number": 4284,
    "title": "What difference from `readAllEntrySet` and `getAll` in `RMap`",
    "created_at": "2022-05-10T12:57:00Z",
    "closed_at": "2022-05-10T13:15:01Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/4284",
    "body": "Hi~ Community:\r\n    When I want to use `hmget` command in redis, I found `rMap.getAll(\"\")`, it returns all fields, so what difference from `readAllEntrySet` and `getAll` in `RMap`?\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/4284/comments",
    "author": "xdshent",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2022-05-10T13:01:52Z",
        "body": "`getAll` methods allows to load map by specified keys. Whereas `readAllEntrySet` loads all map entries."
      }
    ]
  },
  {
    "number": 4065,
    "title": "How to use 'zAdd'?",
    "created_at": "2022-01-10T09:22:53Z",
    "closed_at": "2022-01-11T07:26:11Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/4065",
    "body": "How to use 'RedisZSetCommands.zAdd(byte[] key, double score, byte[] value)'?\r\nnot implemented\uff1f",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/4065/comments",
    "author": "Jabwin",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2022-01-10T10:55:47Z",
        "body": "It's implemented in all versions. Starting from Spring Data Redis 2.5.0 it's routed to `zAdd(byte[] key, double score, byte[] value, ZAddArgs args)` method. Which is also implemented."
      }
    ]
  },
  {
    "number": 4046,
    "title": "Reads only happening from Master Node for Redis Cache in Elastic Cache replicated mode",
    "created_at": "2021-12-23T11:38:40Z",
    "closed_at": "2021-12-26T08:32:43Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/4046",
    "body": "We are using the clustered connection in aws for redis, but the read is always happening from the primary node.\r\n\r\nThe versions we are using:\r\n\r\nRedis engine in aws  : 4.0.10\r\n\r\nClient:\r\n                       <dependency>\r\n\t\t\t\t<groupId>org.redisson</groupId>\r\n\t\t\t\t<artifactId>redisson</artifactId>\r\n\t\t\t\t<version>3.16.6</version>\r\n\t\t\t</dependency>\r\n\r\n\r\nConfig:\r\nURL: aws cluster url\r\nfinal int poolSize = Runtime.getRuntime().availableProcessors() * 2 + 2;\r\n\t\tConfig config = new Config();\r\n\t\tconfig\r\n\t\t\t.useClusterServers()\r\n\t\t\t.setScanInterval(2000)\r\n\t\t\t.addNodeAddress(redisUrl)\r\n\t\t\t.setMasterConnectionPoolSize(poolSize)\r\n\t\t\t.setMasterConnectionMinimumIdleSize(poolSize)\r\n\t\t\t.setSlaveConnectionPoolSize(poolSize)\r\n\t\t\t.setSlaveConnectionMinimumIdleSize(poolSize)\r\n\t\t\t\t.setReadMode(ReadMode.SLAVE);\r\n\r\n\t\tconfig.setCodec(codec);\r\n\t\tredissonClient = Redisson.create(config);\r\n\r\n\r\nCache read:\r\n\r\n                final RMap<String, Config> cache = this.redissonClient.getMap(CONFIG_CACHE);\r\n\t\tif (cache.isEmpty()) {\r\n\t\t\tlog.info(\"found Config cache empty... reloading from database\");\r\n\t\t\treloadPartnerConfig();\r\n\t\t}\r\n\t\treturn cache.get(apiKey);\r\n\r\n\r\n@mrniko  Could you check this once you have some time. I am sure you can provide a relevant answer very fast.\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/4046/comments",
    "author": "rjvharidas",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2021-12-23T11:45:49Z",
        "body": "please share log with `trace` logging level for `org.redisson` package."
      },
      {
        "user": "mrniko",
        "created_at": "2021-12-23T17:32:02Z",
        "body": "EVAL script uses write command so it's executed on master. You can use RMapCache.getWithTTLOnly() if idleTimeout is not defined."
      },
      {
        "user": "formanojhr",
        "created_at": "2023-04-26T03:45:11Z",
        "body": "@mrniko is this issue also in cluster mode? for read replicas. I assume yes."
      }
    ]
  },
  {
    "number": 3925,
    "title": "Redisson client injects weird characters at the beginning of strings",
    "created_at": "2021-10-29T12:01:41Z",
    "closed_at": "2021-10-29T12:28:17Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3925",
    "body": "I'm using Redisson client to publish String messages on a topic, but for some reasons, the published messages always contain some weird characters at the beginning:\r\n\r\neg: when I publish the string \"{\"event\":\"notification\"}\" at the redis level I end up with this: \"\\x04>\\x18{\"event\":\"notification\"}\"\r\n\r\n1) \"pmessage\"\r\n2) \"*\"\r\n3) \"active_project_users:1\"\r\n4) \"\\x04>\\x18{\\\"event\\\":\\\"notification\\\"}\"\r\n\r\nAny idea how I can make those weird chars go away?\r\n\r\nMy java code looks like this:\r\n\r\n private void publish(String channel, String message) {       \r\n        RTopic topic = redissonClient.getTopic(channel);\r\n        topic.publish(\"{\\\"event\\\":\\\"notification\\\"}\");\r\n    }\r\nI'm using redis:3.2 & radisson-spring-boot-starter 3.16.1\r\n\r\nThanks",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3925/comments",
    "author": "ghevge",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2021-10-29T12:28:17Z",
        "body": "default codec is MarshallingCodec. You need to define StringCodec if you want data stored as plain text."
      }
    ]
  },
  {
    "number": 3860,
    "title": "How does PING influences the BATCH command?",
    "created_at": "2021-10-04T09:42:08Z",
    "closed_at": "2021-10-05T08:23:34Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3860",
    "body": "I'm doing a batch command in the following way:\r\n\r\n```\r\n...\r\n  final RBatch rBatch = redissonClient.createBatch();\r\n        for (final String key : keys) {\r\n            rBatch.getMap(key, StringCodec.INSTANCE).getAsync(fieldName);\r\n        }\r\n  final List<?> responses = rBatch.execute().getResponses();\r\n ...\r\n```\r\nFrom time to time we get the following Timeout exception:\r\n```\r\norg.redisson.client.RedisResponseTimeoutException: Redis server response timeout (20 ms) occured after 0 retry attempts. Increase nettyThreads and/or timeout settings. Try to define pingConnectionInterval setting. Command: null, params: null\r\n```\r\n\r\nI'm wondering about the *Try to define pingConnectionInterval setting.* in the WARN message. We use the default setting for PING (the 30s interval). What is the meaning of that sentence in the message? Is the PING necessary? Could we disable the PING?  How does the PING influences the batch command? Any suggestions how this WARN can be avoided?\r\n\r\n\r\nRedis: 5.0.5\r\nRedisson: 3.16.3\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3860/comments",
    "author": "mircea-pop",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2021-10-04T11:33:26Z",
        "body": "I think in your case it's just a network delay due to response size."
      },
      {
        "user": "mircea-pop",
        "created_at": "2021-10-04T13:06:12Z",
        "body": "would it be OK to completely disable the PING? is there some documentation on how the PING influences the connection pool?"
      },
      {
        "user": "mrniko",
        "created_at": "2021-10-05T07:59:57Z",
        "body": "yes, you can disable PING. It's recommended only if your Redis setup is behind of proxy and it doesn't propagate connection interruptions."
      }
    ]
  },
  {
    "number": 3754,
    "title": "Is there any guideline for upgrading the middle value of a version",
    "created_at": "2021-08-02T05:14:11Z",
    "closed_at": "2021-08-05T07:43:14Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3754",
    "body": "Will it be an incompatible version when I upgrade from 3.11.x to 3.15.x?\r\nIs there any reason or guideline for the version value?",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3754/comments",
    "author": "ieiayaobb",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2021-08-02T08:28:20Z",
        "body": "There is no such guideline. No API breaking changes were made since 3.11.0 version."
      }
    ]
  },
  {
    "number": 3654,
    "title": "Is order of Operations in a RBatch guaranteed?",
    "created_at": "2021-06-11T06:09:58Z",
    "closed_at": "2021-06-14T07:58:49Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3654",
    "body": "Sorry if this is obvious, but i did not find any documentstion about this:\r\n\r\nIf i am using **RBatch** and create let's say a Bucket from it, and call setAsync on the bucket 100 times before executing the batch, is the order of the operations in the batch guaranteed to be the order in which\r\n```\r\nsetAsync(Object)\r\n```\r\nhas been called?\r\n\r\nIn other words, is there any way i could end up with anything but the last value i set to the bucket after the RBatch is executed? For instance if the Marshalling of the 99th value took some time?\r\n\r\nBucket is just an example here, i am also using RMaps the same way.",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3654/comments",
    "author": "uweschaefer",
    "comments": [
      {
        "user": "uweschaefer",
        "created_at": "2021-06-27T18:51:10Z",
        "body": "Thanks for answering, @mrniko \r\n\r\nis there an example somewhere? i fail to understand how RLock helps me in this case.\r\nOr did you refer to RedissonFairLock ?\r\n\r\nthx\r\n\r\nPS: One important thing i realized i failed to mention:\r\n\r\nall setAsync(Object) calls **come from the same Thread**.\r\njust like `stringList.stream().forEach(myStringBucket::setAsync);`"
      },
      {
        "user": "mrniko",
        "created_at": "2021-06-29T07:46:43Z",
        "body": "In batch list of operations is always ordered. But RBatch object isn't thread-safe."
      }
    ]
  },
  {
    "number": 3626,
    "title": "Will RLOS indexed based querying work in cluster enabled Redis?",
    "created_at": "2021-05-28T05:46:43Z",
    "closed_at": "2021-05-28T05:49:18Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3626",
    "body": "When we use cluster enabled Redis like AWS EC, it's possible that objects gets stored on different shards. Will the indexed based querying still work here?",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3626/comments",
    "author": "mayurgoenka",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2021-05-28T05:49:13Z",
        "body": "Sharded index supported only in PRO version."
      },
      {
        "user": "mayurgoenka",
        "created_at": "2021-06-02T13:15:33Z",
        "body": "Hi @mrniko , \r\nI see that the index is created in the following fashion:\r\n`\"redisson_live_object_index:{com.org.application.MyLiveObject}:index_field:<some_hash>\"`\r\n\r\nI see that we are using hash tag : `{com.org.application.MyLiveObject}` for storing all indices belonging to same class inside same keyslot.\r\n\r\nIn my use case, m trying to store billions of objects of the same class MyLiveObject and there are multiple indices as well. It's obvious that this won't fit in the same keyslot and will need sharding.\r\n\r\nYour comment, \"Sharded index supported only in PRO version.\", does this mean that the index itself will also get sharded across nodes and above use case will still work in PRO version? Same hashtag `{com.org.application.MyLiveObject}` won't be used in PRO version for indices?\r\n\r\nSorry for the repeated query, but just want to make sure before I finalise my design.\r\n\r\nHope my query is clear."
      },
      {
        "user": "mrniko",
        "created_at": "2021-06-02T13:30:41Z",
        "body": "Hi @mayurgoenka, \r\n\r\n> does this mean that the index itself will also get sharded across nodes and above use case will still work in PRO version\r\n\r\nIn this case name will be different to distribute evenly across all Redis master nodes.\r\n\r\n> Same hashtag {com.org.application.MyLiveObject} won't be used in PRO version for indices?\r\n\r\nThis name still will be present in key, but without braces.\r\n"
      },
      {
        "user": "mayurgoenka",
        "created_at": "2021-06-02T13:42:13Z",
        "body": "Thank you @mrniko , this means that I can safely use RLOS for huge data in redis clustered mode.\r\n\r\n\r\nAnother query is, are there any plans for supporting batch operations and transactions with RLOS objects? "
      },
      {
        "user": "mrniko",
        "created_at": "2021-06-02T14:03:16Z",
        "body": "What kind of batch / transaction operations over RLOS do you need? Could you describe some use cases?"
      },
      {
        "user": "mayurgoenka",
        "created_at": "2021-06-02T14:45:49Z",
        "body": "Suppose I want to merge 1000s of Live objects into redis cache, like a batch update OR batch insert. I see that we do have rlos.persist(list) but I not sure if its using pipelining inside or not? Also, rlos.merge(list) is what I was primarily looking for. \r\nThese operations are mainly required for warming up the cache in my use case.\r\n\r\n\r\nTransactions could be required when I want to update 2 different Live objects together or not do them at all. Live objects here can be of same class or different classes.\r\nI need this in my use case because there's a parent-child type of relationship in my application, where if I delete the parent object, child object also needs to get deleted."
      },
      {
        "user": "mrniko",
        "created_at": "2021-06-08T10:27:07Z",
        "body": "`org.redisson.api.RLiveObjectService#persist(T...)` method stores object in a batch. `merge()` method for multiple object isn't implemented yet.\r\n\r\nAs for transactions, I can recommend you to use RLock object."
      }
    ]
  },
  {
    "number": 3601,
    "title": "RTopic -ERR only (P)SUBSCRIBE / (P)UNSUBSCRIBE / QUIT allowed in this context",
    "created_at": "2021-05-10T03:09:25Z",
    "closed_at": "2021-05-10T06:15:37Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3601",
    "body": "Did I use Rtopic incorrectly?\r\nCode:\r\n```\r\n void pubEvent(){\r\n  RTopic topic = redissonClient.getTopic(\"test-topic\")\r\n  topic.publish(new Event(\"hello world\"))\r\n}\r\n\r\n void subEvent(){\r\n   RTopic topic = redissonClient.getTopic(\"test-topic\")\r\n   topic.addListener(new MessageListener<Event>(){\r\n            @Override\r\n            public void onMessage(CharSequence channel, Event event) {\r\n                log.debug(\"channel:{},Event :{}\", channel, event);\r\n            }\r\n  })\r\n}\r\n\r\n public static void main(String[] args){\r\n             Executors.newSingleThreadScheduledExecutor().scheduleWithFixedDelay(this::pubEvent, 1000, 10000, TimeUnit.MILLISECONDS);\r\n             subEvent();\r\n             Thread.sleep(1000000);\r\n }\r\n```\r\n\r\nConfig:\r\n```\r\nspring:\r\n  redis:\r\n    redisson:\r\n      config: |\r\n        singleServerConfig:\r\n          address: \"redis://localhost:6379\"\r\n          connectTimeout: 30000\r\n          pingConnectionInterval: 10000\r\n        codec: !<org.redisson.codec.JsonJacksonCodec> {}\r\n```\r\n\r\nError:\r\n```\r\n2021-05-10 10:56:48.237 ERROR 10184 --- [isson-timer-4-1] o.r.c.handler.PingConnectionHandler      : Unable to send PING command over channel: [id: 0x6657975f, L:/2.0.1.49:54140 - R:/172.19.13.25:6379]\r\norg.redisson.client.RedisException: ERR only (P)SUBSCRIBE / (P)UNSUBSCRIBE / QUIT allowed in this context. channel: [id: 0x6657975f, L:/2.0.1.49:54140 - R:/172.19.13.25:6379] command: (PING), params: []\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:343) ~[redisson-3.14.1.jar:3.14.1]\r\n\tat org.redisson.client.handler.CommandPubSubDecoder.decodeCommand(CommandPubSubDecoder.java:83) ~[redisson-3.14.1.jar:3.14.1]\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:117) ~[redisson-3.14.1.jar:3.14.1]\r\n\tat org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:102) ~[redisson-3.14.1.jar:3.14.1]\r\n\tat io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:501) ~[netty-codec-4.1.51.Final.jar:4.1.51.Final]\r\n\tat io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:366) ~[netty-codec-4.1.51.Final.jar:4.1.51.Final]\r\n\tat io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:276) ~[netty-codec-4.1.51.Final.jar:4.1.51.Final]\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379) ~[netty-transport-4.1.51.Final.jar:4.1.51.Final]\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365) ~[netty-transport-4.1.51.Final.jar:4.1.51.Final]\r\n\tat io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357) ~[netty-transport-4.1.51.Final.jar:4.1.51.Final]\r\n\tat io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1410) ~[netty-transport-4.1.51.Final.jar:4.1.51.Final]\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379) ~[netty-transport-4.1.51.Final.jar:4.1.51.Final]\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365) ~[netty-transport-4.1.51.Final.jar:4.1.51.Final]\r\n\tat io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:919) ~[netty-transport-4.1.51.Final.jar:4.1.51.Final]\r\n\tat io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:163) ~[netty-transport-4.1.51.Final.jar:4.1.51.Final]\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:714) ~[netty-transport-4.1.51.Final.jar:4.1.51.Final]\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:650) ~[netty-transport-4.1.51.Final.jar:4.1.51.Final]\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:576) ~[netty-transport-4.1.51.Final.jar:4.1.51.Final]\r\n\tat io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:493) ~[netty-transport-4.1.51.Final.jar:4.1.51.Final]\r\n\tat io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:989) ~[netty-common-4.1.51.Final.jar:4.1.51.Final]\r\n\tat io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74) ~[netty-common-4.1.51.Final.jar:4.1.51.Final]\r\n\tat io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) [netty-common-4.1.51.Final.jar:4.1.51.Final]\r\n\tat java.lang.Thread.run(Thread.java:748) [na:1.8.0_262]\r\n````",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3601/comments",
    "author": "facelezzzz",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2021-05-10T06:07:23Z",
        "body": "yes, usage is correct. which Redis vendor do you use?"
      },
      {
        "user": "facelezzzz",
        "created_at": "2021-05-10T06:15:22Z",
        "body": "The redis of our qa environment is version 2.8, and there is no problem after upgrading to 4.0\r\nthx"
      }
    ]
  },
  {
    "number": 3580,
    "title": "Async lock thread affinity",
    "created_at": "2021-04-27T07:42:51Z",
    "closed_at": "2021-05-12T08:01:55Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3580",
    "body": "Hi,\r\n\r\nI'm working on a kotlin micronaut web app which is attempting to be fully async and we're using redisson for distributed locks.\r\n\r\nI'm somewhat unclear on how to exactly use it correctly.\r\n\r\nThe official documentation says `RLock object behaves according to the Java Lock specification. It means only lock owner thread can unlock it otherwise IllegalMonitorStateException would be thrown. Otherwise consider to use RSemaphore object.` which sounds weird as in an async context, executing on a specific threads is never guaranteed.\r\n\r\nThe code I'm using for now, in a kotlin suspendable func, is like this:\r\n``` kotlin\r\nval lock = rediClinet.getLock(\"lock_name)\r\ntry {\r\n    (lock.lockAsync(50, TimeUnit.SECONDS) as CompletionStage<Void>).await()\r\n    //fancy kotlin async code here.\r\n}\r\nfinally {\r\n    (lock.unlockAsync() as CompletionStage<Void>).await()\r\n}\r\n```\r\n\r\nThe unlock line is not guaranteed to execute on the same thread as the lockAsync line.\r\n\r\nThanks!",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3580/comments",
    "author": "ghost",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2021-05-11T05:12:28Z",
        "body": "Hi,\r\n\r\nuse `unlockAsync(threadId)` method instead."
      },
      {
        "user": "ghost",
        "created_at": "2021-05-12T07:41:42Z",
        "body": "But what do use as `threadId` ?\r\nAny numbers as long as I use the same number across acquire/release methods?"
      },
      {
        "user": "mrniko",
        "created_at": "2021-05-12T07:58:15Z",
        "body": "you need to pass the same id to `lockAsync()` and `unlockAsync()` methods. It might be any id."
      }
    ]
  },
  {
    "number": 3544,
    "title": "Why ExpirationEntry use LinkedHashMap to save threadId",
    "created_at": "2021-04-09T09:28:20Z",
    "closed_at": "2021-04-13T02:50:39Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3544",
    "body": "Reddison watchDog strategy use timerTask to increase key expiration time while set the lock success\r\n\r\n    private void renewExpiration() {\r\n        ExpirationEntry ee = EXPIRATION_RENEWAL_MAP.get(getEntryName());\r\n        if (ee == null) {\r\n            return;\r\n        }\r\n        \r\n        Timeout task = commandExecutor.getConnectionManager().newTimeout(new TimerTask() {\r\n            @Override\r\n            public void run(Timeout timeout) throws Exception {\r\n                ExpirationEntry ent = EXPIRATION_RENEWAL_MAP.get(getEntryName());\r\n                if (ent == null) {\r\n                    return;\r\n                }\r\n                Long threadId = ent.getFirstThreadId();\r\n                if (threadId == null) {\r\n                    return;\r\n                }\r\n                \r\n                RFuture<Boolean> future = renewExpirationAsync(threadId);\r\n                ......\r\n       }\r\n   }\r\n\r\n  First use **entryName** to get ExpirationEntry object. For the same entryName, other threads can't get the key because locked(ps: same thread can get and counter++)\uff0cso why use LinkedHashMap to save thread if there only have one thread?\r\n\r\n`public static class ExpirationEntry {\r\n\r\n        private final Map<Long, Integer> threadIds = new LinkedHashMap<>();\r\n        private volatile Timeout timeout;\r\n\r\n        public ExpirationEntry() {\r\n            super();\r\n        }\r\n\r\n        public synchronized void addThreadId(long threadId) {\r\n            Integer counter = threadIds.get(threadId);\r\n            if (counter == null) {\r\n                counter = 1;\r\n            } else {\r\n                counter++;\r\n            }\r\n            threadIds.put(threadId, counter);\r\n        }\r\n}`",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3544/comments",
    "author": "yukerui",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2021-04-12T13:14:20Z",
        "body": "in case of readwrite lock there are might be multiple read locks."
      }
    ]
  },
  {
    "number": 3493,
    "title": "Transaction in Redis Live Object Service",
    "created_at": "2021-03-16T21:14:11Z",
    "closed_at": "2021-03-18T06:56:07Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3493",
    "body": "Hi,\r\n\r\nIs it possible to perform transaction on Redis Live Object?\r\nI want write a new instance of MyClass - only if new instance is newer than previous one. \r\nI need method similar to 'merge' in RMap. \r\n\r\n    @REntity\r\n    public class MyClass {\r\n\r\n        @RId\r\n        private String key;\r\n\r\n        @RIndex\r\n        public Date createDate;\r\n\r\n        @RIndex\r\n        public String externalValue;\r\n     }\r\n\r\nSo I need to compare dates of old and new objects and then save new object only if it newer. It has be executed in one transaction. In other thread someone can update fields in this object.",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3493/comments",
    "author": "bbartekb",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2021-03-17T08:46:35Z",
        "body": "Wrap this function with RLock object with name based on object id."
      },
      {
        "user": "bbartekb",
        "created_at": "2021-03-17T21:33:02Z",
        "body": "Thank you for your response!\r\n\r\nIt works for me with tryLock()\r\n\r\n    public void updateLiveObjectEntry(MyClass myObject) {\r\n        RLiveObjectService rLiveObjectService = getRedissonConnection().getClient().getLiveObjectService();\r\n        RLock lock = getRedissonConnection().getClient().getLock(myObject.getKey());\r\n\r\n        try {\r\n            lock.tryLock(10, TimeUnit.SECONDS);\r\n            if (myObject.getCreateDate().after(rLiveObjectService.get(MyClass.class, myObject.getKey()).getCreateDate())) {\r\n                rLiveObjectService.merge(myObject);\r\n            }\r\n        } catch (InterruptedException e) {\r\n        } finally {\r\n            lock.unlock();\r\n        }\r\n    }\r\n    \r\nIs my solution correct? \r\nI think this lock is not connected with my LiveObject, so myObject entry is not locked. It will be work if in all usage I use method updateLiveObjectEntry().\r\n    "
      },
      {
        "user": "mrniko",
        "created_at": "2021-03-18T05:31:12Z",
        "body": "you can use follow lock name: `String lockName = MyClass.class.getName() + \":\" + myObject.getKey()`. If you have any doubts about the key uniqueness with different Object classes."
      }
    ]
  },
  {
    "number": 3476,
    "title": "Caused by: java.lang.ClassNotFoundException: com.fasterxml.jackson.core.TSFBuilder",
    "created_at": "2021-03-14T23:59:36Z",
    "closed_at": "2021-03-16T16:49:49Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3476",
    "body": "keep getting this error when i try this\r\nConfig.fromYAML(PropertiesUtil.getResourceAsFile(REDISSON_RESOURCE_NAME));\r\n\r\nthe exception is \r\nCaused by: java.lang.NoClassDefFoundError: com/fasterxml/jackson/core/TSFBuilder\r\n\tat org.redisson.config.ConfigSupport.<init>(ConfigSupport.java:92)\r\n\tat org.redisson.config.Config.fromYAML(Config.java:661)\r\n\tat org.redisson.config.Config.fromYAML(Config.java:657)\r\n\r\nwhen I try to look at the code can't find usage for TSFBuilder at class ConfigSupport",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3476/comments",
    "author": "wdaas",
    "comments": [
      {
        "user": "wdaas",
        "created_at": "2021-03-16T16:49:38Z",
        "body": "thanks @mrniko \r\n\r\nthe problem was that redis 3.14.0 have dependency to jackson-dataformat-yaml.jar and it import version 2.11.1\r\nbut in our project we work with Jackson-core 2.7.6 .\r\n\r\nby add explicitly at mvn file dependency for version 2.7.6 for jackson-dataformat-yaml.jar we fix the issue."
      }
    ]
  },
  {
    "number": 3398,
    "title": "org.redisson.api.RAtomicLong#expireAt(long)  Cause the value to be deleted  ",
    "created_at": "2021-02-03T07:55:21Z",
    "closed_at": "2021-02-03T07:59:08Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3398",
    "body": "Redisson:3.15.0\r\nredis:4.0.9\r\n\r\norg.redisson.api.RAtomicLong#expireAt(long)\r\nCannot find the key of aKey after execution\r\n\r\nWhy is this ?\r\n\r\njava code\r\n```\r\n        Config config = new Config();\r\n        config.useSingleServer()\r\n                .setAddress(\"redis://127.0.0.1:6379\")\r\n                .setDatabase(0);\r\n        RedissonClient redissonClient = Redisson.create(config);\r\n\r\n        String aKey = \"aKey\";\r\n        RAtomicLong aAtomic = redissonClient.getAtomicLong(aKey);\r\n        long aValue0 = aAtomic.get();\r\n        LOG.info(\"aKey-value0[{}]\", aValue0);\r\n\r\n        aAtomic.incrementAndGet();\r\n        long aValue1 = aAtomic.get();\r\n        LOG.info(\"aKey-value1[{}]\", aValue1);\r\n        aAtomic.expireAt(1000 * 60 * 60);\r\n\r\n        long aValue2 = aAtomic.get();\r\n        LOG.info(\"aKey-value2[{}]\", aValue2);\r\n\r\n        LOG.info(\"---------------------------------------------------------\");\r\n\r\n        String bKey = \"bKey\";\r\n        RAtomicLong bAtomic = redissonClient.getAtomicLong(bKey);\r\n        long bValue0 = bAtomic.get();\r\n        LOG.info(\"bKey-value0[{}]\", bValue0);\r\n\r\n        bAtomic.incrementAndGet();\r\n        bAtomic.expire(10, TimeUnit.HOURS);\r\n\r\n        long bValue1 = bAtomic.get();\r\n        LOG.info(\"bKey-value1[{}]\", bValue1);\r\n\r\n        LOG.info(\"---------------------------------------------------------\");\r\n\r\n        String cKey = \"cKey\";\r\n        RAtomicLong cAtomic = redissonClient.getAtomicLong(cKey);\r\n        long cValue0 = cAtomic.get();\r\n        LOG.info(\"cKey-value0[{}]\", cValue0);\r\n\r\n        cAtomic.incrementAndGet();\r\n\r\n        long cValue1 = cAtomic.get();\r\n        LOG.info(\"cKey-value1[{}]\", cValue1);\r\n\r\n        redissonClient.shutdown();\r\n```\r\nlog...\r\n```\r\n15:45:35.913 [main] INFO org.redisson.Version - Redisson 3.15.0\r\n15:45:36.804 [redisson-netty-2-17] INFO org.redisson.connection.pool.MasterPubSubConnectionPool - 1 connections initialized for /127.0.0.1:6379\r\n15:45:36.817 [redisson-netty-2-17] INFO org.redisson.connection.pool.MasterConnectionPool - 24 connections initialized for /127.0.0.1:6379\r\n15:45:36.877 [main] INFO RedissonClient - aKey-value0[0]\r\n15:45:36.880 [main] INFO RedissonClient - aKey-value1[1]\r\n15:45:36.881 [main] INFO RedissonClient - aKey-value2[0]\r\n15:45:36.881 [main] INFO RedissonClient - ---------------------------------------------------------\r\n15:45:36.882 [main] INFO RedissonClient - bKey-value0[0]\r\n15:45:36.886 [main] INFO RedissonClient - bKey-value1[1]\r\n15:45:36.887 [main] INFO RedissonClient - ---------------------------------------------------------\r\n15:45:36.887 [main] INFO RedissonClient - cKey-value0[0]\r\n15:45:36.889 [main] INFO RedissonClient - cKey-value1[1]\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3398/comments",
    "author": "NoSugarIce",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2021-02-03T07:59:08Z",
        "body": "Because `expireAt()` method accepts date in milliseconds."
      }
    ]
  },
  {
    "number": 3390,
    "title": "RBatch response order with cluster env ?",
    "created_at": "2021-01-28T16:31:38Z",
    "closed_at": "2021-02-05T06:19:16Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3390",
    "body": "> In cluster environment batch executed in map\\reduce way. It aggregates commands for each node and sends them simultaneously, then result got from each node added to common result list.\r\n\r\n```\r\n\r\n    /**\r\n     * Executes all operations accumulated during async methods invocations.\r\n     * <p>\r\n     * If cluster configuration used then operations are grouped by slot ids\r\n     * and may be executed on different servers. Thus command execution order could be changed\r\n     *\r\n     * @return List with result object for each command\r\n     * @throws RedisException in case of any error\r\n     *\r\n     */\r\n    BatchResult<?> execute() throws RedisException;\r\n```\r\n\r\nRead above tips, I was not sure about responses order for origin commands.\r\nCould you help me make sure about this?\r\n\r\n1.When commands send group by slots, but I want know responses order is right with original commands?\r\n\r\n\r\nthx~ ",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3390/comments",
    "author": "waylink",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2021-01-29T07:03:15Z",
        "body": "You'll always get correct response, but in cluster environment result in BatchResult can have different order."
      },
      {
        "user": "mrniko",
        "created_at": "2021-01-31T09:37:01Z",
        "body": "result has different order since single request spliced into different requests and executed concurrently on different Redis nodes. If keys of such commands don't belong to the same master node."
      },
      {
        "user": "mrniko",
        "created_at": "2021-02-05T06:19:14Z",
        "body": "It's better to attach handler to each command executed in RBatch rather than use result list:\r\n\r\n```java\r\n\t\tRBatch batch = client.createBatch(batchOptions);\r\n\t\tfor (int i = 0; i < 10; i++) {\r\n\t\t\tString key = \"\" + i;\r\n                        RFuture<Object> t = batch.getBucket(key).getAsync();\r\n                        t.whenComplete((res, ex) -> {\r\n                \r\n                       });\r\n\t\t}\r\n\t\tbatch.execute();\r\n```"
      }
    ]
  },
  {
    "number": 3374,
    "title": "time_to_live and max_idle_time doesn't work in redisson as 2 level cache in hibernate",
    "created_at": "2021-01-22T10:31:32Z",
    "closed_at": "2021-01-23T05:12:18Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3374",
    "body": "Hello everybody,\r\nI try to use Redisson  as second level cache in my jpa spring boot application it works fine i see that it cache entities in redis it just i need to set a time to live and time to idle on cache entries i use this configuration below but it doesn't work:\r\n\r\n`spring.jpa.properties.hibernate.cache.use_second_level_cache=true\r\nspring.cache.type=redis\r\n\r\nhibernate.cache.redisson.entity.expiration.time_to_live=1000\r\nhibernate.cache.redisson.entity.expiration.max_idle_time=1000\r\nhibernate.cache.redisson.collection.expiration.time_to_live=1000\r\nhibernate.cache.redisson.collection.expiration.max_idle_time=1000\r\n\r\nspring.jpa.properties.hibernate.cache.region.factory_class=org.redisson.hibernate.RedissonRegionFactory\r\nspring.jpa.properties.hibernate.cache.redisson.config=redisson/redisson-dev.yaml\r\nspring.jpa.properties.hibernate.cache.redisson.fallback=true\r\nspring.jpa.properties.javax.persistence.sharedCache.mode=ENABLE_SELECTIVE\r\n\r\nserver.port=8888\r\nspring.datasource.url=jdbc:h2:mem:testdb\r\nspring.datasource.driverClassName=org.h2.Driver\r\nspring.datasource.username=sa\r\nspring.datasource.password=\r\n\r\nspring.jpa.database-plateform=org.hibernate.dialect.H2Dialect\r\nspring.jpa.hibernate.ddl-auto=update\r\nspring.h2.console.enabled=true\r\nlogging.level.org.hibernate.SQL=DEBUG\r\nlogging.level.org.hibernate.type=TRACE\r\n`\r\n\r\ni use  redisson-hibernate-53  as dependancy\r\n\r\nAny help on this will help ,thank you.\r\n  \r\n\r\n\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3374/comments",
    "author": "yeagerrrr",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2021-01-22T12:07:55Z",
        "body": "I think spring config file doesn't pickup custom hibernate settings used by Redisson. Try to define them in hibernate config xml file"
      },
      {
        "user": "yeagerrrr",
        "created_at": "2021-01-22T12:32:22Z",
        "body": "it works !!!!!\r\ni just use : \r\n\r\nspring.jpa.properties.hibernate.cache.redisson.entity.expiration.time_to_live=1000\r\nspring.jpa.properties.hibernate.cache.redisson.entity.expiration.max_idle_time=1000\r\nspring.jpa.properties.hibernate.cache.redisson.collection.expiration.time_to_live=1000\r\nspring.jpa.properties.hibernate.cache.redisson.collection.expiration.max_idle_time=1000\r\n\r\nintead of : \r\n\r\nhibernate.cache.redisson.entity.expiration.time_to_live=1000\r\nhibernate.cache.redisson.entity.expiration.max_idle_time=1000\r\nhibernate.cache.redisson.collection.expiration.time_to_live=1000\r\nhibernate.cache.redisson.collection.expiration.max_idle_time=1000\r\n\r\n@mrniko thank you very much for your answer \ud83d\udc4d "
      }
    ]
  },
  {
    "number": 3108,
    "title": "RMap's values(pattern) doesn't seem to work on a simple test",
    "created_at": "2020-10-07T13:18:25Z",
    "closed_at": "2020-11-11T08:12:17Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/3108",
    "body": "The following simple test doesn't seem to work:\r\n```@Test\r\n    public void test() {\r\n\r\n        String mapName = UUID.randomUUID().toString();\r\n        RMap<String, String> map = redissonClient.getMap(mapName, JsonJacksonCodec.INSTANCE);\r\n\r\n        try {\r\n            map.put(\"prefix_1_1_\", \"1\");\r\n            map.put(\"prefix_1_2_\", \"2\");\r\n            map.put(\"prefix_2_3_\", \"3\");\r\n            map.put(\"prefix_2_4_\", \"4\");\r\n\r\n            Collection<String> entries = map.values(\"prefix*\");\r\n\r\n            assertThat(entries).hasSize(4);\r\n        } finally {\r\n            redissonClient.getMap(mapName).delete();\r\n        }\r\n    }\r\n```\r\nVersion of redisson is 3.13.4\r\nI'm pretty sure I'm missing something here so didn't post it as a bug",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/3108/comments",
    "author": "peterlitvak",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2020-10-07T14:33:27Z",
        "body": "You need to use StringCodec for map keys."
      },
      {
        "user": "peterlitvak",
        "created_at": "2020-10-07T14:42:31Z",
        "body": "Does it mean I need to create my own codec with JsonJacksoCodec for the values (since I need values to be JSON encoded objects) and StringCodec for the keys?"
      },
      {
        "user": "mrniko",
        "created_at": "2020-10-07T14:43:39Z",
        "body": "You can use CompositeCodec to use StringCodec for keys and JsonJacksonCodec for values"
      }
    ]
  },
  {
    "number": 2897,
    "title": "Strange characters on value when read data in other language",
    "created_at": "2020-07-06T18:45:50Z",
    "closed_at": "2020-07-07T11:43:46Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/2897",
    "body": "Hey there!\r\n\r\nI was wondering if it's possible to perform a simple operation like we do on Redis StackExchange (c#) client:\r\n\r\n```\r\nIDatabase db = redis.GetDatabase();\r\nstring value = \"abcdefg\";\r\nvar expires = 1000;\r\ndb.StringSet(\"mykey\", value, expires);\r\n...\r\nstring value = db.StringGet(\"mykey\");\r\nConsole.WriteLine(value); // writes: \"abcdefg\r\n```\r\n\r\nRight now I'm using a Map but I would like to make it simple as this example on C#. \r\n\r\n```\r\n    override fun put(collection: String, key: String, value: String, expiresInSeconds: Long) {\r\n        logger.info(\"Storing key $key into collection $collection\")\r\n        val cacheMap = getMapCache(collection)\r\n\r\n        cacheMap.put(key, value, 3600, TimeUnit.SECONDS)\r\n    }\r\n\r\n    private fun getMapCache(collection: String) = redissonClient.getMapCache<String, String>(\"any\", StringCodec())\r\n```\r\n\r\nWhen I try to retrieve values fro other clients like C# or Python, I got some strange characters on value like `????????\ufffd\u0003??????myvalue`.\r\n\r\nIs there any option to clear/remove those characters on Redisson and store it as plain string?\r\n\r\nIs there any option to store it simple as we do in C#?",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/2897/comments",
    "author": "daviddelucca",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2020-07-07T04:37:33Z",
        "body": "Here is how you can do the same with Redisson:\r\n\r\n```java\r\nRBucket b = redisson.getBucket(\"mykey\", StringCodec.INSTANCE);\r\nb.set(\"value\", 1, TimeUnit.SECONDS);\r\n\r\nb.get(); // = \"value\"\r\n```\r\n\r\n> When I try to retrieve values fro other clients like C# or Python, I got some strange characters on value like ????????\ufffd\ufffd??????myvalue.\r\n\r\nBecause default Redisson codec is `MarshallingCodec`"
      },
      {
        "user": "mrniko",
        "created_at": "2020-07-07T11:20:56Z",
        "body": "You can use StringCodec instead"
      }
    ]
  },
  {
    "number": 2888,
    "title": "Set Redisson config using AWS ElastiCache as Clustered Mode",
    "created_at": "2020-07-02T23:45:55Z",
    "closed_at": "2020-07-03T17:05:54Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/2888",
    "body": "Hey there!\r\n\r\nWhat is the proper way to configure Redisson when you have a AWS ElastiCache Redis running as Clustered Mode? I have tried to set using it as follows:\r\n\r\n```\r\n    val nodeAddress = \"redis://test-rest-encryption-0001-001.p0vefj.0001.use1.cache.amazonaws.com:6379\" \r\n    val config = Config()\r\n    val configCluster = config.useClusterServers().addNodeAddress(nodeAddress)\r\n    val client = Redisson.create(config)\r\n```\r\n\r\nNode endpoint: test-rest-encryption-0001-001.p0vefj.0001.use1.cache.amazonaws.com\r\nConfiguration endpoint: test-rest-encryption.p0vefj.clustercfg.use1.cache.amazonaws.com\r\n\r\nFor `nodeAddress`, I have tried to use configuration endpoint and node endpoint but fails in both case (connection timed out):\r\n\r\n```\r\n21:04:39.542 [main] WARN  o.r.cluster.ClusterConnectionManager - connection timed out: test-rest-encryption-0001-001.p0vefj.0001.use1.cache.amazonaws.com/172.31.19.41:6379\r\nException in thread \"main\" org.redisson.client.RedisConnectionException: Can't connect to servers!\r\n\tat org.redisson.cluster.ClusterConnectionManager.<init>(ClusterConnectionManager.java:144)\r\n\tat org.redisson.config.ConfigSupport.createConnectionManager(ConfigSupport.java:237)\r\n\tat org.redisson.Redisson.<init>(Redisson.java:117)\r\n\tat org.redisson.Redisson.create(Redisson.java:156)\r\n\tat aus.web.SessionManagerApplicationKt.main(SessionManagerApplication.kt:23)\r\nCaused by: io.netty.channel.ConnectTimeoutException: connection timed out: test-rest-encryption-0001-001.p0vefj.0001.use1.cache.amazonaws.com/172.31.19.41:6379\r\n\tat io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe$1.run(AbstractNioChannel.java:261)\r\n\tat io.netty.util.concurrent.PromiseTask.runTask(PromiseTask.java:98)\r\n\tat io.netty.util.concurrent.ScheduledFutureTask.run(ScheduledFutureTask.java:170)\r\n\tat io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:164)\r\n\tat io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:472)\r\n\tat io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:500)\r\n\tat io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:989)\r\n\tat io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)\r\n\tat io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)\r\n\tat java.base/java.lang.Thread.run(Thread.java:834)\r\n```\r\n\r\nAm I missing something?\r\n\r\n",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/2888/comments",
    "author": "daviddelucca",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2020-07-03T05:28:56Z",
        "body": "Is your application located in the same security group?"
      },
      {
        "user": "daviddelucca",
        "created_at": "2020-07-03T16:44:10Z",
        "body": "@mrniko I have figured part of the problem: the client throws an exception if I try to connect to cluster with option `Encryption in-transit` enabled. Does this client support Encryption in-transit and Encryption at-rest?\r\n\r\nI'm using version 3.5.6"
      },
      {
        "user": "mrniko",
        "created_at": "2020-07-03T17:04:01Z",
        "body": "use rediss:// prefix for SSL connection. And select latest Redisson version for new projects."
      }
    ]
  },
  {
    "number": 2842,
    "title": "How to retrieve DelayedQueue by name using getDelayedQueue",
    "created_at": "2020-06-17T02:39:53Z",
    "closed_at": "2020-06-17T14:42:38Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/2842",
    "body": "Want to understand how to retrieve delayed queue (RDelayedQueue) by name using getDelayedQueue method on org.redisson.api.RedissonClient. \r\n\r\nDoes it require to call redissonClient.getDelayedQueue(destinationQueue) every time before queuing a message as below or retrieve queue once and use it for every message queuing ?\r\n\r\nRDelayedQueue..offer(message, delayInMillisFromCurrent, TimeUnit.MILLISECONDS);",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/2842/comments",
    "author": "anilkonduru",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2020-06-17T04:52:10Z",
        "body": "No, you can store RDelayedQueue instance and use it."
      }
    ]
  },
  {
    "number": 2782,
    "title": "How to configure scheduling times? ",
    "created_at": "2020-05-19T03:56:55Z",
    "closed_at": "2020-05-19T05:29:49Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/2782",
    "body": "When using the periodic scheduling method\uff08e.g. RScheduledExecutorService.scheduleAtFixedRate\uff09, I want to stop scheduling after a specified number of times. What should I do?\r\nThanks!",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/2782/comments",
    "author": "hgqapp",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2020-05-19T05:29:49Z",
        "body": "You can implement this logic right in the task.\r\n\r\n```java\r\nclass RunnableTask implements Runnable {\r\n\r\n    @RInject\r\n    private RedissonClient redissonClient;\r\n\r\n    @RInject\r\n    private String taskId;\r\n\r\n    public void run() {\r\n         if (redissonClient.getAtomicLong(\"\").incrementAndGet() == 10) {\r\n              redissonClient.getExecutorService(\"\").cancelTask(taskId);\r\n         }\r\n    }\r\n}\r\n```"
      }
    ]
  },
  {
    "number": 2613,
    "title": "In a frequent job , sometime lock.tryLock() can not get lock",
    "created_at": "2020-02-25T15:10:58Z",
    "closed_at": "2020-02-28T05:28:28Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/2613",
    "body": "\t\t<dependency>\r\n\t\t\t<groupId>org.redisson</groupId>\r\n\t\t\t<artifactId>redisson-spring-boot-starter</artifactId>\r\n\t\t\t<version>2.15.2</version>\r\n\t\t</dependency>\r\nIn a spring boot 1.5.6 application , We have a new job which is running every 30 seconds and try to acquire lock to do something . In recent days the job has tried to acquire one specific lock cause of business , We found from 00:13 on Feb 24  the job can not get the lock but after 15:03 the job can get the lock again . The operation on this lock only in this job . \r\nthe code on the lock as below :\r\n\r\n        boolean res = lock.tryLock();\r\n        if (res) {\r\n            try {\r\n                ...\r\n            } finally {\r\n                if (lock.isHeldByCurrentThread())\r\n                    lock.unlock();\r\n            }\r\n        } else {\r\n            LockUtils.logLockError(lockName, amount, null, \"consume balance\");\r\n            msg = String.format(\"acquire merchant account lock (%s)failed\", lockName);\r\n        }\r\n\r\nThanks\r\n\r\n\r\n\r\n\r\n ",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/2613/comments",
    "author": "mi13chael",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2020-02-25T15:13:50Z",
        "body": "I would recommend to remove `if (lock.isHeldByCurrentThread())` this check since unlock should be invoked in any case."
      },
      {
        "user": "mi13chael",
        "created_at": "2020-02-25T15:17:55Z",
        "body": "I think if the lock acquired in another thread , unlock should be invoked in that thread .\r\n"
      },
      {
        "user": "mrniko",
        "created_at": "2020-02-25T15:46:19Z",
        "body": "I don't see any other reason except dealy in code execution between braces."
      },
      {
        "user": "mrniko",
        "created_at": "2020-02-25T15:47:33Z",
        "body": "> I think if the lock acquired in another thread , unlock should be invoked in that thread .\r\n\r\nall the more you don't need to add this check."
      },
      {
        "user": "mi13chael",
        "created_at": "2020-02-26T02:12:33Z",
        "body": "That is a point to catch who is operating the lock in the meantime."
      }
    ]
  },
  {
    "number": 2576,
    "title": "How to know if RedissonMap is created at redis end ",
    "created_at": "2020-02-07T09:29:53Z",
    "closed_at": "2020-02-07T09:32:08Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/2576",
    "body": "Is there a way to know if a map with given name is created at redis end. As per understanding, org.redisson.api.RedissonClient.getMap(java.lang.String name) always gives new RedissonMap and only creates interacts with redis when one does any map operations like get/put. \r\nWhich means Using org.redisson.api.RedissonClient.getMap(java.lang.String name) will not send any request to redis ?\r\nSo how can i know that if a map with given name already exists at redis end using any of the redisson apis? ",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/2576/comments",
    "author": "SushmaReddyLoka",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2020-02-07T09:32:08Z",
        "body": "use `RMap.isExists` method"
      },
      {
        "user": "mrniko",
        "created_at": "2020-02-07T13:33:49Z",
        "body": "> gives new RedissonMap and only creates interacts with redis when one does any map operations like get/put.\r\n\r\nYes, RMap is fully stateless on Redisson side."
      }
    ]
  },
  {
    "number": 2538,
    "title": "\u6570\u636e\u7c7b\u578b\u95ee\u9898",
    "created_at": "2020-01-13T07:40:33Z",
    "closed_at": "2020-01-13T08:12:31Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/2538",
    "body": "\u6211\u7528spring\u4e2d\u7684@cacheable\u65f6\uff0c\u4ece\u6570\u636e\u5e93\u4e2d\u53d6\u51fa\u6765\u51c6\u5907\u5e8f\u5217\u5316\u5b58\u5230redis\u4e2d\u7684\u6570\u636e\u662fByte\u7c7b\u578b\uff0c\u4f46\u662f\u518d\u4eceredis\u4e2d\u67e5\u51fa\u6765\u8fd4\u56de\u7684\u5374\u662fInteger\uff0c\u8fd9\u4e2a\u662f\u9700\u8981\u4fee\u6539redisson\u7684\u6570\u636e\u5e8f\u5217\u5316\u65b9\u5f0f\u5417\uff1f\u6211\u8bd5\u4e86\u4e00\u4e0b\u5305\u88c5\u7c7bShort\u3001Byte\u90fd\u4f1a\u53d8\u6210Integer\uff0cCharacter\u4f1a\u53d8\u6210String\uff0cFloat\u4f1a\u53d8\u6210Double\u3002",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/2538/comments",
    "author": "MarionSong",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2020-01-13T08:06:07Z",
        "body": "Which codec do you use?"
      },
      {
        "user": "MarionSong",
        "created_at": "2020-01-13T08:10:45Z",
        "body": "JsonJacksonCodec"
      },
      {
        "user": "mrniko",
        "created_at": "2020-01-13T08:12:31Z",
        "body": "Switch to FST, KryoCodec or SerializationCodec"
      }
    ]
  },
  {
    "number": 2488,
    "title": "java.lang.ClassNotFoundException: org.springframework.data.redis.connection.RedisStreamCommands ",
    "created_at": "2019-12-18T02:04:35Z",
    "closed_at": "2019-12-18T07:28:00Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/2488",
    "body": "Hello \r\n         I just submitted two questions that didn't work. The reason is that I pressed the wrong key(ctrl + enter on windows). I'm sorry to be embarrassed. My problem is that I use springboot version 2.1.11.RELEASE and the redisson-spring-boot-starter version is 3.11.  .6, the error is the same as the title. I checked issue 2478 and suggested that he downgrade to redisson-spring-data-21. If it is redisson-spring-boot-starter, what version should he downgrade to?",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/2488/comments",
    "author": "LayJustDoIt",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2019-12-18T07:27:57Z",
        "body": "You need to downgrade to redisson-spring-data-21 only"
      }
    ]
  },
  {
    "number": 1706,
    "title": "What is the best practice for setting local caches ttl against Redis caches?",
    "created_at": "2018-10-30T07:35:33Z",
    "closed_at": "2018-10-31T12:15:57Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/1706",
    "body": "Is it correct if Redis cache ttl is the same as timeToLiveInMillis for local cache?\r\n\r\nMY_CACHE: \r\n ttl: 300000\r\n maxIdleTime: 300000\r\n maxSize: 1000\r\n \r\n localCacheOptions:\r\n    evictionPolicy: \"LRU\"\r\n    reconnectionStrategy: \"CLEAR\"\r\n    syncStrategy: \"INVALIDATE\"\r\n    writeMode: \"WRITE_THROUGH\"\r\n    cacheSize: 1000\r\n    timeToLiveInMillis: 300000\r\n    maxIdleInMillis: 300000",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/1706/comments",
    "author": "bkoroliuk-amplify",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2018-10-30T08:12:59Z",
        "body": "Do you use RMapCache and RLocalCachedMapCache under the same name?"
      },
      {
        "user": "mrniko",
        "created_at": "2018-10-30T08:55:39Z",
        "body": "That's a bad idea, since compatibility between these objects is not guaranteed."
      },
      {
        "user": "bkoroliuk-amplify",
        "created_at": "2018-10-30T08:58:34Z",
        "body": "What about this setup? (max ttl for local caches)\r\n```\r\nMY_CACHE:\r\nttl: 300000\r\nmaxIdleTime: 300000\r\nmaxSize: 1000\r\n\r\nlocalCacheOptions:\r\nevictionPolicy: \"LRU\"\r\nreconnectionStrategy: \"CLEAR\"\r\nsyncStrategy: \"INVALIDATE\"\r\nwriteMode: \"WRITE_THROUGH\"\r\ncacheSize: 1000\r\ntimeToLiveInMillis: 0\r\nmaxIdleInMillis: 0\r\n```\r\n"
      },
      {
        "user": "mrniko",
        "created_at": "2018-10-30T09:04:48Z",
        "body": "That config looks correct. What is your concerns about it?"
      }
    ]
  },
  {
    "number": 1687,
    "title": "Default values for local cache in RedissonSpringLocalCachedCacheManager",
    "created_at": "2018-10-23T14:46:37Z",
    "closed_at": "2018-10-24T17:45:39Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/redisson/redisson/issues/1687",
    "body": "What are default values for the mentioned below properties?\r\nAre these values from LocalCachedMapOptions::defaults()?\r\nI see that local caches work, but only ttl, idle and maxSize are defined.\r\n```\r\n localCacheOptions:\r\n    evictionPolicy: \"LRU\"\r\n    reconnectionStrategy: \"CLEAR\"\r\n    syncStrategy: \"UPDATE\"\r\n    writeMode: \"WRITE_THROUGH\"\r\n    cacheSize: 1000\r\n    timeToLiveInMillis: 300000\r\n    maxIdleInMillis: 300000\r\n```",
    "comments_url": "https://api.github.com/repos/redisson/redisson/issues/1687/comments",
    "author": "bkoroliuk-amplify",
    "comments": [
      {
        "user": "mrniko",
        "created_at": "2018-10-24T14:39:26Z",
        "body": "> What are default values for the mentioned below properties?\r\n\r\nevictionPolicy = NONE,\r\nreconnectionStrategy = NONE,\r\nsyncStrategy = INVALIDATE\r\nwriteMode = WRITE_THROUGH\r\ncacheSize = 0\r\ntimeToLiveInMillis = 0\r\nmaxIdleInMillis = 0\r\n\r\n> Are these values from LocalCachedMapOptions::defaults()?\r\n\r\nNo, seems config instance had been changed further in code."
      }
    ]
  }
]