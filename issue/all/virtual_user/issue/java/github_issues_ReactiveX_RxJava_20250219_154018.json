[
  {
    "number": 7732,
    "title": "Observable<T>.scan accumulator seems to be called twice",
    "created_at": "2024-07-14T16:09:17Z",
    "closed_at": "2024-07-14T17:36:11Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/7732",
    "body": "I am currently debugging why the scan {} accumulator lambda is getting invoked twice, even when only one event is getting emitted. It will however produce the correct result, because t will take correct previous count probably, resulting in the same updated count. I am developing an Android app but I don't know if that matters. Here's the logs:\r\n\r\n```\r\n2024-07-14 18:04:47.640  8672-8672  xyz                     app.example                          D  onEvent\r\n2024-07-14 18:04:47.640  8672-8672  xyz                     app.example                          D  new event: Increment\r\n2024-07-14 18:04:47.640  8672-8672  xyz                     app.example                          D  new event: Increment\r\n2024-07-14 18:04:47.649  8672-8672  xyz                     app.example                          D  got state: CounterState(count=1, message=Counter is greater than 0)\r\n```\r\n\r\nAnd the relevant parts of my codebase:\r\n\r\n```kotlin\r\nabstract class Presenter<S : State<out Event>> {\r\n\r\n  protected val subscriptions = CompositeDisposable()\r\n\r\n  protected val eventSink = PublishSubject.create<CounterEvent>()\r\n\r\n  abstract val mStateObservable: Observable<S>\r\n\r\n  fun onEvent(event: CounterEvent) {\r\n    Log.d(\"xyz\", \"onEvent\")\r\n    eventSink.onNext(event)\r\n  }\r\n}\r\n\r\nclass CounterPresenter : Presenter<CounterState>() {\r\n\r\n  private val count = eventSink.scan(0L) { count, event ->\r\n    Log.d(\"xyz\", \"new event: $event\")\r\n    when (event) {\r\n      CounterEvent.Increment -> count + 1\r\n      CounterEvent.Decrement -> count - 1\r\n    }\r\n  }\r\n\r\n  // ...\r\n\r\n  override val mStateObservable = Observable\r\n    .combineLatest(count, message) { count, message -> \r\n        CounterState(count, message) \r\n    }\r\n}\r\n```\r\n\r\n- version 3.1.8",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/7732/comments",
    "author": "itsandreramon",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2024-07-14T16:48:33Z",
        "body": "Is `onEvent` being called from multiple threads? Is the `count` Observable used more than once?\r\n\r\nIf neither, I suggest logging the stacktrace for the \"new event\" logs and see what chain triggered that particular call."
      },
      {
        "user": "itsandreramon",
        "created_at": "2024-07-14T17:35:09Z",
        "body": "yes It's mapped to another observable like this:\r\n\r\n```kotlin\r\n  private val message = count.map { count ->\r\n    when {\r\n      count < 0 -> \"Counter is less than 0\"\r\n      count > 0 -> \"Counter is greater than 0\"\r\n      else -> \"Counter is 0\"\r\n    }\r\n  }\r\n```\r\n\r\nremoving this code block results in the desired result. didn't expect it to call into accumulator again. thanks for the quick response!"
      },
      {
        "user": "akarnokd",
        "created_at": "2024-07-14T17:37:47Z",
        "body": "`.publish().autoConnect()`"
      }
    ]
  },
  {
    "number": 7555,
    "title": "3.x: Different behavior between blockingForEach and forEach",
    "created_at": "2023-04-17T13:54:15Z",
    "closed_at": "2023-04-18T07:21:58Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/7555",
    "body": "Hello,\r\n\r\nI'm surprise to see that the observable:\r\n```java\r\nObservable.just(0, 1, 2)\r\n    .doOnSubscribe(ignored -> LOG.info(\"On subscribe\"))\r\n    .doOnTerminate(() -> LOG.info(\"On terminate\"))\r\n```\r\n\r\nproduce the following result with `.forEach(i -> LOG.info(\"Data: {}\", i));`:\r\n```\r\n15:30:25.501 [main] INFO manual.NonBlockingTest - On subscribe\r\n15:30:25.501 [main] INFO manual.NonBlockingTest - Data: 0\r\n15:30:25.501 [main] INFO manual.NonBlockingTest - Data: 1\r\n15:30:25.501 [main] INFO manual.NonBlockingTest - Data: 2\r\n15:30:25.501 [main] INFO manual.NonBlockingTest - On terminate\r\n```\r\n\r\nand with `.blockingForEach(i -> LOG.info(\"Data: {}\", i));`:\r\n```\r\n15:32:04.932 [main] INFO manual.BlockingTest - On subscribe\r\n15:32:04.934 [main] INFO manual.BlockingTest - On terminate\r\n15:32:04.935 [main] INFO manual.BlockingTest - Data: 0\r\n15:32:04.936 [main] INFO manual.BlockingTest - Data: 1\r\n15:32:04.936 [main] INFO manual.BlockingTest - Data: 2\r\n```\r\n\r\nI expected to have the same result (subscribe, datas, terminate) with `blockingForEach` as with `forEach` without using any scheduler. I have the same result with `subscribe`.\r\n\r\nI tested with versions 3.1.3 and 3.1.6.\r\n\r\nThe documentation does not mention any difference between the two behaviors except that the blocking behavior blocks the current thread (which is what I want).\r\n\r\nDid I not understand correctly the difference between the two or it is a bug?\r\n\r\nThanks for your time.\r\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/7555/comments",
    "author": "JaquierM",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2023-04-17T14:05:18Z",
        "body": "Not a bug. `blockingForEach` has an internal blocking buffer that can fill up before the control reaches its consumer callbacks.\r\n\r\nIn such synchronous cases, the upstream produces all items plus the terminal signal upon subscription, before `blockingForEach` switches to its consumer loop. With asynchronous sources, the production will usually happen on some other thread so the switch to the consumer loop pretty much immediately."
      }
    ]
  },
  {
    "number": 7370,
    "title": "Update the object emitted by Single in async way",
    "created_at": "2021-12-07T13:19:56Z",
    "closed_at": "2021-12-07T13:33:25Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/7370",
    "body": "Hello, Could you please clarify whether I can update the object emitted by Single in async way by several methods?\r\nI have the folliwing code:\r\n```\r\nreturn Single.just(order)\r\n                .flatMap(o -> updateProducerInfo(o))\r\n                .flatMap(o -> updateCustomerInfo(o));\r\n\r\nprivate Single<Order> updateProducerInfo(Order order) {\r\n        // takes a long time\r\n    }\r\nprivate Single<Order> updateCustomerInfo(Order order) {\r\n        // takes a long time\r\n    }\r\n```\r\nIs there a way to execute these methods in parallel to reduce the overall execution time?",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/7370/comments",
    "author": "YauheniZarembin",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2021-12-07T13:31:22Z",
        "body": "Yes, provided both update methods touch independent parts of `Order`:\r\n\r\n```java\r\nreturn Single.zip(\r\n              updateProducerInfo(order).subscribeOn(Schedulers.io()),\r\n              updateCustomerinfo(order).subscribeOn(Schedulers.io()),\r\n              (a, b) -> order);\r\n```"
      }
    ]
  },
  {
    "number": 7327,
    "title": "How can I check completion of saving which is processed  in async way?",
    "created_at": "2021-08-26T13:36:31Z",
    "closed_at": "2021-08-26T16:16:30Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/7327",
    "body": "Hi. could you please clarify how I can wait async execution of saving?\r\nI Have the following methods in repository class.\r\n```\r\npublic Completable save(Book book) {\r\n        // logic to save book in DB\r\n    }\r\n\r\npublic Single<Boolean> exist(Book book) {\r\n        // logic to check if book exists in DB\r\n    }\r\n```\r\nAnd there is method in service that uses _save_ method from repository\r\n```\r\npublic Single<Book> saveBook(Book book) {\r\n        bookRepo.save(book);\r\n        return Sing.just(book);\r\n    }\r\n```\r\n\r\nThe problem is that after _saveBook_ method execution the book may not be in the database as saving is processed  in async way.\r\nHow can I change me _saveBook_ method using _exist_ method to be sure that after _saveBook_ method execution I will have the book in DB?",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/7327/comments",
    "author": "YauheniZarembin",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2021-08-26T13:53:24Z",
        "body": "You can compose them via `flatMapCompletable`, for example:\r\n\r\n```java\r\npublic Single<Book> saveBook(Book book) {\r\n    return exist(book)\r\n           .flatMapCompletable(exists -> exists ? Completable.complete() : bookRepo.save(book))\r\n           .andThen(Single.just(book));\r\n```"
      },
      {
        "user": "YauheniZarembin",
        "created_at": "2021-08-26T14:03:26Z",
        "body": "No, maybe I should clarify my case.\r\n\r\nAt First I have nothing in DB. Then I save book by _saveBook_ method from service.\r\nAfter that I want to update this book.\r\nBut when I try to receive book from DB for update I have nothing, as save is still executing very long in asycn way and DB is empty.\r\n\r\nSo in _saveBook_ method I want to wait to be sure that when I need to update book it will be in DB."
      },
      {
        "user": "akarnokd",
        "created_at": "2021-08-26T14:11:39Z",
        "body": "It depends on how you structured your save-update workflow.\r\n\r\nOne possibility is to cache the `saveBook` above; it will make sure the save runs at most once and there will be a value ready after, indicating the save completed.\r\n\r\n```java\r\nSingle<Book> bookCached = saveBook(book).cache();\r\nbookCached.subscribe(/* trigger the save */);\r\n\r\n// later\r\nbookCached\r\n  .flatMap(book -> updateBook(book))\r\n  .subscribe(/* trigger update */)\r\n```"
      },
      {
        "user": "YauheniZarembin",
        "created_at": "2021-08-26T15:05:32Z",
        "body": "@akarnokd Maybe I foung what I want.\r\nCould you please review is that a good way to check?\r\n\r\n```\r\npublic Single<Book> saveBook(Book book) {\r\n        bookRepo.save(book);\r\n        \r\n        boolean saved = Single.defer(() -> bookRepo.exist(book))\r\n                .repeat()\r\n                .takeUntil(b -> b)\r\n                .ignoreElements()\r\n                .blockingAwait(10000, TimeUnit.MILLISECONDS);\r\n                \r\n        if (saved) {\r\n            return Single.just(book);\r\n        } else {\r\n            //error\r\n        }\r\n  \r\n    }\r\n```\r\n\r\n\u0421an this code be simplified?"
      },
      {
        "user": "akarnokd",
        "created_at": "2021-08-26T15:44:28Z",
        "body": "That repeat will be very eagle, perhaps waiting a second may be preferable: `repeatWhen(o -> o.delay(1, TimeUnit.SECONDS))`.\r\n\r\nIf you block, there is no value in returning a `Single`. Also depending on where this code runs, you may not be allowed to block."
      }
    ]
  },
  {
    "number": 7317,
    "title": "What\u2018s the reason that \"relaying the upstream's Disposable directly is not allowed in RxJava\"?",
    "created_at": "2021-08-24T08:24:13Z",
    "closed_at": "2021-08-24T15:50:48Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/7317",
    "body": "Thanks check my question.\r\nWhen I implement `ObservableOperator`, find the comment \"Note that relaying the upstream's Disposable directly is not allowed in RxJava\" above observable operator `lift` sample.\r\nI searched net, but found nobody explains the reason.  If i follow the sample for `lift`\uff0c the class seems complex a little bit, but relay the upstream's Disposable,  the class seems more clean.\r\n```\r\npublic final class CustomObserver<T> implements Observer<T>, Disposable {\r\n\r\n     final Observer<? super String> downstream;\r\n\r\n     Disposable upstream;\r\n\r\n     public CustomObserver(Observer<? super String> downstream) {\r\n         this.downstream = downstream;\r\n     }\r\n\r\n     // In the subscription phase, the upstream sends a Disposable to this class\r\n     // and subsequently this class has to send a Disposable to the downstream.\r\n     // Note that relaying the upstream's Disposable directly is not allowed in RxJava\r\n     @Override\r\n     public void onSubscribe(Disposable d) {\r\n         if (upstream != null) {\r\n             d.dispose();\r\n         } else {\r\n             upstream = d;\r\n             downstream.onSubscribe(this);\r\n         }\r\n     }\r\n\r\n     @Override\r\n     public void onNext(T item) {\r\n         ... do something...\r\n     }\r\n\r\n     @Override\r\n     public void onError(Throwable throwable) {\r\n         downstream.onError(throwable);\r\n     }\r\n\r\n     @Override\r\n     public void onComplete() {\r\n         downstream.onComplete();\r\n     }\r\n\r\n     @Override\r\n     public void dispose() {\r\n         upstream.dispose();\r\n     }\r\n\r\n     @Override\r\n     public boolean isDisposed() {\r\n         return upstream.isDisposed();\r\n     }\r\n }\r\n\r\n```\r\n\r\n```\r\npublic final class CustomObserver<T> implements Observer<T>, Disposable {\r\n\r\n     final Observer<? super String> downstream;\r\n\r\n     Disposable upstream;\r\n\r\n     public CustomObserver(Observer<? super String> downstream) {\r\n         this.downstream = downstream;\r\n     }\r\n\r\n     // Not follow sample says\r\n     @Override\r\n     public void onSubscribe(Disposable d) {\r\n         downstream.onSubscribe(d);\r\n     }\r\n\r\n     @Override\r\n     public void onNext(T item) {\r\n         ... do something...\r\n     }\r\n\r\n     @Override\r\n     public void onError(Throwable throwable) {\r\n         downstream.onError(throwable);\r\n     }\r\n\r\n     @Override\r\n     public void onComplete() {\r\n         downstream.onComplete();\r\n     }\r\n}\r\n```",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/7317/comments",
    "author": "chxchen",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2021-08-24T10:17:14Z",
        "body": "It breaks operator fusion, which is detected by checking the `Disposable` sent via `onSubscribe`. If, for example, the upstream supports fusion and you relay that `Disposable` to the downstream, it will skip your operator and will talk to the upstream directly.\r\n\r\nIn general, it is rare not to intercept `dispose()` in an operator."
      },
      {
        "user": "chxchen",
        "created_at": "2021-08-24T11:14:32Z",
        "body": "> It breaks operator fusion, which is detected by checking the `Disposable` sent via `onSubscribe`. If, for example, the upstream supports fusion and you relay that `Disposable` to the downstream, it will skip your operator and will talk to the upstream directly.\r\n> \r\n> In general, it is rare not to intercept `dispose()` in an operator.\r\n\r\nThank you!\r\nDo you mean if an custom operator by `lift` is very simple, Relaying the upsteam's disposable does not make hidden error, but recommand to implement `Disposable` and delivery `this` to downstream?  (The simple operator just pass values to downstream.)"
      }
    ]
  },
  {
    "number": 7288,
    "title": "Using withLatestFrom completes without values if other publisher is delayed",
    "created_at": "2021-07-01T17:29:38Z",
    "closed_at": "2021-07-05T11:27:49Z",
    "labels": [
      "Question",
      "Documentation",
      "3.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/7288",
    "body": "**Version**:  3.0.12\r\n\r\nI am not sure if this is per-design and specification (could not find this), but is it really expected that:\r\n\r\n```\r\n      Flowable<Integer> integerFlowable = Flowable.just(1, 2, 3);\r\n      Flowable<Integer> delayedFlowable = Flowable.just(10).delay(1, TimeUnit.SECONDS);\r\n\r\n      integerFlowable.withLatestFrom(delayedFlowable, Integer::sum)\r\n              .test()\r\n              .assertValueCount(3)\r\n              .assertComplete();\r\n```     \r\n\r\nfails with:\r\n\r\n```\r\njava.lang.AssertionError: Value counts differ; expected: 3 but was: 0 (latch = 0, values = 0, errors = 0, completions = 1)\r\nExpected :3\r\nActual   :0 (latch = 0, values = 0, errors = 0, completions = 1)\r\n<Click to see difference>\r\n```\r\n\r\nIf it is, then Javadoc needs to be improved, it is not stated anywhere that this will complete with no values of the other publisher is emitting item after a delay. Of course this is a simple example, but you get the point. If these would be two database calls and second comes emits after the first one, you get nothing? :confused: \r\n\r\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/7288/comments",
    "author": "ivansenic",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2021-07-01T17:37:58Z",
        "body": "It is by design. If the upstream ends before any of the other sources had a chance to signal, the outcome is an empty sequence."
      },
      {
        "user": "ivansenic",
        "created_at": "2021-07-02T08:45:28Z",
        "body": "Thanks @akarnokd. I was checking the PR you made and you said this behavior is unlike the `combineLatest`, but in the test I did I also get similar error for:\r\n\r\n```\r\n      Flowable<Integer> integerFlowable = Flowable.just(1, 2, 3);\r\n      Flowable<Integer> delayedFlowable = Flowable.just(10).delay(1, TimeUnit.SECONDS);\r\n\r\n      Flowable.combineLatest(integerFlowable, delayedFlowable, Integer::sum)\r\n              .test()\r\n              .assertValueCount(3)\r\n              .assertComplete();\r\n```\r\n```\r\njava.lang.AssertionError: Value counts differ; expected: 3 but was: 0 (latch = 1, values = 0, errors = 0, completions = 0)\r\nExpected :3\r\nActual   :0 (latch = 1, values = 0, errors = 0, completions = 0)\r\n```\r\nOK here latch is reported as 1 and not the completion. So is this also expected per design? \r\n\r\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2021-07-02T08:58:07Z",
        "body": "Since you run with async flows, you have to use `.awaitDone(5, TimeUnit.SECONDS)` before asserting to let the code finish.\r\n\r\nAlso I don't think `combineLatest` would fit your intentions. `integerFlowable` would rush to \"3\" and you'd only get one combination of \"3-10\".\r\n\r\nIf you want all combinations, such as \"1-10\", \"2-10\", \"3-10\", you'll need `concatMap` and cached secondary flow:\r\n\r\n```java\r\nFlowable<Integer> integerFlowable = Flowable.just(1, 2, 3);\r\nFlowable<Integer> delayedFlowable = Flowable.just(10).delay(1, TimeUnit.SECONDS).cache();\r\n\r\nintegerFlowable.concatMap(main -> delayedFlowable.map(other -> Integer.sum(main, other)))\r\n              .test()\r\n              .awaitDone(5, TimeUnit.SECONDS)\r\n              .assertResult(11, 12, 13);\r\n```"
      }
    ]
  },
  {
    "number": 7281,
    "title": "Methos to() requires mock in unit test",
    "created_at": "2021-06-08T16:17:32Z",
    "closed_at": "2021-06-09T07:39:57Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/7281",
    "body": "Hi. could you please clarify question?\r\nI Have the following method\r\n```\r\npublic Single<Book> load(String bookName, String author) {\r\n        return bookRepo.load(bookName)\r\n                .switchIfEmpty(Observable.error(EntityNotFoundException::new))\r\n                .toList()\r\n                .flatMap(books-> bookService.loadbookByAuthor(Observable.fromIterable(books), autor)\r\n                        .switchIfEmpty(Maybe.error(() -> new ValidationErrorException()))\r\n                        .toSingle());\r\n    }\r\n```\r\n\r\nAnd I have unit test for this method. which works\r\n```\r\npublic void shouldValidatePolicyExists() {\r\n        when(bookRepo.load(any())).thenReturn(Observable.empty());\r\n\r\n        testObject.load(request).test()\r\n                .assertError(EntityNotFoundException.class)\r\n    }\r\n```\r\n\r\nI want to get rid of toList() in my method and found the following way\r\n```\r\npublic Single<Book> load(String bookName, String author) {\r\n        return bookRepo.load(bookName)\r\n                .switchIfEmpty(Observable.error(EntityNotFoundException::new))\r\n                .to(books-> bookService.loadbookByAuthor(books, autor)\r\n                        .switchIfEmpty(Maybe.error(() -> new ValidationErrorException()))\r\n                        .toSingle());\r\n    }\r\n```\r\nBut unit test does not work for this method implementation.\r\nIt does not return EntityNotFoundException and requires bookService is mocked.\r\nCould you please clarify why ?",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/7281/comments",
    "author": "YauheniZarembin",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2021-06-08T16:43:48Z",
        "body": "How is `loadbookByAuthor` implemented?\r\n\r\nSince your original used `flatMap`, the error just skipped the `loadbookByAuthor` entirely. With `to`, it is always executed and receives the error via `books`."
      },
      {
        "user": "YauheniZarembin",
        "created_at": "2021-06-08T17:02:41Z",
        "body": "@akarnokd \r\n`loadbookByAuthor` just filters observable\r\n\r\n```\r\npublic Maybe<Book> loadbookByAuthor (Observable<Book> books, String author) {\r\n        return books\r\n                .filter(txInTerm -> TransactionRoutine.isEffectiveOnDate(txInTerm, onDate))\r\n                .firstElement();\r\n    }\r\n```\r\nBut, the problem is that I can't change it.\r\n\r\nThen I will reformulate the question : \r\nHow can I change the first method to get rid of toList() without changing `loadbookByAuthor ` ?\r\n\r\nNow I convert Observable `toList()` and then make from it Observable again. For many books I suppose It will affect performance.\r\n\r\nThank you!\r\n\r\n\r\n\r\n\r\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2021-06-08T17:46:54Z",
        "body": "It is a bit convoluted to do it. Try\r\n\r\n```java\r\nbookRepo.load(bookName)\r\n    .switchIfEmpty(Observable.error(EntityNotFoundException::new))\r\n    .publish(o -> \r\n        o.take(1)\r\n        .flatMap(v -> \r\n            bookService.loadbookByAuthor(o.startWith(v), autor)   \r\n            .switchIfEmpty(Maybe.error(() -> new ValidationErrorException()))\r\n            .toObservable()\r\n        )\r\n    )\r\n    .toSingle()\r\n```"
      }
    ]
  },
  {
    "number": 7158,
    "title": "intervalRange behaviour",
    "created_at": "2021-01-23T18:25:25Z",
    "closed_at": "2021-01-24T13:25:19Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/7158",
    "body": "As per documentation `intervalRange` : \r\n>The sequence completes immediately after the last value (start + count - 1) has been reached.\r\n\r\nWhich mean `doOnComplete` is called directly once the last interval is reached (and not _completed_)\r\n\r\n```\r\nprivate fun launchQuestionGame() {\r\n        Flowable\r\n            .fromIterable(mQuestions.asIterable()) // mQuestions contains 3 items\r\n\r\n            .zipWith(\r\n                startTimeIntervalAndCancelItUponUnUneButtonClick(mQuestions.size + 1)\r\n\r\n                    .observeOn(AndroidSchedulers.mainThread())\r\n                    .doOnEach {\r\n                        onEachIntervalEmittion(it)\r\n                    }\r\n\r\n                    .repeat(mQuestions.size.toLong()), // repeat the interval mQuestions.size.toLong() times.\r\n\r\n                BiFunction { t1: Question, _: Long ->\r\n                    Timber.d(t1.toString())\r\n                    doOnCompleteEachFile(t1)\r\n                })\r\n\r\n            .doOnComplete {\r\n                Timber.d(\"doOnComplete\")\r\n                doOnCompleteAllFiles()\r\n            }\r\n\r\n            .subscribe()\r\n    }\r\n```\r\n\r\n2021-01-23 18:38:49.526 17549-17549/ Item 1\r\n2021-01-23 18:38:53.531 17549-17549/ Item 2\r\n2021-01-23 18:38:57.527 17549-17549/ Item 3\r\n2021-01-23 18:38:57.544 17549-17549/ doOnComplete\r\n\r\nI tried to delay before `doOnComplete` but it doesn't work.\r\n\r\nIs there anyway to have `doOnComplete` called after the last interval is finished ?",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/7158/comments",
    "author": "cloudshooterhuman",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2021-01-23T19:11:42Z",
        "body": "I don't understand your question. If you want to execute `doOnComplete` with a similar delay as between the items, append a timer:\r\n\r\n```kotlin\r\n\r\n     .zipWith ( ... )\r\n     .concatWith(Completable.timer(4, TimeUnit.SECONDS))\r\n     .doOnComplete {\r\n           Timber.d(\"doOnComplete\")\r\n           doOnCompleteAllFiles()\r\n      }\r\n```"
      },
      {
        "user": "cloudshooterhuman",
        "created_at": "2021-01-23T19:56:19Z",
        "body": "Thank you it did  work gracfully. just curious, why `delay` didn't have the same effect as ` .concatWith(Completable.timer(4, TimeUnit.SECONDS))` ?\r\n"
      }
    ]
  },
  {
    "number": 7137,
    "title": "2.x: Question about threading and doFinally()",
    "created_at": "2020-12-22T10:34:42Z",
    "closed_at": "2020-12-22T12:07:10Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/7137",
    "body": "I am using RxJava 2 on Android. The modifyUi() function inside doFinally() should be called from main thread only.\r\n```\r\ntask_1\r\n    .subscribeOn(Schedulers.io())\r\n    .doOnSuccess { ... }\r\n    .flatMap { \r\n        task_2\r\n            .subscribeOn(Schedulers.io()) \r\n    }\r\n    .observeOn(AndroidSchedulers.mainThread())\r\n    .doFinally { modifyUi() }\r\n```\r\nHowever, there are certain edge cases where observeOn() is ignored and doFinally() is fired in background.\r\n\r\nQuestion 1: What these cases can be? So far, I've discovered only one of them - a very fast disposing of the chain. If I add\r\n```\r\n.doOnSubscribe { it.dispose() }\r\n```\r\nright after doFinally(), observeOn() becomes ignored, so doFinally() is fired from background. Why is that and what the other cases can be?\r\n\r\nQuestion 2: Is there any reliable way to clean up the chain once it's done that can be set to a particular thread? As I see, doFinally() fails in some cases. Should I resort to duplicating the cleanup code in onSuccess() and onError() methods of the observer/consumer in subscribe()?",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/7137/comments",
    "author": "BorisLaskov",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2020-12-22T10:51:43Z",
        "body": "`doFinally` can run when the downstream disposes on whatever thread it is on, thus `observeOn` has likely no effect. You can apply `unsubscribeOn` after `doFinally` to make sure any dispose call is routed to the desired thread."
      }
    ]
  },
  {
    "number": 7056,
    "title": "3.x: Observable.window(count, skip) completes windows when there are no observers",
    "created_at": "2020-08-16T18:36:01Z",
    "closed_at": "2020-08-20T08:28:00Z",
    "labels": [
      "Question",
      "3.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/7056",
    "body": "RxJava version: 3.0.5\r\nOS: Android\r\n\r\nHi, in addition to #7048. Here are two failed test cases:\r\n\r\n**Test case 1:**\r\n```kotlin\r\n@Test\r\npublic void cancelAfterAbandonmentSize() {\r\n    PublishSubject<Integer> ps = PublishSubject.create();\r\n    AtomicReference<Observable<Integer>> firstWindow = new AtomicReference<>();\r\n    TestObserver<Observable<Integer>> to = ps.window(3, 1)\r\n            .doOnNext((window) -> {\r\n                if (!firstWindow.compareAndSet(null, window)) {\r\n                    window.subscribe();\r\n                }\r\n            })\r\n            .test();\r\n\r\n    assertTrue(ps.hasObservers());\r\n\r\n    ps.onNext(1);\r\n    ps.onNext(2);\r\n\r\n    to.dispose();\r\n\r\n    firstWindow.get()\r\n            .test()\r\n            .assertValues(1, 2);\r\n}\r\n```\r\n\r\nThis test will fail with following description:\r\n`Value count differs; expected: 2 [1, 2] but was: 1 [1] (latch = 0, values = 1, errors = 0, completions = 1)`\r\n\r\n**Test case 2:**\r\n```kotlin\r\n@Test\r\npublic void cancelAfterAbandonmentSize() {\r\n    PublishSubject<Integer> ps = PublishSubject.create();\r\n\r\n    TestObserver<Integer> to = ps.window(3)\r\n            .flatMap((window) -> window.delaySubscription(1, TimeUnit.SECONDS))\r\n            .test();\r\n\r\n    ps.onNext(1);\r\n    ps.onNext(2);\r\n    ps.onNext(3);\r\n\r\n    to.dispose();\r\n\r\n    to.assertValues(1, 2, 3);\r\n}\r\n```\r\n\r\nThis test will fail with following description:\r\n`Value count differs; expected: 3 [1, 2, 3] but was: 0 [] (latch = 1, values = 0, errors = 0, completions = 0, disposed!)`\r\n\r\n**Question**\r\nThis is correct behavior?",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/7056/comments",
    "author": "amihusb",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2020-08-16T19:47:33Z",
        "body": "Test case 1 does not subscribe to the first window in time thus the window gets abandoned and completed. This is the expected behavior.\r\n\r\nTest case 2 disposes the sequence and thus the abandoned windows will have no opportunity to emit their only item."
      },
      {
        "user": "arkivanov",
        "created_at": "2020-08-28T19:12:45Z",
        "body": "@akarnokd There is a notice in the JavaDocs:\r\n\r\n> Note that ignoring windows or subscribing later (i.e., on another thread) will result in\r\n> so-called window abandonment where a window may not contain any elements. In this case, subsequent\r\n> elements will be dropped until the condition for the next window boundary is satisfied. The behavior is\r\n> a trade-off for ensuring upstream cancellation can happen under some race conditions.\r\n\r\nCould you kindly describe in more detail what kind of race conditions? From my point of view we can consider windows \"active\" once emitted, and care only about disposal of windows. And since they are `UnicastSubject`s, there can be only one subscription and only one disposal per window. E.g. if downstream is disposed but there is an \"active\" window, then upstream stays subscribed, unless the last window is (possibly subscribed) and disposed.\r\n\r\nI would appreciate your comments here."
      },
      {
        "user": "akarnokd",
        "created_at": "2020-08-28T19:26:42Z",
        "body": "> there can be only one subscription\r\n\r\nUp to one subscription. If such subscription ever happens then the upstream may never know it has to stop sending events. The race can happen in some operators, such as `flatMap` for example, which hard-cuts its `onNext` processing upon an asynchronous cancellation, thus the emitted inner window may never see an observer/subscriber.\r\n\r\n"
      }
    ]
  },
  {
    "number": 7054,
    "title": "The worker thread failed to start work using subscribeOn(Schedulers.computation())",
    "created_at": "2020-08-14T01:34:18Z",
    "closed_at": "2020-08-15T06:52:54Z",
    "labels": [
      "Question",
      "Android",
      "3.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/7054",
    "body": "**The libraries** that I included:\r\n\r\n    implementation 'io.reactivex.rxjava3:rxandroid:3.0.0'\r\n    implementation 'io.reactivex.rxjava3:rxjava:3.0.5'\r\n    implementation 'com.trello.rxlifecycle4:rxlifecycle-components:4.0.0'\r\n\r\n**My code** is just like this:\r\n\r\n```Java\r\n    private void doLogin() {\r\n        Observable.create((ObservableOnSubscribe<Boolean>) emitter -> {\r\n            Log.i(\"starting\");\r\n            while (true) {\r\n                try {\r\n                    boolean success = mLoginModule.login();\r\n                    if (!success) {\r\n                        KLog.d(\"login failed! No. \" + mLoginTimes + \", \" + ToolKits.getLastError());\r\n\r\n                        mLoginTimes++;\r\n                        emitter.onNext(false);\r\n                    } else {\r\n                        emitter.onNext(true);\r\n                        emitter.onComplete();\r\n                        break;\r\n                    }\r\n\r\n                    if (mLoginTimes > 100) {\r\n                        emitter.onComplete();\r\n                        break;\r\n                    }\r\n\r\n                    Thread.sleep(1000);\r\n                } catch (Exception e) {\r\n                }\r\n            }\r\n        }).subscribeOn(Schedulers.computation())\r\n                .observeOn(AndroidSchedulers.mainThread())\r\n                .compose(bindToLifecycle())\r\n                .subscribe(new Observer<Boolean>() {\r\n                    @Override\r\n                    public void onSubscribe(@NonNull Disposable d) {\r\n                    }\r\n\r\n                    @Override\r\n                    public void onNext(@NonNull Boolean result) {\r\n                        onLoginResult(result);\r\n                    }\r\n\r\n                    @Override\r\n                    public void onError(@NonNull Throwable e) {\r\n                        Log.i(\"onError\");\r\n                    }\r\n\r\n                    @Override\r\n                    public void onComplete() {\r\n                        Log.i(\"onComplete\");\r\n                    }\r\n                });\r\n    }\r\n\r\npublic class MyActivity extends RxAppCompatActivity {\r\n    protected void onCreate(Bundle savedInstanceState) {\r\n          ..........\r\n                 doLogin();\r\n          ..........\r\n\r\n    }\r\n}\r\n\r\n\r\n```\r\n\r\n\r\n**What I encountered** was sometimes the login work just failed to start, even the log output \"starting\" did not come out. But when the activity was destroyed, onComplete got printed out. So I guess there's something wrong with Schedulers.computation. Then I changed it to subscribeOn(Schedulers.newThread()) and it seemed just ok.\r\n\r\nWhat's the problem? Did I misuse something or is there a bug in RxJava or RxAndroid?\r\nThanks!\r\n\r\n\r\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/7054/comments",
    "author": "lancewoo",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2020-08-14T07:01:49Z",
        "body": "`Schedulers.computation` is the wrong kind of scheduler to be used with blocking operations. It has a limited number of threads so when it is exhausted by blocking flows, you'll end up with hangs."
      },
      {
        "user": "lancewoo",
        "created_at": "2020-08-15T01:31:56Z",
        "body": "> \r\n> \r\n> `Schedulers.computation` is the wrong kind of scheduler to be used with blocking operations. It has a limited number of threads so when it is exhausted by blocking flows, you'll end up with hangs.\r\n\r\nYes, login() is a blocking method.\r\nThat's the only place where I used RxJava in the whole application, nowhere else. Does it concern with other threads created in other Android ways? Which scheduler would be suggested then in this situation, `Schedulers.newThread()` or `Schedulers.io()`?\r\nThanks!"
      },
      {
        "user": "akarnokd",
        "created_at": "2020-08-15T06:52:54Z",
        "body": "The io scheduler."
      }
    ]
  },
  {
    "number": 7045,
    "title": "Is it possible to run a multistage pipeline in parallel?",
    "created_at": "2020-08-02T05:25:22Z",
    "closed_at": "2020-08-02T15:22:18Z",
    "labels": [
      "Question",
      "3.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/7045",
    "body": "Hi, suppose I have a query that entails a multi-stage pipeline of operations (e.g., `map(x -> intenseComputation(x)).map(...).map(...)...`)\r\nIs it possible to implement such a query using multiple threads where each thread handles a stage of the computation (e.g., a single `map`)?\r\n\r\nTo illustrate,\r\ninput items -> map1 (assigned to thread1) -> map2 (thread2) -> map3 (thread3) ... -> Observer\r\n\r\nI read the documentation of RxJava and checked many related materials, but now I only found codes and tutorials that taught me how to distribute the input items to multiple threads, where each thread runs the same query (e.g., using `flatMap(o -> ...subscribeOn(...))`).\r\n\r\nCan someone help me to answer this question or refer me to some related materials? \r\nThanks a lot!\r\n\r\nBTW, I am using RxJava version 3.05.",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/7045/comments",
    "author": "Ohyoukillkenny",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2020-08-02T06:51:45Z",
        "body": "Put `observeOn` between the stages."
      }
    ]
  },
  {
    "number": 7019,
    "title": "App Crash when ObserveOn Android main thread",
    "created_at": "2020-06-28T07:54:41Z",
    "closed_at": "2020-06-28T08:00:53Z",
    "labels": [
      "Question",
      "Android",
      "3.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/7019",
    "body": "**Issue** \r\nI try to implement observeOn **AndroidSchedulers.mainThread()** But it always crash \r\nif I remove this line it working fine \r\n\r\n       myObservable = Observable.fromArray(intArray);\r\n       myObservable.subscribeOn(Schedulers.io())\r\n        .observeOn(AndroidSchedulers.mainThread()).\r\n         subscribeWith(getObserver());\r\n\r\n**Error Log** \r\n\r\n        java.lang.BootstrapMethodError: Exception from call site #1 bootstrap method\r\n        at io.reactivex.rxjava3.android.schedulers.AndroidSchedulers.<clinit>(AndroidSchedulers.java:33)\r\n        at io.reactivex.rxjava3.android.schedulers.AndroidSchedulers.mainThread(AndroidSchedulers.java:44)\r\n        at com.example.rxjavasample.SecondActivity.onCreate(SecondActivity.java:38)\r\n\r\n\r\n**Gradle dependencies** \r\n\r\n\r\n    implementation \"io.reactivex.rxjava3:rxjava:3.0.4\"\r\n    implementation 'io.reactivex.rxjava3:rxandroid:3.0.0' ",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/7019/comments",
    "author": "RanjithTawari",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2020-06-28T08:00:53Z",
        "body": "You probably have to set your project to Java 8 mode:\r\n\r\n```groovy\r\ncompileOptions {\r\n    sourceCompatibility JavaVersion.VERSION_1_8\r\n    targetCompatibility JavaVersion.VERSION_1_8\r\n}\r\n```"
      }
    ]
  },
  {
    "number": 6998,
    "title": "3.x Amb operator is not cancelling the other sources once one source completes",
    "created_at": "2020-05-26T22:01:16Z",
    "closed_at": "2020-05-27T15:48:34Z",
    "labels": [
      "Question",
      "3.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/6998",
    "body": "Using library io.reactivex.rxjava3:rxjava:3.0.3\r\n\r\nDepending on the order you declare the sources on the amb operator, the source gets cancelled or not. See code snippet below:\r\n```Kotlin\r\n@Test\r\nfun ambTest() {\r\n  var just = Maybe.just(\"test\")\r\n  val cancellable = object : Cancellable {\r\n    var cancelled = false\r\n    override fun cancel() {\r\n      cancelled = true\r\n    }\r\n  }\r\n  val never = Maybe.create<String> { it.setCancellable(cancellable) }\r\n  var value: String? = null\r\n  // This doesn't work\r\n  Maybe.amb(listOf(just, never)).subscribe { value = it }\r\n  // But this works\r\n  // Maybe.amb(listOf(never, just)).subscribe { value = it }\r\n  assertThat(value).isEqualTo(\"test\")\r\n  // The following line fails if you declare just first instead of never.\r\n  assertThat(cancellable.cancelled).isTrue()\r\n}\r\n```\r\nI would expect that regardless of the order in which you pass the MaybeSources to the `amb` operator, whenever one of them completes, the other are cancelled.\r\n\r\nI found this bug by accident when writing another unit test which sometimes worked and sometimes didn't work. It seemed like a race condition but when I reduced it to the above example it is no longer random. In my case I think it was random because I was building the list from a HashSet so maybe the order was randomly changing each time.\r\n\r\nIf there is a workaround for this, that would be great. Maybe using some schedulers fixes it?\r\n\r\nThanks.",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/6998/comments",
    "author": "JurgenCruz",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2020-05-27T07:57:24Z",
        "body": "If a source completes while the subscriptions are still going on, those sources will not be subscribed and thus not get cancelled.\r\n\r\nWhat is your use case that needs your sources to always start?"
      },
      {
        "user": "JurgenCruz",
        "created_at": "2020-05-27T15:22:32Z",
        "body": "So you are saying that the sources that are not cancelled are also not subscribed and thus should not be active anyway? I had not considered that.\r\n\r\nThe use case in my program was that the sources might be hot sources that are waiting for a cancelation signal to cleanup. Also, even if it is not hot, if the method has side effects, even if it is not subscribed, the side effects will be called. This can be mitigated with a `defer` I guess.\r\n\r\nIs there a way to test if `never` was actually never subscribed to? if I can do an `or` such that it was never subscribed or was cancelled, my unit test will pass."
      },
      {
        "user": "akarnokd",
        "created_at": "2020-05-27T15:25:02Z",
        "body": "There is the `doOnSubscribe` operator that gets called if a subscription is passing through."
      },
      {
        "user": "JurgenCruz",
        "created_at": "2020-05-27T15:26:10Z",
        "body": "Thanks, I'll give it a try and update with my findings.\r\nEdit:\r\n\r\nIt works as expeted. new Unit Test:\r\n\r\n```kotlin\r\n  @Test\r\n  fun ambTest() {\r\n    val just = Maybe.just(\"test\")\r\n    var cancelled = false\r\n    var subscribed = false\r\n    val never = Maybe.create<String> {\r\n      it.setCancellable { cancelled = true }\r\n    }.doOnSubscribe { subscribed = true }\r\n    var value: String? = null\r\n    // This works\r\n    Maybe.amb(listOf(just, never)).subscribe { value = it }\r\n    // This also works\r\n    // Maybe.amb(listOf(never, just)).subscribe { value = it }\r\n    assertThat(value).isEqualTo(\"test\")\r\n    assertThat(cancelled || !subscribed).isTrue()\r\n  }\r\n```"
      }
    ]
  },
  {
    "number": 6933,
    "title": "Merge delay error for multiple API calls.",
    "created_at": "2020-03-14T19:05:20Z",
    "closed_at": "2020-03-16T17:32:14Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/6933",
    "body": "```\r\nlaunchJob {\r\n            Observable.mergeDelayError(\r\n                    getCareUseCase.getAllGetCareItems().toObservable(),\r\n                    appointmentUseCase.getAllAppointment().toObservable()\r\n                        .mergeWith(\r\n                            prescriptionRefillsUseCase.getAllPrescriptionRefills())\r\n                            .mergeWith(billUseCase.getAllPayBills())\r\n                        .mergeWith(careTeamUseCase.getMyCareTeam())\r\n                        .mergeWith(favoriteFacilitiesUseCase.getAllFavoriteFacilities())\r\n                ).iOSubscribeMainThreadObserve()\r\n                .subscribe({\r\n                    mapSection(it)\r\n                    flattenAndEmit()\r\n                }, {\r\n                   Log.e(TAG, \"Failed to load dashboard contents\")\r\n                })\r\n        }\r\n\r\n\r\n```\r\n\r\nIf any of the API is failing entire stream is failing.  Any one knows why?\r\n\r\nThis is my requirement, I want to make all the API calls parallel,  I don't care about the order in which response arrives, I don't care if one fails, which one come fast, I just display in the order that receives. ",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/6933/comments",
    "author": "pollux-",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2020-03-14T19:25:19Z",
        "body": "`mergeWith` doesn't delay errors so if any of those fails, the subsequence will fail. Looks like you can simply use use `mergeArrayDelayError` with those 6 sources direclty:\r\n\r\n```java\r\nObservable.mergeArrayDelayError(\r\n    getCareUseCase.getAllGetCareItems().toObservable(),\r\n    appointmentUseCase.getAllAppointment().toObservable(),\r\n    prescriptionRefillsUseCase.getAllPrescriptionRefills(),\r\n    billUseCase.getAllPayBills(),\r\n    careTeamUseCase.getMyCareTeam(),\r\n    favoriteFacilitiesUseCase.getAllFavoriteFacilities()\r\n)\r\n.iOSubscribeMainThreadObserve()\r\n```"
      },
      {
        "user": "pollux-",
        "created_at": "2020-03-14T19:53:27Z",
        "body": "@akarnokd  \r\n\r\nI ran into an issue.  Observable.mergeArrayDelayError() give me compilation error when I add more than 4 observable? I know this a super dumb question. As per signature it should work though?\r\n\r\n**_mergeArrayDelayError(ObservableSource<? extends T>... sources)_**\r\n\r\n   ```\r\nObservable.mergeDelayError(\r\n            getCareUseCase.getAllGetCareItems().toObservable(),\r\n            getCareUseCase.getAllGetCareItems().toObservable(),\r\n            getCareUseCase.getAllGetCareItems().toObservable(),\r\n            getCareUseCase.getAllGetCareItems().toObservable(),\r\n            getCareUseCase.getAllGetCareItems().toObservable()\r\n        )\r\n```"
      },
      {
        "user": "akarnokd",
        "created_at": "2020-03-14T20:07:46Z",
        "body": "What is the error?"
      },
      {
        "user": "pollux-",
        "created_at": "2020-03-14T20:15:48Z",
        "body": "\r\n_None of the following functions can be called with the arguments supplied: \r\npublic final fun <T : Any!> mergeDelayError(p0: ((Observer<in (???..???)>) -> Unit)!, p1: ((Observer<in (???..???)>) -> Unit)!): Observable<(???..???)>! defined in io.reactivex.Observable\r\npublic final fun <T : Any!> mergeDelayError(p0: ((Observer<in (???..???)>) -> Unit)!, p1: ((Observer<in (???..???)>) -> Unit)!, p2: ((Observer<in (???..???)>) -> Unit)!): Observable<(???..???)>! defined in io.reactivex.Observable\r\npublic final fun <T : Any!> mergeDelayError(p0: ((Observer<in (???..???)>) -> Unit)!, p1: ((Observer<in (???..???)>) -> Unit)!, p2: ((Observer<in (???..???)>) -> Unit)!, p3: ((Observer<in (???..???)>) -> Unit)!): Observable<(???..???)>! defined in io.reactivex.Observable\r\npublic final fun <T : Any!> mergeDelayError(p0: ((Observer<in ObservableSource<out (???..???)>!>) -> Unit)!): Observable<(???..???)>! defined in io.reactivex.Observable\r\npublic final fun <T : Any!> mergeDelayError(p0: ((Observer<in ObservableSource<out (???..???)>!>) -> Unit)!, p1: Int): Observable<(???..???)>! defined in io.reactivex.Observable\r\npublic open fun <T : Any!> mergeDelayError(p0: ObservableSource<out ObservableSource<out (???..???)>!>!): Observable<(???..???)>! defined in io.reactivex.Observable\r\npublic open fun <T : Any!> mergeDelayError(p0: ObservableSource<out ObservableSource<out (???..???)>!>!, p1: Int): Observable<(???..???)>! defined in io.reactivex.Observable\r\npublic open fun <T : Any!> mergeDelayError(p0: ObservableSource<out Result<Pair<Section, List<HomeViewModel.HomeUiModel>>>!>!, p1: ObservableSource<out Result<Pair<Section, List<HomeViewModel.HomeUiModel>>>!>!): Observable<Result<Pair<Section, List<HomeViewModel.HomeUiModel>>>!>! defined in io.reactivex.Observable\r\npublic open fun <T : Any!> mergeDelayError(p0: ObservableSource<out Result<Pair<Section, List<HomeViewModel.HomeUiModel>>>!>!, p1: ObservableSource<out Result<Pair<Section, List<HomeViewModel.HomeUiModel>>>!>!, p2: ObservableSource<out Result<Pair<Section, List<HomeViewModel.HomeUiModel>>>!>!): Observable<Result<Pair<Section, List<HomeViewModel.HomeUiModel>>>!>! defined in io.reactivex.Observable\r\npublic open fun <T : Any!> mergeDelayError(p0: ObservableSource<out Result<Pair<Section, List<HomeViewModel.HomeUiModel>>>!>!, p1: ObservableSource<out Result<Pair<Section, List<HomeViewModel.HomeUiModel>>>!>!, p2: ObservableSource<out Result<Pair<Section, List<HomeViewModel.HomeUiModel>>>!>!, p3: ObservableSource<out Result<Pair<Section, List<HomeViewModel.HomeUiModel>>>!>!): Observable<Result<Pair<Section, List<HomeViewModel.HomeUiModel>>>!>! defined in io.reactivex.Observable\r\npublic open fun <T : Any!> mergeDelayError(p0: (Mutable)Iterable<ObservableSource<out (???..???)>!>!): Observable<(???..???)>! defined in io.reactivex.Observable\r\npublic open fun <T : Any!> mergeDelayError(p0: (Mutable)Iterable<ObservableSource<out (???..???)>!>!, p1: Int): Observable<(???..???)>! defined in io.reactivex.Observable\r\npublic open fun <T : Any!> mergeDelayError(p0: (Mutable)Iterable<ObservableSource<out (???..???)>!>!, p1: Int, p2: Int): Observable<(???..???)>! defined in io.reactivex.Observable\r\n\r\nFAILURE: Build failed with an exception._\r\n\r\n* What went wrong:\r\nExecution failed for task ':kpflagshipapp:compileRefreshKotlin'.\r\n> Compilation error. See log for more details\r\n\r\n* Try:\r\n\r\n\r\n```\r\nval dashboardObservables = listOf(\r\n            getCareUseCase.getAllGetCareItems().toObservable(),\r\n            appointmentUseCase.getAllAppointment().toObservable(),\r\n            prescriptionRefillsUseCase.getAllPrescriptionRefills(\r\n                application.getString(R.string.prescription_refills_title),\r\n                application.getString(R.string.prescription_refills_subtitle),\r\n                R.drawable.ic_prescription_refill\r\n            ),\r\n            billUseCase.getAllPayBills().toObservable(),\r\n            careTeamUseCase.getMyCareTeam().toObservable(),\r\n            favoriteFacilitiesUseCase.getAllFavoriteFacilities().toObservable()\r\n        )\r\n\r\n        launchJob {\r\n            Observable.mergeDelayError(dashboardObservables)\r\n                .iOSubscribeMainThreadObserve()\r\n                .subscribe({\r\n                    mapSection(it)\r\n                    flattenAndEmit()\r\n                }, {\r\n                   Log.e(TAG, \"Failed to load dashboard contents\")\r\n                })\r\n        }\r\n```\r\n\r\n@akarnokd  thank you so much for responding. \r\n\r\nThe above should work,  or do you see any issue with that?"
      },
      {
        "user": "akarnokd",
        "created_at": "2020-03-14T20:25:07Z",
        "body": "I wrote: `mergeArrayDelayError()`\r\nYou had: `mergeDelayError()`\r\nSee the difference?"
      }
    ]
  },
  {
    "number": 6724,
    "title": "Observable vs Flowable on Interfaces With Unknown Implementations",
    "created_at": "2019-11-20T18:06:06Z",
    "closed_at": "2019-11-20T21:13:13Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/6724",
    "body": "We have a base library which provides interfaces for repository / database access and some basic implementations. In the case of getOne, insert, update, and delete, these all make sense as singles / maybes. However in the case of getAll for instance, this could be a ```Single<List<Model>>``` or ```Observable<Model>```. We considered using single, since that's usually how our data is consumed, but these interfaces could hold implementations that support streaming, so using single would essentially prevent those types of implementations from being realized. The consumer can always use the ```toList``` operator if they dont want to consume it like a stream or need all the results for business logic. \r\n\r\nSo now where we are stuck is whether or not these interfaces should return Observables or Flowables. From what I understand, the main difference between the two is that Flowables have added overhead which allow a Consumer to control the rate at which a Producer emits items, where as an Observable does not and will just emit as quickly as possible.\r\n\r\nWould it make sense then to always return lower overhead Observables from these interfaces, and to leave it up to the consumer to use ```toFlowable``` if they need control over the rate of the Producer? Would this even work or would the Observable consume memory with its unbounded buffer (potential out of memory issues) before being converted to a Flowable which has bounded buffers?",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/6724/comments",
    "author": "pixelshaded",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2019-11-20T18:23:39Z",
        "body": "You can always unbound `Flowable` or turn it into a `Single`. Rebounding an `Observable` will be still prone to excessive memory usage. There isn't that much of an overhead difference between `Flowable` and `Observable` otherwise."
      },
      {
        "user": "pixelshaded",
        "created_at": "2019-11-20T18:35:14Z",
        "body": "It seems then, based on docs, that Flowable is essentially what Observable was in rxjava1, and now Observables are just an alternative to something like Java8 streams. Is that accurate?"
      },
      {
        "user": "akarnokd",
        "created_at": "2019-11-20T18:40:51Z",
        "body": "> Flowable is essentially what Observable was in rxjava1\r\n\r\nYes.\r\n\r\n> Observables are just an alternative to something like Java8 streams\r\n\r\nNo, they are for cases where there can't be a reasonable backpressure (UI events) or backpressure doesn't matter due to short sequences.\r\n"
      }
    ]
  },
  {
    "number": 6623,
    "title": "Observers run order issue while using observeOn() `2.x`",
    "created_at": "2019-08-19T09:30:56Z",
    "closed_at": "2019-08-19T09:55:30Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/6623",
    "body": "Library version 2.2.11\r\nI have two `PublishSubject`s and two `Observer`s subscribed respectively. Between `PubslishSubject` and `Subscriber` I switch from [main] thread to [RxSingleScheduler] thread using `observeOn(Schedulers.single())`. I start to publish (`PubslishSubject.onNext()`) on both `PublishSubject`s inside the loop.\r\n\r\n    publishSubject1.onNext(\"next\");\r\n    publishSubject2.onNext(\"next\");\r\nWhat I expected was the both subscribers run in the same order as emissions were published but the results I get is completely different. Subsriber1 handles all it's emissions and then Subscriber2 handles all it's emissions.\r\nI expected emission scheduled and run in publish order. Is there any way to achive this?\r\n```java\r\nimport java.util.concurrent.TimeUnit;\r\n\r\nimport io.reactivex.schedulers.Schedulers;\r\nimport io.reactivex.subjects.PublishSubject;\r\n\r\npublic class ObserveOnApp {\r\n    \r\n    public static void main(String[] args) {\r\n        PublishSubject<String> publishSubject1 = PublishSubject.create();\r\n        PublishSubject<String> publishSubject2 = PublishSubject.create();\r\n        \r\n        publishSubject1\r\n        .observeOn(Schedulers.single())\r\n        .subscribe(next -> {\r\n            System.out.println(\"Subscriber1\");\r\n        });\r\n        \r\n        publishSubject2\r\n        .observeOn(Schedulers.single())\r\n        .subscribe(next -> {\r\n            System.out.println(\"Subscriber2\");\r\n        });\r\n        \r\n        for (int i= 0; i < 10; i++) {\r\n            publishSubject1.onNext(\"next\");\r\n            publishSubject2.onNext(\"next\");\r\n        }\r\n        \r\n        try {\r\n            TimeUnit.SECONDS.sleep(2);\r\n        } catch (InterruptedException e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n}\r\n```",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/6623/comments",
    "author": "pkrysztofiak",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2019-08-19T09:38:58Z",
        "body": "`Schedulers.single` uses a single thread and both of your subjects post work to this one thread. `observeOn` keeps working as long as it sees events so if you post events fast enough, the first subscription will get as much work done as it can, hence you don't see perfect interleaving of the two consumers.\r\n\r\nYou can try `delay(0, TimeUnit.SECONDS, Schedulers.single())` instead which posts events one by one.\r\n"
      },
      {
        "user": "pkrysztofiak",
        "created_at": "2019-08-19T09:49:29Z",
        "body": "delay() works but I'm extremly confused. Isn't it should be the default behaviour? When calling\r\n```\r\npublishSubject1.onNext(\"next\");\r\npublishSubject2.onNext(\"next\");\r\n```\r\nfirst line should schedule an execution. The second line should do the same and since I use the same scheduler subscriptions should interleave perfectly."
      },
      {
        "user": "akarnokd",
        "created_at": "2019-08-19T09:55:30Z",
        "body": "No. Any operator with a queue does as much work as it can in one run, including `observeOn`. Delay has to post events individually as it has to apply an user-defined delay to each, and there is no queue involved in RxJava for that. The underlying `ScheduledExecutorService` will interleave tasks in its own queue. Posting items individually to a thread pool is really inefficient as it causes a lot of extra allocation per task. The way RxJava does this is automatically coalescing nearby events and have one task serving them at once."
      }
    ]
  },
  {
    "number": 6617,
    "title": "ConcatMap caches value from upstream",
    "created_at": "2019-08-14T09:24:53Z",
    "closed_at": "2019-08-21T15:54:06Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/6617",
    "body": "This issue was reproduces on RX-Java v2.2.6 and v3.0.0-RC1\r\n\r\nI have this piece of code:\r\n\r\n```java\r\n@Test\r\npublic void concatMapCachedValueTest() throws InterruptedException {\r\n  Flowable\r\n    .interval(0, 1000, TimeUnit.MILLISECONDS, Schedulers.io())\r\n    .onBackpressureDrop()\r\n    .concatMap(aLong -> Flowable.just(aLong)\r\n        .delay(3500, TimeUnit.MILLISECONDS, Schedulers.io())\r\n    )\r\n    .subscribe(aLong -> System.out.println(aLong));\r\n    Thread.sleep(18000);\r\n}\r\n```\r\n\r\nWhen I run it it prints:\r\n0\r\n1\r\n4\r\n5\r\n11\r\n\r\nI would expect it to print:\r\n0\r\n4\r\n8\r\n12\r\n16\r\n\r\nBut it seems that concatMap is caching another value from the upstream while starting processing the Flowable returned by current value.\r\nThis happens even if you set the prefetch parameter of concatMap to 1, setting it to 0 is illegal.\r\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/6617/comments",
    "author": "adrian-linca",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2019-08-14T09:37:49Z",
        "body": "Yes, `concatMap` has always a buffer to store one upstream element even if the inner source is still active. Try `flatMap` with `maxConcurrency = 1`."
      }
    ]
  },
  {
    "number": 6568,
    "title": "2.2.10: Flowable do not use correct scheduler once bufferSize is reached",
    "created_at": "2019-07-11T10:00:41Z",
    "closed_at": "2019-07-11T11:59:11Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/6568",
    "body": "Hi, I was playing with Flowable to get a deep understanding on how to handle backpressure without dropping events and running the following code I noticed that the flowable starts to emit events on the subscriber scheduler once bufferSize given to observeOn method is reached.\r\n\r\nHere's the code :\r\n\r\n```\r\n    public static void main(String[] args) throws InterruptedException {\r\n        int maxI = 12;\r\n        int bufferSize = 5;\r\n        CountDownLatch waitForIt = new CountDownLatch(1);\r\n        CompositeDisposable compositeDisposable = new CompositeDisposable();\r\n\r\n        Flowable<Integer> integerFlow = Flowable.<Integer, Integer>generate(\r\n                () -> 0,\r\n                (i, emitter) -> {\r\n                    if (i < maxI) {\r\n                        log(\"Emitting: \" + i);\r\n                        emitter.onNext(i);\r\n                    } else {\r\n                        emitter.onComplete();\r\n                    }\r\n                    return i + 1;\r\n                }).observeOn(Schedulers.io(), false, bufferSize);\r\n\r\n        compositeDisposable.add(\r\n                integerFlow\r\n                        .subscribeOn(Schedulers.computation())\r\n                        .subscribeWith(new DisposableSubscriber<Integer>() {\r\n\r\n                            @Override\r\n                            public void onNext(Integer i) {\r\n                                try {\r\n                                    log(\"Receiving: \" + i);\r\n                                    Thread.sleep(10L);\r\n                                } catch (InterruptedException e) {\r\n                                    e.printStackTrace();\r\n                                }\r\n                            }\r\n\r\n                            @Override\r\n                            public void onError(Throwable throwable) {\r\n\r\n                            }\r\n\r\n                            @Override\r\n                            public void onComplete() {\r\n                                compositeDisposable.remove(this);\r\n                                waitForIt.countDown();\r\n                            }\r\n                        }));\r\n\r\n        System.out.println(compositeDisposable.size());\r\n        log(\"Waiting for finish\");\r\n        waitForIt.await();\r\n        System.out.println(compositeDisposable.size());\r\n    }\r\n\r\n    private static void log(String message) {\r\n        System.out.println(message + String.format(\" (%s)\", Thread.currentThread().getName()));\r\n    }\r\n```\r\nHere's the output:\r\n\r\n```\r\n1\r\nWaiting for finish (main)\r\nEmitting: 0 (RxComputationThreadPool-1)\r\nEmitting: 1 (RxComputationThreadPool-1)\r\nEmitting: 2 (RxComputationThreadPool-1)\r\nEmitting: 3 (RxComputationThreadPool-1)\r\nEmitting: 4 (RxComputationThreadPool-1)\r\nReceiving: 0 (RxCachedThreadScheduler-1)\r\nReceiving: 1 (RxCachedThreadScheduler-1)\r\nReceiving: 2 (RxCachedThreadScheduler-1)\r\nReceiving: 3 (RxCachedThreadScheduler-1)\r\nEmitting: 5 (RxCachedThreadScheduler-1)\r\nEmitting: 6 (RxCachedThreadScheduler-1)\r\nEmitting: 7 (RxCachedThreadScheduler-1)\r\nEmitting: 8 (RxCachedThreadScheduler-1)\r\nReceiving: 4 (RxCachedThreadScheduler-1)\r\nReceiving: 5 (RxCachedThreadScheduler-1)\r\nReceiving: 6 (RxCachedThreadScheduler-1)\r\nReceiving: 7 (RxCachedThreadScheduler-1)\r\nEmitting: 9 (RxCachedThreadScheduler-1)\r\nEmitting: 10 (RxCachedThreadScheduler-1)\r\nEmitting: 11 (RxCachedThreadScheduler-1)\r\nReceiving: 8 (RxCachedThreadScheduler-1)\r\nReceiving: 9 (RxCachedThreadScheduler-1)\r\nReceiving: 10 (RxCachedThreadScheduler-1)\r\nReceiving: 11 (RxCachedThreadScheduler-1)\r\n0\r\n```\r\nI would expect all `Emitting: ...`  log lines to be in an RxComputationThreadPool-x. But once `bufferSize` events have been emitted (and the subscriber starts working), the flowable emits in the same thread has the subscriber.\r\n\r\nIs this normal behavior ?\r\n\r\nThanks, regards",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/6568/comments",
    "author": "gauthierj",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2019-07-11T10:46:33Z",
        "body": "This is an allowed behavior. The `generate` responds to requests on whatever thread the request comes from. Initially, the first batch is triggered on the computation thread due to `subscribeOn`. Later on, `observeOn` takes over with requesting from its IO thread and thus generator runs on the IO thread too. \r\n\r\nThe main problem in your code is the position of `subscribeOn`. If you put it just after `generate`, the operator will make sure the subscription and subsequent requests happen on the designated thread."
      }
    ]
  },
  {
    "number": 6495,
    "title": "SwitchIfEmpty on a Subject",
    "created_at": "2019-06-04T07:43:33Z",
    "closed_at": "2019-06-04T07:57:52Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/6495",
    "body": "I have an issue with the Observable.switchIfEmpty operator. It\u2019s not called properly. See sample code\r\n\r\n```kotlin\r\nclass TestObs {\r\n\r\n    @Test\r\n    fun testSwitchIfEmpty() {\r\n        val subject = BehaviorSubject.create<List<String>>()\r\n        subject.onNext(listOf(\"a\"))\r\n        subject.test().assertValueCount(1)\r\n\r\n        // works\r\n//        Observable.create<List<String>> { emitter ->\r\n//            emitter.onNext(listOf(\"a\"))\r\n//            emitter.onComplete()\r\n//        }\r\n\r\n        // fails\r\n        subject\r\n            .flatMapIterable { it }\r\n            .filter { it == \"c\" }\r\n            .switchIfEmpty(Observable.create { emitter ->\r\n                emitter.onNext(\"c\")\r\n                emitter.onComplete()\r\n            })\r\n            .test()\r\n            .assertValue(\"c\")\r\n    }\r\n}\r\n```\r\n\r\nI just want to filter \"c\" and if there is no \"c\" switch to a new Observable an emit a \"c\". \r\n\r\nThis works if the origin of my rx chain starts with an Observable, but my test fails if my source is a subject. Does this make any sense to you?\r\n\r\nThanks!\r\n\r\nrxJavaVersion = '2.2.6'",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/6495/comments",
    "author": "Voto",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2019-06-04T07:57:52Z",
        "body": "An observable is empty if doesn't signal onNext but only `onComplete`. Your code doesn't call `onComplete` and thus the `Subject` is infinite, preventing `switchIfEmpty` to function as you expected."
      },
      {
        "user": "Voto",
        "created_at": "2019-06-04T11:26:19Z",
        "body": "For those interested in this issue. I made a workaround like this:\r\n\r\n```kotlin\r\n    @Test\r\n    fun testSwitchIfEmpty() {\r\n        val subject = BehaviorSubject.create<List<String>>()\r\n        subject.onNext(listOf(\"a\"))\r\n        // works\r\n        Maybe.create<List<String>> { emitter ->\r\n            if (subject.value != null) {\r\n                subject.value?.let {\r\n                    emitter.onSuccess(it)\r\n                }\r\n            } else {\r\n                emitter.onComplete()\r\n            }\r\n        }\r\n            .toObservable()\r\n            .flatMapIterable { it }\r\n            .filter { it == \"c\" }\r\n            .switchIfEmpty(Observable.create { emitter ->\r\n                emitter.onNext(\"c\")\r\n                emitter.onComplete()\r\n            })\r\n            .test()\r\n            .assertValue(\"c\")\r\n    }\r\n```"
      }
    ]
  },
  {
    "number": 6214,
    "title": "RxJava 2.2.2 startsWith subscribes the subsequence streams without subscribing to the upper stream",
    "created_at": "2018-09-16T14:58:16Z",
    "closed_at": "2018-09-16T16:42:26Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/6214",
    "body": "Hi, I'm not sure if this is a bug or an expected behavior. \r\nSee an example below:\r\n```\r\n        PublishSubject<Integer> subject = PublishSubject.create();\r\n        AtomicBoolean bool = new AtomicBoolean();\r\n        subject\r\n                .doOnSubscribe(s->{}) << not called\r\n                .doOnNext(s->{}) << not called\r\n                .startWith(0)\r\n                .switchMap(o -> Observable\r\n                        .empty()\r\n                        .doOnSubscribe(s -> {\r\n                            if (!bool.get()) {\r\n                                subject.onNext(1); << called\r\n                            }\r\n                        }))\r\n                .subscribe();\r\n```\r\nScenario:\r\nIn my use case, I subscribed to a source that chained with a #startWith operator.\r\nI performed a switchMap, expecting the next value terminates it and starts a new one. \r\nSubject emits something during the switchmap. Happens on both Observable/Flowable.\r\n\r\nExpected: receive the new event\r\nActual: receive nothing due to subject not subscribed yet.\r\n\r\nHave not tested on other version.\r\n\r\nThanks\r\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/6214/comments",
    "author": "ykinuse",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2018-09-16T16:03:59Z",
        "body": "This is a valid behavior. The `PublishSubject` is not subscribed at that time because `startWith` hasn't finished yet switching to it. Consider using `BehaviorSubject.create(0)` instead and not doing that reentrant `onNext` call."
      },
      {
        "user": "ykinuse",
        "created_at": "2018-09-16T16:06:44Z",
        "body": "Thanks for the clarification. PublishSubject was used as an example of some source. So I'm assuming doOnSubscribe() chained after startWith does not guaranteed subscription established to the source? Was expecting a guaranteed subscription to source before startWith emits. "
      },
      {
        "user": "akarnokd",
        "created_at": "2018-09-16T16:21:06Z",
        "body": "No. StartWith is like concat, subscribes the next source after the previous source has completed, thus no `doOnSubscribe` is called on the next source until that."
      }
    ]
  },
  {
    "number": 6190,
    "title": "Why doesn't Flowable#buffer(long, TimeUnit, int) support backpressure?",
    "created_at": "2018-08-31T19:16:59Z",
    "closed_at": "2018-08-31T19:55:53Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/6190",
    "body": "Why doesn't Flowable#buffer(long, TimeUnit, int) support backpressure?\r\n\r\nI'm using version 2.2.1, and here's the code for my experiment:\r\n```java\r\n\tpublic static void main(String[] args) throws Exception {\r\n\t\tFlowable.range(0, 10000)\r\n\t\t.buffer(5, TimeUnit.SECONDS, 100)\r\n//\t\t.onBackpressureBuffer()\r\n\t\t.concatMap(list -> {\r\n\t\t\tSystem.out.println(list.size());\r\n\t\t\treturn Flowable.just(list).delaySubscription(500, TimeUnit.MILLISECONDS);\r\n\t\t})\r\n\t\t.blockingSubscribe();\r\n\t}\r\n```\r\nThe code above will cause a `MissingBackpressureException` unless I add `.onBackpressureBuffer()` after `.buffer(5, TimeUnit.SECONDS, 100)`, which is to be expected because the Javadoc for `Flowable#buffer(long, TimeUnit, int)` says `This operator does not support backpressure as it uses time`.\r\n\r\nSo here are my questions:\r\n1. I understand why a size based buffer can support backpressure while a time based buffer cannot. But why can't a time and size based buffer support backpressure like a purely size based buffer does?\r\n2. Is there a way to achieve a backpressured size based buffer with a time based \"kick\"?\r\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/6190/comments",
    "author": "slisaasquatch",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2018-08-31T19:26:38Z",
        "body": "> But why can't a time and size based buffer support backpressure like a purely size based buffer does\r\n\r\nBecause the time part makes it backpressure incompatible and backpressuring would result in time not being honored.\r\n\r\n> Is there a way to achieve a backpressured size based buffer with a time based \"kick\"?\r\n\r\nWhat if the downstream is not ready to receive a buffer when this \"kick\" happens? Apply one of the `onBackpressureXXX` operators to decide what should happen."
      }
    ]
  },
  {
    "number": 6184,
    "title": "flatmap from observable to completable,onComplete Action no call!",
    "created_at": "2018-08-29T09:44:07Z",
    "closed_at": "2018-08-29T09:54:41Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/6184",
    "body": "RxJava version:2.1.12\r\n\r\ncode:\r\n``` kotlin\r\nObservable.create<Unit> { it.onNext(Unit) }\r\n                    .observeOn(Schedulers.io())\r\n                    .flatMap { Observable.create<Unit> { it.onNext(Unit) } }\r\n                    .flatMap { Observable.create<Unit> { it.onNext(Unit) } }\r\n                    .flatMap { Observable.create<Unit> { it.onNext(Unit) } }\r\n                    .flatMapCompletable {\r\n                        Completable.create {\r\n                            Thread.sleep(3000)\r\n                            //do something\r\n                            it.onComplete()\r\n                        }\r\n                    }\r\n                    .observeOn(AndroidSchedulers.mainThread())\r\n                    .subscribe(Action {\r\n                        //no call\r\n                        print(\"11111\")\r\n                    }, Consumer {\r\n                        print(\"1111\")\r\n                    })\r\n```\r\nI don't know why, the final onComplete Action is not called. Is there a problem with my usage?\r\nIf you replace all Observable.create with Observable.just() , the final onComplete Action will be called. Why?\r\n\r\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/6184/comments",
    "author": "linzhengloser",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2018-08-29T09:54:41Z",
        "body": "You need a finite sequence in each `create` in order for the various `flatMap`s to complete at which point the entire sequence completes and you get that Action call.\r\n\r\nPlease, next time ask such questions on StackOverflow."
      }
    ]
  },
  {
    "number": 6169,
    "title": "Give Flowable.sequenceEqual()/BiPredicate the option to use Single<Boolean> instead of boolean",
    "created_at": "2018-08-23T09:15:45Z",
    "closed_at": "2018-08-31T19:29:46Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/6169",
    "body": "I need to compare two `Flowable`s, that unfortunaley, due to `groupBy()` do not complete until all items it contains are subscribed to. \r\n\r\nCurrently, this is not possible since test() in the BiPredicate you can implement for `sequenceEqual()` can only return a `boolean`, it expects the `Flowable` to be comparable one by one. I suggest to overload `test()` so that it can also return `Single<Boolean>` - thus allowing the comparison to happen for all elements of the `Flowable` before expecting it to complete, which lets every item be subscribed to.",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/6169/comments",
    "author": "Namnodorel",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2018-08-23T09:24:41Z",
        "body": "I'm not sure what you try to achieve here. `sequenceEqual` compares item by item when both sources have at least one item ready for comparison."
      },
      {
        "user": "Namnodorel",
        "created_at": "2018-08-23T09:36:01Z",
        "body": "@akarnokd Yes. And this one-after-the-other comparison doesn't work if the items are (or come from a Flowable that was a) `GroupedFlowable`s. In that case, the first item won't complete until all the other items are subscribed to. But currently, `sequenceEqual()` waits until the first item comparison completes until it moves on to the next one. For this to work, `sequenceEqual()` would need to be able to compare the `Flowable`s asynchronously."
      },
      {
        "user": "akarnokd",
        "created_at": "2018-08-23T09:42:43Z",
        "body": "Please show some actual code that demonstrates your issue."
      },
      {
        "user": "Namnodorel",
        "created_at": "2018-08-23T09:56:50Z",
        "body": "Given a class `ValueGroup` with an object `key` and a `Flowable`. I want to squash multiple `ValueGroup`s with the same key together, like this:\r\n```\r\nFlowable<ValueGroup> myFlowable = ...;\r\nmyFlowable\r\n.groupBy(ValueGroup::getKey)\r\n    .map(groupedValueGroups -> new ValueGroup(\r\n        groupedValueGroups.getKey(),\r\n        groupedValueGroups\r\n            .flatMap((Function<ValueGroup, Publisher<? extends Value>>) ValueGroup::getFlowable)\r\n))\r\n```\r\nAt some point later in the code, I then use\r\n```\r\nFlowable.sequenceEqual(myFlowable, anotherFlowable)\r\n```\r\n(`anotherFlowable` is basically the same as `myFlowable`)\r\n\r\nWhat then happens, is: `sequenceEqual()` takes the first item of both Flowables, tries to compare them, and... gets stuck. Because to compare the `ValueGroup`s, the `Flowable`s inside them also need to be compared. But they don't complete, because all the other elements have not yet been subscribed to."
      },
      {
        "user": "akarnokd",
        "created_at": "2018-08-23T10:03:49Z",
        "body": "You have to consume the groups in order for them to make progress. A Single predicate won't help your case as it is too late by then. Turn the groups into Lists and compare that way."
      },
      {
        "user": "Namnodorel",
        "created_at": "2018-08-23T10:15:03Z",
        "body": "Turning `Flowable`s into a `List` is in th category of \"it technically works, but it's not really a clean solution\"...\r\n\r\nI honestly don't quite understand why it wouldn't work for `sequenceEqual()` to call `test()` asynchronously for all objects that it will compare. That way, all `Flowable`s would be subscribed to \"at once\", and could properly complete. The groups would be consumed in the sense that their comparison emits a `Single<Boolean>`."
      },
      {
        "user": "akarnokd",
        "created_at": "2018-08-23T10:33:17Z",
        "body": "> I honestly don't quite understand why it wouldn't work \r\n\r\n`Flowable.groupBy` has backpressure and in order to have the sequence progress at all, you have to consume all groups it creates. Thus you can't just save up an inner `Flowable` to be compared later.\r\n\r\n> call test() asynchronously \r\n\r\nDoesn't work, the operator would subscribe to that `Single` and then hang as well because of the above.\r\n\r\nYou could try and adapt the following:\r\n\r\n```java\r\nFlowable<Flowable<Integer>> seq1 = ...;\r\nFlowable<Flowable<Integer>> seq2 = ...;\r\n\r\nFlowable.zip(seq1, seq2, (a, b) -> \r\n    return Flowable.sequenceEqual(a, b);\r\n)\r\n.flatMapSingle(v -> v)\r\n.all(v -> v);\r\n```"
      },
      {
        "user": "Namnodorel",
        "created_at": "2018-08-23T10:48:12Z",
        "body": ">Flowable.groupBy has backpressure and in order to have the sequence progress at all, you have to consume all groups it creates. Thus you can't just save up an inner Flowable to be compared later.\r\n\r\nI know, that's not what I'm having trouble with understanding.\r\n>Doesn't work, the operator would subscribe to that `Single` and then hang as well because of the above.\r\n\r\nThat would happen if it subscribed to only one `Single` at a time. But because it is async, it wouldn't need to wait for the first `Single` to complete, but could instead go on and subscribe to the rest of them as well. Until at some point, it has subscribed to all, and then they'll be able to complete.\r\n\r\nI'll try your example."
      },
      {
        "user": "Namnodorel",
        "created_at": "2018-08-28T13:21:45Z",
        "body": "Example is also stuck. "
      },
      {
        "user": "akarnokd",
        "created_at": "2018-08-28T13:27:26Z",
        "body": "Try with an `Observable`-based setup."
      },
      {
        "user": "Namnodorel",
        "created_at": "2018-08-31T19:20:36Z",
        "body": "Nevermind, the first example was actually correct, and I made a mistake in implementing it (my actual scenario is a little more complex, but that isn't relevant to the problem itself).\r\n\r\nThe issue I had is thus solved, however I'd still like to keep the suggestion: Implement this as an alternative to the existing `sequenceEqual()` so that it works with data that can't be compared one after the other for one reason or the other. "
      },
      {
        "user": "Namnodorel",
        "created_at": "2018-08-31T19:47:16Z",
        "body": "Structure? Of what? The elements held in the compared Flowable/Observable? I think that is specific to my case, what's on my mind is more something that is just capable of comparing sequences not \"in order\".\r\n\r\nBasically a `sequenceEqual()` that does what your example did, but instead of returning `Flowable.sequenceEqual(a, b)` in `zip()` accessing an interface similar to `BiPredicate`, with the change of returning a `Single<Boolean>`. The elements themselves would be compared like usual; if they contain (or are) nested Flowables/Observables, you'll need a custom implementation of the comparing interface one way or the other.\r\n\r\nRegarding being common... Well, to me it sounds like it could be common enough to be included, but - well, you're the expert :D"
      }
    ]
  },
  {
    "number": 6163,
    "title": "Why rx throws OnErrorNotImplementedException when I have doOnError",
    "created_at": "2018-08-18T02:40:36Z",
    "closed_at": "2018-08-18T02:47:28Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/6163",
    "body": "version:\r\n2.2.0\r\n\r\nThe code:\r\n\r\n```java\r\n        Observable.create(new ObservableOnSubscribe<String>() {\r\n            @Override\r\n            public void subscribe(ObservableEmitter<String> emitter) throws Exception {\r\n                Log.d(TAG, \"subscribe: \" + \" 111111111\");\r\n                emitter.onNext(\"success\");\r\n                emitter.onError(new Throwable(\"2222222\"));\r\n            }\r\n        })\r\n                .doOnNext(new Consumer<String>() {\r\n                    @Override\r\n                    public void accept(String s) throws Exception {\r\n                        Log.d(TAG, \"accept: doOnNext \" + s);\r\n                    }\r\n                })\r\n                .doOnError(new Consumer<Throwable>() {\r\n                    @Override\r\n                    public void accept(Throwable throwable) throws Exception {\r\n                        Log.d(TAG, \"accept: doOnError \" + throwable);\r\n                    }\r\n                })\r\n               .subscribe();\r\n```\r\nThe Exception:\r\n\r\nio.reactivex.exceptions.OnErrorNotImplementedException: 2222222\r\n\r\nIf the `doOnError` can not handle the exception, the `doOnError` is design for what?",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/6163/comments",
    "author": "anatta-feng",
    "comments": [
      {
        "user": "JakeWharton",
        "created_at": "2018-08-18T02:43:12Z",
        "body": "It's for side-effects (e.g., logging). If you want to handle the error, add something which can handle errors to the `subscribe` call."
      }
    ]
  },
  {
    "number": 6008,
    "title": "2.x: Single, toObservable and share: sometimes NoSuchElementException",
    "created_at": "2018-05-16T09:38:23Z",
    "closed_at": "2018-05-17T02:15:26Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/6008",
    "body": "Hello. I periodically have a NoSuchElementException. Version 2.1.12.\r\n\r\nCode:\r\n```\r\nSingle<String> single = Single.just(\"12345\")\r\n              .toObservable()\r\n              .share()\r\n              .singleOrError();\r\n      \r\n      for (int i = 0; i < 10; i++) {\r\n         new Thread(() -> {\r\n            single.subscribe((t) -> {\r\n            }, thrw -> {\r\n               if (NoSuchElementException.class.equals(thrw.getClass())) {\r\n                  printStackTrace();\r\n                  return;\r\n               }\r\n            });\r\n         }).start();\r\n\r\n         if (i % 2 != 0) {\r\n            Thread.sleep(4);\r\n         }\r\n      }\r\n\r\n```\r\nStacktrace:\r\n```\r\nat io.reactivex.internal.observers.ConsumerSingleObserver.onError(ConsumerSingleObserver.java:47)\r\n\tat io.reactivex.internal.operators.observable.ObservableSingleSingle$SingleElementObserver.onComplete(ObservableSingleSingle.java:113)\r\n\tat io.reactivex.internal.operators.observable.ObservableRefCount$ConnectionObserver.onComplete(ObservableRefCount.java:145)\r\n\tat io.reactivex.internal.operators.observable.ObservablePublish$PublishObserver.onComplete(ObservablePublish.java:193)\r\n\tat io.reactivex.internal.observers.DeferredScalarDisposable.complete(DeferredScalarDisposable.java:85)\r\n\tat io.reactivex.internal.operators.single.SingleToObservable$SingleToObservableObserver.onSuccess(SingleToObservable.java:73)\r\n\tat io.reactivex.internal.operators.single.SingleJust.subscribeActual(SingleJust.java:30)\r\n\tat io.reactivex.Single.subscribe(Single.java:3220)\r\n\tat io.reactivex.internal.operators.single.SingleToObservable.subscribeActual(SingleToObservable.java:36)\r\n\tat io.reactivex.Observable.subscribe(Observable.java:12005)\r\n\tat io.reactivex.internal.operators.observable.ObservablePublish.connect(ObservablePublish.java:116)\r\n\tat io.reactivex.internal.operators.observable.ObservableRefCount.subscribeActual(ObservableRefCount.java:68)\r\n\tat io.reactivex.Observable.subscribe(Observable.java:12005)\r\n\tat io.reactivex.internal.operators.observable.ObservableSingleSingle.subscribeActual(ObservableSingleSingle.java:35)\r\n\tat io.reactivex.Single.subscribe(Single.java:3220)\r\n\tat io.reactivex.Single.subscribe(Single.java:3206)\r\n```\r\n\r\nIs this a bug or an incorrect code? For cycle is written to demonstrate the problem.",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/6008/comments",
    "author": "neyron91",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2018-05-16T10:19:27Z",
        "body": "This is a plausible outcome when using `share`. The underlying `publish` operator emits items to currently subscribed observers only. With that race in your code, some observers may come after the \"12345\" has been emitted but just before `onComplete` is signalled, thus they encounter an empty sequence. \r\n\r\nUse `replay(1).refCount()` to ensure you don't lose that single item."
      }
    ]
  },
  {
    "number": 5941,
    "title": "[RxJava 2.1] Executing blocking operations on IO scheduler switches execution to a single thread",
    "created_at": "2018-03-31T03:43:40Z",
    "closed_at": "2018-04-15T11:28:20Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5941",
    "body": "RxJava 2.1.3\r\n\r\nSample that demonstrates the problem:\r\n\r\n```java\r\nimport java.util.concurrent.ConcurrentHashMap;\r\nimport java.util.concurrent.atomic.AtomicInteger;\r\nimport java.util.concurrent.atomic.AtomicLong;\r\n\r\nimport io.reactivex.Observable;\r\nimport io.reactivex.ObservableTransformer;\r\nimport io.reactivex.functions.Action;\r\nimport io.reactivex.schedulers.Schedulers;\r\n\r\npublic class Main {\r\n  private static final int NUM_THREADS = 8;\r\n  private static final int NUM_EVENTS = 200;\r\n\r\n  public static void main(String[] args) throws Exception {\r\n    System.out.println(\"Executing blocking operation...\");\r\n    observe(() -> Thread.sleep((long) (Math.random() * 100)));\r\n\r\n    System.out.println(\"Executing non-blocking operation...\");\r\n    observe(() -> {});\r\n  }\r\n\r\n  private static void observe(Action op) {\r\n    AtomicInteger messageReceived = new AtomicInteger(0);\r\n    AtomicInteger observableComplete = new AtomicInteger(0);\r\n    ConcurrentHashMap<String, AtomicInteger> counters = new ConcurrentHashMap<>();\r\n\r\n    createObservable()\r\n        .compose(createThreadPoolTransformer())\r\n        .compose(performOperation(op))\r\n        .subscribe(\r\n            e -> {\r\n              counters.compute(Thread.currentThread().getName(), (key, ai) -> {\r\n                ai = ai == null ? new AtomicInteger(0) : ai;\r\n                ai.incrementAndGet();\r\n                return ai;\r\n              });\r\n              messageReceived.incrementAndGet();\r\n\r\n              if (messageReceived.get() == NUM_EVENTS) {\r\n                System.out.println(String.format(\"Counts per thread: %s \\n\", counters));\r\n              }\r\n            }, e -> {}, observableComplete::incrementAndGet);\r\n\r\n    while(observableComplete.get() == 0) {\r\n      // wait until it's complete\r\n    }\r\n  }\r\n\r\n  private static Observable<Long> createObservable() {\r\n    return Observable.just(0).repeat(NUM_EVENTS).map(al -> {\r\n      Thread.sleep(10);\r\n      return System.currentTimeMillis();\r\n    });\r\n  }\r\n\r\n  private static ObservableTransformer<Long, Long> createThreadPoolTransformer() {\r\n    AtomicLong counter = new AtomicLong(0);\r\n    return upstream ->\r\n        upstream\r\n            .groupBy(e -> counter.getAndIncrement() % NUM_THREADS)\r\n            .flatMap(g -> g.observeOn(Schedulers.io()));\r\n  }\r\n\r\n  private static ObservableTransformer<Long, Long> performOperation(Action op) {\r\n    return upstream -> upstream\r\n        .map(\r\n            e -> {\r\n              if (Math.random() < 0.5) {\r\n                op.run();\r\n              }\r\n              return e;\r\n            });\r\n  }\r\n}\r\n```\r\nRunning the program should print something like:\r\n```\r\nExecuting blocking operation...\r\nCounts per thread: {RxCachedThreadScheduler-1=200} \r\n\r\nExecuting non-blocking operation...\r\nCounts per thread: {RxCachedThreadScheduler-1=25, RxCachedThreadScheduler-2=25, RxCachedThreadScheduler-3=25, RxCachedThreadScheduler-8=25, RxCachedThreadScheduler-4=25, RxCachedThreadScheduler-5=25, RxCachedThreadScheduler-6=25, RxCachedThreadScheduler-7=25} \r\n```\r\n\r\nIt shows that after scheduling execution of blocking operations on an IO pool, the observable runs all these operations on a single thread instead.\r\n\r\nI would really appreciate any suggestions to retain equal load on all threads even in the presence of blocking operations!",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5941/comments",
    "author": "sndre",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2018-03-31T08:51:28Z",
        "body": "The outcome is completely within allowed behavior for two things:\r\n\r\n- `flatMap` doesn't guarantee that a source thread will be able to push through. It is completely possible that one or few threads will perform the merge for the other threads, therefore, it may appear only one or two threads are only involved pushing data further to the downstream.\r\n- You are measuring the thread use at the end consumer, which is always serialized thus there is no guarantee you'll see that many thread hopping there. To make sure `op` is executed in various background threads, you should apply it after `g.observeOn(Schedulers.io())` inside `flatMap` as well as do the current thread check there."
      }
    ]
  },
  {
    "number": 5939,
    "title": "2.x: Observable.switchMapCompletable does not call action on completion",
    "created_at": "2018-03-30T07:59:47Z",
    "closed_at": "2018-04-01T08:23:10Z",
    "labels": [
      "Question",
      "2.x",
      "Kotlin"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5939",
    "body": "Maybe I\u2019m using it wrong though. I\u2019ve prepared some tests.\r\n\r\n```kotlin\r\nimport io.reactivex.Completable\r\nimport io.reactivex.functions.Action\r\nimport io.reactivex.schedulers.TestScheduler\r\nimport io.reactivex.subjects.PublishSubject\r\nimport org.junit.Test\r\nimport org.mockito.Mockito\r\nimport java.util.concurrent.TimeUnit\r\n\r\nclass CompletableTest {\r\n\r\n    private class Environment {\r\n\r\n        private val completableSeconds = 5\r\n\r\n        val timeScheduler = TestScheduler()\r\n        val action = Mockito.mock(Action::class.java)\r\n\r\n        val observable = PublishSubject.create<Unit>()\r\n        val completable = Completable.timer(completableSeconds.toLong(), TimeUnit.SECONDS, timeScheduler)\r\n\r\n        fun trigger() {\r\n            observable.onNext(Unit)\r\n            timeScheduler.advanceTimeBy(completableSeconds.toLong(), TimeUnit.SECONDS)\r\n        }\r\n    }\r\n\r\n    @Test fun pass_directSubscription() {\r\n        val env = Environment()\r\n\r\n        env.observable.subscribe { env.completable.subscribe(env.action) }\r\n\r\n        env.trigger()\r\n\r\n        Mockito.verify(env.action).run()\r\n    }\r\n\r\n    @Test fun fail_switchMapCompletable() {\r\n        val env = Environment()\r\n\r\n        env.observable.switchMapCompletable { env.completable }.subscribe(env.action)\r\n\r\n        env.trigger()\r\n\r\n        Mockito.verify(env.action).run()\r\n    }\r\n}\r\n```\r\n```\r\nWanted but not invoked:\r\naction.run();\r\n-> at CompletableTest.fail_switchMapCompletable\r\nActually, there were zero interactions with this mock.\r\n```",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5939/comments",
    "author": "arturdryomov",
    "comments": [
      {
        "user": "artem-zinnatullin",
        "created_at": "2018-03-30T17:10:01Z",
        "body": "Because it returns `Completable` that waits for upstream completion, like regular `switchMap`\r\n\r\nSimpler test:\r\n\r\n```java\r\n@Test\r\npublic void t1() {\r\n    PublishSubject<Integer> subject = PublishSubject.create();\r\n\r\n    subject\r\n            .switchMapCompletable(new Function<Integer, CompletableSource>() {\r\n                @Override\r\n                public CompletableSource apply(Integer integer) throws Exception {\r\n                    return Completable.complete();\r\n                }\r\n            })\r\n            .test()\r\n            .assertComplete(); // Fails!\r\n}\r\n```\r\n\r\nBut if you complete upstream, it'll complete `switchMapCompletable`:\r\n\r\n```java\r\n@Test\r\npublic void t2() {\r\n    PublishSubject<Integer> subject = PublishSubject.create();\r\n\r\n    TestObserver<Void> test = subject\r\n            .switchMapCompletable(new Function<Integer, CompletableSource>() {\r\n                @Override\r\n                public CompletableSource apply(Integer integer) throws Exception {\r\n                    return Completable.complete();\r\n                }\r\n            })\r\n            .test();\r\n\r\n    test.assertNotComplete();\r\n\r\n    subject.onComplete();\r\n    \r\n    test.assertComplete();\r\n}\r\n```\r\n\r\n\r\nEdit: add \"Fails!\" comment."
      }
    ]
  },
  {
    "number": 5855,
    "title": "Why zip(range(0, 1mi)), range(0, 100)) never finishes, when inverting the order does?",
    "created_at": "2018-02-15T23:19:53Z",
    "closed_at": "2018-02-15T23:33:47Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5855",
    "body": "Version: \"2.1.9\"\r\n\r\nI recently ran into a problem where the order of my parameters to the Zip function matters, and now I'm trying to understand why.\r\n\r\nHere's a simplified test:\r\n\r\n```kotlin\r\nval bigRange = Observable.range(0, 1_000_000_000)\r\nval shortRange = Observable.range(0, 100)\r\n\r\nval ts = Observable.zip(shortRange, bigRange, BiFunction<Int, Int, Int> { _, b -> b }).test()\r\n// val ts = Observable.zip(bigRange, shortRange, BiFunction<Int, Int, Int> { a, _ -> a }).test()\r\n\r\nts.awaitTerminalEvent(10, TimeUnit.SECONDS)\r\n```\r\n\r\nIn the test above, the stream completes as expected; with 100 items. However, if I uncomment the other `ts`, then the app hangs.\r\n\r\nFrom the docs it makes me believe that if any of the streams completes, then the whole \"zip\" completes, but this is maybe not the case? Is it something to do with the Observable being a \"pusher\" and not a \"puller\"?\r\n\r\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5855/comments",
    "author": "AllanHasegawa",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2018-02-15T23:24:17Z",
        "body": "`Observable` doesn't have backpressure and `range` is synchronous and will fill up the internal queue of `zip` before giving the chance to the other source. If the short one is first, that happens quickly. If the longer one is first, that may take a lot of time and memory. Try with `Flowable` and you should see both cases complete within reasonable time.\r\n\r\nRxJava is synchronous by default and you have to introduce asynchrony explicitly."
      }
    ]
  },
  {
    "number": 5829,
    "title": "Improve takeUntil method",
    "created_at": "2018-01-31T09:26:46Z",
    "closed_at": "2018-01-31T09:53:33Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5829",
    "body": "rxJava version : 2.x\r\n\r\nBoth 'takeUntil' and 'takeWhile' functions have no inclusive functions.\r\nSo It is impossible to make the following code.\r\n\r\n```java\r\nObservable.just(1,2,3,4,-1,1,2,3,4)\r\n.takeUntil(value -> value == -1)\r\n// I wish : 1, 2, 3, 4, -1\r\n// actually : 1, 2, 3, 4\r\n```\r\n\r\nor in real world...\r\n```java\r\nObservable.merge(\r\n    cacheRequest,\r\n    networkRequest\r\n)\r\n.takeUntilInclusive(data -> data.dataType == FROM_NETWORK);\r\n// Load mem/network data. But when it comes to network data, it stops.\r\n```\r\n\r\nhow about create blow functions?\r\n\r\n`takeWhileInclusive`\r\n`takeUntilInclusive`\r\n`skipWhileInclusive`\r\n`skipUntilInclusive`",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5829/comments",
    "author": "JSpiner",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2018-01-31T09:34:26Z",
        "body": "Have you actually tried your code?\r\n\r\n```java\r\nObservable.just(1,2,3,4,-1,1,2,3,4)\r\n        .takeUntil(value -> value == -1)\r\n        .subscribe(System.out::println);\r\n```\r\n\r\nprints:\r\n\r\n```\r\n1\r\n2\r\n3\r\n4\r\n-1\r\n```\r\n\r\nI'm not sure what you tried to accomplish originally, but `merge()` looks suspicious as it can interleave your data unexpectedly. Try `concat()`."
      }
    ]
  },
  {
    "number": 5812,
    "title": "2.x: Surprising `startWith` scheduling behaviour",
    "created_at": "2018-01-17T09:13:58Z",
    "closed_at": "2018-01-17T09:40:19Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5812",
    "body": "Android and RxJava 2.1.8:\r\n\r\nI ran into a surprising behaviour of `startWith` that I'd like to verify. I've boiled it down to a simple example:\r\n```\r\nObservable.just(Unit)\r\n                .observeOn(Schedulers.io())\r\n                .startWith(Unit)\r\n                .switchMap {\r\n                    Observable.create<Unit> { emitter ->\r\n                        Thread.sleep(5000)\r\n                        emitter.onNext(Unit)\r\n                        emitter.onComplete()\r\n                    }\r\n                }\r\n                .observeOn(AndroidSchedulers.mainThread())\r\n                .subscribe()\r\n```\r\n\r\nIn the above example, execution of the observable inside `switchMap` happens on the main scheduler and blocks my UI. \r\n\r\nI would expect that it will happen on the `io` scheduler and it does indeed, as soon as I remove `startWith`. \r\n\r\nI realise I can just add another `observeOn` after `startWith` but it's puzzling. We're already on the `io` scheduler when the `startWith` gets hit, so why would it switch threads?",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5812/comments",
    "author": "Rosomack",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2018-01-17T09:21:54Z",
        "body": "`startWith` subscribes to its argument (constants are turned into Observable.just()) on the current thread and `observeOn` is above it, thus can't have any effect of it. Let me rewrite your code to make it more apparent:\r\n\r\n```java\r\nObservable.concat(\r\n    Observable.just(Unit),\r\n    Observable.just(Unit).observeOn(Schedulers.io())\r\n)\r\n.switchMap {\r\n       Observable.create<Unit> { emitter ->\r\n                Thread.sleep(5000)\r\n                emitter.onNext(Unit)\r\n                emitter.onComplete()\r\n       }\r\n }\r\n .observeOn(AndroidSchedulers.mainThread())\r\n .subscribe()\r\n```\r\n\r\nAs the subscription travels up, the thread hasn't changed so the first `just` will emit `Unit` on the caller thread which then goes into the blocking `switchMap`. \r\n\r\nYou can apply `subscribeOn` instead and the `switchMap` will trigger on the background thread:\r\n\r\n```java\r\nObservable.just(Unit)\r\n                .startWith(Unit)\r\n                .switchMap {\r\n                    Observable.create<Unit> { emitter ->\r\n                        Thread.sleep(5000)\r\n                        emitter.onNext(Unit)\r\n                        emitter.onComplete()\r\n                    }\r\n                }\r\n                .subscribeOn(Schedulers.io())\r\n                .observeOn(AndroidSchedulers.mainThread())\r\n                .subscribe()\r\n```\r\n\r\nor move the `observeOn` below the `startWith`:\r\n\r\n```java\r\nObservable.just(Unit)\r\n                .startWith(Unit)\r\n                .observeOn(Schedulers.io())\r\n                .switchMap {\r\n                    Observable.create<Unit> { emitter ->\r\n                        Thread.sleep(5000)\r\n                        emitter.onNext(Unit)\r\n                        emitter.onComplete()\r\n                    }\r\n                }\r\n                .observeOn(AndroidSchedulers.mainThread())\r\n                .subscribe()\r\n```"
      }
    ]
  },
  {
    "number": 5730,
    "title": "How to execute a flowable dependent from another?",
    "created_at": "2017-11-18T15:29:43Z",
    "closed_at": "2017-11-22T14:32:59Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5730",
    "body": "I want to chain two flowables, when the first one finishes to collect data from the network its result (an array list) must be passed to the second flowable.\r\nThe flowables update the UI as described in the scenario shown below, when an error occurs the execution is stopped.\r\n\r\nI hope to be more clear as possible adding all details about the expected result and the code I wrote\r\n\r\nThe scenario\r\n\r\n1. flowable-1 makes X network calls (X value depends on some condition COND)\r\n2. every network call returns a list of items (size can vary)\r\n3. the UI shows the count of items (eg. \"Retrieved 1 items\", \"Retrieved 5 items\")\r\n4. all calls are done (the condition COND is satisfied)\r\n5. all items collected now must post-processed by flowable-2\r\n6. the UI shows the progress (eg. 'item 1 of 9', 'item 2 of 9', ..., 'item 9 of 9')\r\n\r\nA possible expected output should be\r\n\r\n    Retrieved 1 item(s) |  \r\n    Retrieved 3 item(s) |- printed inside the doOnNext() 'called' by flowable-1\r\n    Retrieved 5 item(s) |  the array contains 9 items (1 + 3 + 5)\r\n\r\n    Item 1 of 9         |\r\n    ...                 |- printed inside the doOnNext() 'called' by flowable-2\r\n    Item 9 of 9         |\r\n      \r\n    Finished            | printed inside the subscribe()\r\n\r\n\r\nI've used Flowable.generate() to collected items from network calls\r\n\r\n```java\r\npublic Flowable<List<String>> fetchFromNetFlowable() {\r\n    offset = 0;\r\n    return Flowable.generate(new Consumer<Emitter<List<String>>>() {\r\n        @Override\r\n        public void accept(Emitter<List<String>> emitter) throws Exception {\r\n            List<String> subset = networkCall(offset);\r\n            boolean loadNext = subset.size() > 0;\r\n            offset += subset.size();\r\n\r\n            final ArrayList<String> validItems = new ArrayList<>();\r\n            for (String dummy : subset) {\r\n                if (conditionMet(dummy)) {\r\n                    validItems.add(dummy);\r\n                } else {\r\n                    loadNext = false;\r\n                    break;\r\n                }\r\n            }\r\n            if (!validItems.isEmpty()) {\r\n                emitter.onNext(validItems);\r\n            }\r\n            if (!loadNext) {\r\n                emitter.onComplete();\r\n            }\r\n        }\r\n    });\r\n}\r\n```\r\n\r\nThe second flowable will be used to update UI from onNext() caller\r\n\r\n```java\r\npublic Flowable secondFlowable(final Iterator<String> iterator) {\r\n    return Flowable.generate((emitter) -> {\r\n        if (iterator.hasNext()) {\r\n            // do some stuff with value\r\n            emitter.onNext(iterator.next());\r\n        } else {\r\n            emitter.onComplete();\r\n        }\r\n    });\r\n}\r\n```\r\n\r\nThen I would use both flowables but I don't understard how to make the second dependent from the first one, the `processTheListCallingTheSecondFlowable()` must be called only when `fetchFromNetFlowable()` has finished\r\n\r\n```java\r\npublic readDataAndProcess() {\r\n    total = 0;\r\n    compositeDisposable.add(postRetrieverRx.readPhotoPosts(blogName)\r\n            .subscribeOn(Schedulers.io())\r\n            .observeOn(AndroidSchedulers.mainThread())\r\n            .toObservable()\r\n            .doOnNext((tumblrPost) -> {\r\n                    total += tumblrPost.size();\r\n                    System.out.println(\"Retrieved \" + total + \" items\");\r\n            })\r\n            .flatMap((posts) -> Observable.fromIterable(posts))\r\n            .toList() // <--- now I have the single list with all items\r\n            // I don't know how to do\r\n            // processTheListCallingTheSecondFlowable() isn't an rx operator\r\n            // consider it only pseudo code\r\n            .processTheListCallingTheSecondFlowable()\r\n            .subscribe((allPosts) -> System.out.println(\"Finished\")\r\n    );\r\n}\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5730/comments",
    "author": "dafi",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-11-18T15:59:12Z",
        "body": "The `flatMap` is a typical dependent continuation operator:\r\n\r\n```java\r\n    .toList()\r\n    .flatMapPublisher(list -> processTheListViaFlowable(list))\r\n    .subscribe(/* ... */);\r\n```"
      }
    ]
  },
  {
    "number": 5727,
    "title": "[RxJava 2.1.0] Single with Cache cancellable behaviour",
    "created_at": "2017-11-15T17:52:41Z",
    "closed_at": "2017-11-16T10:32:56Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5727",
    "body": "Hi,\r\nI'm using `Single` in the following way,\r\n\r\n           val bleConnection = Single.create({  \r\n             emitter -> // Do some one-time bluetooth connection operation and emit ble connection\r\n             emitter.setCancellable { \r\n                    // close the ble connection as this single is unsubscribed\r\n             }\r\n           }).cache()\r\n\r\n\r\nNow I expected `setCancellable` block to run when all the subscribers are disposed. But that block gets called on `onSuccess` or `onError`. So `Single` terminates itself when either success or error happens. But I want to run some cleanup operation when all my subscribers are disposed. How would I do that with `Single`? This can be easily achieved with `Flowable` or `Observable`. But this is essentially `Single` operation (Not a stream, just an one-time connection value). So I thought `Single` is the correct operator to use in this case.",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5727/comments",
    "author": "BharathMG",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-11-15T18:04:36Z",
        "body": "This is not supported by `Single`. You have to use `Observable.create()`, `share()` and `singleOrError()` to have the final type `Single`. A longer path is similar, given the current `cache()`, convert it via `toObservable()`, `share()` and then `singleOrError()` back."
      },
      {
        "user": "BharathMG",
        "created_at": "2017-11-16T05:57:13Z",
        "body": "Sure, but another problem with `cache()` is,\r\n\r\n         val single = Single.create<Boolean>({ emitter ->\r\n         emitter.setCancellable {\r\n              println(\"CANCELLED\")\r\n          }\r\n        }).cache()\r\n\r\n        val test1 = single.subscribe()\r\n        val test2 = single.subscribe()\r\n        val test3 = single.subscribe()\r\n\r\n        test1.dispose()\r\n        test2.dispose()\r\n        test3.dispose()\r\n\r\n        println(\"ALL DISPOSED\")\r\n\r\nHere CANCELLED will not be printed as desired. It waits for `Single` to emit some value before cancelling and not for disposal. Is this intended?"
      },
      {
        "user": "akarnokd",
        "created_at": "2017-11-16T08:27:00Z",
        "body": "You have to do it through `Observable` as I described:\r\n\r\n```java\r\nvar single = Observable.create(emitter -> {\r\n    emitter.setCancellable(() -> System.out.println(\"Cancelled\"));\r\n})\r\n.replay()\r\n.refCount()\r\n.singleOrError();\r\n```"
      }
    ]
  },
  {
    "number": 5588,
    "title": "ConnectableObservable.connect() causes NetworkOnMainThreadException",
    "created_at": "2017-09-06T15:02:52Z",
    "closed_at": "2017-09-14T14:25:23Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5588",
    "body": "## Versions \r\nRxJava: 2.1.0\r\nRxAndroid: 2.0.1\r\n\r\n## Issue\r\nI'm using the following pattern to allow me to share the result of an expensive network call across two observables, which both transform the result in different ways:\r\n\r\n```java\r\nConnectableObservable<Model> connectableObservable = doExpensiveNetworkCall().publish();\r\n\r\n// Transform in one way.\r\nconnectableObservable\r\n    .filter(...)\r\n    .subscribeOn(mDataManager.getScheduler())\r\n    .observeOn(AndroidSchedulers.mainThread())\r\n    .subscribe(...);\r\n\r\n// Transform in another.\r\nconnectableObservable\r\n    .filter(....)\r\n    .subscribeOn(mDataManager.getScheduler())\r\n    .observeOn(AndroidSchedulers.mainThread())\r\n    .subscribe(...);\r\n\r\n// And connect... Uh oh,  NetworkOnMainThreadException!\r\nconnectableObservable.connect();\r\n```\r\n\r\nThis is a very useful pattern, however, calling `.connect()` causes `NetworkOnMainThreadException` as the expensive network call is then run on the *main thread*, despite all subscribers of the downstream observables being on a separate thread.\r\n\r\nIs there an equivalent of `.connectOn()` or another alternative which can be used to also let the ConnectableObservable know that it should be run on a different thread? Alternatively, if there's a better way of achieving the above, any guidance would be much appreciated!",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5588/comments",
    "author": "DCRichards",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-09-06T15:42:56Z",
        "body": "`publish` turns the cold source into a hot one, similar to a `PublishSubject`, and `subscribeOn` has no practical effect on hot publish-like sources. In other terms, applying `subscribeOn` after the `ConnectableObservable` has no effect. You have to apply `subscribeOn` before the publishing:\r\n\r\n```java\r\nConnectableObservable<Model> connectableObservable = doExpensiveNetworkCall()\r\n    .subscribeOn(mDataManager.getScheduler())                  // <------------------------------\r\n    .publish();\r\n\r\n// Transform in one way.\r\nconnectableObservable\r\n    .filter(...)\r\n    .observeOn(AndroidSchedulers.mainThread())\r\n    .subscribe(...);\r\n```"
      }
    ]
  },
  {
    "number": 5583,
    "title": "how to subscribe BiConsumer with 2.x",
    "created_at": "2017-09-04T10:05:34Z",
    "closed_at": "2017-09-05T01:33:31Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5583",
    "body": "Hi,\r\n\r\nHow can I subscribe BiConsumer just like subscribe Consumer?\r\n code like this:\r\n\r\n```java\r\nBiConsumer<Integer, String> biConsumer = new BiConsumer<Integer, String>() {\r\n\r\n            @Override\r\n            public void accept(Integer integer, String s) throws Exception {\r\n\r\n            }\r\n        };\r\nObservable.create().subscribe(biConsumer);\r\n```       \r\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5583/comments",
    "author": "TxShon",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-09-04T10:14:55Z",
        "body": "That is not possible with RxJava. You have to combine data elements into classes or tuples."
      }
    ]
  },
  {
    "number": 5562,
    "title": "in this case subscribe onNext not working",
    "created_at": "2017-08-23T03:47:21Z",
    "closed_at": "2017-08-26T10:38:24Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5562",
    "body": "Thanks for using RxJava but before you post an issue, please consider the following points:\r\n\r\nhere is my retrofit and rxjava version\uff1a\r\n\r\n    //rx\r\n    compile 'io.reactivex.rxjava2:rxjava:2.0.3'\r\n    compile 'io.reactivex.rxjava2:rxandroid:2.0.1'\r\n    //retrofit\r\n    compile 'com.squareup.retrofit2:retrofit:2.2.0'\r\n    compile 'com.squareup.retrofit2:converter-gson:2.0.2'\r\n    compile 'com.squareup.retrofit2:adapter-rxjava2:2.2.0'\r\n    //okhttp3\r\n    compile 'com.squareup.okhttp3:okhttp:3.4.1'\r\n    compile 'com.squareup.okhttp3:logging-interceptor:3.4.1'\r\n    compile 'com.squareup.okio:okio:1.6.0'\r\n\r\n retrofit like this\r\n`    @GET(\"getAppList\")\r\n    Flowable<EBApiResult<List<UserAppInfo>>> testGetUserApp();`\r\n\r\nrxjava like this\r\n\r\n`          Flowable<EBApiResult<List<UserAppInfo>>>  flowable = testGetAppInfos();`\r\n\r\n        flowable.map(new Function<EBApiResult<List<UserAppInfo>>, List<UserAppInfo>>() {\r\n\r\n            @Override\r\n            public List<UserAppInfo> apply(EBApiResult<List<UserAppInfo>> result) throws Exception {\r\n                return result.getResultData();\r\n            }\r\n        }).subscribeOn(Schedulers.io())\r\n                .observeOn(AndroidSchedulers.mainThread())\r\n                .subscribe(new Subscriber<List<UserAppInfo>>() {\r\n                    @Override\r\n                    public void onSubscribe(Subscription s) {\r\n                        Log.i(\"123\");\r\n                    }\r\n\r\n                    @Override\r\n                    public void onNext(List<UserAppInfo> userAppInfos) {\r\n                        uiPresenter.bindAppInfoList(result);\r\n                    }\r\n\r\n                    @Override\r\n                    public void onError(Throwable t) {\r\n                        uiPresenter.errPage(t.getMessage());\r\n                    }\r\n\r\n                    @Override\r\n                    public void onComplete() {\r\n                        uiPresenter.errPage(null);\r\n                    }\r\n                });`\r\n\r\nI can see that onSubscribe is called back\r\nbut onNext onError is not\u3002\r\n\r\nIf I call rxjava like this\r\n\r\n`          Flowable<EBApiResult<List<UserAppInfo>>>  flowable = testGetAppInfos();`\r\n\r\n      flowable.map(new Function<EBApiResult<List<UserAppInfo>>, List<UserAppInfo>>() {\r\n\r\n            @Override\r\n            public List<UserAppInfo> apply(EBApiResult<List<UserAppInfo>> result) throws Exception {\r\n                return result.getResultData();\r\n            }\r\n        }).subscribeOn(Schedulers.io())\r\n                .observeOn(AndroidSchedulers.mainThread())\r\n                .subscribe(new Consumer<List<UserAppInfo>>() {\r\n                    @Override\r\n                    public void accept(List<UserAppInfo> appInfos) throws Exception {\r\n                        storeAppInfos(appInfos);\r\n                        List<UserAppInfo> result = filterListByCurrentCondition(appInfos, CURRENT_NEED_SHOW_APPS);\r\n                        uiPresenter.bindAppInfoList(result);\r\n                    }\r\n                }, new Consumer<Throwable>() {\r\n                    @Override\r\n                    public void accept(Throwable t) throws Exception {\r\n                        uiPresenter.errPage(t.getMessage());\r\n                    }\r\n                }, new Action() {\r\n                    @Override\r\n                    public void run() throws Exception {\r\n                    }\r\n                });`\r\n\r\nevery accept can be reached\r\ni dont know why\u3002\r\nbut i debug with source\uff0cI doubt it because...my Flowable\u2018s implementation is not QueueSubscription\u3002\r\n\r\nI don't know how to fix my problem. I hope you can understand",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5562/comments",
    "author": "neodreamtale",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-08-23T10:05:48Z",
        "body": "You have to call `s.request(Long.MAX_VALUE)` in the first case where you have `Log.i(\"123\")`."
      }
    ]
  },
  {
    "number": 5561,
    "title": "Task order for Observable.combineLatest and Schedulers.computation()",
    "created_at": "2017-08-22T18:25:28Z",
    "closed_at": "2017-08-22T23:30:10Z",
    "labels": [
      "Question",
      "1.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5561",
    "body": "Version: 1.3.0\r\n\r\nHello!\r\n\r\nI have observed strange behavior while I was using combineLatest with Schedulers.computation(). Please take a look at example:\r\n```java\r\n   private static void runSubscription(String prefix, boolean shouldWait, ConcurrentMap<String, Integer> stat) {\r\n        Observable<Long> interval = Observable.interval(1000, TimeUnit.MILLISECONDS);\r\n        Observable.combineLatest(Observable.just(prefix), interval, (s1, s2) -> s1)\r\n            .subscribeOn(Schedulers.computation())\r\n            .observeOn(Schedulers.computation())\r\n            .onBackpressureLatest()\r\n            .subscribe(s -> {\r\n                try {\r\n                    if (shouldWait) {\r\n                        Thread.sleep(4000);\r\n                    }\r\n                } catch (InterruptedException e) {\r\n                    e.printStackTrace();\r\n                }\r\n                stat.merge(s, 1, (v1, v2) -> v1 + v2);\r\n            });\r\n    }\r\n\r\n    public static void main(String[] args) throws Exception {\r\n        ConcurrentMap<String, Integer> stat = new ConcurrentHashMap<>();\r\n\r\n        stat.put(\"1\", 0);\r\n        runSubscription(\"1\", true, stat);\r\n        for (int i = 1; i < Runtime.getRuntime().availableProcessors(); i++) {\r\n            String key = String.valueOf(i + 1);\r\n            stat.put(key, 0);\r\n            runSubscription(key, false, stat);\r\n        }\r\n\r\n        while (!Thread.currentThread().isInterrupted()) {\r\n            // Print invocation statistics\r\n            System.out.println(stat);\r\n            Thread.sleep(4000);\r\n        }\r\n    }\r\n```\r\nThe output shows how many times particular subscriber was invoked. First column - subscriber number, second - invocation count. For version above output is:\r\n```\r\n{1=0, 2=0, 3=0, 4=0}\r\n{1=0, 2=1, 3=1, 4=3}\r\n{1=1, 2=1, 3=1, 4=7}\r\n{1=2, 2=1, 3=1, 4=11}\r\n{1=3, 2=1, 3=1, 4=15}\r\n{1=4, 2=1, 3=1, 4=19}\r\n{1=5, 2=1, 3=1, 4=23}\r\n{1=6, 2=1, 3=1, 4=27}\r\n{1=7, 2=1, 3=1, 4=31}\r\n...\r\n```\r\nThe output is not stable, but every time some of threads invoked less times. \r\nBut when I changed both `Schedulers.computation()` to `Schedulers.io()`, output changed to expected:\r\n```\r\n{1=0, 2=0, 3=0, 4=0}\r\n{1=0, 2=3, 3=3, 4=3}\r\n{1=1, 2=7, 3=7, 4=7}\r\n{1=2, 2=11, 3=11, 4=11}\r\n{1=3, 2=15, 3=15, 4=15}\r\n{1=4, 2=19, 3=19, 4=19}\r\n```\r\nIs it incorrect usage of scheduler, or it is a bug?",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5561/comments",
    "author": "dya-victor",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-08-22T20:16:49Z",
        "body": "The `computation` scheduler has a number of worker threads that is, by default, is equal to the number of available processors and hands out worker threads in a round robin fashion. Since there is a limited number of them and you block one of them in your first run, the subsequent runs will likely get that scheduler and block tasks behind it.\r\n\r\nYou are practically wasting schedulers as `subscribeOn` in this case has no effect, `interval` already runs on the computation scheduler and `observeOn` moves the events from one computation worker to another without much benefit."
      },
      {
        "user": "dya-victor",
        "created_at": "2017-08-22T22:36:55Z",
        "body": "Thank you for quick answer! But I still have a doubts. I tried to changed `Schedulers.computation` to `Schedulers.from(Executors.newFixedThreadPool(3))`, nine subscriptions, and it did work as expected:\r\n```\r\n{1=0, 2=0, 3=0, 4=0, 5=0, 6=0, 7=0, 8=0, 9=0}\r\n{1=0, 2=3, 3=3, 4=3, 5=3, 6=3, 7=3, 8=3, 9=3}\r\n{1=1, 2=7, 3=7, 4=7, 5=7, 6=7, 7=7, 8=7, 9=7}\r\n{1=2, 2=11, 3=11, 4=11, 5=11, 6=11, 7=11, 8=11, 9=11}\r\n```\r\nIn the same time, even with removing `observeOn` and `subscribeOn` number of invocations are not even. \r\n\r\n<details>\r\n<summary>Modified code, Executor used</Summary>\r\n\r\n```java\r\npublic class Main {\r\n    private static final Executor executor = Executors.newFixedThreadPool(3);\r\n\r\n    private static void runSubscription(String prefix, boolean shouldWait, ConcurrentMap<String, Integer> stat) {\r\n        Observable<Long> interval = Observable.interval(1000, TimeUnit.MILLISECONDS);\r\n        Observable.combineLatest(Observable.just(prefix), interval, (s1, s2) -> s1)\r\n                .onBackpressureLatest()\r\n                .observeOn(Schedulers.from(executor))\r\n                .subscribeOn(Schedulers.from(executor))\r\n                //.observeOn(Schedulers.computation())\r\n                .subscribe(s -> {\r\n                    try {\r\n                        if (shouldWait) {\r\n                            Thread.sleep(4000);\r\n                        }\r\n                    } catch (InterruptedException e) {\r\n                        e.printStackTrace();\r\n                    }\r\n                    stat.merge(s, 1, (v1, v2) -> v1 + v2);\r\n                });\r\n    }\r\n\r\n    public static void main(String[] args) throws Exception {\r\n        ConcurrentMap<String, Integer> stat = new ConcurrentHashMap<>();\r\n\r\n        stat.put(\"1\", 0);\r\n        runSubscription(\"1\", true, stat);\r\n        for (int i = 1; i < Runtime.getRuntime().availableProcessors() + 5; i++) {\r\n            String key = String.valueOf(i + 1);\r\n            stat.put(key, 0);\r\n            runSubscription(key, false, stat);\r\n        }\r\n\r\n        while (!Thread.currentThread().isInterrupted()) {\r\n            // Print invocation statistics\r\n            System.out.println(stat);\r\n            Thread.sleep(4000);\r\n        }\r\n    }\r\n}\r\n```\r\n</details>"
      },
      {
        "user": "akarnokd",
        "created_at": "2017-08-22T22:46:37Z",
        "body": "`Executors.newFixedThreadPool(3)` works differently than our schedulers. We have N x `Executors.newSingleThreadedScheduledExecutor()`, each of them handed out to operators on demand. If one gets stuck, everybody who gets that executor is blocked. \r\n\r\nIn contrast, `newFixedThreadPool(3)` has 3 workers which pick the next task from a shared queue. If one is blocked, the other 2 will be still able to pick tasks from the queue."
      },
      {
        "user": "timofeevda",
        "created_at": "2017-08-23T09:35:05Z",
        "body": "> Executors.newSingleThreadedScheduledExecutor(), each of them handed out to operators on demand. If one gets stuck, everybody who gets that executor is blocked.\r\n\r\nThat's a strange design decision. If we replace Thread.sleep() with tough computational work (e.g. several nested loops with large amount of iterations) one of \"observeOn\" operators will be starving because the other one keeps getting tasks from \"observeOn\" queue effectively blocking other operator who got that executor.\r\n\r\nIn case of bad timings, backpressure and conditional logic within \"CPU bound\" work (leading to arbitrary execution time spent in observer) usage of Scheduler.computation() will lead to completely unpredictable results.\r\n\r\nLooks like round-robin policy of handing out pooled worker is very sensitive to the rate of events and time computational work takes. Shared queue doesn't have this issue but may be slightly less efficient.\r\n\r\nIn any case behavior described above seems conterintuitive. I would except scheduler to try to invoke tasks regardless of \"slow\" tasks performed in one of the workers. "
      },
      {
        "user": "akarnokd",
        "created_at": "2017-08-23T10:01:22Z",
        "body": "> That's a strange design decision.\r\n\r\nIt is designed as such by default to avoid thread hopping that hurts performance in the long run. Plus, if you actually don't block but compute something, you are making progress.\r\n\r\n> I would except scheduler to try to invoke tasks regardless of \"slow\" tasks performed in one of the workers.\r\n\r\nThe default doesn't do that because most operators expect a FIFO execution and reliable delayed scheduling which can be achieved by a single threaded scheduled executor. \r\n\r\nFor all other cases, there is the option of `Schedulers.from` which adds the penalty for forcing a FIFO execution internally in case the underlying executor is multi-threaded and has to use helper schedulers to ensure timing stays ordered."
      }
    ]
  },
  {
    "number": 5559,
    "title": "Sample operator with BehaviorSubject issue",
    "created_at": "2017-08-22T15:20:15Z",
    "closed_at": "2017-08-22T16:34:56Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5559",
    "body": "When trying to use the sample operator with a BehaviorSubject as sampler it didn't work as expected (or understood).\r\nFor instance, this simple unit test fails:\r\n\r\n```java\r\n\u2002@Test\r\n\u2002\u2002\u2002\u2002public void testSampler() {\r\n\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002PublishSubject<Long> generator = PublishSubject.create();\r\n\r\n\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002BehaviorSubject<Boolean> sampler = BehaviorSubject.createDefault(true);\r\n\r\n\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002TestObserver<Long> sampledGeneratorObserver = generator.sample(sampler).test();\r\n\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002generator.onNext(2L);\r\n\r\n\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002sampledGeneratorObserver.assertValueCount(1);\r\n\u2002\u2002\u2002\u2002}\r\n```\r\n\r\nRX version: 2.1.x\r\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5559/comments",
    "author": "jaumard",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-08-22T15:28:21Z",
        "body": "Sampler is subscribed before the generator source thus the default `true` sampled nothing as the generator hasn't emitted anything yet. If you call `sampler.onNext(true)` after `generator.onNext(2L)`, the test should pass."
      }
    ]
  },
  {
    "number": 5532,
    "title": "RxJava 2 and async subscriber",
    "created_at": "2017-08-02T17:16:46Z",
    "closed_at": "2017-08-03T05:55:57Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5532",
    "body": "Hi, I am using RxJava 2.1.2 and found recently sample code that worked in RxJava 1.x but seems to work differently in RxJava 2.\r\nWhen I execute the code below I assume that each \"subscribe\" code will be run in new thread. However it is run in new but the same thread \"RxNewThreadScheduler-1\". I assume that Schedulers.io() should create a new thread per each long-running task. Please advice.\r\n\r\n```java\r\npublic class SampleRx {\r\n\tpublic static void main(String[] args) throws Exception {\r\n\t\tObservable.fromArray(\"1\", \"2\", \"3\")\r\n\t\t\t.observeOn(Schedulers.io())\r\n\t\t\t.subscribe(item -> { \r\n\t\t\t\tSystem.out.println(\r\n\t\t\t\t\t\tThread.currentThread().getName());\r\n\t\t\tThread.sleep(2000); });\r\n\t\tThread.sleep(7000);\r\n\t}\r\n}\r\n```",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5532/comments",
    "author": "sergey-morenets",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-08-02T18:02:32Z",
        "body": "`Schedulers.io()` reuses threads so if there is a small delay after a flow terminates, the same thread will appear to serve the next flow. This behavior should be the same for both v1 and v2. Your sample code has one flow so it can't show any effects of multiple flows. Could you clarify it?"
      },
      {
        "user": "sergey-morenets",
        "created_at": "2017-08-02T18:19:32Z",
        "body": "Hi @akarnokd \r\n\r\nYes, it's strange but it seems to work the same way in 1.x.\r\nCan you advise then how to to modify the original code so that each subscribe method will be invoked in the separate thread ?"
      },
      {
        "user": "akarnokd",
        "created_at": "2017-08-02T18:22:58Z",
        "body": "There is the `Schedulers.newThread` for that."
      },
      {
        "user": "sergey-morenets",
        "created_at": "2017-08-02T18:31:29Z",
        "body": "Thank you, @akarnokd \r\n\r\nDo you mean this code? Unfortunately it still uses one thread \"RxNewThreadScheduler-1\"\r\n\r\n```java\r\n\t\tObservable.fromArray(\"1\", \"2\", \"3\")\r\n\t\t\t.observeOn(Schedulers.newThread())\r\n\t\t\t.subscribe(item -> { \r\n\t\t\t\tSystem.out.println(\r\n\t\t\t\t\t\tThread.currentThread().getName());\r\n\t\t\tThread.sleep(2000); });\r\n\t\tThread.sleep(7000);\r\n```"
      },
      {
        "user": "akarnokd",
        "created_at": "2017-08-02T19:27:46Z",
        "body": "It's unclear to me how do you expect multiple threads when subscribing once?\r\n\r\nTry this:\r\n\r\n```java\r\nObservable<String> source = \r\n    Observable.fromArray(\"1\", \"2\", \"3\")\r\n    .observeOn(Schedulers.newThread());\r\n\r\nsource.subscribe(v -> System.out.println(Thread.currentThread().getName()));\r\n\r\nsource.subscribe(v -> System.out.println(Thread.currentThread().getName()));\r\n\r\nThread.sleep(10000);\r\n```\r\n\r\nor this:\r\n\r\n```java\r\nObservable.fromArray(\"1\", \"2\", \"3\")\r\n  .flatMap(v -> \r\n    Observable.just(v)\r\n       .subscribeOn(Schedulers.newThread())\r\n       .map(v -> Thread.currentThread().getName())\r\n  )\r\n  .subscribe(System.out::println);\r\n\r\nThread.sleep(10000);\r\n```"
      }
    ]
  },
  {
    "number": 5526,
    "title": "ParallelFlowable  concatMapDelayError emits items out of order",
    "created_at": "2017-07-30T19:49:09Z",
    "closed_at": "2017-08-08T14:35:33Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5526",
    "body": "here is my code  with  parallel operator \r\n\r\n\r\n```\r\ndisposable.add(RxFirebase.observeChildEvent(mDatabase.child(AppConstant.MESSAGES).child(myID_otherID))\r\n                .filter(event -> event.getEventType() == RxFirebaseChildEvent.EventType.ADDED )\r\n                .parallel().runOn(Schedulers.io())\r\n                .concatMapDelayError(messageEvent-> {\r\n\r\n                  \r\n                  Message msg = messageEvent.getValue().getValue(Message.class);\r\n\r\n                    if(msg.getType().equals(AppConstant.MSG_TYPE_VIDEO))\r\n                    {\r\n\r\n                       return Flowable.zip(Flowable.just(msg),AppDatabase.getInstance(getContext()).downloadDoa().getDownloadtem(msg.getVideo_url())\r\n                            .defaultIfEmpty(new DownloadItem(null,null,null,null))\r\n                            .toFlowable().observeOn(AndroidSchedulers.mainThread()),(message, downloadItem) -> {\r\n\r\n                                message.setLocal_video_Path(downloadItem.local_path);\r\n                                message.setStatus(downloadItem.status);\r\n                                return message;\r\n\r\n                        });\r\n\r\n                    }else {\r\n                        return Flowable.just(msg);\r\n                    }\r\n\r\n                },2,true)\r\n                .sequential()\r\n                .observeOn(AndroidSchedulers.mainThread())\r\n                .subscribe(event -> {\r\n                    if(event.getLocal_video_Path() != null)\r\n                    Log.d(TAG, \"setMessagesListener: \"+event.getLocal_video_Path());\r\n\r\n                    messagesAdapter.addItem(event);\r\n                }, Throwable::printStackTrace));\r\n```\r\n\r\nit emit item out of order   but when i remove   .parallel().runOn(Schedulers.io())   and  .sequential()  and add subscribeOn(Schedular.io())  at zip operator  it emit item in order ???\r\n\r\n\r\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5526/comments",
    "author": "shakil807g",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-07-30T20:00:03Z",
        "body": "If you go parallel, the source is dispatched to parallel, independent rails that can go on their own speed. If joined together with `sequential` the output order is indeterminate."
      },
      {
        "user": "shakil807g",
        "created_at": "2017-07-30T20:03:12Z",
        "body": "but then what is difference between using flatmap with ParallelFlowable and using contactMap ( which emit items in order)"
      },
      {
        "user": "akarnokd",
        "created_at": "2017-07-30T20:05:15Z",
        "body": "`concatMap` keeps a relative order within a rail and `flatMap` doesn't as it by itself can run sources concurrently that can finish at any time."
      },
      {
        "user": "shakil807g",
        "created_at": "2017-07-30T20:13:26Z",
        "body": "ok but how can i go parallel and maintain order as well  ?? and does using contactMap without ParallelFlowable  will work in case of  1000 of message coming in from upper stream and i want to maintain order as well ??"
      },
      {
        "user": "akarnokd",
        "created_at": "2017-07-30T20:30:24Z",
        "body": "Keeping a relative order between the sequential front and sequential back is not supported by RxJava's implementation. You have to manually pack the data and a monotonic index into a tuple, parallelize the flow and then use `sorted(Comparator)` to collect them back in order. However, when using `concatMap`, you have to unpack the data and then repack it with the original index. \r\n\r\nWithout parallel, `concatMap`'s output will remain ordered, i.e., if given an input output mapping of  `a -> (1, 2)` and `b -> (3, 4)`, the operator's final output will be `1, 2, 3, 4` because `a` is processed fully before `b`. "
      },
      {
        "user": "akarnokd",
        "created_at": "2017-07-31T05:25:51Z",
        "body": "`concatMap` runs one source at a time and if you use `Schedulers.io()`, the number of threads created will be small."
      }
    ]
  },
  {
    "number": 5510,
    "title": "Why doOnComplete / doOnSubscribe / subscribe not called?",
    "created_at": "2017-07-20T21:45:45Z",
    "closed_at": "2017-07-20T21:59:44Z",
    "labels": [
      "Question",
      "Kotlin"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5510",
    "body": "Why are `doOnComplete`, `doOnSubscribe` (and also `doFinally`) not called?\r\n\r\n```kotlin\r\n//    val obs = createObservable()\r\nval obs = createCompletable()\r\n\r\n@JvmStatic fun main(args: Array<String>) {\r\n\r\n    obs.doOnSubscribe {\r\n        println(\"on subscribe!\")\r\n    }\r\n\r\n    obs.doOnComplete {\r\n        println(\"complete!\")\r\n    }\r\n\r\n    obs.doFinally{\r\n        println(\"dofinally!\")\r\n    }\r\n\r\n    obs.subscribe{\r\n        println(\"subscribe\")\r\n    }\r\n}\r\n\r\nfun createCompletable(): Completable =\r\n    Completable.create{ emitter ->\r\n        println(\"calling oncomplete\")\r\n        emitter.onComplete()\r\n    }\r\n\r\nfun createObservable(): Observable<Void> =\r\n    Observable.create<Void> { emitter ->\r\n        println(\"calling oncomplete\")\r\n        emitter.onComplete()\r\n    }\r\n```\r\n\r\nAlso, the subscribe block is called only when using `Completable`, with `Observable<Void>` this is also not called, why?\r\n\r\nIt seems that I'm missing something basic but not being able to figure out exactly what it is. \r\n\r\nI assume that the reason `subscribe` is not called when using the observable, is that this reacts only to `onNext` (?), but why isn't `doOnComplete` called either?",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5510/comments",
    "author": "ivnsch",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-07-20T21:53:44Z",
        "body": "The methods on the base reactive types return a new instance which you have to subscribe to or continue chaining:\r\n\r\n```kotlin\r\ncreateCompletable()\r\n.doOnSubscribe {\r\n        println(\"on subscribe!\")\r\n}\r\n.doOnComplete {\r\n        println(\"complete!\")\r\n}\r\n.doFinally {\r\n        println(\"dofinally!\")\r\n}\r\n.subscribe{\r\n        println(\"success\")\r\n}\r\n```\r\n"
      }
    ]
  },
  {
    "number": 5412,
    "title": "combineLatest(Iterable<Publisher<>>, Function<>) not emitting on empty iterable ",
    "created_at": "2017-06-14T10:33:48Z",
    "closed_at": "2017-06-28T08:58:59Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5412",
    "body": "I am using RxJava 2.10 and operator\r\n\r\nio.reactivex.Flowable#combineLatest(java.lang.Iterable<? extends org.reactivestreams.Publisher<? extends T>>, io.reactivex.functions.Function<? super java.lang.Object[],? extends R>)\r\n\r\n but I've seen this behavior in 1.x as well. \r\n\r\nOverload of combineLatests (and combineLatestsDelayError) that takes Iterable of Publishers is not emitting any items and 'combiner' function passed to it is not called when iterable is empty. For this operator I would expect it to scale linearly, that is:\r\n\r\n- If I pass Iterable of size 2 as a first argument I expect an Array of size 2 to be passed to combiner function\r\n- If I pass Iterable of size 1 as a first argument I expect an Array of size 1 to be passed to combiner function\r\n- If I pass Iterable of size 0 as a first argument I expect an Array of size 0 to be passed to combiner function\r\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5412/comments",
    "author": "Sroka",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-06-14T10:46:46Z",
        "body": "Wrong expectation. If you know you have zero sources, you are using the wrong operator to trigger actions. You can pick `just`, `map` it and actually ignore the input value. If you don't know you have zero sources, you still have the option to switch to a non-empty source via `switchIfEmpty`."
      },
      {
        "user": "akarnokd",
        "created_at": "2017-06-14T11:16:14Z",
        "body": "Yes, something along the line of this:\r\n\r\n> Providing an empty array/Iterable will result in an immediate completion without any calls to the provided combiner function.\r\n\r\nNote that there are several overloads to be considered in both `Flowable` and `Observable`."
      }
    ]
  },
  {
    "number": 5402,
    "title": "combineLatest with Iterable  not work ",
    "created_at": "2017-06-08T19:46:08Z",
    "closed_at": "2017-06-11T07:07:47Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5402",
    "body": "What I am currently using:\r\n```\r\nObservable.combineLatest(countsObslist,objects -> {\r\n            Log.d(\"Rx\",\"check\");\r\n            for (Object obj:objects) {\r\n                if(((CharSequence)obj).length()>0){\r\n                    return true;\r\n                }\r\n            }\r\n            return false;\r\n        }).subscribe(aBoolean -> RxView.enabled(btnOder).accept(aBoolean));\r\n```\r\ncountsObslist is List<Observable<CharSequence>> type\r\n\r\nthis funtion can not run correctly.....",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5402/comments",
    "author": "benlinx1018",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-06-08T20:06:21Z",
        "body": "What exactly are you trying to achieve and what is it that doesn't work?"
      },
      {
        "user": "benlinx1018",
        "created_at": "2017-06-09T00:25:30Z",
        "body": "I want to subscribe all edittext in  list view\r\nif anyone has value,enable button\r\n\r\nusing follow code subscribe the edittext and add to list:\r\n\r\n`  countsObslist.add(RxTextView.textChanges(viewHolder.edtTxtCount));`"
      },
      {
        "user": "akarnokd",
        "created_at": "2017-06-09T07:23:55Z",
        "body": "`combineLatest` acts only if all sources have emitted an item. You have to start the sources with some default value to get it going:\r\n\r\n```java\r\ncountsObslist.add(RxTextView.textChanges(viewHolder.edtTxtCount).startWith(\"\"));\r\n```"
      }
    ]
  },
  {
    "number": 5398,
    "title": "Execute specific (automatic) actions when the client un/subscribe to Flowable.",
    "created_at": "2017-06-06T19:07:33Z",
    "closed_at": "2017-07-05T22:22:39Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5398",
    "body": "I was trying to create a `Flowable` that is connected to a source when the client subscribes, and disconnect from the source when the client unsubscribes.\r\n\r\nI tried first using a custom `Flowable`, in this way:\r\n\r\n```\r\npublic final class SensorEventFlowable extends Flowable<RxSensorEvent> {\r\n\r\n    private final SensorManager sensorManager;\r\n    private final Sensor sensor;\r\n    private final int samplingPeriodUs;\r\n\r\n    SensorEventFlowable(SensorManager sensorManager, Sensor sensor, int samplingPeriodUs) {\r\n        this.sensorManager = sensorManager;\r\n        this.sensor = sensor;\r\n        this.samplingPeriodUs = samplingPeriodUs;\r\n    }\r\n\r\n    @Override\r\n    protected void subscribeActual(Subscriber<? super RxSensorEvent> subscriber) {\r\n        Listener listener = new Listener(sensorManager, subscriber);\r\n        subscriber.onSubscribe(listener);\r\n        sensorManager.registerListener(listener, sensor, samplingPeriodUs);\r\n    }\r\n\r\n    static final class Listener implements Subscription, SensorEventListener {\r\n        private final SensorManager sensorManager;\r\n        private final Subscriber<? super RxSensorEvent> subscriber;\r\n\r\n        Listener(SensorManager sensorManager, Subscriber<? super RxSensorEvent> subscriber) {\r\n            this.sensorManager = sensorManager;\r\n            this.subscriber = subscriber;\r\n        }\r\n\r\n        @Override\r\n        public void onSensorChanged(SensorEvent event) {\r\n            subscriber.onNext(new RxSensorEvent(event));\r\n        }\r\n\r\n        @Override\r\n        public void request(long n) { }\r\n\r\n        @Override\r\n        public void cancel() {\r\n            sensorManager.unregisterListener(this);\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n\r\nbut I was suggested to use `Flowable.create()` instead. So I tried to use it:\r\n\r\n```\r\npublic final class SensorEventFlowableFactory {\r\n\r\n    public static Flowable<RxSensorEvent> create(SensorManager sensorManager, Sensor sensor, int samplingPeriodUs) {\r\n        return Flowable.create(e -> {\r\n            Listener listener = new Listener(e);\r\n            sensorManager.registerListener(listener, sensor, samplingPeriodUs);\r\n        }, BackpressureStrategy.MISSING);\r\n    }\r\n\r\n    static final class Listener implements SensorEventListener {\r\n        private final FlowableEmitter<RxSensorEvent> emitter;\r\n\r\n        Listener(FlowableEmitter<RxSensorEvent> emitter) {\r\n            this.emitter = emitter;\r\n        }\r\n\r\n        @Override\r\n        public void onSensorChanged(SensorEvent event) {\r\n            emitter.onNext(new RxSensorEvent(event));\r\n        }\r\n    }\r\n}\r\n\r\n```\r\n\r\nI have some doubts about this code:\r\n\r\n1. In the first implementation I have `cancel` method that will execute `sensorManager.unregisterListener(this);`. How can I make this happens in the second implementation? (when the client unsubscribe from the flowable). I don't want the client to be aware about this.\r\n\r\n2. Actually, if I am not wrong, the method `sensorManager.registerListener(listener, sensor, samplingPeriodUs);` is called when the Flowable is created, and not when the client subscribe. Is that correct? If so, where do I need to place that call (registerListner) in order to be executed only if and when the client subscribes?",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5398/comments",
    "author": "Joseph82",
    "comments": [
      {
        "user": "JakeWharton",
        "created_at": "2017-06-06T19:14:09Z",
        "body": "You can set a cancelation action (callback) on the `e` param. And no, the lambda is invoked once per subscriber when they subscribe."
      }
    ]
  },
  {
    "number": 5392,
    "title": "RxJava 2.1.0 SerialDisposable#isDisposed() return false for Disposables#disposed() initial value",
    "created_at": "2017-06-05T12:35:17Z",
    "closed_at": "2017-06-05T13:37:29Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5392",
    "body": "Consider following code:\r\n```java\r\nSerialDisposable disposable = new SerialDisposable(Disposables.disposed());\r\nif (disposable.isDisposed()) {\r\n   // do somesing\r\n}\r\n```\r\nI wanted to set my initial value to be disposed and thought ```isDispossed()``` will return ```true``` for ```Disposable``` returned from ```Disposables.disposed()```, but it actually returns ```false```. Find out thats because ```SerialDisposable#isDisposed()``` just check if current ```Disposable``` equals to ```DisposableHelper#DISPOSED```, which is weird. So to fix this I have to go with this:\r\n```java\r\nSerialDisposable disposable = new SerialDisposable(DisposableHelper.DISPOSED);\r\nif (disposable.isDisposed()) {\r\n   // do somesing\r\n}\r\n```\r\nIs this intended behavior? If so, can you please explicitly indicate this in the documentation?",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5392/comments",
    "author": "bejibx",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-06-05T13:14:30Z",
        "body": "> Is this intended behavior?\r\n\r\nYes. The containers don't care of the actual state of what they contain and if they did, that would disrupt the state of the system. For example, if a Disposable in the CompositeDisposable container is disposed, should the the CompositeDisposable report itself as disposed despite all other content not being disposed? Also containers act as a deferred cancellation mechanism so having a disposes content doesn't mean the end of life since that disposed item can be replaced by a non-disposed item any time and continue.\r\n\r\n> If so, can you please explicitly indicate this in the documentation?\r\n\r\nTrying to prevent all those possible misunderstandings or mis-assumptions via documentation is infeasible, especially in a free and open-source project where you can find out and experiment with the code on your own to clear up your understanding. I firmly think this question and the original assumptions behind it are not suitable for explicit mention in the documentation."
      },
      {
        "user": "bejibx",
        "created_at": "2017-06-05T13:37:29Z",
        "body": "It seems I just misunderstood ```SerialDisposable``` concept. Sorry about that.\r\n\r\n> Trying to prevent all those possible misunderstandings or mis-assumptions via documentation is infeasible, especially in a free and open-source project where you can find out and experiment with the code on your own to clear up your understanding.\r\n\r\nNot quite agree with that. Having this little clarification in documentation would have saved me about 2 hours trying to understand why my app behave so strange. There could be another developers who may at first misunderstood how ```SerialDisposable``` behaves.\r\n\r\nAnyway, closing this issue. Again, sorry for bother you.\r\n"
      }
    ]
  },
  {
    "number": 5380,
    "title": "How to abort map() with long running operation after unsubscribe?",
    "created_at": "2017-05-30T21:33:50Z",
    "closed_at": "2017-07-05T22:23:30Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5380",
    "body": "Hi,\r\nI am writing to a file (with a while loop) in map().\r\n\r\n I want to cancel this request, so I unsubscribe from the observable, onNext does not come as expected, _however the while cycle in map() keeps going_. \r\n\r\nIs there a way I can have the while loop break upon unsubscribe with map() or do I have to flatmap and create custom observable and check for isUnsubscribe somehow?",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5380/comments",
    "author": "ursusursus",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-05-30T21:42:40Z",
        "body": "How does your loop look like? Maybe it can be turned into `range`, `fromIterable` or a generator that gets cancelled if run from within `flatMap` or `concatMap`."
      },
      {
        "user": "ursusursus",
        "created_at": "2017-05-30T21:46:29Z",
        "body": "Its a download of file, so the usual: getting the inputstream and writing it to fileoutputstream\r\n\r\n```\r\n...\r\nwhile ((bytesRead = is.read(buffer)) > 0) {\r\n   fos.write(buffer, 0, bytesRead);\r\n}\r\n... \r\nreturn filePath\r\n```"
      },
      {
        "user": "akarnokd",
        "created_at": "2017-05-30T21:59:09Z",
        "body": "Maybe the simplest way to gain access to a cancellation indicator is to have this code inside a `Observable.create()`:\r\n\r\n```java\r\nObservable.just(file)\r\n.flatMap(f ->\r\n    Observable.create(emitter -> {\r\n         // ...\r\n         while ((bytesRead = is.read(buffer)) > 0 && !emitter.isDisposed()) {\r\n            fos.write(buffer, 0, bytesRead);\r\n         }\r\n         if (!emitter.isDisposed()) {\r\n             emitter.onNext(filePath);\r\n             emitter.onComplete();\r\n         }\r\n    })\r\n)\r\n.subscribeOn(Schedulers.io())\r\n.subscribe(...);"
      },
      {
        "user": "akarnokd",
        "created_at": "2017-05-30T22:26:27Z",
        "body": "> obviously never completes\r\n\r\nCall `onComplete` on the `PublishSubject` and it will complete once all previous items have been processed."
      },
      {
        "user": "ursusursus",
        "created_at": "2017-05-30T22:29:30Z",
        "body": "Yes, but thats what I was hoping rx would do somehow by it self. \r\nSo the only way is to keep a hashmap of queued tasks manually?"
      },
      {
        "user": "akarnokd",
        "created_at": "2017-05-30T22:32:01Z",
        "body": "> when all work is done\r\n\r\nHow do you know that there is no more work being submitted to the task queue?"
      },
      {
        "user": "ursusursus",
        "created_at": "2017-05-30T22:34:46Z",
        "body": "What I would imagine is that concatMap could somehow query its backpressure buffer (im no rx expert, i just assume there is a buffer since it concats backpressured things) and emit onComplete if there is none"
      },
      {
        "user": "akarnokd",
        "created_at": "2017-05-30T22:38:37Z",
        "body": "It's unclear to me what you try to achieve. Perhaps you should ask this question on Stackoverflow, especially if you target platform is Android."
      },
      {
        "user": "ursusursus",
        "created_at": "2017-05-30T22:45:45Z",
        "body": "I dont think the platform matters. Im trying to create a stream which processes stuff and then completes. However you can add a new tasks onto it while it is running via subject (therefore stream should process this emission next (via concatmap) and only then terminate\r\n\r\nIn other words, I want to also complete the stream in subscriber.onNext if concatMap has nothing in buffer"
      }
    ]
  },
  {
    "number": 5375,
    "title": "2.0.9 possible bug with Maybe.switchIfEmpty ",
    "created_at": "2017-05-29T11:55:42Z",
    "closed_at": "2017-05-29T12:29:09Z",
    "labels": [
      "Question",
      "2.x",
      "Kotlin"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5375",
    "body": "So, not sure if it's a bug or am I not using the operator right.\r\n\r\n    Maybe.empty<Int>()\r\n            .switchIfEmpty { Maybe.just(2) }\r\n            .subscribe {\r\n                println(\"got $it\")\r\n            }\r\n\r\nBlock above completes without any results as if `Maybe` is empty. While block below completes successfully with `got 2` output.\r\n\r\n    Maybe.empty<Int>()\r\n            .switchIfEmpty(Maybe.just(2))\r\n            .subscribe {\r\n                println(\"got $it\")\r\n            }\r\n\r\nFrom documentation I expect, that both cases should work the same.\r\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5375/comments",
    "author": "mjurkus",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-05-29T12:03:10Z",
        "body": "The first case creates a lambda that does nothing, courtesy of Kotlin I guess. If written out in Java syntax:\r\n\r\n```java\r\n.switchIfEmpty(mo -> { Maybe.just(2); })\r\n```\r\n\r\nwhere you are supposed to signal on `mo` according to the `Maybe` protocol but you just create and throw away a `Maybe` instance."
      },
      {
        "user": "mjurkus",
        "created_at": "2017-05-29T12:27:41Z",
        "body": "You're right, but, lambda does something.\r\n`.switchIfEmpty { ... }` creates `MaybeSource` where `subscribe` is executed and `Maybe.just(2)` is created, but nothing happens after that.\r\nso in this case:\r\n`.switchIfEmpty { it.onSuccess(2) }` and `.switchIfEmpty(Maybe.just(2))` are the same.\r\n\r\nThanks for pointing out my mistake."
      }
    ]
  },
  {
    "number": 5311,
    "title": "Confusing about request() method in a custom Flowable",
    "created_at": "2017-04-22T12:16:44Z",
    "closed_at": "2017-05-04T09:17:41Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5311",
    "body": "Let's say I create a custom `Flowable`:\r\n\r\n```\r\npublic final class CustomFlowable extends Flowable<Integer> {\r\n\r\n    @Override\r\n    protected void subscribeActual(Subscriber subscriber) {\r\n        Listener listener = new Listener(subscriber);\r\n        subscriber.onSubscribe(listener);\r\n    }\r\n\r\n    static final class Listener implements Subscription {\r\n        private final Subscriber<Integer> subscriber;\r\n\r\n\r\n        Listener(Subscriber<Integer> subscriber) {\r\n            this.subscriber = subscriber;\r\n        }\r\n\r\n       public void onSensorChanged(SensorEvent event) {\r\n            subscriber.onNext(event));\r\n        }\r\n\r\n        @Override\r\n        public void request(long n) {\r\n            // how to deal with this method?\r\n        }\r\n\r\n        @Override\r\n        public void cancel() {\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nI have no clue about how to implement the `request(long n)` method in order to handle gracefully the backpressure. \r\nMy guess it is that when the `request()` method is called, I should send a number of items equals to `n` . But, should I stop in the meantime the normal stream of data coming from external source ( sensors)?\r\nDo I have a way for accessing the items in the queue and call a sequence of `onNext()` for those items? ",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5311/comments",
    "author": "Joseph82",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-04-22T12:20:36Z",
        "body": "There is rarely any reason to implement custom Flowables. Why do you want it? Based on the naming, you should be using `Flowable.create()` instead."
      },
      {
        "user": "Joseph82",
        "created_at": "2017-04-22T13:04:25Z",
        "body": "With `Flowable.create()` I have to define a `BackpressureStrategy` (as second parameter). \r\n\r\nWhat if I want to let the user to define a different backpressure strategy? "
      },
      {
        "user": "akarnokd",
        "created_at": "2017-04-22T13:21:50Z",
        "body": "There is the `BackpressureStrategy.MISSING` and the requirement that the consumer applies one of the `onBackpressureX` operators."
      }
    ]
  },
  {
    "number": 5292,
    "title": "NPE in defer().flatMap() chain [2.0.6]",
    "created_at": "2017-04-18T20:26:12Z",
    "closed_at": "2017-04-18T21:08:09Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5292",
    "body": "I get \"java.lang.NullPointerException: Attempt to invoke interface method 'void io.reactivex.disposables.Disposable.dispose()' on a null object reference\" running following sample code\r\n\r\n`    CompositeDisposable subs = new CompositeDisposable();\r\n\r\n    private Integer getInt() {\r\n        if(true)\r\n            throw new IllegalStateException();\r\n        return 0;\r\n    }\r\n\r\n    private void test() {\r\n        subs.add(Observable.defer(() -> observer -> {\r\n            observer.onNext(1);\r\n            observer.onComplete();\r\n        }).flatMap(o -> Observable.fromCallable(this::getInt))\r\n                .subscribe(integer -> {}, Throwable::printStackTrace)\r\n        );\r\n    }`\r\n\r\nAm I using defer in a wrong way? ",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5292/comments",
    "author": "kamehamehajim",
    "comments": [
      {
        "user": "kamehamehajim",
        "created_at": "2017-04-18T20:32:24Z",
        "body": "```\r\n04-18 23:27:23.310 12259-12259/? E/AndroidRuntime: FATAL EXCEPTION: main\r\n                                                   Process: com.example.testapp, PID: 12259\r\n                                                   java.lang.RuntimeException: Unable to resume activity {com.example.testapp/com.example.testapp.ui.MainActivity}: java.lang.NullPointerException: Attempt to invoke interface method 'void io.reactivex.disposables.Disposable.dispose()' on a null object reference\r\n                                                       at android.app.ActivityThread.performResumeActivity(ActivityThread.java:3145)\r\n                                                       at android.app.ActivityThread.handleResumeActivity(ActivityThread.java:3176)\r\n                                                       at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:2517)\r\n                                                       at android.app.ActivityThread.access$900(ActivityThread.java:158)\r\n                                                       at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1364)\r\n                                                       at android.os.Handler.dispatchMessage(Handler.java:102)\r\n                                                       at android.os.Looper.loop(Looper.java:148)\r\n                                                       at android.app.ActivityThread.main(ActivityThread.java:5515)\r\n                                                       at java.lang.reflect.Method.invoke(Native Method)\r\n                                                       at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:764)\r\n                                                       at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:654)\r\n                                                    Caused by: java.lang.NullPointerException: Attempt to invoke interface method 'void io.reactivex.disposables.Disposable.dispose()' on a null object reference\r\n                                                       at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.disposeAll(ObservableFlatMap.java:498)\r\n                                                       at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.checkTerminate(ObservableFlatMap.java:490)\r\n                                                       at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.drainLoop(ObservableFlatMap.java:331)\r\n                                                       at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.drain(ObservableFlatMap.java:323)\r\n                                                       at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.tryEmitScalar(ObservableFlatMap.java:224)\r\n                                                       at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.subscribeInner(ObservableFlatMap.java:146)\r\n                                                       at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.onNext(ObservableFlatMap.java:139)\r\n                                                       at com.example.testapp.presenters.ListSpecsPresenter.lambda$null$0(ListSpecsPresenter.java:51)\r\n                                                       at com.example.testapp.presenters.ListSpecsPresenter$$Lambda$8.subscribe(Unknown Source)\r\n                                                       at io.reactivex.internal.operators.observable.ObservableDefer.subscribeActual(ObservableDefer.java:39)\r\n                                                       at io.reactivex.Observable.subscribe(Observable.java:10700)\r\n                                                       at io.reactivex.internal.operators.observable.ObservableFlatMap.subscribeActual(ObservableFlatMap.java:55)\r\n                                                       at io.reactivex.Observable.subscribe(Observable.java:10700)\r\n                                                       at io.reactivex.Observable.subscribe(Observable.java:10686)\r\n                                                       at io.reactivex.Observable.subscribe(Observable.java:10615)\r\n                                                       at com.example.testapp.presenters.ListSpecsPresenter.test(ListSpecsPresenter.java:54)\r\n                                                       at com.example.testapp.presenters.ListSpecsPresenter.onAttachView(ListSpecsPresenter.java:34)\r\n                                                       at com.example.testapp.presenters.ListSpecsPresenter.onAttachView(ListSpecsPresenter.java:15)\r\n                                                       at com.example.testapp.ui.SpecListFragment.onResume(SpecListFragment.java:158)\r\n                                                       at android.support.v4.app.Fragment.performResume(Fragment.java:2235)\r\n                                                       at android.support.v4.app.FragmentManagerImpl.moveToState(FragmentManager.java:1346)\r\n                                                       at android.support.v4.app.FragmentManagerImpl.moveFragmentToExpectedState(FragmentManager.java:1528)\r\n                                                       at android.support.v4.app.FragmentManagerImpl.moveToState(FragmentManager.java:1595)\r\n                                                       at android.support.v4.app.FragmentManagerImpl.dispatchResume(FragmentManager.java:2898)\r\n                                                       at android.support.v4.app.FragmentController.dispatchResume(FragmentController.java:223)\r\n                                                       at android.support.v4.app.FragmentActivity.onResumeFragments(FragmentActivity.java:509)\r\n                                                       at android.support.v4.app.FragmentActivity.onPostResume(FragmentActivity.java:498)\r\n                                                       at android.support.v7.app.AppCompatActivity.onPostResume(AppCompatActivity.java:172)\r\n                                                       at android.app.Activity.performResume(Activity.java:6548)\r\n                                                       at android.app.ActivityThread.performResumeActivity(ActivityThread.java:3134)\r\n                                                       at android.app.ActivityThread.handleResumeActivity(ActivityThread.java:3176)\u00a0\r\n                                                       at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:2517)\u00a0\r\n                                                       at android.app.ActivityThread.access$900(ActivityThread.java:158)\u00a0\r\n                                                       at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1364)\u00a0\r\n                                                       at android.os.Handler.dispatchMessage(Handler.java:102)\u00a0\r\n                                                       at android.os.Looper.loop(Looper.java:148)\u00a0\r\n                                                       at android.app.ActivityThread.main(ActivityThread.java:5515)\u00a0\r\n                                                       at java.lang.reflect.Method.invoke(Native Method)\u00a0\r\n                                                       at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:764)\u00a0\r\n                                                       at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:654)\r\n```"
      },
      {
        "user": "akarnokd",
        "created_at": "2017-04-18T20:32:43Z",
        "body": "Okay, the problem is that you are not supposed to create observables via the lambda (even though they appear to be functional interfaces) because you have to call `onSubscribe` with a `Disposable`. Use `Observable.just()` or `Observable.create()` instead."
      },
      {
        "user": "kamehamehajim",
        "created_at": "2017-04-18T20:39:38Z",
        "body": "```java\r\n    private void test() {\r\n        subs.add(Observable.defer(() -> new ObservableSource<Integer>() {\r\n            @Override\r\n            public void subscribe(Observer<? super Integer> observer) {\r\n                observer.onNext(1);\r\n                observer.onComplete();\r\n            }\r\n        }).flatMap(o -> Observable.fromCallable(this::getInt))\r\n                .subscribe(integer -> {}, Throwable::printStackTrace)\r\n        );\r\n    }\r\n```\r\n\r\nFails too. Am I still doing it wrong? (sorry for badly inserted code, I don't know what's going on)"
      },
      {
        "user": "akarnokd",
        "created_at": "2017-04-18T20:51:30Z",
        "body": "```java\r\npublic void test() {\r\n    subs.add(Observable.defer(() -> Observable.create(observer -> {\r\n        observer.onNext(1);\r\n        observer.onComplete();\r\n    })).flatMap(o -> Observable.fromCallable(this::getInt))\r\n        .subscribe(integer -> {}, Throwable::printStackTrace)\r\n    );\r\n}\r\n```"
      }
    ]
  },
  {
    "number": 5272,
    "title": "1.x repeatWhen does not call onCompleted on child subscription",
    "created_at": "2017-04-07T21:37:26Z",
    "closed_at": "2017-04-07T22:08:32Z",
    "labels": [
      "Question",
      "1.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5272",
    "body": "Tested using RxJava 1.2.9.\r\n\r\nThe description of `repeatWhen` implies if the `notificationHandler` call an `onComplete` it should pass it onto the child subscription: \"If that Observable calls onComplete or onError then repeatWhen will call onCompleted or onError on the child subscription.\"\r\n\r\nHowever, this doesn't seem to happen. The `onError` seems to work, but `onCompleted` does not. This code illustrates this:\r\n\r\n```java\r\nSubscriber<Integer> subscriber = new Subscriber<Integer>() {\r\n    @Override public void onCompleted() {\r\n        System.out.println(\"completed\");\r\n    }\r\n\r\n    @Override public void onError(Throwable e) {\r\n        System.out.println(\"error\");\r\n    }\r\n\r\n    @Override public void onNext(Integer i) {\r\n\r\n    }\r\n};\r\n\r\n// Does not output anything\r\nObservable.just(1)\r\n        .repeatWhen(observable -> observable.flatMap(ignored -> Observable.empty()))\r\n        .subscribe(subscriber);\r\n\r\n// Prints \"error\" (as expected)\r\nObservable.just(1)\r\n        .repeatWhen(observable -> observable.flatMap(ignored -> Observable.error(new Exception())))\r\n        .subscribe(subscriber);\r\n```",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5272/comments",
    "author": "Chubacca",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-04-07T21:42:40Z",
        "body": "You can't complete an entire `flatMap` with an inner `empty()` source, that just counts as 'skipping' and the merged flow is kept intact. For `repeatWhen` and `retryWhen`, you need a different mechanism and make `observable` complete, for example, with `takeWhile` or `takeUntil` or some lifted operator that can turn an `onNext` into an `onCompleted`."
      }
    ]
  },
  {
    "number": 5264,
    "title": "doOnDispose / doOnLifecycle onDisposed action not being called",
    "created_at": "2017-04-04T20:31:22Z",
    "closed_at": "2017-04-11T11:51:36Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5264",
    "body": "Maybe I am doing something wrong, but this just stopped working when I updated version from 2.01 to 2.07 and 2.08.\r\n\r\nThe doOnDispose and the doOnLifecycle onDisposed action are not being called.\r\n\r\nSample code:\r\n\r\n        Observable.fromCallable(() -> \"1\")\r\n                .doOnLifecycle(\r\n                        disposable -> Log.i(TAG, \"1:doOnSubscribe\"),\r\n                        () -> Log.i(TAG, \"1:doOnDispose\")\r\n                )\r\n                .subscribe()\r\n                .dispose();\r\n\r\n        Observable.fromCallable(() -> \"2\")\r\n                .doOnSubscribe(disposable -> Log.i(TAG, \"2:doOnSubscribe\"))\r\n                .doOnDispose(() -> Log.i(TAG, \"2:doOnDispose\"))\r\n                .subscribe()\r\n                .dispose();",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5264/comments",
    "author": "fqborges",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-04-04T20:39:30Z",
        "body": "`subscribe` disconnects the upstream `Disposable` when it receives a terminal event thus you can't dispose an already completed sequence. This change was introduced in 2.0.5 via #4957."
      },
      {
        "user": "fqborges",
        "created_at": "2017-04-04T20:52:36Z",
        "body": "Is there a way to receive onDispose events after 2.0.5?\r\nI was using subscribe and dispose events for showing and hiding activity indicators/progress bar on when doing network.\r\n\r\nFor example, I used to do something like this:\r\n\r\n                doSomethingUsingNetwork()\r\n                .doOnSubscribe(d -> showProgress() )\r\n                .doOnDispose(() -> hideProgress() )\r\n                .subscribe(\r\n                        this::handleNext,\r\n                        this::handleError\r\n                )\r\n\r\nEdit: Why using onDispose? Because I missed the onFinally events when the subscription was disposed before onComplete/onError"
      },
      {
        "user": "akarnokd",
        "created_at": "2017-04-04T20:54:09Z",
        "body": "Use doFinally."
      }
    ]
  },
  {
    "number": 5254,
    "title": "RxJava 1.2.9 : calling onError without finishing / unsubscribing / onCompleted",
    "created_at": "2017-04-01T10:58:49Z",
    "closed_at": "2017-04-27T13:04:17Z",
    "labels": [
      "Question",
      "1.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5254",
    "body": "my code\uff1a\r\n\r\n```\r\nSubscription subscription = Observable.create(new Observable.OnSubscribe<ProgressModel>() {\r\n            @Override\r\n            public void call(Subscriber<? super ProgressModel> subscriber) {\r\n                try {\r\n                    OkHttpClient httpClient = new OkHttpClient();\r\n                    Call call = httpClient.newCall(new Request.Builder().url(URL).build());\r\n                    Response response = call.execute();\r\n                    if (response.code() == 200) {\r\n\r\n                        makeFileFullPath(savePath);\r\n\r\n                        File file = new File(savePath);\r\n\r\n                        FileOutputStream outputStream = null;\r\n\r\n                        InputStream inputStream = null;\r\n                        try {\r\n\r\n                            inputStream = response.body().byteStream();\r\n                            outputStream = new FileOutputStream(file);\r\n                            byte[] buff = new byte[1024 * 4];\r\n                            long downloaded = 0;\r\n                            long target = response.body().contentLength();\r\n\r\n                            ProgressModel progressModel = new ProgressModel();\r\n                            progressModel.updateData(0, target, false);\r\n                            subscriber.onNext(progressModel);\r\n                            int length = 0;\r\n                            long oldPro = 0;\r\n                            while ((length = inputStream.read(buff)) != -1) {\r\n                                outputStream.write(buff, 0, length);\r\n                                downloaded += length;\r\n\r\n                                long tmp = (downloaded *100 /target);\r\n\r\n                               if(tmp != oldPro) {\r\n                                   progressModel.updateData(downloaded, target, false);\r\n                                   subscriber.onNext(progressModel);\r\n                                   oldPro = tmp;\r\n                               }\r\n\r\n                                if(isStop.get()) {\r\n                                    break;\r\n                                }\r\n                                System.out.println(\"complemnt\"+tmp+\",\"+oldPro);\r\n                            }\r\n                            if (downloaded == target) {\r\n                                subscriber.onCompleted();\r\n                            } else {\r\n                                subscriber.onNext(new ProgressModel(-1,-1,false));\r\n                            }\r\n\r\n                        } catch (IOException ignore) {\r\n                            subscriber.onNext(new ProgressModel(-1,-1,false));\r\n\r\n                        } finally {\r\n                            if (inputStream != null) {\r\n                                inputStream.close();\r\n                            }\r\n                            if(outputStream != null) {\r\n                                outputStream.close();\r\n                            }\r\n                        }\r\n                    } else {\r\n                        subscriber.onNext(new ProgressModel(-1,-1,false));\r\n                    }\r\n                } catch (IOException e) {\r\n                    e.printStackTrace();\r\n                }\r\n\r\n            }\r\n        }).subscribeOn(Schedulers.io())\r\n                .observeOn(AndroidSchedulers.mainThread()).subscribe(new Subscriber<ProgressModel>() {\r\n            @Override\r\n            public void onNext(ProgressModel s) {\r\n                if(s == null) return;\r\n\r\n               if(!progressListener.update(s.already,s.total,s.done)) {\r\n                   System.out.println(\"calback1111111112 kaishi zhixingle\");\r\n                   isStop.set(true);\r\n               }\r\n            }\r\n\r\n            @Override\r\n            public void onCompleted() {\r\n                progressListener.update(-1,-1,true);\r\n            }\r\n\r\n            @Override\r\n            public void onError(Throwable e) {\r\n                System.out.println(\"calback1111111112 kaishi zhixingle\");\r\n            }\r\n        });\r\n        mCompositeSubscription.add(subscription);\r\n```\r\nI did not call the method   ```public void onError(Throwable e)``` ,\r\n, but it was called by itself.",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5254/comments",
    "author": "trycatchx",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-04-01T11:42:20Z",
        "body": "It would be great if you actually shared the exception you are getting."
      },
      {
        "user": "trycatchx",
        "created_at": "2017-04-12T09:56:20Z",
        "body": "@akarnokd I can not get any exception. But i add .onBackpressureBuffer()  in Observable ,  and the problem is solved.  if I add onBackpressureDrop the problem is still there . "
      },
      {
        "user": "akarnokd",
        "created_at": "2017-04-12T10:28:49Z",
        "body": "> I can not get any exception\r\n\r\nI can't tell what's wrong without knowing at least the name of the exception you are getting. Any stacktrace would be equally helpful. \r\n\r\nYou should avoid using `Observable.create(Observable.OnSubscribe)` because it has no safeguards and you are responsible for implementing the Observable protocol correctly. Use `Observable.create(Action<Emitter<T>>, Emitter.BackpressureMode)` instead."
      }
    ]
  },
  {
    "number": 5218,
    "title": "FlatMap with Completable ",
    "created_at": "2017-03-24T06:38:08Z",
    "closed_at": "2017-03-24T10:13:32Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5218",
    "body": "Basically I want to have the option of converting an Observable from flatMap to use as Completable. I am using RxJava 1.2.1 and trying to migrate to RxJava 2. Following the lead by Jake, I am removing all the Observable<Void> declarations  and replacing them with Completable. Here is the problem where I am stuck\r\n```\r\n public Observable<Void> saveReminder(final Reminder reminder)\r\n    {\r\n        return Observable.fromEmitter((Emitter<DataSnapshot> dataSnapshotAsyncEmitter) ->\r\n        {\r\n            FirebaseApi.getReminderReference().addListenerForSingleValueEvent(new ValueEventListener()\r\n            {\r\n                @Override\r\n                public void onDataChange(DataSnapshot dataSnapshot)\r\n                {\r\n                    dataSnapshotAsyncEmitter.onNext(dataSnapshot);\r\n                    dataSnapshotAsyncEmitter.onCompleted();\r\n                }\r\n\r\n                @Override\r\n                public void onCancelled(DatabaseError databaseError)\r\n                {\r\n                    if (databaseError != null)\r\n                    {\r\n                        dataSnapshotAsyncEmitter.onError(databaseError.toException());\r\n                    }\r\n                }\r\n            });\r\n        }, Emitter.BackpressureMode.LATEST).observeOn(Schedulers.io()).flatMap(reminderCardsSnapshot ->\r\n        {\r\n            try\r\n            {\r\n                return Observable.just(saveData(reminder, reminderCardsSnapshot));\r\n            } catch (Exception e)\r\n            {\r\n                return Observable.error(e);\r\n            }\r\n        });\r\n    }\r\n```\r\nI need to replace **Observable<Void>** with **Completable**. Plz help",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5218/comments",
    "author": "reactivedroid",
    "comments": [
      {
        "user": "reactivedroid",
        "created_at": "2017-03-24T08:52:13Z",
        "body": "@akarnokd I want to replace Observable<Void> to return Completable. \r\n`try\r\n            {\r\n                return Observable.just(saveData(reminder, reminderCardsSnapshot));\r\n            } catch (Exception e)\r\n            {\r\n                return Observable.error(e);\r\n            }`\r\nHow can the above method return Completable when it is wrapped inside flatMap which returns an Observable. Can you plz change the method above to return Completable?"
      },
      {
        "user": "akarnokd",
        "created_at": "2017-03-24T09:02:18Z",
        "body": "```java\r\n.flatMapCompletable(reminderCardsSnapshot ->\r\n    Completable.fromAction(() -> saveData(reminder, reminderCardsSnapshot)))\r\n```\r\n\r\nAs a general tip, I suggest you walk through each method in the classes so you can build a mental map on what's available.\r\n"
      },
      {
        "user": "reactivedroid",
        "created_at": "2017-03-24T10:08:05Z",
        "body": "Agreed. But `flatMapCompletable` is available in RxJava2...do you know any way where we can achieve the same in RxJava 1.2.1?"
      },
      {
        "user": "akarnokd",
        "created_at": "2017-03-24T10:09:18Z",
        "body": "Upgrade to 1.2.9."
      }
    ]
  },
  {
    "number": 5200,
    "title": "2.x distinctUntilChanged should not update its value reference unless it changes",
    "created_at": "2017-03-20T09:11:41Z",
    "closed_at": "2017-03-20T12:34:54Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5200",
    "body": "RxJava version: 2.0.7\r\n\r\nThe `ObservableDistinctUntilChanged` caches the last emitted value regardless if it changes or not, this can waste memory needlessly if the emits emitted are large. \r\n\r\nFor example, consider this snippet:\r\n```java\r\nObservable.concatArray(loadHeavyResourceFromCache(), observeHeavyResourceFromNetwork())\r\n    .distinctUntilChanged()\r\n    .subscribe(this::showHeavyResource);\r\n```\r\n\r\nAssuming they resources are equal and that `showHeavyResource` stores a reference to the item both the cached value and the network value are kept in memory.\r\nI feel like `ObservableDistinctUntilChanged` probably shouldn't change its internal value if it doesn't change between emissions.",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5200/comments",
    "author": "ansman",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-03-20T09:36:38Z",
        "body": "The contract is that subsequent elements are compared and thus the last seen element is always stored to be ready for comparing with the upcoming element."
      },
      {
        "user": "ansman",
        "created_at": "2017-03-20T10:28:26Z",
        "body": "But why does it need to update the value if they are equal?"
      },
      {
        "user": "akarnokd",
        "created_at": "2017-03-20T10:31:07Z",
        "body": "Equality is a funny thing when mutable objects are involved. See #4743 for example. You can use `onTerminateDetach` to get rid of any internal references after termination."
      },
      {
        "user": "ansman",
        "created_at": "2017-03-20T10:37:41Z",
        "body": "My stream is endless so there is no termination.\r\nI assume mutable objects break all sorts of things, but with the PR you linked it should make no difference if you store the first or the last of the duplicate values?"
      },
      {
        "user": "akarnokd",
        "created_at": "2017-03-20T11:19:04Z",
        "body": "Then you need a custom operator."
      },
      {
        "user": "akarnokd",
        "created_at": "2017-03-20T11:36:25Z",
        "body": "```java\r\npublic static <T> ObservableTransformer<T, T> distinctUntilChangedNoUpdate() {\r\n    return o -> Observable.defer(() -> {\r\n        AtomicReference<T> last = new AtomicReference<T>()\r\n        return o.filter(v -> {\r\n            if (last.get() == null || !last.get().equals(v)) {\r\n               last.lazySet(v);\r\n               return true;\r\n            }\r\n            return false;\r\n        }); \r\n    });\r\n}\r\n```"
      },
      {
        "user": "ansman",
        "created_at": "2017-03-20T12:11:48Z",
        "body": "I see, and there is no way that the built in operator will change?\r\n\r\nAlso, how come an `AtomicReference` is needed? Access should be serialised by upstream, right?"
      },
      {
        "user": "akarnokd",
        "created_at": "2017-03-20T12:21:28Z",
        "body": "> I see, and there is no way that the built in operator will change?\r\n\r\nEstablished operators' behavior won't change.\r\n\r\n> Also, how come an AtomicReference is needed? Access should be serialised by upstream, right?\r\n\r\nYou can't create a `T[]` and `AtomicReference` already stores items on the heap and casts it properly. This is why `lazySet` is in there."
      }
    ]
  },
  {
    "number": 5166,
    "title": "1.x Execute action after flattened observable completes",
    "created_at": "2017-03-08T20:57:05Z",
    "closed_at": "2017-03-12T14:51:27Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5166",
    "body": "Hello,\r\n\r\ni'm with a doubt that i don't know how to write a flow that use a connection from database, but closes it a soon as the query ends, and before the downstream consume it's events.\r\n\r\nI'm using vert.x rxfied jdbc client, example code:\r\n\r\n```\r\njdbcClient.getConnectionObservable()\r\n                  .flatMap(conn -> conn.queryWithParamsObservable(\"SQL QUERY ...\", new JsonArray())\r\n                                       .doOnTerminate(conn::close))\r\n                  .map(ResultSet::getRows)\r\n                  .groupBy( // ... )\r\n```\r\n\r\nHow can i make the `conn::close` be classed **BEFORE** `map`, `groupby` and the rest of chian operators execute?\r\n\r\nCurrently, it will run the `doOnTerminate` only when the `subscriber` `unsubscribes`, since i'm returning it to other code, someone could do expensive things with the results, and i don't want the connection to be held due to that.\r\n\r\nOther thing, ideally i will be using `Observable.using` to create generic repository methods, because `getConnectionObservable` isn't lazy, it fetches a connection on calling, but it's not a `hot` observable since it don't pushes the values until subscribed, so, a sampel code would look like this:\r\n\r\n```\r\nObservable.defer(jdbcClient::getConnectionObservable)\r\n                  .flatMap(conn -> Observable.using(() -> {\r\n                                                      log.debug(\"Fetching database connection\");\r\n                                                      return conn;\r\n                                                  },\r\n                                                  // handle the connection here,\r\n                                                  connToClose -> {\r\n                                                      log.debug(\"Returning connection to pool\");\r\n                                                      connToClose.close();\r\n                                                  }));\r\n```\r\n\r\nI need to close the connection after it's used, before the chain ends.",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5166/comments",
    "author": "kennedyoliveira",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-03-08T21:13:33Z",
        "body": "Hi. You were almost there: you have to apply Observable.using() on the outside:\r\n\r\n```java\r\nObservable.using(\r\n    jdbcClient::getConnectionObservable,\r\n    conn -> conn.queryWithParamsObservable(...)\r\n               .map(ResultSet::getRows)\r\n               .groupBy( ... )\r\n    conn -> conn.close(),\r\n    false\r\n)\r\n\r\n// or\r\nObservable.using(\r\n    jdbcClient::getConnectionObservable,\r\n    conn -> conn.queryWithParamsObservable(...)\r\n    conn -> conn.close(),\r\n    false\r\n)\r\n.map(ResultSet::getRows)\r\n.groupBy( ... )\r\n\r\n```"
      },
      {
        "user": "akarnokd",
        "created_at": "2017-03-08T22:19:03Z",
        "body": "In that case your `defer` approach should work.\r\n\r\n> would you mind explaining it\r\n\r\nIf true, the dispose action is called before the onComplete is sent downstream. If false, the dispose action is called after. Sometimes you have to delay the dispose action with it because computation may still depend on the resource."
      },
      {
        "user": "akarnokd",
        "created_at": "2017-03-09T08:45:14Z",
        "body": "So you need the connection closed before the downstream starts processing the single result set, right? In that case apply `.singleOrError()` before your first map and have the `using` eagerly dispose."
      },
      {
        "user": "kennedyoliveira",
        "created_at": "2017-03-09T12:34:04Z",
        "body": "Yes, that's exactly it, using single worked, now the connection is release before downstream starts to process.\r\n\r\nI was trying to understand the `OperatorSingle`, but i got a little confused with the parent child relationship on subscribing, could you explain it a little?\r\n\r\n```\r\n    @Override\r\n    public Subscriber<? super T> call(final Subscriber<? super T> child) {\r\n\r\n        final ParentSubscriber<T> parent = new ParentSubscriber<T>(child, hasDefaultValue,\r\n                defaultValue);\r\n        child.add(parent);\r\n        return parent;\r\n    }\r\n```\r\n\r\nThank you!"
      },
      {
        "user": "kennedyoliveira",
        "created_at": "2017-03-09T12:41:00Z",
        "body": "Another thing, i noticed there are 2 single operators, `toSingle` and `single`, one use `Single.create` and other use `lift`, what are the differences between them?"
      }
    ]
  },
  {
    "number": 5118,
    "title": "Why is there no share or publish/refcount for single?",
    "created_at": "2017-02-19T09:04:44Z",
    "closed_at": "2017-02-19T10:03:00Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5118",
    "body": "RX Java version 2.0.4 - Single doesn't have share/publish/refcount and therefore we can't have hot observables. Is there any reason for the same.",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5118/comments",
    "author": "bangarharshit",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-02-19T09:53:14Z",
        "body": "It has a `cache` operator and a `SingleSubject` to help with many cases when the single item should be cached. You can always convert back to `Observable` and have access to the `publish` and `refCount` operators."
      },
      {
        "user": "afaucogney",
        "created_at": "2020-11-04T09:54:21Z",
        "body": "I come back to the issue. Could we have more context about the \"why\" there is no \"share\" operator for single ? Even if we can maybe solve some requirement in another way. Is it by design decision ?"
      },
      {
        "user": "akarnokd",
        "created_at": "2020-11-04T10:02:19Z",
        "body": "We limit the API surface of the library and the need for share in other types is rare."
      }
    ]
  },
  {
    "number": 5073,
    "title": "2.x - groupBy() Parallelization Not Working like in 1.0",
    "created_at": "2017-02-05T02:24:15Z",
    "closed_at": "2017-02-05T14:16:18Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5073",
    "body": "Hi David, \r\n\r\nWhile I was writing the Packt book, I think I might have found a problem with RxJava 2.0, unless this was an intended change and I'm missing something. When I do the parallelization pattern with `groupBy()` and a modulus Integer, it works fine in RxJava 1.0. Everything parallelizes across multiple threads as expected. \r\n\r\n```java \r\n\r\nimport rx.Observable;\r\nimport rx.schedulers.Schedulers;\r\nimport java.time.LocalTime;\r\nimport java.util.concurrent.ThreadLocalRandom;\r\nimport java.util.concurrent.atomic.AtomicInteger;\r\n\r\npublic class Launcher {\r\n    public static void main(String[] args) {\r\n\r\n       int coreCount = Runtime.getRuntime().availableProcessors();\r\n       AtomicInteger assigner = new AtomicInteger(0);\r\n\r\n       Observable.range(1,10)\r\n               .groupBy(i -> assigner.incrementAndGet() % coreCount)\r\n               .flatMap(grp -> grp.observeOn(Schedulers.io())\r\n                       .map(i2 -> intenseCalculation(i2))\r\n               )\r\n               .subscribe(i -> System.out.println(\"Received \" + i + \" \"\r\n                       + LocalTime.now() + \" on thread \"\r\n                       + Thread.currentThread().getName()));\r\n\r\n       sleep(20000);\r\n    }\r\n\r\n    public static <T> T intenseCalculation(T value) {\r\n        sleep(ThreadLocalRandom.current().nextInt(3000));\r\n        return value;\r\n    }\r\n    public static void sleep(long millis) {\r\n        try {\r\n            Thread.sleep(millis);\r\n        } catch (InterruptedException e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n**OUTPUT:**\r\n\r\n```\r\nReceived 1 20:17:23.422 on thread RxIoScheduler-2\r\nReceived 3 20:17:23.840 on thread RxIoScheduler-4\r\nReceived 4 20:17:24.053 on thread RxIoScheduler-5\r\nReceived 9 20:17:24.273 on thread RxIoScheduler-2\r\nReceived 5 20:17:24.695 on thread RxIoScheduler-6\r\nReceived 8 20:17:24.950 on thread RxIoScheduler-9\r\nReceived 6 20:17:25.242 on thread RxIoScheduler-7\r\nReceived 7 20:17:25.251 on thread RxIoScheduler-8\r\nReceived 2 20:17:25.324 on thread RxIoScheduler-3\r\nReceived 10 20:17:27.532 on thread RxIoScheduler-3\r\n\r\n```\r\n\r\nBut if I switch to RxJava 2.0, this no longer parallelizes. Everything stays strictly serial and only one thread is used. \r\n\r\n```java\r\n\r\nimport io.reactivex.Observable;\r\nimport io.reactivex.schedulers.Schedulers;\r\n\r\nimport java.time.LocalTime;\r\nimport java.util.concurrent.ThreadLocalRandom;\r\nimport java.util.concurrent.atomic.AtomicInteger;\r\n\r\npublic class Launcher {\r\n    public static void main(String[] args) {\r\n\r\n       int coreCount = Runtime.getRuntime().availableProcessors();\r\n       AtomicInteger assigner = new AtomicInteger(0);\r\n\r\n       Observable.range(1,10)\r\n               .groupBy(i -> assigner.incrementAndGet() % coreCount)\r\n               .flatMap(grp -> grp.observeOn(Schedulers.io())\r\n                       .map(i2 -> intenseCalculation(i2))\r\n               )\r\n               .subscribe(i -> System.out.println(\"Received \" + i + \" \"\r\n                       + LocalTime.now() + \" on thread \"\r\n                       + Thread.currentThread().getName()));\r\n\r\n       sleep(20000);\r\n    }\r\n\r\n    public static <T> T intenseCalculation(T value) {\r\n        sleep(ThreadLocalRandom.current().nextInt(3000));\r\n        return value;\r\n    }\r\n    public static void sleep(long millis) {\r\n        try {\r\n            Thread.sleep(millis);\r\n        } catch (InterruptedException e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n**OUTPUT:**\r\n\r\n```\r\nReceived 1 20:21:03.321 on thread RxCachedThreadScheduler-1\r\nReceived 9 20:21:05.273 on thread RxCachedThreadScheduler-1\r\nReceived 2 20:21:05.559 on thread RxCachedThreadScheduler-1\r\nReceived 10 20:21:07.390 on thread RxCachedThreadScheduler-1\r\nReceived 3 20:21:10.055 on thread RxCachedThreadScheduler-1\r\nReceived 4 20:21:11.962 on thread RxCachedThreadScheduler-1\r\nReceived 5 20:21:12.850 on thread RxCachedThreadScheduler-1\r\nReceived 6 20:21:15.779 on thread RxCachedThreadScheduler-1\r\nReceived 7 20:21:17.927 on thread RxCachedThreadScheduler-1\r\nReceived 8 20:21:20.540 on thread RxCachedThreadScheduler-1\r\n```\r\n\r\nIs there something new that I'm supposed to do? Or is this a possible behavior regression? ",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5073/comments",
    "author": "thomasnield",
    "comments": [
      {
        "user": "thomasnield",
        "created_at": "2017-02-05T02:28:51Z",
        "body": "Hmmm... this makes things more interesting. Using a `subscribeOn()` instead of an `observeOn()` seems to make parallelization work. I don't know if this was intended or not. \r\n\r\n```java\r\n\r\nimport io.reactivex.Observable;\r\nimport io.reactivex.schedulers.Schedulers;\r\n\r\nimport java.time.LocalTime;\r\nimport java.util.concurrent.ThreadLocalRandom;\r\nimport java.util.concurrent.atomic.AtomicInteger;\r\n\r\npublic class Launcher {\r\n    public static void main(String[] args) {\r\n\r\n       int coreCount = Runtime.getRuntime().availableProcessors();\r\n       AtomicInteger assigner = new AtomicInteger(0);\r\n\r\n       Observable.range(1,10)\r\n               .groupBy(i -> assigner.incrementAndGet() % coreCount)\r\n               .flatMap(grp -> grp.subscribeOn(Schedulers.io())\r\n                       .map(i2 -> intenseCalculation(i2))\r\n               )\r\n               .subscribe(i -> System.out.println(\"Received \" + i + \" \"\r\n                       + LocalTime.now() + \" on thread \"\r\n                       + Thread.currentThread().getName()));\r\n\r\n       sleep(20000);\r\n    }\r\n\r\n    public static <T> T intenseCalculation(T value) {\r\n        sleep(ThreadLocalRandom.current().nextInt(3000));\r\n        return value;\r\n    }\r\n    public static void sleep(long millis) {\r\n        try {\r\n            Thread.sleep(millis);\r\n        } catch (InterruptedException e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n}\r\n```\r\n**OUTPUT:**\r\n\r\n```\r\nReceived 8 20:27:03.291 on thread RxCachedThreadScheduler-8\r\nReceived 6 20:27:03.446 on thread RxCachedThreadScheduler-6\r\nReceived 5 20:27:03.495 on thread RxCachedThreadScheduler-5\r\nReceived 4 20:27:03.681 on thread RxCachedThreadScheduler-4\r\nReceived 7 20:27:03.989 on thread RxCachedThreadScheduler-7\r\nReceived 2 20:27:04.797 on thread RxCachedThreadScheduler-2\r\nReceived 1 20:27:05.172 on thread RxCachedThreadScheduler-1\r\nReceived 9 20:27:05.327 on thread RxCachedThreadScheduler-1\r\nReceived 10 20:27:05.913 on thread RxCachedThreadScheduler-2\r\nReceived 3 20:27:05.957 on thread RxCachedThreadScheduler-3\r\n```\r\n\r\n"
      },
      {
        "user": "thomasnield",
        "created_at": "2017-02-05T14:16:18Z",
        "body": "Ah, okay. I was using 2.0.3 where apparently there was an issue. It looks like it was resolved by 2.0.5. Sorry I didn't check that first. "
      }
    ]
  },
  {
    "number": 5022,
    "title": "Doubt about the terms Upstream vs Downstream",
    "created_at": "2017-01-26T20:07:36Z",
    "closed_at": "2017-01-27T16:00:42Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5022",
    "body": "Hello everyone,\r\n\r\ni'm confused with the terms upstream and downstream, and hope someone could describe better who is who, and maybe illustrate with some examples?\r\n\r\nFor example, the documentation about zipWith in a Flowable:\r\n\r\n`The operator expects backpressure from the sources and honors backpressure from the downstream. (I.e., zipping with interval(long, TimeUnit) may result in MissingBackpressureException, use one of the onBackpressureX to handle similar, backpressure-ignoring sources.`\r\n\r\nHow do i interpret it? The downstream is the source i'm zipping (The parameter of `zipWith`) and the upstream is the `Flowable` i'm calling `zipWith`? ",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5022/comments",
    "author": "kennedyoliveira",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-01-26T20:14:40Z",
        "body": "Let me illustrate it:\r\n\r\n```\r\n           upstream                           downstream\r\nsource <------------- operator (parameters) -------------> consumer/further operators\r\n```\r\n\r\nSome operators have multiple upstreams such as `zipWith` which is an instance convenience for `zip(upstream1, upstream2, func2)`."
      },
      {
        "user": "keshavvgarg",
        "created_at": "2022-03-10T12:57:22Z",
        "body": "@akarnokd, What does the arrow symbol apply here?"
      }
    ]
  },
  {
    "number": 5012,
    "title": "2.x: Reusing observers with managing subscriptions/disposables. ",
    "created_at": "2017-01-23T08:44:40Z",
    "closed_at": "2017-01-23T09:19:41Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5012",
    "body": "I have the following problem: I have observer for network request, which can be reused in future (user swipe to refresh and etc). The problem is that I want to have ability to unsubscribe from results in any time and don't want to recreate observer each time. Code looks like that.\r\n```java\r\nprotected Observer<Collection<T>> mResponseObserver = new Observer<Collection<T>>() {\r\n        @Override\r\n        public void onSubscribe(Disposable d) {\r\n          // don't know how to store reference in another way     \r\n          mDisposable = d;\r\n        }\r\n     .....................\r\n    };\r\n..........................\r\n// can execute periodically\r\nvoid onRefresh() {\r\n    observableA.subscribe(mResponseObserver);\r\n}\r\n\r\n.........................\r\nvoid dispose() {\r\n    mDisposable.dispose();\r\n}\r\n```\r\nI try variant replacing ``` Observer``` with ```DisposableObserver``` and save disposable using ```subscribeWith()``` method, but it throw ```java.lang.IllegalStateException: Disposable already set!``` which is logical.\r\n\r\nMaybe I'm wrong and I need to create new observer each time ? What is the best practice?",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5012/comments",
    "author": "youngam",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-01-23T08:53:44Z",
        "body": "The best practice is to create an `Observer` every time you want to subscribe."
      },
      {
        "user": "akarnokd",
        "created_at": "2017-01-23T09:11:49Z",
        "body": "Most developers don't know enough about concurrency, the java memory model, the flow and lifecycle model of RxJava to ensure such optimizations actually work. I don't think you have thousands or millions of subscriptions that you can't afford allocating a few dozen new `Observer`s when needed. "
      }
    ]
  },
  {
    "number": 5010,
    "title": "How can `.buffer(2,1)` ever emit a list with only one item?",
    "created_at": "2017-01-20T21:07:28Z",
    "closed_at": "2017-01-20T21:19:47Z",
    "labels": [
      "Question",
      "1.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5010",
    "body": "Using RxJava version 1.2.5. (kotlin code below) \r\n\r\n```\r\nObservable.just(\"1\")\r\n                .startWith(emptyList<String>())\r\n                .buffer(2, 1)\r\n                .map { Pair(it[0], it[1]) } //throws java.lang.IndexOutOfBoundsException: Index: 1, Size: 1\r\n                .subscribe()\r\n\r\n```\r\n\r\nHow can `.buffer(2,1)` ever emit a list with only one item?\r\n\r\n\r\nOr, if you prefer java\r\n\r\n```\r\npublic class BufferTest {\r\n\r\n    @Test\r\n    public void name() throws Exception {\r\n        Observable.just(\"1\")\r\n                .startWith(new ArrayList<String>(0))\r\n                .buffer(2, 1)\r\n                .map(\r\n                        new Func1<List<String>, Pair>() {\r\n                            @Override\r\n                            public Pair call(List<String> list) {\r\n                                return new Pair(list.get(0), list.get(1)); //throws java.lang.IndexOutOfBoundsException: Index: 1, Size: 1\r\n                            }\r\n                        })\r\n                .subscribe();\r\n    }\r\n\r\n    private static class Pair {\r\n        final String first;\r\n        final String second;\r\n\r\n        Pair(String first, String second) {\r\n            this.first = first;\r\n            this.second = second;\r\n        }\r\n    }\r\n}\r\n\r\n```",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5010/comments",
    "author": "ZakTaccardi",
    "comments": [
      {
        "user": "ZakTaccardi",
        "created_at": "2017-01-20T21:19:47Z",
        "body": "My bad - when the observable completes, the remaining buffer is emitted, hence the exception"
      },
      {
        "user": "akarnokd",
        "created_at": "2017-01-20T21:21:12Z",
        "body": "It's quite easy: if there is a non-empty buffer when `onComplete` arrives, emit it. Operators try to avoid data loss so you can get partial buffers. If you don't want those, filter them out with `filter`."
      }
    ]
  },
  {
    "number": 4995,
    "title": "Share does not work with just() and from()",
    "created_at": "2017-01-14T22:46:02Z",
    "closed_at": "2017-01-19T14:00:58Z",
    "labels": [
      "Question",
      "1.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4995",
    "body": "Tested with RxJava <= 1.2.5:\r\n\r\nCreating observable with _interval()_:\r\n```java\r\nObservable<Long> interval = Observable.interval(100, TimeUnit.MILLISECONDS);\r\nObservable<Long> source = interval\r\n        .take(2)\r\n        .doOnNext(aLong -> System.out.println(\"Side effect\"));\r\nObservable<Long> published = source.share();\r\nObservable<Zip> zip = Observable.zip(\r\n        published.buffer(2),\r\n        OperatorMinMax.max(published),\r\n        Zip::new\r\n);\r\nzip.toBlocking().single();\r\n```\r\n\r\nresults in (which is **correct** because of the _share()_ operator):\r\n```\r\nSide effect\r\nSide effect\r\n```\r\n\r\nHowever, when creating Observable with _just()_:\r\n```java\r\nObservable<Long> interval = Observable.just(0L, 1L);\r\nObservable<Long> source = interval\r\n        .take(2)\r\n        .doOnNext(aLong -> System.out.println(\"Side effect\"));\r\nObservable<Long> published = source.share();\r\nObservable<Zip> zip = Observable.zip(\r\n        published.buffer(2),\r\n        OperatorMinMax.max(published),\r\n        Zip::new\r\n);\r\nzip.toBlocking().single();\r\n```\r\nthe result is:\r\n```\r\nSide effect\r\nSide effect\r\nSide effect\r\nSide effect\r\n```\r\nwhich is in my opinion **incorrect** as I used the _share()_ operator. The same applies for operators _from()_, _range()_...\r\nIs this a bug, or am I missing something important here?",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4995/comments",
    "author": "xdom",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-01-14T22:56:35Z",
        "body": "With `share()`, if the upstream terminates, the internal subscriber count is set to zero. If a new subscriber comes in, that makes `share()` resubscribe to the upstream. \r\n\r\nIn your second case, `just` completes within the buffer size of `zip` and now you have two subscriptions."
      },
      {
        "user": "akarnokd",
        "created_at": "2017-01-14T23:12:52Z",
        "body": "Use `publish()` and when everything is set up, including the end consumer(s), call `connect()` on the `ConnectableObservable`."
      },
      {
        "user": "xdom",
        "created_at": "2017-01-14T23:18:09Z",
        "body": "Alright, and what if (in my real scenario) I return the zipped observable from a method and thus when subscribing to it, I don't have any access to the `ConnectableObservable`? Am I lost then?"
      },
      {
        "user": "JakeWharton",
        "created_at": "2017-01-14T23:28:30Z",
        "body": "You can use the overload of `publish()` that takes a function.\r\n```java\r\nObservable<Zip> zip = source.publish(published -> {\r\n    return Observable.zip(\r\n          published.buffer(2),\r\n          OperatorMinMax.max(published),\r\n          Zip::new);\r\n});\r\n```"
      }
    ]
  },
  {
    "number": 4960,
    "title": "1.x Documentation issue for .doOnUnsubscribe()",
    "created_at": "2017-01-05T20:32:20Z",
    "closed_at": "2017-01-05T20:39:32Z",
    "labels": [
      "Question",
      "1.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4960",
    "body": "Looking at the javadoc for .doOnUnsubscribe, there's a caveat:\r\n\r\n```\r\nNote that terminal events trigger the action unless the Observable is subscribed to via unsafeSubscribe().\r\n```\r\n\r\nRunning a quick test, this seems wrong:\r\n\r\n```\r\nSubscription subscription = Observable.never()\r\n                .doOnSubscribe(() -> Timber.e(\"Sub\"))\r\n                .doOnUnsubscribe(() -> Timber.e(\"Unsub\"))\r\n                .unsafeSubscribe(new Subscriber<Object>() {\r\n                    @Override\r\n                    public void onCompleted() {}\r\n\r\n                    @Override\r\n                    public void onError(Throwable e) {}\r\n\r\n                    @Override\r\n                    public void onNext(Object o) {}\r\n                });\r\n        subscription.unsubscribe();\r\n```\r\n\r\nprints out:\r\n\r\n```\r\nSub\r\nUnsub\r\n```",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4960/comments",
    "author": "danh32",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-01-05T20:35:09Z",
        "body": "`terminal events == onError | onCompleted`"
      }
    ]
  },
  {
    "number": 4913,
    "title": "2.x: Misbehavior of BehavoirProcessor when converted to Single",
    "created_at": "2016-12-09T11:25:11Z",
    "closed_at": "2016-12-09T14:04:45Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4913",
    "body": "io.reactivex.rxjava2:rxandroid:2.0.1\r\n\r\nI believe `BehaviorProcessor` does not work correctly with `Single` observable. I am using `BehaviorProcessor` similarly to how I used `BehaviorSubject` with RxJava1, but this time with a `Single` observable.\r\n\r\nEvent producer\r\n```java\r\nBehaviorProcessor<Event> bp = BehaviorProcessor.create();\r\n\r\npublic Single<Event> getEvent() {\r\n    return bp.singleOrError();\r\n}\r\n\r\nvoid onEventReceived(Event event) {\r\n    bp.onEvent(event);\r\n    bp.onComplete();\r\n}\r\n```\r\n\r\nEvent observer\r\n```java\r\n\r\nproducer.getEvent().subscribeWith(\r\n    new DisposableSingleObserver<Event>() {\r\n        @Override public void onSuccess(Event value) {\r\n            Log.e(TAG, \"success\");\r\n        }\r\n\r\n        @Override public void onError(Throwable e) {\r\n            Log.e(TAG, \"error\");\r\n        }\r\n    }\r\n);\r\n```\r\n\r\nObserved behavior:\r\n1. If observers get subscribed **before** `onEventReceived()` is called, then all observers receive their `onSuccess()` callback, which is OK.\r\n2. If observers get subscribe **after** `onEventReceived()` (meaning after `onEvent()` and `onComplete()` are emitted), then `Single` receives `java.util.NoSuchElementException`. I believe this is NOT OK. Expected behavoir would be receiveing `onSuccess()` with the last value. This is what `BehaviorProcessor` should do for downstream observers, isn't it? Otherwise it appears to be useless for `Single` observers.\r\n\r\nThanks!",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4913/comments",
    "author": "sergejsha",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-12-09T13:05:20Z",
        "body": "This is the correct behavior for `BehaviorProcessor`. It doesn't retain the last value if it gets terminated. This has been so since day 1 with `BehaviorSubject` as well. Use `ReplayProcessor.createWithSize(1)` instead."
      },
      {
        "user": "sergejsha",
        "created_at": "2016-12-09T13:33:45Z",
        "body": "This is true what you say. But if I try to keep it not terminated by not calling `onComplete()`, the `Single` doesn't receive `onSuccess()`, which is also ok. Just out of curiosity, what would be the main use case for `BehavoirProcesser` with `Single` then, if later subscriptions always receive `onError()` instead of the most recent item it has observed?"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-12-09T14:00:08Z",
        "body": "I don't understand what you try to achieve here. If you want a `Single` of the latest of the `BehaviorProcessor`, use `take(1).singleOrError()` so a `SingleObserver` will receive at most one success value and disconnect from the `BehaviorProcessor`."
      }
    ]
  },
  {
    "number": 4906,
    "title": "The order of `doOnSubscribe` changed in RxJava 2 without documentation",
    "created_at": "2016-12-06T07:10:35Z",
    "closed_at": "2016-12-06T10:04:30Z",
    "labels": [
      "Question",
      "1.x",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4906",
    "body": "We noticed one of our tests failing because or an ordering issue with `doOnSubscribe`. In RxJava 1 downstream `doOnSubcribe` would be called before upstream but it's the reverse in RxJava 2.\r\n\r\nHere's a code snippet that showcases the problem:\r\n```java\r\nObservable.empty()\r\n\t.doOnSubscribe(() -> System.out.println(\"RX1 upstream\"))\r\n\t.doOnSubscribe(() -> System.out.println(\"RX1 downstream\"))\r\n\t.subscribe();\r\n```\r\nThis will produce the following log statements:\r\n```\r\nRX1 downstream\r\nRX1 upstream\r\n```\r\nwhile the following snippet:\r\n```java\r\nio.reactivex.Observable.empty()\r\n\t.doOnSubscribe(d -> System.out.println(\"RX2 upstream\"))\r\n\t.doOnSubscribe(d -> System.out.println(\"RX2 downstream\"))\r\n\t.subscribe();\r\n```\r\nproduces the following statement:\r\n```\r\nRX2 upstream\r\nRX2 downstream\r\n```\r\n\r\nIs this an intended change?",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4906/comments",
    "author": "ansman",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-12-06T09:06:46Z",
        "body": "Yes. The 1.x operator is lift based which executes the downstream operations first. In 2.x, the onSubscribe happens starting from upstream travelling downstream like the onNext events. Why do you have order-dependent doOnSubscribe?"
      },
      {
        "user": "ansman",
        "created_at": "2016-12-06T09:46:22Z",
        "body": "We had a test that tested a retry transformer and we needed to simulate getting different errors on different tries. Here's the code that caused the issue:\r\n```java\r\nAtomicInteger subscribeCount = new AtomicInteger(0);\r\nIOException e = new IOException();\r\nRuntimeException re = new RuntimeException();\r\n\r\nObservable\r\n        .defer(() -> subscribeCount.get() >= 2 ?\r\n                Observable.error(re) :\r\n                Observable.concat(Observable.just(\"1\"), Observable.just(\"2\"), Observable.error(e)))\r\n        .doOnSubscribe(subscribeCount::incrementAndGet)\r\n        .compose(retry())\r\n        .subscribe(subscriber);\r\n```"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-12-06T09:59:32Z",
        "body": "Relplace `get()` with `incrementAndGet()` and drop the `doOnSubscribe()` call."
      }
    ]
  },
  {
    "number": 4888,
    "title": "Should a disposed ConnectableObservable replay() still emit?",
    "created_at": "2016-11-28T10:00:15Z",
    "closed_at": "2016-11-28T12:05:55Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4888",
    "body": "I have this test which passes, but I initially expected it (in particular the 2nd `test`) to fail:\r\n\r\n```java\r\n@Test\r\npublic void connectableReplay() throws Exception {\r\n    ConnectableObservable<Integer> just = Observable.just(1).replay();\r\n\r\n    just.test().assertNoValues();\r\n\r\n    Disposable connect = just.connect();\r\n    connect.dispose();\r\n\r\n    just.test()\r\n            .assertValue(1)\r\n            .assertComplete();\r\n}\r\n```\r\n\r\nSo even after a `replay()` ConnectableObservable was disposed it can still emit it's replayed values? Is that the desired behaviour?",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4888/comments",
    "author": "Mauin",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-11-28T10:05:48Z",
        "body": "Yes. `connect.dispose` disconnects from the upstream in case it hasn't yet terminated but consumers still get the events received till then."
      }
    ]
  },
  {
    "number": 4869,
    "title": "RxJava 1.2.1  retryWhen not working on eclipse\uff0cbut working on Android Studio",
    "created_at": "2016-11-20T13:17:37Z",
    "closed_at": "2016-11-26T11:57:31Z",
    "labels": [
      "Question",
      "1.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4869",
    "body": "The code is as follows:\r\n\r\n```java\r\nstatic int retryCount = 0;\r\n\tprivate static void test5(){\r\n\t\t\r\n\t\tfinal int maxRetries = 3;\r\n\r\n        Observable.create(new Observable.OnSubscribe<Integer>() {\r\n            @Override\r\n            public void call(Subscriber<? super Integer> subscriber) {\r\n                subscriber.onError(new RuntimeException(\"always fails\"));\r\n            }\r\n        })\r\n        .subscribeOn(Schedulers.immediate())\r\n         .retryWhen(new Func1<Observable<? extends Throwable>, Observable<?>>() {\r\n\r\n                    @Override\r\n                    public Observable<?> call(Observable<? extends Throwable> observable) {\r\n                        return observable.flatMap(new Func1<Throwable, Observable<?>>() {\r\n                            @Override\r\n                            public Observable<?> call(Throwable throwable) {\r\n                                if (++retryCount <= maxRetries) {\r\n                                    // When this Observable calls onNext, the original Observable will be retried (i.e. re-subscribed).\r\n                                    System.out.println(\"get error, it will try after \" + 1000 + \" millisecond, retry count \" + retryCount);\r\n                                    return Observable.timer(1000, TimeUnit.MILLISECONDS);\r\n                                }\r\n                                return Observable.error(throwable);\r\n                            }\r\n                        });\r\n                    }\r\n\r\n\r\n                })\r\n                .subscribe(new Subscriber<Integer>() {\r\n\r\n                    @Override\r\n                    public void onCompleted() {\r\n                        System.out.println(\"onCompleted\");\r\n                    }\r\n\r\n                    @Override\r\n                    public void onNext(Integer value) {\r\n                        System.out.println(\"onSuccess value = \" + value);\r\n                    }\r\n\r\n                    @Override\r\n                    public void onError(Throwable error) {\r\n                        System.out.println(\"onError error = \" + error);\r\n                    }\r\n                });\r\n\t\t\r\n\t}\r\n```\r\n\r\n\r\nThank you\uff01",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4869/comments",
    "author": "jdsjlzx",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-11-20T15:01:33Z",
        "body": "You mean it doesn't compile? It works for me in Eclipse 4.6.1 and when I add `Thread.sleep(10000)`.\n"
      },
      {
        "user": "jdsjlzx",
        "created_at": "2016-11-21T01:53:34Z",
        "body": "it can compile,but the code execution results are different"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-11-21T07:11:51Z",
        "body": "What results do you get in each case?"
      },
      {
        "user": "jdsjlzx",
        "created_at": "2016-11-23T16:52:47Z",
        "body": "the code execution on eclipse\uff08Only one time\uff09\uff1a\r\nget error, it will try after 1000 millisecond, retry count 1\r\n\r\nthe code execution Android Studio\uff1a\r\nget error, it will try after 1000 millisecond, retry count 1\r\nget error, it will try after 1000 millisecond, retry count 2\r\nget error, it will try after 1000 millisecond, retry count 3\r\nonError error = java.lang.RuntimeException: always fails\r\n\r\nI don't know what reason is this\uff0cwaiting for your reply\uff0cthank you\uff01"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-11-23T16:58:12Z",
        "body": "Try this:\r\n\r\n```java\r\n```java\r\nstatic int retryCount = 0;\r\nprivate static void test5() throws Exception {\r\n\r\n    final int maxRetries = 3;\r\n    Observable.create(new Observable.OnSubscribe<Integer>() {\r\n            @Override\r\n            public void call(Subscriber<? super Integer> subscriber) {\r\n                subscriber.onError(new RuntimeException(\"always fails\"));\r\n            }\r\n        })\r\n        .subscribeOn(Schedulers.immediate())\r\n         .retryWhen(new Func1<Observable<? extends Throwable>, Observable<?>>() {\r\n\r\n                    @Override\r\n                    public Observable<?> call(Observable<? extends Throwable> observable) {\r\n                        return observable.flatMap(new Func1<Throwable, Observable<?>>() {\r\n                            @Override\r\n                            public Observable<?> call(Throwable throwable) {\r\n                                if (++retryCount <= maxRetries) {\r\n                                    // When this Observable calls onNext, the original Observable will be retried (i.e. re-subscribed).\r\n                                    System.out.println(\"get error, it will try after \" + 1000 + \" millisecond, retry count \" + retryCount);\r\n                                    return Observable.timer(1000, TimeUnit.MILLISECONDS);\r\n                                }\r\n                                return Observable.error(throwable);\r\n                            }\r\n                        });\r\n                    }\r\n\r\n\r\n                })\r\n        .subscribe(new Subscriber<Integer>() {\r\n\r\n            @Override\r\n            public void onCompleted() {\r\n                System.out.println(\"onCompleted\");\r\n            }\r\n\r\n            @Override\r\n            public void onNext(Integer value) {\r\n                System.out.println(\"onSuccess value = \" + value);\r\n            }\r\n\r\n            @Override\r\n            public void onError(Throwable error) {\r\n                System.out.println(\"onError error = \" + error);\r\n            }\r\n        });\r\n\r\n\t\tThread.sleep(10000);  // <--------------------------------------------- let it wait\r\n\t}\r\n```"
      },
      {
        "user": "flyfire",
        "created_at": "2018-03-13T10:02:29Z",
        "body": "Why does it work?Can somebody explain?"
      },
      {
        "user": "akarnokd",
        "created_at": "2018-03-13T10:05:33Z",
        "body": "@flyfire You have to have the Java main thread sleep a bit, otherwise it quits before the retry can take effect. Standard RxJava schedulers run on daemon threads that are stopped when all other threads, such as the main thread, end."
      }
    ]
  },
  {
    "number": 4862,
    "title": "2.x: RxJavaPlugins.reset() doesn't reset after Schedulers initializaion",
    "created_at": "2016-11-16T17:16:36Z",
    "closed_at": "2016-12-15T12:09:10Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4862",
    "body": "I have a query about whether or not the current behavior of`RxJavaPlugins`'s \r\n`setInit<XYZ>SchedulerHandler` hooks are behaving as intended. It seems that it is not possible to revert to the \"out of the box\" `Schedulers` state.\r\n\r\nTake the example of `Scheduler.computation()`. If I set a new default `Scheduler` using `setInitComputationSchedulerHandler` (which, to be applied successfully, must be done prior to accessing the `Schedulers` class), then once set this default cannot be changed; even using `RxJavaPlugins.reset()`.\r\n\r\nTo elaborate, when I override the default `Scheduler` instance, using the aforementioned hook, then the overriding `Function<Callable<Scheduler>>` is assigned to the non-final static field: `RxJavaPlugins.onInitComputationHandler`.\r\n\r\nAs per:\r\n\r\n```java\r\n    public static void setInitComputationSchedulerHandler(Function<Callable<Scheduler>, Scheduler> handler) {\r\n        if (lockdown) {\r\n            throw new IllegalStateException(\"Plugins can't be changed anymore\");\r\n        }\r\n        onInitComputationHandler = handler;\r\n    }\r\n```   \r\n\r\nNow in `Schedulers.java`, the static final field `COMPUTATION` is statically initialized via the result of `RxJavaPlugins.initComputationScheduler()` using the eventual default value of `new ComputationScheduler()` when no override is set. \r\n\r\nIf an override was set via `setInitComputationSchedulerHandler`,then that override is applied, but that result is final, as can be seen below -\r\n\r\n```java\r\nstatic final Scheduler COMPUTATION;\r\n\r\nstatic final class ComputationHolder {\r\n    static final Scheduler DEFAULT = new ComputationScheduler();\r\n}\r\n\r\nstatic {\r\n    COMPUTATION = RxJavaPlugins.initComputationScheduler(new Callable<Scheduler>() {\r\n                @Override\r\n                public Scheduler call() throws Exception {\r\n                    return ComputationHolder.DEFAULT;\r\n                }\r\n            });\r\n    }\r\n``` \r\n\r\nThis means that `COMPUTATION` is permanently assigned to be the override value. When a class accessess `Schedulers.computation()`, they will get the `COMPUTATION` instance by default.\r\n\r\nSee:\r\n\r\n```java\r\n    public static Scheduler computation() {\r\n        return RxJavaPlugins.onComputationScheduler(COMPUTATION);\r\n    }\r\n```\r\n\r\nIf they again call `setInitComputationSchedulerHandler` or `reset()` to clear the `RxJavaPlugins.onInitComputationHandler` field, then regardless, the original `COMPUTATION` value remains.\r\n\r\nNow they *can* call `RxJavaPlugins.setComputationSchedulerHandler()` to change the `Scheduler` that is eventually returned, but my opinion at least, is that it should be possible to revert back to the \"out of the box\" `Schedulers` state. Also being subject to the vagueries of static initialization order timing has the potential to cause debugging headaches for those overriding `Schedulers`.\r\n\r\nWithout suggesting an implementation, I would at least suggest that `RxJavaPlugins.reset()` should at least allow the caller the potential to reassign the default `Scheduler` instance.\r\n\r\nWhat thoughts do you have on the current behavior and my suggested change? ",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4862/comments",
    "author": "peter-tackage",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-11-16T17:26:25Z",
        "body": "The current setup is introduced to prevent instantiating the default schedulers in environments where the default ExecutorService-based schedulers are not allowed. Instead of overriding the initial value, override the individual `setComputationSchedulerHandler` to return the scheduler of your chosing dynamically.\n"
      },
      {
        "user": "peter-tackage",
        "created_at": "2016-11-16T18:31:03Z",
        "body": "There are similar use cases in the Android world (which has the same API); we don't want the equivalent default Scheduler to be initialized in `AndroidSchedulers.mainThread()` when executing on the desktop JVM. So I'm comfortable with the motivation for having an alternative default Scheduler. \n\nHowever; is the intent behind the current implementation that once set (even implicitly, by accessing the `Schedulers` class), one should expect that it cannot be changed? `RxJavaPlugins.reset()` gives the impression that can reset to the out-of-the-box state (by calling `setInitComputationSchedulerHandler(null);`, but currently that would only be effective when done _before_ the `Schedulers` class is accessed.\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-11-16T18:36:29Z",
        "body": "You set the baseline Schedulers once then dynamically override them. Because the dynamic override takes precedence, there is no loss of functionality.\n"
      }
    ]
  },
  {
    "number": 4861,
    "title": "SerializedSubscriber should propagate onStart()",
    "created_at": "2016-11-16T16:00:28Z",
    "closed_at": "2016-12-15T12:07:26Z",
    "labels": [
      "Question",
      "1.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4861",
    "body": "`rx.observers.SerializedSubscriber` should also propagate `onStart()` event to the original subscriber, similar to other `on*()` methods",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4861/comments",
    "author": "adamdyga",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-11-16T16:40:32Z",
        "body": "Do you have an use case for this? Currently it doesn't do that because that usually leads to double calls to `onStart` in some operators.\n"
      },
      {
        "user": "adamdyga",
        "created_at": "2016-11-28T14:24:28Z",
        "body": "In my case `onStart()` is used to initiate backpressure (reactive pull):\r\n\r\n```\r\npublic class MySubscriber extends Subscriber<...>\r\n{\r\n\t@Override\r\n\tpublic void onStart()\r\n\t{\r\n\t\trequest(1);\r\n\t}\r\n        ....\r\n}\r\n```\r\n\r\nWhen the subscriber is wrapped with `SerializedSubscriber` it doesn't work. Yes, it can be easily fixed  by subclassing `SerializedSubscriber` and propagating `onStart()`, but this just doesn't feel right. If all `on*()` events are propagated, why not `onStart()` too? I understand that it was omitted due to some operators calling it multiple times, but can it also happen to my (or any other) subscriber if I don't wrap it with `SerializedSubscriber`? If so, shouldn't the operators be fixed, instead of mitigating the problem in subscriber(s)?"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-11-28T14:29:23Z",
        "body": "It has been fixed; it is called RxJava 2. Call `request(1)` in the constructor of your subscriber."
      },
      {
        "user": "akarnokd",
        "created_at": "2016-11-28T14:38:49Z",
        "body": "Such request calls get accumulated and forwarded to the upstream when the time is right."
      }
    ]
  },
  {
    "number": 4821,
    "title": "Question: Observable no longer throwing MissingBackpressureException",
    "created_at": "2016-11-08T09:57:47Z",
    "closed_at": "2016-11-08T10:28:24Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4821",
    "body": "Hello, \r\nI understand as with RxJava2.x that Observable is not backpressure aware by default.\r\nI had a piece of code that I was expecting to throw MissingBackpressureException. It did with RxJava1.x\r\n\r\n```\r\nObservable.create(subscriber -> {\r\n            log.info(\"Started emitting\");\r\n\r\n            for (int i = 0; i < 200; i++) {\r\n                log.info(\"Emitting {}\", i);\r\n                subscriber.onNext(i);\r\n            }\r\n\r\n            subscriber.onComplete();\r\n        });\r\nobservable = observable\r\n                .observeOn(Schedulers.io());\r\n        CountDownLatch latch = new CountDownLatch(1);\r\n        observable.subscribe(slowObserver(latch));\r\n        Helpers.wait(latch);\r\n\r\n\r\n    private <T> Observer<T> slowObserver(CountDownLatch latch) {\r\n        return new Observer<T>() {\r\n            @Override\r\n            public void onSubscribe(Disposable d) {\r\n            }\r\n\r\n            @Override\r\n            public void onNext(Object value) {\r\n                log.info(\"Got {}\", value);\r\n                Helpers.sleepMillis(100);\r\n            }\r\n\r\n            @Override\r\n            public void onError(Throwable err) {\r\n                log.error(\"Subscriber got error\", err);\r\n                latch.countDown();\r\n            }\r\n\r\n            @Override\r\n            public void onComplete() {\r\n                log.info(\"Completed\");\r\n                latch.countDown();\r\n            }\r\n        };\r\n    }\r\n```\r\nI see that the buffer size should be Integer.getInteger(\"rx2.buffer-size\", 128) - and it's 128 in my case, however no exception is thrown.",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4821/comments",
    "author": "balamaci",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-11-08T10:15:15Z",
        "body": "`Observable` operators use unbounded buffers which use linked arrays, of lenght 128 each section by default, to reduce allocation pressure. They are not there to limit the element count travelling through.\n"
      }
    ]
  },
  {
    "number": 4814,
    "title": "java.io.InterruptedIOException: thread interrupted ",
    "created_at": "2016-11-06T14:15:01Z",
    "closed_at": "2016-11-12T18:09:14Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4814",
    "body": "when i use retrofit and rxjava download file with progress.\r\n``` java\r\n11-03 22:52:35.048 18649-18699/better.hello W/System.err: java.io.InterruptedIOException: thread interrupted\r\n11-03 22:52:35.049 18649-18699/better.hello W/System.err:     at okio.Timeout.throwIfReached(Timeout.java:145)\r\n11-03 22:52:35.049 18649-18699/better.hello W/System.err:     at okio.Okio$2.read(Okio.java:137)\r\n11-03 22:52:35.049 18649-18699/better.hello W/System.err:     at okio.AsyncTimeout$2.read(AsyncTimeout.java:238)\r\n11-03 22:52:35.049 18649-18699/better.hello W/System.err:     at okio.RealBufferedSource.read(RealBufferedSource.java:45)\r\n11-03 22:52:35.049 18649-18699/better.hello W/System.err:     at okhttp3.internal.http.Http1xStream$FixedLengthSource.read(Http1xStream.java:381)\r\n11-03 22:52:35.049 18649-18699/better.hello W/System.err:     at okio.RealBufferedSource.read(RealBufferedSource.java:45)\r\n11-03 22:52:35.049 18649-18699/better.hello W/System.err:     at okio.ForwardingSource.read(ForwardingSource.java:35)\r\n11-03 22:52:35.049 18649-18699/better.hello W/System.err:     at retrofit2.OkHttpCall$ExceptionCatchingRequestBody$1.read(OkHttpCall.java:279)\r\n11-03 22:52:35.049 18649-18699/better.hello W/System.err:     at okio.RealBufferedSource$1.read(RealBufferedSource.java:386)\r\n11-03 22:52:35.049 18649-18699/better.hello W/System.err:     at java.io.InputStream.read(InputStream.java:162)\r\n11-03 22:52:35.049 18649-18699/better.hello W/System.err:     at better.hello.util.FileUtils.writeFile(FileUtils.java:120)\r\n11-03 22:52:35.049 18649-18699/better.hello W/System.err:     at better.hello.common.UiHelper$1$1.call(UiHelper.java:29)\r\n11-03 22:52:35.049 18649-18699/better.hello W/System.err:     at better.hello.common.UiHelper$1$1.call(UiHelper.java:26)\r\n11-03 22:52:35.049 18649-18699/better.hello W/System.err:     at rx.Observable.unsafeSubscribe(Observable.java:10200)\r\n11-03 22:52:35.049 18649-18699/better.hello W/System.err:     at rx.internal.operators.OperatorMerge$MergeSubscriber.onNext(OperatorMerge.java:248)\r\n11-03 22:52:35.049 18649-18699/better.hello W/System.err:     at rx.internal.operators.OperatorMerge$MergeSubscriber.onNext(OperatorMerge.java:148)\r\n11-03 22:52:35.049 18649-18699/better.hello W/System.err:     at rx.internal.operators.OnSubscribeMap$MapSubscriber.onNext(OnSubscribeMap.java:77)\r\n11-03 22:52:35.049 18649-18699/better.hello W/System.err:     at rx.internal.operators.OperatorSubscribeOn$1$1.onNext(OperatorSubscribeOn.java:53)\r\n11-03 22:52:35.049 18649-18699/better.hello W/System.err:     at retrofit2.adapter.rxjava.OperatorMapResponseToBodyOrError$1.onNext(OperatorMapResponseToBodyOrError.java:41)\r\n11-03 22:52:35.049 18649-18699/better.hello W/System.err:     at retrofit2.adapter.rxjava.OperatorMapResponseToBodyOrError$1.onNext(OperatorMapResponseToBodyOrError.java:38)\r\n11-03 22:52:35.049 18649-18699/better.hello W/System.err:     at retrofit2.adapter.rxjava.RxJavaCallAdapterFactory$RequestArbiter.request(RxJavaCallAdapterFactory.java:173)\r\n11-03 22:52:35.050 18649-18699/better.hello W/System.err:     at rx.internal.operators.OperatorSubscribeOn$1$1$1.request(OperatorSubscribeOn.java:80)\r\n11-03 22:52:35.050 18649-18699/better.hello W/System.err:     at rx.Subscriber.setProducer(Subscriber.java:211)\r\n11-03 22:52:35.050 18649-18699/better.hello W/System.err:     at rx.internal.operators.OnSubscribeMap$MapSubscriber.setProducer(OnSubscribeMap.java:102)\r\n11-03 22:52:35.050 18649-18699/better.hello W/System.err:     at rx.internal.operators.OperatorSubscribeOn$1$1.setProducer(OperatorSubscribeOn.java:76)\r\n11-03 22:52:35.050 18649-18699/better.hello W/System.err:     at rx.Subscriber.setProducer(Subscriber.java:205)\r\n11-03 22:52:35.050 18649-18699/better.hello W/System.err:     at retrofit2.adapter.rxjava.RxJavaCallAdapterFactory$CallOnSubscribe.call(RxJavaCallAdapterFactory.java:152)\r\n11-03 22:52:35.050 18649-18699/better.hello W/System.err:     at retrofit2.adapter.rxjava.RxJavaCallAdapterFactory$CallOnSubscribe.call(RxJavaCallAdapterFactory.java:138)\r\n11-03 22:52:35.050 18649-18699/better.hello W/System.err:     at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:48)\r\n11-03 22:52:35.050 18649-18699/better.hello W/System.err:     at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:30)\r\n11-03 22:52:35.050 18649-18699/better.hello W/System.err:     at rx.Observable.unsafeSubscribe(Observable.java:10200)\r\n11-03 22:52:35.050 18649-18699/better.hello W/System.err:     at rx.internal.operators.OperatorSubscribeOn$1.call(OperatorSubscribeOn.java:94)\r\n11-03 22:52:35.050 18649-18699/better.hello W/System.err:     at rx.internal.schedulers.CachedThreadScheduler$EventLoopWorker$1.call(CachedThreadScheduler.java:228)\r\n11-03 22:52:35.050 18649-18699/better.hello W/System.err:     at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:55)\r\n11-03 22:52:35.050 18649-18699/better.hello W/System.err:     at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:422)\r\n11-03 22:52:35.050 18649-18699/better.hello W/System.err:     at java.util.concurrent.FutureTask.run(FutureTask.java:237)\r\n11-03 22:52:35.050 18649-18699/better.hello W/System.err:     at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:152)\r\n11-03 22:52:35.050 18649-18699/better.hello W/System.err:     at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:265)\r\n11-03 22:52:35.050 18649-18699/better.hello W/System.err:     at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1112)\r\n11-03 22:52:35.050 18649-18699/better.hello W/System.err:     at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:587)\r\n11-03 22:52:35.050 18649-18699/better.hello W/System.err:     at java.lang.Thread.run(Thread.java:818)\r\n```\r\nthere is my snippet:\r\n``` java\r\nHttpUtil.downFile(mp4_url).subscribeOn(Schedulers.io()).flatMap(new Func1<ResponseBody, Observable<DownloadInfo>>() {\r\n            @Override\r\n            public Observable<DownloadInfo> call(final ResponseBody body) {\r\n                return Observable.create(new Observable.OnSubscribe<DownloadInfo>() {\r\n                    @Override\r\n                    public void call(Subscriber<? super DownloadInfo> subscriber) {\r\n                        FileUtils.writeFile(subscriber, body, fileName);\r\n                    }\r\n                });\r\n            }\r\n        }).unsubscribeOn(Schedulers.io()).observeOn(AndroidSchedulers.mainThread()).subscribe(new Subscriber<DownloadInfo>() {\r\n            @Override\r\n            public void onCompleted() {\r\n                \r\n            }\r\n\r\n            @Override\r\n            public void onError(Throwable e) {\r\n\r\n            }\r\n\r\n            @Override\r\n            public void onNext(DownloadInfo info) {\r\n\r\n            }\r\n        });\r\n```\r\n``` java\r\npublic static void writeFile(Subscriber<? super DownloadInfo> subscriber, ResponseBody body, String fileName) {\r\n        try {\r\n            File file = getFile(fileName);\r\n            long readSize = 0, length = body.contentLength();\r\n            byte buffer[] = new byte[4096];\r\n            FileOutputStream outputStream = new FileOutputStream(file, true);\r\n            InputStream ins = body.byteStream();\r\n            DownloadInfo info = new DownloadInfo(length);\r\n            while (true) {\r\n                int read = ins.read(buffer);\r\n                if (read <= 0) {\r\n                    subscriber.onCompleted();\r\n                    break;\r\n                }\r\n                outputStream.write(buffer, 0, read);\r\n                readSize += read;\r\n                info.setReadFileSize(readSize);\r\n                info.setProgress(readSize / length);\r\n                subscriber.onNext(info);\r\n                Utils.d(\"Better\", \"\u4e0b\u8f7d\u4e86==\" + readSize + \",total=\" + length);\r\n            }\r\n            if (null != outputStream) {\r\n                outputStream.flush();\r\n                outputStream.close();\r\n            }\r\n            if (null != ins) {\r\n                ins.close();\r\n            }\r\n            if (null!=body){\r\n                body.close();\r\n            }\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n            subscriber.onError(e);\r\n        }\r\n    }\r\n```\r\nif i do not call subscriber.onNext(info) in the while circle  ,everything will be ok ,and the file will be download correctly.The place where the error can occur is subscribe.onNext().I just do not known why.\r\nsomeone can help me ?",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4814/comments",
    "author": "471448446",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-11-07T08:12:58Z",
        "body": "First, this looks like to be an unreliable network issue that times out. \n\nSecond, you are sending a mutable object downstream from that `onNext` which can lead to all sorts of undefined behavior. You should send a fresh object on every turn:\n\n``` java\n                DownloadInfo info = new DownloadInfo(length);\n                info.setReadFileSize(readSize);\n                info.setProgress(readSize / length);\n                subscriber.onNext(info);\n```\n\nThird, don't use `Observable.create` but use `Observable.fromEmitter`.\n"
      }
    ]
  },
  {
    "number": 4806,
    "title": "Can I force zip opertaer work on AndroidSchedulers.mainThread()",
    "created_at": "2016-11-04T08:47:24Z",
    "closed_at": "2016-11-04T09:01:01Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4806",
    "body": "zip combine varlues on the Scheduler which last Observable worked on.\r\nI want zip operate work on AndroidSchedulers.mainThread() or anyone of the Observable Schedulers.\r\n\r\nHow could I do?",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4806/comments",
    "author": "lengyue524",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-11-04T08:50:23Z",
        "body": "2 options\n-  apply `observeOn(AndroidSchedulers.mainThread())` on all of its inputs\n- identity map (or pair up) the zipper function's input, apply `observeOn` after the zip then use `map` to work with the pair/array of values.\n"
      }
    ]
  },
  {
    "number": 4802,
    "title": "Observable depends on other Observable | Needing both values",
    "created_at": "2016-11-03T20:39:01Z",
    "closed_at": "2016-11-04T12:41:48Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4802",
    "body": "I have an Observable whose emitted item I need for the next Observable but I can't use flatMap() because the method I need to call in the Subscriber needs the result of both Observables.\r\n\r\n```java\r\nservice.getToken(code)\r\n          .subscribe(new Action1<Token>() {\r\n                        @Override\r\n                        public void call(Token token) {\r\n                            service.getProfile(token.getAccessToken())\r\n                                    .subscribe(\r\n                                    new Action1<Profile>() {\r\n                                        @Override\r\n                                        public void call(Profile profile) {\r\n                                            createAccount(token, profile);\r\n                                        }\r\n                                    });\r\n                        }\r\n                    });\r\n```\r\n\r\nAny better approach then this?",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4802/comments",
    "author": "metp",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-11-03T20:56:32Z",
        "body": "Use the `flatMap` that takes a second `Func2`:\n\n``` java\nservice.getToken()\n.flatMap(token -> service.getProfile(token.getAccessToken()),\n    (token, profile) -> { createAccount(token, profile); return true; })\n.subscribe(v -> { }, Throwable::printStackTrace)\n```\n"
      }
    ]
  },
  {
    "number": 4788,
    "title": "RxJava 2.x Single is not extending Publisher",
    "created_at": "2016-10-31T12:26:51Z",
    "closed_at": "2016-10-31T14:59:49Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4788",
    "body": "Hi, I think Single should implement also org.reactivestreams.Publisher like Flowable.\r\nRight now in io.reactivex.rxjava2 2.0.0 Single doesn't implement Publisher and this leads to being unable to do the following:\r\n\r\n```\r\nFlowable<String> colors = Flowable.fromArray(\"red\", \"green\", \"blue\",\r\n                \"red\", \"yellow\", \"green\", \"green\");\r\n\r\n        Flowable<GroupedFlowable<String, String>> groupedColorsStream = colors\r\n                                                                           .groupBy(val -> val);\r\n\r\n        Flowable<Pair<String, Long>>\r\n                countedColors = groupedColorsStream\r\n                                        .flatMap(groupedFlow -> groupedFlow\r\n                                                                    .count()\r\n                                                                    .map(countVal -> new Pair<>(groupedFlow.getKey(), countVal))\r\n                                        );\r\n        countedColors.subscribe(System.out::println);\r\n\r\n```\r\n\r\nsince count() returns Single<Long>, and flatMap has the signature:\r\n```\r\n    public final <R> Flowable<R> flatMap(Function<? super T, ? extends Publisher<? extends R>> mapper) {\r\n        return this.flatMap(mapper, false, bufferSize(), bufferSize());\r\n    }\r\n```",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4788/comments",
    "author": "balamaci",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-10-31T13:22:26Z",
        "body": "It's not possible because of the receiver types are incompatible. Use `toFlowable` or `flatMapSingle` instead.\n"
      }
    ]
  },
  {
    "number": 4781,
    "title": "2.x - the code below Subscription.request(long) in onSubscribe() would't be executed until a flowable were completed",
    "created_at": "2016-10-30T03:51:19Z",
    "closed_at": "2016-10-30T13:38:29Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4781",
    "body": "When a flowable works on the main thread, `request(long)` in `onSubscribe(Subscription)` always calls `onNext(T)` and then `onComplete()`.\nTherefore, the code below `request(long)` in `onSubscribe(Subscription)` would be executed after `onNext(T)` and `onComplete()`.\n\n```\nFlowable.just(1, 2, 3).subscribe(new Subscriber<Integer>() {\n\n  @Override\n  public void onSubscribe(Subscription s) {\n    s.request(Long.MAX_VALUE);\n    System.out.println(\"onSubscribe done\");\n  }\n\n  @Override\n  public void onNext(Integer t) {\n    System.out.println(t);\n  }\n  ...\n}\n```\n\nThe result is always like this.\n\n```\n1\n2\n3\nonComplete called\nonSubscribe done\n```\n\nI can avoid this by calling `request(long)` at the end of `onSubscribe()`.\nHowever, this behavior is different from RxJava 1.x.\n\nAlso, there is a problem to override ResourceSubscriber's onStrat().\nSince `request(long)` acts this way, if I want to do something in `onStart()`, I have to put `super.onStart()` on the bottom of `onStart()`.\n\n```\n@Override\nprotected void onStart() {\n  initialize();\n  super.onStart();\n}\n```\n\nIf I write below, `intitalize()` would be called after `onComplete()`.\n\n```\n@Override\nprotected void onStart() {\n  super.onStart();\n  initialize();\n}\n```\n\nI think that this is a problem since developers always have to care about where they writie a request method.\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4781/comments",
    "author": "otal1105",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-10-30T07:34:46Z",
        "body": "Yes, this is a property of how Reactive-Streams request-onNext pair work. You have to do initialization before you call `request(n)` or make sure whatever you do after is thread-safe when looked at from `onNext`.\n\nI'll update the wiki and mention this case.\n"
      }
    ]
  },
  {
    "number": 4778,
    "title": "Error handling when operate observable",
    "created_at": "2016-10-28T08:44:29Z",
    "closed_at": "2016-11-12T18:19:12Z",
    "labels": [
      "Question",
      "1.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4778",
    "body": " when i do operator like Map to observable  ,then  function throws exception ,is there a way to let  the subscriber 's onError know error emit?\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4778/comments",
    "author": "julist213",
    "comments": [
      {
        "user": "davidmoten",
        "created_at": "2016-10-28T08:59:13Z",
        "body": "If the exception is  a checked exception then rethrow it wrapped in a RuntimeException (or your own class that extends RuntimeException). A non-checked exception will turn up as an onError emission.\n"
      },
      {
        "user": "davidmoten",
        "created_at": "2016-10-28T09:02:12Z",
        "body": "Example:\n\n``` java\nObservable.just(1)\n  .map(x -> {\n      try { \n          return canThrow(x);\n      } catch (IOException e) { \n          throw new RuntimeException(e);}\n    });\n```\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-11-12T18:19:12Z",
        "body": "Sidenote: you could go with 2.x and avoid these try catches almost always. \n\nIf you have further input on the issue, don't hesitate to reopen this issue or post a new one.\n"
      }
    ]
  },
  {
    "number": 4748,
    "title": "[2.x] sequenceEqual should return a Single, not an Observable?",
    "created_at": "2016-10-21T20:05:12Z",
    "closed_at": "2016-10-21T20:38:21Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4748",
    "body": "sequenceEqual should always emit a single boolean, so should its return value be a Single?\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4748/comments",
    "author": "DavidMGross",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-10-21T20:10:41Z",
        "body": "All `sequenceEqual` calls should return `Single` in RC5. Did you find one which doesn't?\n"
      }
    ]
  },
  {
    "number": 4704,
    "title": "2.x: Observable.interval() - why doesn't it have backpressure (Flowable) now (after 1.x)?",
    "created_at": "2016-10-14T06:38:02Z",
    "closed_at": "2016-10-14T08:23:19Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4704",
    "body": "I used to use `Observable.interval()` with `Observable.zip()` and deal with `backpressure`. Now then `backpressure` is implemented via `Flowable`, `Observable.interval()` still returns `Observable`, not `Flowable`. \nHow can it be `Observable` when it is a hot source?\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4704/comments",
    "author": "Nexen23",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-10-14T07:04:30Z",
        "body": "You mixed up a few concepts here. In 2.x the backpressure-enabled type is `Flowable`. `Observable` doesn't have any backpressure. Why would `Observable.interval()` return `Flowable`? In addition, `interval` is cold because it only starts to tick when a `Subscriber`/`Observer` subscribes to it.\n"
      },
      {
        "user": "Nexen23",
        "created_at": "2016-10-14T07:57:21Z",
        "body": "@akarnokd, oww well, haven't expected `Flowable.interval()` to exist.\nYeah, you are right, its cold. What I meant is `interval()` will not wait `Subscriber` to be done with its things and emit next value if `intervalMs` is smaller than time needed for `Subscriber.onNext()`.\nSo, in case of long doing `onNext()`, what will `Observable.interval()` do with `Observable.zip()` after that if it has no `backpressure`? Will it drop all except last value or...?\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-10-14T07:59:14Z",
        "body": "There is no drop there but it will fill in the internal buffer of zip(). If zip is delayed too much, you'll get an `OutOfMemoryError`.\n"
      },
      {
        "user": "Nexen23",
        "created_at": "2016-10-14T08:14:31Z",
        "body": "@akarnokd, have I understood it right that  `2.x Observable.zip(source)` now works like `1.x Observable.zip(source.onBackpressureBuffer())`, maintaining all unobserved data in itself?\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-10-14T08:18:54Z",
        "body": "2.x `Observable.zip` uses an unbounded buffer instead of a bounded one. There is no additional buffer like with 1.x zip+onBackpressureBuffer.\n"
      }
    ]
  },
  {
    "number": 4703,
    "title": "Subject should throw exception when calling onNext after onComplete",
    "created_at": "2016-10-13T22:11:05Z",
    "closed_at": "2016-10-14T17:11:44Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4703",
    "body": "```\nPublishSubject publishSubject = PublishSubject.create();\npublishSubject.onCompleted();\npublishSubject.onNext(new Object());\n```\n\nIn 1.x you can call onNext after onCompleted and no exception will be thrown. \nI think it should throw an exception, but maybe it isn't possible to reliably assert that the observable hasn't completed before calling onNext when dealing with different threads. \n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4703/comments",
    "author": "runningcode",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-10-14T07:01:52Z",
        "body": "This change would break the expectation that these methods don't throw. Why do you call onNext after onComplete?\n"
      },
      {
        "user": "runningcode",
        "created_at": "2016-10-14T07:26:56Z",
        "body": "Maybe `onCompleted` and `onNext` are called from different threads. I guess that's the problem with subjects anyways. :\\\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-10-14T07:29:55Z",
        "body": "Then you should use `toSerialized` and work with that `Subject` as regular `Subject`s are not thread safe. If you work with `SerializedSubject` then there is no reason to penalize that thread that didn't and can't know some other thread brought the `Subject` to a terminal state.\n"
      },
      {
        "user": "runningcode",
        "created_at": "2016-10-14T17:11:44Z",
        "body": "Ah ok. Perhaps I misunderstood that RxJava enforces the contract. It only guarantees that Observers receive events that follow the contract by wrapping Observers inside a SafeSubscriber.\n"
      }
    ]
  },
  {
    "number": 4700,
    "title": "Observable.using async resource factory?",
    "created_at": "2016-10-13T08:17:29Z",
    "closed_at": "2016-10-13T15:43:05Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4700",
    "body": "Hello,\n\ni have a use case where i will use a resource that need to be released after usage, so i thought the `Observable.using` fit in these case, but i obtain the resource from a `Observable` that could do a network call if it's not available local.\n\nThe resource is a session identifier with expiration time, so when it's not expired i have it local and it's fast, otherwise i do a network call, but the problem is, the `Observable.using` resourceFactory (first param), is a `Func0`, and i don't want to block inside it with `toBlocking.single`, how could i use it? Is there any alternative?\n\nHere is an example code, i wan't to remove the blocking part\n\n``` java\nreturn Observable.using(\n      // create resource\n      () -> getSession().toBlocking().single(), // i don't want to do that!\n      // use it\n      session -> doWork(session), // returns a observable\n      // release\n      session -> // release session,\n      true)\n```\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4700/comments",
    "author": "kennedyoliveira",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-10-13T08:25:04Z",
        "body": "FlatMap over it and have it as a constant in using.\n\n``` java\ngetSession()\n.flatMap(session -> Observable.using(() -> session, s-> doWork(s), s -> { }));\n```\n"
      }
    ]
  },
  {
    "number": 4673,
    "title": "Subscriber receives value after the unsubscription",
    "created_at": "2016-10-06T07:56:21Z",
    "closed_at": "2016-11-09T11:51:25Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4673",
    "body": "I have the following issue\n\n```\n@Test public void testUnsubscribe() throws InterruptedException {\n    PublishSubject<Boolean> mBooleanPublishSubject = PublishSubject.create();\n    Subscription subscription = mBooleanPublishSubject\n            .doOnNext(value -> System.out.println(\"Sending value \" + value))\n            .onBackpressureBuffer()\n            .observeOn(Schedulers.computation())\n            .map(v -> {\n                long sum = 0;\n                for (int i = 0; i < 10000000; i++) {\n                    sum += i;\n                }\n                return sum > 0;\n            })\n            .doOnNext(__ -> System.out.println(\"Before subscribe\"))\n            .subscribe(value -> System.out.println(\"Value received \" + value));\n\n    mBooleanPublishSubject.onNext(true);\n    mBooleanPublishSubject.onNext(true);\n    Thread.sleep(10);\n    System.out.println(\"Unsubscribing\");\n    subscription.unsubscribe();\n    System.out.println(\"Unsubscribed\");\n    Thread.sleep(1000);\n}\n```\n\nOutput\n\n```\nSending value true\nSending value true\nUnsubscribing\nUnsubscribed\nBefore subscribe\nValue received true\n```\n\nIs that expected behaviour?\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4673/comments",
    "author": "httpdispatch",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-10-06T08:09:25Z",
        "body": "Unsubscription is best effort and unless called in sequence, values may slip through.\n"
      },
      {
        "user": "httpdispatch",
        "created_at": "2016-10-06T08:10:46Z",
        "body": "Are there any recomendations to reduce such slip probability?\n"
      },
      {
        "user": "httpdispatch",
        "created_at": "2016-10-06T08:11:43Z",
        "body": "If i have flatMap after the map or use concatMap instead of map everything works as expected\n\n```\n@Test public void testUnsubscribe() throws InterruptedException {\n        PublishSubject<Boolean> mBooleanPublishSubject = PublishSubject.create();\n        Subscription subscription = mBooleanPublishSubject\n                .doOnNext(value -> System.out.println(\"Sending value \" + value))\n                .onBackpressureBuffer()\n                .observeOn(Schedulers.computation())\n                .concatMap(v -> Observable.fromCallable(() -> {\n                    System.out.println(\"concatMap\");\n                    long sum = 0;\n                    for (int i = 0; i < 100000000; i++) {\n                        sum += i;\n                    }\n                    return sum > 0;\n                }))\n                .doOnNext(__ -> System.out.println(\"Before subscribe\"))\n                .subscribe(value -> System.out.println(\"Value received \" + value));\n\n        mBooleanPublishSubject.onNext(true);\n        mBooleanPublishSubject.onNext(true);\n        Thread.sleep(30);\n        System.out.println(\"Unsubscribing\");\n        subscription.unsubscribe();\n        System.out.println(\"Unsubscribed\");\n        Thread.sleep(1000);\n    }\n```\n\nOutput\n\n```\nSending value true\nSending value true\nconcatMap\nUnsubscribing\nUnsubscribed\n```\n"
      },
      {
        "user": "httpdispatch",
        "created_at": "2016-10-06T08:18:11Z",
        "body": "How i understood from the described behaviour map, doOnNext should not perform long running operations because of such value slip probability\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-10-06T08:42:02Z",
        "body": "Have your end Subscriber check isUnsubscribed eagerly.\n"
      },
      {
        "user": "httpdispatch",
        "created_at": "2016-10-06T08:44:00Z",
        "body": "@akarnokd should it be something like this?\n\n```\n@Test public void testUnsubscribe() throws InterruptedException {\n        PublishSubject<Boolean> mBooleanPublishSubject = PublishSubject.create();\n        MutableObject<Subscription> subscription = new MutableObject<>();\n        subscription.set(mBooleanPublishSubject\n                .doOnNext(value -> System.out.println(\"Sending value \" + value))\n                .onBackpressureBuffer()\n                .observeOn(Schedulers.computation())\n                .map(v -> {\n                    System.out.println(\"map: started\");\n                    long sum = 0;\n                    for (int i = 0; i < 10000000; i++) {\n                        sum += i;\n                    }\n                    System.out.println(\"map: ended\");\n                    return sum > 0;\n                })\n                .filter(__ -> !subscription.get().isUnsubscribed())\n                .doOnNext(__ -> System.out.println(\"Before subscribe\"))\n                .filter(__ -> !subscription.get().isUnsubscribed())\n                .subscribe(value -> System.out.println(\"Value received \" + value)));\n\n        mBooleanPublishSubject.onNext(true);\n        mBooleanPublishSubject.onNext(true);\n        Thread.sleep(10);\n        System.out.println(\"Unsubscribing\");\n        subscription.get().unsubscribe();\n        System.out.println(\"Unsubscribed\");\n        Thread.sleep(1000);\n    }\n```\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-10-06T08:45:46Z",
        "body": "I mean subclass Subscriber instead of using lambdas.\n"
      },
      {
        "user": "httpdispatch",
        "created_at": "2016-10-06T08:47:50Z",
        "body": "That is OK for subscriber but not enough for other places of the chain: map, doOnNext. Is there a way to check whether the chain is unsubscribed without using external variable? For sure i may write dummy calls\nflatMap(v -> Observable.just(v)) instead of checking !subscription.get().isUnsubscribed(), but that doesn't look beautiful either\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-10-06T09:17:27Z",
        "body": "Other than writing a custom operator there is no  more elegant way subjectively.\n"
      },
      {
        "user": "httpdispatch",
        "created_at": "2016-10-06T09:42:19Z",
        "body": "Using your suggestion i've implemented Operator\n\nPerhaps that may help somebody else\n\n```\n@Test public void testUnsubscribe() throws InterruptedException {\n    PublishSubject<Boolean> mBooleanPublishSubject = PublishSubject.create();\n    MutableObject<Subscription> subscription = new MutableObject<>();\n    subscription.set(mBooleanPublishSubject\n            .doOnNext(value -> System.out.println(\"Sending value \" + value))\n            .onBackpressureBuffer()\n            .observeOn(Schedulers.computation())\n            .map(v -> {\n                System.out.println(\"map: started\");\n                long sum = 0;\n                for (int i = 0; i < 10000000; i++) {\n                    sum += i;\n                }\n                System.out.println(\"map: ended\");\n                return sum > 0;\n            })\n            .lift(new BreakIfUnsubscribed())\n            .doOnNext(__ -> System.out.println(\"Before subscribe\"))\n            .lift(new BreakIfUnsubscribed())\n            .subscribe(value -> System.out.println(\"Value received \" + value)));\n\n    mBooleanPublishSubject.onNext(true);\n    mBooleanPublishSubject.onNext(true);\n    Thread.sleep(30);\n    System.out.println(\"Unsubscribing\");\n    subscription.get().unsubscribe();\n    System.out.println(\"Unsubscribed\");\n    Thread.sleep(1000);\n}\n\npublic class BreakIfUnsubscribed<T> implements Observable.Operator<T, T> {\n    public BreakIfUnsubscribed() {\n    }\n\n    @Override public Subscriber<? super T> call(Subscriber<? super T> subscriber) {\n        return new Subscriber<T>(subscriber) {\n            @Override\n            public void onCompleted() {\n                if (!subscriber.isUnsubscribed()) {\n                    subscriber.onCompleted();\n                }\n            }\n\n            @Override\n            public void onError(Throwable t) {\n                if (!subscriber.isUnsubscribed()) {\n                    subscriber.onError(t);\n                }\n            }\n\n            @Override\n            public void onNext(T item) {\n                if (!subscriber.isUnsubscribed()) {\n                    subscriber.onNext(item);\n                }\n            }\n        };\n    }\n}\n```\n\nOutput\n\n```\nSending value true\nSending value true\nmap: started\nmap: ended\nBefore subscribe\nValue received true\nmap: started\nUnsubscribing\nUnsubscribed\nmap: ended\n```\n"
      }
    ]
  },
  {
    "number": 4670,
    "title": "Regarding delayed emissions",
    "created_at": "2016-10-05T11:53:45Z",
    "closed_at": "2016-10-25T13:41:10Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4670",
    "body": "In my code bbaPi.getProductsNextPage makes an http call and returns an observable. I generate a range of page numbers and pass this to the api call. I want to make this call after every n seconds but currently, when I use the zip operator, the call is sent for all the page numbers and then the emission of the call is delayed by 2 minutes. How can I delay this call by n seconds?\n\n```\n@Override\n    public Observable<List<Product>> getBbProducts(String category, String city) {\n        return bbApi.getProductsList(category, readCookie(objectMapper))\n                .map(response -> BbMapper.mapResponse(ProductPage.class, objectMapper, response))\n                .onBackpressureBuffer()\n                .filter(productPage -> productPage != null)\n                .flatMap(productPage -> {\n                    int totalPages = productPage.getResponse().getTab_info().get(0).getProduct_info().getTot_pages();\n                    int totalProducts = productPage.getResponse().getTab_info().get(0).getProduct_info().getP_count();\n\n                    return Observable.range(1, totalPages)\n                            .onBackpressureBuffer()\n                            .flatMap(new Func1<Integer, Observable<List<Product>>>() {\n                                         @Override\n                                         public Observable<List<Product>> call(Integer integer) {\n                                             long startTime = System.currentTimeMillis();\n                                             return Observable.zip(\n                                                     Observable.interval(1, TimeUnit.SECONDS)\n                                                             .onBackpressureDrop(),\n// This. I want to delay it by n seconds.\n                                                     bbApi.getProductsNextPage(category, readCookie(objectMapper), integer)\n                                                             .onBackpressureBuffer()\n                                                             .flatMap(new Func1<Response, Observable<List<Product>>>() {\n                                                                 @Override\n                                                                 public Observable<List<Product>> call(Response response) {\n                                                                     long endTime = System.currentTimeMillis();\n                                                                     System.out.println(\"Time taken: \" + (endTime - startTime) + \"Page: \" + integer);\n                                                                     return Observable\n                                                                             .from(BbMapper.mapToProductList(objectMapper, response))\n                                                                             .map(all -> BbMapper.mapToProduct(all, city))\n                                                                             .toList()\n                                                                             .subscribeOn(Schedulers.computation());\n                                                                 }\n                                                             })\n                                                             .onBackpressureBuffer()\n                                                     ,\n                                                     (aLong, products) -> products);\n                                         }\n                                     }\n                            )\n                            .onBackpressureDrop()\n                            .flatMap(new Func1<List<Product>, Observable<List<Product>>>() {\n                                @Override\n                                public Observable<List<Product>> call(List<Product> products) {\n                                    return Observable.just(products);\n                                }\n                            });\n                });\n    }\n```\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4670/comments",
    "author": "masterlittle",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-10-05T12:07:55Z",
        "body": "I don't fully understand what you try to achieve. If you want to retrieve the next page after 2 seconds, you can just flatMap an `interval`:\n\n``` java\nObservable.interval(2, TimeUnit.SECONDS)\n.take(maxPages)\n.onBackpressureDrop()\n.concatMap(v -> service.getPage((int)v + 1))\n...\n\n// or \n\nObservable.range(1, maxPages)\n.concatMap(v -> service.getPage(v).delaySubscription(2, TimeUnit.SECONDS))\n...\n```\n"
      },
      {
        "user": "masterlittle",
        "created_at": "2016-10-05T20:11:00Z",
        "body": "I implemented the first suggestion and it works! thanks\nI have one more query. I am iterating over a list using from() and in each emission I am making http calls using the data from the emission. Currently the http calls of different emissions are interleaved. I want to do do something so that until the result of all http calls for the first emission is not returned it should be blocked and after that, second emission should be emitted. Can it be done?\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-10-05T20:26:22Z",
        "body": "See `concatMapEager` which runs async sources at once but relays values from the first one only until it completes, then relays values from the second one, etc.\n"
      },
      {
        "user": "masterlittle",
        "created_at": "2016-10-06T05:39:45Z",
        "body": "Thanks @akarnokd . Worked like a dream after I tweaked the maxConcurrent. Another query(sorry), I want to limit the rate of emission. Currently every 2 seconds I receive an emission of 20 items. I want to throttle this to 10 items. I thought of using debounce() with buffer() but I am not sure I will not be losing emissions in the process. I mean if I use a debounce of 2 and a buffer of 10, I will receive a list of 10 items but what will happen to the remaining 10 items? Is there ny other way to do it?\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-10-06T08:50:09Z",
        "body": "Buffer it with 10 size and zip it with a interval.\n"
      }
    ]
  },
  {
    "number": 4664,
    "title": "2x RxJavaPlugins - 1.x RxJavaHooks using TestScheduler::advanceTimeBy",
    "created_at": "2016-10-03T23:53:21Z",
    "closed_at": "2016-10-04T07:05:38Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4664",
    "body": "I have a question regarding the usage of `TestScheduler` and hooks.\n\nThe next text passes using 1.x version:\n\n``` java\n  @Test public void Verify_Test_Scheduler_Rx1() {\n    rx.schedulers.TestScheduler scheduler = new rx.schedulers.TestScheduler();\n    RxJavaHooks.setOnComputationScheduler(current -> scheduler);\n\n    AtomicInteger flag = new AtomicInteger();\n\n    rx.Observable.just(1)\n        .doOnNext(ignored -> flag.getAndIncrement())\n        .delay(3, TimeUnit.SECONDS)\n        .doOnNext(ignored -> flag.getAndIncrement())\n        .subscribe();\n\n    scheduler.advanceTimeBy(4, TimeUnit.SECONDS);\n\n    assertThat(flag.get(), is(2));\n\n    RxJavaHooks.reset();\n  } \n```\n\n But this one fails, being the flag value 1, instead of 2:\n\n``` java\n@Test public void Verify_Test_Scheduler_Rx2() {\n    TestScheduler scheduler = new TestScheduler();\n    RxJavaPlugins.onComputationScheduler(scheduler);\n\n    AtomicInteger flag = new AtomicInteger();\n\n    Observable.just(1)\n        .doOnNext(ignored -> flag.getAndIncrement())\n        .delay(3, TimeUnit.SECONDS)\n        .doOnNext(ignored -> flag.getAndIncrement())\n        .subscribe();\n\n    scheduler.advanceTimeBy(4, TimeUnit.SECONDS);\n\n    assertThat(flag.get(), is(2));\n\n    RxJavaPlugins.reset();\n  }\n```\n\n  What is the correct usage of `TestScheduler` with `RxJavaPlugins` in 2.x to achieve the same effect that the one recreated in 1.x? \n\n  Thanks. \n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4664/comments",
    "author": "VictorAlbertos",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-10-04T07:00:59Z",
        "body": "``` java\nRxJavaPlugins.setComputationSchedulerHandler(current -> scheduler);\n```\n"
      }
    ]
  },
  {
    "number": 4657,
    "title": "Subscriber unsubscribe doubt",
    "created_at": "2016-10-02T03:19:13Z",
    "closed_at": "2016-10-03T07:34:07Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4657",
    "body": "Hello!\n\nI'm with a doubt about the unsubscribe process and memory related stuff, today i faced a simple case that made me wonder, the case is, i have a web Event Stream that i'll send some information when receive a request, but this information is sent with an interval, suppose each 500 milliseconds, and when the request ends, i want to clear all the resources allocated so i don't get a memory leak, the simplified code looks like this:\n\n``` java\nfinal Subscription metricsSubscription = Observable.interval(delay, TimeUnit.MILLISECONDS, scheduler)\n                                                   .map(i -> new DashboardData(HystrixCommandMetrics.getInstances(),\n                                                                               HystrixThreadPoolMetrics.getInstances(),\n                                                                               HystrixCollapserMetrics.getInstances()))\n                                                   .concatMap(dashboardData -> Observable.from(SerialHystrixDashboardData.toMultipleJsonStrings(dashboardData)))\n                                                   .subscribe(metric -> writeMetric(metric, response),\n                                                              ex -> log.error(\"Error sending metrics\", ex));\n```\n\nPretty simple, when the request ends, the client disconnect, i call:\n\n``` java\nmetricsSubscription.unsubscribe();\n```\n\nWhat happens to the interval observable? It'll stop emitting events, but it'll be garbage collected? \n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4657/comments",
    "author": "kennedyoliveira",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-10-02T07:44:20Z",
        "body": "The internal sequences should become collectable but it is possible that holding the `Subscription` reference itself may keep alive components. Use `onTerminateDetach` to make sure that doesn't happen.\n"
      },
      {
        "user": "kennedyoliveira",
        "created_at": "2016-10-02T08:34:26Z",
        "body": "@akarnokd thank you for your response, so basically the code is correct, the problem would be the `Subscription` reference as you state, so basically, if there are no problems with references, unsubscribing would clean everything that needs to be clean so the observable can stop and be collected?\n"
      },
      {
        "user": "kennedyoliveira",
        "created_at": "2016-10-02T22:25:02Z",
        "body": "@akarnokd thanks for clarifying things out, i didn't know about this onTerminateDetach, it was implemented recently or i missed it?\n\nAnother thing, there is any performance impact using it? \n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-10-03T07:14:40Z",
        "body": "A couple of patch versions before.\n\n> Another thing, there is any performance impact using it?\n\nIt has minimal overhead, just like an extra `map` or `filter`.\n"
      }
    ]
  },
  {
    "number": 4588,
    "title": "2.x: Convert Observable to Single without a default value",
    "created_at": "2016-09-23T08:23:13Z",
    "closed_at": "2016-10-09T18:24:36Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4588",
    "body": "With the RC3 changes I don't see an easy way of converting an Observable into a Single without giving a default value.\n\nHow do you feel about adding methods for that?\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4588/comments",
    "author": "vanniktech",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-09-23T08:29:11Z",
        "body": "@abersnaze didn't like throwing because being empty. Try your API through `Maybe` and `switchIfEmpty(Maybe.error())`.\n\n**Edit** wrong method name, fixed.\n"
      },
      {
        "user": "vanniktech",
        "created_at": "2016-09-23T08:34:27Z",
        "body": "`defaultIfEmpty(MaybeSource<T>)` does not exist\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-09-23T08:45:57Z",
        "body": "Yeah sorry, `switchIfEmpty()` (I sometimes mix the two as `defaultIfEmpty` delegates to `switchIfEmpty`).\n"
      },
      {
        "user": "vanniktech",
        "created_at": "2016-09-23T09:07:04Z",
        "body": "I don't quite see how `switchIfEmpty` solves my original problem. `Maybe.switchIfEmpty()` still returns a `Maybe`.\n\nAlso I'd rather have a `NoSuchElementException` and fail early than passing in a default value when converting an Observable to Single.\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-09-23T09:09:56Z",
        "body": "You could restore `toSingle` (under `singleOrError`), only the surface API has been removed.\n"
      },
      {
        "user": "vanniktech",
        "created_at": "2016-09-23T09:13:47Z",
        "body": "So basically add to Observable + Flowable:\n\n`singleOrError`\n`firstOrError`\n`lastOrError`\n`elementAtOrError`\n"
      },
      {
        "user": "abersnaze",
        "created_at": "2016-09-23T18:21:47Z",
        "body": "Does singleElement() error on more than one but not on empty?\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-09-23T18:27:46Z",
        "body": "Yes, that was kept and also why firstElement is there to ignore more without signalling.\n"
      }
    ]
  },
  {
    "number": 4571,
    "title": "Replay + Scan with initial value emits too many values",
    "created_at": "2016-09-20T20:30:27Z",
    "closed_at": "2016-10-17T18:47:01Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4571",
    "body": "The following test behaves as expected, emitting a single value to the subscriber:\n\n```\n    @Test\n    public void testExpectedReplayBehavior() {\n        final TestScheduler scheduler = new TestScheduler();\n        final TestSubject<Integer> subject = TestSubject.create(scheduler);\n        final TestSubscriber<Integer> subscriber = new TestSubscriber<>();\n\n        final ConnectableObservable<Integer> sums = subject.scan((a, b) -> a + b).replay(1);\n        sums.connect();\n\n        subject.onNext(1);\n        subject.onNext(2);\n        subject.onNext(3);\n        scheduler.triggerActions();\n\n        sums.subscribe(subscriber);\n\n        subscriber.assertValueCount(1);\n        subscriber.assertValues(6);\n    }\n```\n\nHowever, the second test fails, emitting all of the events from the source subject, rather than replaying the 1 event I requested with `replay(1)`:\n\n```\n    @Test\n    public void testFlakyReplayBehavior() {\n        final TestScheduler scheduler = new TestScheduler();\n        final TestSubject<Integer> subject = TestSubject.create(scheduler);\n        final TestSubscriber<Integer> subscriber = new TestSubscriber<>();\n\n        final ConnectableObservable<Integer> sums = subject.scan(1, (a, b) -> a + b).replay(1);\n        sums.connect();\n\n        subject.onNext(2);\n        subject.onNext(3);\n        scheduler.triggerActions();\n\n        sums.subscribe(subscriber);\n\n        subscriber.assertValueCount(1);\n        subscriber.assertValues(6);\n    }\n```\n\nAm I missing something nonintuitive about either `scan` or `replay`'s behavior that would reconcile these differences? I don't understand why supplying an initial argument for the accumulator would cause a drastic difference in behavior here.\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4571/comments",
    "author": "Thorn1089",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-09-20T20:59:16Z",
        "body": "Interesting.\n\n`scan(T, Func2)` has an internal buffer that holds onto the intermediate values until the downstream requests. Since `replay` coordinates requests, without a real subscriber, replay doesn't request on its own so `scan` keeps buffering. Once there is a subscriber to `replay`, it requests and now `scan` delivers all buffered values and given the active connection, the `TestSubscriber` receives all 3 values (1, 3, 6). The `scan(Func2)` doesn't buffer and delivers values immediately, filling in the `replay`'s buffer.\n\nSumming up:\n1. `TestSubject` doesn't honor backpressure\n2. `scan(T, Func2)` buffers too much\n3. `replay` doesn't request without `Subscriber`(s)\n\n2 can be considered a bug, 1 should be worked around with proper test emission and 3 is a matter of design and consequences (unlikely to change in 1.x).\n"
      },
      {
        "user": "Thorn1089",
        "created_at": "2016-09-20T21:09:58Z",
        "body": "Thanks for the clarification. I do have a follow-up question around number 1; namely, what should I be doing instead in a test scenario to manually mimic observable emissions if `TestSubject` is not the correct method? Can you clarify what proper test emission would look like here?\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-09-20T21:16:54Z",
        "body": "We use `PublishSubject` mostly when there is no real need for a time component but an imperative sequence of emit-then-test code:\n\n``` java\nPublishSubject<Integer> ps = PublishSubject.create();\n\nTestSubscriber<Integer> ts = new TestSubscriber<>();\n\nps.subscribe(ts);\n\nps.onNext(1);\nts.assertValues(1);\n\nps.onNext(2);\nts.assertValues(1, 2);\n\n// etc.\n```\n"
      },
      {
        "user": "tgolden-andplus",
        "created_at": "2016-10-17T18:53:47Z",
        "body": "Sorry, can you link the corresponding ticket for the buggy behavior described re: `scan(T, Func2)`?\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-10-17T18:59:45Z",
        "body": "There is none. It was unclear if the given scan behavior should be considered a bug or not.\n"
      }
    ]
  },
  {
    "number": 4559,
    "title": "2.x: Single.timeout with Callable<SingleSource<? extends T> other>>",
    "created_at": "2016-09-15T08:36:57Z",
    "closed_at": "2016-09-15T09:03:57Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4559",
    "body": "Basically I'd like to have a lazy timeout so that I only need to construct the other Single source once the original Single source 'timeouts'\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4559/comments",
    "author": "vanniktech",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-09-15T08:39:15Z",
        "body": "`Single.defer()`\n"
      }
    ]
  },
  {
    "number": 4547,
    "title": "replay does not cache if subscribed to using toBlocking().toFuture().get()",
    "created_at": "2016-09-13T23:20:07Z",
    "closed_at": "2016-09-29T14:20:46Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4547",
    "body": "Given the following snippet:\n\n```\n    BehaviorSubject<Observable<Integer>> s = BehaviorSubject.create(Observable.just(1));\n\n    Observable<Integer> o = s.flatMap(sp -> sp).replay(1).autoConnect();\n\n    //o.subscribe();\n\n    System.out.println(\"1st = \" + o.first().toBlocking().toFuture().get(0, TimeUnit.SECONDS));\n\n    s.onNext(Observable.just(2));\n\n    System.out.println(\"2st = \" + o.first().toBlocking().toFuture().get(0, TimeUnit.SECONDS));\n```\n\nI expect output: \n\n```\n1st = 1\n2nd = 2 \n```\n\ninstead I get \n\n```\n1st = 1 \n2nd = 1\n```\n\nIf I uncomment o.subscribe(), then the replay value gets updated correctly on 2nd.  Also it works correctly if not using the flatMap().  \n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4547/comments",
    "author": "ppiech",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-09-14T07:13:38Z",
        "body": "`replay` only moves as far as there were requests. Since both `o.first()` request 1 (due to `take(1)` inside), `replay` doesn't request more from the `flatMap`. Without `flatMap`, there is no backpressure and the `s.onNext(Observable.just(2))` is forced through into the `replay`. When you have a consumer like `o.subscribe`, that requests `Long.MAX_VALUE` which then allows `replay` to move forward and take in the 2nd Observable.\n"
      },
      {
        "user": "ppiech",
        "created_at": "2016-09-14T16:08:43Z",
        "body": "The explanation make sense, but it doesn't leave me with any good workaround.  Is there an alternative to replay() which ignores backpressure?\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-09-14T16:10:05Z",
        "body": "``` java\no.subscribe();\n```\n\nthat will unbound it.\n"
      },
      {
        "user": "ppiech",
        "created_at": "2016-09-14T18:05:53Z",
        "body": "I think this means that if I'm dealing with an open observable, it's not safe to use `o.first().toBlocking().toFuture()`\ninstead I should use \n`o.toBlocking().next().toIterator().next()`\nThe downside is that the latter may deadlock if I haven't implemented my observable correctly, where as the former would throw an exception.\n\nOr I should add \n`o.subscribe().unsubscribe()` prior to calling `toBlocking()`.\nbut it really looks like a voodoo hack.\n\nThank you for the explanation!\n"
      }
    ]
  },
  {
    "number": 4489,
    "title": "2.x: SerializedEmitter not implementing Disposable",
    "created_at": "2016-09-06T17:47:50Z",
    "closed_at": "2016-09-06T20:30:45Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4489",
    "body": "While looking at the different `Observable`/`Single`/`Completable` Emitters I noticed that the ObservableCreate `SerializedEmitter` is the only one not implementing `Disposable` and thus `#dispose`.\n\nIs this intended?\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4489/comments",
    "author": "Mauin",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-09-06T19:52:33Z",
        "body": "Yes, you are not supposed to dispose it from inside the emitter callback anyway.\n"
      }
    ]
  },
  {
    "number": 4477,
    "title": "2.x TestObserver and TestSubscriber for unit testing",
    "created_at": "2016-09-05T15:24:36Z",
    "closed_at": "2016-09-06T08:50:41Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4477",
    "body": "In 1.x I was using `TestSubscriber` to perform assertions in unit tests. But it seems that in 2.x is `TestObserver` the class that we need to use for this matter. Is that correct? And if that's correct, when I should use `TestSubscriber`?\n\nThanks. \n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4477/comments",
    "author": "VictorAlbertos",
    "comments": [
      {
        "user": "vanniktech",
        "created_at": "2016-09-05T15:27:33Z",
        "body": "All reactive types also have a built in `test` method that can be used.\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-09-06T06:57:26Z",
        "body": "You use `TestSubscriber` with `Flowable` and `TestObserver` with `Observable`. You can test `Single`, `Completable` and `Maybe` by converting them to either `Flowable` or `Observable`, but the built-in `test()`s for these three return `TestObserver`.\r\n"
      },
      {
        "user": "andreathacker",
        "created_at": "2018-03-08T23:19:41Z",
        "body": "In 2.x @akarnokd mentioned that the built-in return for `Single`, `Completable` and `Maybe` is `TestSubscriber` but it looks like it actual default for `Completable` is now `TestObserver`\r\n\r\n```\r\n    @CheckReturnValue\r\n    @SchedulerSupport(SchedulerSupport.NONE)\r\n    public final TestObserver<Void> test() {\r\n        TestObserver<Void> ts = new TestObserver<Void>();\r\n        subscribe(ts);\r\n        return ts;\r\n    }\r\n```"
      },
      {
        "user": "akarnokd",
        "created_at": "2018-03-08T23:41:11Z",
        "body": "@davidargylethacker Thanks, edited my comment to define the correct type."
      }
    ]
  },
  {
    "number": 4473,
    "title": "1.x: SingleDoAfterTerminateSubscriber swallowing exception",
    "created_at": "2016-09-05T12:35:46Z",
    "closed_at": "2016-09-05T12:49:28Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4473",
    "body": "Isn't `SingleDoAfterTerminateSubscriber` swallowing an exception?\n\ne.g. when action that get's invoked throws an excpetion for instance NullPointerException It'll be just rethrown but not delivered through onError\n\nAlso could not `SingleDoOnEvent` be reused for this behavior of invoking an action when Single has completed or errored? \n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4473/comments",
    "author": "vanniktech",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-09-05T12:41:03Z",
        "body": "It is **AfterTerminate**, that is, called after onXXX of the downstream has been called. At that point, the exception can't go anywhere other than the global onError handler.\n"
      }
    ]
  },
  {
    "number": 4440,
    "title": "Observable invoked twice on single subscription",
    "created_at": "2016-08-30T05:17:19Z",
    "closed_at": "2016-09-01T16:34:32Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4440",
    "body": "Hi,\nI have a simple use case where f1,  f2 and f3 are observable network calls with the dependency order: f2 -> f1 (f2 depends on f1 )and f3 -> f1 (f3 depends on f1). \nWhen I zip f2 and f3 to produce a combined result, f1 is getting called twice but I want it invoked only once otherwise it defeats the purpose. Could you please advise? I am sure I have the wiring wrong but couldn't figure out where and I tried all options on f1 : cache, share, replay \n\nCode:\n\n``` java\npublic static void main(String[] args) {\n    String id = \"abc\";\n    Observable.zip(T2dependency(id ), T3dependency(id ), \n        new Func2<JsonObject, JsonObject, JsonObject>() {\n\n    @Override\n    public JsonObject call(JsonObject t2Response, JsonObject t3Response) {\n\n     // operations on t2 & t3\n\n        return t2Response;\n    }\n\n    })\n    .subscribe(next -> System.out.println(\"final subscribe o/p: \" + new Gson().toJson(next)),\n        error -> error.printStackTrace());\n}\n\n\nprotected Observable<JsonObject> T2dependency(String id) {\n\n    return getT1info(id)\n    .<JsonObject>flatMap(new Func1<JsonObject, Observable<JsonObject>>() {\n\n        @Override\n        public Observable<JsonObject> call(JsonObject t1Response) {\n            System.out.println(\"T2.t1Response\");\n            return Observable.just(t1Response);\n        }\n    });\n}\n\nprotected Observable<JsonObject> T3dependency(String id) {\n\n    return getT1info(id)\n    .<JsonObject>flatMap(new Func1<JsonObject, Observable<JsonObject>>() {\n\n        @Override\n        public Observable<JsonObject> call(JsonObject t1Response) {\n            System.out.println(\"T3.t1Response\");\n            return Observable.just(t1Response);\n        }\n    });\n}\n\nprotected Observable<JsonObject> getT1info(String id) {\n        return ObservableHttp.createGet(url+id, client).toObservable()\n    .<JsonObject>flatMap(\n            response -> {\n\n                System.out.println(\"calling getT1info: \" + count++ );\n                return response.getContent()\n                        .map(s3 ->{\n                            System.out\n                                    .println(new String(s3));\n                            return new JsonParser().parse(new String(s3)).getAsJsonObject();\n                            }\n                        ); \n                    }\n            )\n            .timeout(3000, TimeUnit.MILLISECONDS)\n        .doOnError(throwable ->\n                System.out.println(\"printing throwable (getT1info): \" + throwable.toString())\n        );\n}\n```\n\nAny advise is greatly appreciated,\nThank you.\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4440/comments",
    "author": "udayravuri",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-08-30T07:11:07Z",
        "body": "You can use `publish(Func1)` that will share the underlying source for all consumers within the function call:\n\n``` java\nObservable.range(1, 10)\n.doOnSubscribe(() -> System.out.println(\"Subscribed\"))\n.publish(o -> Observable.zip(o.map(v -> v * 10), o.map(v -> v * 20), (a, b) -> a + \"-\" + b))\n.subscribe(System.out::println, Throwable::printStackTrace);\n```\n"
      }
    ]
  },
  {
    "number": 4438,
    "title": "2.x: Best way to unsubscribe/dispose a Subject subscription?",
    "created_at": "2016-08-29T19:41:55Z",
    "closed_at": "2016-08-29T19:53:59Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4438",
    "body": "Since there is no longer a `Subscription` returned when subscribing a `Subject` to an `Observable`, looking for the best way unsubscribe/dispose.\n\n``` java\nObservable<Long> observableA = Observable.interval(200, TimeUnit.MILLISECONDS).map(value -> value);\nObservable<Long> observableB = Observable.interval(200, TimeUnit.MILLISECONDS).map(value -> value * 100L);\n\nBehaviorSubject<Long> subject = BehaviorSubject.create();\nsubject.subscribe(System.out::println);\n\nSystem.out.println(\"Subscribing to observableA\");\nobservableA.subscribe(subject);\n\nTimeUnit.SECONDS.sleep(3);\n\n// TODO: How to unsubscribe the subject from upstream observableA before subscribing it to upstream observableB?\n\nSystem.out.println(\"Subscribing to observableB\");\nobservableB.subscribe(subject);\n\nTimeUnit.SECONDS.sleep(3);\n```\n\nWhat I've come up with so far is to `subscribeWith` an object that extends `DisposableObserver` that forwards `onNext`, `onError`, `onComplete` to the subject and use that to `dispose()` at the appropriate time.\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4438/comments",
    "author": "paulblessing",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-08-29T19:50:07Z",
        "body": "Yes, that works, also `subscribe(subject::onNext)` etc. where you get back a `Disposable` too.\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-08-29T19:58:25Z",
        "body": "In 2.x, exposing the `dispose()` method is the choice of the consumer `Observer`; this saves us a lot of allocation when such feature is not required.\n"
      }
    ]
  },
  {
    "number": 4408,
    "title": "CombineLatest and toList combination.",
    "created_at": "2016-08-23T07:28:11Z",
    "closed_at": "2016-08-24T10:40:51Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4408",
    "body": "Hello, \nThe RexactiveX documentation says : \n\n>  CombineLatest emits an item whenever any of the source Observables emits an item (so long as each of the source Observables has emitted at least one item)\n\nbut when I use combineLatest on a stream converted with toList, the output only produces one element even if the other stream (the one not converted with toList) has many values.\n\nGiving this test :\n\n``` java\nimport org.testng.annotations.Test;\nimport rx.Observable;\n\npublic class CombineLastTest {\n\n    @Test\n    public void testZip() {\n        Observable.combineLatest(//\n                Observable.just(1, 2, 3, 4, 5)//\n                     .doOnNext((integerValue) -> System.out.println(\"First stream value  : \" + integerValue))//\n                     .doOnCompleted(() -> System.out.println(\"First stream complete\")),//\n                Observable.just(\"a\", \"b\", \"c\", \"d\", \"e\")//\n                     .doOnNext((stringValue) -> System.out.println(\"Second stream value : \" + stringValue))//\n                     .toList()//\n                     .doOnNext((stringListValues) -> System.out.println(\"Second stream to list : \" + stringListValues))//\n                     .doOnCompleted(() -> System.out.println(\"Second stream complete\")),//\n                (firstStreamLatestStringValue, secondStreamLatestStringListValue) -> firstStreamLatestStringValue + \" \" + secondStreamLatestStringListValue)//\n            .doOnCompleted(() -> System.out.println(\"Stream is completed\")).subscribe(System.out::println);\n    }\n}\n```\n\nI get :\n\n```\nFirst stream value  : 1\nFirst stream value  : 2\nFirst stream value  : 3\nFirst stream value  : 4\nFirst stream value  : 5\nFirst stream complete\nSecond stream value : a\nSecond stream value : b\nSecond stream value : c\nSecond stream value : d\nSecond stream value : e\nSecond stream to list : [a, b, c, d, e]\n5 [a, b, c, d, e]\nSecond stream complete\nStream is completed\n```\n\nI presume I should get : \n\n```\nFirst stream value  : 1\nFirst stream value  : 2\nFirst stream value  : 3\nFirst stream value  : 4\nFirst stream value  : 5\nFirst stream complete\nSecond stream value : a\nSecond stream value : b\nSecond stream value : c\nSecond stream value : d\nSecond stream value : e\nSecond stream to list : [a, b, c, d, e]\n1 [a, b, c, d, e]\n2 [a, b, c, d, e]\n3 [a, b, c, d, e]\n4 [a, b, c, d, e]\n5 [a, b, c, d, e]\nSecond stream complete\nStream is completed\n```\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4408/comments",
    "author": "sdaclin",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-08-23T07:43:11Z",
        "body": "`combineLatest` will run through a synchronous source and only keep its last value. You should swap the two parameters that will yield something like you wanted.\n\nIt is an odd operator because it only works as one expects if the sources emit from the same thread and are naturally interleaved or all have exactly one value to combine. All else is subject to either thread scheduling non-determinism or run-to-end like behavior just like this.\n"
      },
      {
        "user": "sdaclin",
        "created_at": "2016-08-23T08:21:08Z",
        "body": "Ok thank you a lot David for being so fast with your answer. :+1: \nI've swapped the two inputs : \n\n``` java\n@Test\n    public void testZipFixed() {\n        Observable.combineLatest(//\n                                 Observable.just(\"a\", \"b\", \"c\", \"d\", \"e\")//\n                                         .doOnNext((stringValue) -> System.out.println(\"Second stream value : \" + stringValue))//\n                                         .toList()//\n                                         .doOnNext((stringListValues) -> System.out.println(\"Second stream to list : \" + stringListValues))//\n                                         .doOnCompleted(() -> System.out.println(\"Second stream complete\")),//\n                                 Observable.just(1, 2, 3, 4, 5)//\n                                         .doOnNext((integerValue) -> System.out.println(\"First stream value  : \" + integerValue))//\n                                         .doOnCompleted(() -> System.out.println(\"First stream complete\")),//\n                                 (secondStreamLatestStringListValue, firstStreamLatestStringValue) -> firstStreamLatestStringValue + \" \" + secondStreamLatestStringListValue)//\n                .doOnCompleted(() -> System.out.println(\"Stream is completed\")).subscribe(System.out::println);\n    }\n```\n\nAnd now it works as expected :\n\n```\nSecond stream value : a\nSecond stream value : b\nSecond stream value : c\nSecond stream value : d\nSecond stream value : e\nSecond stream to list : [a, b, c, d, e]\nSecond stream complete\nFirst stream value  : 1\n1 [a, b, c, d, e]\nFirst stream value  : 2\n2 [a, b, c, d, e]\nFirst stream value  : 3\n3 [a, b, c, d, e]\nFirst stream value  : 4\n4 [a, b, c, d, e]\nFirst stream value  : 5\n5 [a, b, c, d, e]\nFirst stream complete\nStream is completed\n```\n"
      }
    ]
  },
  {
    "number": 4407,
    "title": "Unsubscribe not called when using retryWhen",
    "created_at": "2016-08-23T05:22:14Z",
    "closed_at": "2016-08-23T16:56:02Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4407",
    "body": "I am not sure if this is expected, but when I run the below test, I get an assertion error:\n\n`java.lang.AssertionError: Not unsubscribed. (1 completion)`\n\nIt does not happen all the time which is why I put it in a loop. I suspect it has something to do with the timer in `retryWhen`. If the timer is set to 0, the test runs successfully. Anything else, it fails. I noticed the timer runs on the computation scheduler and tried adding `observeOn(Schedulers.immediate())` everywhere with no luck. \n\nIs the expected? If so, how can I get this to run reliably?\n\nTested on RxJava v1.1.9 and v1.1.0\n\n``` java\n\n    @Test\n    public void testUnsubscribe_shouldUnsubscribeAfterRetry() {\n        String testValue = \"test\";\n        for (int i = 0; i < 1000; ++i) {\n            TestSubscriber<String> subscriber = new TestSubscriber<>();\n            AtomicBoolean shouldFail = new AtomicBoolean(true);\n\n            Observable.defer(() -> {\n                if (shouldFail.getAndSet(false)) {\n                    return Observable.error(new IOException(\"Network Error\"));\n                } else {\n                    return Observable.just(testValue);\n                }\n            }).retryWhen(this::onErrorTryAgainWithTimer).subscribe(subscriber);\n\n            subscriber.awaitTerminalEvent();\n            subscriber.assertValue(testValue);\n            subscriber.assertNoErrors();\n            subscriber.assertUnsubscribed();  // Fails here\n        }\n    }\n\n    private Observable<?> onErrorTryAgainWithTimer(Observable<? extends Throwable> errors) {\n        return errors.zipWith(Observable.just(10, 1000, 2000), (n, i) -> i)\n                .flatMap(time -> Observable.timer(time, MILLISECONDS));\n    }\n```\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4407/comments",
    "author": "mandrizzle",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-08-23T07:04:04Z",
        "body": "What happens is that the `SafeSubscriber` calls `onComplete()` and then `unsubscribe` from the timer thread. The `onComplete` unblocks the `awaitTerminalEvent()` and then the assertions may run concurrently with `unsubscribe` which may or may not happen in time for the `assertUnsubscribed` to happen.\n"
      },
      {
        "user": "mandrizzle",
        "created_at": "2016-08-23T16:56:02Z",
        "body": "I think you are right, if I change my test to use a count down latch:\n\n``` java\n    @Test\n    public void testUnsubscribe_shouldUnsubscribeAfterRetry() throws InterruptedException {\n        String testValue = \"test\";\n        CountDownLatch latch = new CountDownLatch(1);\n\n        for (int i = 0; i < 1000; ++i) {\n            TestSubscriber<String> subscriber = new TestSubscriber<>();\n            AtomicBoolean shouldFail = new AtomicBoolean(true);\n\n            Observable.defer(() -> {\n                if (shouldFail.getAndSet(false)) {\n                    return Observable.error(NETWORK_EXCEPTION);\n                } else {\n                    return Observable.just(testValue);\n                }\n            }).retryWhen(this::onErrorTryAgainWithTimer).doOnUnsubscribe(latch::countDown).subscribe(subscriber);\n\n            subscriber.awaitTerminalEvent();\n            subscriber.assertValue(testValue);\n            subscriber.assertNoErrors();\n            latch.await();\n//            subscriber.assertUnsubscribed();\n        }\n    }\n```\n\nthe test completes every time. Thanks!\n"
      }
    ]
  },
  {
    "number": 4202,
    "title": "Question about takeUntil and Subscription.unsubscribe()",
    "created_at": "2016-07-14T09:17:49Z",
    "closed_at": "2016-08-16T08:38:52Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4202",
    "body": "in android ,if I use takeUntil for any network and on activity destroy, I use PublishSubject.onNext(null), the relation is gone; if I use CompositeSubscription.add() for any network and on activity destroy, I use CompositeSubscription.unsubscribe(), the relation is gone. what is different ?\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4202/comments",
    "author": "caoguodong",
    "comments": [
      {
        "user": "caoguodong",
        "created_at": "2016-07-15T02:19:39Z",
        "body": "@akarnokd \nI'm sorry about my english, and I give some code in android.\n\n``` java\nPublishSubject<Void> detachSignal = PublishSubject.create();\n\n    @Override\n    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n\n        Observable<Object> observable = Observable.create(new Observable.OnSubscribe<Object>() {\n            @Override\n            public void call(Subscriber<? super Object> subscriber) {\n                System.out.print(\"this is a network\");\n            }\n        });\n\n        observable.takeUntil(detachSignal)\n                .subscribe(new Action1<Object>() {\n                    @Override\n                    public void call(Object o) {\n\n                    }\n                });\n\n    }\n\n    @Override\n    public void onDestroy() {\n        super.onDestroy();\n        detachSignal.onNext(null);\n    }\n```\n\n``` java\nprivate CompositeSubscription mSubscription;\n\n    @Override\n    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n\n        mSubscription.add(Observable.create(new Observable.OnSubscribe<Object>() {\n            @Override\n            public void call(Subscriber<? super Object> subscriber) {\n                System.out.print(\"this is a network\");\n            }\n        }).subscribe(new Action1<Object>() {\n            @Override\n            public void call(Object o) {\n\n            }\n        }));\n    }\n\n    @Override\n    public void onDestroy() {\n        super.onDestroy();\n        mSubscription.unsubscribe();\n    }\n```\n\nwhat is different for destroy the relation between Observer and  the Observered\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-07-15T07:07:14Z",
        "body": "They should be functionally identical if there is only a single consumer.\n"
      },
      {
        "user": "caoguodong",
        "created_at": "2016-07-18T02:30:37Z",
        "body": "@akarnokd thank you for your answer and if there are several consumer \uff0c have any different\uff1f\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-07-18T06:51:47Z",
        "body": "The `detach` is shared between all of them so if you signal with it, all the other consumers and any future consumers will be completed.\n"
      }
    ]
  },
  {
    "number": 4197,
    "title": "Question about Observable.using's resourceFactory & disposeAction",
    "created_at": "2016-07-13T13:04:54Z",
    "closed_at": "2016-08-16T08:39:33Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4197",
    "body": "I have a resource which I want to release upon unsubscribing of the Observable, and release action must be run on the same thread which I created the resource.\n\nSo I found `Observable.using` and assumed that resourceFactory & disposeAction will run on a same thread which I specified with `subscribeOn`.\n\nAt first it seems working as I expected, but I realized that sometimes disposeAction runs on different thread than I specified with `subscribeOn`\n\n``` java\npublic class UsingResourceSample {\n    public static void main(String[] args) throws InterruptedException {\n    for (int i = 0; i < 10; i++) {\n      Observable.using(() -> {\n            String factoryThread = \"Getting @\" + Thread.currentThread().toString();\n            System.out.println(factoryThread);\n            return factoryThread;\n          },\n          Observable::just,\n          (factoryThread) -> System.out.println(\"Closing @\" + Thread.currentThread().toString() + \", \" + factoryThread))\n          .subscribeOn(Schedulers.io())\n          .subscribe()\n          .unsubscribe();\n    }\n  }\n}\n```\n\nIf I run this code multiple times, most of the time it shows `Closing @ThreadA, Getting @ThreadA`, but sometimes it shows `Closing @ThreadB, Getting @ThreadA`.\n\nSo, here are questions:\n1. is this behavior intentional?\n2. is there any way to run resourceFactory & disposeAction to run on the same thread which I specified with `subscribeOn`?\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4197/comments",
    "author": "yshrsmz",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-07-13T13:11:13Z",
        "body": "Hi.\n\n1) Yes. The operator doesn't deal with scheduling.\n2) Not with `subscribeOn`; try `unsubscribeOn` but you need a single-threaded `Scheduler` as all the default ones will give you different threads most likely.\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-07-14T06:54:25Z",
        "body": "Once upon a time our `subscribeOn` did unsubscribe on the same thread but it was split into `unsubscribeOn`; I can't remember why. @zsxwing  ?\n"
      },
      {
        "user": "yshrsmz",
        "created_at": "2016-07-15T11:07:51Z",
        "body": "ok, I created this simple single-threaded scheduler pool.\nhope this works well\n\n``` java\npublic class SingleThreadSchedulerPool {\n    private final static AtomicLong COUNT = new AtomicLong(0L);\n    private final static List<Scheduler> SCHEDULERS = new ArrayList<>(){{\n        add(Schedulers.from(Executors.newSingleThreadExecutor(new RxThreadFactory(\"SingleThreadScheduler-1-\"))));\n        add(Schedulers.from(Executors.newSingleThreadExecutor(new RxThreadFactory(\"SingleThreadScheduler-2-\"))));\n        add(Schedulers.from(Executors.newSingleThreadExecutor(new RxThreadFactory(\"SingleThreadScheduler-3-\"))));\n    }};\n\n    private SingleThreadSchedulerPool() {\n        // no-op\n    }\n\n    public static Scheduler get() {\n        long current = COUNT.getAndIncrement();\n        return SCHEDULERS.get((int) (current % 3));\n    }\n}\n```\n"
      }
    ]
  },
  {
    "number": 4164,
    "title": "Method for shutdown CachedObservable",
    "created_at": "2016-07-05T07:41:57Z",
    "closed_at": "2016-07-05T08:34:39Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4164",
    "body": "I have endless stream (which is not called onComplete at all). And I cache last value in it:\n\n```\nObservable<T> endlessStream = createStream().cache();\n\nSubscription s1 = endlessStream.subscribe(...)\nSubscription s2 = endlessStream.subscribe(...)\n```\n\nBy some condition endlessStream become not valid and I replace it (with switchMap, but it's not important).\n\n```\ns1.unsubscribe()\ns2.unsubscribe()\n```\n\nBut CachedObservable will always store connection to source stream (returned from createStream()). This leads to memory leak. How to disconnect CachedObservable from source observable?\n\nMore information:\n\nCachedObservable contains field state, which contain SerialSubscription to source observables (connection). If I call next hack, everything becomes OK:\n\n```\nprivate void disconnectCachedObservable(CachedObservable<T> observable) {\n    try {\n        Field fieldState = CachedObservable.class.getDeclaredField(\"state\");\n        fieldState.setAccessible(true);\n        Object state = fieldState.get(observable);\n        Field fieldConnection = state.getClass().getDeclaredField(\"connection\");\n        fieldConnection.setAccessible(true);\n        SerialSubscription subscription = (SerialSubscription) fieldConnection.get(state);\n        subscription.unsubscribe();\n    } catch (NoSuchFieldException e) {\n        e.printStackTrace();\n    } catch (IllegalAccessException e) {\n        e.printStackTrace();\n    }\n}\n```\n\nBut reflection isn't good solution:(\n\nMaybe create public method it?\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4164/comments",
    "author": "HotIceCream",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-07-05T08:19:59Z",
        "body": "You can use \n\n``` java\nreplay().autoConnect(1, toStop -> { /* store Subscription to cancel later */ });\n```\n\nwhich let's you stop the upstream by giving you a `Subscription`.\n"
      }
    ]
  },
  {
    "number": 4161,
    "title": "triggerActions doesn't work w/o advanceTimeBy",
    "created_at": "2016-07-04T13:27:57Z",
    "closed_at": "2016-08-10T16:43:06Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4161",
    "body": "So I have unit test:\n\n```\n @Test\n    public void interestingTest() {\n        TestSubscriber subscriber = new TestSubscriber();\n\n        List<Item> defaultList = new ArrayList<>();\n        Observable.concat(\n                memory.getItems(0, 20, item -> true),\n                disk.getItems(0, 20)\n                        .filter(items -> items != null && !items.isEmpty())\n                        .observeOn(uiScheduler),\n                cloud.getItems(TEST_USER_ID, 0, 20)\n                        .filter(items -> items != null && !items.isEmpty())\n                        .subscribeOn(ioScheduler)\n                        .observeOn(uiScheduler)\n        )\n                .firstOrDefault(defaultList, items -> items != null && !items.isEmpty())\n                .subscribe(subscriber);\n\n        uiScheduler.advanceTimeBy(0, TimeUnit.NANOSECONDS);\n        ioScheduler.triggerActions();\n        uiScheduler.triggerActions();\n\n        assertTrue(subscriber.getOnNextEvents().get(0) == defaultList);\n    }\n```\n\nmemory/disk/cloud are all mocked to return  Observable.just(new ArrayList<>())) so there is no any domain specific code.\n\nIt will work if I call `uiScheduler.advanceTimeBy(0, TimeUnit.NANOSECONDS)` even if I advance time with 0 {any timeunit}, but if I skip this line - testSubscriber won't get any items and test will fail. What's the reason of this behavior?\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4161/comments",
    "author": "zoopolitic",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-07-05T07:02:13Z",
        "body": "I can't run your test because the missing references, but the following code works for me:\n\n``` java\npublic class Issue4161 {\n    @Test\n    public void interestingTest() {\n        AtomicInteger counter = new AtomicInteger();\n\n        TestScheduler test = Schedulers.test();\n\n        Worker w = test.createWorker();\n\n        try {\n\n            w.schedule(() -> counter.incrementAndGet());\n            w.schedule(() -> counter.incrementAndGet());\n\n            test.triggerActions();\n        } finally {\n            w.unsubscribe();\n        }\n\n        Assert.assertEquals(2, counter.get());\n    }\n}\n```\n"
      },
      {
        "user": "zoopolitic",
        "created_at": "2016-07-05T07:09:52Z",
        "body": "cloud/disk/memory just interfaces for abstraction that returns `Observable<T>`. As I said they are mocked so there is no any specific logic for returning data. The point is in: \n\n```\n.subscribeOn(ioScheduler)\n.observeOn(uiScheduler)\n```\n\nso request executes on different threads. If I'll remove schedulers switch test pass successfully, so the problem is in scheduling/triggering\n"
      },
      {
        "user": "zoopolitic",
        "created_at": "2016-07-05T07:18:46Z",
        "body": "@akarnokd Here is the full test that you can just copy paste:\n\n```\npublic class ATest {\n\n    private interface Gateway {\n\n        Observable<List<Item>> getItems();\n    }\n\n    private static class Item {\n\n        private final int id;\n\n        private Item(int id) {\n            this.id = id;\n        }\n    }\n\n    @Mock private Gateway memory;\n    @Mock private Gateway disk;\n    @Mock private Gateway cloud;\n\n    private TestScheduler ioScheduler;\n    private TestScheduler uiScheduler;\n\n    @Before public void setUp() {\n        MockitoAnnotations.initMocks(this);\n\n        ioScheduler = Schedulers.test();\n        uiScheduler = Schedulers.test();\n    }\n\n    @Test\n    public void interestingTest() {\n        TestSubscriber subscriber = new TestSubscriber();\n\n        when(memory.getItems()).thenReturn(Observable.just(new ArrayList<>()));\n        when(disk.getItems()).thenReturn(Observable.just(new ArrayList<>()));\n        when(cloud.getItems()).thenReturn(Observable.just(new ArrayList<>()));\n\n        List<Item> defaultList = new ArrayList<>();\n        Observable.concat(\n                memory.getItems(),\n                disk.getItems()\n                        .filter(items -> items != null && !items.isEmpty())\n                        .observeOn(uiScheduler),\n                cloud.getItems()\n                        .filter(items -> items != null && !items.isEmpty())\n                        .subscribeOn(ioScheduler)\n                        .observeOn(uiScheduler)\n        )\n                .firstOrDefault(defaultList, items -> items != null && !items.isEmpty())\n                .subscribe(subscriber);\n\n        uiScheduler.advanceTimeBy(0, TimeUnit.NANOSECONDS); // comment this and test will fail\n        ioScheduler.triggerActions();\n        uiScheduler.triggerActions();\n\n        assertTrue(subscriber.getOnNextEvents().get(0) == defaultList);\n    }\n}\n```\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-07-05T08:37:15Z",
        "body": "What happens is that the uiScheduler schedules actions on ioScheduler which schedules actions on the uiScheduler again. If you remove the advanceTimeBy, the order changes to io->ui but then the io scheduler is not triggering the ui further on. If you add\n\n``` java\n\nuiScheduler.triggerActions(); // <--- add this\nioScheduler.triggerActions();\nuiScheduler.triggerActions();\n```\n\nor\n\n``` java\n\nioScheduler.triggerActions();\nuiScheduler.triggerActions();\nioScheduler.triggerActions();  // <-- add these again\nuiScheduler.triggerActions();\n```\n\nThe test passes again.\n"
      },
      {
        "user": "zoopolitic",
        "created_at": "2016-07-05T09:12:43Z",
        "body": "Can you please describe a little bit more ? I've tested again and see that `ioScheduler` and `uiScheduler` does not share same instance. They are different and `Schedulers.test()` produces new instance with its own queue every call. So why  \n\n> uiScheduler schedules actions on ioScheduler which schedules actions on the uiScheduler again\n\n? Thanks.\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-07-05T09:19:41Z",
        "body": "In your original test, they are independent schedulers and the test setup cross-scheduled activities. You have to trigger actions in both one after another until there are no more actions in either instance. If you call `test()` and assign its value to `ioScheduler` and `uiScheduler` there is no cross-scheduling `triggerActions` will exhaustively execute all pending tasks.\n"
      },
      {
        "user": "zoopolitic",
        "created_at": "2016-07-05T09:39:38Z",
        "body": "> You have to trigger actions in both one after another until there are no more actions in either instance\n\nIn original test I call `subscribeOn(ioScheduler).observeOn(uiScheduler)`. Schedulers are independent, you're right, but when I call triggerAction on ioScheduler - it should execute all pending tasks, same with uiScheduler, the question is why we need to call it more than 1 time on each scheduler. I think I misunderstand something in schedulers concept, because I don't understand why on 2 different schedulers we should call `triggerActions()` more than once\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-07-12T09:03:39Z",
        "body": "Two test schedulers have two distinct queues. A task running on one will add tasks to the other's queue but the `triggerAction` is confined to its own queue. Therefore, if there is a ping-pong between the schedulers, you have to repeatedly call `triggerAction` on both.\n"
      },
      {
        "user": "yoelglus",
        "created_at": "2016-09-03T16:37:56Z",
        "body": "So it seems that if you remove the:\n`uiScheduler.advanceTimeBy(0, TimeUnit.NANOSECONDS);`\nand just reverse the order so:\n\n```\nuiScheduler.triggerActions();\nioScheduler.triggerActions();\n```\n\nit works.\n"
      }
    ]
  },
  {
    "number": 4159,
    "title": "1.x Subscriber receives value after unsubscription",
    "created_at": "2016-07-01T22:44:06Z",
    "closed_at": "2016-07-02T15:50:40Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4159",
    "body": "Is it expected that this test case fails?\n\nOr the OnSubscribe is incomplete with this design (missing explicit `isUnsubscribed()` check)?\n\n```\n@Test\npublic void testAfterUnsubscribeNoValue() throws InterruptedException {\n    TestSubscriber<String> ts = new TestSubscriber<>();\n    AtomicBoolean unsubscribed = new AtomicBoolean();\n    CountDownLatch latch = new CountDownLatch(2);\n\n    Observable<String> s1 = Observable.create(s -> {\n\n        Thread t = new Thread(() -> {\n            try {\n                Thread.sleep(1000);\n                s.onNext(\"should not be displayed\");\n                latch.countDown();\n            } catch (InterruptedException ignored) {\n            }\n        });\n\n        s.add(Subscriptions.create(() -> {\n            unsubscribed.set(true);\n            latch.countDown();\n        }));\n        t.start();\n    });\n\n    Subscription subscription = s1.subscribe(ts);\n    subscription.unsubscribe();\n\n    if (latch.await(2000, TimeUnit.MILLISECONDS)) {\n        ts.assertNoValues();\n        assertTrue(unsubscribed.get());\n        assertTrue(subscription.isUnsubscribed());\n    } else {\n        fail(\"timed out waiting for latch\");\n    }\n}\n```\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4159/comments",
    "author": "Diolor",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-07-02T09:18:49Z",
        "body": "When you use `create` _you_ have to ensure the `Observable` contracts are honored. Not sure what you wanted to achieve originally, but you can do it via standard operators:\n\n``` java\nObservable.just(1)\n.delay(1, TimeUnit.SECONDS, Schedulers.newThread())\n.map(v -> \"should not be displayed\")\n.subscribe(ts);\n```\n\nOtherwise yes, you should call `isUnsubscribed` before `onNext`ing.\n"
      }
    ]
  },
  {
    "number": 3962,
    "title": "concatMap and Subject weirdness",
    "created_at": "2016-05-24T13:45:34Z",
    "closed_at": "2016-05-24T14:51:10Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3962",
    "body": "Hi,\n\nMaybe I just interpret it wrong but I found some unexpected behaviour.\n\n``` java\nObservable.just(1,2,3).concatMap(new Func1<Integer, Observable<String>>() { //flatmap <-- gets called 3 times\n    @Override\n    public Observable<String> call(Integer integer) {\n        return BehaviorSubject.create(\"one\"); //Observable.just(\"one\"); <-- This gets called 3 times\n    }\n}).subscribe(new Action1<String>() {\n    @Override\n    public void call(String s) {\n        //This gets called once... :(\n    }\n});\n```\n\nThe interesting thing is that if I use flatMap instead of concatMap the callback gets called 3 times. also if I don't use the subject but the Observable.just() it also gets called 3 times what I expect. Can someone describe me this outcome?\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3962/comments",
    "author": "mateherber",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-05-24T14:23:20Z",
        "body": "You need a source to complete with `concatMap` before it can move to the next. `BehaviorSubject` emits its initial value and just waits there, never completing.\n"
      }
    ]
  },
  {
    "number": 3956,
    "title": "Calling to Observable.toBlocking(). Always a bad practice?",
    "created_at": "2016-05-20T16:19:57Z",
    "closed_at": "2016-05-22T16:50:51Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3956",
    "body": "Hi.\n\nI have a library which returns observables. And I have another one which require to return the data in a synchronous way. \n\nParticularly, I\u2019m talking about OkHttp Interceptors. I need to retrieve the oauth token in order to add it as header. But this data comes from an observable. \n\n``` java\npublic class TwitterInterceptor implements Interceptor {\n    @Override public Response intercept(Chain chain) throws IOException {\n        Request request = chain.request();\n        Request newRequest = request.newBuilder()\n                .addHeader(\"oauth_token\", RxToken.getTwitterToken().toBlocking().first())\n                .build();\n        return chain.proceed(newRequest);\n    }\n}\n```\n\nCalling `toBlocking().first()` is the only way I can think to solve this problem. But I do not know if calling `toBlocking()` may have some unexpected effects (I mean I know that this observable resolves its task reading from disk or memory, so it is not a really heavy task). But because it seems to be not recommended to use it in production code, as a general rule.\n\nThanks. \n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3956/comments",
    "author": "VictorAlbertos",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-05-21T08:21:19Z",
        "body": "`toBlocking` gets you out of the reactive world and is generally fine if you have to bridge legacy, non-reactive APIs with it. In your example, if you can't change the method to `Observable<Response> intercept(Chain chain)`, `toBlocking` is acceptable tradeoff.\n\nHowever, if you are in the reactive world and suddenly want to use `toBlocking` inside a sequence, there are almost always ways to not do that. A typical mistake that comes up is something like this:\n\n``` java\nsource.map(v -> someAPI(v).toBlocking().first())...\n```\n\nInstead, you should be using any of the `flatMap`, `concatMap`, etc.\n\n``` java\nsource.concatMap(v -> someAPI(v))...\n```\n"
      },
      {
        "user": "tomgallagher",
        "created_at": "2019-02-13T02:35:59Z",
        "body": "I've got a question about this. In Android, shouldInterceptRequest on a WebClient requires a returned value, either null or a WebResourceResponse. I would like to avoid having a blockingFirst() call. Ideally I would like to pass a reference to the return value into the Observable chain and then make the decision on blocking later on. But I can't see how to do this. "
      }
    ]
  },
  {
    "number": 3955,
    "title": "concatMap not working",
    "created_at": "2016-05-20T10:24:55Z",
    "closed_at": "2016-06-17T08:07:48Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3955",
    "body": "Hello! I'm using a RxJava to login to server. I need to create next logic of login:\n**1. Get version of API from server and create (based on version) server urls\n2. Get tokens from the first server url\n3. If tokens received, I need to check if other servers (that I created in point 1) can be accessed by connecting to them**\n\nI writed next logic: \n\n```\n// getObservable() funcion;\nretrun Observable.create(new Observable.OnSubscribe<Integer>() {\n            @Override\n            public void call(Subscriber<? super Integer> subscriber) {\n                if (subscriber.isUnsubscribed()) return;\n//get version from server\n                int version = ServerAPI.getInstance(mContext).getVersion(User.this);\n                if (version < 5) {\n                    subscriber.onNext(AccountsAdapter.ERROR_OLD_API);\n                    subscriber.onCompleted();                 \n                    return;\n                }\n//get tokens\n                Pair<Integer,Tokens> data = ServerAPI.getInstance(mContext).getTokens(User.this, ServerAPI.GRANT_TYPE_PASSWORD);\n                if (data.first==ServerAPI.CODE_OK&&data.second.isValid()) {\n                    setAccessToken(data.second.getAccessToken());\n                    setRefreshToken(data.second.getRefreshToken());\n                    setUserId(data.second.getUserID());\n                    setApiVersion(data.second.getApiVersion());\n                    setTypeToken(data.second.getTokenType());\n                    setMacAlgorithm(data.second.getMacAlgorithm());\n                    setMacKey(data.second.getMacKey());\n                    setApiServer(createApiLink(version));\n                    setImagesServer(createImagesLink());\n //at this point result retuns to subscriber\n                    subscriber.onNext(data.first);\n                } else if (data.first==ServerAPI.CODE_OK\n                        ||data.first==ServerAPI.CODE_INVALID_RESPONSE_DATA) {\n                    subscriber.onNext(AccountsAdapter.ERROR_LOGIN_OR_PASS_INVALID);\n                } else {\n                    subscriber.onNext(data.first);\n                }\n                subscriber.onCompleted();\n            }\n        })\n               .concatMap(integer -> {\n// this code never called\n                if (integer==ServerAPI.CODE_OK) {\n// checking access to the servers\n                    return Observable.zip(getUserModules(), Observable.just(ServerAPI.getInstance(mContext).checkAccessToImagesServer(User.this)), (strings, aBoolean) -> {\n                        if (SystemUtils.isEmpty(strings)) {\n                            logOut();\n                            return AccountsAdapter.ERROR_INVALID_API_SERVER;\n                        } else if (aBoolean) {\n                            Users.getInstance(mContext).setCurrentUser(User.this);\n                            NotificationsManager.enableAllNotifications(mContext, getUserId());\n                            return ServerAPI.CODE_OK;\n                        } else {\n                            logOut();\n                            return AccountsAdapter.ERROR_INVALID_IMAGES_SERVER;\n                        }\n                    });\n                } else {\n                    return Observable.just(integer);\n                }\n            })\n         .subscribeOn(scheduler);\n```\n\nBut this Observable ignores concatMap and returns result from commented string. How to fix this?\n\nSubscriber is called by `getObservable().observeOn(AndroidSchedulers.mainThread()).subscribe();`\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3955/comments",
    "author": "personshelldon",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-05-20T10:30:04Z",
        "body": "RxJava is not using the builder pattern; each operator returns a new `Observable`. In your example, result won't change by calling `concatMap` on it. You should chain the `subscribeOn` after the application of `concatMap` return the resulting `Observable`.\n"
      },
      {
        "user": "personshelldon",
        "created_at": "2016-05-20T10:38:58Z",
        "body": "I don't understand what You say: I'm returning Observable with already concatMap implemented (I corrected code), but it does not work. Please, explain what I need to do in detailes to get this scheme to work? \nDocumentation says that concatMap will convert emitted items to another Observable, but concatMap ignores that items.\nSorry for my English.\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-05-20T10:44:31Z",
        "body": "What do you get as `integer` in the `concatMap`? Did you debug your `OnSubscribe` implementation to see what it does and what it gets from the API calls?\n"
      },
      {
        "user": "personshelldon",
        "created_at": "2016-05-20T10:49:02Z",
        "body": "Ah, sorry, I understood Your words about the \"not builder pattern\" I need to write`result = result.concatmap()` instead of `result.concatMap()`. Thank You a lot. Now it is working fine.\n\nOne more question: there are many articles that that say `Observable.create()`causes memory leaks if do not call `subscriber.unsubscribe()` in `OnSubscribe()` implementation. Is that true? Or `subscriber.onComplete()` is enough?\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-06-17T08:07:48Z",
        "body": "Sorry for the late response. If an `Observable` is run to completion, resources are released. Otherwise, if your activity is destroyed before that, you have to call `unsubscribe` manually. The problem with `create` is that people tend to implement it poorly, ignoring backpressure and most importantly, resource management.\n\nIf you have further input on the issue, don't hesitate to reopen this issue or post a new one.\n"
      }
    ]
  },
  {
    "number": 3939,
    "title": "What's the best way to have a side effect of a different type",
    "created_at": "2016-05-13T19:04:23Z",
    "closed_at": "2016-06-17T18:43:42Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3939",
    "body": "I'd like to have an `Observable` that represents some long running action, such as `Observable<ProgressEvent>` where the event holds progress information for the task, such as a status message or percentage completed.\n\nAt the end of the task I'd like to return a value of a different type. A trivial example would be counting the number of mis spelled words in some text. The progress would be processing word X of Y, but the result might be the list of mis-spelled words.\n\nThe first thing I looked at was`Subject`, but that won't work since the thing is really an `Observable` of the events and an `Observable` of the result, rather than an `Observable` an an `Observer` like `Subject`. Then I thought maybe simply extending `Observable` would work; I'd add an extra method `Optional<Result> result()` which would return the result of the computation after `onComplete`. But you \"lose\" the type of the `Observable` if you call other methods on it like a map, then a filter. You can get around that obviously, either extending all of the methods on Observable to return the subtype, or saving the variable, then chaining method calls to it, then finally, getting the result.\n\nI also considered adding the `result` method to the event interface such that the last call to `onNext` would have an event whose `Optional<Result>` is not empty. This seems pretty easy, but did not feel like the cleanest solution.\n\nWondering if there's a mechanism in the framework that I missed, or some best practice for this type of situation that I'm not aware of.\n\nThe reason I don't return an `Observable<Result>` in the first place is I wanted the caller to have the option of subscribing to the event stream to do something like show a progress monitor.\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3939/comments",
    "author": "mhgrove",
    "comments": [
      {
        "user": "davidmoten",
        "created_at": "2016-05-14T10:31:48Z",
        "body": "Trying again with formatting fixed.\n\nYou could emit a custom object that has a `ProgressEvent` and `List<String>`\nbeing the list of misspelled words so far (only needs to have real content till the last emission though) and then:\n\n``` java\nobservable\n    .doOnNext(x -> updateProgress(x.event))\n    .last()\n    .map(x -> x.list);\n```\n"
      },
      {
        "user": "mhgrove",
        "created_at": "2016-05-16T15:17:03Z",
        "body": "Yeah, that's similar to what I had stubbed out:\n\n```\n    public interface ProgressEvent<T> {\n\n        public long progress();\n        public long maxProgress();\n\n        public default Optional<T> result() {\n            return Optional.empty();\n        }\n    }\n```\n\nThat's the event that any `Observable` emitted that was a process that reported progress on the creation of a result.\n\nIt had not occurred to me `last().map(ProgressEvent::result).map(Optional::get)` could pretty cleanly get the result of the operation. I had been trying to use `compose`, `extend`, or `lift`, but those couldn't really be provided by the caller since the functions would need the state of the process being observed to potentially build the result. Extending `Observable` didn't feel clean, nor did hacking the builder creating the process to add observers to the resulting `Observable` or having it provide the function needed to get the final result.\n\n`last`/`map` seems like it might be the best option.\n"
      }
    ]
  },
  {
    "number": 3933,
    "title": "BackPressure and nested flatMap",
    "created_at": "2016-05-12T10:28:40Z",
    "closed_at": "2016-05-14T08:26:47Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3933",
    "body": "Hi, can someone explain why the following code (without nested flatmap)\n\n<div class=\"highlight highlight-source-java\"><pre>\nObservable.from(new IterateOverFloat(1))) //\n                .flatMap(__ -> Observable.create(new OnSubscribeFromIterable<>(new IterateOverFloat(10_000_000)))) //\n                .flatMap(Observable::just) //\n                .observeOn(Schedulers.computation()) //\n                .subscribe();\n</pre></div>\n\ngoes through method `slowPath(long)` of `OnSubscribeFromIterable.IterableProducer`,\n\nwhile the following code (with nested flat map)\n\n<div class=\"highlight highlight-source-java\"><pre>\nObservable.from(new IterateOverFloat(1)) //\n                .flatMap(__ -> Observable.create(new OnSubscribeFromIterable<>(new IterateOverFloat(10_000_000))) //\n                        .flatMap(Observable::just)) //\n                .observeOn(Schedulers.computation()) //\n                .subscribe();\n</pre></div>\n\ngoes through method `fastPath()` ?\n\n`IterateOverFloat` is just a basic iterable that produces the asked number of floats.\n\nI've tested with both RxJava-1.1.0 and 1.1.5 with the same results.\n\nEDIT : ok, I have looked around a bit more, and here is what I have found.\nI have created an Observable with backpressure support, which prints the first number of requested items:\n\n<div class=\"highlight highlight-source-java\"><pre>\nObservable<Long> myObsWithBackPressureSupport = Observable.create(subs -> {\n            subs.setProducer(new Producer() {\n\n                AtomicBoolean bool = new AtomicBoolean(true);\n\n                @Override\n                public void request(long n) {\n                    if(bool.getAndSet(false)){\n                        System.out.println(\"request \" + n);\n                    }\n                    \n                    LongStream.range(0, n).forEach(subs::onNext);\n                }\n                \n            });\n        });\n</pre></div>\n\n\nand I used it the following ways: \n\n<div class=\"highlight highlight-source-java\"><pre>\n// case 1\nmyObsWithBackPressureSupport //\n        .observeOn(Schedulers.computation()) //\n        .subscribe();\n\n// case 2\nmyObsWithBackPressureSupport //\n        .flatMap(l -> Observable.just(l)) //\n        .observeOn(Schedulers.computation()) //\n        .subscribe();\n</pre></div>\n\n\nIn case 1, first request of 128 items.\nIn case 2, first request of Long.MAX_VALUE items.\n\nI have concluded that using `flatMap` disables the backpressure support. Can someone tell me if I am right and if it is an intended behavior ?\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3933/comments",
    "author": "feneuilflo",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-05-12T17:31:56Z",
        "body": "FlatMap has multiple entry points: one front and any number of inner sequences. \n\nBy default, `flatMap` requests the `Long.MAX_VALUE` - which is called unbounded mode - from its main upstream, which may trigger the fast-paths in sources. \n\nThe inner, mapped sequences, request a fixed amount - default 128 - and keeps requesting as those inner values get consumed and merged into the output sequence. This doesn't trigger the fast-paths in most inner sequences. \n\nYou can restrict the outer unbounded mode by setting the `maxConcurrency` parameter but you can't unbound the inner sequences. \n\nIf you are dealing with inner `Iterable`s, you can avoid the genreal overhead by using `flatMapIterable`.\n"
      }
    ]
  },
  {
    "number": 3929,
    "title": ".groupBy should not hold strong references to keys",
    "created_at": "2016-05-11T09:08:08Z",
    "closed_at": "2016-05-11T12:43:54Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3929",
    "body": "Actual result: .groupBy maintains internal map with strong references to keys. In case when key is large object, or references another large objects, this can lead to OOM eventually.\n\nExpected result: groupBy keeps week references to keys, which does not prevent GC from collecting the keys.\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3929/comments",
    "author": "gumanoid",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-05-11T09:22:19Z",
        "body": "GroupBy has to remember the whole key because values have to go to the associated `GroupedObservable`. A weak key would imply groups get recreated multiple times or worse, an old group's `getKey()` suddenly returning `null`.\n\nYou could try extracting only the necessary key material into a separate, independent data class and use that in the keyselector:\n\n``` java\nsource.groupBy(v -> new MyKey(v.name, v.age))...\n```\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-05-11T12:43:54Z",
        "body": "Yes, if your key class depends on a `List<String>` with million items then it is hard to avoid the retention. A possible solution is perhaps to reduce that large data amount with a hash function (SHA256) which gives a manageable key size at the cost of a very low chance of key collision.\n"
      },
      {
        "user": "abersnaze",
        "created_at": "2016-05-12T01:59:15Z",
        "body": "If you unsubscribe from the GroupedObservables it should remove the reference to the key so that it can be GC'd.  If a new value that maps to the old key shows up a new GroupedObservable is started up.\n\n```\nimport java.util.concurrent.TimeUnit;\nimport rx.Observable;\n\npublic class Main {\n    public static void main(String[] args) {\n        Observable<Long> fast = Observable.interval(10, TimeUnit.MILLISECONDS).map(i -> i * 2).take(10);\n        Observable<Long> slow = Observable.interval(20, TimeUnit.MILLISECONDS).map(i -> i * 2 + 1).take(10);\n\n        fast.mergeWith(slow)//\n                .groupBy(i -> i % 2)\n                .flatMap(grp -> {\n                    System.out.println(\"New group for key \" + grp.getKey());\n                    Observable<Long> timeLimitedGrp = grp.take(100, TimeUnit.MILLISECONDS).doOnUnsubscribe(() -> System.out.println(\"Unsub group for key \" + grp.getKey()));\n                    // do other stuff\n                    return timeLimitedGrp;\n                })\n                .toBlocking()\n                .forEach(System.out::println);\n    }\n}\n```\n\nproduces the output\n\n```\nNew group for key 0\n0\n2\nNew group for key 1\n1\n4\n6\n3\n8\n10\n5\n12\n7\n14\n16\n18\n9\nUnsub group for key 0\n11\nUnsub group for key 1\nNew group for key 1\n13\n15\n17\n19\nUnsub group for key 1\n\n```\n"
      }
    ]
  },
  {
    "number": 3869,
    "title": "wondering",
    "created_at": "2016-04-20T10:13:38Z",
    "closed_at": "2016-05-21T09:14:09Z",
    "labels": [
      "Question",
      "Android"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3869",
    "body": "``` java\nObservable\n.just(mToast)\n.observeOn(AndroidSchedulers.mainThread())\n.subscribe(new Action1<Toast>() {\n    @Override\n    public void call(Toast toast) {\n       if (mToast == null) {\n          mToast = Toast.makeText(MainActivity.this, \"test==================\", Toast.LENGTH_SHORT);\n       } else {\n           mToast.setText(\"test====================\");\n       }\n       mToast.show();\n   }\n}).unsubscribe();\n```\n\nwhy the toast can\u2018t show\uff1f\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3869/comments",
    "author": "longshiming",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-04-20T10:24:32Z",
        "body": "You unsubscribe immediately and the value may not ever reach the action at all.\n"
      },
      {
        "user": "longshiming",
        "created_at": "2016-04-20T10:29:09Z",
        "body": "its not order\uff1ffirst \uff0cperform the action,then ,perform unsubscribe().\n\nOr rather, at what time should I perform unsubscribe?\n"
      },
      {
        "user": "zsxwing",
        "created_at": "2016-04-20T17:21:15Z",
        "body": "@longshiming the problem is in `.observeOn(AndroidSchedulers.mainThread())`. I guess your code was running in the main thread. Then `.observeOn(AndroidSchedulers.mainThread())` will emit the element to the main handler queue. After your codes finishes, unsubscribe has been called. Therefore when the element is polled  from the queue, it will be ignored.\n"
      },
      {
        "user": "longshiming",
        "created_at": "2016-04-22T08:17:31Z",
        "body": "@zsxwing Thanks. AndroidSchedulers. MainThread () can run time-consuming tasks\uff1f\n"
      },
      {
        "user": "artem-zinnatullin",
        "created_at": "2016-04-22T08:49:57Z",
        "body": "No, it's a bad idea because it'll block main thread of Android app, UI will freeze and Android OS may display ANR dialog. \n"
      }
    ]
  },
  {
    "number": 3847,
    "title": "I use scan operator,but it not work when just one value or first event",
    "created_at": "2016-04-10T15:54:23Z",
    "closed_at": "2016-06-17T20:21:05Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3847",
    "body": "I use the `rxjava` version `1.1.0`,and use scan operator such as:\n\n```\nObservable.just(\"Hello, world!\").scan(new Func2<String, String, String>() {\n        @Override\n        public String call(String s, String s2) {\n            Log.e(\"test\", s);\n            return s;\n        }\n    }).subscribe(new Action1<String>() {\n        @Override\n        public void call(String s) {\n            Log.e(\"test\", s);\n        }\n    });\n```\n\n the `scan()` not invoke.\n\nor \n\n```\nRxView.clicks(btn).map(new Func1<Void, Integer>() {\n        @Override\n        public Integer call(Void aVoid) {\n            times = times + 1;\n            return times;\n        }\n    }).timestamp().scan(new Func2<Timestamped<Integer>, Timestamped<Integer>,               Timestamped<Integer>>() {\n        @Override\n        public Timestamped<Integer> call(Timestamped<Integer> integerTimestamped, Timestamped<Integer> integerTimestamped2) {\n  Log.e(\"integerTimestamped:\", integerTimestamped.getValue() + \"\");\n  Log.e(\"integerTimestamped\", integerTimestamped.getTimestampMillis() + \"\");\n  Log.e(\"integerTimestamped2:\", integerTimestamped2.getValue() + \"\");\n  Log.e(\"integerTimestamped2\", integerTimestamped2.getTimestampMillis() + \"\");\n  return Timestamped<>(integerTimestamped2.getTimestampMillis(),times);\n        }\n    }).subscribe(new Action1<Timestamped<Integer>>() {\n        @Override\n        public void call(Timestamped<Integer> integerTimestamped) {\n            if (integerTimestamped.getValue() == 5) {\n                firstClickTime = 0;\n                times = 0;\n                Toast.makeText(MainActivity.this,\n                    \"test\",\n                    Toast.LENGTH_LONG).show();\n            }\n\n        }\n    });\n```\n\n when click btn first time ,the `scan()` also not invok\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3847/comments",
    "author": "carl1990",
    "comments": [
      {
        "user": "abersnaze",
        "created_at": "2016-04-10T16:40:30Z",
        "body": "That overload of scan is only invokes the function when there are more than one onNext.  change the first example to either:\nA) use the scan( Func0, Func2 )\nB) use just(\"hello\", \"world\")\n\n> On Apr 10, 2016, at 08:54, carl notifications@github.com wrote:\n> \n> I use the rxjava version 1.1.0,and use scan operator such as:\n> \n> Observable.just(\"Hello, world!\").scan(new Func2<String, String, String>() {\n>         @Override\n>         public String call(String s, String s2) {\n>             Log.e(\"test\", s);\n>             return s;\n>         }\n>     }).subscribe(new Action1<String>() {\n>         @Override\n>         public void call(String s) {\n>             Log.e(\"test\", s);\n>         }\n>     });\n> the scan() not invoke.\n> \n> or\n> \n> RxView.clicks(btn).map(new Func1<Void, Integer>() {\n>         @Override\n>         public Integer call(Void aVoid) {\n>             times = times + 1;\n>             return times;\n>         }\n>     }).timestamp().scan(new Func2<Timestamped<Integer>, Timestamped<Integer>,               Timestamped<Integer>>() {\n>         @Override\n>         public Timestamped<Integer> call(Timestamped<Integer> integerTimestamped, Timestamped<Integer> integerTimestamped2) {\n>   Log.e(\"integerTimestamped:\", integerTimestamped.getValue() + \"\");\n>   Log.e(\"integerTimestamped\", integerTimestamped.getTimestampMillis() + \"\");\n>   Log.e(\"integerTimestamped2:\", integerTimestamped2.getValue() + \"\");\n>   Log.e(\"integerTimestamped2\", integerTimestamped2.getTimestampMillis() + \"\");\n>   return Timestamped<>(integerTimestamped2.getTimestampMillis(),times);\n>         }\n>     }).subscribe(new Action1<Timestamped<Integer>>() {\n>         @Override\n>         public void call(Timestamped<Integer> integerTimestamped) {\n>             if (integerTimestamped.getValue() == 5) {\n>                 firstClickTime = 0;\n>                 times = 0;\n>                 Toast.makeText(MainActivity.this,\n>                     \"test\",\n>                     Toast.LENGTH_LONG).show();\n>             }\n> \n> ```\n>     }\n> });\n> ```\n> \n> when click btn first time ,the scan() also not invok\n> \n> \u2014\n> You are receiving this because you are subscribed to this thread.\n> Reply to this email directly or view it on GitHub\n"
      }
    ]
  },
  {
    "number": 3844,
    "title": "delaySubscription(Observable) breaks upstream unsubscription",
    "created_at": "2016-04-08T18:26:09Z",
    "closed_at": "2016-04-09T08:44:57Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3844",
    "body": "This test case is failing (tested with 1.1.2):\n\n``` java\n  @Test\n  public void testWithSubjects() {\n    PublishSubject<Integer> delayUntil = PublishSubject.create();\n    PublishSubject<Integer> interrupt = PublishSubject.create();\n    final AtomicBoolean subscribed = new AtomicBoolean(false);\n\n    Observable.just(1)\n        .doOnSubscribe(() -> subscribed.set(true))\n        .delaySubscription(delayUntil)\n        .takeUntil(interrupt)\n        .subscribe();\n\n    interrupt.onNext(9000);\n    delayUntil.onNext(1);\n\n    assertFalse(subscribed.get());\n  }\n\n```\n\nI stumbled upon this using `Completable.andThen` (which delegates to `delaySubscription`).\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3844/comments",
    "author": "hannesstruss",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-04-08T18:31:47Z",
        "body": "TakeUntil subscribes to its source before the subscription to upstream could happen. This is partly due to how `lift` works and partly to allow interrupting a synchronous source as it would otherwise possibly rush through without letting the operator subscribe to the until source.\n"
      },
      {
        "user": "hannesstruss",
        "created_at": "2016-04-08T19:02:22Z",
        "body": "In other words, `takeUntil` only guarantees to suppress emission of items given a condition, but does not guarantee what happens upstream?\n\n(I was confused, as the analogous example with time based `delaySubscription` works:)\n\n``` java\n  @Test\n  public void testWithSubjects() {\n    PublishSubject<Integer> interrupt = PublishSubject.create();\n    final AtomicBoolean subscribed = new AtomicBoolean(false);\n    TestScheduler testScheduler = new TestScheduler();\n\n    Observable.just(1)\n        .doOnSubscribe(() -> subscribed.set(true))\n        .delaySubscription(1, TimeUnit.SECONDS, testScheduler)\n        .takeUntil(interrupt)\n        .subscribe();\n\n    interrupt.onNext(9000);\n    testScheduler.advanceTimeBy(1, TimeUnit.SECONDS);\n\n    assertFalse(subscribed.get());\n  }\n```\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-04-08T19:22:34Z",
        "body": "Interesting. The second case shouldn't pass either. I'll investigate.\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-04-08T19:41:58Z",
        "body": "Okay, I was wrong. Both tests should pass because they verify that the subscription doesn't happen - as expected. There is a bug in the non-timed `delaySubscription` that doesn't propagate the unsubscription properly. I'll post a PR to fix that.\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-04-08T19:57:05Z",
        "body": "Fix posted: #3845\n"
      }
    ]
  },
  {
    "number": 3843,
    "title": "Unexpected behavior",
    "created_at": "2016-04-08T05:57:48Z",
    "closed_at": "2016-04-08T08:57:41Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3843",
    "body": "``` java\nimport rx.Observable;\n\npublic class RxTest {\n\n    public static void main(String[] args) {\n        Observable.<String>create(subscriber -> {\n            subscriber.onNext(\"as\");\n            subscriber.onNext(\"asd\");\n        })\n                .map(s -> {\n                    if (s.length() < 3) {\n                        throw new RuntimeException(\"\");\n                    }\n                    return 1;\n                })\n                .flatMap(o -> {\n                    System.out.println(\"flatMap\");\n                    return Observable.just(true);\n                })\n                .subscribe(System.out::println, t -> {});\n    }\n}\n```\n\nOutput:\n\n```\nflatMap\n```\n\nBut, if we comment line with `throw new RuntimeException(\"\")` output will be:\n\n```\nflatMap\ntrue\nflatMap\ntrue\n```\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3843/comments",
    "author": "nikialeksey",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-04-08T07:11:33Z",
        "body": "This is the expected behavior. `map` crashes and `flatMap` is skipped.\n"
      },
      {
        "user": "nikialeksey",
        "created_at": "2016-04-08T07:56:37Z",
        "body": "Wow! Be careful:\n1. emit \"as\": `throw` -> `flatMap` is skiped\n2. emit \"asd\": go to `flatMap`, output `\"flatMap\"`, but where is output in `subscribe`?\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-04-08T08:10:31Z",
        "body": "The problem is that your `create` ignores unsubscription and thus violates the `Observable` contract. If you add \n\n``` java\n     if (subscriber.isUnsubscribed()) return;\n```\n\nin between the two calls to `onNext`, nothing is printed.\n"
      },
      {
        "user": "adipascu",
        "created_at": "2016-04-08T09:05:50Z",
        "body": "@akarnokd can the observable be unsubscribed on a different thread ? Can it get unsubscribed after the check to isUnsubscribed is done but before calling onNext?\n"
      }
    ]
  },
  {
    "number": 3813,
    "title": "OnSubscribeCombineLatest#MultiSourceProducer request method get different result?",
    "created_at": "2016-03-31T09:17:24Z",
    "closed_at": "2016-04-02T23:13:22Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3813",
    "body": "In request method,there is a line code ':o.unsafeSubscribe(s);' and I find the unsafeSubscribe()'s note is 'Subscribes to an Observable and invokes {@link OnSubscribe} function without any contract protection,error handling, unsubscribe, or execution hooks.'.\nThis is my code:\n\n``` java\nObservable<Long> observable1 = Observable.interval(0, 1000, TimeUnit.MILLISECONDS)\n                    .map(new Func1<Long, Long>() {\n                        @Override\n                        public Long call(Long aLong) {\n                            return aLong * 5;\n                        }\n                    }).take(5);\n            Observable<Long> observable2 = Observable.interval(500, 1500, TimeUnit.MILLISECONDS)\n                    .map(new Func1<Long, Long>() {\n                        @Override\n                        public Long call(Long aLong) {\n                            return aLong * 10;\n                        }\n                    }).take(4);\n            Observable.combineLatest(observable2, observable1, new Func2<Long, Long, Long>() {\n                @Override\n                public Long call(Long aLong, Long aLong2) {\n                    Log.i(\"ppppp\", \"combineLatest aLong = \" + aLong + \"   aLong2 =\" + aLong2);\n                    return aLong + aLong2;\n                }\n            }).subscribe(new Subscriber<Long>() {\n                @Override\n                public void onCompleted() {\n                    System.out.println(\"Sequence complete.\");\n                }\n                @Override\n                public void onError(Throwable e) {\n                    System.err.println(\"Error: \" + e.getMessage());\n                }\n                @Override\n                public void onNext(Long aLong) {\n                    System.out.println(\"combineLatest Next: \" + aLong);\n                }\n            });\n```\n\nI run this code and get two different results.\n(1)\n Next: 0\n Next: 5\n Next: 10\n Next: 20\n Next: 25\n Next: 35\n Next: 40\n Next: 50\n(2)\n Next: 0\n Next: 5\n Next: 15\n Next: 20\n Next: 25\n Next: 35\n Next: 40\n Next: 50\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3813/comments",
    "author": "fanturbo",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-03-31T14:23:08Z",
        "body": "You have two intervals which will fire together at t = 2000 ms where there is no guarantee which will arrive first to the sum in combineLatest.\n"
      },
      {
        "user": "fanturbo",
        "created_at": "2016-04-01T01:37:30Z",
        "body": "@akarnokd thanks.I want to ask another question.combineLatest opreator's explanation is 'Combines a collection of source Observables by emitting an item that aggregates the latest values of **each of the source Observables each time an item is received from any of the source Observables**, where this aggregation is defined by a specified function.\u2018.\nWhen observable1 emit the first item,and the observable2 doesn't emit the first item,why the Combines don't emit the result?In my code I think it should print this:\nNext: 0\nNext: 0\nNext: 5\nNext: 15\nNext: 20\nNext: 25\nNext: 35\nNext: 40\nNext: 50\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-04-01T06:54:04Z",
        "body": "By definition, combineLatest emits only when all sources have emitted at least one item. Otherwise you wouldn't have a full row of values to work with.\n"
      },
      {
        "user": "fanturbo",
        "created_at": "2016-04-01T08:00:53Z",
        "body": "In other words, combineLatest emits when all sources have emiited at least one item,and then if one of source Observables emits an item, the Combines will emits their results?\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-04-01T08:08:24Z",
        "body": "If you have a full row, that is the first time the combiner function is called.\n\n``` java\nPublishSubject<String> a = PublishSubject.create();\nPublishSubject<String> b = PublishSubject.create();\nPublishSubject<String> c = PublishSubject.create();\n\nObservable.combineLatest(a, b, c, (u, v, w) -> u + v + w).subscribe(System.out::println);\n\na.onNext(\"1\");\nb.onNext(\"1\");\na.onNext(\"2\");\nb.onNext(\"2\");\nb.onNext(\"3\");\nSystem.out.println(\"Full row:\");\nc.onNext(\"1\");\n```\n\nIt will print\n\n```\nFull row:\n231\n```\n"
      }
    ]
  },
  {
    "number": 3811,
    "title": "About Subscriber",
    "created_at": "2016-03-30T10:25:44Z",
    "closed_at": "2016-04-02T23:13:45Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3811",
    "body": "When I watch the source code of operators, I found that in order to keep the unsubscribe chain, the parent subscriber always created by two way:\n\n```\nSubscriber<T> parent = new Subscriber(child){ ... };\n```\n\nor\n\n```\nSubscriber<T> parent = new Subscriber{ ... };\nchild.add(parent);\n```\n\nI know that the first one can pass through the producer.\nAnd, What else can decide the choosing? \n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3811/comments",
    "author": "dieyidezui",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-03-30T10:36:31Z",
        "body": "If the parent may issue `unsubscribe` on its own, you have to chose the second pattern because otherwise the call may go downstream and cause trouble.\n"
      }
    ]
  },
  {
    "number": 3788,
    "title": "toList() does not work",
    "created_at": "2016-03-22T07:48:05Z",
    "closed_at": "2016-03-22T10:36:26Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3788",
    "body": "I have one Observable below . \n\n```\nComApi.getInstance().getRegionList().compose(RxUtil.background())\n                .filter(resRegionModel -> resRegionModel != null)\n                .map(ResRegionsModel::getData)\n                .flatMap(Observable::from)\n                .filter(dataEntity -> dataEntity != null)\n                .map(this::convert)\n                .doOnNext(adapter::replaceWith)  // this can work, it will receive data one by one.\n                .toList()\n                .doOnNext(adapter::replaceWith) // but this callback will not be called .while after toList()..it can \n                                                                      // not receive data by once. \n                .doOnError(Throwable::printStackTrace)\n                .subscribe();\n```\n\nthis is my first catch problem while I using toList(). I don't know how to fix this issue.\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3788/comments",
    "author": "sharyuke",
    "comments": [
      {
        "user": "sharyuke",
        "created_at": "2016-03-22T07:57:02Z",
        "body": "```\n\n    /**\n     * \u83b7\u53d6\u533a\u57df\u5217\u8868\n     *\n     * @return \u533a\u57df\u5217\u8868\n     */\n    public Observable<ResRegionsModel> getRegionList() {\n        return Observable.create(subscriber -> subscriber.add(mComInterface.getRegionList(IndoorunSDKDataCenter.APP_KEY_VALUE,\n                IndoorunSDKDataCenter.getInstance().getPhoneUUID(), IndoorunSDKDataCenter.SESSION_KEY_VALUE, \"1\")\n                .doOnNext(resRegionModel -> {\n                    if (resRegionModel != null && resRegionModel.isSuccess()) {\n                        subscriber.add(Observable.just(resRegionModel.getData())\n                                .doOnNext(TableRegionDao.getInstance()::syncInsert)\n                                .flatMap(Observable::from)\n                                .filter(dataEntity -> dataEntity.getFloorList() != null)\n                                .flatMap(dataEntity2 -> Observable.from(dataEntity2.getFloorList()))\n                                .toList()\n                                .flatMap(TableRegionFloorDao.getInstance()::insert)\n                                .onErrorResumeNext(Observable.empty())\n                                .compose(background())\n                                .subscribe());\n                    }\n                })\n                .doOnNext(subscriber::onNext)\n                .compose(background())\n                .subscribe()));\n    }\n\n```\n\nthis is ComApi.getInstance().getRegionList() method. \n"
      },
      {
        "user": "sharyuke",
        "created_at": "2016-03-22T08:01:00Z",
        "body": "when I change  ComApi.getInstance().getRegionList()  to this , and toList() worked. I want to know why\n\n```\n\n    /**\n     * \u83b7\u53d6\u533a\u57df\u5217\u8868\n     *\n     * @return \u533a\u57df\u5217\u8868\n     */\n    public Observable<ResRegionsModel> getRegionList() {\n        return mComInterface.getRegionList(IndoorunSDKDataCenter.APP_KEY_VALUE,\n                IndoorunSDKDataCenter.getInstance().getPhoneUUID(), IndoorunSDKDataCenter.SESSION_KEY_VALUE, \"1\")\n                .doOnNext(resRegionModel -> {\n                    if (resRegionModel != null && resRegionModel.isSuccess()) {\n                        Observable.just(resRegionModel.getData())\n                                .doOnNext(TableRegionDao.getInstance()::syncInsert)\n                                .flatMap(Observable::from)\n                                .filter(dataEntity -> dataEntity.getFloorList() != null)\n                                .flatMap(dataEntity2 -> Observable.from(dataEntity2.getFloorList()))\n                                .toList()\n                                .flatMap(TableRegionFloorDao.getInstance()::insert)\n                                .onErrorResumeNext(Observable.empty())\n                                .compose(background())\n                                .subscribe();\n                    }\n                })\n                .compose(background());\n    }\n```\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-03-22T09:22:56Z",
        "body": "Something doesn't call `onCompleted`, but I can't tell what because you are using some unconventional dataflow structure.\n"
      },
      {
        "user": "sharyuke",
        "created_at": "2016-03-22T09:34:55Z",
        "body": "@akarnokd yes, it is custom Observable ,created by Observable.create(OnSubscriber subscriber), but I think it should work, and it worked actually until toList() method.\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-03-22T10:10:53Z",
        "body": "If you are using `create()`, you are at your own and you have to honor the contracts and expectations of operators. Operators can't know if you just forgot to call `onCompleted` or you never intended to do so. See `just`, `fromCallable` and `from` as alternatives to `create()`.\n"
      }
    ]
  },
  {
    "number": 3786,
    "title": "timeout eats exceptions",
    "created_at": "2016-03-21T09:51:29Z",
    "closed_at": "2016-03-21T16:16:38Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3786",
    "body": "If I have a custom Observable that published some exceptions in onError, chaining such observable with timeout(time, units, MyCustomTimeoutException()) hides exceptions that are sent by custom observable.\n\nSome example.\nSecurityException and IllegalArgumentException never reach my subscriber.\n\n```\nfun getLocation(): Observable<Location> {\n        return requestSingleLocation()\n                .subscribeOn(schedulers.loopedIo)\n                .timeout(LOCATION_REQUEST_TIMEOUT,\n                         TimeUnit.SECONDS,\n                         Observable.error(NetworkLocationTimeoutException()))\n                .first()\n    }\n\n    private fun requestSingleLocation(): Observable<Location> {\n        return Observable.create<Location> { subscriber ->\n\n            try {\n                val knownLocation = locationManager.getLastKnownLocation(LocationManager.NETWORK_PROVIDER)\n                knownLocation?.apply {\n                    subscriber.onNext(this)\n                }\n\n                locationManager.requestSingleUpdate(LocationManager.NETWORK_PROVIDER, LocationChangedListener {\n                    subscriber.onNext(it)\n                    subscriber.onCompleted()\n                }, null)\n\n            } catch (securityException: SecurityException) {\n                subscriber.onError(securityException)\n            } catch (illegalArgumentException: IllegalArgumentException) {\n                subscriber.onError(illegalArgumentException)\n            }\n        }\n    }\n\n```\n\nFollowing test fails:\n\n```\n@Test\n    fun getLocationProcessesSecurityException() {\n        // given\n\n        val securityException = SecurityException()\n        given(locationManager.getLastKnownLocation(LocationManager.NETWORK_PROVIDER)).willReturn(location)\n        given(locationManager.requestSingleUpdate(BDDMockito.anyString(), any(), any())).willThrow(securityException)\n        val testSubscriber = TestSubscriber<Location>()\n\n        // when\n        classToTest.getLocation().subscribe(testSubscriber)\n\n        // then\n        testSubscriber.assertError(securityException)\n    }\n```\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3786/comments",
    "author": "AAverin",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-03-21T10:58:37Z",
        "body": "This test works for me:\n\n``` java\n@Test\npublic void testErrorTimeout() {\n    TestSubscriber<Object> ts =  TestSubscriber.create();\n\n    SecurityException se = new SecurityException();\n    Observable.error(se)\n    .subscribeOn(Schedulers.io())\n    .timeout(1, TimeUnit.SECONDS, Observable.error(new TestException()))\n    .subscribe(ts)\n    ;\n\n    ts.awaitTerminalEvent();\n    ts.assertError(se);\n}\n```\n\nIt seems you did forget to await the terminal event and thus the test thread completes before the error is propagated.\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-03-21T12:11:00Z",
        "body": "Print out the content of `ts.getOnNextEvents()` list before asserting to see if the mocking of `requestSingleUpdate` didn't work (maybe it runs the body but only throws after it?).\n"
      },
      {
        "user": "AAverin",
        "created_at": "2016-03-21T12:19:56Z",
        "body": "I have modified your test example and made it fail\n\n```\n class TestClass {\n\n    }\n\n    @Test\n    fun testErrorTimeout() {\n        val ts: TestSubscriber<TestClass> = TestSubscriber.create()\n\n        val se = SecurityException()\n\n        Observable.merge(Observable.just(TestClass()), Observable.error(SecurityException())).first()\n                .subscribeOn(Schedulers.io())\n                .timeout(1, TimeUnit.SECONDS, Observable.error(NetworkLocationTimeoutException()))\n                .subscribe(ts)\n\n        ts.awaitTerminalEvent()\n        ts.assertError(se)\n    }\n```\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-03-21T12:40:37Z",
        "body": "> first()\n> Returns an Observable that emits only the very first item emitted by the source Observable, or notifies of an NoSuchElementException if the source Observable is empty.\n\nThat also means it cuts any subsequent events, including errors.\n"
      },
      {
        "user": "AAverin",
        "created_at": "2016-03-21T12:41:58Z",
        "body": "Hmm. What I need is either a successful result - TestClass returned, or a custom error message.\nWithout .first() I will get both even in case of success because `timeout` will wait for subsequent events until timer runs out.\n"
      },
      {
        "user": "AAverin",
        "created_at": "2016-03-21T12:43:42Z",
        "body": "Ok, can confirm that sample test passes without `first()`.\nCan you suggest any other way of achieving desired result?\nThanks\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-03-21T12:55:18Z",
        "body": "I'm not sure what you want to achieve. Timeout should not even happen, unless `getLastKnownLocation` or `requestSingleLocation` really take a long time to return or throw.\n"
      },
      {
        "user": "AAverin",
        "created_at": "2016-03-21T12:59:26Z",
        "body": "Well, they can.\nUser may be in a bad connection place and these call can take a long time.\nI need to make sure that if they really take a long time - I get a custom exception to gracefully handle the case in the UI.\n\nImplementation with `first()` works in the UI - I correctly get either a success, or a custom exception in case of long response.\nBut I also need to cover this with tests, and looks like I may have a problem=)\nAnd looks like `first()` might be not a correct solution - if `getLastKnownLocation` will return valid result, but `requestSingleLocation` would throw an exception - my code will not get it\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-03-21T13:11:57Z",
        "body": "You mean the case when timeout happens before the `requestSingleLocation` throws?\n"
      },
      {
        "user": "AAverin",
        "created_at": "2016-03-21T13:16:00Z",
        "body": "`getLastKnownLocation` is a relatevely fast call and will just return null in case there is no last known location\n`requestSingleLocation`, on the other hand, can take a while.\n\nThe problem in my code is that I can't use `first()` at all - I will loose my updated location if there was a known location.\nSo I need a timeout() operator that will work only if there are no items emmited, but would not wait for subsequent items.\n\nRemoving the `first` will lead to a situation when I will get onNext() and then onError() from the timeout because there was no 2nd onNext event with new item - my observable isn't hot and is expected to emmit only single set of items, starting with some cached old result\n"
      },
      {
        "user": "AAverin",
        "created_at": "2016-03-21T15:45:00Z",
        "body": "Issue resolved, thanks for your help a lot!\nProblem was that I didn't call onCompleted() for my custom subscriber due to a small mistake in the code.\nonCompleted correctly unsubscribes timeout\n"
      }
    ]
  },
  {
    "number": 3776,
    "title": "Why does affect not calling subsciber.onCompleted() when applying operator observable.toList()?",
    "created_at": "2016-03-17T10:54:04Z",
    "closed_at": "2016-03-17T11:45:18Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3776",
    "body": "Hi!\n\nIf I create an observable using `Observable.create()` and I don\u2019t call onCompleted on its `subscriber`, following chaining operation `toList()` does not get executed.\n\n``` java\nprivate Observable<List<String>> createObservable() {\n        return Observable.create(subscriber -> {\n                subscriber.onNext(\"\");\n                subscriber.onCompleted(); //if onCompleted is not called the operations chained after calling flatMapIterable() -> toList() do not execute\n            })\n            .map(string -> Arrays.asList(\"1\", \"2\", \"3\"));\n    }\n```\n\n``` java\ncreateObservable()\n                .flatMapIterable(strings -> strings)\n                .map(string -> string)\n                .toList()\n                .map(strings -> strings); //this line is not executed if the source observable does not call onCompleted()\n```\n\nIs this the expected behaviour?\n\nThanks!\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3776/comments",
    "author": "VictorAlbertos",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-03-17T10:57:12Z",
        "body": "Yes. `toList` gives you the complete list of all values, but it has to know when there are no more values. Without `onCompleted()` it can't know you forgot it or it got just delayed a bit.\n"
      }
    ]
  },
  {
    "number": 3736,
    "title": "How to get filtered POJO when used getXXX()?",
    "created_at": "2016-02-27T03:44:59Z",
    "closed_at": "2016-04-11T08:05:13Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3736",
    "body": "```\n.flatMap(new Func1<Area, Observable<Store>>() {\n    @Override\n     public Observable<Store> call(Area area) {\n        return Observable.from(area.getStores());\n     }\n})\n.filter(new Func1<Store, Boolean>() {\n    @Override\n    public Boolean call(Store store) {\n        return store.getName().contains(text);\n    }\n})\n```\n\n> i want to get the filtered **Area**\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3736/comments",
    "author": "deviltsw",
    "comments": [
      {
        "user": "davidmoten",
        "created_at": "2016-02-27T10:16:25Z",
        "body": "One way is to wrap every instance of Store with its Area:\n\n``` java\n.flatMap(area -> \n    Observable.from(area.getStores())\n        .map(store -> new Wrapper(area, store)))\n.filter(wrapper -> wrapper.store().getName().contains(text))\n.map(wrapper ->wrapper.area());\n```\n"
      },
      {
        "user": "kotucz",
        "created_at": "2016-02-27T10:20:16Z",
        "body": "or you could use this trick\n\n```\noa.flatMap(new Func1<Area, Observable<Area>>() {\n        @Override\n        public Observable<Area> call(final Area area) {\n            return Observable.from(area.getStores())\n                    .filter(new Func1<Store, Boolean>() {\n                        @Override\n                        public Boolean call(Store store) {\n                            return store.getName().contains(text);\n                        }\n                    })\n                    .map(new Func1<Store, Area>() {\n                        @Override\n                        public Area call(Store store) {\n                            return area;\n                        }\n                    });\n        }\n    });\n```\n\nbut you maybe do not need to wrap Stores in the `Observable` so this should be fine too\n\n```\noa.filter(new Func1<Area, Boolean>() {\n        @Override\n        public Boolean call(Area area) {\n            return areaHasStoreWithText(area, text);\n        }\n    });\n```\n"
      },
      {
        "user": "davidmoten",
        "created_at": "2016-02-27T10:42:16Z",
        "body": "One thing to note is that my suggestion and @kotucz first suggestion both potentially produce multiple copies of `Area` so you might want to use `.distinct()`.\n"
      }
    ]
  },
  {
    "number": 3735,
    "title": "observable.toBlocking().toFuture().get(timeout, timeUnit) does not timeout",
    "created_at": "2016-02-25T10:10:53Z",
    "closed_at": "2016-03-14T01:25:56Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3735",
    "body": "The use case is pretty simple. Am I getting something wrong or is this a bug ? \n\n```\ndef observable = Observable.from(new CompletableFuture()) // never completes\nobservable.toBlocking().toFuture().get(1, TimeUnit.SECONDS) // never completes either\n```\n\nThis should throw a TimeoutException after a second but actually blocks forever.\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3735/comments",
    "author": "prismec",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-02-25T10:27:30Z",
        "body": "Observing a Future blocks the current thread so when you call `get()` it blocks further up and never gets to the timeout part. This is why there is an overload of `from(Future, long, TimeUnit)` to timeout directly with a future. Now since RxJava is Java 6. It doesn't know about `CompletableFuture` so can't utilize its non-blocking continuation style API that would otherwise allow the `get()` to timeout.\n\nYou can apply `.subscribeOn(Schedulers.io())` to make that first blocking wait happen on a different thread so your main thead is free to wait for the get with timeout.\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-02-25T11:54:32Z",
        "body": "Oh sorry, I wrote the wrong version number. As it seems, both RxJava 1 and 2 are set out to remain Java **6** compatible and thus we can't really support those newer APIs in the core library. Your best bet is to find some other library and conversions or write the necessary source operator yourself.\n"
      }
    ]
  },
  {
    "number": 3723,
    "title": "SerializedBehaviorSubject",
    "created_at": "2016-02-19T20:33:24Z",
    "closed_at": "2016-02-23T08:19:16Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3723",
    "body": "Looking at the changes in #2470, a useful `getValue()` method was added to `BehaviorSubject`. This goes away though if you want to serialize it. Would there be feasible to have something like a `SerializedBehaviorSubject` that maintains the API of `BehaviorSubject`?\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3723/comments",
    "author": "ZacSweers",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-02-19T20:39:01Z",
        "body": "You can keep a reference to the original BehaviorSubject; the method is threadsafe by itself.\n"
      }
    ]
  },
  {
    "number": 3716,
    "title": "flatMapIterable and toList combination issue",
    "created_at": "2016-02-16T08:42:14Z",
    "closed_at": "2016-02-17T06:22:43Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3716",
    "body": "In the following code the \"three\" and \"done\" never appears in the output. Looks like the problem is in `toList` call. Am i using it wrong?\n\n```\nPublishSubject<Boolean> mBooleanPublishSubject = PublishSubject.create();\nObservable<Boolean> observable = mBooleanPublishSubject.asObservable().share();\nobservable\n        .doOnNext(__ -> System.out.println(\"one\"))\n        .flatMap(__ -> Observable.just(Arrays.asList(1, 2, 3, 4)))\n        .flatMapIterable(number -> number)\n        .doOnNext(v -> System.out.println(\"two \" + v))\n        .toList()\n        .doOnNext(v -> System.out.println(\"three \" + v))\n        .subscribe(v -> System.out.println(\"done\"));\nmBooleanPublishSubject.onNext(true);\n```\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3716/comments",
    "author": "httpdispatch",
    "comments": [
      {
        "user": "MyDogTom",
        "created_at": "2016-02-16T14:09:30Z",
        "body": "`toList` waits for `onCompleted` event. In your case there is no `onCompleted` event. Add `mBooleanPublishSubject.onCompleted();` and you will see others outputs.\n"
      },
      {
        "user": "httpdispatch",
        "created_at": "2016-02-17T06:22:43Z",
        "body": "Thanks for the explanation. It works like this\n\n```\nPublishSubject<Boolean> mBooleanPublishSubject = PublishSubject.create();\n        Observable<Boolean> observable = mBooleanPublishSubject.asObservable().share();\n        observable\n                .doOnNext(__ -> System.out.println(\"one\"))\n                .flatMap(__ -> Observable.just(Arrays.asList(1, 2, 3, 4))\n                        .flatMapIterable(number -> number)\n                        .doOnNext(v -> System.out.println(\"two \" + v))\n                        .toList()\n                        .doOnNext(v -> System.out.println(\"three \" + v)))\n                .doOnNext(v -> System.out.println(\"four \" + v))\n                .subscribe(v -> System.out.println(\"done\"));\n        mBooleanPublishSubject.onNext(true);\n        mBooleanPublishSubject.onNext(true);\n```\n"
      }
    ]
  },
  {
    "number": 3656,
    "title": "Take and debounce usage",
    "created_at": "2016-01-29T10:30:55Z",
    "closed_at": "2016-01-29T12:20:44Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3656",
    "body": "I have the next test case\n\n``` @Test\n    public void testLimitAndPublishSubject() throws InterruptedException {\n        PublishSubject<Boolean> mBooleanPublishSubject = PublishSubject.create();\n        mBooleanPublishSubject.asObservable()\n                .doOnEach(__ -> System.out.println(\"on value emitted \"+System.currentTimeMillis()))\n                .take(1)\n                .doOnEach(__ -> System.out.println(\"on value emitted 2 \"+System.currentTimeMillis()))\n                .debounce(1000, TimeUnit.MILLISECONDS)\n                .doOnEach(__ -> System.out.println(\"on value emitted 3 \"+System.currentTimeMillis()))\n                .subscribe(__ -> System.out.println(\"done \"+System.currentTimeMillis()));\n        mBooleanPublishSubject.onNext(true);\n        Thread.sleep(1000);\n        mBooleanPublishSubject.onNext(true);\n        Thread.sleep(2000);\n    }\n```\n\nand the output is\n\n```\non value emitted 1454063289770\non value emitted 2 1454063289770\non value emitted 2 1454063289779\non value emitted 3 1454063289780\ndone 1454063289780\non value emitted 3 1454063289780\n```\n\nI can't figure out why the `on value emitted 2` and `on value emitted 3` appears in the log twice and why the debounce delay doesn't work. Can somebody please help?\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3656/comments",
    "author": "httpdispatch",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-01-29T11:47:03Z",
        "body": "Hi. The debounce doesn't work because with `take(1)` you immediately complete the stream which forces debounce to emit (because no further value will come thus it's safe to emit the last value).\n\nAs for why the duplication, doesn't look to me right either so I'll investigate it further.\n"
      },
      {
        "user": "httpdispatch",
        "created_at": "2016-01-29T11:49:54Z",
        "body": "Thank You for the help. Should i use flatMap or defer to overcome the debounce issue?\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-01-29T11:50:54Z",
        "body": "The reason you see the duplication because you peek via `doOnEach` which is get called for `onNext` and `onCompleted` in your test. You can see this if you append the `__` to the output:\n\n``` java\n.doOnEach(__ -> System.out.println(\"on value emitted \"+System.currentTimeMillis() + __))\n```\n\nwhich prints:\n\n```\non value emitted 1454068146563[rx.Notification@1e307009 OnNext true]\non value emitted 2 1454068146563[rx.Notification@1e307009 OnNext true]\non value emitted 2 1454068146565[rx.Notification@4edde6e5 OnCompleted]\non value emitted 3 1454068146565[rx.Notification@1e307009 OnNext true]\ndone 1454068146565\non value emitted 3 1454068146565[rx.Notification@4edde6e5 OnCompleted]\n```\n\nIf you are not interested in all the event types, use `doOnNext` instead.\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-01-29T11:53:30Z",
        "body": "> Thank You for the help. Should i use flatMap or defer to overcome the debounce issue?\n\nThat do you want to achieve in the first place? Using `take(1).debounce()` is pointless because there won't be more values for debounce to work on.\n"
      },
      {
        "user": "httpdispatch",
        "created_at": "2016-01-29T11:55:02Z",
        "body": "I want the subscription to work like a replacement for CountDownTimer. When first event arrives - timer starts. All next events should be ignored\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-01-29T11:57:03Z",
        "body": "In this case, you can use delay instead:\n\n``` java\nsource.take(1).delay(1, TimeUnit.SECONDS)...\n```\n"
      }
    ]
  },
  {
    "number": 3611,
    "title": "GroupedObservable -> toBlocking() - hang forever",
    "created_at": "2016-01-11T13:31:57Z",
    "closed_at": "2016-01-11T20:42:51Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3611",
    "body": "Found an issue where `groupObservable.toBlocking()` hangs.\n\n`rxjava:1.1.0`\n\n```\nObservable\n            .just(1, 1, 2, 3, 4, 4, 5)\n            .groupBy(new Func1<Integer, Boolean>() {\n                @Override\n                public Boolean call(Integer integer) {\n                    return integer % 2 == 0;\n                }\n            }).subscribe(new Action1<GroupedObservable<Boolean, Integer>>() {\n            @Override\n            public void call(GroupedObservable<Boolean, Integer> grouped) {\n                List<Integer> first = grouped.toList().toBlocking().first();\n                Timber.d(first.size() + \" (Even: \" + grouped.getKey() + \")\");\n            }\n        });\n```\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3611/comments",
    "author": "palaima",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-01-11T15:47:43Z",
        "body": "Hi. This is expected as the `toBlocking` gives access to blocking functions that may block the sequence. In this case, the problem is that `toList` expects a complete stream and won't emit until it receives an `onCompleted` event, Since you applied `toBlocking().first()`, that will block the current thread until it receives a single element which `toList` can't ever produce; the whole chain up to the producing `just` is blocked. The usual solution is to use `flatMap` and do some non-blocking processing with `GroupedObservable`:\n\n``` java\nObservable.just(1, 1, 2, 3, 4, 4, 5)\n.groupBy(v -> v % 2 == 0)\n.flatMap(g -> g.toList().doOnNext(first ->\n    Timber.d(first.size() + \" (Even: \" + g.getKey() + \")\")).ignoreElements())\n.subscribe(v -> { }, Throwable::printStackTrace);\n```\n"
      }
    ]
  },
  {
    "number": 3608,
    "title": "Computation Scheduler stopping/slowing items from processing",
    "created_at": "2016-01-07T16:02:33Z",
    "closed_at": "2016-01-07T20:03:19Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3608",
    "body": "I am having a problem with trying to multi-thread my application to improve performance. My actual application follows a similar structure to the code below (except using real data and doing real work). I am using a flatMap so that I can simultaneously process the items on mutliple threads since the map work can potentially take a lot of time. \n\nWhat I am seeing, is when an item takes a long time to process in the map, it stops the items from being processed by other threads in the pool. In this example, I am seeing 11 items waiting till after the \"Done Sleeping...\" to be processed. The point of the multi-threading is for those items to be all processed in parallel with the item that is processing slowly.\n\nI noticed by switching to a FixedThreadPool Scheduler, it works as expected and the other threads pick up all the items remaining to be processed. \n\nWhy does the computation scheduler act like this? Is it a bug, or is there something I am not understanding?\n\nThe code snippet is in Groovy and I am using RxJava 1.1.0.\n\n```\nimport rx.Observable\nimport rx.Scheduler\nimport rx.schedulers.Schedulers\n\nimport java.util.concurrent.CountDownLatch\nimport java.util.concurrent.Executors\n\ndef threadpool = Executors.newFixedThreadPool(8)\ndef latch = new CountDownLatch(1)\n\n// Using a fixed thread pool works\n//Scheduler scheduler = Schedulers.from(threadpool)\n\n// Using the computation thread pool doesn't\nScheduler scheduler = Schedulers.computation()\n\nObservable.from(1..100).flatMap {\n    Observable.just(it).subscribeOn(scheduler).map {\n        if (it == 5) {\n            println \"${Thread.currentThread().name} - Sleeping... ${it}\"\n            // simulate long work here - only on certain items\n            Thread.sleep(15_000)\n            println \"${Thread.currentThread().name} - Done Sleeping... ${it}\"\n        }\n        return it\n    }\n}.subscribe ({\n    println \"${Thread.currentThread().name} - Got a num: ${it}\"\n}, {\n    println \"Error\"\n    it.printStackTrace()\n    threadpool.shutdown()\n    latch.countDown()\n}, {\n    println 'Complete'\n    threadpool.shutdown()\n    latch.countDown()\n})\nlatch.await()\n```\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3608/comments",
    "author": "ottboy4",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-01-07T17:30:24Z",
        "body": "Hi. This code doesn't exhibit any unexpected delays: it emits all but one value and waits for the 15s sleep. I get a bunch of thread prints on my i7 4770K (4 core, 8 threads)\n\n``` java\nObservable.range(1, 100)\n    .flatMap(v -> Observable.just(v)\n            .subscribeOn(Schedulers.computation())\n            .map(u -> {\n                System.out.printf(\"P | %s: %s%n\", Thread.currentThread(), u);\n                if (u == 5) {\n                    try {\n                        Thread.sleep(15_000);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }\n                return u;\n            }))\n    .doOnNext(v -> {\n        System.out.printf(\"  | %s: %s%n\", Thread.currentThread(), v);\n    }).toBlocking().subscribe();\n```\n\nBecause `flatMap` routes to a single thread, it may get stuck with one particular thread when merged, but it shouldn't block of the other threads.\n"
      },
      {
        "user": "ottboy4",
        "created_at": "2016-01-07T17:50:46Z",
        "body": "akarnokd,\n\nHere is the exact output when I run the java code from your comment (I added in a timestamp on the print outs).\n\nNotice how 13, 21, 29, 37, etc do not get processed till After 5 prints out in the doOnNext? So you are seeing different results than this?\n\nI am using java 8u45.\n\n```\nP | 11:47:47:333 Thread[RxComputationThreadPool-6,5,main]: 4\n  | 11:47:47:336 Thread[RxComputationThreadPool-6,5,main]: 4\nP | 11:47:47:337 Thread[RxComputationThreadPool-6,5,main]: 12\nP | 11:47:47:337 Thread[RxComputationThreadPool-8,5,main]: 6\nP | 11:47:47:337 Thread[RxComputationThreadPool-4,5,main]: 2\nP | 11:47:47:337 Thread[RxComputationThreadPool-2,5,main]: 8\nP | 11:47:47:337 Thread[RxComputationThreadPool-1,5,main]: 7\nP | 11:47:47:337 Thread[RxComputationThreadPool-3,5,main]: 1\nP | 11:47:47:337 Thread[RxComputationThreadPool-5,5,main]: 3\n  | 11:47:47:337 Thread[RxComputationThreadPool-6,5,main]: 12\nP | 11:47:47:337 Thread[RxComputationThreadPool-7,5,main]: 5\nP | 11:47:47:339 Thread[RxComputationThreadPool-6,5,main]: 20\n  | 11:47:47:339 Thread[RxComputationThreadPool-6,5,main]: 20\nP | 11:47:47:340 Thread[RxComputationThreadPool-6,5,main]: 28\n  | 11:47:47:340 Thread[RxComputationThreadPool-6,5,main]: 28\nP | 11:47:47:340 Thread[RxComputationThreadPool-6,5,main]: 36\n  | 11:47:47:341 Thread[RxComputationThreadPool-6,5,main]: 36\nP | 11:47:47:344 Thread[RxComputationThreadPool-6,5,main]: 44\n  | 11:47:47:344 Thread[RxComputationThreadPool-6,5,main]: 44\nP | 11:47:47:344 Thread[RxComputationThreadPool-1,5,main]: 15\nP | 11:47:47:344 Thread[RxComputationThreadPool-5,5,main]: 11\nP | 11:47:47:344 Thread[RxComputationThreadPool-8,5,main]: 14\nP | 11:47:47:345 Thread[RxComputationThreadPool-5,5,main]: 19\nP | 11:47:47:345 Thread[RxComputationThreadPool-5,5,main]: 27\nP | 11:47:47:346 Thread[RxComputationThreadPool-5,5,main]: 35\nP | 11:47:47:346 Thread[RxComputationThreadPool-5,5,main]: 43\nP | 11:47:47:346 Thread[RxComputationThreadPool-5,5,main]: 51\nP | 11:47:47:346 Thread[RxComputationThreadPool-5,5,main]: 59\nP | 11:47:47:347 Thread[RxComputationThreadPool-5,5,main]: 67\nP | 11:47:47:347 Thread[RxComputationThreadPool-5,5,main]: 75\nP | 11:47:47:345 Thread[RxComputationThreadPool-1,5,main]: 23\n  | 11:47:47:345 Thread[RxComputationThreadPool-6,5,main]: 1\nP | 11:47:47:345 Thread[RxComputationThreadPool-3,5,main]: 9\nP | 11:47:47:345 Thread[RxComputationThreadPool-2,5,main]: 16\nP | 11:47:47:345 Thread[RxComputationThreadPool-4,5,main]: 10\nP | 11:47:47:348 Thread[RxComputationThreadPool-2,5,main]: 24\nP | 11:47:47:348 Thread[RxComputationThreadPool-3,5,main]: 17\n  | 11:47:47:348 Thread[RxComputationThreadPool-6,5,main]: 2\nP | 11:47:47:348 Thread[RxComputationThreadPool-2,5,main]: 32\nP | 11:47:47:347 Thread[RxComputationThreadPool-1,5,main]: 31\nP | 11:47:47:347 Thread[RxComputationThreadPool-5,5,main]: 83\nP | 11:47:47:349 Thread[RxComputationThreadPool-5,5,main]: 91\nP | 11:47:47:349 Thread[RxComputationThreadPool-5,5,main]: 99\nP | 11:47:47:345 Thread[RxComputationThreadPool-8,5,main]: 22\nP | 11:47:47:349 Thread[RxComputationThreadPool-1,5,main]: 39\nP | 11:47:47:349 Thread[RxComputationThreadPool-2,5,main]: 40\nP | 11:47:47:350 Thread[RxComputationThreadPool-1,5,main]: 47\nP | 11:47:47:350 Thread[RxComputationThreadPool-2,5,main]: 48\n  | 11:47:47:348 Thread[RxComputationThreadPool-6,5,main]: 3\nP | 11:47:47:348 Thread[RxComputationThreadPool-3,5,main]: 25\nP | 11:47:47:348 Thread[RxComputationThreadPool-4,5,main]: 18\nP | 11:47:47:351 Thread[RxComputationThreadPool-4,5,main]: 26\nP | 11:47:47:351 Thread[RxComputationThreadPool-4,5,main]: 34\nP | 11:47:47:351 Thread[RxComputationThreadPool-3,5,main]: 33\nP | 11:47:47:351 Thread[RxComputationThreadPool-3,5,main]: 41\nP | 11:47:47:352 Thread[RxComputationThreadPool-3,5,main]: 49\nP | 11:47:47:352 Thread[RxComputationThreadPool-3,5,main]: 57\nP | 11:47:47:352 Thread[RxComputationThreadPool-3,5,main]: 65\n  | 11:47:47:350 Thread[RxComputationThreadPool-6,5,main]: 6\nP | 11:47:47:350 Thread[RxComputationThreadPool-2,5,main]: 56\nP | 11:47:47:350 Thread[RxComputationThreadPool-1,5,main]: 55\nP | 11:47:47:350 Thread[RxComputationThreadPool-8,5,main]: 30\nP | 11:47:47:353 Thread[RxComputationThreadPool-2,5,main]: 64\nP | 11:47:47:352 Thread[RxComputationThreadPool-3,5,main]: 73\n  | 11:47:47:353 Thread[RxComputationThreadPool-6,5,main]: 7\nP | 11:47:47:351 Thread[RxComputationThreadPool-4,5,main]: 42\n  | 11:47:47:354 Thread[RxComputationThreadPool-6,5,main]: 8\nP | 11:47:47:354 Thread[RxComputationThreadPool-3,5,main]: 81\nP | 11:47:47:354 Thread[RxComputationThreadPool-2,5,main]: 72\nP | 11:47:47:353 Thread[RxComputationThreadPool-8,5,main]: 38\nP | 11:47:47:353 Thread[RxComputationThreadPool-1,5,main]: 63\nP | 11:47:47:355 Thread[RxComputationThreadPool-8,5,main]: 46\nP | 11:47:47:354 Thread[RxComputationThreadPool-2,5,main]: 80\nP | 11:47:47:354 Thread[RxComputationThreadPool-3,5,main]: 89\n  | 11:47:47:354 Thread[RxComputationThreadPool-6,5,main]: 9\nP | 11:47:47:354 Thread[RxComputationThreadPool-4,5,main]: 50\n  | 11:47:47:355 Thread[RxComputationThreadPool-6,5,main]: 10\nP | 11:47:47:355 Thread[RxComputationThreadPool-3,5,main]: 97\n  | 11:47:47:356 Thread[RxComputationThreadPool-6,5,main]: 11\nP | 11:47:47:355 Thread[RxComputationThreadPool-2,5,main]: 88\nP | 11:47:47:356 Thread[RxComputationThreadPool-2,5,main]: 96\nP | 11:47:47:355 Thread[RxComputationThreadPool-8,5,main]: 54\nP | 11:47:47:355 Thread[RxComputationThreadPool-1,5,main]: 71\nP | 11:47:47:357 Thread[RxComputationThreadPool-8,5,main]: 62\n  | 11:47:47:356 Thread[RxComputationThreadPool-6,5,main]: 14\nP | 11:47:47:356 Thread[RxComputationThreadPool-4,5,main]: 58\n  | 11:47:47:357 Thread[RxComputationThreadPool-6,5,main]: 15\nP | 11:47:47:357 Thread[RxComputationThreadPool-8,5,main]: 70\nP | 11:47:47:357 Thread[RxComputationThreadPool-1,5,main]: 79\nP | 11:47:47:357 Thread[RxComputationThreadPool-8,5,main]: 78\n  | 11:47:47:357 Thread[RxComputationThreadPool-6,5,main]: 16\nP | 11:47:47:357 Thread[RxComputationThreadPool-4,5,main]: 66\n  | 11:47:47:358 Thread[RxComputationThreadPool-6,5,main]: 17\nP | 11:47:47:358 Thread[RxComputationThreadPool-8,5,main]: 86\nP | 11:47:47:358 Thread[RxComputationThreadPool-1,5,main]: 87\nP | 11:47:47:358 Thread[RxComputationThreadPool-8,5,main]: 94\n  | 11:47:47:358 Thread[RxComputationThreadPool-6,5,main]: 18\nP | 11:47:47:358 Thread[RxComputationThreadPool-4,5,main]: 74\nP | 11:47:47:359 Thread[RxComputationThreadPool-4,5,main]: 82\nP | 11:47:47:359 Thread[RxComputationThreadPool-4,5,main]: 90\nP | 11:47:47:358 Thread[RxComputationThreadPool-1,5,main]: 95\n  | 11:47:47:359 Thread[RxComputationThreadPool-6,5,main]: 19\nP | 11:47:47:363 Thread[RxComputationThreadPool-4,5,main]: 98\n  | 11:47:47:363 Thread[RxComputationThreadPool-6,5,main]: 22\n  | 11:47:47:364 Thread[RxComputationThreadPool-6,5,main]: 23\n  | 11:47:47:364 Thread[RxComputationThreadPool-6,5,main]: 24\n  | 11:47:47:364 Thread[RxComputationThreadPool-6,5,main]: 25\n  | 11:47:47:364 Thread[RxComputationThreadPool-6,5,main]: 26\n  | 11:47:47:364 Thread[RxComputationThreadPool-6,5,main]: 27\n  | 11:47:47:364 Thread[RxComputationThreadPool-6,5,main]: 30\n  | 11:47:47:364 Thread[RxComputationThreadPool-6,5,main]: 31\n  | 11:47:47:365 Thread[RxComputationThreadPool-6,5,main]: 32\n  | 11:47:47:365 Thread[RxComputationThreadPool-6,5,main]: 33\n  | 11:47:47:365 Thread[RxComputationThreadPool-6,5,main]: 34\n  | 11:47:47:365 Thread[RxComputationThreadPool-6,5,main]: 35\n  | 11:47:47:365 Thread[RxComputationThreadPool-6,5,main]: 38\n  | 11:47:47:365 Thread[RxComputationThreadPool-6,5,main]: 39\n  | 11:47:47:365 Thread[RxComputationThreadPool-6,5,main]: 40\n  | 11:47:47:366 Thread[RxComputationThreadPool-6,5,main]: 41\n  | 11:47:47:366 Thread[RxComputationThreadPool-6,5,main]: 42\n  | 11:47:47:366 Thread[RxComputationThreadPool-6,5,main]: 43\n  | 11:47:47:366 Thread[RxComputationThreadPool-6,5,main]: 46\n  | 11:47:47:366 Thread[RxComputationThreadPool-6,5,main]: 47\n  | 11:47:47:366 Thread[RxComputationThreadPool-6,5,main]: 48\n  | 11:47:47:366 Thread[RxComputationThreadPool-6,5,main]: 49\n  | 11:47:47:367 Thread[RxComputationThreadPool-6,5,main]: 50\n  | 11:47:47:367 Thread[RxComputationThreadPool-6,5,main]: 51\n  | 11:47:47:367 Thread[RxComputationThreadPool-6,5,main]: 54\n  | 11:47:47:367 Thread[RxComputationThreadPool-6,5,main]: 55\n  | 11:47:47:368 Thread[RxComputationThreadPool-6,5,main]: 56\n  | 11:47:47:368 Thread[RxComputationThreadPool-6,5,main]: 57\n  | 11:47:47:368 Thread[RxComputationThreadPool-6,5,main]: 58\n  | 11:47:47:368 Thread[RxComputationThreadPool-6,5,main]: 59\n  | 11:47:47:368 Thread[RxComputationThreadPool-6,5,main]: 62\n  | 11:47:47:368 Thread[RxComputationThreadPool-6,5,main]: 63\n  | 11:47:47:369 Thread[RxComputationThreadPool-6,5,main]: 64\n  | 11:47:47:370 Thread[RxComputationThreadPool-6,5,main]: 65\n  | 11:47:47:370 Thread[RxComputationThreadPool-6,5,main]: 66\n  | 11:47:47:370 Thread[RxComputationThreadPool-6,5,main]: 67\n  | 11:47:47:370 Thread[RxComputationThreadPool-6,5,main]: 70\n  | 11:47:47:370 Thread[RxComputationThreadPool-6,5,main]: 71\n  | 11:47:47:374 Thread[RxComputationThreadPool-6,5,main]: 72\n  | 11:47:47:375 Thread[RxComputationThreadPool-6,5,main]: 73\n  | 11:47:47:375 Thread[RxComputationThreadPool-6,5,main]: 74\n  | 11:47:47:375 Thread[RxComputationThreadPool-6,5,main]: 75\n  | 11:47:47:375 Thread[RxComputationThreadPool-6,5,main]: 78\n  | 11:47:47:375 Thread[RxComputationThreadPool-6,5,main]: 79\n  | 11:47:47:375 Thread[RxComputationThreadPool-6,5,main]: 80\n  | 11:47:47:375 Thread[RxComputationThreadPool-6,5,main]: 81\n  | 11:47:47:376 Thread[RxComputationThreadPool-6,5,main]: 82\n  | 11:47:47:376 Thread[RxComputationThreadPool-6,5,main]: 83\n  | 11:47:47:376 Thread[RxComputationThreadPool-6,5,main]: 86\n  | 11:47:47:376 Thread[RxComputationThreadPool-6,5,main]: 87\n  | 11:47:47:376 Thread[RxComputationThreadPool-6,5,main]: 88\n  | 11:47:47:376 Thread[RxComputationThreadPool-6,5,main]: 89\n  | 11:47:47:376 Thread[RxComputationThreadPool-6,5,main]: 90\n  | 11:47:47:377 Thread[RxComputationThreadPool-6,5,main]: 91\n  | 11:47:47:377 Thread[RxComputationThreadPool-6,5,main]: 94\n  | 11:47:47:377 Thread[RxComputationThreadPool-6,5,main]: 95\n  | 11:47:47:377 Thread[RxComputationThreadPool-6,5,main]: 96\n  | 11:47:47:377 Thread[RxComputationThreadPool-6,5,main]: 97\n  | 11:47:47:377 Thread[RxComputationThreadPool-6,5,main]: 98\n  | 11:47:47:378 Thread[RxComputationThreadPool-6,5,main]: 99\nP | 11:47:47:378 Thread[RxComputationThreadPool-6,5,main]: 52\n  | 11:47:47:378 Thread[RxComputationThreadPool-6,5,main]: 52\nP | 11:47:47:378 Thread[RxComputationThreadPool-6,5,main]: 60\n  | 11:47:47:378 Thread[RxComputationThreadPool-6,5,main]: 60\nP | 11:47:47:379 Thread[RxComputationThreadPool-6,5,main]: 68\n  | 11:47:47:379 Thread[RxComputationThreadPool-6,5,main]: 68\nP | 11:47:47:379 Thread[RxComputationThreadPool-6,5,main]: 76\n  | 11:47:47:379 Thread[RxComputationThreadPool-6,5,main]: 76\nP | 11:47:47:379 Thread[RxComputationThreadPool-6,5,main]: 84\n  | 11:47:47:379 Thread[RxComputationThreadPool-6,5,main]: 84\nP | 11:47:47:380 Thread[RxComputationThreadPool-6,5,main]: 92\n  | 11:47:47:380 Thread[RxComputationThreadPool-6,5,main]: 92\nP | 11:47:47:380 Thread[RxComputationThreadPool-6,5,main]: 100\n  | 11:47:47:380 Thread[RxComputationThreadPool-6,5,main]: 100\n  | 11:48:02:339 Thread[RxComputationThreadPool-7,5,main]: 5\nP | 11:48:02:339 Thread[RxComputationThreadPool-7,5,main]: 13\n  | 11:48:02:339 Thread[RxComputationThreadPool-7,5,main]: 13\nP | 11:48:02:339 Thread[RxComputationThreadPool-7,5,main]: 21\n  | 11:48:02:340 Thread[RxComputationThreadPool-7,5,main]: 21\nP | 11:48:02:340 Thread[RxComputationThreadPool-7,5,main]: 29\n  | 11:48:02:340 Thread[RxComputationThreadPool-7,5,main]: 29\nP | 11:48:02:340 Thread[RxComputationThreadPool-7,5,main]: 37\n  | 11:48:02:340 Thread[RxComputationThreadPool-7,5,main]: 37\nP | 11:48:02:340 Thread[RxComputationThreadPool-7,5,main]: 45\n  | 11:48:02:340 Thread[RxComputationThreadPool-7,5,main]: 45\nP | 11:48:02:340 Thread[RxComputationThreadPool-7,5,main]: 53\n  | 11:48:02:340 Thread[RxComputationThreadPool-7,5,main]: 53\nP | 11:48:02:341 Thread[RxComputationThreadPool-7,5,main]: 61\n  | 11:48:02:341 Thread[RxComputationThreadPool-7,5,main]: 61\nP | 11:48:02:341 Thread[RxComputationThreadPool-7,5,main]: 69\n  | 11:48:02:341 Thread[RxComputationThreadPool-7,5,main]: 69\nP | 11:48:02:341 Thread[RxComputationThreadPool-7,5,main]: 77\n  | 11:48:02:341 Thread[RxComputationThreadPool-7,5,main]: 77\nP | 11:48:02:341 Thread[RxComputationThreadPool-7,5,main]: 85\n  | 11:48:02:341 Thread[RxComputationThreadPool-7,5,main]: 85\nP | 11:48:02:341 Thread[RxComputationThreadPool-7,5,main]: 93\n  | 11:48:02:341 Thread[RxComputationThreadPool-7,5,main]: 93\n```\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-01-07T18:32:26Z",
        "body": "Okay, now I see it. What happens is that the threads of the computation scheduler get assigned to in a round-robin fashion, the 13th, 21th, etc value will queue up behind 5 and won't get executed until the sleep runs out.\n\nThe reason the fixed threadpool works is because it doesn't have value-to-thread pinning like the computation scheduler. Since each value runs individually, a pool thread can pick it any time and execute it; nobody has to wait on a sleeping thread if there are enough available threads.\n"
      },
      {
        "user": "ottboy4",
        "created_at": "2016-01-07T19:21:11Z",
        "body": "Great explanation. I believe I understand it now.\n\nHowever, why is it that the computation scheduler performs like that? Is there a benefit of doing it that way?\nFrom what I can see in this example I would rather have the functionality of the fixed thread pool over using the computation scheduler. \n\nThe main reason this is an issue is I specify maxConcurrent in the flatMap (since my producer produces items faster than my threads can process the items). Which this now causes the rest of the items to not be processed till my slow thread finishes.\n\nTry this code now, with the maxConcurrent specified. Now you should see that it processes about half the items and stops (waiting on the slow thread), then after the slow thread picks up the rest of the items are processed.\n\n```\nObservable.range(1, 100)\n        .flatMap(v -> Observable.just(v)\n                .subscribeOn(Schedulers.computation())\n                .map(u -> {\n                    System.out.printf(\"P | %s: %s%n\", Thread.currentThread(), u);\n                    if (u == 5) {\n                        try {\n                            Thread.sleep(15_000);\n                        } catch (Exception e) {\n                            e.printStackTrace();\n                        }\n                    }\n                    return u;\n                }), 8)\n        .doOnNext(v -> {\n            System.out.printf(\"  | %s: %s%n\", Thread.currentThread(), v);\n        }).toBlocking().subscribe();\n```\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-01-07T19:45:51Z",
        "body": "> Is there a benefit of doing it that way?\n\nYes, schedulers create workers, which are practically threads, that execute the work sequentially in respect of each other. This is in line with the sequential requirement of subscribers thus there is no need and overhead of making every inner component fully thread safe. In addition, this pinning gives cache locality. In summary, it has performance benefits.\n\nUsing `Scheduler.from` doesn't have this same-thread guarantee (although it is sequential still) and hops threads at random. This is generally slower but can handle your blocking situation much better.\n\n> Which this now causes the rest of the items to not be processed till my slow thread finishes.\n\nthreads are round robin assigned to values but this time you can have only 8 concurrent subscriptions. After a dozen elements, all that remains are those who have been assigned the thread that is blocked.\n"
      }
    ]
  },
  {
    "number": 3598,
    "title": "BehaviorSubject deadlocks when using subject.single().toBlocking().single()",
    "created_at": "2016-01-05T00:31:43Z",
    "closed_at": "2016-01-05T16:50:35Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3598",
    "body": "When I use `.single().toBlocking().single()` on a `BehaviorSubject` (where a default item has been set), it will deadlock the following test. When `.take(1).toBlocking().single()` is used, the test completes successfully.\n\n``` java\nSystem.out.println(\"take(1) started\");\nBehaviorSubject.create(\"Item\").take(1).toBlocking().single();\nSystem.out.println(\"take(1) finished\");\n\nSystem.out.println(\"single() started\");\nBehaviorSubject.create(\"Item\").single().toBlocking().single(); // Deadlocks here\nSystem.out.println(\"single() finished\");\n```\n\nAm I doing something wrong here?\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3598/comments",
    "author": "austynmahoney",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-01-05T08:12:51Z",
        "body": "`Observable.single` requires 1 element and 1 completion signal to emit a single item or 2 elements to emit an overflow error. Since there is no more item, the second stream will hang indefinitely. This is the expected behavior.\n"
      }
    ]
  },
  {
    "number": 3557,
    "title": "onErrorResumeNext/OperatorOnErrorResumeNextViaFunction ignoring unsubscription?",
    "created_at": "2015-12-04T09:45:35Z",
    "closed_at": "2015-12-04T13:54:45Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3557",
    "body": "I first wanted to ask, just in case, to check if the behavior I'm going to describe is the expected.\n\nIt happens that using the operator `OperatorOnErrorResumeNextViaFunction` seems to ignore the **unsubscription** event.\n\nI had this code for testing it.\n\n``` java\n        final AtomicBoolean readyToUnsubscribe = new AtomicBoolean(false);\n        final AtomicBoolean readyToFail = new AtomicBoolean(false);\n        final ReentrantLock lock = new ReentrantLock();\n        final Condition rtuCond = lock.newCondition();\n        final Condition rtfCond = lock.newCondition();\n\n\n        Subscription subscribe = Observable.create(\n                new Observable.OnSubscribe<String>() {\n                    @Override\n                    public void call(Subscriber<? super String> subscriber) {\n                        lock.lock();\n                        System.out.println(\"Subscription started: \" + !subscriber.isUnsubscribed());\n                        readyToUnsubscribe.set(true);\n                        rtuCond.signal();\n                        try {\n                            while (!readyToFail.get()) {\n                                rtfCond.await();\n                            }\n                        } catch (InterruptedException e) {\n                            Exceptions.throwIfFatal(e);\n                        } finally {\n                            lock.unlock();\n                        }\n                        System.out.println(\"Gonna fail\");\n                        throw new RuntimeException(\"Yup Crashing Bad!\");\n                    }\n                }\n        )\n                .onErrorResumeNext(\n                        new Func1<Throwable, Observable<? extends String>>() {\n                            @Override\n                            public Observable<? extends String> call(Throwable throwable) {\n                                return Observable.just(\"Recovered from: \" + throwable.getMessage());\n                            }\n                        }\n                )\n                .subscribeOn(Schedulers.io())\n                .subscribe(\n                        new Action1<String>() {\n                            @Override\n                            public void call(String s) {\n                                System.out.println(\"Got message: \" + s);\n                            }\n                        },\n                        new Action1<Throwable>() {\n                            @Override\n                            public void call(Throwable throwable) {\n                                throwable.printStackTrace(System.err);\n                            }\n                        },\n                        new Action0() {\n                            @Override\n                            public void call() {\n                                System.out.println(\"Completed\");\n                            }\n                        }\n                );\n\n        lock.lock();\n        while (!readyToUnsubscribe.get()) {\n            rtuCond.await();\n        }\n        subscribe.unsubscribe();\n        System.out.println(\"Now this is unsubscribed\");\n        readyToFail.set(false);\n        rtfCond.signal();\n        lock.unlock();\n```\n\nWhich gives the output\n\n```\nSubscription started: true\nNow this is unsubscribed\nGonna fail\nGot message: Recovered from: Yup Crashing Bad!\nCompleted\n```\n\nAnd I would have expected none of the Obsever's methods to be called indeed, that is last two lines of output should't be there. But this is my understanding, can somebody confirm if this should be considered a bug, or is it expected behavior of the onErrorResumeNext operator?\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3557/comments",
    "author": "davidgarciaanton",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2015-12-04T10:16:14Z",
        "body": "Unsubscription is best effort so events may still slip through. In particular, `just` ignores backpressure and unsubscription completely. If you use `just(\"Recovered from: \" + throwable.getMessage(), \"\")`, it won't emit anything because that overload is more eager with unsubscription.\n"
      }
    ]
  },
  {
    "number": 3554,
    "title": "Observable.combineLatest ignores onCompleted?",
    "created_at": "2015-12-03T07:23:10Z",
    "closed_at": "2016-02-09T14:13:16Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3554",
    "body": "Hello. This is the code:\n\n``` java\nimport rx.Observable;\nimport rx.subjects.PublishSubject;\n\nfinal class OnNextIngored {\n\n   public static void main(final String[] args) {\n\n      final PublishSubject<Integer> publisher = PublishSubject.create();\n\n      // pass any arg to fail the day!\n      final boolean doFail = args.length != 0;\n\n      final Observable<Integer> possiblyFail\n         = Observable.<Integer>create(subscriber\n                                      -> {\n\n                                         if (doFail) {\n                                            subscriber.onError(new RuntimeException(\"blah\"));\n                                         } else {\n                                            subscriber.onNext(2);\n                                            subscriber.onCompleted();\n                                         }\n                                      });\n\n      publisher\n         .startWith(// combine latest ignores onCompleted ?\n                    Observable.combineLatest(possiblyFail ,\n                                             Observable.just(1),\n                                             (l, r) -> r + l)\n                    .take(2))\n         .onErrorResumeNext(Observable.just(4))\n         .subscribe(i -> {\n               log(\"i is: \" + i);\n            },\n            e -> {\n               log(\"error is: \" + e);\n            },\n            () -> {\n               log(\"completed\");\n            } );\n\n      publisher.onNext(5);\n      publisher.onNext( 6 );\n      publisher.onNext(7);\n   }\n\n   private static void log(final String s) {\n      System.out.println(s);\n   }\n}\n```\n\nDepending on value of doFail (which can be changed by passing arg to test app) the conveyor receives or does not receive onCompleted and thus it does or does not ignore onNext:\n\n```\n[elk@qulix-elktop java-rxjava]$ java -cp rxjava-1.0.16.jar:. OnNextIngored 4\ni is: 4\ncompleted\n[elk@qulix-elktop java-rxjava]$ java -cp rxjava-1.0.16.jar:. OnNextIngored \ni is: 3\ni is: 5\ni is: 6\ni is: 7\n```\n\nIs it expected behavior? If yes, why?\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3554/comments",
    "author": "alosich",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2015-12-03T09:09:46Z",
        "body": "You don't call `publisher.onCompleted()` so the Subscriber won't receive it. If you start it to make error, it completes because the `onErrorResumeNext` receives the error before `publisher` is subscribed by `startWith`.\n"
      }
    ]
  },
  {
    "number": 3541,
    "title": "Recommended way of applying operators to items in sequence of collections?",
    "created_at": "2015-11-26T12:11:41Z",
    "closed_at": "2015-11-26T17:00:04Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3541",
    "body": "When I want to transform the items in collections emitted in a stream, I find myself doing something like this:\n\n``` java\nObservable<List<Integer>> integerLists = \u2026\n// Emits [1, 2, 3], [4, 5, 6]\n\nintegerLists.concatMap(list -> Observable.from(list).map(x -> x * 2).toList())\n// Emits  [2, 4, 6], [8, 10,12]\n```\n\nIs there are cleaner/recommended way to achieve the same that doesn't require the 'Observable.from \u2026 toList' bit?\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3541/comments",
    "author": "danhawkes",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2015-11-26T12:20:52Z",
        "body": "If you want to avoid in-place mutation, you can use Java Streams which looks almost the same:\n\n``` java\nObservable<List<Integer>> source = Observable.just(\n    Arrays.asList(1, 2, 3), Arrays.asList(4, 5, 6));\n\nsource.map(list -> list.stream().map(i -> i * 2).collect(Collectors.toList()))\n.subscribe(System.out::println);\n```\n\nSo essentially the pattern stays the same.\n"
      }
    ]
  },
  {
    "number": 3522,
    "title": "Why does the scan operator only emit the initialValue when receiving the first value from the observable (or on completion)?",
    "created_at": "2015-11-13T14:20:11Z",
    "closed_at": "2015-11-13T14:56:50Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3522",
    "body": "Hello, I am wondering why the scan() method with an initialValue only emits the initialValue when the first value from the observable arrives. I had expected this to happen instantly upon subscription. \n\nFor now, I worked around this issue by NOT providing an initialValue, and adding \".startWith()\" to the observable I am scanning. \n\nIn the `OperatorScan` class:\n\n``` java\n\n        return new Subscriber<T>(child) {\n            ...\n\n            @Override\n            public void onNext(T currentValue) {\n                emitInitialValueIfNeeded(child);\n                ...\n                child.onNext(this.value);\n            }\n\n            @Override\n            public void onError(Throwable e) {\n                child.onError(e);\n            }\n\n            @Override\n            public void onCompleted() {\n                emitInitialValueIfNeeded(child);\n                child.onCompleted();\n            }\n        }\n```\n\nExample scenario: scan an observable that counts from 0 to 4, emitting a number every second.\n\n``` java\nObservable\n    .create(new Observable.OnSubscribe<Integer>() {\n        @Override\n        public void call(Subscriber<? super Integer> subscriber) {\n            for (int i = 0; i < 5; i++) {\n                try {\n                    Thread.sleep(1000);\n                } catch (InterruptedException e) {\n                    subscriber.onError(e);\n                }\n                subscriber.onNext(i);\n            }\n            subscriber.onCompleted();\n        }\n    })\n    .scan(0, new Func2<Integer, Integer, Integer>() {\n        @Override\n        public Integer call(Integer sum, Integer nextNumber) {\n            return sum + nextNumber;\n        }\n    })\n```\n\nThe timeline of this observable would be:\n\n0ms : subscribe()\n1000ms: 0 <- the initial value\n1001ms: 0 <- the acummulated result of 0 + the initial value\n2000ms: 1 <- the accumulated result of 1 + 0\n3000ms: 3 <- the accumulated result of 2 + 1\n4000ms: 6 <- the accumulated result of 3 + 2\n5000ms: 10 <- the accumulated result of 4 + 6\n\nMy question is: why does this happen lazily. Why not immediately call `child.onNext(initialValue)` when the subscription starts? Why does the given example not produce value 0 at 1 ms? \n\nThank you in advance.\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3522/comments",
    "author": "amoerie",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2015-11-13T14:38:30Z",
        "body": "This was a bug with 1.0.14 and has been fixed in 1.0.15. You should, however, switch to 1.0.16 instead as 1.0.15 had a regression bug with null initial value.\n"
      }
    ]
  },
  {
    "number": 3494,
    "title": "switchIfEmpty() causes \"more items arrived than were requested\" in bizarre case",
    "created_at": "2015-11-04T17:19:06Z",
    "closed_at": "2016-02-09T14:04:00Z",
    "labels": [
      "Bug",
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3494",
    "body": "This is the simplest reproduction I could conjure up of this problem:\n\n``` java\n    Observable.just(1)\n        .flatMap(n -> {\n          return Observable.just(null, null)\n              .filter(o -> o != null)\n              .switchIfEmpty(Observable.empty().switchIfEmpty(Observable.just(\"Hello\")));\n        })\n        .subscribe(System.out::println);\n```\n\nThis will spit out `onError` with the error message \"more items arrived than were requested\".\n\nThis appears to be a regression. It works on RxJava 1.0.11 but fails on every version since then (including 1.0.15, the latest).\n\nAdding in a `take(1)` seems to fix the problem (as a workaround).\n\nFor completeness, here is the exception:\n\n```\nException in thread \"main\" rx.exceptions.OnErrorNotImplementedException: more items arrived than were requested\n    at rx.Observable$27.onError(Observable.java:7996)\n    at rx.observers.SafeSubscriber._onError(SafeSubscriber.java:158)\n    at rx.observers.SafeSubscriber.onError(SafeSubscriber.java:119)\n    at rx.internal.util.ScalarSynchronousObservable$2$1.onError(ScalarSynchronousObservable.java:140)\n    at rx.internal.operators.OperatorSwitchIfEmpty$AlternateSubscriber.onError(OperatorSwitchIfEmpty.java:116)\n    at rx.internal.operators.OperatorSwitchIfEmpty$AlternateSubscriber.onError(OperatorSwitchIfEmpty.java:116)\n    at rx.Observable.unsafeSubscribe(Observable.java:8178)\n    at rx.internal.operators.OperatorSwitchIfEmpty$ParentSubscriber.subscribeToAlternate(OperatorSwitchIfEmpty.java:78)\n    at rx.internal.operators.OperatorSwitchIfEmpty$ParentSubscriber.onCompleted(OperatorSwitchIfEmpty.java:71)\n    at rx.Observable$EmptyHolder$1.call(Observable.java:1073)\n    at rx.Observable$EmptyHolder$1.call(Observable.java:1070)\n    at rx.Observable$2.call(Observable.java:162)\n    at rx.Observable$2.call(Observable.java:154)\n    at rx.Observable.unsafeSubscribe(Observable.java:8171)\n    at rx.internal.operators.OperatorSwitchIfEmpty$ParentSubscriber.subscribeToAlternate(OperatorSwitchIfEmpty.java:78)\n    at rx.internal.operators.OperatorSwitchIfEmpty$ParentSubscriber.onCompleted(OperatorSwitchIfEmpty.java:71)\n    at rx.internal.operators.OperatorFilter$1.onCompleted(OperatorFilter.java:42)\n    at rx.internal.operators.OnSubscribeFromIterable$IterableProducer.fastpath(OnSubscribeFromIterable.java:129)\n    at rx.internal.operators.OnSubscribeFromIterable$IterableProducer.request(OnSubscribeFromIterable.java:70)\n    at rx.internal.producers.ProducerArbiter.setProducer(ProducerArbiter.java:126)\n    at rx.internal.operators.OperatorSwitchIfEmpty$ParentSubscriber.setProducer(OperatorSwitchIfEmpty.java:63)\n    at rx.Subscriber.setProducer(Subscriber.java:205)\n    at rx.internal.operators.OnSubscribeFromIterable.call(OnSubscribeFromIterable.java:49)\n    at rx.internal.operators.OnSubscribeFromIterable.call(OnSubscribeFromIterable.java:32)\n    at rx.Observable$2.call(Observable.java:162)\n    at rx.Observable$2.call(Observable.java:154)\n    at rx.Observable$2.call(Observable.java:162)\n    at rx.Observable$2.call(Observable.java:154)\n    at rx.Observable.unsafeSubscribe(Observable.java:8171)\n    at rx.internal.util.ScalarSynchronousObservable$2.call(ScalarSynchronousObservable.java:133)\n    at rx.internal.util.ScalarSynchronousObservable$2.call(ScalarSynchronousObservable.java:125)\n    at rx.Observable.subscribe(Observable.java:8266)\n    at rx.Observable.subscribe(Observable.java:8233)\n    at rx.Observable.subscribe(Observable.java:7987)\n    at net.danlew.experiments.Tester.main(Tester.java:40)\n    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n    at java.lang.reflect.Method.invoke(Method.java:483)\n    at com.intellij.rt.execution.application.AppMain.main(AppMain.java:140)\nCaused by: java.lang.IllegalStateException: more items arrived than were requested\n    at rx.internal.producers.ProducerArbiter.produced(ProducerArbiter.java:98)\n    at rx.internal.operators.OperatorSwitchIfEmpty$AlternateSubscriber.onNext(OperatorSwitchIfEmpty.java:122)\n    at rx.internal.util.ScalarSynchronousObservable$1.call(ScalarSynchronousObservable.java:46)\n    at rx.internal.util.ScalarSynchronousObservable$1.call(ScalarSynchronousObservable.java:35)\n    at rx.Observable.unsafeSubscribe(Observable.java:8171)\n    ... 33 more\n```\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3494/comments",
    "author": "dlew",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2015-11-04T18:32:27Z",
        "body": "The cause for this exception is that `just` doesn't support backpressure and emits immediately. For a workaround, you can apply `onBackpressureBuffer` to `just(\"Hello\")`.\n"
      },
      {
        "user": "davidmoten",
        "created_at": "2015-11-05T04:40:29Z",
        "body": "@dlew Thanks for finding another instance of backpressure failure caused by `just`. I've been collecting them! (#3044). I think it's time backpressure support for `just` happened.\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2015-11-05T16:09:02Z",
        "body": "Fix posted: #3496.\n"
      },
      {
        "user": "zsxwing",
        "created_at": "2015-11-05T23:35:27Z",
        "body": "I remember we don't require that the user's Observable should support backpressure. So the user could just implement an `Observable` like `just(1)`. Right?\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-02-09T14:04:00Z",
        "body": "Just now supports backpressure and will be part of 1.1.1.\n"
      }
    ]
  },
  {
    "number": 3466,
    "title": "SwitchMap with connectable's Replay raise exception",
    "created_at": "2015-10-22T13:31:12Z",
    "closed_at": "2015-10-24T12:02:22Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3466",
    "body": "For the following code:\n\n``` java\nConnectableObservable<Long> replayObs = Observable.interval(3, TimeUnit.SECONDS)\n        .startWith(-5L)\n        .switchMap(aLong -> {\n            if (aLong == 2L) {\n                return Observable.error(new NullPointerException());\n            } else {\n                return Observable.just(aLong);\n            }\n        })\n        .replay(1);\n\nreplayObs.connect(Actions.empty());\n\nreplayObs\n        .subscribe(s -> {\n            Log.wtf(\"MainActivity \", \"call \" + s);\n        }, throwable -> {\n            Log.wtf(\"MainActivity \", throwable);\n        });\n```\n\nIt emmits the following:\n\n```\nMainActivity: call -5\nMainActivity: java.lang.IllegalStateException: more items arrived than were requested\nMainActivity:     at rx.internal.producers.ProducerArbiter.produced(ProducerArbiter.java:98)\n```\n\nI realize that the `.connect` is happening before the first `.subscribe` but if I have `.flatpMap` instead, which has a different producer, it doesn't complain.\n\nThis is the simplest way to raise the exception:\n\n``` java\nConnectableObservable<Long> replayObs = Observable.just(1l)\n        .switchMap(Observable::just)\n    //  .onBackpressureBuffer(1)\n        .replay(1);\n```\n\nAdding a onBackpreassureBuffer(1) before the .replay() solves the problem. Is that a correct solution? Is that a bug in the `ProducerArbiter`?\n\n---\n\nFull stacktrace:\n\n```\njava.lang.IllegalStateException: more items arrived than were requested\n    at rx.internal.producers.ProducerArbiter.produced(ProducerArbiter.java:98)\n    at rx.internal.operators.OperatorSwitch$SwitchSubscriber.emit(OperatorSwitch.java:162)\n    at rx.internal.operators.OperatorSwitch$InnerSubscriber.onNext(OperatorSwitch.java:277)\n    at rx.internal.util.ScalarSynchronousObservable$1.call(ScalarSynchronousObservable.java:46)\n    at rx.internal.util.ScalarSynchronousObservable$1.call(ScalarSynchronousObservable.java:35)\n    at rx.Observable.unsafeSubscribe(Observable.java:7710)\n    at rx.internal.operators.OperatorSwitch$SwitchSubscriber.onNext(OperatorSwitch.java:105)\n    at rx.internal.operators.OperatorSwitch$SwitchSubscriber.onNext(OperatorSwitch.java:60)\n    at rx.internal.operators.OperatorMap$1.onNext(OperatorMap.java:55)\n    at rx.internal.util.ScalarSynchronousObservable$1.call(ScalarSynchronousObservable.java:46)\n    at rx.internal.util.ScalarSynchronousObservable$1.call(ScalarSynchronousObservable.java:35)\n    at rx.Observable$2.call(Observable.java:162)\n    at rx.Observable$2.call(Observable.java:154)\n    at rx.Observable$2.call(Observable.java:162)\n    at rx.Observable$2.call(Observable.java:154)\n    at rx.Observable.unsafeSubscribe(Observable.java:7710)\n    at rx.internal.operators.OperatorReplay.connect(OperatorReplay.java:285)\n    at com.lorentzos.rxexperiment.MainActivity.onCreate(MainActivity.java:42)\n    at android.app.Activity.performCreate(Activity.java:5990)\n    at android.app.Instrumentation.callActivityOnCreate(Instrumentation.java:1106)\n    at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:2309)\n    at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:2418)\n    at android.app.ActivityThread.access$900(ActivityThread.java:154)\n    at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1321)\n    at android.os.Handler.dispatchMessage(Handler.java:102)\n    at android.os.Looper.loop(Looper.java:135)\n    at android.app.ActivityThread.main(ActivityThread.java:5289)\n    at java.lang.reflect.Method.invoke(Native Method)\n    at java.lang.reflect.Method.invoke(Method.java:372)\n    at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:904)\n    at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:699)\n```\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3466/comments",
    "author": "Diolor",
    "comments": [
      {
        "user": "davidmoten",
        "created_at": "2015-10-24T10:36:59Z",
        "body": "What's happening here is that you are using sources that don't support backpressure. `Observable.interval()` doesn't support backpressure so combine it with `.onBackpressureXXX()`. Ditto for `Observable.just` with one parameter (with two or more does support backpressure).\n\nI'm actually intrigued to see this one because I hadn't yet been able to bring about backpressure exceptions using `Observable.just(t)` (see #3044). Thanks!\n"
      },
      {
        "user": "davidmoten",
        "created_at": "2015-10-24T10:43:27Z",
        "body": "Distilling this test case a bit further:\n\nThis one fails with `java.lang.IllegalStateException: more items arrived than were requested`:\n\n``` java\nConnectableObservable<Integer> o = Observable\n    .just(1,2)\n    .switchMap(x -> Observable.just(x))\n    .replay();\no.connect();\no.subscribe();\n```\n\nThis one does not fail:\n\n``` java\nConnectableObservable<Integer> o = Observable\n    .just(1,2)\n    .switchMap(x -> Observable.just(x).onBackpressureBuffer())\n    .replay();\no.connect();\no.subscribe();\n```\n"
      }
    ]
  },
  {
    "number": 3446,
    "title": "How can I use OperatorConcat<T>?",
    "created_at": "2015-10-14T16:31:52Z",
    "closed_at": "2016-02-09T13:56:28Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3446",
    "body": "I'm trying to write an operator `then<R,T>` which ignores all emissions from the source (except errors), and continues with a second Observable when completed.\n\nSomething like:\n\n```\n// Typical Case\nObservable.just(1, 2, 3, 4, 5)\n   .lift(new then<String, Integer>(Observable.just(\"Hello\")))\n   .subscribe(new Action1<String>() {\n      @Override\n      public void call(String s) {\n         // Called once with \"Hello\"\n      });\n\n// Source Errors\nObservable.<Integer>error(new RuntimeException())\n   .lift(new then<String, Integer>(Observable.just(\"Hello\")))  // <-- the second observable should never be subscribed to since the source error'd\n   .subscribe(new Action1<String>() {\n      @Override\n      public void call(String s) {\n         // Not Called\n\n      }, new Action1<Throwable>() {\n      @Override\n      public void call(Throwable e) {\n        System.out.println(\"Error: \"+e); // Should be called with the RuntimeException from above\n\n      }\n   });\n```\n\nI've come up with an implementation using `ignoreElements` + `map` + `concatWith`:\n\n```\n    public static <R, T> Observable<? extends R> then(Observable<T> source, Observable<R> other) {\n        return source\n                .ignoreElements()\n                .map(new Func1<T, R>() {\n                    @Override\n                    public R call(T integer) {\n                        return null;\n                    }\n                }).concatWith(other);\n    }\n```\n\nI'm quite new to writing custom operators, and I can't quite figure out how to translate that static function into an operator. I've written a few operators by composing the provided Operator\\* types, but I'm having trouble with this one.\n\nAny help would be greatly appreciated :)\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3446/comments",
    "author": "fougere-mike",
    "comments": [
      {
        "user": "fougere-mike",
        "created_at": "2015-10-14T17:12:48Z",
        "body": "Ok, well that eliminates the need for my operator, but I'm still interested in how it could be correctly implemented using lift(). I'm sure I'll be writing more operators in the future so I'd like to have a better understanding of how they work. \n\nThis is what I've come up with:\n\n```\n/**\n * Ignores all emissions from the source observable. Once the source completes, the provided\n * observable will be subscribed to. If the source errors, the error will terminate the stream and\n * the provided observable will not be subscribed to.\n *\n * @param <T> The type of objects emitted by the source observable.\n * @param <R> The type of objects emitted by the provided `next` observable.\n */\npublic class then<R, T> implements Observable.Operator<R, T> {\n    private final OperatorIgnoreElements<T> mIgnoreElements;\n    private final OperatorMap<T, R> mMap;\n    private final OperatorConcat<R> mConcat;\n\n    private final Observable<R> mNextObservable;\n\n    public then(Observable<R> nextObservable) {\n        assert( nextObservable != null );\n        mNextObservable = nextObservable;\n        mIgnoreElements = OperatorIgnoreElements.instance();\n        mMap = new OperatorMap<>(new Func1<T, R>() {\n            @Override\n            public R call(T t) {\n                return null;\n            }\n        });\n        mConcat = OperatorConcat.instance();\n    }\n\n    @Override\n    public Subscriber<? super T> call(final Subscriber<? super R> subscriber) {\n        // TODO: Compose operators...\n    }\n}\n```\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2015-10-14T18:29:46Z",
        "body": "This is \"super easy\" to implement as an `Operator`:\n\n``` java\npublic final class Then<T, R> implements Operator<R, T> {\n    final Observable<R> other;\n\n    public Then(Observable<R> other) {\n        this.other = other;\n    }\n\n    @Override\n    public Subscriber<? super T> call(final Subscriber<? super R> t) {\n        MultipleAssignmentSubscription mas = new MultipleAssignmentSubscription();\n        t.add(mas);\n\n        Subscriber<T> parent = new Subscriber<T>() {\n            @Override\n            public void onNext(T t) {\n                // ignored\n            }\n\n            @Override\n            public void onError(Throwable e) {\n                t.onError(e);\n            }\n\n            @Override\n            public void onCompleted() {\n                Subscriber<R> tr = Subscribers.wrap(t);\n                mas.set(tr);\n                other.subscribe(tr);\n            }\n        };\n\n        mas.set(parent);\n\n        return parent;\n    }\n}\n```\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-02-09T13:56:28Z",
        "body": "1) unnecessary\n2) so the unsubscription from the child can target both the first parent and the second subscriber.\n"
      }
    ]
  },
  {
    "number": 3431,
    "title": "Zip$InnerSubscriber does not respect backpressure on RxRingBuffer",
    "created_at": "2015-10-10T01:16:14Z",
    "closed_at": "2015-10-12T20:46:40Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3431",
    "body": "This test throws a `MissingBackpressureException` while attempting to call onNext on the internal RxRingBuffer. This can be solved by adding a `.onBackpressureDrop()` to the interval observable before zipping. \n\n``` java\nObservable<Integer> cache = Observable.range(1, 50).cache().repeat();\nObservable<Long> interval = Observable.interval(10_000, TimeUnit.NANOSECONDS);\nObservable.zip(interval, cache, (i, c) ->c).toBlocking().last();\n```\n\nStacktrace:\n\n```\nException in thread \"main\" java.lang.RuntimeException: rx.exceptions.MissingBackpressureException\n    at rx.observables.BlockingObservable.blockForSingle(BlockingObservable.java:455)\n    at rx.observables.BlockingObservable.last(BlockingObservable.java:219)\n    at wtf.WTF.main(WTF.java:31)\nCaused by: rx.exceptions.MissingBackpressureException\n    at rx.internal.util.RxRingBuffer.onNext(RxRingBuffer.java:352)\n    at rx.internal.operators.OperatorZip$Zip$InnerSubscriber.onNext(OperatorZip.java:329)\n    at rx.internal.operators.OnSubscribeTimerPeriodically$1.call(OnSubscribeTimerPeriodically.java:52)\n    at rx.Scheduler$Worker$1.call(Scheduler.java:120)\n    at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:55)\n    at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n    at java.util.concurrent.FutureTask.run(FutureTask.java:266)\n    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180)\n    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293)\n    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)\n    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\n    at java.lang.Thread.run(Thread.java:745)\n```\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3431/comments",
    "author": "stealthcode",
    "comments": [
      {
        "user": "zsxwing",
        "created_at": "2015-10-10T05:27:59Z",
        "body": "This looks right. `interval` doesn't support `backpressure`. There is nothing to do for `Zip$InnerSubscriber`.\n"
      },
      {
        "user": "stealthcode",
        "created_at": "2015-10-12T20:21:45Z",
        "body": "Thanks,  yes I realized this. I'm not sure that there can be any better solution, but there is no obvious solution from the stack trace since the Zip doesn't have context of the subscriber above it (or which observable's onNext caused the problem).\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2015-10-12T20:43:57Z",
        "body": "This is why 2.0 operators track their clients requested amount and report the MissingBackpressureException themselves.\n"
      }
    ]
  },
  {
    "number": 3379,
    "title": "OnSubscribeCombineLatest#MultiSourceProducer#collectedValues leaks?",
    "created_at": "2015-09-27T18:17:22Z",
    "closed_at": "2015-10-01T10:39:15Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3379",
    "body": "It looks to me that it should be cleared when the child `subscriber` is unsubscribed.\n\nThe issue is that when I keep a subscription this automatically mean that I will keep a reference to the latest emitted value even if the subscription is unsubscribed. This prevents us from using `combineLatest` on memory-heavy objects.\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3379/comments",
    "author": "konmik",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2015-09-27T18:47:51Z",
        "body": "Why do you keep the subscription once the sequence is unsubscribed through it? Even if the array is cleared, its surroundings will keep leaking.\n"
      },
      {
        "user": "konmik",
        "created_at": "2015-09-27T19:07:04Z",
        "body": "I keep subscription because I don't want to attach side-effects to the chain clearing the reference to the subscription when it is completed. I find it a good idea to follow some functional practices when using RxJava.\n\nWhy the environment would leak? The value has been passed into the chain, that's it.\n"
      },
      {
        "user": "konmik",
        "created_at": "2015-09-28T07:46:07Z",
        "body": "So, should I write something like this?\n\n``` java\n    Subscription subscription;\n\n    void connect() {\n        subscription = combineLatest(api.login(), heavyViewThatDisappearsAndAppearsRandomly)\n            .doOnUnsubscribe(() -> subscription = null) // THIS \n            .subscribe( -> view.onLoginCompleted(loginOk));\n    }\n```\n\nLooks super-ugly.\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2015-09-28T08:53:22Z",
        "body": "The setting of the subscription may race with each other. Instead:\n\n``` java\nCompositeSubscription composite = new CompositeSubscription();\n\nvoid connect();\n    Subscriber<T> subscriber = new Subscriber<T>() {\n         // onNext logic here\n    });\n    composite.add(subscriber);\n\n    combineLatest(...)\n    .doOnUnsubscribe(() -> composite.remove(subscriber))\n    .subscribe(subscriber);\n}\n```\n"
      },
      {
        "user": "konmik",
        "created_at": "2015-09-28T09:03:20Z",
        "body": "So, if there is no guarantee that operators will not leak events after unsubscription, should I apply this pattern _always_? I think that having such guarantee would simplify the RxJava usage a lot.\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2015-09-28T09:27:31Z",
        "body": "I've seen some people creating their own `Subscriber` wrapper which has nulls out the reference to the original in case of a terminal event. Otherwise, cleaning up in operators all the time may hinder performance in case the references go away anyways.\n"
      }
    ]
  },
  {
    "number": 3344,
    "title": "subscribe vs unsafeSubscribe",
    "created_at": "2015-09-14T15:56:04Z",
    "closed_at": "2015-09-14T18:19:06Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3344",
    "body": "What's the difference between `subscribe` and `unsafeSubscribe`?\n\nThe javadoc mentions that `unsafeSubscribe` should only be used for `Observable.Operator`, I'm assuming that includes `Observable.OnSubscribe`. Also, it briefly mentions nested subscriptions but it doesn't explain the difference in behavior of `subscribe` and `unsafeSubscribe`.\n\nAlso, is there guidance on when `Subscribers.wrap` should be used?\n\nHere's a snippet that I thought would behave the same, however `unsafeSubscribe` is working and `subscribe` is timing out.\n\n``` java\n  public static Observable<Long> foo() {\n    return Observable.create(subscriber -> {\n      Observable.timer(1, TimeUnit.MILLISECONDS)\n          .unsafeSubscribe(Subscribers.wrap(subscriber));\n    });\n  }\n\n  public static Observable<Long> foo2() {\n    return Observable.create(subscriber -> {\n      Observable.timer(1, TimeUnit.MILLISECONDS)\n          .subscribe(Subscribers.wrap(subscriber));\n    });\n  }\n\n  public static void main(String[] args) {\n    long result = foo().flatMap(value -> foo())\n        .timeout(1, TimeUnit.SECONDS)\n        .toBlocking().single();\n    System.out.println(\"result = \" + result);\n\n\n    long result2 = foo2().flatMap(value -> foo2())\n        .timeout(1, TimeUnit.SECONDS)\n        .toBlocking().single();\n    System.out.println(\"result2 = \" + result2);\n  }\n```\n\n```\nresult = 0\nException in thread \"main\" java.lang.RuntimeException: java.util.concurrent.TimeoutException\n    at rx.observables.BlockingObservable.blockForSingle(BlockingObservable.java:455)\n    at rx.observables.BlockingObservable.single(BlockingObservable.java:331)\n    at Foo.main(Foo.java:39)\n    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n    at java.lang.reflect.Method.invoke(Method.java:483)\n    at com.intellij.rt.execution.application.AppMain.main(AppMain.java:140)\nCaused by: java.util.concurrent.TimeoutException\n    at rx.internal.operators.OperatorTimeoutBase$TimeoutSubscriber.onTimeout(OperatorTimeoutBase.java:169)\n    at rx.internal.operators.OperatorTimeout$1$1.call(OperatorTimeout.java:42)\n    at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:55)\n    at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n    at java.util.concurrent.FutureTask.run(FutureTask.java:266)\n    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180)\n    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293)\n    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)\n    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\n    at java.lang.Thread.run(Thread.java:745)\n```\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3344/comments",
    "author": "vadims",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2015-09-14T16:53:43Z",
        "body": "Hello,\n\nthe difference is that `subscribe` wraps the `Subscriber` into a `SafeSubscriber` which captures exceptions thrown from the wrapped Subscriber's `onXXX` methods and unsubscribes both the upstream and downstream on a terminal event. `unsafeSubscribe` doesn't do this and is mainly there to avoid the wrapping overhead as much as possible.\n\nWhat happens here with `foo2` is that this downstream-directed unsubscription from `SafeSubscriber` cancels the merge operation which then cancels the inner `foo2` call and simply stops emitting anything (not even terminal events) and the next operator - timeout - will time out.\n\nGenerally, I'd warn against using `create` to roll your own source because there are subtle and less-subtle things that can go wrong.\n"
      }
    ]
  },
  {
    "number": 3343,
    "title": " Equivalent with CompletableFuture.complete",
    "created_at": "2015-09-14T06:10:07Z",
    "closed_at": "2015-09-25T18:18:00Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3343",
    "body": "Hi,\nDose Rxjava Observable has equivalent with CompletableFuture.complete?\nlike: CompletableFuture future=new CompletableFuture();\n       ...do  something...\n       future.complete(xxx)\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3343/comments",
    "author": "GrapeBaBa",
    "comments": [
      {
        "user": "benjchristensen",
        "created_at": "2015-09-14T06:25:12Z",
        "body": "You can use a Subject for that type of 'promise' usage. \n\nSubject s = ReplaySubject.create()\n... do something ...\ns.onCompleted()\n\nOr for the more idiomatic approach, create a lazy Observable:\n\nreturn Observable.create(s -> {\n  ... do something ...\n  s.onCompleted()\n});\n\n> On Sep 13, 2015, at 11:10 PM, Chen Kai notifications@github.com wrote:\n> \n> Hi,\n> Dose Rxjava Observable has equivalent with CompletableFuture.complete?\n> like: CompletableFuture future=new CompletableFuture();\n> ...do something...\n> future.complete(xxx)\n> \n> \u2014\n> Reply to this email directly or view it on GitHub.\n"
      }
    ]
  },
  {
    "number": 3338,
    "title": "Should withLatestFrom behave like zip in terms of buffering?",
    "created_at": "2015-09-11T08:44:00Z",
    "closed_at": "2015-09-11T09:06:37Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3338",
    "body": "I've just picked up withLatestFrom and I expected it to behave a bit like zip in terms of buffering source1 until source2 initially emits.  Am I missing something?  Is there something in the pipeline (for what I appreciate is an experimental operator) or could/ should it be enhanced to behave more like zip?\n\nUsing 1.0.13\n\nExamples of both below:\n# Zip Example Test\n\n```\n        testScenario\n                .given()\n                .theStreamUnderTest((s1, s2) -> s1.zipWith(s2, (z, n) -> z + n))\n\n                .when()\n                .theSubscriber().subscribes()\n                .source1().emits(\"a\")\n                .source1().emits(\"b\")\n                .source1().emits(\"c\")\n                .source2().emits(1)\n                .source2().emits(2)\n                .source2().emits(3)\n                .source1().completes()\n\n                .then()\n                .theSubscribers()\n                .renderedStream().isEqualTo(\"[a1]-[b2]-[c3]-|\");\n\n```\n# WithLatestFrom Test\n\n```\n       testScenario\n                .given()\n                .theStreamUnderTest((s1, s2) -> s1.withLatestFrom(s2, (z, n) -> z + n))\n                .theRenderer(s -> s)\n\n                .when()\n                .theSubscriber().subscribes()\n                .source1().emits(\"a\")\n                .source2().emits(1)\n                .source1().emits(\"b\")\n                .source2().emits(2)\n                .source1().emits(\"c\")\n                .source1().completes()\n\n                .then()\n                .theSubscribers()\n                .renderedStream().isEqualTo(\"[a1]-[b1]-[c2]-|\");\n```\n\nActually emits [b1]-[c2]-|\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3338/comments",
    "author": "leonjones1974",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2015-09-11T08:53:38Z",
        "body": "This is by design and matches how combineLatest doesn't combine until all sources have produced at least one value.\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2015-09-11T09:15:05Z",
        "body": "You can achieve this via the following construct:\n\n``` java\nObservable<Integer> source = Observable.range(1, 10);\n\nPublishSubject<Integer> other = PublishSubject.create();\n\nsource\n.delaySubscription(() -> other)\n.withLatestFrom(other, (a, b) -> a + b)\n.subscribe(System.out::println);\n\nother.onNext(10);\n```\n\nIf you excuse me, now I have to file a bugfix against 2.x :)\n"
      }
    ]
  },
  {
    "number": 3187,
    "title": "MissingBackpressureException when not using Backpressure",
    "created_at": "2015-08-25T16:07:45Z",
    "closed_at": "2015-08-25T17:34:52Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3187",
    "body": "Hey, I'm seeing a crash on my Android app but I'm not sure exactly what's causing the crash (Exception included at the bottom). We don't use or request backpressure anywhere in our app. This is on RxJava `1.0.13`. My only thought would be that maybe some other RX operator is doing this.\n\nFor instance, we have a zip operator:\n\n``` Java\nObservable.zip(\n        new ObservableThatRunsInThread1(),\n        new ObservableThatRunsInThread2(),\n        new ObservableThatRunsInThread3(),\n        new ObservableThatRunsInThread4(),\n        new Func4<Object, Object, Object, Object, Response>() {\n            @Override public Response call(Object o1, Object o2, Object o3, Object o4) {\n                return new Response(o1, o2, o3, o4);\n            }\n        }\n);\n```\n\nCould the multiple threads possibly be causing a race condition, or something of the sort? I'm a bit stuck at this point. Thanks!\n\n``` Java\njava.lang.IllegalStateException: Exception thrown on Scheduler.Worker thread. Add `onError` handling.\n       at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:60)\n       at android.os.Handler.handleCallback(Handler.java:739)\n       at android.os.Handler.dispatchMessage(Handler.java:95)\n       at android.os.Looper.loop(Looper.java:145)\n       at android.app.ActivityThread.main(ActivityThread.java:5835)\n       at java.lang.reflect.Method.invoke(Method.java)\n       at java.lang.reflect.Method.invoke(Method.java:372)\n       at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:1399)\n       at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:1194)\nCaused by: rx.exceptions.OnErrorNotImplementedException\n       at rx.Observable$30.onError(Observable.java:7540)\n       at rx.observers.SafeSubscriber._onError(SafeSubscriber.java:154)\n       at rx.observers.SafeSubscriber.onError(SafeSubscriber.java:111)\n       at rx.internal.operators.OperatorObserveOn$ObserveOnSubscriber.pollQueue(OperatorObserveOn.java:197)\n       at rx.internal.operators.OperatorObserveOn$ObserveOnSubscriber$2.call(OperatorObserveOn.java:170)\n       at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:55)\n       at android.os.Handler.handleCallback(Handler.java:739)\n       at android.os.Handler.dispatchMessage(Handler.java:95)\n       at android.os.Looper.loop(Looper.java:145)\n       at android.app.ActivityThread.main(ActivityThread.java:5835)\n       at java.lang.reflect.Method.invoke(Method.java)\n       at java.lang.reflect.Method.invoke(Method.java:372)\n       at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:1399)\n       at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:1194)\nCaused by: rx.exceptions.MissingBackpressureException\n       at rx.internal.operators.OperatorObserveOn$ObserveOnSubscriber.onNext(OperatorObserveOn.java:138)\n       at rx.internal.operators.OnSubscribeTimerPeriodically$1.call(OnSubscribeTimerPeriodically.java:51)\n       at rx.Scheduler$Worker$1.call(Scheduler.java:120)\n       at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:55)\n       at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:422)\n       at java.util.concurrent.FutureTask.run(FutureTask.java:237)\n       at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:152)\n       at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:265)\n       at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1112)\n       at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:587)\n       at java.lang.Thread.run(Thread.java:818)\n```\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3187/comments",
    "author": "ScottPierce",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2015-08-25T16:39:52Z",
        "body": "It appears your periodic timer overflows the observeOn buffer. You have to apply `onBackpressureDrop`.\n"
      },
      {
        "user": "ScottPierce",
        "created_at": "2015-08-25T16:54:17Z",
        "body": "Oh, so this is happening with a timer? I see it now with the `OnSubscribeTimerPeriodically`.\n\nOn all timers should I be applying backpressure drop? If I use RxJava for any sort of timers, in what cases should I be worried about this exception?\n\nThanks for your fast reply!\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2015-08-25T17:02:48Z",
        "body": "If you don't mind losing a tick with a periodic timer then `onBackpressureDrop` should work. Otherwise, if you thing it is just a transitional effect, you can use `onBackpressureBuffer`.\n\nIf you encounter this exception, you should verify all the operators do support backpressure. If not, you need to apply one of the `onBackpressureXXX` methods. If all the operators support backpressure yet you encounter this exception, it is possible that there is a bug in one of the operators and you should report it here.\n"
      },
      {
        "user": "ScottPierce",
        "created_at": "2015-08-25T17:27:47Z",
        "body": "So in instances where we have a long running timer like this:\n\n``` Java\nmSubscription = Observable.timer(0L, 1L, TimeUnit.SECONDS)\n        .observeOn(AndroidSchedulers.mainThread())\n        .subscribe(new Action1<Long>() {\n            @Override public void call(final Long l) {\n            }\n        });\n```\n\nWould you recommend putting the `.onBackpressureDrop()` above or below the `.observeOn()`?\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2015-08-25T17:30:52Z",
        "body": "Above.\n"
      }
    ]
  },
  {
    "number": 3146,
    "title": "OnSubscribeCombineLatest MultiSourceProducer request method",
    "created_at": "2015-08-10T21:06:54Z",
    "closed_at": "2015-09-03T07:31:08Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3146",
    "body": "Why is the AtomicBolean started get and compareAndSet methods both called in the if statement on line 114 of the OnSubscribeCombineLatest class?\n\nif (!started.get() && started.compareAndSet(false, true)) \n\nIs compareAndSet alone not good enough?\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3146/comments",
    "author": "wrightm",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2015-08-10T21:40:21Z",
        "body": "It is much faster that way because after the first call, all subsequent calls would fail the CAS and it costs 15-45 cycles whereas `get()` is likely to  cost 3-10 cycles only. Since `request` is called quite frequently, the optimization helps greatly in reducing the overhead. See the `AtomicPerf` benchmark that measures this effect. \n\nHowever, if said check is likely to get executed once, the extra get actually makes it slightly slower (something to do with how CPUs behave when they read-then-write the same memory location). Therefore, we don't call `get()` in, for example, Subscription implementations.\n"
      }
    ]
  },
  {
    "number": 2958,
    "title": "Backpressure and \"nested Observables\"",
    "created_at": "2015-05-17T09:09:30Z",
    "closed_at": "2015-08-13T00:23:33Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/2958",
    "body": "Hi,\n\nI encountered a behavior with Backpressure that I found weird.\nHere is a working example (in Groovy) with backpressure : \n\n```\nrx.Observable.from([1, 2, 3, 4])\n    .flatMap({ rx.Observable.just(it+1) })\n    .delay(2, java.util.concurrent.TimeUnit.SECONDS)\n    .subscribe(new rx.Subscriber<Integer>() {\n      public void onStart() {\n        request(2);\n      }\n      public void onNext(Integer t) {\n        println(t)\n        request(1);\n      }\n      public void onCompleted() { }\n      public void onError(Throwable e) { }\n    });\n\n// Prints : \n2\n3 //waits 2 seconds here\n4\n5\n```\n\nLet's apply `delay` directly on the Observable into the `flatMap` Operator : \n\n```\nrx.Observable.from([1, 2, 3, 4])\n    .flatMap({rx.Observable.just(it+1).delay(2, java.util.concurrent.TimeUnit.SECONDS)})\n    .subscribe(new rx.Subscriber<Integer>() {\n      public void onStart() {\n        request(2);\n      }\n      public void onNext(Integer t) {\n        println(t)\n        request(1);\n      }\n      public void onCompleted() { }\n      public void onError(Throwable e) { }\n    });\n\n// Prints : \n// waits 2 seconds\n2\n5\n4\n3// In a random order\n```\n\nI can't see why the second one is not acting like the first, printing 2 results, waiting 2 seconds before printing 2 other ones.\nIs this the normal behavior? Why? How should I do to achieve such a thing?\n\nThanks a lot for your hard work and this amazing library ;)\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/2958/comments",
    "author": "HugoCrd",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2015-05-17T11:05:12Z",
        "body": "They work as expected. \n\nThe first case, you should see a 2 second delay before 2 too, but because you delay request(1) as well, the next value will get 2 second delay relative to that.\n\nIn the second case, since all just values are delayed independently and emit from different threads, the end result order is random.\n\nYou can use timeinterval() to see the delays between values.\n"
      },
      {
        "user": "HugoCrd",
        "created_at": "2015-05-17T16:51:34Z",
        "body": "So `rx.Observable.just(it+1)` are all subscribed when I subsribe to the Observable. In that case I understand why they all complete at the same time.\n\nI thought backpressure would allow me to subscribe to whatever[1] is into the `flatMap` when `request(1)` is called (and not before).\n\nWell I got some other solutions to do that, but I was happy to use backpressure in a real case ;)\n\n[1] which in my real world problem is not a `delay` but a long processing\n"
      }
    ]
  },
  {
    "number": 2947,
    "title": "TestObserver thread-safety",
    "created_at": "2015-05-14T01:18:16Z",
    "closed_at": "2015-05-14T14:45:16Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/2947",
    "body": "Disclaimer: I understand, that `TestObserver` and `TestSubscriber` were made for Unit testing purposes, but they are pretty convenient because you can record received notifications and emissions, make assertions and so on, so we used them it in our Integration test and faced problem with thread-safety of `TestObserver`.\n\nThe problem is that `TestObserver` uses `ArrayList` to store notifications and received items, in case of multi-threaded `Observable` `ArrayList` may be corrupted and tests can fail randomly.\n\nWhat do you think about using thread-safe list implementation in `TestObserver`? It should not break public API. I can prepare PR for that.\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/2947/comments",
    "author": "artem-zinnatullin",
    "comments": [
      {
        "user": "benjchristensen",
        "created_at": "2015-05-14T05:21:53Z",
        "body": "None of these types are thread safe and are not supposed to be as Observables are single threaded. We do not serialize by default for performance reasons. \n\nIf you need to serialize a Subject, use the toSerialized() method. An Observer should never need to be thread safe unless an Observable is breaking the contract, in which case use Observable.serialize()\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2015-05-14T13:09:34Z",
        "body": "No. You need to front-serialize a `PublishSubject` via `toSerialized()`. Technically, a concurrent `onNext()` call doesn't break `PublishSubject` itself but observers don't and shouldn't anticipate concurrent calls to their `onXXX` methods.\n"
      }
    ]
  },
  {
    "number": 2608,
    "title": "Run two observables sequentially, using result from first observable in second observable (question)",
    "created_at": "2015-02-05T10:47:15Z",
    "closed_at": "2015-03-11T13:59:21Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/2608",
    "body": "I'm probably overlooking something basic (sorry for that), this seems like it should be easy to do.\n\nI have an Identifier class:\n\n```\nclass Identifier {\n    int id;\n    String value;\n    Ticket[] tickets;\n\n    void setTickets(Ticket[] tickets) { this.tickets = tickets; }\n}\n```\n\nAnd two separate API calls, (1) one for retrieving an identifier based on the identifier value (not the id), and (2) one for retrieving the tickets for an identifier using the identifier id:\n1. `Observable<Identifier> getIdentifier(String identifierValue);`\n2. `Observable<Ticket[]> getTickets(int identifierId);`\n\nI want to create a method with the following signature:\n`Observable<Identifier> getIdentifierWithTickets(String identifierValue);`\n\nthat combines the two observables to create an `Observable<Identifier>` that:\n1. Retrieves the identifier based on the identifierValue.\n2. Retrieves the tickets for that identifier and assigns them to that identifier.\n\nI've tried several operators but I can't find the right one. The `zipWith` operator runs the two observables in parallel so that didn't work. I can perhaps use `flatMap` but then I have to create a new observable that transforms `Observable<Ticket[]>` into `Observable<Identifier>`.\n\nLike I said, I feel that I'm missing something very basic here, anyone please help.\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/2608/comments",
    "author": "riley-van-hengstum",
    "comments": [
      {
        "user": "riley-van-hengstum",
        "created_at": "2015-02-05T11:29:16Z",
        "body": "**Update**\n\nThis is what I have so far:\n\n``` java\npublic Observable<Identifier> getIdentifierWithTickets(String identifierValue) {\n    return service.getIdentifier(identifierValue)\n            .flatMap(new Func1<Identifier, Observable<Identifier>>() {\n                @Override\n                public Observable<Identifier> call(final Identifier identifier) {\n                    return service.getTickets(identifier.getId())\n                            .flatMap(new Func1<Ticket[], Observable<Identifier>>() {\n                                @Override\n                                public Observable<Identifier> call(Ticket[] tickets) {\n                                    identifier.setTickets(tickets);\n                                    return Observable.just(identifier);\n                                }\n                            });\n                }\n            });\n}\n```\n\nThis works, but it seems a bit convoluted. Is there any way to simplify this?\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2015-02-05T11:51:44Z",
        "body": "I think you don't need the second `flatMap`s since you return a single value for each; `map` should do it.\n"
      },
      {
        "user": "riley-van-hengstum",
        "created_at": "2015-02-05T12:58:58Z",
        "body": "@akarnokd Thanks, I overlooked that. This simplifies things:\n\n``` java\npublic Observable<Identifier> getIdentifierWithTickets(String identifierValue) {\n    return service.getIdentifier(identifierValue)\n            .flatMap(new Func1<Identifier, Observable<Identifier>>() {\n                @Override\n                public Observable<Identifier> call(final Identifier identifier) {\n                    return service.getTickets(identifier.getId())\n                            .map(new Func1<Ticket[], Identifier>() {\n                                @Override\n                                public Identifier call(Ticket[] tickets) {\n                                    identifier.setTickets(tickets);\n                                    return identifier;\n                                }\n                            });\n                }\n            });\n}\n```\n"
      },
      {
        "user": "parikshitdutta",
        "created_at": "2018-07-12T12:25:42Z",
        "body": "Probably we can make it a bit less convoluted, besides using map for obvious reason:\r\n\r\n```\r\npublic Observable<Identifier> getIdentifierWithTickets(String identifierValue) {\r\n     return service.getIdentifier(identifierValue)\r\n          .flatMap(identifier -> {\r\n               return service.getTickets(identifier.getId())\r\n                    .map(tickets -> identifier.setTickets(tickets));\r\n          });\r\n}\r\n```\r\n\r\n"
      },
      {
        "user": "scamexdotexe",
        "created_at": "2018-09-20T21:15:49Z",
        "body": "@madnotdead how did you go about that login? My case is quite similar, I have to get the time first from the server and convert it to timestamp and use it as one of the parameters for login (second api call)."
      }
    ]
  },
  {
    "number": 2597,
    "title": "scan with retry",
    "created_at": "2015-02-04T09:33:07Z",
    "closed_at": "2015-05-20T09:09:03Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/2597",
    "body": "Hi, let's say for example I have this code:\n\n``` java\nObservable.range(1,100)\n        .scan(1, (p, i) -> {\n            if (i == 10 && start) {\n                start = false;\n                throw OnErrorThrowable.from(new Exception(\"wow\"));\n            }\n            return p * i;\n        })\n        .retry()\n        .doOnNext(System.out::println)\n        .subscribe();\n```\n\nIts output is:\n\n```\n1\n1\n2\n6\n24\n120\n720\n5040\n40320\n362880\n362880\n1\n1\n2\n6\n24\n120\n720\n5040\n40320\n362880\n3628800\n39916800\n479001600\n1932053504\n...\n```\n\nI want the `retry` operator to cause the observable to start from where it stopped (10 in this case). Is there a way to do this purely, without saving the state etc.?\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/2597/comments",
    "author": "david-hoze",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2015-02-04T09:48:47Z",
        "body": "You could use `distinct()` to skip over or don't throw in the function:\n\n``` java\n(p, i) -> {\n    while (true) {\n        try {\n            if (i == 10 && start) {\n                start = false;\n                throw OnErrorThrowable.from(new Exception(\"wow\"));\n            }\n            break;\n        } catch (Throwable t) {\n        }\n    }\n    return p * i;\n}\n```\n"
      },
      {
        "user": "david-hoze",
        "created_at": "2015-02-04T10:11:56Z",
        "body": "Hi, in my use case I actually need to handle the error in the subscriber, so I need to throw..\nUsing `distinct` like this:\n\n``` java\nObservable.range(1,100)\n        .scan(1, (p, i) -> {\n            if (i == 10 && start) {\n                start = false;\n                throw OnErrorThrowable.from(new Exception(\"wow\"));\n            }\n            return p * i;\n        })\n        .distinct()\n        .retry()\n        .doOnNext(System.out::println)\n        .subscribe();\n```\n\nyields the same behavior, as the first run and the second run of the `interval`+`scan` do not emit consequent non-distinct values (the repetition only happens after 10 cycles).\n\nHowever, for some reason using `distinct` like this (after the `retry`):\n\n``` java\nObservable.range(1,100)\n        .scan(1, (p, i) -> {\n            if (i == 10 && start) {\n                start = false;\n                throw OnErrorThrowable.from(new Exception(\"wow\"));\n            }\n            return p * i;\n        })\n        .retry()\n        .distinct()\n        .doOnNext(System.out::println)\n        .subscribe();\n```\n\noutputs:\n\n```\n1\n2\n6\n24\n120\n720\n5040\n40320\n362880\n```\n\nand stops there.. Couldn't figure out why, is this the desired behavior?\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2015-02-04T10:17:49Z",
        "body": "The latter works for me with 1.0.5 and prints:\n\n```\n1\n2\n6\n24\n120\n720\n5040\n40320\n362880\n3628800\n39916800\n479001600\n1932053504\n1278945280\n2004310016\n2004189184\n-288522240\n-898433024\n109641728\n-2102132736\n-1195114496\n-522715136\n862453760\n-775946240\n2076180480\n-1853882368\n1484783616\n-1375731712\n-1241513984\n1409286144\n738197504\n-2147483648\n0\n```\n"
      },
      {
        "user": "david-hoze",
        "created_at": "2015-02-04T13:57:43Z",
        "body": "Thanks, you're right, after I upgraded it's working.\nI just realized though that the example I gave didn't model the problem I'm trying to solve very well, so I'll try to give a better one:\n\n``` java\nObservable.interval(1, TimeUnit.SECONDS)\n        .map(i -> { Calendar cal = Calendar.getInstance();\n            cal.getTime();\n            SimpleDateFormat sdf = new SimpleDateFormat(\"HH:mm:ss\");\n            return sdf.format(cal.getTime());})\n        .scan(\"\", (times, time) -> {\n            if (time.endsWith(\"5\")) {\n                throw OnErrorThrowable.from(new Exception(\"wow\"));\n            }\n            return times + \",\" + time;\n        })\n        .retry()\n        .doOnNext(System.out::println)\n        .subscribe();\n```\n\nSo now I'm trying to aggregate the emitted times. The output is:\n\n```\n,13:42:40\n,13:42:40,13:42:41\n,13:42:40,13:42:41,13:42:42\n,13:42:40,13:42:41,13:42:42,13:42:43\n,13:42:40,13:42:41,13:42:42,13:42:43,13:42:44\n,13:42:40,13:42:41,13:42:42,13:42:43,13:42:44\n,13:42:46\n,13:42:46,13:42:47\n,13:42:46,13:42:47,13:42:48\n,13:42:46,13:42:47,13:42:48,13:42:49\n,13:42:46,13:42:47,13:42:48,13:42:49,13:42:50\n,13:42:46,13:42:47,13:42:48,13:42:49,13:42:50,13:42:51\n,13:42:46,13:42:47,13:42:48,13:42:49,13:42:50,13:42:51,13:42:52\n,13:42:46,13:42:47,13:42:48,13:42:49,13:42:50,13:42:51,13:42:52,13:42:53\n,13:42:46,13:42:47,13:42:48,13:42:49,13:42:50,13:42:51,13:42:52,13:42:53,13:42:54\n,13:42:46,13:42:47,13:42:48,13:42:49,13:42:50,13:42:51,13:42:52,13:42:53,13:42:54\n,13:42:56\n,13:42:56,13:42:57\n,13:42:56,13:42:57,13:42:58\n,13:42:56,13:42:57,13:42:58,13:42:59\n,13:42:56,13:42:57,13:42:58,13:42:59,13:43:00\n,13:42:56,13:42:57,13:42:58,13:42:59,13:43:00,13:43:01\n...\n```\n\nSo I'm losing the numbers I already got. Can I gracefully handle the error and get the correct aggregation without using state?\n"
      },
      {
        "user": "benjchristensen",
        "created_at": "2015-02-04T17:48:49Z",
        "body": "Generally I'd recommend doing the data validation before the `scan` so that you're filtering out bad data. Especially since your validation does not depend on the accumulated state.\n\nIf you want to be aware of the errors, do a side-effect where you pass the error events off to a logger or different Observable sequence but prevent the terminal state from propagating. This would remove the need for `retry` and error handling inside `scan`.\n"
      },
      {
        "user": "benjchristensen",
        "created_at": "2015-02-04T18:06:31Z",
        "body": "Here are a variety of approaches:\n\n``` java\nimport java.text.SimpleDateFormat;\nimport java.util.Calendar;\nimport java.util.concurrent.TimeUnit;\n\nimport rx.Observable;\nimport rx.exceptions.OnErrorThrowable;\nimport rx.subjects.PublishSubject;\n\npublic class ScanErrorExample {\n\n    public static void main(String... args) {\n        System.out.println(\"scanWithErrorThrownAndDropped -------------------------------\");\n        scanWithErrorThrownAndDropped();\n        System.out.println(\"scanWithErrorThrownAndLogged -------------------------------\");\n        scanWithErrorThrownAndLogged();\n        System.out.println(\"scanWithErrorEvent -------------------------------\");\n        scanWithErrorEvent();\n        System.out.println(\"scanWithFilteredData -------------------------------\");\n        scanWithFilteredData();\n        System.out.println(\"-------------------------------\");\n    }\n\n    public static void scanWithErrorThrownAndDropped() {\n        data()\n                .map(time -> {\n                    if (time.endsWith(\"5\")) {\n                        throw OnErrorThrowable.from(new Exception(\"wow\"));\n                    } else {\n                        return time;\n                    }\n                })\n                .retry()\n                .scan(\"\", (times, time) -> {\n                    return times + \",\" + time;\n                })\n                .take(15)\n                .toBlocking().forEach(System.out::println);\n    }\n\n    public static void scanWithErrorThrownAndLogged() {\n        data()\n                .map(time -> {\n                    if (time.endsWith(\"5\")) {\n                        throw OnErrorThrowable.from(new Exception(\"wow\"));\n                    } else {\n                        return time;\n                    }\n                })\n                .doOnError(e -> System.out.println(\"Error: \" + e))\n                .retry()\n                .scan(\"\", (times, time) -> {\n                    return times + \",\" + time;\n                })\n                .take(15)\n                .toBlocking().forEach(System.out::println);\n    }\n\n    public static void scanWithErrorEvent() {\n        PublishSubject<Exception> errors = PublishSubject.create();\n        errors.forEach(e -> System.out.println(\"Error: \" + e));\n\n        data()\n                .doOnNext(time -> {\n                    if (time.endsWith(\"5\")) {\n                        errors.onNext(new Exception(\"wow\"));\n                        // or just log them\n                    }\n                })\n                .filter(time -> !time.endsWith(\"5\"))\n                .retry()\n                .scan(\"\", (times, time) -> {\n                    return times + \",\" + time;\n                })\n                .take(15)\n                .toBlocking().forEach(System.out::println);\n    }\n\n    public static void scanWithFilteredData() {\n        data()\n                .filter(time -> !time.endsWith(\"5\"))\n                .scan(\"\", (times, time) -> {\n                    return times + \",\" + time;\n                })\n                .take(15)\n                .toBlocking().forEach(System.out::println);\n    }\n\n    public static Observable<String> data() {\n        return Observable.interval(1, TimeUnit.SECONDS)\n                .map(i -> {\n                    Calendar cal = Calendar.getInstance();\n                    cal.getTime();\n                    SimpleDateFormat sdf = new SimpleDateFormat(\"HH:mm:ss\");\n                    return sdf.format(cal.getTime());\n                });\n    }\n\n}\n```\n\nIf you need the error data inside the scan as well, then instead of throwing, convert it to a type that you treat as an event that your scan logic can understand. \n"
      },
      {
        "user": "david-hoze",
        "created_at": "2015-02-04T23:26:12Z",
        "body": "Hi, thanks a lot :+1:, I think the `scanWithErrorEvent` solves my problem.\nAre subjects considered hacky?\nHow about this approach instead:\n\n``` java\n    public static void scanWithErrorObservable() {\n        Observable<String> dataObservable = data();\n\n        dataObservable\n                .filter(time -> !time.endsWith(\"5\"))\n                .scan(\"\", (times, time) -> {\n                    return times + \",\" + time;\n                })\n                .take(15)\n                .toBlocking().forEach(System.out::println);\n\n        dataObservable\n                .filter(time -> time.endsWith(\"5\"))\n                .map(time -> new Exception(\"wow\"))\n                .take(15)\n                .toBlocking().forEach(e -> System.out.println(\"Error: \" + e));\n    }\n```\n\nAlso, on a general note, the fact that error propagation always unsubscribes and the only way to gracefully handle it is to resubscribe seems to limit the fluency of RxJava in a lot of use cases. The solutions suggested here show that there is no fluent way of propagating errors without disrupting the normal flow of events. I think a more straightforward solution will be:\n\n``` java\n    private static class AccumulatedState {\n        private AccumulatedState() {\n            times = \"\";\n        }\n\n        String times;\n        Throwable throwable;\n    }\n\n    public static void scanWithErrorContext() {\n        data()\n                .scan(new AccumulatedState(), (accumulatedState, time) -> {\n                    if (time.endsWith(\"5\"))\n                        accumulatedState.throwable = new Exception(\"wow\");\n                    else {\n                        accumulatedState.throwable = null;\n                        accumulatedState.times = accumulatedState.times + \",\" + time;\n                    }\n                    return accumulatedState;\n                })\n                .take(15)\n                .toBlocking()\n                .forEach(accumulatedState -> {\n                    if (accumulatedState.throwable != null) {\n                        System.out.println(\"Error: \" + accumulatedState.throwable);\n                    } else {\n                        System.out.println(accumulatedState.times);\n                    }\n                });\n    }\n```\n\nBut it seems so generic that it should be part of the framework (something like `subscriber.onSilentError`).\nThanks, Amitai.\n"
      }
    ]
  },
  {
    "number": 2525,
    "title": "How to stop observable execution",
    "created_at": "2015-01-23T18:45:15Z",
    "closed_at": "2015-01-23T20:07:01Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/2525",
    "body": "Hi,\n\nI have some set of observable which I am executing in parallel. I need to get the value of observable who is completing first. If the return value meets my requirement then i need to stop the execution of other observables. I couldn't find the example for that. \n\nI could do this scenario through Callable interface and CompletionService interface from concurrent package.\n\nsample code using concurrent package\n\n```\n@Autowired\nprivate CompletionService<Result> cService;\n\nList<Future<Result>> statusList = new ArrayList<Future<Result>>();\ntry{\nfor(String str: strLst){\n        statusList.add(cService.submit(new GetItemOnCallable(msg)));\n    }\n\n    for(int i =0; i < statusList.size(); i++){\n        Result status = cService.take().get();\n        if(null != status){\n         if(staus.equals(Result.SUCCESS))\n         break;\n    }\n}finally{\nfor(Future<Result> statusFuture: statusList){\n    statusFuture.cancel(true);\n}\n}\n```\n\nIs there any way to achieve this using observable?\nCan someone please help on this.\n\nRegards\nPranesh\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/2525/comments",
    "author": "pradhakrishnan",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2015-01-23T19:07:13Z",
        "body": "We have the `amb` operator which streams the first responding source observable. You could filter your sources then amb them to get the first matching value:\n\n``` java\namb(source1.filter(predicate), source2.filter(predicate))\n```\n"
      },
      {
        "user": "pradhakrishnan",
        "created_at": "2015-01-23T20:01:29Z",
        "body": "It works fine. Thanks Akarnokd. \nI have one question on this. What will happen if none of my source observable meets my filter.\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2015-01-23T20:04:19Z",
        "body": "You get an empty sequence which just calls onCompleted.\n"
      }
    ]
  },
  {
    "number": 1636,
    "title": "How to properly terminal Observable sequences",
    "created_at": "2014-08-27T21:59:04Z",
    "closed_at": "2014-08-29T23:00:46Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/1636",
    "body": "``` java\nObservable<Boolean> obs1;\nObservable<Boolean> obs2;\n\nresult = obs1\n.flatmap(value -> {\n   if (value) {\n      // terminate result observable\n      // the only way i see right now is to do\n      BehaviorSubject<Boolean> terminator = BehaviorSubject.create();\n      terminator.onNext(new TerminateException());\n      return terminator;\n   } else {\n       return obs2;\n   }\n});\n\n```\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/1636/comments",
    "author": "buildbreaker",
    "comments": [
      {
        "user": "headinthebox",
        "created_at": "2014-08-27T22:17:48Z",
        "body": "You just return `Observable.empty()` if you want to terminate successfully, or `Observable.error(new TerminateException())` if you want to terminate unsuccessfully (probably not). \n"
      },
      {
        "user": "buildbreaker",
        "created_at": "2014-08-28T17:33:41Z",
        "body": "Thank you for your response @headinthebox!\n\nI believe I do want to terminate unsuccessfully since at the end of my flatmap as I would like to have an action regardless of what value was originally. I actually have a flatmap chain of similar flatmaps that was mentioned above:\n\n``` java\nresult = obs1\n.flatmap(value -> {\n   if (value) {\n      return Observable.error(new TerminateException());\n   } else {\n       return obs2;\n   }\n})\n.flatmap(value -> {\n  if (value) {\n    return Observable.from(new Object());\n  } else {\n    return Observable.error(newTerminateException());\n  }\n})\n.doOnEach( value -> {\n  // Always do something\n})\n.subscribe(...); \n```\n\nI have tried and having an Observable.error(new TerminateException()) works for this case but I'm not sure if this is the best way to go about the problem.\n"
      },
      {
        "user": "headinthebox",
        "created_at": "2014-08-28T17:42:23Z",
        "body": "It is the best way; if you find yourself using subjects, typically you are _wrong_. \n"
      },
      {
        "user": "benjchristensen",
        "created_at": "2014-08-28T19:08:34Z",
        "body": "You can also use `takeUntil` or `takeWhile` to terminate the source when a condition or event occurs instead of forcing an artificial `onError` event. In other words, unsubscribing is the \"clean shutdown\" approach and `takeUntil` and `takeWhile` are typical approaches to shutting down.\n"
      }
    ]
  },
  {
    "number": 1539,
    "title": "Need help with composition of several observables.",
    "created_at": "2014-08-01T02:38:04Z",
    "closed_at": "2014-08-01T04:47:17Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/1539",
    "body": "``` java\nObservable<String> observable1;\nObservable<Boolean> observable2;\nObservable<Void> observable3;\n```\n\nI need to to create observable3 that will produce values on every change of observable1 when observable2 last value is True.\n\nWill appreciate any help.\n\n(By the way, I'm using Java 6.)\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/1539/comments",
    "author": "buildbreaker",
    "comments": [
      {
        "user": "davidmoten",
        "created_at": "2014-08-01T04:12:10Z",
        "body": "do you mean latest value of obs2 is true or last value?\n"
      },
      {
        "user": "benjchristensen",
        "created_at": "2014-08-01T04:20:22Z",
        "body": "Here are some options that might get you moving in the direction you want:\n\n``` java\nimport java.util.concurrent.TimeUnit;\n\nimport rx.Observable;\n\npublic class CombineLatestAndFilter {\n\n    public static void main(String[] args) {\n        Observable<String> observable1 = Observable.interval(1, TimeUnit.MILLISECONDS).map(i -> \"value_\" + i);\n        Observable<Boolean> observable2 = Observable.interval(7, TimeUnit.MILLISECONDS).map(i -> i % 2 == 0 ? true : false).startWith(false);\n\n        /*\n         * Solution A\n         * \n         * This works as long as you're okay if the last observable1 value is emitted when observable2 changes from false to true\n         */\n        Observable<String> observable3a = Observable.combineLatest(observable1, observable2, (o1, o2) -> {\n            System.out.println(\"        o1: \" + o1 + \" o2: \" + o2);\n            return new Object[] { o1, o2 }; // poor excuse for a tuple\n            }).filter(oo -> (Boolean) oo[1]).map(oo -> (String) oo[0]);\n\n        /*\n         * Solution B\n         * \n         * This adds 'distinctUntilChanged' so that it won't emit during the change from false -> true.\n         * However, this means it could also skip values from observable1 if duplicates are expected, so it can only be used if\n         * the values are expected to be unique.\n         */\n        Observable<String> observable3b = Observable.combineLatest(observable1, observable2, (o1, o2) -> {\n            System.out.println(\"        o1: \" + o1 + \" o2: \" + o2);\n            return new Object[] { o1, o2 }; // poor excuse for a tuple\n            }).distinctUntilChanged(oo -> (String) oo[0]).filter(oo -> (Boolean) oo[1]).map(oo -> (String) oo[0]);\n\n        /*\n         * Solution C\n         * \n         * This gets more complicated by zipping observable1 with a range to index it so we can de-dupe on the index number\n         * instead of the value in case we need to handle possible duplicate values and solution A above is not okay.\n         */\n        Observable<Object[]> observable1withIndex = observable1.zipWith(Observable.range(0, Integer.MAX_VALUE), (v, i) -> new Object[] { v, i });\n        Observable<String> observable3c = Observable.combineLatest(observable1withIndex, observable2, (o1, o2) -> {\n            System.out.println(\"        o1: \" + o1[0] + \" index: \" + o1[1] + \" o2: \" + o2);\n            return new Object[] { o1[1], \"repetitive-value\", o2 }; // poor excuse for a tuple\n            }).distinctUntilChanged(oo -> oo[0]).filter(oo -> (Boolean) oo[2]).map(oo -> (String) oo[1]);\n\n        observable3a.take(20).toBlocking().forEach(System.out::println);\n        //        observable3b.take(20).toBlocking().forEach(System.out::println);\n        //        observable3c.take(20).toBlocking().forEach(System.out::println);\n    }\n}\n```\n"
      }
    ]
  }
]