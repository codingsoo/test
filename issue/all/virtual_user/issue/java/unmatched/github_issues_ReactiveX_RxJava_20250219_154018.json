[
  {
    "number": 7834,
    "title": "DistinctUntilChanged doesn't work on API level 29",
    "created_at": "2025-02-13T18:38:13Z",
    "closed_at": "2025-02-17T08:24:11Z",
    "labels": [
      "Question",
      "Android"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/7834",
    "body": "Running this code on API level 25, `t1` and `t2` are different when typing in the edit text.  \nHowever, on API level 29, the `t1 == t2` condition always evaluates to true.\n\n```\nfun TextInputLayout.priceInput(\n    maxValue: Long = Constants.max_value_receipt.toLong(),\n    skipInitialValue: Boolean = false): Observable<CharSequence> {\n\n    var animation: ValueAnimator? = null\n\n    errorIconDrawable = null\n\n    editText!!.inputType =\n        EditorInfo.TYPE_NUMBER_FLAG_DECIMAL\n    editText!!.keyListener =\n        DigitsKeyListener.getInstance(\"0123456789,\")\n\n    editText!!.setOnTouchListener { _, motionEvent ->\n        if (motionEvent.action == MotionEvent.ACTION_UP) {\n            editText!!.showSoftKeyboard()\n        }\n        return@setOnTouchListener true\n    }\n\n    editText!!.setOnFocusChangeListener { _, hasFocus ->\n        if (hasFocus) editText!!.selectAtTheEnd()\n    }\n\n    val afterTextChangeEvents = editText!!.textChanges().let {\n        if (skipInitialValue)\n            it.skipInitialValue()\n        else\n            it.skip(0)\n    }\n    return afterTextChangeEvents\n        .distinctUntilChanged { t1, t2 ->\n            t1 == t2\n        }\n        .concatMap {\n            Observable.fromCallable {\n                val toString = it.toEmptyIfNull().toString()\n                if (toString.isEmpty())\n                    return@fromCallable toString\n                val withoutComma = toString.replace(\",\", \"\")\n                val value = try {\n                    withoutComma.toLong()\n                } catch (e: Exception) {\n                    return@fromCallable (editText!!).text.delete(\n                            editText!!.text.length - 1,\n                            editText!!.text.length)\n                }\n                if (value > maxValue) {\n                    if (animation == null || animation!!.isRunning.not()) {\n                        animation = createAnimationError(editText!!)\n                        animation!!.start()\n                    }\n                    return@fromCallable editText!!.text.delete(\n                            editText!!.text.length - 1,\n                            editText!!.text.length)\n                }\n                val result = Formats.convertPrice_LongToStringWithComma(value)\n                Logger.d { \"formatted: $result\" }\n                if (toString != result)\n                    editText!!.text.replace(0, editText!!.text.length, result)\n                return@fromCallable result\n            }\n                .onErrorReturnItem(\"\")\n        }\n}\n```",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/7834/comments",
    "author": "Jacek-Gawel",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2025-02-13T18:46:06Z",
        "body": "As far as I remember, text change events use a mutable `CharSequence`, thus you may be checking the contents of the same reference object.\n\nTry mapping the text changes into Strings\n\n```kotlin\neditText!!.textChanges().map { it.toString() }.let {\n```"
      }
    ]
  },
  {
    "number": 7613,
    "title": "3.x: Items dropped by observeOn without backpressure errors",
    "created_at": "2023-10-19T16:29:53Z",
    "closed_at": "2023-10-19T17:13:12Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/7613",
    "body": "RxJava version: 3.1.8\r\n\r\nI'm processing messages from `PublishProcessor` in parallel. On failure, items are put back to the processor for re-processing. I've noticed that events go missing randomly.\r\n\r\nReproduction:\r\n\r\n```java\r\nprocessor\r\n    .doOnNext(s -> logger.trace(\"next: {}\", s)) // item is here\r\n    .onBackpressureDrop(s -> { // never called\r\n        logger.error(\"!!!!!!! DROP {}\", s);\r\n        throw new RuntimeException(\"drop\");\r\n    })\r\n    .observeOn(Schedulers.single()) // switch to single thread\r\n    .doOnNext(s -> logger.trace(\"next single: {}\", s)) // item is missing here\r\n    .parallel()\r\n    .runOn(Schedulers.io())\r\n    .map(s -> { // run in parallel\r\n        logger.info(\"Processing {}\", s);\r\n        Thread.sleep(50);\r\n        logger.warn(\"Processing completed, reprocessing: {}\", s);\r\n        processor.onNext(s); // put item back\r\n        return s;\r\n    })\r\n    .sequential()\r\n    .subscribe();\r\n\r\nprocessor.onNext(\"aaa\");\r\nprocessor.onNext(\"XXX\");\r\n```\r\n\r\nRunning it gives results in under a minute, often quicker - after some time, only one of the items is being processed, the other is lost.\r\n\r\nI'm switching to `Schedulers.single()` for computation I've removed for brevity, and then process items in parallel. I found that items are lost on the `observeOn()` step - item is logged before it, and not logged after.\r\n\r\nI've read the backpressure notice for the `observeOn()`, but as I understand, in case of the backpressure problem the `MissingBackpressureException` should be thrown. That's not happening.\r\n\r\nAlso the `onBackpressureDrop()` callback is never called.\r\n\r\nReplacing `observeOn()` with `delay(0, TimeUnit.SECONDS, Schedulers.single())` seems to solve the problem, however I don't think quietly dropping items by `observeOn()` is expected here?",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/7613/comments",
    "author": "m-radzikowski",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2023-10-19T16:35:40Z",
        "body": "Did you serialize the `processor`? You are accessing it from possibly many threads."
      },
      {
        "user": "m-radzikowski",
        "created_at": "2023-10-19T17:13:12Z",
        "body": "No \ud83e\udd26\u200d\u2642\ufe0f\r\n\r\nI did not notice that Publishers are not all methods are thread-safe by default. Serializing it solves the issue. Sorry."
      }
    ]
  },
  {
    "number": 7475,
    "title": "repeatWhen bocking",
    "created_at": "2022-10-09T07:41:26Z",
    "closed_at": "2022-10-16T09:55:28Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/7475",
    "body": "Observable.just(1)\r\n  .repeatWhen(o->o.flatMap(os->Observable.empty()))\r\n  .blockingIterable().forEach(System.out::println);\r\n\r\n// blocking on here\r\n\r\nSystem.out.println(\"Complete\");\r\n\r\nnot print Complete",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/7475/comments",
    "author": "VectorWen",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2022-10-09T09:17:30Z",
        "body": "What where you trying to achieve? \r\n\r\nIn order to stop repeating, the inner sequence has to be completed, however, `flatMap`ping an empty source does not complete the sequence. You need some kind of `takeUntil` inside `repeatWhen` to trigger a completion."
      },
      {
        "user": "VectorWen",
        "created_at": "2022-10-12T03:23:18Z",
        "body": "@akarnokd e.g.\r\n\r\n```java\r\npublic class RepeatWhenMain {\r\n    private static int i = 0;\r\n\r\n    public static void main(String[] args) {\r\n        Observable.just(0)\r\n                .map(o -> i)\r\n                .repeatWhen(o -> o.flatMap(s -> {\r\n                    if (i < 15) {\r\n                        i++;\r\n                        return Observable.just(1);\r\n                    }\r\n                    //need complete, but  not completed\r\n                    return Observable.empty();\r\n                }))\r\n                .blockingIterable().forEach(System.out::println);\r\n    }\r\n}\r\n```"
      },
      {
        "user": "akarnokd",
        "created_at": "2022-10-12T05:43:03Z",
        "body": "Try `o.takeUntil(v -> v == 15).flatMap(etc.)`."
      }
    ]
  },
  {
    "number": 6939,
    "title": "doOnSubscribe don't work as expected.",
    "created_at": "2020-03-19T08:25:50Z",
    "closed_at": "2020-03-19T12:26:43Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/6939",
    "body": "RxJava 2.2.19\r\nMy code(sample):\r\n```\r\nclass Foo {\r\n\r\n\tprivate val someCachedData = listOf(1, 2, 3)\r\n\r\n\tprivate val publisher = PublishProcessor.create<Int>()\r\n\r\n\tfun getPublisher(): Flowable<Int> = publisher.onBackpressureBuffer().publish().refCount()\r\n\r\n\tfun subscribe() {\r\n\t\tprintln(\"subscribe called\")\r\n\r\n\t\tsomeCachedData.forEach(publisher::onNext)\r\n\t}\r\n }\r\n\r\n fun main() {\r\n\r\n\tval foo = Foo()\r\n\r\n\tfoo.getPublisher()\r\n\t\t.subscribeOn(Schedulers.computation())\r\n\t\t.doOnSubscribe {\r\n\t\t\tprintln(\"doOnSubscribe called\")\r\n\t\t\tfoo.subscribe()\r\n\t\t}\r\n\t\t.subscribe { print(it) }\r\n\r\n\tThread.sleep(10000)\r\n}\r\n```\r\n\r\nOutput:\r\n```\r\ndoOnSubscribe called\r\nsubscribe called\r\n\r\nProcess finished with exit code 0\r\n```\r\nIf i add some delay to call `foo.subscribe()`, App works fine.\r\nThe following code works fine:\r\n```\r\nfoo.getPublisher()\r\n\t\t.subscribeOn(Schedulers.computation())\r\n\t\t.doOnSubscribe {\r\n\t\t\tprintln(\"doOnSubscribe called\")\r\n\t\t\tSingle.just(true)\r\n\t\t\t\t.subscribeOn(Schedulers.single())\r\n\t\t\t\t.delay(1, TimeUnit.SECONDS)\r\n\t\t\t\t.subscribe { _ ->\r\n\t\t\t\t\tfoo.subscribe()\r\n\t\t\t\t}\r\n\t\t}\r\n\t\t.subscribe { print(it) }\r\n```",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/6939/comments",
    "author": "VovaStelmashchuk",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2020-03-19T08:32:40Z",
        "body": "In your setup, `doOnSubscribe` runs just before the `PublishProcessor` finishes the registration of the subscriber and thus when you try to signal the values then, the processor simply won't see the subscriber. Also such re-entrant use is not encouraged.\r\n\r\n> Can you provide some fix?\r\n\r\nWhat were you trying to achieve there? If you want a source to signal when a subscriber arrives, use a cold source."
      },
      {
        "user": "VovaStelmashchuk",
        "created_at": "2020-03-19T08:47:52Z",
        "body": "In my case, I connect to socket. Some data load from cache, another from the real socket. I want to emit cached data immediately after consumer subscribe.  How i can implement this?"
      },
      {
        "user": "akarnokd",
        "created_at": "2020-03-19T08:57:18Z",
        "body": "Use `startWith` for example."
      }
    ]
  },
  {
    "number": 6339,
    "title": "Delayed events do not keep order doOnNext and doOnComplete (groupBy with publish) ",
    "created_at": "2018-12-14T07:40:12Z",
    "closed_at": "2018-12-14T08:36:34Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/6339",
    "body": "Hi,\r\nI'm a bit confused about how doOnComplete works in example below. \r\nrxjava version: 2.2.4\r\n\r\n```java\r\nFlowable<String> emitter = Flowable.just(\"aa\", \"ba\", \"ab\", \"bb\", \"ac\")\r\n                .doOnComplete(() -> logger.info(\"End emit\"));\r\n\r\n        Flowable<GroupedFlowable<Character, String>> groupBy = emitter.groupBy(s -> s.charAt(0));\r\n\r\n        groupBy.flatMap(characterStringGroupedFlowable -> stats(characterStringGroupedFlowable)\r\n                .publish(stringFlowable -> stringFlowable.concatMap(s -> \r\n                     Flowable.just(s).delay(100, TimeUnit.MILLISECONDS))))\r\n                .subscribeOn(Schedulers.from(Executors.newFixedThreadPool(1)))\r\n                .test()\r\n                .await();\r\n```\r\n```java\r\nprivate Flowable<String> stats(GroupedFlowable<Character, String> groupedFlowable) {\r\n        return groupedFlowable.compose(upstream -> {\r\n            AtomicLong count = new AtomicLong(0);\r\n            return upstream\r\n                    .doOnNext(s -> {\r\n                        count.incrementAndGet();\r\n                        logger.info(\"Group: {} - stats - [{}] - count: {}\", \r\n                        groupedFlowable.getKey(), s, count.get());\r\n                    })\r\n                    .doOnComplete(() -> {\r\n                        logger.info(\"Group: {} - stats - complete - count: {}\", \r\n                        groupedFlowable.getKey(), count.get());\r\n                    });\r\n\r\n        });\r\n    }\r\n```\r\nOutput:\r\n```\r\n08:13:39.349 | INFO  | pool-1-thread-1 | Group: a - stats - [aa] - count: 1\r\n08:13:39.355 | INFO  | pool-1-thread-1 | Group: b - stats - [ba] - count: 1\r\n08:13:39.356 | INFO  | pool-1-thread-1 | Group: a - stats - [ab] - count: 2\r\n08:13:39.356 | INFO  | pool-1-thread-1 | Group: b - stats - [bb] - count: 2\r\n08:13:39.356 | INFO  | pool-1-thread-1 | End emit\r\n08:13:39.356 | INFO  | pool-1-thread-1 | Group: a - stats - complete - count: 2\r\n08:13:39.356 | INFO  | pool-1-thread-1 | Group: b - stats - complete - count: 2\r\n08:13:39.459 | INFO  | RxComputationThreadPool-1 | Group: a - stats - [ac] - count: 3\r\n```\r\nI expected that this line `Group: a - stats - [ac] - count: 3` will be before that line `Group: a - stats - complete - count: 2`. I think it is a bug, of course I can be wrong. Removing `publish` operator solving a problem but in real world I need it to my business logic.",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/6339/comments",
    "author": "lukaszguz",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2018-12-14T08:36:34Z",
        "body": "Sometimes due to backpressure, `publish` may emit on the requestor thread, in this case the thread `delay` uses. To ensure proper ordering, use `observeOn` and then log."
      },
      {
        "user": "lukaszguz",
        "created_at": "2018-12-14T11:51:16Z",
        "body": "You mean something like that?\r\n```\r\nScheduler scheduler = Schedulers.from(Executors.newFixedThreadPool(1));\r\ngroupBy.flatMap(characterStringGroupedFlowable -> stats(characterStringGroupedFlowable)\r\n                        .publish(stringFlowable -> stringFlowable.observeOn(scheduler).concatMap(s -> Flowable.just(s).delay(100, TimeUnit.MILLISECONDS))))\r\n                        .subscribeOn(scheduler)\r\n                        .test()\r\n                        .await();\r\n```"
      },
      {
        "user": "akarnokd",
        "created_at": "2018-12-14T12:03:03Z",
        "body": "Try `characterStringGroupedFlowable.observeOn(scheduler)`."
      }
    ]
  },
  {
    "number": 6093,
    "title": "2.x: Concat operator, Maybes, and threading",
    "created_at": "2018-07-18T15:26:24Z",
    "closed_at": "2018-07-20T06:34:47Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/6093",
    "body": "Following code sample (Kotlin 1.2.51, RxJava 2.1.16):\r\n```kotlin\r\nval m1 = Maybe.just(1).subscribeOn(Schedulers.io())\r\nval m2 = Maybe.just(1).subscribeOn(Schedulers.io())\r\n\r\nval m3 = m1\r\n    .concatWith(m2)\r\n    .firstElement()\r\n    .map { Thread.currentThread().name }\r\n\r\nvar counter = 0\r\nvar counterMain = 0\r\n\r\n(0 until 10000)\r\n    .forEach { if (m3.blockingGet() == \"main\") counterMain++ else counter++ }\r\n\r\nprintln(\"Result: main $counterMain, other $counter, sum ${counterMain + counter}\")\r\n````\r\nleads to the following in-deterministic (main number is different for each run) result:\r\n```Result: main 13, other 9987, sum 10000```\r\n\r\nIt seems that the result of the `concat` operator sometimes runs on the calling thread, even if the participating Maybes use specific schedulers. I could not reproduce this behavior for Observables or Singles. Is this intended behavior and the resulting thread cannot be guaranteed or could it be a bug?",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/6093/comments",
    "author": "schmist",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2018-07-18T15:53:31Z",
        "body": "This is a peculiarity of the backpressure inside the `concatArray` operator `concatWith` builds upon. If the first source is fast, the drain loop running on the main thread may get the success value and push it to downstream still on the main thread. You have to use `observeOn` before `map` to make sure the right thread is used or apply `subscribeOn` just after `concatWith` so that the drain loop is no longer invoked on the main thread if the above race condition happens."
      },
      {
        "user": "akarnokd",
        "created_at": "2018-07-18T18:26:10Z",
        "body": "This is a `Maybe` specific property as it has a dedicated implementation. `Single` is converted to `Flowable` and `Flowable.concat` is used where the code path is longer for the emission. Try with `Schedulers.single()` for those other implementations so that the scheduling window is minimal. "
      },
      {
        "user": "akarnokd",
        "created_at": "2018-07-18T18:38:21Z",
        "body": "To be clear, concatenating `Observable`s doesn't have this effect because there is no backpressure to coordinate the emissions with. Each source emits from its thread which passes through the `concat` operator. With `Flowable`, emissions may be held off or simply cached until the value can be retrieved, but this can happen on any participating threads. That's why to ensure proper reception of items, one should use `observeOn` before such `map`s to make sure no matter where the value originated, it continues on the desired thread (until the next async boundary)."
      }
    ]
  },
  {
    "number": 5869,
    "title": "No successful subscription when running `using` and `retry` together",
    "created_at": "2018-02-27T08:43:11Z",
    "closed_at": "2018-02-27T09:29:07Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5869",
    "body": "Version: 'io.reactivex.rxjava2:rxjava:2.1.10'\r\n\r\nNo successful subscription when running `using` and `retry` together, without `retry` or with other `Single` everything is fine.\r\n\r\n```        \r\nSingle.just(\"input\").flatMap(val ->\r\n                Single.using(\r\n                        () -> {\r\n                            System.out.println(\"create\");\r\n                            return \"\";\r\n                            },\r\n                        call -> singleSubscriber -> {\r\n                            System.out.println(\"sub\");\r\n                            singleSubscriber.onSuccess(val);\r\n                            System.out.println(\"sub done\");\r\n                            },\r\n                        call -> {\r\n                            System.out.println(\"close\");\r\n                        }\r\n                        )\r\n                .retry((count, error) -> {\r\n                    System.out.println(\"retry\");\r\n                    return true;\r\n                })\r\n        )\r\n                .subscribe(val -> System.out.println(\"output \" + val));\r\n```\r\nOutput:\r\n```\r\ncreate\r\nsub\r\nclose\r\nsub done\r\n```\r\n\r\nExpected:\r\n```\r\ncreate\r\nsub\r\nclose\r\noutput input\r\nsub done\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5869/comments",
    "author": "dmitart",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2018-02-27T09:16:51Z",
        "body": "You should not create a `SingleSource` via lambda as people often forget to follow the protocol: `onSubscribe (onSuccess | onError)?`. Use `Single.create()` instead:\r\n\r\n```java\r\nSingle.create(singleSubscriber -> {\r\n    System.out.println(\"sub\");\r\n    singleSubscriber.onSuccess(val);\r\n    System.out.println(\"sub done\");\r\n})\r\n```\r\n\r\nwith which now prints:\r\n\r\n```\r\ncreate\r\nsub\r\nclose\r\noutput input\r\nsub done\r\n```\r\n\r\nWhat happens is that `retry` converts to `Flowable` internally to reuse that operator, which requires downstream requests. However, since `onSubscribe` was never called, the request channel is never established below that operator and the single element is hold up indefinitely."
      }
    ]
  },
  {
    "number": 5666,
    "title": "Use take() concat() skip() together would cause item lost.",
    "created_at": "2017-10-13T09:35:33Z",
    "closed_at": "2017-10-16T02:16:31Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5666",
    "body": "Version: 2.1.5\r\n\r\n```java\r\npublic static void main(String[] args) {\r\n        Observable<Integer> src = Observable.just(1, 2, 3, 4, 5);\r\n        src.publish(new Function<Observable<Integer>, ObservableSource<Integer>>() {\r\n            @Override\r\n            public ObservableSource<Integer> apply(@NonNull Observable<Integer> integerObservable) throws Exception {\r\n                return integerObservable.take(2).concatWith(integerObservable.skip(2));\r\n            }\r\n        }).subscribe(new Consumer<Integer>() {\r\n            @Override\r\n            public void accept(Integer integer) throws Exception {\r\n                System.out.println(integer);\r\n            }\r\n        });\r\n    }\r\n\r\n```\r\n\r\nexpected result: 1 2 3 4 5\r\nactual result: 1 2 5\r\n\r\n3 and 4 are lost. We suppose it was a bug.",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5666/comments",
    "author": "jie-meng",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-10-13T09:50:33Z",
        "body": "That is the expected behavior. This is what happens:\r\n\r\n1. the range 1..5 is shared through a function\r\n2. the `integerObservable` you get will emit 1, 2\r\n3. the `take` unsubscribes after this two items\r\n4. `concatWith` switches to its second `ObservableSource` and subscribes to it\r\n5. the `skip` subscribes to the shared `integerObservable`\r\n6. the `integerObservable` resumes with 3, 4, 5\r\n7. `skip` ignores 3, 4; relays 5\r\n8. the sequence completes.\r\n\r\nSo due to `concatWith`, the second parameter sequence doesn't get to interact with the shared sequence until the first half completed."
      }
    ]
  },
  {
    "number": 5610,
    "title": "how to retry when subscriber error ?",
    "created_at": "2017-09-20T11:59:51Z",
    "closed_at": "2017-09-21T07:34:56Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5610",
    "body": "```java\r\n\r\n          final int[] a = {0};\r\n            Observable.interval(1, TimeUnit.SECONDS).retry(new Predicate<Throwable>() {\r\n                @Override\r\n                public boolean test(Throwable throwable) throws Exception {\r\n                    a[0]=0;\r\n                    System.out.println(\" reset Observable\");\r\n                    return true;\r\n                }\r\n            }).subscribe(new io.reactivex.functions.Consumer<Long>() {\r\n                @Override\r\n                public void accept(Long aLong) throws Exception {\r\n                    a[0]++;\r\n                    System.out.println(a[0]+\"=====\"+System.currentTimeMillis());\r\n                    if (a[0] >5){\r\n                        /*\r\n                        *  it will throw error  i want to retry\r\n                        * */\r\n                        System.out.println(\"a[2] = \" + a[2]);\r\n                    }\r\n                }\r\n            }, new io.reactivex.functions.Consumer<Throwable>() {\r\n                @Override\r\n                public void accept(Throwable throwable) throws Exception {\r\n                    System.out.println(\"e.getLocalizedMessage() = \" + throwable.getLocalizedMessage());\r\n                    a[0]=0;\r\n                }\r\n            });\r\n```\r\n\r\nthis is my log \r\n\r\n```\r\n1=====1505908635697\r\n2=====1505908636687\r\n3=====1505908637684\r\n4=====1505908638684\r\n5=====1505908639684\r\n6=====1505908640684\r\ne.getLocalizedMessage() = 2\r\n```\r\nIf the consumer throws an error, this wording can not be retried? If  i  want to try again, what should I do?\r\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5610/comments",
    "author": "AllenCoder",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-09-20T12:09:46Z",
        "body": "`retry` can only deal with errors upstream to it. You have to reorganize your flow in a way that the operation that may throw happens before `retry`:\r\n\r\n```java\r\nObservable.interval(1, TimeUnit.SECONDS)\r\n.doOnNext(v -> {\r\n   /* your potentially crashing code here */\r\n})\r\n.retry(e -> true)\r\n.subscribe(v -> { /* non-crashing code here */ }, e -> { /* ... */ }}\r\n```"
      },
      {
        "user": "TomasThibaut",
        "created_at": "2019-08-13T07:34:09Z",
        "body": "But is there anyway to retry error on downstreams like ``` subscribe() ```,cuz if error happens here, it'll be catch by error callback in ```subscribe()``` and interrupt the whole steam?"
      }
    ]
  },
  {
    "number": 5591,
    "title": "Caused by: java.lang.NullPointerException                                                                             at io.reactivex.internal.operators.observable.ObservableConcatMap$SourceObserver.onNext(ObservableConcatMap.java:128)",
    "created_at": "2017-09-07T02:59:13Z",
    "closed_at": "2017-09-07T07:40:29Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5591",
    "body": "```java\r\npublic class BluetoothActivity extends AppCompatActivity {\r\n   @Override\r\n    protected void onCreate(Bundle savedInstanceState) {\r\n        super.onCreate(savedInstanceState);\r\n        setContentView(R.layout.activity_bluetooth);\r\n        Observable.just(\"a\")\r\n                .concatMap(b->getResponse(b))\r\n                .concatMap(b->getResponse(b))\r\n                .subscribe(new Consumer<Object>() {\r\n                    @Override\r\n                    public void accept(Object o) throws Exception {\r\n                    }\r\n\r\n                }, new Consumer<Throwable>() {\r\n                    @Override\r\n                    public void accept(Throwable throwable) throws Exception {\r\n                    }\r\n                });\r\n}\r\npublic Observable<Object> getResponse(Object o){\r\n        Log.d(\"program\",\"getResponse():\"+o.toString());\r\n        return new Observable<Object>() {\r\n            @Override\r\n            protected void subscribeActual(Observer<? super Object> observer) {\r\n                observer.onNext(\"b\");\r\n                observer.onComplete();\r\n            }\r\n\r\n        };\r\n    }\r\n}\r\n```\r\n\r\nLog:\r\n```\r\n09-06 18:55:58.312 20589-20589/? E/dalvikvm: /system/framework/pm.jar odex has stale dependencies\r\n09-06 18:55:58.472 20589-20589/? E/memtrack: Couldn't load memtrack module (No such file or directory)\r\n09-06 18:55:58.472 20589-20589/? E/android.os.Debug: failed to load memtrack module: -2\r\n09-06 18:55:58.632 1478-20601/? E/ActivityThread: Failed to find provider info for com.leadcore.sdb\r\n09-06 18:56:06.622 20618-20618/? E/dalvikvm: /system/framework/am.jar odex has stale dependencies\r\n09-06 18:56:06.832 20618-20618/? E/memtrack: Couldn't load memtrack module (No such file or directory)\r\n09-06 18:56:06.832 20618-20618/? E/android.os.Debug: failed to load memtrack module: -2\r\n09-06 18:56:09.082 20638-20638/com.example.z.myplayer E/dalvikvm: Could not find class 'android.graphics.drawable.RippleDrawable', referenced from method android.support.v7.widget.AppCompatImageHelper.hasOverlappingRendering\r\n09-06 18:56:09.252 20638-20638/com.example.z.myplayer E/AndroidRuntime: FATAL EXCEPTION: main\r\n                                                                        Process: com.example.z.myplayer, PID: 20638\r\n                                                                        java.lang.RuntimeException: Unable to start activity ComponentInfo{com.example.z.myplayer/com.example.z.myplayer.BluetoothActivity}: java.lang.NullPointerException\r\n                                                                            at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:2209)\r\n                                                                            at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:2258)\r\n                                                                            at android.app.ActivityThread.access$800(ActivityThread.java:147)\r\n                                                                            at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1211)\r\n                                                                            at android.os.Handler.dispatchMessage(Handler.java:102)\r\n                                                                            at android.os.Looper.loop(Looper.java:136)\r\n                                                                            at android.app.ActivityThread.main(ActivityThread.java:5135)\r\n                                                                            at java.lang.reflect.Method.invokeNative(Native Method)\r\n                                                                            at java.lang.reflect.Method.invoke(Method.java:515)\r\n                                                                            at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:798)\r\n                                                                            at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:614)\r\n                                                                            at dalvik.system.NativeStart.main(Native Method)\r\n                                                                         Caused by: java.lang.NullPointerException\r\n                                                                            at io.reactivex.internal.operators.observable.ObservableConcatMap$SourceObserver.onNext(ObservableConcatMap.java:128)\r\n                                                                            at com.example.z.myplayer.BluetoothActivity$5.subscribeActual(BluetoothActivity.java:170)\r\n                                                                            at io.reactivex.Observable.subscribe(Observable.java:10903)\r\n                                                                            at io.reactivex.internal.operators.observable.ObservableScalarXMap$ScalarXMapObservable.subscribeActual(ObservableScalarXMap.java:166)\r\n                                                                            at io.reactivex.Observable.subscribe(Observable.java:10903)\r\n                                                                            at io.reactivex.internal.operators.observable.ObservableConcatMap.subscribeActual(ObservableConcatMap.java:52)\r\n                                                                            at io.reactivex.Observable.subscribe(Observable.java:10903)\r\n                                                                            at io.reactivex.Observable.subscribe(Observable.java:10889)\r\n                                                                            at io.reactivex.Observable.subscribe(Observable.java:10818)\r\n                                                                            at com.example.z.myplayer.BluetoothActivity.onCreate(BluetoothActivity.java:79)\r\n                                                                            at android.app.Activity.performCreate(Activity.java:5356)\r\n                                                                            at android.app.Instrumentation.callActivityOnCreate(Instrumentation.java:1087)\r\n                                                                            at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:2163)\r\n                                                                            at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:2258)\u00a0\r\n                                                                            at android.app.ActivityThread.access$800(ActivityThread.java:147)\u00a0\r\n                                                                            at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1211)\u00a0\r\n                                                                            at android.os.Handler.dispatchMessage(Handler.java:102)\u00a0\r\n                                                                            at android.os.Looper.loop(Looper.java:136)\u00a0\r\n                                                                            at android.app.ActivityThread.main(ActivityThread.java:5135)\u00a0\r\n                                                                            at java.lang.reflect.Method.invokeNative(Native Method)\u00a0\r\n                                                                            at java.lang.reflect.Method.invoke(Method.java:515)\u00a0\r\n                                                                            at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:798)\u00a0\r\n                                                                            at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:614)\u00a0\r\n                                                                            at dalvik.system.NativeStart.main(Native Method)\u00a0\r\n09-06 18:56:09.402 1478-20662/? E/ActivityThread: Failed to find provider info for com.leadcore.sdb\r\n09-06 18:56:09.662 20660-20660/? E/dalvikvm: /system/framework/am.jar odex has stale dependencies\r\n09-06 18:56:09.822 20660-20660/? E/memtrack: Couldn't load memtrack module (No such file or directory)\r\n09-06 18:56:09.822 20660-20660/? E/android.os.Debug: failed to load memtrack module: -2\r\n```",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5591/comments",
    "author": "youngonlyforyou",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-09-07T07:39:35Z",
        "body": "The problem is that you use `new Observable()` where you should follow the observable protocol and call `onSubscribe`:\r\n\r\n```java\r\npublic Observable<Object> getResponse(Object o){\r\n        Log.d(\"program\",\"getResponse():\"+o.toString());\r\n        return new Observable<Object>() {\r\n```\r\n\r\nYou should use `Observable.create()`  instead:\r\n\r\n```java\r\npublic Observable<Object> getResponse(Object o){\r\n    Log.d(\"program\",\"getResponse():\"+o.toString());\r\n    return Observable.<Object>create(new ObservableOnSubscribe<Object>() {\r\n        @Override \r\n        public void subscribe(ObservableEmitter<Object> observer) {\r\n             observer.onNext(\"b\");\r\n             observer.onComplete();\r\n        }\r\n    });\r\n```"
      }
    ]
  },
  {
    "number": 5534,
    "title": " [1.2.0]Caused by: rx.exceptions.OnErrorNotImplementedException: HTTP 500 Internal Server Error",
    "created_at": "2017-08-03T09:41:38Z",
    "closed_at": "2017-08-03T10:32:12Z",
    "labels": [
      "Question",
      "1.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5534",
    "body": "when i use retrofit+rxjava+rxCalladapter,  foud error  here :\r\n\r\n```\r\n08-03 17:12:50.864 18778-18809/com.xuebansoft.xinghuo.manager E/AndroidRuntime: FATAL EXCEPTION: RxIoScheduler-2\r\nProcess: com.xuebansoft.xinghuo.manager, PID: 18778\r\njava.lang.IllegalStateException: Exception thrown on Scheduler.Worker thread. Add `onError` handling.\r\n    at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:57)\r\n    at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:422)\r\n    at java.util.concurrent.FutureTask.run(FutureTask.java:237)\r\n    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:152)\r\n    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:265)\r\n    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1112)\r\n    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:587)\r\n    at java.lang.Thread.run(Thread.java:841)\r\n Caused by: rx.exceptions.OnErrorNotImplementedException: HTTP 500 Internal Server Error\r\n    at rx.internal.util.InternalObservableUtils$ErrorNotImplementedAction.call(InternalObservableUtils.java:386)\r\n    at rx.internal.util.InternalObservableUtils$ErrorNotImplementedAction.call(InternalObservableUtils.java:383)\r\n    at rx.internal.util.ActionSubscriber.onError(ActionSubscriber.java:44)\r\n    at rx.observers.SafeSubscriber._onError(SafeSubscriber.java:152)\r\n    at rx.observers.SafeSubscriber.onError(SafeSubscriber.java:115)\r\n    at rx.internal.operators.OperatorObserveOn$ObserveOnSubscriber.checkTerminated(OperatorObserveOn.java:276)\r\n    at rx.internal.operators.OperatorObserveOn$ObserveOnSubscriber.call(OperatorObserveOn.java:219)\r\n    at rx.internal.schedulers.CachedThreadScheduler$EventLoopWorker$1.call(CachedThreadScheduler.java:228)\r\n    at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:55)\r\n    at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:422)\u00a0\r\n    at java.util.concurrent.FutureTask.run(FutureTask.java:237)\u00a0\r\n    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:152)\u00a0\r\n    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:265)\u00a0\r\n    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1112)\u00a0\r\n    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:587)\u00a0\r\n    at java.lang.Thread.run(Thread.java:841)\u00a0\r\n Caused by: retrofit2.adapter.rxjava.HttpException: HTTP 500 Internal Server Error\r\n    at retrofit2.adapter.rxjava.BodyOnSubscribe$BodySubscriber.onNext(BodyOnSubscribe.java:51)\r\n    at retrofit2.adapter.rxjava.BodyOnSubscribe$BodySubscriber.onNext(BodyOnSubscribe.java:36)\r\n    at retrofit2.adapter.rxjava.CallArbiter.deliverResponse(CallArbiter.java:115)\r\n    at retrofit2.adapter.rxjava.CallArbiter.emitResponse(CallArbiter.java:97)\r\n    at retrofit2.adapter.rxjava.CallExecuteOnSubscribe.call(CallExecuteOnSubscribe.java:46)\r\n    at retrofit2.adapter.rxjava.CallExecuteOnSubscribe.call(CallExecuteOnSubscribe.java:24)\r\n    at retrofit2.adapter.rxjava.BodyOnSubscribe.call(BodyOnSubscribe.java:33)\r\n    at retrofit2.adapter.rxjava.BodyOnSubscribe.call(BodyOnSubscribe.java:25)\r\n    at rx.Observable.unsafeSubscribe(Observable.java:10151)\r\n    at rx.internal.operators.OperatorSubscribeOn$1.call(OperatorSubscribeOn.java:94)\r\n    at rx.internal.schedulers.CachedThreadScheduler$EventLoopWorker$1.call(CachedThreadScheduler.java:228)\u00a0\r\n    at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:55)\u00a0\r\n    at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:422)\u00a0\r\n    at java.util.concurrent.FutureTask.run(FutureTask.java:237)\u00a0\r\n    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:152)\u00a0\r\n    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:265)\u00a0\r\n    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1112)\u00a0\r\n    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:587)\u00a0\r\n    at java.lang.Thread.run(Thread.java:841)\u00a0\r\n```\r\n\r\nand  the running code is here:\r\n\r\n```java\r\n    ManagerApi.getIns().updateChannelInfoForMobileUser(AppHelper.getIUser().getMobileUserId(), ((XhEvent.BindEvent) event).getmChannelId(), ((XhEvent.BindEvent) event).getmUserId())\r\n                                .subscribeOn(Schedulers.io()).observeOn(Schedulers.io()).subscribe(new Action1<EduCommResponse>() {\r\n                            @Override\r\n                            public void call(EduCommResponse eduCommResponse) {\r\n                                if (eduCommResponse.isSuccess()) {\r\n                                    RememberMe.get().devBindedUser();\r\n                                }\r\n                            }\r\n                        });\r\n```\r\nwhen the http response code is 500 ,will throw this error",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5534/comments",
    "author": "pMotato",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-08-03T09:57:18Z",
        "body": "The key message is:\r\n\r\n> Add onError handling.\r\n\r\ni.e., use `subscribe(Action1<T>, Action1<Throwable>)` at least."
      }
    ]
  },
  {
    "number": 5446,
    "title": "2.x: #delay() operator emits items non-deterministically",
    "created_at": "2017-06-26T22:44:48Z",
    "closed_at": "2017-06-27T18:09:22Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5446",
    "body": "I am using RxJava 2.1.0.\r\n\r\n**tl;dr: I think this is a real issue because sometimes the test case is single-threaded (as expected), but sometimes it is multi-threaded. This non-determinism seems problematic.**\r\n\r\nI had a flaky test in my test suite. I have boiled it down to the following reproducible (failing) test case:\r\n\r\n```java\r\n    @Test\r\n    public void test() throws Exception {\r\n        // Looping to demonstrate flakiness\r\n        for (int i = 0; i < 10; i++) {\r\n            Single<String> source = Single.create(new ErrorsProvider());\r\n\r\n            source.observeOn(Schedulers.trampoline()) // Schedulers.io() in production\r\n                    .retryWhen(delayedRetry())\r\n                    .test()\r\n                    .assertResult(\"Success\");\r\n        }\r\n    }\r\n\r\n    private static class ErrorsProvider implements SingleOnSubscribe<String> {\r\n\r\n        private AtomicInteger count = new AtomicInteger(0);\r\n\r\n        @Override public void subscribe(@NonNull SingleEmitter<String> e) throws Exception {\r\n            if (count.getAndIncrement() == 0) {\r\n                e.onError(new Throwable(\"fail\"));\r\n            } else {\r\n                e.onSuccess(\"Success\");\r\n            }\r\n        }\r\n    }\r\n\r\n    private static Function<Flowable<Throwable>, Publisher<?>> delayedRetry() {\r\n        return errors -> errors.flatMap(error -> {\r\n            if (error.getMessage().equals(\"fail\")) {\r\n                // This delay would be non-zero in production but set to 0 during test runs\r\n                return Flowable.just(0).delay(0, TimeUnit.SECONDS);\r\n            }\r\n            return Flowable.error(error);\r\n        });\r\n    }\r\n```\r\n\r\nI would expect this test to pass 100% of the time, but instead it fails every time I run it inside this loop. More to the point, even with 1 iteration, it'll fail on CI regularly.\r\n\r\nI have modified my test like so to workaround the issue:\r\n\r\n```java\r\n            Single<String> source = Single.create(new ErrorsProvider());\r\n\r\n            source.observeOn(Schedulers.trampoline())\r\n                    .retryWhen(delayedRetry())\r\n                    .test()\r\n                    .awaitCount(1) // new line\r\n                    .assertResult(\"Success\");\r\n```\r\n\r\nBut I feel like this should not be necessary.\r\n\r\nIn my production code, I have extensive logging enabled, and by reading them carefully I noticed that _sometimes_, after the `retryWhen()` operator was called, subsequent emissions occurred on a new thread. Most of the time, all emissions are called on a single thread (which is what I'd expect when using `Schedulers.trampoline()`). It was at this point I noticed that the `delay()` operator operates by default on `Schedulers.computation()`. I thought perhaps I was simply mis-using the library, and so I changed my delay call to `delay(...).observeOn(Schedulers.trampoline())`, but that had no effect.",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5446/comments",
    "author": "autonomousapps",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-06-27T07:23:55Z",
        "body": "`delay` runs on the computation scheduler and observing it on the trampoline scheduler has no effect. The trampoline scheduler isn't there to pin execution to a particular thread, its purpose is to make sure tasks submitted from multiple threads execute one after the other. You could use the `delay(long, TimeUnit, Scheduler)` overload to override the scheduler and not introduce asynchrony in your tests.\r\n\r\nAlternatively, you could use `awaitDone(long, TimeUnit)` to wait for the async flow and then assert on the contents. `awaitCount` waits only for the `onNext` event and your workaround may still fail to receive `onComplete` in time."
      },
      {
        "user": "autonomousapps",
        "created_at": "2017-06-27T17:24:20Z",
        "body": "Thank you for correcting my misunderstanding of some of these issues. (I actually wish the javadoc were as clear as your sentence \"The trampoline scheduler isn't there to pin execution to a particular thread, its purpose is to make sure tasks submitted from multiple threads execute one after the other\".)\r\n\r\nNevertheless, the non-deterministic behavior seems wrong. Why would the test sometimes pass (when not in a loop), but other times fail? Why would I sometimes observe all code paths on a single thread, and sometimes on two threads?"
      },
      {
        "user": "akarnokd",
        "created_at": "2017-06-27T17:34:46Z",
        "body": "The moment you have an async scheduler in there somewhere (via opeator overload default), you open yourself to concurrent behavior thus events may not arrive \"immediately\" like in a fully synchronous case.\r\n\r\n> non-deterministic behavior seems wrong\r\n\r\nConcurrent behavior is often non-intuitive and non-deterministic.\r\n\r\n> Why would the test sometimes pass (when not in a loop), but other times fail?\r\n\r\nBecause the test thread and the consuming thread run concurrently and the test thread might get delayed just enough so the other thread has time to signal all of its events. Other times, the other thread may get things done a bit later and the test thread has already at or behind its checks.\r\n\r\n> Why would I sometimes observe all code paths on a single thread, and sometimes on two threads?\r\n\r\nConcurrent events are serialized into a single thread and if more events are involved, the same thread may deliver all events if the timing is right."
      }
    ]
  },
  {
    "number": 5424,
    "title": "RxJava1.3.0 stackoverflow at android4.4",
    "created_at": "2017-06-19T07:23:07Z",
    "closed_at": "2017-06-19T08:35:55Z",
    "labels": [
      "Question",
      "Android",
      "1.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5424",
    "body": "version:1.3.0\r\nos:android4.4\r\nMy app is running is very good at other version of android except for android4.4.\r\nThere is the crash log:\r\n```\r\n\r\njava.lang.IllegalStateException: Fatal Exception thrown on Scheduler.Worker thread.\r\n                                                       at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:59)\r\n                                                       at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:422)\r\n                                                       at java.util.concurrent.FutureTask.run(FutureTask.java:237)\r\n                                                       at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:152)\r\n                                                       at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:265)\r\n                                                       at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1112)\r\n                                                       at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:587)\r\n                                                       at java.lang.Thread.run(Thread.java:841)\r\n                                                    Caused by: java.lang.StackOverflowError\r\n                                                       at java.util.concurrent.ConcurrentLinkedQueue.isEmpty(ConcurrentLinkedQueue.java:397)\r\n                                                       at rx.internal.schedulers.CachedThreadScheduler$CachedWorkerPool.get(CachedThreadScheduler.java:90)\r\n                                                       at rx.internal.schedulers.CachedThreadScheduler$EventLoopWorker.<init>(CachedThreadScheduler.java:188)\r\n                                                       at rx.internal.schedulers.CachedThreadScheduler.createWorker(CachedThreadScheduler.java:176)\r\n                                                       at rx.internal.operators.OperatorSubscribeOn.call(OperatorSubscribeOn.java:44)\r\n                                                       at rx.internal.operators.OperatorSubscribeOn.call(OperatorSubscribeOn.java:30)\r\n                                                       at rx.Observable.unsafeSubscribe(Observable.java:10256)\r\n                                                       at rx.internal.operators.OnSubscribeDoOnEach.call(OnSubscribeDoOnEach.java:41)\r\n                                                       at rx.internal.operators.OnSubscribeDoOnEach.call(OnSubscribeDoOnEach.java:30)\r\n                                                       at rx.Observable.unsafeSubscribe(Observable.java:10256)\r\n                                                       at rx.internal.operators.CachedObservable$CacheState.connect(CachedObservable.java:183)\r\n                                                       at rx.internal.operators.CachedObservable$CachedSubscribe.call(CachedObservable.java:248)\r\n                                                       at rx.internal.operators.CachedObservable$CachedSubscribe.call(CachedObservable.java:230)\r\n                                                       at rx.Observable.unsafeSubscribe(Observable.java:10256)\r\n                                                       at rx.internal.operators.OperatorZip$Zip.start(OperatorZip.java:202)\r\n                                                       at rx.internal.operators.OperatorZip$ZipSubscriber.onNext(OperatorZip.java:143)\r\n                                                       at rx.internal.operators.OperatorZip$ZipSubscriber.onNext(OperatorZip.java:109)\r\n                                                       at rx.internal.util.ScalarSynchronousObservable$WeakSingleProducer.request(ScalarSynchronousObservable.java:276)\r\n                                                       at rx.Subscriber.setProducer(Subscriber.java:209)\r\n                                                       at rx.internal.util.ScalarSynchronousObservable$JustOnSubscribe.call(ScalarSynchronousObservable.java:138)\r\n                                                       at rx.internal.util.ScalarSynchronousObservable$JustOnSubscribe.call(ScalarSynchronousObservable.java:129)\r\n                                                       at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:48)\r\n                                                       at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:30)\r\n                                                       at rx.Observable.unsafeSubscribe(Observable.java:10256)\r\n                                                       at rx.internal.operators.OnSubscribeMap.call(OnSubscribeMap.java:48)\r\n                                                       at rx.internal.operators.OnSubscribeMap.call(OnSubscribeMap.java:33)\r\n                                                       at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:48)\r\n                                                       at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:30)\r\n                                                       at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:48)\r\n                                                       at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:30)\r\n                                                       at rx.Observable.unsafeSubscribe(Observable.java:10256)\r\n                                                       at rx.internal.operators.OperatorMerge$MergeSubscriber.onNext(OperatorMerge.java:248)\r\n                                                       at rx.internal.operators.OperatorMerge$MergeSubscriber.onNext(OperatorMerge.java:148)\r\n                                                       at rx.internal.operators.OnSubscribeMap$MapSubscriber.onNext(OnSubscribeMap.java:77)\r\n                                                       at rx.internal.producers.SingleDelayedProducer.emit(SingleDelayedProducer.java:102)\r\n                                                       at rx.internal.producers.SingleDelayedProducer.setValue(SingleDelayedProducer.java:85)\r\n                                                       at rx.internal.operators.OperatorAny$1.onNext(OperatorAny.java:62)\r\n                                                       at rx.internal.operators.NotificationLite.accept(NotificationLite.java:135)\r\n                                                       at rx.internal.operators.CachedObservable$ReplayProducer.replay(CachedObservable.java:403)\r\n                                                   \tat rx.internal.operators.CachedObservable$CacheState.dispatch(CachedObservable.j\r\n\r\n\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5424/comments",
    "author": "yangwuan55",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-06-19T07:28:23Z",
        "body": "Maybe the default stack size on that platform is low. You can break the stack depth at places by introducing `observeOn` or (somehow) specify the minimum thread stack depth for the application."
      }
    ]
  },
  {
    "number": 5420,
    "title": "Subscribe is not returning disposable when using repeat operator",
    "created_at": "2017-06-16T11:20:24Z",
    "closed_at": "2017-07-05T22:29:42Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5420",
    "body": "Hi, I'm using rxjava 2.1.0. I want to make a pooling to a server, so I'm using a repeat operator. But when I subscribe to the observable, it does not return a disposable. \r\n\r\nFor example, if I do: \r\n\r\n Disposable s = Observable.just(true).repeat().subscribe();\r\n int i = 0;\r\n\r\nThe second line i = 0 is never reached. I cant get a disposable reference after calling to subscribe(), in order to call to dispose() when I want to finish my pooling.\r\n\r\nI'm not sure if this is a bug, or I dont understand the behaviour of the repeat operator. It is working fine, but I'm not able to finish the subscription when using the repeat operator. ",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5420/comments",
    "author": "vicpinm",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-06-16T11:31:03Z",
        "body": "You built a sequence that repeats a constant, immediate source indefinitely upon subscription on the current thread and thus you won't get the control back. You have to specify where the asynchronous execution should happen via `subscribeOn` in this case. Also such immediate repeats are not really recommended for pooling and instead you should consider using `interval()`."
      }
    ]
  },
  {
    "number": 5349,
    "title": "2.0.8 flowableOnSubscribe onNext not working",
    "created_at": "2017-05-17T10:33:20Z",
    "closed_at": "2017-05-19T06:48:28Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5349",
    "body": "```java\r\nFlowable<List<String>> flowable = Flowable.just(Arrays.asList(\"one\",\"two\",\"three\"));\r\n\t\tflowable.subscribe(new FlowableSubscriber() {\r\n\r\n\t\t\t@Override\r\n\t\t\tpublic void onComplete() {\r\n\t\t\t\t// TODO Auto-generated method stub\r\n\t\t\t\tSystem.out.println(\"completed\");\r\n\t\t\t}\r\n\r\n\t\t\t@Override\r\n\t\t\tpublic void onError(Throwable arg0) {\r\n\t\t\t\t// TODO Auto-generated method stub\r\n\t\t\t\t\r\n\t\t\t}\r\n\r\n\t\t\t@Override\r\n\t\t\tpublic void onNext(Object arg0) {\r\n\t\t\t\t// TODO Auto-generated method stub\r\n\t\t\t\tSystem.out.println((String)arg0);\r\n\t\t\t}\r\n\r\n\t\t\t@Override\r\n\t\t\tpublic void onSubscribe(Subscription arg0) {\r\n\t\t\t\t// TODO Auto-generated method stub\r\n\t\t\t\tSystem.out.println(\"on subscribe\");\r\n\t\t\t}\r\n\t\t});\r\n```\r\n\r\nflowableOnSubscribe onNext and onComplete not working,only onSubscribe is working",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5349/comments",
    "author": "mithunkumarc",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-05-17T11:03:11Z",
        "body": "You should call `Subscription.request(n)` to have the data start flowing."
      }
    ]
  },
  {
    "number": 5342,
    "title": "2.x: withLatestFrom() doesn't return the latest value",
    "created_at": "2017-05-15T11:55:22Z",
    "closed_at": "2017-05-15T19:39:02Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5342",
    "body": "Version of RxJava - `2.1.0`. Here is an example which involves use of `PublishSubject`:\r\n\r\n```\r\n// Subject is used to communicate changes in the model\r\nPublishSubject modelSubject = PublishSubject.create();\r\nmodelSubject.subscribe(model -> {\r\n    editText.setText(model.value());   // this will cause a new event in the stream below\r\n});\r\n\r\n// Observing changes in the form\r\nRxTextView.afterTextChangeEvents(editText)\r\n     .takeUntil(RxView.detaches(parent))\r\n     .filter(event -> event.editable() != null)\r\n     .withLatestFrom(modelSubject, (event, model) -> {\r\n          return Pair.create(event, model);\r\n     })\r\n     .filter(pair -> {\r\n         return !pair.val0().editable().toString()\r\n             .equals(String.valueOf(pair.val1().value()));\r\n         })\r\n     .debounce(512, TimeUnit.MILLISECONDS)\r\n     .map(pair -> RowAction.create(pair.val1().uid(),\r\n            pair.val0().editable().toString()))\r\n     .subscribe(processor::onNext, throwable -> {\r\n            throw new OnErrorNotImplementedException(throwable);\r\n      });\r\n```\r\n\r\nAs you can see, `modelSubject` here can trigger events in the `RxTextView.afterTextChangeEvents(editText)` stream, meaning that consequent call to the `.withLatestFrom()` should return the value which caused the event in the stream. \r\n\r\nIt is quite interesting that for the first event emitted by `RxTextView.afterTextChangeEvents(editText)`, `withLatestFrom()` captures correct model value. Let's say that we push second model through subject which triggers another event in `editText` observable. Instead of pulling newest model instance from `modelSubject`, `.withLatestFrom()` returns an old value which is not relevant anymore. ",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5342/comments",
    "author": "arazabishov",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-05-15T12:11:34Z",
        "body": "There are two subscribers to the `modelSubject` of which the first one triggers a text event change synchronously before the second subscriber is notified, thus when the `withLatestFrom` is reached you'll have the old model. Swap the two `subscribe()` calls which should make sure `withLatestFrom` is notified first.\r\n\r\nAlternatively, consider using `BehaviorSubject` and `map` by mapping in the `BehaviorSubject.getValue()` instead of `withLatestFrom`.\r\n\r\n```java\r\nBehaviorSubject modelSubject = BehaviorSubject.create();\r\n\r\n .map(event -> {\r\n      return Pair.create(event, modelSubject.getValue());\r\n })\r\n```"
      }
    ]
  },
  {
    "number": 5329,
    "title": "2.x Completable stops the chain",
    "created_at": "2017-05-02T12:57:35Z",
    "closed_at": "2017-05-02T17:28:18Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5329",
    "body": "I discovered that once Completable is done (method of `CompletableEmitter.onComplete()` is called), the chain stops and all operators are not called. \r\n\r\nSo I have the following source code\r\n```\r\nCompletable setup() {\r\n...\r\n}\r\n....\r\n            payment.setup()\r\n                          .toObservable()\r\n                          .flatMap(new Function<Object, ObservableSource<List<String>>() {\r\n                                       @Override\r\n                                       public ObservableSource<String>> apply(@io.reactivex.annotations.NonNull Object o) throws Exception {\r\n                                           return \"Some mapping is here\";\r\n                                       }\r\n                                   });\r\n```\r\n\r\nOnce `setup()` method finished successfully, `flatMap()` is not called. Is it supposed to be so? Is it possible to have a chain to Completable?",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5329/comments",
    "author": "dkhmelenko",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-05-02T13:02:22Z",
        "body": "`Completable` does not have values and `flatMap` doesn't work without values. Use `Completable.andThen`."
      }
    ]
  },
  {
    "number": 5314,
    "title": "The following error confuse packaging is complete, run times",
    "created_at": "2017-04-25T02:19:52Z",
    "closed_at": "2017-04-27T08:30:57Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5314",
    "body": "```\r\nProcess: www.pingyuan.yangplay, PID: 8040\r\nreactivex.exceptions.OnErrorNotImplementedException\r\n at io.reactivex.internal.functions.Functions$14.accept(Unknown Source)\r\n at io.reactivex.internal.functions.Functions$14.accept(Unknown Source)\r\n at io.reactivex.internal.observers.LambdaObserver.onError(Unknown Source)\r\n at io.reactivex.internal.observers.LambdaObserver.onNext(Unknown Source)\r\n at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.tryEmitScalar(Unknown Source)\r\n at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.subscribeInner(Unknown Source)\r\n at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.onNext(Unknown Source)\r\n at io.reactivex.internal.operators.observable.ObservableBuffer$BufferExactObserver.onNext(Unknown Source)\r\n at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.tryEmit(Unknown Source)\r\n at io.reactivex.internal.operators.observable.ObservableFlatMap$InnerObserver.onNext(Unknown Source)\r\n at io.reactivex.observers.SerializedObserver.onNext(Unknown Source)\r\n at io.reactivex.internal.operators.observable.ObservableConcatMap$SourceObserver$InnerObserver.onNext(Unknown Source)\r\n at io.reactivex.internal.operators.observable.ObservableScalarXMap$ScalarDisposable.run(Unknown Source)\r\n at io.reactivex.internal.operators.observable.ObservableJust.subscribeActual(Unknown Source)\r\n at io.reactivex.Observable.subscribe(Unknown Source)\r\n at io.reactivex.internal.operators.observable.ObservableConcatMap$SourceObserver.drain(Unknown Source)\r\n at io.reactivex.internal.operators.observable.ObservableConcatMap$SourceObserver.onSubscribe(Unknown Source)\r\n at io.reactivex.internal.operators.observable.ObservableFromIterable.subscribeActual(Unknown Source)\r\n at io.reactivex.Observable.subscribe(Unknown Source)\r\n at io.reactivex.internal.operators.observable.ObservableConcatMap.subscribeActual(Unknown Source)\r\n at io.reactivex.Observable.subscribe(Unknown Source)\r\n at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.subscribeInner(Unknown Source)\r\n at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.onNext(Unknown Source)\r\n at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.tryEmitScalar(Unknown Source)\r\n at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.subscribeInner(Unknown Source)\r\n at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.onNext(Unknown Source)\r\n at io.reactivex.internal.operators.observable.ObservableFromArray$FromArrayDisposable.run(Unknown Source)\r\n at io.reactivex.internal.operators.observable.ObservableFromArray.subscribeActual(Unknown Source)\r\n at io.reactivex.Observable.subscribe(Unknown Source)\r\n at io.reactivex.internal.operators.observable.ObservableFlatMap.subscribeActual(Unknown Source)\r\n at io.reactivex.Observable.subscribe(Unknown Source)\r\n at io.reactivex.internal.operators.observable.ObservableFlatMap.subscribeActual(Unknown Source)\r\n at io.reactivex.Observable.subscribe(Unknown Source)\r\n at io.reactivex.internal.operators.observable.ObservableBuffer.subscribeActual(Unknown Source)\r\n at io.reactivex.Observable.subscribe(Unknown Source)\r\n at io.reactivex.internal.operators.observable.ObservableFlatMap.subscribeActual(Unknown Source)\r\n at io.reactivex.Observable.subscribe(Unknown Source)\r\n at io.reactivex.Observable.subscribe(Unknown Source)\r\n at io.reactivex.Observable.subscribe(Unknown Source)\r\n at www.pingyuan.yangplay.ui.activity.MainActivity.j(Unknown Source)\r\n```",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5314/comments",
    "author": "AndroidAndYang",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-04-25T08:24:27Z",
        "body": "You are using `subscribe(Consumer<T>)` instead of `subscribe(Consumer<T>, Consumer<Throwable>)` and your `Consumer<T>` crashes."
      }
    ]
  },
  {
    "number": 5312,
    "title": "Disposable state in onComplete",
    "created_at": "2017-04-23T06:03:45Z",
    "closed_at": "2017-06-16T09:18:52Z",
    "labels": [
      "Question",
      "2.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5312",
    "body": "Hello! Version of RxJava is 2.0.9.\r\nIn my app I use ```Disposable```'s state to determine if some work is done or still running.\r\nI noticed, that in ```onComplete``` callback ```Single```'s ```Disposable``` returns ```true``` from isDisposed while ```Completable```'s ```Disposable``` returns ```false```.\r\n\r\nDoes it correct? Or I should not rely on ```Disposable``` state in ```onComplete``` callback?\r\n\r\nCode sample:\r\n```\r\nimport io.reactivex.Completable\r\nimport io.reactivex.Single\r\nimport io.reactivex.disposables.Disposable\r\nimport io.reactivex.schedulers.Schedulers\r\n\r\nfun main(args: Array<String>) {\r\n\r\n    var sin_disposable: Disposable? = null\r\n    sin_disposable = Single.just(34)\r\n            .subscribeOn(Schedulers.computation())\r\n            .observeOn(Schedulers.io())\r\n            .subscribe { _, _ ->\r\n                println(\"sin 1 ${sin_disposable?.isDisposed}\")\r\n            }\r\n    println(\"sin 2 ${sin_disposable?.isDisposed}\")\r\n\r\n    var \u0441om_disposable: Disposable? = null\r\n    \u0441om_disposable = Completable.complete()\r\n            .subscribeOn(Schedulers.computation())\r\n            .observeOn(Schedulers.io())\r\n            .subscribe({\r\n                println(\"\u0441om 1 ${\u0441om_disposable?.isDisposed} completed\")\r\n            }, { e ->\r\n                println(\"\u0441om 1 ${\u0441om_disposable?.isDisposed} error $e\")\r\n            })\r\n    println(\"\u0441om 2 ${\u0441om_disposable?.isDisposed}\")\r\n\r\n    Thread.sleep(1000)\r\n    println(\"sin 3 ${sin_disposable?.isDisposed}\")\r\n    println(\"\u0441om 3 ${\u0441om_disposable?.isDisposed}\")\r\n\r\n}\r\n```\r\n\r\nOutput is:\r\n```\r\nsin 2 false\r\nsin 1 true\r\n\u0441om 2 false\r\n\u0441om 1 false completed\r\nsin 3 true\r\n\u0441om 3 true\r\n```",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5312/comments",
    "author": "qwert2603",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-04-23T08:20:16Z",
        "body": "Relying on such external `isDisposed` is not recommended and is considered a non-reactive thinking. The Completable.subscribe() sets the disposed state after the callback, probably because some test wants to call dispose that propagates upstream."
      }
    ]
  },
  {
    "number": 5180,
    "title": "When using retryWhen why is there not a resubscription if the return is Observable.error(...)",
    "created_at": "2017-03-13T21:49:42Z",
    "closed_at": "2017-03-29T08:58:04Z",
    "labels": [
      "Question",
      "1.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/5180",
    "body": "Thanks for using RxJava but before you post an issue, please consider the following points:\r\n\r\n  - RxJava Version: 1.2.7\r\n\r\nOverview:\r\nI wanted to test the scenario where I use RxJava to poll a service. The expectation is that the service will return a list with transactions, an empty list, or an exception will be thrown. Whenever, a list with transactions is returned they will be published to any subscribe to the relevant Rx subject. From Rx perspective polling and retry will be indefinite by will be throttled and the intent is to use a circuit breaker higher up the call stack to reduce necessary calls when the server is not available. \r\n\r\nIn my research all works as expected if you return list data, empty list or throw an exception. However, if one was to return say:\r\n\r\n  Observable.error(new RuntimeException());\r\n\r\nThen resubscription does not appear to take place.\r\n\r\nHere's the pretty much self contain code.  I've made it so that I can simulate having a mix of list items, empty list or exception returning. I can also have a specific set of the above options return. Additionally, I can simulate throwing an exception or returning Observable.error(...).\r\n\r\n```java\r\npackage com.shapestone.transaction.publisher;\r\n\r\nimport rx.Observable;\r\nimport rx.Observer;\r\nimport rx.Subscription;\r\nimport rx.subjects.PublishSubject;\r\nimport rx.subjects.Subject;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\nimport java.util.Random;\r\nimport java.util.concurrent.TimeUnit;\r\n\r\nimport static java.lang.String.format;\r\nimport static rx.Observable.just;\r\nimport static rx.Observable.timer;\r\n\r\n/**\r\n * Date: 3/13/17.\r\n */\r\npublic class TransactionSubjectPlaypen {\r\n  enum ExceptionType { OBSERVABLE_EXCEPTION, THROW_EXCEPTION}\r\n  private static ExceptionType exceptionType;\r\n  private static final int COUNTER_START = 1;\r\n  private static final int ATTEMPTS = 5;\r\n  private static final int ORIGINAL_DELAY_IN_SECONDS = 10;\r\n  private Subject<TestTransaction, TestTransaction> transactionSubject;\r\n\r\n  public TransactionSubjectPlaypen() {\r\n    this.transactionSubject = PublishSubject.create();\r\n  }\r\n\r\n  public static void main(String[] args) {\r\n    try {\r\n      exceptionType = ExceptionType.THROW_EXCEPTION;\r\n      final TransactionSubjectPlaypen transactionSubjectPlaypen = new TransactionSubjectPlaypen();\r\n      transactionSubjectPlaypen.subscribe(new TestTransactionObserver());\r\n      transactionSubjectPlaypen.start();\r\n      Thread.sleep(120000);\r\n    } catch (InterruptedException e) {\r\n      e.printStackTrace();\r\n    }\r\n  }\r\n\r\n  public Subscription subscribe(Observer<TestTransaction> transactionObserver) {\r\n    return transactionSubject.subscribe(transactionObserver);\r\n  }\r\n\r\n  public void start() {\r\n    startPeriodicTransactionRetrieval();\r\n  }\r\n\r\n  // Emits Transaction\r\n\r\n  private void startPeriodicTransactionRetrieval() {\r\n    System.out.println(\"TransactionSubjectPlaypen.startPeriodicTransactionRetrieval\");\r\n    TransactionSubjectPlaypen.exceptionType = ExceptionType.OBSERVABLE_EXCEPTION;\r\n    Observable.fromCallable(() -> pollRemoteForTransactions(1))\r\n      .retryWhen(errors -> {\r\n        System.out.println(\"retryWhen\");\r\n        return errors.flatMap(error -> {\r\n          return Observable.just(null);\r\n        });\r\n      })\r\n      .repeatWhen(observable -> {\r\n        System.out.println(\"repeatWhen\");\r\n        return observable.concatMap(v -> timer(4, TimeUnit.SECONDS));\r\n      })\r\n      .flatMap(listObservable -> {\r\n       return listObservable;\r\n      }).flatMapIterable(testTransactions -> {\r\n        return testTransactions;\r\n      }).subscribe(transactionSubject);\r\n  }\r\n\r\n  // This is a bit superfluous however it is included to gave a more complete understanding of the problem.\r\n  private Observable<List<TestTransaction>> pollRemoteForTransactions(Integer i) {\r\n    System.out.println(\"TransactionSubjectPlaypen.pollRemoteForTransactions\");\r\n    return remoteServiceClientSimulation(i);\r\n  }\r\n\r\n  private Observable<List<TestTransaction>> remoteServiceClientSimulation(Integer i) {\r\n    System.out.println(\"TransactionSubjectPlaypen.remoteServiceClientSimulation\");\r\n    try {\r\n      randomNetworkDelaySimulation();\r\n      return getTransactions(i);\r\n    } catch (InterruptedException e) {\r\n      throw new RuntimeException(e.getMessage());\r\n    }\r\n  }\r\n\r\n  private void randomNetworkDelaySimulation() throws InterruptedException {\r\n    System.out.println(\"TransactionSubjectPlaypen.randomNetworkDelaySimulation\");\r\n    final int MAX_DELAY = 8000;\r\n    Thread.sleep(new Random().nextInt(MAX_DELAY));\r\n  }\r\n\r\n  @SuppressWarnings(\"Duplicates\")\r\n  private Observable<List<TestTransaction>> getTransactions(Integer requestedOption) {\r\n    System.out.println(\"TransactionSubjectPlaypen.getTransactions\");\r\n    final List<TestTransaction> transactions = new ArrayList<>();\r\n    int ZERO_RETURN_TRANSACTIONS = 0, ONE_RETURN_EXCEPTION = 1;\r\n\r\n    int MAX_OPTIONS = 3;\r\n    final int i = (requestedOption != null ? requestedOption : new Random().nextInt(MAX_OPTIONS));\r\n    if (i == ZERO_RETURN_TRANSACTIONS) {\r\n\r\n      transactions.add(new TestTransaction(\"addVendor\"));\r\n      transactions.add(new TestTransaction(\"addPersonAccount\"));\r\n      transactions.add(new TestTransaction(\"addSystemAccount\"));\r\n      transactions.add(new TestTransaction(\"addDeploymentContext\"));\r\n      transactions.add(new TestTransaction(\"addProperty\"));\r\n\r\n      System.out.println(format(\"Return %d transaction\", transactions.size()));\r\n\r\n      return just(transactions);\r\n\r\n    } else if (i == ONE_RETURN_EXCEPTION) {\r\n\r\n      if (exceptionType == ExceptionType.THROW_EXCEPTION) {\r\n        System.out.println(\"Return exception\");\r\n        throw new RuntimeException();\r\n        //return error(new RuntimeException());\r\n      } else {\r\n        System.out.println(format(\"Returning %d transaction\", transactions.size()));\r\n        return Observable.error(new RuntimeException());\r\n      }\r\n    } else {\r\n\r\n      System.out.println(format(\"Returning %d transaction\", transactions.size()));\r\n      return just(transactions);\r\n\r\n    }\r\n\r\n  }\r\n\r\n  public static class TestTransactionObserver implements Observer<TestTransaction> {\r\n\r\n    @Override\r\n    public void onCompleted() {\r\n      System.out.println(\"TestTransactionObserver.onCompleted\");\r\n    }\r\n\r\n    @Override\r\n    public void onError(Throwable e) {\r\n      System.out.println(\"TestTransactionObserver.onError\");\r\n      System.out.println(e);\r\n    }\r\n\r\n    @Override\r\n    public void onNext(TestTransaction testTransaction) {\r\n      System.out.println(\"TestTransactionObserver.onNext\");\r\n      System.out.println(\"Value = \" + testTransaction);\r\n    }\r\n  }\r\n\r\n  public static class TestTransaction {\r\n    private String name;\r\n\r\n    public TestTransaction() {\r\n    }\r\n\r\n    public TestTransaction(String name) {\r\n      this.name = name;\r\n    }\r\n\r\n    public String getName() {\r\n      return name;\r\n    }\r\n\r\n    public void setName(String name) {\r\n      this.name = name;\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n      return \"TestTransaction{\" +\r\n        \"name='\" + name + '\\'' +\r\n        '}';\r\n    }\r\n  }\r\n\r\n}\r\n```",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/5180/comments",
    "author": "michaaelw",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2017-03-13T22:10:59Z",
        "body": "The `pollRemoteForTransactions` returns an `Observable` from the `fromCallable` which is considedered a success value and thus `retryWhen` doesn't see its inner exception. Only the first `flatMap` will unbox it and will find the error, but ther is no `retryWhen` further down. \r\n\r\nNote that error handling such as `retryWhen` can operate on errors that are above them, not below in the chain. \r\n\r\nPlace the `retryWhen` and `repeatWhen` just before the `subscribe()` call and you should see the retry/repeat happening."
      }
    ]
  },
  {
    "number": 4847,
    "title": "RxJava 1.x onCompleted is never called?",
    "created_at": "2016-11-14T15:33:28Z",
    "closed_at": "2016-11-15T14:20:43Z",
    "labels": [
      "Question",
      "1.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4847",
    "body": "Hi, \r\n\r\nI have the following code to demonstrate the problem.\r\n\r\n```Java\r\nCountDownLatch latch = new CountDownLatch(1);\r\n        \r\nObservable<Integer> stream1 = Observable.range(1, 3);\r\nObservable<Integer> stream2 = stream1\r\n        .flatMap(a -> {\r\n            return Observable.fromEmitter(emitter -> {\r\n                Thread t = new Thread(() -> {\r\n                    if (a == 3) {\r\n                        emitter.onCompleted();\r\n                    } else {\r\n                        emitter.onNext(a + 1000);\r\n                    }\r\n                });\r\n                System.out.println(Thread.currentThread().getName() + \" Created a-thread for \" + a);\r\n                t.setName(\"a-thread\");\r\n                t.start();\r\n            }, Emitter.BackpressureMode.NONE);\r\n        });\r\n        stream2\r\n                .doOnUnsubscribe(()-> System.out.println(Thread.currentThread().getName() + \" Unsubscribed.\"))\r\n                .subscribe(a -> {\r\n                    System.out.println(Thread.currentThread().getName() + \" processing: \" + a);\r\n                },\r\n                System.err::println,\r\n                () -> {\r\n                    System.out.println(Thread.currentThread().getName() + \" processed complete.\");\r\n                    latch.countDown();\r\n                });\r\nlatch.await();\r\n```\r\n\r\nI am expecting \" processed complete.\" will be called but it never did. I am using rxJava 1.2.2.\r\nAlso, would the Observer#onCompleted being called if the \"emitter.onCompleted()\" had been commented out from the above?",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4847/comments",
    "author": "lawkai",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-11-14T18:03:03Z",
        "body": "You have to call `emitter.onCompleted()` for all `Observable`s because `flatMap` completes only if both the upstream and all the inner `Observable`s complete. You complete only the `Observable` for `a == 3` and keep the others alive.\n"
      }
    ]
  },
  {
    "number": 4840,
    "title": "Why  resubscribe the source observable emit same output when I use retryWhen operator?",
    "created_at": "2016-11-12T09:58:00Z",
    "closed_at": "2016-11-12T21:01:06Z",
    "labels": [
      "Question",
      "1.x"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4840",
    "body": "code:\r\n```java\r\nstr = \"aaa\";\r\n        Observable.just(str).map(new Func1<String, String>() {\r\n                    @Override\r\n                    public String call(String s) {\r\n                        Log.i(\"====\", \"s == \" + s);\r\n                        if (\"aaa\".equals(s)) throw new RuntimeException(s);\r\n                        return s + \"123\";\r\n                    }\r\n                }).retryWhen(new Func1<Observable<? extends Throwable>, Observable<?>>() {\r\n                    @Override\r\n                    public Observable<?> call(Observable<? extends Throwable> observable) {\r\n                        return observable.zipWith(Observable.range(1, 4), new Func2<Throwable, Integer, Integer>() {\r\n                            @Override\r\n                            public Integer call(Throwable throwable, Integer i) {\r\n                                str = \"ggg\";\r\n                                return i;\r\n                            }\r\n                        }).flatMap(new Func1<Integer, Observable<? extends Long>>() {\r\n                            @Override\r\n                            public Observable<? extends Long> call(Integer retryCount) {\r\n                                return Observable.timer(1, TimeUnit.SECONDS);\r\n                            }\r\n                        });\r\n                    }\r\n                }).subscribe(new Action1<String>() {\r\n                    @Override\r\n                    public void call(String s) {\r\n                        Log.i(\"====k\", \"s = \" + s);\r\n                    }\r\n                }, new Action1<Throwable>() {\r\n                    @Override\r\n                    public void call(Throwable throwable) {\r\n                        Log.i(\"====\", \"throwable = \" + throwable.getMessage());\r\n                    }\r\n                });\r\n```\r\nIn my opinion\uff0cit should log\r\n```\r\naaa\r\nggg\r\nggg\r\n...\r\n```\r\nbut in fact it always log\r\n```\r\naaa\r\naaa\r\naaa\r\n...\r\n```\r\nwhy?",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4840/comments",
    "author": "fanturbo",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-11-12T11:10:48Z",
        "body": "`Observable.just(str)` captures `str`'s value and is a constant `Observable` in this regard, no matter how `str` changes afterwards. Use `Observable.fromCallable(() -> str)` to get a fresh value each time there is a retry.\n"
      },
      {
        "user": "fanturbo",
        "created_at": "2016-11-12T12:50:26Z",
        "body": "@akarnokd When I use retrofit & rxjava in project,api return type is Observable,is it a constant Observable?I use cookie in request,and when cookie is invalid,i request new cookie(cookie is a String type member variable) in retrywhen and i got same error from server afterwards because the cookie is old cookie.Why is Observable.just(str) a constant Observabl?Is it because of str's String type?or other reasons?Thanks for your reply.\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-11-12T12:59:01Z",
        "body": "Let me illustrate the situation with a classical example program:\n\n``` java\npublic class Example {\n    static String str;\n\n    public static void main(String[] args) {\n        str = \"aaa\";\n\n        String local = str;\n\n        str = \"ggg\";\n\n        System.out.println(local);\n        System.out.println(local);\n        System.out.println(local);\n    }\n}\n```\n\nCan you tell what this program prints to the console?\n"
      },
      {
        "user": "fanturbo",
        "created_at": "2016-11-22T01:49:03Z",
        "body": "@akarnokd \r\nI am sorry about  so late to ask this.\r\nI use rxjava&retrofit in my project.\r\n`@GET(\"group/{id}/users\")\r\nObservable<List<User>> groupList(@Path(\"id\") int groupId);`\r\nIs this return Observable also a constant Observable ?"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-11-22T07:55:47Z",
        "body": "No."
      },
      {
        "user": "fanturbo",
        "created_at": "2016-11-22T09:21:23Z",
        "body": "@akarnokd okay,it's the same question.groupId is member variable,when i first request from server i set groupid 0 and server return 404.and in retrywhen i changed groupId value,but i find in charles that in Request groupId is 0,too.(Now i use OkHttp interceptor to resolve this problem.But i want to know why groupId didn't change in second retry?)"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-11-22T09:27:49Z",
        "body": "How do you call `groupList()`? If you call it once and resubscribe to the returned Observable, that request path `id` is baked in:\r\n\r\n```java\r\nint groupId = 0;\r\n\r\nObservable<List<User>> obs1 = groupList(groupId);\r\n\r\ngroupId = 1;\r\n\r\nobs1.subscribe(v -> { }, Throwable::printStackTrace);\r\n```\r\n\r\nDo you think the last line will request with `groupId == 1` ?"
      },
      {
        "user": "fanturbo",
        "created_at": "2016-11-22T09:57:42Z",
        "body": "```java\r\nApiClient.groupList(groupId)\r\n                .map(new Func1<List<User>, List<User>>() {\r\n                    @Override\r\n                    public List<User> call(List<User> list) {\r\n                        if (list.size() == 0) {\r\n                            throw new RuntimeException(\"gg\");\r\n                        }\r\n                        return list;\r\n                    }\r\n                })\r\n                .retryWhen(new RetryWithDelay(3, 2000))\r\n                .subscribeOn(Schedulers.io())\r\n                .observeOn(AndroidSchedulers.mainThread())\r\n                .subscribe(new Action1<List<User>>() {\r\n                    @Override\r\n                    public void call(List<User> response) {\r\n                        fillData(response);\r\n                    }\r\n                }, new Action1<Throwable>() {\r\n                    @Override\r\n                    public void call(Throwable throwable) {\r\n                        Log.i(\"===========k3\", throwable.toString());\r\n                    }\r\n                });\r\n```\r\nthis is my code.I change groupId in RetryWithDelay's call method.what's wrong with the code?\r\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-11-22T10:13:55Z",
        "body": "You don't seem to understand how a value read from a variable won't change if you change the variable. Use `defer`:\r\n\r\n```java\r\nObservable.defer(() -> ApiClient.groupList(groupId))\r\n   // ... the rest\r\n```"
      },
      {
        "user": "fanturbo",
        "created_at": "2016-11-22T14:22:29Z",
        "body": "@akarnokd yes,I didn't understand where differences are between Observable.just and Observable.fromCallable.Since you say 'No',I think retrofit's return Observable is like Observable.fromCallable,it is not a constant Observable and it will use fresh value when retry again.\r\nBut i was wrong.retrywhen operator's meaning is resubscribe source Observable,in my code,it is constant because ApiClient.groupList(groupId)) has produced,it is like Observable.just.(I think you should say 'Yes' because I think retrofit's return Observable is like a constant Observable) But when use \r\nObservable.defer,the result is different because defer operator decides the Observable is new(use fresh variable) when subscribe.\r\nThanks for your help!love you!"
      }
    ]
  },
  {
    "number": 4829,
    "title": "subscribeOn (rx.Scheduler) in Observable\u00a0cannot be applied to (io.reactivex.Scheduler) ",
    "created_at": "2016-11-10T07:49:33Z",
    "closed_at": "2016-11-10T15:34:52Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4829",
    "body": "   Gradle:\r\n    // \u7f16\u8bd1RxJava\r\n    compile 'io.reactivex:rxjava:1.2.2'\r\n    // \u7f16\u8bd1RxAndroid\r\n    compile 'io.reactivex:rxandroid:1.2.1'\r\n    // \u7f16\u8bd1Retrofit\u7f51\u7edc\u52a0\u8f7d\u6846\u67b6\r\n    compile 'com.squareup.retrofit2:retrofit:2.1.0'\r\n    // \u7f16\u8bd1Retrofit\u7f51\u7edc\u52a0\u8f7d\u6846\u67b6\u76f4\u63a5\u89e3\u6790JSON\u6570\u636e\u53d8\u6210JAVA\u5bf9\u8c61\r\n    compile 'com.squareup.retrofit2:converter-gson:2.1.0'\r\n    // \u7f16\u8bd1Retrofit\u5bf9RxJava\u7684\u652f\u6301\r\n    compile 'com.jakewharton.retrofit:retrofit2-rxjava2-adapter:1.0.0'",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4829/comments",
    "author": "ljf1172361058",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-11-10T08:26:37Z",
        "body": "You have the wrong imports:\n\n```\ncompile 'io.reactivex.rxjava2:rxjava:2.0.0'\ncompile 'io.reactivex.rxjava2:rxandroid:2.0.0'\n```\n"
      }
    ]
  },
  {
    "number": 4608,
    "title": "1.x @Beta and @Experimental annotations are annotated with itself. ",
    "created_at": "2016-09-26T14:08:31Z",
    "closed_at": "2016-09-26T22:11:03Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4608",
    "body": "In branch 1.x both @Beta and @Experimental annotations are annotated with itself. That's not the case for the branch 2.x.\n\nI don't understand the purpose of annotating those annotation with itself. Should they not be annotated? \n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4608/comments",
    "author": "VictorAlbertos",
    "comments": [
      {
        "user": "zsxwing",
        "created_at": "2016-09-26T19:42:45Z",
        "body": "I guess it's added when they were experimental but we totally forgot to delete them. I think we can remove them now since they are definitely stable APIs.\n\n@VictorAlbertos  could you submit a PR to remove them?\n"
      }
    ]
  },
  {
    "number": 4511,
    "title": "skipUntil with \"empty\" observable causes source obs to never complete.",
    "created_at": "2016-09-08T14:31:02Z",
    "closed_at": "2016-09-08T15:31:59Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/4511",
    "body": "Hello,\n\n``` java\nObservable.interval(1, TimeUnit.SECONDS)\n      .doOnNext(n -> Timber.d(\"firstObs %s\", n))\n      .doOnUnsubscribe(() -> Timber.d(\"onUnsubscribe\"))\n      .doOnCompleted(() -> Timber.d(\"onCompleted\"))\n      .skipUntil(Observable.timer(3, TimeUnit.SECONDS)\n        .flatMap(b -> Observable.empty())\n        .doOnCompleted(() -> Timber.d(\"onCompleted2\")))\n      .subscribe(\n        n -> Timber.d(\"Next? %s\",n),\n        e -> Timber.d(e, \"Err\"),\n        () -> Timber.d(\"Completed\")\n      );\n    Timber.d(\"Ciao\");\n```\n\nLooking at this snippet I would expect \"Completed\" to be triggered upon skipUntil observable completion ('after 3 seconds'). \n\nAfter some time of debugging I found out it's not the case and the Source observable does not get \"onCompleted\" or \"onUnsubscribe\" called when the latter `skipUntil` obs completes its execution.\n\nThis means that the first obs is never gonna end and the emitted items are not going to reach the end of the chain\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/4511/comments",
    "author": "vekexasia",
    "comments": [
      {
        "user": "JakeWharton",
        "created_at": "2016-09-08T14:34:29Z",
        "body": "flatMap does not propagate completion events\n"
      },
      {
        "user": "vekexasia",
        "created_at": "2016-09-08T14:52:48Z",
        "body": "why do I get the following output \n\n```\n09-08 16:50:05.670 D/MainActivity: onSubscribe2\n09-08 16:50:05.672 D/MainActivity: onSubscribe\n09-08 16:50:05.674 D/MainActivity: Ciao\n09-08 16:50:06.674 D/MainActivity: firstObs 0\n09-08 16:50:07.674 D/MainActivity: firstObs 1\n09-08 16:50:08.672 D/MainActivity: onCompleted2\n09-08 16:50:08.672 D/MainActivity: onUnsubscribe2\n09-08 16:50:08.674 D/MainActivity: firstObs 2\n09-08 16:50:09.674 D/MainActivity: firstObs 3\n09-08 16:50:10.674 D/MainActivity: firstObs 4\n...\n```\n\nwhen using the following code then?\n\n``` java\nObservable.interval(1, TimeUnit.SECONDS)\n      .doOnNext(n -> Timber.d(\"firstObs %s\", n))\n      .doOnSubscribe(() -> Timber.d(\"onSubscribe\"))\n      .doOnUnsubscribe(() -> Timber.d(\"onUnsubscribe\"))\n      .doOnCompleted(() -> Timber.d(\"onCompleted\"))\n      .skipUntil(Observable.timer(3, TimeUnit.SECONDS)\n        .flatMap(b -> Observable.empty())\n        .doOnCompleted(() -> Timber.d(\"onCompleted2\"))\n        .doOnSubscribe(() -> Timber.d(\"onSubscribe2\"))\n        .doOnUnsubscribe(() -> Timber.d(\"onUnsubscribe2\"))\n      )\n      .subscribe(\n        n -> Timber.d(\"Next? %s\", n),\n        e -> Timber.d(e, \"Err\"),\n        () -> Timber.d(\"Completed\")\n      );\n    Timber.d(\"Ciao\");\n```\n"
      },
      {
        "user": "JakeWharton",
        "created_at": "2016-09-08T14:56:57Z",
        "body": "Because timer completes. I guess you're just using that as an `ignoreElements()`?\n"
      },
      {
        "user": "vekexasia",
        "created_at": "2016-09-08T14:59:19Z",
        "body": "Actually I was hoping that when the skipUntil observable completes, then \"parent\".\"unsubscribe\"  is triggered so that no more elements are sent through the pipeline.\n"
      },
      {
        "user": "JakeWharton",
        "created_at": "2016-09-08T15:00:28Z",
        "body": "`skipUntil` is documented to require an emission to unlatch upstream events so all you need to do is remove your `flatMap`.\n\n> Returns an Observable that skips items emitted by the source Observable until a second Observable emits an item.\n"
      },
      {
        "user": "vekexasia",
        "created_at": "2016-09-08T15:04:35Z",
        "body": "the code above is just as \"sample\". Consider an observable that completes after three seconds without emitting any item (used as skipUntil parameter).\n\nIn such case the first obs will just continue emit its elements without ever completing (and without any chance for the items to reach the end of the chain) \n"
      },
      {
        "user": "vekexasia",
        "created_at": "2016-09-08T15:11:48Z",
        "body": "Just to mention that I rewrote the OperatorSkipUntil so that it unsubscribes from `child` when `other` completes without emitting any element.\n\nI figured it would be something to raise here since someone might expect the same behavior ( if `other` completes without emitting any elements then unsubscribe from `child`)\n"
      },
      {
        "user": "JakeWharton",
        "created_at": "2016-09-08T15:17:01Z",
        "body": "Ahhh, I see. That makes sense I think. I thought you were proposing that it become unlatched when the inner observable completes.\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-09-08T15:22:45Z",
        "body": "Yes, `skipUntil` requires the other `Observable` to signal an item in 1.x and just ignores an empty other `Observable`. In 2.x `skipUntil` enables the gate when the source either signals or just completes.\n\nThis signals-or-completes is a common practice in such operators that take auxiliary sources to trigger one-time events. I guess the 1.x `skipUntil` not opening the gate on a plain `onComplete` is a bug.\n"
      }
    ]
  },
  {
    "number": 3976,
    "title": "Only part of chain executed after exception",
    "created_at": "2016-05-31T17:30:20Z",
    "closed_at": "2016-06-05T09:49:33Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3976",
    "body": "Hi. Rx java is pretty new to me and I have one problem that I can't understand. After exception only part of my operator chain is executed for next objects and I don't know why. \nI have kafka consumer that polls server for messages and then turns them in infinitie observable:\n\n<!-- language: lang-java-->\n\n```\npublic Observable<Event> consume() {\n    return Observable.create(subscriber -> {\n        try {\n            consumer.subscribe(Arrays.asList(topic));\n\n            while (running) {\n                ConsumerRecords<String, Event> records = consumer.poll(pollTimeout);\n                for (TopicPartition partition : records.partitions()) {\n                    for (ConsumerRecord<String, Event> record : records.records(partition)) {\n                        Event event= record.value();\n                        subscriber.onNext(event);\n\n                        long offfset = record.offset() + 1;\n                        consumer.commitSync(Collections.singletonMap(partition, new OffsetAndMetadata(offfset)));\n                        LOGGER.info(\"Comitted offset \"+offfset);\n                    }\n                }\n            }\n            subscriber.onCompleted();\n        } catch (Exception ex) {\n            LOGGER.error(\"Exception thrown during events consuming\", ex);\n            subscriber.onError(ex);\n        }\n    });\n}\n```\n\nAnd here is my problem:\n\n```\n    public Observable<ProcessDoneEvent> doSth(Event event) {\n    String vin = event.getVin();\n    return vehicleStateRepository.getState(vin)\n            .filter(state -> shouldProcess(state, event))\n            .flatMap((State state) -> {\n                return backendService.getVehicle(vin)\n                        .map(this::getCarLicense)\n                        .flatMap((CarLicense carLicense) -> api.apiAction(carLicense)\n                                .map((ActionConfirmation confirmation) -> {\n                                    log(carLicense, confirmation, event);\n                                    return confirmation;\n                                })\n                                .flatMap((ActionConfirmation t) -> {\n                                    return vehicleStateRepository.saveState(vin, State.IDLE)\n                                            .map((String sth) -> createProcessDoneEvent(vin));\n                                }));\n            });\n}\n```\n\nIn normal situation all operators are executed, state is fetched from db, api is called and finally vehicle state is saved in db. And this is working fine for any amount of events.\n\nNow lets consider situation that timeout occurred in backendService.getVehicle(vin). Exception is handled in retry operator and we are ready for next events. And now what happens - for next events, only lines above api.apiAction(carLicense)(including) are executed and lines below are skipped. So result is that: vehicle state is fetched, api is called and then control returns to loop in message consumer so it's committing new offset without saving vehicle state to db and logging it. \n\nWhy is this happening? :(\n\nAlso here is code with subscription:\n\n```\n    public void startConsuming() {\n\n    consumer.consume() <- code in first posted snipplet\n            .flatMap(this::doAction)\n            .retry((count, e) -> {\n                LOGGER.error(\"aaaaaaaa\", e);\n                return true;\n            }).subscribe(subscriber);\n}\n\nprivate Observable<ProcessDoneEvent> doAction(Event event) {\n    if (Event.getEventType().equals(EventType.TYPE_ONE)) {\n        return process.doSth(event); <- this is method posted above\n    } else {\n        return process.doSthOther(event);\n    }\n}\n```\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3976/comments",
    "author": "slawomirbiernacki",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-05-31T20:12:29Z",
        "body": "For one, you didn't implement unsubscription in your `create`d `Observable` properly. You should check `subscriber.isUnsubscribed()` and quit the method if `true`. Second, many operators have either variants or parameters that allow delaying errors to the end, they should allow you to finish up with good values before failing/retrying.\n"
      }
    ]
  },
  {
    "number": 3967,
    "title": "error when Zipping 2 publish subjects asynchroneously",
    "created_at": "2016-05-26T09:16:52Z",
    "closed_at": "2016-05-26T09:57:33Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3967",
    "body": "Hi,\n\nI'm having some weird problem I've tried to simplify.\n\nTake for instance the following code:\n\n``` java\n        for (int i = 0; i < 500; i++) {\n            Subject<Integer, Integer> s1 = PublishSubject.<Integer> create().toSerialized();\n            Subject<Integer, Integer> s2 = PublishSubject.<Integer> create().toSerialized();\n\n            Observable.zip(s1.single(), s2.toList(), (a, b) -> null)\n                .subscribeOn(Schedulers.io())\n                .subscribe(\n                    j -> {},\n                    t -> {\n                        t.printStackTrace();\n                    });\n\n            s1.onNext(1);\n            s2.onNext(1);\n            s1.onCompleted();\n            s2.onCompleted();\n        }\n        Thread.sleep(5000);\n```\n\nI'm often getting the following error:\n\n```\njava.util.NoSuchElementException: Sequence contains no elements\n    at rx.internal.operators.OperatorSingle$ParentSubscriber.onCompleted(OperatorSingle.java:131)\n    at rx.internal.operators.NotificationLite.accept(NotificationLite.java:140)\n    at rx.subjects.SubjectSubscriptionManager$SubjectObserver.accept(SubjectSubscriptionManager.java:318)\n    at rx.subjects.SubjectSubscriptionManager$SubjectObserver.emitLoop(SubjectSubscriptionManager.java:291)\n    at rx.subjects.SubjectSubscriptionManager$SubjectObserver.emitFirst(SubjectSubscriptionManager.java:270)\n    at rx.subjects.PublishSubject$1.call(PublishSubject.java:66)\n    at rx.subjects.PublishSubject$1.call(PublishSubject.java:62)\n    at rx.subjects.SubjectSubscriptionManager.add(SubjectSubscriptionManager.java:95)\n    at rx.subjects.SubjectSubscriptionManager.call(SubjectSubscriptionManager.java:60)\n    at rx.subjects.SubjectSubscriptionManager.call(SubjectSubscriptionManager.java:35)\n    at rx.Observable.unsafeSubscribe(Observable.java:8172)\n    at rx.subjects.SerializedSubject$1.call(SerializedSubject.java:45)\n    at rx.subjects.SerializedSubject$1.call(SerializedSubject.java:41)\n    at rx.Observable$2.call(Observable.java:162)\n    at rx.Observable$2.call(Observable.java:154)\n    at rx.Observable.unsafeSubscribe(Observable.java:8172)\n    at rx.internal.operators.OperatorZip$Zip.start(OperatorZip.java:209)\n    at rx.internal.operators.OperatorZip$ZipSubscriber.onNext(OperatorZip.java:156)\n    at rx.internal.operators.OperatorZip$ZipSubscriber.onNext(OperatorZip.java:122)\n    at rx.internal.util.ScalarSynchronousObservable$1.call(ScalarSynchronousObservable.java:46)\n    at rx.internal.util.ScalarSynchronousObservable$1.call(ScalarSynchronousObservable.java:35)\n    at rx.Observable$2.call(Observable.java:162)\n    at rx.Observable$2.call(Observable.java:154)\n    at rx.Observable.unsafeSubscribe(Observable.java:8172)\n    at rx.internal.operators.OperatorSubscribeOn$1$1.call(OperatorSubscribeOn.java:62)\n    at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:55)\n    at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n    at java.util.concurrent.FutureTask.run(FutureTask.java:266)\n    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180)\n    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293)\n    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)\n    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\n    at java.lang.Thread.run(Thread.java:745)\n```\n\nI'm not sure what's going wrong here. It would seem that from time to time, the `s1` subject receives the onCompleted before the onNext.\n\nI saw that removing `.subscribeOn(Schedulers.io())` fixes this but I'd like to understand why.\nDepending on that I could come up with an other solution to what i'm trying to do.\n\nThanks\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3967/comments",
    "author": "Crystark",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-05-26T09:25:37Z",
        "body": "Because you subscribe on a different thread, the two subjects don't have any subscriber yet when you call onXXX on them, dropping the values. Once zip can subscribe, both may end up being completed and thus the first source will signal the `NoSuchElementException`. \n"
      },
      {
        "user": "Crystark",
        "created_at": "2016-05-26T09:50:25Z",
        "body": "Indeed, I can see it now. Thanks for the explanation.\nSo if I understand this well, using a `ReplaySubject` seems to be the way to go if I want to keep this order of code ?\n"
      }
    ]
  },
  {
    "number": 3920,
    "title": "a Subscriber object  only has effect when be subscribed first time by Observable.just(...).subscribe()",
    "created_at": "2016-05-09T07:34:28Z",
    "closed_at": "2016-05-18T22:44:38Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3920",
    "body": "I just test Observable.just(...) by click a button;\n`private void rxUseJustCreateObserable(){\n        Log.d(TAG,\"rxUseJustCreateObserable\");\n        Observable<String> observable = Observable.just(\"just 1\",\"just 2\");\n       ...}`\n\n**1.**if I use `observable.subscribe(mSubscriber);`  only the first time when I click button it has effect;\n\n**2.**if I use `observable.subscribe(new Subscriber<String>(){...});` every time I click  button, it's has effect;\n\nwhat the different between **1** and**2** ?\ncould anyone give me an answer?\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3920/comments",
    "author": "gaobq",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-05-09T07:41:00Z",
        "body": "`Subscriber` instances are not reusable, you may want to use `Observer` instead.\n"
      }
    ]
  },
  {
    "number": 3801,
    "title": "PublishSubject: OnNext Not delivered or OnNext delivered on wrong Thread",
    "created_at": "2016-03-27T20:58:37Z",
    "closed_at": "2016-03-27T21:36:17Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3801",
    "body": "I was writing some automated test to verify the behaviour of PublishSubject and I noticed strange and unexpected behaviour when the subject is subscribed on a Scheduler. If I do not put a sleep after the subscriber, I will not get the onNext items but the onCompleted is called on the correct Thread. If I put a sleep after subscribing, the subscriber receives the onNext items but on the wrong thread. It receives the onNext items on the thread that called the subject.onNext.\n\nI wrote some unit test to show the behaviour. Both tests will fail with rxjava 1.1.2. Is this a bug or is this expected behavior and where can I find this in the documentation? \n\n``` java\nimport org.junit.Test;\nimport rx.observers.TestSubscriber;\nimport rx.subjects.PublishSubject;\n\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static rx.schedulers.Schedulers.newThread;\n\npublic class PublishSubjectTest {\n\n    @Test\n    public void subscribeOn_WhenNoSleep_ThenNoOnNextReceived() throws InterruptedException {\n\n        // GIVEN\n        PublishSubject<String> subject = PublishSubject.create();\n        Thread currentThread = Thread.currentThread();\n        TestSubscriber<String> subscriber = new TestSubscriber<>();\n\n        // WHEN\n        subject.subscribeOn(newThread()).subscribe(subscriber);\n        subject.onNext(\"one\");\n        subject.onCompleted();\n\n        // THEN\n        subscriber.awaitTerminalEvent();\n        assertThat(subscriber.getLastSeenThread()).isNotSameAs(currentThread);\n        assertThat(subscriber.getOnNextEvents()).containsOnly(\"one\");\n\n    }\n\n    @Test\n    public void subscribeOn_WhenSleep_ThenOnNextReceivedButOnWrongThread() throws InterruptedException {\n\n        // GIVEN\n        PublishSubject<String> subject = PublishSubject.create();\n        Thread currentThread = Thread.currentThread();\n        TestSubscriber<String> subscriber = new TestSubscriber<>();\n\n        // WHEN\n        subject.subscribeOn(newThread()).subscribe(subscriber);\n        Thread.sleep(2000);\n        subject.onNext(\"one\");\n        subject.onCompleted();\n\n        // THEN\n        subscriber.awaitTerminalEvent();\n        assertThat(subscriber.getOnNextEvents()).containsOnly(\"one\");\n        assertThat(subscriber.getLastSeenThread()).isNotSameAs(currentThread);\n\n    }\n\n}\n```\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3801/comments",
    "author": "bdeneuter",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-03-27T21:14:05Z",
        "body": "The problem is that you use `subscribeOn` instead of `observeOn` to move the delivery of events to another thread. When you `subscribeOn`, that delays the real subscription to `PublishSubject` by some amount, giving enough time to `onNext` to be observed by no one. You see only `onCompleted` because `PublishSubject` replays the terminal event to late `Subscriber`s.\n"
      },
      {
        "user": "bdeneuter",
        "created_at": "2016-03-27T21:30:20Z",
        "body": "Thx David,\n\nIndeed, observeOn seems to solve the behaviour I was seeing. With subsribeOn and waiting long enough for the subscription to succeed, can you also explain why the terminal event is delivered on the main thread and not on the scheduler thread?\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2016-03-27T21:35:01Z",
        "body": "You are racing with the subscription and by chance, it is possible the subscription happens in time for onComplete to pass through directly to the Subscriber.\n"
      },
      {
        "user": "bdelville",
        "created_at": "2018-07-17T00:52:10Z",
        "body": "Hi\r\n\r\nI am not sure about the racing condition explanation, because I can reproduce it with a BehaviorSubject too (with onNext() called after subscription and timer before it)\r\n\r\n```\r\n@Test\r\n  public void testSubjectThreadFollowSubscribeOn() {\r\n    TestObserver<String> tester = new TestObserver<>();\r\n    BehaviorSubject<Integer> source = BehaviorSubject.create();\r\n    String currentThread = Thread.currentThread().getName();\r\n\r\n    source\r\n        .subscribeOn(Schedulers.io())\r\n        .take(1)\r\n        .map(o -> Thread.currentThread().getName())\r\n        .subscribe(tester);\r\n    source.onNext(1);\r\n\r\n    tester.awaitCount(1);\r\n    tester.assertValue(threadAfterSubscribeOn -> !threadAfterSubscribeOn.equals(currentThread));\r\n}\r\n```"
      },
      {
        "user": "akarnokd",
        "created_at": "2018-07-17T06:37:04Z",
        "body": "You still have a race where onNext could find an already subscribed observer and signal the first item on the test thread."
      }
    ]
  },
  {
    "number": 3748,
    "title": "replay().connect() does not complete on current thread",
    "created_at": "2016-03-11T13:10:57Z",
    "closed_at": "2016-03-11T14:14:19Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3748",
    "body": "This test case:\n\n``` java\n  @Test\n  public void test() {\n    final AtomicBoolean onNext = new AtomicBoolean(false);\n    final AtomicBoolean onCompleted = new AtomicBoolean(false);\n\n    Observable<String> o = Observable.just(\"Hallo\")\n        .doOnNext(new Action1<String>() {\n          @Override\n          public void call(String s) {\n            onNext.set(true);\n          }\n        })\n        .doOnCompleted(new Action0() {\n          @Override\n          public void call() {\n            onCompleted.set(true);\n          }\n        });\n\n    ConnectableObservable<String> connectable = o.replay();\n    connectable.connect();\n\n    assertTrue(onNext.get());\n    assertTrue(onCompleted.get());\n  }\n```\n\nstarted failing for me on the latest snapshot. `git bisect` says c925e860c01c30edc15c59c592c1d5e9b9777a90 is the first bad commit. `.publish()` is not affected.\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3748/comments",
    "author": "hannesstruss",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-03-11T13:28:32Z",
        "body": "Previously, `just()` didn't support backpressure and emitted its value immediately after subscription. Now it waits for a proper downstream request which doesn't happen because `replay()` requests upstream only when there is a downstream request. Just add `connectable.subscribe()` to trigger `just()`.\n"
      }
    ]
  },
  {
    "number": 3743,
    "title": "Caused by: rx.exceptions.MissingBackpressureException",
    "created_at": "2016-03-07T09:53:07Z",
    "closed_at": "2016-04-02T23:21:54Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3743",
    "body": "java.lang.IllegalStateException: Exception thrown on Scheduler.Worker thread. Add `onError` handling.\n    at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:60)\n    at android.os.Handler.handleCallback(Handler.java:733)\n    at android.os.Handler.dispatchMessage(Handler.java:95)\n    at android.os.Looper.loop(Looper.java:136)\n    at android.app.ActivityThread.main(ActivityThread.java:5315)\n    at java.lang.reflect.Method.invokeNative(Native Method)\n    at java.lang.reflect.Method.invoke(Method.java:515)\n    at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:864)\n    at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:680)\n    at dalvik.system.NativeStart.main(Native Method)\nCaused by: rx.exceptions.OnErrorNotImplementedException\n    at rx.Observable$27.onError(Observable.java:7535)\n    at rx.observers.SafeSubscriber._onError(SafeSubscriber.java:154)\n    at rx.observers.SafeSubscriber.onError(SafeSubscriber.java:111)\n    at rx.internal.operators.OperatorSubscribeOn$1$1$1.onError(OperatorSubscribeOn.java:71)\n    at rx.internal.operators.OperatorOnBackpressureDrop$2.onError(OperatorOnBackpressureDrop.java:76)\n    at rx.internal.operators.OperatorObserveOn$ObserveOnSubscriber.pollQueue(OperatorObserveOn.java:197)\n    at rx.internal.operators.OperatorObserveOn$ObserveOnSubscriber$2.call(OperatorObserveOn.java:170)\n    at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:55)\n    ... 9 more\nCaused by: rx.exceptions.MissingBackpressureException\n    at rx.internal.operators.OperatorObserveOn$ObserveOnSubscriber.onNext(OperatorObserveOn.java:138)\n    at rx.internal.operators.OperatorMap$1.onNext(OperatorMap.java:55)\n    at rx.internal.operators.OnSubscribeTimerPeriodically$1.call(OnSubscribeTimerPeriodically.java:51)\n    at rx.Scheduler$Worker$1.call(Scheduler.java:120)\n    at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:55)\n    at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:422)\n    at java.util.concurrent.FutureTask.run(FutureTask.java:237)\n    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:152)\n    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:265)\n    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1112)\n    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:587)\n    at java.lang.Thread.run(Thread.java:841)\nrx.exceptions.OnErrorNotImplementedException\n    at rx.Observable$27.onError(Observable.java:7535)\n    at rx.observers.SafeSubscriber._onError(SafeSubscriber.java:154)\n    at rx.observers.SafeSubscriber.onError(SafeSubscriber.java:111)\n    at rx.internal.operators.OperatorSubscribeOn$1$1$1.onError(OperatorSubscribeOn.java:71)\n    at rx.internal.operators.OperatorOnBackpressureDrop$2.onError(OperatorOnBackpressureDrop.java:76)\n    at rx.internal.operators.OperatorObserveOn$ObserveOnSubscriber.pollQueue(OperatorObserveOn.java:197)\n    at rx.internal.operators.OperatorObserveOn$ObserveOnSubscriber$2.call(OperatorObserveOn.java:170)\n    at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:55)\n    at android.os.Handler.handleCallback(Handler.java:733)\n    at android.os.Handler.dispatchMessage(Handler.java:95)\n    at android.os.Looper.loop(Looper.java:136)\n    at android.app.ActivityThread.main(ActivityThread.java:5315)\n    at java.lang.reflect.Method.invokeNative(Native Method)\n    at java.lang.reflect.Method.invoke(Method.java:515)\n    at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:864)\n    at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:680)\n    at dalvik.system.NativeStart.main(Native Method)\nCaused by: rx.exceptions.MissingBackpressureException\n    at rx.internal.operators.OperatorObserveOn$ObserveOnSubscriber.onNext(OperatorObserveOn.java:138)\n    at rx.internal.operators.OperatorMap$1.onNext(OperatorMap.java:55)\n    at rx.internal.operators.OnSubscribeTimerPeriodically$1.call(OnSubscribeTimerPeriodically.java:51)\n    at rx.Scheduler$Worker$1.call(Scheduler.java:120)\n    at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:55)\n    at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:422)\n    at java.util.concurrent.FutureTask.run(FutureTask.java:237)\n    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:152)\n    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:265)\n    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1112)\n    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:587)\n    at java.lang.Thread.run(Thread.java:841)\nrx.exceptions.MissingBackpressureException\n    at rx.internal.operators.OperatorObserveOn$ObserveOnSubscriber.onNext(OperatorObserveOn.java:138)\n    at rx.internal.operators.OperatorMap$1.onNext(OperatorMap.java:55)\n    at rx.internal.operators.OnSubscribeTimerPeriodically$1.call(OnSubscribeTimerPeriodically.java:51)\n    at rx.Scheduler$Worker$1.call(Scheduler.java:120)\n    at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:55)\n    at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:422)\n    at java.util.concurrent.FutureTask.run(FutureTask.java:237)\n    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:152)\n    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:265)\n    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1112)\n    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:587)\n    at java.lang.Thread.run(Thread.java:841)\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3743/comments",
    "author": "itxuye",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2016-03-07T13:30:00Z",
        "body": "You applied the `onBackpressureDrop` at the wrong location. You should apply it just after `interval`.\n"
      },
      {
        "user": "itxuye",
        "created_at": "2016-03-08T01:58:45Z",
        "body": "@akarnokd Thanks for your answer. But i don\u2018t known what's wrong in my code.\n`Observable.timer(1, 1, TimeUnit.SECONDS)\n        .map(aLong -> calcLeftTime())\n        .observeOn(AndroidSchedulers.mainThread())\n        .onBackpressureDrop()\n        .subscribeOn(Schedulers.io())\n        .subscribe(new Action1<Long>() {\n          @Override public void call(Long aLong) {\n            if (aLong > 0) {\n              countTime.updateShow(aLong);\n            } else {\n              countTime.setVisibility(View.INVISIBLE);\n            }\n          }\n        }, Throwable::printStackTrace);`\n"
      },
      {
        "user": "artem-zinnatullin",
        "created_at": "2016-03-08T02:03:26Z",
        "body": "@itxuye \n1. Apply `onBackpressureDrop()` after `timer()`\n2. You don't need `subscribeOn()` since `Observable.timer()` will run on `Schedulers.computation()` by default and you're not overriding it via `subscribeOn()`.\n"
      },
      {
        "user": "abersnaze",
        "created_at": "2016-03-08T02:24:16Z",
        "body": "The reason is the observeOn is a producer/consumer queue between the timer and the work being done in the main thread. That queue is filling up because the producer is faster.\n"
      }
    ]
  },
  {
    "number": 3367,
    "title": "propagating request when using flatMap",
    "created_at": "2015-09-20T09:50:42Z",
    "closed_at": "2015-09-25T18:16:58Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/3367",
    "body": "Hi, \n\nI ve this piece of code : \n\n```\nObservable\n    .from(IntStream.range(1, 20).boxed().collect(Collectors.toList()))\n    .map(i -> {\n                System.out.println(\"Step :\"+i);\n                return i;\n            })\n    .flatMap(elt ->\n                            Observable\n                                    .just(elt).observeOn(Schedulers.io())\n                                    .map(String::valueOf)\n\n            )\n    .subscribe(new Subscriber<String>() {\n\n                @Override\n                public void onStart() {\n                    request(1);\n                }\n\n                @Override\n                public void onCompleted() {}\n\n                @Override\n                public void onError(Throwable throwable) {}\n\n                @Override\n                public void onNext(String s) {\n                    System.out.println(\"Next : \" + s);\n                }\n            });\n```\n\nI expect this on the logs : \n\nStep : 1\nNext : 1\n\nBut Instead I've this : \n\nStep :1\nStep :2\nNext : 1\nStep :3\nStep :4\nStep :5\nStep :6\nStep :7\n...\n\nWhy does the request is not propagating to the source when I use flatMap ?\n\nThanks for your help! \n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/3367/comments",
    "author": "larousso",
    "comments": [
      {
        "user": "davidmoten",
        "created_at": "2015-09-20T22:06:12Z",
        "body": "You've only requested one so that is all you get arriving to the subscriber. The other log lines are because `flatMap` requests 128 (or 16 on Android) regardless of how many were requested of it and then buffers. When you request more `flatMap` will empty its buffer.\n\nIf you put a `request(1)` just after  `System.out.println(\"Next : \" + s);` then your stream will report all to the subscriber.\n"
      }
    ]
  },
  {
    "number": 2805,
    "title": "PublishSubject does not honour subscribeOn",
    "created_at": "2015-03-05T12:23:53Z",
    "closed_at": "2015-03-12T23:11:10Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/2805",
    "body": "In the code below, the subscriber gets called in main thread itself. If we remove the sleep, subscriber is not even called. Tried version 1.0.7, 1.0.6 and 1.0.4. My understanding is that the subscriber will be called in the passed executor.\n\n``` java\n  public static void main(String[] args) {\n        ExecutorService executor = Executors.newFixedThreadPool(2);\n        Scheduler scheduler = Schedulers.from(executor);\n\n        Subject<Integer, Integer> sub = PublishSubject.create();\n        // BufferUntilSubscriber.create();\n        sub.subscribeOn(scheduler).subscribe(new Action1<Integer>() {\n            @Override\n            public void call(Integer t1) {\n                // This prints 'main'\n                System.out.println(Thread.currentThread());\n            }\n        });\n\n        try {\n            Thread.sleep(100);\n        } catch (InterruptedException e1) {\n            e1.printStackTrace();\n        }\n\n        sub.onNext(1);\n    }\n```\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/2805/comments",
    "author": "ashish-tyagi",
    "comments": [
      {
        "user": "ashish-tyagi",
        "created_at": "2015-03-05T12:31:50Z",
        "body": "If we use BufferUntilSubscriber, the behavior is even more puzzling. If there is no sleep, the subscriber gets called in the executor thread. If we put some sleep, the subscriber gets called in main thread.  Should not the behavior be consistent, sleep or no sleep?\n\n``` java\n    public static void main(String[] args) {\n        ExecutorService executor = Executors.newFixedThreadPool(2);\n        Scheduler scheduler = Schedulers.from(executor);\n\n        Subject<Integer, Integer> sub = BufferUntilSubscriber.create();\n        sub.subscribeOn(scheduler).subscribe(new Action1<Integer>() {\n            @Override\n            public void call(Integer t1) {\n                System.out.println(Thread.currentThread());\n            }\n        });\n\n        try {\n            Thread.sleep(100);\n        } catch (InterruptedException e1) {\n            e1.printStackTrace();\n        }\n\n        sub.onNext(1);\n    }\n```\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2015-03-05T15:45:20Z",
        "body": "Your first example subscribes on the given thread but receives values from the same thread your PublishSubject is emitting. You need `observeOn` to put those values to the desired thread.\n"
      },
      {
        "user": "akarnokd",
        "created_at": "2015-03-05T21:24:38Z",
        "body": "In the second example, there is a race between the main thread emission and when the BufferUntilSubscriber starts to replay any buffered value. If the main thread is slow, the BufferUntilSubscriber wins but is empty at that point and just relays any value. If the main thread is fast, the BufferUntilSubscriber receives the value first, then it is subscribed to on the specified thread and immediately replays this buffered value.\n"
      }
    ]
  },
  {
    "number": 2653,
    "title": "onBackpressureBlock() blocks forever when subscribe and observe on newThread",
    "created_at": "2015-02-13T03:24:35Z",
    "closed_at": "2015-02-13T21:14:36Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/ReactiveX/RxJava/issues/2653",
    "body": "``` Java\n        Observable<Integer> source = Observable.range(0,1000)\n                .onBackpressureBlock()\n                .subscribeOn(Schedulers.newThread())\n                .observeOn(Schedulers.newThread());\n\n        source.subscribe(new Action1<Integer>() {\n            @Override\n            public void call(Integer i) {\n                try {\n                    Thread.sleep(1);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                System.out.println(i);\n            }\n        });\n\n        try {\n            Thread.sleep(2000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n```\n\nThe output gives only 0 to 127, where I expected it to be 0 to 999.\nThis behavior exists in both 1.0.6 and master. Is this a bug or I used it incorrectly?\n",
    "comments_url": "https://api.github.com/repos/ReactiveX/RxJava/issues/2653/comments",
    "author": "FinalVersion",
    "comments": [
      {
        "user": "akarnokd",
        "created_at": "2015-02-13T07:35:00Z",
        "body": "Hi. What's happening is that subscribeOn routes all backpressure requests to the same thread doing the range emission which blocks. You need to move the `subscribeOn` before the `onBackpressureBlock`.\n"
      }
    ]
  }
]