[
  {
    "number": 14627,
    "title": "Is there a way to preserve documents modifications when a doc is modified and then populated?",
    "created_at": "2024-05-31T15:11:05Z",
    "closed_at": "2024-06-05T20:43:44Z",
    "labels": [
      "help",
      "help wanted"
    ],
    "url": "https://github.com/Automattic/mongoose/issues/14627",
    "body": "### Prerequisites\n\n- [X] I have written a descriptive issue title\n\n### Mongoose version\n\n6.12.8, 7.6.12\n\n### Node.js version\n\n14.21.3, 16.20.2\n\n### MongoDB version\n\n5.0.26\n\n### Operating system\n\nNone\n\n### Operating system version (i.e. 20.04, 11.3, 10)\n\n_No response_\n\n### Issue\n\nHi all,\r\n\r\nWondering if there's a way to preserve changes when doing the following:\r\n\r\n```JS\r\nconst foo = await Foo.findById('someId').populate('bar')\r\n\r\nfoo.bar.name = 'hi there'\r\n\r\nawait foo.populate('bar')\r\n// At this point the foo.bar.name modification is wiped out, saving the document will result in no changes\r\n```\r\n\r\nI know that this looks like a contrived example and there should be no reason to do it. The problem I'm trying to solve is this:\r\nI have a function, `funky`, that will populate `bar`, it essentially just does `await foo.populate('bar')`, that multiple code paths go to and `funky` requires that all properties of `bar` be available. These code paths contain a mixture of:\r\n  - Instances of a populated `bar` where only certain paths have been selected, such as ` await Foo.findById('someId').populate({path: 'bar', select: 'name'})`\r\n  - Instances like the example above where `select` is not used and modifications to `bar` are made. This includes cases where modifications happen before and after the second `populate` is performed.\r\n\r\nI suppose the answer here is that I should audit all of these code paths and remove any `selects` that are happening, and then I shouldn't need the second populate. Just wanted to ask here if there's a way around this though before I spend the time, and potentially create new bugs. \r\n\r\nThanks for any advice.\r\n\r\n",
    "comments_url": "https://api.github.com/repos/Automattic/mongoose/issues/14627/comments",
    "author": "ericneubauerbumphealth",
    "comments": [
      {
        "user": "vkarpov15",
        "created_at": "2024-06-02T15:00:16Z",
        "body": "Unfortunately the only workarounds would be to\r\n\r\n 1. `save()` the document before populating again: `await foo.bar.save(); await foo.populate('bar');`\r\n 2. avoid the extra `populate()` if `bar` is already populated: `if (!foo.populated('bar')) await foo.populate('bar');`\r\n 3. store a reference to the old document before populating: `const oldDoc = foo.bar; await foo.populate('bar');` \r\n  \r\n `populate()` creates a new populated document, so any change state on the previous document would get wiped out. Do any of these approaches work for you?"
      }
    ]
  },
  {
    "number": 13673,
    "title": "Typescript logic to avoid null as a result for model.findOne",
    "created_at": "2023-07-30T12:32:20Z",
    "closed_at": "2023-08-06T19:20:58Z",
    "labels": [
      "help",
      "help wanted"
    ],
    "url": "https://github.com/Automattic/mongoose/issues/13673",
    "body": "### Prerequisites\n\n- [X] I have written a descriptive issue title\n\n### Mongoose version\n\n7.4.1\n\n### Node.js version\n\n18.16.1\n\n### MongoDB version\n\nLatest\n\n### Operating system\n\nNone\n\n### Operating system version (i.e. 20.04, 11.3, 10)\n\n_No response_\n\n### Issue\n\nHi, I have been using Mongoose v5 for a long time and now I've started to migrate to Mongoose 7. I'm following the official guide which recommends to migrate to v6 first and then to 7, but I'm having some issues with Typescript that did not happen on v5.\r\n\r\nWhen I call `model.findOne()` now, it can return null, which makes sense, but this did not happen on Mongoose 5. This is fine for most cases when you are not sure if there'll be any document at all. However, it does not make sense if my program does different checks before calling the method (findOne) that Typescript says it can be null.\r\n\r\nFor instance, let's say I have two documents that are created at the same time but in different models with different schemas:\r\n```\r\n// Global\r\ninterface GlobalUser {\r\n\tid: string;\r\n\tname: string;\r\n\tavatar: string;\r\n}\r\n\r\nconst SchemaGlobalUser = new mongoose.Schema<GlobalUser>({\r\n\tid: String,\r\n\tname: String,\r\n\tavatar: String\r\n});\r\n\r\nconst ModelGlobalUser = mongoose.model<GlobalUser>('Global', SchemaGlobalUser);\r\n\r\n// Local (copying the interface and schema for a better explanation)\r\ninterface LocalUser {\r\n\tid: string;\r\n\tname: string;\r\n\tavatar: string;\r\n}\r\n\r\nconst SchemaLocalUser = new mongoose.Schema<LocalUser>({\r\n\tid: String,\r\n\tname: String,\r\n\tavatar: String\r\n});\r\n\r\nconst ModelLocalUser = mongoose.model<LocalUser>('Local', SchemaLocalUser);\r\n```\r\n\r\nAnd I create the documents at the same time (with different data):\r\n```\r\nconst newGlobalModel = new ModelGlobalUser({\r\n\tid: user.id,\r\n\tname: user.username,\r\n\tavatar: user.avatar\r\n});\r\n\r\nconst newLocalModel = new ModelLocalUser({\r\n\tid: user.id,\r\n\tname: user.localName,\r\n\tavatar: user.localAvatar\r\n});\r\n\r\nawait newGlobalModel.save();\r\nawait newLocalModel.save();\r\n```\r\n\r\nThen if I call `ModelGlobalUser.findOne({id: user.id})` and it exists, `ModelLocalUser.findOne({id: user.id})` cannot be null. Same thing should happen if I call them in different files or functions (for example, do something -> first findOne (global) -> call another function where the second findOne (local) is done). Nevertheless, Typescript always says it can be null.\r\n\r\nAs said previously, this did not happen on Mongoose 5, where Typescript never said it could be null. Is there any way to return to that old behaviour by setting an option when creating the model or something? I know it's pretty impossible for Typescript to recognise when it can or cannot be null, but maybe a way to tell Typescript that some models cannot return null documents could solve it (basically a way to ignore that findOne can return no documents). ",
    "comments_url": "https://api.github.com/repos/Automattic/mongoose/issues/13673/comments",
    "author": "k2helix",
    "comments": [
      {
        "user": "vkarpov15",
        "created_at": "2023-08-01T19:39:41Z",
        "body": "Try `await ModelLocalUser.findOne({id: user.id}).orFail()`, that will make the result non-nullable. Does that help?"
      },
      {
        "user": "vkarpov15",
        "created_at": "2023-08-06T19:20:58Z",
        "body": "Not with TypeScript unfortunately. You could write middleware to add `orFail()` to every query operation, but that wouldn't help TypeScript infer that the result is non-nullable. You're better off just using `orFail()`."
      },
      {
        "user": "vermaslal",
        "created_at": "2024-08-12T17:23:12Z",
        "body": "I had same issue on @nestjs/mongoose . I found adding compiler option as below works\r\n\r\n```\r\n{\r\n  \"compilerOptions\": {\r\n    \"strictNullChecks\": true,\r\n    \"noImplicitAny\": true,\r\n    ...\r\n  }\r\n}\r\n```"
      }
    ]
  },
  {
    "number": 13590,
    "title": "500 Error when using populate method in mongoose",
    "created_at": "2023-07-09T08:05:52Z",
    "closed_at": "2023-07-10T16:16:25Z",
    "labels": [
      "help",
      "help wanted"
    ],
    "url": "https://github.com/Automattic/mongoose/issues/13590",
    "body": "### Prerequisites\r\n\r\n- [X] I have written a descriptive issue title\r\n\r\n### Mongoose version\r\n\r\n7.3.1\r\n\r\n### Node.js version\r\n\r\n18.14.2\r\n\r\n### MongoDB version\r\n\r\n6.06\r\n\r\n### Operating system\r\n\r\nWindows\r\n\r\n### Operating system version (i.e. 20.04, 11.3, 10)\r\n\r\n11\r\n\r\n### Issue\r\n\r\nI am trying to fetch data from MongoDB using mongoose and the populate method, but I get a 500 error. Here is the code that causes the error:\r\n```\r\nexport const productGetAllMiddleware = expressAsyncHandler(\r\n  async (req: Request, res: Response, next: NextFunction) => {\r\n    try {\r\n      req.query.page = req.query.page ? req.query.page : \"1\";\r\n      const products = await productModel\r\n        .find({})\r\n        .populate(\"inventory_id\")\r\n        .limit(10)\r\n        .skip(10 * (parseInt(req.query.page as string) - 1))\r\n        .exec();\r\n      res.status(200).json(products);\r\n    } catch (err) {\r\n      console.log(err);\r\n      return next(err);\r\n    }\r\n  }\r\n);\r\n```\r\nIf I remove the populate method, the code works fine. Here are the productModel and inventoryModel schemas that I am using:\r\n\r\n```\r\n// productModel\r\nimport mongoose, { InferSchemaType } from \"mongoose\";\r\nimport BaseSchema from \"./BaseSchema\";\r\n\r\nconst Schema = mongoose.Schema;\r\nconst Product = new Schema({\r\n  name: {\r\n    type: String,\r\n    required: [true, \"Name is required\"],\r\n    validate: {\r\n      validator: function (v: string) {\r\n        return v.trim().length > 0;\r\n      },\r\n      message: \"Name cannot be empty\",\r\n    },\r\n  },\r\n  desc: {\r\n    type: String,\r\n    required: [true, \"Description is required\"],\r\n    validate: {\r\n      validator: function (v: string) {\r\n        return v.trim().length > 10;\r\n      },\r\n      message: \"Description should be at least 10 characters long\",\r\n    },\r\n  },\r\n  SKU: {\r\n    type: String,\r\n    required: [true, \"SKU is required\"],\r\n    validate: {\r\n      validator: function (v: string) {\r\n        return /^[A-Z0-9]+$/.test(v);\r\n      },\r\n      message: \"SKU should only contain uppercase letters and numbers\",\r\n    },\r\n  },\r\n  price: {\r\n    type: Number,\r\n    required: [true, \"Price is required\"],\r\n    validate: {\r\n      validator: function (v: number) {\r\n        return v > 0;\r\n      },\r\n      message: \"Price should be a positive number\",\r\n    },\r\n  },\r\n  category_id: { type: Schema.Types.ObjectId, ref: \"ProductCategory\" },\r\n  discount_id: { type: Schema.Types.ObjectId, ref: \"ProductDiscount\" },\r\n  inventory_id: {\r\n    type: Schema.Types.ObjectId,\r\n    ref: \"ProductInventory\",\r\n    require: true,\r\n  },\r\n  image: [{ type: String, default: \"\" }],\r\n  amountPurchased: { type: Number, default: 0 },\r\n});\r\n\r\ntype ProductType = InferSchemaType<typeof Product>;\r\nProduct.add(BaseSchema);\r\nProduct.virtual(\"id\").get(function () {\r\n  return this._id.toHexString();\r\n});\r\n\r\nexport default mongoose.model<ProductType>(\"Product\", Product);\r\n\r\n// inventoryModel\r\nimport mongoose, { InferSchemaType } from \"mongoose\";\r\nimport BaseSchema from \"./BaseSchema\";\r\nconst Schema = mongoose.Schema;\r\nconst ProductInventory = new Schema({\r\n  quantity: {\r\n    type: Number,\r\n    required: [true, \"Quantity is required\"],\r\n    min: [0, \"Quantity cannot be negative\"],\r\n  },\r\n});\r\ntype ProductInventoryType = InferSchemaType<typeof ProductInventory>;\r\nProductInventory.add(BaseSchema);\r\nexport default mongoose.model<ProductInventoryType>(\r\n  \"ProductInventory\",\r\n  ProductInventory\r\n);\r\n\r\n// baseSchema\r\nimport mongoose from \"mongoose\";\r\nconst { Schema } = mongoose;\r\nconst BaseSchema = new Schema(\r\n  {\r\n    deleted_at: { type: Date, default: null },\r\n  },\r\n  {\r\n    timestamps: true,\r\n  }\r\n);\r\nexport default BaseSchema;\r\n```\r\nCan anyone help me figure out why the populate method is causing an error and how to fix it? Thanks in advance.\r\n",
    "comments_url": "https://api.github.com/repos/Automattic/mongoose/issues/13590/comments",
    "author": "loingtan",
    "comments": [
      {
        "user": "ayushkavad",
        "created_at": "2023-07-09T17:25:17Z",
        "body": "hey! @maikusobu \r\n\r\nThe issue in your code lies in the definition of the \"inventory_id\" field in your productModel schema. There's a typo in the schema definition where you wrote \"require\" instead of \"required\". Because of this typo, Mongoose doesn't recognize the \"inventory_id\" field as required and allows it to be empty, which leads to an error when trying to populate it.\r\n\r\nTo fix the issue, update the \"inventory_id\" field definition in the productModel schema as follows:\r\n\r\n```JavaScript\r\ninventory_id: {\r\n  type: Schema.Types.ObjectId,\r\n  ref: \"ProductInventory\",\r\n  required: true, \r\n},\r\n```\r\nAfter making this change, the \"inventory_id\" field will be recognized as required, and Mongoose will properly validate and populate it when fetching data from MongoDB."
      }
    ]
  },
  {
    "number": 13511,
    "title": "`match`ing on current date in a virtual populate",
    "created_at": "2023-06-15T03:51:13Z",
    "closed_at": "2023-06-15T19:29:03Z",
    "labels": [
      "help",
      "help wanted"
    ],
    "url": "https://github.com/Automattic/mongoose/issues/13511",
    "body": "### Prerequisites\r\n\r\n- [X] I have written a descriptive issue title\r\n\r\n### Mongoose version\r\n\r\n6.7.4\r\n\r\n### Node.js version\r\n\r\n16.20\r\n\r\n### MongoDB version\r\n\r\n4.4\r\n\r\n### Operating system\r\n\r\nmacOS\r\n\r\n### Operating system version (i.e. 20.04, 11.3, 10)\r\n\r\n_No response_\r\n\r\n### Issue\r\n\r\nHello,\r\n\r\nI'm trying to use a populate virtual that `match`es on a Date field, filtering for documents which have a value that is in the past. My first instinct was to do something like this:\r\n\r\n```ts\r\n// MySchema: { _id }\r\n// OtherSchema: { _id, myRef, activeAt }\r\n\r\nMySchema.virtual(\"myVirtual\", {\r\n    ref: \"OtherSchema\",\r\n    localField: \"_id\",\r\n    foreignField: \"myRef\",\r\n    justOne: true,\r\n    match: {\r\n        activeAt: {\r\n            $lte: new Date()\r\n        }\r\n    },\r\n    options: {\r\n        sort: { activeAt: -1 }\r\n    }\r\n});\r\n```\r\n\r\nBut `new Date()` just evaluates when the app first starts up, and so the match query is always just for the same date.\r\n\r\nIs there some way to query for the current timestamp when the populate runs?",
    "comments_url": "https://api.github.com/repos/Automattic/mongoose/issues/13511/comments",
    "author": "seankwalker",
    "comments": [
      {
        "user": "vkarpov15",
        "created_at": "2023-06-15T13:20:16Z",
        "body": "Try replacing `match: { activeAt: { $lte: new Date() } }` with `match: () =>({ activeAt: { $lte: new Date() } })`. Setting `match` to a function means Mongoose executes the `match` function every time you call `populate()`, so that should solve your problem."
      }
    ]
  },
  {
    "number": 13205,
    "title": "i cant save data from checkbox using js and mongoose",
    "created_at": "2023-03-23T15:12:51Z",
    "closed_at": "2023-03-23T21:52:38Z",
    "labels": [
      "help",
      "help wanted"
    ],
    "url": "https://github.com/Automattic/mongoose/issues/13205",
    "body": "### Prerequisites\n\n- [X] I have written a descriptive issue title\n\n### Mongoose version\n\n7.0.0\n\n### Node.js version\n\n18.15.0 \n\n### MongoDB version\n\n6.0\n\n### Operating system\n\nWindows\n\n### Operating system version (i.e. 20.04, 11.3, 10)\n\n10\n\n### Issue\n\ni have form for new product and using checkbox for chose many size \r\nwhen i choose more than 1 size this error happen\r\n\r\n this.$__.validationError = new ValidationError(this);\r\n                               ^\r\n\r\nValidationError: Product validation failed: size: Cast to string failed for value \"[ 'S', 'M', 'L' ]\" (type Array) at path \"size\"\r\n\r\n\r\n\r\nand this is the schema \r\n\r\nconst mongoose = require('mongoose');\r\nconst Schema = mongoose.Schema;\r\n\r\nconst ProductSchema = new Schema({\r\n    title: String,\r\n    image: String,\r\n    price: Number,\r\n    size: {\r\n        type: String,\r\n        enum: ['S', 'M', 'L', 'xL', '2xL']\r\n    }\r\n});\r\n\r\nand this is example of the checkbox\r\n\r\n <div class=\"form-check form-check-inline\">\r\n                <input class=\"form-check-input\" type=\"checkbox\" name=\"products[size]\" id=\"M\" value=\"M\">\r\n                <label class=\"form-check-label\" for=\"M\">\r\n                    Medium\r\n                </label>\r\n              </div> \r\n\r\n\r\nmodule.exports = mongoose.model('Product', ProductSchema);",
    "comments_url": "https://api.github.com/repos/Automattic/mongoose/issues/13205/comments",
    "author": "mohamed9777",
    "comments": [
      {
        "user": "vkarpov15",
        "created_at": "2023-03-23T21:52:38Z",
        "body": "Sounds like you need to update your schema to the following:\r\n\r\n```javascript\r\nconst ProductSchema = new Schema({\r\n  title: String,\r\n  image: String,\r\n  price: Number,\r\n  size: {\r\n    type: [String], // <-- make size an array of strings rather than just a string\r\n    enum: ['S', 'M', 'L', 'xL', '2xL']\r\n  }\r\n});\r\n```"
      }
    ]
  },
  {
    "number": 13048,
    "title": "Connecting to local MongoDb from a Docker container fails in any 6.x.x versions",
    "created_at": "2023-02-17T22:47:03Z",
    "closed_at": "2023-02-18T18:46:59Z",
    "labels": [
      "help",
      "help wanted"
    ],
    "url": "https://github.com/Automattic/mongoose/issues/13048",
    "body": "### Prerequisites\n\n- [X] I have written a descriptive issue title\n\n### Mongoose version\n\n6.9.1\n\n### Node.js version\n\n16.13.2\n\n### MongoDB version\n\n4.0.5\n\n### Operating system\n\nWindows\n\n### Operating system version (i.e. 20.04, 11.3, 10)\n\nWindows 10 Pro (OS Build: 19044.1645)\n\n### Issue\n\nTeam,\r\n\r\nBy using `host.docker.internal` as the `host` value within a Docker Container; up to version **5.12.7** it works beautifully to connect to my local MongoDb (outside of Container), however, it fails to connect at any versions above that, including 6.x.x.   \r\n\r\nHere is sample code snippet:\r\n\r\n    open(mongoose, callback) {        \r\n        const options = {\r\n            // useMongoClient: true,      // <-- no longer necessary\r\n            // useNewUrlParser: true,     // <-- no longer necessary\r\n            // useUnifiedTopology: true,  // <-- no longer necessary\r\n            promiseLibrary: global.Promise  // <-- not sure if its needed in 6.x.x; works fine in 5.12.7\r\n        };\r\n\r\n        const env = process.env.MICRO_SVC_ENV,\r\n              dockerLocalHost = 'host.docker.internal',\r\n              connStr = `mongodb://${dockerLocalHost}:27017/someDb`;\r\n\r\n        mongoose.connect(connStr, options, (err) => {\r\n            if (err) {\r\n                console.error(`${logPrefix} Open(${env}). Mongoose.Connect() failed:`, err);\r\n                return;\r\n            }\r\n\r\n            console.log(`${logPrefix} Open(${env}). CONNECTED to MongoDB.`);\r\n        });\r\n        /// rest of code....\r\n\r\nDoes anyone know if the new versions of mongoose has disabled this feature, or may be I am missing an extra options setting when connecting?        ",
    "comments_url": "https://api.github.com/repos/Automattic/mongoose/issues/13048/comments",
    "author": "sonnyk22",
    "comments": [
      {
        "user": "Pr0dt0s",
        "created_at": "2023-02-18T15:34:45Z",
        "body": "The connection is trying to use the server\u00b4s configured listening ip (127.0.0.1) unsuccessfully since that points to the loopback interface inside the docker container.\r\n\r\nSetting the option ```directConnection: true``` to force the use of the host in the connection string seem to solve this issue.\r\n"
      }
    ]
  },
  {
    "number": 13014,
    "title": "Filter in pre (find) hook Mongoose",
    "created_at": "2023-02-09T18:52:05Z",
    "closed_at": "2023-02-16T04:13:28Z",
    "labels": [
      "help",
      "help wanted"
    ],
    "url": "https://github.com/Automattic/mongoose/issues/13014",
    "body": "### Prerequisites\n\n- [X] I have written a descriptive issue title\n\n### Mongoose version\n\n6.3.3\n\n### Node.js version\n\n19.5\n\n### MongoDB version\n\n4.4.18 Community\n\n### Operating system\n\nLinux\n\n### Operating system version (i.e. 20.04, 11.3, 10)\n\nManjaro Linux 5.15.91-1\n\n### Issue\n\nI'm trying to perform a query that filters an array from another document, to mention something about the structure, I try to populate the document based on the specified product and store id, so that it doesn't bring the other data from the array but in this case I understand that I can't access the document fields while in the middleware, I'm reading the documentation but I still learning concepts\r\n```\r\n\r\nbUnitSchema.pre(/^find/, function (next) {\r\n  this.populate({\r\n    path: \"menuItem.product\",\r\n\r\n    select: {\r\n      \"storeId.$\": 1,\r\n    },\r\n    match: {\r\n      \"storeId.store\": \"62a811d1af67f5415770f297\",\r\n      \r\n    }\r\n  });\r\n  next();\r\n});\r\n\r\n```\r\n\r\nany guide would be of excellent help\r\n\r\nI try something like this\r\n```\r\n\r\nbUnitSchema.pre(/^find/, function (next) {\r\n  \r\n  this.populate({\r\n    path: \"menuItem.product\",\r\n\r\n    select: {\r\n      \"storeId.$\": 1,\r\n    },\r\n    match: {\r\n      \r\n       *//here im trying to do something like this*\r\n      *\"storeid.store\": bUnitSchema.menuItem.store*\r\n    },\r\n  });\r\n\r\n  next();\r\n});\r\n```\r\n\r\nbut give me\r\n`\r\nstore not defined`",
    "comments_url": "https://api.github.com/repos/Automattic/mongoose/issues/13014/comments",
    "author": "jj-devs",
    "comments": [
      {
        "user": "vkarpov15",
        "created_at": "2023-02-12T18:56:58Z",
        "body": "I think you would need a post hook, not a pre hook. If I'm reading this correctly, I think you're trying to use the result of `find()` in a `populate()`, which isn't going to work in a pre hook because the query hasn't executed yet."
      },
      {
        "user": "jj-devs",
        "created_at": "2023-02-16T04:13:27Z",
        "body": "Yes you are right, that was i need, this is the code:\r\n```\r\nbUnitSchema.post(/^find/, async function (docs) {\r\n  for (let doc of docs) {\r\n    for (let store of doc.menuItem) {\r\n      await doc.populate({\r\n        path: \"menuItem.product\",\r\n        select: {\r\n          \"storeId.$\": 1,\r\n        },\r\n        match: {\r\n          \"storeId.store\": store.store,\r\n        },\r\n      });\r\n    }\r\n  }\r\n});\r\n```\r\n\r\nThanks for the help @vkarpov15 !"
      }
    ]
  },
  {
    "number": 12998,
    "title": " \"Schema hasn't been registered for model \"[object Object]\" error in two way referential relationship in mongo ig because of 'populate' function.",
    "created_at": "2023-02-04T06:33:19Z",
    "closed_at": "2023-02-06T15:38:48Z",
    "labels": [
      "help",
      "help wanted"
    ],
    "url": "https://github.com/Automattic/mongoose/issues/12998",
    "body": "### Prerequisites\n\n- [X] I have written a descriptive issue title\n\n### Mongoose version\n\n6.8.1\n\n### Node.js version\n\n16.13.2\n\n### MongoDB version\n\n6.0.3\n\n### Operating system\n\nWindows\n\n### Operating system version (i.e. 20.04, 11.3, 10)\n\n_No response_\n\n### Issue\n\nHere I have declared a two way referential relationship, If I import 'farm' module before 'products' module I am having access to all farms but linked linked products are throwing \"Schema hasn't been registered for model \"[object Object]\" error. If I import 'products' first I cannot access 'farms' collections.\r\n**farm.js**\r\n```\r\nconst mongoose=require('mongoose');\r\nconst product = require('./products');\r\nconst {Schema}=mongoose;\r\n\r\nconst farmSchema=new Schema({\r\n    name:{\r\n        type:String,\r\n        required:[true,'Farm must have an name!']\r\n    },\r\n    city:{\r\n        type:String\r\n    },\r\n    email:{\r\n        type:String,\r\n        required:true\r\n    },\r\n    products:[\r\n        {\r\n            type:Schema.Types.ObjectId,\r\n            ref:product//ref refers to model \r\n        }\r\n    ]\r\n})\r\n\r\nconst farm=mongoose.model('Farm',farmSchema)\r\n\r\nmodule.exports=farm\r\n```\r\n**product.js**\r\n```\r\nconst mongoose=require('mongoose')\r\nconst farm = require('./farm')\r\n\r\nconst productSchema=new mongoose.Schema({\r\n    Pname:{\r\n        type:String,\r\n        required:true\r\n    },\r\n    Price:{\r\n        type:Number,\r\n        required:true,\r\n        min:0\r\n        \r\n    },\r\n    category:{\r\n        type:String,\r\n        lowercase:true,//item will always be lowercase\r\n        enum:['fruit','vegetable','dairy','drinks','nota']\r\n\r\n    },\r\n    farms:[\r\n       {\r\n        type:mongoose.Schema.Types.ObjectId,\r\n        ref:farm\r\n       }\r\n    ]\r\n})\r\n\r\nconst product=mongoose.model('Product',productSchema)\r\n\r\nmodule.exports=product  \r\n```\r\n**index.js**\r\n### This code renders a new page and set up relationship between them.\r\n```app.get('/farm/:id/product/new',async(req,res)=>{//this is the new route for product in a farm, no need to create product individually.(this is correct becouse why anyone will write a subcomment if there is no comment.)\r\n    const {id}=req.params;\r\n    const f=await farm.findById(id)\r\n    res.render('views/products/new',{categories,f})\r\n})\r\n\r\n//setting relationship between two collections\r\napp.post('/farm/:id/product',async(req,res)=>{\r\n    const {id}=req.params\r\n    const Cfarm=await farm.findById(id)\r\n    const {Pname,Price,category}=req.body;\r\n    const p=new product({Pname,Price,category})\r\n    Cfarm.products.push(p)\r\n    p.farms=Cfarm //not pushing bcz many to one relationship\r\n    await Cfarm.save()\r\n    await p.save()\r\n    res.redirect(`/farm/${id}`)\r\n\r\n})\r\n```\r\n### This is a product route which renders the specific page for the product. Having issue populating in this one.\r\n```app.get('/product/:id',async (req,res)=>{\r\n    const {id}=req.params;\r\n    const p=await product.findById(id).populate('farm','name')\r\n    console.log(p)\r\n    res.render('views/products/detail',{p})\r\n})\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/Automattic/mongoose/issues/12998/comments",
    "author": "ManjeetvermaCode",
    "comments": [
      {
        "user": "lpizzinidev",
        "created_at": "2023-02-06T08:44:57Z",
        "body": "Hi @ManjeetvermaCode  \u270b\r\n\r\nTry to change your imports and references to:\r\n```\r\n// farm.js\r\n// Change `const product = require('./products');` to:\r\nrequire('./products');\r\n\r\nproducts: [\r\n  {\r\n    type: Schema.Types.ObjectId,\r\n    ref: 'Product',\r\n  },\r\n];\r\n\r\n// product.js\r\n// Remove `const farm = require('./farm');`\r\nfarms: [\r\n  {\r\n    type: mongoose.Schema.Types.ObjectId,\r\n    ref: 'Farm',\r\n  },\r\n];\r\n```"
      }
    ]
  },
  {
    "number": 12238,
    "title": "Chaining a Mongoose Query returned by an async function",
    "created_at": "2022-08-08T16:31:03Z",
    "closed_at": "2022-08-09T09:06:48Z",
    "labels": [
      "help",
      "help wanted"
    ],
    "url": "https://github.com/Automattic/mongoose/issues/12238",
    "body": "### Prerequisites\r\n\r\n- [X] I have written a descriptive issue title\r\n\r\n### Mongoose version\r\n\r\n6.3.3\r\n\r\n### Node.js version\r\n\r\n18.6.0\r\n\r\n### MongoDB version\r\n\r\n5.0.10\r\n\r\n### Operating system\r\n\r\nWindows\r\n\r\n### Operating system version (i.e. 20.04, 11.3, 10)\r\n\r\n_No response_\r\n\r\n### Issue\r\n\r\nLet's say we have the following method defined on a Schema:\r\n```js\r\nasync method() {\r\n  // do async stuff first, then\r\n  return this.constructor.find();\r\n}\r\n```\r\n\r\nChaining on an async method will return an error:\r\n```js\r\nconst model = new Model();\r\nawait model.method().populate('field').exec();\r\n// throws .populate is not a function\r\nawait (await model.method()).populate('field').exec();\r\n// same\r\n```\r\n\r\nI understand that the error is thrown because `model.method()` won't return a Mongoose Query, but instantiated documents.\r\n\r\nI'm not sure why the query has been executed, but I guess it has to do with Mongoose internally calling exec for pending queries when there is a change in the event loop or something like that.\r\n\r\nHow can I properly chain the `populate` call here? Is there an option to delay the execution?\r\n\r\n`method` needs to be async because async stuff actually happens inside, besides the `find` call.\r\n\r\nThanks!\r\n",
    "comments_url": "https://api.github.com/repos/Automattic/mongoose/issues/12238/comments",
    "author": "jeanbmar",
    "comments": [
      {
        "user": "imranbarbhuiya",
        "created_at": "2022-08-09T08:26:40Z",
        "body": "You can do it by returning an object or array. I don't think simply returning the query will work as `await` will call `then` on query and it'll execute the query.\r\n\r\n```ts\r\nasync method() {\r\n  // do async stuff first, then\r\n  return {find: this.constructor.find()};\r\n}\r\n```\r\n\r\n```ts\r\nconst model = new Model();\r\nawait (await model.method()).find.populate('field').exec();\r\n```"
      },
      {
        "user": "jeanbmar",
        "created_at": "2022-08-09T09:06:48Z",
        "body": "At best we can `await (await model.method()).populate('field').exec();` if we set the thenable to undefined in the `method` function.\r\nBut it comes with side effects and the syntax is still not ideal anyway.\r\nThere's no magic to chain from a Promise but this is regular Promise stuff!"
      }
    ]
  },
  {
    "number": 11938,
    "title": "Set model for many schemas in the same file",
    "created_at": "2022-06-15T09:00:44Z",
    "closed_at": "2022-06-15T21:53:17Z",
    "labels": [
      "help",
      "help wanted"
    ],
    "url": "https://github.com/Automattic/mongoose/issues/11938",
    "body": "### Prerequisites\r\n\r\n- [X] I have written a descriptive issue title\r\n\r\n### Mongoose version\r\n\r\n6.3.8\r\n\r\n### Node.js version\r\n\r\n16.13.2\r\n\r\n### MongoDB version\r\n\r\n5.0.6\r\n\r\n### Operating system\r\n\r\n_No response_\r\n\r\n### Operating system version (i.e. 20.04, 11.3, 10)\r\n\r\n_No response_\r\n\r\n### Issue\r\n\r\nWhen I created two different schemas related to the model (via optional param in schema object), I accepted an error that shows a Mongoose did override the name of each model, despite these being two separate collections with unique names. \r\nThe following code is related to the scenario: \r\n```\r\nconst mongoose = require('mongoose');\r\nconst st_schema = new mongoose.Schema({\r\n    name: String,\r\n    degree: String\r\n}, {collection: 'students'});\r\nconst st_model = mongoose.model('',st_schema);\r\nconst dpt_schema = new mongoose.Schema({\r\n    name: String,\r\n    num_students: Number\r\n}, {collection: 'departments'});\r\nconst dpt_model = mongoose.model('',dpt_schema);\r\n```\r\n**The error: OverwriteModelError: Cannot overwrite \"\" model once compiled.**\r\nI assumed that cause uses the same variable (const mongoose.). \r\nWe have other roads to define the model, but I would like to learn more details about a specific scenario. \r\nPay attention to the collection of defined \"Inline\" schema variables and the same file.",
    "comments_url": "https://api.github.com/repos/Automattic/mongoose/issues/11938/comments",
    "author": "GalO005",
    "comments": [
      {
        "user": "Uzlopak",
        "created_at": "2022-06-15T11:45:34Z",
        "body": "Well. No.it is because the first argument of model is the same\r\n\r\nI would probably do it like this:\r\n\r\n```javascript\r\nconst mongoose = require('mongoose');\r\nconst st_schema = new mongoose.Schema({\r\n    name: String,\r\n    degree: String\r\n}, {collection: 'students'});\r\nconst st_model = mongoose.model('st',st_schema, 'students');\r\nconst dpt_schema = new mongoose.Schema({\r\n    name: String,\r\n    num_students: Number\r\n}, {collection: 'departments'});\r\nconst dpt_model = mongoose.model('dpt',dpt_schema, 'departments');\r\n```"
      },
      {
        "user": "GalO005",
        "created_at": "2022-06-15T21:40:58Z",
        "body": "So, where is the advantage of defining collection in the schema? \r\nI see that we have duplicate declarations. Right?  @Uzlopak "
      },
      {
        "user": "Uzlopak",
        "created_at": "2022-06-15T21:45:23Z",
        "body": "Idk, for me it is actually also new that you can define collection in Schemas. Lol. I usually define that on the model, how i showed it to you."
      }
    ]
  },
  {
    "number": 5138,
    "title": "Mongoose authentication fail when trying to connect to MongoDB Atlas",
    "created_at": "2017-03-31T17:05:48Z",
    "closed_at": "2017-10-09T14:49:55Z",
    "labels": [
      "help wanted"
    ],
    "url": "https://github.com/Automattic/mongoose/issues/5138",
    "body": "#4818 Referencing this issue: it's closed but I am still reproducing the same problem.\r\n\r\nMongoose version: `4.9.2`\r\nNode.js version: `7.7.4`\r\nMongoDB Atlas version: `3.2`\r\n\r\nWhen trying to connect via mongo shell, everything works fine.\r\n\r\n```\r\nmongo 'mongodb://someUser:somePassword@someShard-shard-00-00-fjfvq.mongodb.net:27017,someShard-shard-00-01-fjfvq.mongodb.net:27017,someShard-shard-00-02-fjfvq.mongodb.net:27017/someDb?replicaSet=someShard-shard-0&ssl=true&authSource=admin'\r\n```\r\n\r\nHere, I'm connecting to `someDb`, but I'm authenticating the user against the `admin` database.\r\n\r\nWhen trying to connect with Mongoose I get the following error:\r\n\r\n```\r\n { MongoError: authentication fail\r\nat Function.MongoError.create ...\r\n```\r\n\r\nI'm thinking it's an error with it not handling the `authSource` properly. Mongoose successfully connects if I make `admin` the database I'm trying to connect to, but doesn't connect if I make `admin` the `authSource` I'm trying to authenticate against.\r\n\r\nAny ideas?",
    "comments_url": "https://api.github.com/repos/Automattic/mongoose/issues/5138/comments",
    "author": "emaxedon",
    "comments": [
      {
        "user": "gilalan",
        "created_at": "2017-04-07T20:47:21Z",
        "body": "Hello @emaxedon , I am using MEANJS generator from Yeoman. Here is my code:\r\n`var config.db.uri = 'mongodb://myUser:myPass@myCluster-shard-00-00-67fdt.mongodb.net:27017,myCluster-shard-00-01-67fdt.mongodb.net:27017,myCluster-shard-00-02-67fdt.mongodb.net:27017/myDatabase?ssl=true&replicaSet=myCluster-shard-0&authSource=admin'`\r\n\r\n`var db = mongoose.connect(config.db.uri, function (err) {\r\n    // Log Error\r\n    if (err) {\r\n      console.error(chalk.red('Could not connect to MongoDB!'));\r\n      console.log(err);\r\n    } else {\r\n\r\n      // Enabling mongoose debug mode if required\r\n      mongoose.set('debug', config.db.debug);\r\n\r\n      // Call callback FN\r\n      if (cb) cb(db);\r\n    }\r\n  });`\r\n\r\nIt returns the following error: \r\n`Could not connect to MongoDB!\r\n    { MongoError: no valid seed servers in list}`\r\n\r\nUsing this same String, I can successfully connect via mongo shell. Until I find a solution, I'm using an old database from Xervo.io, but my actual database is already set in Atlas. Any ideas ? "
      },
      {
        "user": "sobafuchs",
        "created_at": "2017-04-08T22:33:59Z",
        "body": "@emaxedon did you change anything between when it was working and when it started working? And is it still working?"
      },
      {
        "user": "emaxedon",
        "created_at": "2017-04-08T23:55:22Z",
        "body": "@gilalan @varunjayaraman \r\n\r\nNot sure if it makes a difference - but the only thing I changed that made it work (no idea why this works) is the following.\r\n\r\n```\r\nconst db = mongoose.connect(config.db.uri, {\r\n\tserver: {\r\n\t\tsocketOptions: {\r\n\t\t\tkeepAlive: 1\r\n\t\t}\r\n\t}\r\n}).connection;\r\n\r\ndb.on('error', (err) => {\r\n\tconsole.log(err);\r\n});\r\ndb.once('open', (err) => {\r\n\tif (err) {\r\n\t\tconsole.log(err);\r\n\t} else {\r\n\t\t// ...\r\n\t}\r\n});\r\n```"
      },
      {
        "user": "BGTN",
        "created_at": "2017-05-09T17:13:33Z",
        "body": "I had the same issue like @gilalan. \"name: 'MongoError', message: 'no valid seed servers in list'\". I updated node to version v6.10.3 and mongoose to version 4.9.8. After these updates I was able to connect to Atlas via Mongoose.\r\n\r\n"
      },
      {
        "user": "kevinadi",
        "created_at": "2017-05-11T01:22:18Z",
        "body": "@gilalan I can confirm that mongoose 4.2.10 cannot connect to MongoDB Atlas with the error message `MongoError: no valid seed servers in list`.\r\n\r\nHowever, I can also confirm that upgrading to the latest mongoose (currently 4.9.8) fixed the issue, and enabled mongoose to connect to MongoDB Atlas.\r\n\r\nI believe this issue should be closed."
      }
    ]
  },
  {
    "number": 5100,
    "title": "Mongoose select,populate and save behaving differently on Mac and Windows",
    "created_at": "2017-03-22T19:01:56Z",
    "closed_at": "2017-03-30T03:12:10Z",
    "labels": [
      "help wanted"
    ],
    "url": "https://github.com/Automattic/mongoose/issues/5100",
    "body": "I have a funciton in which i am selecting only 3 fields to go ahead with i.e billing,current_referral_program and referral. And populating user using the reference stored in billing.user\r\n\r\n`static populateReferralLinks(){\r\n\r\n    return Promise.coroutine(function*(){\r\n        let companies = yield Company.find({},'billing referral current_referral_program')\r\n        .populate('billing.user','emails name');\r\n        for(let i = 0 ; i < length ; i++){  \r\n            companies[i].referral.is_created = true;\r\n            companies[i].referral.referral_email = companies[i].billing.user.emails[0].email;\r\n            companies[i] = yield companies[i].save();\r\n       }\r\n       return companies;\r\n    })\r\n    .apply(this)\r\n    .catch((err) => {\r\n            throw err;\r\n    });\r\n} `\r\n\r\nNow when i call this function then on line\r\n\r\n`companies[i].save();`\r\n\r\nThe following command is shown in the terminal in windows\r\n\r\n`Mongoose: companies.update(\r\n{ _id: ObjectId(\"58d12e1a588a96311075c45c\") }, \r\n{ '$set': \r\n   { billing: \r\n      { configured: false, \r\n        user: ObjectId(\"58d12e16588a96311075c45a\") }, \r\n     referral: \r\n     { is_created: true,  \r\n       referral_email: 'jadon.devesh98@gmail.com', \r\n     }, \r\n     updatedAt: new Date(\"Wed, 22 Mar 2017 12:02:55 GMT\") \r\n   } \r\n}\r\n)`\r\n\r\nBut in Mac's terminal it shows this command\r\n\r\n`Mongoose: companies.update({ _id: ObjectId(\"58d12e1a588a96311075c45c\") }) { '$set': { billing: { configured: false, user: ObjectId(\"58d12e16588a96311075c45a\") }, current_limit: {}, current_usage: {},referral: { is_created: true, referral_email: 'jadon.devesh98@gmail.com'}}, '$unset': { updatedAt: 1 } }`\r\n\r\nNow, I haven't mentioned **current_limit** and **current_usage** to be empty. it's executing fine on windows but on Mac it's setting **current_limit** and **current_usage** empty thus updating my document with empty objects on Mac but not on windows.\r\n\r\nIt should behave same way on both OS but it is not.\r\n\r\nMy Company Schema is like this\r\n\r\n`const companySchema = new mongoose.Schema(\r\n    {\r\n       name: {\r\n            type: String,\r\n            trim: true,\r\n            required: true,\r\n            minlength: 3,\r\n            lowercase: true,\r\n        },\r\n        current_limit: {\r\n            leads: {\r\n                type: Number,\r\n                default: null\r\n            },\r\n            traffic: {\r\n                type: Number,\r\n                default: null\r\n            }\r\n        },\r\n        current_usage: {\r\n            leads: {\r\n                type: Number,\r\n                default: 0\r\n            },\r\n            traffic: {\r\n                type: Number,\r\n                default: 0\r\n            }\r\n        }\r\n        billing: {\r\n            user: {\r\n                type: mongoose.Schema.ObjectId,\r\n                ref: 'User'\r\n            },\r\n            configured: {\r\n                type: Boolean,\r\n                default: false\r\n            },\r\n        },\r\n        current_referral_program: {\r\n            type: String,\r\n            uppercase: true,\r\n            enum: ['FIRST', 'SECOND'],\r\n            default: 'FIRST'\r\n        },\r\n        referral: {\r\n            is_created:{\r\n                type: Boolean,\r\n                default: false\r\n            }\r\n            referral_email:{\r\n                type: String,\r\n                default:null\r\n            }\r\n        }\r\n    },\r\n    {\r\n        timestamps: true,\r\n        autoIndex: true\r\n    }\r\n);`\r\n\r\nand User Schema is like this\r\n\r\n`const userSchema = new mongoose.Schema(\r\n    {\r\n        name: {\r\n            type: String,\r\n            trim: true,\r\n            default: ''\r\n        },\r\n        username: {\r\n            type: String,\r\n            trim: true,\r\n            required: true,\r\n            minlength: 4,\r\n            lowercase: true,\r\n            unique: true\r\n        },\r\n        emails: [emailSchema],\r\n        password: {\r\n            type: String,\r\n            required: true,\r\n            minlength: 8\r\n        },\r\n    },\r\n    {\r\n        timestamps: true,\r\n        autoIndex: true\r\n    }\r\n);`\r\n\r\nNote : this happens only for fields like **current_limit** which store an object but not for fields like **name** which store single value but not whole object.\r\n\r\nMongoDb version is 3.4.0 on both systems\r\nMongoose version is 4.5.8",
    "comments_url": "https://api.github.com/repos/Automattic/mongoose/issues/5100/comments",
    "author": "deveshjadon98",
    "comments": [
      {
        "user": "sobafuchs",
        "created_at": "2017-03-24T03:09:19Z",
        "body": "@deveshjadon98 can you try with mongoose 4.9.1. This is definitely a weird one... what version of node are you using?"
      },
      {
        "user": "deveshjadon98",
        "created_at": "2017-03-24T05:31:53Z",
        "body": "@varunjayaraman it worked fine after upgrading to mongoose 4.9.1 , now it's making the same query in both environments, which was earlier made in windows. i am using ubuntu instance on aws, On 4.5.8 it resulted in data loss because of different queries. \r\nNode version is 6.2.2 \r\nAll good now, Thanks."
      }
    ]
  }
]