[
  {
    "number": 2319,
    "title": "[QUESTION] Cannot delete using predicate",
    "created_at": "2023-05-06T00:46:45Z",
    "closed_at": "2023-05-08T20:14:48Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/litedb-org/LiteDB/issues/2319",
    "body": "Tried to search issues and other people seem to have this working but I cannot.\r\n\r\n```\r\npublic void DeletePackage(string identifier)\r\n{\r\n    var db = _database.GetCollection<ExtensionManifest>(\"packages\");\r\n    db.Delete(x => x.Identifier == identifier)\r\n}\r\n```\r\n\r\nError is\r\n```\r\nCS1660\tCannot convert lambda expression to type 'BsonValue' because it is not a delegate type\r\n```",
    "comments_url": "https://api.github.com/repos/litedb-org/LiteDB/issues/2319/comments",
    "author": "timheuer",
    "comments": [
      {
        "user": "mbdavid",
        "created_at": "2023-05-08T19:19:11Z",
        "body": "Hi @timheuer,\r\n\r\n`Delete` method must be used with an `BsonValue` (accepts only `_id` value).\r\n\r\nIf you don't know the `_id` you can try `DeleteMany` with an expression (your expression is a valid expression).\r\n\r\nTip: if you have too many documents in this collection or query/delete/update by this identifier, create an index on this field and you will not loose performance..\r\n"
      }
    ]
  },
  {
    "number": 2060,
    "title": "How to map constructor using fluent mapping",
    "created_at": "2021-08-23T11:42:00Z",
    "closed_at": "2021-09-13T15:06:25Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/litedb-org/LiteDB/issues/2060",
    "body": "Hi there,\r\n\r\nFirst I want to say that I've searched for a solution, but didn't found one. So, I'm having some difficulty to map a constructor using the fluent mapping. For example, I have a class, \"User\", it have a constructor with 2 parameters, something like `User(string username, ProfileRole profileRole)`. How can I map it using the fluent mapping?",
    "comments_url": "https://api.github.com/repos/litedb-org/LiteDB/issues/2060/comments",
    "author": "nunonux",
    "comments": [
      {
        "user": "lbnascimento",
        "created_at": "2021-09-09T18:00:34Z",
        "body": "@nunonux You could do something like this:\r\n\r\n```C#\r\nBsonMapper.Global.Entity<Sample>().Ctor(x => new User(x[\"Username\"], BsonMapper.Global.Deserialize<ProfileRole>(x[\"ProfileRole\"])));\r\n```\r\n\r\nThe constructor mapping is only meant for simple cases (e.g. using the construtor that takes an `int` and a `string` instead of the parameterless constructor). If you need to pass complex types and enums to the constructor, it's probably best to create custom serializer and deserializer with `BsonMapper.Global.RegisterType<T>(...)`."
      }
    ]
  },
  {
    "number": 2054,
    "title": "[QUESTION] FIND/QUERY throw exception",
    "created_at": "2021-08-11T11:02:49Z",
    "closed_at": "2021-08-11T13:46:52Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/litedb-org/LiteDB/issues/2054",
    "body": "I'm a begginer in C#. Just started using LiteDB in one of my project.\r\n\r\nMy class:\r\n```\r\n  public class KeyValueObject\r\n    {\r\n        [BsonId]\r\n        public ObjectId id;\r\n        public string keyName;\r\n        public object dataValue;\r\n        public long lastUpdated;\r\n    }\r\n```\r\nI'm inserting document. It's working fine.\r\n```\r\n        public void Store(string name, object value)\r\n        {\r\n            Console.WriteLine(Collection().Insert(new KeyValueObject { keyName = name,  dataValue = value }).ToString());\r\n        }\r\n```\r\n\r\nI've a problem here, coll.Find thows exception \"Member keyName not found on BsonMapper for type LocalDBStoreLibrary.KeyValueObject.\"\r\n```\r\n   public KeyValueObject Find(string name)\r\n        {\r\n            var coll = Collection();\r\n            var res = coll.FindOne(x => x.keyName == name);\r\n            if (res != null)\r\n                return (KeyValueObject)res;\r\n            else\r\n                return null;\r\n        }\r\n```\r\n\r\nWhat am I missing? How do I solve it?",
    "comments_url": "https://api.github.com/repos/litedb-org/LiteDB/issues/2054/comments",
    "author": "valvenetbabu",
    "comments": [
      {
        "user": "lbnascimento",
        "created_at": "2021-08-11T13:09:18Z",
        "body": "@valvenetbabu By default, the LiteDB mapper only serializes properties. If you want it to store fields too, you must run `BsonMapper.Global.IncludeFields = true`."
      }
    ]
  },
  {
    "number": 2044,
    "title": "[QUESTION] does LiteDB support C# 9 record?",
    "created_at": "2021-07-29T13:55:19Z",
    "closed_at": "2021-07-30T13:13:49Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/litedb-org/LiteDB/issues/2044",
    "body": "C#9 records are finally the immutable type that we needed in C#.\r\nSince it's syntax is game changing, does refit supports serializing/deserializing such objects ?",
    "comments_url": "https://api.github.com/repos/litedb-org/LiteDB/issues/2044/comments",
    "author": "roubachof",
    "comments": [
      {
        "user": "lbnascimento",
        "created_at": "2021-07-29T14:11:38Z",
        "body": "@roubachof Given that records are merely syntatic sugar and are implemented using regular objects, the LiteDB mapper shouldn't have any issues serializing them. If you find a bug or weird behavior, you can open an issue."
      },
      {
        "user": "roubachof",
        "created_at": "2022-06-01T08:50:00Z",
        "body": "To follow-up this question. \r\n**WARNING** LiteDB has a **limited** C# 9 record support.\r\nIt doesn't support primary contructors, so you will have to type this:\r\n\r\n```csharp\r\npublic record TourInfo()\r\n{\r\n    public int Id { get; init; }\r\n    public Sector? Sector { get; init; }\r\n    public Collector Collector { get; init; }\r\n    public TourState TourState { get; init; }\r\n    public string? Name { get; init; }\r\n    public DateTime Date { get; init; }\r\n    public List<int> SortedCollectionIdList { get; init; }\r\n}\r\n```\r\n\r\ninstead of this:\r\n\r\n```csharp\r\npublic record TourInfo(\r\n        int Id,\r\n        Sector? Sector,\r\n        Collector Collector,\r\n        TourState TourState,\r\n        string? Name,\r\n        DateTime Date,\r\n        List<int> SortedCollectionIdList);\r\n```"
      }
    ]
  },
  {
    "number": 1948,
    "title": "[QUESTION] How get items filtered by many parameters in Array?",
    "created_at": "2021-02-28T21:33:57Z",
    "closed_at": "2021-03-01T19:15:28Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/litedb-org/LiteDB/issues/1948",
    "body": "For example there is some shops and they have some products. Every product have array of string parameters.\r\nHow can i selection shops by product parameters? All params must be in one product.\r\n\r\nShop1\r\n{\r\n\t\"_id\" : 1,\r\n\t\"products\":\r\n\t[\r\n\t\t{\r\n\t\t\"name\":phone,\r\n\t\t\"params\":[\"black\",\"small\",\"Germany\"]\r\n\t\t},\r\n\t\t{\r\n\t\t\"name\":tablet \r\n\t\t\"params\":[\"blue\",\"big\",\"China\"]\t\r\n\t\t},\r\n\t\t{\r\n\t\t\"name\":apple \r\n\t\t\"params\":[\"red\",\"big\",\"Sweet\"]\r\n\t\t}\r\n\t]\r\n}\r\nShop2\r\n{\r\n\t\"_id\" : 2,\r\n\t\"products\":\r\n\t[\r\n\t\t{\r\n\t\t\"name\":phone,\r\n\t\t\"params\":[\"green\",\"small\",\"France\"]\r\n\t\t},\r\n\t\t{\r\n\t\t\"name\":book \r\n\t\t\"params\":[\"red\",\"big\",\"China\"]\t\r\n\t\t},\r\n\t\t{\r\n\t\t\"name\":pumpkin \r\n\t\t\"params\":[\"yellow\",\"big\",\"Sweet\"]\r\n\t\t}\r\n\t]\r\n}\t\t\r\n\r\n\r\n\r\nOne shop is one BsonDocument. I make like this:\t\r\n\t\r\nusing (var db = new LiteDatabase(DBname))\r\n{\r\n\tstring Query=products[*].params[*] ANY LIKE('red') AND products[*].params[*] ANY LIKE('sweet');\r\n\tdb.GetCollection(Name).Find(BsonExpression.Create(Query)));\r\n}\t\t\r\n\r\nI get result Shop1 and Shop2.\r\nIn shop 1 red and sweet is apple. in shop 2 red is book, sweet is pumpkin.\r\nBUT I want get only Shop1 with apple, where all params is in one product.\r\nSomething like this:\r\n\r\nstring Query=products[*].params[*] ANY (LIKE('red') AND LIKE('sweet'));\t",
    "comments_url": "https://api.github.com/repos/litedb-org/LiteDB/issues/1948/comments",
    "author": "tivial19",
    "comments": [
      {
        "user": "lbnascimento",
        "created_at": "2021-03-01T13:58:29Z",
        "body": "@tivial19 The following expression should work:\r\n\r\n`COUNT($.products[@.params any like 'red' and @.params any like 'sweet']) > 0`"
      }
    ]
  },
  {
    "number": 1941,
    "title": "int Upsert(IEnumerable<T> entities);",
    "created_at": "2021-02-23T10:49:22Z",
    "closed_at": "2021-02-24T14:38:02Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/litedb-org/LiteDB/issues/1941",
    "body": "Hi, \r\n\r\nShall this method return the number of records either inserted or updated successfully ? \r\nI detect a 0 return value meanwhile a record updated. ",
    "comments_url": "https://api.github.com/repos/litedb-org/LiteDB/issues/1941/comments",
    "author": "sigmarsson",
    "comments": [
      {
        "user": "lbnascimento",
        "created_at": "2021-02-23T17:17:02Z",
        "body": "@sigmarsson The `int Upsert(...)` overload returns the number of _inserted_ records. So, if it returned 0, it means that all of the records in the `IEnumerable<T>` were updated and none needed to be inserted."
      }
    ]
  },
  {
    "number": 1875,
    "title": "How to query by GUID field",
    "created_at": "2020-11-17T08:28:50Z",
    "closed_at": "2020-11-18T02:19:04Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/litedb-org/LiteDB/issues/1875",
    "body": "For example\r\n\r\npublic class Test\r\n{\r\n  public Guid Key {get; set;}\r\n}\r\n\r\nTest test = new Test() { Key = new Guid(\"1eb2c168-ea2c-4692-b492-1309671c093a\") }\r\n\r\nI've tried to query the collection using the expression $.Key = '1eb2c168-ea2c-4692-b492-1309671c093a' but this returns no records.\r\n\r\nIs there a special syntax required to query GUID columns?\r\n\r\nThanks\r\n\r\n\r\n",
    "comments_url": "https://api.github.com/repos/litedb-org/LiteDB/issues/1875/comments",
    "author": "ghost",
    "comments": [
      {
        "user": "lbnascimento",
        "created_at": "2020-11-17T17:11:19Z",
        "body": "@sysmirror `$.Key = GUID('1eb2c168-ea2c-4692-b492-1309671c093b')` should work."
      }
    ]
  },
  {
    "number": 1842,
    "title": "[QUESTION] How do you DeleteMany efficiently",
    "created_at": "2020-10-12T21:17:59Z",
    "closed_at": "2020-10-13T16:32:09Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/litedb-org/LiteDB/issues/1842",
    "body": "I've looked through the documentation and there is a lot of information about querying and indexes to query things efficiently, but I don't see a lot of information about deleting things efficiently.\r\n\r\nI'm trying to DeleteMany from a LiteDb database, but even relatively small deletes of 3000 items takes 10-20 seconds. Right now I am just experimenting with smaller data sets, but I plan to scale things up to much larger data sets, but I'm concerned that if the performance scales as well, then some of my deletion operations may take 30 minutes or more.\r\n\r\nI'm trying to make a generic database implementation using LiteDB, and below is the code that I'm using for deleting from the database\r\n\r\n```csharp\r\npublic void Delete<T>(IEnumerable<T> items)\r\n{\r\n    //Gets the collection name based on type. Will throw an exception if we don't support the type used.\r\n    var collectionName = getCollectionNameAndThrowIfNotSupported<T>();\r\n    //Gets the connection string. We are only specifying Filename, ReadOnly, and the Connection is shared\r\n    var connectionString = getConnectionString(read_only: false);\r\n    using (var db = new LiteDatabase(connectionString))\r\n    {\r\n        var collectionExists = db.CollectionExists(collectionName);\r\n        if (!collectionExists)\r\n            return; //no collection exists, so there is nothing to delete\r\n\r\n        //converting items to a hash set to help find matches more quickly\r\n        var hashedItems = items.ToHashSet();\r\n\r\n        var collection = db.GetCollection<T>(collectionName);\r\n        //This is the line that I have the most questions about. Is there a better way of writing this line to be more efficient?\r\n        collection.DeleteMany(x => hashedItems.Contains(x));\r\n    }\r\n}\r\n``` \r\n\r\nI thought that `Contains` would check if the items are equal, and for my objects that are being stored in LiteDb I am overriding `Equals` and `GetHashCode` and for two items to be equal I am only checking if the `ObjectId`s are equal.\r\n\r\nFrom the documentation it would appear that if you have an `ObjectId Id` that this will automatically get indexed, but am I missing something in my `DeleteMany` predicate that would help take advantage of indexes? Is there something that can be done to make this process faster?",
    "comments_url": "https://api.github.com/repos/litedb-org/LiteDB/issues/1842/comments",
    "author": "trockefeller-pathway",
    "comments": [
      {
        "user": "lbnascimento",
        "created_at": "2020-10-13T14:59:25Z",
        "body": "@trockefeller-pathway Basically, what `DeleteMany` does is to run a query to get the id of all documents that match the predicate and, after that, it deletes these documents by their ids. What is actually happening is that `x => hashedItems.Contains(x)` is being converted into a `BsonExpression`, which involves serializing all the items in `hashedItems`, and executed for every document in the query. So, not very efficient.\r\n\r\nDeleting by id is always faster. Given your situation, I believe the fastest way to delete many documents would be something like this (assuming your class has an Id field):\r\n```C#\r\ndb.BeginTrans();\r\nforeach(var item in items)\r\n{\r\n\tcollection.Delete(BsonMapper.Global.Serialize(item)[\"_id\"]);\r\n}\r\ndb.Commit();\r\n```"
      },
      {
        "user": "trockefeller-pathway",
        "created_at": "2020-10-13T15:20:14Z",
        "body": "@lbnascimento in my LiteDb objects I have a `public ObjectId Id { get; }` property. I don't explicitly have a private _id field. Do I need to explicitly create this field, or does it automatically get created because of my public Id property?"
      },
      {
        "user": "lbnascimento",
        "created_at": "2020-10-13T15:37:33Z",
        "body": "@trockefeller-pathway The id property in your object always becomes \"_id\" in the mapped `BsonDocument`, which is why I used it after the `BsonMapper.Serialize<T>(T obj)` call. I did this because your method is generic, so you can't simply do something like `collection.Delete(item.Id)`.\r\n\r\nThere are other ways to solve your problem, of course. You could get the Id field by reflection, but that's exactly what `BsonMapper` does. You could also make all of your data classes implement an interface that has a public property Id, which would allow you to use `collection.Delete(item.Id)`, but I think it would be over-engineering and it would only work if you own all of your data classes."
      }
    ]
  },
  {
    "number": 1820,
    "title": "Can't delete a specific document in V4.1.4",
    "created_at": "2020-09-16T21:40:22Z",
    "closed_at": "2020-09-17T17:07:31Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/litedb-org/LiteDB/issues/1820",
    "body": "I have a collection with several documents I can't delete using Collection.Delete whether I delete by bson id or query.\r\n\r\nFor these certain documents I get KeyNotFoundException errors.\r\n\r\nI also tried deleting these documents from LiteDB.Shell.exe and LiteDB Viewer, get the same error and it crashes the tools.\r\n\r\nThese same documents are returned in queries and otherwise behave like normal object documents.\r\n\r\nI can somewhat work around it but would really like to delete them.\r\n\r\nI'm looking for a recommendation on a quick work around.\r\n\r\nI suppose I could exclude select these documents drop and copy the good docs to a new instance of the collection. But would not want to have to do that all the time or codify it. \r\n\r\nNote: I just downgraded to V4 to eliminate file locking issues from a network file share in V5. In V5 after upgrading the db file from V4, I had no problems deleting these same documents using DeleteMany in V5.",
    "comments_url": "https://api.github.com/repos/litedb-org/LiteDB/issues/1820/comments",
    "author": "chucksullivancvs",
    "comments": [
      {
        "user": "lbnascimento",
        "created_at": "2020-09-17T13:57:09Z",
        "body": "@chucksullivancvs You could try running `db.Shrink()`. Also, I would like for you to send me this data file if possible (if it's not too big and doesn't contain sensitive information, of course)."
      },
      {
        "user": "chucksullivancvs",
        "created_at": "2020-09-17T15:57:41Z",
        "body": "@lbnascimento - thx Leonardo. That worked. I did a db.Shrink first from LiteDB.Shell.exe and that fixed the KeyNotFoundException because I was then able to delete the items. I added a db.Shrink to my delete method so hopefully that will mitigate the issue going forward. \r\n\r\nAs usual, thanks for the quick and meaningful response. LiteDB is a great, simple to use component for when a client-server db is not practical. It is serving me well. Keep up the good work guys, it is much appreciated.\r\n"
      }
    ]
  },
  {
    "number": 1802,
    "title": "[QUESTION] Setting Subdocument fields in a Query",
    "created_at": "2020-08-26T08:29:39Z",
    "closed_at": "2020-08-26T14:39:25Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/litedb-org/LiteDB/issues/1802",
    "body": "I want to change values in a subdocument field from null to empty strings and here's my Query in LiteDB Studio.\r\n\r\n```\r\nUPDATE\r\nusers\r\nSET\r\nCharacter.AppTransactions = \"\"\r\nWHERE\r\nCharacter.AppTransactions = null\r\n```\r\n\r\nBut I get this error\r\n```\r\nUnexpected token `.` in position 29.\r\n\r\nUPDATE  users  SET  Character.AppTransaction\r\n-----------------------------^\r\n```\r\n\r\nSeems we are unable to use valid JSON paths to update subdocuments? Is there a Query that would let me do this operation?\r\n\r\nThanks\r\nBenz",
    "comments_url": "https://api.github.com/repos/litedb-org/LiteDB/issues/1802/comments",
    "author": "NongBenz",
    "comments": [
      {
        "user": "lbnascimento",
        "created_at": "2020-08-26T13:54:26Z",
        "body": "@NongBenz The only way to update subdocuments in an update query is ti recreate the structure of the original document. Something like this:\r\n\r\n```SQL\r\nUPDATE users SET\r\n{\r\n\t_id: $._id,\r\n\tName: $.Name,\r\n\t...,\r\n\tCharacters:\r\n\t{\r\n\t\tAppTransactions: '',\r\n\t\tSubField2: $.Characters.SubField2,\r\n\t\t...\r\n\t}\r\n}\r\nWHERE $.Characters.AppTransactions = null\r\n```"
      }
    ]
  },
  {
    "number": 1794,
    "title": "[QUESTION] Object reference error. Am I doing something wrong?",
    "created_at": "2020-08-18T10:34:08Z",
    "closed_at": "2020-10-22T17:00:43Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/litedb-org/LiteDB/issues/1794",
    "body": "This is my code, written for a Discord bot:\r\n```cs\r\nusing (var db = new LiteDatabase(@\"database\\Profile.db\"))\r\n                {\r\n                    var collection = db.GetCollection<Profile>(\"Profile\");\r\n                    long? result = collection.FindOne(x => x.userId == Context.User.Id).gold;\r\n                    if (result != null)\r\n                    {\r\n                        await Context.Channel.SendMessageAsync($\"You have {result.Value.ToString(\"N0\")}G.\");\r\n                    }\r\n                    else\r\n                    {\r\n                        await Context.Channel.SendMessageAsync($\"You aren't registered. Write `!register` to start!\");\r\n                    }\r\n                }\r\n```\r\nIf there are no results found the program throws an \"Object reference not set to an instance of an object.\" (`System.NullReferenceException`) error.\r\nWhat am I doing wrong?\r\n\r\nThanks,\r\nb1sergiu",
    "comments_url": "https://api.github.com/repos/litedb-org/LiteDB/issues/1794/comments",
    "author": "b1sergiu",
    "comments": [
      {
        "user": "lbnascimento",
        "created_at": "2020-08-18T13:54:11Z",
        "body": "@b1sergiu I believe you're missing the null-conditional operator after the call to `FindOne`: \r\n```C#\r\nlong? result = collection.FindOne(x => x.userId == Context.User.Id)?.gold\r\n```"
      }
    ]
  },
  {
    "number": 1779,
    "title": "[QUESTION] Get collection size or how can calculate the collection size Version 5",
    "created_at": "2020-08-06T14:45:47Z",
    "closed_at": "2020-08-07T12:37:16Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/litedb-org/LiteDB/issues/1779",
    "body": "Hello,\r\n\r\ngive a function how can read the collection size out of the box?\r\n\r\nor\r\n\r\nHow can the calculate this? \r\nIn the version 4 i have claculate this about the singel documents with \"GetBytesCount(true)\" but this is not working on liteDB 5.\r\n\r\nI switch liteDB 4.1.4 to 5.0.8.\r\n\r\nHave you an Idee? Thank you\r\n",
    "comments_url": "https://api.github.com/repos/litedb-org/LiteDB/issues/1779/comments",
    "author": "foxshooter",
    "comments": [
      {
        "user": "lbnascimento",
        "created_at": "2020-08-06T15:40:10Z",
        "body": "@foxshooter If you want to read the total size occupied by a collection, you can do it with the following command:\r\n\r\n```C#\r\nint bytes = db.Execute(\"select SUM(*.usedBytes) from $dump where pageType = 'Data' and collection = 'collection'\").Single()[\"usedBytes\"];\r\n```\r\n\r\nIt's a bit convoluted, but it works fine. Of couse, you need to change the collection name in the query. We'll consider adding a property to the `LiteCollection` that gets this count."
      },
      {
        "user": "foxshooter",
        "created_at": "2020-08-07T08:00:57Z",
        "body": "@lbnascimento Thank you.\r\nCan you explain why pageType='Data' and which Type can use?\r\n\r\nIf I leave out the type='Data' then the size is bigger."
      },
      {
        "user": "lbnascimento",
        "created_at": "2020-08-07T12:35:26Z",
        "body": "@foxshooter If you leave out the `pageType='Data'`, this will also include Index pages."
      }
    ]
  },
  {
    "number": 1769,
    "title": "Upgraded from V4 to V4 - simple Find(Query.All()) stopped working",
    "created_at": "2020-07-29T20:42:08Z",
    "closed_at": "2020-07-31T15:28:03Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/litedb-org/LiteDB/issues/1769",
    "body": "Searched for this but found nothing.\r\n\r\nProblem:\r\n\r\nThis works fine in V4, fails to produce usable results in V5. \r\n\r\nThis pretty basic operation has been upgraded to V5. Data file has been upgraded using LiteDB Studio.\r\n\r\n               using (var db = new LiteDatabase(@ConfigDBConnection))\r\n                {\r\n                    var items = db.GetCollection<Item>(collection);\r\n\r\n                    var results = items.Find(Query.All());\r\n\r\n                }\r\n\r\nNew LiteDatabase produces what looks like a valid LiteDB.LiteDatabase reference.\r\n\r\nGetCollection returns a seemingly valid object reference to the right type: \"LiteDB.LiteCollection<AIMFacTool.Item>\"\r\n\r\nV5 Query.All produces an unusable \"System.Linq.Enumerable.WhereSelectEnumerableIterator<LiteDB.BsonDocument, AIMFacTool.Item>\" and an error in the ResultsView of \"Error The function evaluation requires all threads to run.\"\r\n\r\nWhereas V4 produces a usable \"LiteDB.LiteCollection<AIMFacTool.Item>\" object.\r\n\r\nI am hoping there is a workaround or alternative I can use, otherwise I will have to revert back to V4.\r\n\r\nAm looking forward to using LiteDB Studio though so I am keeping my hopes up that this is an easy fix.\r\n\r\nThanks in advance for your help.\r\n",
    "comments_url": "https://api.github.com/repos/litedb-org/LiteDB/issues/1769/comments",
    "author": "chucksullivancvs",
    "comments": [
      {
        "user": "lbnascimento",
        "created_at": "2020-07-29T21:07:52Z",
        "body": "I'm not sure why you call the result of the `LiteCollection.Find` method unusable. This class `WhereSelectEnumerableIterator<T>` is an internal C# class, and it implements `IEnumerable<T>`, so you can use it in many ways, like iterating with a `foreach` loop and calling `ToList()` or `ToArray()`.\r\n\r\nAlso, the `The function evaluation requires all threads to run` error is related to a limitation of the Visual Studio debugger for multi-threaded code, it has nothing to do with LiteDB itself and should never happen when running it without a debugger attached."
      },
      {
        "user": "chucksullivancvs",
        "created_at": "2020-07-30T16:08:28Z",
        "body": "Perhaps I should have said \"I don't know how to use it\" which is really what I was trying to say.\r\n\r\nCasting the result to a List solved the problem, as in:\r\n\r\n                    var items = db.GetCollection<Item>(collection);\r\n                    var results = items.Find(Query.All());\r\n                    results = results.ToList();\r\n                    return results;\r\n\r\nI did not have to do this in V4 and did not find anything in the documentation that mentioned this change in behavior.\r\n\r\nThanks again Leonardo.\r\n\r\nLiteDB is a great little tool and overall I have had good success using it.\r\n\r\nKeep up the good work!"
      }
    ]
  },
  {
    "number": 1767,
    "title": "Just upgraded a project from V4 to latest V5 getting \"Cannot convert lambda expression to type 'BsonValue' because it is not a delegate type\"",
    "created_at": "2020-07-28T18:11:40Z",
    "closed_at": "2020-08-14T16:37:49Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/litedb-org/LiteDB/issues/1767",
    "body": "I just upgraded a C# project reference from LiteDB 4 to latest v5.0.8. First converted data file using LiteDB Studio. Still worked.\r\n\r\nChange the C# project reference to v5 and now get a compiler error:\r\n\r\n\"Cannot convert lambda expression to type 'BsonValue' because it is not a delegate type\"\r\n\r\non this Collection Delete method statement that was previously working.\r\n\r\n`using (var db = new LiteDatabase(@DBConnection))\r\n{\r\n                    var requests = db.GetCollection<Request>(\"Request\");\r\n                    requests.Delete(x => x.CreateDate < deletedate);                    \r\n }`\r\n\r\nI'm not an expert in Lambda, LINQ or BSON.\r\n\r\nDidn't find any obvious answers.\r\n\r\nI'm looking for an easy fix. Please advise. Thx.",
    "comments_url": "https://api.github.com/repos/litedb-org/LiteDB/issues/1767/comments",
    "author": "chucksullivancvs",
    "comments": [
      {
        "user": "lbnascimento",
        "created_at": "2020-07-28T18:28:07Z",
        "body": "@chucksullivancvs There was a small change in the delete syntax for v5: the method `LiteCollection.Delete` is now only used when you want to delete a single document by its id. For other usage, you should use `DeleteMany`."
      },
      {
        "user": "gbthakkar",
        "created_at": "2022-05-21T07:24:18Z",
        "body": "Hi,\r\nI am little late here.\r\nThe answer definately solved the issue for chucksullivancvs . But there is sitution where we want to delete one record(document) in collection based on ID.\r\nLike\r\npublic class Service\r\n    {\r\n        public int Id { get; set; }\r\n        public string Name { get; set; } = \"\";\r\n        public bool IsActive { get; set; }=true;\r\n    }\r\nNow what should be the code to delete one service based on ID. Because BsonValue is known to me in this case.\r\n"
      }
    ]
  },
  {
    "number": 1757,
    "title": "How can i get the autoid from a poco record",
    "created_at": "2020-07-16T10:13:22Z",
    "closed_at": "2020-07-16T15:17:45Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/litedb-org/LiteDB/issues/1757",
    "body": "Hi,\r\nI have a class:\r\npublic class x\r\n{\r\npublic string a {get;set;}\r\npublic string b {get;set;}\r\n}\r\n\r\ninsertion is:\r\nx record = new x();\r\nrecord.a=\"a\";\r\nrecord.b =\"b\";\r\nILiteCollection<x> collection = db.GetCollection<x>(\"records\");\r\ncollection.Insert(record);\r\n\r\nget records:\r\nILiteCollection<x> collection = db.GetCollection<x>(\"records\");\r\nList<x> records = collection.FindAll().ToList();\r\nforeach (x record in records)\r\n{\r\nDebug(x.a); // fine\r\nDebug(x.b); // fine\r\n\r\nBsonValue id;\r\n// how can i get the id for delete the record?\r\n\r\n//collection.delete(id);\r\n}\r\n\r\nthx",
    "comments_url": "https://api.github.com/repos/litedb-org/LiteDB/issues/1757/comments",
    "author": "BobMcKay",
    "comments": [
      {
        "user": "lbnascimento",
        "created_at": "2020-07-16T14:15:37Z",
        "body": "@BobMcKay The first (and recommended) way would be to add a `ObjectId Id { get; set; }` field to your class. If that is not possible, you could simply store the value returned by the `Insert` method (it returns the id of the inserted document). If that is not possible, your best option would probably be to use `DeleteMany` instead of `Delete`: `collection.DeleteMany(r => r.a == x.a && r.b == x.b)`."
      }
    ]
  },
  {
    "number": 1743,
    "title": "[QUESTION] Accessing nested objects in LiteDB v5",
    "created_at": "2020-07-03T06:16:59Z",
    "closed_at": "2020-07-03T14:33:47Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/litedb-org/LiteDB/issues/1743",
    "body": "Refer #1926 - not resolved ",
    "comments_url": "https://api.github.com/repos/litedb-org/LiteDB/issues/1743/comments",
    "author": "panther142",
    "comments": [
      {
        "user": "lbnascimento",
        "created_at": "2020-07-03T13:43:46Z",
        "body": "@panther142 This is happening because the `Transactions` attribute in `Holdings` is read-only. The transactions are being stored correctly (that is why you see them in LiteDB.Studio), but they are not being returned because the mapper looks for a public setter and doesn't find one.\r\n\r\nThe simplest solution would be to add a public setter. If that is not possible in your scenario, you could create a custom constructor and add `BsonCtorAttribute` to it so that the mapper knows to use it."
      },
      {
        "user": "lbnascimento",
        "created_at": "2020-07-03T14:15:36Z",
        "body": "@panther142 If you want to add a public setter to the `Transactions ` property in `Holdings`, just add `set;` after `get;` in its declaration. If you want to make a custom constructor, it would be something like this:\r\n\r\n```C#\r\npublic Holdings(int id, BsonArray transactions)\r\n{\r\n        var mapper = BsonMapper.Global;\r\n        Id = id;\r\n        Transactions = transactions.Select(x => mapper.Deserialize<Transactions>(x)).ToList();\r\n}\r\n```"
      }
    ]
  },
  {
    "number": 1717,
    "title": "[QUESTION] How to see how much space a particular collection takes?",
    "created_at": "2020-06-10T11:01:13Z",
    "closed_at": "2020-06-11T05:55:04Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/litedb-org/LiteDB/issues/1717",
    "body": "How to see how much space a particular collection takes? And what is the place occupied in general, if it is not a collection.",
    "comments_url": "https://api.github.com/repos/litedb-org/LiteDB/issues/1717/comments",
    "author": "SKProCH",
    "comments": [
      {
        "user": "lbnascimento",
        "created_at": "2020-06-10T15:04:35Z",
        "body": "@SKProCH The query `select count(*) from $dump where Collection = 'mycollection'` will return the number of pages in use for `mycollection`. Each page is currently 8kB."
      }
    ]
  },
  {
    "number": 1716,
    "title": "[QUESTION] LiteDb v5 Query Api Group By Issue",
    "created_at": "2020-06-09T23:41:33Z",
    "closed_at": "2020-06-11T02:13:14Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/litedb-org/LiteDB/issues/1716",
    "body": "Hi!\r\nI am trying to execute a LiteDB (v5) query but facing the problem with Group By.\r\n\r\nI am building my expression in C# like that:\r\nvar r1 = collection.Query()\r\n\t\t        .GroupBy(\"Age\")\r\n\t\t        .Select(\"{Key: @Key,Max: Max(Id)}\").\r\n\t\t        ToArray();\r\nHere I want to get the maximum Id of the person in each age group.\r\n\r\nIt results in the following SQL:\r\n\r\nSELECT {Key:@Key,Max:MAX($.Id)}\r\nFROM Person\r\nGROUP BY $.Age\r\n\r\nHowever, the engine throws this exception:\r\n\r\n'Field 'Id' is invalid in the select list because it is not contained in either an aggregate function or the GROUP BY clause.'\r\n\r\nCould you please explain how to use aggregate functions with Group By?\r\n\r\nI was able to use only Count(*) or Max(@Key).\r\n\r\nPS. I thought I might need to use 'Include' function to add the Id field into the groups, but GROUP BY doesn't allow me to do it.\r\n",
    "comments_url": "https://api.github.com/repos/litedb-org/LiteDB/issues/1716/comments",
    "author": "oleg-chibikov",
    "comments": [
      {
        "user": "lbnascimento",
        "created_at": "2020-06-10T14:48:21Z",
        "body": "@oleg-chibikov Just replace `MAX($.Id)` with `MAX(*.Id)` and it should work"
      },
      {
        "user": "1nfected",
        "created_at": "2023-07-19T06:06:47Z",
        "body": "> @oleg-chibikov Just replace `MAX($.Id)` with `MAX(*.Id)` and it should work\r\n\r\nThis is such an important piece of info, which should definitely be a part of the documentation."
      }
    ]
  },
  {
    "number": 1696,
    "title": "[QUESTION] EnsureIndex on empty collection",
    "created_at": "2020-05-27T13:02:14Z",
    "closed_at": "2020-05-28T12:52:07Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/litedb-org/LiteDB/issues/1696",
    "body": "Is it OK to call EnsureIndex on empty collection - at database creation time, to register index fields, or there must be at least one data entry in collection?",
    "comments_url": "https://api.github.com/repos/litedb-org/LiteDB/issues/1696/comments",
    "author": "abrca",
    "comments": [
      {
        "user": "lbnascimento",
        "created_at": "2020-05-27T14:02:10Z",
        "body": "@abrca It is perfectly fine to call `EnsureIndex` for a possibly non-existent collection, it will be created if it doesn't exist."
      }
    ]
  },
  {
    "number": 1674,
    "title": "[QUESTION] POCO classes having a Guid Id",
    "created_at": "2020-05-08T14:29:25Z",
    "closed_at": "2020-05-10T00:26:16Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/litedb-org/LiteDB/issues/1674",
    "body": "Most of the data I'm dealing with has a Guid as unique identifier. When I'm trying to add an object that has a property called Id of type System.Guid to LiteDB I'm stopped by \r\n\r\n> System.InvalidCastException: 'Unable to cast object of type 'System.Guid' to type 'System.Int32'.'\r\n\r\nIs there any way to get this done? I can't change the object model.",
    "comments_url": "https://api.github.com/repos/litedb-org/LiteDB/issues/1674/comments",
    "author": "ssteiner",
    "comments": [
      {
        "user": "lbnascimento",
        "created_at": "2020-05-08T16:07:08Z",
        "body": "@ssteiner Could you post more info about the object you're trying to store? `Guid` is supported natively by LiteDB, there shouldn't be any issues."
      },
      {
        "user": "ssteiner",
        "created_at": "2020-05-08T16:50:37Z",
        "body": "Here's the object I'm trying to store\r\n\r\n```csharp\r\n    public class PluginConfiguration\r\n    {\r\n        public Guid Id { get; set; }\r\n\r\n        public string Name { get; set; }\r\n\r\n        public SpecialConfiguration SpecialConfig { get; set; }\r\n        \r\n    }\r\n\r\n    public class SpecialConfiguration\r\n    {\r\n        public string Value1 { get; set; }\r\n\r\n        public string Value2 { get; set; }\r\n    }"
      },
      {
        "user": "lbnascimento",
        "created_at": "2020-05-08T17:04:42Z",
        "body": "@ssteiner This class is perfectly fine, I just tested it and it works fine. Could you show me how you're opening the datafile, the collection and inserting the object?"
      },
      {
        "user": "ssteiner",
        "created_at": "2020-05-08T17:09:05Z",
        "body": "@lbnascimento sure thing - here's how I'm trying to insert. Note I commented out the EnsureIndex because I first though maybe that's what's tripping it up, but it happens either way.\r\n\r\n```csharp\r\nprivate string databaseFile = @\"c:\\temp\\litedb.db\";\r\n\r\ninternal void AddConfig(PluginConfiguration config)\r\n        {\r\n            using (var db = new LiteDatabase(databaseFile))\r\n            {\r\n                var configs = db.GetCollection<PluginConfiguration>(nameof(PluginConfiguration));\r\n                //configs.EnsureIndex(x => x.Id);\r\n                int nbRows = configs.Insert(config);\r\n            }\r\n        }"
      },
      {
        "user": "lbnascimento",
        "created_at": "2020-05-08T17:22:03Z",
        "body": "@ssteiner The error is happening because you're attributing the result of the `Insert` to an `int`. `Insert` returns the Id of the inserted document, which is a `Guid` in your case."
      },
      {
        "user": "ssteiner",
        "created_at": "2020-05-08T17:46:51Z",
        "body": "@lbnascimento : Ahh, I see. While I have you, do I need the EnsureIndex in this case or is it automatically indexed on Id?"
      },
      {
        "user": "lbnascimento",
        "created_at": "2020-05-08T17:52:05Z",
        "body": "@ssteiner It is not needed, the Id field is always indexed."
      }
    ]
  },
  {
    "number": 1666,
    "title": "Selection a random document from a collection",
    "created_at": "2020-05-02T19:44:00Z",
    "closed_at": "2020-05-04T19:11:23Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/litedb-org/LiteDB/issues/1666",
    "body": "Hello,\r\nI am quite new to LiteDB, but my first impression is enthusiastic. I am trying to investigate its capabilities, which is not always easy, since the documentation is still somewhat sparse.\r\nMy first issue is as follows: I need to select random elements from a collection, how can I do it? The Query class does not seem to provide for such a possibility, is there any (in SQLite I would use ORDER BY RANDOM or so)?\r\nThanks, F.",
    "comments_url": "https://api.github.com/repos/litedb-org/LiteDB/issues/1666/comments",
    "author": "FrancescaY",
    "comments": [
      {
        "user": "lbnascimento",
        "created_at": "2020-05-04T16:55:49Z",
        "body": "@FrancescaY There's no specific funcionality for querying a random document. You could do something like this:\r\n\r\n```C#\r\nvar rnd = new Random();\r\nvar offset = rnd.Next(0, col.Count());\r\nvar result = col.Query().Limit(1).Offset(offset).SingleOrDefault();\r\n```"
      }
    ]
  },
  {
    "number": 1659,
    "title": "[QUESTION] How to create a query/expression with a NOT clause",
    "created_at": "2020-04-27T21:57:15Z",
    "closed_at": "2020-04-28T12:47:56Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/litedb-org/LiteDB/issues/1659",
    "body": "In LiteDB v4 you could construct a query (using the API) like the following:\r\n\r\n`\r\nvar query = Query.Not(someOtherQuery);\r\n`\r\n\r\nIn LiteDB v5 that option no longer exists.  Is there a method that I am missing that replaces that functionality?  I would have expected to see something like this:\r\n\r\n`\r\nvar bsonExpression = Query.Not(someOtherBsonExpression);\r\n`\r\n",
    "comments_url": "https://api.github.com/repos/litedb-org/LiteDB/issues/1659/comments",
    "author": "jonlipsky",
    "comments": [
      {
        "user": "lbnascimento",
        "created_at": "2020-04-27T23:41:52Z",
        "body": "@jonlipsky There's no explicit `NOT` operator currently. You could do something like this:\r\n\r\n```C#\r\nBsonExpression expr2 = string.Format(\"({0})=false\", expr1.Source);\r\n```\r\n\r\nIt's a bit convoluted, but it works perfectly."
      }
    ]
  },
  {
    "number": 1655,
    "title": "[QUESTION] How to properly delete file from filestorage so that db size also reduces?",
    "created_at": "2020-04-25T15:20:23Z",
    "closed_at": "2020-04-27T04:24:25Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/litedb-org/LiteDB/issues/1655",
    "body": "Currently when i delete file stored in filestorage, the size of db file does not reduce. I use code as below for\r\n```\r\npublic bool deleteById(string id)\r\n        {\r\n            using (var flowDB = new LiteDatabase(dbName))\r\n            {\r\n                // first delete any files stored for this\r\n                flowDB.BeginTrans();\r\n                var col = flowDB.GetCollection<FlowFileModel>(COLLECTION_NAME);\r\n                var result = col.Find(x => x.Id == id).First<FlowFileModel>();\r\n                flowDB.FileStorage.Delete(result.StoredFileId);\r\n                flowDB.Commit();\r\n\r\n                // delete the object\r\n                var ret = flowDB.GetCollection<FlowFileModel>(COLLECTION_NAME)\r\n                               .Delete(id);\r\n                return ret;\r\n            }\r\n        }\r\n```\r\n\r\nNow the issue is when i see the objects and associated file in LiteDB studio it is gone. But after closing the application the db size remains as it was with file before. Am i missing something?",
    "comments_url": "https://api.github.com/repos/litedb-org/LiteDB/issues/1655/comments",
    "author": "ranjanpr",
    "comments": [
      {
        "user": "zmira",
        "created_at": "2020-04-25T22:19:26Z",
        "body": "have you tried rebuilding the database, using `flowDB.Rebuild();` before returning?"
      }
    ]
  },
  {
    "number": 1646,
    "title": "In memory database with encryption, persisting to file system",
    "created_at": "2020-04-21T07:51:26Z",
    "closed_at": "2020-04-22T18:56:08Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/litedb-org/LiteDB/issues/1646",
    "body": "I want to use LiteDB to create an in-memory database with encryption and once it has been build I want to persist it to disk.\r\n\r\nIf I use a memorystream to persist it, I cannot specify a password.\r\nIf I use :memory: to create it, I cannot persist it.\r\n\r\nAny hints on how to do this ?",
    "comments_url": "https://api.github.com/repos/litedb-org/LiteDB/issues/1646/comments",
    "author": "mvdzwaan",
    "comments": [
      {
        "user": "lbnascimento",
        "created_at": "2020-04-22T18:06:15Z",
        "body": "@mvdzwaan Something like this should work:\r\n```C#\r\nvar stream = new MemoryStream();\r\nvar aesStream = new LiteDB.Engine.AesStream(\"mypassword\", stream);\r\n\r\nusing (var db = new LiteDatabase(aesStream))\r\n{\r\n    //do whatever you want\r\n}\r\n\r\nusing (var fs = File.Create(\"C:\\\\Temp\\\\outputfile.db\"))\r\n{\r\n    stream.Seek(0, SeekOrigin.Begin);\r\n    stream.CopyTo(fs);\r\n}\r\n```"
      }
    ]
  },
  {
    "number": 1643,
    "title": "[QUESTION]",
    "created_at": "2020-04-20T06:16:04Z",
    "closed_at": "2020-04-22T17:53:19Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/litedb-org/LiteDB/issues/1643",
    "body": " I'm a newbie in LiteDB. I make an asp.net mvc project to interact with a LiteDB file. All function is ok, but the data only save in DB-log.db file. DB.db file don't change. \r\n Please help me how to commit data from log file to main db file.\r\n Thanks!",
    "comments_url": "https://api.github.com/repos/litedb-org/LiteDB/issues/1643/comments",
    "author": "hvson",
    "comments": [
      {
        "user": "lbnascimento",
        "created_at": "2020-04-20T15:06:15Z",
        "body": "@hvson While auto-checkpoint is supposed to run eventually (by default, every time the log file reaches 8MB), it might not happen if your application is always using the datafile.\r\n\r\nTry running a `db.Checkpoint()` every once in a while."
      }
    ]
  },
  {
    "number": 1625,
    "title": "How filter result by reference column?",
    "created_at": "2020-04-11T20:08:56Z",
    "closed_at": "2020-04-14T16:07:56Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/litedb-org/LiteDB/issues/1625",
    "body": "Hi.\r\nThis is not work:\r\n\r\n`var result = db.GetCollection<Product>(\"products\").Include(x => x.Category).Find(x => x.Category.Id == 14).ToList();`\r\n\r\nI receive empty result. \r\nThis work:\r\n\r\n`var result = db.GetCollection<Product>(\"products\").Include(x => x.Category).FindAll().Where(x => x.Category.Id == 14).ToList();`\r\n\r\nWhat I am doing wrong? How to filter products by category?\r\n```\r\n[BsonRef(\"categories\")]\r\npublic Category Category { get; set; }\r\n```",
    "comments_url": "https://api.github.com/repos/litedb-org/LiteDB/issues/1625/comments",
    "author": "fu-hsi",
    "comments": [
      {
        "user": "lbnascimento",
        "created_at": "2020-04-13T14:09:56Z",
        "body": "@fu-hsi Your first example should be working. Could you provide us the datafile you're using?"
      },
      {
        "user": "fu-hsi",
        "created_at": "2020-04-13T16:19:43Z",
        "body": "```\r\n    public class Category\r\n    {\r\n        [BsonId]\r\n        public int Id { get; set; }\r\n        public string Name { get; set; }\r\n    }\r\n```\r\n\r\n```\r\n    public class Product\r\n    {\r\n        [BsonId]\r\n        public int Id { get; set; }\r\n\r\n        [BsonRef(\"categories\")]\r\n        public Category Category { get; set; }\r\n\r\n        public string Name { get; set; }\r\n    }\r\n```\r\n\r\nData in database:\r\n```\r\n[\r\n  {\r\n    \"Id\": 1,\r\n    \"Category\": {\r\n      \"Id\": 1,\r\n      \"Name\": \"Kategoria 12.04.2020 08:57:22\"\r\n    },\r\n    \"Name\": \"Produkt 12.04.2020 08:57:26\",\r\n  }\r\n]\r\n```\r\nNot working (with Include):\r\n```\r\nvar result = db.GetCollection<Product>(\"products\").Include(x => x.Category).Find(x => x.Category.Id == 1).ToList();\r\n```\r\n\r\nWorking (without Include):\r\n```\r\nvar result = db.GetCollection<Product>(\"products\").Find(x => x.Category.Id == 1).ToList();\r\n```"
      },
      {
        "user": "lbnascimento",
        "created_at": "2020-04-13T16:30:25Z",
        "body": "@fu-hsi The `Category` data was inserted incorrectly: it was inserted as a subdocument of `Product` instead of a reference to another collection. You should remove this entry, insert the categories in a separate collection (if you haven't already) and then insert the product data again (the existence of `BsonRefAttribute` should be enough for it to be inserted correctly this time)."
      },
      {
        "user": "fu-hsi",
        "created_at": "2020-04-13T16:37:42Z",
        "body": "This is only data dump from result variable.\r\nInsert query:\r\n\r\n```\r\nproducts.Insert(new Product { Name = \"Produkt \" + DateTime.Now, Category = category });\r\n```\r\nData from LiteDB Studio:\r\n\r\n```\r\n/* 1 */\r\n{\r\n  \"_id\": 1,\r\n  \"Category\": \r\n  {\r\n    \"$id\": 1,\r\n    \"$ref\": \"categories\"\r\n  },\r\n  \"Name\": \"Produkt 12.04.2020 08:57:26\",\r\n}\r\n```"
      },
      {
        "user": "lbnascimento",
        "created_at": "2020-04-14T16:07:56Z",
        "body": "@fu-hsi This issue has been fixed and its fix is already available in version 5.0.7."
      }
    ]
  },
  {
    "number": 1620,
    "title": "[QUESTION] How can I store an array of strings in this database?",
    "created_at": "2020-04-07T18:34:05Z",
    "closed_at": "2020-04-08T08:11:42Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/litedb-org/LiteDB/issues/1620",
    "body": "I don`t wanna create new class to do this. \r\nI need fast way to store and read array of strings and nothing else.\r\n\r\nIs there a method to do this?\r\nIf not, are there plans to add?\r\n\r\n",
    "comments_url": "https://api.github.com/repos/litedb-org/LiteDB/issues/1620/comments",
    "author": "riksking",
    "comments": [
      {
        "user": "lbnascimento",
        "created_at": "2020-04-07T19:32:37Z",
        "body": "@riksking I took the code you mentioned in #1597 and modified it:\r\n\r\n```C#\r\npublic static void WriteToExistDb(IEnumerable<string> chunk, string pathToDb, string tableName)\r\n{\r\n\tusing (var testDb = new LiteDatabase(pathToDb))\r\n\t{\r\n\t\tvar col = testDb.GetCollection(tableName);\r\n\t\tforeach (var str in chunk)\r\n\t\t{\r\n\t\t\tcol.Insert(new BsonDocument { [\"value\"] = str });\r\n\t\t}\r\n\t}\r\n}\r\n\r\npublic static IEnumerable<string> ReadFromExistDb(string pathToDb, sting tableName)\r\n{\r\n\tusing (var testDb = new LiteDatabase(pathToDb))\r\n\t{\r\n\t\tvar col = testDb.GetCollection(tableName);\r\n\t\tforeach(var doc in col.FindAll())\r\n\t\t{\r\n\t\t\tyield return doc[\"value\"].AsString;\r\n\t\t}\r\n\t}\r\n}\r\n```"
      }
    ]
  },
  {
    "number": 1594,
    "title": "[QUESTION] How do you load a encrypted db from System.IO.Stream?",
    "created_at": "2020-03-27T14:46:55Z",
    "closed_at": "2020-03-31T00:36:32Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/litedb-org/LiteDB/issues/1594",
    "body": "First of all, thank you, LiteDB is AWESOME!!\r\n\r\nI have a database in a dll stored as an EmbeddedResource. It is encrypted with a password.\r\nHow do I load it as a stream and pass it the password?.\r\n\r\nIf it is a file from disk, I can do this:\r\n``` csharp\r\nvar connectionString=\"Filename=C:\\database.db;Password=1234\";\r\nvar db = new LiteDatabase(connectionString);\r\n```\r\nBut I want to stream the EmbeddedResource directly without copying it to disk.\r\n```csharp\r\nvar stream = GetAssembly().GetManifestResourceStream(\"MyApp.database.db\");\r\nvar db = new LiteDatabase(stream); // how do I specify the password???\r\n```",
    "comments_url": "https://api.github.com/repos/litedb-org/LiteDB/issues/1594/comments",
    "author": "koddek",
    "comments": [
      {
        "user": "lbnascimento",
        "created_at": "2020-03-27T15:11:13Z",
        "body": "@koddek You can do something like this:\r\n```C#\r\nvar aesStream = new LiteDB.Engine.AesStream(\"mypassword\", stream);\r\nvar db = new LiteDatabase(aesStream);\r\n```"
      }
    ]
  },
  {
    "number": 1584,
    "title": "[QUESTION] How do I fetch a list of KeyValuePair from db?",
    "created_at": "2020-03-21T20:48:12Z",
    "closed_at": "2020-03-23T17:09:47Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/litedb-org/LiteDB/issues/1584",
    "body": "For example I have `List<KeyValuePair<string, Rectangle>> listName` that I can write and update in the db. When I am checking with LiteStudio I can see that the list has been written correctly but when I fetch the list i get the number of elements in the list but the Key and the Value are empty",
    "comments_url": "https://api.github.com/repos/litedb-org/LiteDB/issues/1584/comments",
    "author": "Mbogdan95",
    "comments": [
      {
        "user": "lbnascimento",
        "created_at": "2020-03-23T14:12:43Z",
        "body": "@Mbogdan95 Is there any specific reason you're not using `Dictionary<string, Rectangle>`?"
      }
    ]
  },
  {
    "number": 1579,
    "title": "[QUESTION] How to Backup a LiteDB",
    "created_at": "2020-03-19T02:13:17Z",
    "closed_at": "2020-03-20T01:37:12Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/litedb-org/LiteDB/issues/1579",
    "body": "May I know how to backup a LiteDB?\r\nOr 'rollback' to previously commits.\r\nOr use Export json file is the best option?\r\n\r\n(Because I am inserting data to LiteDB. But sometimes I just insert some improper JSON...)\r\n\r\nThanks!",
    "comments_url": "https://api.github.com/repos/litedb-org/LiteDB/issues/1579/comments",
    "author": "josephinenewbie",
    "comments": [
      {
        "user": "lbnascimento",
        "created_at": "2020-03-19T13:26:50Z",
        "body": "@josephinenewbie There is no way to rollback a commited transaction - however, an uncommited transaction can be manually rolled back and it will be discarded if the datafile is abruptly closed (process crashed, power loss etc.).\r\n\r\nRegarding backup, there is no specific functionality for it. Making copies of the datafile should be fine for most purposes."
      },
      {
        "user": "HolyOne",
        "created_at": "2021-08-16T13:58:15Z",
        "body": "Can I copy litedb file while my website is running?\r\nWill it always create a working copy of the database? O is there a chance for it to be broken if there are write operations on the website while copying?"
      },
      {
        "user": "lbnascimento",
        "created_at": "2021-08-16T16:43:56Z",
        "body": "@HolyOne You can't simply copy the file while it's open by LiteDB. You have to make sure the file is closed and that the log file is empty by running `db.Checkpoint()` before copying the file."
      }
    ]
  },
  {
    "number": 1573,
    "title": "Filtering on child field using substring",
    "created_at": "2020-03-15T19:35:16Z",
    "closed_at": "2020-03-16T20:47:34Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/litedb-org/LiteDB/issues/1573",
    "body": "Hello,\r\n\r\nWhen I execute the following SQL which filters documents on a parent field, the query seems to get the correct result.\r\n\r\nselect $ from Patients WHERE substring($.nameFirst,0,1) ALL = 'd'\r\n\r\nHowever, when I use the following SQL on a child field using substring I do not get any result.\r\n \r\nselect $ from Patients WHERE substring($.Tumors[*].dateOfDiagnosis,0,4) ALL = '2018'\r\n\r\nWhat am I doing wrong?",
    "comments_url": "https://api.github.com/repos/litedb-org/LiteDB/issues/1573/comments",
    "author": "sanjeevbaral",
    "comments": [
      {
        "user": "lbnascimento",
        "created_at": "2020-03-16T16:54:56Z",
        "body": "@sanjeevbaral `substring` can only be used with scalar expressions (expressions that evaluate to a single value), and `$.Tumors[*].dateOfDiagnosis` is an enumerable expression (it evaluates to all the dates of diagnosis).\r\n\r\nYou could use `select $ from Patients WHERE $.Tumors[*].dateOfDiagnosis ALL like '2018%'`."
      }
    ]
  },
  {
    "number": 1572,
    "title": "IN() in SQL",
    "created_at": "2020-03-15T10:53:51Z",
    "closed_at": "2020-03-16T20:47:36Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/litedb-org/LiteDB/issues/1572",
    "body": "Hello,\r\n\r\nI found that the following executes fine \r\n\r\nselect $ from Patients WHERE $.Tumors[*].primarySite ALL  IN ('C447')\r\n\r\nHowever, if I add more values to the list like this I get syntax error on the comma separating the values. \r\n\r\nselect $ from Patients WHERE $.Tumors[*].primarySite ALL  IN ('C447','C500')\r\n\r\nWhat is the correct syntax for specifying a list of values? ",
    "comments_url": "https://api.github.com/repos/litedb-org/LiteDB/issues/1572/comments",
    "author": "sanjeevbaral",
    "comments": [
      {
        "user": "lbnascimento",
        "created_at": "2020-03-16T16:40:22Z",
        "body": "@sanjeevbaral You should use `select $ from Patients WHERE $.Tumors[*].primarySite ALL IN ['C447','C500']`"
      }
    ]
  },
  {
    "number": 1555,
    "title": "[QUESTION] Any API to include data on deployment",
    "created_at": "2020-03-11T06:49:14Z",
    "closed_at": "2020-03-14T13:09:58Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/litedb-org/LiteDB/issues/1555",
    "body": "```\r\npublic class Customer\r\n{\r\n    public ObjectId CustomerId { get; set; }\r\n    public CustomerType type  { get; set; }\r\n    public string Name { get; set; }\r\n    public DateTime CreateDate { get; set; }\r\n    public List<Phone> Phones { get; set; }\r\n    public bool IsActive { get; set; }\r\n}\r\n\r\npublic class CustomerType\r\n{\r\n    public ObjectId Id { get; set; }\r\n    public string Type{ get; set; }\r\n\r\n}\r\n```\r\n\r\nI wanted to include default data for Customer type while deploying the WPF app. Any API for that?\r\nId Type\r\n1 Loyal\r\n2 Normal\r\n\r\n\r\n",
    "comments_url": "https://api.github.com/repos/litedb-org/LiteDB/issues/1555/comments",
    "author": "meteorsnows",
    "comments": [
      {
        "user": "meteorsnows",
        "created_at": "2020-03-13T16:01:49Z",
        "body": "I am trying to include default data for CustomerType Table at first installed for WPF app\r\n\r\nId Type\r\n1 Loyal\r\n2 Normal\r\n\r\nInstead of following:\r\n>   // Create your new customer instance\r\n>     var customer = new CustomerType\r\n>     { \r\n>         Type = \"Loyal\", \r\n>     };\r\n>     col.Insert(customer);\r\n\r\n\r\n\r\n\r\n"
      },
      {
        "user": "lbnascimento",
        "created_at": "2020-03-13T17:41:43Z",
        "body": "@meteorsnows There is no specific collection initialization functionality. You would have to do it manually, something like this:\r\n\r\n```C#\r\nvar types = db.GetCollection<CustomerType>();\r\nif(types.Count() == 0)\r\n{\r\n\ttypes.Insert(new CustomerType { Type = \"Loyal\" });\r\n\ttypes.Insert(new CustomerType { Type = \"Normal\" });\r\n}\r\n```"
      }
    ]
  },
  {
    "number": 1528,
    "title": "[QUESTION]",
    "created_at": "2020-03-03T09:29:09Z",
    "closed_at": "2020-03-03T14:05:18Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/litedb-org/LiteDB/issues/1528",
    "body": "In version 4.x, I used the function GetIndexes() of the LiteCollection<T> to view the existing indexes. This allowed me to view the existing indexes and drop them automatically if the where absolute in older collections.\r\nBut in version 5 this functionality is missing in the ILiteCollection<T>. Is there a way to get the existing indexes (I only need the names of the indexes)?",
    "comments_url": "https://api.github.com/repos/litedb-org/LiteDB/issues/1528/comments",
    "author": "Fleximinded",
    "comments": [
      {
        "user": "lbnascimento",
        "created_at": "2020-03-03T13:50:57Z",
        "body": "@filipgeens You can list indexes by querying the `$indexes` system collection. You can open it as if it were a regular collection: `var col = db.GetCollection(\"$indexes\")`.\r\n\r\nEach document returned has the following structure:\r\n\r\n```javascript\r\n{\r\n   \"collection\":\"Customers\",\r\n   \"name\":\"_id\",\r\n   \"expression\":\"$._id\",\r\n   \"unique\":true,\r\n   \"maxLevel\":19\r\n}\r\n```\r\n\r\nYou can use filters too. For example, if you wanted only the indexes for the collection `Customers`, you can use `col.Find(\"$.collection = 'Customers'\")`."
      }
    ]
  },
  {
    "number": 1484,
    "title": "[QUESTION] How to filter by referenced collection primary key?",
    "created_at": "2020-02-16T22:23:51Z",
    "closed_at": "2020-02-17T19:57:25Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/litedb-org/LiteDB/issues/1484",
    "body": "Let's take next relation\r\n```csharp\r\nclass Child\r\n{\r\n   int Id {get;set;}\r\n}\r\nclass Owner\r\n{\r\n    int Id {get;set;}\r\n    Child Child {get;set;}\r\n}\r\n```\r\nWhich is registered in next way\r\n```csharp\r\nDatabase.Mapper.Entity<Child>()\r\n     .Id(e => e.Id, false);\r\nDatabase.Mapper.Entity<Owner>()\r\n     .DbRef(e => e.Child)\r\n     .Id(e => e.Id, false);\r\n```\r\nOn this point I understand, Owner document will contain only id of child document.\r\nBut how should I filter Owner documents by Child id?\r\nI can use next code:\r\n```csharp\r\nCollection\r\n    .Include(o => o.Child)\r\n    .Find(Query.EQ($\"{nameof(Owner.Child)}.{nameof(Child.Id)}\", new BsonValue(idValue))))\r\n```\r\nBut is it the best way to do filter by referenced document id? Because code above requires Include, when I don't really need child document, except of Id.\r\nAlso, how should I ensure index for it?\r\n\r\nThanks.\r\n",
    "comments_url": "https://api.github.com/repos/litedb-org/LiteDB/issues/1484/comments",
    "author": "maxkatz6",
    "comments": [
      {
        "user": "mbdavid",
        "created_at": "2020-02-17T13:07:54Z",
        "body": "Hi @maxkatz6, if you don't need to include you can filter by `$id` key. Like this:\r\n\r\n```\r\ncollection.Query()\r\n    .Where(\"$.Child.$id = @0\", idValue)\r\n    .ToList()\r\n```"
      }
    ]
  },
  {
    "number": 1477,
    "title": "[QUESTION] Delete after upgrade to 5.X",
    "created_at": "2020-02-14T11:02:00Z",
    "closed_at": "2020-02-17T07:30:40Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/litedb-org/LiteDB/issues/1477",
    "body": "With version 4.X I was able to delete entries with:\r\n\r\ncol.Delete(Query.EQ(\"_id\", toDelete.Id));\r\n\r\nThis doesn't work with 5.X. So what is the best approach with 5.X to delete records? I didn't find anything in the documentation?",
    "comments_url": "https://api.github.com/repos/litedb-org/LiteDB/issues/1477/comments",
    "author": "gnimor",
    "comments": [
      {
        "user": "JensSchadron",
        "created_at": "2020-02-14T22:32:58Z",
        "body": "Hi @gnimor \r\nHere's a sample that (hopefully answers your question.\r\n```csharp\r\nclass Program\r\n{\r\n\tstatic void Main(string[] args)\r\n\t{\r\n\t\tusing var db = new LiteDatabase(new MemoryStream());\r\n\t\tvar col = db.GetCollection<TestClass>();\r\n\t\t\r\n\t\tvar instance = new TestClass\r\n\t\t{\r\n\t\t\tId = Guid.NewGuid(),\r\n\t\t\tData = \"My data\"\r\n\t\t};\r\n\t\tcol.Insert(instance);\r\n\r\n\t\tConsole.WriteLine($\"{nameof(TestClass)} collection contains {col.Count()} item(s)\");\r\n\r\n\t\tConsole.WriteLine($\"Deleting item by id in collection {nameof(TestClass)}\");\r\n\t\t// Delete specific item by id\r\n\t\tcol.Delete(instance.Id);\r\n\r\n\t\tConsole.WriteLine($\"{nameof(TestClass)} collection contains {col.Count()} item(s)\\n\");\r\n\t\t\r\n\t\t// Inserting item again\r\n\t\tcol.Insert(instance);\r\n\r\n\t\tConsole.WriteLine($\"{nameof(TestClass)} collection contains {col.Count()} item(s)\");\r\n\r\n\t\tConsole.WriteLine($\"Deleting item by id in collection {nameof(TestClass)}\");\r\n\t\t// Delete using predicate lambda\r\n\t\tcol.DeleteMany(item => item.Data == \"My data\");\r\n\t\t// or delete using Bson expressions\r\n\t\tcol.DeleteMany(Query.StartsWith(nameof(instance.Data), instance.Data));\r\n\r\n\t\tConsole.WriteLine($\"{nameof(TestClass)} collection contains {col.Count()} item(s)\");\r\n\t}\r\n\r\n\tclass TestClass\r\n\t{\r\n\t\tpublic Guid Id { get; set; }\r\n\t\tpublic string Data { get; set; }\r\n\t}\r\n}\r\n```\r\n\r\nAs you can see in the sample, you could either delete a specific item by it's Id using the `col.Delete(<id>)` method, or you could use the DeleteMany method which accepts predicates and BSON expressions.\r\n\r\nIf this answers your question, please close the issue \ud83d\ude42 "
      }
    ]
  },
  {
    "number": 1474,
    "title": "[QUESTION] Using Memory Stream in v5",
    "created_at": "2020-02-13T17:45:07Z",
    "closed_at": "2020-02-15T18:08:31Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/litedb-org/LiteDB/issues/1474",
    "body": "Hi,\r\n\r\nWith migration to v5 there are some breaking changes (there is no Shrink method, no access to Engine etc) and there is no documentation how to migrate from v4.\r\nIn v4, I used MemoryStream to load data from file and pass it to the LiteRepository, and after when I finished working with LiteDB I was saving the MemoryStream to disk as byte array in a file. And afterwards when reloading the MemoryStream from the file, the LiteDB contained my objects.\r\nNow, it seems that MemoryStream does not contains all data necessary to recreate the LiteRepository the next time when it is reloaded from disk. The way that is used to use LiteDB is not longer valid?\r\n\r\nHow can I retrieve the Data that is stored in the LiteRepository (initialized by MemoryStream) and save it on disk? ",
    "comments_url": "https://api.github.com/repos/litedb-org/LiteDB/issues/1474/comments",
    "author": "Soruk",
    "comments": [
      {
        "user": "mbdavid",
        "created_at": "2020-02-15T13:32:49Z",
        "body": "LiteDB v5 works quit different from v4 in this aspect. In v4 you had a single file only (with no temp data). v5 needs temp (log file) to implement WAL. When you initialize a database with MemoryStream, another memory stream are created to store data log (pages changes). This new memory stream contains changes only and when get 1000 pages, this file are copied into original data file. This command can be called by `Checkpoint` method too. After a checkpoint, your datafile contains all your data an log file are clear. This checkpoin also occurs when you close database.\r\n"
      },
      {
        "user": "nightroman",
        "created_at": "2020-02-15T14:18:14Z",
        "body": "Given I create a database instance A using\r\n\r\n```csharp\r\n    public LiteDatabase(Stream stream, BsonMapper mapper = null)\r\n```\r\n\r\nIs that correct that I should not open another database instance B using the same stream until I close A? (Because, my thinking, A and B will create different WAL streams instead of using the same).\r\n "
      }
    ]
  },
  {
    "number": 1462,
    "title": "[QUESTION] disable creation of LiteDB-log",
    "created_at": "2020-02-10T11:50:40Z",
    "closed_at": "2020-02-15T13:21:28Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/litedb-org/LiteDB/issues/1462",
    "body": "when I create a database (let's call him \"DB\"), it's created me a file DB.db and DB-log.db.\r\nhow I can create a database without the log file?\r\n\r\nthe c# code is:\r\n`var db = new LiteDatabase(@\"DB.db\");`",
    "comments_url": "https://api.github.com/repos/litedb-org/LiteDB/issues/1462/comments",
    "author": "asakl",
    "comments": [
      {
        "user": "mbdavid",
        "created_at": "2020-02-10T19:42:21Z",
        "body": "This temp file are required in LiteDB v5 because it's used as WAL (write ahead log). All databases needs this to implement of ACID. This file are deleted when you close database."
      },
      {
        "user": "asakl",
        "created_at": "2020-02-11T15:59:48Z",
        "body": "OK thanks. \r\nbut, even when i close my program entirely it's still there... \r\nthe file can risk my data? (like, if it's a private info)"
      },
      {
        "user": "rickguedes",
        "created_at": "2020-02-11T20:53:16Z",
        "body": "It seems it's only deleted when you call Dispose() in you database"
      },
      {
        "user": "mbdavid",
        "created_at": "2020-02-12T17:02:46Z",
        "body": "You always should call Dispose() on LiteDatabase after use. If not, you will not close file connections"
      },
      {
        "user": "DinoChan",
        "created_at": "2020-02-18T03:08:54Z",
        "body": "In some cases, we do not have permission to delete any files (GMP or 21crf) in the directory. This temporary log file will cause some exceptions. Is there really no way to disable log files?"
      },
      {
        "user": "AntonyNET",
        "created_at": "2020-03-12T14:37:57Z",
        "body": "Hi!\r\nI open DB on my app start and dispose it when app closed.\r\nSometimes my app crashs and when i start it next time i have no data that i save. \r\nHow i can flush changes from log file to main DB? log file is 7GB already"
      },
      {
        "user": "lbnascimento",
        "created_at": "2020-03-12T14:46:24Z",
        "body": "@AntonyNET Just run a checkpoint operation after opening the datafile (actually, it should automatically run checkpoint when opening a datafile)"
      },
      {
        "user": "challamzinniagroup",
        "created_at": "2021-02-16T02:56:24Z",
        "body": "@lbnascimento  Sorry to drag up an old post - but can you explain a little further about the checkpoint operation (or point me to the docs section, if such a section exists)? I am using LiteDB on an API that is always on. I wrap the connection in `using` statements so they are always disposed. Yet I recently revisited an old project and the db file shows a last updated timestamp of 8 months ago, while the log file shows last updated of today and is over 3GB in size. So the log file is clearly not being merged back into the db file, nor is it being deleted.\r\n\r\nAny more info you could provide would be appreciated.\r\n\r\nThanks!"
      }
    ]
  },
  {
    "number": 1453,
    "title": "[QUESTION] How to correctly set a shared connection?",
    "created_at": "2020-02-08T21:13:07Z",
    "closed_at": "2020-02-08T22:14:36Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/litedb-org/LiteDB/issues/1453",
    "body": "Hi all, I am on v5.0.1 and I don't understand how to set the connection as shared. I have tried with both Mode=Shared and Connection=Shared but if I open the database in LiteDB Studio and then in my app or the opposite, I receive an exception stating that the file is already opened in another process.\r\n\r\nCan you tell me what is the correct way of setting the connection as shared?\r\nThanks in advance",
    "comments_url": "https://api.github.com/repos/litedb-org/LiteDB/issues/1453/comments",
    "author": "darcome",
    "comments": [
      {
        "user": "JensSchadron",
        "created_at": "2020-02-08T22:07:51Z",
        "body": "@darcome Here's a working example of how to run LiteDB in Shared connection mode\r\n```csharp\r\nclass Program\r\n{\r\n\tstatic async Task Main(string[] args)\r\n\t{\r\n\t\tawait Task.WhenAll(\r\n\t\t\tAction(),\r\n\t\t\tAction());\r\n\t}\r\n\r\n\tprivate static async Task Action()\r\n\t{\r\n\t\tusing var db = new LiteDatabase(@\"Filename=database.db;Password='1234';connection=shared\");\r\n\t\tawait Task.Delay(1000);\r\n\t}\r\n}\r\n```\r\n\r\nIf you prefer using a connectionString object instead of a literal string, you can also replace the string with something like this\r\n```csharp\r\nnew ConnectionString(@\"database.db\")\r\n{\r\n\tPassword = \"1234\",\r\n\tConnection = ConnectionType.Shared\r\n};\r\n```\r\n"
      },
      {
        "user": "djarvis",
        "created_at": "2020-10-19T13:36:02Z",
        "body": "I see that I cannot use shared mode when I also specify Upgrade=true?"
      },
      {
        "user": "TerenceWallace",
        "created_at": "2021-08-03T04:14:39Z",
        "body": "I cannot get it to work using two separate instances of LiteDB.Studio 'Check Shared' nothing works. (v. 5.0.11)"
      },
      {
        "user": "lbnascimento",
        "created_at": "2021-08-03T14:07:48Z",
        "body": "@TerenceWallace Are you getting any specific error? It should work if both instances are opened in shared mode."
      },
      {
        "user": "TerenceWallace",
        "created_at": "2021-08-03T16:11:22Z",
        "body": "> \r\n> \r\n> @TerenceWallace Are you getting any specific error? It should work if both instances are opened in shared mode.\r\n\r\nYes, I am getting \"The process cannot access the file \"....{filename.db}\" because it is being used by another process.  In both instances (i.e. [Instance 1] running VS in debug mode; [Instance 2] running by double clicking the LiteDB.Studio.exe)  the \"Shared\" box is checked.\r\n\r\nI can send the full solution file to view it for yourself.\r\n"
      },
      {
        "user": "lbnascimento",
        "created_at": "2021-08-03T18:33:16Z",
        "body": "@TerenceWallace Do you get this error for both instances? Or does the first instance open the file successfully and the second one fails?"
      },
      {
        "user": "TerenceWallace",
        "created_at": "2021-08-03T19:35:41Z",
        "body": "Only the second instance fails.  The first instance works fine without any issues."
      },
      {
        "user": "lbnascimento",
        "created_at": "2021-08-03T20:43:41Z",
        "body": "@TerenceWallace This is weird. You can send the solution and the datafile to me at lbnascimento@inf.ufrgs.br"
      },
      {
        "user": "lbnascimento",
        "created_at": "2021-08-04T18:54:03Z",
        "body": "@TerenceWallace The project you sent me uses a very old version of LiteDB.Studio. It should work fine in the latest version."
      },
      {
        "user": "TerenceWallace",
        "created_at": "2021-08-04T19:41:15Z",
        "body": "@lbnascimento is v5.0.11 the very old version?  The files come directly from that version.  Only, the files are compiled using the .NET 4.6 Framework.  \r\n\r\nUnfortunately, we are not a Web 2.0 company and do not rush to the latest 'bells & whistles' of MS Framework(s).  \r\n\r\nIF your saying that the latest (.NET, CORE 3.**, etc.) is a requirement for LiteDB then I can understand that this will not work for us.  "
      },
      {
        "user": "lbnascimento",
        "created_at": "2021-08-04T19:56:17Z",
        "body": "@TerenceWallace v5.0.11 is the latest version of LiteDB. You're running a very old version of LiteDB.**Studio**, which apparently has a bug when opening datafiles in shared mode."
      }
    ]
  },
  {
    "number": 1450,
    "title": "[QUESTION] What's the equivalent for db.GetCollection<Command>(\"commands\").Include(new string[] { \"$.Package\", \"$.Command\", \"$.Command.Package\" }) in version 5?",
    "created_at": "2020-02-07T16:34:17Z",
    "closed_at": "2020-02-07T19:59:12Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/litedb-org/LiteDB/issues/1450",
    "body": "Hi there!\r\n\r\nI have migrated LiteDB from version 4 to 5 and face the problem that `Include()` doesnt' accept a string **ARRAY** argument anymore.\r\n\r\nSo far, I have used\r\n`db.GetCollection<Command>(\"commands\").Include(new string[] { \"$.Package\", \"$.Command\", \"$.Command.Package\" })`\r\n\r\n`Command` is an abstract class and there are different implementations of it. I save all of them in one collection. Some of them have DBRefs to other objects, some of them have not. That's the reason why I cannot use\r\n\r\n`db.GetCollection<Command>(\"commands\").Include(t => t.Package)`\r\n\r\nbecause the abstract class `Command` does not have a `Package` property.\r\n\r\nWhat's the correct way in version 5 to include the DbRefs (and even nested DBRefs) in this scenario with abstract classes?\r\n\r\nLooking forward to your answer. Thank you!",
    "comments_url": "https://api.github.com/repos/litedb-org/LiteDB/issues/1450/comments",
    "author": "loebi-ch",
    "comments": [
      {
        "user": "lbnascimento",
        "created_at": "2020-02-07T18:04:49Z",
        "body": "@loebi-ch There's an overload of `Include` that takes a `BsonExpression` as argument, and strings are implicitly converted to `BsonExpression`, so you can simply use `db.GetCollection<Command>(\"commands\").Include(\"$.Package\")` for your first include. This should work for abstract classes with no issues, even if some of the subclasses don't have a `Package` property.\r\n\r\nRegarding the rest of your question, could you post your classes (or a simplified version of them) and some usage? If `$.Command` is a reference from an instance of `Command` to another, it won't work because LiteDB does not support circular references (in fact, it should not work in v4 too)."
      },
      {
        "user": "loebi-ch",
        "created_at": "2020-02-07T19:34:28Z",
        "body": "Thank you @lbnascimento for your very fast response.\r\n\r\nI wrote \"I have migrated LiteDB from version 4 to 5 and face the problem that Include() doesn't accept a string argument anymore.\" Actually I meant \"STRING ARRAY\".\r\n\r\nSo before in version 4 I used a string array like this:\r\n\r\n`db.GetCollection<Command>(\"commands\").Include(new string[] { \"$.Package\", \"$.Command\", \"$.Command.Package\" })`\r\n\r\nDoes the correct new approach in version 5 looks like this:\r\n\r\n`db.GetCollection<Command>(\"commands\").Include(\"$.Package, $.Command, $.Command.Package\")`\r\n\r\nA string instead of a string array? And can I just comma separate it, or do I have to use multiple includes like\r\n\r\n`db.GetCollection<Command>(\"commands\").Include(\"$.Package\").Include(\"$.Command\").Include(\"$.Command.Package\")`\r\n\r\nActually there is no rest in my question... but I see your confusion because in my example I have used `$.Command` in db.GetCollection<Command>(\"commands\")... but forget about this, there are no circular references and I understood that this is not supported."
      },
      {
        "user": "lbnascimento",
        "created_at": "2020-02-07T19:40:42Z",
        "body": "@loebi-ch You have to make multiple calls to `Include`, in the same order that you used to place the expressions in the string array. So yes, it would look something like `db.GetCollection<Command>(\"commands\").Include(\"$.Package\").Include(\"$.Command\").Include(\"$.Command.Package\")`.\r\n\r\nWe are considering creating a new overload to `Include` that takes a `params BsonExpression[]` as input in the next incremental release."
      }
    ]
  },
  {
    "number": 1282,
    "title": "[question] [bug] which simbol to use for naming reserved collections in my application?",
    "created_at": "2019-08-13T13:54:13Z",
    "closed_at": "2019-08-14T06:54:55Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/litedb-org/LiteDB/issues/1282",
    "body": "Hi,\r\nCollection name starting with \"_\" is used to naming reserved collection inside LiteDB engine.\r\n\r\n[bug]\r\nIf i create a collection named \"$col\" directly, i recieve an exeption: \"invalid format \"$col\".\r\nBut if, for example, i create a collection named \"col\" and i rename it as \"$col\", everything works fine. Is this a bug?\r\n\r\n[question]\r\nNow i know that can be used only letters, numbers and _\r\nWhich starting simbol can i use to identify my reserved collections instead \"$\"?\r\nCan use \"_\" too? I think it could be dangerous.\r\nIf it is possible, i prefer to avoid numbers.\r\n\r\nThanks\r\n",
    "comments_url": "https://api.github.com/repos/litedb-org/LiteDB/issues/1282/comments",
    "author": "alemik",
    "comments": [
      {
        "user": "mbdavid",
        "created_at": "2019-08-13T17:44:11Z",
        "body": "Hi @alemik, are you using v4 or v5? There are some difference in versions.\r\n\r\nI found a bug (in v5) in this nameing checking - will fix"
      },
      {
        "user": "mbdavid",
        "created_at": "2019-08-13T20:48:33Z",
        "body": "Here v5 name validation:\r\n\r\n- Names should be a word: `[a-z]_$` (case insensitive)\r\n- Names should not starts with `$` (reserved for system collections)\r\n\r\nSystem collection are \"virtual collections\", is not concrete data (like `$transactions` returns all open transactions) or \"functions\" (like `$file_csv('c:\\temp\\data.csv')` to read data from CSV file as a collection)\r\n\r\nCollections that starts with `_` are normal user collections. Need attention only for FileStorage: file storage need 2 user collections to store data and, by default, names are `_files` and `_chunks` (this names can be changed is used with `GetStorage` method)."
      }
    ]
  },
  {
    "number": 671,
    "title": "Qual a quantidade total de armazenamento",
    "created_at": "2017-08-01T14:06:44Z",
    "closed_at": "2020-02-05T17:39:27Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/litedb-org/LiteDB/issues/671",
    "body": "Ol\u00e1 Maur\u00edcio. Em primeiro lugar meus parab\u00e9ns pela sua iniciativa, aud\u00e1cia e qualidade do seu projeto.\r\nJ\u00e1 havia ouvido falar do LiteDB mas n\u00e3o havia utilizado e ap\u00f3s ter contato com ele achei formid\u00e1vel.\r\nAinda n\u00e3o efetuei testes com grande massa de dados mas gostaria de saber qual o limite de armazenamento do banco de dados e, com grande volume de dados o banco onera o desempenho da aplica\u00e7\u00e3o?\r\nO LiteDB para aplica\u00e7\u00f5es simples e m\u00e9dias pode ser a grande solu\u00e7\u00e3o para desenvolvedores .NET, j\u00e1 que \u00e9 100% C#, no qual desenvolvo e nos traz o poder de manipular os dados inteiramente dentro das aplica\u00e7\u00f5es.\r\n\r\nParab\u00e9ns,\r\n\r\nMarcelo Henrique",
    "comments_url": "https://api.github.com/repos/litedb-org/LiteDB/issues/671/comments",
    "author": "mhnegrao",
    "comments": [
      {
        "user": "mbdavid",
        "created_at": "2017-08-01T18:17:26Z",
        "body": "Ol\u00e1 Marcelo, obrigado. E que bom poder escrever em portugues :)\r\n\r\nCara, n\u00e3o existe limita\u00e7\u00e3o de tamanho no LiteDB, ele se comporta bem para qualquer tamanho. J\u00e1 tive relato de pessoas falando em um \u00fanico arquivo de 60Gb sem nenhum problema. Se as buscas s\u00e3o feitas por indice, a complexiadade o O(log(n)), ou seja, mesmo que aumente muito a quantidade de registros a quantidade de passos para encontrar um registro pouco \u00e9 afetada.\r\n\r\nO grande desafio tem sido a quest\u00e3o da concorr\u00eancia de escrita. A gest\u00e3o de lock de disco e de thread tem me tirado o sono, pois \u00e9 bem complexa e ainda n\u00e3o cheguei na solu\u00e7\u00e3o ideal. Estou trabalhando na branch `dev` que, a principio, deve corrigir alguns problemas em rela\u00e7\u00e3o a isso. Em breve deve pedir ajuda ao pessoas para uma bateria de testes maior (o pessoal tem muita criatividade nisso :)\r\n\r\nAbra\u00e7o,"
      }
    ]
  },
  {
    "number": 543,
    "title": "IncludeFields not including ",
    "created_at": "2017-03-21T16:17:39Z",
    "closed_at": "2017-04-07T06:38:01Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/litedb-org/LiteDB/issues/543",
    "body": "If I understand correctly, it should return level one props and fill them?\r\nI have a post with category, but it works only if I put real inlude on collection..\r\n\r\nLitedb 3.1.0\r\nNetcoreapp1.1\r\n```csharp\r\npublic class BEntity\r\n{\r\n\tpublic BEntity()\r\n\t{\r\n\t\tDateCreated = DateTime.Now;\r\n\t}\r\n\tpublic int ID { get; set; }\r\n\tpublic DateTime DateCreated { get; set; }\r\n\tpublic DateTime DateChanged { get; set; }\r\n\tpublic int Count { get; set; } //for paging\t\t\t\t\t\t\t\r\n\r\n}\r\n  public class Post : BEntity\r\n    {\r\n        public string Title { get; set; }\r\n        public string Content { get; set; }\r\n        public List<Category> Categories { get; set; }     \r\n    }\r\npublic class Category: BEntity\r\n{\r\n\tpublic string Name { get; set; }\r\n\tpublic List<Post> Posts { get; set; }\r\n}\r\nvar mapper = new BsonMapper();\r\n\tmapper.IncludeFields = true;\r\n\tmapper.IncludeNonPublic = true;\r\n\tmapper.Entity< Post >().Index(x => x.Title).Index(x => x.Content)\r\n\t.Index(x => x.Slug)\r\n\t.DbRef(x => x.Categories, \"category\")\r\n\t.DbRef(x => x.Comments, \"comment\")\r\n\t.DbRef(x => x.Tags, \"tag\");\r\n\t//dbpost\r\n\tmapper.Entity< Category >()\r\n\t.Index(x => x.Name);\r\n\r\n\tusing (var db = new LiteDatabase(@\"C:\\\\data.db\", mapper))\r\n\t//using (var db = new LiteDatabase(path))\r\n\t{\r\n\t\r\n\t\t//DROP FIRST\r\n\t\t//db.DropCollection(\"post\");\r\n\t\t//db.DropCollection(\"category\");\r\n\t\t//db.DropCollection(\"tag\");\r\n\t\t\t//db.Shrink();\r\n\t\t// Get customer collection\r\n\t\tvar col = db.GetCollection<Post>(\"post\");//.Include(c=>c.Categories).Include(s=>s.Tags); //it works only with include\r\n\t\tvar catcol = db.GetCollection<Category>(\"category\");\r\n\r\n...\r\n```",
    "comments_url": "https://api.github.com/repos/litedb-org/LiteDB/issues/543/comments",
    "author": "Jacknq",
    "comments": [
      {
        "user": "mbdavid",
        "created_at": "2017-03-28T11:47:05Z",
        "body": "Hi @Jack85, includes can be using where you are querying data. In you example you can:\r\n\r\n```\r\nvar col = db.GetCollection<Post>(\"post\");\r\n\r\nvar r = col.Include(x => x.Caetgories).FindAll().ToList();\r\n```\r\n\r\nNow `r` contains all posts and each post contains all categories. But, to this works, you must add categories inside a post before insert. Like this:\r\n\r\n```\r\nvar p = new Post { ... }\r\np.Categories.Add(new Category { Id = 1 });\r\np.Categories.Add(new Category { Id = 2 });\r\ncol.Insert(p);\r\n```"
      },
      {
        "user": "Jacknq",
        "created_at": "2017-03-28T12:25:40Z",
        "body": "yes I know that worked, but that field set \r\n`mapper.IncludeFields = true;`\r\nshould do that includes for me for level 1 all entities that I then call without specific include?"
      },
      {
        "user": "mbdavid",
        "created_at": "2017-03-28T12:28:40Z",
        "body": "By default, only properties from your class are converted to \"BSON document field\". If you se \"IncludeFields\" alse fields from your class will be converted to \"BSON document field\"."
      },
      {
        "user": "Jacknq",
        "created_at": "2017-03-28T12:31:44Z",
        "body": "Ok, so that field is about saving entities, not getting them.. I thought there is a switch that I can simple put true and it includes level1 related data."
      }
    ]
  },
  {
    "number": 528,
    "title": "I have to reference specific dll when I want to read a collection !",
    "created_at": "2017-03-12T14:38:42Z",
    "closed_at": "2017-03-13T01:13:39Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/litedb-org/LiteDB/issues/528",
    "body": "Can i read a collection and ignore the _type  format? in that case, I can read a collection without reference the dll witch the source type of the collection items.",
    "comments_url": "https://api.github.com/repos/litedb-org/LiteDB/issues/528/comments",
    "author": "newbe36524",
    "comments": [
      {
        "user": "mbdavid",
        "created_at": "2017-03-12T17:13:27Z",
        "body": "Yes, you can use `GetCollection(name)` and use `BsonDocument` as your data manipulation."
      },
      {
        "user": "newbe36524",
        "created_at": "2017-03-15T14:43:06Z",
        "body": "and i failed !  how can I deserialize a BsonDocument to a super class which is be in inherit by the collection item.\r\nI insert type A into a collection and I get collection in type B.Type A inherit from type B."
      },
      {
        "user": "mbdavid",
        "created_at": "2017-03-15T14:48:16Z",
        "body": "If you want convert class to/from BsonDocument you always need use `BsonMapper`.\r\n\r\n```\r\nvar m = new BsonMapper();\r\n\r\nvar doc = (your bson document)\r\n\r\nvar obj = m.ToObject<MyClassType>(doc);\r\n```\r\n\r\nIf your document contains `_type` you can just removed from BsonDocument"
      }
    ]
  },
  {
    "number": 523,
    "title": "[Question] FileStore, Transactions and data corruption?",
    "created_at": "2017-03-08T23:30:11Z",
    "closed_at": "2017-03-09T18:38:20Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/litedb-org/LiteDB/issues/523",
    "body": "If I understand correctly:\r\n1. Journal is being written only when commiting a transaction.\r\n2. FileStore does not supports transactions\r\n\r\nDoes it mean that file store writes/deletion might lead to the db file corruption (if interrupted in the worst moment) because of lack of journaling?\r\n\r\nOr is the page-mechanism designed the way these are safe operations? And in the worst case we will end up with some unlinked pages?",
    "comments_url": "https://api.github.com/repos/litedb-org/LiteDB/issues/523/comments",
    "author": "mkosieradzki",
    "comments": [
      {
        "user": "mbdavid",
        "created_at": "2017-03-09T11:09:08Z",
        "body": "Yes, journal writes only when commiting. The steps are:\r\n\r\n1) Write all dirty pages to journal (write original data)\r\n2) Update all dirty pages do datafile\r\n3) Clean journal file\r\n\r\nIf any problem occurs during step 1, next connection will just delete journal file. If any problem occurs during step 2, all journal file will be restored into datafile.\r\n\r\nBut, to do this, I need keep all dirty pages in memory (cache). So, to store files it\u00b4s complicated to store all file in memory, so I split file in chunks. Each chunk are in a transaction (each chunk has 1mb). So, to write new file inside storage, these are the steps:\r\n\r\n1) Write file header descriptor (in _files collection) with Length = 0\r\n2) Slipt file in chunk. Each chunk in a transaction (in _chunk collection)\r\n3) Update header descriptor to Length = final_file_length\r\n\r\nSo, there are, at least, 3 transactions here. If any problem occurs during spliting file, you will get only part (or none) of file in chunks, but your descriptor still in 0 bytes length. You just need delete any file with FileLength = 0.\r\nDatafile will not be corrupted, only this file will be unfinished.\r\n"
      },
      {
        "user": "mkosieradzki",
        "created_at": "2017-03-09T12:20:53Z",
        "body": "@mbdavid Thanks a lot for clarification this is exactly as I hoped it works based on #486 ...\r\n\r\nAFAIK chunks are 255KiB not 1mb :).\r\n\r\nI am currently implementing an alternative API (async-friendly) for file storing based on your low level API.\r\n\r\nBTW. Do you consider rewriting API and locking to be async-friendly inside the LiteEngine in the next version?"
      },
      {
        "user": "mbdavid",
        "created_at": "2017-03-09T14:34:02Z",
        "body": "Hi @mkosieradzki, yes 256 and not 1mb (1mb it\u00b4s max document size).\r\n\r\nNext major version (v4) will be .NET45/NetStandard 2.0 only and will works async too. Thats my goal :)"
      }
    ]
  },
  {
    "number": 518,
    "title": "\"Collection  exceeded the maximum limit of indices: 16\"",
    "created_at": "2017-03-02T20:42:40Z",
    "closed_at": "2017-03-07T10:11:04Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/litedb-org/LiteDB/issues/518",
    "body": "Don\u00b4t know why I get this error message when I try to find documents in my collection, \r\nI try with:\r\n```\r\nvar results = col.Find(Query.StartsWith(\"FullName\", \"Hapa\"));\r\nvar namer = col.Find(a => a.FullName.StartsWith(\"Hapa\"));\r\n```\r\n\r\nwhen I do a col.FindAll or col.Count all data I have saved is there, \r\nmaybe I do something wrong with the index? I tried with col.EnsureIndex(test.FullName); ",
    "comments_url": "https://api.github.com/repos/litedb-org/LiteDB/issues/518/comments",
    "author": "mattiaspalm",
    "comments": [
      {
        "user": "mbdavid",
        "created_at": "2017-03-05T00:18:12Z",
        "body": "Hi, every time you do run Find using different fields you are creating new index in collection. LiteDB limit in 16 indexes per collection. To see all indexes, in shell tool run `db.yourcol.indexes`. You can drop indexes using `db.yourcol.dropIndex fieldname`"
      }
    ]
  },
  {
    "number": 517,
    "title": "Invalid connection string when using shared mode",
    "created_at": "2017-03-02T15:53:42Z",
    "closed_at": "2017-03-11T22:12:37Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/litedb-org/LiteDB/issues/517",
    "body": "Hi, \r\nI am trying to open the database in shared mode. However I am getting this error:\r\n`Unhandled exception: LiteDB.LiteException: Invalid connection string value type for [mode]`  \r\n\r\nThis is how I access the database:  \r\n\r\n```cs\r\nusing (var db = new LiteDatabase(\"Filename=Database.db;Mode=Shared\"))\r\n{\r\n  ...\r\n}\r\n```\r\n\r\nI am using .net core 1.1.",
    "comments_url": "https://api.github.com/repos/litedb-org/LiteDB/issues/517/comments",
    "author": "onurhb",
    "comments": [
      {
        "user": "mbdavid",
        "created_at": "2017-03-02T16:40:59Z",
        "body": "Hi @onurhb, there is not Shared mode in netstandard. NetStandard do not support FileStream.Lock/Unlock methods (at least in v1.6... it\u00b4s on roadmap to v2).\r\nIn NetStandard you must use Exclusive mode only. Try use a single instance only (it\u00b4s support multi-thread)."
      },
      {
        "user": "onurhb",
        "created_at": "2017-03-02T18:17:03Z",
        "body": "Adding it to the dependency injection as singleton works:\r\n`services.AddSingleton<IDatabaseRepository, DatabaseRepository>();`\r\nFor some reason, I was using AddTransient which creates one instance per object. This fixes my problem. Thanks for reply. \r\n"
      },
      {
        "user": "sgrassie",
        "created_at": "2017-09-04T15:02:59Z",
        "body": "Any thoughts on this now that netstandard2.0 has been released?"
      },
      {
        "user": "mbdavid",
        "created_at": "2017-09-04T16:00:38Z",
        "body": "@sgrassie, I'm thinking in update to v4 final release. I will remove 1.3 support to add only 2.0"
      }
    ]
  },
  {
    "number": 508,
    "title": "[Question]Update data without deletion",
    "created_at": "2017-02-26T14:54:15Z",
    "closed_at": "2017-03-11T22:12:21Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/litedb-org/LiteDB/issues/508",
    "body": "Hello, I load my data in chunks, because I don't want to keep entire collection in memory. The problem is that the database stores only the last chunk. I assume this is because whenever I do Update it replaces the collection. How can I insert more data into an existing collection?\r\n\r\nThis is the code I use:\r\n```\r\npublic bool Add(T document)\r\n        {\r\n            using (var db = DbLite.GetDatabase())\r\n            {\r\n                var documents = db.GetCollection(typeof(T).Name);\r\n\r\n                var bsonDoc = db.ToDocument(document);\r\n\r\n                if (documents.FindById(document.Id) != null)\r\n                    return documents.Update(db.ToDocument(document));\r\n                \r\n                documents.Insert(bsonDoc);\r\n            }\r\n\r\n            return true;\r\n        }\r\n```",
    "comments_url": "https://api.github.com/repos/litedb-org/LiteDB/issues/508/comments",
    "author": "fcin",
    "comments": [
      {
        "user": "mbdavid",
        "created_at": "2017-02-26T18:01:16Z",
        "body": "Hi @fcin, try:\r\n\r\n```\r\npublic bool Add(T document)\r\n{\r\n    using (var db = DbLite.GetDatabase())\r\n    {\r\n        return db.GetCollection<T>(typeof(T).Name).Upsert(document);\r\n    }\r\n}\r\n```"
      },
      {
        "user": "fcin",
        "created_at": "2017-02-26T19:33:24Z",
        "body": "Turns out I had 2.0.4 version, that's why I couldn't find Upsert method. Thank you. It certainly helped. \r\n\r\nThe only problem is that now I get NullReferenceException in checking if collection exists in other method This seems to be a very simple code, so I don't think I messed it up, Could you take a look at it?\r\n@mbdavid  I don't really know what could be the cause of it. I tried to follow the stacktrace, but I don't it doesn't look like it's my code's fault.\r\n\r\n```\r\npublic IEnumerable<T> GetAll()\r\n        {\r\n            using (var db = DbLite.GetDatabase())\r\n            {\r\n                if (!db.CollectionExists(typeof (T).Name)) // Throws NullReferenceException\r\n                    return null;\r\n\r\n                var documents = db.GetCollection(typeof(T).Name);\r\n                return documents.FindAll().Select(x => (T)db.Mapper.ToObject(typeof(T), x)).ToList();\r\n            }\r\n        }\r\n```\r\n\r\n```\r\nSystem.NullReferenceException was unhandled by user code\r\n  HResult=-2147467261\r\n  Message=Object reference not set to an instance of an object.\r\n  Source=LiteDB\r\n  StackTrace:\r\n       at LiteDB.StreamExtensions.<>c__DisplayClass4_0.<TryLock>b__0()\r\n       at LiteDB.FileHelper.TryExec(Action action, TimeSpan timeout)\r\n       at LiteDB.StreamExtensions.TryLock(FileStream stream, Int64 position, Int64 length, TimeSpan timeout)\r\n       at LiteDB.FileDiskService.Lock(LockState state, TimeSpan timeout)\r\n       at LiteDB.LockService.LockShared()\r\n       at LiteDB.LockService.Shared()\r\n       at LiteDB.LiteEngine.GetCollectionNames()\r\n       at LiteDB.LiteDatabase.CollectionExists(String name)\r\n       at DrawMe.Core.Repositories.DmRepository`1.GetAll() in F:\\Obrazki\\C#\\DrawMe\\DrawMe\\DrawMe.Core\\Repositories\\DmRepository.cs:line 50\r\n       at DrawMe.Core.Repositories.CachedDmRepository`1.GetAll() in F:\\Obrazki\\C#\\DrawMe\\DrawMe\\DrawMe.Core\\Repositories\\CachedDmRepository.cs:line 62\r\n       at DrawMe.BasicDocumentExplorer.ViewModels.DocumentListExplorerViewModel.Update() in F:\\Obrazki\\C#\\DrawMe\\DrawMe\\DrawMe.BasicDocumentExplorer\\ViewModels\\DocumentListExplorerViewModel.cs:line 49\r\n       at DrawMe.BasicDocumentExplorer.ViewModels.DocumentListExplorerViewModel..ctor(IDmRepository`1 dmRepository, IEventAggregator eventAggregator, ILanguageManager langManager) in F:\\Obrazki\\C#\\DrawMe\\DrawMe\\DrawMe.BasicDocumentExplorer\\ViewModels\\DocumentListExplorerViewModel.cs:line 44\r\n```\r\n  InnerException: \r\n"
      }
    ]
  },
  {
    "number": 504,
    "title": "Question - How to change database password after it's creation",
    "created_at": "2017-02-25T03:33:09Z",
    "closed_at": "2017-03-02T06:12:52Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/litedb-org/LiteDB/issues/504",
    "body": "Greetings @mbdavid,\r\n\r\nit seems that I won't give u peace soon, hehehehe.\r\n\r\nonce again, thank you for liteDB, it's a wonderful tool, it fits perfectly my research project.\r\n\r\nI have a question this time: Is it possible to change the database password after it's creation?\r\n\r\nWhy?\r\n\r\nExample:\r\n\r\nEach user has it's own database. So, the database is created with user password. When user change it's password, I'd like to change the password of the database too.\r\n\r\nIs it possible? If the answer is yes, how?\r\n\r\nThank u.\r\n\r\n[].\r\nRegards,\r\n\r\n@rmszc81",
    "comments_url": "https://api.github.com/repos/litedb-org/LiteDB/issues/504/comments",
    "author": "rmszc81",
    "comments": [
      {
        "user": "falahati",
        "created_at": "2017-02-25T10:58:33Z",
        "body": "After opening the database,\r\n\r\n`database.Engine.Shrink(newPassword);`"
      }
    ]
  },
  {
    "number": 500,
    "title": "DateTime.Kind property is not preserved",
    "created_at": "2017-02-23T03:38:34Z",
    "closed_at": "2017-03-11T22:09:03Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/litedb-org/LiteDB/issues/500",
    "body": "```\r\npublic class Ax {\r\n    [BsonIndex] public DateTime Time { get; set; }\r\n}\r\n\r\nusing (var db = new LiteDatabase(\"temp.db\")) {     \r\n    LiteCollection<Ax> col = db.GetCollection<Ax>(\"Ax\");\r\n    DateTime now = DateTime.UtcNow;\r\n    Console.WriteLine(now.Kind);//\r\n    col.Insert(new Ax {Time = DateTime.UtcNow});\r\n    Console.WriteLine(col.FindOne(x => true).Time.Kind);\r\n}\r\n```\r\n\r\nThis gives output: \r\n`Utc`\r\n`Local`\r\n\r\nWhich is not correct. \r\n\r\nAny thoughts?",
    "comments_url": "https://api.github.com/repos/litedb-org/LiteDB/issues/500/comments",
    "author": "aviadmini",
    "comments": [
      {
        "user": "mbdavid",
        "created_at": "2017-02-24T12:26:32Z",
        "body": "Hi @aviadmini, BSON specs has no information about how date was storage and always convert to UTC.\r\n\r\n```\r\npublic static readonly DateTime UnixEpoch = new DateTime(1970, 1, 1, 0, 0, 0, DateTimeKind.Utc);\r\n\r\n// serialize\r\nvar date = (DateTime)value.RawValue;\r\n// do not convert to UTC min/max date values - #19\r\nvar utc = (date == DateTime.MinValue || date == DateTime.MaxValue) ? date : date.ToUniversalTime();\r\nvar ts = utc - BsonValue.UnixEpoch;\r\nwriter.Write(Convert.ToInt64(ts.TotalMilliseconds));\r\n\r\n// deserialize\r\nvar ts = reader.ReadInt64();\r\n\r\n// catch specific values for MaxValue / MinValue #19\r\nif (ts == 253402300800000) return DateTime.MaxValue;\r\nif (ts == -62135596800000) return DateTime.MinValue;\r\n\r\nreturn BsonValue.UnixEpoch.AddMilliseconds(ts).ToLocalTime();\r\n```\r\n\r\nSo, deserialization always convert to you date to LocalTime to be more common. If you works wih UTC you must use ToUniversalTime()."
      }
    ]
  },
  {
    "number": 474,
    "title": "Query using multikey index (where products are an array of embedded documents)",
    "created_at": "2017-02-10T00:20:53Z",
    "closed_at": "2017-02-11T10:27:57Z",
    "labels": [
      "bug",
      "question",
      "fixed"
    ],
    "url": "https://github.com/litedb-org/LiteDB/issues/474",
    "body": "Hello\r\n\r\nI have an issue with embedded documents. As per below sample I'm able to index and search by embedded documents but Find returns nothing.\r\n\r\n> // Query using multikey index (where products are an array of embedded documents)\r\n> var results = col.Find(Query.GT(\"Products.Price\", 100))\r\n\r\nHere is the complete code to test:\r\n\r\n\r\n        public class Customer\r\n        {\r\n            public class Phone\r\n            {\r\n                public string Number { get; set; }\r\n            }\r\n            public int Id { get; set; }\r\n            public string Name { get; set; }\r\n            public Phone[] Phones { get; set; }\r\n            public bool IsActive { get; set; }\r\n        }\r\n\r\n        static void Main(string[] args)\r\n        {\r\n            // Open database (or create if doesn't exist)\r\n            using (var db = new LiteDatabase(@\"MyData.db\"))\r\n            {\r\n                // Get a collection (or create, if doesn't exist)\r\n                var col = db.GetCollection<Customer>(\"customers\");\r\n\r\n                // Create your new customer instance\r\n                var customer = new Customer\r\n                {\r\n                    Name = \"John Doe\",\r\n                    Phones = new Customer.Phone[] { new Customer.Phone { Number = \"8000-0000\" } , new Customer.Phone { Number = \"9000-0000\" }},\r\n                    IsActive = true\r\n                };\r\n\r\n                // Insert new customer document (Id will be auto-incremented)\r\n                col.Insert(customer);\r\n\r\n                col.EnsureIndex(\"Phones.Number\");\r\n\r\n                var results = col.Find(Query.EQ(\"Phones.Number\", \"8000-0000\")); // returns no documents\r\n            }\r\n        }\r\n",
    "comments_url": "https://api.github.com/repos/litedb-org/LiteDB/issues/474/comments",
    "author": "vlad-k4k",
    "comments": [
      {
        "user": "mbdavid",
        "created_at": "2017-02-10T23:07:07Z",
        "body": "Hi @vlad-k4k, do not use nested classes. I made same example here:\r\n\r\n```\r\nusing System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Text;\r\nusing System.Threading.Tasks;\r\nusing LiteDB;\r\n\r\nnamespace Test474\r\n{\r\n    public class Customer\r\n    {\r\n        public int Id { get; set; }\r\n        public string Name { get; set; }\r\n        public Phone[] Phones { get; set; }\r\n        public bool IsActive { get; set; }\r\n    }\r\n\r\n    public class Phone\r\n    {\r\n        public string Number { get; set; }\r\n    }\r\n\r\n    class Program\r\n    {\r\n        static void Main(string[] args)\r\n        {\r\n            // Open database (or create if doesn't exist)\r\n            using (var db = new LiteDatabase(@\"MyData.db\"))\r\n            {\r\n                // Get a collection (or create, if doesn't exist)\r\n                var col = db.GetCollection<Customer>(\"customers\");\r\n\r\n                // Create your new customer instance\r\n                var customer = new Customer\r\n                {\r\n                    Name = \"John Doe\",\r\n                    Phones = new Phone[] { new Phone { Number = \"8000-0000\" }, new Phone { Number = \"9000-0000\" } },\r\n                    IsActive = true\r\n                };\r\n                \r\n                // Insert new customer document (Id will be auto-incremented)\r\n                col.Insert(customer);\r\n\r\n                var r1 = col.FindOne(Query.EQ(\"Phones.Number\", \"8000-0000\"));\r\n\r\n                Console.WriteLine(r1.Name);\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nBut I found a bug here: when using array [] it's not working Linq expression like\r\n`col.FindOne(x => x.Phones[0].Number == \"8000-000\"`\r\n(works fine with List<T>)\r\n\r\nI'm fixing this, thanks"
      }
    ]
  },
  {
    "number": 460,
    "title": "Question : How can i insert complex entities to db?",
    "created_at": "2017-02-05T23:12:34Z",
    "closed_at": "2017-02-10T23:49:02Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/litedb-org/LiteDB/issues/460",
    "body": "Hi @mbdavid,\r\n\r\nI think, i understand all concepts about document database. Because of that i start to use LiteDB in my project. I implement my simple entities first insert, update etc working fine. But i'm stuck about my complex entities. I produce sample console application which is below. I tried many ways for insert entities to db but i received an exception in every situation. Could you please help me about that problem.\r\n\r\n* Am i missing something? Because every exception from LiteDB is null reference exception and they don't have any inner exception because of that i don't understand what is the problem. Is there a way to catch inner exceptions?\r\n* How can i save my TradingHours entity to db in one step?\r\n* If not possible one step insert how can i save to db simply?\r\n\r\n```\r\nusing System;\r\nusing System.Collections.Generic;\r\nusing System.Globalization;\r\nusing LiteDB;\r\n\r\nnamespace LiteDBTest\r\n{\r\n    public class TradingHours\r\n    {\r\n        public TradingHours()\r\n        {\r\n\r\n        }\r\n\r\n        public TradingHours(string name, TimeZoneInfo timeZoneInfo)\r\n            : this()\r\n        {\r\n            Name = name;\r\n            TimeZoneInfo = timeZoneInfo;\r\n        }\r\n\r\n        public TradingHours(string name, TimeZoneInfo timeZoneInfo, IEnumerable<Session> sessions, IEnumerable<Holiday> holidays)\r\n            : this(name, timeZoneInfo)\r\n        {\r\n            Sessions = sessions;\r\n            Holidays = holidays;\r\n        }\r\n\r\n        public int Id { get; set; }\r\n        public string Name { get; set; }\r\n        public TimeZoneInfo TimeZoneInfo { get; set; }\r\n        public IEnumerable<Session> Sessions { get; set; }\r\n        public IEnumerable<Holiday> Holidays { get; set; }\r\n    }\r\n\r\n    public class Session\r\n    {\r\n        public Session()\r\n        {\r\n\r\n        }\r\n\r\n        public Session(TradingHours tradingHours)\r\n            : this()\r\n        {\r\n            TradingHours = tradingHours;\r\n        }\r\n\r\n        public Session(TradingHours tradingHours, DayOfWeek startDay, TimeSpan startTime, DayOfWeek endDay, TimeSpan endTime, bool endOfDay)\r\n            : this(tradingHours)\r\n        {\r\n            StartDay = startDay;\r\n            StartTime = startTime;\r\n            EndDay = endDay;\r\n            EndTime = endTime;\r\n            EndOfDay = endOfDay;\r\n        }\r\n\r\n        public int Id { get; set; }\r\n        public TradingHours TradingHours { get; set; }\r\n        public DayOfWeek StartDay { get; set; }\r\n        public TimeSpan StartTime { get; set; }\r\n        public DayOfWeek EndDay { get; set; }\r\n        public TimeSpan EndTime { get; set; }\r\n        public bool EndOfDay { get; set; }\r\n    }\r\n\r\n    public class Holiday\r\n    {\r\n        public Holiday()\r\n        {\r\n\r\n        }\r\n\r\n        public Holiday(TradingHours tradingHours)\r\n            : this()\r\n        {\r\n            TradingHours = tradingHours;\r\n        }\r\n\r\n        public Holiday(TradingHours tradingHours, string name, HolidayType type, DateTime date, TimeSpan startTime, TimeSpan endTime)\r\n            : this(tradingHours)\r\n        {\r\n            Name = name;\r\n            Type = type;\r\n            Date = date;\r\n            StartTime = startTime;\r\n            EndTime = endTime;\r\n        }\r\n\r\n        public int Id { get; set; }\r\n        public TradingHours TradingHours { get; set; }\r\n        public string Name { get; set; }\r\n        public HolidayType Type { get; set; }\r\n        public DateTime Date { get; set; }\r\n        public TimeSpan StartTime { get; set; }\r\n        public TimeSpan EndTime { get; set; }\r\n    }\r\n\r\n    public enum HolidayType\r\n    {\r\n        FullDay,\r\n        LateOpen,\r\n        EarlyClose\r\n    }\r\n\r\n    class Program\r\n    {\r\n        static void Main(string[] args)\r\n        {\r\n            BsonMapper.Global.Entity<TradingHours>()\r\n                .Id(e => e.Id)\r\n                .Index(e => e.Name, true)\r\n                .DbRef(e => e.Sessions, \"Sessions\")\r\n                .DbRef(e => e.Holidays, \"Holidays\");\r\n\r\n            BsonMapper.Global.Entity<Session>()\r\n                .Id(e => e.Id)\r\n                .Index(e => e.TradingHours)\r\n                .DbRef(e => e.TradingHours, \"TradingHours\");\r\n\r\n            BsonMapper.Global.Entity<Holiday>()\r\n                .Id(e => e.Id)\r\n                .Index(e => e.TradingHours)\r\n                .DbRef(e => e.TradingHours, \"TradingHours\");\r\n\r\n            BsonMapper.Global.RegisterType(\r\n                (timeSpan) => timeSpan.Ticks,\r\n                (bsonValue) => TimeSpan.FromTicks(bsonValue.AsInt64));\r\n\r\n            BsonMapper.Global.RegisterType(\r\n                (cultureInfo) => cultureInfo.Name,\r\n                (bsonValue) => CultureInfo.GetCultureInfo(bsonValue.AsString));\r\n\r\n            BsonMapper.Global.RegisterType(\r\n                (timeZoneInfo) => timeZoneInfo.Id,\r\n                (bsonValue) => TimeZoneInfo.FindSystemTimeZoneById(bsonValue.AsString));\r\n\r\n            using (var database = new LiteDatabase(AppDomain.CurrentDomain.BaseDirectory + \"Data.db\"))\r\n            {\r\n                var tradingHoursCollection = database.GetCollection<TradingHours>(\"TradingHours\");\r\n                var sessionCollection = database.GetCollection<Session>(\"Sessions\");\r\n                var holidayCollection = database.GetCollection<Holiday>(\"Holidays\");\r\n\r\n                if (tradingHoursCollection.FindOne(tradingHours => tradingHours.Name == \"US Equities Regular\") == null)\r\n                {\r\n                    var tradingHours = new TradingHours(\"US Equities Regular\", TimeZoneInfo.FindSystemTimeZoneById(\"Eastern Standard Time\"));\r\n\r\n                    var sessions = new List<Session>\r\n                    {\r\n                        new Session(tradingHours, DayOfWeek.Monday, new TimeSpan(9, 30, 0), DayOfWeek.Monday, new TimeSpan(16, 0, 0), true),\r\n                        new Session(tradingHours, DayOfWeek.Tuesday, new TimeSpan(9, 30, 0), DayOfWeek.Tuesday, new TimeSpan(16, 0, 0), true),\r\n                        new Session(tradingHours, DayOfWeek.Wednesday, new TimeSpan(9, 30, 0), DayOfWeek.Wednesday, new TimeSpan(16, 0, 0), true),\r\n                        new Session(tradingHours, DayOfWeek.Thursday, new TimeSpan(9, 30, 0), DayOfWeek.Thursday, new TimeSpan(16, 0, 0), true),\r\n                        new Session(tradingHours, DayOfWeek.Friday, new TimeSpan(9, 30, 0), DayOfWeek.Friday, new TimeSpan(16, 0, 0), true)\r\n                    };\r\n\r\n                    var holidays = new List<Holiday>\r\n                    {\r\n                        new Holiday(tradingHours, \"New Year's Day\", HolidayType.FullDay, new DateTime(2016, 1, 1), TimeSpan.Zero, TimeSpan.Zero),\r\n                        new Holiday(tradingHours, \"Martin Luther King, Jr. Day\", HolidayType.FullDay, new DateTime(2016, 1, 18), TimeSpan.Zero, TimeSpan.Zero),\r\n                        new Holiday(tradingHours, \"President's Day\", HolidayType.FullDay, new DateTime(2016, 2, 15), TimeSpan.Zero, TimeSpan.Zero),\r\n                        new Holiday(tradingHours, \"Good Friday\", HolidayType.FullDay, new DateTime(2016, 3, 25), TimeSpan.Zero, TimeSpan.Zero),\r\n                        new Holiday(tradingHours, \"Memorial Day\", HolidayType.FullDay, new DateTime(2016, 5, 30), TimeSpan.Zero, TimeSpan.Zero),\r\n                        new Holiday(tradingHours, \"Independence Day\", HolidayType.FullDay, new DateTime(2016, 7, 4), TimeSpan.Zero, TimeSpan.Zero),\r\n                        new Holiday(tradingHours, \"Labor Day\", HolidayType.FullDay, new DateTime(2016, 9, 5), TimeSpan.Zero, TimeSpan.Zero),\r\n                        new Holiday(tradingHours, \"Thanksgiving\", HolidayType.FullDay, new DateTime(2016, 11, 24), TimeSpan.Zero, TimeSpan.Zero),\r\n                        new Holiday(tradingHours, \"Thanksgiving\", HolidayType.EarlyClose, new DateTime(2016, 11, 25), TimeSpan.Zero, new TimeSpan(13, 0, 0)),\r\n                        new Holiday(tradingHours, \"Christmas Day\", HolidayType.FullDay, new DateTime(2016, 12, 15), TimeSpan.Zero, TimeSpan.Zero)\r\n                    };\r\n\r\n                    using (var transaction = database.BeginTrans())\r\n                    {\r\n                        try\r\n                        {\r\n                            tradingHours.Sessions = new List<Session>(sessions);\r\n                            tradingHours.Holidays = new List<Holiday>(holidays);\r\n                            tradingHoursCollection.Insert(tradingHours);\r\n                            transaction.Commit();\r\n                        }\r\n                        catch (Exception)\r\n                        {\r\n                            transaction.Rollback();\r\n                            throw;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n```",
    "comments_url": "https://api.github.com/repos/litedb-org/LiteDB/issues/460/comments",
    "author": "aytacasan",
    "comments": [
      {
        "user": "mbdavid",
        "created_at": "2017-02-06T00:04:14Z",
        "body": "Hi @aytacasan,\r\n\r\nIf you are using DbRefs you need choose between: 1 ThradingHour has multiple Sessions (and Holidays) or 1 Session/Holliday has 1 ThradingHour- not both.\r\n\r\nTry first insert all your Sessions/Holliday without any relation with ThradingHour. Than, insert your ThradingHour. Like: \r\n\r\n```\r\n// insert many sessions/hollidays\r\nsessionCollection.Insert(tradingHours.Sessions);\r\nholidayCollection.Insert(tradingHours.Holidays);\r\n\r\n// and now insert you treading hour\r\ntradingHoursCollection.Insert(tradingHours);\r\n```\r\n\r\nYou final database will be:\r\n```\r\nSession Collection:\r\n[\r\n    { _id: 1, StartDay: \"Monday\", StartTime: \".....\" .... },\r\n    { _id: 2, StartDay: \"Tuesday\", StartTime: \".....\" .... },\r\n    ...\r\n]\r\n\r\nHolidays Collection:\r\n[\r\n    { _id: 1, Name: \"New Year's Day\", .... },\r\n    { _id: 2, Name: \"Martin Luther King, Jr. Day\", .... },\r\n   ....\r\n]\r\n\r\nThradingHour Collection:\r\n[\r\n    { \r\n        _id: 1,\r\n        Name: \"US Equities Regular\",\r\n        ...\r\n        Sessions: [ { $id: 1, $ref: \"Sessions\" }, { $id: 2, $ref: \"Sessions\" }, { $id: 3, $ref: \"Sessions\" }, ...]\r\n        Holidays: [ { $id: 1, $ref: \"Holidays\" }, { $id: 2, $ref: \"Holidays\" }, { $id: 3, $ref: \"Holidays\" }, ...]\r\n    }\r\n]\r\n"
      },
      {
        "user": "aytacasan",
        "created_at": "2017-02-06T14:13:07Z",
        "body": "Hi @mbdavid,\r\n\r\nI see when i want to use DBRef i have to select one side of relation for use it. In your code you selected to add DBRef to TradingHours. But i need to opposite and change my sample console application according to this. Here is the mappings;\r\n\r\n```\r\n            BsonMapper.Global.Entity<TradingHours>()\r\n                .Id(e => e.Id)\r\n                .Index(e => e.Name, true)\r\n                .Ignore(e => e.Sessions)\r\n                .Ignore(e => e.Holidays);\r\n\r\n            BsonMapper.Global.Entity<Session>()\r\n                .Id(e => e.Id)\r\n                .Index(e => e.TradingHours)\r\n                .DbRef(e => e.TradingHours, \"TradingHours\");\r\n\r\n            BsonMapper.Global.Entity<Holiday>()\r\n                .Id(e => e.Id)\r\n                .Index(e => e.TradingHours)\r\n                .DbRef(e => e.TradingHours, \"TradingHours\");\r\n```\r\n\r\nI can easily inserting all records like below;\r\n\r\n```\r\n                    using (var transaction = database.BeginTrans())\r\n                    {\r\n                        try\r\n                        {\r\n                            tradingHoursCollection.Insert(tradingHours);\r\n                            sessionCollection.Insert(sessions);\r\n                            holidayCollection.Insert(holidays);\r\n                            transaction.Commit();\r\n                        }\r\n                        catch (Exception)\r\n                        {\r\n                            transaction.Rollback();\r\n                            throw;\r\n                        }\r\n                    }\r\n```\r\n\r\nDatabase will be;\r\n\r\n```\r\nThradingHour Collection:\r\n[\r\n    { \r\n        _id: 1,\r\n        Name: \"US Equities Regular\",\r\n        ...\r\n    }\r\n]\r\n\r\nSession Collection:\r\n[\r\n    { _id: 1, TradingHours: { $id: 1, $ref: \"TradingHours\" }, StartDay: \"Monday\", StartTime: \".....\" .... },\r\n    { _id: 2, TradingHours: { $id: 1, $ref: \"TradingHours\" }, StartDay: \"Tuesday\", StartTime: \".....\" .... },\r\n    ...\r\n]\r\n\r\nHolidays Collection:\r\n[\r\n    { _id: 1, TradingHours: { $id: 1, $ref: \"TradingHours\" }, Name: \"New Year's Day\", .... },\r\n    { _id: 2, TradingHours: { $id: 1, $ref: \"TradingHours\" }, Name: \"Martin Luther King, Jr. Day\", .... },\r\n   ....\r\n]\r\n```\r\n\r\nNow i want to read records separately;\r\n\r\n* Because there is no DBRef in TradingHours entity we can not use Include directive so we have to fill Sessions and Holidays lists manually.  I'm using below code and it's working, but is this right way? or can you recommend any other more appropriate way?\r\n\r\n```\r\n                var USERTH = tradingHoursCollection.FindOne(tradingHours => tradingHours.Name == \"US Equities Regular\");\r\n                USERTH.Sessions = new List<Session>(sessionCollection.Find(session => session.TradingHours.Id == USERTH.Id));\r\n                USERTH.Holidays = new List<Holiday>(holidayCollection.Find(session => session.TradingHours.Id == USERTH.Id));\r\n```\r\n\r\n* There is queries and notes below about read Sessions. Do you have something to add?\r\n\r\nWhen we have TradingHours instance, we can not query via TradingHours instance : `sessionCollection.Include(session => session.TradingHours).Find(session => session.TradingHours == USERTH);`\r\nWhen we have TradingHours Name, We can not query via TradingHours.Name despite use of Include directive : `sessionCollection.Include(session => session.TradingHours).Find(session => session.TradingHours.Name == \"US Equities Regular\");`\r\nOnly we can query from Id : `sessionCollection.Include(session => session.TradingHours).Find(session => session.TradingHours.Id == USERTH.Id);`\r\n\r\n* In session entity's map there is `.Index(e => e.TradingHours)` then i'm calling `sessionCollection.EnsureIndex(sc => sc.TradingHours);` actually i expected to create this index before run any query like that: {\"slot\":1,\"field\":\"TradingHours.$id\",\"unique\":false} but i can't. How can i create this index via fluent api? When i try `.Index(e => e.TradingHours.Id)` i'm receiving an error.\r\n\r\nBest Regards"
      },
      {
        "user": "mbdavid",
        "created_at": "2017-02-07T20:28:25Z",
        "body": "For now it's your best way to populate tradingHours with sessions and holidays.\r\n\r\n```\r\n var USERTH = tradingHoursCollection.FindOne(tradingHours => tradingHours.Name == \"US Equities Regular\");\r\nUSERTH.Sessions = new List<Session>(sessionCollection.Find(session => session.TradingHours.Id == USERTH.Id));\r\nUSERTH.Holidays = new List<Holiday>(holidayCollection.Find(session => session.TradingHours.Id == USERTH.Id));\r\n```\r\n\r\nIt's on my plans support custom user Action<T> in includes, so user can add some like this\r\n\r\n```\r\ntradingHoursCollection\r\n    .Include(x => x.Sessions = sessionCollection.Find(z => z.TradingHours.Id == x.Id))\r\n    .FindAll();\r\n```\r\n\r\nYes, you can't query from session information about tradingHours, becase there is not index, in Sessions. If you need query you will need duplicate your tradingHours name information in session.\r\n\r\n- Indexes are created only when run first time. If you need run before, use `EnsureIndex` method after you open your database"
      },
      {
        "user": "aytacasan",
        "created_at": "2017-02-08T02:13:49Z",
        "body": "Hi @mbdavid,\r\n\r\n* I saw your sample code at codeproject and you used user action for include directive like you said. But i think it was supported in some old versions of LiteDB. If you support it again with new versions this will be awesome. Is it necessary to open new issue about that by me or you prefer handle it by yourself?\r\n\r\nAlso there is a issue that you labeled suggestion and add to backlog for version 3.1. Can i labeled it closed or suggestion issues must handle by you?\r\n\r\n* Thanks @mbdavid i know if i'm not use EnsureIndex for force index creation, indexes will be create when first query. Actually i want to learn that in my previous post's sample code, how can i write that code; \"create index for TradingHours.Id\" with fluent api? When i try it '.Index(e => e.TradingHours.Id)' receiving an error. Yes i know if i'm not write anything, when i run query according DBRef property index will be create auto but i just wondered.\r\n\r\nBest Regards"
      }
    ]
  },
  {
    "number": 450,
    "title": "Issue with Collection Insert()",
    "created_at": "2017-02-02T09:22:16Z",
    "closed_at": "2017-02-10T22:27:59Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/litedb-org/LiteDB/issues/450",
    "body": "First of all, let me say well done on releasing v3.0.0. And here is me saying it: Well Done! :)\r\n\r\nThink I may have raised this before, but I have an interface issue with Insert().\r\n\r\nBasically, both the Upsert() and Update() variants returns true on success. While Insert() has no return type and throws instead.\r\n\r\nThis is means that, if I want to have appropriate behaviour in my app (without it throwing out) I either have to wrap the Insert() call in a try catch block, or query whether the document exists before hand.",
    "comments_url": "https://api.github.com/repos/litedb-org/LiteDB/issues/450/comments",
    "author": "kuiperzone",
    "comments": [
      {
        "user": "mbdavid",
        "created_at": "2017-02-04T11:30:22Z",
        "body": "But Upsert returns true if insert and false if update (when using single document). And Update returns true when found and update document and false if not found document.\r\n\r\nIn both cases there is no exceptions. If you compare with relation database is the same: INSERT can throw duplicate key exception but UPDATE only update founded rows, so there is no exception on this.\r\n"
      },
      {
        "user": "mbdavid",
        "created_at": "2017-02-04T16:20:33Z",
        "body": "It's better call Insert and test duplicate exception an than Update.\r\n\r\nor\r\n\r\nUpdate first, if returns false, than Insert.\r\n\r\nIn both cases it's better inside an transaction. You can choose what you beleave that you will have most: Inserts or Updates? "
      }
    ]
  },
  {
    "number": 408,
    "title": "v3.0.0 - beta3 - Question regarding the Fluent Mapper with Index",
    "created_at": "2017-01-01T20:15:28Z",
    "closed_at": "2017-01-01T21:03:06Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/litedb-org/LiteDB/issues/408",
    "body": "I'm quite new to LiteDB and this seems kinda strange to me.\r\n\r\nWhy does the Fluent Mapper throw a `ArgumentNullException` here:\r\n```\r\nBsonMapper.Global.Entity<TesBase>()\r\n\t.Id(x => x.Id)\r\n\t.Index(x => x.Value)\r\n\t.Index(x => x.Embed.Import) // <= Problematic line\r\n\t;\r\n```\r\n\r\nwhile this works perfectly:\r\n```\r\nvar audioLogEntries = db.GetCollection<TesBase>(\"base\");\r\naudioLogEntries.EnsureIndex(x => x.Embed.Import);\r\n```\r\n\r\nUsed classes:\r\n```\r\nclass TesBase\r\n{\r\n\tpublic int Id { get; set; }\r\n\tpublic string Value { get; set; }\r\n\r\n\tpublic TesEmbed Embed { get; set; } = new TesEmbed();\r\n}\r\n\r\nclass TesEmbed\r\n{\r\n\tpublic string Import { get; set; }\r\n}\r\n```",
    "comments_url": "https://api.github.com/repos/litedb-org/LiteDB/issues/408/comments",
    "author": "Splamy",
    "comments": [
      {
        "user": "mbdavid",
        "created_at": "2017-01-01T20:40:13Z",
        "body": "It's happend because you are modeling `TesBase` and not `TesEmbeded`. When you write `x.Embeded.Import` mapper try find `Import` property in `TesBase` and not found.\r\n\r\nIn this case, you must use `EnsureIndex` or do nothing - indexes are auto-created when you run any query. Explicit indexes are useful only when you want create unique index (default index are not unique) or a virtual field, like `.Index(\"myindex\", (item) => item.FuncOverDocumnet());`"
      }
    ]
  },
  {
    "number": 375,
    "title": "Question - Is v3 backward compatible with v2 data?",
    "created_at": "2016-12-11T10:44:45Z",
    "closed_at": "2016-12-15T17:57:12Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/litedb-org/LiteDB/issues/375",
    "body": "Is v3 backward compatible with v2 data?\r\n\r\nIf I use v2 initially, could I upgrade to v3 later and will it read the data files generated by v2 seemlessly? Or would there be a migration proceedure?",
    "comments_url": "https://api.github.com/repos/litedb-org/LiteDB/issues/375/comments",
    "author": "kuiperzone",
    "comments": [
      {
        "user": "mbdavid",
        "created_at": "2016-12-11T11:10:46Z",
        "body": "LiteDB uses a new datafile structure, V7. So, will be not compatible with any older version.\r\n\r\nBut, I wrote some migration. It's possible call `LiteEngine.Upgrade` do convert V6 to V7 datafile or use `upgrade=true` on connection string"
      }
    ]
  },
  {
    "number": 358,
    "title": "Maximum collection size?",
    "created_at": "2016-12-04T05:09:29Z",
    "closed_at": "2016-12-04T15:49:12Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/litedb-org/LiteDB/issues/358",
    "body": "LiteDB looks great, although I'm slightly concerned about the 2GB file size limit in terms of future scalability for my application.\r\n\r\nAm I correct in thinking that the maximum collection size on disk will be limited to 2GB? Are there any long term plans to extend this? Or is it hard limit for the foreseeable future?\r\n\r\nCheers",
    "comments_url": "https://api.github.com/repos/litedb-org/LiteDB/issues/358/comments",
    "author": "kuiperzone",
    "comments": [
      {
        "user": "mbdavid",
        "created_at": "2016-12-04T11:18:08Z",
        "body": "Hi @kuiperzone, 2GB file size limit is \"per file in FileStorage\" not per \"datafile\". Each physical datafile supports UInt.MaxValue * PageSize (4096) =~16 TB"
      }
    ]
  },
  {
    "number": 344,
    "title": "v3 DropCollection?",
    "created_at": "2016-11-21T09:59:59Z",
    "closed_at": "2016-11-21T12:33:13Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/litedb-org/LiteDB/issues/344",
    "body": "Hello,\r\n\r\nhow to drop a collection in v3?\r\n\r\nv2 had LiteDatabase.DropCollection but to me it looks lie that is gone?\r\n\r\nRegards,\r\n  Dirk",
    "comments_url": "https://api.github.com/repos/litedb-org/LiteDB/issues/344/comments",
    "author": "gmwilhelm",
    "comments": [
      {
        "user": "mbdavid",
        "created_at": "2016-11-21T10:53:25Z",
        "body": "I will back thsi method again to LiteDatabase. You can use db.Engine.DropCollection"
      },
      {
        "user": "mbdavid",
        "created_at": "2016-11-21T12:10:47Z",
        "body": "Hi @gmwilhelm, LiteEngine is like \"the server side\" of LiteDB. It\u00b4s responsable with all low layer data access. LiteDatabase use a instance of LiteEngine to access all method plus add all \"mapper\" things: Serialize/Deserialize, Cross References, AutoId, Linq queries and all this things. So, when you use LiteDatase, you are just using LiteEngine with support to POCO classes (LiteEngine works only with BsonDocuments)\r\n\r\nI will add again this operations in LiteDatabase just to be compatible with v2 version, but basicly will call the same method from LiteEngine. LiteEngine is not new, exists in v2 but aren't public to user. Now, in v3, if you want works only with LiteEngine it\u00b4s possible.\r\n\r\nI will try explain better in new wiki update."
      }
    ]
  },
  {
    "number": 329,
    "title": "Help wanted about searching a substring in an array of strings",
    "created_at": "2016-10-31T09:53:13Z",
    "closed_at": "2016-10-31T15:50:56Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/litedb-org/LiteDB/issues/329",
    "body": "Hi,\r\n\r\nI could not find any answer to this. Let's say we have this data structure:\r\n```\r\npublic class Data\r\n{\r\n  public Data() { }\r\n\r\n  [DataMember(Name = \"Id\")]\r\n  public string Id { get; set; }\r\n\r\n  [DataMember(Name = \"Comments\")]\r\n  public List<string> Comments { get; set; }\r\n}\r\n```\r\n\r\nWhen I want to find a substring in `Id`, I do:\r\n```\r\nvar collection = database.GetCollection<Data>(\"myCollection\");\r\nvar results = collection.Find(Query.Contains(\"_id\", \"my substring\"));\r\n```\r\n\r\nBut I cannot do the same in `Comments`. The following request returns nothing:\r\n```\r\nvar collection = database.GetCollection<Data>(\"myCollection\");\r\nvar results = collection.Find(Query.Contains(\"Comments\", \"my substring\"));\r\n```\r\n\r\nHow to search inside an array of strings?",
    "comments_url": "https://api.github.com/repos/litedb-org/LiteDB/issues/329/comments",
    "author": "real-felix",
    "comments": [
      {
        "user": "mbdavid",
        "created_at": "2016-10-31T11:47:14Z",
        "body": "Hi @Boiethios, in current v2 there is not index in arrays (named Multi Key Index). So, to this query works you need full collection scan: some like this:\n\n```\ncollection.FindAll().Where(x => x.Comments.Any(z => z.Contains(\"substring\"));\n```\n\nIn v3 (`dev` branch under dev) multi key index was implemented. So, you can do full index scan (not best solution, but much better than full scan solution).\n\n```\ncollection.Find(Query.Contains(\"Comments\", \"substring\"));\n// there is no Linq expression support yet\n```\n\nBut, if you will have lots of documents that you need do this kind of search, I recommend to use \"full text search\". It's a special king of index used for this situations. LiteDB doest implement yet (I try once in `fts` branch, but did do sequence). You can take a look on Lucene.NET, a super index library.\n"
      }
    ]
  },
  {
    "number": 308,
    "title": ".ToString() in  Lambda Query for Collection.Find()",
    "created_at": "2016-09-23T17:55:59Z",
    "closed_at": "2016-09-24T12:47:45Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/litedb-org/LiteDB/issues/308",
    "body": "I have a collection items when i query using a lambda expression with a .ToString() it cause an exception. For example:\n`var y = items.Find(x => x.Year.ToString() == \"1993\");   // Year is int`\nThe exception is : **\"Property 'Year.ToString(' was not mapped into BsonDocument\"**\n",
    "comments_url": "https://api.github.com/repos/litedb-org/LiteDB/issues/308/comments",
    "author": "MoamenMohamed",
    "comments": [
      {
        "user": "mbdavid",
        "created_at": "2016-09-24T12:31:27Z",
        "body": "Hi @MoamenMohamed, there is not index functions supports. If you want create an index based on a function returns, create a field like this:\n\n```\npublic string YearString { get { return this.Year.ToString(); } }\n```\n\nAnd than use as `items.Find(x => x.YearString == \"1993\")`\n"
      },
      {
        "user": "mbdavid",
        "created_at": "2016-09-24T12:39:26Z",
        "body": "Just to know, next version will support virtual function field in BsonMapper, some like this:\n\n`db.Entity<Customer>().Index(\"year-fn\", (b) => b.Year.ToString());`\n\nSo, you query will be: `items.Find(\"year-fn\", \"1993\")`\n"
      }
    ]
  },
  {
    "number": 271,
    "title": "query with order",
    "created_at": "2016-08-12T14:44:24Z",
    "closed_at": "2016-08-22T21:57:20Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/litedb-org/LiteDB/issues/271",
    "body": "Hey, the documentation is really good but after having read it all I still wonder how to query  collections in a specific order efficiently. \nLimiting a query mostly only makes sense if you can specify the order. For instance I want to limit my query to get the first 100 docs or the last hundred of a collection according to a query. I can currently apply .OrderByDescending(x=>x.Id) on a query result but this would not be executed by the query engine, right?\n",
    "comments_url": "https://api.github.com/repos/litedb-org/LiteDB/issues/271/comments",
    "author": "henon",
    "comments": [
      {
        "user": "mbdavid",
        "created_at": "2016-08-12T14:51:21Z",
        "body": "When you query in a collection using an index, you are using an order (index order). So, this is used to limit/skip.\n\nLiteDB implements `skip list` indexes. So you query `Query.EQ(\"Age\", 12)` database will search using Age index, that are in order asc (or desc, if you want).\n"
      },
      {
        "user": "henon",
        "created_at": "2016-08-12T15:01:03Z",
        "body": "How do I configure the index order i.e. to Descending ?\n"
      },
      {
        "user": "mbdavid",
        "created_at": "2016-08-12T15:52:00Z",
        "body": "Query with Desc order only when all rows are selected:\n\n`Query.All(Query.Descending)` (desc by _id index)\n`Query.All(\"Name\", Query.Descending)` (desc by Name index)\n\nAll others cases are not supported (or even has no sense, like Equals)\n"
      },
      {
        "user": "henon",
        "created_at": "2016-08-12T19:26:00Z",
        "body": "Cool. Since this was not intuitive to me, I allowed myself to extend the docu on page Queries with the following example. Correct me if I am wrong.\n\n// find top 100 oldest persons aged between 20 and 30\nvar results = collection.Find(Query.And(Query.All(\"Age\", Query.Descending), Query.Between(\"Age\", 20, 30)), limit:100);\n"
      },
      {
        "user": "mbdavid",
        "created_at": "2016-08-22T21:57:18Z",
        "body": "Hi @henon, sorry for a long delay. This way not works. If you wants this order, you must OrderBy using linq.\n\n`collection.Find(Query.Between(\"Age\", 20, 30)).OrderBy(x => x.Age).Take(10);`\n\nThe \"hard\" query part are executed using index (finding all 20-30 yo). Linq will order and limit to 10.\n"
      },
      {
        "user": "henon",
        "created_at": "2016-08-25T04:55:06Z",
        "body": "sorry to open this up again, but I did try this out before I posted, so I am curious why you say it does not work. was I lucky and got the correct result? what is wrong with the way I built the query? I just want to understand.\n"
      },
      {
        "user": "mbdavid",
        "created_at": "2016-08-26T13:11:42Z",
        "body": "Hi @henon, you right. Your code is correct. Query.And use Except Linq operation. So, when you findAll using Age index, your NodeIndex returns in Age desc order.\n"
      }
    ]
  },
  {
    "number": 270,
    "title": "Why string end with \"\\r\\n\" be trimmed?",
    "created_at": "2016-08-12T05:23:48Z",
    "closed_at": "2016-08-12T14:01:17Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/litedb-org/LiteDB/issues/270",
    "body": "I found this in a project.For 2 days, I can't find the problem.\nThe test code:\n\n```\np = new Person\n{\n    Name = \"\u5f20\u7acb\",\n    Age = 31,\n    Sex = 1,\n    Description = \"\u4e00\u4e2a\u8f6f\u4ef6\u5de5\u7a0b\u5e08\\r\\n\"\n};\n\nConsole.WriteLine(\"name:{0}\", p.Name);\nConsole.WriteLine(\"age:{0}\", p.Age);\nConsole.WriteLine(\"sex:{0}\", p.Sex);\nConsole.WriteLine(\"description:{0}\", p.Description);\n\nusing (var conn = new LiteDB.LiteDatabase(\"test3.db\"))\n{\n    var col = conn.GetCollection<Person>(\"p3\");\n    col.Insert(p);\n}\n\nusing (var conn = new LiteDB.LiteDatabase(\"test3.db\"))\n{\n    var col = conn.GetCollection<Person>(\"p3\");\n    var ps = col.FindAll();\n    foreach(var p1 in ps)\n    {\n        Console.WriteLine(\"name:{0}\", p1.Name);\n        Console.WriteLine(\"age:{0}\", p1.Age);\n        Console.WriteLine(\"sex:{0}\", p1.Sex);\n        Console.WriteLine(\"description:{0}\", p1.Description);\n    }\n}\n\nConsole.WriteLine(\"------------------------------------\");\n```\n",
    "comments_url": "https://api.github.com/repos/litedb-org/LiteDB/issues/270/comments",
    "author": "lidanger",
    "comments": [
      {
        "user": "mbdavid",
        "created_at": "2016-08-12T13:19:53Z",
        "body": "Hi @lidanger, It\u00b4s a default in BsonMapper. Try:\n\n`BsonMapper.Global.TrimWhitespace = false;`\n"
      }
    ]
  },
  {
    "number": 228,
    "title": "Exception : Invalid transaction on top of stack",
    "created_at": "2016-07-27T10:10:00Z",
    "closed_at": "2016-08-04T12:41:46Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/litedb-org/LiteDB/issues/228",
    "body": "Hello,\n\nI just started using your DB. Seems it is exactly what I was looking, simple, NoSQL.\nI tried to use LiteDB in a windows service  with multiple threads accessing the DB.\nThe service is something similar to a job scheduler, and tasks are stored in the DB.\n\nAt the very beginning of the app when DB access (read or write) are done, I get the following exception :\n\n```\n\nType : System.ArgumentException, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089\n        Message : Invalid transaction on top of stack\n        Source : LiteDB\n        HelpLink :\n        Data : None\n        Additional Infos :\n            ParamName : null\n\n        StackTrace :\n             at LiteDB.TransactionService.popTopTransaction(LiteTransaction trans)\n             at LiteDB.TransactionService.Complete(LiteTransaction trans)\n             at LiteDB.LiteTransaction.Commit()\n             at LiteDB.LiteTransaction.Dispose()\n             at LiteDB.DbEngine.<Find>d__9.System.IDisposable.Dispose()\n             at LiteDB.DbEngine.<Find>d__9.MoveNext()\n             at LiteDB.LiteCollection`1.<Find>d__34.MoveNext()\n             at System.Linq.Buffer`1..ctor(IEnumerable`1 source)\n             at System.Linq.OrderedEnumerable`1.<GetEnumerator>d__1.MoveNext()\n             at System.Linq.Enumerable.FirstOrDefault[TSource](IEnumerable`1 source)\n             at xxxxxxxxxxxxxxxxx\n```\n\nIs the LiteDatabase thread-safe ? Because I'm sharing the LiteDatabase instance on all threads.\nShould I do differently ?\n\nThanks for your help.\n\nLuc\n",
    "comments_url": "https://api.github.com/repos/litedb-org/LiteDB/issues/228/comments",
    "author": "ldubrois",
    "comments": [
      {
        "user": "mbdavid",
        "created_at": "2016-07-27T11:33:26Z",
        "body": "Hi @ldubrois, no, it's not thread-safe. Reusing same LiteDatabase instance in different threads/tasks causes invalid states. Try use one instance per thread (LiteDB support multiple concurrency instances).\n"
      },
      {
        "user": "mbdavid",
        "created_at": "2016-07-27T13:00:56Z",
        "body": "It\u00b4s not heavy. LiteDatabase instance is just a simple layer of `DbEngine` class. Havy operation is initialize `BsonMapper`, so it\u00b4s importat to keep this in a single instance (by default, using BsonMapper.Global is single static instance).\n\nIf you have lots of read operation, you need lock them too. In this case, use multiple instances of LiteDatabase is better way. This current version keeps datafile always closed and open only when need execute an disk operation.\n\nI had a old version with lock in all operations. But had some bugs and I gave up. Maybe for `2.1` release I try add this again.\n"
      }
    ]
  },
  {
    "number": 224,
    "title": "Query with EndsWith",
    "created_at": "2016-07-26T17:43:28Z",
    "closed_at": "2016-08-02T11:30:59Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/litedb-org/LiteDB/issues/224",
    "body": "Hi\nIt is not possible to run a query with \"EndsWith\"\n\n```\nvar tmp = reg.Find(x => x.Name.EndsWith(\"P\"));\ntmp.ForEach(x => Console.WriteLine(x.Name));\n```\n",
    "comments_url": "https://api.github.com/repos/litedb-org/LiteDB/issues/224/comments",
    "author": "bencz",
    "comments": [
      {
        "user": "mbdavid",
        "created_at": "2016-07-26T17:47:17Z",
        "body": "Hi @bencz, because there is not index that catch EndsWith (I think in no one database). So, when you don't have an index (using in Find(predicate)) you need use a non-indexed query:\n\n`var tmp = reg.FindAll().Where(x => x.Name.EndsWith(\"P\"));`\n"
      },
      {
        "user": "bencz",
        "created_at": "2016-07-27T14:32:01Z",
        "body": "Hi @mbdavid, thanks!\nuse the findall, if I have a 'table' with a lot of documents.... it's not a good idea...\nI can do something different... just save the last chars of field name, and create a index in this field and query based in this field...\n"
      },
      {
        "user": "mbdavid",
        "created_at": "2016-07-27T14:34:26Z",
        "body": "Yes, you can create a get only property with ends of name, index this property and quering using indexed query. \n"
      }
    ]
  },
  {
    "number": 91,
    "title": "OnVersionUpdate called before Mapper Initialized from ctor",
    "created_at": "2015-12-23T08:29:22Z",
    "closed_at": "2016-01-02T06:03:29Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/litedb-org/LiteDB/issues/91",
    "body": "When Using OnVersionUpdate we need to register custom type one more time.\nOnVersionUpdate is called from base(connectionString), before myDb ctor.\nIt's not that easy to solve...\nI don't mind calling UpdateDatabaseVersion() manually or override a method where I can init the mapper only once.\n\n``` C#\npublic myDb(string connectionString) : base(connectionString)\n{\n//Called Second\n    Mapper.RegisterType(TimeSpanToBson, BsonToTimeSpan);\n}\n protected override void OnVersionUpdate(int newVersion)\n    {\n// Called First\n        Mapper.RegisterType(TimeSpanToBson, BsonToTimeSpan);\n        switch (newVersion)\n        {\n            case 1:\n            [...]\n        }\n    }\n```\n",
    "comments_url": "https://api.github.com/repos/litedb-org/LiteDB/issues/91/comments",
    "author": "kgallerin",
    "comments": [
      {
        "user": "mbdavid",
        "created_at": "2015-12-23T14:55:08Z",
        "body": "Hi @techrising, are you using lastest version? In v2 use `OnModelCreating` override method to register custom mappings. Get lastest version from `master` branch.\n"
      }
    ]
  },
  {
    "number": 51,
    "title": "Implement OnUpdate or OnCommit triggers",
    "created_at": "2015-08-19T04:48:30Z",
    "closed_at": "2015-08-19T12:51:59Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/litedb-org/LiteDB/issues/51",
    "body": "Hi,\nI wrote an application that can send updates from editor to client. i want implement an db check organism in the client that check db last modify date before install it. can i use db file modified date for this kind of work?\nor How can I use global update trigger in the editor for each change like these:\n\n```\npublic class AppData : LiteDatabase {\n    public AppData()\n        : base(DataStore.ConnectionString) { }\n\n        protected override void Commit() {\n            var cl = this.GetCollection<DbInfo>(\"db\");\n            var dbi = cl.FindById(0);\n            dbi.ModifiedOn = DateTime.UtcNow;\n            cl.Update(area);\n            base.Commit()\n        }\n    }\n```\n\nEnglish isn\u2019t my first language, so please excuse any mistakes.\n",
    "comments_url": "https://api.github.com/repos/litedb-org/LiteDB/issues/51/comments",
    "author": "nildarar",
    "comments": [
      {
        "user": "nildarar",
        "created_at": "2015-08-19T12:43:54Z",
        "body": "I found some properties in `db.GetDatabaseInfo()` useful for this kind of work.\n\n```\nchangeID\nfileLength\nlastPageID\n```\n"
      },
      {
        "user": "mbdavid",
        "created_at": "2015-08-19T12:44:50Z",
        "body": "Hi @nildarar,\n\nI don\u00b4t think that override `Commit` method is a good ideia. Internal, this method just call `transaction.Commit()`, so this will works only with explicit `Commit` call (not implicit).\n\nYou ca use Last file modified date because only open and run queries didn\u00b4t change data file.\n"
      },
      {
        "user": "mbdavid",
        "created_at": "2015-08-19T12:46:46Z",
        "body": "Yes, you can use `GetDatabaseInfo()` too, but here has no DateTime to know when was last modified.\n\n`changeID` is a counter that increment after each commit\n`fileLenth` and `lastPageID` is total size/last page used - it\u00b4s not indicate if has any changes.\n"
      }
    ]
  },
  {
    "number": 48,
    "title": "Huge Memory & CPU Usage",
    "created_at": "2015-08-13T12:26:10Z",
    "closed_at": "2015-08-22T13:40:45Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/litedb-org/LiteDB/issues/48",
    "body": "Hello,\n\nI compared three versions of a test application. I saved a lot (10^7) objects of a type with three properties of type double.\nThe first version was coded with saving to a file with json serialization (Newtonsoft Json). The second was with litedb. The third with simply saving to a txt-File (File.WriteAllLines).\n\nCode LiteDB:\n\n```\n// Open database (or create if not exits)\nusing(var db = new LiteDatabase(@\".\\LiteDB.db\"))\n{\n    // Get customer collection\n    var col = db.GetCollection<Node>(\"nodes\");\n    col.Insert(nodes);\n}\n```\n\nThe results are:\n\n| Version | Memory Usage | Disk Space Usage | Time Needed [ms] |\n| --- | --- | --- | --- |\n| Newtonsoft Json | ~500MB | 673MB | 68,630ms |\n| LiteDB | ~6 675MB | 3 476MB | 497,464ms |\n| Text File | ~500MB | 950MB | 38,913ms |\n\nIs there a faster way of saving bigger datas?\n",
    "comments_url": "https://api.github.com/repos/litedb-org/LiteDB/issues/48/comments",
    "author": "KeKl",
    "comments": [
      {
        "user": "mbdavid",
        "created_at": "2015-08-13T23:32:27Z",
        "body": "Hi @KeKl, thanks for your comment.\n\nPerformance and memory use drops in LiteDB when you are working with huge mass of data. This reason is because LiteDB implement a full transaction and journal backup save. Transactions are memory only (thats why use too many memory) and journal write in disk twice.\n\nTo works fast with huge data in LiteDB, try to use:\n\n``` C#\nusing(var db = new LiteDatabase(@\"filename=.\\LiteDB.db; journal=false\"))\n{\n    var col = db.GetCollection<Node>(\"nodes\");\n    col.InsertBulk(nodes);\n}\n```\n- `nodes` var must returns and `IEnumerable<Node>` and will be better if uses `yield return`\n\nThis code must run fast, but never as Newtonsoft or Text File. LiteDB implements indexes (at least _id index), data in pages, and has a much more complex data structure.\n\nI have some plans to remove some features (like transactions and journals) in prior be simple, less memory usage and faster.\n"
      }
    ]
  },
  {
    "number": 37,
    "title": "how can i order in db ",
    "created_at": "2015-05-25T16:38:22Z",
    "closed_at": "2015-07-26T23:00:18Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/litedb-org/LiteDB/issues/37",
    "body": "Hi : Mauricio \nthanks for your project first .\ni have a doubt that why there is no order in Find\n\n```\nIEnumerable<T> Find(Query query, int skip = 0, int limit = int.MaxValue)\n```\n\nfor example , i want take latest 100 docs , i have a field \"AddedTime\"\n the normal way is  order by AddedTime desc  then skip 0 and  take(limit) 100 ,that's what  i needed .\nbut without order ,the take is no sence .\n\nwhat should i do ?\n",
    "comments_url": "https://api.github.com/repos/litedb-org/LiteDB/issues/37/comments",
    "author": "JsonSong89",
    "comments": [
      {
        "user": "mbdavid",
        "created_at": "2015-05-25T16:43:59Z",
        "body": "Hi @178220709,\n\nIf you want take your lasted 100 docs using indexes, you can:\n\n1) Create an index on `AddedTime`\n2) Run `collection.Find(Query.All(\"AddedTime\", Query.Descending), 0, 100);\n\nNow you will list all yor documents in `AddedTime` desc order and get only 100 first.\n"
      },
      {
        "user": "JsonSong89",
        "created_at": "2015-05-26T07:16:23Z",
        "body": "Hi:  Mauricio \nthanks for you reply. \n\nthis is a little strange that order and query together\nand there is a overload \n\n```\nIEnumerable<T> Find(Expression<Func<T, bool>> predicate, int skip = 0, int limit = int.MaxValue)\n```\n\ncan i do my above example by this function?\nlooks like if i need order in db, i can't use linq ?\n\nhow about this function \n\n```\nIEnumerable<TEntity> Find(Expression<Func<TEntity, bool>> predicate, Dictionary<string,int> orderKeys, int skip = 0, int limit = int.MaxValue)\n```\n\nand we use \n\n```\nvar orderKeys = new Dictionary<string, int>()\n            {\n                {\"AddedTime\", Query.Descending},\n                {\"OtherFiled\", Query.Ascending}\n            };\n```\n\nto control the order \n"
      },
      {
        "user": "mbdavid",
        "created_at": "2015-05-26T19:26:35Z",
        "body": "Hi @178220709,\n\nThanks for your idea, but LiteDB doesn\u00b4t have order operations (like a relation database). LiteDB has only indexed fields that can be used to Find results in ASC or DESC order (use a skip-list index structure). The only way to get a sorted data (using an index) is when you get operation like `All`, `>\u00b4, \u00b4<\u00b4 so I start searching data from begin to end (ASC) or end to begin (DESC). But it\u00b4s not the same of sort your document results.\n\nAnd why LiteDB has no internal order operations? Because .NET has implemented this operations in linq-to-object. `Find` method returns an `IEnumerable<T>` so you can run any local (non-indexed) linq operation in results only (like Order/GroupBy/Distinct).\n\n`col.Find(x => x.FirstName == \"John\").OrderBy(x => x.LastName)`\n"
      },
      {
        "user": "JsonSong89",
        "created_at": "2015-05-28T05:25:59Z",
        "body": "oh! \ni guess i know the means of LiteDB.\nbecause this is the local db , the cost of  data transport is less than other service dbms .\nafter the filter , as much as possible,we should use linq to object in memory?\neven ,we use Query.All immediaty , and do every operation in memory(when data is not very large)?\n"
      },
      {
        "user": "mbdavid",
        "created_at": "2015-05-28T16:36:21Z",
        "body": "You right, local db has no network and all operations must be executed in local machine.\n\nThe only optimization that can be do it is filter. So, `Find` operation use indexed document field. This is valid optimation. When you use `Query.All` and than implement a `Where` linq, it\u00b4s more expensive because you need read all data pages and deserialize all documento only to know if match with your clause.\n\nSo, my recomendation is: always use `Find` (when possible) and then use normal `Linq` implementation.\n"
      }
    ]
  }
]