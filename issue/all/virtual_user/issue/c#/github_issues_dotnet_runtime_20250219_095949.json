[
  {
    "number": 99559,
    "title": "[System.Reflection.Emit] AssemblyBuilderAccess.RunAndCollect not collecting assemblies",
    "created_at": "2024-03-11T19:45:12Z",
    "closed_at": "2024-03-11T22:20:54Z",
    "labels": [
      "question",
      "area-AssemblyLoader-coreclr"
    ],
    "url": "https://github.com/dotnet/runtime/issues/99559",
    "body": "### Description\r\n\r\nSo I've been playing around with `AssemblyBuilderAccess.RunAndCollect`, but it turns out it's not working and has the same behavior as `Run`.\r\nAccording to the docs:\r\n```\r\nThe dynamic assembly will be automatically unloaded and its memory reclaimed,\r\nwhen it's no longer accessible.\r\n```\r\n\r\nEven after fully unreferencing everything related to my dynamic assembly, it will not unload, even after a forced GC collection.\r\nI have fully tested this, using the code in the section below.\r\n\r\n### Reproduction Steps\r\n\r\nI tested this with the following script:\r\n```cs\r\nint id = 0;\r\nfor (; ; )\r\n{\r\n    GC.Collect();\r\n\r\n    var name = $\"Test{id++}\";\r\n    var asm = AssemblyBuilder.DefineDynamicAssembly(new(name), AssemblyBuilderAccess.RunAndCollect);\r\n    var mod = asm.DefineDynamicModule(name);\r\n\r\n    var type1 = mod.DefineType(\"TestClass\", TypeAttributes.Public);\r\n    var met = type1.DefineMethod(\"Foo\", MethodAttributes.Public | MethodAttributes.Static);\r\n    var il = met.GetILGenerator();\r\n    il.EmitWriteLine(\"Hello World!\");\r\n    il.Emit(OpCodes.Ret);\r\n    var t = type1.CreateType();\r\n\r\n    t.InvokeMember(\"Foo\", BindingFlags.Static | BindingFlags.Public | BindingFlags.InvokeMethod, null, null, null);\r\n\r\n    Console.WriteLine(\"----\");\r\n\r\n    foreach (var ass in AppDomain.CurrentDomain.GetAssemblies())\r\n    {\r\n        if (!ass.GetName().Name?.StartsWith(\"Test\") ?? true)\r\n            continue;\r\n\r\n        Console.WriteLine(ass.FullName);\r\n    }\r\n\r\n    Thread.Sleep(100);\r\n    Console.Clear();\r\n}\r\n```\r\n\r\n### Expected behavior\r\n\r\nAfter a `GC.Collect`, the AppDomain should not contain the previously loaded dynamic assembly, and the console output should only contain the latest dyanmic assembly.\r\n\r\nExpected console output after 6th iteration:\r\n```\r\nHello World!\r\n----\r\nTest5, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null\r\n```\r\n\r\n### Actual behavior\r\n\r\nThe AppDomain still contains the old dynamic assemblies, even after a forced collection, as seen in the console output.\r\n\r\nActual console output after 6th iteration:\r\n```\r\nHello World!\r\n----\r\nTest0, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null\r\nTest1, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null\r\nTest2, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null\r\nTest3, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null\r\nTest4, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null\r\nTest5, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null\r\n```\r\n\r\n### Regression?\r\n\r\nI have tested the same code in net48 and net472, but the results are the same.\r\n\r\n### Known Workarounds\r\n\r\n_No response_\r\n\r\n### Configuration\r\n\r\nnet8.0\r\nWindows 11\r\nx64\r\nI don't believe the issue is related to these configs.\r\n\r\n### Other information\r\n\r\n_No response_",
    "comments_url": "https://api.github.com/repos/dotnet/runtime/issues/99559/comments",
    "author": "slxdy",
    "comments": [
      {
        "user": "slxdy",
        "created_at": "2024-03-11T20:08:49Z",
        "body": "Ok, I have done some extra research, and it turns out that `GetAssemblies` prevents collectible assemblies from being unloaded in the future.\r\nFrom what I've read, that should only happen when using `Assembly.Load`. I don't think `GetAssemblies` should replicate this behavior, considering that we should have the ability to check for loaded assemblies, collectible or not, without forcing collectible assemblies to stay alive forever.\r\nIs it worth opening another issue for this problem?"
      },
      {
        "user": "reflectronic",
        "created_at": "2024-03-11T20:22:14Z",
        "body": "The issue does not reproduce for me after extracting the `foreach` to a separate method:\r\n```cs\r\n// ...\r\n    Console.WriteLine(\"----\");\r\n\r\n    PrintAssemblies();\r\n\r\n    Thread.Sleep(100);\r\n    Console.Clear();\r\n}\r\n\r\n\r\nstatic void PrintAssemblies()\r\n{\r\n    foreach (var ass in AppDomain.CurrentDomain.GetAssemblies())\r\n    {\r\n        if (!ass.GetName().Name?.StartsWith(\"Test\") ?? true)\r\n            continue;\r\n\r\n        Console.WriteLine(ass.FullName);\r\n    }\r\n}\r\n``` \r\n\r\nThen I get output like this:\r\n```\r\nHello World!\r\n----\r\nTest33, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null\r\nTest34, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null\r\n```"
      },
      {
        "user": "jkotas",
        "created_at": "2024-03-11T21:49:46Z",
        "body": "Yes, `GetAssemblies()` returns the array of with all assemblies, the JIT may extend the lifetime of the array till end of the method (depends on many factors)."
      }
    ]
  },
  {
    "number": 90925,
    "title": "[Question] Ref reassignment",
    "created_at": "2023-08-22T14:48:16Z",
    "closed_at": "2023-08-22T14:58:36Z",
    "labels": [
      "question",
      "needs-area-label"
    ],
    "url": "https://github.com/dotnet/runtime/issues/90925",
    "body": "Below is the simple repro which is quite self-explanatory. The question is - why upon exit from `fn` our char reference `c` is not changed to '**b**' char?\r\n```csharp\r\nusing System;\r\nusing System.Runtime.CompilerServices;\r\nusing System.Runtime.InteropServices;\r\n\r\nstatic void fn(ref char c)\r\n{\r\n    c = ref Unsafe.Add(ref c, 1);\r\n\t// now we have c = 'b'\r\n}\r\n\r\nvar input = \"abc\";\r\nref var c = ref MemoryMarshal.GetReference(input.AsSpan());\r\n\r\nfn(ref c);\r\n// but on exit we still have c = 'a'\r\nConsole.WriteLine(c);\r\n```",
    "comments_url": "https://api.github.com/repos/dotnet/runtime/issues/90925/comments",
    "author": "hypeartist",
    "comments": [
      {
        "user": "jkotas",
        "created_at": "2023-08-22T14:58:36Z",
        "body": "> why upon exit from fn our char reference c is not changed to 'b' char?\r\n\r\n`c = ref Unsafe.Add(ref c, 1);` reassigns where `c` points to. It does not change the value that `c` points to. It is how `ref` works in C#.\r\n\r\nYou would need to omit the `ref` to make it do what you are trying to.\r\n\r\nNote that string objects are expected to be immutable. It is not legal to modify their content. It breaks the runtime invariants that can lead to a lot of surprising behaviors."
      }
    ]
  },
  {
    "number": 46661,
    "title": "Question about memory barriers in .NET",
    "created_at": "2021-01-07T01:06:26Z",
    "closed_at": "2021-01-22T16:55:25Z",
    "labels": [
      "question",
      "area-System.Threading",
      "untriaged"
    ],
    "url": "https://github.com/dotnet/runtime/issues/46661",
    "body": "In .NET, there are some APIs that explicitly mention the use of memory barriers in their implementation (`Volatile`, `Interlocked`, `Thread.MemoryBarrier`, etc.). But then there are other APIs (such as `ThreadPool.QueueUserWorkItem`, `Task.Run`, and `Threading.Timer`) where it's generally assumed that there is an implicit memory barrier, but the API doesn't explicitly state this. For example:\r\n\r\n```c#\r\nprivate int _i;\r\n\r\npublic void Method()\r\n{\r\n    _i = 1;\r\n    var timer = new Timer(_ => Console.WriteLine(_i), null, 0, -1); //Guaranteed to print 1?\r\n}\r\n```\r\n\r\nMore generally, is there somehow a way to tell which APIs guarantee a memory barrier and which don't? I have a hard time blindly _trusting_ without strong API guarantees to fall back on, especially knowing that implementations are allowed change over time.",
    "comments_url": "https://api.github.com/repos/dotnet/runtime/issues/46661/comments",
    "author": "WizardBrony",
    "comments": [
      {
        "user": "stephentoub",
        "created_at": "2021-01-07T14:37:09Z",
        "body": "In order to successfully achieve the defined purpose of the API, any method (Timer's ctor, ThreadPool.QueueUserWorkItem, Task.Run, etc.) which queues work necessarily incurs the appropriate barriers to ensure that the queued work can read any state set by the thread doing the queueing prior to the queueing.  How it achieves that is an implementation detail, but that it achieves it is just necessary for the method to be functionally correct.\r\n\r\n> //Guaranteed to print 1?\r\n\r\nYes (unless some other code changes _i to something else before the callback actually runs)."
      },
      {
        "user": "WizardBrony",
        "created_at": "2021-01-07T15:12:16Z",
        "body": "@stephentoub Okay, I can accept that. Does this rationale also apply to all concurrent APIs? For example:\r\n\r\n```c#\r\nprivate class C\r\n{\r\n    public int I;\r\n}\r\n\r\nprivate readonly ConcurrentDictionary<int, C> _dictionary = new ConcurrentDictionary<int, C>();\r\n\r\npublic void Thread1()\r\n{\r\n    var c = new C();\r\n    c.I = 1;\r\n\r\n    // No memory barrier\r\n\r\n    _dictionary.TryAdd(0, c);\r\n}\r\n\r\npublic void Thread2()\r\n{\r\n    if (_dictionary.TryGetValue(0, out var c))\r\n        Console.WriteLine(c.I); // Guaranteed to print 1?\r\n}\r\n```"
      },
      {
        "user": "stephentoub",
        "created_at": "2021-01-07T16:33:18Z",
        "body": "> Does this rationale also apply to all concurrent APIs?\r\n\r\nYes"
      },
      {
        "user": "WizardBrony",
        "created_at": "2021-01-22T16:43:43Z",
        "body": "@stephentoub I'm really sorry to bring this up again, but if you could calm my paranoia about one other API I'd really appreciate it. Is `CancellationTokenSource.Cancel` guaranteed to incur a barrier such that all state changes are visible prior to the request for cancellation?"
      },
      {
        "user": "stephentoub",
        "created_at": "2021-01-22T16:55:25Z",
        "body": "> Is CancellationTokenSource.Cancel guaranteed to incur a barrier such that all state changes are visible prior to the request for cancellation?\r\n\r\nYes."
      }
    ]
  },
  {
    "number": 41568,
    "title": "[Question] Static readonly fields and branch optimization",
    "created_at": "2020-08-30T17:03:50Z",
    "closed_at": "2020-08-31T01:20:25Z",
    "labels": [
      "question",
      "area-CodeGen-coreclr",
      "untriaged"
    ],
    "url": "https://github.com/dotnet/runtime/issues/41568",
    "body": "Does JIT optimize `if` and `switch` statements based on value of **static readonly** field? I understand that value will be available only at runtime, but once the type is loaded and cctor called then the static fields remain unchanged. In this case, constant propagation can be applied and dead branches can be removed.\r\n",
    "comments_url": "https://api.github.com/repos/dotnet/runtime/issues/41568/comments",
    "author": "sakno",
    "comments": [
      {
        "user": "EgorBo",
        "created_at": "2020-08-30T17:16:16Z",
        "body": "@sakno yes it does, e.g.:\r\n```csharp\r\nclass Program\r\n{\r\n    static readonly int Field = 42;\r\n\r\n    static void Main()\r\n    {\r\n        for (int i = 0; i < 50; i++)\r\n        {\r\n            Test(); // promote (re-compile) Test to tier1 (from tier0) after 30th(?) iteration,\r\n                    // Program class is expected to be already\r\n                    // statically inited at that point\r\n            Thread.Sleep(10);\r\n        }\r\n\r\n        Console.ReadKey();\r\n    }\r\n\r\n    [MethodImpl(MethodImplOptions.NoInlining)]\r\n    static void Test()\r\n    {\r\n        if (Field == 43)\r\n            throw new ArgumentException();\r\n    }\r\n}\r\n```\r\nCodegen for `Test`:\r\n```asm\r\nG_M24707_IG01:\r\n                                                ;; bbWeight=1    PerfScore 0.00\r\nG_M24707_IG02:\r\n       C3                   ret\r\n                                                ;; bbWeight=1    PerfScore 1.00\r\n\r\n; Total bytes of code 1, prolog size 0, PerfScore 1.10, (MethodHash=009c9f7c) for method Program:Test()\r\n; ============================================================\r\n```\r\nUnfortunately it's not possible to see this effect on sharplab.io."
      },
      {
        "user": "sakno",
        "created_at": "2020-08-30T17:36:12Z",
        "body": "@EgorBo , thanks for clarification! Just a few additional questions:\r\n1. Does JIT eliminate the field from the memory associated with the class itself?\r\n1. What if declaring type is a generic class instantiated several times with a reference type as a generic argument? AFAIK, only value types used as generic argument force JIT to produce several specializations."
      },
      {
        "user": "RamType0",
        "created_at": "2020-08-30T19:43:51Z",
        "body": "Many thinkable optimization for field is disabled because of we could access it through reflection.\r\nWe could rewrite readonly fields by reflection.\r\nObviously,it is evil for almost any scenario,but I think it is useful for deserialization.\r\n\r\nIn contrast,optimization for function locals are very aggressive."
      },
      {
        "user": "jkotas",
        "created_at": "2020-08-31T01:19:28Z",
        "body": "> Does JIT eliminate the field from the memory associated with the class itself?\r\n\r\nIt does not. Note that the memory footprint of data structures that represent fields is a typically lot more than the memory footprint of the static field itself. Removing the field from the memory would not move the needle in the total memory consumption.\r\n\r\n> What if declaring type is a generic class instantiated several times with a reference type\r\n\r\nThis JIT optimization does not kick in this case."
      }
    ]
  },
  {
    "number": 39689,
    "title": "[Might be Roslyn] Jit produces different ASM results when working with pointer[index] syntax opposed to star syntax",
    "created_at": "2020-07-21T08:11:28Z",
    "closed_at": "2020-07-21T11:43:45Z",
    "labels": [
      "question",
      "area-CodeGen-coreclr"
    ],
    "url": "https://github.com/dotnet/runtime/issues/39689",
    "body": "Well, this might be a Roslyn issue as such code actually produces different IL\r\nSo a code like this:\r\n```\r\nprivate static int Test(int* ptr, int width)\r\n{\r\n   return ptr[width + 1];\r\n}\r\n\r\nprivate static int Test2(int* ptr, int width)\r\n{\r\n   return *(ptr + width + 1);\r\n}\r\n\r\nGet worse when you add more code like this.\r\n\r\n```\r\nproduces different asm:\r\nI got this ASM using @EgorBo 's Disasmo\r\n\r\nThis is Test:\r\n```\r\nG_M56480_IG01:\r\n\t\t\t\t\t\t;; bbWeight=1    PerfScore 0.00\r\nG_M56480_IG02:\r\n       inc      edx\r\n       movsxd   rax, edx\r\n       mov      eax, dword ptr [rcx+4*rax]\r\n\t\t\t\t\t\t;; bbWeight=1    PerfScore 2.50\r\nG_M56480_IG03:\r\n       ret\r\n```\r\n\r\nand this is Test2:\r\n```\r\nG_M8850_IG01:\r\n\t\t\t\t\t\t;; bbWeight=1    PerfScore 0.00\r\nG_M8850_IG02:\r\n       movsxd   rax, edx\r\n       mov      eax, dword ptr [rcx+4*rax+4]\r\n\t\t\t\t\t\t;; bbWeight=1    PerfScore 2.25\r\nG_M8850_IG03:\r\n       ret\r\n```\r\n\r\nNote redundant inc and movsxd instructions\r\n\r\nAs I said before, this might be a Roslyn bug as IL code produces is different:\r\n\r\nThis is Test:\r\n```\r\nIL_0000: ldarg.0      // ptr\r\nIL_0001: ldarg.1      // width\r\n\r\n// this part is different\r\nIL_0002: ldc.i4.1 // (width + 1) * 4\r\nIL_0003: add\r\nIL_0004: conv.i\r\nIL_0005: ldc.i4.4\r\nIL_0006: mul\r\n\r\nIL_0007: add\r\nIL_0008: ldind.i4\r\nIL_0009: ret\r\n```\r\n \r\nAnd this is Test2:\r\n```\r\nTest2\r\nIL_0000: ldarg.0      // ptr\r\nIL_0001: ldarg.1      // width\r\n\r\n// this part is different\r\nIL_0002: conv.i // (width * 4 + 4)\r\nIL_0003: ldc.i4.4\r\nIL_0004: mul\r\nIL_0005: add\r\nIL_0006: ldc.i4.4\r\n\r\nIL_0007: add\r\nIL_0008: ldind.i4\r\nIL_0009: ret\r\n```\r\n\r\nSeen on .Net Core 3.1, .Net 5\r\nArch x64\r\n\r\nSlightly bigger case: \r\n```\r\n private static int Test(int* ptr, int width)\r\n{\r\n    return ptr[width + 1] + ptr[width + 2] + ptr[width + 3];\r\n}\r\n\r\n private static int Test2(int* ptr, int width)\r\n{\r\n    return *(ptr + width + 1) + *(ptr + width + 2) + *(ptr + width + 3);\r\n}\r\n```\r\n\r\nTest:\r\n```\r\nG_M56480_IG01:\r\n\t\t\t\t\t\t;; bbWeight=1    PerfScore 0.00\r\nG_M56480_IG02:\r\n       lea      eax, [rdx+1]\r\n       movsxd   rax, eax\r\n       mov      eax, dword ptr [rcx+4*rax]\r\n       lea      r8d, [rdx+2]\r\n       movsxd   r8, r8d\r\n       add      eax, dword ptr [rcx+4*r8]\r\n       add      edx, 3\r\n       movsxd   rdx, edx\r\n       add      eax, dword ptr [rcx+4*rdx]\r\n\t\t\t\t\t\t;; bbWeight=1    PerfScore 8.00\r\nG_M56480_IG03:\r\n       ret  \r\n```\r\n\r\nTest2:\r\n```\r\nG_M8850_IG01:\r\n\t\t\t\t\t\t;; bbWeight=1    PerfScore 0.00\r\nG_M8850_IG02:\r\n       movsxd   rax, edx\r\n       mov      edx, dword ptr [rcx+4*rax+4]\r\n       add      edx, dword ptr [rcx+4*rax+8]\r\n       add      edx, dword ptr [rcx+4*rax+12]\r\n       mov      eax, edx\r\n\t\t\t\t\t\t;; bbWeight=1    PerfScore 6.50\r\nG_M8850_IG03:\r\n       ret\r\n```",
    "comments_url": "https://api.github.com/repos/dotnet/runtime/issues/39689/comments",
    "author": "En3Tho",
    "comments": [
      {
        "user": "jkotas",
        "created_at": "2020-07-21T11:43:45Z",
        "body": "The two versions of your methods are not equivalent. They will have different behavior when `width` is `Int32.MaxValue`. In this case, `width + 1` will overflow in Test1 and so you will end up with `*ptr`, `ptr + width + 1` won't overflow in the second case and so you will end up with the expected `ptr + 2147483648`. It explains the different code you are seeing for the two versions."
      },
      {
        "user": "jkotas",
        "created_at": "2020-07-21T13:44:37Z",
        "body": "Yes, this is the expected behavior per C# language spec. You may consider using nint (new in C# 9). It should not have this problem."
      },
      {
        "user": "jkotas",
        "created_at": "2020-07-21T13:45:12Z",
        "body": "e.g.:\r\n```\r\nprivate static int Test(int* ptr, nint width)\r\n{\r\n   return ptr[width + 1];\r\n}\r\n```"
      }
    ]
  },
  {
    "number": 39627,
    "title": "GetFromJsonAsync(HttpClient, String, Type, CancellationToken) Losing Track of its Type",
    "created_at": "2020-07-20T12:46:04Z",
    "closed_at": "2020-07-21T22:31:43Z",
    "labels": [
      "question",
      "area-System.Net.Http"
    ],
    "url": "https://github.com/dotnet/runtime/issues/39627",
    "body": "Using GetFromJsonAsync(HttpClient, String, Type, CancellationToken) via Blazor hosted WebAssembly (Version 16.7.0 Preview 4.0 and WebAssembly v5.0.0-preview.6.20312.15.\r\n\r\nI don't want to use the `GetFromJsonAsync<TValue>(HttpClient, String, CancellationToken)` because I specifically don't want to make any explicit casts. The following only works successfully with the explicit cast, it won't return the result from the Json call without it.\r\n\r\nThis should work, since it knows it's a `List<Means>` type via the DataType parameter but does not:\r\n`Items = ((List<TableEntity>)await Server.GetFromJsonAsync(GetAPIs, DataType));`\r\n\r\nThis does, but the need for explicit casting takes away the power of the non TValue version of the function:\r\n\r\n`Items = ((List<Means>)await Server.GetFromJsonAsync(GetAPIs, DataType)).Cast<TableEntity>().ToList();`\r\n\r\nNote: GetAPIs a string with the correct path to the API on the controller. DataType is set as `typeof(List<Means>)` and Items is `List<TableEntity>`.\r\n\r\nPerhaps I'm missing something, but I expect the source code may have a bug.\r\n\r\nThank you in advance - EP\r\n",
    "comments_url": "https://api.github.com/repos/dotnet/runtime/issues/39627/comments",
    "author": "ericpincus",
    "comments": [
      {
        "user": "scalablecory",
        "created_at": "2020-07-21T15:26:32Z",
        "body": "The behavior you're seeing is that you can't cast a `List` of one type as a `List` of another type. This is happening outside of `GetFromJsonAsync`.\r\n\r\nAs an example of what you're seeing, this will fail for the same reason:\r\n```c#\r\nList<Means> listA = new List<Means>();\r\nList<TableEntity> listB = listA;\r\n```\r\n\r\nCalling `.Cast<TableEntity>.ToList()` is one correct solution, if you do need a `List`. Another, if you don't need to modify the list, is to use the covariant `IEnumerable` instead of `List`:\r\n\r\n```c#\r\nItems = ((IEnumerable<TableEntity>)await Server.GetFromJsonAsync(GetAPIs, DataType));\r\n```"
      }
    ]
  },
  {
    "number": 34097,
    "title": "System.InvalidOperationException: StandardIn has not been redirected",
    "created_at": "2020-03-25T22:51:00Z",
    "closed_at": "2020-03-30T15:36:42Z",
    "labels": [
      "question",
      "area-System.Diagnostics.Process"
    ],
    "url": "https://github.com/dotnet/runtime/issues/34097",
    "body": "I got the following exception from time to time in my application whereas the standard input is  redirected.\r\n\r\n````\r\nException has occurred: CLR/System.InvalidOperationException\r\nAn exception of type 'System.InvalidOperationException' occurred in System.Diagnostics.Process.dll but was not handled in user code: 'StandardIn has not been redirected.'\r\n   at System.Diagnostics.Process.get_StandardInput()\r\n   at repro_process.Program.ExecuteProcessAsync(ProcessStartInfo psi) in /home/meziantou/repro-process/Program.cs:line 72\r\n   at repro_process.Program.<>c.<Main>b__0_0(Int32 i) in /home/meziantou/repro-process/Program.cs:line 27\r\n   at System.Threading.Tasks.Parallel.<>c__DisplayClass19_0`1.<ForWorker>b__1(RangeWorker& currentWorker, Int32 timeout, Boolean& replicationDelegateYieldedBeforeCompletion)\r\n````\r\n\r\nI tried to make a small repro of the code I have in production. Note that it doesn't always throw the exception. You may need to run the code 10 times to get the exception.\r\n\r\nA similar exception sometimes occurs on `process.BeginErrorReadLine()` or `process.BeginOutputReadLine()` with a similar message indicating the the standard output/error is not redirected.\r\n\r\n````c#\r\nusing System;\r\nusing System.Diagnostics;\r\nusing System.Threading.Tasks;\r\n\r\nnamespace repro_process\r\n{\r\n    class Program\r\n    {\r\n        static void Main()\r\n        {\r\n            // In the actual code, multiple unit tests (xUnit) run in parallel so I tried to reproduce this behavior by using Parallel.For\r\n            Parallel.For(0, 10000, i =>\r\n            {\r\n                var psi = new ProcessStartInfo\r\n                {\r\n                    FileName = \"git\",\r\n                    ArgumentList =\r\n                    {\r\n                        \"config\",\r\n                        \"--global\",\r\n                        \"test.a\",\r\n                        \"abc\" + i,\r\n                    },\r\n                    RedirectStandardError = true,\r\n                    RedirectStandardInput = true,\r\n                    RedirectStandardOutput = true,\r\n                };\r\n                ExecuteProcessAsync(psi).Wait(); // In the actual code, there is no wait/Result, only await\r\n                Console.WriteLine(i);\r\n            });\r\n        }\r\n\r\n        private static Task<bool> ExecuteProcessAsync(ProcessStartInfo psi)\r\n        {\r\n            var process = new System.Diagnostics.Process\r\n            {\r\n                StartInfo = psi,\r\n                EnableRaisingEvents = true,\r\n            };\r\n\r\n            var tcs = new TaskCompletionSource<bool>(TaskCreationOptions.RunContinuationsAsynchronously);\r\n            process.Exited += (sender, e) =>\r\n            {\r\n                try\r\n                {\r\n                    process.WaitForExit();\r\n                    process.Dispose();\r\n                    tcs.TrySetResult(true);\r\n                }\r\n                catch (Exception ex)\r\n                {\r\n                    tcs.SetException(ex);\r\n                }\r\n            };\r\n\r\n            process.Start();\r\n\r\n            if (psi.RedirectStandardOutput)\r\n            {\r\n                process.OutputDataReceived += (s, e) => { Console.WriteLine(e.Data); };\r\n                process.BeginOutputReadLine();\r\n            }\r\n\r\n            if (psi.RedirectStandardError)\r\n            {\r\n                process.ErrorDataReceived += (s, e) => { Console.WriteLine(e.Data); };\r\n                process.BeginErrorReadLine();\r\n            }\r\n\r\n            if (psi.RedirectStandardInput)\r\n            {\r\n                process.StandardInput.Close();\r\n            }\r\n\r\n            return tcs.Task;\r\n        }\r\n    }\r\n}\r\n````\r\n\r\n**Environment:**\r\n- .NET Core 3.1.3 but I also get the exception on 3.1.0 and 3.1.2\r\n\r\n````\r\n$> lsb_release -a\r\nNo LSB modules are available.\r\nDistributor ID: Ubuntu\r\nDescription:    Ubuntu 18.04.2 LTS\r\nRelease:        18.04\r\nCodename:       bionic\r\n\r\n$> uname -a\r\nLinux DESKTOP-TV4IPEK 4.4.0-19041-Microsoft #1-Microsoft Fri Dec 06 14:06:00 PST 2019 x86_64 x86_64 x86_64 GNU/Linux\r\n\r\n$> lscpu\r\nArchitecture:        x86_64\r\nCPU op-mode(s):      32-bit, 64-bit\r\nByte Order:          Little Endian\r\nCPU(s):              4\r\nOn-line CPU(s) list: 0-3\r\nThread(s) per core:  1\r\nCore(s) per socket:  4\r\nSocket(s):           1\r\nVendor ID:           GenuineIntel\r\nCPU family:          6\r\nModel:               94\r\nModel name:          Intel(R) Core(TM) i5-6600 CPU @ 3.30GHz\r\nStepping:            3\r\nCPU MHz:             3301.000\r\nCPU max MHz:         3301.0000\r\nBogoMIPS:            6602.00\r\nHypervisor vendor:   Windows Subsystem for Linux\r\nVirtualization type: container\r\nFlags:               fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush dts acpi mmx fxsr sse sse2 ss ht tm pbe syscall nx pdpe1gb rdtscp lm pni pclmulqdq dtes64 est tm2 ssse3 fma cx16 xtpr pdcm pcid sse4_1 sse4_2 movbe popcnt aes xsave osxsave avx f16c rdrand hypervisor lahf_lm abm 3dnowprefetch fsgsbase tsc_adjust bmi1 hle avx2 smep bmi2 erms invpcid rtm rdseed adx smap clflushopt ibrs ibpb stibp ssbd\r\n````\r\n\r\nEdit: I've just got the issue on Windows too (.NET Core 3.1.2).",
    "comments_url": "https://api.github.com/repos/dotnet/runtime/issues/34097/comments",
    "author": "meziantou",
    "comments": [
      {
        "user": "stephentoub",
        "created_at": "2020-03-30T01:16:15Z",
        "body": "This looks like a bug in your repro. Your `process.Exited` event handler is calling `process.Dispose`.  That can race with your subsequent call to `process.StandardInput.Close()`.  If the process exits and the `process.Dispose` is invoked before you access `process.StandardInput`, the call to `StandardInput` will throw, by design."
      },
      {
        "user": "meziantou",
        "created_at": "2020-03-30T15:36:42Z",
        "body": "You are right! That's explain why it occurs very rarely. I've seen the new method `WaitForExitAsync` in the repository. I'll take inspiration from it to fix my code :)"
      },
      {
        "user": "pakrym",
        "created_at": "2020-11-12T21:25:17Z",
        "body": "Wonder if it's worth throwing an `ObjectDisposedException` instead to make this situation more discoverable."
      },
      {
        "user": "stephentoub",
        "created_at": "2020-11-24T05:34:54Z",
        "body": "> Wonder if it's worth throwing an ObjectDisposedException instead to make this situation more discoverable.\r\n\r\nSeems reasonable to consider.\r\ncc: @adamsitnik @eiriktsarpalis"
      }
    ]
  },
  {
    "number": 2385,
    "title": " WebRequest.DefaultWebProxy Return null exeption",
    "created_at": "2020-01-30T13:40:09Z",
    "closed_at": "2020-01-30T14:34:20Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/runtime/issues/2385",
    "body": "Hello,\r\n\r\nI have migrated my project .NET FrameWork to .NET Core, and i have a null exeption when i used \r\nWebRequest.DefaultWebProxy.GetType().GetProperty(\"WebProxy\", BindingFlags.NonPublic | BindingFlags.Instance);\r\n\r\n\r\n\r\nCordially",
    "comments_url": "https://api.github.com/repos/dotnet/runtime/issues/2385/comments",
    "author": "HASSEN-MEDDEB-ATOS",
    "comments": [
      {
        "user": "stephentoub",
        "created_at": "2020-01-30T13:46:54Z",
        "body": "> WebRequest.DefaultWebProxy.GetType().GetProperty(\"WebProxy\", BindingFlags.NonPublic | BindingFlags.Instance);\r\n\r\nThis is trying to use private implementation details. They're private for a reason, and are in no way guaranteed to work the same from version to version."
      },
      {
        "user": "stephentoub",
        "created_at": "2020-01-30T14:03:55Z",
        "body": "> i readed in some other disccsussion that i should delete WebRequest.DefaultWebProxy; beacause it's not supported\r\n\r\nWebRequest.DefaultWebProxy should work fine.  Did you try it and it doesn't work?  If so, what version of .NET Core are you using?"
      },
      {
        "user": "HASSEN-MEDDEB-ATOS",
        "created_at": "2020-01-30T14:07:50Z",
        "body": "I used .Net Core 3.1, WebRequest.DefaultWebProxy.GetType().GetProperty(\"WebProxy\", BindingFlags.NonPublic | BindingFlags.Instance); at this line, it return NullExeption"
      },
      {
        "user": "stephentoub",
        "created_at": "2020-01-30T14:08:42Z",
        "body": "Why are you doing \".GetType().GetProperty(\"WebProxy\", BindingFlags.NonPublic | BindingFlags.Instance)\"?  That's the bad part.  Don't do that ;)"
      },
      {
        "user": "HASSEN-MEDDEB-ATOS",
        "created_at": "2020-01-30T14:13:36Z",
        "body": "This will force the DefaultWebProxy to use default credentials\r\n wProxy.Credentials = System.Net.CredentialCache.DefaultNetworkCredentials;\r\n"
      },
      {
        "user": "stephentoub",
        "created_at": "2020-01-30T14:23:05Z",
        "body": "You can do that with just WebRequest.DefaultWebProxy.  It is the IWebProxy.  You don't need to try to use its private members, which is what that NonPublic reflection code is trying to do.\r\n```C#\r\nWebRequest.DefaultWebProxy.Credentials = CredentialCache.DefaultNetworkCredentials;\r\n```"
      }
    ]
  },
  {
    "number": 1191,
    "title": "How to disable using HTTP_PROXY as default",
    "created_at": "2019-12-27T16:05:19Z",
    "closed_at": "2019-12-28T16:07:11Z",
    "labels": [
      "question",
      "area-System.Net.Http"
    ],
    "url": "https://github.com/dotnet/runtime/issues/1191",
    "body": "#36553\r\n\r\nHow can we turn off this new default implementation?\r\n\r\nI have environment variables HTTP_PROXY. But I want to use system-level proxy default instead of environment variables. I don't want to delete the environment variables because it used by other applications. How can I set to go for system proxy?",
    "comments_url": "https://api.github.com/repos/dotnet/runtime/issues/1191/comments",
    "author": "dhmuralikrishna",
    "comments": [
      {
        "user": "scalablecory",
        "created_at": "2019-12-27T16:19:58Z",
        "body": "You'll need to remove the envvars, either prior to launching the app or in your app itself prior to using HttpClient:\r\n\r\n```c#\r\nEnvironment.SetEnvironmentVariable(\"HTTP_PROXY\", null);\r\nEnvironment.SetEnvironmentVariable(\"HTTPS_PROXY\", null);\r\nEnvironment.SetEnvironmentVariable(\"ALL_PROXY\", null);\r\nEnvironment.SetEnvironmentVariable(\"NO_PROXY\", null);\r\n```"
      }
    ]
  },
  {
    "number": 31419,
    "title": "about method Write(byte[] buffer, int offset, int count)   the  class of memoryStream ",
    "created_at": "2019-11-07T08:26:40Z",
    "closed_at": "2020-02-01T05:24:09Z",
    "labels": [
      "question",
      "area-System.IO"
    ],
    "url": "https://github.com/dotnet/runtime/issues/31419",
    "body": "if ((count <= 8) && (buffer != _buffer))\r\n            {\r\n                int byteCount = count;\r\n                while (--byteCount >= 0)\r\n                {\r\n                    _buffer[_position + byteCount] = buffer[offset + byteCount];\r\n                }\r\n            }\r\n            else\r\n            {\r\n                Buffer.BlockCopy(buffer, offset, _buffer, _position, count);\r\n            }\r\n\r\n\r\nwhy does the  count of buffer more than 8 and Less than or equal to 8 use different copy method",
    "comments_url": "https://api.github.com/repos/dotnet/runtime/issues/31419/comments",
    "author": "changhengyu",
    "comments": [
      {
        "user": "Gnbrkm41",
        "created_at": "2019-11-07T08:50:52Z",
        "body": "`Buffer.BlockCopy` is implemented with a private method called `Memmove` which either calls a native `memmove` function, probably written in assembly for maximum performance, or for smaller sizes, use tricks like unrolling and moving bytes in blocks to move the data more efficiently. The number 8 there probably is something that was figured out to be faster with a simple loop, because the Memmove method involves a few checks which probably isn't worth it for small data.\r\n\r\n(tl;dr: performance optimisations)"
      }
    ]
  },
  {
    "number": 30894,
    "title": "Q: TaskStatus.Canceled for non-matching OperationCanceledException",
    "created_at": "2019-09-18T21:10:55Z",
    "closed_at": "2020-02-01T04:29:52Z",
    "labels": [
      "question",
      "area-System.Threading.Tasks"
    ],
    "url": "https://github.com/dotnet/runtime/issues/30894",
    "body": "When I run:\r\n```cs\r\n        static void Main(string[] args)\r\n        {\r\n            Task fooTask = Foo();\r\n            System.Console.WriteLine(fooTask.Status);\r\n            Task tokenTask = Task.Run(() => throw new OperationCanceledException(), new CancellationTokenSource().Token);\r\n            tokenTask.ContinueWith(t => System.Console.WriteLine(t.Status)).Wait();\r\n        }\r\n\r\n        static async Task Foo()\r\n        {\r\n            throw new OperationCanceledException();\r\n        }\r\n```\r\nit outputs:\r\n```\r\nCanceled\r\nCanceled\r\n```\r\nI expected the Tasks to be in the `Faulted` state because the `OperationCanceledException` isn't associated with the Task token.\r\n\r\nWhy are these Tasks `Canceled`?",
    "comments_url": "https://api.github.com/repos/dotnet/runtime/issues/30894/comments",
    "author": "tmds",
    "comments": [
      {
        "user": "stephentoub",
        "created_at": "2019-09-19T12:55:44Z",
        "body": "This is by design.\r\n\r\nFor all `async` methods, `OperationCanceledException` is special-cased to complete the returned `Task` as `Canceled` rather than `Faulted`.  It pays zero attention to cancellation tokens, because the C# language / compiler for `async` methods has zero knowledge of cancellation tokens.  As such, rather than having all exceptions (even if for cancellation) be `Faulted`, we chose to special-case all `OperationCanceledExceptions`.\r\n\r\nThe `Task.Run` case is just an extension of that.  There are multiple `Task.Run` overloads that differ only by delegate return type, and since your lambda always throws and doesn't have any return statements that would indicate which delegate type to map to and thus which overload to map to, the C# betterness rules are selecting the `Func<Task>` overload.  That overload (as well as the `Func<Task<TResult>>` overload) are primarily intended to be used with `async` methods, as they \"unwrap\" the returned task in order to marshal it to the task returned from the `Run` call.  In order to not have a subtle difference in behavior based on whether the delegate synchronously or asynchronously throws an `OperationCanceledException`, this overload similarly treats all `OperationCanceledException`s as cancellation."
      }
    ]
  },
  {
    "number": 30439,
    "title": "Crypto: Is it safe to pool X509Chain objects without resetting the X509ChainPolicy?",
    "created_at": "2019-07-31T19:55:52Z",
    "closed_at": "2020-02-01T03:42:08Z",
    "labels": [
      "question",
      "area-System.Security"
    ],
    "url": "https://github.com/dotnet/runtime/issues/30439",
    "body": "I\u2019m building a high-throughput message broker in .net core (2.1 today, upgrading to 3.0-preview7 soon), and need to do client certificate based authentication with a custom cert chain (that I set up on the chain.ChainPolicy.ExtraStore).\r\n\r\nTo reduce GC pressure, I tend to pool all the byte arrays / batch message arrays / etc.\r\n\r\nIs it a good idea to also pool X509Chain objects? And not do a chain.Policy.Reset call on every rent/return?\r\n\r\nIt\u2019s the X509ChainPolicy.ExtraStore allocation and 5x X509ChainPolicy.ExtraStore.Add(customCert) calls that lead to array resizing, that I want to avoid.\r\n\r\n-\tWhen the chain is returned to the pool, I dispose off all the chainElement.Certificate objects and do a chain.Reset() to dispose off the _pal object.\r\n-\tI am explicitly resetting chain.ChainPolicy.VerificationTime to DateTime.Now after every pool.Rent().\r\n\r\nIn other words - Does the X509ChainPolicy ever end up holding on to any valid / invalid state from an old call to chain.Build()?\r\n\r\nI couldn\u2019t find anything in the source code that says the Policy leads to any cross-talk between multiple chain.Build() calls using the same Policy object, but still wanted someone from corefx to weigh in and give an all clear.\r\n\r\nThanks!\r\n\r\ncc @bartonjs @stephentoub \r\n",
    "comments_url": "https://api.github.com/repos/dotnet/runtime/issues/30439/comments",
    "author": "hiteshmadan",
    "comments": [
      {
        "user": "bartonjs",
        "created_at": "2019-08-01T15:33:06Z",
        "body": "`X509ChainPolicy` is just an options input type in the end, nothing is written back to it during chain walking.  It should be fine to keep it long term if (as you already acknowledged) you are explicitly setting VerificationTime before each call to X509Chain.Build."
      }
    ]
  },
  {
    "number": 30409,
    "title": "Dataflow does not process messages in parallel?",
    "created_at": "2019-07-29T13:42:34Z",
    "closed_at": "2020-02-01T03:39:02Z",
    "labels": [
      "question",
      "area-System.Threading.Tasks"
    ],
    "url": "https://github.com/dotnet/runtime/issues/30409",
    "body": "Hello.\r\nIt seems that specifying MaxDegreeOfParallelism does not actually allows dataflow blocks to process multiple messages in parallel. Or I'm missing something?\r\n\r\n```\r\npublic class DataflowTests\r\n{\r\n    private readonly ITestOutputHelper output;\r\n\r\n\r\n    public DataflowTests(ITestOutputHelper output)\r\n    {\r\n        this.output = output;\r\n    }\r\n\r\n    [Fact]\r\n    public async Task Test()\r\n    {\r\n        // arrange\r\n        var second_item_finished = new SemaphoreSlim(0, 1);\r\n        var completed_items = new ConcurrentBag<string>();\r\n\r\n        var start_block = new BufferBlock<string>(new DataflowBlockOptions { BoundedCapacity = 10 });\r\n\r\n        var process_block = new TransformBlock<string, string>(\r\n            async x =>\r\n            {\r\n                // await Task.Yield();\r\n\r\n                this.output.WriteLine(\"Process block: {0}\", x);\r\n\r\n                if (x == \"1\")\r\n                    await second_item_finished.WaitAsync();\r\n\r\n                return x;\r\n            },\r\n            new ExecutionDataflowBlockOptions\r\n            {\r\n                MaxDegreeOfParallelism = 4,\r\n                BoundedCapacity = 10\r\n            });\r\n\r\n\r\n        var final_block = new ActionBlock<string>(\r\n            x =>\r\n            {\r\n                this.output.WriteLine(\"Final block: {0}\", x);\r\n\r\n                if (x == \"2\")\r\n                    second_item_finished.Release();\r\n\r\n                completed_items.Add(x);\r\n            },\r\n            new ExecutionDataflowBlockOptions\r\n            {\r\n                MaxDegreeOfParallelism = 4,\r\n                BoundedCapacity = 10\r\n            });\r\n\r\n        start_block.LinkTo(process_block, new DataflowLinkOptions { PropagateCompletion = true });\r\n        process_block.LinkTo(final_block, new DataflowLinkOptions { PropagateCompletion = true });\r\n\r\n        // act\r\n        foreach (var item in new[] { \"1\", \"2\" })\r\n            if (!await start_block.SendAsync(item))\r\n                this.output.WriteLine(\"Unable to send: {0}\", item);\r\n\r\n        start_block.Complete();\r\n\r\n        if (!final_block.Completion.Wait(2000))\r\n            throw new TimeoutException();\r\n\r\n\r\n        // assert\r\n        completed_items.Should().BeEquivalentTo(\"1\", \"2\");\r\n    }\r\n}\r\n```\r\n\r\nI've tried changing MaxMessagesPerTask to 1 for both process and final block and got the same result (timeout exception).",
    "comments_url": "https://api.github.com/repos/dotnet/runtime/issues/30409/comments",
    "author": "MichaelLogutov",
    "comments": [
      {
        "user": "stephentoub",
        "created_at": "2019-07-29T14:04:01Z",
        "body": "By default items are propagated from a block in order.  So if you block the processing of item 1 such that item 1 won't complete until item 2 has propagated, you will deadlock.  Try setting EnsureOrdered to false on your ExecutionDataflowBlockOptions."
      },
      {
        "user": "MichaelLogutov",
        "created_at": "2019-07-29T21:07:56Z",
        "body": "Thanks! It works. I must admit - this is not default behavior I was expecting. I thought that just specifying max DOP was enough to get dataflow block working in parallel. But it seems that without changing EnsureOrdered max DOP ignored and dataflow block always working in single task mode. Am I correct?"
      },
      {
        "user": "stephentoub",
        "created_at": "2019-07-29T21:09:40Z",
        "body": "> But it seems that without changing EnsureOrdered max DOP ignored and dataflow block always working in single task mode.  Am I correct?\r\n\r\nNo.  An individual block will still be able to process up to DOP operations in parallel, but that's not what your test is doing."
      }
    ]
  },
  {
    "number": 30288,
    "title": "Question : ValueTask or warning because of not using await",
    "created_at": "2019-07-17T12:23:47Z",
    "closed_at": "2020-02-01T03:27:09Z",
    "labels": [
      "question",
      "area-System.Threading"
    ],
    "url": "https://github.com/dotnet/runtime/issues/30288",
    "body": "Hi\r\n\r\nI have an interface from an external library which i have to adhere by.\r\nIt looks like this :\r\n```\r\npublic Task<RealestateObject> Handle(RealEstatePushRequestModel request, CancellationToken cancellationToken)\r\n{\r\n}\r\n```\r\nI only have synchronous code that is required in this block.\r\nIs it better make the function async and just return the result : \r\n```\r\npublic async Task<RealestateObject> Handle(RealEstatePushRequestModel request, CancellationToken cancellationToken)\r\n{\r\n    //Much synchronous code here...\r\n    return new RealestateObject();\r\n}\r\n```\r\nWhich warns me :\r\n**This async method lacks 'await' operators and will run synchronously. Consider using the 'await' operator to await non-blocking API calls, or 'await Task.Run(...)' to do** \r\n\r\n**OR**\r\n\r\nI await ValueTask and return that : \r\n```\r\npublic async Task<RealestateObject> Handle(RealEstatePushRequestModel request, CancellationToken cancellationToken)\r\n{\r\n    return await GetValue(request);\r\n}\r\n\r\npublic ValueTask<RealestateObject> GetValue(RealEstatePushRequestModel request)\r\n{\r\n    //Much synchronous code here...\r\n    return new ValueTask<RealestateObject>(new RealestateObject() { ObjectKey = \"dummydata\" });\r\n}\r\n```\r\nWhich has no warnings at all.\r\n\r\n**OR** \r\n\r\nuse **Task.FromResult**.\r\n```\r\npublic Task<RealestateObject> Handle(RealEstatePushRequestModel request, CancellationToken cancellationToken)\r\n{\r\n    //Much synchronous code here...\r\n    return Task.FromResult(new RealestateObject() { ObjectKey = \"dummydata\" });\r\n}\r\n```\r\n\r\nWhich one of the scenario's is the best to use ?\r\n\r\nThanks!\r\n",
    "comments_url": "https://api.github.com/repos/dotnet/runtime/issues/30288/comments",
    "author": "christophedemey",
    "comments": [
      {
        "user": "Wraith2",
        "created_at": "2019-07-17T13:00:11Z",
        "body": "I would choose option 3. Your code isn't doing any async work so there is no benefit to using a compiler generated state machine. ValueTask is not relevant to this use case. You may want to check the cancellation token to throw an exception or return an appropriate value."
      },
      {
        "user": "stephentoub",
        "created_at": "2019-07-17T13:45:20Z",
        "body": "What @Wraith2 said.\r\n\r\nYour second approach with `ValueTask` is just adding unnecessary cost and complexity, solely to confuse the compiler's analysis in order to avoid the warning, but it logically has the same condition the compiler is trying to flag: you've got an async method and you're always completing synchronously.\r\n\r\nI'd recommend either just suppressing the warning, or not using `async` in the signature and just using Task.FromResult.  If you do the latter, you'll also want to consider adding a try/catch block, and in the catch block returning any exceptions via a Task.FromException (and potentially cancellation via Task.FromCanceled)... `async` does that for you."
      }
    ]
  },
  {
    "number": 30188,
    "title": "Double.TryParse succeeds and returns an incorrect value for strings in scientific notation that exceed the bounds of a double.",
    "created_at": "2019-07-08T18:42:57Z",
    "closed_at": "2020-02-01T03:17:02Z",
    "labels": [
      "question",
      "area-System.Numerics"
    ],
    "url": "https://github.com/dotnet/runtime/issues/30188",
    "body": ".NET Core Version: Version: 3.0.100-preview6-012264 - I think. VS2019 apparently hides the NetCore packages, now, so I am not 100% sure. \r\nHave you experienced this same bug with .NET Framework?: No\r\n\r\nRun the following code: \r\n            var text = \"123e466\";\r\n            var provider = new CultureInfo(\"en-US\");\r\n            double value;\r\n\r\n            var success = Double.TryParse(\r\n                text,\r\n                NumberStyles.Any & ~NumberStyles.AllowTrailingSign,\r\n                provider,\r\n                out value);\r\n\r\n            MessageBox.Show(this, value.ToString(), success.ToString());\r\n\r\nResults in DotNetFramework: \r\n\tsuccess = false\r\n\tvalue = 0\r\n\r\nResults in NetCore:\r\n\tsuccess = true\r\n\tvalue = double.Infinity\r\n\r\nIt seems to me that the original .Net Framework results were correct. \"123e466\" exceeds the bounds of a double, but it should fail to parse, not return Infinity. \r\n",
    "comments_url": "https://api.github.com/repos/dotnet/runtime/issues/30188/comments",
    "author": "IGMikeS",
    "comments": [
      {
        "user": "tannergooding",
        "created_at": "2019-07-08T20:38:34Z",
        "body": "This was updated to be IEEE 754 compliant for .NET Core 3.0. The correct behavior is that values are parsed to the \"infinitely precise\" value and then rounded to the \"nearest representable\" result (which in this case is `Infinity`).\r\n\r\nThe new behavior is correct, compliant, and expected."
      }
    ]
  },
  {
    "number": 29988,
    "title": "Hardware Acceleration for unsupported overloads",
    "created_at": "2019-06-23T21:28:14Z",
    "closed_at": "2020-02-01T02:57:40Z",
    "labels": [
      "question",
      "area-System.Runtime.Intrinsics"
    ],
    "url": "https://github.com/dotnet/runtime/issues/29988",
    "body": "Some methods in System.Runtime.Intrinsics.X86 don't have overloads for certain data types. For example:\r\n\r\n```\r\nlong u1 = 12L,\r\nlong u2 = 14L;\r\nvar vectorOne = Vector128.Create(u1);\r\nvar vectorTwo = Vector128.Create(u2);\r\nvar mask = Sse2.MoveMask(Sse2.CompareEqual(vectorOne, vectorTwo))\r\n...\r\n```\r\n\r\nWhile this is expected as there is no hardware instruction for them. Is there **anything** I can do as a workaround to compare, in this case, two Vector128 of data type long using Sse2? Such as reinterpreting, casting, different APIs?",
    "comments_url": "https://api.github.com/repos/dotnet/runtime/issues/29988/comments",
    "author": "Symbai",
    "comments": [
      {
        "user": "mikedn",
        "created_at": "2019-06-24T05:52:17Z",
        "body": "If you only care about equality/inequality then yes, you can reinterpret vectors to use a different integer type. Otherwise you should be able to use `Subtract` and then `MoveMask` to extract the sign bits."
      },
      {
        "user": "Symbai",
        "created_at": "2019-06-24T06:08:13Z",
        "body": "Thanks, I've tried reinterpreting it as double as I thought it needs to have the same amount of 8 bytes in memory but that didn't worked in some cases. Using an integer type as you said however works fine.\r\n\r\nI'm also checking for CompareGreaterThan and CompareLessThan. Can you show me a short code example how I can compare them then?"
      },
      {
        "user": "mikedn",
        "created_at": "2019-06-24T07:17:08Z",
        "body": "> Thanks, I've tried reinterpreting it as double as I thought it needs to have the same amount of 8 bytes in memory but that didn't worked in some cases. Using an integer type as you said however works fine.\r\n\r\nYes, floating point compares cannot be used in this case because floating point has various special values (NaN, negative 0 etc.).\r\n\r\n> I'm also checking for CompareGreaterThan and CompareLessThan. Can you show me a short code example how I can compare them then?\r\n\r\nIf you're not concerned about integer overflow then `LessThan` is pretty simple: `x < y` iff `x - y < 0` and `x - y < 0` iff `signbit(x - y) = 1`. To get the sign bits:\r\n```C#\r\nSse2.MoveMask(Sse2.Subtract(v1, v2).AsByte()) & 0x8080\r\n```\r\nNow it depends what do you want to do with the result. Perhaps you don't really need `MoveMask`, perhaps you need the result in vector format, like normal vector compares provide?\r\n"
      },
      {
        "user": "Symbai",
        "created_at": "2019-06-24T07:49:54Z",
        "body": "I have a byte array which I iterate through and trying to find matches for a specific value, which itself can be in various data types T, such as long. Matches can be either based on equality, or bigger or smaller. To gain maximum performance I'm casting the byte array into a span of vector128<T> and then use hardware acceleration of SSE2 to compare.\r\n\r\nBut I also need to save the position of the match in the original byte array, as well as the matched value as data type T. For this I'm using MoveMask and then TrailingZeroCount and IsBitSet from the BitOps class.  This is what I've seen in this repo once and all together is 2-4x times faster than reinterpreting the original byte array as an array of long and iterate through it with a simple loop.\r\n\r\nIf I just compare two vectors I know if I got a match, but I dont know which of the elements in the vector triggered the match. And calling GetElement for all of them is slower than MoveMask and only call GetElement when needed. Please tell me when I'm wrong and there is a faster and easier way."
      },
      {
        "user": "tannergooding",
        "created_at": "2019-06-24T17:12:22Z",
        "body": "Using `MoveMask` to get the element which triggered the match and `BitOperations.LeadingZeroCount` or `BitOperations.TrailingZeroCount` (the former hardware accelerated on more computers) to get the index of that byte is likely the right thing to do here.\r\n\r\nWe do similar things in the `SpanHelpers` class."
      }
    ]
  },
  {
    "number": 29909,
    "title": "[System.Text.Json] merging two json structures",
    "created_at": "2019-06-16T19:52:43Z",
    "closed_at": "2020-02-01T02:49:32Z",
    "labels": [
      "question",
      "area-System.Text.Json",
      "json-functionality-doc"
    ],
    "url": "https://github.com/dotnet/runtime/issues/29909",
    "body": "I ran into this use case recently and I was unable to find a solution. \r\n\r\nOn one hand I read the contents of a file, then I obtained the JSON representaiton of that content with\r\n\r\n```\r\nvar document = JsonDocument.Parse(fileContent);\r\n```\r\n\r\nNow I have access to all that data. The second thing I did was build a custom JSON object with the `Utf8JsonWriter`.\r\n\r\n**Question:** how can I integrate the latter object into the former (`document`)? I want to create a property in `document` (maybe nested quite deeply) and set the value of that property to the object that I build with `Utf8JsonWriter`.",
    "comments_url": "https://api.github.com/repos/dotnet/runtime/issues/29909/comments",
    "author": "axm",
    "comments": [
      {
        "user": "ahsonkhan",
        "created_at": "2019-06-17T19:50:21Z",
        "body": "The `JsonDocument`, in its v1 implementation, is read-only (i.e. it is not modifiable).\r\n\r\nOne thing you could do as a workaround, via the `Utf8JsonWriter`, is enumerate all the tokens of the `JsonDocument`, and write them out to the writer (including inserting the custom JSON object you have). You can then pass the output of the `Utf8JsonWriter` to `JsonDocument.Parse` to get a `JsonDocument` containing your whole JSON.\r\n\r\nMaybe something like this (note: this isn't fully tested, just a sample):\r\n```C#\r\n[Fact]\r\npublic static void ModifyJsonDocument()\r\n{\r\n    string originalJson = \"{\\\"hi\\\": 1}\";\r\n    JsonDocument doc = JsonDocument.Parse(originalJson);\r\n\r\n    JsonDocument newDoc = AddJsonData(doc, doc);\r\n\r\n    Assert.Equal(\"{\\\"hi\\\":1,\\\"mySubElement\\\":{\\\"hi\\\":1}}\", newDoc.RootElement.ToString());\r\n}\r\n\r\nprivate static JsonDocument AddJsonData(JsonDocument original, JsonDocument subOject)\r\n{\r\n    JsonElement element = original.RootElement;\r\n    var abw = new ArrayBufferWriter<byte>();\r\n    using var writer = new Utf8JsonWriter(abw);\r\n\r\n    writer.WriteStartObject();\r\n    foreach(JsonProperty properties in element.EnumerateObject())\r\n    {\r\n        properties.Value.WriteProperty(properties.Name, writer);\r\n    }\r\n    JsonElement subElement = subOject.RootElement;\r\n    subElement.WriteProperty(\"mySubElement\", writer);\r\n    writer.WriteEndObject();\r\n\r\n    writer.Flush();\r\n\r\n    return JsonDocument.Parse(abw.WrittenMemory);\r\n}\r\n```"
      },
      {
        "user": "ahsonkhan",
        "created_at": "2019-06-18T08:57:48Z",
        "body": "> Are there any plans to introduce this functionality out of the box in 1.1 or above?\r\n\r\nWhen you say 1.1 or above, what do you mean? If you mean the next version of .NET Core, we will likely add support for a modifiable `JsonDocument` in the next release of .NET Core (after 3.0)."
      }
    ]
  },
  {
    "number": 29815,
    "title": ".NET Core 3 and WPF library",
    "created_at": "2019-06-07T22:23:21Z",
    "closed_at": "2020-02-01T02:41:45Z",
    "labels": [
      "question",
      "area-Meta"
    ],
    "url": "https://github.com/dotnet/runtime/issues/29815",
    "body": "I just tried some existing WPF code using .NET Core 3.0 preview 5 and VS 16.2 Preview 1. I read the porting guide for WPF and it seems to only talk about apps not libraries. The main changes seem to be \r\n```\r\n    <OutputType>WinExe</OutputType>\r\n    <UseWPF>true</UseWPF>\r\n```\r\nWhen I try \r\n```\r\n    <OutputType>Library</OutputType>\r\n    <UseWPF>true</UseWPF>\r\n```\r\nI get unresolved references for all the WPF related stuff. I did try WinLibrary but that is rejected. Does this only work for applications at present?",
    "comments_url": "https://api.github.com/repos/dotnet/runtime/issues/29815/comments",
    "author": "davidhunter22",
    "comments": [
      {
        "user": "wangfu91",
        "created_at": "2019-06-08T07:15:04Z",
        "body": "@davidhunter22  For libraries, you need change the ```Sdk``` to ```Microsoft.NET.Sdk.WindowsDesktop```, and add the ```<UseWPF>true</UseWPF>``` tag.\r\n```xml\r\n<Project Sdk=\"Microsoft.NET.Sdk.WindowsDesktop\">\r\n  <PropertyGroup>\r\n    <TargetFramework>netcoreapp3.0</TargetFramework>\r\n    <UseWPF>true</UseWPF>\r\n  </PropertyGroup>\r\n</Project>\r\n```"
      }
    ]
  },
  {
    "number": 29465,
    "title": "ProcessInfo Linux/Windows incompatibility",
    "created_at": "2019-05-06T12:40:26Z",
    "closed_at": "2020-02-01T02:07:07Z",
    "labels": [
      "question",
      "area-System.Diagnostics.Process"
    ],
    "url": "https://github.com/dotnet/runtime/issues/29465",
    "body": "Hi,\r\n\r\nI'm trying to run same process as a child of current process. Showed below code works just fine under windows, but fails in Linux with  error\r\n\r\nNo executable found matching command \"dotnet-MyDll.dll\"\r\n\r\n```\r\nvar processInfo = new ProcessStartInfo\r\n            {\r\n                FileName = \"dotnet\",\r\n                Arguments = \"MyDll.dll \" + id.ToString()\r\n            };\r\n\r\n            Console.WriteLine(\"Starting child process...\");\r\n            var process = Process.Start(processInfo);\r\n            return process;\r\n\r\n```\r\n\r\nIve also tried\r\n         `       FileName = \"dotnet MyDll.dll\"+ id.ToString(),`\r\nbut it ends up with different error \r\nUnhandled Exception: System.ComponentModel.Win32Exception: No such file or directory\r\n\r\nI've also tried \r\n```\r\n\r\n            var parentP = Process.GetCurrentProcess();\r\n            string fullPath = parentP.MainModule.FileName;\r\n            var command = fullPath+\" \"+Assembly.GetEntryAssembly().Location+\" \"+ id.ToString();\r\n            Console.WriteLine(\"Command = \"+command);\r\n            var processInfo = new ProcessStartInfo\r\n            {\r\n                FileName = command\r\n            };\r\n            var process = Process.Start(processInfo);\r\n```\r\nStill \r\nUnhandled Exception: System.ComponentModel.Win32Exception: No such file or directory\r\n\r\nwhat is proper way of running currently running dll again under Linux with dotnet core",
    "comments_url": "https://api.github.com/repos/dotnet/runtime/issues/29465/comments",
    "author": "pragmaticadam",
    "comments": [
      {
        "user": "pragmaticadam",
        "created_at": "2019-05-07T09:21:32Z",
        "body": "I've also tried :\r\n\r\n```\r\nvar parrentP = Process.GetCurrentProcess();\r\n        string fullPath = parrentP.MainModule.FileName;\r\n        var command = \"\\\"\" + fullPath + \"\\\" \" ;\r\n        var args = Assembly.GetEntryAssembly().Location + \" \" + id;\r\n        var processInfo = new ProcessStartInfo\r\n        {\r\n            FileName = command,\r\n            Arguments = args\r\n        };\r\n            var process = Process.Start(processInfo);\r\n```\r\n\r\n\r\nWorks under windows, do not work under LINUX\r\n\r\n\r\nException No such file or directory\r\nException    at System.Diagnostics.Process.StartCore(ProcessStartInfo startInfo)\r\n   at System.Diagnostics.Process.Start()\r\n   at System.Diagnostics.Process.Start(ProcessStartInfo startInfo)\r\n\r\nLooks for me like something with path building, \r\n\r\nWHAT IS WORK AROUND FOR THIS ?\r\n\r\n\r\n"
      },
      {
        "user": "tmds",
        "created_at": "2019-05-07T10:03:19Z",
        "body": "This works:\r\n\r\n```cs\r\nstatic void Main(string[] args)\r\n{\r\n    if (args.Length == 0)\r\n    {\r\n        var psi = new ProcessStartInfo\r\n        {\r\n            FileName = Process.GetCurrentProcess().MainModule.FileName,\r\n            Arguments = $\"\\\"{Assembly.GetEntryAssembly().Location}\\\" \\\"hello world\\\"\"\r\n        };\r\n        Process.Start(psi).WaitForExit();\r\n    }\r\n    else\r\n    {\r\n        System.Console.WriteLine(\"Called with arg: \" + args[0]);\r\n    }\r\n}\r\n```\r\n\r\nIf you want to use the `Arguments` property, you need to surround the individual arguments with double quotes. For example:\r\n```cs\r\nArguments = $\"\\\"{Assembly.GetEntryAssembly().Location}\\\" \\\"hello world\\\"\"\r\n```\r\n\r\nIf it doesn't work for you, what is the values of: `Process.GetCurrentProcess().MainModule.FileName` and `Assembly.GetEntryAssembly().Location`.\r\n\r\n> WHAT IS WORK AROUND FOR THIS ?\r\n\r\nDon't use CAPS unless you're angry and want to yell at someone."
      },
      {
        "user": "stephentoub",
        "created_at": "2019-05-07T12:14:33Z",
        "body": "> If you want to use the Arguments property, you need to surround the individual arguments with double quotes\r\n\r\nOnly if they may have whitespace, right?"
      },
      {
        "user": "tmds",
        "created_at": "2019-05-07T12:51:34Z",
        "body": "> Only if they may have whitespace, right?\r\n\r\nYes, only needed then. They get stripped of the other arguments, so adding them everywhere is a simple way to avoid forgetting them somewhere."
      }
    ]
  },
  {
    "number": 29160,
    "title": "What kind EqualityComparer use to unknown in compile time type?",
    "created_at": "2019-04-04T08:23:28Z",
    "closed_at": "2020-02-01T01:39:08Z",
    "labels": [
      "question",
      "area-System.Runtime"
    ],
    "url": "https://github.com/dotnet/runtime/issues/29160",
    "body": "Is it possible get `EqualityComparer<>.Default`\r\nby `Type` in runtime?\r\nIn compile time I don't know what type will be.\r\n\r\nIs it correct to use `EqualityComparer<object>.Default`?\r\nCan there be problems with this?\r\n\r\n",
    "comments_url": "https://api.github.com/repos/dotnet/runtime/issues/29160/comments",
    "author": "westfin",
    "comments": [
      {
        "user": "bartonjs",
        "created_at": "2019-05-15T19:23:49Z",
        "body": "@westfin Do you mean you want to get the default equality comparer for a type that you learn about at runtime, but not in a generic way?\r\n\r\n```C#\r\nIEqualityComparer comparer = (IEqualityComparer)typeof(EqualityComparer<>).\r\n    MakeGenericType(o.GetType()).\r\n    GetProperty(\"Default\", BindingFlags.Static | BindingFlags.Public);\r\n```\r\n\r\nSeems like maybe what you want?\r\n\r\nI think `EqualityComparer<object>.Default` is just going to end up calling `((object)x).Equals((object)y)`; which is probably functionally equivalent for any particular T, but I can't speak to that without a lot more digging."
      }
    ]
  },
  {
    "number": 29130,
    "title": "Potential Bug with a pinned GCHandle.Alloc call",
    "created_at": "2019-03-31T20:05:18Z",
    "closed_at": "2020-02-01T01:36:48Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/runtime/issues/29130",
    "body": "There's a problem with GCHandle.Alloc where if you try to allocate the same object (in my case the same byte array) with the GCHandle.Pinned parameter, it doesn't store the byte array again and instead just uses a reference to the first byte array that was stored.\r\n\r\nHere's an example\r\n\r\n```csharp\r\nvar bytes = new byte[] { 0x00, 0xFF, 0x00, 0xFF };\r\n\r\nvar buffer1 = GCHandle.Alloc(bytes, GCHandleType.Pinned);\r\n\r\nvar buffer1Address = buffer1.AddrOfPinnedObject();\r\n\r\nvar buffer2 = GCHandle.Alloc(bytes, GCHandleType.Pinned);\r\n\r\nvar buffer2Address = buffer2.AddrOfPinnedObject();\r\n```\r\n\r\nIn this case, buffer1Address and buffer2Address will be the exact same.\r\n\r\nI was just wondering if this is intentional or if it is indeed a bug?\r\n\r\nIf this is intentional maybe offering an option to not do this could be useful (at least in my case it is)\r\n",
    "comments_url": "https://api.github.com/repos/dotnet/runtime/issues/29130/comments",
    "author": "ghost",
    "comments": [
      {
        "user": "stephentoub",
        "created_at": "2019-03-31T20:26:05Z",
        "body": "AddrOfPinnedObject returns the same address because it's the same object.  There's only one array object here and thus only has one location in memory: AddrOfPinnedObject returns that location, the \"address of the pinned object\"."
      },
      {
        "user": "GrabYourPitchforks",
        "created_at": "2019-03-31T21:23:34Z",
        "body": "To add to what @stephentoub said, I think the confusion might be coming from the `Alloc` method name. The `GCHandle.Alloc` method is allocating a new _handle_ to the object, not duplicating the object passed in to it. So if you compare the two `GCHandle` instances directly, you'll see that they have two different values for the stored handle, but each handle points to the exact same backing object. Hence the behavior you're seeing with `AddrOfPinnedObject`."
      }
    ]
  },
  {
    "number": 28099,
    "title": "name collision with type Index added to System namespace",
    "created_at": "2018-12-06T22:55:39Z",
    "closed_at": "2020-02-01T00:02:19Z",
    "labels": [
      "question",
      "design-discussion",
      "area-System.Runtime"
    ],
    "url": "https://github.com/dotnet/runtime/issues/28099",
    "body": "tag:discussion\r\n\r\nWe have this very old class that's used all over the place called Index, which is basically a Dictionary that accepts more than one item per key. It's used like a mutable IGrouping and was recently retrofitted to implement IGrouping. It's use is so pervasive that it grew another implementation called SortedIndex which is to Index as SortedDictionary is to Dictionary.\r\n\r\nSo now we've got literally thousands of files importing System and expecting Index to be ours (in a far namespace), and on upgrading to .NET Core 3 we get a completely ridiculous number of errors.\r\n\r\nSo now we've got to figure out how to handle this name collision. Trying to rename Index is going to break back-compatibility of our nuget packages all over the place.\r\n\r\n(Yes, some parts of our .NET Core codebase are literally 11 years old and I've got the source control trees to prove 9 of them and would have more but for a disk crash.)",
    "comments_url": "https://api.github.com/repos/dotnet/runtime/issues/28099/comments",
    "author": "jhudsoncedaron",
    "comments": [
      {
        "user": "tarekgh",
        "created_at": "2018-12-06T23:42:34Z",
        "body": "@terrajobst is it possible our Index can be moved to a different namespace? "
      },
      {
        "user": "terrajobst",
        "created_at": "2018-12-07T00:24:30Z",
        "body": "We could consider moving it but I don't think this will solve the OPs problem because it likely will be another core namespace that's imported by default. The only option I see is us renaming the type, but I think that would be substantially worse for everyone else.\r\n\r\nHistorically, us trying to avoid naming collisions with consuming code is basically an exercise in futility unless we put new types in esoteric namespaces or choose multi-word names that are unlikely to collide, so for new core features (such as `Task`, `Tuple`, `Range`, `Span`) this simply isn't actionable for us."
      },
      {
        "user": "jhudsoncedaron",
        "created_at": "2018-12-07T00:35:11Z",
        "body": "In this case it has its own syntax, so System.Runtime.CompilerServices could be used.\r\n\r\nBut I said discussion for a reason. Perhaps there's a good way to prioritize imports that can be mechanically applied at the file level."
      },
      {
        "user": "terrajobst",
        "created_at": "2018-12-08T06:36:38Z",
        "body": "> In this case it has its own syntax, so System.Runtime.CompilerServices could be used.\r\n\r\n`System.Runtime.CompilerServices` is meant for types that you basically never have to use yourself. While `Range` and `Index` have language syntax, you still need to use the type name for parameters and return declarations of methods -- they are not like tuples where the language offered syntax for the *type*. For `Range` and `Index` the language only provides syntax for *values*. That's why these types belong to the `System` namespace IMHO.\r\n\r\n> Perhaps there's a good way to prioritize imports that can be mechanically applied at the file level.\r\n\r\nCan you explain what you mean by that?"
      },
      {
        "user": "danmoseley",
        "created_at": "2018-12-10T04:13:41Z",
        "body": "Can you either\r\n1. search and replace (or use Roslyn analyzer) to fully qualify use of your `Index` or\r\n2. insert statement like `using Index = MyNamespace.Index;` at the top of all your files?"
      },
      {
        "user": "jhudsoncedaron",
        "created_at": "2018-12-10T16:17:49Z",
        "body": "Number 2 is probably going to work."
      },
      {
        "user": "jhudsoncedaron",
        "created_at": "2018-12-11T23:27:24Z",
        "body": "@danmosemsft : It looks like we're going to try on the whole codebase tomorrow and see what happens."
      }
    ]
  },
  {
    "number": 27797,
    "title": "ConcurrentDictionary initialized with an existing ConcurrentDictionary will act as pointer instead of new object",
    "created_at": "2018-11-01T21:38:10Z",
    "closed_at": "2020-01-31T23:35:51Z",
    "labels": [
      "question",
      "area-System.Collections"
    ],
    "url": "https://github.com/dotnet/runtime/issues/27797",
    "body": "When initializing a new ConcurrentDictionary starting from an existing ConcurrentDictionary, the new object will act as pointer.\r\n\r\n``` csharp\r\n// Summary:\r\n//     Initializes a new instance of the System.Collections.Concurrent.ConcurrentDictionary`2\r\n//     class that contains elements copied from the specified System.Collections.Generic.IEnumerable`1,\r\n//     has the default concurrency level, has the default initial capacity, and uses\r\n//     the default comparer for the key type.\r\npublic ConcurrentDictionary(IEnumerable<KeyValuePair<TKey, TValue>> collection);\r\n```\r\nbased on this description I wrote the following code:\r\n``` csharp\r\npublic static ConcurrentDictionary<int, myCustomClass> startDictionary;\r\n[...]\r\nConcurrentDictionary<int, myCustomClass> tempDictionary =\r\n                new ConcurrentDictionary<int, myCustomClass>(startDictionary);\r\n```\r\nbecause i need to modify some data into ```tempDictionary``` without affecting ```startDictionary```.\r\n\r\nWhat happens is that any edit to ```tempDictionary``` is reflected to ```startDictionary``` too. Am I doing something wrong?",
    "comments_url": "https://api.github.com/repos/dotnet/runtime/issues/27797/comments",
    "author": "pietrodicaprio",
    "comments": [
      {
        "user": "stephentoub",
        "created_at": "2018-11-01T21:45:57Z",
        "body": "Can you share a repro?  I don't see how that's possible.  Adds/removes/etc. to startDictionary should definitely not be visible to tempDictionary.  But if TKey/TValue are classes and you mutate those instances, then yeah, as with any collection, the updates would be visible to both collections, because they're both storing the original object.\r\n\r\nFor example, if you write:\r\n```C#\r\nclass C\r\n{\r\n    public int Value;\r\n}\r\n...\r\nvar c1 = new C() { Value = 42 };\r\nvar c2 = new C() { Value = 42 };\r\n\r\nvar oldList = new List<C>();\r\noldList.Add(c1);\r\n\r\nvar newList = new List<C>(oldList);\r\nnewList.Add(c2);\r\n```\r\noldList will contain only c1 and newList will contain both c1 and c2.  If you then do:\r\n```C#\r\nc1.Value = 84;\r\n```\r\nthen both oldList and newList will still contain c1, which will have a Value of 84."
      },
      {
        "user": "pietrodicaprio",
        "created_at": "2018-11-01T22:13:07Z",
        "body": "Share the repo is difficult because you would need my db and so on to have it running.\r\n\r\ni have\r\n``` csharp\r\nclass myCustomClass\r\n{\r\n    public int Id;\r\n    public int value1;\r\n    public int value2;\r\n}\r\n\r\n[...]\r\npublic static ConcurrentDictionary<int, myCustomClass> startDictionary =\r\n    new ConcurrentDictionary<int, myCustomClass>();\r\n\r\nprivate void myMethod()\r\n{\r\n    var mCC = new myCustomClass(){ Id = 1, value1 = 1, value2 = 3 };\r\n    startDictionary.TryAdd(1, mCC); // startDictionary receives data\r\n}\r\n\r\n[...]\r\nConcurrentDictionary<int, myCustomClass> tempDictionary =\r\n    new ConcurrentDictionary<int, myCustomClass>(startDictionary ); // my temp Dict to be modified\r\nforeach (myCustomClass mcc in tempDictionary.Values) // <-- THIS\r\n{\r\n    mcc.value2 = Id + value1; // Just for example\r\n}\r\n\r\n// tempDictionary[1].value2 is now == 2\r\n// startDictionary[1].value2 is now == 2 <-- NOT GOOD (for me)\r\n\r\nDoThingsWithModified(tempDictionary);\r\n```\r\n\r\nWhat i don't understand is why the foreach ```// <-- THIS``` is affecting ```startDictionary``` too. Is it normal?"
      },
      {
        "user": "stephentoub",
        "created_at": "2018-11-01T23:01:09Z",
        "body": "> Is it normal\r\n\r\nYes. You're not modifying the dictionary. You're modifying an object stored in the dictionary. When you copy the dictionary, you're copying over all of the object references the dictionary contains... if you change that referenced object, that change will be visible everywhere, because it's the same object both dictionaries contain. This is the same as the c1.Value change in my previous response."
      },
      {
        "user": "Clockwork-Muse",
        "created_at": "2018-11-01T23:15:11Z",
        "body": "AKA shallow-copy semantics (when you were expecting some form of deep copy)."
      },
      {
        "user": "pietrodicaprio",
        "created_at": "2018-11-01T23:16:41Z",
        "body": "Uhm, i understand..\r\nCould you kindly suggest a different approach to my needing?\r\n\r\nThe only idea i have is\r\n```csharp\r\nConcurrentDictionary<int, myCustomClass> tempDictionary =\r\n    new ConcurrentDictionary<int, myCustomClass>(); // no reference to startDictionary\r\nforeach (KeyValuePair<int, myCustomClass> kvp in startDictionary)\r\n{\r\n    myCustomClass mcc = new myCustomClass()\r\n        {\r\n            Id = kpv.Value.Id,\r\n            value1 = kvp.Value.value1,\r\n            value2 = kvp.Value.value2\r\n        };\r\n    tempDictionary.TryAdd(kvp.Key, mcc);\r\n}\r\n\r\nforeach (myCustomClass mcc in tempDictionary.Values)\r\n{\r\n    mcc.value2 = Id + value1; // Just for example\r\n}\r\n\r\nDoThingsWithModified(tempDictionary);\r\n```\r\nbut, I'm not sure this would solve my problem..."
      },
      {
        "user": "stephentoub",
        "created_at": "2018-11-02T00:37:50Z",
        "body": "Your approach is fine: you're cloning the object to add to the second dictionary so that it's not the same object as the one stored in the first dictionary."
      }
    ]
  },
  {
    "number": 11367,
    "title": "ECMA 335 II.15.2 Static, instance, and virtual methods",
    "created_at": "2018-10-30T22:18:06Z",
    "closed_at": "2020-01-31T05:25:00Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/runtime/issues/11367",
    "body": "Hello all\r\n\r\nWe have two notices in this article\r\n\r\n-  Instance methods on classes (including boxed value types), have a this pointer that is\r\nby default an object reference to the class on which the method is defined.\r\n\r\n-  Instance methods on (unboxed) value types, have a this pointer that is by default a\r\nmanaged pointer to an instance of the type on which the method is defined.\r\n\r\nWhat is a difference between a **object reference** and **managed pointer** in this case?",
    "comments_url": "https://api.github.com/repos/dotnet/runtime/issues/11367/comments",
    "author": "ghost",
    "comments": [
      {
        "user": "jkotas",
        "created_at": "2018-10-30T22:27:39Z",
        "body": "The difference between object reference and managed pointer is described in section I.12.1.1.2 Object reference and managed pointer types: O and &\r\n\r\nThe short answer is that object reference points to an object vs. managed pointer points to the interior of an object."
      }
    ]
  },
  {
    "number": 11072,
    "title": "Linked cancellation token source where all tokens must be cancelled",
    "created_at": "2018-09-12T16:37:40Z",
    "closed_at": "2020-01-31T05:05:23Z",
    "labels": [
      "question",
      "area-System.Threading"
    ],
    "url": "https://github.com/dotnet/runtime/issues/11072",
    "body": "This is more of an question of whether such functionality exists within the coreclr already.\r\n\r\nI've used `CancellationTokenSource.CreateLinkedTokenSource` to get a `CancellationToken` which will be cancelled when any of the subject tokens are cancelled.\r\n\r\nMy current scenario is I invoke an HTTP API and I would like to record in Entity Framework the result of that call.  Currently the EF call uses the same token I used for the HTTP API.  This works fine so long the token does not become cancelled.\r\n\r\nThe obvious solution to use a separate `CancellationToken` for the database call, which resulted in me making a small one that expires after 3 seconds, works fine for most scenarios but sometimes it operation takes longer than 3 seconds, so despite the first token still having time left left, the database operation fails due to the 3 second token.\r\n\r\nMy question is: \r\nIs there functionality within the `CancellationTokenSource` class (or elsewhere) that creates a linked token where *all* of the subject tokens must be cancelled for the derived one to be considered cancelled?",
    "comments_url": "https://api.github.com/repos/dotnet/runtime/issues/11072/comments",
    "author": "MatthewLymer",
    "comments": [
      {
        "user": "tarekgh",
        "created_at": "2018-09-19T19:28:10Z",
        "body": "I am not aware of any API support this scenario. you may create your custom type doing that. \r\n\r\nCC @stephentoub just in case he knows any API doing that."
      },
      {
        "user": "stephentoub",
        "created_at": "2018-09-19T20:36:38Z",
        "body": "> Is there functionality within the CancellationTokenSource class (or elsewhere) that creates a linked token where all of the subject tokens must be cancelled for the derived one to be considered cancelled?\r\n\r\nThere's nothing built into .NET, but you could easily build your own, e.g. (untested)\r\n```C#\r\nsealed class AllLinkedSource : CancellationTokenSource\r\n{\r\n    private readonly CancellationTokenRegistration[] _registrations;\r\n    private int _remaining;\r\n\r\n    public AllLinkedSource(params CancellationToken[] tokens)\r\n    {\r\n        _remaining = tokens.Length;\r\n        _registrations = new CancellationTokenRegistration[tokens.Length];\r\n        for (int i = 0; i < tokens.Length; i++)\r\n        {\r\n            _registrations[i] = tokens[i].Register(t =>\r\n            {\r\n                var thisRef = (AllLinkedSource)t;\r\n                if (Interlocked.Decrement(ref thisRef._remaining) == 0) thisRef.Cancel();\r\n            }, this);\r\n        }\r\n    }\r\n\r\n    protected override void Dispose(bool disposing)\r\n    {\r\n        foreach (CancellationTokenRegistration reg in _registrations) reg.Dispose();\r\n        base.Dispose(disposing);\r\n    }\r\n}\r\n```"
      }
    ]
  },
  {
    "number": 27285,
    "title": "Can not send email with SmtpClient on Ubuntu 18.4 LTS",
    "created_at": "2018-09-01T04:58:33Z",
    "closed_at": "2020-01-31T22:53:26Z",
    "labels": [
      "question",
      "area-System.Net",
      "os-linux"
    ],
    "url": "https://github.com/dotnet/runtime/issues/27285",
    "body": "I'm trying to send email using Google SMTP server but its throwing exception:\r\n```\r\nAn unhandled exception occurred while processing the request.\r\nWin32Exception: GSSAPI operation failed with error - An invalid status code was supplied (Unknown error).\r\n\r\nSystem.Net.Security.NegotiateStreamPal.AcquireCredentialsHandle(string package, bool isServer, NetworkCredential credential)\r\nSmtpException: Failure sending mail.\r\n\r\nSystem.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()\r\n```\r\nAt `Startup` Class:\r\n```c#\r\n services.AddScoped<SmtpClient>((provider) =>\r\n            {\r\n                var config = provider.GetRequiredService<IConfiguration>();\r\n                return new SmtpClient()\r\n                {\r\n                    Host = config.GetValue<String>(\"MailService:Smtp\"),\r\n                    Port = config.GetValue<int>(\"MailService:Port\"),\r\n                    Credentials = new NetworkCredential(\r\n                            config.GetValue<String>(\"MailService:Username\"),\r\n                            config.GetValue<String>(\"MailService:Password\")\r\n                        )\r\n                };\r\n            });\r\n```\r\nAnd in `Controller`:\r\n```c#\r\n        private readonly SmtpClient _smtpClient;\r\n\r\n        public ValuesController(\r\n            SmtpClient smtpClient\r\n        )\r\n        {\r\n            _smtpClient = smtpClient;\r\n        }\r\n\r\n        [HttpGet]\r\n        public async Task<IActionResult> Get()\r\n        {\r\n            await _smtpClient.SendMailAsync(new MailMessage(\r\n                from: \"sender@domain.com\",\r\n                to: \"receiver@domain.com\",\r\n                subject: \"Test message subject\",\r\n                body: \"Test message body\"\r\n                        ));\r\n            return Ok();\r\n        }\r\n```",
    "comments_url": "https://api.github.com/repos/dotnet/runtime/issues/27285/comments",
    "author": "shakeri",
    "comments": [
      {
        "user": "danmoseley",
        "created_at": "2018-09-02T05:43:07Z",
        "body": "Hello, it may not help, but can you please confirm this reproes on 2.1 (or master)? 2.0 is about to go out of support."
      },
      {
        "user": "shakeri",
        "created_at": "2018-09-03T10:40:57Z",
        "body": "@danmosemsft thanks for reply.\r\nI upgraded this project to version 2.1, but there is still a similar error:\r\n```\r\nAn unhandled exception occurred while processing the request.\r\nWin32Exception: GSSAPI operation failed with error - An invalid status code was supplied (Unknown error).\r\n\r\nSystem.Net.Security.NegotiateStreamPal.AcquireCredentialsHandle(string package, bool isServer, NetworkCredential credential)\r\nSmtpException: Failure sending mail.\r\n```"
      },
      {
        "user": "danmoseley",
        "created_at": "2018-09-03T15:18:27Z",
        "body": "Thanks. Do you have a different machine to try? Not much to go on."
      },
      {
        "user": "shakeri",
        "created_at": "2018-09-04T06:31:42Z",
        "body": "I tested this project on Windows Server 2012 R2 on the same network and it worked without problems."
      },
      {
        "user": "karelz",
        "created_at": "2018-09-04T16:08:18Z",
        "body": "I suspect a problem with configuration on Linux - similar to dotnet/runtime#25885\r\n@tmds @wfurt any tips & tricks for troubleshooting?"
      },
      {
        "user": "wfurt",
        "created_at": "2018-09-04T16:18:20Z",
        "body": "I would suggest packet capture with wireshark or tcpdump. I would also suggest to install gss-ntlmssp package (or verify that it is in place) \r\nJust some background @shakeri: Windows do have all the necessary parts needed for NTLM and Kerberos. On Unix, this varies based on distribution and configuration.    "
      },
      {
        "user": "shakeri",
        "created_at": "2018-09-05T18:37:00Z",
        "body": "@wfurt I installed gss-ntlmssp package and test again.It worked.\r\nThanks."
      },
      {
        "user": "danmoseley",
        "created_at": "2018-09-05T19:11:21Z",
        "body": "@karelz I wonder if it would make sense for the exceptoin message to suggest installing it."
      },
      {
        "user": "wfurt",
        "created_at": "2018-09-05T20:44:17Z",
        "body": "we talk about it while back @danmosemsft. I think that would be good idea. "
      },
      {
        "user": "davidsh",
        "created_at": "2018-09-05T20:51:53Z",
        "body": ">we talk about it while back @danmosemsft. I think that would be good idea.\r\n\r\nIt's not a trivial problem to solve.  The error message we get back when doing NTLM operations is not always specific enough to determine that the problem is configuration (i.e. gss-ntlmssp not installed)."
      }
    ]
  },
  {
    "number": 27225,
    "title": "Why RSACng use SignHash with RSASignaturePadding.Pkcs1 need input hash length equal to HashAlgorithmName's hash's length?",
    "created_at": "2018-08-24T07:06:45Z",
    "closed_at": "2020-01-31T22:48:17Z",
    "labels": [
      "question",
      "area-System.Security"
    ],
    "url": "https://github.com/dotnet/runtime/issues/27225",
    "body": "I'm use .NET Framework 4.6.1 on Windows.\r\n\r\nAnd I found when use RSACng SignHash, which is \r\n```c#\r\nbyte[] SignHash(byte[] hash, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding);\r\n```\r\nwhen the parameter hash, the byte array 's length is not equal to hashAlgorithm's hash length, it will throw exception: wrong parameter.\r\nFor example:\r\nwhen use hashAlgorithm Sha256, whose result length is 32 , the length of hash must also be 32.\r\n\r\nPSS padding has no such restrictions.\r\nI think native library like Openssl also has no such restrictions.",
    "comments_url": "https://api.github.com/repos/dotnet/runtime/issues/27225/comments",
    "author": "avalon1610",
    "comments": [
      {
        "user": "bartonjs",
        "created_at": "2018-08-25T05:46:49Z",
        "body": "If you're using `SignHash` (the hash is already computed) then the hash needs to be correct for it's size.  If PSS isn't requiring that then that sounds like a bug with the PSS handler (though I'd have to dig in and double check).\r\n\r\nIf you are signing data (which needs to be hashed first) then you should use `SignData` instead.  It has no size restrictions."
      },
      {
        "user": "avalon1610",
        "created_at": "2018-08-25T06:45:03Z",
        "body": "OK, I made a mistake. \r\nI found openssl's `EVP_DigestSignUpdate` will auto hash for the data, equals to `SignData` here. \r\nBut signing with PSS padding has different behavior here as I tested."
      },
      {
        "user": "bartonjs",
        "created_at": "2019-02-25T21:23:58Z",
        "body": "The PSS format allows the hash to mismatch because PSS technically doesn't have a requirement that the PSS hash and the data hash match, and that functionality is the escape valve for implementing custom logic (e.g. hash the data using SHA384 then verify the signature with PSS/SHA256... for... reasons.... :smile:).\r\n\r\nThere doesn't seem to be any other action required here, so closing."
      }
    ]
  },
  {
    "number": 10674,
    "title": "Assembly.LoadFrom(\"System.Threading.Tasks.Extensions.dll\") fails with FileLoadException",
    "created_at": "2018-07-13T16:03:23Z",
    "closed_at": "2020-01-31T04:37:40Z",
    "labels": [
      "question",
      "area-AssemblyLoader-coreclr"
    ],
    "url": "https://github.com/dotnet/runtime/issues/10674",
    "body": "We (PostSharp) noticed a weird behavior of .NET Core CLR and are asking for clarifications so we can implement a proper solution.\r\n\r\nConsider the following program:\r\n\r\n```\r\n   class Program\r\n    {\r\n        static void Main(string[] args)\r\n        {\r\n           Assembly.LoadFrom(@\"C:\\Users\\gael\\.nuget\\packages\\system.threading.tasks.extensions\\4.5.1\\lib\\netstandard2.0\\System.Threading.Tasks.Extensions.dll\");\r\n   \r\n        }\r\n    }\r\n```\r\n\r\nWhen executed with the default command line with .NET Core 2.0.9, this program throws:\r\n\r\n```\r\nUnhandled Exception: System.IO.FileLoadException: Could not load file or assembly 'System.Threading.Tasks.Extensions, Version=4.2.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51'.\r\n   at System.Runtime.Loader.AssemblyLoadContext.LoadFromPath(IntPtr ptrNativeAssemblyLoadContext, String ilPath, String niPath, ObjectHandleOnStack retAssembly)\r\n   at System.Runtime.Loader.AssemblyLoadContext.LoadFromAssemblyPath(String assemblyPath)\r\n   at System.Reflection.Assembly.LoadFrom(String assemblyFile)\r\n   at ConsoleApp2.Program.Main(String[] args) in c:\\users\\gael\\documents\\visual studio 2017\\ConsoleApp2\\Program.cs:line 10\r\n```\r\n\r\nWe found the following workaround. First, define a file `my.deps.json` with the following content:\r\n\r\n```\r\n{\r\n  \"runtimeTarget\": {\r\n    \"name\": \".NETCoreApp,Version=v2.0\",\r\n    \"signature\": \"fc666d3b05189566bb68c07fa9bfb9b94dbee726\"\r\n  },\r\n  \"targets\": {\r\n    \".NETCoreApp,Version=v2.0\": {\r\n      \"System.Threading.Tasks.Extensions/4.5.1\": {\r\n        \"dependencies\": {\r\n          \"System.Runtime.CompilerServices.Unsafe\": \"4.5.0\"\r\n        },\r\n        \"runtime\": {\r\n          \"C:/Users/gael/.nuget/packages/system.threading.tasks.extensions/4.5.1/lib/netstandard2.0/System.Threading.Tasks.Extensions.dll\": {\r\n            \"assemblyVersion\": \"4.2.0.0\",\r\n            \"fileVersion\": \"4.6.26606.5\"\r\n          }\r\n        }\r\n      }\r\n    }\r\n  },\r\n  \"libraries\": {\r\n    \"System.Threading.Tasks.Extensions/4.5.1\": {\r\n      \"type\": \"package\",\r\n      \"serviceable\": true,\r\n      \"sha512\": \"sha512-rckdhLJtzQ3EI+0BGuq7dUVtCSnerqAoAmL3S6oMRZ4VMZTL3Rq9DS8IDW57c6PYVebA4O0NbSA1BDvyE18UMA==\",\r\n      \"path\": \"system.threading.tasks.extensions/4.5.1\",\r\n      \"hashPath\": \"system.threading.tasks.extensions.4.5.1.nupkg.sha512\"\r\n    }\r\n  }\r\n}\r\n```\r\n\r\nThen use the following command line:\r\n\r\n```\r\ndotnet --additional-deps my.deps.json ConsoleApp2.dll\r\n```\r\n\r\nOur hypothesis is that `Assembly.LoadFrom` is not allowed for assemblies that are shipped with .NET Core (i.e. those under the directory `C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App\\2.0.9`). A viable workaround is to generate an additional `deps.json` file and include any assembly that we need to load at runtime but that are not a build-time dependency.\r\n\r\nCould you please spread some light on this situation?\r\n\r\nThank you.\r\n\r\n-gael\r\n",
    "comments_url": "https://api.github.com/repos/dotnet/runtime/issues/10674/comments",
    "author": "gfraiteur",
    "comments": [
      {
        "user": "jeffschwMSFT",
        "created_at": "2018-07-13T20:37:35Z",
        "body": "@gfraiteur thanks for reaching out.  The original failure happens for two reasons: 1) simple version downgrade checks and 2) tpa list unification.  When running on .NET Core 2.0.9 there is a version of System.Threading.Tasks.Extensions with version 4.1.1 that ships as part of NetCore.APP.  When you try to load S.T.T.E version 4.2 (which is what ships as part of the 4.5.1 nuget package) the runtime checks the TPA list and sees there is a version that is part of the platform.  When we try to load that version we see there is a downgrade in the version and fail.  The reason why adding it to the *.deps.json file fixes this issue is that at startup the highest version wins and is loadable.  \r\nThe poor diagnostics is noted and that is a problem we are actively looking to resolve.  For assemblies that ship as part of the NETCore.App package not easily overwritten in this way.  \r\nWhat is the core of your scenario?"
      },
      {
        "user": "gfraiteur",
        "created_at": "2018-07-16T09:13:38Z",
        "body": "Thank you for your reply.\r\n\r\nOur scenario is a post-compiler (PostSharp), which transforms the assembly being built. This assembly itself contains executable transformations (aspects with build-time logic), therefore we need to feed our application (a .NET Core App application in this case) with the proper list of dependencies. This assembly has of course a different set of dependencies than the post-compiler system.\r\n\r\nI think our scenario is just a sub-case of any \"plugin loader\" system, which typically uses Assembly.LoadFrom. I guess all plugin loaders would be affected by this limitation.\r\n\r\nAs a workaround, it seems we will need to generate `deps.json` on the fly from the MSBuild task before starting our post-compiler. Maybe a better solution is needed for the general case, i.e. to support Assembly.LoadFrom when the list of dependencies is not known upfront."
      },
      {
        "user": "jeffschwMSFT",
        "created_at": "2018-07-16T15:06:51Z",
        "body": "In this case if you wire up a AssemblyResolve event and return the 4.2 version of System.Threading.Tasks.Extensions then we will load it (regardless of the version number).  We are exploring options to make this better, once we have a proposal I will include you for comment."
      },
      {
        "user": "gfraiteur",
        "created_at": "2018-07-16T16:12:20Z",
        "body": "Thank you. Currently we're calling `Assembly.LoadFrom` from `AssemblyLoadContext.Default.Resolving`. I tried to use `AppDomain,AssemblyResolve` instead per your suggestion, but I did not work.\r\n\r\nI now have a workaround that generates some `postsharp.deps.json` before starting dotnet.exe and it seems to work, although it's a bit brutal."
      }
    ]
  },
  {
    "number": 10483,
    "title": "StringBuidler  support Offset(int length)",
    "created_at": "2018-06-09T08:20:03Z",
    "closed_at": "2020-01-31T04:23:45Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/runtime/issues/10483",
    "body": "New API:\r\n```C#\r\n//\r\npublic void Offset(int length){\r\n   if(length<0)\r\n   {\r\n       // throw........   \r\n   }\r\n   if(length>count){\r\n       // alloc more space\r\n   }else{ \r\n      // reset the offset\r\n       m_ChunkLength=length;\r\n   }\r\n}\r\n```\r\n\r\nUse:\r\n```C#\r\nStringBuilder builder = new StringBuilder();\r\nfor(int i=0;i<10;i+=1)\r\n{\r\n    builder.Append(array[i]);\r\n    builder.Append(',');\r\n}\r\nbuilder.Offset(builder.length-1);\r\nbuilder.Append(others);\r\n\r\n```",
    "comments_url": "https://api.github.com/repos/dotnet/runtime/issues/10483/comments",
    "author": "NMSAzulX",
    "comments": [
      {
        "user": "stephentoub",
        "created_at": "2018-06-09T12:00:51Z",
        "body": "I don't understand... what's the purpose of this proposed method? Why can't Length be used in your example?"
      },
      {
        "user": "NMSAzulX",
        "created_at": "2018-06-10T04:05:31Z",
        "body": "\u201c1\uff0c2\uff0c3\uff0c\u201d\r\nI want to remove the latest ',' \r\n\r\nresult:\r\n\u201c1\uff0c2\uff0c3\u201d\r\n"
      },
      {
        "user": "jkotas",
        "created_at": "2018-06-10T04:09:54Z",
        "body": "Replace `builder.Offset(builder.length-1);` with `builder.Length=builder.Length-1` in your example. It will remove the latest ','."
      },
      {
        "user": "jkotas",
        "created_at": "2018-06-10T04:12:30Z",
        "body": "Another way to remove the latest character from StringBuilder is: `builder.Remove(builder.Length - 1, 1)`."
      }
    ]
  },
  {
    "number": 26332,
    "title": "Missing dlls in bin/pkg/netcoreapp/runtime for BinPlaceNETCoreAppPackage=true",
    "created_at": "2018-05-31T13:56:07Z",
    "closed_at": "2020-01-31T21:31:34Z",
    "labels": [
      "question",
      "area-System.Memory"
    ],
    "url": "https://github.com/dotnet/runtime/issues/26332",
    "body": "Hello.\r\n\r\nLooks like `bin/runtime` and `bin/pkg/netcoreapp/runtime` contain different sets of dlls on `release/2.0.0` branch for `BinPlaceNETCoreAppPackage=true`. For example, System.Memory.dll is missing in `bin/pkg/netcoreapp/runtime` but exists in `bin/runtime`. On `master` branch System.Memory.dll exists in both folders.\r\n\r\nCould you, please, clarify if this is correct behavior or this should be fixed?\r\n\r\ncc @alpencolt @Dmitri-Botcharnikov ",
    "comments_url": "https://api.github.com/repos/dotnet/runtime/issues/26332/comments",
    "author": "gbalykov",
    "comments": [
      {
        "user": "gbalykov",
        "created_at": "2018-05-31T16:06:39Z",
        "body": "@karelz, these dlls also exist only in `bin/runtime`:\r\n\r\nOSExtensions.dll\r\nSOS.NETCore.dll\r\nSystem.CodeDom.dll\r\nSystem.ComponentModel.Composition.dll\r\nSystem.Composition.AttributedModel.dll\r\nSystem.Composition.Convention.dll\r\nSystem.Composition.Hosting.dll\r\nSystem.Composition.Runtime.dll\r\nSystem.Composition.TypedParts.dll\r\nSystem.Configuration.ConfigurationManager.dll\r\nSystem.Data.DataSetExtensions.dll\r\nSystem.Data.Odbc.dll\r\nSystem.Data.SqlClient.dll\r\nSystem.Diagnostics.EventLog.dll\r\nSystem.Diagnostics.PerformanceCounter.dll\r\nSystem.DirectoryServices.AccountManagement.dll\r\nSystem.DirectoryServices.dll\r\nSystem.DirectoryServices.Protocols.dll\r\nSystem.Drawing.Common.dll\r\nSystem.IO.Packaging.dll\r\nSystem.IO.Pipelines.dll\r\nSystem.IO.Ports.dll\r\nSystem.Json.dll\r\nSystem.Management.dll\r\nSystem.Net.Http.WinHttpHandler.dll\r\nSystem.Net.WebSockets.WebSocketProtocol.dll\r\nSystem.Reflection.Context.dll\r\nSystem.Runtime.Caching.dll\r\nSystem.Runtime.CompilerServices.Unsafe.dll\r\nSystem.Runtime.Intrinsics.Experimental.dll\r\nSystem.Security.Cryptography.Pkcs.dll\r\nSystem.Security.Cryptography.ProtectedData.dll\r\nSystem.Security.Cryptography.Xml.dll\r\nSystem.Security.Permissions.dll\r\nSystem.ServiceModel.Syndication.dll\r\nSystem.ServiceProcess.ServiceController.dll\r\nSystem.Text.Encoding.CodePages.dll\r\nSystem.Text.Encodings.Web.dll\r\nSystem.Threading.AccessControl.dll\r\nSystem.Threading.Channels.dll"
      },
      {
        "user": "weshaggard",
        "created_at": "2018-06-06T18:11:06Z",
        "body": ">Could you, please, clarify if this is correct behavior or this should be fixed?\r\n\r\nThat is the correct behavior. With BinPlaceNETCoreAppPackage=true it will create a subset of what we build in corefx under bin/pkg/netcoreapp/runtime. That subset maps directly to what is part of Microsoft.NETCore.App (aka the shared framework). In 2.0 System.Memory was not part of it but in 2.1 is is which is why you see the difference. "
      },
      {
        "user": "joperezr",
        "created_at": "2018-06-06T23:16:35Z",
        "body": "As @weshaggard said, basically bin/runtime will contain everything we build in a vertical that is not a reference assembly, or test project. Not all of that goes into the shared framework, which is why we have the other folder (bin/pkg/netcoreapp/runtime) which does have only the shared framework."
      }
    ]
  },
  {
    "number": 26310,
    "title": "Reflection is missing type information for ByRef generic arguments",
    "created_at": "2018-05-30T10:59:22Z",
    "closed_at": "2020-01-31T21:29:40Z",
    "labels": [
      "question",
      "area-System.Reflection"
    ],
    "url": "https://github.com/dotnet/runtime/issues/26310",
    "body": "`IsGenericType` for generic byRef arugments returns false. For both .NET and .NET Core. Because of that, it's impossible to generic arguments for such types.\r\n\r\n```cs\r\npublic class MyClass<T1, T2>{}\r\n\r\npublic class GenericByRef\r\n{\r\n    public void TheMethod(ref MyClass<int, short> _) { }\r\n}\r\n\r\nclass Program\r\n{\r\n    static void Main(string[] args)\r\n    {\r\n        var byRefGenericType = typeof(GenericByRef).GetMethod(nameof(GenericByRef.TheMethod)).GetParameters().Single().ParameterType;\r\n        \r\n        Console.WriteLine($\"FullName = {byRefGenericType.FullName}\");\r\n        Console.WriteLine($\"Name = {byRefGenericType.Name}\");\r\n        Console.WriteLine($\"IsGenericType = {byRefGenericType.IsGenericType}\");\r\n        Console.WriteLine($\"UnderlyingSystemType.IsGenericType = {byRefGenericType.UnderlyingSystemType.IsGenericType}\");\r\n    }\r\n}\r\n```\r\n\r\nPrints:\r\n\r\n```log\r\nFullName = Tests.MyClass`2[[System.Int32, System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e],[System.Int16, System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]&\r\nName = MyClass`2&\r\nIsGenericType = False\r\nUnderlyingSystemType.IsGenericType = False\r\n```\r\n\r\n@jkotas @VSadov do you have any idea how can I get the generic arguments in that case?",
    "comments_url": "https://api.github.com/repos/dotnet/runtime/issues/26310/comments",
    "author": "adamsitnik",
    "comments": [
      {
        "user": "jkotas",
        "created_at": "2018-05-30T11:57:59Z",
        "body": "Try:\r\n\r\n```\r\n        Console.WriteLine($\"GetElementType() = {byRefGenericType.GetElementType()}\");\r\n        Console.WriteLine($\"GetElementType().IsGenericType = {byRefGenericType.GetElementType().IsGenericType}\");\r\n```"
      }
    ]
  },
  {
    "number": 25639,
    "title": "System.Security.Cryptography.Pkcs '1.2.840.113549.1.1.5' is not a known hash algorithm.",
    "created_at": "2018-03-27T13:12:38Z",
    "closed_at": "2020-01-31T20:33:37Z",
    "labels": [
      "question",
      "area-System.Security"
    ],
    "url": "https://github.com/dotnet/runtime/issues/25639",
    "body": "i'm trying to compute a cms SHA1RSA using the pre release version(4.5.0-preview1-26216-02) of System.Security.Cryptography.Pkcs.\r\n\r\nOid.FromFriendlyName(\"SHA1RSA\",OidGroup.SignatureAlgorithm) returns the corect digest algorithem, but upon calling encode, i get the exception that i,m not using any known hash algorithm.\r\n\r\nIs there any short term plan to incorporate it?\r\n\r\nEncoding snippet:----------\r\nprotected byte[] GenerateSignature(byte[] fileContent)\r\n        {\r\n            CmsSigner signer = new CmsSigner(SubjectIdentifierType.IssuerAndSerialNumber, ClientCert);\r\n            SignedCms signedCms = new SignedCms(new ContentInfo(fileContent), false);\r\n            signer = new CmsSigner(SubjectIdentifierType.IssuerAndSerialNumber, ClientCert);\r\n            signer.DigestAlgorithm = Oid.FromFriendlyName(\"SHA1RSA\",OidGroup.SignatureAlgorithm);\r\n            signedCms.ComputeSignature(signer, false);\r\n            var signature = signedCms.Encode();\r\n            return signature;\r\n        }",
    "comments_url": "https://api.github.com/repos/dotnet/runtime/issues/25639/comments",
    "author": "hozjanmarko",
    "comments": [
      {
        "user": "bartonjs",
        "created_at": "2018-03-27T13:23:29Z",
        "body": "SHA1RSA is a signature algorithm, not a hash algorithm.  The correct value to use is the SHA-1 OID (1.3.14.3.2.26).  (That results in using SHA1RSA if the signer key is an RSA key, but the API here expects the parts separately)"
      },
      {
        "user": "bartonjs",
        "created_at": "2018-03-30T13:20:22Z",
        "body": "```c#\r\nprotected byte[] GenerateSignature(byte[] fileContent)\r\n{\r\n    CmsSigner signer = new CmsSigner(SubjectIdentifierType.IssuerAndSerialNumber, ClientCert);\r\n    SignedCms signedCms = new SignedCms(new ContentInfo(fileContent), false);\r\n    signer = new CmsSigner(SubjectIdentifierType.IssuerAndSerialNumber, ClientCert);\r\n\r\n    // instead of\r\n    //signer.DigestAlgorithm = Oid.FromFriendlyName(\"SHA1RSA\",OidGroup.SignatureAlgorithm);\r\n    // use\r\n    signer.DigestAlgorithm = Oid.FromFriendlyName(\"SHA1\", OidGroup.HashAlgorithm);\r\n    // or\r\n    //signer.DigestAlgorithm = new Oid(\"1.3.14.3.2.26\");\r\n\r\n    signedCms.ComputeSignature(signer, false);\r\n    var signature = signedCms.Encode();\r\n    return signature;\r\n}\r\n```"
      }
    ]
  },
  {
    "number": 24982,
    "title": "Crypto provider wrappers in System.Security.Cryptography.Algorithms",
    "created_at": "2018-02-09T10:36:37Z",
    "closed_at": "2020-01-31T19:40:31Z",
    "labels": [
      "question",
      "area-System.Security"
    ],
    "url": "https://github.com/dotnet/runtime/issues/24982",
    "body": "PR dotnet/corefx#12964 added crypto wrappers.\r\n\r\nI'm able to use them targeting netstandard 2.x but not for netstandard1.x.\r\n\r\nI see that those providers are not included as part of `System.Security.Cryptography.Algorithms` package (v4.3.1). Would it be possible to include them as part of the nuget package?",
    "comments_url": "https://api.github.com/repos/dotnet/runtime/issues/24982/comments",
    "author": "jorgebay",
    "comments": [
      {
        "user": "bartonjs",
        "created_at": "2018-02-09T17:43:14Z",
        "body": "Are you having a compilation problem, or a runtime problem?"
      },
      {
        "user": "jorgebay",
        "created_at": "2018-02-09T18:28:13Z",
        "body": "Its a compilation issue, wrappers are not available on net standard 1.x and not included in `System.Security.Cryptography.Algorithms` package."
      },
      {
        "user": "bartonjs",
        "created_at": "2018-02-09T18:46:12Z",
        "body": "Okay, that's what I would expect.  The wrappers were added for netstandard 2.0.  There's no expectation that they will be available when targeting lower versions.\r\n\r\nWhether using netstandard 1.x or 2.0 the recommended pattern is to use the algorithm factory methods.\r\n\r\n| Replace This | With This |\r\n| --- | --- |\r\n| new SHA1CryptoServiceProvider() | SHA1.Create() |\r\n| new SHA256CryptoServiceProvider() | SHA256.Create() |\r\n| new SHA384CryptoServiceProvider() | SHA384.Create() |\r\n| new SHA512CryptoServiceProvider() | SHA512.Create() |\r\n| new AesCryptoServiceProvider() | Aes.Create() |\r\n\r\netc\r\n"
      }
    ]
  },
  {
    "number": 24764,
    "title": "Passing additional CMake arguments to Native build",
    "created_at": "2018-01-22T12:47:37Z",
    "closed_at": "2020-01-31T19:22:14Z",
    "labels": [
      "question",
      "area-Infrastructure-libraries",
      "os-linux"
    ],
    "url": "https://github.com/dotnet/runtime/issues/24764",
    "body": "`build-native.sh` has options `cmakeargs` for passing additional arguments to CMake. But if I want add `-D_FORTIFY_SOURCE=2` option to `CXXFLAGS` it will be applied to `corefx/src/Native/Unix/configure.cmake` (which cause errors on test programs compilation).\r\nIf I add this option to `corefx/src/Native/Unix/CMakeLists.txt` it will applied to source code only (as expected).\r\n\r\nIs there other way to pass this and others options to build without patching source code? If not is it possible to change `cmakeargs` behavior or add some other logic?\r\n\r\nThis behavior is the same for CoreCLR too.\r\n\r\ncc @BruceForstall @jkotas \r\ncc @chunseoklee",
    "comments_url": "https://api.github.com/repos/dotnet/runtime/issues/24764/comments",
    "author": "alpencolt",
    "comments": [
      {
        "user": "janvorli",
        "created_at": "2018-01-24T01:05:12Z",
        "body": "Hmm, I was pretty sure I've replied to this yesterday, but the window probably get lost before I have sent it.\r\nI am not sure I understand how defining a cmake variable using the cmakeargs automatically results in setting the compiler option. You need to have your own code in the cmake scripts to set the compiler define if the cmake variable is set, right? And then you can choose where to put it and what to influence. @alpencolt can you please explain to me what I am missing?\r\n"
      },
      {
        "user": "alpencolt",
        "created_at": "2018-01-24T17:34:34Z",
        "body": "@janvorli Tizen project is needed to set some global compiler and linker options (e.g. `D_FORTIFY_SOURCE=2`) for all modules included to OS, sometimes it might be list of options (`-fstack-protector-strong -D_FORTIFY_SOURCE=2` or others). This list can be different for different releases and we don't really modify CoreCL/FX sources for this purpose(it's worth case).\r\n\r\nBetter option is passing this additional options and defines through global variable or some command line key and read them in `CMakeLists.txt`. The main point we are needed is applying this compiler/linker flags only to CoreCLR/FX source and not to `configure.cmake`. Since `configure.cmake` failed on easiest checks.\r\n`cmakeargs` option doesn't provide necessary functionality (may be we use it wrong way?). It isn't pass arguments as we expected  and it doesn't work with list of options (e.g. `CXXFLAGS+=-fstack-protector-strong -D_FORTIFY_SOURCE=2`).\r\n\r\nCan we solve this issue by existed tools? If not can we add this functionality to upstream?"
      },
      {
        "user": "janvorli",
        "created_at": "2018-01-24T21:26:43Z",
        "body": "@alpencolt I think the best solution for this would be to pass a single cmake variable containing the compiler options and then using them in the CMakeLists.txt where you want them to take effect.\r\nSo, we could add support for that to coreclr / corefx and then you can pass whatever options you want through that without further touching the sources in the future.\r\nSo we would add a cmake variable named e.g. `CLR_ADDITIONAL_COMPILER_OPTIONS`. On the build command line, you would add `cmakeargs \"-DCLR_ADDITIONAL_COMPILER_OPTIONS=-fstack-protector-strong;-D_FORTIFY_SOURCE=2\"`. Please note the `;` separating the options and the quotes around the whole option, they are necessary to ensure that the options are correctly passed to cmake.\r\nIn the compileoptions.cmake, we would add `add_compile_options(${CLR_ADDITIONAL_COMPILER_OPTIONS})` inside the initial `if (CLR_CMAKE_PLATFORM_UNIX)`.\r\nThat should be all that's needed to enable passing in any compiler options you want."
      },
      {
        "user": "alpencolt",
        "created_at": "2018-01-31T18:54:23Z",
        "body": "@janvorli `corefx/Tools/run.exe` which is called from `corefx/run.sh` doesn't keep quotes on Linux. So I call for example:\r\n```\r\n./build-native.sh -Release -buildArch=armel -- clang3.8 cmakeargs '-DCLR_FIRST=1 -DCLR_SECOND=2'\r\n```\r\nString `-DCLR_FIRST=1 -DCLR_SECOND=2` can be handled as one argument (by using `$7` or other number depending from position) in all scripts before `corefx/Tools/run.exe`. But after `-DCLR_FIRST=1 ` and `-DCLR_SECOND=2` are two different arguments (`$7` and `$8`).\r\nDoes it OK? How can I fix `run.exe` behavior?\r\n"
      },
      {
        "user": "janvorli",
        "created_at": "2018-02-01T16:13:01Z",
        "body": "The solution is simple - pass the two defines separately:\r\n```sh\r\n./build-native.sh -Release -buildArch=armel -- clang3.8 cmakeargs -DCLR_FIRST=1 cmakeargs -DCLR_SECOND=2\r\n```"
      }
    ]
  },
  {
    "number": 24279,
    "title": "System.IO.FileNotFoundException: Could not load file or assembly 'System.Net.Http, Version=4.1.1.0",
    "created_at": "2017-11-30T00:14:33Z",
    "closed_at": "2020-01-31T18:44:50Z",
    "labels": [
      "question",
      "area-System.Net.Http"
    ],
    "url": "https://github.com/dotnet/runtime/issues/24279",
    "body": "I recently created a .NET Core 2.0 library that multitargeted `net46`. It included this in the .csproj file:\r\n\r\n```\r\n  <ItemGroup Condition=\"'$(TargetFramework)'=='net46'\">\r\n    <Reference Include=\"System.Net.Http\" />\r\n  </ItemGroup>\r\n\r\n  <ItemGroup Condition=\"'$(TargetFramework)'=='netstandard2.0'\">\r\n    <PackageReference Include=\"System.Net.Http\" Version=\"4.3.3\" />\r\n    <PackageReference Include=\"System.Net.Primitives\" Version=\"4.3.0\" />\r\n    <PackageReference Include=\"System.Net.Requests\" Version=\"4.3.0\" />\r\n    <PackageReference Include=\"System.Net.Sockets\" Version=\"4.3.0\" />\r\n  </ItemGroup>\r\n```\r\n\r\nI referenced this library is a .NET Framework 4.7 console app and get this exception:\r\n```\r\nUnhandled Exception: System.IO.FileNotFoundException: Could not load file or assembly 'System.Net.Http, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a' or one of its dependencies. The system cannot find the file specified. ---> System.IO.FileNotFoundException: Could not load file or assembly 'System.Net.Http, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a' or one of its dependencies. The system cannot find the file specified.\r\n```\r\n\r\nI didn't see any warnings in the error list, but I decided to check the build log and found a conflict.\r\n\r\nThis is what I see in the detailed build log:\r\n```\r\n1>  There was a conflict between \"System.Net.Http, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a\" and \"System.Net.Http, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a\".\r\n1>      \"System.Net.Http, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a\" was chosen because it was primary and \"System.Net.Http, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a\" was not.\r\n1>      References which depend on \"System.Net.Http, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a\" [C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.7\\System.Net.Http.dll].\r\n1>          C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.7\\System.Net.Http.dll\r\n1>            Project file item includes which caused reference \"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.7\\System.Net.Http.dll\".\r\n1>              System.Net.Http\r\n```\r\n\r\nMy `App.config` includes a redirect which should have been used\r\n```\r\n<dependentAssembly>\r\n        <assemblyIdentity name=\"System.Net.Http\" publicKeyToken=\"b03f5f7f11d50a3a\" culture=\"neutral\" />\r\n        <bindingRedirect oldVersion=\"0.0.0.0-4.1.1.0\" newVersion=\"4.1.1.0\" />\r\n      </dependentAssembly>\r\n```\r\n\r\nWhat I don't fully understand in why System.Net.Http includes a reference to itself. Is this corruption of some sort or am I missing something?",
    "comments_url": "https://api.github.com/repos/dotnet/runtime/issues/24279/comments",
    "author": "shravan2x",
    "comments": [
      {
        "user": "karelz",
        "created_at": "2017-11-30T00:39:25Z",
        "body": "System.Net.Http.dll 4.1.1.0 shipped in nuget package System.Net.Http 4.3.0. It caused a problem on .NET Framework - see dotnet/runtime#18280 for details.\r\nWe shipped updated package System.Net.Http 4.3.1 which passes through to the underlying platform on .NET Framework (with assembly version 4.0.0.0).\r\nI assume something in your app is referencing older nuget package with higher assembly version. You need a binding redirect like this:\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n<configuration>\r\n    <runtime>\r\n        <assemblyBinding xmlns=\"urn:schemas-microsoft-com:asm.v1\">\r\n            <dependentAssembly>\r\n                <assemblyIdentity name=\"System.Net.Http\" culture=\"neutral\" publicKeyToken=\"b03f5f7f11d50a3a\" />\r\n                <bindingRedirect oldVersion=\"0.0.0.0-4.1.1.0\" newVersion=\"4.0.0.0\" />\r\n            </dependentAssembly>\r\n        </assemblyBinding>\r\n    </runtime>\r\n</configuration>\r\n```"
      },
      {
        "user": "shravan2x",
        "created_at": "2017-11-30T01:24:34Z",
        "body": "@karelz The issue is that I do not use System.Net.Http 4.3.0 anywhere. My multi target for `netstandard2.0` uses version 4.3.3 and the reference for `net46` directly uses an assembly reference `<Reference Include=\"System.Net.Http\" />`.\r\n\r\nAlso, the project that uses the library already has the binding redirect you mentioned.\r\n```\r\n      <dependentAssembly>\r\n        <assemblyIdentity name=\"System.Net.Http\" publicKeyToken=\"b03f5f7f11d50a3a\" culture=\"neutral\" />\r\n        <bindingRedirect oldVersion=\"0.0.0.0-4.1.1.0\" newVersion=\"4.1.1.0\" />\r\n      </dependentAssembly>\r\n```\r\n\r\n**EDIT**: Nevermind I didn't notice the `newVersion` in your post was different than mine. Your fix seems to work for me.\r\n\r\nI vaguely remember encountering this issue in the past; it might help future users to maintain a wiki page for this issue with enough keywords that it shows up in a google search.\r\n\r\nThanks for the help!"
      },
      {
        "user": "fernandozamoraj",
        "created_at": "2020-05-04T15:14:19Z",
        "body": "In my case the team was using Visual Studio 2019.  I was using VS 2015 because that is what the sln would default to.  Once I opened in in VS 2019 it worked.  I guess that's because of the references in one applicaiton vs. the other.  And actually in my case it was the System.Net.Sockets file."
      }
    ]
  },
  {
    "number": 23265,
    "title": "C# new operate bug?",
    "created_at": "2017-08-20T05:49:39Z",
    "closed_at": "2020-01-31T17:27:12Z",
    "labels": [
      "question",
      "area-Meta"
    ],
    "url": "https://github.com/dotnet/runtime/issues/23265",
    "body": "```c#\r\npublic class ListTest\r\n{\r\n    public List<int> MyList;\r\n    public ListTest()\r\n    {\r\n        MyList = new List<int> { 1, 2, 3 };\r\n    }\r\n}\r\n\r\nvar listTest = new ListTest()\r\n{\r\n    MyList = {4,5,6}\r\n};\r\n```\r\n\r\nDo you know the value of listTest.MyList ???\r\n\r\nIt would be {1,2,3,4,5,6}   (on .net framework 4.6.1)\r\n\r\nSomeone can explain that??\r\n\r\n[EDIT] Fixed proper code formatting by @karelz",
    "comments_url": "https://api.github.com/repos/dotnet/runtime/issues/23265/comments",
    "author": "TimRowe",
    "comments": [
      {
        "user": "mikedn",
        "created_at": "2017-08-20T05:59:32Z",
        "body": "This is really a C# language question. Collection initialization works by calling collection's Add method so your `MyList = {4,5,6}` is really:\r\n```c#\r\nlistTest.MyList.Add(4);\r\nlistTest.MyList.Add(5);\r\nlistTest.MyList.Add(6);\r\n```\r\nBut more importantly:\r\n> C# new operate bug?\r\n\r\nWhat `new`? There's no `new` in `MyList = {4,5,6}` :smile: So there's no reason to expect a new list containing 4, 5 and 6 to be created.\r\n\r\n[EDIT] Added C# syntax highlight by @karelz"
      },
      {
        "user": "TimRowe",
        "created_at": "2017-08-20T06:08:18Z",
        "body": "It's really a big pit !  Someone would forget `new` , but they think they have done that. It's better to raise error without `new` ."
      },
      {
        "user": "mikedn",
        "created_at": "2017-08-20T06:18:39Z",
        "body": ">  It's better to raise error without new.\r\n\r\nThat would block a very common scenario - initializing readonly collection properties:\r\n```C#\r\npublic class ListTest\r\n{\r\n    public List<int> MyList { get; } = new List<int>();\r\n}\r\nvar listTest = new ListTest\r\n{\r\n     // You can't do = new List<int> { 4, 5, 6 } here because the property is readonly\r\n    MyList = { 4, 5, 6 }\r\n};\r\n```"
      },
      {
        "user": "JonHanna",
        "created_at": "2017-08-20T11:25:01Z",
        "body": "From the C#5 spec (all specs after initializers were introduced have similar language):\r\n\r\n> A member initializer that specifies an object initializer after the equals sign is a nested object initializer, i.e. an initialization of an embedded object. Instead of assigning a new value to the field or property, the assignments in the nested object initializer are treated as assignments to members of the field or property. Nested object initializers cannot be applied to properties with a value type, or to read-only fields with a value type.\r\n> \r\n> A member initializer that specifies an object initializer after the equals sign is a nested object initializer, i.e. an initialization of an embedded object. Instead of assigning a new value to the field or property, the assignments in the nested object initializer are treated as assignments to members of the field or property. Nested object initializers cannot be applied to properties with a value type, or to read-only fields with a value type.\r\nA member initializer that specifies a collection initializer after the equals sign is an initialization of an embedded collection. Instead of assigning a new collection to the field or property, the elements given in the initializer are added to the collection referenced by the field or property. The field or property must be of a collection type that satisfies the requirements specified in \u00a77.6.10.3.\r\n\r\nSo the code:\r\n\r\n```c#\r\nvar listTest = new ListTest()\r\n{\r\n    MyList = {4,5,6}\r\n};\r\n```\r\n\r\nShould be equivalent to:\r\n\r\n```c#\r\nvar listTest = new ListTest();\r\nlistTest.MyList.Add(4);\r\nlistTest.MyList.Add(5);\r\nlistTest.MyList.Add(6);\r\n```\r\n\r\nSo `listTest.MyList` should contain `1, 2, 3, 4, 5, 6`. Anything else would be a bug.\r\n\r\n> It's really a big pit ! Someone would forget `new`, but they think they have done that. It's better to raise error without `new`.\r\n\r\nPeople can forget all manner of things, but if the definition of `ListTest` defaults to setting a `MyList` to `{1, 2, 3}` then presumably there's a reason for that. It's just as sensible to use that as a starting point to then add more numbers as it is to use `new` to set something completely different, and the language allows both to be expressed.\r\n\r\nThe code is also analogous to the way that when using a collection initialiser on its own first either `new TheType()` is called or whatever constructor is explicitly used, and then the further items added. E.g.:\r\n\r\n```c#\r\nvar starter = new[] { 1, 2, 3 };\r\nvar list = new List<int>(starter) { 4, 5, 6 };\r\nforeach (int item in list)\r\n{\r\n\tConsole.WriteLine(item);\r\n}\r\n```\r\nOutputs the numbers 1 through 6.\r\n\r\nUltimately though the biggest problem would be that if nested collection initialisers didn't go through the constructor included in `ListTest` would break encapsulation. Consider:\r\n\r\n```c#\r\npublic class ListTest\r\n{\r\n\tpublic readonly AddOnlyList<int> MyList;\r\n\tpublic ListTest()\r\n\t{\r\n\t\tMyList = new AddOnlyList<int> { 1, 2, 3 };\r\n\t}\r\n}\r\n```\r\n\r\nIt is part of the class invariant of `ListTest` that `MyList` starts with `1, 2, 3`. If outside code is allowed to break the encapsulation and force other values into it then `ListTest` no longer controls its own invariants and can no longer be reasoned about by its author.\r\n\r\nAlso, there's no reason why a type with `Add()` that implements `IEnumerable` need have a parameterless constructor, so no reason why having the code in the example equivalent to `new TheListType { 4, 5, 6 }` should even be valid.\r\n\r\n[EDIT] Fixed C# syntax highlighting by @karelz"
      }
    ]
  },
  {
    "number": 22442,
    "title": "Quiet msbuild mode",
    "created_at": "2017-06-23T04:52:09Z",
    "closed_at": "2020-01-31T16:30:54Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/runtime/issues/22442",
    "body": "Can we get a build mode, maybe `msbuild /T:BuildAndTest /P:Quiet=true` that gets rid of all the build logs and just prints out the test results?\r\n\r\nThis is useful to compare test failures and I don't really care about what's compiling.",
    "comments_url": "https://api.github.com/repos/dotnet/runtime/issues/22442/comments",
    "author": "hughbe",
    "comments": [
      {
        "user": "ViktorHofer",
        "created_at": "2017-06-23T09:45:54Z",
        "body": "Yes verbosity switch set to minimal: `/v:m`"
      }
    ]
  },
  {
    "number": 7731,
    "title": "Load unmanaged static dll in load context",
    "created_at": "2017-03-27T11:06:45Z",
    "closed_at": "2020-01-31T01:27:05Z",
    "labels": [
      "question",
      "area-AssemblyLoader-coreclr"
    ],
    "url": "https://github.com/dotnet/runtime/issues/7731",
    "body": "I have native unmanaged dll which is static and must be loaded each time when I need library to do some work if i want to run it in parallel. In .NET I would use AppDomain and load this dll when i need it, but in NET Core AppDomains are gone (for now). I have looked at AssemblyLoadContext but there is no proper documentation with LoadUnmanagedDll. Can this be done in netstandard1.6?",
    "comments_url": "https://api.github.com/repos/dotnet/runtime/issues/7731/comments",
    "author": "rdvojmoc",
    "comments": [
      {
        "user": "jkotas",
        "created_at": "2017-03-27T16:32:06Z",
        "body": "Could you please explain a bit more why you are using AppDomains in .NET Framework? Why can't you just load the unmanaged dll within the same AppDomain?"
      },
      {
        "user": "rdvojmoc",
        "created_at": "2017-03-27T16:38:25Z",
        "body": " Currently code is called with PInvoke and is working perfectly. Problem is because nature of this unmanged dll (it's static) written in C, when I try to call it in parallel throws AccessViolationException because two or more task wants to access same memory.\r\n\r\nIf I could load dll for each time that in some context and then call PInvoke on that this problem would be gone. At least that is my idea. \r\n\r\n"
      },
      {
        "user": "jkotas",
        "created_at": "2017-03-27T16:45:16Z",
        "body": "The unmanaged .dll is always loaded once. It is constrain imposed by the OS loader, not much we can do about it in .NET. It is same for both .NET Framework and .NET Core. If you load same unmanaged .dll from two different appdomain in full .NET Framework, both AppDomains will get the same instance."
      },
      {
        "user": "rdvojmoc",
        "created_at": "2017-03-27T17:19:13Z",
        "body": "Thanks for quick answer. Based on your answer only way to avoid this error, is to implement synchronized access to this unmanaged dll."
      },
      {
        "user": "jkotas",
        "created_at": "2017-03-27T17:25:15Z",
        "body": "Yes. The other alternatives maybe to run the unmanaged dll in separate process, or to have multiple physical copies (different paths on disk) of this unmanaged .dll."
      }
    ]
  },
  {
    "number": 2596,
    "title": "Programatically Getting the path to the directory containing the framework?",
    "created_at": "2017-02-10T19:35:58Z",
    "closed_at": "2020-01-30T20:36:50Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/runtime/issues/2596",
    "body": "Ok, I have a reaaaaly strange question now.\r\n\r\nWe have app that generates c# code. \r\n\r\nWe have unit tests that use the generator to generate c# code, then compiles the code using Roslyn, and then loads the generated assembly and  uses reflection to inspect the code to check that things went right.\r\n\r\nWhen we were running on desktop clr, we used `AppDomain.GetAssemblies()` to get the assemblies that were loaded and added them to the Roslyn compiler as references.\r\n\r\nSince we're now on `netcoreapp1.0` we don't have that. \r\n\r\nFor some assemblies, I was able to cheat a bit and use stuff like `typeof(RestException).GetAssembly().Location,`\r\n\r\nBut in the end I needed to get a handful of assemblies from the current runtime folder.\r\n\r\nI can hardcode them like this:\r\n\r\n``` csharp\r\n        protected static readonly string[] _assemblies = new[] {\r\n            \r\n            @\"C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App\\1.0.3\\System.Runtime.dll\",\r\n            @\"C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App\\1.0.3\\System.Net.Http.dll\",\r\n            @\"C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App\\1.0.3\\mscorlib.dll\",\r\n            @\"C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App\\1.0.3\\System.Threading.Tasks.dll\",\r\n            @\"C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App\\1.0.3\\System.Net.Primitives.dll\",\r\n            @\"C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App\\1.0.3\\System.Collections.dll\",\r\n            @\"C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App\\1.0.3\\System.Text.Encoding.dll\",\r\n            @\"C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App\\1.0.3\\System.Text.RegularExpressions.dll\",\r\n            @\"C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App\\1.0.3\\System.IO.dll\",\r\n        ]\r\n```\r\n\r\nAnd it works.\r\n\r\nThis only works because I know the `C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App\\1.0.3\\` part of the path.\r\n\r\nIs there *any means* to find out that path for the currently executing `netcoreapp1.0` program, so I can locate these programatically?",
    "comments_url": "https://api.github.com/repos/dotnet/runtime/issues/2596/comments",
    "author": "fearthecowboy",
    "comments": [
      {
        "user": "weshaggard",
        "created_at": "2017-02-10T19:48:25Z",
        "body": "One approach that may work is to do `typeof(object).GetAssembly().Location` and then traverse for `*.dll` in that directory which will give you all the assemblies next to the core assembly. That will give you all the potential references not necessary what is loaded at runtime so depending on your scenario that might be enough. "
      },
      {
        "user": "weshaggard",
        "created_at": "2017-02-10T19:49:38Z",
        "body": "Actually thinking about that a little more that would also pick-up native dlls which you don't want to pass to the compiler but you can probably do a little further filtering to things that start with \"System\" or \"Microsoft\". "
      },
      {
        "user": "fearthecowboy",
        "created_at": "2017-02-10T19:50:13Z",
        "body": "I've been trying that. \r\n\r\nI can't seem to get one in the framework folder. They are all showing up as the ones in the `nuget` packages folder.\r\n\r\nHave an idea of a type that's in `mscorlib` (but doesn't come from a pkg elsewhere?)\r\n\r\n\r\n"
      },
      {
        "user": "fearthecowboy",
        "created_at": "2017-02-10T19:53:17Z",
        "body": "The closest I've come so far is :\r\n\r\n``` csharp\r\n        protected static string DOTNET = System.IO.Path.GetDirectoryName( System.Diagnostics.Process.GetCurrentProcess().MainModule.FileName);\r\n        protected static string FRAMEWORK= Path.Combine( DOTNET, \"shared\", \"Microsoft.NETCore.App\", \"1.0.3\" );\r\n\r\n        protected static readonly string[] _assemblies = new[] {\r\n            \r\n            Path.Combine(FRAMEWORK, \"System.Runtime.dll\"),\r\n            Path.Combine(FRAMEWORK, \"System.Net.Http.dll\"),\r\n            Path.Combine(FRAMEWORK, \"mscorlib.dll\"),\r\n            Path.Combine(FRAMEWORK, \"System.Threading.Tasks.dll\"),\r\n            Path.Combine(FRAMEWORK, \"System.Net.Primitives.dll\"),\r\n            Path.Combine(FRAMEWORK, \"System.Collections.dll\"),\r\n            Path.Combine(FRAMEWORK, \"System.Text.Encoding.dll\"),\r\n            Path.Combine(FRAMEWORK, \"System.Text.RegularExpressions.dll\"),\r\n            Path.Combine(FRAMEWORK, \"System.IO.dll\"),\r\n        ]\r\n```\r\n\r\nBut I'd hate to hard-code the '1.0.3' part of that ..."
      },
      {
        "user": "weshaggard",
        "created_at": "2017-02-10T19:54:43Z",
        "body": "How are you running? If you are doing \"dotnet run\" it does do a hybrid of loading assemblies from packages instead of the shared framework. If you do \"dotnet <yourapp>\" I think the approach I used would work.\r\n\r\nI'm not sure what a great way to do that is for \"dotnet run\" scenario. \r\n\r\nUnfortunately we don't expose the shared framework version anywhere, especially not in \"dotnet run\" scenarios because it doesn't run on the shared framework. "
      },
      {
        "user": "fearthecowboy",
        "created_at": "2017-02-10T20:02:02Z",
        "body": "It's unit tests, so it's run with `dotnet test`\r\n\r\n"
      },
      {
        "user": "weshaggard",
        "created_at": "2017-02-10T20:19:34Z",
        "body": "Yeah I guess there isn't any great solution right now. Good news is that AppDomain.GetAssemblies() will be back in .NET Core 2.0.\r\n\r\nFor now in 1.0 you try another hack like getting the FX deps file location that the host sets up via `AppContext.GetData(\"FX_DEPS_FILE\")` and getting the directory from that. I believe that might get you what you want for your scenarios right now. "
      },
      {
        "user": "fearthecowboy",
        "created_at": "2017-02-23T18:47:28Z",
        "body": "Yes, I'm doing pretty good with this approach."
      }
    ]
  },
  {
    "number": 19682,
    "title": "EntryPointNotFoundException on .NET Core on Linux",
    "created_at": "2016-12-14T15:46:38Z",
    "closed_at": "2020-01-31T13:33:54Z",
    "labels": [
      "question",
      "area-System.Runtime.InteropServices"
    ],
    "url": "https://github.com/dotnet/runtime/issues/19682",
    "body": "I want to prepare a wrapper library for a 3rd party library on linux\r\n\r\nI've created 2 simple functions, and from another C++ program they execute without a problem\r\n\r\nalso .. I've tried to use system library (libc) and it works without issues:\r\n\r\n[System.Runtime.InteropServices.DllImport(\"libc\")]\r\npublic static extern int puts(string str);\r\n\r\nputs(\"some test string\"); // <- this works\r\n\r\nhowever, when I try to use my 2 simple function from my wrapper library, I'm getting EntryPointNotFoundException exception\r\n\r\nhere is the code:\r\n\r\n[System.Runtime.InteropServices.DllImport(\"mywrapper\")]\r\npublic static extern void TestFunc1();\r\n[System.Runtime.InteropServices.DllImport(\"mywrapper\")]\r\npublic static extern string TestFunc2();\r\n\r\nUnhandled Exception: System.EntryPointNotFoundException: Unable to find an entry point named 'TestFunc1' in DLL 'mywrapper'.\r\n\r\nthe library is found, and from C++ these two functions just work\r\nalso ... a DLLImport puts(const char *) works in .NET Core\r\n\r\nonly my library has this problem\r\n\r\nany ideas ?\r\n",
    "comments_url": "https://api.github.com/repos/dotnet/runtime/issues/19682/comments",
    "author": "rottor12",
    "comments": [
      {
        "user": "janvorli",
        "created_at": "2016-12-14T19:01:58Z",
        "body": "@rottor12 do you have extern \"C\" on your functions? If not, their names would be mangled."
      },
      {
        "user": "rottor12",
        "created_at": "2016-12-14T19:42:21Z",
        "body": "@janvorli I was missing extern \"C\" before method signatures, but .. after the change to extern \"C\", and ldconfig, I'm still getting the same error"
      },
      {
        "user": "janvorli",
        "created_at": "2016-12-14T19:49:51Z",
        "body": "@rottor12 could you please run `objdump -T mywrapper.so` and paste here the results?"
      },
      {
        "user": "rottor12",
        "created_at": "2016-12-14T20:02:37Z",
        "body": "I had another copy of an old library in the .NET Core project, and that is why the error still persisted\r\n\r\nonce I removed it (so it could load a version from /usr/lib64) it run the first function correctly, the second produced an error, but that I'll handle on my own\r\n\r\nbig thanks for your help !!\r\n"
      }
    ]
  },
  {
    "number": 18716,
    "title": "Strange dependency behavior",
    "created_at": "2016-09-26T22:39:51Z",
    "closed_at": "2020-01-31T12:38:20Z",
    "labels": [
      "question",
      "area-Meta"
    ],
    "url": "https://github.com/dotnet/runtime/issues/18716",
    "body": "Hi all,\n\nI have a library build for netstandard1.4, which corresponds to .NET 461.\nThen I build a desktop console application with .NET 4.5 and added reference to named library.\nAll worked fine.\n\nBut, this should not work, because v4.5 should not be able to use netstandard1.4.  Previously this was not the case.\nIs tat same new expected behavior?\n\nThanks\n",
    "comments_url": "https://api.github.com/repos/dotnet/runtime/issues/18716/comments",
    "author": "ddobric",
    "comments": [
      {
        "user": "mellinoe",
        "created_at": "2016-09-26T22:46:08Z",
        "body": "And how are you building/running your project? NuGet would prevent you from installing such a library into your console application, but that doesn't necessarily mean that you couldn't directly reference the assembly, build against it, and deploy some facades to make it work at runtime. And if your netstandard1.4 assembly didn't happen to use anything that wasn't available in .NET 4.5, then you might even be able to run against it successfully. There's always some subset of stuff in a framework that would be safe to use in a lower version of that framework, but it is also pretty easy to mess up, and things will blow up if you use an API that isn't available on the lower framework.\n"
      },
      {
        "user": "ddobric",
        "created_at": "2016-09-27T19:43:07Z",
        "body": "I use VS and also command line (dotnet build) for build. I'm referencing assemblies directly, because currently it is not possible to add project reference to netcore libs directly from \"desktop projects\" (i.e.: console application, lib etc.)\n\nSo, if I understood You correctly, by using of direct references, there is no framework check, which was working previously?\nI'm fine with this. Just wanted to know if this is by design or just temporary implementation. \n\nThanks\n"
      },
      {
        "user": "tarekgh",
        "created_at": "2017-03-02T20:01:37Z",
        "body": "> So, if I understood You correctly, by using of direct references, there is no framework check, which was working previously? I'm fine with this. Just wanted to know if this is by design or just temporary implementation.\r\n\r\nYes if you reference the library directly, then there is no check will be done but expect you may get some runtime failures. "
      }
    ]
  },
  {
    "number": 18284,
    "title": "Confusing empty directories in some runtime packages",
    "created_at": "2016-08-24T22:09:42Z",
    "closed_at": "2020-01-31T12:14:12Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/runtime/issues/18284",
    "body": "The package `runtime.win.System.Runtime.Extensions` contains (among the files and directories it should contain) the empty directories `ref/netstandard` and `runtimes/win/lib/net`.\n\nI don't think these directories should exist: normal framework version directories always have a version (e.g. `netstandard1.5`, not just `netstandard`). And the presence of a `ref` directory in a `runtime` package is especially puzzling to me.\n\nThis does not seem to be limited to `runtime.win.System.Runtime.Extensions`, other `runtime` packages also contain these strange empty directories.\n\nI'm not aware of any actual problem caused by this, but I thought it's strange and probably worth fixing.\n",
    "comments_url": "https://api.github.com/repos/dotnet/runtime/issues/18284/comments",
    "author": "svick",
    "comments": [
      {
        "user": "ericstj",
        "created_at": "2016-08-25T16:18:09Z",
        "body": "These are both by design.\n\n> ref/netstandard\n\nThis ensures that no-one will ever get a reference to the implementation assembly in this package.  The reference comes from the `System.Runtime.Extensions` package.  The `runtime.*` packages should never appear in the compile graph since they are typically only brought in by runtime.json, but someone could directly reference them.  Just in case they do, we want to make sure that they don't end up providing a reference that would conflict with the `System.Runtime.Extensions` package\n\n> runtimes/win/lib/net\n\nThis ensures that the package will never provide a runtime asset on any desktop framework.  We put the desktop assets in the `System.Runtime.Extensions` and do not want two packages providing the same assembly (if someone happens to build for desktop with a RID).  \n"
      }
    ]
  },
  {
    "number": 17755,
    "title": "Assigning VectorX right to VectorX left",
    "created_at": "2016-07-02T05:50:03Z",
    "closed_at": "2020-01-31T11:46:52Z",
    "labels": [
      "question",
      "area-System.Numerics"
    ],
    "url": "https://github.com/dotnet/runtime/issues/17755",
    "body": "CopyTo allows copying of value to arrays but not another Vector of the same length.\n",
    "comments_url": "https://api.github.com/repos/dotnet/runtime/issues/17755/comments",
    "author": "lampuiho",
    "comments": [
      {
        "user": "benaadams",
        "created_at": "2016-07-02T06:13:07Z",
        "body": "Vector is a value type so you just need to use assignment to do a copy.\n\ne.g. `var vectorB = vectorA;`\n"
      },
      {
        "user": "lampuiho",
        "created_at": "2016-07-04T07:22:34Z",
        "body": "No, that's all. Thank you. I do have a question about Vector < double >  though. How do I assign values directly to it? I am actually trying to do matrix multiplication here. Currently I am using a locally allocated \"fixed size\" array with unrolled dot product to do the multiplication with a vector. But the extra code to initialise the array and wrapping it into a vector is quite costly (and I have to wrap it each time the multiplication is done with values allocated to the array). Is there any faster way to do it without initialising the array at all and directly perform the multiplication on the locally initialised vector.\n\nVector4 only supports float*\n"
      },
      {
        "user": "mellinoe",
        "created_at": "2016-07-05T17:42:49Z",
        "body": "`Vector<T>` is designed to be immutable once created, so the individual elements of a vector cannot be modified after it is constructed. There's a few main ways to initialize a `Vector<T>`:\n- Store all of your data upfront in a large array, create vectors from it, using different contiguous parts of the array\n- Store your data in a small, local array, perhaps re-using the array for several constructions, and modifying the values in-between. This sounds like what you're doing already.\n- Store your data on the stack (using `float* ptr = stackalloc float[Vector<float>.Count]`) and then using `Unsafe.Read<Vector<float>>(ptr)`. You can avoid the temporary allocation here, but you have to be careful about the unsafe code and boundary checks.\n\n> Vector4 only supports float*\n\nIs this related to the above question? I'm not sure what you're referring to.\n"
      }
    ]
  },
  {
    "number": 17680,
    "title": "Cant instal System.Net.Security 4.0.0-rc2-24027",
    "created_at": "2016-06-23T12:36:24Z",
    "closed_at": "2020-01-31T11:43:11Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/runtime/issues/17680",
    "body": "Hello,\ni instalig nuget System.Net.Security 4.0.0-rc2-24027 to new csproj project, but take this error:\nCould not install package 'runtime.native.System 4.0.0-rc2-24027'. You are trying to install this package into a project that targets '.NETFramework,Version=v4.6.1', but the package does not contain any assembly references or content files that are compatible with that framework. For more information, contact the package author.\n",
    "comments_url": "https://api.github.com/repos/dotnet/runtime/issues/17680/comments",
    "author": "Lisaj",
    "comments": [
      {
        "user": "svick",
        "created_at": "2016-06-23T13:59:34Z",
        "body": "Could you share your project.json and the full output of running the restore?\n"
      },
      {
        "user": "Lisaj",
        "created_at": "2016-06-23T14:33:41Z",
        "body": "I dont have project.json. It is csproj and i instal nuget.\n\nPackage manager output:\n\nAttempting to gather dependency information for package 'System.Net.Security.4.0.0-rc2-24027' with respect to project 'WebApplication1', targeting '.NETFramework,Version=v4.6.1'\nAttempting to resolve dependencies for package 'System.Net.Security.4.0.0-rc2-24027' with DependencyBehavior 'Lowest'\nResolving actions to install package 'System.Net.Security.4.0.0-rc2-24027'\nResolved actions to install package 'System.Net.Security.4.0.0-rc2-24027'\nInstall failed. Rolling back...\nPackage 'runtime.native.System.4.0.0-rc2-24027' does not exist in project 'WebApplication1'\nPackage 'runtime.native.System.4.0.0-rc2-24027' does not exist in folder 'C:\\Users\\prouz\\onedrive\\dokumenty\\visual studio 2015\\Projects\\WebApplication4\\packages'\nCould not install package 'runtime.native.System 4.0.0-rc2-24027'. You are trying to install this package into a project that targets '.NETFramework,Version=v4.6.1', but the package does not contain any assembly references or content files that are compatible with that framework. For more information, contact the package author.\n========== Finished ==========\n"
      },
      {
        "user": "bartonjs",
        "created_at": "2016-06-24T15:29:13Z",
        "body": "Walking through the daily builds feed, the net46 dependency graph gained runtime.native.System.Net.Security in rc2-23921 (and rc3-23921).\n\nWhile the rc2 line never lost this dependency, it did clear out of the rc3 dependency subgraph in rc3-24018-00, and it does not appear to have been reintroduced since then.\n\nSo, there's probably no easy workaround for this; but if everything goes according to plan the stable version goes out on Monday, and the problem should be fixed.\n"
      },
      {
        "user": "bartonjs",
        "created_at": "2016-06-28T18:18:27Z",
        "body": "I've tried with the stable version of the package (System.Net.Security 4.0.0), and that worked fine; so I'm going to go ahead and close out the issue.\n\nThanks for reporting the problem, please let us know if any more crop up.\n"
      }
    ]
  },
  {
    "number": 17594,
    "title": "Hello. Is it possible to install CoreFX to a custom folder?",
    "created_at": "2016-06-13T09:54:05Z",
    "closed_at": "2020-01-31T11:39:17Z",
    "labels": [
      "question",
      "area-Infrastructure-libraries",
      "help wanted"
    ],
    "url": "https://github.com/dotnet/runtime/issues/17594",
    "body": "Is it possible to install CoreFX to a custom folder after the building from sources?\n\nCommand to build:\n`./build.sh x64 debug`\n\nBut in this case CoreFX installs to a current folder. What command I must enter to onfigure sources and instal to a custom folder?\nPS: OS Ubuntu 16.04 LTS. Problem with building are missing.\n",
    "comments_url": "https://api.github.com/repos/dotnet/runtime/issues/17594/comments",
    "author": "ghost",
    "comments": [
      {
        "user": "joperezr",
        "created_at": "2016-06-13T16:11:35Z",
        "body": "Hi @zenitfan219 thanks for posting your question. There is no easy way of selecting the drop folder of the build output. However, corefx itself doesn't install in that directory, only the output is dropped there. If you want to use the corefx that you just built in a different project, you can do this by referencing the packages that get produced in `<corefxRepoPath>/bin/packages` from your project.\n\nPlease let me know if this answers your question.\n"
      },
      {
        "user": "ghost",
        "created_at": "2016-06-13T21:24:24Z",
        "body": "Okay, thank You for yor answer. Then next question.\n\nCan I use built packages in <corefxRepoPath>/bin/packages without source code? I want to delete source code without <corefxRepoPath>/bin directory. Does it work?\n"
      },
      {
        "user": "joperezr",
        "created_at": "2016-06-13T21:47:40Z",
        "body": "I'm not 100% sure I get your question, but if what you want to know is if the built packages are self-contained meaning that they don't depend on source code being in your machine, then that is correct. You only need the source code to build the packages, but once they are built, you can delete all of the repo code entirely from your machine, and just reference the packages that were produced.\n"
      },
      {
        "user": "ghost",
        "created_at": "2016-06-13T22:45:07Z",
        "body": "Thank you, @joperezr.\n\nAnd the last question. Can I build CoreFX not in repo folder?\n"
      },
      {
        "user": "mellinoe",
        "created_at": "2016-06-13T23:16:06Z",
        "body": "Do you mean if you do not have corefx in a git repository? Right now, it does not work, but that's something we should fix, in my opinion. We have some build steps that add assembly metadata based on  some git information. We should be able to skip that step if there is no git repository.\n\nFor now, you'll need to be in a git repo to build.\n"
      },
      {
        "user": "ghost",
        "created_at": "2016-06-14T08:46:37Z",
        "body": "No.\nI mean if I clonned CoreFX repo to my PC to folder `/home/<username>/MS_GIT/corefx` and wanted to build in folder `/home/<username>/MS_BINARIES/corefx/bin`. Is it possible?\n"
      },
      {
        "user": "joperezr",
        "created_at": "2016-06-14T16:31:30Z",
        "body": "No. There is no easy way to have the output of the build be a folder different than the `<repoRoot>/bin`. That said, you could easily just wait for the build to finish and then either manually or by a script copy the outputs (all of the bin directory) to a different folder in your machine, and then use that. The reason why there is no easy way to do this is because every time you run build.sh, we basically build two phases of the repo, first the native assets and then the managed ones so it's not super straight forward to change outputs from both phases into a different folder.\n"
      }
    ]
  },
  {
    "number": 5463,
    "title": "How to print exception message and type from IL_Throw?",
    "created_at": "2016-03-30T03:56:31Z",
    "closed_at": "2020-01-30T23:29:03Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/runtime/issues/5463",
    "body": "Is there an easy way to print the exception object from gdb when we are in DispatchManagedException? I cannot do lldb as I'm on arm where it is not working.'\n\nThanks!\n",
    "comments_url": "https://api.github.com/repos/dotnet/runtime/issues/5463/comments",
    "author": "manu-st",
    "comments": [
      {
        "user": "janvorli",
        "created_at": "2016-03-31T13:29:17Z",
        "body": "@manu-silicon sorry for not responding earlier, I am on a sick leave at the moment and so I monitor my emails only once a day.\nAt the DispatchManagedException, you'd need to go up the stack to IL_Throw to access the exception object and then use `p *((ExceptionObject*)obj)->_message.m_asString->m_Characters`  to get the exception message. \nYou can also set a breakpoint at RaiseTheExceptionInternalOnly and then \ndo `p *((ExceptionObject*)throwable)->_message.m_asString->m_Characters`, which works for the case when the DispatchManagedException was called from IL_Rethrow too.\n\nThere is a also a way to turn on exception processing logging where you can see various details on how the managed frames are being processed (including method names for each frame), which clauses are being considered, etc. Use the following settings (the LogFacility value picks the EH logs):\n\n```\nexport COMPlus_LogEnable=1\nexport COMPlus_LogToConsole=1\nexport COMPlus_LogFacility=4000\nexport COMPlus_LogLevel=6\n```\n"
      },
      {
        "user": "manu-st",
        "created_at": "2016-04-01T01:31:09Z",
        "body": "@janvorli Not a problem. I was able to get the message from the exception and this was very helpful. I also enabled the logging but it does not print the message part.\n"
      }
    ]
  },
  {
    "number": 4878,
    "title": "JIT compilation compitible with .NET Framework 4.x ?",
    "created_at": "2015-12-30T08:09:07Z",
    "closed_at": "2020-01-30T23:02:31Z",
    "labels": [
      "question",
      "area-CodeGen-coreclr"
    ],
    "url": "https://github.com/dotnet/runtime/issues/4878",
    "body": "The CoreCLR `corinfo.h` & `corjit.h` compatible with .NET Framework 4.x or only support .NET Framework 4.6 ? I tried on FW 4.0 doesn't work.\n",
    "comments_url": "https://api.github.com/repos/dotnet/runtime/issues/4878/comments",
    "author": "danysu",
    "comments": [
      {
        "user": "jkotas",
        "created_at": "2015-12-31T00:07:37Z",
        "body": "`corinfo.h`  &  `corjit.h` are internal unstable frequently changing interfaces. No compatibility guarantees accross different runtimes or runtime versions.\n"
      }
    ]
  },
  {
    "number": 8010,
    "title": "cleanup BCLDebug",
    "created_at": "2017-05-04T16:18:43Z",
    "closed_at": "2020-01-31T01:43:08Z",
    "labels": [
      "help wanted"
    ],
    "url": "https://github.com/dotnet/runtime/issues/8010",
    "body": "Is this the debug tracing mechanism we want corelib code to use long term? CoreRT uses Debug.xx exclusively, CoreCLR corelib uses Debug.xx in most cases but BCLDebug.xx in some. They need to be reconciled.\r\n\r\nBCLDebug has some other features: categories, verbosity, registry configuration.",
    "comments_url": "https://api.github.com/repos/dotnet/runtime/issues/8010/comments",
    "author": "danmoseley",
    "comments": [
      {
        "user": "danmoseley",
        "created_at": "2017-05-04T17:20:52Z",
        "body": "Do you want everything to just use Debug.Log, etc? With no filtering, disabling, ..? Or you want to recreate something like BCLDebug?\r\n\r\nI don't know whether any of the existing uses would fire so much that Debug.Log would be spammy."
      },
      {
        "user": "jkotas",
        "created_at": "2017-05-04T18:10:41Z",
        "body": "There are a very few classes where BCLDebug.Log is used, and I do not think anybody used that logging for anything in like last 10 years. I think it is fine just to delete it. \r\n\r\nOr if you see a good reason to keep it (I do not) - change it to per-class Log method that is `[Condition(\"DEBUG\")]` and does nothing, that the developer can instrument with printf in debug build.\r\n\r\nCoreLib is no different from CoreFX. I do not think anything in CoreFX has logging like this either. It suggests that it is not very useful."
      }
    ]
  },
  {
    "number": 20041,
    "title": "Remove test attributes only necessary for running on older CoreFX versions",
    "created_at": "2017-01-27T19:29:20Z",
    "closed_at": "2020-01-31T13:55:29Z",
    "labels": [
      "enhancement",
      "area-Meta",
      "help wanted"
    ],
    "url": "https://github.com/dotnet/runtime/issues/20041",
    "body": "Remove these\r\n`[SkipOnTargetFramework(TargetFrameworkMonikers.Netcoreapp1_0]`\r\n`[SkipOnTargetFramework(TargetFrameworkMonikers.Netcoreapp1_1]`\r\n\r\nWe do not have plans to run the CoreFX tests against older versions of .NET Core so these are unnecessary and we should remove them all.\r\n\r\nWe still need the versionless one `[SkipOnTargetFramework(TargetFrameworkMonikers.Netcoreapp)]` where a test only passes on Desktop",
    "comments_url": "https://api.github.com/repos/dotnet/runtime/issues/20041/comments",
    "author": "danmoseley",
    "comments": [
      {
        "user": "JonHanna",
        "created_at": "2017-01-27T21:33:11Z",
        "body": "`System.Tests.StringTests.Join_ObjectArray_WithNullIssue` fails in CI if `[SkipOnTargetFramework(TargetFrameworkMonikers.Netcoreapp1_1]` is removed."
      },
      {
        "user": "weshaggard",
        "created_at": "2017-01-27T22:10:45Z",
        "body": "@JonHanna some of the tests like those might need to be changed to use the version-less one as in it should have been `[SkipOnTargetFramework(TargetFrameworkMonikers.Netcoreapp)] `. "
      },
      {
        "user": "danmoseley",
        "created_at": "2017-01-27T23:01:00Z",
        "body": "Do you want to replace that last one  `[SkipOnTargetFramework(TargetFrameworkMonikers.Netcoreapp1_1)]` so we can close this?"
      }
    ]
  },
  {
    "number": 6887,
    "title": "Disassembly dump some times prints hex, sometimes doesn't",
    "created_at": "2016-10-26T21:39:37Z",
    "closed_at": "2020-01-31T00:40:16Z",
    "labels": [
      "test-bug",
      "help wanted",
      "area-CodeGen-coreclr"
    ],
    "url": "https://github.com/dotnet/runtime/issues/6887",
    "body": "I just noticed this while doing a JIT disassembly dump... sometimes the offsets of the memory addresses will be specified in hex, sometimes they'll be specified in decimal.\n\nRepro code to dump:\n\n``` cs\nusing System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Linq;\nusing System.Runtime.CompilerServices;\nusing System.Threading;\nusing System.Threading.Tasks;\n\nnamespace ConsoleApplication\n{\n    public static class Program\n    {\n        [MethodImpl(MethodImplOptions.NoInlining)]\n        private static void LargeStructReturner(out ValueTuple<decimal, decimal, decimal, decimal> tuple)\n        {\n            tuple = default(ValueTuple<decimal, decimal, decimal, decimal>);\n        }\n\n        public static void Main()\n        {\n            ValueTuple<decimal, decimal, decimal, decimal> tuple;\n            LargeStructReturner(out tuple);\n        }\n    }\n}\n```\n\nOutput:\n\n``` asm\n; Assembly listing for method Program:LargeStructReturner():struct\n; Emitting BLENDED_CODE for X64 CPU with AVX\n; optimized code\n; rsp based frame\n; partially interruptible\n; Final local variable assignments\n;\n;  V00 RetBuf       [V00,T00] (  4,   4  )   byref  ->  rcx\n;  V01 loc0         [V01,T01] (  2,   2  )  struct (64) [rsp+0x08]   do-not-enreg[SB] must-init ld-addr-op\n;# V02 loc1         [V02    ] (  1,   1  )  lclBlk ( 0) [rsp+0x00]\n;\n; Lcl frame size = 72\n\nG_M9337_IG01:\n       57                   push     rdi\n       56                   push     rsi\n       4883EC48             sub      rsp, 72\n       488BF1               mov      rsi, rcx\n       488D7C2408           lea      rdi, [rsp+08H]\n       B910000000           mov      ecx, 16\n       33C0                 xor      rax, rax\n       F3AB                 rep stosd\n       488BCE               mov      rcx, rsi\n\nG_M9337_IG02:\n       33C0                 xor      rax, rax\n       488D542408           lea      rdx, bword ptr [rsp+08H]\n       C4E17957C0           vxorpd   ymm0, ymm0\n       C4E17A7F02           vmovdqu  qword ptr [rdx], ymm0\n       C4E17A7F4210         vmovdqu  qword ptr [rdx+16], ymm0\n       C4E17A7F4220         vmovdqu  qword ptr [rdx+32], ymm0\n       C4E17A7F4230         vmovdqu  qword ptr [rdx+48], ymm0 ; HERE\n       C4E17A6F442408       vmovdqu  ymm0, qword ptr [rsp+08H] ; HERE\n       C4E17A7F01           vmovdqu  qword ptr [rcx], ymm0\n       C4E17A6F442418       vmovdqu  ymm0, qword ptr [rsp+18H]\n       C4E17A7F4110         vmovdqu  qword ptr [rcx+16], ymm0\n       C4E17A6F442428       vmovdqu  ymm0, qword ptr [rsp+28H]\n       C4E17A7F4120         vmovdqu  qword ptr [rcx+32], ymm0\n       C4E17A6F442438       vmovdqu  ymm0, qword ptr [rsp+38H]\n       C4E17A7F4130         vmovdqu  qword ptr [rcx+48], ymm0\n       488BC1               mov      rax, rcx\n\nG_M9337_IG03:\n       4883C448             add      rsp, 72\n       5E                   pop      rsi\n       5F                   pop      rdi\n       C3                   ret\n\n; Total bytes of code 122, prolog size 26 for method Program:LargeStructReturner():struct\n; ============================================================\n```\n",
    "comments_url": "https://api.github.com/repos/dotnet/runtime/issues/6887/comments",
    "author": "jamesqo",
    "comments": [
      {
        "user": "mikedn",
        "created_at": "2016-10-28T16:55:32Z",
        "body": "The display code does this on purpose:\n\n```\n            if (frameRef)\n            {\n                printf(\"%02XH\", disp);\n            }\n            else if (disp < 1000)\n            {\n                printf(\"%d\", disp);\n            }\n            else if (disp <= 0xFFFF)\n            {\n                printf(\"%04XH\", disp);\n            }\n            else\n            {\n                printf(\"%08XH\", disp);\n            }\n```\n\nHaving written similar code in the past I'm not surprised at all by this \"inconsistency\".\n"
      },
      {
        "user": "jamesqo",
        "created_at": "2016-10-28T17:41:37Z",
        "body": "@mikedn I see. Can you explain what `frameRef` is supposed to be?\n"
      },
      {
        "user": "mikedn",
        "created_at": "2016-10-28T18:26:15Z",
        "body": "@jamesqo `frameRef` basically means local variable or method argument\n"
      }
    ]
  },
  {
    "number": 14029,
    "title": "2 tests fail when run build.cmd",
    "created_at": "2015-01-30T00:44:59Z",
    "closed_at": "2020-01-31T08:47:41Z",
    "labels": [
      "test-bug",
      "help wanted"
    ],
    "url": "https://github.com/dotnet/runtime/issues/14029",
    "body": "Discovering: MemoryMappedFile.Tests\nDiscovered:  MemoryMappedFile.Tests\nStarting:    MemoryMappedFile.Tests\nErr445! Got unexpected exception: System.IO.IOException: There is not enough space on the disk.\n\n```\n at System.IO.MemoryMappedFiles.MemoryMappedFile.CreateCore(SafeFileHandle fileHandle, String mapName, HandleInheritability inheritability, MemoryMappedFileAccess access, MemoryMappedFileOptions options, Int64 capacity) in e:\\Dev\\GitHub\\DotNet\\corefx\\src\\System.IO.MemoryMappedFiles\\src\\System\\IO\\MemoryMappedFiles\\MemoryMappedFile.Windows.cs:line 45\n at System.IO.MemoryMappedFiles.MemoryMappedFile.CreateFromFile(String path, FileMode mode, String mapName, Int64 capacity, MemoryMappedFileAccess access) in e:\\Dev\\GitHub\\DotNet\\corefx\\src\\System.IO.MemoryMappedFiles\\src\\System\\IO\\MemoryMappedFiles\\MemoryMappedFile.cs:line 180\n at System.IO.MemoryMappedFiles.MemoryMappedFile.CreateFromFile(String path, FileMode mode, String mapName, Int64 capacity) in e:\\Dev\\GitHub\\DotNet\\corefx\\src\\System.IO.MemoryMappedFiles\\src\\System\\IO\\MemoryMappedFiles\\MemoryMappedFile.cs:line 107\n at CreateViewAccessor.RunTestLargeCapacity(Int64 capacity) in e:\\Dev\\GitHub\\DotNet\\corefx\\src\\System.IO.MemoryMappedFiles\\tests\\MemoryMappedFile\\CreateViewAccessor.cs:line 378\n```\n\n  Err445! Got unexpected exception: System.IO.IOException: There is not enough space on the disk.\n\n```\n at System.IO.MemoryMappedFiles.MemoryMappedFile.CreateCore(SafeFileHandle fileHandle, String mapName, HandleInheritability inheritability, MemoryMappedFileAccess access, MemoryMappedFileOptions options, Int64 capacity) in e:\\Dev\\GitHub\\DotNet\\corefx\\src\\System.IO.MemoryMappedFiles\\src\\System\\IO\\MemoryMappedFiles\\MemoryMappedFile.Windows.cs:line 45\n at System.IO.MemoryMappedFiles.MemoryMappedFile.CreateFromFile(String path, FileMode mode, String mapName, Int64 capacity, MemoryMappedFileAccess access) in e:\\Dev\\GitHub\\DotNet\\corefx\\src\\System.IO.MemoryMappedFiles\\src\\System\\IO\\MemoryMappedFiles\\MemoryMappedFile.cs:line 180\n at System.IO.MemoryMappedFiles.MemoryMappedFile.CreateFromFile(String path, FileMode mode, String mapName, Int64 capacity) in e:\\Dev\\GitHub\\DotNet\\corefx\\src\\System.IO.MemoryMappedFiles\\src\\System\\IO\\MemoryMappedFiles\\MemoryMappedFile.cs:line 107\n at CreateViewAccessor.RunTestLargeCapacity(Int64 capacity) in e:\\Dev\\GitHub\\DotNet\\corefx\\src\\System.IO.MemoryMappedFiles\\tests\\MemoryMappedFile\\CreateViewAccessor.cs:line 378\n```\n\n  Err445! Got unexpected exception: System.IO.IOException: There is not enough space on the disk.\n\n```\n at System.IO.MemoryMappedFiles.MemoryMappedFile.CreateCore(SafeFileHandle fileHandle, String mapName, HandleInheritability inheritability, MemoryMappedFileAccess access, MemoryMappedFileOptions options, Int64 capacity) in e:\\Dev\\GitHub\\DotNet\\corefx\\src\\System.IO.MemoryMappedFiles\\src\\System\\IO\\MemoryMappedFiles\\MemoryMappedFile.Windows.cs:line 45\n at System.IO.MemoryMappedFiles.MemoryMappedFile.CreateFromFile(String path, FileMode mode, String mapName, Int64 capacity, MemoryMappedFileAccess access) in e:\\Dev\\GitHub\\DotNet\\corefx\\src\\System.IO.MemoryMappedFiles\\src\\System\\IO\\MemoryMappedFiles\\MemoryMappedFile.cs:line 180\n at System.IO.MemoryMappedFiles.MemoryMappedFile.CreateFromFile(String path, FileMode mode, String mapName, Int64 capacity) in e:\\Dev\\GitHub\\DotNet\\corefx\\src\\System.IO.MemoryMappedFiles\\src\\System\\IO\\MemoryMappedFiles\\MemoryMappedFile.cs:line 107\n at CreateViewStream.RunTestLargeCapacity(Int64 capacity) in e:\\Dev\\GitHub\\DotNet\\corefx\\src\\System.IO.MemoryMappedFiles\\tests\\MemoryMappedFile\\CreateViewStream.cs:line 377\n```\n\n  Err445! Got unexpected exception: System.IO.IOException: There is not enough space on the disk.\n\n```\n at System.IO.MemoryMappedFiles.MemoryMappedFile.CreateCore(SafeFileHandle fileHandle, String mapName, HandleInheritability inheritability, MemoryMappedFileAccess access, MemoryMappedFileOptions options, Int64 capacity) in e:\\Dev\\GitHub\\DotNet\\corefx\\src\\System.IO.MemoryMappedFiles\\src\\System\\IO\\MemoryMappedFiles\\MemoryMappedFile.Windows.cs:line 45\n at System.IO.MemoryMappedFiles.MemoryMappedFile.CreateFromFile(String path, FileMode mode, String mapName, Int64 capacity, MemoryMappedFileAccess access) in e:\\Dev\\GitHub\\DotNet\\corefx\\src\\System.IO.MemoryMappedFiles\\src\\System\\IO\\MemoryMappedFiles\\MemoryMappedFile.cs:line 180\n at System.IO.MemoryMappedFiles.MemoryMappedFile.CreateFromFile(String path, FileMode mode, String mapName, Int64 capacity) in e:\\Dev\\GitHub\\DotNet\\corefx\\src\\System.IO.MemoryMappedFiles\\src\\System\\IO\\MemoryMappedFiles\\MemoryMappedFile.cs:line 107\n at CreateViewAccessor.RunTestLargeCapacity(Int64 capacity) in e:\\Dev\\GitHub\\DotNet\\corefx\\src\\System.IO.MemoryMappedFiles\\tests\\MemoryMappedFile\\CreateViewAccessor.cs:line 378\n```\n\n  FAiL! iCountErrors==3\n  Err445! Got unexpected exception: System.IO.IOException: There is not enough space on the disk.\n\n```\n at System.IO.MemoryMappedFiles.MemoryMappedFile.CreateCore(SafeFileHandle fileHandle, String mapName, HandleInheritability inheritability, MemoryMappedFileAccess access, MemoryMappedFileOptions options, Int64 capacity) in e:\\Dev\\GitHub\\DotNet\\corefx\\src\\System.IO.MemoryMappedFiles\\src\\System\\IO\\MemoryMappedFiles\\MemoryMappedFile.Windows.cs:line 45\n at System.IO.MemoryMappedFiles.MemoryMappedFile.CreateFromFile(String path, FileMode mode, String mapName, Int64 capacity, MemoryMappedFileAccess access) in e:\\Dev\\GitHub\\DotNet\\corefx\\src\\System.IO.MemoryMappedFiles\\src\\System\\IO\\MemoryMappedFiles\\MemoryMappedFile.cs:line 180\n at System.IO.MemoryMappedFiles.MemoryMappedFile.CreateFromFile(String path, FileMode mode, String mapName, Int64 capacity) in e:\\Dev\\GitHub\\DotNet\\corefx\\src\\System.IO.MemoryMappedFiles\\src\\System\\IO\\MemoryMappedFiles\\MemoryMappedFile.cs:line 107\n at CreateViewStream.RunTestLargeCapacity(Int64 capacity) in e:\\Dev\\GitHub\\DotNet\\corefx\\src\\System.IO.MemoryMappedFiles\\tests\\MemoryMappedFile\\CreateViewStream.cs:line 377\n CreateViewAccessor.CreateViewAccessorTestCases [FAIL]\n    One or more test cases failed.\n    Stack Trace:\n       e:\\Dev\\GitHub\\DotNet\\corefx\\src\\System.IO.MemoryMappedFiles\\tests\\MemoryMappedFile\\CreateViewAccessor.cs(32,0): at CreateViewAccessor.CreateViewAccessorTestCases()\n```\n\n  Finished:    System.Diagnostics.FileVersionInfo.Tests\n\n=== TEST EXECUTION SUMMARY ===\n     System.Diagnostics.FileVersionInfo.Tests  Total: 6, Errors: 0, Failed: 0, Skipped: 0, Time: 2.371s\n  FAiL! iCountErrors==2\n     CreateViewStream.CreateViewStreamTestCases [FAIL]\n        One or more test cases failed.\n        Stack Trace:\n           e:\\Dev\\GitHub\\DotNet\\corefx\\src\\System.IO.MemoryMappedFiles\\tests\\MemoryMappedFile\\CreateViewStream.cs(31,0): at CreateViewStream.CreateViewStreamTestCases()\n  Finished:    MemoryMappedFile.Tests\n\n=== TEST EXECUTION SUMMARY ===\n     MemoryMappedFile.Tests  Total: 7, Errors: 0, Failed: 2, Skipped: 0, Time: 1.345s\n",
    "comments_url": "https://api.github.com/repos/dotnet/runtime/issues/14029/comments",
    "author": "cnblogs-dudu",
    "comments": [
      {
        "user": "krwq",
        "created_at": "2015-01-30T00:55:05Z",
        "body": "@cnblogs-dudu could give some more details?\nWhat is your OS?\nHow much space do you have left on your E: drive?\nDoes it happens all the time or intermittently?\nHow did you run the tests? (did you use build.cmd or VS)\n\n@KrzysztofCwalina, @mellinoe is it known issue?\n\nThere is no way of diabling single test, I can disable only whole file.\n"
      },
      {
        "user": "mellinoe",
        "created_at": "2015-01-30T01:48:59Z",
        "body": "The tests try to make files with the following sizes, so I'd imagine they probably fail if your disk is too full:\n\n``` CSharp\nInt64[] capacities = { 2147483647, 2147483648, 2147483649, 4294967295, 4294967296, 4294967297 };\n```\n\nWe can probably either tone down these numbers or just make such a case deliver a warning, maybe?\n"
      },
      {
        "user": "cnblogs-dudu",
        "created_at": "2015-01-30T02:35:26Z",
        "body": "@krwq \n1) Windows Server 2012\n2) Free Space: 4.81G\n3) all the time\n4) use build.cmd\n"
      },
      {
        "user": "cnblogs-dudu",
        "created_at": "2015-01-30T02:38:43Z",
        "body": "@mellinoe \nfailed when capacity is 4294967296\n"
      },
      {
        "user": "krwq",
        "created_at": "2015-01-30T07:06:06Z",
        "body": "@cnblogs-dudu, does it fail for 4294967295 too? Are you using 64bit OS or 32? What type of file system is your E:? Is it FAT32?\n"
      },
      {
        "user": "cnblogs-dudu",
        "created_at": "2015-01-30T09:45:29Z",
        "body": "@krwq \nfail too. \n64bit. \nNTFS. \n\n```\n4294967295\nSystem.IO.IOException: There is not enough space on the disk.\n\nat System.IO.MemoryMappedFiles.MemoryMappedFile.CreateCore\n(SafeFileHandle fileHandle,   String mapName,   HandleInheritability inheritability,   MemoryMappedFileAccess access,   MemoryMappedFileOptions options,  Int64 capacity) \nin e:\\Dev\\GitHub\\DotNet\\corefx\\src\\System.IO.MemoryMappedFiles\\src\\System\\IO\\MemoryMappedFiles\\MemoryMappedFile.Windows.cs:line 45\n\nat System.IO.MemoryMappedFiles.MemoryMappedFile.CreateFromFile(String path, FileMode mode, String mapName, Int64 capacity, MemoryMappedFileAccess access) \nin e:\\Dev\\GitHub\\DotNet\\corefx\\src\\System.IO.MemoryMappedFiles\\src\\System\\IO\\MemoryMappedFiles\\MemoryMappedFile.cs:line 180\n\nat System.IO.MemoryMappedFiles.MemoryMappedFile.CreateFromFile(String path, FileMode mode, String mapName, Int64 capacity) \nin e:\\Dev\\GitHub\\DotNet\\corefx\\src\\System.IO.MemoryMappedFiles\\src\\System\\IO\\MemoryMappedFiles\\MemoryMappedFile.cs:line 107\n\nat CreateViewAccessor.RunTestLargeCapacity(Int64 capacity) \nin e:\\Dev\\GitHub\\DotNet\\corefx\\src\\System.IO.MemoryMappedFiles\\tests\\MemoryMappedFile\\CreateViewAccessor.cs:line 379\n```\n"
      },
      {
        "user": "cnblogs-dudu",
        "created_at": "2015-01-30T10:01:24Z",
        "body": "@krwq \nWhen increased free space from 4.81G to 9.21G, \"There is not enough space on the disk\" exception was gone.\n"
      },
      {
        "user": "krwq",
        "created_at": "2015-01-30T18:51:25Z",
        "body": "Ok, we should mark all tests testing large files as outer loop as creating 4GB files feels like an overkill for the unit test. In this case it looks like we might need to refactor the code to do so first.\n"
      }
    ]
  }
]