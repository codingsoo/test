[
  {
    "number": 1891,
    "title": "Reading result data via C# code",
    "created_at": "2022-01-13T11:41:50Z",
    "closed_at": "2022-01-13T17:37:10Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/BenchmarkDotNet/issues/1891",
    "body": "Hello there\r\n\r\nI've set up BenchmarkDotNet, but I would like to use it not via the default exporters and statistics, but more in the means of an integration-test. Unfortunately, I didn't see a way to get the actual results as just plain values via the provided API.\r\nIs this in fact not possible or even a good idea? The statistics and the printing are neat, but I wouldn't want to check the results manually.\r\nI've also tried to toy around with a  custom-exporter and basically make this one the test, but this seems also very complicated and doesn't look to be your intention.",
    "comments_url": "https://api.github.com/repos/dotnet/BenchmarkDotNet/issues/1891/comments",
    "author": "DrMueller",
    "comments": [
      {
        "user": "mawosoft",
        "created_at": "2022-01-13T17:04:05Z",
        "body": "The BenchmarkRunner/Switcher that you call to execute the benchmarks returns `Summary` or `Summary[]`, which contains all the individual measurements in `BenchmarkReport[] Reports`.\r\n\r\nYou can also add one of the other existing exporters, like `JsonExporter.Full` to get these data.\r\n"
      }
    ]
  },
  {
    "number": 1346,
    "title": "Benchmark Crashing on AssemblyCache in .NET Core 3.0.100",
    "created_at": "2020-01-08T00:01:09Z",
    "closed_at": "2020-04-20T14:54:10Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/BenchmarkDotNet/issues/1346",
    "body": "I've setup my environment before in .NET Framework and my benchmarks worked really great in the past! Kudos for this great lib!\r\n\r\nMy current issue now is that I'm trying to run benchmarks in a new project, this time, in .NET Core 3.0. After writing my last benchmark and executing them, I stumbled upon this error: \r\n\r\n```\r\nC:\\Program Files\\dotnet\\sdk\\3.0.100\\Microsoft.Common.CurrentVersion.targets(4563,5): error MSB3030: Could not copy the file \"C:\\Users\\Kevin.Avignon\\Documents\\Dev\\GitHub\\R.RC\\Robotmaster.CollectionRecommendation\\Robotmaster.CollectionRecommendation.Benchmarks\\bin\\Release\\netcoreapp3.0\\f66f5594-78e5-4bd4-a083-3d1539baf8a9\\obj\\Release\\netcoreapp3.0\\f66f5594-78e5-4bd4-a083-3d1539baf8a9.exe\" because it was not found. [C:\\Users\\Kevin.Avignon\\Documents\\Dev\\GitHub\\R.RC\\Robotmaster.CollectionRecommendation\\Robotmaster.CollectionRecommendation.Benchmarks\\bin\\Release\\netcoreapp3.0\\f66f5594-78e5-4bd4-a083-3d1539baf8a9\\BenchmarkDotNet.Autogenerated.csproj]\r\nC:\\Program Files\\dotnet\\sdk\\3.0.100\\Microsoft.Common.CurrentVersion.targets(2106,5): warning MSB3101: Could not write state file \"obj\\Release\\netcoreapp3.0\\BenchmarkDotNet.Autogenerated.csprojAssemblyReference.cache\". The file 'C:\\Users\\KavignonUserDir\\Documents\\Dev\\GitHub\\R.RC\\Project\\Project.Benchmarks\\bin\\Release\\netcoreapp3.0\\f66f5594-78e5-4bd4-a083-3d1539baf8a9\\obj\\Release\\netcoreapp3.0\\BenchmarkDotNet.Autogenerated.csprojAssemblyReference.cache' already exists. [C:\\Users\\KavignonUserDir\\Documents\\Dev\\GitHub\\R.RC\\Project\\Project.Benchmarks\\bin\\Release\\netcoreapp3.0\\f66f5594-78e5-4bd4-a083-3d1539baf8a9\\BenchmarkDotNet.Autogenerated.csproj]\r\n```\r\n\r\nI made sure of the following before running my benchmarks: \r\n- Release mode\r\n- Passing some arguments to the library: -m --allStats -f *\r\n- Unchecked the option \"Prefer 32 bit.\"\r\n- My benchmarks functions are public\r\n\r\nWhat's the catch here?",
    "comments_url": "https://api.github.com/repos/dotnet/BenchmarkDotNet/issues/1346/comments",
    "author": "Kavignon",
    "comments": [
      {
        "user": "adamsitnik",
        "created_at": "2020-01-10T13:10:06Z",
        "body": "Hello @Kavignon !\r\n\r\nMy gut feeling tells me that MSBuild struggles with long paths. Could you please move the project closer to the root and try again?\r\n\r\nSth like:\r\n\r\n```diff\r\n- C:\\Users\\Kevin.Avignon\\Documents\\Dev\\GitHub\\R.RC\\Robotmaster.CollectionRecommendation\\Robotmaster.CollectionRecommendation.Benchmarks\r\n+ C:\\benchmarks\r\n```"
      }
    ]
  },
  {
    "number": 1330,
    "title": "How to join the results from multiple types?",
    "created_at": "2019-12-13T21:50:28Z",
    "closed_at": "2019-12-17T09:52:53Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/BenchmarkDotNet/issues/1330",
    "body": "Hi, \r\nI want merge benchmark results. \r\nI use \r\nBenchmarkDotNet version=\"0.12.0\" \r\ntargetFramework=\"net461\"\r\n\r\n` \r\n        \r\n            BenchmarkRunner.Run<MyBenchmark>(ManualConfig\r\n                    .Create(DefaultConfig.Instance)\r\n                    .With(ConfigOptions.JoinSummary)\r\n                    .With(ConfigOptions.DisableLogFile));\r\n\r\n            BenchmarkRunner.Run<MyBenchmark1>(ManualConfig\r\n                    .Create(DefaultConfig.Instance)\r\n                    .With(ConfigOptions.JoinSummary)\r\n                    .With(ConfigOptions.DisableLogFile));\r\n//-------------------------------------------------------------------------\r\n\r\n    public class MyBenchmark\r\n    {\r\n        [Benchmark]\r\n        public void Fn1() => Thread.Sleep(10);\r\n\r\n        [Benchmark]\r\n        public void Fn2() => Thread.Sleep(10);\r\n    }\r\n\r\n    public class MyBenchmark1\r\n    {\r\n        [Benchmark]\r\n        public void Fn__1() => Thread.Sleep(10);\r\n\r\n        [Benchmark]\r\n        public void Fn__2() => Thread.Sleep(10);\r\n    }\r\n`\r\n\r\nbut did'nt obtain merged results in  BenchmarkDotNet.Artifacts . That is correct way to merge benchmarks results?",
    "comments_url": "https://api.github.com/repos/dotnet/BenchmarkDotNet/issues/1330/comments",
    "author": "Wizard2007",
    "comments": [
      {
        "user": "adamsitnik",
        "created_at": "2019-12-17T09:52:53Z",
        "body": "Hello @Wizard2007 \r\n\r\n`BenchmarkRunner.Run` stores no state between the runs. \r\n\r\nTo join the results from multiple types you need to pass all types|assemblies info to a single `BenchmarkRunner.Run` call.\r\n\r\nExample:\r\n\r\n```cs\r\nBenchmarkRunner.Run(\r\n    typeof(MyBenchmark).Assembly, // all benchmarks from given assembly are going to be executed\r\n    ManualConfig\r\n                .Create(DefaultConfig.Instance)\r\n                .With(ConfigOptions.JoinSummary)\r\n                .With(ConfigOptions.DisableLogFile));\r\n```"
      },
      {
        "user": "Wizard2007",
        "created_at": "2019-12-17T21:43:22Z",
        "body": "Thank you, it was very help full, and  I can solve my issue.\r\nI use such code, to run only this two benchmark and join results.\r\n\r\n`            \r\n            \r\n       var config = ManualConfig.Create(DefaultConfig.Instance)\r\n             .With(ConfigOptions.JoinSummary)\r\n             .With(ConfigOptions.DisableLogFile);\r\n\r\n        BenchmarkRunner.Run(new[]{\r\n                BenchmarkConverter.TypeToBenchmarks( typeof(MyBenchmark), config),\r\n                BenchmarkConverter.TypeToBenchmarks( typeof(MyBenchmark1), config) \r\n                });\r\n\r\n`"
      }
    ]
  },
  {
    "number": 1272,
    "title": "ArgumentsSource for large complex type",
    "created_at": "2019-10-04T01:42:16Z",
    "closed_at": "2020-03-11T13:58:33Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/BenchmarkDotNet/issues/1272",
    "body": "Hi,\r\n\r\nI want to generate a large amount of test input data to benchmark my query.\r\nBasically I will combine predefined params into a large amount of test input:\r\n\r\n` public IEnumerable<TestParam> Data() `\r\n`{`\r\n            `  var dimensions = new string[] { \"A\", \"B\" };`\r\n           `   var kpis = new string[] { \"C\" };`\r\n            `  parameters = CombineArray.generateParams(dimensions, kpis);`\r\n           `   return parameters.AsEnumerable();`\r\n`}`\r\n\r\nThen use it as argumentSource of my benchmark ` [ArgumentsSource(nameof(Data))]`\r\nThe problem is eveytime benchmark method run, it again executes Data method, which can be slow if I try to put large amount of dimensions and kpis, it can generate million of test input.\r\n\r\nI think I can put it on `GlobalSetup`, but don't know how to setup benchmark method to run all of the test input there.\r\nPlease help,\r\nThank you!!!",
    "comments_url": "https://api.github.com/repos/dotnet/BenchmarkDotNet/issues/1272/comments",
    "author": "valentinoNguyen",
    "comments": [
      {
        "user": "adamsitnik",
        "created_at": "2019-10-05T16:00:50Z",
        "body": "Hello @valentinoNguyen !\r\n\r\n> The problem is eveytime benchmark method run, it again executes Data method, which can be slow if I try to put large amount of dimensions and kpis, it can generate million of test input.\r\n\r\nThis is unfortunately by design. We simply run something like `argumentSource().ToArray()[argumentIndex]` in the auto-generated code.\r\n\r\nThe good news is that as you said moving it to `[GlobalSetup]` should work:\r\n\r\n```cs\r\n[Params(\"A\", \"B\")]\r\npublic string Dimension {get; set;}\r\n\r\n[Params(\"C\", \"D\")]\r\npublic string KPI { get; set;\r\n\r\nprivate TestParam _testParam;\r\n\r\n[GlobalSetup]\r\npublic void Setup() => _testParam = generateParams(Dimension, KPI);\r\n``` \r\n\r\nThe key thing here is that when you are using multiple `Params` in your type with benchmarks, BDN creates a cartesian product of all params. For the example above (ABxCD), we would have the following 4 benchmark cases:\r\n\r\n* A, C\r\n* A, D\r\n* B, C\r\n* B, D"
      },
      {
        "user": "adamsitnik",
        "created_at": "2019-10-06T09:12:46Z",
        "body": "> But I am curious if is there any way to allow Params() take a function or something to generate a set of input params instead of hardcode it like this.\r\n\r\nUnfortunately not. The reason is that we need to run the benchmark in a separate process and things like functions are hard to serialize and deserialize (in our case the host and parent process can be two different runtimes: for example .NET Core and Mono or Full .NET Framework and .NET Core)"
      }
    ]
  },
  {
    "number": 1140,
    "title": "Targeting .NET 4.6.2 but executing as 4.7.2",
    "created_at": "2019-04-28T17:57:36Z",
    "closed_at": "2019-04-28T21:07:48Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/BenchmarkDotNet/issues/1140",
    "body": "I have a small benchmark project that is targeting netcoreapp2 and net462.\r\n\r\n```\r\n<Project Sdk=\"Microsoft.NET.Sdk\">\r\n\r\n  <PropertyGroup>\r\n    <OutputType>Exe</OutputType>\r\n    <TargetFrameworks>netcoreapp2;net462</TargetFrameworks>\r\n  </PropertyGroup>\r\n\r\n  <ItemGroup>\r\n    <PackageReference Include=\"BenchmarkDotNet\" Version=\"0.11.5\" />\r\n  </ItemGroup>\r\n\r\n</Project>\r\n```\r\n\r\n\r\nHowever when running this benchmark it only seems to respect the netcoreapp target and not the full framework one. It states that the CLR job was run targeting net472. Could I be doing this wrong or is this an issue? I have targeted only two jobs [CoreJob, ClrJob].\r\n\r\n>   [Host] : .NET Core 2.0.9 (CoreCLR 4.6.26614.01, CoreFX 4.6.26614.01), 64bit RyuJIT\r\n>   Clr    : .NET Framework 4.7.2 (CLR 4.0.30319.42000), 64bit RyuJIT-v4.7.3394.0\r\n>   Core   : .NET Core 2.0.9 (CoreCLR 4.6.26614.01, CoreFX 4.6.26614.01), 64bit RyuJIT\r\n\r\n",
    "comments_url": "https://api.github.com/repos/dotnet/BenchmarkDotNet/issues/1140/comments",
    "author": "ghost",
    "comments": [
      {
        "user": "ghost",
        "created_at": "2019-04-28T19:34:11Z",
        "body": "I have also noticed that even if I remove the explicit job attributes and only target my project to net462 the run summary still shows it executes with net472."
      },
      {
        "user": "ghost",
        "created_at": "2019-04-28T21:07:48Z",
        "body": "After asking on SO someone pointed out that unlike .net core the full framework does not have side by side installs but a runtime that is upgraded in place. So even with net462 but having 4.7.2 installed means that will be the runtime. Makes sense."
      },
      {
        "user": "adamsitnik",
        "created_at": "2019-04-29T13:02:24Z",
        "body": "This is the default behavior of Full .NET Framework. No matter what version your app targets, it's always executed with the latest .NET Runtime installed on your machine.\r\n\r\nYou can test it with the following example\r\n\r\n```cs\r\nvoid Main() => System.Console.WriteLine(Microsoft.DotNet.PlatformAbstractions.RuntimeEnvironment.FrameworkDescription);\r\n```"
      }
    ]
  },
  {
    "number": 804,
    "title": "What is the point of BuildScriptFilePath ?",
    "created_at": "2018-06-25T05:23:10Z",
    "closed_at": "2018-06-25T10:04:17Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/BenchmarkDotNet/issues/804",
    "body": "I'm in the process of attempting to implement #290 and noticed that the Generators create a `.bat` build script which seems quite handy, but then the Builders don't actually use the build script generated.\r\n\r\nFor example the `DotNetCliBuilder` runs it's own `restore` and `build` commands and doesn't use the generated build script to do the building.  The Roslyn Builder outputs a log entry for the `BuildScriptFilePath` but then doesn't use it at all.\r\n\r\nThis might be intentional, so sorry if I'm being naive (the solution is quite a learning curve :) \r\n\r\n",
    "comments_url": "https://api.github.com/repos/dotnet/BenchmarkDotNet/issues/804/comments",
    "author": "Shazwazza",
    "comments": [
      {
        "user": "adamsitnik",
        "created_at": "2018-06-25T10:04:17Z",
        "body": "Hi @Shazwazza \r\n\r\nIt's a very good question!\r\n\r\nBDN used to generate **and run** this script. At some point of time, we moved from doing this to calling Roslyn API directly. The script was preserved for situations when we fail to build the benchmark project, apply `[KeepBenchmarkFiles]` attribute and run it manually to reproduce the problem. So we keep it only for eventual troubleshooting.\r\n\r\nYou can ignore it if you are developing a custom toolchain."
      }
    ]
  },
  {
    "number": 775,
    "title": "Few questions related to understanding of results",
    "created_at": "2018-06-04T20:05:03Z",
    "closed_at": "2018-06-04T22:01:41Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/BenchmarkDotNet/issues/775",
    "body": "### 1. What is a difference between DryCore and Core?\r\nResult in Core:   0.2182 ns\r\nResult in DryCore: 647,800.0000 ns\r\n\r\n### 2. What is the meaning of histograms?\r\n\r\n[-0.002 ns ; 0.074 ns) | @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\r\n[ 0.074 ns ; 0.178 ns) | @@@@@@@@@@@@@@@@@@\r\n[ 0.178 ns ; 0.280 ns) | @@@@@@@@\r\n[ 0.280 ns ; 0.355 ns) | @@@@@@@@@@@@@@@@@\r\n[ 0.355 ns ; 0.444 ns) | @@@@@@@@\r\n[ 0.444 ns ; 0.528 ns) | @@@\r\n[ 0.528 ns ; 0.604 ns) | @@@@@\r\n[ 0.604 ns ; 0.651 ns) |\r\n[ 0.651 ns ; 0.727 ns) | @@\r\n[ 0.727 ns ; 0.797 ns) |\r\n[ 0.797 ns ; 0.873 ns) | @\r\n",
    "comments_url": "https://api.github.com/repos/dotnet/BenchmarkDotNet/issues/775/comments",
    "author": "ddobric",
    "comments": [
      {
        "user": "adamsitnik",
        "created_at": "2018-06-04T22:01:40Z",
        "body": "Hi @ddobric \r\n\r\n1. `DryJob` runs the benchmark exactly once, without any warmup. You can use it to measure the JIT overhead or to test your benchmark if it works\r\n\r\n2. Each `@` represents a single iteration\r\n`[ 0.444 ns ; 0.528 ns) | @@@` - means that there were 3 iterations for which the average time of benchmark execution was between 0.444 ns to 0.528 ns"
      }
    ]
  },
  {
    "number": 708,
    "title": "Error of DisassemblyDiagnoser(printAsm: true, printSource: true) in MultiTarget project",
    "created_at": "2018-03-31T21:56:58Z",
    "closed_at": "2018-04-03T13:58:39Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/BenchmarkDotNet/issues/708",
    "body": "I have a multitarget project with windows diagnoser enabler for NET47:\r\n\r\n```\r\n<Project Sdk=\"Microsoft.NET.Sdk\">\r\n\r\n  <PropertyGroup>\r\n    <OutputType>Exe</OutputType>\r\n    <TargetFrameworks>netcoreapp2.0;net47</TargetFrameworks>\r\n\t<LangVersion>latest</LangVersion>\r\n  </PropertyGroup>\r\n\r\n  <ItemGroup>\r\n    <PackageReference Include=\"BenchmarkDotNet\" Version=\"0.10.13\" />\r\n    \r\n    <PackageReference Include=\"DynamicExpresso.Core\" Version=\"2.0.0\" />\r\n    <PackageReference Include=\"Newtonsoft.Json\" Version=\"11.0.2\" />\r\n  </ItemGroup>\r\n  \r\n    <ItemGroup Condition=\"'$(TargetFramework)' == 'net47'\">\r\n\t\t<PackageReference Include=\"BenchmarkDotNet.Diagnostics.Windows\" Version=\"0.10.13\" />\r\n\t</ItemGroup>\r\n\r\n  <ItemGroup>\r\n    <ProjectReference Include=\"..\\..\\Routines\\Routines.csproj\" />\r\n  </ItemGroup>\r\n</Project>\r\n```\r\n\r\nDisassembler configuration enabled on conditional compiling:\r\n\r\n```\r\n#if !NETCOREAPP2_0\r\n    [DisassemblyDiagnoser(printAsm: true, printSource: true)]\r\n#endif\r\n    public class BenchmarkConverAll\r\n    { \r\n\r\n```\r\nInlining diagnoser enabled that way works, when dissasembly diagnoser returns an error:\r\n\r\nTest executed as \r\n& dotnet run -c Release -f net47 -p \"$BenchmarkProjectPath\"\r\n\r\n\r\n```\r\nPS D:\\cot\\DashboardCode\\Routines> D:\\cot\\DashboardCode\\Routines\\BenchmarkWindows.ps1\r\nMicrosoft (R) Build Engine version 15.6.82.30579 for .NET Core\r\nCopyright (C) Microsoft Corporation. All rights reserved.\r\n\r\n  Restore completed in 64.03 ms for D:\\cot\\DashboardCode\\Routines\\Routines\\Routines.csproj.\r\n  Restore completed in 64.46 ms for D:\\cot\\DashboardCode\\Routines\\Tests\\Benchmark\\Benchmark.csproj.\r\n  Routines -> D:\\cot\\DashboardCode\\Routines\\Routines\\bin\\Release\\netstandard2.0\\DashboardCode.Routines.dll\r\n  Benchmark -> D:\\cot\\DashboardCode\\Routines\\Tests\\Benchmark\\bin\\Release\\netcoreapp2.0\\Benchmark.dll\r\n  Benchmark -> D:\\cot\\DashboardCode\\Routines\\Tests\\Benchmark\\bin\\Release\\net47\\Benchmark.exe\r\n\r\nBuild succeeded.\r\n    0 Warning(s)\r\n    0 Error(s)\r\n\r\nTime Elapsed 00:00:05.85\r\nMicrosoft (R) Build Engine version 15.6.82.30579 for .NET Core\r\nCopyright (C) Microsoft Corporation. All rights reserved.\r\n\r\n  Restore completed in 104.64 ms for D:\\cot\\DashboardCode\\Routines\\Routines\\Routines.csproj.\r\n  Restore completed in 121.11 ms for D:\\cot\\DashboardCode\\Routines\\Tests\\Benchmark\\Benchmark.csproj.\r\n// ***** BenchmarkRunner: Start   *****\r\n// Found benchmarks:\r\n//   BenchmarkConverAll.TestConverAll: RyuJitX64(Jit=RyuJit, Platform=X64)\r\n\r\n// Validating benchmarks:\r\n// ***** Building 1 benchmark(s) in Parallel: Start   *****\r\n// ***** Done, took 00:00:05 (5.29 sec)   *****\r\n// **************************\r\n// Benchmark: BenchmarkConverAll.TestConverAll: RyuJitX64(Jit=RyuJit, Platform=X64)\r\n// *** Execute ***\r\n// Launch: 1 / 1\r\n// Execute: D:\\cot\\DashboardCode\\Routines\\Tests\\Benchmark\\bin\\Release\\net47\\74d4fd8a-270d-46ab-bde8-907d0dfaa814.exe diagnoserAttached\r\n// BeforeAnythingElse\r\n\r\n// Benchmark Process Environment Information:\r\n// Runtime=.NET Framework 4.7 (CLR 4.0.30319.42000), 64bit RyuJIT-v4.7.2633.0\r\n// GC=Concurrent Workstation\r\n// Job: RyuJitX64(Jit=RyuJit, Platform=X64)\r\n\r\nPilot  1: 16 op, 3459366.51 ns, 216.2104 us/op\r\n\r\n..............................\r\n\r\n// AfterAll\r\n\\ ---------------------------\r\nFailed to read source code location!\r\nPlease make sure that the project, which defines benchmarks contains following settings:\r\n\t <DebugType>pdbonly</DebugType>\r\n\t <DebugSymbols>true</DebugSymbols>\r\n\\ ---------------------------\r\ndotnet.exe : \r\nAt D:\\cot\\DashboardCode\\Routines\\BenchmarkWindows.ps1:17 char:1\r\n+ & dotnet run -c Release -f net47 -p \"$BenchmarkProjectPath\"\r\n+ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n    + CategoryInfo          : NotSpecified: (:String) [], RemoteException\r\n    + FullyQualifiedErrorId : NativeCommandError\r\n \r\nUnhandled Exception: \r\nSystem.InvalidOperationException: There is an error in XML document (0, 0). ---> System.Xml.XmlException: Root element is missing.\r\n   at System.Xml.XmlTextReaderImpl.Throw(Exception e)\r\n   at System.Xml.XmlTextReaderImpl.ParseDocumentContent()\r\n   at System.Xml.XmlReader.MoveToContent()\r\n   at Microsoft.Xml.Serialization.GeneratedAssembly.XmlSerializationReaderDisassemblyResult.Read9_DisassemblyResult()\r\n   --- End of inner exception stack trace ---\r\n   at System.Xml.Serialization.XmlSerializer.Deserialize(XmlReader xmlReader, String encodingStyle, XmlDeserializationEvents events)\r\n   at BenchmarkDotNet.Diagnosers.WindowsDisassembler.Dissasemble(DiagnoserActionParameters parameters)\r\n   at BenchmarkDotNet.Diagnosers.DisassemblyDiagnoser.Handle(HostSignal signal, DiagnoserActionParameters parameters)\r\n   at BenchmarkDotNet.Extensions.CommonExtensions.ForEach[T](IList`1 source, Action`1 command)\r\n   at BenchmarkDotNet.Loggers.SynchronousProcessOutputLoggerWithDiagnoser.ProcessInput()\r\n   at BenchmarkDotNet.Toolchains.Executor.Execute(Process process, Benchmark benchmark, SynchronousProcessOutputLoggerWithDiagnoser loggerWithDiagnoser, ILogger logger)\r\n   at BenchmarkDotNet.Toolchains.Executor.Execute(Benchmark benchmark, ILogger logger, String exePath, String workingDirectory, String args, IDiagnoser diagnoser, IResolver \r\nresolver, IConfig config)\r\n   at BenchmarkDotNet.Toolchains.Executor.Execute(ExecuteParameters executeParameters)\r\n   at BenchmarkDotNet.Running.BenchmarkRunnerCore.Execute(ILogger logger, Benchmark benchmark, IToolchain toolchain, BuildResult buildResult, IConfig config, IResolver \r\nresolver)\r\n   at BenchmarkDotNet.Running.BenchmarkRunnerCore.RunCore(Benchmark benchmark, ILogger logger, ReadOnlyConfig config, String rootArtifactsFolderPath, Func`2 \r\ntoolchainProvider, IResolver resolver, BuildResult buildResult)\r\n   at BenchmarkDotNet.Running.BenchmarkRunnerCore.Run(BenchmarkRunInfo benchmarkRunInfo, ILogger logger, String title, String rootArtifactsFolderPath, Func`2 \r\ntoolchainProvider, IResolver resolver, List`1 artifactsToCleanup)\r\n   at BenchmarkDotNet.Running.BenchmarkRunnerCore.Run(BenchmarkRunInfo benchmarkRunInfo, Func`2 toolchainProvider)\r\n   at Benchmark.Program.Main(String[] args)\r\n```",
    "comments_url": "https://api.github.com/repos/dotnet/BenchmarkDotNet/issues/708/comments",
    "author": "rpokrovskij",
    "comments": [
      {
        "user": "adamsitnik",
        "created_at": "2018-04-03T13:58:39Z",
        "body": "Hi @rpokrovskij \r\n\r\nThe answer is in the output you provided:\r\n\r\n```\r\nFailed to read source code location!\r\nPlease make sure that the project, which defines benchmarks contains following settings:\r\n\t <DebugType>pdbonly</DebugType>\r\n\t <DebugSymbols>true</DebugSymbols>\r\n```\r\n\r\nPlease feel free to reopen if it does not help."
      },
      {
        "user": "rpokrovskij",
        "created_at": "2018-04-03T16:22:29Z",
        "body": "I have noticed this but thougth that this works only for classic proj file (when I use `<Project Sdk=\"Microsoft.NET.Sdk\">` )...\r\nI will check does this works in this case.\r\nYes it works! Thank you.\r\n"
      }
    ]
  },
  {
    "number": 668,
    "title": "Can ParamsSource be evaluated after GlobalSetup?",
    "created_at": "2018-02-27T14:28:15Z",
    "closed_at": "2018-03-02T20:29:17Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/BenchmarkDotNet/issues/668",
    "body": "I have to initialize several objects that are generating parameters. Therefore my idea was to initialize these objects in the GlobalSetup area. \r\n\r\n        private IProjectInfo _generatedProject1;\r\n        private IProjectInfo _generatedProject2;\r\n\r\n        [GlobalSetup]\r\n        public void BenchmarkSetup()\r\n        {\r\n            var loader = new ProjectLoader();\r\n            _generatedProject1 = loader.GetSample();\r\n            _generatedProject2 = loader.GetBigSample();\r\n        }\r\n\r\n        [ParamsSource(nameof(Projects))]\r\n        public IProjectInfo Project;\r\n\r\n        public IEnumerable<IParam> Projects()\r\n        {\r\n            yield return new ProjectParameter { Project = _generatedProject1};\r\n            yield return new ProjectParameter { Project = _generatedProject2};\r\n        }\r\n\r\n        [Benchmark]\r\n        public IProject OpenProject()\r\n        {\r\n            var project = OpenProject(Project);\r\n            return project;\r\n        }\r\n\r\n        public class ProjectParameter : IParam\r\n        {\r\n            public IProjectInfo Project { get; set; }\r\n            public string ToSourceCode() => \"\";\r\n            public object Value => Project;\r\n            public string DisplayText => Project.Name;\r\n        }\r\n\r\nBut unfortunately the parameters are built before, so I get an exception. Is there any workaround?",
    "comments_url": "https://api.github.com/repos/dotnet/BenchmarkDotNet/issues/668/comments",
    "author": "chriga",
    "comments": [
      {
        "user": "adamsitnik",
        "created_at": "2018-02-27T15:38:59Z",
        "body": "Parameters are generated before the call to `Setup` method(s), to make it possible for the setup to use their values.\r\n\r\nYou could do sth like:\r\n\r\n```cs\r\nprivate Dictionary<string, IProjectInfo> _projectsByName;\r\n\r\nprivate IProjectInfo _project;\r\n\r\n[ParamsSource(nameof(Projects))]\r\npublic string CurrentProjectName;\r\n\r\npublic IEnumerable<IParam> Projects()\r\n{\r\n\tyield return \"generatedProject1\"\r\n\tyield return \"generatedProject2\";\r\n}\r\n\r\n\r\n[GlobalSetup]\r\npublic void BenchmarkSetup()\r\n{\r\n\tvar loader = new ProjectLoader();\r\n\t_projectsByName = new Dictionary<string, IProjectInfo>\r\n\t{\r\n\t\t{ \"_generatedProject1\", loader.GetSample() },\r\n\t\t{ \"_generatedProject2\", loader.GetBigSample() },\r\n\t}\r\n\r\n\t_currentProject = _projectsByName[CurrentProjectName];\r\n}\r\n\r\n[Benchmark]\r\npublic IProject OpenProject()\r\n{\r\n\tvar project = OpenProject(_currentProject);\r\n\treturn project;\r\n}\r\n```"
      },
      {
        "user": "chriga",
        "created_at": "2018-03-02T16:00:17Z",
        "body": "Hi Adam,\r\n\r\nthanks for your input. Your idea seems to work with some modification:\r\n\r\n    private Dictionary<string, IProjectInfo> _projectsByName;\r\n    \r\n    [ParamsSource(nameof(Projects))]\r\n    public string CurrentProjectName;\r\n\r\n    public IEnumerable<string> Projects()\r\n    {\r\n\t    yield return \"generatedProject1\"\r\n\t    yield return \"generatedProject2\";\r\n    }\r\n\r\n    [GlobalSetup]\r\n    public void BenchmarkSetup()\r\n    {\r\n\t    var loader = new ProjectLoader();\r\n\t    _projectsByName = new Dictionary<string, IProjectInfo>\r\n        {\r\n\t\t    { \"generatedProject1\", loader.GetSample() },\r\n\t\t    { \"generatedProject2\", loader.GetBigSample() }\r\n\t    }\r\n    }\r\n\r\n    [Benchmark]\r\n    public IProject OpenProject()\r\n    {\r\n\t    var project = OpenProject(_projectsByName[CurrentProjectName]);\r\n\t    return project;\r\n    }\r\n\r\nOriginal I wanted that the project names are used from loaded projects. But I can get over it."
      },
      {
        "user": "FreePhoenix888",
        "created_at": "2023-03-17T11:15:55Z",
        "body": "I have found out that static constructor is evaluated before ParamsSource evaluation. @chriga , you can try this solution"
      },
      {
        "user": "timcassell",
        "created_at": "2023-03-17T11:50:38Z",
        "body": "@FreePhoenix888 So is a non-static constructor (just make sure it's public, parameter-less). In any case, I wouldn't recommend that. By default, benchmarks are ran in a separate process from the host process that evaluated the params, so if you're trying to use that instead of `[GlobalSetup]`, you could be in for a surprise."
      },
      {
        "user": "FreePhoenix888",
        "created_at": "2023-03-17T12:21:31Z",
        "body": "> @FreePhoenix888 So is a non-static constructor (just make sure it's public, parameter-less). In any case, I wouldn't recommend that. By default, benchmarks are ran in a separate process from the host process that evaluated the params, so if you're trying to use that instead of `[GlobalSetup]`, you could be in for a surprise.\r\n\r\nThank you for fast response.\r\nAs I know initializing a field right on the declaration line is equivalent to having aconstructor because C# automatically creates it under the hood. Is not it ? :)"
      }
    ]
  },
  {
    "number": 656,
    "title": "Question: is it possible to access method, mean and scale programmatically once the benchmarks have ran?",
    "created_at": "2018-02-22T16:43:55Z",
    "closed_at": "2018-02-28T14:43:43Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/BenchmarkDotNet/issues/656",
    "body": "Is it possible to access method, mean and scale programmatically once the benchmarks have ran?",
    "comments_url": "https://api.github.com/repos/dotnet/BenchmarkDotNet/issues/656/comments",
    "author": "PonchoPowers",
    "comments": [
      {
        "user": "PonchoPowers",
        "created_at": "2018-02-22T17:34:24Z",
        "body": "Use case being I would like to run the benchmarks on the command line as part of an automatic build system, and I'd like to flag up when the benchmarks are too slow, so would like to programmatically parse the results to then indicate on the build system summary page whether the build has passed or failed.\r\n\r\nI couldn't see anywhere in the docs which specified I could and I took a look at the Summary class and it wasn't immediately apparent if I could access this data via the API or not."
      },
      {
        "user": "PonchoPowers",
        "created_at": "2018-02-28T12:45:18Z",
        "body": "I know artifacts are created which contain this information, but I was hoping to programmatically parse the Summary class but can't see how to. Should I parse the artifacts after the benchmarks have ran or is there another way?"
      },
      {
        "user": "adamsitnik",
        "created_at": "2018-02-28T13:07:16Z",
        "body": "```cs\r\nvar summary = BenchmarkRunner.Run<Program>();\r\n\r\nforeach (var report in summary.Reports)\r\n{\r\n    report.ResultStatistics.Mean // ResultStatistics has all you need\r\n}\r\n```"
      }
    ]
  },
  {
    "number": 323,
    "title": "Dead code elimination - is this safe?",
    "created_at": "2016-12-10T17:12:36Z",
    "closed_at": "2016-12-12T13:07:44Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/dotnet/BenchmarkDotNet/issues/323",
    "body": "I have a benchmark like so:\r\n\r\n```cs\r\n[Params(1, 10, 100, 500, 1000, 10000)]\r\npublic int NumberOfMatches { get; set; }\r\n\r\n[Benchmark]\r\npublic List<bool> DotNetGlobIsMatch()\r\n{\r\n    // we collect all results in a list \r\n    // and return it to prevent dead code elimination (optimisation)\r\n    var results = new List<bool>(NumberOfMatches);\r\n    for (int i = 0; i < NumberOfMatches; i++)\r\n    {\r\n        var testString = _testData[i];\r\n        var result = _dotnetGlob.IsMatch(testString);\r\n        results.Add(result);\r\n    }\r\n    return results;\r\n}\r\n```\r\n\r\nI would use `[OperationsPerInvoke]` except it's not dynamic, so I use  `[Params(1, 10, 100, 500, 1000, 10000)]` instead.\r\n\r\nMy question is, I don't really like having to construct and return a list in my Benchmark method, however I need to ensure that something is done with each result in the iteration so that dead code elimination doesn't remove it.\r\n\r\nIs this safe to do instead?\r\n\r\n```cs\r\n[Benchmark]\r\npublic IEnumerable<bool> DotNetGlobIsMatch()\r\n{\r\n    for (int i = 0; i < NumberOfMatches; i++)\r\n    {\r\n        var testString = _testData[i];\r\n        var result = _dotnetGlob.IsMatch(testString);\r\n        yield return result;\r\n    }\r\n}\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/dotnet/BenchmarkDotNet/issues/323/comments",
    "author": "dazinator",
    "comments": [
      {
        "user": "AndreyAkinshin",
        "created_at": "2016-12-12T12:52:53Z",
        "body": "In both cases, you will have some overhead. Here is an almost overhead-free benchmark:\r\n```cs\r\n[Benchmark]\r\npublic bool DotNetGlobIsMatch()\r\n{\r\n    var result = false;\r\n    for (int i = 0; i < NumberOfMatches; i++)\r\n    {\r\n        var testString = _testData[i];\r\n        result ^= _dotnetGlob.IsMatch(testString);\r\n    }\r\n    return result;\r\n}\r\n```"
      }
    ]
  }
]