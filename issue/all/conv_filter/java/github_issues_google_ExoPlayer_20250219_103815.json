[
  {
    "number": 11212,
    "title": "Skip ads while fast forwarding/ Remove first pre roll ads in resumed content.",
    "created_at": "2023-06-15T07:40:17Z",
    "closed_at": "2023-06-16T06:30:14Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/google/ExoPlayer/issues/11212",
    "body": "hi,\r\nIs there any way that pre-roll ads can be removed in the condition when the user is resuming the content from the continue watching row?\r\nAlso, need to skip the ad when the user if fast forwarding. Is there any way to achieve this.",
    "comments_url": "https://api.github.com/repos/google/ExoPlayer/issues/11212/comments",
    "author": "dev-sharma-deltatre",
    "comments": [
      {
        "user": "marcbaechinger",
        "created_at": "2023-06-15T09:23:00Z",
        "body": "> Is there any way that pre-roll ads can be removed in the condition when the user is resuming the content from the continue watching row?\r\n\r\nI assume you are using  the IMA extension with client-side ads (please add all information initially, so we can be sure to answer for the right thing from the beginning. It for you benefit because the waiting time for a second answer tends to be much longer).\r\n\r\nIf there is only a pre-roll, then you can simply not add the ad metadata to your media item, when you add it to the player. The stream then plays without ads. If there are further ads to be played I don't think you can drop single ads or ad groups.\r\n\r\n> Also, need to skip the ad when the user if fast forwarding\r\n\r\nGenerally, the player doesn't allow seeking when an ad is playing. You can use skippeable ads, which then can be skipped by the user. With IMA, there is no API to skip over ads other than with skippeable ads."
      },
      {
        "user": "dev-sharma-deltatre",
        "created_at": "2023-06-15T10:19:26Z",
        "body": "@marcbaechinger, thank you for the quick response. \r\nSo there is no way to just remove the pre-roll ad and keep the mid-rolls and post-rolls?\r\nAlso, when the user is fast-forwarding the content and mid-rolls are there, then ads cannot be skipped, unless they are skippable ads?\r\nPlease confirm."
      },
      {
        "user": "marcbaechinger",
        "created_at": "2023-06-15T11:13:23Z",
        "body": "> So there is no way to just remove the pre-roll ad and keep the mid-rolls and post-rolls?\r\n\r\nConfirmed.\r\n\r\n> Also, when the user is fast-forwarding the content and mid-rolls are there, then ads cannot be skipped, unless they are skippable ads?\r\n\r\nConfirmed when an ad is playing, the user can not seek. If an ad is skippeable, then the user can not seek until the non-skippeable duration is played. Then the user can skip the ad.\r\n\r\nI can also confirm that when a user seek across the cue point of an ad, then the player plays the ad and then goes to the  requested seek position.\r\n"
      },
      {
        "user": "dev-sharma-deltatre",
        "created_at": "2023-06-16T06:30:14Z",
        "body": "Thank you so much for the information."
      }
    ]
  },
  {
    "number": 10946,
    "title": "RtspMediaSource with not available RTSP stream will block whole ExoPlayer",
    "created_at": "2023-01-26T14:49:34Z",
    "closed_at": "2023-01-27T11:58:54Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/google/ExoPlayer/issues/10946",
    "body": "Hello,\r\nI try to implement a player which mixes local video files in playlist with public RTSP streams for my project.\r\nI found that if RTSP Server is not accesible (dead) - Exoplayer will lock whole play thread even at playing an earlier local MP4 file in playlist.\r\n\r\nIt will finally, after about 2 minutes, fire ExoPlaybackException\r\n\r\nI cannot find a timeout option to setup.\r\n```\r\nvar mediaSourceRTSP =\r\n    RtspMediaSource.Factory()\r\n        .setForceUseRtpTcp(true)\r\n        .setTimeoutMs(3000)\r\n        .createMediaSource(newMediaItem)\r\n```\r\n\r\nAnd the Exception which fires about 2 minutes later:\r\n\r\n```\r\nE/ExoPlayerImplInternal: Playback error\r\n      com.google.android.exoplayer2.ExoPlaybackException: Source error\r\n        at com.google.android.exoplayer2.ExoPlayerImplInternal.handleIoException(ExoPlayerImplInternal.java:637)\r\n        at com.google.android.exoplayer2.ExoPlayerImplInternal.handleMessage(ExoPlayerImplInternal.java:613)\r\n        at android.os.Handler.dispatchMessage(Handler.java:102)\r\n        at android.os.Looper.loop(Looper.java:223)\r\n        at android.os.HandlerThread.run(HandlerThread.java:67)\r\n     Caused by: java.net.ConnectException: failed to connect to /11.201.0.110 (port 11035) from /:: (port 58066): connect failed: ETIMEDOUT (Connection timed out)\r\n        at libcore.io.IoBridge.connect(IoBridge.java:142)\r\n        at java.net.PlainSocketImpl.socketConnect(PlainSocketImpl.java:142)\r\n        at java.net.AbstractPlainSocketImpl.doConnect(AbstractPlainSocketImpl.java:390)\r\n        at java.net.AbstractPlainSocketImpl.connectToAddress(AbstractPlainSocketImpl.java:230)\r\n        at java.net.AbstractPlainSocketImpl.connect(AbstractPlainSocketImpl.java:212)\r\n        at java.net.SocksSocketImpl.connect(SocksSocketImpl.java:436)\r\n        at java.net.Socket.connect(Socket.java:621)\r\n        at java.net.Socket.connect(Socket.java:570)\r\n        at java.net.Socket.<init>(Socket.java:450)\r\n        at java.net.Socket.<init>(Socket.java:218)\r\n        at javax.net.DefaultSocketFactory.createSocket(SocketFactory.java:279)\r\n        at com.google.android.exoplayer2.source.rtsp.RtspClient.getSocket(RtspClient.java:304)\r\n        at com.google.android.exoplayer2.source.rtsp.RtspClient.start(RtspClient.java:198)\r\n        at com.google.android.exoplayer2.source.rtsp.RtspMediaPeriod.prepare(RtspMediaPeriod.java:158)\r\n        at com.google.android.exoplayer2.source.MaskingMediaPeriod.prepare(MaskingMediaPeriod.java:145)\r\n        at com.google.android.exoplayer2.source.MaskingMediaPeriod.prepare(MaskingMediaPeriod.java:145)\r\n        at com.google.android.exoplayer2.ExoPlayerImplInternal.maybeUpdateLoadingPeriod(ExoPlayerImplInternal.java:1981)\r\n        at com.google.android.exoplayer2.ExoPlayerImplInternal.updatePeriods(ExoPlayerImplInternal.java:1961)\r\n        at com.google.android.exoplayer2.ExoPlayerImplInternal.doSomeWork(ExoPlayerImplInternal.java:961)\r\n        at com.google.android.exoplayer2.ExoPlayerImplInternal.handleMessage(ExoPlayerImplInternal.java:495)\r\n        at android.os.Handler.dispatchMessage(Handler.java:102)\u00a0\r\n        at android.os.Looper.loop(Looper.java:223)\u00a0\r\n        at android.os.HandlerThread.run(HandlerThread.java:67)\u00a0\r\n     Caused by: android.system.ErrnoException: connect failed: ETIMEDOUT (Connection timed out)\r\n        at libcore.io.Linux.connect(Native Method)\r\n        at libcore.io.ForwardingOs.connect(ForwardingOs.java:94)\r\n        at libcore.io.BlockGuardOs.connect(BlockGuardOs.java:138)\r\n        at libcore.io.ForwardingOs.connect(ForwardingOs.java:94)\r\n        at libcore.io.IoBridge.connectErrno(IoBridge.java:156)\r\n        at libcore.io.IoBridge.connect(IoBridge.java:134)\r\n        at java.net.PlainSocketImpl.socketConnect(PlainSocketImpl.java:142)\u00a0\r\n        at java.net.AbstractPlainSocketImpl.doConnect(AbstractPlainSocketImpl.java:390)\u00a0\r\n        at java.net.AbstractPlainSocketImpl.connectToAddress(AbstractPlainSocketImpl.java:230)\u00a0\r\n        at java.net.AbstractPlainSocketImpl.connect(AbstractPlainSocketImpl.java:212)\u00a0\r\n        at java.net.SocksSocketImpl.connect(SocksSocketImpl.java:436)\u00a0\r\n        at java.net.Socket.connect(Socket.java:621)\u00a0\r\n        at java.net.Socket.connect(Socket.java:570)\u00a0\r\n        at java.net.Socket.<init>(Socket.java:450)\u00a0\r\n        at java.net.Socket.<init>(Socket.java:218)\u00a0\r\n        at javax.net.DefaultSocketFactory.createSocket(SocketFactory.java:279)\u00a0\r\n        at com.google.android.exoplayer2.source.rtsp.RtspClient.getSocket(RtspClient.java:304)\u00a0\r\n        at com.google.android.exoplayer2.source.rtsp.RtspClient.start(RtspClient.java:198)\u00a0\r\n        at com.google.android.exoplayer2.source.rtsp.RtspMediaPeriod.prepare(RtspMediaPeriod.java:158)\u00a0\r\n        at com.google.android.exoplayer2.source.MaskingMediaPeriod.prepare(MaskingMediaPeriod.java:145)\u00a0\r\n        at com.google.android.exoplayer2.source.MaskingMediaPeriod.prepare(MaskingMediaPeriod.java:145)\u00a0\r\n        at com.google.android.exoplayer2.ExoPlayerImplInternal.maybeUpdateLoadingPeriod(ExoPlayerImplInternal.java:1981)\u00a0\r\n        at com.google.android.exoplayer2.ExoPlayerImplInternal.updatePeriods(ExoPlayerImplInternal.java:1961)\u00a0\r\n        at com.google.android.exoplayer2.ExoPlayerImplInternal.doSomeWork(ExoPlayerImplInternal.java:961)\u00a0\r\n        at com.google.android.exoplayer2.ExoPlayerImplInternal.handleMessage(ExoPlayerImplInternal.java:495)\u00a0\r\n        at android.os.Handler.dispatchMessage(Handler.java:102)\u00a0\r\n        at android.os.Looper.loop(Looper.java:223)\u00a0\r\n        at android.os.HandlerThread.run(HandlerThread.java:67)\u00a0\r\n```",
    "comments_url": "https://api.github.com/repos/google/ExoPlayer/issues/10946/comments",
    "author": "MarcinWad",
    "comments": [
      {
        "user": "marcbaechinger",
        "created_at": "2023-01-26T15:27:02Z",
        "body": "@claincly May I ask you to take a look? Thanks!"
      },
      {
        "user": "claincly",
        "created_at": "2023-01-26T16:57:49Z",
        "body": "First, the `timeoutMs` setter is not for the network, so as you have observed, it's doing no good.\r\n\r\nIn your specific use case, IIUC you need to set a timeout on the `Socket` itself, and this timeout will ensure the connection error is surfaced earlier than the current value (which is the platform specific, and two minutes as you said.)\r\n\r\nI would suggest make your own `SocketFactory`, which can be as easy as\r\n\r\n```\r\n    new RtspMediaSource.Factory()\r\n        .setSocketFactory(\r\n            new SocketFactory() {\r\n              SocketFactory defaultSocketFactory = SocketFactory.getDefault();\r\n\r\n              @Override\r\n              public Socket createSocket(String host, int port) throws IOException {\r\n                Socket socket = defaultSocketFactory.createSocket();\r\n                socket.connect(\r\n                    new InetSocketAddress(InetAddress.getByName(host), port), /* timeout= */ 1000);\r\n                return socket;\r\n              }\r\n\r\n              @Override\r\n              public Socket createSocket(\r\n                  String host, int port, InetAddress localHost, int localPort) {\r\n                throw new UnsupportedOperationException();\r\n              }\r\n\r\n              @Override\r\n              public Socket createSocket(InetAddress host, int port) {\r\n                throw new UnsupportedOperationException();\r\n              }\r\n\r\n              @Override\r\n              public Socket createSocket(\r\n                  InetAddress address, int port, InetAddress localAddress, int localPort) {\r\n                throw new UnsupportedOperationException();\r\n              }\r\n            });\r\n\r\n```\r\n"
      },
      {
        "user": "MarcinWad",
        "created_at": "2023-01-27T07:10:06Z",
        "body": "Hello,\r\nThank you.\r\nAdding own implementation of SocketFactory fixes the problem and Exo is not blocking main thread anymore.\r\n\r\nI think that adding this functionality to a Builder of RTSPMediaSource would be better idea. I digged almost whole Internet before i wrote here :)\r\n\r\n\r\n\r\n"
      },
      {
        "user": "claincly",
        "created_at": "2023-01-27T11:58:54Z",
        "body": "Glad it helped!"
      }
    ]
  },
  {
    "number": 10897,
    "title": "Identify onPlaybackStatsReady callbacks for Ads playback",
    "created_at": "2023-01-02T13:18:42Z",
    "closed_at": "2023-01-07T11:44:25Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/google/ExoPlayer/issues/10897",
    "body": "As mentioned in docs for `PlaybackStatsListener`, `onPlaybackStatsReady` callback is called separately for main playback item and all of the inserted ads (e.g. pre-roll ads). Since `PlaybackStats` for ad playbacks are not important for me, I only want to log stats for the main media item. Is there a way to identify the type of media item for which the  `PlaybackStats` is prepared?",
    "comments_url": "https://api.github.com/repos/google/ExoPlayer/issues/10897/comments",
    "author": "MBakhshi96",
    "comments": [
      {
        "user": "tonihei",
        "created_at": "2023-01-05T09:13:28Z",
        "body": "The `eventTime` parameter of `onPlaybackStatsReady` tells you about which playback the stats belong to. In particular, the `EventTime` contains a `Timeline` with the full playlist and ad information and the `mediaPeriodId` field that tells you about the current ad group index and ad index. "
      },
      {
        "user": "MBakhshi96",
        "created_at": "2023-01-07T11:43:42Z",
        "body": "I'm now using `eventTime.mediaPeriodId.isAd()` to filter ad playbacks and it seems to work. Thank you for your help."
      }
    ]
  },
  {
    "number": 10896,
    "title": "How to signal that the activation status of an `AudioProcessor` has changed?",
    "created_at": "2023-01-01T17:56:21Z",
    "closed_at": "2023-01-05T16:46:04Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/google/ExoPlayer/issues/10896",
    "body": "As an optimization, I try to avoid \"no-op\" scenarios that would require an expensive copy in my `AudioProcessor` by overriding `isActive` and returning `false` if the `AudioProcessor` has nothing to do. The issue is that the activation status can change during playback, and I've recently realized that ExoPlayer is highly inconsistent in when it checks if the `AudioProcessor` is active. \r\n\r\nFor example, if the `AudioProcessor` was *active*, then became *inactive*, and then became *active* again, ExoPlayer picks up on it immediately. However, if the `AudioProcessor` starts *inactive* and then becomes *active*, ExoPlayer does not pick up on it until the next `MediaItem` plays. This results in really in-explicable issues in my app.\r\n\r\nIs there a way to signal ExoPlayer to always re-check my `AudioProcessor` when it's activation status changes? There should be some way to do it given that `SonicAudioProcessor` could feasibly change it's activation status during playback too. Without this, I'm stuck either with this inconsistent behavior or removing the `isActive` optimization entirely and doing a copy when there's nothing to do, neither of which are desirable in any capacity.\r\n\r\nAny help here would be appreciated.",
    "comments_url": "https://api.github.com/repos/google/ExoPlayer/issues/10896/comments",
    "author": "OxygenCobalt",
    "comments": [
      {
        "user": "tonihei",
        "created_at": "2023-01-05T16:39:07Z",
        "body": "Your observations fit the current implementation:\r\nWhether `AudioProcessors` are active or not is evaluated only once during set up. And they are only reset when the chain of processors if flushed (e.g. when the format changes, a new item starts playing or new `PlaybackParameters` are applied). The reason for this is that the chain of processors takes the output format of one processor and uses it as input format for the next processor in the list. If you suddenly deactivated a processor in a chain without flushing, the input format wouldn't match anymore. Moreover, if the chain suddenly produces a new output format (e.g. because some processors got activated/deactivated), the entire AudioTrack needs to be flushed. \r\n\r\nThere are probably two ways in which you can make this work:\r\n 1. *Change your audio processor to be a no-op, but leave it active*: This still requires one copy of the audio data. You mentioned that you consider this expensive, but given it's just audio data it shouldn't be too bad. The implementation can call `replaceOutputBuffer(inputBuffer.remaining()).put(inputBuffer).flip()` from `queueInput` (assuming you overwrite `BaseAudioProcessor`). This should also avoid any additional memory allocations mid-playback.\r\n 2. *Treat this as a feature request to force a audio processor chain flush/re-configure*: There is currently no way for you to do this without interrupting playback. We could add a method to `DefaultAudioSink` that lets you reconfigure the audio processors mid-playback. This is non-trivial and we are unlikely to address this soon. "
      },
      {
        "user": "OxygenCobalt",
        "created_at": "2023-01-05T16:46:04Z",
        "body": "Okay, I'll just do a copy then and take the worse performance on high-bitrate files."
      }
    ]
  },
  {
    "number": 10834,
    "title": "SimplePool for Exoplayer",
    "created_at": "2022-12-05T15:56:40Z",
    "closed_at": "2023-01-16T14:34:18Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/google/ExoPlayer/issues/10834",
    "body": "Describe your question in detail:\r\n\r\nHello, my application use extensively Exoplayer and I wanted to make some improvement for my users ( ~440 000 users with phone from API 21 to API 26).\r\n\r\nFor context my app is just like Youtube, so users browse between pages which result in an ever-ending cycle of:\r\n1. creating Exoplayer\r\n2. setting mediaSource + listeners\r\n3. playing/pausing\r\n4. removing listener + releasing Exoplayer\r\n\r\nI was wondering if creating/releasing player is more resource-consuming than creating a Pool with 2 instances of Exoplayer? What's your opinion about using a `SimplePool<Exoplayer>(2)` ?\r\n",
    "comments_url": "https://api.github.com/repos/google/ExoPlayer/issues/10834/comments",
    "author": "yoobi",
    "comments": [
      {
        "user": "marcbaechinger",
        "created_at": "2022-12-06T13:33:00Z",
        "body": "Using a pool of player can make sense for some use cases. I wouldn't think about performance in the sense opf resources required to create the players. It is certainly needs a bit more resources to recreate new instances, but I would focus on performance only in the sense of user experience. That is, if you want to play two videos in a `RecyclerView` or a `ViewPager` and the surfaces on which the video is rendered are visible at the same time, then you possibly need two players to be able to have at least one frame rendered on each of the surfaces. In general, if your app needs to decode two videos at the same time, you need multiple instances.\r\n\r\nHowever, if you do that you need to take care of some low-level devices possibly do not support multiple instances of the video codec being used at the same time. So it gets a bit more complicated.\r\n\r\nIn general I would say if there is no need in terms of user experience I would stick with a single instance for simplicity. But I think in your case it can make sense to use a pool.\r\n\r\nThis is an advanced problem to solve properly and people asked question around this quite a lot. So it also makes sense to search the existing issues a bit to learn how other users solved this problem. An example issue about how to use the player in a `RecyclerView` is #867. \r\n\r\n"
      },
      {
        "user": "yoobi",
        "created_at": "2022-12-06T15:24:23Z",
        "body": "Thank you for your detailed answer ! My issue is not really caused by a `RecyclerView` or `ViewPager` albeit it can relate in a sense.\r\n\r\nLet's say we have `VideoPageFragment` which creates a new `Exoplayer` instance in `fun onStart()` and destroy the instance in `onStop()`. Therefore there is only one instance of Exoplayer at a time.\r\n \r\n1. User browse to`VideoPageFragment` to watch a video called: \"Building Exoplayer Part 1\"\r\n2. User clicks on button \"Next\", hence destroying the last `VideoPageFragment` and creating a new `VideoPageFragment` with data of the next video.\r\n3. User close the app\r\n\r\nWith this simple 3-step example, the user has created and destroyed 2 instance of `Exoplayer`. Would using a Pool make sense for such a case ?"
      },
      {
        "user": "yoobi",
        "created_at": "2023-01-16T09:29:54Z",
        "body": "Do you have some advice ?"
      },
      {
        "user": "marcbaechinger",
        "created_at": "2023-01-16T10:46:54Z",
        "body": "I understand there is only one fragment active and  only one instance playing at a time that can be shared by these fragments.  I think in this case I would just have a single instance that is created in the activity, that you can use from the fragment by using `((ExoPlayerHostingActivity)getActivity()).getPlayer()`. The fragments lifecycle methods can then be used to set media sources, prepare the player and start playback. Afterwards the player is pause, stopped and released. For such a use case without overlapping playback a single instance sounds sufficient.  "
      },
      {
        "user": "yoobi",
        "created_at": "2023-01-16T11:09:44Z",
        "body": "I'm ashamed to say I didn't think of that because this is simple and brilliant. I'll go with that instead of doing a pool.\r\n\r\nThanks"
      }
    ]
  },
  {
    "number": 10543,
    "title": "Intercepting notification events",
    "created_at": "2022-08-22T18:02:13Z",
    "closed_at": "2022-09-01T15:31:10Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/google/ExoPlayer/issues/10543",
    "body": "I would like to intercept the notification events, so I can implement custom functionality when they are fired. Currently, they are being handled in this `NotificationBroadcastReceiver`:\r\n\r\n```java\r\n @Override\r\n    public void onReceive(Context context, Intent intent) {\r\n      Player player = PlayerNotificationManager.this.player;\r\n      if (player == null\r\n          || !isNotificationStarted\r\n          || intent.getIntExtra(EXTRA_INSTANCE_ID, instanceId) != instanceId) {\r\n        return;\r\n      }\r\n      String action = intent.getAction();\r\n      if (ACTION_PLAY.equals(action)) {\r\n        if (player.getPlaybackState() == Player.STATE_IDLE) {\r\n          player.prepare();\r\n        } else if (player.getPlaybackState() == Player.STATE_ENDED) {\r\n          player.seekToDefaultPosition(player.getCurrentMediaItemIndex());\r\n        }\r\n        player.play();\r\n      } else if (ACTION_PAUSE.equals(action)) {\r\n        player.pause();\r\n      } else if (ACTION_PREVIOUS.equals(action)) {\r\n        player.seekToPrevious();\r\n      } else if (ACTION_REWIND.equals(action)) {\r\n        player.seekBack();\r\n      } else if (ACTION_FAST_FORWARD.equals(action)) {\r\n        player.seekForward();\r\n      } else if (ACTION_NEXT.equals(action)) {\r\n        player.seekToNext();\r\n      } else if (ACTION_STOP.equals(action)) {\r\n        player.stop(/* reset= */ true);\r\n      } else if (ACTION_DISMISS.equals(action)) {\r\n        stopNotification(/* dismissedByUser= */ true);\r\n      } else if (action != null\r\n          && customActionReceiver != null\r\n          && customActions.containsKey(action)) {\r\n        customActionReceiver.onCustomAction(player, action, intent);\r\n      }\r\n    }\r\n```\r\n\r\nSadly, I can't replace the receiver with my own, since it's private:\r\n\r\n`  private final NotificationBroadcastReceiver notificationBroadcastReceiver;`\r\n\r\nI was thinking of maybe overriding `getActions` and `getActionIndicesForCompactView` and make my own custom actions, but the original actions are used in so many cases in functions that are not overridable that I don't think it's possible to mimic when they are called. \r\n\r\nMy final solution is to just make my own notification manager from scratch, but I hope it doesn't come to that.\r\n\r\nIs there a way that I haven't found to intercept those events?",
    "comments_url": "https://api.github.com/repos/google/ExoPlayer/issues/10543/comments",
    "author": "mpivchev",
    "comments": [
      {
        "user": "marcbaechinger",
        "created_at": "2022-08-22T22:12:38Z",
        "body": "You can use a `ForwardingPlayer` to intercept the method calls done in `onReceive`. Issue #10212 has some more detail. Please let me know if this helps for your use case."
      },
      {
        "user": "mpivchev",
        "created_at": "2022-09-01T15:31:03Z",
        "body": "`ForwardingPlayer` did the trick, thank you."
      }
    ]
  },
  {
    "number": 10533,
    "title": "Do not Deprecate Player.Listener.onPlayerStateChanged()",
    "created_at": "2022-08-17T16:56:36Z",
    "closed_at": "2022-08-17T17:36:12Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/google/ExoPlayer/issues/10533",
    "body": "### [REQUIRED] Use case description\r\n\r\nI need to listen for a state where the video is playing. The only way to do that right now is using `Player.Listener.onPlayerStateChanged()`.\r\n\r\n```\r\nexoPlayer.addListener(object : Player.Listener {\r\n            override fun onPlayerStateChanged(playWhenReady: Boolean, playbackState: Int) {\r\n                if (playWhenReady && playbackState == ExoPlayer.STATE_READY) {\r\n                    // The video is playing\r\n                }\r\n            }\r\n        })\r\n```\r\n\r\nHowever, this method is marked as deprecated. `onPlaybackStateChanged(int)` and `onPlayWhenReadyChanged(boolean, int)` are being recommended. However, none of them provides the state that the video is actually playing.\r\n\r\n`onPlaybackStateChanged()` could means it's still loading and `onPlayWhenReadyChanged` could means it's loaded but still paused.\r\n\r\n\r\n\r\n### Proposed solution\r\nWe should un-deprecate `onPlayerStateChanged`\r\n\r\n\r\n\r\n### Alternatives considered\r\nOr adde a new state: `STATE_PLAYING`\r\n",
    "comments_url": "https://api.github.com/repos/google/ExoPlayer/issues/10533/comments",
    "author": "GC-Xi",
    "comments": [
      {
        "user": "rohitjoins",
        "created_at": "2022-08-17T17:36:12Z",
        "body": "@GC-Xi You can use either of the options below to know if the video is playing:\r\n\r\n1.  `onEvents(Player player, Events events)` callback which has a reference to player and check\r\n```\r\nif (events.contains(Player.EVENT_PLAY_WHEN_READY_CHANGED) && player.getPlaybackState() == ExoPlayer.STATE_READY) {\r\n    // The video is playing\r\n}\r\n```\r\n2. `Player.isPlaying()` which returns whether the player is playing."
      },
      {
        "user": "GC-Xi",
        "created_at": "2022-08-18T10:22:18Z",
        "body": "@rohitjoins That worked. Thanks!"
      }
    ]
  },
  {
    "number": 10529,
    "title": "is there any difference between addMediasource and setMediasource method as in case of setMediaSource method we always need to call player.prepare method? will it affect start time of video?",
    "created_at": "2022-08-16T13:31:44Z",
    "closed_at": "2022-08-17T18:36:37Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/google/ExoPlayer/issues/10529",
    "body": null,
    "comments_url": "https://api.github.com/repos/google/ExoPlayer/issues/10529/comments",
    "author": "kshailes",
    "comments": [
      {
        "user": "rohitjoins",
        "created_at": "2022-08-17T18:36:37Z",
        "body": "@kshailes Based on the documentation for these methods:\r\n\r\n- `setMediaSource` : Clears the playlist and adds the specified MediaSource\r\n- `addMediaSource` : Adds a media source to the end of the playlist. \r\n\r\nSo that is basically the difference between these methods. Both these methods have multiple overridden methods to reset position or start playing from a particular index in the playlist.\r\n\r\n`player.prepare()` is called to move the player out of idle state and start loading media, which for `addMediaSource` is not always required if the player is already playing a playlist and a media source gets added to the list.\r\n\r\n"
      },
      {
        "user": "kshailes",
        "created_at": "2022-08-17T19:39:09Z",
        "body": "thanks @rohitjoins "
      }
    ]
  },
  {
    "number": 10452,
    "title": "How to configure forward and rewind time values for player notification manager?",
    "created_at": "2022-07-19T09:31:41Z",
    "closed_at": "2022-07-19T10:49:03Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/google/ExoPlayer/issues/10452",
    "body": "By default rewind button in the notification seeking player time by 5 seconds but forward button seeking player by 15 seconds. Can't find any direct functions in the player notification manager javadoc.",
    "comments_url": "https://api.github.com/repos/google/ExoPlayer/issues/10452/comments",
    "author": "shaiksalam9182",
    "comments": [
      {
        "user": "marcbaechinger",
        "created_at": "2022-07-19T10:02:28Z",
        "body": "When you build your player you can set the `seekBackIncrements` or the `seekForwardIncrement` by using the setters of the `ExoPlayer.Builder`. This sets the seek increments generally for all `Player.seekBack()` and `Player.seekForward()` calls on that player instance.\r\n\r\nIf you want to have the behaviour specific for commands coming from the notification, you can use a `ForwardingPlayer` with which you wrap the player. Then you set the forwarding player to the `PlayerNotificationManager.setPlayer(forwardingPlayer)` and you can override the `seekBack()` and `seekForward()` methods on the forwarding player to customize it to fit your requirements.\r\n\r\n"
      },
      {
        "user": "shaiksalam9182",
        "created_at": "2022-07-19T10:49:03Z",
        "body": "Thanks @marcbaechinger . It's working now"
      }
    ]
  },
  {
    "number": 10396,
    "title": "Intercepting DAI stream URL using the ExoPlayer IMA extension",
    "created_at": "2022-07-01T14:02:13Z",
    "closed_at": "2022-07-13T08:31:36Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/google/ExoPlayer/issues/10396",
    "body": "Hi, \r\n\r\nwe are currently trying out the ExoPlayer IMA extension for IMA server side inserted ad streams in our android app, by using `ImaServerSideAdInsertionMediaSource`. We encountered the following problem and would like to ask you how to best handle it.\r\n\r\nWe have been using the trick to have a placeholder @TOKEN@ configured in ad manager and replace it in our client with the proper auth token. The hook to do this seems to be missing from the IMA extension.\r\nWith a previous IMA SDK integration, the IMA SDK functionality was implemented by our client app, resolving the media URL dynamically in order to get the stitched stream. This allowed us to manipulate the loaded media URL of the stitched stream (via `VideoStreamPlayer.loadUrl(...` callback), so we could replace a stream token placeholder for authorisation, before passing the stitched stream url to the player. \r\n\r\nBy using `ImaServerSideAdInsertionMediaSource`, the stitched stream URL seems to be passed to the player internally, and we were not yet able to find any way to intercept this stitched stream media URL over the new IMA extension API.\r\n\r\nDo you have any suggestions as to how to best handle stream authorisation in the given context?\r\n\r\nThanks in advance!\r\n",
    "comments_url": "https://api.github.com/repos/google/ExoPlayer/issues/10396/comments",
    "author": "amiantoch",
    "comments": [
      {
        "user": "amiantoch",
        "created_at": "2022-07-11T12:50:33Z",
        "body": "Hi,\r\n\r\nare there any updates on this issue?\r\nIs any additional information required from our side to further clarify?\r\n\r\nThanks\r\n"
      },
      {
        "user": "marcbaechinger",
        "created_at": "2022-07-11T18:04:31Z",
        "body": "I'm not quite sure whether I understand all your requirements and what manipulations you want to do at what moment in time of the SDK/Player interaction. But I think there are some hooks that are useful for you to know about.\r\n\r\nThe `ImaServerSideAdInsertionMediaSource.Factory` allows app to set their `MediaSourceFactory` by passing it to the constructor. By default apps want this to be the `DefaultMediaSourceFactory` to support HLS and DASH. In your case you may want to take advantage of this flexibility:\r\n\r\n1) You can inject your own custom `DataSource.Factory` into the constructor of the `DefaultMediaSourceFactory` and then inject that into the constructor of the `ImaServerSideAdInsertionMediaSource.Factory`. The custom `DataSource.Factory` would then create a `ResolvingDataSource` that wraps the concrete `DataSource` that you are using. The `ResolvingDataSource` allows you to replace the `DataSpec` with your modified version by providing a `Resolver` and overriding its\r\n\r\n```\r\nDataSpec resolveDataSpec(DataSpec dataSpec) throws IOException;\r\n```\r\n\r\nThe `DataSpec` passed in is what you would have seen in `loadUrl` (I think) and you can create a new `DataSpec` replacing that with whatever you like in the resolver. \r\n\r\nNote: If I'm not mistaken then the `Resolver` will be called for any requests manifest/playlist and any media (video/audio/text).\r\n\r\n2) An alternative would be to implement your own `MediaSource.Factory` and pass it to the constructor of `ImaServerSideAdInsertionMediaSource.Factory`. Your implementation is a composition that delegates everything to an instance of `DefaultMediaSourceFactory` that you hold as a member field. Then when `MediaSource.Factory.createMediaSource(MediaItem)` is called your wrapper source receives the `MediaItem` and can `buildUpon()` to inject the modified URI before delegating to `createMediaSource` of the actual source and pass the new `MediaItem`.\r\n\r\nNote: This approach does only manipulate the initial URI that is used to load the manifest/playlist initially. After that, media and the like is requested as without this change.\r\n\r\nI hope one or the other approach may work for you. Please let me know in either case. :)"
      },
      {
        "user": "amiantoch",
        "created_at": "2022-07-13T08:31:36Z",
        "body": "Very useful tips!:)\r\nThe second solution seems to be working perfectly for our needs.\r\n\r\nThank you!"
      }
    ]
  },
  {
    "number": 10268,
    "title": "ForwardingPlayer.setPlayWhenReady is not being called",
    "created_at": "2022-05-17T21:56:44Z",
    "closed_at": "2022-05-24T10:49:32Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/google/ExoPlayer/issues/10268",
    "body": "From migrating a `DefaultControlDispatcher` to `ForwardingPlayer`, do I need to implement something else besides only creating an instance of the `ForwardingPlayer` class? Because I'm not getting called the method `setPlayWhenReady` from the `ForwardingPlayer` but other methods are called as `getPlayWhenReady` and `isPlaying`, for example.\r\n\r\nThis is reproducible in the ExoPlayer Demo app v2.17.1 by just passing a `ForwardingPlayer` object to the `playerView` object through the method `setPlayer()`\r\n\r\nThank you!\r\n",
    "comments_url": "https://api.github.com/repos/google/ExoPlayer/issues/10268/comments",
    "author": "nandovelazquez",
    "comments": [
      {
        "user": "marcbaechinger",
        "created_at": "2022-05-17T22:07:42Z",
        "body": "The `PlayerControlView` is using `player.play()` and `player.pause()` which is delegated by the `ForwardingPlayer` to the wrapped `Player`. Then the wrapped player is calling `setPlayWhenReady(true|false)` but not on the `ForwardingPlayer` but internally on itself.\r\n\r\nSo you can intercept these calls by overriding `play()` and `pause()` of your `ForwardingPlayer`."
      },
      {
        "user": "nandovelazquez",
        "created_at": "2022-05-20T17:17:09Z",
        "body": "Thanks for the quick response!\r\n\r\nThe methods `play()` and `pause()` work. It might be helpful if that behavior is somewhere in the documentation for future references.\r\n\r\nThanks again."
      },
      {
        "user": "marcbaechinger",
        "created_at": "2022-05-24T10:49:32Z",
        "body": "We added a section about 'ForwardingPlayer' to the developer guide that will be published with the next release."
      }
    ]
  },
  {
    "number": 10262,
    "title": "Method to disable sequential playback on MediaSource level",
    "created_at": "2022-05-16T09:53:15Z",
    "closed_at": "2022-05-17T09:22:01Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/google/ExoPlayer/issues/10262",
    "body": "I am looking for a way to disable sequential playback of mp3s on `MediaSource` level (of course, the MediaSource in my case is a `ConcatenatingMediaSource`). I know about the method `setPauseAtEndOfMediaItems` on exoplayer level. But this disables sequential playback for ALL media sources used by exoplayer. I would like to disable sequential playback on one `MediaSource` while enable it on another `MediaSource`. Is there something like `MediaSource.setPauseAtEndOfMediaItems` ? Thank you!",
    "comments_url": "https://api.github.com/repos/google/ExoPlayer/issues/10262/comments",
    "author": "tosam144",
    "comments": [
      {
        "user": "marcbaechinger",
        "created_at": "2022-05-16T21:02:24Z",
        "body": "There is no API for this I'm afraid, but I think implementing this with the existing API is straightforward.\r\n\r\nYou can listen to `Player.Listener.onMediaItemTransition(mediaItem, reason)` then look at the media item and set `pauseAtEndOfMediaItems` accordingly.\r\n\r\nWould that work?"
      },
      {
        "user": "tosam144",
        "created_at": "2022-05-17T09:10:18Z",
        "body": "Excellent, @marcbaechinger: thank you. That works perfectly indeed."
      }
    ]
  },
  {
    "number": 10128,
    "title": "Ffmpeg extension quesion",
    "created_at": "2022-03-30T05:25:24Z",
    "closed_at": "2022-03-30T14:19:17Z",
    "labels": [
      "question",
      "needs triage"
    ],
    "url": "https://github.com/google/ExoPlayer/issues/10128",
    "body": "I'm able to build the ffmpeg extension and use it in the demo app and my own app. But I want to just have the armeabi-v7a and arm64-v8a libraries generated only to reduce the apk size. When I build the demo project, it seems  x86 and x64_64 libraries needs to be in  the ANDROID-LIBS folder. I build the ffmpeg extension in  the Linux machine and  copy the ffmpeg directory to Windows 10  where Android Studio is resided. What needs to be done to achieve this? Thanks.\r\n\r\n",
    "comments_url": "https://api.github.com/repos/google/ExoPlayer/issues/10128/comments",
    "author": "tpuserhp",
    "comments": [
      {
        "user": "vovan888",
        "created_at": "2022-03-30T10:58:23Z",
        "body": "app/build.gradle:\r\n\r\n```\r\nandroid {\r\n        ndk {\r\n            abiFilters \"armeabi-v7a\", \"arm64-v8a\"\r\n        }\r\n}\r\n\r\n```"
      },
      {
        "user": "tpuserhp",
        "created_at": "2022-03-30T14:19:16Z",
        "body": "Yes, the suggested changes resulted in a smaller size of the apk  generated. Thank you very much  for your help. This issue can be closed now."
      }
    ]
  },
  {
    "number": 10023,
    "title": "Custom controller layout not recognizing play and pause buttons.",
    "created_at": "2022-03-03T14:33:23Z",
    "closed_at": "2022-03-04T08:39:18Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/google/ExoPlayer/issues/10023",
    "body": "Hi, I think there is a bug with the custom controller layout.\r\n\r\nI tried to add a custom controller layout to StyledPlayerView on the demo app and it is loaded, but when I override the exo_play and exo_pause buttons they don't work. \r\nWeird thing is that exo_ffwd and exo_rew work as expected (I didn't try others).\r\n\r\nPlayer Activity contains StyledPlayerView\r\n\r\n```\r\n    <com.google.android.exoplayer2.ui.StyledPlayerView\r\n          android:id=\"@+id/player_view\"\r\n          android:layout_width=\"match_parent\"\r\n          android:layout_height=\"match_parent\"\r\n          app:controller_layout_id=\"@layout/exo_player_layout\"/>\r\n```\r\n\r\n\r\nAnd this is exo_player_layout\r\n\r\n\r\n```\r\n     <LinearLayout\r\n            android:id=\"@+id/play_controls\"\r\n            android:layout_width=\"wrap_content\"\r\n            android:layout_height=\"wrap_content\"\r\n            android:gravity=\"center\">\r\n\r\n            <ImageButton\r\n                android:id=\"@id/exo_play\"\r\n                android:layout_width=\"wrap_content\"\r\n                android:layout_height=\"wrap_content\"\r\n                app:srcCompat=\"@drawable/ic_exo_play\" />\r\n\r\n            <ImageButton\r\n                android:id=\"@id/exo_pause\"\r\n                android:layout_width=\"wrap_content\"\r\n                android:layout_height=\"wrap_content\"\r\n                app:srcCompat=\"@drawable/ic_exo_pause\"/>\r\n\r\n        </LinearLayout>\r\n\r\n```\r\n\r\nDoes anyone have any ideas?",
    "comments_url": "https://api.github.com/repos/google/ExoPlayer/issues/10023/comments",
    "author": "mdurokov",
    "comments": [
      {
        "user": "marcbaechinger",
        "created_at": "2022-03-03T15:00:21Z",
        "body": "I think the `StyledPlayerView` is using `@id/exo_play_pause` rather than `@id/exo_play` and `@id/exo_pause`.\r\n\r\nIf you want to provide your custom layout you should use a single button with `@+id/exo_play_pause`. The styled control view does not hide/show one or the other of these buttons, but instead change the drawable of the icon. If you want to change these icons you can do so by adding a `drawables.xml` in the `values` folder of the app module to override the drawables used by default:\r\n\r\n```\r\n<resources>\r\n  <drawable name=\"exo_styled_controls_play\">@drawable/custom_controls_play</drawable>\r\n  <drawable name=\"exo_styled_controls_pause\">@drawable/custom_controls_pause</drawable>\r\n</resources>\r\n``` \r\n\r\nPlease see #10008 also which is about a similar issue.\r\n\r\nThere were quite some changes in the ui components, so if the above does not help, please let us know the exact ExoPlayer version you are depending to with your app."
      },
      {
        "user": "mdurokov",
        "created_at": "2022-03-04T08:39:18Z",
        "body": "That does the trick, thank you! \r\nI didn't see it documented anywhere.\r\nAs a matter of fact, I did use PlayerView before and it worked with exo_play and exo_pause. "
      },
      {
        "user": "draganstojanov",
        "created_at": "2022-03-10T12:10:51Z",
        "body": "It works. But, i have two sets of icons, one for vertical oriented video and other for horizontal oriented. Is there any way to programmatically override drawables?"
      }
    ]
  },
  {
    "number": 9945,
    "title": "Allow LoadControl to prevent loading indefinitely",
    "created_at": "2022-02-07T13:00:18Z",
    "closed_at": "2022-06-09T12:26:05Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/google/ExoPlayer/issues/9945",
    "body": "My use case here is that I would like to prevent loading by overriding DefaultLoadControl if the user switches to a mobile data connection. Due to data caps not everybody wants to use their data towards video streaming. I would like to offer a setting to opt in using mobile data (just like you need to explicitly allow automatic app updates when not on wifi).\r\n\r\nYou can easily reproduce this by overriding `shouldContinueLoading` and always returning `false`.\r\n\r\nApparently there are some legitimate cases where the player could get stuck which is why there is a check for this in `ExoPlayerImplInternal`:\r\n\r\n```\r\nif (!playbackInfo.isLoading\r\n    && playbackInfo.totalBufferedDurationUs < 500_000\r\n    && isLoadingPossible()) {\r\n  // Throw if the LoadControl prevents loading even if the buffer is empty or almost empty. We\r\n  // can't compare against 0 to account for small differences between the renderer position\r\n  // and buffered position in the media at the point where playback gets stuck.\r\n  throw new IllegalStateException(\"Playback stuck buffering and not loading\");\r\n}\r\n```\r\n\r\nIs there a better way to achieve this without running into an Exception? I would like this to be fully recoverable: if the user connects to wifi again streaming should continue without having to prepare the player again.\r\n\r\nIf not I would like to request a configuration flag to override this for my use case. I cannot imagine that I am the only one facing this.",
    "comments_url": "https://api.github.com/repos/google/ExoPlayer/issues/9945/comments",
    "author": "wkarl",
    "comments": [
      {
        "user": "tonihei",
        "created_at": "2022-05-17T15:34:08Z",
        "body": ">  I would like this to be fully recoverable: if the user connects to wifi again streaming should continue without having to prepare the player again.\r\n\r\nThis is an interesting request in that the player is technically doing the right thing: it detects the playback as being stuck and fails. The issue is that you actually want the player to be stuck forever (or until the WiFi connection comes back). I think it would make more sense to let the player fail, display an appropriate message to the user (\"no internet connection / waiting for WiFi\") and just call `player.prepare()` once the Wifi is available again. There isn't a big cost involved in calling `prepare` again (other than recreating the decoder) because there is no already downloaded data left to play anyway, so it's unclear why you want to avoid re-preparation. \r\n\r\nTwo further thoughts on general setup:\r\n - It's not too unlikely that the user will stay on the mobile data connection for a considerable amount of time, so they might not expect playback to continue anyway? \r\n - To create a consistent user experience, you likely need to implement the same logic for a client that goes offline completely. However, that's not easily possible because sudden switches to offline will almost certainly result in network-related playback errors instead of a stuck-buffering exception, so it's unlikely you can prevent the player from going into an error state when the connection is lost completely. "
      },
      {
        "user": "wkarl",
        "created_at": "2022-05-18T05:05:00Z",
        "body": "Thank you for your detailed response @tonihei \r\nAbout the two further thoughts you mentioned:\r\n> It's not too unlikely that the user will stay on the mobile data connection for a considerable amount of time, so they might not expect playback to continue anyway?\r\n\r\nThis only applies to users with a very limited data plan. Many users will want to continue playing on mobile data. That's why there is a \"allow mobile data playback\" button in the dialog we display: it will dismiss the message and continue playing immediately (in addition to a switch in the app settings).\r\n\r\n> To create a consistent user experience, you likely need to implement the same logic for a client that goes offline completely. However, that's not easily possible because sudden switches to offline will almost certainly result in network-related playback errors instead of a stuck-buffering exception, so it's unlikely you can prevent the player from going into an error state when the connection is lost completely.\r\n\r\nYou'd be surprised how well this works. I modified `DefaultLoadErrorHandlingPolicy` to keep retrying playback for this case. As soon as a connection is restored the stream continues playing without fail.\r\n\r\nAs you suggested I currently just call `player.prepare()` again but there are a few downsides:\r\n- The error must be suppressed for this specific case when reporting errors to Firebase etc. to avoid inflating playback errors.\r\n- Semantics: I see this specific case as more of a prompt than an actual error. Handling in the app is very different to regular errors.\r\n- Recovery would be simpler: just unblock `LoadControl` instead of specialised error handling.\r\n- To make sure the video is resumed at the correct position, I either need to remember the position where the error occurred or skip setting the media item again (or use `player.setMediaItem(mediaItem, false)` to keep the position).\r\n\r\nDespite the successful workaround this would definitely be a nice-to-have for me."
      },
      {
        "user": "tonihei",
        "created_at": "2022-05-18T11:20:13Z",
        "body": "> To make sure the video is resumed at the correct position, I either need to remember the position where the error occurred or skip setting the media item again (or use player.setMediaItem(mediaItem, false) to keep the position).\r\n\r\nI believe this should just work without any special workarounds? If you just call `prepare()` after the error and nothing else, playback should continue from where it left off and the whole playlist should still be intact.\r\n\r\n>  You'd be surprised how well this works. I modified DefaultLoadErrorHandlingPolicy to keep retrying playback for this case. As soon as a connection is restored the stream continues playing without fail.\r\n\r\nThis is certainly possible (although I think not the original intention of the `LoadErrorHandlingPolicy`). If you handle network errors in this way anyway, I believe you can achieve your goal with the mobile data connection via the same path by using a `DataSource` wrapper that throws a custom exception when Wifi is lost.\r\n\r\nSomething like (pseudo-code):\r\n```\r\nclass NetworkAwareDataSource implements DataSource {\r\n\r\n   private DataSource actualDataSource;\r\n\r\n   @Override \r\n   public void allDataSourceMethods(...) {\r\n      actualDataSource.method(...);\r\n    }\r\n\r\n   @Override \r\n   public int read(....) throws IOException {\r\n      if (networkLost) {\r\n        throw new CustomNetworkLostIOException();\r\n      }\r\n      return actualDataSource.read(...);\r\n   }\r\n}\r\n```\r\nand you can then pass this `DataSource` to the `DefaultMediaSourceFactory` in the `ExoPlayer.Builder` (or your more specific `MediaSource.Factory` depending on your setup)."
      },
      {
        "user": "wkarl",
        "created_at": "2022-05-18T19:24:54Z",
        "body": "That looks like a good approach, thank you for the suggestion!"
      },
      {
        "user": "tonihei",
        "created_at": "2022-06-09T12:26:05Z",
        "body": "Closing the issue, because the question was answered. "
      }
    ]
  },
  {
    "number": 9870,
    "title": "Unable to fetch the Chunk Size and Latency during playing the video",
    "created_at": "2022-01-18T11:24:15Z",
    "closed_at": "2022-01-21T14:21:12Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/google/ExoPlayer/issues/9870",
    "body": "Hi Team,\r\n\r\nCurrently, I am using the 2.12.1 version and trying to fetch the Chunk Size and Latency by calling the MediaSourceEventListener but I didn't get a call inside the onLoadCompleted Override method.\r\n\r\nPlease find the onLoadCompleted method logic\r\n\r\n@Override\r\n    public void onLoadCompleted(int windowIndex, @Nullable MediaSource.MediaPeriodId mediaPeriodId, LoadEventInfo loadEventInfo, MediaLoadData mediaLoadData) {\r\n        mLatestChunkLatency = loadEventInfo.loadDurationMs;\r\n        mLatestChunkSize = (int) ((mediaLoadData.mediaEndTimeMs - mediaLoadData.mediaStartTimeMs) / 1000);\r\n    }\r\n    \r\n    How to find the Chunk Size and Latency without updating the version?",
    "comments_url": "https://api.github.com/repos/google/ExoPlayer/issues/9870/comments",
    "author": "satishkumar-tudip",
    "comments": [
      {
        "user": "christosts",
        "created_at": "2022-01-21T14:12:19Z",
        "body": "I don't know how you are creating MediaSources and attaching listeners to them in your app, however can you try attaching an `AnalyticsListener` to the player and override its `onLoadCompleted()`?\r\n\r\nLet me know if that worked."
      },
      {
        "user": "satishkumar-tudip",
        "created_at": "2022-01-21T14:15:20Z",
        "body": "Hi @christosts \r\nThank you for the reply, I have already attached the AnalyticsListener and it's working now."
      }
    ]
  },
  {
    "number": 9751,
    "title": "seekToPrevious() in PlayerControlView can't change to the previous mediaItem",
    "created_at": "2021-12-02T10:18:02Z",
    "closed_at": "2021-12-02T12:25:54Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/google/ExoPlayer/issues/9751",
    "body": "I'm used PlayeControlView in the xml layout, when I clicked previous button, it's just seek to the start of current mediaItem.\r\n\r\nI find that there is a method `seekToPreviousMediaItem()` , but in PlayeControlView, it's called `seekToPrevious()`, then it's will get the current playing position and judge is change to previous or seek to 0 of current item.\r\n\r\nI just want to change the previous item, but I can't control it if I use PlayeControlView ,since I can't override the onClick()\r\n\r\n",
    "comments_url": "https://api.github.com/repos/google/ExoPlayer/issues/9751/comments",
    "author": "lizebinbin",
    "comments": [
      {
        "user": "ojw28",
        "created_at": "2021-12-02T12:25:54Z",
        "body": "You can achieve this by wrapping the player in a `ForwardingPlayer`, and overriding the `seekToPrevious()` behavior:\r\n\r\n```\r\nPlayer forwardingPlayer = new ForwardingPlayer(player) {\r\n  @Override\r\n  public long getMaxSeekToPreviousPosition() {\r\n      return 0;\r\n  }\r\n  @Override\r\n  public final void seekToPrevious() {\r\n    seekToPreviousMediaItem();\r\n  }\r\n};\r\nplayerView.setPlayer(forwardingPlayer);\r\n``` "
      },
      {
        "user": "lizebinbin",
        "created_at": "2021-12-03T03:29:02Z",
        "body": "than\r\n\r\n> You can achieve this by wrapping the player in a `ForwardingPlayer`, and overriding the `seekToPrevious()` behavior:\r\n> \r\n> ```\r\n> Player forwardingPlayer = new ForwardingPlayer(player) {\r\n>   @Override\r\n>   public long getMaxSeekToPreviousPosition() {\r\n>       return 0;\r\n>   }\r\n>   @Override\r\n>   public final void seekToPrevious() {\r\n>     seekToPreviousMediaItem();\r\n>   }\r\n> };\r\n> playerView.setPlayer(forwardingPlayer);\r\n> ```\r\n\r\nThanks\uff5e"
      }
    ]
  },
  {
    "number": 9683,
    "title": "How to reset the back/forward increments on 2.16.0?",
    "created_at": "2021-11-11T11:08:53Z",
    "closed_at": "2021-11-12T12:29:40Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/google/ExoPlayer/issues/9683",
    "body": "I need to implement **multi-speed** fast-forward/backward when the user multi-tap the forward/backward button. \r\n\r\n> Remove ControlDispatcher and DefaultControlDispatcher. Operations can be customized by using a ForwardingPlayer, or when configuring the player (for example by using ExoPlayer.Builder.setSeekBackIncrementMs).\r\n\r\nThe above is written at the release note for 2.16.0\r\nwe were using the `DefaultControlDispatcher(long fastForwardIncrementMs, long rewindIncrementMs)` or `playerView.setFastForwardIncrementMs(positionOffset)`/`playerView.setRewindIncrementMs(positionOffset)`.\r\n\r\nbut this class is already removed. we should using `ExoPlayer.Builder.setSeekBackIncrementMs` according to the release note. but I can't see how we can reset the increments after the player is built.\r\n\r\nCould you guys please help to figure out it? maybe I am missing sth.",
    "comments_url": "https://api.github.com/repos/google/ExoPlayer/issues/9683/comments",
    "author": "MiaJiaXa",
    "comments": [
      {
        "user": "christosts",
        "created_at": "2021-11-12T12:12:12Z",
        "body": "Let me confirm I understood the question, I also read your comments on #9492: In your app, when the user changes the player speed, you would re-construct the `DefaultControlDispatcher` with the updated `fastForwardIncrementMs` and  `rewindIncrementMs`, is this correct?\r\n\r\nIf my understanding is correct, you can achieve the same by using the `ForwardingPlayer`: wrap the `Player` in a `ForwardingPlayer` and override the `ForwardingPlayer``s `seekForward` and `seekBack` . Your implementation of these two methods can take the player's forward or backward increment values, multiply them by a factor (2x for double speed?) and then call `Player.seekTo` accordingly, for example\r\n\r\n```\r\nForwardingPlayer forwardingPlayer = new ForwardingPlayer(player) {\r\n      @Override\r\n      public void seekForward() {        \r\n        // Double the forward increment.\r\n        long seekForwardIncrement = player.getSeekForwardIncrement() * 2;\r\n        seekToOffset(seekForwardIncrement);\r\n      }\r\n\r\n      // Copied from DefaultContorlDispatcher implementation.\r\n      private void seekToOffset(long offsetMs) {\r\n        long positionMs = player.getCurrentPosition() + offsetMs;\r\n        long durationMs = player.getDuration();\r\n        if (durationMs != C.TIME_UNSET) {\r\n          positionMs = min(positionMs, durationMs);\r\n        }\r\n        positionMs = max(positionMs, 0);\r\n        player.seekTo(positionMs);\r\n      }\r\n    };\r\n```\r\n\r\nYou'll need of course to find a way to update the multiplication factors in your `ForwardingPlayer`, but that's a general programming task (e.g., you can subclass `ForwardingPlayer` and add additional setters). Please let me know if that works for your app, so we can close this issue."
      },
      {
        "user": "MiaJiaXa",
        "created_at": "2021-11-12T12:29:37Z",
        "body": "Yeah, It helped. A lot of thanks! @christosts  :)"
      }
    ]
  },
  {
    "number": 9656,
    "title": "Language Key from .m3u8 file doesn't match language key in track group",
    "created_at": "2021-11-07T06:47:26Z",
    "closed_at": "2021-11-08T21:42:15Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/google/ExoPlayer/issues/9656",
    "body": "In my .m3u8 file, I have a track for subtitles in Indonesian, with language key \"id\". \r\nIt looks like this: \r\n`#EXT-X-MEDIA:TYPE=SUBTITLES,GROUP-ID=\"subs\",NAME=\"Indonesian\",DEFAULT=NO,AUTOSELECT=YES,FORCED=NO,LANGUAGE=\"id\",URI=\"main_id.m3u8\"`\r\n\r\nAfter it's parsed into the player's track group, the language key is \"ms-ind-d\"\r\nIt looks like this: \r\n`Format(subs:Indonesian _ Indonesia, Indonesian _ Indonesia, application/x-mpegURL, text/vtt, null, -1, ms-ind-id, [-1, -1, -1.0], [-1, -1])`\r\n\r\nThe same thing happens with Norwegian. The language key in the .m3u8 file is \"nb\", but when it's parsed by the player, it becomes \"no-nob\".\r\n\r\nWhy does this happen?",
    "comments_url": "https://api.github.com/repos/google/ExoPlayer/issues/9656/comments",
    "author": "tinder-sophiafrench",
    "comments": [
      {
        "user": "tonihei",
        "created_at": "2021-11-08T09:28:04Z",
        "body": "> Language Key from .m3u8 file doesn't match language key in track group\r\n\r\nThe reason why this happens in general is to allow comparison between values and ensuring everything is in the same format. ExoPlayer receives language keys from at least 3 different sources: The media itself (like the m3u8 file), user preferences that are set in the parameters (e.g. TrackSelectionParameters.preferredAudioLanguages) and also system Locale information. All 3 sources use potentially different formats and standards to represent a language, so we normalize all language input to a consistent format. \r\n\r\n> \"id\" to \"ms-ind\" and \"nb\" to\" no-nob\"\r\n\r\nOur chosen standardization format is ISO 639-1, including mapping all existing individual language codes within a macrolanguage to the equivalent full macrolanguage code. The macrolanguage code is the most modern representation and the only one we can easily use for normalization from all variants. For example, \"id\" is a code that was defined for Indonesian originally, but then the standardization body later introduced \"ms\" for the Malayan macrolanguage Indonesion is part of. So we map \"id\" to \"ms-ind\" and other deprecated codes like \"in\", \"ind\" are also mapped to \"ms-ind\".  The same happens for \"nb\", \"nob\" and \"no-bok\", which are all mapped to its full modern macrolanguage code of \"no-nob\"."
      },
      {
        "user": "tinder-sophiafrench",
        "created_at": "2021-11-08T21:42:15Z",
        "body": "Thank you for the explanation. "
      }
    ]
  },
  {
    "number": 9614,
    "title": "How can i play RTSP stream without audio codecs?",
    "created_at": "2021-10-27T12:09:20Z",
    "closed_at": "2021-11-10T14:10:23Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/google/ExoPlayer/issues/9614",
    "body": "How can i play RTSP stream without audio codecs? I need only video?I can't start watch stream because camera using g.711 for audio.\r\n",
    "comments_url": "https://api.github.com/repos/google/ExoPlayer/issues/9614/comments",
    "author": "LostInAbyss",
    "comments": [
      {
        "user": "claincly",
        "created_at": "2021-11-01T10:40:27Z",
        "body": "The player drops the formats that it cannot play and plays the playable formats only. In your case, G711 will be automatically dropped and the player should start playing video only.\r\n\r\nPlease comment if that's not the case."
      },
      {
        "user": "LostInAbyss",
        "created_at": "2021-11-10T13:54:38Z",
        "body": "Thanks for answer!"
      },
      {
        "user": "claincly",
        "created_at": "2021-11-10T14:10:23Z",
        "body": "I'm closing it for now, please feel free to re-open."
      }
    ]
  },
  {
    "number": 9369,
    "title": "Check if an error is caused by a Renderer",
    "created_at": "2021-09-01T08:09:40Z",
    "closed_at": "2021-09-01T12:21:40Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/google/ExoPlayer/issues/9369",
    "body": "In version 2.15.0 the **onPlayerError** signature has changed from:\r\n\r\n`public void onPlayerError(ExoPlaybackException error)`\r\n\r\nto:\r\n\r\n`public void onPlayerError(PlaybackException error)`\r\n\r\nWith the older signature we could check if the error was caused by a renderer by querying the error type:\r\n\r\n`if (error.type == ExoPlaybackException.TYPE_RENDERER)`\r\n\r\nHow can now be checked with **PlaybackException**? There is no equivalent in **PlaybackException.errorCode**\r\n\r\n\r\n",
    "comments_url": "https://api.github.com/repos/google/ExoPlayer/issues/9369/comments",
    "author": "perracodex",
    "comments": [
      {
        "user": "AquilesCanta",
        "created_at": "2021-09-01T12:21:40Z",
        "body": "The simple answer is: Use\r\n\r\n```\r\nif (error instanceof ExoPlaybackException\r\n    && ((ExoPlaybackException) error).type == ExoPlaybackException.TYPE_RENDERER)\r\n```\r\n\r\nBut the better answer is use `error.errorCode` which provides a finer grained description of what the issue is.\r\n\r\n"
      },
      {
        "user": "perracodex",
        "created_at": "2021-09-01T12:29:02Z",
        "body": "Thank you for the answer.\r\nI checked all the possible codes available for **error.errorCode**, but couldn't find any to be the equivalent for **TYPE_RENDERER**,\r\nShould I assume that for all \"renderer\" errors the only solution would be as in your answer?"
      },
      {
        "user": "AquilesCanta",
        "created_at": "2021-09-01T12:35:42Z",
        "body": "There is no equivalent of TYPE_RENDERER because knowing that an error happened in the renderer is deemed not useful. It just tells you it happened in the renderer. The cause could be a DRM issue, an AudioTrack issue, a decoder issue, or even something else. So knowing the type is not really a significant usecase. It would be more meaningful to know what you do if the error is of TYPE_RENDERER."
      }
    ]
  },
  {
    "number": 9341,
    "title": "Behaviour of `getMinimumLoadableRetryCount` in `DefaultLoadErrorHandlingPolicy`",
    "created_at": "2021-08-26T09:06:14Z",
    "closed_at": "2021-09-01T08:13:05Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/google/ExoPlayer/issues/9341",
    "body": "ExoPlayerVersion: v2.15.0\r\n\r\nI am trying to give retry count for the http calls which Exo is doing internally (Be it manifest, Chunk/Segment, DRM).\r\nFor that, I have my class which extends to `DefaultLoadErrorHandlingPolicy` and I am overriding `getMinimumLoadableRetryCount` in order to achieve it.\r\n\r\n**Question:** I can see that when i pass count 2 then LoadError is coming 3 times and then it gives SourceError. I mean when I give value greater than 1, it always results in +1 LoadError.\r\n\r\nBut when I give 0 or 1 in count, it always results with LoadError 2 times.\r\nI think Exo is internally starting from 0 (with Index). But what is going on with 0 or 1 count value. \r\n\r\nExo is calling it **minLoadableRetryCount**, is there something max as well ? \r\nCan you please suggest on it ? Is this the expected behaviour. \r\n\r\nI have tested in ExoDemo app as well by hard coding the return value in `getMinimumLoadableRetryCount` of `DefaultLoadErrorHandlingPolicy`. It is the same behaviour as explained above.\r\n",
    "comments_url": "https://api.github.com/repos/google/ExoPlayer/issues/9341/comments",
    "author": "GouravSna",
    "comments": [
      {
        "user": "GouravSna",
        "created_at": "2021-08-30T05:06:03Z",
        "body": "Hi @ojw28 , Can you please help me on this."
      },
      {
        "user": "ojw28",
        "created_at": "2021-08-31T11:14:45Z",
        "body": "As per the documentation, `getMinimumLoadableRetryCount` returns a _minimum_ number of retries. The player may make more retry attempts than this. This approach is generally useful to allow the player to continue making additional retries for errors that may be recoverable, for as long as it's able to play out media that it had already buffered.\r\n\r\nIf you want to impose a maximum limit then I think you can do so by overriding `getRetryDelayMsFor` to do something like:\r\n\r\n```\r\nif (loadErrorInfo.errorCount > maxRetryCount) {\r\n  return C.TIME_UNSET;\r\n}\r\nreturn super.getRetryDelayMsFor(loadErrorInfo);\r\n```\r\n\r\nAs per the Javadoc for that method:\r\n\r\n> A return value of {@link C#TIME_UNSET} indicates that the error is fatal and should not be retried."
      },
      {
        "user": "GouravSna",
        "created_at": "2021-08-31T11:24:37Z",
        "body": "Sure. Thanks @ojw28 \r\nI will try it."
      }
    ]
  },
  {
    "number": 9302,
    "title": "How to get Proper AdprogressInfo using Exoplayer extension of IMA",
    "created_at": "2021-08-16T08:25:47Z",
    "closed_at": "2021-08-18T14:48:53Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/google/ExoPlayer/issues/9302",
    "body": "How I will get ad player current position when ad is playing. Am able to get ad duration but am not getting ad current position means that how much second being played. Am working on custom ad controller using exoplayer ima extension,  so I required this information. Please help.",
    "comments_url": "https://api.github.com/repos/google/ExoPlayer/issues/9302/comments",
    "author": "adityaroutandroid",
    "comments": [
      {
        "user": "ojw28",
        "created_at": "2021-08-16T16:26:58Z",
        "body": "Just calling `getCurrentPosition` on the player should give you the playback position within the ad. If you're interested in the position within the content (i.e., the position from which playback of the content will resume after the ad has finished playing), then you can call `getContentPosition`."
      },
      {
        "user": "adityaroutandroid",
        "created_at": "2021-08-18T14:48:53Z",
        "body": "thanks @ojw28. Its working as expected."
      }
    ]
  },
  {
    "number": 9148,
    "title": "How to clear the view and the buffer?",
    "created_at": "2021-07-04T13:31:44Z",
    "closed_at": "2021-09-06T13:41:45Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/google/ExoPlayer/issues/9148",
    "body": "My app is focusing on downloading videos and then playing them with Exoplayer. And obviously Downloading comes together with deleting the file.\r\n\r\nSo the downloading/playing parts work but then I want to be able to clear the player when the user is deleting the video he/she is playing. So I have:\r\n\r\n```\r\nvideoView.player?.stop()\r\nvideoView.player?.release()\r\n```\r\n\r\nHowever, the videoview still shows the image that it was last playing and I'm also guessing that the buffer is still there because when I delete and redownload the same video just after I cannot play it, it gives me this error:\r\n\r\n```\r\nE/ExoPlayerImplInternal: Playback error\r\n      com.google.android.exoplayer2.ExoPlaybackException: Source error\r\n        at com.google.android.exoplayer2.ExoPlayerImplInternal.handleMessage(ExoPlayerImplInternal.java:580)\r\n        at android.os.Handler.dispatchMessage(Handler.java:102)\r\n        at android.os.Looper.loop(Looper.java:246)\r\n        at android.os.HandlerThread.run(HandlerThread.java:67)\r\n     Caused by: com.google.android.exoplayer2.source.UnrecognizedInputFormatException: None of the available extractors (Mp4Extractor, AdtsExtractor) could read the stream.\r\n        at com.google.android.exoplayer2.source.BundledExtractorsAdapter.init(BundledExtractorsAdapter.java:92)\r\n        at com.google.android.exoplayer2.source.ProgressiveMediaPeriod$ExtractingLoadable.load(ProgressiveMediaPeriod.java:1027)\r\n        at com.google.android.exoplayer2.upstream.Loader$LoadTask.run(Loader.java:417)\r\n        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1167)\r\n        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:641)\r\n        at java.lang.Thread.run(Thread.java:923)\r\n```\r\n\r\n(i tried to use all the possible exrtractors)\r\n\r\nHow can I clear view and buffer in this case and then still being able to play the new downloaded video?",
    "comments_url": "https://api.github.com/repos/google/ExoPlayer/issues/9148/comments",
    "author": "Clement-Jean",
    "comments": [
      {
        "user": "marcbaechinger",
        "created_at": "2021-07-05T12:00:55Z",
        "body": "Can you give some more details what you do after calling `release`? Because I'd say that after releasing you have to recreate the player to restart playback with a new stream.\r\n\r\nI don't think it has something to do with the buffer because data in the buffer isn't read by the extractor. For my understanding the data in the buffer has been extracted by an extractor already and is then buffered before it is sent to the codec.\r\n\r\nCan you give some more details in how you release and then recreate the player in your code?"
      },
      {
        "user": "Clement-Jean",
        "created_at": "2021-07-05T23:21:39Z",
        "body": "I was not recreating the player but yesterday I saw that the `release` documentation says something like `don't use the player after calling this`.\n\nSo I recreated it and it works. However, I wonder if there is a less \"heavy\" way of doing this because I have a player with a Playlist (ConcatenatingMediaSource) and I need to reinitialize everything each time this event happens.\n\nWhat do you think ?"
      },
      {
        "user": "marcbaechinger",
        "created_at": "2021-07-07T09:51:59Z",
        "body": "I think it should be enough to just remove the `MediaSource` for the given stream to the download that have been removed. Then you can create a new `MediaSource` and add it to the `ConcatentaingMediaSource` again. When the user then seeks to that item in the playlist (or playback transitions to it automatically), the new source will be prepared.\r\n\r\n```\r\nconcatenatingMediaSource.removeMediaSource(index);\r\nconcatenatingMediaSource.addMediaSource(index, newMediaSource);\r\n```\r\n\r\nAs an aside, we support playlist with a top level API since a while (2.12). So you could move from the concatenating media source to `player.addMediaSource()`. \r\n\r\n```\r\nplayer.removeMediaSource(index);\r\nplayer.addMediaSource(index, newMediaSource);\r\n```"
      }
    ]
  },
  {
    "number": 9008,
    "title": "Issue with wrap_content in ExoPlayerView. ExoPlayerView height remain 0 at run-time if it set to wrap_content",
    "created_at": "2021-06-02T11:46:32Z",
    "closed_at": "2021-06-02T17:14:09Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/google/ExoPlayer/issues/9008",
    "body": "[Condition]\r\n - video url only available\r\n\r\nThe title of this issue was on Stack Overflow but there was no answer.\r\n\r\nI was trying to set exoplayers to recyclerview with multiple media source.\r\n\r\nAutomatic video playback takes up space appropriately. Also, if the height value is given as an absolute value, thumbnail can be seen through the \"use_artwork\" option even if no replay is made('But it's not fit to the given layout).\r\n\r\nSo I brought a thumbnail separately through Glide, but it was too slow.\r\n\r\nIs there a way to automatically set the height value without playing the EXO player automatically or setting an absolute value?\r\n\r\n```\r\n<com.google.android.exoplayer2.ui.PlayerView\r\n                android:layout_width=\"match_parent\"\r\n                android:layout_height=\"wrap_content\"\r\n                app:use_artwork=\"true\"\r\n                app:resize_mode=\"fit\"\r\n                app:show_buffering=\"when_playing\"\r\n                />\r\n```",
    "comments_url": "https://api.github.com/repos/google/ExoPlayer/issues/9008/comments",
    "author": "JiyongYang",
    "comments": [
      {
        "user": "andrewlewis",
        "created_at": "2021-06-02T14:12:57Z",
        "body": "If you are trying to set the height of the player view such that it matches the shape of the video but without actually loading the video I don't think there is a way to do that. You can `pause()` the player before preparing it if you want to load the media (and acquire resources for buffering and decoders) but not actually start playback. I'm not sure I follow the question though, so perhaps you could rephrase?"
      },
      {
        "user": "JiyongYang",
        "created_at": "2021-06-02T17:14:09Z",
        "body": "Thank you. It really helped. I think calling `pause()` is way more effective than using other lib."
      }
    ]
  },
  {
    "number": 8833,
    "title": "Equivalent callback for onTimelineChanged with reason TIMELINE_CHANGE_REASON_PREPARED, on versiosn 2.12+",
    "created_at": "2021-04-20T10:32:13Z",
    "closed_at": "2021-04-29T08:37:46Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/google/ExoPlayer/issues/8833",
    "body": "Hi,\r\n\r\nOn my project, when playing a live stream, i need to make a seek to a specific time of the day, when starting playing a new stream. \r\nTo do that, on ExoPlayer 2.11.x i relied the callback for `onTimelineChanged `with reason `TIMELINE_CHANGE_REASON_PREPARED`. \r\nWhen that callback was called, i could get the media duration, and with the offset from the currentTime, calculate the position to pass to the `seekTo `method (`player.duration - System.currentTime - timeOfTheDayToSeekTo`).\r\n\r\nAfter version 2.12.0, `TIMELINE_CHANGE_REASON_PREPARED `was removed, and when the callback is called with reason `TIMELINE_CHANGE_REASON_PLAYLIST_CHANGED`, the player duration still undefined.\r\n\r\nI could rely on the callback being called with `TIMELINE_CHANGE_REASON_SOURCE_UPDATE`, but since that is called multiple times, i need to make extra checks to be sure i only make the seek on the first call after the media is changed, and the `timeOfTheDayToSeekTo `is set.\r\n\r\n\r\nMy question is:\r\nOn versions 2.12.+ is there any equivalent callback to `onTimelineChanged`, with reason `TIMELINE_CHANGE_REASON_PREPARED `on 2.11.x (Only called once, before the first the first frame is rendered, and after the media duration is known) ? \r\n\r\nIs there any way make a relative seek, like seek to 30000ms before the live edge/default position (something like seekTo(-30000) so i can set the seek position right after calling prepare without knowing the media duration?\r\n\r\nThanks in advance",
    "comments_url": "https://api.github.com/repos/google/ExoPlayer/issues/8833/comments",
    "author": "jrocharodrigues",
    "comments": [
      {
        "user": "marcbaechinger",
        "created_at": "2021-04-21T13:50:27Z",
        "body": "For 2.12. the equivalent is the first call with `TIMELINE_CHANGE_REASON_SOURCE_UPDATE` like you mention. For non-live sources this commonly is called only once. To answer your question, there is no alternative that is called only once for live streams I'm afraid.\r\n\r\nFor the second question you may want to use the extended live support we added with 2.13 where you can set the target offset from the live edge. So you could calculate the offset for the time to which you want to seek \r\n\r\n```\r\nMediaItem mediaItem = new MediaItem.Builder()\r\n        .setUri(uri)\r\n        .setLiveTargetOffsetMs(10 * 60_000)\r\n        .build();\r\n```\r\n\r\nYou probably want to look into issue #8218 that is about a similar topic for HLS, there is a proposal for adding a new property (not HLS specific) to the live configuration that lets you set the requested live unix start time. I think that would be most precisely what you want. Please drop a comment of interest in that issue if that would be something you'd like to have in a future release.\r\n\r\n```\r\nMediaItem mediaItem = new MediaItem.Builder()\r\n        .setUri(uri)\r\n        .setRequestedLiveUnixStartTimeMs(unixStartTimeMs)\r\n        .build();\r\n```"
      },
      {
        "user": "jrocharodrigues",
        "created_at": "2021-04-21T14:40:02Z",
        "body": "Hi, thanks for your answer.\r\n\r\nFor now i'll use you suggestion:\r\n`MediaItem mediaItem = new MediaItem.Builder()\r\n        .setUri(uri)\r\n        .setLiveTargetOffsetMs(10 * 60_000)\r\n        .build();`\r\n\r\nAs for the new property `setRequestedLiveUnixStartTimeMs` tracked on #8218  , i think it's a good idea, i'll drop a comment suggesting it to be implmented also for Dash.\r\n\r\nbest regards"
      }
    ]
  },
  {
    "number": 8813,
    "title": "Generating Relation Between Offline License and Downloaded Content",
    "created_at": "2021-04-12T23:49:48Z",
    "closed_at": "2021-04-13T11:06:26Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/google/ExoPlayer/issues/8813",
    "body": "Hi,\r\n\r\nI am trying to understand how to create the downloaded license's keySetId and downloaded track. Normally If I am on the latest release that's not an issue. Because we can create a relation between keySetId and download request during the request generation. But since I am on 2.11.4 (due to some other dependencies in the project) I can not find a way to create the relation. \r\n\r\nShould I save the keyset id with the related content id in local storage or some place like that ? Or is there a supportive utility that can manage the keysetId and content relation ? ",
    "comments_url": "https://api.github.com/repos/google/ExoPlayer/issues/8813/comments",
    "author": "olgunkaya",
    "comments": [
      {
        "user": "ojw28",
        "created_at": "2021-04-13T11:06:26Z",
        "body": "`DownloadRequest.data` is available in 2.11.4, and can be used to hold arbitrary application defined data. So you can use that. Note that if you're serializing multiple pieces of data into that field, it's your responsibility to handle versioning and compatibility of the data across different versions of your application.\r\n\r\nAs you've noted, you can also persist the mapping with your own application code."
      },
      {
        "user": "olgunkaya",
        "created_at": "2021-04-13T14:21:12Z",
        "body": "Thanks @ojw28, I was using that field to hold metadata like title etc.. But, now I will add my piece of keySetId array there too. "
      }
    ]
  },
  {
    "number": 8775,
    "title": "add MediaSourceListener using DataSource.Factory ",
    "created_at": "2021-03-29T13:47:23Z",
    "closed_at": "2021-03-31T08:42:47Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/google/ExoPlayer/issues/8775",
    "body": "Hi, since i've migrated to MediaSourceFactory pattern, how can i add a MediaSourceListener if i can't access MediaSource?\r\n\r\ni was able to add listener using the mediaSource.addEventListener(handler, listener) methon and then, prepare the player passing the mediasource: player.prepare(MediaSource mediaSource, boolean resetPosition, boolean resetState)\r\n\r\nBut now, building the player like this, i can't figure out how to listen the mediasource events\r\n```\r\nSimpleExoPlayer player = new SimpleExoPlayer.Builder(context)\r\n    .setMediaSourceFactory(mediaSourceFactory)\r\n    .build();\r\n```\r\n\r\nThank you",
    "comments_url": "https://api.github.com/repos/google/ExoPlayer/issues/8775/comments",
    "author": "GrilloLuca",
    "comments": [
      {
        "user": "marcbaechinger",
        "created_at": "2021-03-30T09:27:26Z",
        "body": "Can you instead use the `AnalyticsListener` that you can add globally to `SimpleExoPlayer`? The events from the `MediaSourceEventListener` are delegated to the `AnalyticsListener`.\r\n\r\n```\r\nSimpleExoPlayer player = new SimpleExoPlayer.Builder(context)\r\n    .setMediaSourceFactory(mediaSourceFactory)\r\n    .build();\r\n\r\nplayer.addAnalyticsListener(new MyAnalyticsListener() {\r\n    public void onLoadStarted(\r\n      EventTime eventTime, LoadEventInfo loadEventInfo, MediaLoadData mediaLoadData) {\r\n          // your implementation\r\n     }\r\n})'\r\n```"
      },
      {
        "user": "GrilloLuca",
        "created_at": "2021-03-31T08:42:39Z",
        "body": "> Can you instead use the `AnalyticsListener` that you can add globally to `SimpleExoPlayer`? The events from the `MediaSourceEventListener` are delegated to the `AnalyticsListener`.\r\n> \r\n> ```\r\n> SimpleExoPlayer player = new SimpleExoPlayer.Builder(context)\r\n>     .setMediaSourceFactory(mediaSourceFactory)\r\n>     .build();\r\n> \r\n> player.addAnalyticsListener(new MyAnalyticsListener() {\r\n>     public void onLoadStarted(\r\n>       EventTime eventTime, LoadEventInfo loadEventInfo, MediaLoadData mediaLoadData) {\r\n>           // your implementation\r\n>      }\r\n> })'\r\n> ```\r\n\r\nthank you, it worked !"
      }
    ]
  },
  {
    "number": 8769,
    "title": "How to enableDecoderFallback for ExoPlayerFactory.newSimpleInstance() ?",
    "created_at": "2021-03-29T06:47:22Z",
    "closed_at": "2021-04-01T16:29:45Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/google/ExoPlayer/issues/8769",
    "body": "Let's say there is an app which uses two third-party media players each one internally implemented using ExoPlayer.\r\nLet's refer to the first player as the \"main\" and the second one as \"aux\".\r\n\r\nThe main player plays content and when the user pauses playback it the application starts the \"aux\" player.\r\nThe aux player plays some special \"pause\" content.\r\n\r\nWhen we were using this scenario with ExoPlayer 2.9.4 this worked with a caveat that the aux player was using the software video decoder while the main player was holding on to the hardware video decoder (it is just paused and not stopped or released). \r\n\r\nWhen we switched to ExoPlayer 2.12.3 this stopped working -- the \"aux\" player now fails with an exception that it cannot allocate the _hardware_ video decoder.\r\n\r\nIn ExoPlayer 2.12.3 there is a way to enable decoder fallback, when it is enabled the behavior is similar to what we used to have with 2.9.4.\r\nThe problem however is that \"aux\" player is using ExoPlayerFactory.newSimpleInstance() and there is no way to enable decoder fallback from this level of API (and decoder fallback is disabled by default).\r\n\r\nDo you have any recommendation on how to work around this issue (without asking the \"main\" player vendor to change the player behavior significantly during pause or asking the \"aux\" player vendor to use different API level for ExoPlayer)?\r\n\r\nAny plans to allow enableDecoderFallback with ExoPlayerFactory.newSimpleInstance() ?\r\n\r\n",
    "comments_url": "https://api.github.com/repos/google/ExoPlayer/issues/8769/comments",
    "author": "sruditsky",
    "comments": [
      {
        "user": "lcf87",
        "created_at": "2021-03-29T13:28:05Z",
        "body": "I don't think supporting `enableDecoderFallback` in `newSimpleInstance` is on our agenda. If you don't have direct influence on the implementations on the two players you are using, I doubt there's a \"workaround\" to enabling that. \r\n\r\nOlly, could you confirm?"
      },
      {
        "user": "ojw28",
        "created_at": "2021-04-01T16:29:45Z",
        "body": "I'm not sure exactly what was in `2.12.3`, but certainly from `2.13.0` you can do:\r\n\r\n```\r\nDefaultRenderersFactory renderersFactory =\r\n    new DefaultRenderersFactory(this).setEnableDecoderFallback(true);\r\nSimpleExoPlayer player =\r\n    new SimpleExoPlayer.Builder(/* context= */ this, renderersFactory)\r\n        ...\r\n        .build();\r\n```"
      },
      {
        "user": "sruditsky",
        "created_at": "2021-04-02T14:31:42Z",
        "body": "Oh, yeah, this should work.\r\nThanks!"
      }
    ]
  },
  {
    "number": 8666,
    "title": "How to know which MediaSource caused ExoPlaybackException (on preloading the next track)?",
    "created_at": "2021-03-03T09:44:43Z",
    "closed_at": "2021-03-03T15:09:23Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/google/ExoPlayer/issues/8666",
    "body": "To handle `ExoPlaybackException` we must implement `EventListener.onPlayerError()`. If for example, we encounter a 403 HTTP error because the track's URL is expired,  we can catch it inside this function and take appropriate actions:\r\n- See which track caused 403 exception.\r\n- Check our application API to see if we have access to a new URL for the track.\r\n- Replace the corresponding MediaSource with a new one having a valid & fresh URL.\r\n- Play the new MediaSource.\r\n\r\nIt isn't clear how we can find which track caused the exception. Currently we are using `player.getCurrentWindowIndex()`. There is a new `mediaPeriodId` in the exception too, but I am not sure how to trace it back to `MediaSource`. Also I am not sure if either of `player.getCurrentWindowIndex()` or ` mediaPeriodId` leads me to the correct `MediaSource`, in case the media source was just preloaded and it is not actually the current playing media source.\r\n",
    "comments_url": "https://api.github.com/repos/google/ExoPlayer/issues/8666/comments",
    "author": "halaei",
    "comments": [
      {
        "user": "marcbaechinger",
        "created_at": "2021-03-03T12:24:36Z",
        "body": "I think with the approach you are currently using, `player.getCurrentWindowIndex()` will return the window index that belongs to the media source that causes the exception (for my explanation I assume that you are not using `ConcatenatingMediaSource` but the top-level playlist API with a 1:1 relationship between media sources and windows). So in case of the playback error it is clear that the source from which the current window originated caused the exception, and you could do something like the following to recover:\r\n\r\n```\r\nMediaItem mediaItem = player.getCurrentMediaItem();\r\nint windowIndex = player.getCurrentWindowIndex();\r\nMediaItem fixedMediaItem = mediaItem.buildUpon().setUri(fixMyUri(mediaItem.playbackProperties.uri)).build();\r\nplayer.removeMediaItem(windowIndex);\r\nplayer.addMediaItem(windowIndex, fixedMediaItem);\r\nplayer.seekTo(windowIndex, C.TIME_UNSET);\r\nplayer.play();\r\nplayer.prepare();\r\n```\r\n\r\nThe reason why this works is that you get the `ExoPlayerPlaybackException` in `onPlayerError` late, namely when the player (that had a load error for the given medias source earlier) wants to start playback for the given window, but can't as no data is available. \r\n\r\nWhile this works, you probably want to get notified about this earlier, which is when you notice that a load error occurs when the player tries to buffer data ahead. In a playlist for which the player transitions to the next item without user interaction, this is when the player tries to load data ahead for the next window. Being aware of this, you could fix your media source ahead of time and possibly don't even run into the playback exception. I don't think I can give you a answer regarding an API that exactly matches this use case. You may want to look into a custom `LoadErrorHandlingPolicy` which gets notified early about such loading errors and can evaluate which url caused the exception. However, there is no API to correlated that properly to the media source that caused this load error though. The API of the `LoadErrorhandlingPolicy` is not designed for this purpose.\r\n\r\nAlso, if the player does not transition automatically to the next window, but instead the user skips to this window you will be late anyway, and encounter the `ExoPlayerPlaybackException` in `onPlayerError` as above. You probably may want to tweak the `LoadErrorHandlingPolicy` for this case to fail with a playback exception  quickly, but again, the API is not designed for this I think."
      },
      {
        "user": "tonihei",
        "created_at": "2021-03-03T13:37:35Z",
        "body": "Just to add to that:\r\nOne further alternative if you want to handle the case early is to listen to `AnalyticsListener.onLoadError` which has an `EventTime` parameter that tells you exactly which item the error is for. "
      },
      {
        "user": "halaei",
        "created_at": "2021-03-03T15:09:23Z",
        "body": "Thanks for your help.\r\nSo I can assume `onPlayerError()` is only called for the current track and they are delayed in case of preloading. Meanwhile I take a look at `LoadErrorhandlingPolicy` and `AnalyticsListener.onLoadError()` to see if I can handle the errors during the preload sooner, so that I can prevent lags.\r\nI hope I get it right."
      }
    ]
  },
  {
    "number": 8632,
    "title": "TextOutput onCues called multiple times with same cue text with segmented WebVTT subtitles",
    "created_at": "2021-02-25T10:47:10Z",
    "closed_at": "2021-02-25T11:12:39Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/google/ExoPlayer/issues/8632",
    "body": "Our stream provider recently changed the way the subtitles are segmented so that a subtitle segment length is the same as the video segment. So now one .vtt file contains subtitles for a 10 second period. Now there can be multiple subtitle segments that contain the same cue if the cue should be visible in 2 different segments.\r\n\r\nExample .vtt segments:\r\n**seg-38.vtt**\r\nWEBVTT\r\n\r\n28\r\n00:05:47.160 --> 00:05:50.000 \r\nThis line is repeated twice\r\n\r\n**seg-39.vtt**\r\nWEBVTT\r\n\r\n28\r\n00:05:47.160 --> 00:05:50.000 \r\nThis line is repeated twice\r\n\r\n29\r\n00:05:52.680 --> 00:05:54.320 \r\nSome other line that is fine\r\n\r\nThe issue with the onCues getting called twice with the same cue causes problems because we use the onCues callback to feed the cues to the Text-To-Speech engine and now users are complaining that they hear the same line twice. \r\n\r\nI was thinking that I could check if the subtitle number (28 in the example above) matches the previous cue's number and skip the duplicate one based on that but there seems to be no way to get that line number from the cue that's provided in the onCues method.\r\n\r\nDo you have any ideas for a workaround for this issue. At first I was thinking about storing the previous cue and checking if the next cue text matches the previous one and then skipping it if it matches but there may be cases where it is intended to have the same text repeat multiple times in a row so that won't really work. I would need to be able to compare the start/end times or subtitle numbers but those aren't provided to the method.\r\n",
    "comments_url": "https://api.github.com/repos/google/ExoPlayer/issues/8632/comments",
    "author": "jarnova",
    "comments": [
      {
        "user": "icbaker",
        "created_at": "2021-02-25T11:12:39Z",
        "body": "> At first I was thinking about storing the previous cue and checking if the next cue text matches the previous one and then skipping it if it matches but there may be cases where it is intended to have the same text repeat multiple times in a row so that won't really work.\r\n\r\nI think this will work actually, because of the way TextOutput uses an empty List<Cue> to indicate 'breaks' between subtitles.\r\n\r\nWhen seeing the subtitles on-screen, there's expected to be no visual difference between these call sequences:\r\n```\r\ntextOutput.onCues([\"cue 1\"]);\r\ntextOutput.onCues([]);\r\ntextOutput.onCues([\"cue 2\"]);\r\ntextOutput.onCues([]);\r\n```\r\n\r\n```\r\ntextOutput.onCues([\"cue 1\"]);\r\ntextOutput.onCues([]);\r\ntextOutput.onCues([\"cue 2\"]);\r\n// cue 2 is already shown on-screen, so showing it again is a no-op\r\ntextOutput.onCues([\"cue 2\"]);\r\ntextOutput.onCues([]);\r\n```\r\n\r\nIf you want your `TextOutput` implementation to mimic this behaviour then it seems the right thing to do is only 'speak' subtitles when they're different to the previous parameter.\r\n\r\nIf a content provider wants subtitle content to 'repeat' in a way that's visible to the viewer they're going to need to make it disappear and reappear (or change some other property e.g. position, color, etc). And these changes will be visible to your memoization implementation:\r\n```\r\ntextOutput.onCues([\"cue 1\"]);\r\ntextOutput.onCues([]);\r\ntextOutput.onCues([\"cue 1\"]);\r\n```\r\n\r\nNote that you'd still be making a lot of assumptions (which may be completely fine if you control the content, just want to call them out).\r\n\r\ne.g. some subtitles are 'typed' onto screen letter-by-letter and thus the call sequence ends up being something like this, which i imagine would upset your TTS engine:\r\n```\r\ntextOutput.onCues([\"c\"])\r\ntextOutput.onCues([\"cu\"])\r\ntextOutput.onCues([\"cue\"])\r\ntextOutput.onCues([\"cue \"])\r\ntextOutput.onCues([\"cue 1\"])\r\n```\r\n\r\nAnd similarly you probably don't want to re-speak subtitles when a second cue is added to the list (i.e. appears on-screen while the first cue stays visible). There the call sequence is something like:\r\n\r\n```\r\ntextOutput.onCues([\"cue 1\"])\r\n// Here you probably only want to say \"cue 2\"\r\ntextOutput.onCues([\"cue 1\", \"cue 2\"])\r\n```\r\n\r\nYou can probably solve the latter case by being careful about how you memoize the cues. The former case seems much harder to solve, it might be easier just to assume your content won't do that..."
      },
      {
        "user": "jarnova",
        "created_at": "2021-02-25T13:54:22Z",
        "body": "Thanks for the fast reply and explanation. Our subtitles are authored so that there is only one subtitle on screen at a time and they should be in a format that is readable by text-to-speech so there won't be those kind of cases that you mentioned in your examples.\r\n\r\nI didn't notice at first that the method will be called with an empty array when there is a change from one subtitle to another so this should actually work just fine in our case as long as there is at least a small gap in the timestamps."
      }
    ]
  },
  {
    "number": 8607,
    "title": "[Question] Previous button is going to the beginning of the stream instead of the previous item in the playlist",
    "created_at": "2021-02-19T08:37:10Z",
    "closed_at": "2021-02-19T10:48:44Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/google/ExoPlayer/issues/8607",
    "body": "I am using the exoplayer to play live streams in a playlist.\r\n\r\nThe previous button instead of going to the previous item in the playlist, it returns to the beginning of the stream of the current item.\r\n\r\nThis happens when I let it play the stream for few seconds then click on the previous button.\r\nIn that case, I need to click twice on the previous button to have it switch to the previous item in the playlist.\r\n\r\nWhat do I need to do in order to force the previous button to ignore the current item's live window and go to the previous item in the playlist?\r\n\r\nThanks",
    "comments_url": "https://api.github.com/repos/google/ExoPlayer/issues/8607/comments",
    "author": "amahouachi",
    "comments": [
      {
        "user": "marcbaechinger",
        "created_at": "2021-02-19T10:17:16Z",
        "body": "This behaviour is defined by the `DefaultControlDispatcher`.  You can create a subclass of `DefaultControlDispatcher`, override `dispatchPrevious` and set the control dispatcher with `PlayerView.setControlDispatcher` or `StyledPlayerView.setControlDispatcher` respectively."
      },
      {
        "user": "amahouachi",
        "created_at": "2021-02-19T10:48:44Z",
        "body": "Works great thanks !\r\n\r\n```kotlin\r\nplayerView.setControlDispatcher(object : DefaultControlDispatcher() {\r\n          override fun dispatchPrevious(player: Player): Boolean {\r\n            player.seekTo(0)\r\n            return super.dispatchPrevious(player)\r\n          }\r\n        })\r\n```"
      }
    ]
  },
  {
    "number": 8509,
    "title": "MediaCodecVideoRenderer error, index=0, format=Format(1, null, null, video/avc, null, -1, null, [720, 1280, 29.969316], [-1, -1]), format_supported=YES",
    "created_at": "2021-01-26T08:51:15Z",
    "closed_at": "2021-01-26T10:59:11Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/google/ExoPlayer/issues/8509",
    "body": "To be honest, it is the first I use the ExoPlayer. And, a problem happened!\r\nwhen the SimpleExoPlayer.stop() invoked, I want the screen(the SurfaceView) is pur black color, So, I did this.\r\n\r\n      stopBtn.setOnClickListener(new View.OnClickListener() {\r\n            @Override\r\n            public void onClick(View v) {\r\n                simpleExoPlayer.stop(true);\r\n                simpleExoPlayer.clearVideoSurfaceHolder(surfaceView.getHolder());\r\n\r\n                SurfaceHolder holder = surfaceView.getHolder();\r\n                Canvas canvas = holder.lockCanvas();\r\n                canvas.drawColor(Color.BLACK);\r\n                holder.unlockCanvasAndPost(canvas);\r\n\r\n                simpleExoPlayer.setVideoSurfaceHolder(surfaceView.getHolder());\r\n            }\r\n        });\r\n        nextBtn.setOnClickListener(new View.OnClickListener() {\r\n            @Override\r\n            public void onClick(View v) {\r\n                MediaItem mediaItem = MediaItem.fromUri(getString(R.string.media_url_mp4));\r\n                simpleExoPlayer.setMediaItem(mediaItem);\r\n                simpleExoPlayer.prepare();\r\n            }\r\n        });` \r\nI click stop button, it running well.\r\nwhen I click the button what name is nextVideo, Yes\uff0cit is Error.\r\nGuys,please tell me WTF?\r\n\r\n`2021-01-26 16:22:37.780 E/SurfaceUtils: Failed to connect to surface 0x71e8f79010, err -22\r\n2021-01-26 16:22:37.780 E/MediaCodec: nativeWindowConnect returned an error: Invalid argument (-22)\r\n2021-01-26 16:22:37.780 E/MediaCodec: configure failed with err 0xffffffea, resetting...\r\n2021-01-26 16:22:37.788 I/OMXClient: IOmx service obtained\r\n2021-01-26 16:22:37.816 W/MediaCodecRenderer: Failed to initialize decoder: OMX.qcom.video.decoder.avc\r\n      java.lang.IllegalArgumentException\r\n        at android.media.MediaCodec.native_configure(Native Method)\r\n        at android.media.MediaCodec.configure(MediaCodec.java:2023)\r\n        at android.media.MediaCodec.configure(MediaCodec.java:1951)\r\n        at com.google.android.exoplayer2.mediacodec.SynchronousMediaCodecAdapter.configure(SynchronousMediaCodecAdapter.java:43)\r\n        at com.google.android.exoplayer2.video.MediaCodecVideoRenderer.configureCodec(MediaCodecVideoRenderer.java:580)\r\n        at com.google.android.exoplayer2.mediacodec.MediaCodecRenderer.initCodec(MediaCodecRenderer.java:1143)\r\n        at com.google.android.exoplayer2.mediacodec.MediaCodecRenderer.maybeInitCodecWithFallback(MediaCodecRenderer.java:1040)\r\n        at com.google.android.exoplayer2.mediacodec.MediaCodecRenderer.maybeInitCodecOrBypass(MediaCodecRenderer.java:604)\r\n        at com.google.android.exoplayer2.mediacodec.MediaCodecRenderer.onInputFormatChanged(MediaCodecRenderer.java:1470)\r\n        at com.google.android.exoplayer2.video.MediaCodecVideoRenderer.onInputFormatChanged(MediaCodecVideoRenderer.java:640)\r\n        at com.google.android.exoplayer2.mediacodec.MediaCodecRenderer.readToFlagsOnlyBuffer(MediaCodecRenderer.java:994)\r\n        at com.google.android.exoplayer2.mediacodec.MediaCodecRenderer.render(MediaCodecRenderer.java:844)\r\n        at com.google.android.exoplayer2.ExoPlayerImplInternal.doSomeWork(ExoPlayerImplInternal.java:892)\r\n        at com.google.android.exoplayer2.ExoPlayerImplInternal.handleMessage(ExoPlayerImplInternal.java:467)\r\n        at android.os.Handler.dispatchMessage(Handler.java:103)\r\n        at android.os.Looper.loop(Looper.java:224)\r\n        at android.os.HandlerThread.run(HandlerThread.java:67)\r\n2021-01-26 16:22:37.820 E/ExoPlayerImplInternal: Playback error\r\n      com.google.android.exoplayer2.ExoPlaybackException: MediaCodecVideoRenderer error, index=0, format=Format(1, null, null, video/avc, null, -1, null, [720, 1280, 29.969316], [-1, -1]), format_supported=YES\r\n        at com.google.android.exoplayer2.ExoPlayerImplInternal.handleMessage(ExoPlayerImplInternal.java:542)\r\n        at android.os.Handler.dispatchMessage(Handler.java:103)\r\n        at android.os.Looper.loop(Looper.java:224)\r\n        at android.os.HandlerThread.run(HandlerThread.java:67)\r\n     Caused by: com.google.android.exoplayer2.mediacodec.MediaCodecRenderer$DecoderInitializationException: Decoder init failed: OMX.qcom.video.decoder.avc, Format(1, null, null, video/avc, null, -1, null, [720, 1280, 29.969316], [-1, -1])\r\n        at com.google.android.exoplayer2.mediacodec.MediaCodecRenderer.maybeInitCodecWithFallback(MediaCodecRenderer.java:1047)\r\n        at com.google.android.exoplayer2.mediacodec.MediaCodecRenderer.maybeInitCodecOrBypass(MediaCodecRenderer.java:604)\r\n        at com.google.android.exoplayer2.mediacodec.MediaCodecRenderer.onInputFormatChanged(MediaCodecRenderer.java:1470)\r\n        at com.google.android.exoplayer2.video.MediaCodecVideoRenderer.onInputFormatChanged(MediaCodecVideoRenderer.java:640)\r\n        at com.google.android.exoplayer2.mediacodec.MediaCodecRenderer.readToFlagsOnlyBuffer(MediaCodecRenderer.java:994)\r\n        at com.google.android.exoplayer2.mediacodec.MediaCodecRenderer.render(MediaCodecRenderer.java:844)\r\n        at com.google.android.exoplayer2.ExoPlayerImplInternal.doSomeWork(ExoPlayerImplInternal.java:892)\r\n        at com.google.android.exoplayer2.ExoPlayerImplInternal.handleMessage(ExoPlayerImplInternal.java:467)\r\n        at android.os.Handler.dispatchMessage(Handler.java:103)\u00a0\r\n        at android.os.Looper.loop(Looper.java:224)\u00a0\r\n        at android.os.HandlerThread.run(HandlerThread.java:67)\u00a0\r\n     Caused by: java.lang.IllegalArgumentException\r\n        at android.media.MediaCodec.native_configure(Native Method)\r\n        at android.media.MediaCodec.configure(MediaCodec.java:2023)\r\n        at android.media.MediaCodec.configure(MediaCodec.java:1951)\r\n        at com.google.android.exoplayer2.mediacodec.SynchronousMediaCodecAdapter.configure(SynchronousMediaCodecAdapter.java:43)\r\n        at com.google.android.exoplayer2.video.MediaCodecVideoRenderer.configureCodec(MediaCodecVideoRenderer.java:580)\r\n        at com.google.android.exoplayer2.mediacodec.MediaCodecRenderer.initCodec(MediaCodecRenderer.java:1143)\r\n        at com.google.android.exoplayer2.mediacodec.MediaCodecRenderer.maybeInitCodecWithFallback(MediaCodecRenderer.java:1040)\r\n        at com.google.android.exoplayer2.mediacodec.MediaCodecRenderer.maybeInitCodecOrBypass(MediaCodecRenderer.java:604)\u00a0\r\n        at com.google.android.exoplayer2.mediacodec.MediaCodecRenderer.onInputFormatChanged(MediaCodecRenderer.java:1470)\u00a0\r\n        at com.google.android.exoplayer2.video.MediaCodecVideoRenderer.onInputFormatChanged(MediaCodecVideoRenderer.java:640)\u00a0\r\n        at com.google.android.exoplayer2.mediacodec.MediaCodecRenderer.readToFlagsOnlyBuffer(MediaCodecRenderer.java:994)\u00a0\r\n        at com.google.android.exoplayer2.mediacodec.MediaCodecRenderer.render(MediaCodecRenderer.java:844)\u00a0\r\n        at com.google.android.exoplayer2.ExoPlayerImplInternal.doSomeWork(ExoPlayerImplInternal.java:892)\u00a0\r\n        at com.google.android.exoplayer2.ExoPlayerImplInternal.handleMessage(ExoPlayerImplInternal.java:467)\u00a0\r\n        at android.os.Handler.dispatchMessage(Handler.java:103)\u00a0\r\n        at android.os.Looper.loop(Looper.java:224)\u00a0\r\n        at android.os.HandlerThread.run(HandlerThread.java:67)\u00a0`\r\n",
    "comments_url": "https://api.github.com/repos/google/ExoPlayer/issues/8509/comments",
    "author": "Kimiar",
    "comments": [
      {
        "user": "andrewlewis",
        "created_at": "2021-01-26T10:59:11Z",
        "body": "I think there's an Android platform limitation that once you've used a `Surface` for drawing from the CPU like this it can't be used as the output surface for a video decoder. See also #6454.\r\n\r\nYour best bet is have a separate view with the background color. This can go on top of the surface view to obscure it until you want to show the video output (when the player triggers the `onRenderedFirstFrame` event). If you don't want to write your own code to do this you could just use the ExoPlayer UI module `StyledPlayerView`, which takes care of this for you."
      },
      {
        "user": "Kimiar",
        "created_at": "2021-01-27T01:46:46Z",
        "body": "Buddy, thanks. You are really great!"
      }
    ]
  },
  {
    "number": 8258,
    "title": "Why does ExoPlayer call updateSelectedTrack() many times when I modify determineIdealSelectedIndex()?",
    "created_at": "2020-11-20T10:44:55Z",
    "closed_at": "2020-11-22T10:53:13Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/google/ExoPlayer/issues/8258",
    "body": "Hi,\r\nWhen I run your **demo** configuration and watch `Google Play H264 (MP4)`, the `AdaptiveTrackSelection.updateSelectedTrack()` is called 15 times, and the selected qualities are recorded as follows:\r\n_Note_: \r\n```java\r\nThe QualityIdx is determined as `length - newSelectedIndex`\r\npublic static final int DEFAULT_MIN_BUFFER_MS = 20_000;\r\npublic static final int DEFAULT_MAX_BUFFER_MS = 20_000; \r\n```\r\n```\r\n2020-11-20 11:17:23.105 5588-5588/com.google.android.exoplayer2.demo I/MINH: Id\tTime\tEstThroughput\tQualityIdx\tBitrate\tBuffer\r\n2020-11-20 11:17:23.105 5588-5588/com.google.android.exoplayer2.demo I/MINH: 1\t989\t4.139778\t6\t1.834968\t0.0\t\r\n2020-11-20 11:17:23.105 5588-5588/com.google.android.exoplayer2.demo I/MINH: 2\t990\t4.139778\t6\t1.834968\t0.0\t\r\n2020-11-20 11:17:23.106 5588-5588/com.google.android.exoplayer2.demo I/MINH: 3\t990\t23.515743\t6\t1.834968\t5.213468\t\r\n2020-11-20 11:17:23.106 5588-5588/com.google.android.exoplayer2.demo I/MINH: 4\t990\t32.762936\t6\t1.834968\t9.359454\t\r\n2020-11-20 11:17:23.106 5588-5588/com.google.android.exoplayer2.demo I/MINH: 5\t990\t32.762936\t6\t1.834968\t13.740843\t\r\n2020-11-20 11:17:23.107 5588-5588/com.google.android.exoplayer2.demo I/MINH: 6\t991\t28.8144\t\t6\t1.834968\t17.874817\t\r\n2020-11-20 11:17:23.107 5588-5588/com.google.android.exoplayer2.demo I/MINH: 7\t993\t28.8144\t\t6\t1.834968\t19.99352\t\r\n2020-11-20 11:17:23.108 5588-5588/com.google.android.exoplayer2.demo I/MINH: 8\t998\t28.8144\t\t6\t1.834968\t19.996836\t\r\n2020-11-20 11:17:23.108 5588-5588/com.google.android.exoplayer2.demo I/MINH: 9\t1003\t27.448479\t6\t1.834968\t19.99776\t\r\n2020-11-20 11:17:23.109 5588-5588/com.google.android.exoplayer2.demo I/MINH: 10\t1008\t31.993544\t6\t1.834968\t19.997576\t\r\n2020-11-20 11:17:23.109 5588-5588/com.google.android.exoplayer2.demo I/MINH: 11\t1012\t31.993544\t6\t1.834968\t19.995329\t\r\n2020-11-20 11:17:23.109 5588-5588/com.google.android.exoplayer2.demo I/MINH: 12\t1017\t31.585793\t6\t1.834968\t19.999952\t\r\n2020-11-20 11:17:23.110 5588-5588/com.google.android.exoplayer2.demo I/MINH: 13\t1023\t51.726105\t6\t1.834968\t19.996777\t\r\n2020-11-20 11:17:23.110 5588-5588/com.google.android.exoplayer2.demo I/MINH: 14\t1027\t51.726105\t6\t1.834968\t19.990929\t\r\n2020-11-20 11:17:23.110 5588-5588/com.google.android.exoplayer2.demo I/MINH: 15\t1029\t51.726105\t6\t1.834968\t19.996412\t\r\n```\r\n\r\nHowever, when I modify the function `determineIdealSelectedIndex()`\r\n\r\n```java\r\n...\r\nprivate static int minh_count = 0;\r\n...\r\nprivate int determineIdealSelectedIndex(long nowMs) {\r\n    long effectiveBitrate = bandwidthProvider.getAllocatedBandwidth();\r\n    int lowestBitrateAllowedIndex = 0;\r\n    for (int i = 0; i < length; i++) {\r\n      if (nowMs == Long.MIN_VALUE || !isBlacklisted(i, nowMs)) {\r\n        Format format = getFormat(i);\r\n        if (canSelectFormat(format, format.bitrate, playbackSpeed, effectiveBitrate)) { //throughput-based\r\n          // Modify for test - START\r\n          //  return  i;\r\n          minh_count ++;\r\n          return minh_count%length;\r\n          // Modify for test - END\r\n        } else {\r\n          lowestBitrateAllowedIndex = i;\r\n        }\r\n      }\r\n    }\r\n\r\n    return lowestBitrateAllowedIndex;\r\n  }\r\n```\r\nThe `AdaptiveTrackSelection.updateSelectedTrack()` is called 20 times as follows:\r\n```\r\n2020-11-20 11:20:25.514 5744-5744/com.google.android.exoplayer2.demo I/MINH: Id\tTime\tEstThroughput\tQualityIdx\tBitrate\tBuffer\r\n2020-11-20 11:20:25.514 5744-5744/com.google.android.exoplayer2.demo I/MINH: 1\t1172\t4.139778\t5\t1.006977\t0.0\t\r\n2020-11-20 11:20:25.514 5744-5744/com.google.android.exoplayer2.demo I/MINH: 2\t1172\t4.139778\t4\t0.499978\t0.0\t\r\n2020-11-20 11:20:25.514 5744-5744/com.google.android.exoplayer2.demo I/MINH: 3\t1172\t4.139778\t3\t0.257246\t0.0\t\r\n2020-11-20 11:20:25.514 5744-5744/com.google.android.exoplayer2.demo I/MINH: 4\t1172\t4.139778\t2\t0.147097\t0.0\t\r\n2020-11-20 11:20:25.515 5744-5744/com.google.android.exoplayer2.demo I/MINH: 5\t1172\t4.139778\t1\t0.075814\t0.0\t\r\n2020-11-20 11:20:25.515 5744-5744/com.google.android.exoplayer2.demo I/MINH: 6\t1172\t4.139778\t1\t0.075814\t0.0\t\r\n2020-11-20 11:20:25.515 5744-5744/com.google.android.exoplayer2.demo I/MINH: 7\t1172\t4.139778\t1\t0.075814\t5.214\t\r\n2020-11-20 11:20:25.515 5744-5744/com.google.android.exoplayer2.demo I/MINH: 8\t1172\t4.139778\t1\t0.075814\t9.522873\t\r\n2020-11-20 11:20:25.515 5744-5744/com.google.android.exoplayer2.demo I/MINH: 9\t1172\t4.139778\t3\t0.257246\t14.114865\t\r\n2020-11-20 11:20:25.515 5744-5744/com.google.android.exoplayer2.demo I/MINH: 10\t1172\t15.159876\t2\t0.147097\t18.749332\t\r\n2020-11-20 11:20:25.515 5744-5744/com.google.android.exoplayer2.demo I/MINH: 11\t1175\t15.932693\t1\t0.075814\t19.99592\t\r\n2020-11-20 11:20:25.515 5744-5744/com.google.android.exoplayer2.demo I/MINH: 12\t1180\t15.932693\t6\t1.834968\t19.999607\t\r\n2020-11-20 11:20:25.515 5744-5744/com.google.android.exoplayer2.demo I/MINH: 13\t1180\t15.932693\t5\t1.006977\t19.87662\t\r\n2020-11-20 11:20:25.515 5744-5744/com.google.android.exoplayer2.demo I/MINH: 14\t1185\t16.497812\t4\t0.499978\t19.998589\t\r\n2020-11-20 11:20:25.515 5744-5744/com.google.android.exoplayer2.demo I/MINH: 15\t1190\t15.932693\t3\t0.257246\t19.999405\t\r\n2020-11-20 11:20:25.515 5744-5744/com.google.android.exoplayer2.demo I/MINH: 16\t1195\t19.41076\t2\t0.147097\t19.99306\t\r\n2020-11-20 11:20:25.515 5744-5744/com.google.android.exoplayer2.demo I/MINH: 17\t1200\t19.41076\t1\t0.075814\t19.991512\t\r\n2020-11-20 11:20:25.515 5744-5744/com.google.android.exoplayer2.demo I/MINH: 18\t1205\t18.738419\t6\t1.834968\t19.993235\t\r\n2020-11-20 11:20:25.515 5744-5744/com.google.android.exoplayer2.demo I/MINH: 19\t1209\t19.41076\t5\t1.006977\t19.998152\t\r\n2020-11-20 11:20:25.515 5744-5744/com.google.android.exoplayer2.demo I/MINH: 20\t1211\t18.738419\t4\t0.499978\t19.99512\t\r\n```\r\nEspecially, the segment `Id`s: 2, 3, 4, 5 and 12 have the `chunk.getDurationUs() = 0.0` in the function `DefaultDashChunkSource.onChunkLoadCompleted()`, and theses segments are not played on the screen.\r\n\r\nWhy does this happen?\r\nHow can I enforce the ExoPlayer to send requests and plays exactly what `updateSelectedTrack()` determines?\r\n\r\nThank you.",
    "comments_url": "https://api.github.com/repos/google/ExoPlayer/issues/8258/comments",
    "author": "minhkstn",
    "comments": [
      {
        "user": "tonihei",
        "created_at": "2020-11-20T13:25:33Z",
        "body": "ExoPlayer calls `updateSelectedTrack` whenever we need to load something new. Depending on your `selectedIndex`, ExoPlayer may need to load non-media data first though. \r\n\r\nIn the example stream we need to load the initialization data for the selected format the first time you try to select it. After we loaded the initialization data, we call `updateSelectedTrack` again to see if we still want to continue with this format. So the chunks with `chunk.getDurationUs() = 0.0` are most likely the initialization chunk loads you see. The second example contains more of them because you force the player to load the initialization data for all formats before even starting playback."
      },
      {
        "user": "minhkstn",
        "created_at": "2020-11-20T14:01:15Z",
        "body": " @tonihei Thank you for your response. So I guess to avoid additional calls, I need to keep the same format in the `updateSelectedTrack` by choosing the same quality index before starting playback. Is it correct?"
      },
      {
        "user": "tonihei",
        "created_at": "2020-11-20T15:55:25Z",
        "body": "Yes, but there is generally no need to avoid them because the initialization data is really small compared to the actual media data."
      },
      {
        "user": "minhkstn",
        "created_at": "2020-11-22T10:53:09Z",
        "body": "Thank you so much."
      }
    ]
  },
  {
    "number": 8243,
    "title": "Exoplayer in viewpager2 with offscreen limit buffers in background",
    "created_at": "2020-11-18T02:26:27Z",
    "closed_at": "2020-12-18T17:13:41Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/google/ExoPlayer/issues/8243",
    "body": "We are using exoplayer inside a viewpager 2 fragment. we have defined off set screen limit to 2. While initialising the player we are setting `playwhenready = false `we have defined max buffer ms as 3. We expected video on position 1 and 2 to have buffered max of 3 sec, However the players in position 1 and 2 while user is at 0th position is buffering more than defined time and sometimes entire video is cached if video is around 1mb in size. \r\n\r\n```\r\nconst val DEFAULT_MIN_BUFFER_MS = 500\r\nconst val DEFAULT_MAX_BUFFER_MS = 3000\r\nconst val DEFAULT_MIN_BUFFER_FOR_PLAY_BACK = 500\r\nconst val DEFAULT_MIN_BUFFER_AFTER_REBUFFER = 500\r\n```\r\n  ```\r\n  var player = SimpleExoPlayer.Builder(Mitron.getContext(), DefaultRenderersFactory(Mitron.getContext()))\r\n                    .setLoadControl(\r\n                            DefaultLoadControl.Builder()\r\n                                    .setPrioritizeTimeOverSizeThresholds(false)\r\n                                    .setBufferDurationsMs(\r\n                                            Constants.DEFAULT_MIN_BUFFER_MS,\r\n                                            Constants.DEFAULT_MAX_BUFFER_MS,\r\n                                            Constants.DEFAULT_MIN_BUFFER_FOR_PLAY_BACK,\r\n                                            Constants.DEFAULT_MIN_BUFFER_AFTER_REBUFFER\r\n                                    )\r\n                                    .createDefaultLoadControl()\r\n                    )\r\n                    .setTrackSelector(DefaultTrackSelector())\r\n                    .build()\r\n            player.playWhenReady = false\r\n            binding?.playerview?.useController = true\r\n            binding?.playerview?.setKeepContentOnPlayerReset(true)\r\n            var cacheKey = if (videoModel?.video_url?.contains(\"?\") == true) {\r\n                videoModel?.video_url?.substring(0, videoModel?.video_url?.lastIndexOf(\"?\") ?: 1)\r\n            } else {\r\n                videoModel?.video_url\r\n            }\r\n            val mediaSource =\r\n                    ProgressiveMediaSource.Factory(CacheUtils.cacheDataSourceFactory)\r\n                            .setCustomCacheKey(cacheKey).createMediaSource(Uri.parse(videoModel?.video_url))\r\n            player.prepare(mediaSource)\r\n            binding?.playerview?.player = player\r\n```\r\n ```\r\n for_you_pager.setOffscreenPageLimit(2);\r\n for_you_pager.registerOnPageChangeCallback(forYouPagerListener);\r\n for_you_pager.setAdapter(forYoupagerAdapter);\r\n for_you_pager.setPageTransformer(new ParallaxTransformer());\r\n```",
    "comments_url": "https://api.github.com/repos/google/ExoPlayer/issues/8243/comments",
    "author": "Arunkarthicknallasami",
    "comments": [
      {
        "user": "tonihei",
        "created_at": "2020-12-17T16:48:37Z",
        "body": "Sorry for the delay in answering your question, I didn't realize I was assigned to the issue.\r\n\r\n`ProgressiveMediaSource` loads the data in chunks of a certain byte size before checking whether loading should continue. The default size of these chunks is 1 MB, so that's why we always load 1 MB even though it may be more than your configured max buffer duration in seconds. \r\n\r\nIf you want to check more often, you can call `setContinueLoadingCheckIntervalBytes` on `ProgressiveMediaSource.Factory` and specify any number you want. Note that this comes with a small pause in loading, so you shouldn't choose this chunk size too small to avoid stalling the loading process too much."
      },
      {
        "user": "Arunkarthicknallasami",
        "created_at": "2020-12-18T08:25:44Z",
        "body": "Thanks"
      },
      {
        "user": "tonihei",
        "created_at": "2020-12-18T17:13:41Z",
        "body": "Closing the issue because the question was answered."
      }
    ]
  },
  {
    "number": 8172,
    "title": "CacheEvictionListener",
    "created_at": "2020-11-06T04:13:02Z",
    "closed_at": "2020-11-09T09:14:12Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/google/ExoPlayer/issues/8172",
    "body": "Is there any callbacks for listening to cache eviction? Like when something is being removed from cache we shall observe which item is being removed.",
    "comments_url": "https://api.github.com/repos/google/ExoPlayer/issues/8172/comments",
    "author": "Arunkarthicknallasami",
    "comments": [
      {
        "user": "marcbaechinger",
        "created_at": "2020-11-06T19:30:04Z",
        "body": "You can listen to the changes of a given resource by using `Cache.addListener(String key, Listener listener)`\r\n\r\n```\r\n/**\r\n   * Registers a listener to listen for changes to a given resource.\r\n   *\r\n   * <p>No guarantees are made about the thread or threads on which the listener is called, but it\r\n   * is guaranteed that listener methods will be called in a serial fashion (i.e. one at a time) and\r\n   * in the same order as events occurred.\r\n   *\r\n   * @param key The cache key of the resource.\r\n   * @param listener The listener to add.\r\n   * @return The current spans for the resource.\r\n   */\r\n  NavigableSet<CacheSpan> addListener(String key, Listener listener);\r\n```"
      },
      {
        "user": "Arunkarthicknallasami",
        "created_at": "2020-11-09T09:14:43Z",
        "body": "Thanks"
      }
    ]
  },
  {
    "number": 8153,
    "title": "Caching S3 signed url",
    "created_at": "2020-11-03T12:05:40Z",
    "closed_at": "2020-11-04T06:12:56Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/google/ExoPlayer/issues/8153",
    "body": "I have implemented pre-caching and it works for unsigned url's. However when s3 signed urls are used it cache's it as new video everytime when loaded instead of loading from cache if cached already (s3 signed url changes on every request but video id on the url will remain the same)\r\n\r\nAny help?",
    "comments_url": "https://api.github.com/repos/google/ExoPlayer/issues/8153/comments",
    "author": "Arunkarthicknallasami",
    "comments": [
      {
        "user": "marcbaechinger",
        "created_at": "2020-11-03T12:32:07Z",
        "body": "Are you using progressive media streams? Does it help to use `DownloadRequest.Builder.setCustomCacheKey`?\r\n\r\nIf you are using the downloader there is support for customCacheKey as well: `ProgressiveDownloader(Uri uri, @Nullable String customCacheKey, CacheDataSource.Factory cacheDataSourceFactory)`"
      },
      {
        "user": "Arunkarthicknallasami",
        "created_at": "2020-11-03T13:34:29Z",
        "body": "Yes we use mp4 and we use caching and the code is as follows\r\n\r\n```\r\nclass CacheUtils {\r\n    var cacheDataSourceFactory: CacheDataSourceFactory?=null\r\n    var simpleCache: SimpleCache?=null\r\n    init {\r\n        simpleCache = Mitron.simpleCache\r\n\r\n        cacheDataSourceFactory = CacheDataSourceFactory(\r\n            simpleCache,\r\n            DefaultHttpDataSourceFactory(Mitron.getContext()?.let {\r\n                Util.getUserAgent(\r\n                    it,\"Playback\")\r\n            })\r\n        )\r\n    }\r\n}\r\n```\r\n\r\n ```\r\n@JvmStatic\r\n    @BindingAdapter(value = [\"app:video_url\",\"app:eventListener\"],requireAll = true)\r\n    fun PlayerView.loadVideo(url: String?,playerEventListener: Player.EventListener?) {\r\n        try {\r\n            if (url == null) return\r\n            var player = SimpleExoPlayer.Builder(Mitron.getContext(), DefaultRenderersFactory(Mitron.getContext()))\r\n                    .setLoadControl(\r\n                            DefaultLoadControl.Builder()\r\n                                    .setPrioritizeTimeOverSizeThresholds(false)\r\n                                    .setBufferDurationsMs(\r\n                                            Constants.DEFAULT_MIN_BUFFER_MS,\r\n                                            Constants.DEFAULT_MAX_BUFFER_MS,\r\n                                            Constants.DEFAULT_MIN_BUFFER_FOR_PLAY_BACK,\r\n                                            Constants.DEFAULT_MIN_BUFFER_AFTER_REBUFFER\r\n                                    )\r\n                                    .createDefaultLoadControl()\r\n                    )\r\n                    .setTrackSelector(DefaultTrackSelector())\r\n                    .build()\r\n            player.playWhenReady = true\r\n            setKeepContentOnPlayerReset(true)\r\n            this.useController = true\r\n            val mediaSource =\r\n                    ProgressiveMediaSource.Factory(CacheUtils().cacheDataSourceFactory).createMediaSource(Uri.parse(url))\r\n            player.prepare(mediaSource)\r\n            this.player = player\r\n            playerEventListener?.let {\r\n                player.addListener(playerEventListener)\r\n            }\r\n        }catch (e:Exception){\r\n          Log.e(\"Error\",\"Error on binding url to player\")\r\n        }\r\n\r\n    }\r\n```\r\n\r\n```\r\n  private fun preCacheVideo() {\r\n        try {\r\n            var videoUrl: String? = null\r\n            if (!videosList.isNullOrEmpty()) {\r\n                videoUrl = videosList?.get(0)\r\n                videosList?.removeAt(0)\r\n            }\r\n            if (!videoUrl.isNullOrBlank() && !videoUrl.isNullOrEmpty()) {\r\n                val dataSpec =\r\n                        DataSpec(Uri.parse(videoUrl), 0, getFileMetaData(videoUrl), null)\r\n                val defaultCacheKeyFactory = CacheUtil.DEFAULT_CACHE_KEY_FACTORY\r\n                val progressListener =\r\n                        CacheUtil.ProgressListener { requestLength, bytesCached, newBytesCached ->                 \r\n                        }\r\n                val dataSource: DataSource =\r\n                        DefaultDataSourceFactory(\r\n                                context,\r\n                                Util.getUserAgent(context, \"Playback\")\r\n                        ).createDataSource()\r\n\r\n                cachingJob = GlobalScope.launch(Dispatchers.IO) {\r\n                    cacheVideo(dataSpec, defaultCacheKeyFactory, dataSource, progressListener)\r\n                    preCacheVideo()\r\n                }\r\n            }\r\n        } catch (e: Exception) {\r\n            Log.e(\"Error caching\", \"Error $e\")\r\n        }\r\n```"
      },
      {
        "user": "marcbaechinger",
        "created_at": "2020-11-03T13:55:28Z",
        "body": "I think that should work if `CacheUtil.DEFAULT_CACHE_KEY_FACTORY` takes care to create the same `customCacheKey` for the urls that point to the same 'video id' and all cache data sources that are involved when downloading and doing playback use the same custom cache key factory.  Can you verify this is the case?"
      },
      {
        "user": "Arunkarthicknallasami",
        "created_at": "2020-11-03T14:14:37Z",
        "body": "I will verify it for sure but i did notice video being downloaded again and i could see download progress for already cached videos when app is closed and reopened (New signed url will be obtained on ropening)"
      },
      {
        "user": "marcbaechinger",
        "created_at": "2020-11-03T15:05:27Z",
        "body": "I think if the `customCacheKey` matches that should not happen. Probably start your review with your `CacheUtil` class where a `CacheDataSourceFactory` is created without a cache key factory as far as I can see. "
      },
      {
        "user": "Arunkarthicknallasami",
        "created_at": "2020-11-03T15:24:37Z",
        "body": "Alright let me start from there and keep u updated"
      },
      {
        "user": "Arunkarthicknallasami",
        "created_at": "2020-11-04T06:12:56Z",
        "body": "```\r\n var cacheKey = if (url.contains(\"?\")) {\r\n                url.substring(0, url.lastIndexOf(\"?\"))\r\n            } else {\r\n                url\r\n            }\r\n            val mediaSource =\r\n                    ProgressiveMediaSource.Factory(CacheUtils().cacheDataSourceFactory)\r\n                            .setCustomCacheKey(cacheKey).createMediaSource(Uri.parse(url))\r\n            player.prepare(mediaSource)\r\n```\r\n```\r\n\r\ntry {\r\n            var videoUrl: String? = null\r\n            if (!videosList.isNullOrEmpty()) {\r\n                videoUrl = videosList?.get(0)\r\n                videosList?.removeAt(0)\r\n            }\r\n            if (!videoUrl.isNullOrBlank() && !videoUrl.isNullOrEmpty()) {\r\n                var cacheKey = if (videoUrl.contains(\"?\")) {\r\n                    videoUrl.substring(0, videoUrl.lastIndexOf(\"?\"))\r\n                } else {\r\n                    videoUrl\r\n                }\r\n                val dataSpec =\r\n                        DataSpec(Uri.parse(videoUrl), 0, getFileMetaData(videoUrl), cacheKey)\r\n                val defaultCacheKeyFactory = CacheKeyFactory { dataSpec ->\r\n                    dataSpec.key\r\n                }\r\n                val progressListener =\r\n                        CacheUtil.ProgressListener { requestLength, bytesCached, newBytesCached ->\r\n                          \r\n                        }\r\n                val dataSource: DataSource =\r\n                        DefaultDataSourceFactory(\r\n                                context,\r\n                                Util.getUserAgent(context, \"Playback\")\r\n                        ).createDataSource()\r\n                cachingJob = GlobalScope.launch(Dispatchers.IO) {\r\n                    cacheVideo(dataSpec, defaultCacheKeyFactory, dataSource, progressListener)\r\n                    preCacheVideo()\r\n                }\r\n            }\r\n        } catch (e: Exception) {\r\n            Log.e(\"Error caching\", \"Error $e\")\r\n        }\r\n\r\n```\r\nSo i used url of video without signing as key and it works."
      }
    ]
  },
  {
    "number": 8137,
    "title": "How to get the entire content Duration of a MediaItem, not just the clip length? ",
    "created_at": "2020-10-29T17:04:48Z",
    "closed_at": "2020-11-03T13:36:47Z",
    "labels": [
      "duplicate",
      "question"
    ],
    "url": "https://github.com/google/ExoPlayer/issues/8137",
    "body": "### [REQUIRED] Question\r\nI have a list of `MediaItem`s with different start positions. \r\n```java\r\nMediaItem mediaItem = new MediaItem.Builder()\r\n    .setUri(trackUri)\r\n    .setClipStartPositionMs(startPos)\r\n    .setClipEndPositionMs(C.TIME_END_OF_SOURCE)\r\n    .build();\r\n```\r\nWhen a particular MediaItem is being played, the Player is just returning the duration of the clip, not the total length of the track. \r\nIs there a way where I can get the total length of the track, not just the clip length? ",
    "comments_url": "https://api.github.com/repos/google/ExoPlayer/issues/8137/comments",
    "author": "pavan245",
    "comments": [
      {
        "user": "pavan245",
        "created_at": "2020-11-02T18:28:01Z",
        "body": "Hi\r\n\r\nI have to do quite a bit of work if the Player can't give the entire duration of the MediaItem. And I'm not sure if this is a bug or the intended behavior. \r\nCan I get an update here? Do I need to provide some more details for this question? \r\n\r\nThanks"
      },
      {
        "user": "ojw28",
        "created_at": "2020-11-02T19:49:51Z",
        "body": "If you're only changing the start clip position then I think you can retrieve the entire content duration like:\r\n```\r\n@Override\r\npublic void onTimelineChanged(Timeline timeline, @TimelineChangeReason int reason) {\r\n  if (!timeline.isEmpty()) {\r\n    long durationMs = timeline.getPeriod(0, new Period()).getDurationMs();\r\n  }\r\n}\r\n```\r\nNote that you can also retrieve the timeline from `Player.getCurrentTimeline`. @pavan245 - Does that work for you?\r\n\r\nThe same trick does not work if you set an end clip position, however. This may not be relevant to your use case, but is something we should think about. @tonihei - Do you understand why that's not the case? If both start and end are clipped, I think I'd expect the period and window to look like:\r\n```\r\n<----------- original content ----------->\r\n<-------------- period ------------------>\r\n            <----- window ----->\r\n```\r\nwhere-as it seems they look like:\r\n```\r\n<----------- original content ----------->\r\n<-------------- period -------->\r\n            <----- window ----->\r\n```\r\nI tried changing `ClippingTimeline.getPeriod` to do what I expected, but then playback doesn't transition to the ended state once the clip end point is reached. Which also seems unexpected to me."
      },
      {
        "user": "tonihei",
        "created_at": "2020-11-03T13:03:21Z",
        "body": "> If both start and end are clipped, I think I'd expect the period and window to look like ... where-as it seems they look like ...\r\n\r\nThis is because the clipping is not properly integrated in every `MediaPeriod` and thus the player (without knowing `ClippingMediaSource`) has no concept of a period ending early. That's why we need to shorten the period so that the player knows when it ends and that it can transition to the next item. \r\n\r\nThe pending work for #3163 will change this by making clipping a first-class citizen in `MediaPeriod` and `Timeline.Period`. This will solve this issue, but also #3163 that is currently blocked on correctly discarding buffer when the end clip position changes.  "
      },
      {
        "user": "ojw28",
        "created_at": "2020-11-03T13:36:47Z",
        "body": "@pavan245 - For only changing the start clip position, my solution posted above will work. For the end position, marking this as a duplicate of #3163 as per Toni's response above."
      },
      {
        "user": "pavan245",
        "created_at": "2020-11-09T15:01:13Z",
        "body": "@ojw28 Thanks for your solution. For the time being, I'm only using the start clip position so your solution works. \r\n\r\nIs there any way I can get the current playing position in the window from the Player/Timeline APIs? \r\nI tried `Period.getPositionInWindowMs` and it's returning a negative of `startPosition`. \r\nI can add the `startPosition` and `Player.getCurrentPosition`, but prefer to rely on the Player. "
      },
      {
        "user": "tonihei",
        "created_at": "2020-11-09T15:09:04Z",
        "body": "`Player.getCurrentPosition` returns the position in the window actually. If you want to convert to a period position you can use `Timeline.getPeriodPosition(window, period, windowIndex, windowPositionUs)` that gives you both the `periodUid` and the period position. The uid is only relevant for cases where you have multiple periods per window. As `ClippingMediaSource` doesn't support multi-period windows at all, you can probably ignore this part of the return value."
      },
      {
        "user": "pavan245",
        "created_at": "2020-11-09T15:36:08Z",
        "body": "Hi @tonihei \r\nIf the MediaItem's `setClipStartPositionMs` is 300000ms, I need the `Player.getCurrentPosition` to start from 300000. Is this the expected behaviour? \r\n\r\nFrom the below source code, I can see `Player.getCurrentPosition` internally calling `periodPositionUsToWindowPositionMs` method. But as mentioned in the above comment, `Period.getPositionInWindowMs()` is returning `-300000`\r\n\r\n```java\r\n\r\n@Override\r\npublic long getCurrentPosition() {\r\n    if (playbackInfo.timeline.isEmpty()) {\r\n      return maskingWindowPositionMs;\r\n    } else if (playbackInfo.periodId.isAd()) {\r\n      return C.usToMs(playbackInfo.positionUs);\r\n    } else {\r\n      return periodPositionUsToWindowPositionMs(playbackInfo.periodId, playbackInfo.positionUs);\r\n    }\r\n }\r\n\r\nprivate long periodPositionUsToWindowPositionMs(MediaPeriodId periodId, long positionUs) {\r\n    long positionMs = C.usToMs(positionUs);\r\n    playbackInfo.timeline.getPeriodByUid(periodId.periodUid, period);\r\n    positionMs += period.getPositionInWindowMs();\r\n    return positionMs;\r\n}\r\n\r\n```"
      },
      {
        "user": "tonihei",
        "created_at": "2020-11-09T15:39:04Z",
        "body": "If you want the position to start at `300000`, then you want to know the period position if I understand you correctly. Have you tried using `Timeline.getPeriodPosition` as proposed above?"
      },
      {
        "user": "pavan245",
        "created_at": "2020-11-09T16:22:09Z",
        "body": "Sorry, you're right. I need the period position.\r\nThis is how I got it working:\r\n\r\n```java\r\n    public long getCurrentPosition() {\r\n\r\n        if (player == null || player.getPlaybackState() == Player.STATE_IDLE)\r\n            return 0;\r\n\r\n        Timeline timeline = player.getCurrentTimeline();\r\n        if (timeline == null || timeline.isEmpty())\r\n            return 0;\r\n\r\n        Timeline.Period period = timeline.getPeriod(0, new Timeline.Period());\r\n\r\n        Timeline.Window window = timeline.getWindow(period.windowIndex, new Timeline.Window());\r\n\r\n        long windowPosition = player.getCurrentPosition();\r\n\r\n        Pair<Object, Long> periodPosition = timeline.getPeriodPosition(window, period, period.windowIndex, C.msToUs(windowPosition));\r\n\r\n        return periodPosition != null ? C.usToMs(periodPosition.second) : 0;\r\n    }\r\n```"
      }
    ]
  },
  {
    "number": 8118,
    "title": "can't get duration of audio file which  extension is .aac",
    "created_at": "2020-10-27T03:10:20Z",
    "closed_at": "2020-10-29T08:56:36Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/google/ExoPlayer/issues/8118",
    "body": "[No information provided]",
    "comments_url": "https://api.github.com/repos/google/ExoPlayer/issues/8118/comments",
    "author": "l20160606sy",
    "comments": [
      {
        "user": "ojw28",
        "created_at": "2020-10-28T17:20:47Z",
        "body": "This is a known limitation. You should consider using a more appropriate container format for your audio, such as MP4, which will not have this problem."
      },
      {
        "user": "l20160606sy",
        "created_at": "2020-10-29T02:02:26Z",
        "body": "But I found that sometimes the audio of AAC files can get the total duration, and sometimes it can't"
      },
      {
        "user": "ojw28",
        "created_at": "2020-10-29T08:46:55Z",
        "body": "I think the duration might become known once the player has buffered to the end of the stream, so you may find that duration is determined quickly for short AAC files (which are fully buffered up-front), and toward the end of the playback for longer AAC files (where this is not possible).\r\n\r\nThe problem is that the player doesn't have an efficient way to determine the duration of the content from only the start of the file. Processing the entire file is clearly a very inefficient way of determining duration, and so we opt not to do this. If this is a requirement you should use a modern container format such as MP4, which specifies its duration directly at the start of the file in a way that the player can easily read."
      },
      {
        "user": "l20160606sy",
        "created_at": "2020-10-29T08:56:36Z",
        "body": "OK, got it.thanks"
      }
    ]
  },
  {
    "number": 8117,
    "title": "Crash while playing HLS live content (probably a playlist update retry process)",
    "created_at": "2020-10-27T01:47:11Z",
    "closed_at": "2020-10-28T01:17:33Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/google/ExoPlayer/issues/8117",
    "body": "In exoplayer 2.10.6\r\n\r\nI am having trouble with a crashing phenomenon while playing live content on HLS.\r\n\r\nIt was crashing in the part of the playlist where I was getting an I/O (HTTP) error and retrying to get the playlist update.\r\n\r\nI suspect the crash is caused by the fact that the process of updating currentTask is not thread-safe.\r\n\r\nI think that if <Loader#startLoading> is called between <Loader.LoadTask#finish> and <Loader.LoadTask#start> in <Loader.LoadTask#handleMessage>, it will be like this.\r\n\r\nIs this working as designed?\r\n\r\n\r\nLogging of crashes:\r\n```\r\nFatal Exception: java.lang.IllegalStateException\r\n       at com.google.android.exoplayer2.util.Assertions.checkState(Assertions.java:81)\r\n       at com.google.android.exoplayer2.upstream.Loader$LoadTask.start(Loader.java:351)\r\n       at com.google.android.exoplayer2.upstream.Loader$LoadTask.handleMessage(Loader.java:481)\r\n       at android.os.Handler.dispatchMessage(Handler.java:106)\r\n       at android.os.Looper.loop(Looper.java:193)\r\n       at android.app.ActivityThread.main(ActivityThread.java:6758)\r\n       at java.lang.reflect.Method.invoke(Method.java)\r\n       at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:493)\r\n       at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:858)",
    "comments_url": "https://api.github.com/repos/google/ExoPlayer/issues/8117/comments",
    "author": "Our-colibri",
    "comments": [
      {
        "user": "ojw28",
        "created_at": "2020-10-27T19:33:22Z",
        "body": "For that stack trace to happen, I think `Loader.startLoading` must have been called on the application's main thread. This should never happen, since loads are only expected to be started by the player's own internal thread(s).\r\n\r\nThis suggests to me that your application code might be calling something directly that it shouldn't be calling. Perhaps your application code is calling `prepareSource` on a `MediaSource` instance, for example. Could you take a look? If that's not the case, I think you'll need to figure out how `Laoder.startLoading` ends up being called on the application's main thread. If you can point to where this happens in the ExoPlayer library, then that would be something we could investigate and fix.\r\n"
      },
      {
        "user": "Our-colibri",
        "created_at": "2020-10-28T01:17:33Z",
        "body": "Thanks for the reply.\r\n\r\nI was creating a separate thread in MyMediaSource#prepareSource to call the actual MediaSource#prepare as you wrote.\r\n(The reason was to recreate and replace the MediaSource as needed in the Prepare phase.)\r\n\r\nI didn't understand it well enough, so your reply was a great help.\r\nThanks so much."
      }
    ]
  },
  {
    "number": 7955,
    "title": "With v2.12.0 playlist api, how do I know which source causes the onPlayerError",
    "created_at": "2020-09-21T08:30:29Z",
    "closed_at": "2020-09-21T15:03:28Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/google/ExoPlayer/issues/7955",
    "body": "### [REQUIRED] Searched documentation and issues\r\nLooked at StackOverflow and other issues. Could not find anything related\r\n\r\n### [REQUIRED] Question\r\nI using the new playlist API provided with v2.12.0 and loading multiple `MediaItem`s into the player. One of the sources throws an `ExoPlaybackException` of `ExoPlaybackException.TYPE_SOURCE` type.\r\n\r\nHow do I know which media item this relates to?\r\n\r\n### A full bug report captured from the device\r\nNo specific bug is referred to.\r\n\r\n### Link to test content\r\nGeneral question that does not relate to a specific source.\r\n",
    "comments_url": "https://api.github.com/repos/google/ExoPlayer/issues/7955/comments",
    "author": "strangesource",
    "comments": [
      {
        "user": "marcbaechinger",
        "created_at": "2020-09-21T12:53:18Z",
        "body": "I think in this case the field `ExoPlaybackException.mediaPeriodId` has a media period id assigned (it is not null). If so you can do something like this:\r\n\r\n```\r\nMediaSource.MediaPeriodId mediaPeriodId = playbackException.mediaPeriodId;\r\nint windowIndex = player.getCurrentTimeline()\r\n   .getPeriodByUid(mediaPeriodId.periodUid, new Timeline.Period()).windowIndex;\r\nplayer.removeMediaItem(windowIndex);\r\n```\r\n\r\nPlease note, that the above assumes that you are having a 1:1 relationship between media items and windows in the timeline. This means you are not using a `ConcatenatingMediaSource`. In case you are only using the new API with `MediaItem` you are fine. \r\n\r\nPlease let me know whether that works for you."
      },
      {
        "user": "tonihei",
        "created_at": "2020-09-21T13:03:41Z",
        "body": "You can also use `AnalyticsListener` and listen to `onPlayerError` which has an `EventTime` argument with a `windowIndex` field. This is essentially equivalent to the proposal above, but easier to read in code:\r\n```\r\n@Override\r\n public void onPlayerError(EventTime eventTime, ExoPlaybackException e) {\r\n    Log.e(\"ERROR\", \"Media item number \" + eventTime.windowIndex + \" failed.\");\r\n }\r\n```"
      },
      {
        "user": "strangesource",
        "created_at": "2020-09-21T13:36:49Z",
        "body": "Thanks a lot for the fast answers, this solves my problem. \ud83d\ude42  \ud83d\ude47 "
      },
      {
        "user": "marcbaechinger",
        "created_at": "2020-09-21T15:03:28Z",
        "body": "Cool, thanks for letting us know. I'm closing this issue. Please re-open if you think it is needed."
      }
    ]
  },
  {
    "number": 7915,
    "title": "MediaItem.Builder() doesn't contain StreamType in ExoPlayer 2.12.0",
    "created_at": "2020-09-15T10:55:40Z",
    "closed_at": "2020-09-15T22:30:40Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/google/ExoPlayer/issues/7915",
    "body": "Hello,\r\n\r\nUntil ExoPlayer 2.12.0 i used `MediaInfo.Builder()` where i could set media stream type, for example: `.setStreamType(MediaInfo.STREAM_TYPE_LIVE)` and then i passed all information to the `MediaQueueItem.Builder()` to cast video to Google Chromecast.\r\n\r\nIn the new ExoPlayer 2.12.0 version i have to use `MediaItem.Builder()` now. And it is impossible to set media stream type now.\r\nOr maybe i'm missing something?\r\n\r\nThank you.",
    "comments_url": "https://api.github.com/repos/google/ExoPlayer/issues/7915/comments",
    "author": "menscikov",
    "comments": [
      {
        "user": "menscikov",
        "created_at": "2020-09-15T11:25:52Z",
        "body": "There is also a problem with `com.google.android.exoplayer2.MediaMetadata` class.\r\nIt's only accepting \"title\" now.\r\n\r\nEarlier i used `com.google.android.gms.cast.MediaMetadata` class, and i could set \"title\", \"subtitle\", \"image\" and other options to metadata with `MediaInfo.Builder()`.\r\n\r\nBut now `MediaItem.Builder()` is only accepting `MediaMetadata` class from `com.google.android.exoplayer2`."
      },
      {
        "user": "menscikov",
        "created_at": "2020-09-15T11:29:14Z",
        "body": "Maybe it's better to leave `MediaQueueItem.Builder()` and make `CastPlayer.loadItem()` method not deprecated for Google Chromecast?"
      },
      {
        "user": "marcbaechinger",
        "created_at": "2020-09-15T11:59:14Z",
        "body": "You can pass a `MediaItemConverter` to the constructor of the `CastPlayer`. This lets you convert the `MediaItem` to a `MediaQueueItem` which is then sent to `RemoteMediaClient`.\r\n\r\nIf you want to transport custom data with the `MediaItem` you can do so by using `new MediaItem.Builder().setTag(object)`. This can be retrieved in the converter by using `mediaItem.playbackProperties.tag` and then converted to the `MediaQueueItem` ."
      },
      {
        "user": "menscikov",
        "created_at": "2020-09-15T17:00:58Z",
        "body": "> You can pass a `MediaItemConverter` to the constructor of the `CastPlayer`. This lets you convert the `MediaItem` to a `MediaQueueItem` which is then sent to `RemoteMediaClient`.\r\n> \r\n> If you want to transport custom data with the `MediaItem` you can do so by using `new MediaItem.Builder().setTag(object)`. This can be retrieved in the converter by using `mediaItem.playbackProperties.tag` and then converted to the `MediaQueueItem` .\r\n\r\nCould you please give an example how to do that?\r\nI can't understand how can i convert `MediaQueueItem` to `MediaItem` with all options, like \"streamType\" and `MediaMetadata` \"title\", \"subtitle\", \"image\"?\r\nCastPlayer is accepting only `MediaItem` now in ExoPlayer 2.12.0 version.\r\n\r\n`DefaultMediaItemConverter().toMediaItem` class doesn't allow to do this."
      },
      {
        "user": "marcbaechinger",
        "created_at": "2020-09-15T17:39:47Z",
        "body": "Sorry to not give you enough details. You are right it's confusing. Specifically because the conversion back which confused you is currently unused. Please accept my apologies of not being clear here.\r\n\r\nOn the bright side, this should make things easier for you. You said above that your app is building a `MediaQueueItem` with `MediaQueueItem.Builder()`. If you aim for doing this with the least possible changes in you code it would probably be something like the following:\r\n\r\nImplement your custom `MediaItemConverter`:\r\n\r\n```\r\npublic class CustomConverter implements MediaItemConverter {\r\n  public MediaQueueItem toMediaQueueItem(MediaItem mediaItem) {\r\n       // The MediaQueueItem you build is expected to be in the tag.\r\n       return (MediaQueueItem)mediaItem.playbackProperties.getTag();\r\n  }\r\n  public MediaItem toMediaItem(MediaQueueItem Item) {\r\n      // This should give the same as when you build your media item to be passed to ExoPlayer.\r\n      return new MediaItem.Builder()\r\n          .setUri(item.getMedia().getContentUrl())\r\n          .setTag(item)\r\n          .build();\r\n  }\r\n}\r\n\r\n// The custom converter is used to create the cast player.\r\nCastPlayer castPlayer = CastPlayer(castContext, new CustomConverter());\r\n\r\n// You code builds a MediaQueueItem\r\nMediaQueueItem queueItem = MediaQueueItem.Builder().setXyz().build();\r\n// and ads it as the tag of the media item\r\nMediaItem mediaItem = new MediaItem.Build().setUri(uri).setTag(queueItem).build();\r\n\r\n// Add the item to the cast player which uses the converter internally.\r\ncastPlayer.addMediaItem(mediaItem);\r\nsimpleExoPlayer.addMediaItem(mediaItem);\r\n```\r\n\r\nYou could use any object as the tag. But given your code builds the media queue item already it's probably easiest to just use this.\r\n\r\nYour app can now use the same API like `addMediaItem` on both, the `CastPlayer` and `SimpleExoPlayer` because both implement the `Player` interface. ExoPlayer will just ignore the tag which you only need to create the queue item."
      },
      {
        "user": "menscikov",
        "created_at": "2020-09-15T18:07:11Z",
        "body": "Thank you very much for the explanation. It's working now!"
      },
      {
        "user": "marcbaechinger",
        "created_at": "2020-09-15T22:30:40Z",
        "body": "Cool. I'm glad it works :) \r\n\r\nI close this issue for now. Please re-open if you have further questions. Happy to help!"
      }
    ]
  },
  {
    "number": 7782,
    "title": "Switch between video and view at given times",
    "created_at": "2020-08-19T05:15:33Z",
    "closed_at": "2020-08-21T12:41:48Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/google/ExoPlayer/issues/7782",
    "body": "I'm looking for a way to stop the video at, let's say 10s, pause the video switch to another view and when the user is finished with that view, start back the video display.\r\n\r\nAfter looking at the dev website, I was wondering if this could be done with IMA ads but I guess it can't be done because I need indefinite time for the in-middle view. \r\n\r\nIs there any way I can do this? Then is there a way to display little vertical yellow bars (at switching position) in the seekbar as you do for ads ?",
    "comments_url": "https://api.github.com/repos/google/ExoPlayer/issues/7782/comments",
    "author": "Clement-Jean",
    "comments": [
      {
        "user": "marcbaechinger",
        "created_at": "2020-08-19T11:56:41Z",
        "body": "You can use ad markers for marking positions and fire player messages at the given playback positions to run your code:\r\n\r\n```\r\nlong[] extraAdGroupTimesMs = new long[]{20_000, 40_000};\r\nplayerView.setExtraAdGroupMarkers(extraAdGroupTimesMs, new boolean[] { false, false});\r\n```\r\n\r\nThe first argument is an array holding the positions on the timebar of the `PlayerControlView`. The second argument is an array of flags whether these markers should be shown or not.\r\n\r\nYou can customize the color of the markers by customizing the `player_control_view.xml` layout file and replacing the placeholder with id `exo_progress_placeholder` with a DefaultTimeBar element with id `exo_progress`:\r\n\r\n```  \r\n  <com.google.android.exoplayer2.ui.DefaultTimeBar\r\n    android:id=\"@id/exo_progress\"\r\n    android:layout_width=\"match_parent\"\r\n    android:layout_gravity=\"bottom\"\r\n    app:ad_marker_color=\"@color/customAdMarkerColor\" />\r\n```\r\n\r\nAnd finally you can add player messages which can execute custom code at a given position:\r\n\r\n```\r\nfor (int i = 0; i < extraAdGroupTimesMs.length; i++) {\r\n  long positionMs = extraAdGroupTimesMs[i];\r\n  PlayerMessage playerMessage = player.createMessage(\r\n      (messageType, payload) -> {\r\n        Log.d(\"player message\", \"message at position: \" + positionMs);\r\n        // do what you need to do\r\n        player.setPlayWhenReady(false);\r\n        switchToAnotherView();\r\n      });\r\n\r\n  playerMessage\r\n      .setPosition(positionMs) // the playback position according to the markers\r\n      .setDeleteAfterDelivery(false) \r\n      .setHandler(new Handler())\r\n      .send();\r\n}\r\n```"
      },
      {
        "user": "Clement-Jean",
        "created_at": "2020-08-19T14:13:28Z",
        "body": "Thank you @marcbaechinger, very helpful.\r\n\r\nJust one thing to add here, I needed to use activity.runOnUiThread in the lambda or I would have an error saying that you need to be in the same thread for changing the player and the view."
      },
      {
        "user": "marcbaechinger",
        "created_at": "2020-08-19T15:57:43Z",
        "body": "Oh, yes, sorry. I forgot to add the `setHandler(new Handler())` call. I added it to the snippet above. If you pass the handler, the message is executed on the thread on which the `Handler` has been created. Assuming you send the message on the UI thread this would do what you want."
      },
      {
        "user": "marcbaechinger",
        "created_at": "2020-08-21T12:41:48Z",
        "body": "I close this for now. Please re-open if you have any further question."
      }
    ]
  },
  {
    "number": 7703,
    "title": "Does exoplayer automatically use ABR as per internet connectivity?",
    "created_at": "2020-08-02T16:16:42Z",
    "closed_at": "2020-08-03T07:33:28Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/google/ExoPlayer/issues/7703",
    "body": "Hello there,\r\nHope you are well.\r\n\r\nWith regards, we are developing a video news android app(from our app: we are going to distribute the videos to end-users, only video content).\r\n\r\n**For the same, we are looking to integrate Exoplayer(as a video player to stream the content) but we have a query:**\r\n\r\n-Does Exoplayer automatically use ABR and stream as per Internet connectivity? What I mean over here is: normal MP4 links from AWS/google cloud to the player, no M3U8 links will be provided by AWS/Google cloud to the player & player streams as per internet connectivity of the end-user without getting M3U8 link from AWS )? Does this work? OR \r\n\r\n-Does Exoplayer needs the inputs(in the form of M3U8) from Cloud(like AWS or Google cloud) and then only Exoplayer can stream HLS?\r\n\r\nWill wait to hear from you\r\n\r\nThanks & Regards\r\nKumar Vansh Moondra",
    "comments_url": "https://api.github.com/repos/google/ExoPlayer/issues/7703/comments",
    "author": "kvmoondra",
    "comments": [
      {
        "user": "ojw28",
        "created_at": "2020-08-03T07:33:19Z",
        "body": "If you play adaptive media (i.e., DASH, HLS or SmoothStreaming), then ExoPlayer will do ABR by default. If you play progressive media (i.e., regular media files such as MP4s), then ExoPlayer will not do ABR.\r\n\r\nGiven a progressive media file, there isn't really a way that a player could do ABR even if it wanted to. A player could theoretically do ABR if provided with multiple progressive media files at different bitrates, but that's exactly what adaptive streaming standards such as DASH, HLS and SmoothStreaming are designed to do. So that's what you should use.\r\n\r\nIn conclusion, if you want ExoPlayer to do ABR then you need to use an adaptive streaming standard (i.e., DASH, HLS or SmoothStreaming) for your content."
      },
      {
        "user": "kvmoondra",
        "created_at": "2020-08-03T07:54:47Z",
        "body": "Thanks, @ojw28 for your reply. \r\n\r\n**Regarding HLS streaming**, you meant to say: If one wants ABR through Exoplayer then we need to give .M3U8 input then only Exoplayer can stream ABR? Player won't use ABR technology(HLS) if we give.MP4 input?\r\n\r\nCorrect me If I am wrong\r\n\r\nThanks & Regards\r\nKumar Vansh Moondra"
      },
      {
        "user": "ojw28",
        "created_at": "2020-08-03T08:00:04Z",
        "body": "Correct."
      }
    ]
  },
  {
    "number": 7564,
    "title": "Setting initial startup buffer size/time for Dash playback",
    "created_at": "2020-06-30T07:38:12Z",
    "closed_at": "2020-07-03T11:10:16Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/google/ExoPlayer/issues/7564",
    "body": "### [REQUIRED] Searched documentation and issues\r\n\r\n### [REQUIRED]We have a question of how to set the initial buffer size/time for DASH playback.\r\n\r\nWe are using the below parameter, wanted a confirmation if this is enough. Our chunk size is 4s.\r\n\r\n /**\r\n     * The default duration of media that must be buffered for playback to start or resume following a\r\n     * user action such as a seek, in milliseconds.\r\n     */\r\n    public static final int DEFAULT_BUFFER_FOR_PLAYBACK_MS = 1000; //start after downloading 1 chunk\r\n\r\nIf we use this above value for loadControl, does this mean dash file will start playing after 1s of audio + video data (i.e. 1st chunk) is downloaded?\r\n\r\n",
    "comments_url": "https://api.github.com/repos/google/ExoPlayer/issues/7564/comments",
    "author": "biswarupdasgupta",
    "comments": [
      {
        "user": "AquilesCanta",
        "created_at": "2020-07-01T10:14:05Z",
        "body": "As you point out, buffer for playback is `The duration of media that must be buffered for playback to start or resume following a user action such as a seek`. If you want to start playback after loading the first chunk then you should match this value and the duration of the first chunk, which is 4 seconds.\r\n\r\n> 1s of audio + video data (i.e. 1st chunk)\r\n\r\nI don't understand the _id est_ part of the sentence. 1 seconds of audio and video are not the first chunk. Can you clarify this?\r\n\r\nAside, I'd generally advise against changing the default values unless you are trying to achieve something specific. Perhaps you could roughly explain your usecase?"
      },
      {
        "user": "biswarupdasgupta",
        "created_at": "2020-07-03T10:05:37Z",
        "body": "hi @AquilesCanta , the goal is for faster startup time. We wanted to use this configuration to start playback as soon as 1 independent decodable segment is downloaded by player. Since our chunk size is 4s and the DEFAULT_BUFFER_FOR_PLAYBACK_MS is 1s , what we understand is using this config we can make the player start playback after downloading the first audio and video segment.\r\n\r\nPlease correct me."
      },
      {
        "user": "AquilesCanta",
        "created_at": "2020-07-03T11:10:16Z",
        "body": "In that case I suggest you experiment with the different parameters in `DefaultLoadControl`. Specifically important are `bufferForPlaybackMs` and `bufferForPlaybackAfterRebufferMs`. In general, the smaller the values, the faster playback will transition to the READY state. But it's also more likely that it will transition to BUFFERING immediately afterwards. The unit for both parameters is milliseconds, so it has no relation with the chunk/segment size. There's plenty of material on this in this issue tracker, please have a look around. For example, #7238, #2083."
      },
      {
        "user": "ojw28",
        "created_at": "2020-07-03T11:52:18Z",
        "body": "> We wanted to use this configuration to start playback as soon as 1 independent decodable segment is downloaded by player. Since our chunk size is 4s and the DEFAULT_BUFFER_FOR_PLAYBACK_MS is 1s , what we understand is using this config we can make the player start playback after downloading the first audio and video segment.\r\n\r\nTo clarify, \"chunk\" and \"segment\" mean the same thing, and the duration is solely determined by the media. If your chunks/segments are 4s long, then the player will download 4s chunks/segments regardless of what value you're using.\r\n\r\nThe player does not need to download an entire chunk/segment before it can start playback. If `bufferForPlaybackMs` / `bufferForPlaybackAfterRebufferMs` are set to 1s and your chunk/segment duration is 4s, this means playback will start once a quarter of the first chunk/segment has been downloaded."
      },
      {
        "user": "biswarupdasgupta",
        "created_at": "2020-07-07T10:38:40Z",
        "body": "Thanks for the clarifications"
      }
    ]
  },
  {
    "number": 7525,
    "title": "Accessing active datasource in onPositionDiscontinuity",
    "created_at": "2020-06-18T18:31:36Z",
    "closed_at": "2020-09-22T16:17:58Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/google/ExoPlayer/issues/7525",
    "body": "### [REQUIRED] Searched documentation and issues\r\n\r\nI did :)\r\n\r\n### [REQUIRED] Question\r\nI'm having an hard time to get the active datasource when the media change in a ```ConcatenatingMediaSource```.\r\n\r\nI use a specific ```DataSourceFactory``` that extends ```HttpDataSource.BaseFactory``` and prepare the media in the ```open(dataSpec)```.\r\nDuring this preparation the media can be transcoded or not and depending on many factor the resulting may support some things like seeking or not.\r\nI need to be able to access this information to do things like not calling normal seek but restart the transcoding at the new position.\r\n\r\nThe problem is that in ```ConcatenatingMediaSource``` ```open``` can be called to prepare the next media while the active media is still not closed.\r\n\r\nSo the question is how can I access the datasource from the player ```onPositionDiscontinuity``` callback. Or how can I access the ```MediaSource``` from the ```DataSource``` to be able to modify the tag?\r\n",
    "comments_url": "https://api.github.com/repos/google/ExoPlayer/issues/7525/comments",
    "author": "Tolriq",
    "comments": [
      {
        "user": "AquilesCanta",
        "created_at": "2020-06-19T15:01:31Z",
        "body": "Why don't you assign a specific `DataSourceFactory` to each `MediaSource` so that each `DataSourceFactory` knows to which MediaSource they are assigned?\r\n\r\nSo when the media source calls `open(...)` for preparation (or whatever), you know which is the calling MediaSource, since the `DataSourceFactory` knows the corresponding `MediaSource`."
      },
      {
        "user": "Tolriq",
        "created_at": "2020-06-19T15:23:04Z",
        "body": "Isn't that highly inefficient to create a DefaultDataSourceFactory and my factory for every single items for very large playlists?"
      },
      {
        "user": "tonihei",
        "created_at": "2020-09-22T14:41:11Z",
        "body": "`DefaultDataSourceFactory` is just a thin wrapper creating other `DataSource` instances, so there should be no issue with creating multiple factories if needed.\r\n\r\nNot sure about your exact use case, but you can also consider one of the following:\r\n - Use `ResolvingDataSource` to add additional loading steps based on the `DataSpec`. You could detect whatever you need from the `DataSpec` URL, custom header key-value pairs or from using the `customData` object. Whether this is easily possible depends on the details of what you need and what you are trying to achieve.\r\n - Set a `tag` on each `MediaSource` (or `MediaItem`) that can be retrieved by `Player.getCurrentTag()` in `onPositionDiscontinuity`."
      },
      {
        "user": "Tolriq",
        "created_at": "2020-09-22T14:56:49Z",
        "body": "@tonihei  Ok so let me try to better explain the need that is.\r\n\r\nThe player can play media from many different sources and some of them can transcode the media on the fly.\r\nThe transcoding or not decision is made at the ```DataSource.open``` to avoid wasting server resources.\r\nWhen transcoding some server for some media type and transcoded media can generate non seekable media via normal player seek functions.\r\nI can detect and know this only when transcoding start so in ```DataSource.open```\r\n\r\nBut I need to know this at the player / UI side to either disable the seek functions or intercept the seek to be actual restart of the media at the proper new starting point.\r\n\r\nThe problem is that with gapless / ConcateningMediaSource the ```DataSource.open``` is called independently of the active media.\r\n\r\nAnd from ```DataSource.open``` I can't access the corresponding MediaItem/MediaSource to update the tag that I could then use in ```onPositionDiscontinuity```\r\n\r\nSo TL;DR I need to access the MediaSource/MediaItem from the ```DataSource.open``` not sure ```ResolvingDataSource``` brings anything here as it's before the open."
      },
      {
        "user": "tonihei",
        "created_at": "2020-09-22T15:06:29Z",
        "body": "`ResolvingDataSource` is essentially just an easy wrapper to intercept the `DataSpec` to the `DataSource`. If the actual information you need is only available afterwards, you would probably need to follow @AquilesCanta's advice and use a `DataSource.Factory` for each of your `DataSources` that has access to your tag object:\r\n\r\n```\r\nMediaSource mediaSource = \r\n    new ProgressiveMediaSource.Factory(() -> new MyCustomDataSource(tag))\r\n      .setTag(tag)\r\n      .createMediaSource(MediaItem.forUri(uri));\r\n```\r\n\r\nAside: If you make the `tag` object mutable be aware that the loading takes place on another thread, so you need additional thread safety around the updates."
      },
      {
        "user": "Tolriq",
        "created_at": "2020-09-22T15:36:03Z",
        "body": "Thanks that's what I do, but the new playlist api is all about MediaItem directly no? Or I can use MediaSources directly and still use the new playlist api instead of concateningmediasource?"
      },
      {
        "user": "tonihei",
        "created_at": "2020-09-22T15:43:49Z",
        "body": "Yes, you can. The `ExoPlayer` interface defines all relevant methods for that (e.g. `setMediaSource`, `addMediaSource` etc)"
      },
      {
        "user": "Tolriq",
        "created_at": "2020-09-22T16:17:58Z",
        "body": "Ok thanks, closing this one too as there's no other way and factory are small :)"
      }
    ]
  },
  {
    "number": 7514,
    "title": "PlayerNotificationManager not showing notification for video",
    "created_at": "2020-06-17T10:48:32Z",
    "closed_at": "2020-06-17T12:53:56Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/google/ExoPlayer/issues/7514",
    "body": "I have application which plays video and I want to show notification with player controls - play, pause, next, previous etc.\r\nI tried using PlayerNotificationManager mentioned in the Medium Post\r\nPlayerNotificationManager\r\nBut the notification isn't visible. I assigned the player to notification manager after the player is initialised.\r\n\r\nChecking on android API 29 and I am using SimpleExoPlayer for player and setting it to notification manager\r\n\r\n          `  DefaultRenderersFactory defaultRenderersFactory = new DefaultRenderersFactory(getContext())\r\n                .setExtensionRendererMode(DefaultRenderersFactory.EXTENSION_RENDERER_MODE_ON);\r\n        SimpleExoPlayer   player = new SimpleExoPlayer.Builder(getContext(), defaultRenderersFactory)\r\n                .setTrackSelector(trackSelector)\r\n                .build();\r\n        player.addListener(this);\r\n        playerView.setPlayer(player);\r\n        playerView.setPlaybackPreparer(this);\r\n        PlayerNotificationManager playerNotificationManager = new PlayerNotificationManager(\r\n                appCMSPresenter.getCurrentContext(),\r\n                \"player not\",\r\n                459, new DescriptionAdapter());\r\n\r\n        playerNotificationManager.setPlayer(player);`",
    "comments_url": "https://api.github.com/repos/google/ExoPlayer/issues/7514/comments",
    "author": "wishy-viewlift",
    "comments": [
      {
        "user": "marcbaechinger",
        "created_at": "2020-06-17T11:57:27Z",
        "body": "With the code above you are saying that you have created a notification channel with the title `player not`. If such a notification channel does not exist, the system will not show the notification and I believe you would find something in the logs telling this (not sure though).\r\n\r\nCan you double check  whether the notification channel 'player not' has been properly created? \r\n\r\nIf you find you need to create a channel first, you may consider looking into the static factory method which will create the channel with the declared id's and names for you.\r\n\r\n```\r\ncreateWithNotificationChannel(\r\n      Context context,\r\n      String channelId,\r\n      @StringRes int channelName,\r\n      @StringRes int channelDescription,\r\n      int notificationId,\r\n      MediaDescriptionAdapter mediaDescriptionAdapter)\r\n```\r\n\r\nIf this does not work, please accept my apologies and do a bug report and upload it here so I can look into your issue some more. You can alternatively send the bug report by email to dev.exoplayer@gmail.com using a subject in the format \"Issue #7514\"."
      },
      {
        "user": "wishy-viewlift",
        "created_at": "2020-06-17T12:53:56Z",
        "body": "Notification Channel did not existed, that seemed to be the issue."
      }
    ]
  },
  {
    "number": 7450,
    "title": "How to remove ICY header request",
    "created_at": "2020-05-31T13:53:32Z",
    "closed_at": "2020-06-01T10:21:49Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/google/ExoPlayer/issues/7450",
    "body": "Hi,\r\n\r\nI was trying to find a way on how to remove the ICY header from the header request. I'm expecting it is causing some issues with certein hosting server.\r\n\r\ni have been trying many things without success e.g. \r\n\r\n```\r\nfinal HttpDataSource.RequestProperties s = dataSourceFactory.getDefaultRequestProperties();\r\ns.remove(IcyHeaders.REQUEST_HEADER_ENABLE_METADATA_NAME);\r\n```\r\n\r\nOR \r\n\r\n```\r\nfinal ProgressiveMediaSource audioSource2 =\r\nnew ProgressiveMediaSource.Factory(() -> {\r\n\tfinal HttpDataSource dataSource = new DefaultHttpDataSource(Util.getUserAgent(this, getString(R.string.app_name)))\r\n\t{\r\n\t\t@Override\r\n\t\tpublic long open(DataSpec dataSpec) throws HttpDataSourceException\r\n\t\t{\r\n\t\t\tdataSpec.httpRequestHeaders.remove(IcyHeaders.REQUEST_HEADER_ENABLE_METADATA_NAME);\r\n\t\t\treturn super.open(dataSpec);\r\n\t\t}\r\n\t};\r\n\t//dataSource.clearRequestProperty(IcyHeaders.REQUEST_HEADER_ENABLE_METADATA_NAME);\r\n\treturn dataSource;\r\n}).createMediaSource(Uri.parse(url));\r\n```\r\n\r\nthe last one throws:\r\n```\r\n2020-05-31 17:45:56.863 9747-10339/com.myapp.audiocataloger E/LoadTask: Unexpected exception loading stream\r\n      java.lang.UnsupportedOperationException\r\n        at java.util.Collections$UnmodifiableMap.remove(Collections.java:1502)\r\n        at com.myapp.audiocataloger.MediaService$4.open(MediaService.java:813)\r\n        at com.google.android.exoplayer2.upstream.StatsDataSource.open(StatsDataSource.java:83)\r\n        at com.google.android.exoplayer2.source.ProgressiveMediaPeriod$ExtractingLoadable.load(ProgressiveMediaPeriod.java:956)\r\n        at com.google.android.exoplayer2.upstream.Loader$LoadTask.run(Loader.java:391)\r\n        at java.util.concurrent.ThreadPoolExecutor.processTask(ThreadPoolExecutor.java:1187)\r\n        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1152)\r\n        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:641)\r\n        at java.lang.Thread.run(Thread.java:784)\r\n```\r\n\r\nI tried as well to override it in TransferListener without success as well\r\n\r\n```\r\nfinal TransferListener transferListener = new TransferListener()\r\n{\r\n\t@Override\r\n\tpublic void onTransferInitializing(DataSource dataSource, DataSpec dataSpec, boolean isNetwork)\r\n\t{\r\n\t\t// Override it here\r\n\t}\r\n\r\n\t@Override\r\n\tpublic void onTransferStart(DataSource dataSource, DataSpec dataSpec, boolean b){}\r\n\r\n\t@Override\r\n\tpublic void onBytesTransferred(DataSource dataSource, DataSpec dataSpec, boolean b, int i){}\r\n\r\n\t@Override\r\n\tpublic void onTransferEnd(DataSource dataSource, DataSpec dataSpec, boolean b){}\r\n};\r\n```\r\n\r\nPlease advise the proper way to do this.\r\n",
    "comments_url": "https://api.github.com/repos/google/ExoPlayer/issues/7450/comments",
    "author": "Abu-Abdullah",
    "comments": [
      {
        "user": "andrewlewis",
        "created_at": "2020-06-01T08:04:06Z",
        "body": "In the option where you override `open`, could you try instantiating a new `DataSpec` based on values from the old one but without the ICY header?"
      },
      {
        "user": "Abu-Abdullah",
        "created_at": "2020-06-01T10:21:49Z",
        "body": "thank you @andrewlewis for the hint. it is working as you suggest:\r\n```\r\n@Override\r\npublic long open(DataSpec dataSpec) throws HttpDataSourceException\r\n{\r\n\tfinal Map<String, String> m1 = dataSpec.httpRequestHeaders;\r\n\tfinal Map<String, String> m2 = new HashMap<>();\r\n\tfor (Map.Entry<String, String> entry : m1.entrySet())\r\n\t\tif(!entry.getKey().equals(IcyHeaders.REQUEST_HEADER_ENABLE_METADATA_NAME))\r\n\t\t\tm2.put(entry.getKey(), entry.getValue());\r\n\t\r\n\treturn super.open(dataSpec.withRequestHeaders(m2));\r\n}\r\n```\r\nAnd thankfully the web server behavior is correct now. I'm not facing the same issues that i faced in #7353 which indicates that setting ICY_Metadata in the header by default is not the correct way. Many web servers might be affected by this (at least in my case which i have it on bluehost, one of the leaders in this market).\r\n\r\nI think we should have an easy way to configure the dataspec.httpRequestHeaders\r\n\r\nthank you again"
      }
    ]
  },
  {
    "number": 7443,
    "title": "onMetadataChanged callback not getting updated properly",
    "created_at": "2020-05-29T01:55:47Z",
    "closed_at": "2020-06-01T08:11:40Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/google/ExoPlayer/issues/7443",
    "body": "### [REQUIRED] Searched documentation and issues\r\nI've looked pretty thoroughly through the documentation but am not able to figure this out.\r\n\r\n### [REQUIRED] Question\r\nI started with the demo app from IO18, \"Building feature-rich media apps with ExoPlayer (Google I/O '18)\". Currently I have my ExoPlayer version 2.9.6 wrapped in a service. It is using MediaSessionConnector and PlayerNotificationManager. The app can add songs to the playlist from any fragment in the app, and they play fine, but the fragments are not receiving correct notifications as to the current song. They receive notifications that a song has changed but the metadata for that song is always the first song added to the playlist, not the current song.\r\n\r\nThe fragment has a MediaControllerCompat that it initializes with the \"global\" session token and registers a MediaControllerCallback instance. It is this callback that doesn't get up-to-date metadata, only the metadata from the the first song played from the playlist.\r\n\r\nSo am I going about this the wrong way, forgetting a step, or did I miss something obvious?\r\n\r\nI am not using a PlayerView. Songs are added via Intents and the ACTION_ADD_TO_PLAYLIST action.\r\n\r\nFor what it is worth, here is my code, warts and all:\r\n\r\n```\r\n\r\npublic class AudioPlayerService extends Service {\r\n\r\n    public static final String TAG = \"AudioPlayerService\";\r\n    public static final int ACTION_START_SERVICE = 0;\r\n    public static final int ACTION_ADD_TO_PLAYLIST = 1;\r\n    public static final String SERVICE_ACTION = \"service_action\";\r\n    public static final String SERVICE_DETAIL = \"service_detail\";\r\n    public static final String BUNDLED_LISTENER = \"bundled_listener\";\r\n    public static final String TOKEN_VAL = \"bundled_token\";\r\n\r\n    private SimpleExoPlayer player;\r\n    private PlayerNotificationManager playerNotificationManager;\r\n    private MediaSessionCompat mediaSession;\r\n    private MediaSessionConnector mediaSessionConnector;\r\n    private final IBinder mBinder = new LocalBinder();\r\n\r\n    ConcatenatingMediaSource concatenatingMediaSource;\r\n    CacheDataSourceFactory cacheDataSourceFactory;\r\n\r\n    private MusicRepo musicRepo;\r\n    private MediaSessionCompat.Token mMediaSessionToken;\r\n\r\n    @Override\r\n    public void onCreate() {\r\n\r\n        super.onCreate();\r\n        Log.i(TAG, \"onCreate\");\r\n        final Context context = this;\r\n\r\n        player = ExoPlayerFactory.newSimpleInstance(context, new DefaultTrackSelector());\r\n\r\n        DefaultDataSourceFactory dataSourceFactory = new DefaultDataSourceFactory(\r\n                context, Util.getUserAgent(context, getString(R.string.app_name)));\r\n\r\n        cacheDataSourceFactory = new CacheDataSourceFactory(\r\n                DownloadUtil.getCache(context),\r\n                dataSourceFactory,\r\n                CacheDataSource.FLAG_IGNORE_CACHE_ON_ERROR);\r\n\r\n        concatenatingMediaSource = new ConcatenatingMediaSource();\r\n\r\n        player.setPlayWhenReady(true);\r\n\r\n        musicRepo = MusicRepo.get(getApplicationContext());\r\n        playerNotificationManager = PlayerNotificationManager.createWithNotificationChannel(\r\n                context,\r\n                PLAYBACK_CHANNEL_ID,\r\n                R.string.playback_channel_name,\r\n                PLAYBACK_NOTIFICATION_ID,\r\n                new MediaDescriptionAdapter() {\r\n                    @Override\r\n                    public String getCurrentContentTitle(Player player) {\r\n\r\n                        //int index = player.getCurrentWindowIndex();\r\n\r\n                        Log.d(TAG, \"Current Tag\" + player.getCurrentTag());\r\n\r\n                        Object mediaTag = player.getCurrentTag();\r\n                        if (mediaTag != null) {\r\n                            Song song = musicRepo.GetSongByMediaId(mediaTag.toString());\r\n                            if (song != null) {\r\n                                return song.title;\r\n                            }\r\n                        }\r\n\r\n                        return null;\r\n                    }\r\n\r\n                    @Nullable\r\n                    @Override\r\n                    public PendingIntent createCurrentContentIntent(Player player) {\r\n                        return null;\r\n                    }\r\n\r\n                    @Nullable\r\n                    @Override\r\n                    public String getCurrentContentText(Player player) {\r\n//                        return SAMPLES[player.getCurrentWindowIndex()].description;\r\n\r\n                        //int index = player.getCurrentWindowIndex();\r\n\r\n                        Log.d(TAG, \"Current Tag\" + player.getCurrentTag());\r\n\r\n                        Object mediaTag = player.getCurrentTag();\r\n                        if (mediaTag != null) {\r\n                            Song song = musicRepo.GetSongByMediaId(mediaTag.toString());\r\n                            if (song != null) {\r\n                                return song.description;\r\n                            }\r\n                        }\r\n\r\n                        return null;\r\n\r\n                    }\r\n\r\n                    @Nullable\r\n                    @Override\r\n                    public Bitmap getCurrentLargeIcon(Player player, BitmapCallback callback) {\r\n                        Log.d(TAG, \"Current Tag\" + player.getCurrentTag());\r\n\r\n                        Object mediaTag = player.getCurrentTag();\r\n                        if (mediaTag != null) {\r\n                            Song song = musicRepo.GetSongByMediaId(mediaTag.toString());\r\n                            if (song != null) {\r\n                                return MusicRepo.getBitmap( getApplicationContext(), song.bitmapResource);\r\n                            }\r\n                        }\r\n\r\n                        return null;\r\n\r\n//                        return Samples.getBitmap(\r\n//                                context, SAMPLES[player.getCurrentWindowIndex()].bitmapResource);\r\n                    }\r\n                }\r\n        );\r\n        playerNotificationManager.setUseChronometer(true);\r\n        playerNotificationManager.setNotificationListener(new NotificationListener() {\r\n            @Override\r\n            public void onNotificationStarted(int notificationId, Notification notification) {\r\n                startForeground(notificationId, notification);\r\n            }\r\n\r\n            @Override\r\n            public void onNotificationCancelled(int notificationId) {\r\n                stopSelf();\r\n            }\r\n        });\r\n\r\n        playerNotificationManager.setUseChronometer(true);\r\n        playerNotificationManager.setPlayer(player);\r\n\r\n        mediaSession = new MediaSessionCompat(context, MEDIA_SESSION_TAG);\r\n        mediaSession.setActive(true);\r\n        mMediaSessionToken = mediaSession.getSessionToken();\r\n        Log.d(TAG, \"Media Session Token: \" + mMediaSessionToken.toString());\r\n        playerNotificationManager.setMediaSessionToken(mMediaSessionToken);\r\n\r\n        mediaSessionConnector = new MediaSessionConnector(mediaSession);\r\n        mediaSessionConnector.setQueueNavigator(new TimelineQueueNavigator(mediaSession) {\r\n            @Override\r\n            public MediaDescriptionCompat getMediaDescription(Player player, int windowIndex) {\r\n                Log.d(TAG, \"getMediaDescription: QueueNavigator: \" + windowIndex);\r\n\r\n                Object tag = player.getCurrentTag();\r\n                if (tag != null) {\r\n                    String mediaId = tag.toString();\r\n                    Song song = musicRepo.GetSongByMediaId(mediaId);\r\n                    if (song != null) {\r\n                        return MusicRepo.getMediaDescription( AudioPlayerService.this, song);\r\n                    }\r\n                }\r\n                //return Samples.getMediaDescription(context, SAMPLES[windowIndex]);\r\n                return null;\r\n            }\r\n\r\n        });\r\n        mediaSessionConnector.setPlayer(player, null);\r\n        //mediaSession.setActive(true);\r\n    }\r\n\r\n    @Override\r\n    public void onDestroy() {\r\n        mediaSession.release();\r\n        mediaSessionConnector.setPlayer(null, null);\r\n        playerNotificationManager.setPlayer(null);\r\n        player.release();\r\n        player = null;\r\n\r\n        super.onDestroy();\r\n    }\r\n\r\n    @Nullable\r\n    @Override\r\n    public IBinder onBind(Intent intent) {\r\n        return mBinder;\r\n    }\r\n\r\n    @Override\r\n    public int onStartCommand(Intent intent, int flags, int startId) {\r\n        int action = intent.getIntExtra(SERVICE_ACTION, ACTION_START_SERVICE);\r\n        switch (action) {\r\n            case ACTION_START_SERVICE:\r\n\r\n                Log.d(TAG, \"onStartCommand: ACTION_START_SERVICE \");\r\n                //don't need this now that service is bound\r\n//                ResultReceiver receiver = intent.getParcelableExtra(AudioPlayerService.BUNDLED_LISTENER);\r\n//                Bundle bundle = new Bundle();\r\n//                bundle.putParcelable(TOKEN_VAL, mMediaSessionToken);\r\n//                receiver.send(Activity.RESULT_OK, bundle);\r\n                return START_STICKY;\r\n\r\n            case ACTION_ADD_TO_PLAYLIST:\r\n\r\n                Log.d(TAG, \"onStartCommand: ACTION_ADD_TO_PLAYLIST \");\r\n                int detailId = intent.getIntExtra(SERVICE_DETAIL, 0) ;\r\n                DetailedSelection detail = DetailedSelection.toDetailedSelection(detailId);\r\n                Log.d(TAG, \"onStartCommand: Adding to playlist \" + detail);\r\n                addToPlaylist(detail);\r\n\r\n            break;\r\n        }\r\n        return START_STICKY;\r\n    }\r\n\r\n    @Override\r\n    public void onLowMemory() {\r\n        super.onLowMemory();\r\n    }\r\n\r\n    private void addToPlaylist(DetailedSelection detail) {\r\n\r\n        Log.d(TAG, \"Adding to playlist detail: \" + detail);\r\n\r\n        MusicRepo musicRepo = MusicRepo.get(this);\r\n\r\n        Song song = musicRepo.GetPrimarySong(detail);\r\n        Log.d(TAG, \"Adding Song: \" + song.mediaId + \" \" + song.title);\r\n\r\n/*\r\n        Samples.Sample sample = null;\r\n        if (detail.getValue() % 2 == 0) {\r\n            sample = SAMPLES[0];\r\n        }\r\n        else {\r\n           sample = SAMPLES[1];\r\n        }\r\n*/\r\n        MediaSource mediaSource = new ExtractorMediaSource.Factory(cacheDataSourceFactory)\r\n                .setTag(song.mediaId)//add in tag for unique identifier of song\r\n                .createMediaSource(song.uri);\r\n\r\n        concatenatingMediaSource.addMediaSource(mediaSource);\r\n        /*\r\n        for (Samples.Sample sample : SAMPLES) {\r\n            MediaSource mediaSource = new ExtractorMediaSource.Factory(cacheDataSourceFactory)\r\n                    .createMediaSource(sample.uri);\r\n            concatenatingMediaSource.addMediaSource(mediaSource);\r\n        }\r\n\r\n        */\r\n\r\n        //player.prepare(concatenatingMediaSource, false, false);\r\n        player.prepare(concatenatingMediaSource);\r\n      //  player.\r\n      //  player.getMetadataComponent().notifyAll();\r\n//        if ( player.getPlaybackState() == Player.STATE_READY && player.getPlayWhenReady()) {\r\n//\r\n//        }\r\n//        else {\r\n//            player.setPlayWhenReady(true);\r\n//        }\r\n\r\n\r\n    }\r\n\r\n    /** method for clients */\r\n    public int Pause() {\r\n        Log.d(TAG, \"Pause: \");\r\n\r\n        return 0;\r\n    }\r\n\r\n    public int Add(DetailedSelection mDetailedSelection) {\r\n\r\n        Log.d(TAG, \"Adding selection \" + mDetailedSelection);\r\n        player.setPlayWhenReady(true);\r\n        return 0;\r\n\r\n    }\r\n\r\n    public static Intent GetFactoryIntent(Context ctx) {\r\n\r\n        Intent intent = new Intent(ctx, AudioPlayerService.class);\r\n        intent.putExtra(SERVICE_ACTION, ACTION_START_SERVICE);\r\n        return intent;\r\n    }\r\n    public static Intent GetAddToPlaylistIntent(Context ctx, DetailedSelection detail ) {\r\n\r\n        Intent intent = new Intent(ctx, AudioPlayerService.class);\r\n        intent.putExtra(SERVICE_ACTION, ACTION_ADD_TO_PLAYLIST);\r\n        intent.putExtra(SERVICE_DETAIL, detail.getValue());\r\n        return intent;\r\n\r\n    }\r\n\r\n    public MediaSessionCompat.Token getMediaSessionToken() {\r\n        return mMediaSessionToken;\r\n    }\r\n\r\n    public class LocalBinder extends Binder {\r\n        public AudioPlayerService getService() {\r\n            return AudioPlayerService.this;\r\n        }\r\n    }\r\n```\r\n\r\nAnd here is the fragment that is not getting updated properly. Right now the songs are started in another fragment, play fine in the NotificationArea, so the buttons don't really mean anything. The session token is shared via a common view model. Mostly I wonder why the code in `onMetadataChanged` is not working as expected.\r\n\r\n```\r\n\r\npublic class HomeFragment extends Fragment {\r\n\r\n    private String TAG = getClass().getSimpleName();\r\n\r\n    private MediaSessionCompat.Token mToken;\r\n    private PlayerView mPlayerView;\r\n    private MediaControllerCompat mMediaController;\r\n    private MediaControllerCallback mControllerCallback;\r\n    private boolean mControllerRegistered = false;\r\n\r\n    private Button btn1;\r\n    private Button btn2;\r\n    private CheckBox checkBox1;\r\n    private CheckBox checkBox2;\r\n\r\n    public View onCreateView(@NonNull LayoutInflater inflater,\r\n                             ViewGroup container, Bundle savedInstanceState) {\r\n\r\n        View root = inflater.inflate(R.layout.fragment_home, container, false);\r\n        final TextView textView = root.findViewById(R.id.text_home);\r\n\r\n\r\n        final Button button = root.findViewById(R.id.button_token);\r\n      //  button.setOnClickListener(v -> Toast.makeText(this, \"Button clicked\", Toast.LENGTH_LONG).show());\r\n        button.setOnClickListener(view -> {\r\n            Activity activity  =  getActivity();\r\n            if (activity != null) {\r\n                if (activity instanceof IMainActivity) {\r\n                    mToken = ((IMainActivity)activity).getSessionToken();\r\n                    if (mToken != null) {\r\n                        Log.i(TAG, mToken.toString());\r\n                    }\r\n                }\r\n            }\r\n        });\r\n\r\n        final Button button_playlist = root.findViewById(R.id.button_playlist);\r\n        button_playlist.setOnClickListener(new View.OnClickListener() {\r\n            @Override\r\n            public void onClick(View view) {\r\n                Log.i(TAG, \"trying to get playlist\");\r\n                try {\r\n                    MediaControllerCompat mcc = new MediaControllerCompat(getContext(), HomeFragment.this.mToken);\r\n                    //mcc.get\r\n                    List<MediaSessionCompat.QueueItem> queue = mcc.getQueue();\r\n                    if (queue != null) {\r\n                        Log.i(TAG, \"queue not null\");\r\n                       //  Log.i(TAG, queue.toString());\r\n                         for (MediaSessionCompat.QueueItem item : queue) {\r\n                             Log.i(TAG, \"qi:\" + item.toString());\r\n                         }\r\n                    }\r\n                    else {\r\n                        Log.i(TAG, \"queue NULL\");\r\n                    }\r\n                } catch (RemoteException e) {\r\n                    e.printStackTrace();\r\n                }\r\n\r\n\r\n            }\r\n        });\r\n      //  mPlayerView = root.findViewById(R.id.player_view);\r\n\r\n        btn1 = root.findViewById(R.id.btn_play_1);\r\n        btn2 = root.findViewById(R.id.btn_play_2);\r\n        checkBox1 = root.findViewById(R.id.chbox_is_playing_1);\r\n        checkBox2 = root.findViewById(R.id.chbox_is_playing_2);\r\n        btn1.setOnClickListener(v -> {\r\n\r\n            Log.i(TAG, \"btn1 Clicked\");\r\n\r\n        });\r\n        btn2.setOnClickListener(v -> {\r\n                Log.i(TAG, \"btn2 Clicked\");\r\n        });\r\n\r\n        return root;\r\n    }\r\n    @Override\r\n    public void onViewCreated(@NonNull View view, Bundle savedInstanceState) {\r\n\r\n        super.onViewCreated(view, savedInstanceState);\r\n        MainViewModel mainVm = new ViewModelProvider (requireActivity()).get(MainViewModel.class);\r\n\r\n        mainVm.getName().observe(getViewLifecycleOwner(), s -> {\r\n            Log.i(TAG, \"Name = \" + s);\r\n        });\r\n        //\r\n        mainVm.getToken().observe(getViewLifecycleOwner(), token -> {\r\n            Log.i(TAG, \"Token = \" + token);\r\n            try {\r\n\r\n                if (mControllerRegistered) {\r\n                    return;\r\n                }\r\n\r\n                mMediaController = new MediaControllerCompat(getActivity(), token);\r\n                if (mControllerCallback == null) {\r\n                    mControllerCallback = new HomeFragment.MediaControllerCallback();\r\n                }\r\n                Log.i(TAG, \"Registered!!!\");\r\n                mMediaController.registerCallback(mControllerCallback);\r\n                mControllerRegistered = true;\r\n           //     registerController();\r\n//                mControllerCallback = new HomeFragment.MediaControllerCallback();\r\n//                mMediaController.registerCallback(mControllerCallback);\r\n//                mControllerRegistered = true;\r\n\r\n\r\n            }\r\n\r\n            catch(RemoteException ex) {\r\n                Log.e(TAG, ex.getMessage());\r\n                ex.printStackTrace();\r\n\r\n            }\r\n\r\n        });\r\n\r\n    }\r\n    @Override\r\n    public void onDestroyView() {\r\n        super.onDestroyView();\r\n        Log.e(TAG, \"View Destroyed\");\r\n        unRegisterController();\r\n    }\r\n    @Override\r\n    public void onAttach(Context context) {\r\n\r\n        super.onAttach(context);\r\n        Log.i(TAG, \"onAttach\");\r\n       // registerController();\r\n\r\n\r\n\r\n    }\r\n\r\n    @Override\r\n    public void onDetach() {\r\n\r\n        super.onDetach();\r\n        Log.i(TAG, \"onDetach\");\r\n        unRegisterController();\r\n\r\n    }\r\n\r\n    private void registerController() {\r\n\r\n\r\n    }\r\n    private void unRegisterController() {\r\n\r\n        if (mControllerRegistered) {\r\n            mMediaController.unregisterCallback(mControllerCallback);\r\n            mControllerRegistered = false;\r\n        }\r\n\r\n    }\r\n    private static class MediaControllerCallback extends MediaControllerCompat.Callback {\r\n\r\n        private static final String TAG = \"HomeFragment:MCC\";\r\n        @Override\r\n        public void onPlaybackStateChanged(@Nullable final PlaybackStateCompat state) {\r\n            Log.i(TAG, \"onPlaybackStateChanged: \" + state.toString());\r\n            long queueId =  state.getActiveQueueItemId();\r\n            Log.i(TAG, \"onPlaybackStateChanged: qid \" + queueId);\r\n        }\r\n        @Override\r\n        public void onMetadataChanged(final MediaMetadataCompat metadata) {\r\n            // Filtering out needless updates, given that the metadata has not changed.\r\n            Log.i(TAG, \"onMetadataChanged\");\r\n            if (metadata != null) {\r\n                Log.i(TAG, \"onMetadataChanged: \" + metadata.toString());\r\n                Set<String> keys = metadata.keySet();\r\n\r\n                String mediaId = metadata.getString(MediaMetadataCompat.METADATA_KEY_MEDIA_ID);\r\n                String title = metadata.getString(MediaMetadataCompat.METADATA_KEY_TITLE);\r\n                Log.i(TAG, \"MediaId: \" +  mediaId);\r\n                Log.i(TAG, \"Title: \" +  title);\r\n            }\r\n        }\r\n        @Override\r\n        public void onQueueChanged (List<MediaSessionCompat.QueueItem> queue) {\r\n            Log.i(TAG, \"onQueueChanged\");\r\n            int queueCount = queue.size();\r\n            for(MediaSessionCompat.QueueItem item : queue) {\r\n\r\n            }\r\n            Log.i(TAG, \"onQueueChanged: size \" + queueCount);\r\n        }\r\n        @Override\r\n        public void onQueueTitleChanged (CharSequence title) {\r\n            Log.i(TAG, \"onQueueTitleChanged: \" + title);\r\n        }\r\n        @Override\r\n        public void onSessionDestroyed ()\r\n        {\r\n            Log.i(TAG, \"onSessionDestroyed: \" );\r\n        }\r\n    }\r\n```",
    "comments_url": "https://api.github.com/repos/google/ExoPlayer/issues/7443/comments",
    "author": "voam",
    "comments": [
      {
        "user": "marcbaechinger",
        "created_at": "2020-05-29T12:15:08Z",
        "body": "In the code above the `MediaSessionConnector` is setup with the `TimelineQueueNavigator`. The `TimelineQueueNavigator` is used for two things: providing the `activeQueueItemId` of the `PlaybackStatenCompat` and to provide the media descriptions for each item in the timeline, with which the queue of the media session is populated. Former is done internally, while latter, the media descriptions for each timeline/queue item, needs to be provided by the abstract method `getMediaDescription(Player player, int windowIndex)` which you need to implement yourself.\r\n\r\nLooking into the implementation above it appears to me, that it always returns the description of the current item which is evaluated with `player.getCurrentTag()`. Instead the `windowIndex` needs to be taken into account.\r\n\r\nImagine that the `MediaSessionConnector` knows that there are 10 items in the timeline of the player. To populate the queue of the media session, it then call this method for each `windowIndex` 0 to 9 and populates the queue of the session with the 10 descriptions that are returned. The metadata is then taken from the queue of the session at the `currentWindowIndex`. \r\n\r\nWith the code above I'd expect that the queue is not properly populated because `getMediaDescription(Player player, int windowIndex)` does not what it is expected to do.\r\n\r\nCan you check this and provide the media description for the `windowIndex`? You can put a breakpoint into `getMediaDescription(Player player, int windowIndex)` at first to see that it is called once for each window index.\r\n\r\n"
      },
      {
        "user": "voam",
        "created_at": "2020-05-31T02:53:38Z",
        "body": "I see. That makes sense. Indeed, the `getMediaDescription(Player player, int windowIndex)` is called once for each window index.  The correct songs play in the correct order and show up in the Notification area properly.  But the MediaDescription is always the one for the first song added. \r\n\r\nI guess the question comes down to how to use the windowIndex to navigate the timeline and get the tag of the song based on the timline index?. Maybe I shouldn't be using an anonymous `TimelineQueueNavigator` ?"
      },
      {
        "user": "voam",
        "created_at": "2020-05-31T11:32:42Z",
        "body": "Ah, after your explanation and exploring a little bit I guess I can use the `windowIndex `to index into the `concatenatingMediaSource` and this lets me get the correct media. With this change the `onMetadataChanged` callback in the second fragment gets supplied the correct info. Super!\r\n\r\nThanks you @marcbaechinger for the insight and help!\r\n\r\n\r\n```\r\n\r\nmediaSessionConnector.setQueueNavigator(new TimelineQueueNavigator(mediaSession) {\r\n            @Override\r\n            public MediaDescriptionCompat getMediaDescription(Player player, int windowIndex) {\r\n\r\n                Log.d(TAG, \"getMediaDescription: QueueNavigator: \" + windowIndex);\r\n\r\n                MediaSource mediaSource = concatenatingMediaSource.getMediaSource(windowIndex);\r\n                Object tag = mediaSource.getTag();\r\n\r\n                if (tag != null) {\r\n                    String mediaId = tag.toString();\r\n                    Song song = musicRepo.GetSongByMediaId(mediaId);\r\n                    if (song != null) {\r\n                        Log.i(TAG, \"GetSongByMediaId: getMediaDescription: \" + song.title + \" : \" + song.mediaId + \" windowIndex: \" + windowIndex);\r\n                        MediaDescriptionCompat mediaDescription = MusicRepo.getMediaDescription( AudioPlayerService.this, song);\r\n                        return mediaDescription;\r\n                    }\r\n                }\r\n                //return Samples.getMediaDescription(context, SAMPLES[windowIndex]);\r\n                return null;\r\n            }\r\n\r\n        });\r\n```"
      }
    ]
  },
  {
    "number": 7426,
    "title": "\"*mp4?type=m3u8\" cause error media source",
    "created_at": "2020-05-26T10:40:30Z",
    "closed_at": "2020-05-27T00:45:34Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/google/ExoPlayer/issues/7426",
    "body": "### [REQUIRED] Searched documentation and issues\r\n\r\n### [REQUIRED] Question\r\nThe movie link end with **\"mp4?type=m3u8\"**, use exo player with `TYPE_OTHER` to watch the movie, and then it caused `UnrecognizedInputFormatException`. But my android platform support the video format, I try again with `TYPE_HLS`, it works well. \r\n**Is there any good ways to solve it?**\r\n\r\n### A full bug report captured from the device\r\n```\r\nExoPlayer: mExoEventListener - onPlayerStateChanged: playWhenReady = true, playbackState = 2\r\nExoPlayer: mExoEventListener: playbackState = STATE_BUFFERING 0 - 0\r\nEventLogger: timeline [eventTime=0.01, mediaPos=0.00, window=0, periodCount=1, windowCount=1, reason=PREPARED\r\nEventLogger:   period [?]\r\nEventLogger:   window [?, false, false]\r\nEventLogger: ]\r\nExoPlayer: mExoEventListener: onTimelineChanged-----timeline com.google.android.exoplayer2.source.SinglePeriodTimeline@214da72\r\nEventLogger: mediaPeriodCreated [eventTime=0.02, mediaPos=0.00, window=0, period=0]\r\nEventLogger: loading [eventTime=0.02, mediaPos=0.00, window=0, period=0, true]\r\nExoPlayer: mExoEventListener: onLoadingChanged-----isLoading true\r\nUsbService.NetworkService: usbFile.exists() =false\r\nEventLogger: internalError [eventTime=2.09, mediaPos=0.00, window=0, period=0, loadError\r\nEventLogger:   com.google.android.exoplayer2.source.UnrecognizedInputFormatException: None of the available extractors (MatroskaExtractor, FragmentedMp4Extractor, Mp4Extractor, Mp3Extractor, AdtsExtractor, Ac3Extractor, TsExtractor, FlvExtractor, OggExtractor, PsExtractor, WavExtractor, AmrExtractor, Ac4Extractor, FlacExtractor) could read the stream.\r\nEventLogger:       at com.google.android.exoplayer2.source.ProgressiveMediaPeriod$ExtractorHolder.selectExtractor(ProgressiveMediaPeriod.java:1090)\r\nEventLogger:       at com.google.android.exoplayer2.source.ProgressiveMediaPeriod$ExtractingLoadable.load(ProgressiveMediaPeriod.java:969)\r\nEventLogger:       at com.google.android.exoplayer2.upstream.Loader$LoadTask.run(Loader.java:391)\r\nEventLogger:       at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1133)\r\nEventLogger:       at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:607)\r\nEventLogger:       at java.lang.Thread.run(Thread.java:761)\r\nEventLogger: ]\r\nExoPlayerImplInternal: Source error\r\nExoPlayerImplInternal:   com.google.android.exoplayer2.source.UnrecognizedInputFormatException: None of the available extractors (MatroskaExtractor, FragmentedMp4Extractor, Mp4Extractor, Mp3Extractor, AdtsExtractor, Ac3Extractor, TsExtractor, FlvExtractor, OggExtractor, PsExtractor, WavExtractor, AmrExtractor, Ac4Extractor, FlacExtractor) could read the stream.\r\nExoPlayerImplInternal:       at com.google.android.exoplayer2.source.ProgressiveMediaPeriod$ExtractorHolder.selectExtractor(ProgressiveMediaPeriod.java:1090)\r\nExoPlayerImplInternal:       at com.google.android.exoplayer2.source.ProgressiveMediaPeriod$ExtractingLoadable.load(ProgressiveMediaPeriod.java:969)\r\nExoPlayerImplInternal:       at com.google.android.exoplayer2.upstream.Loader$LoadTask.run(Loader.java:391)\r\nExoPlayerImplInternal:       at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1133)\r\nExoPlayerImplInternal:       at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:607)\r\nExoPlayerImplInternal:       at java.lang.Thread.run(Thread.java:761)\r\nEventLogger: mediaPeriodReleased [eventTime=2.09, mediaPos=0.00, window=0, period=0]\r\nEventLogger: playerFailed [eventTime=2.09, mediaPos=0.00, window=0, period=0\r\nEventLogger:   com.google.android.exoplayer2.ExoPlaybackException: com.google.android.exoplayer2.source.UnrecognizedInputFormatException: None of the available extractors (MatroskaExtractor, FragmentedMp4Extractor, Mp4Extractor, Mp3Extractor, AdtsExtractor, Ac3Extractor, TsExtractor, FlvExtractor, OggExtractor, PsExtractor, WavExtractor, AmrExtractor, Ac4Extractor, FlacExtractor) could read the stream.\r\nEventLogger:       at com.google.android.exoplayer2.ExoPlayerImplInternal.handleMessage(ExoPlayerImplInternal.java:394)\r\nEventLogger:       at android.os.Handler.dispatchMessage(Handler.java:98)\r\nEventLogger:       at android.os.Looper.loop(Looper.java:154)\r\nEventLogger:       at android.os.HandlerThread.run(HandlerThread.java:61)\r\nEventLogger:   Caused by: com.google.android.exoplayer2.source.UnrecognizedInputFormatException: None of the available extractors (MatroskaExtractor, FragmentedMp4Extractor, Mp4Extractor, Mp3Extractor, AdtsExtractor, Ac3Extractor, TsExtractor, FlvExtractor, OggExtractor, PsExtractor, WavExtractor, AmrExtractor, Ac4Extractor, FlacExtractor) could read the stream.\r\nEventLogger:       at com.google.android.exoplayer2.source.ProgressiveMediaPeriod$ExtractorHolder.selectExtractor(ProgressiveMediaPeriod.java:1090)\r\nEventLogger:       at com.google.android.exoplayer2.source.ProgressiveMediaPeriod$ExtractingLoadable.load(ProgressiveMediaPeriod.java:969)\r\nEventLogger:       at com.google.android.exoplayer2.upstream.Loader$LoadTask.run(Loader.java:391)\r\nEventLogger:       at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1133)\r\nEventLogger:       at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:607)\r\nEventLogger:       at java.lang.Thread.run(Thread.java:761)\r\nEventLogger: ]\r\nExoPlayer: onPlayerError: error type : TYPE_SOURCE, com.google.android.exoplayer2.source.UnrecognizedInputFormatException: None of the available extractors (MatroskaExtractor, FragmentedMp4Extractor, Mp4Extractor, Mp3Extractor, AdtsExtractor, Ac3Extractor, TsExtractor, FlvExtractor, OggExtractor, PsExtractor, WavExtractor, AmrExtractor, Ac4Extractor, FlacExtractor) could read the stream.\r\nExoPlayer: onPlayerError: com.google.android.exoplayer2.source.UnrecognizedInputFormatException: None of the available extractors (MatroskaExtractor, FragmentedMp4Extractor, Mp4Extractor, Mp3Extractor, AdtsExtractor, Ac3Extractor, TsExtractor, FlvExtractor, OggExtractor, PsExtractor, WavExtractor, AmrExtractor, Ac4Extractor, FlacExtractor) could read the stream.\r\nBaseVideoView: [ciel_debug][onError]: what: -10001,extra: 0\r\n```\r\n\r\n### Link to test content\r\nSorry, the test link is private.\r\n",
    "comments_url": "https://api.github.com/repos/google/ExoPlayer/issues/7426/comments",
    "author": "VeiZhang",
    "comments": [
      {
        "user": "marcbaechinger",
        "created_at": "2020-05-26T13:29:26Z",
        "body": "If you want to play an HLS stream, then you need to use a `HlsMediaSource`. So you need to use `TYPE_HLS`. An HLS stream provides a playlist which is a text file this needs to be interpreted by the player to then download the adaptive media. The error you are seeing and posted above occurs because the `ProgressiveMediaSource` is used and it tries to interpret the text playlist as a media file. This fails with the error message above because the extractors expect a media container rather than a playlist.\r\n\r\nSo you need to do something like this:\r\n\r\n```\r\nHlsMediaSource hlsMediaSource = new HlsMediaSource.Factory(dataSourceFactory)\r\n    .createMediaSource(uri);\r\nplayer.setMediaSource(hlsMediaSource);\r\n```"
      },
      {
        "user": "VeiZhang",
        "created_at": "2020-05-26T13:41:41Z",
        "body": "@marcbaechinger Thanks for your reply. But the situation is different, I don't know which stream will be played, so I used `ProgressiveMediaSource`, then the `mp4?type=m3u8` come error. I mean how to recognize and use the true media soure."
      },
      {
        "user": "marcbaechinger",
        "created_at": "2020-05-26T14:13:04Z",
        "body": "If you are using an adaptive stream like HLS, DASH or SmoothStreaming you can not use `ProgressiveMediaSource`. Instead you need to use the adaptive media source according to the type of the stream. In you case of an HLS stream yoy would need to create a `HlsMediaSource` as shown below. \r\n\r\nIt's up to the app to choose the correct media source.\r\n(This is a duplicate of #7389)"
      },
      {
        "user": "VeiZhang",
        "created_at": "2020-05-27T00:45:34Z",
        "body": "@marcbaechinger Thanks a lot"
      }
    ]
  },
  {
    "number": 7366,
    "title": "Is it possible to change video duration after changing video speed?",
    "created_at": "2020-05-12T13:28:41Z",
    "closed_at": "2020-05-21T08:33:47Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/google/ExoPlayer/issues/7366",
    "body": "I have used `setPlaybackParameters` method to change speed of video. Player keep same duration when I increased or decreased speed. But if we apply process on video then if speed increased, video duration decreased and speed decreased, video duration increased. I want to show that in preview using exoplayer. \r\n\r\nPlease guide me.\r\n\r\nThanks",
    "comments_url": "https://api.github.com/repos/google/ExoPlayer/issues/7366/comments",
    "author": "ghost",
    "comments": [
      {
        "user": "krocard",
        "created_at": "2020-05-13T19:20:45Z",
        "body": "I'm not sure to understand the question. What type of video processing are you talking about?\r\n\r\nDo you want the video duration in the UI to decrease with the speed as if\r\n`UI_video_duration = real_video_duration / speed`)\r\n\r\nOr is the UI video duration you want to display related to your app _processing on video_, so not proportional to the speed?"
      },
      {
        "user": "ghost",
        "created_at": "2020-05-14T04:59:47Z",
        "body": "Hi @krocard Thank you for quick response.\r\nI have applied above formula. But video will complete on it's actual time.\r\nLet's say I have choose video of `144639` Millisecond. set speed 5. As per your formula `144639/5 = 28927.8`. So now video duration is `28927.8`. But when I play video in exoplayer with speed `5` it will complete in `144639` Millisecond not `28927.8`. \r\nSo how can I play complete video in updated duration?\r\nI hope for your response.\r\nThank you."
      },
      {
        "user": "krocard",
        "created_at": "2020-05-14T10:26:55Z",
        "body": "> But when I play video in exoplayer with speed 5 it will complete in 144639 Millisecond not 28927.8.\r\n\r\nIf you play a video with speed 5, the real elapse time to play the video will be 5\u00a0time less.\r\nAka if you start a stopwatch at the beginning of the video, and stop the timewatch when it is finished playing, the stopwatch will show around 28927.8. You will also see and hear the video playing 5 time faster.\r\n\r\nOn the other hand, the timestamps reported by ExoPlayer (for example `Player.getCurrentPosition()`), are independent of the speed and refer to the position in the video as if it was played at speed 1.\r\n\r\nIf what you want is the real time ExoPlayer has played the current video (like the stopwatch would give you in my previous thought experiment), I'm afraid ExoPlayer does not keep track of it.\r\nNevertheless, assuming you always play the video at the same speed, you can divide the position that ExoPlayer returns by the playback speed to get the \"stopwatch\" position.\r\n\r\nDoes this answers your question?"
      },
      {
        "user": "ghost",
        "created_at": "2020-05-20T07:22:44Z",
        "body": "Thanks for your help.\r\n\r\nI have implemented as per you told. I calculated updated video duration and video will complete within updated duration with speed changes.\r\n\r\nLet say `29568` Millisecond video, `0.6` speed set then updated video duration is `49280(29568 / 0.6).` So I sat that update duration and display in my screen.\r\n\r\nBut now I will seek manually and `seekTo` `24640` millisecond means `50%` of updated video duration. But player seek video almost till end because video actual duration is `29568`.\r\nIn That case what should I do to seek video to `50%`\r\n\r\nPlease guide me.\r\n\r\nThank you."
      },
      {
        "user": "krocard",
        "created_at": "2020-05-20T08:47:36Z",
        "body": "Does doing the inverse transformation when controlling the player fixes your issue. Aka\r\n`player.seekTo(TimestampFromTheUI*videoSpeed)`.\r\n\r\nIn your example that would be: `player.seekTo(24640*0.6)`. As `24640*0.6 = 14784` which is 50% of the actual video duration (`29568/2`).\r\n"
      },
      {
        "user": "ghost",
        "created_at": "2020-05-21T04:24:15Z",
        "body": "Yes, It is working.\r\nThank you so much for help and support."
      },
      {
        "user": "krocard",
        "created_at": "2020-05-21T08:33:47Z",
        "body": "You're welcome!\r\nI'm closing this issue as your questions are answered."
      }
    ]
  },
  {
    "number": 7276,
    "title": "PlayerNotificationManager event onNotificationCanceled is never called",
    "created_at": "2020-04-21T18:08:56Z",
    "closed_at": "2020-04-22T12:50:16Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/google/ExoPlayer/issues/7276",
    "body": "### [REQUIRED] Issue description\r\nHi everyone, \r\n\r\nNotification cannot be swiped and onNotificationCanceled is never called.\r\n\r\n### [REQUIRED] Reproduction steps\r\n```\r\n`\r\n@Override\r\npublic void onCreate() {\r\nsuper.onCreate();\r\n\r\nfinal Context context = this;\r\n\r\nplayer = ExoPlayerFactory.newSimpleInstance(context, new DefaultTrackSelector());\r\n\r\n// playlist preparation\r\n\r\n// player.prepare(concatenatedSource, false, false);\r\nplayer.prepare(playlist);\r\nplayer.setPlayWhenReady(true);\r\n\r\nPlayerNotificationManager.MediaDescriptionAdapter notificationAdapter = new PlayerNotificationManager.MediaDescriptionAdapter() {\r\n    // implementation\r\n};\r\n\r\nPlayerNotificationManager.NotificationListener notificationListener = new PlayerNotificationManager.NotificationListener() {\r\n\r\n    @Override\r\n    public void onNotificationCancelled(int notificationId, boolean dismissedByUser) {\r\n        System.out.println(\"onNotificationCancelled dismissedByUser \"+dismissedByUser);\r\n        stopForeground(true);\r\n    }\r\n\r\n    @Override\r\n    public void onNotificationPosted(int notificationId, Notification notification, boolean ongoing) {\r\n        startForeground(notificationId, notification);\r\n    }\r\n};\r\n\r\nIntent dialogIntent = new Intent(this, PlayerActivity.class);\r\ndialogIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\r\n\r\nstartActivity(dialogIntent);\r\nplayerNotificationManager = PlayerNotificationManager.createWithNotificationChannel(\r\n        context, \"channelId\", R.string.player_activity_name, R.string.player_activity_description, 1, notificationAdapter, notificationListener );\r\nplayerNotificationManager.setPlayer(player);\r\n```\r\n`\r\n\r\n### [REQUIRED] Version of ExoPlayer being used\r\ncom.google.android.exoplayer:exoplayer-core:2.10.5\r\n\r\n### [REQUIRED] Device(s) and version(s) of Android being used\r\n    compileSdkVersion 29\r\n    defaultConfig {\r\n        minSdkVersion 16\r\n        targetSdkVersion 29\r\n\r\nMany thanks !!",
    "comments_url": "https://api.github.com/repos/google/ExoPlayer/issues/7276/comments",
    "author": "ghost",
    "comments": [
      {
        "user": "marcbaechinger",
        "created_at": "2020-04-22T12:25:04Z",
        "body": "The notification can only be swiped when not assigned to a foreground service. So it requires you to stop the foreground service, when the notification is not ongoing anymore (that is when the player is paused).\r\n\r\nYou are pretty close to that already with the code you show above.  You need to change `onNotificationPosted()` and check wether the notification is still ongoing. If paused `isOngoing` is false and you should stop the foreground service. Now the notification can be swiped, because it's not tied to a foreground service anymore.\r\n\r\nWhen you receive the cancellation event after swipe, you can totally destroy your service. The user needs to restart in the app UI without notification. That's when you can start the cycle again and start your foreground service again.\r\n\r\nThat could probably look like this:\r\n\r\n```\r\n@Override\r\npublic void onNotificationPosted(\r\n    int notificationId, Notification notification, boolean ongoing) {\r\n  if (ongoing) {\r\n    startForeground(notificationId, notification);\r\n   } else {\r\n     stopForeground(/* removeNotification= */ false);\r\n   }\r\n}\r\n\r\n@Override\r\npublic void onNotificationCancelled(int notificationId, boolean dismissedByUser) {\r\n   stopSelf();\r\n}\r\n``` \r\n\r\nPlease let me know if this help."
      },
      {
        "user": "ghost",
        "created_at": "2020-04-22T12:50:16Z",
        "body": "I understand perfectly I think, it works as expected. Thank you so much!"
      }
    ]
  },
  {
    "number": 7175,
    "title": "IndexOutOfBoundsException - while checking if media isLive",
    "created_at": "2020-04-02T15:16:45Z",
    "closed_at": "2020-04-03T12:52:44Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/google/ExoPlayer/issues/7175",
    "body": "Hi,\r\n\r\nWhile checking the isLive new API  \r\nin the Demo app in v2.11.3 version I get this exception after executing the below code.\r\nrunning this on Pixel 3 android 10\r\n\r\nNo sure what is the best approach here but I was expecting to get false\r\nunless it should be called only after player is READY\r\n\r\nis there a way to add api that checks is there is a window  before calling get, so this  case can be checked before accessing the window?\r\n\r\ndo you think I should stick to our current logic that uses -  `player.isCurrentWindowDynamic()`\r\n```\r\n     player.prepare(mediaSource, !haveStartPosition, false);\r\n    boolean isLive = false;\r\n    \r\n    if (player.getCurrentTimeline() != null) {\r\n      isLive = player.getCurrentTimeline().getWindow(player.getCurrentWindowIndex(), new Timeline.Window()).isLive;\r\n    }\r\n```\r\n\r\n\r\n10x\r\nGilad.\r\n\r\n2020-04-02 18:02:19.419 13123-13123/com.google.android.exoplayer2.demo E/AndroidRuntime: FATAL EXCEPTION: main\r\n    Process: com.google.android.exoplayer2.demo, PID: 13123\r\n    java.lang.IndexOutOfBoundsException\r\n        at com.google.android.exoplayer2.Timeline$1.getWindow(Timeline.java:550)\r\n        at com.google.android.exoplayer2.Timeline.getWindow(Timeline.java:668)\r\n        at com.google.android.exoplayer2.demo.PlayerActivity.initializePlayer(PlayerActivity.java:412)\r\n        at com.google.android.exoplayer2.demo.PlayerActivity.onStart(PlayerActivity.java:240)\r\n        at android.app.Instrumentation.callActivityOnStart(Instrumentation.java:1432)\r\n        at android.app.Activity.performStart(Activity.java:7848)\r\n        at android.app.ActivityThread.handleStartActivity(ActivityThread.java:3294)\r\n        at android.app.servertransaction.TransactionExecutor.performLifecycleSequence(TransactionExecutor.java:221)\r\n        at android.app.servertransaction.TransactionExecutor.cycleToPath(TransactionExecutor.java:201)\r\n        at android.app.servertransaction.TransactionExecutor.executeLifecycleState(TransactionExecutor.java:173)\r\n        at android.app.servertransaction.TransactionExecutor.execute(TransactionExecutor.java:97)\r\n        at android.app.ActivityThread$H.handleMessage(ActivityThread.java:2016)\r\n        at android.os.Handler.dispatchMessage(Handler.java:107)\r\n        at android.os.Looper.loop(Looper.java:214)\r\n        at android.app.ActivityThread.main(ActivityThread.java:7356)\r\n        at java.lang.reflect.Method.invoke(Native Method)\r\n        at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:492)\r\n        at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:930)\r\n\r\n\r\n",
    "comments_url": "https://api.github.com/repos/google/ExoPlayer/issues/7175/comments",
    "author": "giladna",
    "comments": [
      {
        "user": "andrewlewis",
        "created_at": "2020-04-03T12:52:44Z",
        "body": "You can check `timeline.getWindowCount()` or `timeline.isEmpty()`."
      },
      {
        "user": "tonihei",
        "created_at": "2020-04-03T12:57:40Z",
        "body": "Actually, the preferred way to check if media is live is to use `player.isCurrentWindowLive()`.  This already includes the check Andrew mentioned above."
      },
      {
        "user": "giladna",
        "created_at": "2020-04-05T10:13:19Z",
        "body": "thanks!"
      }
    ]
  },
  {
    "number": 7091,
    "title": "TrackSelectionView.getDialog is deprecated . what should i use instead ?",
    "created_at": "2020-03-15T23:01:01Z",
    "closed_at": "2020-03-16T09:39:56Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/google/ExoPlayer/issues/7091",
    "body": "Hi guys \r\nI am completely newbie with exoplayer . I want to show the list of quality of hls to user and let the user to choose one of them . I found below code but one part is deprecated in version 2.10. Could someone help me on this case please ? I also tried to find solution on demo app . but there is a lot of code and it make me confused .\r\n```\r\nMappingTrackSelector.MappedTrackInfo mappedTrackInfo = trackSelector.getCurrentMappedTrackInfo();\r\n        if (mappedTrackInfo != null) {\r\n            CharSequence title = \"Video\";\r\n            int rendererIndex = 2;\r\n            int rendererType = mappedTrackInfo.getRendererType(rendererIndex);\r\n            boolean allowAdaptiveSelections =\r\n                    rendererType == C.TRACK_TYPE_VIDEO\r\n                            || (rendererType == C.TRACK_TYPE_AUDIO\r\n                            && mappedTrackInfo.getTypeSupport(C.TRACK_TYPE_VIDEO)\r\n                            == MappingTrackSelector.MappedTrackInfo.RENDERER_SUPPORT_NO_TRACKS);\r\n            Pair<AlertDialog, TrackSelectionView> dialogPair =\r\n                    TrackSelectionView.getDialog(this, title, trackSelector, rendererIndex);\r\n            dialogPair.second.setShowDisableOption(true);\r\n            dialogPair.second.setAllowAdaptiveSelections(allowAdaptiveSelections);\r\n            dialogPair.first.show();\r\n        }\r\n    }\r\n```\r\n\r\nTrackSelectionView.getDialog  is deprecated .Thanks in advance.",
    "comments_url": "https://api.github.com/repos/google/ExoPlayer/issues/7091/comments",
    "author": "newtestpage",
    "comments": [
      {
        "user": "ojw28",
        "created_at": "2020-03-16T09:39:56Z",
        "body": "Use `TrackSelectionDialogBuilder`."
      },
      {
        "user": "newtestpage",
        "created_at": "2020-03-16T14:42:14Z",
        "body": "> Use `TrackSelectionDialogBuilder`.\r\n\r\nThanks for your response . I changed the code as follow and it shows the dialog but it just contain auto and unknown. however hls has 5 different quality (second code) . \r\n\r\ncode 1 :\r\n`private void showMenuQuality() {\r\n        MappingTrackSelector.MappedTrackInfo mappedTrackInfo = trackSelector.getCurrentMappedTrackInfo();\r\n        if (mappedTrackInfo != null) {\r\n            CharSequence title = \"Video\";\r\n            int rendererIndex = 2;\r\n            int rendererType = mappedTrackInfo.getRendererType(rendererIndex);\r\n            boolean allowAdaptiveSelections =\r\n                    rendererType == C.TRACK_TYPE_VIDEO\r\n                            || (rendererType == C.TRACK_TYPE_AUDIO\r\n                            && mappedTrackInfo.getTypeSupport(C.TRACK_TYPE_VIDEO)\r\n                            == MappingTrackSelector.MappedTrackInfo.RENDERER_SUPPORT_NO_TRACKS);\r\n\r\n\r\n            TrackSelectionDialogBuilder build = new TrackSelectionDialogBuilder(PlayerActivity.this, title, trackSelector, rendererIndex);\r\n\r\n            build.setAllowAdaptiveSelections(allowAdaptiveSelections);\r\n            build.build().show();\r\n\r\n\r\n        }\r\n\r\n    }`\r\n\r\n\r\ncode 2 (stream file ) \r\n`#EXTM3U\r\n#EXT-X-VERSION:3\r\n#EXT-X-INDEPENDENT-SEGMENTS\r\n#EXT-X-STREAM-INF:BANDWIDTH=3951200,AVERAGE-BANDWIDTH=2961200,CODECS=\"avc1.4d4028,mp4a.40.2\",RESOLUTION=1920x1080,FRAME-RATE=25.000\r\nlive_2500.m3u8\r\n#EXT-X-STREAM-INF:BANDWIDTH=2631200,AVERAGE-BANDWIDTH=1861200,CODECS=\"avc1.4d4028,mp4a.40.2\",RESOLUTION=1920x1080,FRAME-RATE=25.000\r\nlive_1500.m3u8\r\n#EXT-X-STREAM-INF:BANDWIDTH=1971200,AVERAGE-BANDWIDTH=1311200,CODECS=\"avc1.4d4028,mp4a.40.2\",RESOLUTION=1920x1080,FRAME-RATE=25.000\r\nlive_1000.m3u8\r\n#EXT-X-STREAM-INF:BANDWIDTH=1201200,AVERAGE-BANDWIDTH=1036200,CODECS=\"avc1.4d401f,mp4a.40.2\",RESOLUTION=1280x720,FRAME-RATE=25.000\r\nlive_750.m3u8\r\n#EXT-X-STREAM-INF:BANDWIDTH=871200,AVERAGE-BANDWIDTH=761200,CODECS=\"avc1.4d401f,mp4a.40.2\",RESOLUTION=1280x720,FRAME-RATE=25.000\r\nlive_500.m3u8`"
      },
      {
        "user": "newtestpage",
        "created_at": "2020-03-16T15:06:09Z",
        "body": "I changed the renderindex to 0 and get answer . Thanks"
      }
    ]
  },
  {
    "number": 6979,
    "title": "different mimeType between FlacExtractor and LibflacAudioRenderer",
    "created_at": "2020-02-15T04:13:10Z",
    "closed_at": "2020-02-17T14:28:56Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/google/ExoPlayer/issues/6979",
    "body": "Hello, I don't figure out that the mimeType is \"audio/raw\" in FlacExtractor of FLAC extension. However, the specific mimeType is \"audio/flac\" in LibflacAudioRenderer. As s result, LibflacAudioRenderer couldn't work for FlacExtractor.",
    "comments_url": "https://api.github.com/repos/google/ExoPlayer/issues/6979/comments",
    "author": "xufuji456",
    "comments": [
      {
        "user": "kim-vde",
        "created_at": "2020-02-17T10:29:21Z",
        "body": "The `FlacExtractor` from the FLAC extension is not intended to be used with the `LibflacAudioRenderer` because the frames are decoded directly in the extractor and PCM data is therefore outputted. You have 2 possibilities:\r\n- use the `FlacExtractor` from the FLAC extension and render with `MediaCodecAudioRenderer`, or\r\n- use the (newly-released) `FlacExtractor` from the core library and render with any renderer able to decode FLAC frames (`MediaCodecAudioRenderer` from API 27+, `LibflacAudioRenderer`, `FfmpegAudioRenderer`)."
      },
      {
        "user": "xufuji456",
        "created_at": "2020-02-17T14:28:41Z",
        "body": "@kim-vde Thank you very much. I got it."
      }
    ]
  },
  {
    "number": 6959,
    "title": "Calculating total playback time of a media.",
    "created_at": "2020-02-10T11:25:57Z",
    "closed_at": "2020-02-11T11:05:47Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/google/ExoPlayer/issues/6959",
    "body": "**Scenario**: \r\nI want to calculate the total playback time for a media until the user switches to a different media by going to the next or previous media. \r\n\r\n**Problem**:\r\nI have covered all the possible scenarios except one, when the user switches to the next track/media after playing the media for a while, I'm not able to get the **playbackEndTime**. \r\nWhere **playbackEndTime** is the last known position from where the media was discontinued.\r\n\r\nIn this case the `EventTime.currentPlaybackPositionMs` is always 0 in every Callbacks of the AnalyticsListener. \r\n\r\nPlease correct me if my approach is not appropriate. ",
    "comments_url": "https://api.github.com/repos/google/ExoPlayer/issues/6959/comments",
    "author": "VivekBhalodiya",
    "comments": [
      {
        "user": "kim-vde",
        "created_at": "2020-02-10T15:15:05Z",
        "body": "What implementation of `AnalyticsListener` are you using? Please provide the code if it is a custom one."
      },
      {
        "user": "VivekBhalodiya",
        "created_at": "2020-02-11T08:48:50Z",
        "body": "```\r\nclass ExoPlayerAnalyticsListener : AnalyticsListener, EventListener {\r\n  private var isSeekStarted: Boolean = false\r\n  private var hasTracksChanged: Boolean = false\r\n  private var playbackStartTime: Long = 0L\r\n  private var playbackEndTime: Long = 0L\r\n  private var isPlayingTime: Long = 0L\r\n  private var totalPlayBack: Long = 0L\r\n  private var currentMediaId: String? = null\r\n  private var window = Window()\r\n\r\n  override fun onPositionDiscontinuity(\r\n    eventTime: EventTime,\r\n    reason: Int\r\n  ) {\r\n    playbackStartTime = eventTime.currentPlaybackPositionMs\r\n  }\r\n\r\n  override fun onTracksChanged(\r\n    eventTime: EventTime,\r\n    trackGroups: TrackGroupArray,\r\n    trackSelections: TrackSelectionArray\r\n  ) {\r\n    hasTracksChanged = true\r\n    // I want the currentPlaybackPositionMs here \r\n  }\r\n\r\n  override fun onSeekStarted(eventTime: EventTime) {\r\n    isSeekStarted = true\r\n    playbackEndTime = eventTime.currentPlaybackPositionMs\r\n    calculatePlayback()\r\n    isSeekStarted = false\r\n  }\r\n\r\n  override fun onPlayerStateChanged(\r\n    eventTime: EventTime,\r\n    playWhenReady: Boolean,\r\n    playbackState: Int\r\n  ) {\r\n     // eventTime.currentPlaybackPositionMs is 0 when track is changed\r\n  }\r\n\r\n  override fun onIsPlayingChanged(\r\n    eventTime: EventTime,\r\n    isPlaying: Boolean\r\n  ) {\r\n    isPlayingTime = eventTime.currentPlaybackPositionMs\r\n    when {\r\n      isPlaying -> playbackStartTime = isPlayingTime\r\n      else -> playbackEndTime = isPlayingTime\r\n    }\r\n    if (isSeekStarted.not())\r\n      calculatePlayback()\r\n  }\r\n\r\n  private fun calculatePlayback() {\r\n    if (hasTracksChanged) {\r\n      hasTracksChanged = false\r\n      resetTrackers()\r\n      return\r\n    }\r\n\r\n    if (playbackStartTime == 0L) {\r\n      //Media is being played from start\r\n      totalPlayBack += playbackEndTime\r\n    } else if (playbackEndTime > playbackStartTime) {\r\n      totalPlayBack += abs(playbackEndTime - playbackStartTime)\r\n    }\r\n  }\r\n\r\n  private fun resetTrackers() { //.. }\r\n}\r\n```"
      },
      {
        "user": "tonihei",
        "created_at": "2020-02-11T09:47:17Z",
        "body": "In case you are using ExoPlayer 2.11, you can use add `PlaybackStatsListener` to retrieve `PlaybackStats` for each playlist item that has a method called `getTotalPlayTimeMs()`. Sounds as if you are trying to calculate this value. "
      },
      {
        "user": "VivekBhalodiya",
        "created_at": "2020-02-11T11:05:47Z",
        "body": "God bless `PlaybackStatsListener`\r\n`getTotalPlayTimeMs()` This is what exactly I've been looking for.\r\nThank you @tonihei  and @kim-vde  for your support. Really appreciate your time. "
      }
    ]
  },
  {
    "number": 6847,
    "title": "Blank screen while switching video from portrait to landscape full screen for DRM enabled videos in DASH format",
    "created_at": "2020-01-08T07:37:27Z",
    "closed_at": "2020-01-09T10:22:32Z",
    "labels": [
      "question",
      "documentation candidate"
    ],
    "url": "https://github.com/google/ExoPlayer/issues/6847",
    "body": "Issue description:\r\nWhile switching a video from portrait to landscape mode a blank black screen is visible for a sec before showing the video frame.This happens while switching from landscape to portrait also.This is occuring only for the videos which are DRM protected.This is seen only in few devices.It appears in the exoplayer demo app as well.\r\n\r\nReproduction steps:\r\n1.In the exoplayer demo app play the video with DASH+DRM\r\n2.Enable auto rotate option in settings.\r\n3.Rotate the phone to landscape.\r\n4.A blank screen is shown for a sec before the video frame shows up.\r\n5.Switch to portrait again and see the same blank screen\r\n\r\nLink to test content\r\nYou can check any drm enabled video from the demo app for dash stream.\r\n\r\nVersion of ExoPlayer being used\r\n2.9.0\r\n\r\nDevice(s) and version(s) of Android being used\r\n1.Mi Note 7 Pro Android version:9.0--Issue arises\r\n2.Asus Zenfone Max Pro M2. Android version:8.0--Issue arises\r\n3.Real Me 2 Pro. Android version 9.0--No issue\r\n4.Lenovo K5 note. Android Version 6.0--Issue Arises\r\n5.Samsung Galaxy J2 Pro. Andorid version 6.0--No Issue\r\n6.Mi A2. Android Version 9.0--No issue\r\n7.Redmi Note 3. Android Version 6.0--No issue \r\n\r\nCould you please check into this issue.\r\n\r\n\r\n",
    "comments_url": "https://api.github.com/repos/google/ExoPlayer/issues/6847/comments",
    "author": "meenukrishnamurthy",
    "comments": [
      {
        "user": "ojw28",
        "created_at": "2020-01-08T07:45:10Z",
        "body": "This is a limitation in the underlying platform. The fact that the output path is secure means that the video buffers aren't available to be composited into the rotation animation when the display orientation changes, so for the duration of the animation the surface appears as though it is black. You will observe the issue in all applications that play DRM protected content."
      },
      {
        "user": "meenukrishnamurthy",
        "created_at": "2020-01-08T07:49:02Z",
        "body": "Can you be more specific as to which underlying platform the issue arises.Because i dont see this issue in all the devices."
      },
      {
        "user": "ojw28",
        "created_at": "2020-01-08T08:01:47Z",
        "body": "As above:\r\n\r\n> The fact that the output path is secure means that the video buffers aren't available to be composited into the rotation animation when the display orientation changes, so for the duration of the animation the surface appears as though it is black.\r\n\r\nI'm not sure why you don't see the issue on all devices, but my best guess would be that your content doesn't require a secure output path in the license policy, and that the devices where you don't see the issue only support L3 Widevine. If that's the case then you could try forcing L3 Widevine on all devices, to see if that resolves the problem.\r\n\r\nAlternatively, is it possible the devices where you don't see the issue simply don't animate orientation changes?"
      },
      {
        "user": "meenukrishnamurthy",
        "created_at": "2020-01-09T07:07:45Z",
        "body": "Thanks a lot @ojw28 . Forcing to L3 on all devices worked for me."
      }
    ]
  },
  {
    "number": 6759,
    "title": "How to get BufferInfo in ExoPlayer 2?",
    "created_at": "2019-12-12T14:27:12Z",
    "closed_at": "2019-12-12T19:01:21Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/google/ExoPlayer/issues/6759",
    "body": "Hi,\r\n**BufferInfo** was available in ExoPlayer 1 in the **processOutputBuffer** method, But in curently veresion bufferInfo not exist in **processOutputBuffer**\r\nIn version 1 I had access to **BufferInfo** by extending **MediaCodecAudioRenderer** Class and implementing **processOutputBuffer**\r\nAs you can see below\r\n\r\nVersion 1:\r\n```\r\n@Override\r\nprotected boolean processOutputBuffer(long positionUs,\r\n                                      long elapsedRealtimeUs,\r\n                                      MediaCodec codec,\r\n                                      ByteBuffer buffer,\r\n                                      MediaCodec.BufferInfo bufferInfo, //TODO: BufferInfo\r\n                                      int bufferIndex,\r\n                                      boolean shouldSkip)\r\n        throws com.google.android.exoplayer.ExoPlaybackException {\r\n\r\n    //using bufferInfo\r\n\r\n    return super.processOutputBuffer(positionUs,\r\n            elapsedRealtimeUs,\r\n            codec,\r\n            buffer,\r\n            bufferInfo,\r\n            bufferIndex,\r\n            shouldSkip);\r\n}\r\n```\r\nLast Version:\r\n```\r\n    protected boolean processOutputBuffer(long positionUs,\r\n                                          long elapsedRealtimeUs,\r\n                                          MediaCodec codec,\r\n                                          ByteBuffer buffer,\r\n                                          int bufferIndex,\r\n                                          int bufferFlags,\r\n                                          long bufferPresentationTimeUs,\r\n                                          boolean isDecodeOnlyBuffer,\r\n                                          boolean isLastBuffer,\r\n                                          Format format) throws ExoPlaybackException {\r\n\r\n        return super.processOutputBuffer(positionUs,\r\n                elapsedRealtimeUs,\r\n                codec,\r\n                buffer,\r\n                bufferIndex,\r\n                bufferFlags,\r\n                bufferPresentationTimeUs,\r\n                isDecodeOnlyBuffer,\r\n                isLastBuffer,\r\n                format);\r\n    }\r\n```\r\nAs you can see there is no **BufferInfo** inside **processOutputBuffer** method in the last version\r\nI need to get BufferInfo for read '**size**' and '**offset**' and '**presentationTimeUs**', How to do this in the latest version?",
    "comments_url": "https://api.github.com/repos/google/ExoPlayer/issues/6759/comments",
    "author": "saleh-gholamian",
    "comments": [
      {
        "user": "ojw28",
        "created_at": "2019-12-12T19:01:21Z",
        "body": "All the information is still there. It's just in slightly different places:\r\n* `bufferFlags` in V2 is the same as `bufferInfo.flags` in V1\r\n* `bufferPresentationTimeUs` in V2 is the same as `bufferInfo.presentationTimeUs` in V1\r\n* `buffer.position()` in V2 is the same as `bufferInfo.offset` in V1\r\n* `buffer.limit() - buffer.position()` in V2 is the same as `bufferInfo.size` in V1"
      },
      {
        "user": "saleh-gholamian",
        "created_at": "2019-12-13T08:54:39Z",
        "body": "> All the information is still there. It's just in slightly different places:\r\n\r\n    bufferFlags in V2 is the same as bufferInfo.flags in V1\r\n    bufferPresentationTimeUs in V2 is the same as bufferInfo.presentationTimeUs in V1\r\n    buffer.position() in V2 is the same as bufferInfo.offset in V1\r\n    buffer.limit() - buffer.position() in V2 is the same as bufferInfo.size in V1\r\n\r\nVery Thanks"
      }
    ]
  },
  {
    "number": 6710,
    "title": "Exoplayer releases itself when in background",
    "created_at": "2019-11-29T09:55:01Z",
    "closed_at": "2019-11-30T15:26:17Z",
    "labels": [
      "question",
      "need more info"
    ],
    "url": "https://github.com/google/ExoPlayer/issues/6710",
    "body": "#6386 # [REQUIRED] Searched documentation and issues\r\n\r\nTried searching on Google but didn't find anything relevant.\r\n\r\n### [REQUIRED] Question\r\nI have an app that can play videos. I use a single instance of exoplayer that i initialize in a service so that the user can listen and control the video in background. The problem is that when a video is playing, the user goes into background and then pauses the player for 1-2 minutes exoplayer releases itself. So when the app comes back to the foreground all i have is a black screen playerView with no video in it.\r\n\r\n### A full bug report captured from the device\r\n```\r\n2019-11-29 10:26:51.715 23697-26444/app  D/FA: Application backgrounded\r\n2019-11-29 10:26:51.738 23697-26444/app  D/FA: Logging event (FE): app_background(_ab), Bundle[{ga_event_origin(_o)=auto}]\r\n2019-11-29 10:28:13.053 23697-23697/app  I/ExoPlayerImpl: Release 192e8c2 [ExoPlayerLib/2.10.4] [HWSTK-HF, STK-LX1, HUAWEI, 28] [goog.exo.core, goog.exo.ui, goog.exo.hls]\r\n2019-11-29 10:28:13.080 23697-26655/app  D/android.media.AudioTrack: [HSM] AudioTrace stop() uid: 10308, pid: 23697\r\n2019-11-29 10:28:13.084 23697-25116/app W/ACodec: forcing OMX state to Idle when received shutdown in ExecutingState\r\n2019-11-29 10:28:13.136 23697-25115/app  D/SurfaceUtils: disconnecting from surface 0x723f653010, reason disconnectFromSurface\r\n2019-11-29 10:28:13.167 23697-25127/app  W/ACodec: forcing OMX state to Idle when received shutdown in ExecutingState\r\n```\r\n\r\nAs you can see i backgrounded the video and then pause it. After 1.5 minutes without touching the phone  exoplayer released itself. \r\nI can see how this could be done on purpose to free some resources but is there any way to override this?\r\n\r\nThis is what happens when i bring the app to the foreground:\r\n```\r\n2019-11-29 10:58:47.192 23697-23697/app D/ZrHung.AppEyeUiProbe: notify runnable to start.\r\n2019-11-29 10:58:47.192 23697-23750/app D/ZrHung.AppEyeUiProbe: restart watching\r\n2019-11-29 10:58:47.220 23697-27978/app D/FA: Setting user property (FE): _sid, 1575021527\r\n2019-11-29 10:58:47.278 23697-23768/app D/mali_winsys: EGLint new_window_surface(egl_winsys_display *, void *, EGLSurface, EGLConfig, egl_winsys_surface **, EGLBoolean) returns 0x3000\r\n2019-11-29 10:58:47.289 23697-23697/app I/ExoPlayerImpl: Init aaeb70c [ExoPlayerLib/2.10.4] [HWSTK-HF, STK-LX1, HUAWEI, 28]\r\n2019-11-29 10:58:47.296 23697-27978/app D/FA: Logging event (FE): session_start(_s), Bundle[{ga_event_origin(_o)=auto, ga_session_id(_sid)=1575021527}]\r\n2019-11-29 10:58:47.330 23697-27978/app D/FA: Logging event (FE): app_start, Bundle[{method=app_start, ga_event_origin(_o)=app, ga_screen_class(_sc)=MainActivity, ga_screen_id(_si)=5911828178843061323}]\r\n2019-11-29 10:58:47.454 23697-23697/app I/ViewRootImpl: jank_removeInvalidNode all the node in jank list is out of time\r\n2019-11-29 10:58:47.465 23697-23697/app W/InputMethodManager: startInputReason = 1\r\n2019-11-29 10:58:47.500 23697-27978/app D/FA: Connected to remote service\r\n```\r\n\r\nI'm pretty new at this so i don't really understand what all this means or if it's useful at all.\r\nThanks in advance for your time!\r\n",
    "comments_url": "https://api.github.com/repos/google/ExoPlayer/issues/6710/comments",
    "author": "Cosminnv",
    "comments": [
      {
        "user": "marcbaechinger",
        "created_at": "2019-11-30T15:10:16Z",
        "body": "I don't think ExoPlayer does release itself automatically after a given time. But probably the service does release the player when it is destroyed, which would be the correct behaviour of the service.\r\n\r\nWith the available information that sounds like you may call stopForeground(boolean) when the user pauses the player. With this the service is not running in the foreground anymore and the system may remove/destroy the service after a given amount of time (the 2 minutes you are reporting seems reasonable). \r\n\r\nIf this is the case then the service is behaving correctly and according to what the recommendation is for having the player in a foreground service. If you want to override this, then you should not call stopForeground(boolean) for your service.\r\n\r\nMy recommendation would be to remove the service from the foreground as you do, but then. When the app comes to foreground again you have to restart the service and then resume playback from where it was paused.\r\n\r\nAside: is there a specific reason why you have the player in a service for playing a video? Usually this is required for audio, when playback should continue when the player is in background. In case of video you could have the player living in the activity instead."
      },
      {
        "user": "Cosminnv",
        "created_at": "2019-11-30T15:26:17Z",
        "body": "Hi, thanks for the reply.\r\n\r\nYou're right, i do call stopForeground when the player is paused ,but i only do that because i want the user to be able to swipe the notification away without killing the video ( kinda like spotify does). I'll try to do it like you recommended.\r\n\r\nAlso, i kinda need the player to be in a service because i have video of a guy talking. So you can watch him while he is speaking but you can also only listen to him.\r\n\r\nI think i got everything i needed, thank you very much!"
      }
    ]
  },
  {
    "number": 6707,
    "title": "Library source does not match the bytecode for class ImaAdsLoader",
    "created_at": "2019-11-28T03:24:52Z",
    "closed_at": "2019-11-29T16:45:30Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/google/ExoPlayer/issues/6707",
    "body": "While displaying ads with IMA extension and the ProgressiveMediaSource, I am getting the following error. The app crashed just after the preroll ad completes.\r\nOn navigating to the class ImaAdsLoader I get the error \"Library source does not match the bytecode for class ImaAdsLoader\"\r\n`\r\njava.lang.NoSuchMethodError: No virtual method getAdGroupIndexAfterPositionUs(J)I in class Lcom/google/android/exoplayer2/source/ads/AdPlaybackState; or its super classes (declaration of 'com.google.android.exoplayer2.source.ads.AdPlaybackState' appears in /data/app/com.example.exomedia-pEwo-P6MjYGRL3PeKbTLiw==/base.apk)\r\n        at com.google.android.exoplayer2.ext.ima.ImaAdsLoader.getContentProgress(ImaAdsLoader.java:758)\r\n        at com.google.ads.interactivemedia.v3.internal.iu.a(IMASDK:4)\r\n        at com.google.ads.interactivemedia.v3.internal.jh.handleMessage(IMASDK:27)\r\n        at android.os.Handler.dispatchMessage(Handler.java:102)\r\n        at android.os.Looper.loop(Looper.java:193)\r\n        at android.app.ActivityThread.main(ActivityThread.java:6692)\r\n        at java.lang.reflect.Method.invoke(Native Method)\r\n        at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:493)\r\n        at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:858)\r\n`\r\nSteps to reproduce : \r\n    Use the following dependencies \r\n\r\n`    implementation 'com.google.android.exoplayer:exoplayer-core:2.10.7'\r\n    implementation 'com.google.android.exoplayer:exoplayer-ui:2.10.7'\r\n    implementation 'com.google.android.exoplayer:extension-ima:2.9.6'\r\n`\r\n\r\nAnd initiate the playback with the following code:\r\n\r\n`     player=ExoPlayerFactory.newSimpleInstance(this,DefaultTrackSelector())\r\n        player_view.player=player\r\n        adsLoader?.setPlayer(player)\r\n\r\n\r\n        val dataSourceFactory = DefaultDataSourceFactory(\r\n            this,\r\n            \"ExoDemo\")\r\n\r\n        val mediaSource:MediaSource=ProgressiveMediaSource.Factory(dataSourceFactory)\r\n            .createMediaSource(Uri.parse(resources.getString(R.string.media_url_mp4)))\r\n\r\n        val adsMediaSource = AdsMediaSource(mediaSource, dataSourceFactory, adsLoader, player_view)\r\n\r\n\r\n        player?.prepare(adsMediaSource)\r\n        player?.setPlayWhenReady(true)`\r\n\r\n\r\nThe works without any error with the following versions of the libraries and using ExtractorMediaSource:\r\n\r\n`    implementation 'com.google.android.exoplayer:exoplayer-core:2.9.6'\r\n    implementation 'com.google.android.exoplayer:exoplayer-ui:2.9.6'\r\n    implementation 'com.google.android.exoplayer:extension-ima:2.9.6'\r\n`\r\n",
    "comments_url": "https://api.github.com/repos/google/ExoPlayer/issues/6707/comments",
    "author": "droidmonktutorials",
    "comments": [
      {
        "user": "andrewlewis",
        "created_at": "2019-11-28T08:41:50Z",
        "body": "Does the error go away if you use the same version number for all the modules?"
      },
      {
        "user": "droidmonktutorials",
        "created_at": "2019-11-28T15:44:58Z",
        "body": "Yes it works, and I have realized that if I want to use _exoplayer-core:2.10.7_ then I can clone the ExoPlayer repository and depend on the module locally. \r\nBut it would have been great if we could use the latest version of exoplayer_core with extension_ima without cloning the repository. Is that not possible?"
      },
      {
        "user": "andrewlewis",
        "created_at": "2019-11-29T08:00:53Z",
        "body": "It shouldn't be necessary to clone the sources. It looks like the maven repository has both exoplayer-core:2.10.7 and extension-ima:2.10.7. Could you give some more details on what goes wrong if you try to depend on those?"
      },
      {
        "user": "droidmonktutorials",
        "created_at": "2019-11-29T15:59:38Z",
        "body": "My bad, it works. I am extremely sorry."
      }
    ]
  },
  {
    "number": 6651,
    "title": "PlayerNotificationManager not cancellable ",
    "created_at": "2019-11-14T09:06:30Z",
    "closed_at": "2019-11-24T15:02:15Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/google/ExoPlayer/issues/6651",
    "body": "I am using PlayerNotificationManager and attaching it to Exoplayer.\r\nI want to make the notification as cancellable when the video/audio is paused.\r\n\r\nI am using stopForeground(false) when my video is paused but still the notification is non cancellable.\r\n\r\n```\r\n  class MediaConsumptionService : Service(), Player.EventListener {\r\n\r\n    private var player: SimpleExoPlayer? = null\r\n    var image: Bitmap? = null\r\n    private lateinit var playerNotificationManager: PlayerNotificationManager\r\n\r\n    private val NOTIFICATION_CHANNEL_ID = \"playback_channel\"\r\n    private val NOTIFICATION_ID = 2\r\n    private var additionalJson: String? = null\r\n    private var trackId = 0L\r\n    private var trackTitle = \"\"\r\n    private var trackThumbUrl = \"\"\r\n\r\n    override fun onBind(intent: Intent?): IBinder? {\r\n        return null\r\n    }\r\n\r\n    override fun onCreate() {\r\n        super.onCreate()\r\n    }\r\n\r\n    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {\r\n\r\n        player = VideoPlayer.getInstance().player\r\n        player?.addListener(this)\r\n        val context = this\r\n\r\n        val bundle = intent?.extras\r\n        if (bundle != null) {\r\n            trackId = bundle.getLong(MVConstants.PLAYBACK_TRACK_ID, 0)\r\n            trackTitle = bundle.getString(MVConstants.PLAYBACK_TRACK_TITLE, \"\")\r\n            trackThumbUrl = bundle.getString(MVConstants.PLAYBACK_TRACK_THUMB, \"\")\r\n            additionalJson = bundle.getString(MVConstants.MEDIA_JSON, \"\")\r\n            Glide.with(context)\r\n                    .asBitmap()\r\n                    .load(trackThumbUrl)\r\n                    .into(object : CustomTarget<Bitmap>() {\r\n\r\n                        override fun onLoadFailed(errorDrawable: Drawable?) {\r\n                            super.onLoadFailed(errorDrawable)\r\n                            addNotificationToPlayer()\r\n                        }\r\n\r\n                        override fun onResourceReady(resource: Bitmap, transition:\r\n                        Transition<in Bitmap>?) {\r\n                            image = resource\r\n                            addNotificationToPlayer()\r\n                        }\r\n\r\n                        override fun onLoadCleared(placeholder: Drawable?) {\r\n                        }\r\n                    })\r\n\r\n        }\r\n\r\n\r\n        return START_NOT_STICKY\r\n    }\r\n\r\n    private fun addNotificationToPlayer() {\r\n        if (player != null) {\r\n\r\n            playerNotificationManager = createWithNotificationChannel(\r\n                    this,\r\n                    NOTIFICATION_CHANNEL_ID,\r\n                    R.string.playback_channel_name,\r\n                    0,\r\n                    NOTIFICATION_ID,\r\n                    object : MediaDescriptionAdapter {\r\n\r\n                        override fun createCurrentContentIntent(player: Player?): PendingIntent? {\r\n                            val intent = VideoPlayer.getInstance().mediaSessionIntent\r\n                            intent.putExtra(MVConstants.MEDIA_JSON, additionalJson)\r\n                            intent.putExtra(MVConstants.PLAYBACK_TRACK_ID, trackId)\r\n                            intent.putExtra(MVConstants.FROM_NOTIFICATION, true)\r\n                            return PendingIntent.getActivity(applicationContext,\r\n                                    2, intent, PendingIntent.FLAG_UPDATE_CURRENT)\r\n                        }\r\n\r\n                        override fun getCurrentContentText(player: Player?): String? {\r\n                            return \"\"\r\n                        }\r\n\r\n                        override fun getCurrentContentTitle(player: Player?): String {\r\n                            return trackTitle\r\n                        }\r\n\r\n                        override fun getCurrentLargeIcon(player: Player?, callback:\r\n                        BitmapCallback?): Bitmap? {\r\n                            return image\r\n\r\n                        }\r\n                    },\r\n                    object : NotificationListener {\r\n\r\n                        override fun onNotificationPosted(notificationId: Int,\r\n                                                          notification: Notification?,\r\n                                                          ongoing: Boolean) {\r\n                            super.onNotificationPosted(notificationId, notification, ongoing)\r\n                            startForeground(notificationId, notification)\r\n                        }\r\n\r\n                        override fun onNotificationCancelled(notificationId: Int,\r\n                                                             dismissedByUser: Boolean) {\r\n                            super.onNotificationCancelled(notificationId, dismissedByUser)\r\n                            stopSelf()\r\n                        }\r\n                    }\r\n            )\r\n            // omit skip previous and next actions\r\n            playerNotificationManager.setUseNavigationActions(false);\r\n            // omit fast forward action by setting the increment to zero\r\n            playerNotificationManager.setFastForwardIncrementMs(0);\r\n            // omit rewind action by setting the increment to zero\r\n            playerNotificationManager.setRewindIncrementMs(0);\r\n\r\n            playerNotificationManager.setSmallIcon(R.drawable.ico_notification_wings)\r\n\r\n            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {\r\n                playerNotificationManager.setColor(ResourceUtils.getColor(R.color.mva_blue))\r\n            }\r\n\r\n            //assign the player to it\r\n            playerNotificationManager.setPlayer(player)\r\n        }\r\n    }\r\n\r\n    override fun onTaskRemoved(rootIntent: Intent) {\r\n        stopService()\r\n        super.onTaskRemoved(rootIntent)\r\n    }\r\n\r\n    /**\r\n     * Stop service and release the video player\r\n     * This is only executed if we remove the app from tasks or memory is low\r\n     */\r\n    private fun stopService() {\r\n        stopSelf()\r\n        VideoPlayer.getInstance().release()\r\n    }\r\n\r\n    override fun onTrimMemory(level: Int) {\r\n        stopService()\r\n        super.onTrimMemory(level)\r\n    }\r\n\r\n    override fun onPlayerStateChanged(playWhenReady: Boolean, playbackState: Int) {\r\n        super.onPlayerStateChanged(playWhenReady, playbackState)\r\n        when (playbackState) {\r\n            Player.STATE_BUFFERING -> {\r\n\r\n            }\r\n            Player.STATE_READY -> {\r\n                val videoPlaying = player?.playWhenReady ?: false\r\n                if (!videoPlaying) {\r\n                    **stopForeground(false)**\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    override fun onDestroy() {\r\n        if (::playerNotificationManager.isInitialized) {\r\n            playerNotificationManager.setPlayer(null)\r\n        }\r\n        //save the last played position for that track\r\n        if (player != null) {\r\n            PreferenceManager.putLong(\"$trackId\",\r\n                    player?.currentPosition ?: 0)\r\n            player?.removeListener(this)\r\n        }\r\n        super.onDestroy()\r\n    }\r\n\r\n\r\n}\r\n```\r\n\r\nMy minimum SDK is 16. I have also tried minimum SDK 21 but still does not works.\r\nMy Target SDK is 28.\r\nI have checked quite a few forums but could not find a solution.",
    "comments_url": "https://api.github.com/repos/google/ExoPlayer/issues/6651/comments",
    "author": "harshmittal29",
    "comments": [
      {
        "user": "marcbaechinger",
        "created_at": "2019-11-14T10:39:06Z",
        "body": "I think you do not need your own event listener. You can remove your `onPlayerStateChanged` and just do:\r\n\r\n```\r\npublic void onNotificationPosted(int notificationId,\r\n   Notification notification,\r\n   ongoing: Boolean) {\r\n  if (!ongoing) {\r\n    stopForeground(false)\r\n  } else {\r\n    startForeground(notificationId, notification)\r\n  }\r\n}\r\n```"
      },
      {
        "user": "goldy1992",
        "created_at": "2019-11-23T17:13:48Z",
        "body": "@marcbaechinger I had that same issue and I can confirm four solution **fixes the issue**."
      },
      {
        "user": "harshmittal29",
        "created_at": "2019-11-24T15:02:15Z",
        "body": "@marcbaechinger This fixes the issue. Thanks a lot. "
      }
    ]
  },
  {
    "number": 6580,
    "title": "Error: ExoPlaybackException OutOfMemoryError when play .mkv local file.",
    "created_at": "2019-10-25T09:26:34Z",
    "closed_at": "2019-11-02T02:25:37Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/google/ExoPlayer/issues/6580",
    "body": "- ExoPlayer version: 2.10.6\r\n- OS: android 9.0\r\n\r\nHi Dev team, I play file mkv from local (size 3840*2160 - 30s - 679MB), when play to 10s -> OutOfMemoryError\r\n\r\n```\r\nLog: 019-10-25 16:11:57.109 9875-10049/net.vsmart.vphotos E/ExoPlayerImplInternal: Source error.\r\n    com.google.android.exoplayer2.upstream.Loader$UnexpectedLoaderException: Unexpected OutOfMemoryError: Failed to allocate a 65552 byte allocation with 58232 free bytes and 56KB until OOM, max allowed footprint 268435456, growth limit 268435456\r\n        at com.google.android.exoplayer2.upstream.Loader$LoadTask.run(Loader.java:424)\r\n        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1167)\r\n        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:641)\r\n        at java.lang.Thread.run(Thread.java:764)\r\n     Caused by: java.lang.OutOfMemoryError: Failed to allocate a 65552 byte allocation with 58232 free bytes and 56KB until OOM, max allowed footprint 268435456, growth limit 268435456\r\n        at com.google.android.exoplayer2.upstream.DefaultAllocator.allocate(DefaultAllocator.java:102)\r\n        at com.google.android.exoplayer2.source.SampleQueue.preAppend(SampleQueue.java:641)\r\n        at com.google.android.exoplayer2.source.SampleQueue.sampleData(SampleQueue.java:561)\r\n        at com.google.android.exoplayer2.extractor.mkv.MatroskaExtractor.readToOutput(MatroskaExtractor.java:1461)\r\n        at com.google.android.exoplayer2.extractor.mkv.MatroskaExtractor.writeSampleData(MatroskaExtractor.java:1363)\r\n        at com.google.android.exoplayer2.extractor.mkv.MatroskaExtractor.binaryElement(MatroskaExtractor.java:1161)\r\n        at com.google.android.exoplayer2.extractor.mkv.MatroskaExtractor$InnerEbmlProcessor.binaryElement(MatroskaExtractor.java:1628)\r\n        at com.google.android.exoplayer2.extractor.mkv.DefaultEbmlReader.read(DefaultEbmlReader.java:138)\r\n        at com.google.android.exoplayer2.extractor.mkv.MatroskaExtractor.read(MatroskaExtractor.java:440)\r\n        at com.google.android.exoplayer2.source.ProgressiveMediaPeriod$ExtractingLoadable.load(ProgressiveMediaPeriod.java:965)\r\n        at com.google.android.exoplayer2.upstream.Loader$LoadTask.run(Loader.java:394)\r\n        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1167)\u00a0\r\n        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:641)\u00a0\r\n```\r\n\r\nPlease help me re-check and resolve this issue. Thanks so much!",
    "comments_url": "https://api.github.com/repos/google/ExoPlayer/issues/6580/comments",
    "author": "BuiVanNam",
    "comments": [
      {
        "user": "tonihei",
        "created_at": "2019-10-31T15:05:27Z",
        "body": "> 30s - 679MB\r\n\r\nThat's 181 Mbps :)\r\n\r\nExoPlayer buffers up to a certain minimum buffer length by default irrespective of the memory usage. If you want ExoPlayer to stop buffering at the target memory usage, you can try to set `DefaultLoadControl.Builder.setPrioritizeTimeOverSizeThresholds(false)`."
      },
      {
        "user": "BuiVanNam",
        "created_at": "2019-11-02T02:24:55Z",
        "body": "Thanks so much!"
      }
    ]
  },
  {
    "number": 6304,
    "title": "Does Exo player support to set error time out?",
    "created_at": "2019-08-16T09:49:22Z",
    "closed_at": "2019-08-21T01:56:54Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/google/ExoPlayer/issues/6304",
    "body": "When exo player happend `timeout` or `socket timeout` exception, inner player will retry soon, the problem is how can I set the error retry time? Because inner player retry fastly.",
    "comments_url": "https://api.github.com/repos/google/ExoPlayer/issues/6304/comments",
    "author": "VeiZhang",
    "comments": [
      {
        "user": "tonihei",
        "created_at": "2019-08-19T10:50:50Z",
        "body": "I'm not entirely sure what kind of timeout or delay you mean, but there are multiple ways to customize the loading behavior:\r\n- `DefaultHttpDataSourceFactory` allows you to set a `connectTimeoutMillis` and a `readTimeoutMillis` for the connection and reading timeout respectively. You can your customized data source factory in the `MediaSource` builders. \r\n- Every `MediaSource` builder allows you to set a `LoadErrorHandlingPolicy` to define how the player handles errors. You can for example specify the delay before a load is retried (or if it's retried at all)."
      },
      {
        "user": "VeiZhang",
        "created_at": "2019-08-20T10:39:49Z",
        "body": "@tonihei Thanks for your help. I found when playing error, exo player will retry to play more times, I want it retry once or don't retry.\r\nFollow your help, I find the way, maybe it can. I will try.\r\n```\r\nDefaultLoadErrorHandlingPolicy#minimumLoadableRetryCount\r\n```\r\n\r\n**Thanks again**"
      },
      {
        "user": "tonihei",
        "created_at": "2019-08-20T11:49:04Z",
        "body": "Please have a look at `LoadErrorHandlingPolicy.getRetryDelayMsFor`. If you return `C.TIME_UNSET` from this method, it stops retrying. Otherwise, you can also specify the number of time to retry with `minimumLoadableRetryCount`."
      },
      {
        "user": "VeiZhang",
        "created_at": "2019-08-21T01:56:54Z",
        "body": "@tonihei Thanks"
      }
    ]
  },
  {
    "number": 6118,
    "title": "Audio focus is permanently lost",
    "created_at": "2019-07-02T07:26:48Z",
    "closed_at": "2019-07-31T18:34:31Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/google/ExoPlayer/issues/6118",
    "body": "### [REQUIRED] Use case description\r\nI need a player that plays the video silently, it never holds the audio focus, just plays the video without sound.\r\n\r\n<!-- DO NOT DELETE\r\nvalidate_template=true\r\ntemplate_path=.github/ISSUE_TEMPLATE/feature_request.md\r\n-->\r\n",
    "comments_url": "https://api.github.com/repos/google/ExoPlayer/issues/6118/comments",
    "author": "Tumbler0809",
    "comments": [
      {
        "user": "google-oss-bot",
        "created_at": "2019-07-02T07:26:48Z",
        "body": "This issue does not seem to follow the issue template. Make sure you provide all the required information."
      },
      {
        "user": "tonihei",
        "created_at": "2019-07-02T08:12:28Z",
        "body": "The audio focus is not requested unless you explicitly use `SimpleExoPlayer.setAudioAttributed` to set the audio attributes. Could that be the problem? If not, please describe the question in more details following the issue template."
      },
      {
        "user": "Tumbler0809",
        "created_at": "2019-07-09T09:42:37Z",
        "body": "The SimpleExoPlayer.setAudioAttributed method is not called\r\n\r\nAudioManager.isMusicActive() returns true when playing a mute video\uff0cI want it to return false\uff0cBecause I don't use audio resources. I just want to play a video screen.\r\n\r\n"
      },
      {
        "user": "tonihei",
        "created_at": "2019-07-09T09:55:10Z",
        "body": "This means that either something else in the system is playing audio, or the video actually contains  audio data and ExoPlayer is playing it.\r\n\r\nIf your video contains audio data and you just set the volume to zero, it would be better to turn off audio completely. There are two ways to do this:\r\n1. [preferred] Remove the audio renderers by overriding `DefaultRenderersFactory.buildAudioRenderers` with an empty method.\r\n2. Or disable audio tracks with `DefaultTrackSelector.ParametersBuilder.setRendererDisabled` using the audio renderer index."
      },
      {
        "user": "Tumbler0809",
        "created_at": "2019-07-09T10:00:52Z",
        "body": "yes,the video actually contains audio data and ExoPlayer is playing it,I will try the method you provided, thank you"
      }
    ]
  },
  {
    "number": 6057,
    "title": "Getting informed about user actions",
    "created_at": "2019-06-18T12:58:46Z",
    "closed_at": "2019-06-18T18:45:03Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/google/ExoPlayer/issues/6057",
    "body": "### Searched documentation and issues\r\nOfficial ExoPlayer documentation and source code of `MediaControllerCompat`, `MediaSessionConnector`, `MediaSession` classes.\r\n\r\n### Question\r\nIs it possible to get notified about user actions? I'm using `ExoPlayer` and `MediaSessionConnector` for handling MediaSession, so I'm not able to register `MediaSession.Callback`, that would have solved my problem, because it can be registered only once and it is done inside of `MediaSessionConnector` class.\r\n\r\nI would like to be informed about user actions like \"PLAY\", \"PAUSE\", \"SKIP TO NEXT\", \"SKIP TO PREVIOUS\" etc. The only way to do it, I have found, is to register `MediaControllerCompat.Callback`, that has `onPlaybackStateChanged` method. The problem is that after testing it, I have found that only states that are dispatched to this method are `STATE_NONE`, `STATE_PAUSED`, `STATE_PLAYING` and `STATE_BUFFERING`. There are other states like `STATE_SKIPPING_TO_PREVIOUS`, `STATE_SKIPPING_TO_NEXT` I would like to be notified about, but it never happens. \r\n\r\n<!-- DO NOT DELETE\r\nvalidate_template=true\r\ntemplate_path=.github/ISSUE_TEMPLATE/question.md\r\n-->\r\n",
    "comments_url": "https://api.github.com/repos/google/ExoPlayer/issues/6057/comments",
    "author": "Kamil-H",
    "comments": [
      {
        "user": "marcbaechinger",
        "created_at": "2019-06-18T15:10:48Z",
        "body": "Do you need to be aware of skip to next/previous in the app which has access to the `SimpleExoPlayer` instance or does it need to be reported to external client via `MediaControllerCompat.Callback`? From your comment above I understand it's the app (because the `MediaSession.Callback` would help which is in the app).\r\n\r\nIf it's the app, you can \r\n\r\n1) add a listener by using `player.addListener(EventListener)`. When the player transitions from one item to the next, the `onPositionDiscontinuity(int reason)` is called with `reason==DISCONTINUITY_REASON_PERIOD_TRANSITION`. This will be called if the user does skip as well as when playback automatically transitions to the next period in the timeline. In the callback method you can use `player.getCurrentWindowIndex()` to check whats the new item.\r\n\r\n2) Another option is just provide your own ControlDispatcher with connector.setControlDispatcher() and intercept dispatchSeekTo() calls.\r\n\r\nIf you need to know about this in a `MediaControllerCompat.Callback`, you are right that the `STATE_SKIPPING_TO_PREVIOUS, STATE_SKIPPING_TO_NEXT` states are not published by the connector. \r\n\r\nI see two options:\r\n\r\n1) If you are using a `TimelineQueueNavigator` the `PlaybackStateCompat` has a method `getActiveQueueItemId()` which returns the current window index.\r\n\r\n2) If the active item changes `MediaControllerCompat.Callback.onMetadataChanged(MediaMetadataCompat metadata)` is called with a new metadata object when the player transitions to the next or previous item.\r\n\r\nLet me know if one of these options help."
      },
      {
        "user": "Kamil-H",
        "created_at": "2019-06-18T17:02:07Z",
        "body": "Thank you @marcbaechinger for quick replay. \r\nI need this data for statistics purpose. I would like to get to know how users use my app and eventually improve some part of content/app.\r\nTo be more specific, I'm using ExoPlayer in `MediaBrowserServiceCompat`, I have access to both `ExoPlayer` and `MediaControllerCompat.Callback`.\r\nCurrently I'm using something you also mentioned: `MediaControllerCompat.Callback.onMetadataChanged` to detect that media item has been changed and it works pretty well. Unfortunately I don't see an option to distinguish skipping by user and the fact that one media has been finished and another started playing and this is something crucial in my case."
      },
      {
        "user": "marcbaechinger",
        "created_at": "2019-06-18T18:17:17Z",
        "body": "I think in this case it's best to register an `EventListener` with `player.addListener(eventListener)`.\r\n\r\nThe player will call `onPositionDiscontinuity(int reason)` and pass a reason. If it's a seek by the user (skip is a seek) the reason is `Player.DISCONTINUITY_REASON_SEEK`. If playback transitioned automatically the reason is `Player.DISCONTINUITY_REASON_PERIOD_TRANSITION`.\r\n\r\nYou may also want to look into `AnalyticsListener` if you want to collect other events. You can add it by using `SimpleExoPlayer.addAnalyticsListener(AnalyticsListener)`."
      },
      {
        "user": "Kamil-H",
        "created_at": "2019-06-18T18:38:40Z",
        "body": "I was able to play with `onPositionDiscontinuity(int reason)` a little bit and it seem like it will solve my problem. \r\nThank you!  "
      },
      {
        "user": "marcbaechinger",
        "created_at": "2019-06-18T18:45:03Z",
        "body": "Great to hear. I'm closing this issue. Please re-open if needed."
      }
    ]
  },
  {
    "number": 6020,
    "title": "Player currentPosition is 0 on PlayerNotificationManager.onNotificationCancelled",
    "created_at": "2019-06-11T17:57:38Z",
    "closed_at": "2019-06-19T19:13:48Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/google/ExoPlayer/issues/6020",
    "body": "### [REQUIRED] Issue description\r\n\r\nThe currentPosition is 0 on dismissing the player from the PlayerNotificationManager with method onNotificationCancelled. Also in the EventListener.onPlayerStateChanged the currentPosition is 0.\r\n\r\n### [REQUIRED] Reproduction steps\r\n\r\n1. Start the ExoPlayer with PlayerNotificationManager\r\n2. Release the player from the notification\r\n3. Check the currentPosition of the player on dismissing the notification and releasing the player.\r\n\r\n###  [REQUIRED] Link to test content\r\n\r\n-\r\n\r\n### [REQUIRED] A full bug report captured from the device\r\n\r\n-\r\n\r\n### Version of ExoPlayer being used\r\nExoPlayer version 2.10.1\r\n\r\n### Device(s) and version(s) of Android being used\r\nAndroid API 28\r\n\r\n<!-- DO NOT DELETE\r\nvalidate_template=true\r\ntemplate_path=.github/ISSUE_TEMPLATE/bug.md\r\n-->\r\n",
    "comments_url": "https://api.github.com/repos/google/ExoPlayer/issues/6020/comments",
    "author": "AleksandarKovachev",
    "comments": [
      {
        "user": "marcbaechinger",
        "created_at": "2019-06-12T20:27:20Z",
        "body": "The `PlayerNotificationManager` uses roughly `Player.add/removeEventListener` and setters methods of the player which is passed to `PlayerNotificationManager.setPlayer(player)`. These do not affect the playback position. Besides this no other methods are called, which potentially could affect the position of the player.\r\n\r\nI added the `PlayerNotificationManager` to `PlayerActivity` of the demo app. Then I paused at 0:20, dismissed the notification and then continued playback at 0:20 in the player activity. The playback position has not been reset to 0.\r\n\r\nCan you provide some code around what you do in `onNotificationCancelled` of your notification listener. I don't exactly understand what you mean with step 2 and 3?"
      },
      {
        "user": "AleksandarKovachev",
        "created_at": "2019-06-17T14:20:02Z",
        "body": "I am running the player in foreground service. In the foreground service, I have EventListener and in the EventListener.onPlayerStateChanged I am saving the currentPosition in shared preferences. When I am dismissing the PlayerNotification (clicking the stop button) while still playing, the method EventListener.onPlayerStateChanged is called with 0 currentPosition."
      },
      {
        "user": "marcbaechinger",
        "created_at": "2019-06-18T18:31:47Z",
        "body": "When the `PlayerNotificationManager` receives the `ACTION_STOP` action, it calls `controlDispatcher.dispatchStop(player, /* reset= */ true)`. This resets the player, which means the position is reset to 0. \r\n\r\nYou can intercept this call by using your own `ControlDispatcher`. Something like this:\r\n\r\n```\r\nplayerNotificationManager.setControlDispatcher(new DefaultControlDispatcher() {\r\n      @Override\r\n      public boolean dispatchStop(Player player, boolean reset) {\r\n        // store current position to shared preferences now.\r\n        return super.dispatchStop(player, reset);\r\n      }\r\n});\r\n```"
      },
      {
        "user": "AleksandarKovachev",
        "created_at": "2019-06-19T19:13:48Z",
        "body": "Perfect! This helped me a lot. Thank you!"
      }
    ]
  },
  {
    "number": 5954,
    "title": "Allow to dismiss notification with stopforeground(false) destroying service",
    "created_at": "2019-05-27T18:11:40Z",
    "closed_at": "2019-05-29T11:14:42Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/google/ExoPlayer/issues/5954",
    "body": "### Issue description\r\nI added a listener to the player and inside onPlayerStateChanged() i call stopforeground(false) when playWhenReady is false to allow users to dismiss the notification\r\n` mPlayer.addListener(new Player.EventListener() {\r\n\r\n            @Override\r\n            public void onPlayerStateChanged(boolean playWhenReady, int playbackState) {\r\n                if (playWhenReady) {\r\n                    ContextWrapper contextWrapper = new ContextWrapper(mContext);\r\n                    contextWrapper.startService(mIntent);\r\n                    startForeground(mNotificationId, mNotification);\r\n                } else {\r\n                    stopForeground(false);\r\n                }\r\n            }\r\n        }`\r\n\r\nThe dismiss notification is working correctly, but if a use the back button to navigate to the launcher or lock the phone, after a while with the playback paused, the service is destroyed and this appears on the logs\r\n```\r\n 2019-05-27 14:59:12.928 13863-14904/com.android.voyce V/FA: Inactivity, disconnecting from the service\r\n2019-05-27 15:02:11.525 13863-13863/com.android.voyce I/ExoPlayerImpl: Release c274b39 [ExoPlayerLib/2.10.1] [dreamlte, SM-G950F, samsung, 28] [goog.exo.core, goog.exo.ui, goog.exo.mediasession]\r\n2019-05-27 15:02:11.538 13863-14549/com.android.voyce I/ACodec: [OMX.SEC.mp3.dec] signalFlush\r\n2019-05-27 15:02:11.539 13863-14549/com.android.voyce I/ACodec: [OMX.SEC.mp3.dec] ExecutingState flushing now (codec owns 10/10 input, 0/5 output).\r\n2019-05-27 15:02:11.549 13863-14549/com.android.voyce I/ACodec: [OMX.SEC.mp3.dec] Now Flushing\r\n2019-05-27 15:02:11.556 13863-14549/com.android.voyce I/ACodec: [OMX.SEC.mp3.dec] FlushingState onOMXEvent(0,1,0)\r\n2019-05-27 15:02:11.556 13863-14549/com.android.voyce I/ACodec: [OMX.SEC.mp3.dec] FlushingState onOMXEvent(0,1,1)\r\n2019-05-27 15:02:11.559 13863-14549/com.android.voyce I/ACodec: [OMX.SEC.mp3.dec] Now Executing\r\n2019-05-27 15:02:11.571 13863-14549/com.android.voyce I/ACodec: [OMX.SEC.mp3.dec] Now Executing->Idle\r\n2019-05-27 15:02:11.590 13863-14549/com.android.voyce I/ACodec: [OMX.SEC.mp3.dec] Now Idle->Loaded\r\n2019-05-27 15:02:11.590 13863-14549/com.android.voyce I/ACodec: [OMX.SEC.mp3.dec] Now Loaded\r\n2019-05-27 15:02:11.591 13863-14549/com.android.voyce I/ACodec:  [OMX.SEC.mp3.dec] Now kWhatShutdownCompleted event : 8544\r\n2019-05-27 15:02:11.598 13863-14549/com.android.voyce I/ACodec:  [OMX.SEC.mp3.dec] Now uninitialized\r\n2019-05-27 15:02:11.604 13863-14549/com.android.voyce I/ACodec:  [] Now kWhatShutdownCompleted event : 8544\r\n2019-05-27 15:02:11.604 13863-14549/com.android.voyce I/MediaCodec: Codec shutdown complete\r\n2019-05-27 15:02:11.731 13863-14075/com.android.voyce W/m.android.voyc: Accessing hidden method Ldalvik/system/CloseGuard;->close()V (light greylist, linking) \r\n```\r\n\r\nthis is my NotificationListener code \r\n\r\n```\r\nnew PlayerNotificationManager.NotificationListener() {\r\n                    @Override\r\n                    public void onNotificationCancelled(int notificationId, boolean dismissedByUser) {\r\n                        if (dismissedByUser) {\r\n                            stopSelf();\r\n                        }\r\n                    }\r\n\r\n                    @Override\r\n                    public void onNotificationPosted(int notificationId, Notification notification, boolean ongoing) {\r\n                        mNotification = notification;\r\n                        mNotificationId = notificationId;\r\n                        if (ongoing) {\r\n                            startForeground(notificationId, notification);\r\n                        }\r\n                    }\r\n                }\r\n```\r\n\r\n### Reproduction steps\r\nI create the service with \r\n```\r\n mPlayerServiceIntent = new Intent(this, AudioPlayerService.class);\r\n        bindService(mPlayerServiceIntent, mPlayerServiceConnection, BIND_AUTO_CREATE);\r\n```\r\n\r\non the activity on create, then when the user chooses a song (a simple mp3 url from firebasestorage) then i call `Util.startForegroundService(this, mPlayerServiceIntent);`\r\n\r\nthen i pause the playback and exits the app with the back button, the notification with the paused state stays for a while, then it is destroyed as i mentioned above.\r\n\r\n### Version of ExoPlayer being used\r\nVersion 2.10.1 \r\n\r\n### Device(s) and version(s) of Android being used\r\nSamsung s8, api 28.\r\n\r\n<!-- DO NOT DELETE\r\nvalidate_template=true\r\ntemplate_path=.github/ISSUE_TEMPLATE/bug.md\r\n-->\r\n",
    "comments_url": "https://api.github.com/repos/google/ExoPlayer/issues/5954/comments",
    "author": "Joaomon7eiro",
    "comments": [
      {
        "user": "marcbaechinger",
        "created_at": "2019-05-28T08:16:36Z",
        "body": "This behaviour seems to be working as intended to me. If you call `stopForeground(false)` the service is not in foreground anymore. Then you put the app into the background with the back button. From this moment on the service needs to be in the foreground, or the system may terminate the service, which is what happens according to the log statements you added.\r\n\r\nSeems like all the resources are nicely released. That's it exactly how it is designed to work.\r\n\r\nIf you want the notification to stay you need to call `startForeground(int, Notification)` again in the moment when the app goes to background. But I think it would maybe make sense to just leave it as is, because if the user pauses playback and leaves the app this may actually indicate the user does not want to play anymore.\r\n\r\nSo if I got your question right this behaviour seems to be as designed. \r\n"
      },
      {
        "user": "Joaomon7eiro",
        "created_at": "2019-05-28T11:57:56Z",
        "body": "Thank you so much for answering. I wanted to keep the notification when user presses the back button and still allow it to dismiss the notification outside of my app. Is it possible? The behavior that i wanted is to allow the users to pause the playback and move to other apps, and the notification persists so the user can resume playback using the notification."
      },
      {
        "user": "marcbaechinger",
        "created_at": "2019-05-28T17:02:13Z",
        "body": "I think you already implemented it according to best practices. \r\n\r\nThe service is kept in foreground, if the app goes to background when the player is playing (playWhenReady = true), then your service is in foreground still. The user can then \r\n\r\n1) Pause with the button in the notification. This would remove the service from foreground and the system kills the service and remove the notification after a given time.\r\n\r\n2) When paused, the notification can be dismissed, which gives you the chance to `stopSelf` the service.\r\n\r\nThat's how you already implemented it. Not removing the service from the foreground when not doing playback is not a 'good citizen' behavior."
      },
      {
        "user": "Joaomon7eiro",
        "created_at": "2019-05-28T17:08:35Z",
        "body": "Okay, I will leave the way it is implemented right now. Thanks again!"
      }
    ]
  },
  {
    "number": 5871,
    "title": "Is there an eventListener for subtitles?",
    "created_at": "2019-05-10T12:30:37Z",
    "closed_at": "2019-05-12T20:38:30Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/google/ExoPlayer/issues/5871",
    "body": "I figured how to load subtitle and merge with `MediaSource`.\r\n\r\nBut I'm wondering if there is an eventListner for loading subtitles.\r\nHere's how I load subtitle\r\n\r\n```\r\nSingleSampleMediaSource.Factory(DefaultHttpDataSourceFactory(\"ua\"))\r\n   .createMediaSource(Uri.parse( subtitleUri ), vttFormat, C.TIME_UNSET)\r\n```\r\n\r\nHow can I set the loadFailedListener....?\r\n\r\n\r\nThank you !",
    "comments_url": "https://api.github.com/repos/google/ExoPlayer/issues/5871/comments",
    "author": "BROUDING",
    "comments": [
      {
        "user": "marcbaechinger",
        "created_at": "2019-05-10T19:47:15Z",
        "body": "There is another `createMediaSource` method which offers two additional parameters which are a `Handler` and a `MediaSourceEventListener`. Is this what you are looking for?\r\n\r\n```\r\npublic SingleSampleMediaSource createMediaSource(\r\n        Uri uri,\r\n        Format format,\r\n        long durationUs,\r\n        @Nullable Handler eventHandler,\r\n        @Nullable MediaSourceEventListener eventListener) \r\n```"
      },
      {
        "user": "BROUDING",
        "created_at": "2019-05-11T01:15:05Z",
        "body": "That should work, thank you!"
      }
    ]
  },
  {
    "number": 5791,
    "title": "playlist with PagedList(AAC)",
    "created_at": "2019-04-23T08:07:28Z",
    "closed_at": "2019-04-30T10:45:01Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/google/ExoPlayer/issues/5791",
    "body": "\r\n### [REQUIRED] Searched documentation and issues\r\nI found playlist feature can be implemented using ConcatenatingMediaSource class which be added MediaSource instance.\r\n\r\n\r\n### [REQUIRED] Question\r\nHi, I'm implementing playlist feature that has about 700 songs.\r\nI've implemented using ConcatenatingMediaSource instance.\r\nBut it require to instantiate HlsMediaSource instance about 700 times at once to add there .\r\n\r\nI use PageList class(AAC) to show playlist in view. \r\nIs there any way to use the pageList to exoplayer playlist feature.\r\n\r\nIs any advice in this scenario?\r\n\r\n<!-- DO NOT DELETE\r\nvalidate_template=true\r\ntemplate_path=.github/ISSUE_TEMPLATE/question.md\r\n-->\r\n",
    "comments_url": "https://api.github.com/repos/google/ExoPlayer/issues/5791/comments",
    "author": "simpler23",
    "comments": [
      {
        "user": "AquilesCanta",
        "created_at": "2019-04-25T10:35:52Z",
        "body": "@tonihei can you provide advise here?"
      },
      {
        "user": "tonihei",
        "created_at": "2019-04-25T14:59:12Z",
        "body": "I think the easiest solution is to create all 700 MediaSources and set the `useLazyPreparation` parameter is the constructor to `true`. This causes the source to not prepare all HLS sources at once but only if they are actually needed. This way the index in the playlist can also stay the same as the index in your PagedList and you don't need any extra logic. "
      },
      {
        "user": "simpler23",
        "created_at": "2019-04-26T14:38:14Z",
        "body": "Thank you for sharing your tip!\r\nBut I worry about instantiating 700 objects at once that might not be used.\r\nIs it fine in memory perspective?"
      },
      {
        "user": "tonihei",
        "created_at": "2019-04-29T09:06:11Z",
        "body": "That shouldn't be an issue. I just tested creating 700 HlsMediaSource and they use up only 233 KB  of memory."
      },
      {
        "user": "tonihei",
        "created_at": "2019-04-30T10:44:59Z",
        "body": "Closing, because the question has been answered."
      },
      {
        "user": "simpler23",
        "created_at": "2019-05-01T10:52:54Z",
        "body": "Thank you for the answers!!"
      }
    ]
  },
  {
    "number": 5727,
    "title": "Question: How to override the video track selection for multiple videos",
    "created_at": "2019-04-04T14:00:08Z",
    "closed_at": "2019-04-12T16:54:58Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/google/ExoPlayer/issues/5727",
    "body": "Can you change the resolution of all the videos that are playing in the player without having to create a new instance of the player?\r\n\r\nExoplayer version 2.9.4\r\n\r\nTo make the exchange of quality I am using this method\r\n\r\n```\r\nprivate fun applySelection() {\r\n        val trackInfo = trackSelector.currentMappedTrackInfo ?: return\r\n        val trackGroups = trackInfo.getTrackGroups(videoRendererIndex)\r\n\r\n        val parametersBuilder = trackSelector.buildUponParameters()\r\n        parametersBuilder.setRendererDisabled(videoRendererIndex, false)\r\n\r\n        if (overridePlayer != null) {\r\n            parametersBuilder.setSelectionOverride(videoRendererIndex, trackGroups, overridePlayer)\r\n        } else {\r\n            parametersBuilder.clearSelectionOverrides(videoRendererIndex)\r\n        }\r\n\r\n        trackSelector.setParameters(parametersBuilder)\r\n}\r\n```",
    "comments_url": "https://api.github.com/repos/google/ExoPlayer/issues/5727/comments",
    "author": "DionataFerraz",
    "comments": [
      {
        "user": "ojw28",
        "created_at": "2019-04-07T15:56:48Z",
        "body": "Selection overrides only apply to content that has the same set of tracks that you've set the override for. Or more precisely, a video track override will only apply to content where the `trackGroups` assigned to the video renderer are the same as those that you've set the override for. If you start playing content that has a different set of tracks, you'll need to set a new override for the new `trackGroups` (note: there is no requirement that you create a new instance of the player to do this).\r\n\r\nIf possible, try using constraint based track selection rather than specific track overrides when playing multiple videos. For example if you're trying to impose a maximum quality, use `parametersBuilder.setMaxVideoSize` or `parametersBuilder.setMaxVideoBitrate`. Constraints are a lot more flexible than specific overrides, and apply naturally over multiple videos. Setting minimum qualities via constraints is currently not possible; adding this functionality is tracked by #4511."
      },
      {
        "user": "DionataFerraz",
        "created_at": "2019-04-11T19:54:02Z",
        "body": "Solved with that\r\nOBS: it was not me that did\r\n```\r\nimport com.google.android.exoplayer2.source.TrackGroup\r\nimport com.google.android.exoplayer2.trackselection.AdaptiveTrackSelection\r\nimport com.google.android.exoplayer2.trackselection.TrackSelection\r\nimport com.google.android.exoplayer2.upstream.BandwidthMeter\r\nimport com.google.android.exoplayer2.util.Clock\r\n\r\ntypealias SelectedIndex = () -> Int?\r\n\r\nclass FixedAdaptiveTrackSelection(\r\n    group: TrackGroup,\r\n    tracks: IntArray,\r\n    bandwidth: BandwidthMeter,\r\n    minDurationForQualityIncreaseMs: Long,\r\n    maxDurationForQualityDecreaseMs: Long,\r\n    minDurationToRetainAfterDiscardMs: Long,\r\n    bandwidthFraction: Float,\r\n    bufferedFractionToLiveEdgeForQualityIncrease: Float,\r\n    minTimeBetweenBufferReevaluationMs: Long,\r\n    clock: Clock,\r\n    private var selectedIndexFunction: SelectedIndex?\r\n) : AdaptiveTrackSelection(\r\n    group,\r\n    tracks,\r\n    bandwidth,\r\n    minDurationForQualityIncreaseMs,\r\n    maxDurationForQualityDecreaseMs,\r\n    minDurationToRetainAfterDiscardMs,\r\n    bandwidthFraction,\r\n    bufferedFractionToLiveEdgeForQualityIncrease,\r\n    minTimeBetweenBufferReevaluationMs,\r\n    clock\r\n) {\r\n\r\n    class Factory : TrackSelection.Factory {\r\n\r\n        private var bandwidthMeter: BandwidthMeter? = null\r\n        private var minDurationForQualityIncreaseMs: Int? = null\r\n        private var maxDurationForQualityDecreaseMs: Int? = null\r\n        private var minDurationToRetainAfterDiscardMs: Int? = null\r\n        private var bandwidthFraction: Float? = null\r\n        private var bufferedFractionToLiveEdgeForQualityIncrease: Float? = null\r\n        private var minTimeBetweenBufferReevaluationMs: Long? = null\r\n        private var clock: Clock\r\n        private var selectedIndex: SelectedIndex? = null\r\n\r\n        constructor(selectedIndex: SelectedIndex?) : this(\r\n            AdaptiveTrackSelection.DEFAULT_MIN_DURATION_FOR_QUALITY_INCREASE_MS,\r\n            DEFAULT_MAX_DURATION_FOR_QUALITY_DECREASE_MS,\r\n            DEFAULT_MIN_DURATION_TO_RETAIN_AFTER_DISCARD_MS,\r\n            DEFAULT_BANDWIDTH_FRACTION,\r\n            DEFAULT_BUFFERED_FRACTION_TO_LIVE_EDGE_FOR_QUALITY_INCREASE,\r\n            DEFAULT_MIN_TIME_BETWEEN_BUFFER_REEVALUTATION_MS,\r\n            Clock.DEFAULT,\r\n            selectedIndex\r\n        )\r\n\r\n        constructor(\r\n            minDurationForQualityIncreaseMs: Int,\r\n            maxDurationForQualityDecreaseMs: Int,\r\n            minDurationToRetainAfterDiscardMs: Int,\r\n            bandwidthFraction: Float,\r\n            bufferedFractionToLiveEdgeForQualityIncrease: Float,\r\n            minTimeBetweenBufferReevaluationMs: Long,\r\n            clock: Clock,\r\n            selectedIndex: SelectedIndex?\r\n        ) {\r\n            this.minDurationForQualityIncreaseMs = minDurationForQualityIncreaseMs\r\n            this.maxDurationForQualityDecreaseMs = maxDurationForQualityDecreaseMs\r\n            this.minDurationToRetainAfterDiscardMs = minDurationToRetainAfterDiscardMs\r\n            this.bandwidthFraction = bandwidthFraction\r\n            this.bufferedFractionToLiveEdgeForQualityIncrease = bufferedFractionToLiveEdgeForQualityIncrease\r\n            this.minTimeBetweenBufferReevaluationMs = minTimeBetweenBufferReevaluationMs\r\n            this.clock = clock\r\n            this.selectedIndex = selectedIndex\r\n        }\r\n\r\n        override fun createTrackSelection(group: TrackGroup, bandwidth: BandwidthMeter, vararg tracks: Int): FixedAdaptiveTrackSelection {\r\n            var meter = bandwidth\r\n            if (bandwidthMeter != null) {\r\n                meter = bandwidthMeter as BandwidthMeter\r\n            }\r\n            return FixedAdaptiveTrackSelection(\r\n                group,\r\n                tracks,\r\n                meter,\r\n                minDurationForQualityIncreaseMs?.toLong() ?: 0,\r\n                maxDurationForQualityDecreaseMs?.toLong() ?: 0,\r\n                minDurationToRetainAfterDiscardMs?.toLong() ?: 0,\r\n                bandwidthFraction ?: 0F,\r\n                bufferedFractionToLiveEdgeForQualityIncrease ?: 0F,\r\n                minTimeBetweenBufferReevaluationMs ?: 0,\r\n                clock,\r\n                selectedIndex)\r\n        }\r\n\r\n    }\r\n\r\n    override fun getSelectedIndex(): Int {\r\n        return selectedIndexFunction?.invoke() ?: super.getSelectedIndex()\r\n    }\r\n\r\n}\r\n```\r\n\r\n\r\n```\r\nval trackSelector: DefaultTrackSelector by lazy {\r\n        DefaultTrackSelector(FixedAdaptiveTrackSelection.Factory(::getSelectedQualityIndex)).apply {\r\n            parameters = trackSelectorParameters\r\n        }\r\n }\r\n```\r\n"
      }
    ]
  },
  {
    "number": 5655,
    "title": "SimpleExoPlayer.prepare(com.google.android.exoplayer2.source.MediaSource)' on a null object reference",
    "created_at": "2019-03-20T11:10:24Z",
    "closed_at": "2019-03-20T12:38:35Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/google/ExoPlayer/issues/5655",
    "body": "### [REQUIRED] Searched documentation and issues\r\nnull\r\n\r\n### [REQUIRED] Question\r\nwhen I init the  SimpleExoPlayer player.the method SimpleExoPlayer.prepare()  will  return a null \r\nobject reference.My uri has no problem,Whyyyyyyyy?\r\n\r\nprivate void initPlayer() {\r\n        if (player!=null) {\r\n            player = ExoPlayerFactory.newSimpleInstance(\r\n                    getActivity(), new DefaultRenderersFactory(getActivity()), new DefaultTrackSelector(), new DefaultLoadControl());\r\n            playerView.setPlayer(player);\r\n            player.setPlayWhenReady(playWhenReady);\r\n            player.seekTo(currentWindow, playbackPosition);\r\n        }\r\n        //\u521b\u5efawav\u6587\u4ef6\r\n        Uri uri=Uri.parse(Environment.getExternalStorageDirectory()+\"/msc/test.wav\");\r\n        DefaultDataSourceFactory dataSourceFactory = new DefaultDataSourceFactory(getActivity(), Util.getUserAgent(getContext(),\"MyApplication\"));\r\n        MediaSource mediaSource=new ExtractorMediaSource.Factory(\r\n                dataSourceFactory).createMediaSource(uri);\r\n        if (mediaSource!=null) {\r\n            player.prepare(mediaSource, false, true);\r\n        }else {\r\n            showTip(\"mediaSource   null\");\r\n        }\r\n\r\n\r\n    }\r\n\r\n<!-- DO NOT DELETE\r\nvalidate_template=true\r\ntemplate_path=.github/ISSUE_TEMPLATE/question.md\r\n-->\r\n",
    "comments_url": "https://api.github.com/repos/google/ExoPlayer/issues/5655/comments",
    "author": "huang122124",
    "comments": [
      {
        "user": "google-oss-bot",
        "created_at": "2019-03-20T11:10:25Z",
        "body": "This issue does not have all the information required by the template.  Looks like you forgot to fill out some sections.  Please update the issue with more information."
      },
      {
        "user": "huang122124",
        "created_at": "2019-03-20T11:11:49Z",
        "body": "My ExoPlayer version is 2.9.3   Android 8.0    XiaoMi PAD 4"
      },
      {
        "user": "tonihei",
        "created_at": "2019-03-20T12:38:35Z",
        "body": "You should probably check for `player==null` on the second line in your snippet. \r\n\r\nBut please be advised that we do not intent to give generic programming advice. Closing this issue for this reason."
      },
      {
        "user": "huang122124",
        "created_at": "2019-03-20T12:46:13Z",
        "body": "Thank you"
      }
    ]
  },
  {
    "number": 5627,
    "title": "Custom Load Error message: available or not?",
    "created_at": "2019-03-13T11:54:46Z",
    "closed_at": "2019-03-31T20:27:14Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/google/ExoPlayer/issues/5627",
    "body": "### Searched documentation and issues\r\nI have been looking around the web, offical Android Dev. website, Medium, in this repository Issue category and in the Source code.\r\n\r\n### Question\r\nI am working with the ExoPlayer error handling. I found that when my Server response is an exception of type \"InvalidResponseCodeException\" I am not able to find the server message, just the default http status message (in the LoadErrorHandlingPolicy custom class as well as for the player listener onPlayerError() method). I am wondering if is there a way to get it or it is a feature not yet implemented.\r\n\r\n<!-- DO NOT DELETE\r\nvalidate_template=true\r\ntemplate_path=.github/ISSUE_TEMPLATE/question.md\r\n-->\r\n",
    "comments_url": "https://api.github.com/repos/google/ExoPlayer/issues/5627/comments",
    "author": "JonathanImperato",
    "comments": [
      {
        "user": "AquilesCanta",
        "created_at": "2019-03-13T12:11:38Z",
        "body": "It should be available through InvalidResponseCodeException#responseMessage. Is that empty? If so, are you sure the server is providing a non-empty response body? Have you tried different HTTP DataSources?"
      },
      {
        "user": "JonathanImperato",
        "created_at": "2019-03-13T13:24:00Z",
        "body": "> It should be available through InvalidResponseCodeException#responseMessage. Is that empty? If so, are you sure the server is providing a non-empty response body? Have you tried different HTTP DataSources?\r\n\r\nInvalidResponseCodeException#responseMessage prints the default http status message such as 401 Unauthorized, not the server message (eg. For 401: You are not authorized)..."
      },
      {
        "user": "AquilesCanta",
        "created_at": "2019-03-13T13:34:05Z",
        "body": "Oh right, the responseMessage doesn't contain the response body. I can confirm this is not provided out of the box. I don't think reading the response body for an error is something we want to add to any default implementation.\r\n\r\nCan you explain the usecase for this?"
      },
      {
        "user": "JonathanImperato",
        "created_at": "2019-03-13T13:49:01Z",
        "body": "> Oh right, the responseMessage doesn't contain the response body. I can confirm this is not provided out of the box. I don't think reading the response body for an error is something we want to add to any default implementation.\r\n> \r\n> Can you explain the usecase for this?\r\n\r\nIt is usefull because we don't want to keep this messages inside the app, these are messages that may change over time and mostly they are translated.\r\nFor example we are handling error 429 \"Too many requests\", when ExoPlayer reaches this error it will show an AlertDialog with the wanted information.\r\nWe want to have this message customizable on the Server side.\r\nI hope it is a little bit more clear."
      },
      {
        "user": "AquilesCanta",
        "created_at": "2019-03-28T10:52:57Z",
        "body": "The easiest way I can think of implementing the provision of the error's response body is including it in the InvalidResponseCodeException. However, it's probably not ideal to block until we read the response body, before we throw the exception. So, we might also want to add a per-implementation flag that enables populating the response body for this case.\r\n\r\n@JonathanImperato, I see slim chances of us adding this any time soon. You might want to think of using your own DataSource implementation that does this for you. It shouldn't be hard, if you part from an existing implementation.\r\n\r\n@ojw28, can you think of a better way of providing the response body of a non-2xx response?"
      },
      {
        "user": "amozoss",
        "created_at": "2019-03-29T21:38:12Z",
        "body": "Not ideal, but if you can have the server return the error in a header, you can get the error message that way. I have a custom header called `X-Client-Error`, which I am able to access.\r\n``` \r\n @Override\r\n    public void onPlayerError(ExoPlaybackException error) {\r\n      String message = \"Unknown\";\r\n      switch (error.type) {\r\n        case ExoPlaybackException.TYPE_SOURCE:\r\n          message = \"TYPE_SOURCE: \" + error.getSourceException().getMessage();\r\n          if (error.getSourceException() instanceof HttpDataSource.InvalidResponseCodeException) {\r\n            HttpDataSource.InvalidResponseCodeException invalidResponseCodeException = (HttpDataSource.InvalidResponseCodeException) error.getSourceException();\r\n            List<String> strings = invalidResponseCodeException.headerFields.get(\"X-Client-Error\");\r\n            if (strings.size() > 0) {\r\n              message +=  \"\\n\" + strings.get(0);\r\n            }\r\n          }\r\n          break;\r\n...\r\n```"
      },
      {
        "user": "JonathanImperato",
        "created_at": "2019-03-30T07:24:03Z",
        "body": "> Not ideal, but if you can have the server return the error in a header, you can get the error message that way. I have a custom header called `X-Client-Error`, which I am able to access.\r\n> \r\n> ```\r\n>  @Override\r\n>     public void onPlayerError(ExoPlaybackException error) {\r\n>       String message = \"Unknown\";\r\n>       switch (error.type) {\r\n>         case ExoPlaybackException.TYPE_SOURCE:\r\n>           message = \"TYPE_SOURCE: \" + error.getSourceException().getMessage();\r\n>           if (error.getSourceException() instanceof HttpDataSource.InvalidResponseCodeException) {\r\n>             HttpDataSource.InvalidResponseCodeException invalidResponseCodeException = (HttpDataSource.InvalidResponseCodeException) error.getSourceException();\r\n>             List<String> strings = invalidResponseCodeException.headerFields.get(\"X-Client-Error\");\r\n>             if (strings.size() > 0) {\r\n>               message +=  \"\\n\" + strings.get(0);\r\n>             }\r\n>           }\r\n>           break;\r\n> ...\r\n> ```\r\n\r\nYes, it is what I am doing right now, but instead of a string I pass a serialized json."
      },
      {
        "user": "ojw28",
        "created_at": "2019-03-31T20:24:43Z",
        "body": "Pretty much all apps that I've seen will include the strings (and translations) as resources inside the app. I don't understand why it would be particularly important to enable these messages to be changed on the server side. Typically an error code has a well defined meaning, and the strings inside the app will reflect that. I understand that the exact wording may be tweaked from release to release, but I'd expect any string that was included in a previous release to still make sense. I also don't understand why translation is important here. Android already provides a resources mechanism that supports translations.\r\n\r\nI don't think it's important that we go out of our way to support this use case. Putting content into a response header as described above is one way of achieving what's being requested, for those who really want to do this."
      }
    ]
  },
  {
    "number": 5602,
    "title": "ConcateningMedia, RepeatOne and next / previous",
    "created_at": "2019-03-06T13:22:36Z",
    "closed_at": "2019-03-06T13:30:11Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/google/ExoPlayer/issues/5602",
    "body": "I have a question regarding REPEAT_ONE mode, ConcateningMedia and using SimpleExoPlayer.next(), previous() and related methods.\r\n\r\nFrom my understanding, REPEAT_ONE should function by endlessly looping same MediaSource. From what I see in the source code of Timeline.getNextWindowIndex, it should return currentWindowIndex when repeat mode is REPEAT_ONE. But this isn't the case. Instead using simpleExoPlayer.next() moves to next window index and plays next MediaSource. \r\n\r\nIn short, I have a ConcateningMedia with MediaSourceA, MediaSourceB and MediaSourceC.\r\nWhen I set REPEAT_ONE and play MediaSourceA, I expect getPreviousWindowIndex() and getNextWindowIndex() to return same values as getCurrentWindowIndex() and that calling next() replays MediaSourceA. Instead, MediaSourceB is played.\r\n \r\nIs this expected behavior? \r\n\r\n<!-- DO NOT DELETE\r\nvalidate_template=true\r\ntemplate_path=.github/ISSUE_TEMPLATE/question.md\r\n-->\r\n",
    "comments_url": "https://api.github.com/repos/google/ExoPlayer/issues/5602/comments",
    "author": "tomislavturcic",
    "comments": [
      {
        "user": "google-oss-bot",
        "created_at": "2019-03-06T13:22:37Z",
        "body": "This issue does not seem to follow the issue template. Make sure you provide all the required information."
      },
      {
        "user": "tonihei",
        "created_at": "2019-03-06T13:28:15Z",
        "body": "Yes, that is expected behaviour. \r\n\r\nThe idea is that you can have UI elements which let you skip to the next and previous item (using `player.next()` and `player.previous()` even though you have REPEAT_ONE enabled. The current item is still repeated endlessly without any interaction. The `getNextWindowIndex()` and `getPreviousWindowIndex()` methods return matching values to tell you which window index will be played when calling `next()` or `previous()`."
      },
      {
        "user": "tomislavturcic",
        "created_at": "2019-03-06T13:30:11Z",
        "body": "Ok, thanks for clarification!"
      },
      {
        "user": "tonihei",
        "created_at": "2019-03-06T13:30:57Z",
        "body": "If you'd like to know the next item the player will play automatically, you can use `player.getCurrentTimeline().getNextWindowIndex(windowIndex, repeatMode, shuffleMode)` to query any transition under different repeat and shuffle mode conditions."
      },
      {
        "user": "ojw28",
        "created_at": "2020-11-24T15:50:53Z",
        "body": "`Player` Javadoc will be improved to more explicitly explain this behavior in a future release. Removing the `documentation candidate` label as these changes have been made internally."
      }
    ]
  },
  {
    "number": 5525,
    "title": "Make DefaultRenderersFactory subclass-friendly",
    "created_at": "2019-02-18T08:28:23Z",
    "closed_at": "2019-02-18T12:28:19Z",
    "labels": [
      "question",
      "cla: yes"
    ],
    "url": "https://github.com/google/ExoPlayer/pull/5525",
    "body": "Change the `private` fields to `protected` so that subclasses can use them. \r\n\r\nAn alternative might can be adding protected/public getters, but that seems to be an overkill.\r\n\r\nCurrently our workaround is having our own copies of private allowedVideoJoiningTimeMs and playClearSamplesWithoutKeys.",
    "comments_url": "https://api.github.com/repos/google/ExoPlayer/issues/5525/comments",
    "author": "noamtamim",
    "comments": [
      {
        "user": "ojw28",
        "created_at": "2019-02-18T10:47:37Z",
        "body": "Could you clarify where you need `allowedVideoJoiningTimeMs` and `playClearSamplesWithoutKeys`. They're already passed to the methods that should need them (e.g. `allowedVideoJoiningTimeMs` is passed to `buildVideoRenderers`). If you're overriding `createRenderers` directly then perhaps at that point you should just be forking the whole class?"
      },
      {
        "user": "noamtamim",
        "created_at": "2019-02-18T12:28:19Z",
        "body": "@ojw28 you're right, we missed the fact that `allowedVideoJoiningTimeMs` and `playClearSamplesWithoutKeys` are passed to `buildVideoRenderers`.\r\n"
      }
    ]
  },
  {
    "number": 5458,
    "title": "Using custom receiver in cast with exoplayer",
    "created_at": "2019-01-31T07:01:43Z",
    "closed_at": "2019-01-31T10:25:46Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/google/ExoPlayer/issues/5458",
    "body": "Hi i am having a question with regards to using cast with exoplayer.\r\nWe are planning to write a custom receiver for cast.The cast sdk mentions that we need to send the receiver app id from the sender app(android app).Where is this to be provided if we are using exoplayer cast extension.\r\n",
    "comments_url": "https://api.github.com/repos/google/ExoPlayer/issues/5458/comments",
    "author": "meenukrishnamurthy",
    "comments": [
      {
        "user": "AquilesCanta",
        "created_at": "2019-01-31T10:25:46Z",
        "body": "The app id is provided by the OptionsProvider, which is in turn defined in the AndroidManifest of your app. Have a look at AndroidManifest.xml in the demo app. You'll find a line like:\r\n\r\n```\r\n<meta-data android:name=\"com.google.android.gms.cast.framework.OPTIONS_PROVIDER_CLASS_NAME\"\r\n        android:value=\"com.google.android.exoplayer2.ext.cast.DefaultCastOptionsProvider\" />\r\n```\r\n\r\nAnd then in DefaultCastOptionsProvider there is\r\n\r\n```\r\n  @Override\r\n  public CastOptions getCastOptions(Context context) {\r\n    return new CastOptions.Builder()\r\n        .setReceiverApplicationId(CastMediaControlIntent.DEFAULT_MEDIA_RECEIVER_APPLICATION_ID)\r\n        .setStopReceiverApplicationWhenEndingSession(true).build();\r\n  }\r\n```\r\n\r\nYou can replace the id. It's worth mentioning we are releasing the initial version of our own receiver app in approximately 2 weeks. It would be great if you could help us test it once it's pushed to the public repo."
      },
      {
        "user": "meenukrishnamurthy",
        "created_at": "2019-01-31T10:53:05Z",
        "body": "Sure will do the needful."
      },
      {
        "user": "meenukrishnamurthy",
        "created_at": "2019-01-31T10:53:42Z",
        "body": "Thanks for the quick response."
      }
    ]
  },
  {
    "number": 5339,
    "title": "Playing mp4 video from assets",
    "created_at": "2019-01-04T15:06:33Z",
    "closed_at": "2019-01-04T16:10:57Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/google/ExoPlayer/issues/5339",
    "body": "I'm trying to use a video that is inside the assets directory, but I always take an exception \r\n com.google.android.exoplayer2.upstream.HttpDataSource$HttpDataSourceException: Unable to connect to assets://vid.mp4\r\n```\r\nExtractorMediaSource.Factory(DefaultDataSourceFactory(context, BuildConfig.USER_AGENT_VALUE)).createMediaSource(Uri.parse(\"assets://vid.mp4\"))\r\n```",
    "comments_url": "https://api.github.com/repos/google/ExoPlayer/issues/5339/comments",
    "author": "DionataFerraz",
    "comments": [
      {
        "user": "andrewlewis",
        "created_at": "2019-01-04T15:08:19Z",
        "body": "Does `asset://...` work?"
      },
      {
        "user": "marcbaechinger",
        "created_at": "2019-01-04T15:18:24Z",
        "body": "Or you need to prefix your path with android_asset. So for your example it would be:\r\n\r\nfile:///android_asset/vid.mp4"
      },
      {
        "user": "DionataFerraz",
        "created_at": "2019-01-04T15:30:03Z",
        "body": "I've tried, but throws an exception that the file was not found\r\n    com.google.android.exoplayer2.upstream.AssetDataSource$AssetDataSourceException: java.io.FileNotFoundException: \r\n\r\npackage assets is inside the main, should it be somewhere else?\r\n\r\nI put the package assets in the singular and also did not work, it throws the same exception above\r\n\r\nI tried putting it in the package raw inside the res and it does not work either\r\n\r\ni try \r\n```\r\nExtractorMediaSource.Factory(DefaultDataSourceFactory(context, BuildConfig.USER_AGENT_VALUE))\r\n.createMediaSource(Uri.parse(\"android.resource://com.dionata.player.dev/raw/video.mp4\"))\r\n```\r\n"
      },
      {
        "user": "DionataFerraz",
        "created_at": "2019-01-04T15:33:06Z",
        "body": "if I try with the Android VideoView I can play the video using that path\r\n`android.resource://com.video.player.dev/raw/video`\r\n\r\nI'm using version 2.9.3"
      },
      {
        "user": "andrewlewis",
        "created_at": "2019-01-04T15:37:03Z",
        "body": "If it's stored as a resource rather than an asset then try `RawResourceDataSource.buildRawResourceUri(R.raw.video)`."
      },
      {
        "user": "DionataFerraz",
        "created_at": "2019-01-04T15:55:23Z",
        "body": "Thanks\r\nI did it here and it worked.\r\n```\r\nExtractorMediaSource.Factory(DefaultDataSourceFactory(context, BuildConfig.USER_AGENT_VALUE))\r\n                .createMediaSource(RawResourceDataSource.buildRawResourceUri(R.raw.videog))\r\n```\r\n\r\nThank you very much\r\n"
      }
    ]
  },
  {
    "number": 5282,
    "title": "How to create AudioProcessor to boost volume",
    "created_at": "2018-12-19T20:32:09Z",
    "closed_at": "2019-01-02T14:07:15Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/google/ExoPlayer/issues/5282",
    "body": "I read issues #3657 where @andrewlewis  is saying that to increase volume above normal limits  one should implement custom AudioProcessor.\r\n\r\nI've made couple of test, but not sure how to implement it, key problem is that input PCM data (16 bit PCM) into my AudioProcessor are already normalized to 16 bit range (so values are already in range 32768 - 32767) , so there is no space to increase amplitude more.\r\n\r\nI tried to change output encoding to PCM 32 bits to have some space for increase, but then got unhanded configuration exception \r\n\r\n(And generally it looks like only PCM 16 bit is supported.\r\nCustom AudioProcessors seem to be used before standard processors - especially SilenceSkippingAudioProcessor, which requires PCM 16 bit as it's input -  so I guess if I'll change resolution to 24 or 32 bits it'll not be working.)\r\n\r\nCan you provide bit more detailed advice how to implement AudioProcessor to boost volume? Or is there any other trick I can use? Any ideas are welcomed.\r\nThanks",
    "comments_url": "https://api.github.com/repos/google/ExoPlayer/issues/5282/comments",
    "author": "izderadicka",
    "comments": [
      {
        "user": "izderadicka",
        "created_at": "2018-12-23T18:25:08Z",
        "body": "I've made another attempt - now going to platform LoudnessEnhancer AudioEffect, which will be applied after exoplayer AudioProcessors.    I have simple code below plugged to player\r\n```kotlin\r\nprivate class VolumeBooster(enabled: Boolean): AudioListener {\r\n    var enabled: Boolean = false\r\n        set(value) {\r\n            field = value\r\n            this.booster?.apply {\r\n                enabled = value\r\n            }\r\n        }\r\n    private var booster: LoudnessEnhancer? = null\r\n    init {\r\n        this.enabled = enabled\r\n    }\r\n    override fun onAudioSessionId(audioSessionId: Int) {\r\n        Log.d(LOG_TAG, \"Audio session id is ${audioSessionId}, supported gain ${LoudnessEnhancer.PARAM_TARGET_GAIN_MB}\")\r\n        booster?.release()\r\n        booster = LoudnessEnhancer(audioSessionId)\r\n        booster?.apply {\r\n            this@VolumeBooster.enabled\r\n            setTargetGain(3000)\r\n        }\r\n\r\n    }\r\n\r\n}\r\n```\r\n\r\nand it's plugged to player like this:\r\n```kotlin\r\nvolumeBooster = VolumeBooster(boostEnabled)\r\nplayer.audioComponent?.addAudioListener(volumeBooster)\r\n```\r\n\r\nBut this also does not work - the result is that track in initially boosted for second or two (but not always) and  then volume returns to normal level.  Not sure why this is happening.\r\n\r\nSo I'd welcome any ideas, experiences in this area, as it's hard to find any reliable information. Thanks."
      },
      {
        "user": "izderadicka",
        "created_at": "2019-01-02T10:23:57Z",
        "body": "Any ideas anybody?  I'm stuck on what I described above. Thanks"
      },
      {
        "user": "andrewlewis",
        "created_at": "2019-01-02T11:04:51Z",
        "body": "Regarding using audio processing for this: #3657 is about amplifying quiet sources rather than increasing volume beyond \"normal limits\" so perhaps not relevant to what you're trying to do. I don't think the bit depth of the PCM audio is going to make a difference to the audio volume. If your audio is already at full volume I wonder if you can do a non-linear transformation that still boosts volume for quite sections, but this may cause distortion!\r\n\r\nFor the loudness enhancer approach: in the code snippet above does the new `LoudnessEnhancer` actually get stored in the field? I vaguely recall a problem when trying to use audio effects previously where the effect was getting garbage collected unless I kept a reference to it."
      },
      {
        "user": "izderadicka",
        "created_at": "2019-01-02T13:03:23Z",
        "body": "@andrewlewis - Thanks that might be it! I did not notice that I used local var instead of field. Will check."
      },
      {
        "user": "izderadicka",
        "created_at": "2019-01-02T14:07:15Z",
        "body": "@andrewlewis - this was it - thanks a million. What a stupid error, I indeed wantedit  to be field of my class, just put there val by mistake and was it. Poor `LoudnessEnhancer` got shredded. I updated the code above to correct one, if someone in future has similar question."
      }
    ]
  },
  {
    "number": 5267,
    "title": "How can I switch the video that I just add to the concatenatingmediasource while the exoplay is runing?",
    "created_at": "2018-12-18T01:41:52Z",
    "closed_at": "2019-01-18T17:49:34Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/google/ExoPlayer/issues/5267",
    "body": "How can I switch the video that I just add to the concatenatingmediasource while the exoplay is runing?\r\nCan make it whihout reprepare the player?",
    "comments_url": "https://api.github.com/repos/google/ExoPlayer/issues/5267/comments",
    "author": "qjh5606",
    "comments": [
      {
        "user": "tonihei",
        "created_at": "2018-12-18T09:20:36Z",
        "body": "If I understand your question correctly, you just need to seek to the new window after it has been added.\r\nYou can use the `Runnable` in `addMediaSource` to run something immediately after the source has been added:\r\n```\r\nconcatenatingMediaSource.addMediaSource(\r\n    newIndex, newMediaSource, () -> player.seekToDefaultPosition(newIndex));\r\n```"
      },
      {
        "user": "qjh5606",
        "created_at": "2018-12-18T09:48:33Z",
        "body": "> If I understand your question correctly, you just need to seek to the new window after it has been added.\r\n> You can use the `Runnable` in `addMediaSource` to run something immediately after the source has been added:\r\n> \r\n> ```\r\n> concatenatingMediaSource.addMediaSource(\r\n>     newIndex, newMediaSource, () -> player.seekToDefaultPosition(newIndex));\r\n> ```\r\n\r\nThank you very much. It seems solve my problem."
      },
      {
        "user": "qjh5606",
        "created_at": "2018-12-20T01:05:44Z",
        "body": "@tonihei \r\nwhen I call the\r\n`concatenatingMediaSource.addMediaSource(\r\n    newIndex, newMediaSource, () -> player.seekToDefaultPosition(newIndex));`\r\non the `onPositionDiscontinuity` \r\n\r\nThe screen will be black for a short time then it start to play the MediaSource that I just added.\r\nHow can I fix the  black problem?\r\n\r\nHere's what I do on  onPositionDiscontinuity:\r\n\r\n` \r\nplayer.addListener(new Player.EventListener() {\r\n      @Override\r\n      public void onPositionDiscontinuity(int reason) {\r\n        int latestWindowIndex = player.getCurrentWindowIndex();\r\n        if (latestWindowIndex != lastWindowIndex) {\r\n          // item selected in playlist has changed, handle here\r\n          lastWindowIndex = latestWindowIndex;\r\n\r\n          String addString=null;\r\n          addString = new String(\"/storage/emulated/0/Download/3D_Rio_shark.MP4\");\r\n          MediaSource addMediaSource = buildMediaSource(Uri.parse(addString));\r\n\r\n          int Size = mediaSource.getSize();\r\n          mediaSource.addMediaSource(lastWindowIndex, addMediaSource, new Runnable() {\r\n            @Override\r\n            public void run() {\r\n              player.seekToDefaultPosition(lastWindowIndex);\r\n            }\r\n          });\r\n        }\r\n      }\r\n    });\r\n`\r\n\r\n\r\n\r\n"
      },
      {
        "user": "tonihei",
        "created_at": "2018-12-21T13:19:08Z",
        "body": "The black screen is visible because you seek to another source and the content needs to buffer first before we can continue playback. What would you expect to be visible during that time?"
      },
      {
        "user": "qjh5606",
        "created_at": "2018-12-21T13:26:56Z",
        "body": "@tonihei \r\nIt would be very nice if the screen render the previous MediaSource's last frame which make it seamless/gapless visually."
      },
      {
        "user": "tonihei",
        "created_at": "2018-12-21T14:03:32Z",
        "body": "> previous MediaSource's last frame\r\n\r\nIf you seek after receiving a `onPositionDiscontinuity` event, you are already in a new media source and the frame that could potentially be displayed is the first frame in the media source which is not going to be played, but that doesn't seem to make much sense.\r\n\r\nIf your intention is to play this new item after the previous one (which played before receiving the `onPositionDiscontinuity` event), then you should probably insert the new source after this item and just let playback proceed automatically? "
      },
      {
        "user": "tonihei",
        "created_at": "2018-12-21T14:24:44Z",
        "body": "Can you try setting the `keep_content_on_player_reset` property of the `PlayerView` to true (or call `PlayerView.setKeepContentOnPlayerReset(true)`). That may help to keep the previous frame visible. "
      },
      {
        "user": "tonihei",
        "created_at": "2018-12-21T14:31:41Z",
        "body": "Reopened to track improving documentation for this method. "
      },
      {
        "user": "tonihei",
        "created_at": "2019-01-18T17:49:34Z",
        "body": "Closing as docs have been improved."
      }
    ]
  },
  {
    "number": 5175,
    "title": "[Question] Custom implementation for raw H.264 Annex B support",
    "created_at": "2018-11-29T23:45:12Z",
    "closed_at": "2018-12-04T19:49:45Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/google/ExoPlayer/issues/5175",
    "body": "#### Scenario\r\nWe are opening a web socket to our backend which is providing a raw H.264 stream. The backend is already splitting the stream into NAL units, so the messages we receive through the socket are already properly split at the NAL headers (0x00000001). What we are trying to do is create custom components that will enable ExoPlayer to play our stream.\r\n\r\n#### What We've Tried\r\nWe did some research and found that #3503 is similar to our situation. Following the advice there, we have successfully created a `DataSource` which wraps a web socket and is receiving the NAL units. We also created an `Extractor` that is modeled after the `Ac3Extractor` but uses an `H264Reader`, as suggested by the previously mentioned issue. Our `Extractor` is receiving the bytes from the `DataSource` and passing them to `H264Reader.consume(ParsableByteArray)`.\r\n\r\n#### Our Problem\r\nAfter finding the first SPS, PPS, and IDR NAL units, the player plays a single frame, but that is all. The `DataSource` and `Extractor` keep running and receiving bytes, but it seems the `H264Reader` is failing to work. Issue #3503 states there are \"...a few more details to work out, like how to set timing information on output samples.\" We believe our issue relates to these \"details\" but are unsure what these details are. We have tried calling `H264Reader.packetStarted(Long, Boolean)` but that doesn't seem to do anything, so we may be dong it incorrectly. What are these \"details\" and how should we go about implementing them?\r\n\r\nI can provide code samples as well as samples of our byte stream if that would be helpful. Looking forward to hearing back!",
    "comments_url": "https://api.github.com/repos/google/ExoPlayer/issues/5175/comments",
    "author": "TroyStopera",
    "comments": [
      {
        "user": "andrewlewis",
        "created_at": "2018-11-30T09:00:48Z",
        "body": "`packetStarted` sets the presentation timestamp for the next NAL unit started from `consume`. I don't think you get timing information in the Annex B bytestream, so you probably need to get frame timestamps from some other source (e.g., by assuming a constant frame rate). If you don't do this all the samples will end up with timestamp 0. If your stream doesn't have access unit delimiters you will need to set the `detectAccessUnits` flag to true at construction time.\r\n\r\nI think a good step to debugging this is to set a breakpoint at the call to `sampleMetadata` and check that the sample timestamps and sizes look correct."
      },
      {
        "user": "TroyStopera",
        "created_at": "2018-11-30T17:59:36Z",
        "body": "Thanks for the quick reply!\r\n\r\nI have tried what you suggested. At the breakpoint, the timestamp appears to be accurate, and the size of the NAL unit is correct as well. Our stream doesn't have access unit delimiters so I set `detectAccessUnits` to true. \r\n\r\nHowever, the video is still not playing. The `currentPosition` of the `ExoPlayer` instance is counting up correctly, but still only one frame is playing, then nothing else."
      },
      {
        "user": "andrewlewis",
        "created_at": "2018-11-30T18:04:00Z",
        "body": "In `MediaCodecRenderer.feedInputBuffer` you can check that the buffers are being queued to the decoder as expected, and in `MediaCodecVideoRenderer.processOutputBuffer` you can see how the output is being handled."
      },
      {
        "user": "TroyStopera",
        "created_at": "2018-12-04T19:49:45Z",
        "body": "I followed your advice and put some debug print statements in those methods. It turns out that we were using `H264Reader.packetStarted(Long, Boolean)` incorrectly. We were passing a timestamp, which was increased with each successive packet, but it turns out we needed to start at 0 rather than the actual timestamp of the video. Once we did this the video began playing correctly. \r\n##### For future people running into similar issues, make sure to start your first packet at 0. "
      },
      {
        "user": "tishion",
        "created_at": "2018-12-10T05:32:17Z",
        "body": "@TroyStopera  I have a question for implementation of Extractor, you said you used H264Reader but I don't know how to construct the H264Reader instance. Where to get the SeiReader?"
      },
      {
        "user": "TroyStopera",
        "created_at": "2019-02-22T04:15:38Z",
        "body": "@tishion Sorry for only just seeing this. I started by using reflection to get an instance (not my favorite, but it worked). I ended up, however, copying the code from `H264Reader`'s source and adapting it to my needs. Our stream has no SEI data, so in my custom implementation I just did away with the `SeiReader`."
      },
      {
        "user": "tishion",
        "created_at": "2019-02-22T05:44:52Z",
        "body": "@TroyStopera  thanks for replying. I finally gave up the extractor implementation. and I just construct the FLV stream with the raw H264 data and fill this stream to Exoplayer."
      }
    ]
  },
  {
    "number": 4971,
    "title": "Getting the resolution(1080p,430p etc) when a video is played in \"AUTO\" in quality",
    "created_at": "2018-10-17T08:46:23Z",
    "closed_at": "2018-10-17T11:36:20Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/google/ExoPlayer/issues/4971",
    "body": "Is there a way in which we can show the resolution when auto is selected in quality.I just want to show if auto is selected the resolution its selecting to play the video\r\n\r\n",
    "comments_url": "https://api.github.com/repos/google/ExoPlayer/issues/4971/comments",
    "author": "meenukrishnamurthy",
    "comments": [
      {
        "user": "tonihei",
        "created_at": "2018-10-17T08:51:45Z",
        "body": "Please add a `VideoListener` to `SimpleExoPlayer.addVideoListener`. The callback `onVideoSizeChanged` notifies you when the currently displayed size changes. \r\n\r\nIf you need the `Format` object of the selected quality, please add an `AnalyticsListener` and listen to `onDownStreamFormatChanged` which is similar but gives you the `Format` object and selection reason and other data."
      },
      {
        "user": "meenukrishnamurthy",
        "created_at": "2018-10-17T09:23:21Z",
        "body": "I am actually using an older fork.Have added exoplayer as library in my app.There is no analytics listener in it.I just want to know which track is being selected while playing Auto.My video format is HLS"
      },
      {
        "user": "tonihei",
        "created_at": "2018-10-17T09:30:25Z",
        "body": "You can use `addVideoDebugListener` on older versions with the same callback. \r\n\r\nNote that for HLS specifically, the `Format` reported in `onDownStreamFormatChanged` may include both video and audio if they are muxed together. In this case you'll only get the actual video size when listening to `onVideoSizeChanged`. Depends on what information you need."
      },
      {
        "user": "meenukrishnamurthy",
        "created_at": "2018-10-17T11:36:20Z",
        "body": "thanks i used onVideoSizeChanged.Its working"
      }
    ]
  },
  {
    "number": 4913,
    "title": "Sound stop after a while when looping",
    "created_at": "2018-10-04T23:34:08Z",
    "closed_at": "2018-10-11T08:15:49Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/google/ExoPlayer/issues/4913",
    "body": "### Issue description\r\n\r\nUsing ExoPlayer 2.8.2 to play a local .m4a sound file in repeat mode, the sound stop after a while (typically a couple of hours). If playing several files simultaneously, each file stop at a different time. No error is reported in neither the player event listener nor the media source event listener.\r\n\r\nThe error occurs with both `player.setRepeatMode(Player.REPEAT_MODE_ALL);` or by using a LoopingMediaSource object.\r\n\r\nWhen the audio stop, the following lines appears in Logcat:\r\n    1536-1577/? I/AudioFlinger: BUFFER TIMEOUT: remove(4096) from active list on thread 0xf1203680\r\n    1430-1578/? W/audio_hw_generic: Not supplying enough data to HAL, expected position 942828484 , only wrote 934428960\r\n\r\ntoggling player.setPlayWhenReady(...) does not restore the playback.\r\n\r\nWe didn't notice this issue (and none of our users complain) with the previous version of ExoPlayer we were using: r2.4.1. Unfortunately it is not possible to roll back as an audio glitch was audible at the end of each loop.\r\n\r\n### Reproduction steps\r\n\r\nThe following code is running in a service:\r\n\r\n```\r\n...\r\ndataSourceFactory = new DefaultDataSourceFactory(context, Util.getUserAgent(context, \"XXXX\"), null);\r\nplayer = ExoPlayerFactory.newSimpleInstance(context, new DefaultTrackSelector());\r\nMediaSource audioSource = new ExtractorMediaSource.Factory(dataSourceFactory).createMediaSource(audioItem.getUri());\r\nplayer.setRepeatMode(Player.REPEAT_MODE_ALL);\r\nplayer.prepare(audioSource);\r\n...\r\nplayer.setPlayWhenReady(true);\r\n```\r\n\r\nWait until the sound stops\r\n\r\n### Link to test content\r\nSent by email\r\n\r\n### Version of ExoPlayer being used\r\n2.8.2\r\n\r\n### Device(s) and version(s) of Android being used\r\nPixel XL simulator with Android Oreo 8.1\r\nSome of our users complained about the same issue on different devices.\r\n\r\n### A full bug report captured from the device\r\nSent by email\r\n\r\n",
    "comments_url": "https://api.github.com/repos/google/ExoPlayer/issues/4913/comments",
    "author": "retameur",
    "comments": [
      {
        "user": "andrewlewis",
        "created_at": "2018-10-05T14:20:06Z",
        "body": "I couldn't see any obvious issues with the media or in the bug report.\r\n\r\nPlease could you try to reproduce this in the ExoPlayer demo app, but modified to set repeat mode, and on a physical device rather than using the emulator? If you can reproduce it please send the bug report. If not, that suggests there's something wrong with the service (perhaps a leak or not holding locks required to keep the device awake). Thanks."
      },
      {
        "user": "andrewlewis",
        "created_at": "2018-10-05T16:31:48Z",
        "body": "I think the issue here is that there's a discrepancy between the duration declared in the MP4 container metadata and the actual duration of audio after applying the iTunSMPB trimming for gapless playback. I think the actual duration is 18955260 us (this is the declared duration 19017142 us, which is the duration of audio before trimming, minus the duration of 2112 + 617 audio frames at 44.1 kHz, which are trimmed). This discrepancy causes the renderer position to drift slowly away from the expected position based on the durations of earlier loops, until the player stops loading because it permanently thinks it has enough data buffered, at which point audio runs out.\r\n\r\nIf you have control over the media you may be able to fix the issue by rewriting the duration in the container to take into account trimmed frames, or possibly switching to using edit lists to signal gapless trimming.\r\n\r\nThe next steps here are to verify the hypothesis by hardcoding the calculated duration and verifying that playback doesn't get stuck, then possibly altering the extractor to update the duration to compensate for audio frames trimmed based on iTunSMPB metadata."
      },
      {
        "user": "retameur",
        "created_at": "2018-10-10T17:53:38Z",
        "body": "I have been able to reproduce the bug with ExoPlayer Demo 2.8.4 (report sent by email). The playback stops after the same number of loops (which varies with each specific sound file) as in our app. Its 241 for the frogs.m4a file I've sent by email.\r\n\r\nWe have control over the media, but it is not a solution for us, as the same media are also used for iOS and the Web. And most of the current users have already downloaded the files.\r\n\r\nI'm not sure it is related to the iTunSMPB metatag. I've re-encoded the file twice using fdkaac:\r\n    - once with the --gapless-mode option set to 0 (iTunSMPB)\r\n    - once with the option set to 1: ISO standard (edts and sgpd)\r\nThe playback of both files fails simultaneously.\r\n\r\nAs for the steps you are suggesting verifying the hypothesis, I have no idea how to do so."
      },
      {
        "user": "retameur",
        "created_at": "2018-10-10T19:26:54Z",
        "body": "I have also tested with ExoPlayer demo 2.9.0 and the bug seems to be fixed now (if it still occurs, it is after way more loops). So problem solved. \r\n\r\nThanks for your help."
      },
      {
        "user": "tonihei",
        "created_at": "2018-10-11T08:15:49Z",
        "body": "Yes, it was fixed by a change in 2.9.0 which prevents the problem you describe. Still, if you want perfect gapless playback of the looped file, you should try to ensure the duration exactly matches the content."
      }
    ]
  },
  {
    "number": 4843,
    "title": "How to seperate default time bar",
    "created_at": "2018-09-20T06:25:44Z",
    "closed_at": "2018-09-20T07:41:27Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/google/ExoPlayer/issues/4843",
    "body": "hi there, i am looking for default time bar separated even though i make media source ConcatenatingMediaSource. For example, like play music list supposed current bar show only time of current music play instead of combine them all together in on line timeba.",
    "comments_url": "https://api.github.com/repos/google/ExoPlayer/issues/4843/comments",
    "author": "hafiz013",
    "comments": [
      {
        "user": "andrewlewis",
        "created_at": "2018-09-20T07:41:27Z",
        "body": "The default behavior is to show each song separately (one at a time). If you call `playerView.setShowMultiWindowTimeBar(true)` then the time bar will show the concatenation of the songs as if they were one long track, but see also #4727 for limitations of this."
      },
      {
        "user": "hafiz013",
        "created_at": "2018-09-25T09:47:48Z",
        "body": "so in that case how to play next media source programmatically in stead of next button from controller."
      },
      {
        "user": "andrewlewis",
        "created_at": "2018-09-25T10:08:25Z",
        "body": "Is this the same as #4863 or a different question? If you pass the player a concatenation it should advance automatically from one item to the next."
      },
      {
        "user": "hafiz013",
        "created_at": "2018-09-26T02:29:12Z",
        "body": "different question.playerView.setShowMultiWindowTimeBar(false) make time bar separated media source even though already concatenation. thank for info."
      }
    ]
  },
  {
    "number": 4836,
    "title": "VP9 ext crash from libvpx 1.7.0",
    "created_at": "2018-09-18T10:53:04Z",
    "closed_at": "2018-09-23T15:17:10Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/google/ExoPlayer/issues/4836",
    "body": "It seems libvpx 1.7.0 has more neon code added. There was error when I run config. By adding -mfloat-abi=softfp -mfpu=neon to cflag, I have managed to get the so file compiled. However, after the first frame is decoded, the sample app always crashes with: \r\n\r\ncom.google.android.exoplayer2.demo A/libc: Fatal signal 11 (SIGSEGV), code 1, fault addr 0x10 in tid 18160 (Thread-1825)\r\n\r\nMy ExoPlayer version is 2.8.2. The working libvpx is 1.6.2, which is from Jan 2017.",
    "comments_url": "https://api.github.com/repos/google/ExoPlayer/issues/4836/comments",
    "author": "blueslabs",
    "comments": [
      {
        "user": "andrewlewis",
        "created_at": "2018-09-21T16:32:42Z",
        "body": "I think the errors that occur during configuration might not actually be problematic. What do you see if you just ignore the errors during configuration? I tried building with libvpx 1.7.0, ignoring the errors and playing a video with the vp9 extension and it worked."
      },
      {
        "user": "blueslabs",
        "created_at": "2018-09-22T18:53:46Z",
        "body": "Thanks! Did a clean build, it works now. -mfloat-abi=softfp -mfpu=neon is actually only required for the current master, otherwise build can fail. 1.7.0 can build without this."
      }
    ]
  },
  {
    "number": 4802,
    "title": "Question: Analytics Listener Play Status + Detect Replay",
    "created_at": "2018-09-11T13:39:22Z",
    "closed_at": "2018-09-13T17:04:00Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/google/ExoPlayer/issues/4802",
    "body": "Using: Exoplayer 2.8.4\r\n\r\nI am trying to implement some tracking from our analytics team, and there are two tracking events that I'm having trouble finding a way to track through the Analytics Listener.\r\n\r\nFirstly, is it possible to detect replays if the video is set to loop when it completes? I tried to listen to:\r\n\r\n```\r\noverride fun onPlayerStateChanged(\r\n        eventTime: AnalyticsListener.EventTime?,\r\n        playWhenReady: Boolean,\r\n        playbackState: Int\r\n    )\r\n```\r\n\r\nbut it doesn't appear as though this event is fired with state ENDED (or anything for that matter) when the video replays.\r\n\r\nSecondly, we would like to track how far into a video a user has watched at certain intervals (e.g. 1s, 5s, 10s, 30s). Is it possible to receive callbacks at certain points in the media's playback? As far as I can see, there's no way to receive callbacks once every second or so. I was thinking that I could implement this via a timer that runs alongside the video, but the problem with that approach is that the second the video has to spend time buffering or the user has seeked, the timer will no longer be accurate to the actual video position.\r\n\r\nThanks",
    "comments_url": "https://api.github.com/repos/google/ExoPlayer/issues/4802/comments",
    "author": "ghost",
    "comments": [
      {
        "user": "tonihei",
        "created_at": "2018-09-11T13:50:27Z",
        "body": "For looping (\"replay\"), you should receive a `onPositionDiscontinuity` event with reason `DISCONTINUITY_REASON_PERIOD_TRANSITION`.\r\n\r\nFor the regular timer, you can either:\r\n- Call a Handler method in regular intervals (every x seconds in real time) and then check the current position with `player.getCurrentPosition()`.\r\n- Or send messages at pre-defined media positions. You can do that by calling `player.createMessage(messageHandler).setPosition(position).setHandler(appHandler).send()`. You may also want to add `setDeleteAfterDelivery(false)` to resend the message even if the user seeks back."
      },
      {
        "user": "ghost",
        "created_at": "2018-09-11T18:49:50Z",
        "body": "The replay check you mentioned does work, so thank you.\r\n\r\nI've done the below for play time tracking and it doesn't ever seem to fire back to the message target. In the below, `recordPlayTime` is never called.\r\n\r\n```\r\nprivate fun createMessageAtPosition(videoPlayer: SimpleExoPlayer, position: Int, handler: Handler) {\r\n        val positionInMilliseconds = position.toLong() * 1000\r\n        Log.v(TAG, \"createMessageAtPosition, Adding message at ${positionInMilliseconds}ms\")\r\n        videoPlayer.createMessage { _: Int, _: Any -> recordPlayTime(position) }\r\n            .setPosition(positionInMilliseconds)\r\n            .setDeleteAfterDelivery(false)\r\n            .setHandler(handler)\r\n            .send()\r\n    }\r\n\r\n    private fun recordPlayTime(position: Int) {\r\n        analyticsLogger.playTime(position)\r\n    }\r\n```\r\n"
      },
      {
        "user": "tonihei",
        "created_at": "2018-09-13T11:13:18Z",
        "body": "I just tried and added the following lines to our demo app:\r\n```\r\nplayer\r\n    .createMessage((type, payload) -> Log.d(\"POSITION\", \"message triggered at 5 seconds.\"))\r\n    .setPosition(5000)\r\n    .setDeleteAfterDelivery(false)\r\n    .setHandler(new Handler())\r\n    .send();\r\n```\r\nThis works fine and logs the message every time I play past the 5 second mark. Can you check what is different in your app? Especially whether the position is actually in milliseconds."
      },
      {
        "user": "ghost",
        "created_at": "2018-09-13T17:04:00Z",
        "body": "For some reason, this started working after I forced the handler to and message to be created on the main thread. Unsure of why exactly that worked, since technically the UI should only be created on the main thread. \r\n\r\nAlso worth noting: PlayerMessage.Target is missing nullity parameters and Kotlin incorrectly assumes these fields will be non-null, which caused a crash since payload is null\r\n\r\n```\r\npublic interface Target {\r\n    void handleMessage(int messageType, Object payload) throws ExoPlaybackException;\r\n  }\r\n```\r\n\r\nThank you for your help, closing."
      },
      {
        "user": "tonihei",
        "created_at": "2018-09-14T13:22:55Z",
        "body": "Thanks for noting the missing annotations! We'll add them to the PlayerMessage class."
      }
    ]
  },
  {
    "number": 4692,
    "title": "Does onTracksChanged gets called when video track changes due to ABR ?",
    "created_at": "2018-08-20T13:03:25Z",
    "closed_at": "2018-08-21T14:19:02Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/google/ExoPlayer/issues/4692",
    "body": "onTracksChanged is not getting called when video changes due to ABR. I tried getting updated track using `getCurrentTrackSelections`, but it is not returning updated list.\r\n\r\n`player.getVideoFormat()` is giving right format selected, but has incorrect values about bitrate.\r\nexample -  getting bitrate as -1, track id is wrong.\r\n\r\nWhat is the best way to get notified and get all track related info when video track changes.",
    "comments_url": "https://api.github.com/repos/google/ExoPlayer/issues/4692/comments",
    "author": "sravan1213",
    "comments": [
      {
        "user": "ojw28",
        "created_at": "2018-08-21T13:57:11Z",
        "body": "`onTracksChanged` only gets called when the available tracks change, not when the adaptive selection changes. You should use `getVideoFormat`. You can also register an `AnalyticsListener` that overrides `onDecoderInputFormatChanged` to be notified when a change occurs.\r\n\r\nYou should see the bitrate and track id set correctly for DASH and SmoothStreaming adaptive playbacks. HLS we made some recent improvements in how this information is propagated, so you may have to try the `dev-v2` branch and/or wait for the 2.9.x release. Please give that a try and let us know if you're still not seeing the data you expect."
      },
      {
        "user": "tonihei",
        "created_at": "2018-08-21T14:05:56Z",
        "body": "Just to add to this, you may prefer to use `onVideoSizeChanged` which gives the selected video format specifically. That makes a difference if using HLS and `onDecoderInputFormatChanged` has a muxed audio and video format."
      },
      {
        "user": "sravan1213",
        "created_at": "2018-08-21T14:19:02Z",
        "body": "@ojw28 @tonihei thanks for the help.\r\nIt is working as expected in `dev-v2` for both HLS and DASH streams."
      }
    ]
  },
  {
    "number": 4613,
    "title": "Order of execution of listeners",
    "created_at": "2018-08-02T23:43:17Z",
    "closed_at": "2018-08-16T20:57:30Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/google/ExoPlayer/issues/4613",
    "body": "Hi,\r\n\r\nI am using ExoPlayer 2.8.2 release and trying to implement a feature where I want to use the bandwidth measurement from the latest video segment download to influence the quality of the next segment. This is for Dash videos.\r\nI have extended trackSelection to `CustomTrackSelection` object. But, the problem on several occasions, by the time the `DefaultDashChunkSource` calls `updateSelectedTrack` function, the previous download end event hasn't been processed by my `listener` and I haven't had a chance to register the latest throughput sample. \r\nI guess what's happening is that the `onLoadCompleted` event is processed by `ChunkSampleStream` and it proceeds with the next download start _before_ my listener is invoked.\r\nIs there any way to get around this? Is there any way I can \"wait\" before downloading the next segment if my listener hasn't registered the download end event?\r\n\r\nThanks for your attention and help! I appreciate any pointers.",
    "comments_url": "https://api.github.com/repos/google/ExoPlayer/issues/4613/comments",
    "author": "kanthicn1",
    "comments": [
      {
        "user": "erdemguven",
        "created_at": "2018-08-07T08:52:12Z",
        "body": "Why don't you use AdaptiveTrackSelection? It already selects tracks according to bandwidth measurement. "
      },
      {
        "user": "kanthicn1",
        "created_at": "2018-08-09T18:58:46Z",
        "body": "Fair enough @erdemguven . Sorry for not writing the complete problem. I don't want to use `AdaptiveTrackSelection` because I want to use my own track selection logic which doesn't quite agree with what `AdaptiveTrackSelection` is doing. Also, the `DefaultBandwidthMeter`, which is used by `AdaptiveTrackSelection`,  gives a  \"SlidingPercentile\" estimate of bandwidth while I want the last instantaneous value of the bandwidth measurement. \r\nOne approach that might actually work for my case is to use a different bandwidth meter instead of relying on throughput measurements from listeners.\r\n\r\n(a) implement `CustomBandwidthMeter` and pass that to the `buildDataSourceFactory` and `customTrackSelection`. -- this is so that my `CustomBandwidthMeter` can expose the last instantaneous measurement of bandwidth sample.\r\n(b) Query the `CustomBandwidthMeter` for the latest throughput sample from `CustomTrackSelection` and use it in my track selection logic.\r\n\r\nMy question is: in the above logic, is there a chance that I might not get the latest throughput sample due to race conditions in event processing? i.e., Is the `DataSourceFactory` guaranteed to update the bandwidth sample before `CustomTrackSelection` is called for picking the quality for the next segment to be loaded?"
      },
      {
        "user": "erdemguven",
        "created_at": "2018-08-16T20:49:57Z",
        "body": "@ojw28 could you look at this?"
      },
      {
        "user": "ojw28",
        "created_at": "2018-08-16T20:57:30Z",
        "body": "> My question is: in the above logic, is there a chance that I might not get the latest throughput sample due to race conditions in event processing? i.e., Is the DataSourceFactory guaranteed to update the bandwidth sample before CustomTrackSelection is called for picking the quality for the next segment to be loaded?\r\n\r\nThere is a guarantee, which is that the `TransferListener.onTransferEnd` call corresponding to a chunk will always be called before `TrackSelection.updateSelectedTrack` is called to pick the quality for the next chunk. Note that `DefaultBandwidthMeter` updates its bitrate estimate in `onTransferEnd`, and `AdaptiveTrackSelection` gets the bitrate estimate in `TrackSelection.updateSelectedTrack`. Hence it's guaranteed that the updated bitrate estimate is used.\r\n\r\nSo in short, as long as you follow the same model in your custom components (albeit changing the actual logic for estimating the bitrate and/or choosing the track), then you'll get the same guarantee, which I think is what you want."
      },
      {
        "user": "kanthicn1",
        "created_at": "2018-08-16T21:03:35Z",
        "body": "Perfect. Thanks @ojw28 and @erdemguven. "
      }
    ]
  },
  {
    "number": 4547,
    "title": "getWindowIndex() sometime is delay",
    "created_at": "2018-07-22T15:50:48Z",
    "closed_at": "2018-07-23T09:44:13Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/google/ExoPlayer/issues/4547",
    "body": "//Version\r\n2.7.3\r\n\r\n//Description\r\nI'm using ClippingMediaSource and DynamicConcatenatingMediaSource to play multiple video clips, and i need to know the current index of window when onVideoSizeChanged callback, but i found sometime the index is not correct because onPositionDiscontinuity->DISCONTINUITY_REASON_PERIOD_TRANSITION is later than  onVideoSizeChanged.\r\nso i getWindowIndex() is an un correct index.\r\n\r\nMy question is how to get exact window index when onVideoSizeChanged?\r\n",
    "comments_url": "https://api.github.com/repos/google/ExoPlayer/issues/4547/comments",
    "author": "RuijiePan",
    "comments": [
      {
        "user": "tonihei",
        "created_at": "2018-07-23T08:28:45Z",
        "body": "What you describe is basically working as intended. The reason is that these two event (onVideoSizeChanged and onPositionDiscontinuity) belong to different listeners and our listeners are not synchronized to each other for various reasons.\r\n\r\nHowever, we recently added the `AnalyticsListener` class which combines all listeners we have in one place and gives additional information for each event (including which window they belong to). This new listener has been added in 2.8.0. The easiest way to use it is with `SimpleExoPlayer.addAnalyticsListener`. "
      },
      {
        "user": "RuijiePan",
        "created_at": "2018-07-23T09:43:51Z",
        "body": "It's work, thank you very much!"
      }
    ]
  },
  {
    "number": 4490,
    "title": "IllegalStateException: Assertions.checkState When using same instance of SimpleCache",
    "created_at": "2018-07-10T07:59:00Z",
    "closed_at": "2018-07-10T09:06:39Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/google/ExoPlayer/issues/4490",
    "body": "Hi,\r\nI am getting the exception\r\n```\r\njava.lang.IllegalStateException\r\nat com.google.android.exoplayer2.util.Assertions.checkState(Assertions.java:81)\r\nat com.google.android.exoplayer2.upstream.cache.SimpleCache.getContentMetadata(SimpleCache.java:348)\r\nat com.google.android.exoplayer2.upstream.cache.SimpleCache.getContentLength(SimpleCache.java:335)\r\nat com.google.android.exoplayer2.upstream.cache.CacheUtil.getCached(CacheUtil.java:88)\r\n```\r\n when I'm trying to use the singleton instance of SimpleCache.\r\n```\r\ncompanion object DownloadCache {\r\n        private var downloadCache: Cache? = null\r\n        private var downloadDirectory: File? = null\r\n\r\n        @Synchronized\r\n        internal fun getDownloadCache(context: Context): Cache {\r\n            if (downloadCache == null) {\r\n                val downloadContentDirectory = File(getDownloadDirectory(context), \"cache\")\r\n                downloadCache = SimpleCache(downloadContentDirectory, NoOpCacheEvictor())\r\n            }\r\n            return downloadCache!!\r\n        }\r\n\r\n        private fun getDownloadDirectory(context: Context): File {\r\n            if (downloadDirectory == null) {\r\n                downloadDirectory = File(LogTrackUtil().getDir(context))\r\n                if (downloadDirectory == null) {\r\n                    downloadDirectory = context.filesDir\r\n                }\r\n            }\r\n            return downloadDirectory!!\r\n        }\r\n    }\r\n```\r\n\r\nI am checking the cached data for a particular URL.\r\nThe below code works perfectly for the first time but following calls to this code throws the exception.\r\n```\r\ndownloadCache = VideoPlayerUtil.getDownloadCache(mContext!!) as SimpleCache\r\nval uri = Uri.parse(mExercise?.fileUrl)\r\nval counters = CacheUtil.CachingCounters()\r\nCacheUtil.getCached(DataSpec(uri), downloadCache, counters)\r\n```\r\n\r\nWhat am I doing wrong?? Please help.",
    "comments_url": "https://api.github.com/repos/google/ExoPlayer/issues/4490/comments",
    "author": "joecizac",
    "comments": [
      {
        "user": "erdemguven",
        "created_at": "2018-07-10T09:06:39Z",
        "body": "Probably, you're releasing your singleton instance of SimpleCache (using SimpleCache.release() method) at some point and then try to reuse it. That's why it's throwing that exception.\r\n\r\nAs you use a singleton, I think you can just remove the call to release(). Otherwise you need to recreate another SimpleCache instance after release() call."
      },
      {
        "user": "joecizac",
        "created_at": "2018-07-10T09:09:20Z",
        "body": "Oh such a silly mistake.\r\nThank you so much"
      }
    ]
  },
  {
    "number": 4443,
    "title": "Adaptive track selection",
    "created_at": "2018-06-27T17:23:44Z",
    "closed_at": "2018-06-27T18:39:22Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/google/ExoPlayer/issues/4443",
    "body": "In class **DefaultTrackSelector** is method:\r\n\r\n```\r\nprivate static boolean isSupportedAdaptiveVideoTrack(\r\n      Format format,\r\n      @Nullable String mimeType,\r\n      int formatSupport,\r\n      int requiredAdaptiveSupport,\r\n      int maxVideoWidth,\r\n      int maxVideoHeight,\r\n      int maxVideoBitrate) {\r\n    return isSupported(formatSupport, false) && ((formatSupport & requiredAdaptiveSupport) != 0)\r\n        && (mimeType == null || Util.areEqual(format.sampleMimeType, mimeType))\r\n        && (format.width == Format.NO_VALUE || format.width <= maxVideoWidth)\r\n        && (format.height == Format.NO_VALUE || format.height <= maxVideoHeight)\r\n        && (format.bitrate == Format.NO_VALUE || format.bitrate <= maxVideoBitrate);\r\n  }\r\n```\r\n\r\nWhy there is ` isSupported(formatSupport, false)` with _false_ ? It does not respect params settings.",
    "comments_url": "https://api.github.com/repos/google/ExoPlayer/issues/4443/comments",
    "author": "pstambrecht",
    "comments": [
      {
        "user": "ojw28",
        "created_at": "2018-06-27T17:31:34Z",
        "body": "Is this in relation to `setExceedRendererCapabilitiesIfNecessary`? The purpose of that parameter is not to completely disable capabilities checks. It's to enable trying to play _something_ in the case all available options are deemed to exceed capabilities, where that _something_ is the lowest quality stream that exceeds capabilities. That does not happen as part of trying to make an adaptive selection, and hence passing `false` when trying to make the adaptive selection is the right thing to do.\r\n\r\nI guess we could provide an option to completely disable capabilities checks, if that's what you're after. To be enabled at your own risk ;)."
      },
      {
        "user": "pstambrecht",
        "created_at": "2018-06-27T18:07:42Z",
        "body": "@ojw28 Yes, it is in relation to `setExceedRendererCapabilitiesIfNecessary` So am I right that it's a protection not to play unsupported streams? But when I change it to `true` it works fine. So this protection does not work properly."
      },
      {
        "user": "ojw28",
        "created_at": "2018-06-27T18:15:51Z",
        "body": "The default is `exceedRendererCapabilitiesIfNecessary = true`, so changing it to true wont do anything. The parameter only has an effect if _all_ streams exceed renderer capabilities. In this case, if `exceedRendererCapabilitiesIfNecessary = true`, we'll try and play the lowest quality stream (i.e. the one that exceeds the capabilities by the least amount), in case the device has under-reported what it's actually capable of and can actually play the stream. If `exceedRendererCapabilitiesIfNecessary = false` then we wont try and play any stream.\r\n\r\nThe reason we default to `true` is that in practice we do see devices under-reporting capabilities (it's also not possible for a device to always get this exactly right ahead of seeing the bit-stream anyway), and the worst that normally happens is that playback fails, which isn't really any worse from the user's perspective compared to not trying in the first place. If you change the value to `false` then we'll not try and do this.\r\n\r\nI think we need to improve the Javadoc here (and in particular more clearly surface what all the defaults are). It's still an open question whether there's actually a feature request here. Is there something you want to do that's not currently possible, or were you just clarifying what the API is for?"
      },
      {
        "user": "pstambrecht",
        "created_at": "2018-06-27T18:20:45Z",
        "body": "Ok, I understand this. But my question was why there is hardcoded `false`. Without any chance to change it."
      },
      {
        "user": "pstambrecht",
        "created_at": "2018-06-27T18:22:18Z",
        "body": "@ojw28 I think javadoc is fine. Maybe it's my fault :)"
      },
      {
        "user": "ojw28",
        "created_at": "2018-06-27T18:39:22Z",
        "body": "It could be better ;). I think I've answered the question (i.e. it's working as intended, the flag is used elsewhere). So will close this but endeavor to improve the Javadoc regardless."
      }
    ]
  },
  {
    "number": 4349,
    "title": "Play/Pause button icons after end of file reached",
    "created_at": "2018-06-06T22:42:23Z",
    "closed_at": "2018-06-07T20:21:20Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/google/ExoPlayer/issues/4349",
    "body": "Hi\r\nI have simple exo player view which show video. After video end's play button showing pause icon. How i can refresh play button after end of video in my DefaultEventListener?\r\n\r\nThanks\r\n",
    "comments_url": "https://api.github.com/repos/google/ExoPlayer/issues/4349/comments",
    "author": "strikemansan",
    "comments": [
      {
        "user": "ojw28",
        "created_at": "2018-06-06T22:52:28Z",
        "body": "We do this automatically as of 2.7.0, so it's likely you're using an older version. I'd suggest you update to a newer version to get this behavior."
      },
      {
        "user": "strikemansan",
        "created_at": "2018-06-06T23:07:45Z",
        "body": "@ojw28 Thanks for you reply"
      }
    ]
  },
  {
    "number": 4217,
    "title": "Question on achieving a low latency HLS live stream",
    "created_at": "2018-05-07T20:54:04Z",
    "closed_at": "2018-05-11T13:57:35Z",
    "labels": [
      "question",
      "need more info"
    ],
    "url": "https://github.com/google/ExoPlayer/issues/4217",
    "body": "I'm using Exoplayer to play HLS live streams with a 30 sec window and 2 second segments, and I'am trying to optimize for low latency.\r\n\r\nEverything works great using all the default settings for `LoadControl` and the default `HlsExtractorFactory`, with playback starting 3 segments before the end of the window as expected. \r\n\r\nThe issue i'm seeing is when I'm on a good connection, I often get into a very short buffering states (around a second) after playing the stream for a few seconds.\r\n\r\nThis happens even more frequently if I lower the resolution of my stream to the lowest possible, and stay on a fast internet connection.\r\n\r\nAfter debugging what's happening, it looks like the renderers are asking for the next segment, but the backend hasn't made that next segment available yet. Almost as if the renderer is ahead of the backend, and when asking for more, instead of just waiting and continuing playback (there's still buffered data to be played), it immediately sets the player state to `Player.STATE_BUFFERING`, until the new segment is available.\r\n\r\nIf I set the stream to start further back in the window, say 4-5 segments from the edge, the problem disappears completely, and my buffer sizes stay healthy, but I obviously loose in latency.\r\n\r\nI'm surprised by this behavior as it seems like a common case for live HLS live streams to try to be as close as possible to the edge of the window.\r\n\r\nI'm trying to understand why I'm getting this behavior, and wondering if I'm missing a configuration setting on the client, or if it's something that needs to be tweaked on the backend.\r\n\r\nThanks in advance!\r\n\r\n### Version of ExoPlayer being used\r\n2.7.3\r\n\r\n### Device(s) and version(s) of Android being used\r\nGoogle Pixel XL 2\r\n\r\n",
    "comments_url": "https://api.github.com/repos/google/ExoPlayer/issues/4217/comments",
    "author": "joaquim-verges",
    "comments": [
      {
        "user": "tonihei",
        "created_at": "2018-05-08T09:50:11Z",
        "body": "Can you provide us with a link to your test stream to ensure we can reproduce the issue? \r\n\r\nI tested another HLS live stream and manually set the start position to a few seconds to the end of the window. This also causes some buffering as soon as I reach the end of the  window. However, this is clearly caused by running out of media as the playlist update and prebuffering of the next segment doesn't happen fast enough. \r\n\r\nNote that our  `DefaultLoadControl` waits until it has 5 seconds of buffered media before continuing playback when in `STATE_BUFFERING`. This is the `bufferForPlaybackAfterRebufferMs` parameter.\r\nWhen I set this to zero, it continues playing immediately after getting new media. That allowed me to set the playback position to 1-2 seconds behind the live edge while still having a smooth playback with only the occasional small hick-up when loading didn't catch up fast enough. "
      },
      {
        "user": "joaquim-verges",
        "created_at": "2018-05-09T18:38:27Z",
        "body": "Thank you for the prompt reply @tonihei! That makes much more sense now, didn't think of reducing the `bufferForPlaybackAfterRebufferMs` value, it does help getting better latency on good connections.\r\n\r\nI'll play with the right value to balance between latency and good experience for slower connections.\r\n\r\nI'm also thinking of subclassing `DefaultLoadControl` to increase the `bufferForPlaybackAfterRebufferMs` value as I hit more buffer empties, to make the value more dynamic.\r\n\r\nSeems like something like this should work?\r\n\r\n```\r\n// bufferForPlaybackAfterRebufferUs == 1 sec initially\r\n\r\n@Override\r\npublic boolean shouldStartPlayback(long bufferedDurationUs, float playbackSpeed, boolean rebuffering) {\r\n\tboolean shouldStartPlayback = super.shouldStartPlayback(bufferedDurationUs, playbackSpeed, rebuffering);\r\n\tif (rebuffering) {\r\n\t\t// add new condition to start playback dependent on the rebuffer count \r\n\t\tshouldStartPlayback &= bufferedDurationUs >= bufferForPlaybackAfterRebufferUs * rebufferCount;\r\n                 // increment rebuffer count when we resume playback\r\n                if (shouldStartPlayback) {\r\n\t                rebufferCount++;\r\n                }\r\n\t}\r\n\treturn shouldStartPlayback;\r\n}\r\n```\r\n\r\nDoes this makes sense for a live stream rebuffer behavior to keep requiring more buffered data as we hit more hiccups? and is `DefaultLoadController.shouldStartPlayback` the right place to add this logic?\r\n\r\nThanks again for the precious help.\r\n\r\n"
      },
      {
        "user": "joaquim-verges",
        "created_at": "2018-05-11T05:46:17Z",
        "body": "Just wanted to post an update for my buffering issue. I was lucky enough to meet @AquilesCanta from your team at Google I/O, and after inspecting a stream that reproduced the issue, he pointed out that I had an incorrect `#EXT-X-TARGETDURATION` of 5 seconds, while my segments are only 2 seconds.\r\n\r\nThis was causing exoplayer to only load new segments every 5 seconds, which I believe was the main cause of my rebuffering issue.\r\n\r\nTo verify this, I recompiled the HLS module with a hardcoded value of 2 seconds for `targetDurationUs` when building new `HlsMediaPlaylist` objects, and indeed the issue is now completely gone! I'm getting great latency and smooth playback :)\r\n\r\nWanted to post this in case it helps other people, and say a huge thanks to @AquilesCanta for helping me debug the issue.\r\n\r\nCongrats on a great library, and keep up the good work!"
      },
      {
        "user": "AquilesCanta",
        "created_at": "2018-05-11T13:38:38Z",
        "body": "Great news, Joaquim! Nice meeting you. Feel free to reach out if you run into any more issues."
      },
      {
        "user": "tonihei",
        "created_at": "2018-05-11T13:57:35Z",
        "body": "Closing the issue then, as it seems the question was solved."
      }
    ]
  },
  {
    "number": 4031,
    "title": "Custom listener to show playback controls",
    "created_at": "2018-03-24T11:22:17Z",
    "closed_at": "2018-05-04T09:11:33Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/google/ExoPlayer/issues/4031",
    "body": "Hi. I want to to show playback controls only when onTouch event is fired. How to prevent control buttons being showed up when on long pressing, dragging etc.?",
    "comments_url": "https://api.github.com/repos/google/ExoPlayer/issues/4031/comments",
    "author": "elnurvl",
    "comments": [
      {
        "user": "tonihei",
        "created_at": "2018-03-26T10:48:12Z",
        "body": "Our `PlayerView` class checks for `MotionEvent.ACTION_DOWN` to show the playback controls. \r\n\r\nIf you like to have a custom behavior, you could extend `PlayerView` and override `onTouchEvent(MotionEvent ev)`. In there, you can call `showController()` or `hideController()` to achieve your intended effect."
      },
      {
        "user": "elnurvl",
        "created_at": "2018-03-26T12:00:02Z",
        "body": "I use ExoPlayerFactory to make a player object. I am not sure if it is the correct way to make a player object with new statement. Can't I set onTouchListener after player object being created?"
      },
      {
        "user": "tonihei",
        "created_at": "2018-03-26T12:22:23Z",
        "body": "Yes, ExoPlayerFactory is the correct way to create the player. I think that's irrelevant for your problem though. For my suggestion, you'd need to overwrite `PlayerView` which is the UI component you may have put somewhere in your layout."
      },
      {
        "user": "elnurvl",
        "created_at": "2018-03-26T14:37:13Z",
        "body": "Sorry, I confused `PlayerView` with `ExoPlayer` object. So in this case I should create my own widget with custom `onTouchEvent` method and use it in my layout instead of standard `PlayerView`, right?"
      },
      {
        "user": "tonihei",
        "created_at": "2018-03-26T14:39:54Z",
        "body": "Sounds right."
      },
      {
        "user": "elnurvl",
        "created_at": "2018-03-26T14:49:45Z",
        "body": "Thank you. It would be more convenient to do customization if a method like setOnTouchListener are added to PlayerView class in the next releases."
      },
      {
        "user": "elnurvl",
        "created_at": "2018-05-02T20:54:07Z",
        "body": "@tonihei , I am trying to implement your solution to customize the event which is responsiple for showing playback controls. Unfortunately it is not working. Because `controller` variable is private and I cannot access it in my own `PlayerView`. I cannot use `super` either, because it checks for `MotionEvent.ACTION_DOWN` implicitly as you said. What I need is to fire the event when a user single taps on the player. Isn't it possible to achieve it in ExoPlayer without changing the library files?"
      },
      {
        "user": "tonihei",
        "created_at": "2018-05-03T09:34:55Z",
        "body": "You can change the visibility of the controller with `showController()` and `hideController()` and you can listen to its visibility with `setControllerVisibilityListener`. That means you don't actually need access to the `controller` variable to achieve your custom `onTouchEvent` handling.\r\n\r\nTo confirm that it's actually working, I tried to implement what you are trying to do with the following code.  Using this custom view, the playback controls are only shown or hidden for short taps. Dragging and long presses are filtered out.\r\n\r\n```\r\npublic final class CustomPlayerView\r\n    extends PlayerView implements PlayerControlView.VisibilityListener {\r\n\r\n  private static final float DRAG_THRESHOLD = 10;\r\n  private static final long LONG_PRESS_THRESHOLD_MS = 500;\r\n\r\n  private boolean controllerVisible;\r\n  private long tapStartTimeMs;\r\n  private float tapPositionX;\r\n  private float tapPositionY;\r\n\r\n  public CustomPlayerView(Context context) {\r\n    this(context, null);\r\n  }\r\n\r\n  public CustomPlayerView(Context context, AttributeSet attrs) {\r\n    this(context, attrs, 0);\r\n  }\r\n\r\n  public CustomPlayerView(Context context, AttributeSet attrs, int defStyleAttr) {\r\n    super(context, attrs, defStyleAttr);\r\n    setControllerVisibilityListener(this);\r\n  }\r\n\r\n  @Override\r\n  public boolean onTouchEvent(MotionEvent ev) {\r\n    switch (ev.getActionMasked()) {\r\n      case MotionEvent.ACTION_DOWN:\r\n        tapStartTimeMs = SystemClock.elapsedRealtime();\r\n        tapPositionX = ev.getX();\r\n        tapPositionY = ev.getY();\r\n        break;\r\n      case MotionEvent.ACTION_MOVE:\r\n        if (tapStartTimeMs != 0\r\n            && (Math.abs(ev.getX() - tapPositionX) > DRAG_THRESHOLD\r\n                || Math.abs(ev.getY() - tapPositionY) > DRAG_THRESHOLD)) {\r\n          tapStartTimeMs = 0;\r\n        }\r\n        break;\r\n      case MotionEvent.ACTION_UP:\r\n        if (tapStartTimeMs != 0) {\r\n          if (SystemClock.elapsedRealtime() - tapStartTimeMs < LONG_PRESS_THRESHOLD_MS) {\r\n            if (!controllerVisible) {\r\n              showController();\r\n            } else if (getControllerHideOnTouch()) {\r\n              hideController();\r\n            }\r\n          }\r\n          tapStartTimeMs = 0;\r\n        }\r\n    }\r\n    return true;\r\n  }\r\n\r\n  @Override\r\n  public void onVisibilityChange(int visibility) {\r\n    controllerVisible = visibility == View.VISIBLE;\r\n  }\r\n}\r\n```"
      },
      {
        "user": "elnurvl",
        "created_at": "2018-05-03T16:44:57Z",
        "body": "Thank you! Exactly what I was looking for."
      }
    ]
  },
  {
    "number": 4023,
    "title": "Playback buffer value",
    "created_at": "2018-03-22T23:21:12Z",
    "closed_at": "2018-03-23T17:12:36Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/google/ExoPlayer/issues/4023",
    "body": "I am writing a DASH video player using ExoPlayer demo app as the base for my application. How can I get the actual playback buffer size in seconds, without messing with the actual MediaSource and other  code libraries (and short of maintaining my own variable tracking media downloaded, played, paused and all that mess)? \r\nBy actual playback buffer size, I mean the 'total duration duration of the video chunks that's already buffered' - 'total duration of the video chunks that's been watched'. \r\nFor example, if the player has downloaded 60s worth of data and the renderer has already played 50s of this video, I want to know that there's 10 more seconds to go before the player might hit a re-buffer. I am trying to eventually get to a feature that minimizes re-buffering events.\r\nI want to do this with minimal changes to the existing code and achieve this with event listeners, as much as possible. I know if I write my own trackSelector, this is easy to obtain. But, can I get it at the app layer?\r\nThanks for any pointers.",
    "comments_url": "https://api.github.com/repos/google/ExoPlayer/issues/4023/comments",
    "author": "kanthicn1",
    "comments": [
      {
        "user": "tonihei",
        "created_at": "2018-03-23T09:23:11Z",
        "body": "`player.getBufferedPosition() - player.getCurrentPosition()` should give you what you want for most situations. \r\n\r\nThe only exception is when the player pre-buffers the following items in a playlist. In this case the calculation would only give you the buffered duration in the current playlist item. But, we are planning to fix this soon. "
      },
      {
        "user": "kanthicn1",
        "created_at": "2018-03-23T16:44:52Z",
        "body": "Thank you! This works perfectly for me right now. However, I want to understand the caveat in this solution that you mentioned. If the player pre-buffers the other items in the playlist, are you saying this method won't give me the buffer values of all the tracks? But, this method will always give me the correct buffer value of the track that is currently being played. Correct?"
      },
      {
        "user": "tonihei",
        "created_at": "2018-03-23T16:48:30Z",
        "body": "Yes, that's correct. We are currently adding a new method the interface `Player.getTotalBufferedDuration()` which returns the total duration of buffered media across all playlist items."
      },
      {
        "user": "kanthicn1",
        "created_at": "2018-03-23T17:12:36Z",
        "body": "Great!\r\nThanks again for your help."
      }
    ]
  },
  {
    "number": 3993,
    "title": "Making my own ABR algorithm in HLS",
    "created_at": "2018-03-15T11:20:15Z",
    "closed_at": "2018-03-19T10:29:12Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/google/ExoPlayer/issues/3993",
    "body": "Hello,\r\n\r\nI am making my own ABR algorithm class in HLS extended from BaseTrackSelection and I am facing with a problem. I need targetDuration in my class but there is no way I can get the information from the application level. Plus, I am making my own LoadController, and it needs bitrate information. In this case, is there simple way that I can pass these information to my class in application level?(like PlayerActivity) \r\n\r\nThank you ",
    "comments_url": "https://api.github.com/repos/google/ExoPlayer/issues/3993/comments",
    "author": "tedKim5178",
    "comments": [
      {
        "user": "AquilesCanta",
        "created_at": "2018-03-15T11:25:38Z",
        "body": "`Player.EventListener#onTimelineChanged`  includes the manifest as one of the arguments. An `HlsManifest` includes a media playlist as one of its fields. Finally, HlsMediaPlaylist contains targetDurationUs. Hope this helps."
      },
      {
        "user": "AquilesCanta",
        "created_at": "2018-03-15T11:31:54Z",
        "body": "Sorry, I missed the bitrate part. Could you clarify the usecase for the bitrate? You can use the media source event listener to get load events to retrieve certain information. The master playlist will also include useful information (also obtainable through onTimelineChanged)."
      },
      {
        "user": "tedKim5178",
        "created_at": "2018-03-18T06:16:48Z",
        "body": "Thanks for your reply. You solved my problem perfectly. Now I am using onTimelineChanged method to get targetDurationUs. Also, I found out onTrackSelected method in LoadControl. I can use this method to get bitrate. Thanks for your help!! Best Player ever!"
      }
    ]
  },
  {
    "number": 3980,
    "title": "How to listen video position",
    "created_at": "2018-03-13T09:19:08Z",
    "closed_at": "2018-03-26T11:07:56Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/google/ExoPlayer/issues/3980",
    "body": "I'm using ExoPlayer 2.7.0 and I would like to listen player position in order to take actions. I couldn't find specific method for it. Could you please suggest me a proper solution?\r\n\r\nThanks",
    "comments_url": "https://api.github.com/repos/google/ExoPlayer/issues/3980/comments",
    "author": "orhunkupeli7",
    "comments": [
      {
        "user": "tonihei",
        "created_at": "2018-03-13T09:42:53Z",
        "body": "You can query `player.getCurrentPosition()` as often as you like. The position is updated all the time, thus we can't send repeated updates in a callback. The progress bar in our UI module, for example, is updated by posting a message every 200ms."
      },
      {
        "user": "orhunkupeli7",
        "created_at": "2018-03-13T12:40:31Z",
        "body": "So, it is okay that to listen it with a handler."
      },
      {
        "user": "tonihei",
        "created_at": "2018-03-13T13:01:59Z",
        "body": "Yes, that's certainly possible."
      },
      {
        "user": "meikaiss",
        "created_at": "2018-03-15T03:48:49Z",
        "body": "Why not provide onProgressChangedListener?  handler is Very troublesome."
      },
      {
        "user": "tonihei",
        "created_at": "2018-03-15T09:17:08Z",
        "body": "The problem with a onProgressChangedListener is that the position changes about every 10 milliseconds. Sending such a huge amount of callbacks would use much more CPU time (and thus battery) than polling the progress infrequently. Most progress bars don't have a resolution which would allow you to show a 10ms difference either, thus it also wouldn't make sense for most purposes. \r\n\r\nAlso, using a handler is not that troublesome:\r\n```\r\npublic class ProgressTracker implements Runnable {\r\n  \r\n  private final Player player;\r\n  private final Handler handler;\r\n\r\n  public void ProgressTracker(Player player) {\r\n    this.player = player;\r\n    handler = new Handler();\r\n    handler.post(this);\r\n  }\r\n\r\n  public void run() {\r\n    long currentPosition = player.getCurrentPosition();\r\n    handler.postDelayed(this, 200 /* ms */);\r\n  }\r\n}\r\n"
      },
      {
        "user": "orhunkupeli7",
        "created_at": "2018-03-16T10:48:21Z",
        "body": "public class ProgressTracker implements Runnable {\r\n\r\n    private final Player player;\r\n    private final Handler handler;\r\n    private PositionListener positionListener;\r\n    private final static int DELAY_MS = 1000;\r\n\r\n    protected ProgressTracker(Player player, PositionListener positionListener) {\r\n        this.player = player;\r\n        this.positionListener = positionListener;\r\n        handler = new Handler();\r\n        handler.post(this);\r\n    }\r\n\r\n    public void run() {\r\n        int position = (int) player.getCurrentPosition();\r\n        Log.e(\"Position::\", String.valueOf(player.getCurrentPosition()));\r\n        positionListener.progress(position);\r\n        handler.postDelayed(this, DELAY_MS);\r\n    }\r\n\r\n    protected void purgeHandler() {\r\n        handler.removeCallbacks(this);\r\n    }\r\n}\r\n\r\nI did like that. However output of the log is:\r\n24358\r\n24358\r\n25088\r\n25088\r\n25357\r\n25368\r\n26088\r\n\r\nWhy there are duplicates how can I get rid of them"
      },
      {
        "user": "tonihei",
        "created_at": "2018-03-16T10:57:09Z",
        "body": "I guess because either the position hasn't changed (for example while buffering) or you have multiple active ProgressTrackers. \r\n\r\nIn general, please direct these more generic programming question to StackOverflow or similar sites. This issue tracker is primarily for answering ExoPlayer specific questions."
      },
      {
        "user": "orhunkupeli7",
        "created_at": "2018-03-16T11:05:26Z",
        "body": "thanks, sorry for inconvenience.\r\n"
      },
      {
        "user": "tonihei",
        "created_at": "2018-03-26T11:07:56Z",
        "body": "Closing because question seems to be answered. Feel free to reopen if not."
      }
    ]
  },
  {
    "number": 3946,
    "title": "cannot resolve MediaSessionConnector",
    "created_at": "2018-03-06T17:44:51Z",
    "closed_at": "2018-03-06T17:47:07Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/google/ExoPlayer/issues/3946",
    "body": "I am using exoplayer v 2.6.1 but i am facing an issue that MediaSessionConnector is not working.\r\n\r\ngradle exoplayer import:\r\n    compile 'com.google.android.exoplayer:exoplayer:2.6.1'",
    "comments_url": "https://api.github.com/repos/google/ExoPlayer/issues/3946/comments",
    "author": "MohammadElKhatib",
    "comments": [
      {
        "user": "ojw28",
        "created_at": "2018-03-06T17:47:07Z",
        "body": "You need to also depend on `com.google.android.exoplayer:extension-mediasession:2.6.1`"
      },
      {
        "user": "MohammadElKhatib",
        "created_at": "2018-03-06T17:51:12Z",
        "body": "@ojw28 yes you are right this was not clear in installation.\r\nthank you"
      }
    ]
  },
  {
    "number": 3943,
    "title": "How to notice me when next video playback and get current playback file's URI at the same time ?",
    "created_at": "2018-03-05T14:42:24Z",
    "closed_at": "2018-03-07T13:27:43Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/google/ExoPlayer/issues/3943",
    "body": "I try to find a listener that can notice me when the next or previous video playback.\r\n\r\nfor example: \r\n\r\nI have a List of uri by using *DynamicConcatenatingMediaSource* to ExoPlayer, when I click \"next\" button or auto play the next video, I hope to know this event and to know the current playback video's uri.\r\n\r\n I try to find some useful information from Demo App,but nothing.\r\nplease help me~\r\n\r\n#### Version of ExoPlayer being used\r\n2.6.1\r\n",
    "comments_url": "https://api.github.com/repos/google/ExoPlayer/issues/3943/comments",
    "author": "yibeiliu",
    "comments": [
      {
        "user": "tonihei",
        "created_at": "2018-03-05T14:49:03Z",
        "body": "You can retrieve the `MediaSource` at each index in the playlist by calling `DynamicConcatenatingMediaSource.getMediaSource(index)`. Unfortunately, our media sources don't have a `.getUri()` method. To work around this you can keep a `Map<MediaSource, Uri>` or similar in your app to lookup the `Uri` from the `MediaSource`. \r\n"
      },
      {
        "user": "yibeiliu",
        "created_at": "2018-03-07T13:27:43Z",
        "body": "Thank a lot! \r\n\r\nI've solved the problem as you said\uff01"
      }
    ]
  },
  {
    "number": 3932,
    "title": "How to render video into off-screen buffer",
    "created_at": "2018-03-03T12:46:06Z",
    "closed_at": "2018-03-06T08:13:07Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/google/ExoPlayer/issues/3932",
    "body": "I'm wondering if it's possible to do at all.\r\nI want to get decoded video frame and use it as OpenGL ES texture in a game, so I don't want it to be rendered into some 'ui' elements (SurfaceView, TextureView etc)\r\n\r\nIt seem a pair of Surface and SurfaceTexture would help me but it doesn't.\r\nHere is a code snippet (I try to do this in Xamarin.Android but it doesn't matter, any advice for 'native' Android would be appreciated).\r\n```\r\n            _bandwidthMeter = new DefaultBandwidthMeter();\r\n            var videoTrackSelectionFactory = new AdaptiveTrackSelection.Factory(_bandwidthMeter);\r\n            _trackSelector = new DefaultTrackSelector(videoTrackSelectionFactory);\r\n            _player = ExoPlayerFactory.NewSimpleInstance(Application.Context, _trackSelector);\r\n\r\n            // This is the MediaSource representing the media to be played.\r\n            DefaultBandwidthMeter bandwidthMeterA = new DefaultBandwidthMeter();\r\n            var dataSrcFacroty = new DefaultDataSourceFactory(Application.Context, \"blabla\", bandwidthMeterA);\r\n            var chunkSrcFactory = new DefaultDashChunkSource.Factory(dataSrcFacroty);\r\n\r\n            var mediaSource = new HlsMediaSource(_uri, dataSrcFacroty, 1, null, null);\r\n\r\n            _player.Prepare(mediaSource);\r\n            _player.PlayWhenReady = true;\r\n            \r\n            #int[] _textures = new int[1];\r\n            ...\r\n            GL.Enable(EnableCap.Texture2D);\r\n            GL.GenTextures(1, _textures);\r\n            GL.BindTexture(TextureTarget.Texture2D, _textures[0]);\r\n\r\n            GL.TexImage2D(\r\n                TextureTarget.Texture2D,\r\n                0,\r\n                PixelInternalFormat.Rgba,\r\n                Width,\r\n                Height,\r\n                0,\r\n                OpenTK.Graphics.ES20.PixelFormat.Rgb,\r\n                PixelType.UnsignedByte, \r\n                _data);\r\n\r\n            var st = new SurfaceTexture(_textures[0], true);\r\n            _surface = new Surface(st);\r\n           _payer.SetVideoSurface(_surface);\r\n\r\n            GL.BindTexture(TextureTarget.Texture2D, 0);\r\n```\r\n\r\nAlas, I don't see any changes in my texture.\r\nWhat I'm doing wrong?",
    "comments_url": "https://api.github.com/repos/google/ExoPlayer/issues/3932/comments",
    "author": "Papirosnik",
    "comments": [
      {
        "user": "Papirosnik",
        "created_at": "2018-03-06T07:33:46Z",
        "body": "It seems I see my fault: texture target must be GlTextureExternalOES"
      },
      {
        "user": "andrewlewis",
        "created_at": "2018-03-06T08:13:07Z",
        "body": "Yes. The decoder outputs to an external texture, and to copy from there one can use a `samplerExternalOES` sampler. I'll close this for now but please feel free to reply if you have any other issues. Thanks."
      }
    ]
  },
  {
    "number": 3930,
    "title": "Failed to resolve: com.google.android.exoplayer:exoplayer-core:r2.7.0 ",
    "created_at": "2018-03-03T10:00:54Z",
    "closed_at": "2018-03-04T11:32:04Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/google/ExoPlayer/issues/3930",
    "body": "Android studio 3.0\r\ngradle version 4.1\r\n\r\nUnable to resolve 2.7.0 dependencies?\r\n\r\n",
    "comments_url": "https://api.github.com/repos/google/ExoPlayer/issues/3930/comments",
    "author": "0x410c",
    "comments": [
      {
        "user": "FD-",
        "created_at": "2018-03-03T15:22:37Z",
        "body": "I'm not a project member, but according to the release notes, version names no longer contain the r.\r\n`com.google.android.exoplayer:exoplayer-core:2.7.0` should work fine."
      },
      {
        "user": "0x410c",
        "created_at": "2018-03-04T11:25:28Z",
        "body": "thanks brother. worked perfectly. i think they should change git readme."
      },
      {
        "user": "ojw28",
        "created_at": "2018-03-04T11:32:04Z",
        "body": "Which readme? It looks like we've already removed all the \"r\"s from the readme."
      }
    ]
  },
  {
    "number": 3894,
    "title": "Does ExoPlayer have the OnSeekCompleteListener?",
    "created_at": "2018-02-23T22:44:06Z",
    "closed_at": "2018-02-26T17:18:39Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/google/ExoPlayer/issues/3894",
    "body": "MediaPlayer class has the OnSeekCompleteListener.\r\n\r\nIf not, I can work around it by checking the current position got updated or not after seeking.\r\nFor the cleanliness of my code, I was looking for the OnSeekCompleteListener but could not find it.\r\n\r\nDoes ExoPlayer not have the listener or I am just not finding it?",
    "comments_url": "https://api.github.com/repos/google/ExoPlayer/issues/3894/comments",
    "author": "jclova",
    "comments": [
      {
        "user": "ghost",
        "created_at": "2018-02-23T23:25:15Z",
        "body": "It's in Player.EventListener, there is a method called onSeekProcessed()."
      },
      {
        "user": "jclova",
        "created_at": "2018-02-26T17:18:39Z",
        "body": "Thank you so much. \r\nI was using the older version of ExoPlayer so I could not find it."
      }
    ]
  },
  {
    "number": 3874,
    "title": "How to display ads of previous player",
    "created_at": "2018-02-21T11:40:09Z",
    "closed_at": "2018-02-21T13:10:15Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/google/ExoPlayer/issues/3874",
    "body": "Hi!\r\n\r\nMy app:\r\nI have an app that consists of a screen with a list of players with ads. (I am using RecyclerView).\r\nWhen the user scrolls the main screen and a video was playing, I display this video in a smaller player at the bottom of the screen (like youtube).\r\n\r\nTo display the smaller video, I create a new player and update it with content position of previous player.\r\n\r\nMy problem:\r\nWhen the user scrolls and an ads is playing, when updating the new player with content position of previous player, the ads starts to play from the beginning and not from the position that it had stopped in the other player. (I am reusing AdsLoader and )\r\n\r\nMy question:\r\nI would like to know if there is any way I can display ads from the position it stopped in previously player. \r\n\r\nCan someone help me, please?\r\n\r\nSome code:\r\n\r\n```\r\nMediaSource mediaSource = buildMediaSource(Uri.parse(url));\r\nString adTag = getAdsUrl();\r\n\r\n if (adTag != null) {\r\n    if (!reuseAds) {\r\n         releaseAdsLoader();\r\n         mAdsLoader = new ImaAdsLoader(context, Uri.parse(adTag));\r\n    }\r\n    mediaSource = new AdsMediaSource(mediaSource, new AdsMediaSourceFactory(), mAdsLoader, playerView.getOverlayFrameLayout(), null, null);\r\n}\r\n\r\nplayer.seekTo(position);\r\nplayer.setPlayWhenReady(true);\r\n\r\nplayer.prepare(mediaSource,false,false);\r\n```",
    "comments_url": "https://api.github.com/repos/google/ExoPlayer/issues/3874/comments",
    "author": "michelecorrea3",
    "comments": [
      {
        "user": "andrewlewis",
        "created_at": "2018-02-21T11:47:42Z",
        "body": "Are you definitely using exactly the same `ImaAdsLoader` instance when creating the `AdsMediaSource` that is played in the new player? It's also important that the old player is released before creating the new one. I think this should just work, as the situation is very similar to background/resuming a player while playing ads."
      },
      {
        "user": "michelecorrea3",
        "created_at": "2018-02-21T12:36:23Z",
        "body": "It was the same ImaAdsLoader, but I wasn't releasing the old player before creating the new one. I released and it worked! Thank you so much :)"
      },
      {
        "user": "andrewlewis",
        "created_at": "2018-02-21T13:10:15Z",
        "body": "Glad to hear it works!"
      }
    ]
  },
  {
    "number": 3637,
    "title": "Continue buffering while in pause",
    "created_at": "2017-12-24T16:44:31Z",
    "closed_at": "2018-01-04T18:18:57Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/google/ExoPlayer/issues/3637",
    "body": "Hi!\r\n\r\nCurrently when player is paused it stops to receive new data in buffer.\r\nIs it possible to continue buffering while player is in pause state?\r\n\r\nIf there is no other options, guess, I could use Cache feature to save data in separate thread and then use cached data to play when it is buffered enough while in pause. If it is the case, could you please explain should I use Downloader to save data in one thread and then use another Cache with the link to the same DataSpec or can I use the same Cache instance in another thread for playback?\r\n\r\nThanks!",
    "comments_url": "https://api.github.com/repos/google/ExoPlayer/issues/3637/comments",
    "author": "aarondib",
    "comments": [
      {
        "user": "erdemguven",
        "created_at": "2017-12-27T19:39:29Z",
        "body": "For the second part of the question, it's an error to create two Cache instances which store cache files on the same folder. It's OK to access to a single instance of Cache from different threads but there are issues with writing and reading the same content on the cache. In your case as long as you stop the downloader before player resumes it should be fine.  "
      },
      {
        "user": "ojw28",
        "created_at": "2018-01-02T21:00:04Z",
        "body": "For the first part of the question: We don't stop buffering when the player is paused. We stop buffering when the criteria for how much media should be buffered is reached, which is independent of whether the player is paused or not. You can customize how much media is buffered by instantiating a `DefaultLoadControl` using one of the constructors that allows specifying minimum and maximum buffer durations, and then passing that instance into a `ExoPlayerFactory` when instantiating the player. You can also implement your own `LoadControl` from scratch if that's easier.\r\n\r\nNote that `LoadControl` controls buffering in RAM, so there's only so far you can go before you'll end up with your process crashing with an out of memory error. If you want to buffer to disk then you should use the cache feature instead."
      },
      {
        "user": "aarondib",
        "created_at": "2018-01-04T18:18:57Z",
        "body": "Thanks for your replies! Very useful."
      }
    ]
  },
  {
    "number": 3585,
    "title": "Unable do play content after upgrading to ExoPlayer 2.6.0 from 1.2.X",
    "created_at": "2017-12-13T17:09:36Z",
    "closed_at": "2017-12-13T18:43:08Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/google/ExoPlayer/issues/3585",
    "body": "We were using ExoPlayer 1.2.X for a while now and decided to upgrade to 2.6.0, but our content won't play, returning some toasts:\r\n\r\n\"Media includes video tracks, but none are playable by this device\"\r\n\r\nand\r\n\r\n\"Media includes audio tracks, but none are playable by this device\"\r\n\r\nWe tried playing in several emulators from Android 6 to 8, and on a Samsung Galaxy S8+ running Android 7.0\r\n\r\nHow to reproduce the issue:\r\n\r\nPlayer Version: 2.6.0\r\nDevice: Pixel XL - API 24\r\n\r\n1 - Downloand ExoPlayer version 2.6.0 release.\r\n\r\n2 - Add the given media uri and drm_license_url using the drm_scheme \"widevine\" to the media.exolist.json.\r\n\r\n3 - Run the ExoPlayer and try to play the media.\r\n\r\nThe media uri, proxy url and bugreport file were sent to dev.exoplayer@gmail.com\r\n\r\nThank you in advance for the help!\r\n",
    "comments_url": "https://api.github.com/repos/google/ExoPlayer/issues/3585/comments",
    "author": "Lezherus",
    "comments": [
      {
        "user": "ojw28",
        "created_at": "2017-12-13T17:16:26Z",
        "body": "This happens because we're concluding from the manifest that the stream only supports PlayReady DRM. This is because the manifest contains ContentProtection elements for PlayReady, but not for Widevine. Adding ContentProtection elements for Widevine should resolve this issue."
      },
      {
        "user": "Lezherus",
        "created_at": "2017-12-13T18:10:25Z",
        "body": "@ojw28 Thank you for the prompt answer! But now I'm wondering, if that's the case, why does it works on 1.2.X? Did ExoPlayer use to support PlayeReady but now it doesn't?"
      },
      {
        "user": "ojw28",
        "created_at": "2017-12-13T18:43:08Z",
        "body": "Both V1 and V2 support PlayReady where supported by the underlying platform. PlayReady is only a requirement for AndroidTV devices, however. Most Android mobile devices don't provide support.\r\n\r\nThe reason V2 fails and V1 doesn't is just that V1 performs fewer checks prior to attempting to start playback. Which meant it was prone to try and play content in an unsupported DRM scheme and fail in an arbitrary way, but also that it was able to successfully play content in a supported DRM scheme even the scheme was missing from the manifest."
      },
      {
        "user": "Lezherus",
        "created_at": "2017-12-13T19:09:12Z",
        "body": "@ojw28 Thank you for the clarification. But we tried using another manifest with the widevine ContentProtection element included and it still doesn't works, but now it returns a different error.\r\n\r\nI e-mailed you the bugreport and new manifest link, could you take a look, please?"
      },
      {
        "user": "ojw28",
        "created_at": "2017-12-13T19:15:59Z",
        "body": "The updated manifest plays fine if you add the following line of JSON:\r\n```\r\n\"extension\": \"mpd\"\r\n```\r\nSo it looks like:\"\r\n```\r\n{\r\n\"name\": \"XXX\",\r\n\"uri\": \"XXX\",\r\n\"drm_scheme\": \"widevine\",\r\n\"drm_license_url\": \"XXX\"\r\n\"extension\": \"mpd\"\r\n},\r\n```\r\nThe demo app tries and automatically infer the content type from the extension, but in this case the extension is \"ism\" and the demo app infers that it's a SmoothStreaming stream. Adding the extra line explicitly tells the demo app what the content type is."
      },
      {
        "user": "Lezherus",
        "created_at": "2017-12-14T11:12:55Z",
        "body": "@ojw28 Indeed, it played fine, thank you very much for the help! I must admit that I'm impressed with how fast you guys reply to the issues, congratulations on the amazing job, and please keep it up!"
      }
    ]
  },
  {
    "number": 3563,
    "title": "[Question] How to get the startTime and endTime from TextRenderer.Output cues",
    "created_at": "2017-12-07T19:28:54Z",
    "closed_at": "2017-12-11T10:41:59Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/google/ExoPlayer/issues/3563",
    "body": "Hi there!\r\nI'm currently implementing the TextRenderer.Output to received the List of Cues for WebVtt captions, and then I'm displaying those captions in our custom caption view.\r\nThe problem is that WebvttCue class is package-private so we can't cast it, so that we can use the startTime and endTime.\r\nIs there a reason to keep that class as package-private? What alternative do I have?\r\n\r\nThanks!\r\n",
    "comments_url": "https://api.github.com/repos/google/ExoPlayer/issues/3563/comments",
    "author": "sergiomartinez4",
    "comments": [
      {
        "user": "botaydotcom",
        "created_at": "2017-12-08T10:35:39Z",
        "body": "Hi @sergiomartinez4 ,\r\nCould you explain your use-case clearer, and why do you need to get access to startTime and endTime in order to display these Cues in your custom view?\r\nBy design, the player will parse these time values from underlying stream, and perform calculations internally to find out when to display these subtitles with respect to other tracks (video/audio etc...). Then the TextRenderer will output the List<Cue> to be displayed at the right time, and the client application only needs to handle displaying these Cues immediately upon receiving them. Attempting to parse startTime and endTime, without understanding fully the timing model of the player, may lead to wrong presentation time.\r\n\r\nPlease elaborate more on your use case and the reasoning behind, and we can answer your question better. Thank you very much.\r\n\r\nWith that said, because of other changes, WebvttCue class has been made public in dev-v2 branch, and may be released as such in the future (I don't know when). However, unless it's really necessary, I don't think you should rely on that given the problem I described.\r\n\r\n"
      },
      {
        "user": "sergiomartinez4",
        "created_at": "2017-12-08T15:15:28Z",
        "body": "@botaydotcom thanks for the reply.\r\n\r\nThe real concern is not about when to display them, as we display them as soon as the onCues method is called, but it's about when to stop displaying the captions. A caption duration property in the Cue object will be enough for our purposes.\r\n\r\nWithout any sense of time, we can either just stop displaying one caption after the next one appears or we can set a default duration timeout (or a combination both). We could also adjust the duration depending on the length of the text and with this approach we can only hope to get a good approximation, but it wouldn't be the exact times as specified in the Webvtt document.\r\n\r\nHaving the public WebvttCue will make it easier with our current implementation, we only need to cast the Cue to WebvttCue and get the extra info, but If I'm missing something or there's an easier or better way to do it, I'm happy to try it out.\r\n\r\nBest!\r\n"
      },
      {
        "user": "botaydotcom",
        "created_at": "2017-12-08T15:31:03Z",
        "body": "Hi @sergiomartinez4 ,\r\nI think I understand your idea, but it is unfortunately it is not our intention behind `TextOutput` interface.\r\nThe idea with `TextOutput` is whenever the player sends a Cue list, the application should just take it and display as it is. If any of the cues are changed (some added, some removed etc...), the player will invoke that method again with a new Cue list reflecting the new state. So you don't need to time the display yourself or find out when to remove the displayed captions. The next time you receive a new list of cues, just remove everything and re-display the whole list accordingly (note that the list might be null if there's nothing to be displayed on the screen).\r\n\r\nI think an easy way to follow this is to check out `com.google.android.exoplayer2.ui.SubtitleView`, which follows this approach. Hope that help."
      },
      {
        "user": "sergiomartinez4",
        "created_at": "2017-12-08T20:11:43Z",
        "body": "@botaydotcom, removing the captions when getting empty cues did the trick. It makes sense now.\r\nThanks a lot for the help."
      },
      {
        "user": "botaydotcom",
        "created_at": "2017-12-11T10:41:58Z",
        "body": "Cool! Glad that it helps."
      }
    ]
  },
  {
    "number": 3509,
    "title": "EventListener.onTimelineChanged howto get current window",
    "created_at": "2017-11-28T01:14:50Z",
    "closed_at": "2017-11-28T08:23:42Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/google/ExoPlayer/issues/3509",
    "body": "I'm using ExoPlayer 2.6.0 and made a simple Activity which creates a ConcatenatingMediaSource of some ExtractorMediaSource with http URL to Videos. All playing in endless loop without any issues.\r\n\r\nNow i want to get the current window+position when the video changes. So i implement the DefaultEventListener and override the onTimelineChanged method.\r\n\r\nIf i ask my player within this method using player.getCurrentPeriodIndex() and player.getCurrentWindowIndex() i do not get the right values.\r\nAre those values updated after the onTimelineChanged Event is fired? I also tried the onTracksChanged event, but with the same results.\r\n\r\nIs there another way to get the current window directly after a new video was loaded? I looked in the EventLogger from the sample, but i could not find the right spot for my needed information.\r\n\r\nIf i put a Handler with a periodic postDelayed runnable to poll the getCurrentPeriodIndex and getCurrentWindowIndex i get the right results.\r\n\r\nI'd rather not do the polling since i want to syncronise some players via network.\r\n\r\nI'm using an Android TV box running 6.0.1 my App Compile SDK is 26, target 26, min 23. Build Tools Version 26.0.2\r\n\r\n",
    "comments_url": "https://api.github.com/repos/google/ExoPlayer/issues/3509/comments",
    "author": "derlucas",
    "comments": [
      {
        "user": "andrewlewis",
        "created_at": "2017-11-28T08:02:55Z",
        "body": "`onPositionDiscontinuity` is called when playback transitions from one item to the next. You can get the new window index by calling `getCurrentWindowIndex`. Does that provide the information you need?"
      },
      {
        "user": "derlucas",
        "created_at": "2017-11-28T08:23:42Z",
        "body": "Thank you very much. This is exactly what i need. Maybe yesterday it was too late and i sat too long on the problem so i did not see this onPositionDiscontinuity description :)"
      }
    ]
  },
  {
    "number": 3405,
    "title": "Multiple ClippingMediaSource not working for m3u8 files ",
    "created_at": "2017-10-30T05:28:00Z",
    "closed_at": "2017-10-31T13:04:58Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/google/ExoPlayer/issues/3405",
    "body": "# Issue \r\n**When I use two or more ClippingMediaSource not working for m3u8. But working same code for MP4**\r\n\r\n### Reproduction steps\r\n\r\n**Bug : When I use Multiple ClippingMediaSource for m3u8 files not working**\r\n\r\nBut working in following cases\r\n\r\n1. Only one ClippingMediaSource with m3u8 - working\r\n2. Multiple ClippingMediaSource with mp4 - working \r\n\r\n\r\n        MediaSource movieMediaSource =getMediaSourceFromUrl(context, mLiveURL);\r\n            final long oneMinute = 60000000L;\r\n            ClippingMediaSource videoSource1 = new ClippingMediaSource(movieMediaSource, 0, oneMinute/2);\r\n\r\n            ClippingMediaSource videoSource2 = new ClippingMediaSource(movieMediaSource, oneMinute/2, oneMinute);\r\n  \r\n            ConcatenatingMediaSource concatenatingMediaSource = new ConcatenatingMediaSource(videoSource1,videoSource2);\r\n\r\n\r\n       public static MediaSource getMediaSourceFromUrl(Context context, String url) {\r\n        mBandwidthMeter = new DefaultBandwidthMeter();\r\n       //Produces DataSource instances through which media data is loaded.\r\n        DefaultDataSourceFactory dataSourceFactory = new DefaultDataSourceFactory(context, \r\n        Util.getUserAgent(context, \"MOD\"), mBandwidthMeter);\r\n       //Produces Extractor instances for parsing the media data.\r\n        ExtractorsFactory extractorsFactory = new DefaultExtractorsFactory();\r\n        MediaSource videoSource = null;\r\n        if (url != null && !url.isEmpty()) {\r\n            Log.d(TAG, \"getMediaSourceFromUrl: 11\");\r\n            if (url.contains(\".m3u8\")) {\r\n          //FOR LIVESTREAM LINK:\r\n                Uri mp4VideoUri = Uri.parse(url);\r\n                videoSource = new HlsMediaSource(mp4VideoUri, dataSourceFactory, null, null);\r\n        \r\n            } else if (url.contains(\".mp4\")) {\r\n         //FOR SD CARD SOURCE:\r\n                Uri mp4VideoUri = Uri.parse(url);\r\n                videoSource = new ExtractorMediaSource(mp4VideoUri, dataSourceFactory, extractorsFactory, null, null);\r\n              }\r\n           }\r\n            return videoSource;\r\n        }\r\n\r\n\r\n### Version of ExoPlayer being used\r\n2.5.4\r\n\r\n### Device(s) and version(s) of Android being used\r\nAndroid 5.1 & Android 7.0\r\n\r\n### A full bug report captured from the device\r\n\r\nLenova A6000+  & Nexus 6\r\n\r\n\r\n### Error Log\r\n\r\n> Internal runtime error.\r\n                                                                    java.lang.IllegalStateException at com.google.android.exoplayer2.util.Assertions.checkState(Assertions.java:79) at com.ajax.mod.controller.player.MyHlsMediaSource.prepareSource(MyHlsMediaSource.java:97)  at com.google.android.exoplayer2.source.ClippingMediaSource.prepareSource(ClippingMediaSource.java:89) at com.google.android.exoplayer2.source.ConcatenatingMediaSource.prepareSource(ConcatenatingMediaSource.java:78) at com.google.android.exoplayer2.ExoPlayerImplInternal.prepareInternal(ExoPlayerImplInternal.java:425)  at com.google.android.exoplayer2.ExoPlayerImplInternal.handleMessage(ExoPlayerImplInternal.java:328) at android.os.Handler.dispatchMessage(Handler.java:98)\r\nat android.os.Looper.loop(Looper.java:154)\r\nat android.os.HandlerThread.run(HandlerThread.java:61)",
    "comments_url": "https://api.github.com/repos/google/ExoPlayer/issues/3405/comments",
    "author": "rranjithkumar100",
    "comments": [
      {
        "user": "tonihei",
        "created_at": "2017-10-30T09:12:04Z",
        "body": "The problem is that you can't re-use MediaSources. That means you need to create a new movieMediaSource for each ClippingMediaSource. "
      },
      {
        "user": "rranjithkumar100",
        "created_at": "2017-10-31T13:04:58Z",
        "body": "Yes you are right.. @tonihei \r\n\r\nProblem solved. I close this issue \ud83d\udc4d "
      }
    ]
  },
  {
    "number": 3338,
    "title": "Determin when video is stalled",
    "created_at": "2017-10-10T15:14:38Z",
    "closed_at": "2017-10-10T18:37:07Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/google/ExoPlayer/issues/3338",
    "body": "Hello! \r\nI wonder can i determine that video is stalled for buffering?\r\nI try check onPlayerStateChanged. But i don't see ability to get real state of player. I see that STATE_BUFFERING don't mean that player stop video.  \r\nI need to track how many times video is stalled for buffering,",
    "comments_url": "https://api.github.com/repos/google/ExoPlayer/issues/3338/comments",
    "author": "Anton111111",
    "comments": [
      {
        "user": "tonihei",
        "created_at": "2017-10-10T15:19:45Z",
        "body": "When the player state changes to STATE_BUFFERING is does exactly that - stop the video playback and buffer data only. Why do you think the player is still playing? "
      },
      {
        "user": "Anton111111",
        "created_at": "2017-10-10T15:23:05Z",
        "body": "I just write to the log state of the player. And I see that the video is playing, but STATE_BUFFERING sometimes appears in the log"
      },
      {
        "user": "tonihei",
        "created_at": "2017-10-10T15:35:19Z",
        "body": "You probably also see a change back to STATE_READY? That indicates the player continues playing. \r\n\r\nIf you like to look any further please also fill out the issue template describing how we can reproduce your problem exactly and also provide example media producing this problem."
      },
      {
        "user": "Anton111111",
        "created_at": "2017-10-10T15:40:26Z",
        "body": "Oh. It's not problem ;)  Only question."
      },
      {
        "user": "ojw28",
        "created_at": "2017-10-10T18:37:07Z",
        "body": "You should see that `STATE_BUFFERING` corresponds to periods of time during which the player is stalled buffering. The ExoPlayer demo app outputs state transitions to logcat, and I see them occurring as expected. You can view these state transitions using `adb logcat` during playback. To get just event transition lines, you can use `adb logcat | grep \"EventLogger: state\"`.\r\n\r\nIf you feel there's still a problem, please provide a log captured during usage of the ExoPlayer demo app, annotated with the point at which you think the reported state is incorrect. Thanks!"
      }
    ]
  },
  {
    "number": 3177,
    "title": "skipping 10 sec forward of backward",
    "created_at": "2017-08-16T07:55:07Z",
    "closed_at": "2017-08-16T09:29:11Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/google/ExoPlayer/issues/3177",
    "body": "First of all I want to say sorry if this is duplicate question, I couldn't find the same or similar question.\r\n\r\nQuestion:\r\nIs there an option in exoplayer that allows skipping 10 seconds forward or backward? This feature is something like on YouTube when you press right or left arrow( J or L keys).\r\n\r\nThanks",
    "comments_url": "https://api.github.com/repos/google/ExoPlayer/issues/3177/comments",
    "author": "lazarvgd",
    "comments": [
      {
        "user": "ojw28",
        "created_at": "2017-08-16T08:00:55Z",
        "body": "`player.seekTo(player.getCurrentPosition() + 10000)` would seek forward 10 seconds (similar to seek backward)?"
      },
      {
        "user": "lazarvgd",
        "created_at": "2017-08-16T09:29:11Z",
        "body": "Thank you very much sir! :+1: "
      }
    ]
  },
  {
    "number": 3124,
    "title": "Question: Is there a same function in v2 for onDownstreamFormatChanged(v1)",
    "created_at": "2017-08-01T03:08:45Z",
    "closed_at": "2017-08-02T02:46:00Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/google/ExoPlayer/issues/3124",
    "body": "I am upgrading a video app from v1 to v2,  there is a third party logic added in the method onDownstreamFormatChanged as below \r\nfor example in the DemoPlayer in v1:\r\n```\r\n@Override\r\n\tpublic void onDownstreamFormatChanged(int sourceId, Format format, int trigger, long mediaTimeMs) {\r\n\t\tif (infoListener == null) {\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif (sourceId == TYPE_VIDEO) {\r\n\t\t\tvideoBitrate = format.bitrate;\r\n\t\t\tvideoFormat = format;\r\n\t\t\tinfoListener.onVideoFormatEnabled(format, trigger, mediaTimeMs);\r\n\t\t} else if (sourceId == TYPE_AUDIO) {\r\n\t\t\taudioBitrate = format.bitrate;\r\n\t\t\tinfoListener.onAudioFormatEnabled(format, trigger, mediaTimeMs);\r\n\t\t}\r\n\r\n\t\tif (videoBitrate > 0 && audioBitrate > 0) {\r\n\t\t\tAnalyticsManager.onBitrateChange(((audioBitrate + videoBitrate) / 1000));\r\n\t\t}\r\n\t}\r\n```\r\nas you can see there is a piece of code  AnalyticsManager.onBitrateChange(((audioBitrate + videoBitrate) / 1000));   is there function that i can add this code in the exoplayer v2?\r\n\r\nThanks in advance.\r\n\r\n",
    "comments_url": "https://api.github.com/repos/google/ExoPlayer/issues/3124/comments",
    "author": "jiafei1986",
    "comments": [
      {
        "user": "ojw28",
        "created_at": "2017-08-01T11:28:16Z",
        "body": "There is still an `onDownstreamFormatChanged` in V2 (and it's used in `EventLogger` in the demo app)."
      },
      {
        "user": "jiafei1986",
        "created_at": "2017-08-02T02:46:00Z",
        "body": "@ojw28 thank you, just found out it ."
      }
    ]
  },
  {
    "number": 3065,
    "title": "Change Subtitles Style",
    "created_at": "2017-07-14T13:19:49Z",
    "closed_at": "2017-07-16T07:11:56Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/google/ExoPlayer/issues/3065",
    "body": "am developing simple video player with vtt subtitles\r\nI want to change styles for captions by\r\n\r\n      private void configureSubtitleView() {\r\n        int defaultSubtitleColor = Color.argb(255, 218, 218, 218);\r\n        int outlineColor = Color.argb(255, 43, 43, 43);\r\n        Typeface subtitleTypeface = Typeface.createFromAsset(getAssets(), \"fonts/droid.ttf\");\r\n        CaptionStyleCompat style =\r\n                new CaptionStyleCompat(defaultSubtitleColor,\r\n                        Color.TRANSPARENT, Color.TRANSPARENT,\r\n                        CaptionStyleCompat.EDGE_TYPE_OUTLINE,\r\n                        outlineColor, subtitleTypeface);\r\n        subtitleLayout.setStyle(style);\r\n        subtitleLayout.setFractionalTextSize(SubtitleView.DEFAULT_TEXT_SIZE_FRACTION * fontScale);\r\n    }\r\n\r\nand call it in **onCreate** method, but nothing changed. is that an issue or I have missed something.",
    "comments_url": "https://api.github.com/repos/google/ExoPlayer/issues/3065/comments",
    "author": "hawkiq",
    "comments": [
      {
        "user": "ojw28",
        "created_at": "2017-07-15T21:13:55Z",
        "body": "Does it help if you call `subtitleLayout.setApplyEmbeddedStyles(false)`?"
      },
      {
        "user": "hawkiq",
        "created_at": "2017-07-16T07:11:56Z",
        "body": "@ojw28 thanks for pointing me to disable default style which results to know that I have used SimpleExoPlayerView so to make changes to subtitles I must call\r\n\r\n     simpleExoPlayerView = (SimpleExoPlayerView) findViewById(R.id.PlayerView);\r\n     simpleExoPlayerView.getSubtitleView().setStyle(style);\r\n\r\nthanks."
      }
    ]
  },
  {
    "number": 3061,
    "title": "Question:How to set max bit rate in exoplayer v2",
    "created_at": "2017-07-13T15:52:23Z",
    "closed_at": "2017-07-14T02:24:03Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/google/ExoPlayer/issues/3061",
    "body": "I am now doing the video app of dash, there is a requirement to let the user choose video quality\r\nthere are 4 types (auto, high, medium,low),  the high, medium,low will be configed in the backend.\r\n\r\nI know there is a method in v1 DashRendererBuilder.setMaxBitrate(maxBitrate); but is there an easy way to set it in v2?\r\nThanks.",
    "comments_url": "https://api.github.com/repos/google/ExoPlayer/issues/3061/comments",
    "author": "jiafei1986",
    "comments": [
      {
        "user": "ojw28",
        "created_at": "2017-07-13T16:36:58Z",
        "body": "We centralized everything to do with track selection in V2. Assuming you have a `DefaultTrackSelector` somewhere, you can set the maximum bitrate with:\r\n\r\n```\r\ntrackSelector.setParameters(\r\n    trackSelector.getParameters().withMaxVideoBitrate(maxBitrate));\r\n```\r\n\r\nYou should do this before calling `player.prepare` if you want this to affect the initial track selection."
      },
      {
        "user": "jiafei1986",
        "created_at": "2017-07-14T00:32:22Z",
        "body": "@ojw28 Thanks for your answer. so you mean it will not affect when the user changes the quality during the playback? is it a way to change it during playback?"
      },
      {
        "user": "jiafei1986",
        "created_at": "2017-07-14T02:24:03Z",
        "body": "@ojw28  I tested this method,  it also affects during playback, thank you very much. Great work!!!"
      },
      {
        "user": "jiafei1986",
        "created_at": "2017-07-29T01:13:10Z",
        "body": "@ojw28 when user select auto, what value should i set to this method?  is it 0? "
      },
      {
        "user": "ojw28",
        "created_at": "2017-07-31T17:35:13Z",
        "body": "Use `Integer.MAX_VALUE` :)."
      },
      {
        "user": "erenbakac",
        "created_at": "2017-10-12T13:15:59Z",
        "body": "Hi,\r\n\r\nHowever i set withMaxVideoBitrate value before player.prepare, player still changes video profiles to higher than i set. For example i set 600.000.  when i checked current video bitrate after i while i get 3.000.000.   \r\n\r\nThe stream has 500.000,900.000,1.500.000,3.000.000 video formats\r\n\r\n\r\n        int maxBitrate=600000;\r\n        player.seekToDefaultPosition();\r\n        trackSelector.getParameters().withMaxVideoBitrate(maxBitrate);\r\n        player.prepare(mediaSource, !haveResumePosition, false);\r\n\r\n"
      }
    ]
  },
  {
    "number": 2990,
    "title": "Background music during video playback",
    "created_at": "2017-06-23T12:55:20Z",
    "closed_at": "2017-06-26T17:05:34Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/google/ExoPlayer/issues/2990",
    "body": "\r\n\r\n### Issue description\r\nI want to implement background music during video playback. I thought of MergingMediaSource, but it seems it does not support this scenario.\r\nYou can have multiple AudioTrack run in parallel, the result is fine. \r\n\r\nSimilar issue is #2200 , but it is closed.",
    "comments_url": "https://api.github.com/repos/google/ExoPlayer/issues/2990/comments",
    "author": "b0g8",
    "comments": [
      {
        "user": "ojw28",
        "created_at": "2017-06-26T17:05:34Z",
        "body": "The answer is the same as in #2200. If you need tight synchronization, you'll probably need to be mixing the audio prior to feeding it into a single AudioTrack instance. This is not a use case we currently support I'm afraid. If you don't need tight synchronization then you can just use two `ExoPlayer` instances (i.e. an extra one for the background music)."
      },
      {
        "user": "b0g8",
        "created_at": "2017-06-26T17:24:53Z",
        "body": "Thanks, I'm trying to use two instances, and share the clock."
      }
    ]
  },
  {
    "number": 2969,
    "title": "UnrecognizedInputFormatException when play dash live stream in v2 ",
    "created_at": "2017-06-19T13:11:15Z",
    "closed_at": "2017-06-19T14:59:23Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/google/ExoPlayer/issues/2969",
    "body": "There is a live stream(dash with widevine),  it worked fine in exoplayer v1, but after upgrade to v2, it shows below error   \r\n```                                              com.google.android.exoplayer2.source.UnrecognizedInputFormatException: None of the available extractors (MatroskaExtractor, FragmentedMp4Extractor, Mp4Extractor, Mp3Extractor, AdtsExtractor, Ac3Extractor, TsExtractor, FlvExtractor, OggExtractor, PsExtractor, WavExtractor) could read the stream.\r\n                                                                       at com.google.android.exoplayer2.source.ExtractorMediaPeriod$ExtractorHolder.selectExtractor(ExtractorMediaPeriod.java:722)\r\n                                                                       at com.google.android.exoplayer2.source.ExtractorMediaPeriod$ExtractingLoadable.load(ExtractorMediaPeriod.java:645)\r\n                                                                       at com.google.android.exoplayer2.upstream.Loader$LoadTask.run(Loader.java:295)\r\n                                                                       at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1133)\r\n                                                                       at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:607)\r\n                                                                       at java.lang.Thread.run(Thread.java:761)\r\n06-19 22:23:13.812 2750-3372/com.test.player E/ExoPlayerImplInternal: Source error.\r\n                                                                             com.google.android.exoplayer2.source.UnrecognizedInputFormatException: None of the available extractors (MatroskaExtractor, FragmentedMp4Extractor, Mp4Extractor, Mp3Extractor, AdtsExtractor, Ac3Extractor, TsExtractor, FlvExtractor, OggExtractor, PsExtractor, WavExtractor) could read the stream.\r\n                                                                                 at com.google.android.exoplayer2.source.ExtractorMediaPeriod$ExtractorHolder.selectExtractor(ExtractorMediaPeriod.java:722)\r\n                                                                                 at com.google.android.exoplayer2.source.ExtractorMediaPeriod$ExtractingLoadable.load(ExtractorMediaPeriod.java:645)\r\n                                                                                 at com.google.android.exoplayer2.upstream.Loader$LoadTask.run(Loader.java:295)\r\n                                                                                 at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1133)\r\n                                                                                 at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:607)\r\n                                                                                 at java.lang.Thread.run(Thread.java:761)\r\n06-19 22:23:13.812 2750-2750/com.test.player E/playback\u00a0error\u00a0>>>: com.google.android.exoplayer2.ExoPlaybackException\r\n```\r\nShould I email you the MPD file?\r\nThanks.\r\n",
    "comments_url": "https://api.github.com/repos/google/ExoPlayer/issues/2969/comments",
    "author": "jiafei1986",
    "comments": [
      {
        "user": "ojw28",
        "created_at": "2017-06-19T13:46:21Z",
        "body": "You're trying to play a DASH stream using `ExtractorMediaSource`, where-as you should be using `DashMediaSource`."
      },
      {
        "user": "jiafei1986",
        "created_at": "2017-06-19T14:49:03Z",
        "body": "@ojw28 Thank you very very much, i just check the code, found the playback URL does not end with mpd, so the sample code will use ExtractorMediaSource,  now i force to use DashMediaSource, the problem fixed.  THANK YOU !!!!"
      }
    ]
  },
  {
    "number": 2823,
    "title": "A more convenient access to certain lifecycle event ",
    "created_at": "2017-05-14T13:10:45Z",
    "closed_at": "2017-05-15T14:30:46Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/google/ExoPlayer/issues/2823",
    "body": "Hello,\r\n\r\nThis is a request for a small adjustment.\r\n\r\nIn the `LoadControl` interface lies a certain number of very useful methods related to the exoplayer lifecycle:\r\n\r\nonPrepared()\r\nonReleased()\r\nonStopped()\r\n\r\nHowever at this point, we can only pass one instance of a `LoadControl` implementation into the `ExoPlayerFactory`, and by default this implementation is `DefaultLoadControl`, a class marked as final.\r\n\r\nRight now, the only way I can access these callbacks in my project is by implementing my own `LoadControl` logic (that is copy pasting the DefaultLoadControl class and tweaking it a bit).\r\n\r\nI think these kind of callbacks deserve their own separate interface so they can be accessed more conveniently.\r\n\r\nThanks",
    "comments_url": "https://api.github.com/repos/google/ExoPlayer/issues/2823/comments",
    "author": "q-litzler",
    "comments": [
      {
        "user": "ojw28",
        "created_at": "2017-05-15T01:19:59Z",
        "body": "These aren't intended for general purpose use outside of the player. They're intended for the `LoadControl` specifically. Note also that they're invoked directly on the player's internal playback thread, which is normally not what you'd want if you're trying to implement some external logic.\r\n\r\nIt's likely that whatever you're trying to do would be better off done in some other way, for example using an `ExoPlayer.EventListener`. What is it that you're trying to do, and why are the existing event listener callbacks not sufficient?"
      },
      {
        "user": "q-litzler",
        "created_at": "2017-05-15T09:58:09Z",
        "body": "What I need is to know precisely when the player is done preparing its `MediaSource`. I would love if there was a dedicated method in `ExoPlayer.EventListener` for that, but that is not the case right now.\r\nThat's why I have been using the `LoadControl` interface, I know it's not meant to be used for this, but it's the only solution I could come up with. I'm not asking for a modification of the `LoadControl` interface, it's fine as it is.\r\nBut a similiar `onPrepared` callback in `ExoPlayer.EventListener` would be greatly appreciated.\r\n\r\nConsider this simple scenario: I want to display a player only when the source is 100% ready to be played (It is part of the advertisement experience of the app I'm working on) and I want the assurance that this callback will not be called several times over the course of the MediaSource lifecycle (like it would be if I were using the `onLoadingChanged` or `onPlayerStateChanged` methods for example)"
      },
      {
        "user": "ojw28",
        "created_at": "2017-05-15T14:30:46Z",
        "body": "I don't think `LoadControl.onPrepared` is called when you think it is. It's called as soon as the playback thread receives the `MediaSource` but before it's actually done anything with it. There will typically be zero buffer at the point when it's fired. So it doesn't seem at all correct for the use case you describe.\r\n\r\nIf you want to do something when the player is ready to be played then you should use `ExoPlayer.EventListener.onPlayerStateChanged`. The first call with `playbackState == ExoPLayer.STATE_READY` is the point at which the player is ready."
      },
      {
        "user": "q-litzler",
        "created_at": "2017-05-15T15:54:44Z",
        "body": "Ok, good to know. Thank you."
      }
    ]
  },
  {
    "number": 2764,
    "title": "Adding request headers to ExtractorMediaSource ",
    "created_at": "2017-05-03T13:20:53Z",
    "closed_at": "2017-05-06T10:25:35Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/google/ExoPlayer/issues/2764",
    "body": "Hello,\r\n I need to add request headers for playing video with exoplayer. I could see it was available with ExtractorSampleSource and I could not add the same with ExtractorMediaSource. Also i dont see  ExtractorSampleSource part of r2.3.1.  Kindly help",
    "comments_url": "https://api.github.com/repos/google/ExoPlayer/issues/2764/comments",
    "author": "Arunkarthicknallasami",
    "comments": [
      {
        "user": "ojw28",
        "created_at": "2017-05-04T17:37:49Z",
        "body": "We will try and document customization points such as this a little better. You can do what you want as follows:\r\n\r\n```\r\nDefaultHttpDataSourceFactory dataSourceFactory = new DefaultHttpDataSourceFactory(userAgent);\r\ndataSourceFactory.getDefaultRequestProperties().set(\"headerName\", \"headerValue\");\r\nreturn new ExtractorMediaSource(uri, dataSourceFactory, ...);\r\n```"
      },
      {
        "user": "Arunkarthicknallasami",
        "created_at": "2017-05-06T10:25:33Z",
        "body": "Thank you so much that helped a lot. :)"
      }
    ]
  },
  {
    "number": 2504,
    "title": "Media Metadata tags",
    "created_at": "2017-02-26T12:42:32Z",
    "closed_at": "2017-02-27T10:28:10Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/google/ExoPlayer/issues/2504",
    "body": "First thanks to this awesome library . \r\n\r\nSecond simply : **how can i get** loaded media(MP3/OGG/..) **meta data**(Artist , name,track no ,year and .. ) ? \r\nWhat about audio file artwork graphic ?",
    "comments_url": "https://api.github.com/repos/google/ExoPlayer/issues/2504/comments",
    "author": "thesiamak",
    "comments": [
      {
        "user": "ojw28",
        "created_at": "2017-02-27T10:28:08Z",
        "body": "If you're using the ExoPlayer V2 demo app then you should see metadata output to logcat with the log tag \"EventLogger\". It should be pretty easy for you to find where that happens in the demo app code, and then go from there.\r\n\r\nWe currently parse metadata for MP3 and MP4. I don't think we parse metadata for OGG yet. Please file a separate feature request if you're able to confirm that this is the case, linking or attaching media that you know to contain metadata that's not being output to \"EventLogger\". Thanks!"
      },
      {
        "user": "thesiamak",
        "created_at": "2017-02-27T12:11:26Z",
        "body": "At this time i just need MP3 metadatas .\r\nI was be able to get metadata via the method that demo app uses to(EventLogger) but obviously developers need a simpler way to get this information.\r\n\r\nThanks a lot for your help \r\n"
      },
      {
        "user": "ojw28",
        "created_at": "2017-02-27T12:43:17Z",
        "body": "I'm not sure developers do need a simpler way. It's pretty simple already, once you remove the parts that you don't need:\r\n\r\n```\r\nMappedTrackInfo mappedTrackInfo = trackSelector.getCurrentMappedTrackInfo();\r\nif (mappedTrackInfo != null) {\r\n  for (int rendererIndex = 0; rendererIndex < mappedTrackInfo.length; rendererIndex++) {\r\n    TrackSelection trackSelection = trackSelections.get(rendererIndex);\r\n    if (trackSelection != null) {\r\n      for (int selectionIndex = 0; selectionIndex < trackSelection.length(); selectionIndex++) {\r\n        Metadata metadata = trackSelection.getFormat(selectionIndex).metadata;\r\n        if (metadata != null) {\r\n          // Metadata!\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n```\r\n\r\nI'm not convinced that it's possible to make it simpler without introducing assumptions that might be true in your simple use case, but that may not be true in the general case (e.g. the assumption that there's only one set of metadata in the media, rather than potentially multiple pieces of metadata attached to different tracks, which may or may not be selected)."
      },
      {
        "user": "thesiamak",
        "created_at": "2017-02-27T13:07:51Z",
        "body": "Now it's more clear! I was using a wrong and complicated method(Passing an interface to Logger) . I appreciate that.\r\nCould you please let me know how to get MP3 artwork graphic too ? Since i couldn't find appropriate field for that in meta data(It's displaying an empty field in Logcat) i was looking for a way to get selected tracks artwork(cover) url . The goal is to load image in an ImageView."
      },
      {
        "user": "ojw28",
        "created_at": "2017-02-27T13:10:25Z",
        "body": "`SimpleExoPlayerView` pulls the artwork out of the `Metadata` object to display it, so take a look at what that class does (specifically, look at `SimpleExoPlayerView.setArtworkFromMetadata`)."
      }
    ]
  },
  {
    "number": 2460,
    "title": "How to hide all control components?",
    "created_at": "2017-02-16T04:02:53Z",
    "closed_at": "2017-02-16T17:43:36Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/google/ExoPlayer/issues/2460",
    "body": "How to hide all controllers  (start button, pause, and so on) that they did not exist, and the screen will always full.\r\n\r\nI looked, there is simpleExoPlayerView.setUseController(true) method;\r\n\r\nBut it deactivate the player ...\r\n\r\n```\r\npublic void setUseController (boolean useController) {\r\n    this.useController = useController;\r\nif (useController) {\r\n      controller.setPlayer(player);\r\n    } else {\r\n      controller.hide();\r\n      controller.setPlayer(null);\r\n    }\r\n}\r\n```\r\nHow to hide or delete these components?",
    "comments_url": "https://api.github.com/repos/google/ExoPlayer/issues/2460/comments",
    "author": "ghost",
    "comments": [
      {
        "user": "directable",
        "created_at": "2017-02-16T04:17:01Z",
        "body": "Have you tried just doing\r\nsimpleExoPlayerView.setUseController(false);\r\nsimpleExoPlayerView.hideController();\r\n\r\nsimpleExoPlayerView.setPlayer(playeryoucreated);\r\n"
      },
      {
        "user": "ghost",
        "created_at": "2017-02-16T04:20:53Z",
        "body": "this method is not - hideController()\r\nBut it works for me. Thank you!\r\n```\r\nsimpleExoPlayerView.setUseController(false);\r\nsimpleExoPlayerView.setPlayer(playeryoucreated);\r\n```\r\n"
      }
    ]
  },
  {
    "number": 2407,
    "title": "Font color of subtitle is not changing using CaptionStyleCompat",
    "created_at": "2017-02-01T10:46:36Z",
    "closed_at": "2017-02-01T12:19:48Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/google/ExoPlayer/issues/2407",
    "body": "My requirement is to change the font color of Closed caption sub title text. For fulfill requirement I am using\r\n```\r\ncaptionStyleCompat = new CaptionStyleCompat(Color.BLACK, Color.BLUE, Color.TRANSPARENT, CaptionStyleCompat.EDGE_TYPE_DROP_SHADOW, Color.GREEN, null);\r\n\r\nsimpleExoPlayerView.getSubtitleView().setStyle(captionStyleCompat);\r\n```\r\nAs per above method my subtitle font color should be black. but still it is default color that is white where as background color has been changed from black to blue.\r\nWhy font color is not changed to black from its default color? I am also changing different color of first and second parameter. All the time background has been changed but foreground has not been changed.\r\n\r\nAs per documentation there is no any method found to change the font color of subtitle text.\r\n",
    "comments_url": "https://api.github.com/repos/google/ExoPlayer/issues/2407/comments",
    "author": "shailesh2208",
    "comments": [
      {
        "user": "ojw28",
        "created_at": "2017-02-01T11:25:31Z",
        "body": "It depends a bit on the source media. If the media doesn't say anything about the caption style, then what you've done should work fine. If the media explicitly indicates a caption style, then anything it indicates takes priority by default. Given what you're seeing, I suspect the media has an explicit embedded caption style that specifies white text.\r\n\r\nYou can disable application of embedded caption styles and have ExoPlayer use only the style you provide by calling `simpleExoPlayerView.getSubtitleView().setApplyEmbeddedStyles(false)`. Please give that a try and let us know if it works. Thanks!"
      },
      {
        "user": "shailesh2208",
        "created_at": "2017-02-01T12:15:53Z",
        "body": "Hi ojw28,\r\nUsing `simpleExoPlayerView.getSubtitleView().setApplyEmbeddedStyles(false)` It is working now. Thank u so much for suggestion."
      }
    ]
  },
  {
    "number": 2357,
    "title": "set equalizer",
    "created_at": "2017-01-22T16:10:22Z",
    "closed_at": "2017-01-23T18:28:38Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/google/ExoPlayer/issues/2357",
    "body": "Hello! I got following code to play mp3 tracks. What should i do to get audioSessionId correct? When i try with getAudioSessionId() and give result to equalizer constructor it says following:\r\nRuntimeException: Cannot initialize effect engine for type: 0bed4300-ddd6-11db-8f34-0002a5d5c51b Error: -3.\r\n\r\nMy code:\r\n```\r\n private void createPlayer(){\r\n        TrackSelector trackSelector = new DefaultTrackSelector();\r\n        LoadControl loadControl = new DefaultLoadControl();\r\n        player = ExoPlayerFactory.newSimpleInstance(context, trackSelector, loadControl);\r\n        player.addListener(this);\r\n    }\r\n\r\npublic void playTrack(Track track) {\r\n        createPlayer();\r\n        this.track = track;\r\n        this.url = track.getPath();\r\n        Uri builtUri = Uri.parse(url);\r\n        DataSource.Factory dataSourceFactory = new DefaultDataSourceFactory(context, Util.getUserAgent(context, \"yourApplicationName\"));\r\n        ExtractorsFactory extractorsFactory = new DefaultExtractorsFactory();\r\n        MediaSource streamSource = new ExtractorMediaSource(builtUri, dataSourceFactory, extractorsFactory, null, null);\r\n        isNotificated = false;\r\n        type = Player_Fragment.Type.MEMORY;\r\n        setVolumeMax();\r\n        player.prepare(streamSource);\r\n        player.setPlayWhenReady(true);\r\n}\r\n```",
    "comments_url": "https://api.github.com/repos/google/ExoPlayer/issues/2357/comments",
    "author": "Merseyside",
    "comments": [
      {
        "user": "ojw28",
        "created_at": "2017-01-23T09:27:21Z",
        "body": "The sample code you've provided lacks the very piece you're asking for help on (i.e. any handling of audioSessionId), which makes it quite difficult for us to help."
      },
      {
        "user": "Merseyside",
        "created_at": "2017-01-23T13:45:07Z",
        "body": "```\r\n@Override\r\n    public void onPlayerStateChanged(boolean playWhenReady, int playbackState) {\r\n        if (playbackState == ExoPlayer.STATE_ENDED){\r\n            if (isLooping){\r\n                playTrack(track);\r\n            }\r\n            else if (!isNotificated) myInterface.endOfTrack();\r\n        }\r\n        else if (playbackState == ExoPlayer.STATE_READY){\r\n            EqualizerEngine equalizerEngine = new EqualizerEngine(context);\r\n            PrintString.printLog(\"Equalizer\", player.getAudioSessionId() + \"\");\r\n            equalizerEngine.setEqualizers(player.getAudioSessionId());\r\n        }\r\n    }\r\n```\r\nthis override method, where i try to get audioSessionId, but it always equals zero"
      },
      {
        "user": "ojw28",
        "created_at": "2017-01-23T14:24:02Z",
        "body": "That means it hasn't been set yet. You can use `player.setAudioDebugListener` to listen for the ID being set (the ID will be passed via `onAudioSessionId` when it is)."
      },
      {
        "user": "Merseyside",
        "created_at": "2017-01-23T14:24:52Z",
        "body": "okay, i will try it. Thanks very muck"
      },
      {
        "user": "Merseyside",
        "created_at": "2017-01-23T18:20:00Z",
        "body": "It works, thanks)"
      }
    ]
  },
  {
    "number": 2332,
    "title": "STATE_ENDED not detected r2.1.1",
    "created_at": "2017-01-16T05:25:40Z",
    "closed_at": "2017-01-16T14:14:18Z",
    "labels": [
      "question",
      "wont fix: infeasible"
    ],
    "url": "https://github.com/google/ExoPlayer/issues/2332",
    "body": "STATE_ENDED not detected. Video repeating , looping never stoped. if i remove \" exoplayerview.setPlayer(exoplayer);\" only audio playing not repeating \r\n\r\n\r\n ` BandwidthMeter defaultBandWidthMeter = new DefaultBandwidthMeter();\r\n        TrackSelection.Factory videoTrackSelectionFactory =\r\n                new AdaptiveVideoTrackSelection.Factory(defaultBandWidthMeter);\r\n        TrackSelector trackSelector = new DefaultTrackSelector(videoTrackSelectionFactory);\r\n        LoadControl loadControl = new DefaultLoadControl();\r\n        exoplayer = ExoPlayerFactory.newSimpleInstance(this, trackSelector, loadControl);\r\n        exoplayerview.setPlayer(exoplayer);\r\n       // exoplayer.setPlayWhenReady(true);\r\n        DataSource.Factory dataSourceFactory = new DefaultDataSourceFactory(\r\n                this,\r\n                Util.getUserAgent(this, getString(R.string.app_name)),\r\n                (DefaultBandwidthMeter) defaultBandWidthMeter\r\n        );\r\n        ExtractorsFactory extractorsFactory = new DefaultExtractorsFactory();\r\n        MediaSource videoSource = new ExtractorMediaSource(\r\n                Uri.parse(VIDEO_URL),\r\n                dataSourceFactory,\r\n                extractorsFactory,\r\n                null, null\r\n        );\r\n        LoopingMediaSource loopingSource = new LoopingMediaSource(videoSource);\r\n        exoplayer.prepare(loopingSource);\r\n\r\n\r\n        exoplayer.addListener(new ExoPlayer.EventListener() {\r\n\r\n            @Override\r\n            public void onLoadingChanged(boolean isLoading) {\r\n                Log.v(\"isLoading\",\"Listener-onLoadingChanged...\");\r\n\r\n            }\r\n\r\n            @Override\r\n            public void onPlayerStateChanged(boolean playWhenReady, int playbackState) {\r\n                Log.v(\"playWhenReady\",\"Listener-onPlayerStateChanged...\");\r\n\r\n                switch(playbackState) {\r\n                    case ExoPlayer.STATE_BUFFERING:\r\n                        videoprogressBar.setVisibility(View.VISIBLE);\r\n                        exo_play.setVisibility(View.GONE);\r\n                        exo_pause.setVisibility(View.GONE);\r\n                        break;\r\n                    case ExoPlayer.STATE_ENDED:\r\n                        exoplayer.setPlayWhenReady(false);\r\n                        exoplayer.seekTo(0,0);\r\n                        Toast.makeText(VideoView_Activity.this, \"stoped\", Toast.LENGTH_LONG).show();\r\n                        Log.v(\"naagu\",\"Listener-onLoadingChanged...\");\r\n                        break;\r\n                    case ExoPlayer.STATE_IDLE:\r\n                        break;\r\n\r\n                    case ExoPlayer.STATE_READY:\r\n                        if (exoplayer.getPlayWhenReady()) {\r\n                            videoprogressBar.setVisibility(View.GONE);\r\n                        } else {\r\n\r\n                        }\r\n                        break;\r\n                    default:\r\n                        break;\r\n                }\r\n\r\n            }\r\n\r\n            @Override\r\n            public void onTimelineChanged(Timeline timeline, Object manifest) {\r\n                Log.v(\"timeline\",\"Listener-onTimelineChanged...\");\r\n\r\n            }\r\n\r\n            @Override\r\n            public void onTracksChanged(TrackGroupArray trackGroups, TrackSelectionArray trackSelections) {\r\n\r\n            }\r\n\r\n            @Override\r\n            public void onPlayerError(ExoPlaybackException error) {\r\n\r\n            }\r\n\r\n            @Override\r\n            public void onPositionDiscontinuity() {\r\n                Log.v(\"onPositionDiscontinuity\",\"Listener-onPositionDiscontinuity...\");\r\n\r\n            }\r\n        });\r\n        exoplayer.setPlayWhenReady(true);\r\n`",
    "comments_url": "https://api.github.com/repos/google/ExoPlayer/issues/2332/comments",
    "author": "Naguchennai",
    "comments": [
      {
        "user": "AquilesCanta",
        "created_at": "2017-01-16T10:13:42Z",
        "body": "This is working as intended. As you mention, you are using a LoopingMediaSource, so the player doesn't end because the media goes on \"_forever_\".\r\n\r\nCould you please clarify:\r\n>  if i remove \" exoplayerview.setPlayer(exoplayer);\" only audio playing not repeating\r\n\r\nIf you remove that line the player actually reaches ENDED state? Or it doesn't but the audio doesn't loop, as it would with the line."
      },
      {
        "user": "Naguchennai",
        "created_at": "2017-01-16T14:14:16Z",
        "body": "@AquilesCanta thank you my mistake "
      }
    ]
  },
  {
    "number": 2286,
    "title": "SimpleExoPlayer.setVideoListener() causes rendering issues r2.1.1",
    "created_at": "2017-01-03T14:12:35Z",
    "closed_at": "2017-01-04T10:51:19Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/google/ExoPlayer/issues/2286",
    "body": "Setting SimpleExoPlayer.VideoListener() causes rendering issues (SimpleExoPlayerView does not show any frames). audio plays fine and even the VideoListener's are invoked properly. Am I missing something here?\r\nFollowing code illustrates the problem.\r\n\r\n```\r\n   private void playStream(final Uri mediaUrl) {\r\n        Log.d(LOGTAG, \"Now playing: \" + mediaUrl);\r\n        mUrl.setText(mediaUrl.toString());\r\n        // Measures bandwidth during playback. Can be null if not required.\r\n        DefaultBandwidthMeter bandwidthMeter = new DefaultBandwidthMeter();\r\n        // Produces DataSource instances through which media data is loaded.\r\n        DataSource.Factory dataSourceFactory = new DefaultDataSourceFactory(this, Util.getUserAgent(this, \"yourApplicationName\"), bandwidthMeter);\r\n        // Produces Extractor instances for parsing the media data.\r\n        ExtractorsFactory extractorsFactory = new DefaultExtractorsFactory();\r\n        // This is the MediaSource representing the media to be played.\r\n        MediaSource videoSource;\r\n        if(mediaUrl.getLastPathSegment().contains(\".m3u8\"))\r\n            videoSource = new HlsMediaSource(mediaUrl,dataSourceFactory, 10, null, null);\r\n        else\r\n            videoSource = new ExtractorMediaSource(mediaUrl,dataSourceFactory, extractorsFactory, null, null);\r\n        // Following listener breaks rendering\r\n        player.setVideoListener(new SimpleExoPlayer.VideoListener() {\r\n            @Override\r\n            public void onVideoSizeChanged(int width, int height, int unappliedRotationDegrees, float pixelWidthHeightRatio) {\r\n                Log.e(LOGTAG, \"onVideoSizeChanged: \" + width + \":\" +height);\r\n            }\r\n\r\n            @Override\r\n            public void onRenderedFirstFrame() {\r\n                Log.e(LOGTAG, \"onRenderedFirstFrame \");\r\n            }\r\n        });\r\n        // Prepare the player with the source.\r\n        player.prepare(videoSource);\r\n        player.setPlayWhenReady(true);\r\n    }\r\n```\r\nReplacing setVideoListener() with setVideoDebugListener() solves the issue.\r\nTested on Nexus 9 running 7.0",
    "comments_url": "https://api.github.com/repos/google/ExoPlayer/issues/2286/comments",
    "author": "pilzflorian",
    "comments": [
      {
        "user": "ojw28",
        "created_at": "2017-01-03T14:54:45Z",
        "body": "SimpleExoPlayerView registers itself as the video listener, so when you set it you're replacing SimpleExoPlayerView as the listener. Hence SimpleExoPlayerView doesn't receive the events that it needs.\r\n\r\nWhy do you need to register a video listener when also using SimpleExoPlayerView?"
      },
      {
        "user": "pilzflorian",
        "created_at": "2017-01-04T10:51:19Z",
        "body": "Thank you so much for clarification, I will create my own SurfaceView and Controller instances. \r\nI need the information for gathering QOS statistics.\r\nI'll close this, thanks again for the quick response!"
      },
      {
        "user": "ojw28",
        "created_at": "2017-01-04T10:55:10Z",
        "body": "You should use `setVideoDebugListener` to gather QOS statistics, and let the view use `setVideoListener`."
      }
    ]
  },
  {
    "number": 2053,
    "title": "Playlist refresh UI",
    "created_at": "2016-11-09T20:16:37Z",
    "closed_at": "2016-11-09T23:10:35Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/google/ExoPlayer/issues/2053",
    "body": "onPlayerStateChanged it's not called when a playlist change from one song to another\r\n",
    "comments_url": "https://api.github.com/repos/google/ExoPlayer/issues/2053/comments",
    "author": "irenecs",
    "comments": [
      {
        "user": "ojw28",
        "created_at": "2016-11-09T20:29:05Z",
        "body": "Why would you expect it to change? One of the key selling points of playlist support in V2 is that we can perform transitions seamlessly, which means there wont be any changes to player state across the transition ;). You should probably be looking at `onPositionDiscontinuity` instead, which is invoked on seeks and also when transitioning from one song to the next.\n"
      },
      {
        "user": "irenecs",
        "created_at": "2016-11-09T20:35:18Z",
        "body": " i would like to refresh  my UI when the song on the playlist change \n"
      },
      {
        "user": "ojw28",
        "created_at": "2016-11-09T20:43:53Z",
        "body": "Yes. So use `onPositionDiscontinuity`. From there, you can use `ExoPlayer.getCurrentWindowIndex` to see the index of the track being played. If it's changed then you can refresh the UI accordingly.\n"
      },
      {
        "user": "irenecs",
        "created_at": "2016-11-09T23:07:27Z",
        "body": "Thx :)  \n"
      }
    ]
  },
  {
    "number": 1918,
    "title": "[Question] Reuse BOTH SimpleExoPlayerView and SimpleExoPlayer after STATE_ENDED",
    "created_at": "2016-10-09T04:40:11Z",
    "closed_at": "2016-10-09T12:48:11Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/google/ExoPlayer/issues/1918",
    "body": "Assuming that I have played a local Video, using those 2 components. After the player reaches STATE_ENDED, it seems that it is not trivial to restart the playback again. What should I do if I want to \"click to one button\" to restart the playback from all over again.\n\nThanks and pardon me if I'm missing some thing.\n",
    "comments_url": "https://api.github.com/repos/google/ExoPlayer/issues/1918/comments",
    "author": "eneim",
    "comments": [
      {
        "user": "ojw28",
        "created_at": "2016-10-09T12:44:42Z",
        "body": "I think it is trivial; just seek back to 0 (by calling seekTo(0)) and that's it? Note that the ExoPlayer demo app allows you to seek back after the state has transitioned to ended (with the player controls).\n"
      },
      {
        "user": "eneim",
        "created_at": "2016-10-09T12:48:11Z",
        "body": "@ojw28 I think I got the solution. Thanks a lot.\n"
      }
    ]
  },
  {
    "number": 1915,
    "title": "Logcat show error when come back the activity. ",
    "created_at": "2016-10-08T07:09:33Z",
    "closed_at": "2016-10-10T03:06:24Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/google/ExoPlayer/issues/1915",
    "body": "Reproduction step:\n1. Play a video with ExoPlayer at a activity, exoPlayer to show the video with surfaceView.\n2. Leave the activity at playing a video.\n3. After that,come back the activity, play the video continue, logcat show error.\n\nNote:\nThe surface view is destroy when i leave the activity, i create a new surface view when come back. The instance of exoPlayer is not destroy throughout the process.\n\nLog:\n\n```\n10-08 15:08:05.028 15837-6568/com.fxtv.threebears E/BufferQueueProducer: [SurfaceTexture-0-15837-11] queueBuffer: BufferQueue has been abandoned\n10-08 15:08:05.028 15837-6568/com.fxtv.threebears E/Surface: queueBuffer: error queuing buffer to SurfaceTexture, -19\n10-08 15:08:05.028 15837-6568/com.fxtv.threebears E/ACodec: queueBuffer failed in onOutputBufferDrained: -19\n10-08 15:08:05.028 15837-6568/com.fxtv.threebears E/ACodec: signalError(omxError 0x80001001, internalError -19)\n10-08 15:08:05.028 15837-6567/com.fxtv.threebears E/MediaCodec: Codec reported err 0xffffffed, actionCode 0, while in state 6\n10-08 15:08:05.036 15837-6529/com.fxtv.threebears E/ExoPlayerImplInternal: Internal runtime error.\n                                                                           java.lang.IllegalStateException\n                                                                               at android.media.MediaCodec.native_dequeueInputBuffer(Native Method)\n                                                                               at android.media.MediaCodec.dequeueInputBuffer(MediaCodec.java:2505)\n                                                                               at com.google.android.exoplayer2.mediacodec.MediaCodecRenderer.feedInputBuffer(MediaCodecRenderer.java:536)\n                                                                               at com.google.android.exoplayer2.mediacodec.MediaCodecRenderer.render(MediaCodecRenderer.java:478)\n                                                                               at com.google.android.exoplayer2.ExoPlayerImplInternal.doSomeWork(ExoPlayerImplInternal.java:431)\n                                                                               at com.google.android.exoplayer2.ExoPlayerImplInternal.handleMessage(ExoPlayerImplInternal.java:265)\n                                                                               at android.os.Handler.dispatchMessage(Handler.java:98)\n                                                                               at android.os.Looper.loop(Looper.java:154)\n                                                                               at android.os.HandlerThread.run(HandlerThread.java:61)\n                                                                               at com.google.android.exoplayer2.util.PriorityHandlerThread.run(PriorityHandlerThread.java:40)\n10-08 15:08:05.066 15837-6568/com.fxtv.threebears E/Surface: getSlotFromBufferLocked: unknown buffer: 0xc40db3a0\n10-08 15:08:05.066 15837-6568/com.fxtv.threebears W/ACodec: [OMX.qcom.video.decoder.avc] can not return buffer 38 to native window\n10-08 15:08:05.067 15837-6568/com.fxtv.threebears E/Surface: getSlotFromBufferLocked: unknown buffer: 0xc40daec0\n10-08 15:08:05.067 15837-6568/com.fxtv.threebears W/ACodec: [OMX.qcom.video.decoder.avc] can not return buffer 37 to native window\n10-08 15:08:05.067 15837-6568/com.fxtv.threebears E/Surface: getSlotFromBufferLocked: unknown buffer: 0xc40daf20\n10-08 15:08:05.067 15837-6568/com.fxtv.threebears W/ACodec: [OMX.qcom.video.decoder.avc] can not return buffer 36 to native window\n10-08 15:08:05.068 15837-6568/com.fxtv.threebears E/Surface: getSlotFromBufferLocked: unknown buffer: 0xc40da440\n10-08 15:08:05.068 15837-6568/com.fxtv.threebears W/ACodec: [OMX.qcom.video.decoder.avc] can not return buffer 35 to native window\n10-08 15:08:05.069 15837-6568/com.fxtv.threebears E/Surface: getSlotFromBufferLocked: unknown buffer: 0xc40db520\n10-08 15:08:05.069 15837-6568/com.fxtv.threebears W/ACodec: [OMX.qcom.video.decoder.avc] can not return buffer 32 to native window\n10-08 15:08:05.069 15837-6568/com.fxtv.threebears E/Surface: getSlotFromBufferLocked: unknown buffer: 0xc40db640\n10-08 15:08:05.069 15837-6568/com.fxtv.threebears W/ACodec: [OMX.qcom.video.decoder.avc] can not return buffer 31 to native window\n10-08 15:08:05.082 15837-15837/com.fxtv.threebears D/fxtv_MeasureHelper: doMeasure,default width size = 2560\n10-08 15:08:05.082 15837-15837/com.fxtv.threebears D/fxtv_MeasureHelper: doMeasure,default height size = 1440\n10-08 15:08:05.083 15837-15837/com.fxtv.threebears D/fxtv_MeasureHelper: doMeasure,result w=2560,h=1440\n10-08 15:08:05.084 15837-15837/com.fxtv.threebears D/fxtv_MeasureHelper: doMeasure,default width size = 2560\n10-08 15:08:05.085 15837-15837/com.fxtv.threebears D/fxtv_MeasureHelper: doMeasure,default height size = 1440\n10-08 15:08:05.085 15837-15837/com.fxtv.threebears D/fxtv_MeasureHelper: doMeasure,result w=2560,h=1440\n10-08 15:08:05.087 15837-6529/com.fxtv.threebears E/ExoPlayerImplInternal: Stop failed.\n                                                                           java.lang.IllegalStateException\n                                                                               at android.media.MediaCodec.native_stop(Native Method)\n                                                                               at android.media.MediaCodec.stop(MediaCodec.java:2005)\n                                                                               at com.google.android.exoplayer2.mediacodec.MediaCodecRenderer.releaseCodec(MediaCodecRenderer.java:441)\n                                                                               at com.google.android.exoplayer2.mediacodec.MediaCodecRenderer.onDisabled(MediaCodecRenderer.java:396)\n                                                                               at com.google.android.exoplayer2.video.MediaCodecVideoRenderer.onDisabled(MediaCodecVideoRenderer.java:275)\n                                                                               at com.google.android.exoplayer2.BaseRenderer.disable(BaseRenderer.java:136)\n                                                                               at com.google.android.exoplayer2.ExoPlayerImplInternal.resetInternal(ExoPlayerImplInternal.java:624)\n                                                                               at com.google.android.exoplayer2.ExoPlayerImplInternal.stopInternal(ExoPlayerImplInternal.java:600)\n                                                                               at com.google.android.exoplayer2.ExoPlayerImplInternal.handleMessage(ExoPlayerImplInternal.java:317)\n                                                                               at android.os.Handler.dispatchMessage(Handler.java:98)\n                                                                               at android.os.Looper.loop(Looper.java:154)\n                                                                               at android.os.HandlerThread.run(HandlerThread.java:61)\n                                                                               at com.google.android.exoplayer2.util.PriorityHandlerThread.run(PriorityHandlerThread.java:40)\n\n```\n",
    "comments_url": "https://api.github.com/repos/google/ExoPlayer/issues/1915/comments",
    "author": "hardcattle",
    "comments": [
      {
        "user": "ojw28",
        "created_at": "2016-10-09T15:50:01Z",
        "body": "The logging is indicative of you not clearing the old `Surface` from the player when it's destroyed. It looks like an application error, in that you're most likely failing to do this.\n"
      },
      {
        "user": "hardcattle",
        "created_at": "2016-10-10T03:06:23Z",
        "body": "Thanks! I forget call the method of clearVideoSurface when it's destroyed.\n"
      }
    ]
  },
  {
    "number": 1892,
    "title": "Calculating size of SurfaceView",
    "created_at": "2016-10-04T16:15:29Z",
    "closed_at": "2016-10-04T18:55:37Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/google/ExoPlayer/issues/1892",
    "body": "Hello all, I am trying to add ExoPlayer 2.0.1 instead of MediaPlayer. With MediaPlayer in the onPrepared() method I use getVideoWidth() and getVideoHeight() to get width and height of video to calculate size of SurfaceView with correct aspect ratio. With ExoPlayer 2.0.1 library I am creating intance of SimpleExoPlayer:\n\n```\n            Handler mainHandler = new Handler();\n            BandwidthMeter bandwidthMeter = new DefaultBandwidthMeter();\n            TrackSelection.Factory videoTrackSelectionFactory =\n                    new AdaptiveVideoTrackSelection.Factory(bandwidthMeter);\n            TrackSelector trackSelector =\n                    new DefaultTrackSelector(mainHandler, videoTrackSelectionFactory);\n            LoadControl loadControl = new DefaultLoadControl();\n            exoPlayer = ExoPlayerFactory.newSimpleInstance(context, trackSelector, loadControl);\n            //simpleExoPlayerView.setPlayer(exoPlayer);\n            exoPlayer.setVideoSurfaceHolder(videoHolder);\n            exoPlayer.addListener(this);\n```\n\nI suppose I need to use this event to get width and height, but this event is not fired, why and what should I use? onPlayerStateChanged event is working.\n\n```\n    @Override\n    public void onVideoSizeChanged(int width, int height, int unappliedRotationDegrees,\n                                   float pixelWidthAspectRatio) {\n        appendLog(\"onVideoSizeChanged: \" +  String.valueOf(width) + \", \" + String.valueOf(height) + \", \" + String.valueOf(pixelWidthAspectRatio));\n    }\n```\n\nTried it on Android 6 on Sony Z3 Compact, LG Spirit.\n",
    "comments_url": "https://api.github.com/repos/google/ExoPlayer/issues/1892/comments",
    "author": "AntonAndev",
    "comments": [
      {
        "user": "ojw28",
        "created_at": "2016-10-04T18:50:20Z",
        "body": "Where in your code are you registering the listener? There should be a call to `SimpleExoPlayer.setVideoListener` somewhere?\n"
      },
      {
        "user": "AntonAndev",
        "created_at": "2016-10-04T18:55:32Z",
        "body": "oh yes, added it, now works, I was thinking addListener does it, thank you.\n"
      }
    ]
  },
  {
    "number": 1501,
    "title": "Question: Using existing components with multiple instances of Exoplayer",
    "created_at": "2016-05-05T12:18:38Z",
    "closed_at": "2016-05-06T12:54:20Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/google/ExoPlayer/issues/1501",
    "body": "I'm playing audio from MP3 files and I'm using two instances of Exoplayer, one to play and one to hold and prepare the next track for gapless playback.\n\nMy question is which of the Exoplayer components can be re-used and static and which needs to be recreated?\nSome of the components I'm using:\nOkHttpClient\nOkHttp3.CacheControl\nOkHttpDataSource\nExtractorSampleSource\nMp3Extractor\nMetadataTrackRenderer\nId3Parser\n\nThanks\n",
    "comments_url": "https://api.github.com/repos/google/ExoPlayer/issues/1501/comments",
    "author": "pantos27",
    "comments": [
      {
        "user": "ojw28",
        "created_at": "2016-05-06T12:47:04Z",
        "body": "I'm not sure about OkHttpCilent and OkHttp3.CacheControl, but for everything else you should be creating fresh instances (i.e. they should not be shared between players).\n"
      },
      {
        "user": "pantos27",
        "created_at": "2016-05-06T12:54:20Z",
        "body": "Ok, thanks.\n\nShould I ignore this log message then?\n_OMXMaster: A component of name 'OMX.qcom.audio.decoder.aac' already exists, ignoring this one._\n"
      },
      {
        "user": "pantos27",
        "created_at": "2016-05-06T12:54:49Z",
        "body": "oops.\nClosed by mistake\n"
      },
      {
        "user": "ojw28",
        "created_at": "2016-05-06T12:57:48Z",
        "body": "Yes, that message can be safely ignored (I'm not really sure why the platform prints that, but oh well!).\n"
      }
    ]
  },
  {
    "number": 1481,
    "title": "Can't suppurt flv format to seek",
    "created_at": "2016-04-28T08:15:50Z",
    "closed_at": "2016-04-28T08:52:46Z",
    "labels": [
      "question",
      "wont fix: infeasible"
    ],
    "url": "https://github.com/google/ExoPlayer/issues/1481",
    "body": "flvxtractor.java\n\nthe isSeekAble return false.\n",
    "comments_url": "https://api.github.com/repos/google/ExoPlayer/issues/1481/comments",
    "author": "mandagod",
    "comments": [
      {
        "user": "ojw28",
        "created_at": "2016-04-28T08:52:46Z",
        "body": "If you want to be able to seek, you should use a container format that's better designed for seeking (e.g. MP4). Not supporting seeking in containers that don't make seeking easy, such as FLV, is working as intended. See #860 for a little more detail.\n"
      },
      {
        "user": "mandagod",
        "created_at": "2016-05-04T10:00:39Z",
        "body": "@ojw28  Thanks.\n"
      }
    ]
  },
  {
    "number": 1469,
    "title": "[Question] Tracking Playback in HLS",
    "created_at": "2016-04-25T14:30:04Z",
    "closed_at": "2016-04-28T09:12:05Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/google/ExoPlayer/issues/1469",
    "body": "Hello, \n\nThanks for the great lib. I am streaming HLS (m3u8 files) for an audio app I'm building. I need to be able to track how much of the audio has been listened to. I'm having a difficult time trying to figure out where to hook into the player to gather this information. Is this possible? If so, what class/listener should I look at? Thanks!\n",
    "comments_url": "https://api.github.com/repos/google/ExoPlayer/issues/1469/comments",
    "author": "donnfelker",
    "comments": [
      {
        "user": "ojw28",
        "created_at": "2016-04-25T14:37:01Z",
        "body": "What's wrong with `ExoPlayer.getCurrentPosition` and `ExoPlayer.getDuration`?\n"
      },
      {
        "user": "donnfelker",
        "created_at": "2016-04-27T22:05:28Z",
        "body": "Seems to me it's a PEBCAK error in this case (me). \ud83d\ude04   Thanks for the quick tip @ojw28, not sure why I didn't see that before (facepalm). \n"
      }
    ]
  },
  {
    "number": 1462,
    "title": "Support for different encryption keys for video and audio AdaptionSets",
    "created_at": "2016-04-22T13:51:58Z",
    "closed_at": "2016-04-25T14:37:29Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/google/ExoPlayer/issues/1462",
    "body": "Hi,\n\nThe latest security update from Widevine strongly advises that we need to use a distinct content encryption keys for video and audio tracks.\n\nFurthermore, after discussing directly, it appears that the Chrome CDM will enforce this configuration as mandatory at some point.\n\nI have tested such content against ExoPlayer 1.5.7 and it appears that the player will only currently generate 1 key request per streaming session, regardless of the fact that two different default keyIDs are specified for each AdaptionSet (in my case Audio and Video).\n\nSo my questions are \n1. Are my suppositions correct on this?\n2. Would you consider adding support for this use-case as an enhancement.  If Chrome forces this, we (and others) could potentially have no choice but to generate content that is not compatible with ExoPlayer...\n\nI will send a private mail with details on the content sample I am using to determine my findings.  \n",
    "comments_url": "https://api.github.com/repos/google/ExoPlayer/issues/1462/comments",
    "author": "ghost",
    "comments": [
      {
        "user": "ojw28",
        "created_at": "2016-04-22T13:56:41Z",
        "body": "Use of distinct keys is not incompatible with having a single key request per session. What's supposed to happen is this:\n1. Player extracts pssh from arbitrary stream.\n2. Player makes single key request with pssh data.\n3. License server responds with _all_ of the keys that the user is entitled to for that content. So specifically, the response would include keys to play both the audio and video streams in this case.\n\nThe same approach is used today by many providers who use distinct keys for SD v.s. HD streams.\n"
      },
      {
        "user": "ojw28",
        "created_at": "2016-04-22T13:59:52Z",
        "body": "Note also that alternative approaches involving separate key requests are less efficient (more network requests) and more likely to result in playback failure (more chances to fail).\n"
      },
      {
        "user": "ghost",
        "created_at": "2016-04-22T14:11:12Z",
        "body": "Hi,\n\nThats the way key management seems to be done if you rely on Widevine cloud services to manage the encryption keys.   \n\nHowever, what you are suggesting (in my opinion) goes some way to actually mandating how a Non-Google provided key management system must actually work.   In our case, we support multipleDRMs and we expect to get (and handle) requests for a specific KeyID, not just \"give me all keys for a specific content instance\".\n\nBe aware that other DRMs (e.g. PlayReady) do not support the notion of the 'content_id' field as Widevine does    \n"
      },
      {
        "user": "ghost",
        "created_at": "2016-04-22T14:15:22Z",
        "body": "Note that the CENC spec only seems to define the KeyID as the signalling used to determine what encryption key to request/use  - it would be good that we can keep using a generic key management implementation, and not have to make Widevine specific alterations for this use-case \n"
      },
      {
        "user": "ojw28",
        "created_at": "2016-04-22T14:33:57Z",
        "body": "- I would argue that you should be implementing your key management system to return all keys when handling Widevine requests regardless, simply because it's more efficient and a better way of doing things. I doubt it's much work at all on the license server side to do this (i.e. if there's a content_id then use it and include the extra keys, if there isn't then don't). In which case a small amount of additional complexity seems well worth it. The generic version could require maintaining three DRM sessions simultaneously (SD, HD, Audio). In the case that PSSH data isn't in the manifest the generic case also requires either loading init chunks from all representations up front at the start of playback, or accepting that the first SD<->HD transition may not be seamless. Neither of these is ideal.\n- For the specific case of using different keys for audio and video, you can actually trivially achieve this already by using separate `StreamingDrmSessionManager`s for the audio and video renderers. Currently `DashRendererBuilder` in the demo app shares a single instance between both renderers, but you could create a separate instance for each to get the separate sessions. As above, I'd recommend you don't do this though (and it wont solve the SD/HD video issue). \n"
      },
      {
        "user": "ghost",
        "created_at": "2016-04-22T14:48:56Z",
        "body": "OK,\n\nI cede the point RE: efficiency.\n\nWe are only concerned with audio vs video for now so we will apply the suggested renderer configuration.\n\nThanks for the detailed explanations and helpful suggestions.\n"
      }
    ]
  },
  {
    "number": 1284,
    "title": "onPlayerError improvement",
    "created_at": "2016-02-19T04:15:00Z",
    "closed_at": "2016-02-19T15:24:02Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/google/ExoPlayer/issues/1284",
    "body": "Dear colleagues,\nI have an inquire about passing additional information with an error in ExoPlayer.\nI am talking about **StreamingDrmSessionManager.java** and it's method:\n`void onKeyResponse(Object response)`\nIn case of any error with License retrieving, our server returns important information with \"**Object response**\" and this causing exception in next line:\n`mediaDrm.provideKeyResponse(sessionId, (byte[]) response);`\nThat is OK. But, however, we loosing that information form client side.\nSo I am asking, whether it is possible to by-pass response with Exception, so it will be possible to get it in \"onPlayerError\" callback ?\n\nAs possible solution now, we inject custom listener into WidevineMediaDrmCallback.java and parse \n`byte[] executeKeyRequest(final UUID uuid, final MediaDrm.KeyRequest request)`\nresponse in order to intercept message.\n\nThanks a lot in advance.\n",
    "comments_url": "https://api.github.com/repos/google/ExoPlayer/issues/1284/comments",
    "author": "ChernyshovYuriy",
    "comments": [
      {
        "user": "ojw28",
        "created_at": "2016-02-19T12:02:46Z",
        "body": "You must be implementing `MediaDrmCallback`. You should have your implementation of `MediaDrmCallback.executeKeyRequest` check the response. If it's an error response this method should construct and throw an appropriate exception, which you can define yourself. Playback will then fail with this exception as the cause.\n\nTo provide more detail, the way I've seen this implemented elsewhere is for the license server to return a response whose body contains a status. For example:\n\n```\nStatus=X\n<data>\n```\n\nUpon obtaining the response, `MediaDrmCallback.executeKeyRequest` will parse the response and look at the status. If it's ok, it'll return `<data>`. If it's not ok, it'll construct and throw an appropriate exception. Note that the license server response is something you can design yourself, so you can put any information in there that you want to include in the exception.\n"
      },
      {
        "user": "ChernyshovYuriy",
        "created_at": "2016-02-19T12:43:19Z",
        "body": "Hi and thanks for the quick response.\n`MediaDrmCallback` is what I was talking about, in particular it's implementation in our project `class WidevineMediaDrmCallback implements MediaDrmCallback`.\nAccording to your suggestion I should intercept response and parse it. This is what I am doing, but I am not blocking farther execution and allow to return data from `byte[] executeKeyRequest(final UUID uuid, final MediaDrm.KeyRequest request)`.\nOk, thanks for the solution.\n"
      },
      {
        "user": "ChernyshovYuriy",
        "created_at": "2016-02-19T14:33:20Z",
        "body": "Oh, I forget important thing!\nIn both methods of the `MediaDrmCallback`:\n`byte[] executeKeyRequest(final UUID uuid, final MediaDrm.KeyRequest request)`\n`byte[] executeProvisionRequest(final UUID uuid, final MediaDrm.ProvisionRequest request)`\nwe must return bytes array.\nThis is the point. In case of success - we have no issues, but in case of any error we have to pass these bytes farther. And this will cause finally `void onPlayerError(final ExoPlaybackException error)`.\nAnd, in case we processing `executeKeyRequest` and detect an error - then there is double error in the side of ExoPlayerImpl. One is `onPlayerError` and another is custom License Error listener.\n\nAnd intention of my initial question was to prevent it. To process an error in single place, in `onPlayerError` callback. Does it make sense for you now?\n"
      },
      {
        "user": "ojw28",
        "created_at": "2016-02-19T14:35:14Z",
        "body": "You don't have to return a byte array. You should be throwing an exception, meaning you don't need to (i.e. can't) return anything.\n"
      },
      {
        "user": "ChernyshovYuriy",
        "created_at": "2016-02-19T14:39:53Z",
        "body": "Ok, let me try tis approach.\n"
      },
      {
        "user": "ChernyshovYuriy",
        "created_at": "2016-02-19T15:17:07Z",
        "body": "This approach works well, thanks a lot. I think question can be closed now :-)\n"
      },
      {
        "user": "ojw28",
        "created_at": "2016-02-19T15:24:02Z",
        "body": "Great!\n"
      }
    ]
  },
  {
    "number": 1255,
    "title": "Get duration of online mp3 file",
    "created_at": "2016-02-11T10:51:01Z",
    "closed_at": "2016-02-11T13:17:59Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/google/ExoPlayer/issues/1255",
    "body": "I wonder when it's safe to `getDuration()` of the audio track. I just need it once as fast as possible. \nWhen I try to get it immediately after `exoPlayer.prepare()` then I get `UNKNOWN_TIME`.\nDidn't find an example in demo project. \nLooks like I need to do it in listener when playback status changed to `ExoPlayer.STATE_READY`, but then there will be useless getDuration on each play/pause action.\n",
    "comments_url": "https://api.github.com/repos/google/ExoPlayer/issues/1255/comments",
    "author": "pavelkorolevxyz",
    "comments": [
      {
        "user": "ojw28",
        "created_at": "2016-02-11T12:15:41Z",
        "body": "If your code is going to have useless calls on each action, why don't you just have a boolean so that you only do it once?\n"
      },
      {
        "user": "pavelkorolevxyz",
        "created_at": "2016-02-11T12:35:51Z",
        "body": "It's okay, but thought there should be a cleaner way to call it once when player prepared, like in onPrepared() method of android default MediaPlayer. Thanks anyway.\n"
      }
    ]
  },
  {
    "number": 1248,
    "title": "Multiple ExoPlayer instances using one SurfaceHolder",
    "created_at": "2016-02-10T01:33:26Z",
    "closed_at": "2016-02-10T17:49:48Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/google/ExoPlayer/issues/1248",
    "body": "Is it possible to create more than one instance of `ExoPlayer` and use the same `SurfaceHolder`? I have the use case where I need one player for streaming content, and another for streaming client side ads. Only one player is supposed to play/show at a time, and they are directly on top of each other. Is there any way I can do this with just a single SurfaceHolder? I'm pretty sure it's only the `MediaCodec` api complaining with this error:\n\n`E/MediaCodec: native_window_api_connect returned an error: Invalid argument (-22)`\n`E/MediaCodec: configure failed with err 0xffffffea, resetting...`\n\nFollowed by an ExoPlayer exception:\n\n```\nE/ExoPlayerImplInternal: Internal track renderer error.\n    com.google.android.exoplayer.ExoPlaybackException: com.google.android.exoplayer.MediaCodecTrackRenderer$DecoderInitializationException: Decoder init failed: OMX.qcom.video.decoder.avc, MediaFormat(null, video/avc, -1, -1, 704, 396, -1, 1.0, -1, -1, null, -1, false, 1280, 720)\n    at com.google.android.exoplayer.MediaCodecTrackRenderer.notifyAndThrowDecoderInitError(MediaCodecTrackRenderer.java:388)\n    at com.google.android.exoplayer.MediaCodecTrackRenderer.maybeInitCodec(MediaCodecTrackRenderer.java:374)\n    at com.google.android.exoplayer.MediaCodecTrackRenderer.onInputFormatChanged(MediaCodecTrackRenderer.java:729)\n    at com.google.android.exoplayer.MediaCodecVideoTrackRenderer.onInputFormatChanged(MediaCodecVideoTrackRenderer.java:334)\n    at com.google.android.exoplayer.MediaCodecTrackRenderer.readFormat(MediaCodecTrackRenderer.java:496)\n    at com.google.android.exoplayer.MediaCodecTrackRenderer.doSomeWork(MediaCodecTrackRenderer.java:479)\n    at com.google.android.exoplayer.SampleSourceTrackRenderer.doSomeWork(SampleSourceTrackRenderer.java:129)\n    at com.google.android.exoplayer.ExoPlayerImplInternal.doSomeWork(ExoPlayerImplInternal.java:431)\n    at com.google.android.exoplayer.ExoPlayerImplInternal.handleMessage(ExoPlayerImplInternal.java:213)\n    at android.os.Handler.dispatchMessage(Handler.java:98)\n    at android.os.Looper.loop(Looper.java:135)\n    at android.os.HandlerThread.run(HandlerThread.java:61)\n    at com.google.android.exoplayer.util.PriorityHandlerThread.run(PriorityHandlerThread.java:40)\n    Caused by: com.google.android.exoplayer.MediaCodecTrackRenderer$DecoderInitializationException: Decoder init failed: OMX.qcom.video.decoder.avc, MediaFormat(null, video/avc, -1, -1, 704, 396, -1, 1.0, -1, -1, null, -1, false, 1280, 720)\n    at com.google.android.exoplayer.MediaCodecTrackRenderer.maybeInitCodec(MediaCodecTrackRenderer.java:374)\u00a0\n    at com.google.android.exoplayer.MediaCodecTrackRenderer.onInputFormatChanged(MediaCodecTrackRenderer.java:729)\u00a0\n    at com.google.android.exoplayer.MediaCodecVideoTrackRenderer.onInputFormatChanged(MediaCodecVideoTrackRenderer.java:334)\u00a0\n    at com.google.android.exoplayer.MediaCodecTrackRenderer.readFormat(MediaCodecTrackRenderer.java:496)\u00a0\n    at com.google.android.exoplayer.MediaCodecTrackRenderer.doSomeWork(MediaCodecTrackRenderer.java:479)\u00a0\n    at com.google.android.exoplayer.SampleSourceTrackRenderer.doSomeWork(SampleSourceTrackRenderer.java:129)\u00a0\n    at com.google.android.exoplayer.ExoPlayerImplInternal.doSomeWork(ExoPlayerImplInternal.java:431)\u00a0\n    at com.google.android.exoplayer.ExoPlayerImplInternal.handleMessage(ExoPlayerImplInternal.java:213)\u00a0\n    at android.os.Handler.dispatchMessage(Handler.java:98)\u00a0\n    at android.os.Looper.loop(Looper.java:135)\u00a0\n    at android.os.HandlerThread.run(HandlerThread.java:61)\u00a0\n    at com.google.android.exoplayer.util.PriorityHandlerThread.run(PriorityHandlerThread.java:40)\u00a0\n    Caused by: android.media.MediaCodec$CodecException: Error 0xffffffea\n    at android.media.MediaCodec.native_configure(Native Method)\n    at android.media.MediaCodec.configure(MediaCodec.java:580)\n    at com.google.android.exoplayer.MediaCodecVideoTrackRenderer.configureCodec(MediaCodecVideoTrackRenderer.java:328)\n    at com.google.android.exoplayer.MediaCodecTrackRenderer.maybeInitCodec(MediaCodecTrackRenderer.java:363)\n    at com.google.android.exoplayer.MediaCodecTrackRenderer.onInputFormatChanged(MediaCodecTrackRenderer.java:729)\u00a0\n    at com.google.android.exoplayer.MediaCodecVideoTrackRenderer.onInputFormatChanged(MediaCodecVideoTrackRenderer.java:334)\u00a0\n    at com.google.android.exoplayer.MediaCodecTrackRenderer.readFormat(MediaCodecTrackRenderer.java:496)\u00a0\n    at com.google.android.exoplayer.MediaCodecTrackRenderer.doSomeWork(MediaCodecTrackRenderer.java:479)\u00a0\n    at com.google.android.exoplayer.SampleSourceTrackRenderer.doSomeWork(SampleSourceTrackRenderer.java:129)\u00a0\n    at com.google.android.exoplayer.ExoPlayerImplInternal.doSomeWork(ExoPlayerImplInternal.java:431)\u00a0\n    at com.google.android.exoplayer.ExoPlayerImplInternal.handleMessage(ExoPlayerImplInternal.java:213)\u00a0\n    at android.os.Handler.dispatchMessage(Handler.java:98)\u00a0\n    at android.os.Looper.loop(Looper.java:135)\u00a0\n    at android.os.HandlerThread.run(HandlerThread.java:61)\u00a0\n    at com.google.android.exoplayer.util.PriorityHandlerThread.run(PriorityHandlerThread.java:40)\n```\n\nHowever, when I use two separate `SurfaceHolder`'s, it doesn't complain. Has anyone had any similar issues? Or am I possibly doing something wrong?\n\nThanks.\n",
    "comments_url": "https://api.github.com/repos/google/ExoPlayer/issues/1248/comments",
    "author": "Viddi",
    "comments": [
      {
        "user": "ojw28",
        "created_at": "2016-02-10T10:34:11Z",
        "body": "ExoPlayer doesn't know anything about `SurfaceHolder`; it only knows about `Surface` directly.\n\nI haven't tried, but it should be possible to have multiple ExoPlayer instances render to the same `Surface`, provided only one of them is doing so at any point in time. When you want to switch player from A to B, you'll need to clear the surface from A using `ExoPlayer.blockingSendMessage` and attach it to B using `ExoPlayer.sendMessage`. Note that the first call needs to be blocking so that you can be sure A really doesn't have access to the surface before you give it to B.\n"
      },
      {
        "user": "Viddi",
        "created_at": "2016-02-10T17:49:48Z",
        "body": "You're right, this was happening because when I switched players, I was using `sendMessage` instead of `blockingSendMessage`, so the surface was still in use when it was trying to make the switch.\n\nThanks!\n"
      }
    ]
  },
  {
    "number": 1208,
    "title": "Is there a state in EXO player like player is fast forwarding or rewinding?",
    "created_at": "2016-01-28T20:01:02Z",
    "closed_at": "2016-01-29T15:19:13Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/google/ExoPlayer/issues/1208",
    "body": "Hello,\n\nI want to know is there a specific state when we FF or Reverse the playback. I know that when we FF or Reverse the play back, it comes into the MediaCodecaudioTrackrenderer's \"SeekTo(position)\" function to adjust he play back. \n\nWhat I am doing is, calling player.SeekTo function to adjust it's position to couple of milliseconds but I am not doing FF, so I just want to differentiate when will it actually FF through which function?\n\nThanks\n",
    "comments_url": "https://api.github.com/repos/google/ExoPlayer/issues/1208/comments",
    "author": "joshimaulik",
    "comments": [
      {
        "user": "ojw28",
        "created_at": "2016-01-29T15:19:13Z",
        "body": "ExoPlayer doesn't have an API for fast-forward and rewind and so there isn't a corresponding state either. I'm not sure I understand your comment `when we FF or Reverse the playback`, since as above ExoPlayer doesn't have fast-forward and rewind APIs.\n"
      },
      {
        "user": "joshimaulik",
        "created_at": "2016-01-29T17:06:26Z",
        "body": "What I want to know is, when we fast forward on exo player, it goes multiple times into seekTo() function of mediacodecaudiotrackrenderer class. So is there any way to find out what was the last position of fast forward ? \n"
      },
      {
        "user": "ojw28",
        "created_at": "2016-02-01T17:47:20Z",
        "body": "There is no such thing as fast forward in ExoPlayer. As far as the player is concerned, it's just receiving lots of individual seek calls. You should probably implement your own playback controls that do have a concept of when the user is fast forwarding (i.e. user's finger is still dragging the control), and then use that.\n"
      },
      {
        "user": "joshimaulik",
        "created_at": "2016-02-01T19:42:11Z",
        "body": "okay, thank you!!\n"
      }
    ]
  },
  {
    "number": 1186,
    "title": "HLS - Handling low buffer and seek with no network connection",
    "created_at": "2016-01-25T22:22:33Z",
    "closed_at": "2016-01-26T00:21:03Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/google/ExoPlayer/issues/1186",
    "body": "I'm using ExoPlayer for audio only, HLS streams. As such, we can buffer quite a bit of audio which we want to continue playing even if the network drops or the device is put into airplane mode. In general that works fine, but there are a couple of no-network scenarios I'm trying to handle:\n1. Play through buffer \n2. Attempt to seek\n\nMy approach so far has been to register listeners with DefaultLoadControl and HlsSampleSource and to move my player into something similar to a buffering state when a load error is encountered. This solves the specific use cases I mentioned, but it doesn't give me very granular understanding of why loading failed. \n\nI realize that to some extent these are business / presentation layer concerns, but I'm wondering if there are recommended ways to address them in the context of ExoPlayer? For example, are there any ways to pause and resume loading? Is there a way to get a 'low buffer' warning before the loader kicks in? \n\nAny insights are greatly appreciated.\n",
    "comments_url": "https://api.github.com/repos/google/ExoPlayer/issues/1186/comments",
    "author": "jedhoffmann",
    "comments": [
      {
        "user": "ojw28",
        "created_at": "2016-01-25T22:56:29Z",
        "body": "I'm a little confused. Are you basically saying that you don't want playback to fail, ever, even if there's no network? Specifically, you'd rather the player enter an indefinite buffering state until network is restored?\n"
      },
      {
        "user": "jedhoffmann",
        "created_at": "2016-01-25T23:15:26Z",
        "body": "That is essentially how I have it coded right now, but it's clearly not ideal. Focusing just on the scenario of playing out the buffer with no network: is there a way you would recommend monitoring the buffers so that we can stop playback if they drop below a critical level and we don't have a network to load more?\n"
      },
      {
        "user": "ojw28",
        "created_at": "2016-01-25T23:26:07Z",
        "body": "You could probably stop the player from failing by passing a large value as minLoadableRetryCount to the HlsChunkSource constructor. You don't need to do anything special to have the player enter a buffering state when the buffer runs out; it'll do this automatically. So I think passing a large minLoadableRetryCount is all you'd need to do to achieve what you want.\n"
      },
      {
        "user": "jedhoffmann",
        "created_at": "2016-01-26T00:20:59Z",
        "body": "Thanks for the suggestion. It looks like that is doing the right thing for me. \n"
      }
    ]
  },
  {
    "number": 1172,
    "title": "DASH video track quality is set to max by default",
    "created_at": "2016-01-21T10:30:03Z",
    "closed_at": "2016-01-21T14:03:21Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/google/ExoPlayer/issues/1172",
    "body": "hello.\n\nI am developing a player app using the demo app as reference and bumped into this issue. When launching player activity, selected video track is 1080p, not auto. and video tracks are listed in the following order:\n1080p\nauto\n720p\n480p\nWhat can be the cause? Any fix for this?\n",
    "comments_url": "https://api.github.com/repos/google/ExoPlayer/issues/1172/comments",
    "author": "j-garin",
    "comments": [
      {
        "user": "ojw28",
        "created_at": "2016-01-21T10:49:21Z",
        "body": "The only thing I can think of that would cause this is if your DASH manifest has the 1080p representation in its own adaptation set at the top, and then a second adaptation set containing 720p/480p. Is that correct, and is there a reason why all three aren't in the same adaptation set?\n"
      },
      {
        "user": "j-garin",
        "created_at": "2016-01-21T11:13:06Z",
        "body": "Indeed there are 2 adaptation sets in the mpd file, because there are 2 codecs. What is the good way to handle this and have 'auto' at track[0]?\n"
      },
      {
        "user": "ojw28",
        "created_at": "2016-01-21T11:16:26Z",
        "body": "What are the two codecs, out of interest? Is the 1080p representation H265, or something like that?\n"
      },
      {
        "user": "j-garin",
        "created_at": "2016-01-21T11:26:10Z",
        "body": "one is H.285 (for 1080p) and the other is H.264\n1080p hevc\n1080p h264\n  720p h264\n  480p h264\n"
      },
      {
        "user": "ojw28",
        "created_at": "2016-01-21T11:31:22Z",
        "body": "It's typically not possible to seamlessly adapt between different codecs. The auto track generated in this case is 720p and 480p only, and so it's pretty ambiguous whether the player should default to the H265 stream or to the two H264 streams (unless you have something in your manifest that indicates this somehow).\n\nI think from the delivery point of view, it would be more normal to have H265 streams in 1080p, 720p and 480p, and then H264 streams in 720p and 480p. You'd then get an auto H265 track that can switch between the three H265 representations and would be enabled by default on devices with H265 decoders, and a separate auto H264 track, which would be the default on devices without an H265 decoder.\n"
      },
      {
        "user": "j-garin",
        "created_at": "2016-01-21T13:04:57Z",
        "body": "that worked. thank you.\nalso i am experiencing difficulties with audio track selection. playback fails to incompatible track selection. is there a way to select audio track that is supported by the device automatically?\n"
      },
      {
        "user": "ojw28",
        "created_at": "2016-01-21T13:50:18Z",
        "body": "ExoPlayer should already select a compatible audio track. What tracks do you have in your manifest, and on what device, and what selection are you seeing?\n"
      },
      {
        "user": "j-garin",
        "created_at": "2016-01-21T14:03:21Z",
        "body": "It was the issue in mpd file. Sorry to have bothered you and thank you for your help.\n"
      },
      {
        "user": "jeprojects",
        "created_at": "2016-01-21T14:11:37Z",
        "body": "@ojw28 This is a great help. One question though, with the multiple resolutions (1080p, 720p, 480p) will mpeg dash (and exoplayer) change between them all seamlessly without buffering? \n\nOr does this only happen when you have multiple bitrates for the same resolution (example: 1080p 10mbit, 5mbit, 4mbit)\n"
      },
      {
        "user": "ojw28",
        "created_at": "2016-01-21T14:16:04Z",
        "body": "Yes, it's possible to switch resolution. On Jellybean and some KitKat devices there might be a slight (~50ms) freeze in the video across the resolution switch, but nothing worse than that. On newer devices it should be completely seamless. There's definitely no buffering involved.\n"
      }
    ]
  },
  {
    "number": 1168,
    "title": "Set Aspect Ratio of Frame",
    "created_at": "2016-01-20T06:52:21Z",
    "closed_at": "2016-01-20T11:16:36Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/google/ExoPlayer/issues/1168",
    "body": "I am having an issue. i am streaming a video from my server where the URL is at passedWorkoutObject.workoutMediaURL. The video plays fine, but I need to scale the frame to the right aspect ratio. onVideoSizeChanged is not called with this code below. How do I get the aspect ratio of the frame so I can scale my frame?\n\n```\n       player = ExoPlayer.Factory.newInstance(2);\n\n\n        Allocator allocator = new DefaultAllocator(BUFFER_SEGMENT_SIZE);\n        DataSource dataSource = new DefaultUriDataSource(this, null, versionName);\n\n        MediaPresentationDescriptionParser parser = new MediaPresentationDescriptionParser();\n        UriDataSource manifestDataSource = new DefaultUriDataSource(this, versionName);\n        ManifestFetcher<MediaPresentationDescription> manifestFetcher = new ManifestFetcher<>(passedWorkoutObject.workoutMediaURL, manifestDataSource, parser);\n        final DefaultBandwidthMeter bandwidthMeter = new DefaultBandwidthMeter();\n\n        ExtractorSampleSource sampleSource = new ExtractorSampleSource(\n        Uri.parse(passedWorkoutObject.workoutMediaURL), dataSource, allocator, BUFFER_SEGMENT_COUNT * BUFFER_SEGMENT_SIZE);\n\n\n        MediaCodecVideoTrackRenderer videoRenderer = new MediaCodecVideoTrackRenderer(\n                this, sampleSource, MediaCodec.VIDEO_SCALING_MODE_SCALE_TO_FIT, 100, null, new MediaCodecVideoTrackRenderer.EventListener() {\n            @Override\n            public void onDroppedFrames(int count, long elapsed) {\n\n            }\n\n            @Override\n            public void onVideoSizeChanged(int width, int height, int unappliedRotationDegrees, float pixelWidthHeightRatio) {\n                videoFrame.setAspectRatio(\n                        height == 0 ? 1 : (width * pixelWidthHeightRatio) / height);\n            }\n\n            @Override\n            public void onDrawnToSurface(Surface surface) {\n\n            }\n\n            @Override\n            public void onDecoderInitializationError(MediaCodecTrackRenderer.DecoderInitializationException e) {\n\n            }\n\n            @Override\n            public void onCryptoError(MediaCodec.CryptoException e) {\n\n            }\n\n            @Override\n            public void onDecoderInitialized(String decoderName, long elapsedRealtimeMs, long initializationDurationMs) {\n\n            }\n        }, 100);\n\n\n        MediaCodecAudioTrackRenderer audioRenderer = new MediaCodecAudioTrackRenderer(sampleSource);\n        player.prepare(videoRenderer, audioRenderer);\n\n        player.sendMessage(videoRenderer, MediaCodecVideoTrackRenderer.MSG_SET_SURFACE, surface);\n\n\n        player.setPlayWhenReady(true);\n        control = new PlayerControl(player);\n```\n",
    "comments_url": "https://api.github.com/repos/google/ExoPlayer/issues/1168/comments",
    "author": "sweatapp",
    "comments": [
      {
        "user": "ojw28",
        "created_at": "2016-01-20T08:19:52Z",
        "body": "If you want your listener to be invoked then you need to pass a something other than null as the value of `eventHandler` in the `MediaCodecVideoTrackRenderer` constructor.\n"
      },
      {
        "user": "sweatapp",
        "created_at": "2016-01-20T09:30:30Z",
        "body": "worked like a charm, thanks\nThe documentation should really be better on all of this. \n"
      },
      {
        "user": "ojw28",
        "created_at": "2016-01-20T11:16:36Z",
        "body": "Whilst I agree in general that we need more detailed documentation, the Javadoc seems pretty clear in this specific case:\n\n```\neventHandler - A handler to use when delivering events to eventListener. May be null if delivery of events is not required.\neventListener - A listener of events. May be null if delivery of events is not required.\n```\n\nChoosing to pass null implies that you're not interested in having your listener receive events.\n"
      }
    ]
  },
  {
    "number": 1122,
    "title": "How to get detail information from VideoChunk in DASH streaming",
    "created_at": "2016-01-07T20:00:10Z",
    "closed_at": "2016-01-12T23:02:48Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/google/ExoPlayer/issues/1122",
    "body": "I am playing MPEG DASH streaming using exo player. I need to extract the video chunks and need to know what information are there in video chunks e.g. how long that chunk is, format of that video chunk etc...\n\nI tried to log that information in DemoPlayer.java class's onLoadStarted(int sourceId, long length, int type, int trigger, Format format, long mediaStartTimeMs, long mediaEndTimeMs) method. But it gives me sourceID= 0 & 1, length=-1 and format=com.google.android.exoplayer.chunk.Format@36, @35 & @34. \n\nPlease let me know if I am looking at correct place or is there any other way to extract the chunk information.\n\nThanks in Advance\n",
    "comments_url": "https://api.github.com/repos/google/ExoPlayer/issues/1122/comments",
    "author": "joshimaulik",
    "comments": [
      {
        "user": "ojw28",
        "created_at": "2016-01-08T15:18:20Z",
        "body": "I think you're looking in the right place. The format object contains a bunch of additional information you can drill into. The start and end times should be set correctly. The actual size of the content in bytes in most likely unknown at the point when the load is started (this would be true unless it's explicitly specified in the manifest or in a SIDX box in the media), which is why it's not reported. You can use onLoadCompleted to retrieve the number of bytes that were loaded.\n\nSo I'm not really sure what you're missing...\n"
      },
      {
        "user": "joshimaulik",
        "created_at": "2016-01-08T19:29:01Z",
        "body": "Okay, let me check and verify in onLoadCompleted event.\n\nThank You,\n"
      },
      {
        "user": "joshimaulik",
        "created_at": "2016-01-12T23:02:46Z",
        "body": "I checked it today, and seems it gives me all the information which I needed, like how long the chunk is, type of the chunk, etc...\n\nThank You..\n"
      }
    ]
  },
  {
    "number": 1046,
    "title": "Decoder init failed DTS",
    "created_at": "2015-12-11T05:04:02Z",
    "closed_at": "2015-12-16T19:19:50Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/google/ExoPlayer/issues/1046",
    "body": "Hi,\n\nI am getting the following error:\n\n``` js\ncom.google.android.exoplayer.ExoPlaybackException: com.google.android.exoplayer.MediaCodecTrackRenderer$DecoderInitializationException: Decoder init failed: [-49999], MediaFormat(1, audio/vnd.dts, -1, 16, -1, -1, -1, -1.0, 2, 48000, und, 0, false, -1, -1)\n```\n\nAm I correct in thinking that this is trying to access the hardware decoder on the device but failing (Nexus 6p) because hardware decode support doesn't exist?\n\nIf so, does exoplayer include software decoding support? Or do we need to fall back to our own?\n\nThanks for your help.\n",
    "comments_url": "https://api.github.com/repos/google/ExoPlayer/issues/1046/comments",
    "author": "jeprojects",
    "comments": [
      {
        "user": "andrewlewis",
        "created_at": "2015-12-11T12:27:27Z",
        "body": "Yes. That log line would be output when trying to create a decoder for audio/vnd.dts on a device with no decoder that supports it. Like most phones, Nexus 6P does not have a built-in DTS decoder. If possible, it is best to switch to a more widely supported format like AAC.\n\nNote that cf27b83 added a check that there is a decoder for the source MIME type, before the track is enabled. So, on an up to date version of ExoPlayer, you shouldn't see this error if the source MIME type is accurate, and the stream should play with no audio (unless other playable audio formats are present). Is this a DASH stream with an incorrect codecs attribute?\n"
      },
      {
        "user": "jeprojects",
        "created_at": "2015-12-11T15:53:37Z",
        "body": "Thanks @andrewlewis for your help.\n\nThis is the part in the mpd file\n\n``` js\n  <Representation id=\"5\" mimeType=\"audio/mp4\" codecs=\"mp4a.a9\" audioSamplingRate=\"48000\" startWithSAP=\"1\" bandwidth=\"1512297\">\n    <AudioChannelConfiguration schemeIdUri=\"urn:mpeg:dash:23003:3:audio_channel_configuration:2011\" value=\"2\"/>\n    <BaseURL>audio0_dashinit.mp4</BaseURL>\n    <SegmentBase indexRangeExact=\"true\" indexRange=\"893-1296\">\n      <Initialization range=\"0-892\"/>\n    </SegmentBase>\n   </Representation>\n```\n\nThis was automatically generated using mp4box.\n"
      },
      {
        "user": "andrewlewis",
        "created_at": "2015-12-11T16:09:36Z",
        "body": "You could try changing codecs=\"mp4a.a9\" to codecs=\"dtsc\" to make the codecs attribute consistent with the actual media format. That should hopefully give video-only playback, as no decoders will be found for the audio stream.\n"
      },
      {
        "user": "jeprojects",
        "created_at": "2015-12-13T07:44:09Z",
        "body": "Thanks again.\n\nThat did the trick.\n\nI am curious though, the one it selected was AAC, when there is AC3 available next in line.\n\n``` js\n  <AdaptationSet segmentAlignment=\"true\" group=\"2\" lang=\"und\" subsegmentAlignment=\"true\" subsegmentStartsWithSAP=\"1\">\n   <Representation id=\"6\" mimeType=\"audio/mp4\" codecs=\"ac-3\" audioSamplingRate=\"48000\" startWithSAP=\"1\" bandwidth=\"449268\">\n    <AudioChannelConfiguration schemeIdUri=\"urn:mpeg:dash:23003:3:audio_channel_configuration:2011\" value=\"2\"/>\n    <BaseURL>audio1_dashinit.mp4</BaseURL>\n    <SegmentBase indexRangeExact=\"true\" indexRange=\"869-1260\">\n      <Initialization range=\"0-868\"/>\n    </SegmentBase>\n   </Representation>\n  </AdaptationSet>\n  <AdaptationSet segmentAlignment=\"true\" group=\"2\" lang=\"und\" subsegmentAlignment=\"true\" subsegmentStartsWithSAP=\"1\">\n   <Representation id=\"7\" mimeType=\"audio/mp4\" codecs=\"mp4a.40.2\" audioSamplingRate=\"48000\" startWithSAP=\"1\" bandwidth=\"309860\">\n    <AudioChannelConfiguration schemeIdUri=\"urn:mpeg:dash:23003:3:audio_channel_configuration:2011\" value=\"2\"/>\n    <BaseURL>audio2_dashinit.mp4</BaseURL>\n    <SegmentBase indexRangeExact=\"true\" indexRange=\"900-1303\">\n      <Initialization range=\"0-899\"/>\n    </SegmentBase>\n   </Representation>\n  </AdaptationSet>\n```\n\nIs there something wrong with my configuration? Why would it skip ac3?\n"
      },
      {
        "user": "andrewlewis",
        "created_at": "2015-12-13T09:12:18Z",
        "body": "It could skip AC-3 for the same reason it skips DTS: MediaCodecAudioTrackRenderer only handles the track if the device has a decoder for the track's format, or if there is an HDMI connection that advertises support for playing the format via encoded audio passthrough (on Android L and above).\n"
      }
    ]
  },
  {
    "number": 1009,
    "title": "Howto read from codec output buffers",
    "created_at": "2015-11-30T19:56:27Z",
    "closed_at": "2015-12-03T18:43:10Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/google/ExoPlayer/issues/1009",
    "body": "I am attempting to play the HLS sample filie BipPop.  I have added code to MediaCodecVideoTrackRenderer. \n\nThe following code can be called in processOutputBuffer or in renderOutputBufferV21 but gets the same buffer freed error regardless (and the video successfully plays despite the buffer supposedly being freed).\n\n```\nprivate Boolean customHack(MediaCodec codec, int bufferIndex) {\nByteBuffer buffer = codec.getOutputBuffer(bufferIndex);\nbyte[] data =  new byte[buffer.remaining()];\n    try {\n      buffer.get(data);\n    }catch(Exception e){\n      Log.e(\"Custom\", \"Error trying to get the buffer\",e);\n      return false;\n    }\n}\n```\n\nMy objective is post-decode modification of the buffer.  I can do this using the regular Android player with non HLS content, but in ExoPlayer, I get the BufferFreed problem.\n",
    "comments_url": "https://api.github.com/repos/google/ExoPlayer/issues/1009/comments",
    "author": "jadedResearcher",
    "comments": [
      {
        "user": "ojw28",
        "created_at": "2015-12-03T17:06:41Z",
        "body": "There are quite strict rules about calls to `getOutputBuffer`. Specifically, in the `MediaCodec` Javadoc, it says: \n\n_After calling this method, any ByteBuffer or Image object previously returned for the same output index MUST no longer be used._.\n\nIt's likely that your call to `getOutputBuffer` is causing an output buffer that ExoPlayer code already has a reference to to become invalid.\n\nIf you're modifying `processOutputBuffer` then you should read from the `buffer` argument that gets passed to it, rather than making any calls to `getOutputBuffer` yourself. Note also that you shouldn't rely on the position and limit of the buffer being set correctly. Use the `bufferInfo` argument to find out the offset and size of the data in the buffer. You can set the buffer position and limit using this information yourself, like:\n\n```\nbuffer.position(bufferInfo.offset);\nbuffer.limit(bufferInfo.offset + bufferInfo.size);\n```\n"
      },
      {
        "user": "jadedResearcher",
        "created_at": "2015-12-03T18:36:19Z",
        "body": "Thank you for response. I changed my code to use the buffer that is passed into the processOutputBuffer method directly, and it works unless I need to get the width and the height, which I use the bufferIndex to do as well.\n\nint h = codec.getOutputImage(bufferIndex).getHeight();\n\nIs there an alternate way to get the width and the height without running into this error?\n"
      },
      {
        "user": "ojw28",
        "created_at": "2015-12-03T18:39:35Z",
        "body": "MediaCodecVideoTrackRenderer already has `currentWidth` and `currentHeight` variables.\n"
      },
      {
        "user": "jadedResearcher",
        "created_at": "2015-12-03T18:42:27Z",
        "body": "I do in fact see that now, thank you so much, you have answered my question in full.\n"
      },
      {
        "user": "ojw28",
        "created_at": "2015-12-03T18:43:10Z",
        "body": "No worries; Glad you got it working!\n"
      },
      {
        "user": "nikhilkilivayil",
        "created_at": "2017-06-28T09:12:08Z",
        "body": "Can you post sample full source code? @ojw28 "
      }
    ]
  },
  {
    "number": 967,
    "title": "Switching between encrypted streams",
    "created_at": "2015-11-18T12:49:19Z",
    "closed_at": "2015-11-26T12:15:28Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/google/ExoPlayer/issues/967",
    "body": "Hello,\nI have encountered a problem while switching between encrypted HLS streams after upgrading to ExoPlayer 1.5.2 from 1.4.1, I am switching between streams as advised in question #931\nSwitching between non-encrypted streams is fine, also between encrypted and non-encrypted. But when switching between encrypted streams i get this exception\n\n``` java\n11-18 13:32:27.926 13748-13847/? E/LoadTask: Unexpected exception loading stream\n11-18 13:32:27.926 13748-13847/? E/LoadTask: java.lang.IllegalArgumentException\n11-18 13:32:27.926 13748-13847/? E/LoadTask:     at com.google.android.exoplayer.util.Assertions.checkArgument(Assertions.java:39)\n11-18 13:32:27.926 13748-13847/? E/LoadTask:     at com.google.android.exoplayer.util.ParsableByteArray.setPosition(ParsableByteArray.java:133)\n11-18 13:32:27.926 13748-13847/? E/LoadTask:     at com.google.android.exoplayer.util.ParsableByteArray.skipBytes(ParsableByteArray.java:145)\n11-18 13:32:27.926 13748-13847/? E/LoadTask:     at com.google.android.exoplayer.extractor.ts.TsExtractor.read(TsExtractor.java:141)\n11-18 13:32:27.926 13748-13847/? E/LoadTask:     at com.google.android.exoplayer.hls.HlsExtractorWrapper.read(HlsExtractorWrapper.java:240)\n11-18 13:32:27.926 13748-13847/? E/LoadTask:     at com.google.android.exoplayer.hls.TsChunk.load(TsChunk.java:108)\n11-18 13:32:27.926 13748-13847/? E/LoadTask:     at com.google.android.exoplayer.upstream.Loader$LoadTask.run(Loader.java:209)\n11-18 13:32:27.926 13748-13847/? E/LoadTask:     at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:390)\n11-18 13:32:27.926 13748-13847/? E/LoadTask:     at java.util.concurrent.FutureTask.run(FutureTask.java:234)\n11-18 13:32:27.926 13748-13847/? E/LoadTask:     at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1080)\n11-18 13:32:27.926 13748-13847/? E/LoadTask:     at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:573)\n11-18 13:32:27.926 13748-13847/? E/LoadTask:     at java.lang.Thread.run(Thread.java:841)\n```\n\nI have tried to track down the issue and found out that TS Extractor is trying to skip adaptation field longer than the size of tsPacket Buffer:\n\n``` java\n11-18 13:32:27.625 13748-13773/? E/null\u00a0check: position: 5, bytes: 7, limit: 188\n11-18 13:32:27.625 13748-13773/? E/null\u00a0check: position: 6, bytes: 1, limit: 9\n11-18 13:32:27.625 13748-13773/? E/null\u00a0check: position: 9, bytes: 0, limit: 9\n11-18 13:32:27.625 13748-13748/? E/Status: preparing\n11-18 13:32:27.896 13748-13847/? E/null\u00a0check: position: 5, bytes: 10, limit: 188\n11-18 13:32:27.926 13748-13847/? E/null\u00a0check: position: 5, bytes: 185, limit: 188\n```\n\nwhere preparing is status of player after switching and bytes is the number if bytes extractor is trying to skip. This never happened while i was using version 1.4.1. Encryption is standard AES so it should be replicable with any encrypted HLS streams.\n",
    "comments_url": "https://api.github.com/repos/google/ExoPlayer/issues/967/comments",
    "author": "SnowcatSVK",
    "comments": [
      {
        "user": "ojw28",
        "created_at": "2015-11-18T17:21:43Z",
        "body": "You're probably not fully rebuilding the renderers when you switch. You shouldn't re-use any objects that you used to build one set of renderers when building the next set, particularly things like DataSource instances. Is it possible that you are re-using them? If so, try not doing so.\n"
      },
      {
        "user": "SnowcatSVK",
        "created_at": "2015-11-19T08:05:25Z",
        "body": "Well, i am using DemoPlayer and HLSRendererBuilder from demo directory in project, these are the methods i am using for switching:\n\n``` java\nprivate HlsRendererBuilder createRenderer() {\n        String userAgent = Util.getUserAgent(this, \"ExoplayerTest\");\n        return new HlsRendererBuilder(this, userAgent, contentUri.toString());\n    }\n\n    private void preparePlayer() {\n        if (player == null) {\n            player = new DemoPlayer(createRenderer());\n            player.addListener(this);\n            player.setCaptionListener(this);\n            player.setMetadataListener(this);\n            playerNeedsPrepare = true;\n\n        }\n        if (playerNeedsPrepare) {\n            player.prepare();\n            playerNeedsPrepare = false;\n        }\n        player.setSurface(surfaceView.getHolder().getSurface());\n        player.setPlayWhenReady(true);\n    }\n\n    private void releasePlayer() {\n        if (player != null) {\n            //playerPosition = player.getCurrentPosition();\n            player.release();\n            player = null;\n\n        }\n    }\n```\n\nand this is the way i am using those methods: \n\n``` javascript\n    releasePlayer();\n    preparePlayer();\n```\n\nonly thing i am reusing is surfaceView, unless there is something in DemoPlayer and HLSRendererBuilder that i have missed, but that shouldn't be the case since it never happened with nonencrypted streams\n"
      },
      {
        "user": "ojw28",
        "created_at": "2015-11-19T16:53:35Z",
        "body": "If that's the case then the two playbacks should be completely independent to one another. It's pretty much equivalent to backing out of playback in the demo activity and selecting another sample. In which case I don't understand how one playback could affect the next (at a theoretical level)?\n\nCan you modify the demo app in some way to reproduce the issue? And if so, can you upload it to GitHub so that we can reproduce ourselves?\n"
      },
      {
        "user": "SnowcatSVK",
        "created_at": "2015-11-20T10:25:01Z",
        "body": "I have my whole project in private repository on GitHub, i can privately send you link to that repository so you can test it yourself\n"
      },
      {
        "user": "ojw28",
        "created_at": "2015-11-26T12:15:28Z",
        "body": "The issue is related to the way that you've made `HlsChunkSource.encryptionKeyUri`static in your branch. The breaks the assumption that the second playback is independent of the first, because state is being left lying around from the first playback in the static variable. If I null it out where the player is released, then the second playback works fine.\n\nSo the conclude - It looks like an issue with your local modifications. As a general style point, it's worth exploring solutions that don't require statics except in the specific case of singletons (which definitely isn't the case for this particular variable). I also noticed some interesting code in User.java where initSingletons re-initializes singletons potentially multiple times, which looks wrong to me.\n"
      },
      {
        "user": "SnowcatSVK",
        "created_at": "2015-11-27T08:44:44Z",
        "body": "Thank you very much for help, I must have left it there from the time when I was trying different solutions and forgot about it, shame I couldn't find it myself, as for User.java, this is a recycled class from an older project written by different developer, I have recycled it as it was working well with our API and I needed to get going fast with testing, this project was just for testing purposes, so I am completely rewriting it since all of the issues are resolved now.\n"
      }
    ]
  },
  {
    "number": 921,
    "title": "Exoplayer declared permissions",
    "created_at": "2015-11-03T18:09:25Z",
    "closed_at": "2016-01-22T15:29:26Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/google/ExoPlayer/issues/921",
    "body": "Hi,\nfirst ,thank you for this library  , i was  wondering if i can remove the wirte permission in exoplyer ,because i use it only for online audio streaming \n",
    "comments_url": "https://api.github.com/repos/google/ExoPlayer/issues/921/comments",
    "author": "diabloo",
    "comments": [
      {
        "user": "ojw28",
        "created_at": "2015-11-03T19:19:16Z",
        "body": "You can remove both READ_EXTERNAL_STORAGE and WRITE_EXTERNAL_STORAGE if you're only doing streaming over the network.\n\nWhen we first added these permissions to the manifest I don't think manifest merging existed, so the permissions were there for informational purposes only. Now manifest merging does exist I guess these permissions do get merged into your application when you pull in the ExoPlayer library.\n\nIs that correct? Do you think it would make more sense to comment these permissions out by default in the library manifest?\n"
      },
      {
        "user": "diabloo",
        "created_at": "2015-11-03T19:49:03Z",
        "body": "thank you for the response . yes I think it would be better to let the devlepper add permission in the manifaist . for my case it easier and faster  to use the Jcenter dependency witout downloading and linking the library . thank you for your time and for this library\n"
      },
      {
        "user": "ojw28",
        "created_at": "2016-01-22T15:29:26Z",
        "body": "This is fixed in the dev branch.\n"
      }
    ]
  },
  {
    "number": 467,
    "title": "Unable to connect to local mp4 file by ExtractorSampleSource",
    "created_at": "2015-05-18T21:34:34Z",
    "closed_at": "2015-05-19T13:34:30Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/google/ExoPlayer/issues/467",
    "body": "Hello!\n\nI am updating the ExoPlayer to 1.3.1 and I am experiencing the issue with  the playback of the local MP4 files:\ncom.google.android.exoplayer.ExoPlaybackException: com.google.android.exoplayer.upstream.HttpDataSource$HttpDataSourceException: Unable to connect to /storage/emulated/0/Android/data/com.getvictorious.staging.eatyourkimchi/files/DCIM/Video/Video-20150518_142803.mp4\n\nI am passing the uri to the ExtractorSampleSource: \nExtractorSampleSource sampleSource = new ExtractorSampleSource(uri, dataSource, extractor, 2,\n                BUFFER_SIZE);\n\nPlease advise what could cause this exception.\n\nThank you in advance!\nEdward\n",
    "comments_url": "https://api.github.com/repos/google/ExoPlayer/issues/467/comments",
    "author": "edwardfoux",
    "comments": [
      {
        "user": "ojw28",
        "created_at": "2015-05-18T22:01:19Z",
        "body": "What are you passing as the dataSource when you make your ExtractorSampleSource? You're either not passing the right thing, or you're not formatting your local URI correctly. Covering both points:\n- Use DefaultUriDataSource, which will work for both local and network URIs\n- Your URI should be formatted to start with file:///\n"
      },
      {
        "user": "ojw28",
        "created_at": "2015-05-19T13:34:30Z",
        "body": "Note: DefaultUriDataSource no longer requires file:// (on the dev branch). If you omit a scheme completely, we'll assume file://.\n"
      },
      {
        "user": "edwardfoux",
        "created_at": "2015-05-19T17:22:58Z",
        "body": "Thank you very much!\n"
      }
    ]
  },
  {
    "number": 257,
    "title": "[Discussion] Potential race between HlsSampleSource and TsChunk?",
    "created_at": "2015-01-22T05:49:40Z",
    "closed_at": "2015-01-23T03:22:27Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/google/ExoPlayer/issues/257",
    "body": "This is not an issue, just some discussion about potential TsExtractor's race between HlsSampleSource and TsChunk.\n\nWhen I read the code related to how HlsSampleSource read the chunk data, it's noticed that reading-data from DataSource and getting-sample from Extractor are in two threads:\n- Reading data is in `TsChunk.load()`, which runs in a backgroud thread:\n\n``` java\n      while (bytesRead != -1 && !loadCanceled) {\n        bytesRead = extractor.read(dataSource);\n        if (bytesRead != -1) {\n          loadPosition += bytesRead;\n        }\n      }\n```\n- Getting sample is in `HlsSampleSource.readData()`, which runs in ExoPlayer's event loop. And other functions access the extractor, e.g. \n\n``` java\n    extractor.getSample(track, sampleHolder)\n    extractor.discardUntil(i, timeUs);\n```\n\nI don't see any protection of the two threads accessing extractor;\nAlthough there is `ConcurrentLinkedQueue` to protect the `SampleQueue.internalQueue` in TsExtractor, other members are not protected.\n\nThe question is, can we make sure there is no race accessing TsExtractor?\n",
    "comments_url": "https://api.github.com/repos/google/ExoPlayer/issues/257/comments",
    "author": "mine260309",
    "comments": [
      {
        "user": "ojw28",
        "created_at": "2015-01-23T02:49:57Z",
        "body": "Can you be specific about which members you're concerned about? The members that are accessed from both threads are marked as volatile, SamplePool is protected with synchronization, and as you say the sample queues use ConcurrentLinkedQueue. I can't see anything not covered by these measures.\n\nThanks!\n"
      },
      {
        "user": "mine260309",
        "created_at": "2015-01-23T03:22:25Z",
        "body": "Thanks for your comment!\nIt did not notice SamplePool is protected with synchronization.\n\nThe reason I asked the question is because I was planning to add a member in SampleQueue and realized that it should be protected by mutex or synchronization.\nNow it's clear and I'll close the question.\n"
      }
    ]
  }
]