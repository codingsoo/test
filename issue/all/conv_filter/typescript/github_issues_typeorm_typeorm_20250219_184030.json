[
  {
    "number": 8548,
    "title": "Preload function doesn't load soft-deleted entities",
    "created_at": "2022-01-20T10:39:40Z",
    "closed_at": "2022-02-18T20:50:30Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/8548",
    "body": "## Issue Description\r\nWhen i want to preload a soft deleted entity (entities with deleted_at field not null), it returns undefined.\r\nI'm using it to update my entity, so i have a condition in order to throw an error if the preloaded entity is empty.\r\n\r\n### Expected Behavior\r\nI expect that the preload function returns the entity even if the entity is soft deleted.\r\nOR\r\nAdd a parameter that allow us to load soft deleted entities\r\n\r\n### Actual Behavior\r\nThe preload function doesn't load the soft deleted entities  and then it returns undefined.\r\n\r\nMy code:\r\n```typescript\r\nconsole.log({ id });\r\nconst project = await queryRunner.manager.preload(Project, {\r\n        id,\r\n        ...projectDto,\r\n });\r\n\r\nconsole.log({ project });\r\nif (!project) {\r\n   throw new NotFoundException(`Project with id \"${id}\" not found`);\r\n}\r\n```\r\nThe logs:\r\n```\r\n{ id: '85c6d6c2-e279-4993-a0bb-53dafdaed5f2' }\r\n{ project: undefined }\r\nError: Project with id \"85c6d6c2-e279-4993-a0bb-53dafdaed5f2\" not found\r\n```\r\nMy entity (exported as json from my db):\r\n```json\r\n[\r\n\t{\r\n\t\t\"id\": \"85c6d6c2-e279-4993-a0bb-53dafdaed5f2\",\r\n\t\t\"name\": \"Oxygen\",\r\n\t\t\"created_at\": \"2022-01-20 09:10:04.531245+00\",\r\n\t\t\"created_by\": null,\r\n\t\t\"updated_at\": \"2022-01-20 09:10:04.531245+00\",\r\n\t\t\"updated_by\": null,\r\n\t\t\"deleted_at\": \"2022-01-20 09:10:04.53+00\",\r\n\t\t\"deleted_by\": null,\r\n\t\t...\r\n\t}\r\n]\r\n```\r\n\r\n### Steps to Reproduce\r\n1. Create an entity with deleted_at not null in your database\r\n2. Try to preload it\r\n\r\n### My Environment\r\n\r\n<!--\r\n  Please add any other relevant dependencies to this table at the end.\r\n  For example: Electron, React Native, or NestJS.\r\n-->\r\n\r\n| Dependency          | Version  |\r\n| ---                 | ---      |\r\n| Operating System    |  macOs 12.1\r\n| Node.js version     | 16.13.1 \r\n| Typescript version  | 4.5.4 \r\n| TypeORM version     | 0.2.41\r\n| @nestjs/typeorm     | 7.1.5\r\n\r\n### Relevant Database Driver(s)\r\n\r\n| DB Type              | Reproducible  |\r\n| ---                  | ---           |\r\n| `aurora-data-api`    | x            |\r\n| `aurora-data-api-pg` | x            |\r\n| `better-sqlite3`     | x            |\r\n| `cockroachdb`        | x            |\r\n| `cordova`            | x            |\r\n| `expo`               | x            |\r\n| `mongodb`            | x            |\r\n| `mysql`              | x            |\r\n| `nativescript`       | x            |\r\n| `oracle`             | x            |\r\n| `postgres`           | yes            |\r\n| `react-native`       | x            |\r\n| `sap`                | x            |\r\n| `sqlite`             | x            |\r\n| `sqlite-abstract`    | x            |\r\n| `sqljs`              | x            |\r\n| `sqlserver`          | x            |\r\n\r\n\r\n### Are you willing to resolve this issue by submitting a Pull Request?\r\n\r\n - \u2716\ufe0f Yes, I have the time, and I know how to start.\r\n - \u2705 Yes, I have the time, but I don't know how to start. I would need guidance.\r\n - \u2716\ufe0f No, I don\u2019t have the time, but I can support (using donations) development.\r\n - \u2716\ufe0f No, I don\u2019t have the time and I\u2019m okay to wait for the community / maintainers to resolve this issue.\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/8548/comments",
    "author": "Anxium",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2022-02-18T20:50:30Z",
        "body": "Looks like a question. Just load it using `.find` method in combination with `withDeleted` option."
      },
      {
        "user": "Anxium",
        "created_at": "2022-02-19T08:19:50Z",
        "body": "Indeed, sorry for the wrong tag.\r\n\r\nBased on the pull request in which this issue was mentioned, do you recommend not using the \"soft delete\" feature and doing a custom implementation in our project ? \r\n\r\nBecause the fact that the preload function will not load the soft-deleted entities is not specified in the doc, it can leads to some issues or maybe a duplicate of this issue, what is a waste of time. Then, can I suggest to add it in the doc ?\r\n\r\nThanks for you response !\r\n"
      },
      {
        "user": "pleerock",
        "created_at": "2022-02-19T09:47:18Z",
        "body": "> Based on the pull request in which this issue was mentioned, do you recommend not using the \"soft delete\" feature and doing a custom implementation in our project ?\r\n\r\nuse it until it satisfy your needs. If it becomes a bottleneck and you miss some features - you can go with your own implementation.\r\n\r\n> Because the fact that the preload function will not load the soft-deleted entities is not specified in the doc, it can leads to some issues or maybe a duplicate of this issue, what is a waste of time. Then, can I suggest to add it in the doc ?\r\n\r\nI'm not sure about future of `preload` method. Better to use `find` to load entity. May I know your use cases (simplified) of `preload` method and why you use it instead of using `find`?"
      },
      {
        "user": "Anxium",
        "created_at": "2022-02-19T10:59:58Z",
        "body": "> May I know your use cases (simplified) of preload method and why you use it instead of using find?\r\n\r\nI'm using it to load the entity and all its relations, and replace the data in one-time. It seemed faster than find and replace. \r\nBut the work-around I did, is what you answered, i'm using a find with `withDeleted: true` now"
      }
    ]
  },
  {
    "number": 6816,
    "title": "fix: queryRunner.renameTable should not rename enums used by the table",
    "created_at": "2020-09-30T14:16:21Z",
    "closed_at": "2021-07-10T06:44:11Z",
    "labels": [
      "question",
      "comp: migrations"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/6816",
    "body": "**Issue type:**\r\n\r\n[x] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:** [x] `postgres`\r\n\r\n**TypeORM version:** `latest`\r\n\r\n### Description\r\n\r\nWhen a table is renamed via `queryRunner.renameTable` it will rename the enums used by the table. I think this should not be the case as an enum can be used by multiple tables and by prefixing it with the renamed table name will make it strange to use in the other tables. \r\n\r\n### Steps to reproduce or a small repository showing the problem\r\n\r\nAll 3 step should be added in a different transaction. First the enum needs to be created:\r\n\r\n```ts\r\nawait queryRunner.query(\r\n  `CREATE TYPE enum_resolution AS ENUM ('PT15M', 'PT60M', 'P1D', 'P1M', 'P3M', 'P1Y', 'seasonal', 'intraday')`\r\n);\r\n```\r\nThen create a table using the enum:\r\n```ts\r\nimport { MigrationInterface, QueryRunner, Table } from 'typeorm';\r\n\r\nexport class createTableHourlyTemperature1550570592750 implements MigrationInterface {\r\n  public async up(queryRunner: QueryRunner): Promise<any> {\r\n    await queryRunner.createTable(\r\n      new Table({\r\n        name: 'raw_data.hourly_temperature',\r\n        columns: [\r\n          {\r\n            name: 'resolution',\r\n            type: 'enum_resolution',\r\n          },\r\n        ],\r\n      })\r\n    );\r\n  }\r\n\r\n  public async down(queryRunner: QueryRunner): Promise<any> {\r\n    await queryRunner.dropTable('raw_data.hourly_temperature');\r\n  }\r\n}\r\n```\r\nThen rename the table via `queryRunner.renameTable`:\r\n```ts\r\nimport { MigrationInterface, QueryRunner } from 'typeorm';\r\n\r\nexport class renameHourlyTemperatureTableToTemperature1599484493349 implements MigrationInterface {\r\n  public async up(queryRunner: QueryRunner): Promise<void> {\r\n    await queryRunner.renameTable('raw_data.hourly_temperature', 'temperature');\r\n  }\r\n\r\n  public async down(queryRunner: QueryRunner): Promise<void> {\r\n    await queryRunner.renameTable('raw_data.temperature', 'hourly_temperature');\r\n  }\r\n}\r\n```\r\n\r\nObserve the generated queries: \r\n\r\n```\r\nquery: ALTER TABLE \"raw_data\".\"hourly_temperature\" RENAME TO \"temperature\"\r\nquery: ALTER TABLE \"raw_data\".\"temperature\" RENAME CONSTRAINT \"PK_b30b7b3b3657b819b781b5e95b8\" TO \"PK_7810603e74ca71d654ef434a078\"\r\nquery: ALTER TYPE \"public\".\"enum_resolution\" RENAME TO \"temperature_resolution_enum\"\r\nquery: ALTER TYPE \"public\".\"enum_temperature_source\" RENAME TO \"temperature_source_enum\"\r\nquery: INSERT INTO \"migrations\"(\"timestamp\", \"name\") VALUES ($1, $2) -- PARAMETERS: [1599484493349,\"renameHourlyTemperatureTableToTemperature1599484493349\"]\r\nquery: COMMIT\r\nquery: START TRANSACTION\r\n```",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/6816/comments",
    "author": "NoNameProvided",
    "comments": [
      {
        "user": "AlexMesser",
        "created_at": "2021-02-25T15:34:25Z",
        "body": "@NoNameProvided you can use `enumName` property if you want to share enum type across multiple tables.\r\n\r\n```ts\r\ncolumns: [\r\n  {\r\n    name: 'resolution',\r\n    type: 'enum',\r\n    enumName: 'enum_resolution'\r\n  },\r\n],\r\n```"
      },
      {
        "user": "NoNameProvided",
        "created_at": "2021-02-25T16:57:51Z",
        "body": "Thanks for the feedback! I will take a look. Should we close or leave it open as a feature request to make enum name preservation the default? "
      },
      {
        "user": "imnotjames",
        "created_at": "2021-07-10T06:44:11Z",
        "body": "We won't make it the default as it leads to other issues.  I'll be closing this as your question was answered"
      }
    ]
  },
  {
    "number": 5470,
    "title": "Question: How to continue  to next value ( aport ) if there a duplications error ",
    "created_at": "2020-02-04T13:37:15Z",
    "closed_at": "2020-10-06T06:38:48Z",
    "labels": [
      "question",
      "driver: mysql",
      "driver: mariadb"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/5470",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[x] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[ ] `cockroachdb`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\nI'm scraping from multiple websites and I save the data on MySQL type database using nestJS and TypeOrm frameworks. \r\n\r\nI have a cron job that runs that scraper service every day checking for new data available and inserted into my SQL database, the problem I don't wanna duplication data so I did a unique column in my table, so any duplicated data not getting be saved.\r\n\r\nNow I got the `dup error` as I expected but I can't find a way to handle this error to just ignore that row and continue for the rest instead of stopping everything.\r\n\r\nThe code for saving the data: \r\n```typescriprt\r\nasync clonningFromScraper() {\r\n   //my scraper data ( array of objects )\r\n    let articles = await this.articlesScraper.articles('1'); \r\n\r\n    articles = articles.map( article => ({ ...article, key: decodeURIComponent(article.url).substring(0, 255) }));\r\n\r\n // saving the data into my database\r\n    return this.articleRepository\r\n        .save(articles);\r\n}\r\n```\r\n\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/5470/comments",
    "author": "heshaShawky",
    "comments": [
      {
        "user": "aatecey",
        "created_at": "2020-02-07T13:46:48Z",
        "body": "Don't think save has an option to handle this. Could use the query builder for this case though. Not tested this but something like:\r\n\r\n        await this.articleRepository.createQueryBuilder()\r\n            .insert()\r\n            .orIgnore()\r\n            .into(Article)\r\n            .values(articles)\r\n            .execute();"
      },
      {
        "user": "heshaShawky",
        "created_at": "2020-02-09T23:39:52Z",
        "body": "> Don't think save has an option to handle this. Could use the query builder for this case though. Not tested this but something like:\r\n> \r\n> ```\r\n>     await this.articleRepository.createQueryBuilder()\r\n>         .insert()\r\n>         .orIgnore()\r\n>         .into(Article)\r\n>         .values(articles)\r\n>         .execute();\r\n> ```\r\nthe `save` method supposed to do that as it's documented \r\n```\r\n /**\r\n     * Saves all given entities in the database.\r\n     * If entities do not exist in the database then inserts, otherwise updates.\r\n     */\r\n```\r\nYour code works well for me, thanks.\r\n\r\n"
      }
    ]
  },
  {
    "number": 5314,
    "title": "getCount(). Perfs issues for multi columns primary key",
    "created_at": "2020-01-10T14:42:25Z",
    "closed_at": "2020-10-09T06:22:09Z",
    "labels": [
      "question",
      "driver: postgres"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/5314",
    "body": "**Issue type:**\r\n\r\n[X ] question\r\n\r\n**Database system/driver:**\r\n[X ] `postgres`\r\n\r\nVersion 0.2.18\r\n\r\nI'm facing a perf issue when running getCount()\r\nWhy when counting all records of a query, queryBuilder creates a SQL query that concatenates the columns that are part of the primary key ?\r\n\r\n**Typescript  :** \r\n```\r\nconst query: SelectQueryBuilder<TEntity> = dbConnection\r\n\t\t\t\t\t.getRepository<TEntity>(entity)\r\n\t\t\t\t\t.createQueryBuilder(entity.name)\r\n\t\t\t\t\t.where(`\"${entity.name}\".\"${id}\"= :val`, {\r\n\t\t\t\t\t\tval: value.toLowerCase(),\r\n\t\t\t\t\t});\r\n\r\n\t\t\t\tconst totalRecords: number = await query.getCount();\r\n```\r\n\r\n**generated sql**\r\n```\r\nSELECT COUNT(DISTINCT(\r\n\tCONCAT(\r\n\t\t\"u\".\"a\", \r\n\t\t\"u\".\"b\",\r\n\t\t\"u\".\"c\")\r\n\t)\r\n) as \"cnt\" FROM \"sc\".\"tbl\" \"u\"\r\n```\r\n\r\nThat is destroying the performances for a table of 140K records. \r\nCreating an index on CONCAT using is not efficient, hard to maintain with 100 of tables, knowing that for some tables, some primay comumns are timestamp...\r\n\r\nIs there a way or a parameter to set to avoid the concat and just running a kind of (`select count(1) FROM \"sc\".\"tbl\" \"u\"`) ?\r\n\r\nRgds\r\n\r\n\r\n\r\n\r\n\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/5314/comments",
    "author": "jeromeSH26",
    "comments": [
      {
        "user": "Destreyf",
        "created_at": "2020-01-10T21:33:06Z",
        "body": "@jeromeSH26 \r\n\r\nI haven't used any multi-column keys, can you try this?\r\n\r\n```typescript\r\nconst query: SelectQueryBuilder<TEntity> = dbConnection\r\n\t\t\t\t\t.getRepository<TEntity>(entity)\r\n\t\t\t\t\t.createQueryBuilder(entity.name)\r\n\t\t\t\t\t.select(\"COUNT(*)\", \"count\")\r\n\t\t\t\t\t.where(`\"${entity.name}\".\"${id}\"= :val`, {\r\n\t\t\t\t\t\tval: value.toLowerCase(),\r\n\t\t\t\t\t});\r\n\r\nconst totalRecords: number = await query.getRawOne().then(r => r.count);\r\n```\r\n\r\nThis is how i perform my queries, but i'm also using it in a mixed scenario of count/sum/avg so i use the getOneRaw quite a bit."
      },
      {
        "user": "jeromeSH26",
        "created_at": "2020-01-11T09:37:30Z",
        "body": "Hi Chris,\r\nthanks for your feedback \r\nI tried your solution and that runs 4.5 faster than the native getCount() (147ms Vs 680ms). Il will go with that solution, since I'm using generic resolvers for typegraphql, so the modification to access DB is easy to maintain, as this is centralized in a single function.\r\nHowever it seems to me more a workaround as a solution. I would expect the native getCount() to be optimizable. But with a `COUNT(DISTINCT(CONCAT(....)))`  query, difficult to optimize as it impacts the design of the DB (need to add specific BTREE indexes) just for a count..\r\n\r\nWill close the issue later on, in case some team guys designing typeorm (which is a fantastic tool btw) want to give us some clues\r\n\r\nRgds\r\n\r\nThis is how I have refactored the query :\r\n```\r\nconst rootQuery = dbConnection\r\n\t.getRepository<TEntity>(entity)\r\n\t.createQueryBuilder(entity.name);\r\n\r\nconst countQuery = rootQuery.select(\"COUNT(1)\", \"cnt\");\r\nconst { cnt }: { cnt: number } = await countQuery.getRawOne();\r\n\r\nlet query = rootQuery\r\n\t.cache(withCache)\r\n\t.skip(start)\r\n\t.take(nbRecords);\r\n\r\n\tconst records: TEntity[] = await query.getMany();\r\n\r\n```"
      },
      {
        "user": "Destreyf",
        "created_at": "2020-01-11T11:38:44Z",
        "body": "@jeromeSH26 i 100% agree that the getCount function should be flexible/adjustable, unfortunately i'm not a maintainer on this project."
      },
      {
        "user": "jeromeSH26",
        "created_at": "2020-01-11T14:18:47Z",
        "body": "Yep, that's why I leave this question opened for a while"
      },
      {
        "user": "dsbert",
        "created_at": "2020-05-01T16:05:31Z",
        "body": "Note this also causes incorrect counts to be returned.\r\n\r\nHere is an example.\r\n\r\nYou have two number columns set as primary keys - `field1` and `field2`.\r\n\r\nThe following two rows will return the incorrect count.\r\n\r\n```\r\n{\r\n\tfield1: 11,\r\n\tfield2: 101\r\n\t// concat(field1, field2) = '11101'\r\n},\r\n{\r\n\tfield1: 1,\r\n\tfield2: 1101\r\n\t// concat(field1, field2) = '11101'\r\n},\r\n```\r\n\r\nCount should be 2, but returns 1.\r\n"
      },
      {
        "user": "imnotjames",
        "created_at": "2020-10-08T08:23:30Z",
        "body": "> Is there a way or a parameter to set to avoid the concat and just running a kind of (select count(1) FROM \"sc\".\"tbl\" \"u\") ?\r\n\r\nIn cases with joins this won't work.  If there are no joins it's possible to be a performance improvement we could apply but we'd need a number of tests to validate behavior."
      },
      {
        "user": "imnotjames",
        "created_at": "2020-10-08T19:35:58Z",
        "body": "Can you confirm that #6870 fixes the issues you're seeing?"
      }
    ]
  },
  {
    "number": 5274,
    "title": "findOne({ someField: undefined }) vs findOne({ someField: null})",
    "created_at": "2020-01-01T21:45:47Z",
    "closed_at": "2020-10-12T09:27:17Z",
    "labels": [
      "bug",
      "question",
      "driver: sqlite"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/5274",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[x] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[ ] `cockroachdb`\r\n[x] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nWhen calling findOne() on a table with a column that is marked as nullable, if you pass `undefined` for that column in the select condition, the query does find any entry. If you pass `null` instead of `undefined`, there there is a typing error (see below for the exact message)\r\n\r\nHere's a small example to reproduce the problem:\r\n\r\n```typescript\r\n@Entity()\r\nclass Person {\r\n\r\n    @PrimaryGeneratedColumn()\r\n    id!: number\r\n\r\n    @Column()\r\n    name!: string\r\n\r\n    @Column({ nullable: true })\r\n    age?: number\r\n}\r\n\r\n\r\n(async () => {\r\n\r\n    const connection = await createConnection({\r\n        type: \"sqlite\",\r\n        database: \":memory:\",\r\n        synchronize: true,\r\n        logging: true,\r\n        entities: [Person]\r\n    })\r\n\r\n    const repo = connection.getRepository(Person)\r\n    const name = \"John\"\r\n\r\n    await repo.save(repo.create({ name }))\r\n\r\n    const result = [\r\n        await repo.findOne({ name, }),  // (1) works OK\r\n        await repo.findOne({ name, age: undefined }), // (2) returns undefined\r\n        await repo.findOne({ name, age: null }), // (3) does not compile, typing error\r\n    ]\r\n\r\n    console.log(result)\r\n})()\r\n```\r\nWhen you try and run this with ts-node, this you get typing error on (3):\r\n\r\n```\r\n    return new TSError(diagnosticText, diagnosticCodes)\r\n           ^\r\nTSError: \u2a2f Unable to compile TypeScript:\r\nsource/backend/index.ts:92:15 - error TS2769: No overload matches this call.\r\n  Overload 1 of 3, '(id?: string | number | Date | ObjectID | undefined, options?: FindOneOptions<Person> \r\n| undefined): Promise<Person | undefined>', gave the following error.\r\n    Argument of type '{ name: string; age: null; }' is not assignable to parameter of type 'string | number | Date | ObjectID | undefined'.\r\n      Object literal may only specify known properties, and 'name' does not exist in type 'Date | ObjectID'.\r\n  Overload 2 of 3, '(options?: FindOneOptions<Person> | undefined): Promise<Person | undefined>', gave the following error.\r\n    Argument of type '{ name: string; age: null; }' is not assignable to parameter of type 'FindOneOptions<Person>'.\r\n      Object literal may only specify known properties, and 'name' does not exist in type 'FindOneOptions<Person>'.\r\n  Overload 3 of 3, '(conditions?: FindConditions<Person> | undefined, options?: FindOneOptions<Person> | undefined): Promise<Person | undefined>', gave the following error.\r\n    Argument of type '{ name: string; age: null; }' is not assignable to parameter of type 'FindConditions<Person>'.\r\n      Types of property 'age' are incompatible.\r\n        Type 'null' is not assignable to type 'number | FindOperator<number | undefined> | undefined'.    \r\n\r\n92         await repo.findOne({ name, age: null }),\r\n                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n\r\n\r\n    at createTSError (C:\\Code\\mixarr\\node_modules\\ts-node\\src\\index.ts:293:12)\r\n    at reportTSError (C:\\Code\\mixarr\\node_modules\\ts-node\\src\\index.ts:297:19)\r\n    at getOutput (C:\\Code\\mixarr\\node_modules\\ts-node\\src\\index.ts:399:34)\r\n    at Object.compile (C:\\Code\\mixarr\\node_modules\\ts-node\\src\\index.ts:457:32)\r\n    at Module.m._compile (C:\\Code\\mixarr\\node_modules\\ts-node\\src\\index.ts:536:43)\r\n    at Module._extensions..js (internal/modules/cjs/loader.js:995:10)\r\n    at Object.require.extensions.<computed> [as .ts] (C:\\Code\\mixarr\\node_modules\\ts-node\\src\\index.ts:539:12)\r\n    at Module.load (internal/modules/cjs/loader.js:815:32)\r\n    at Function.Module._load (internal/modules/cjs/loader.js:727:14)\r\n    at Function.Module.runMain (internal/modules/cjs/loader.js:1047:10)\r\nerror Command failed with exit code 1.\r\n```\r\n\r\nIf you comment out (3), here's the output:\r\n\r\n```\r\nquery: BEGIN TRANSACTION\r\nquery: SELECT * FROM \"sqlite_master\" WHERE \"type\" = 'table' AND \"name\" IN ('person')\r\nquery: SELECT * FROM \"sqlite_master\" WHERE \"type\" = 'index' AND \"tbl_name\" IN ('person')\r\nquery: SELECT * FROM \"sqlite_master\" WHERE \"type\" = 'table' AND \"name\" = 'typeorm_metadata'\r\nquery: CREATE TABLE \"person\" (\"id\" integer PRIMARY KEY AUTOINCREMENT NOT NULL, \"name\" varchar NOT NULL, \"age\" integer)\r\nquery: COMMIT\r\nquery: BEGIN TRANSACTION\r\nquery: INSERT INTO \"person\"(\"id\", \"name\", \"age\") VALUES (NULL, ?, NULL) -- PARAMETERS: [\"John\"]\r\nquery: COMMIT\r\n\r\n// Here are the generated query\r\nquery: SELECT \"Person\".\"id\" AS \"Person_id\", \"Person\".\"name\" AS \"Person_name\", \"Person\".\"age\" AS \"Person_age\" FROM \"person\" \"Person\" WHERE \"Person\".\"name\" = ? LIMIT 1 -- PARAMETERS: [\"John\"]\r\nquery: SELECT \"Person\".\"id\" AS \"Person_id\", \"Person\".\"name\" AS \"Person_name\", \"Person\".\"age\" AS \"Person_age\" FROM \"person\" \"Person\" WHERE \"Person\".\"name\" = ? AND \"Person\".\"age\" = ? LIMIT 1 -- PARAMETERS: [\"John\",null]\r\n\r\n// Here's the result (1) works, and (2) is undefined\r\n[ Person { id: 1, name: 'John', age: null }, undefined ]\r\n```\r\nSo given a `name`and an `age` (potentially `undefined`), I don't know how to find a match properly:\r\n- if I call `findOne({name,age})` i get `undefined`\r\n- if I call `findOne({name, age: age || null}` i get an error.\r\n\r\nI would expect `findOne({name,age})` to return the match in this case.\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/5274/comments",
    "author": "meuter",
    "comments": [
      {
        "user": "xileftenurb",
        "created_at": "2020-06-02T13:12:00Z",
        "body": "as a possible workaround, you could use this syntax :\r\n```\r\n{\r\n    name,\r\n    ...age && {age}\r\n}\r\n```\r\nthis will send to typeorm `{name}` if age is truthy, and {name, age} if it's falsy.\r\nof course, it would be better to have a correct handling on the typeorm side, but for the moment, the workaround should work."
      },
      {
        "user": "meuter",
        "created_at": "2020-08-01T17:01:51Z",
        "body": "Thanks for the workaround!"
      },
      {
        "user": "imnotjames",
        "created_at": "2020-10-12T09:27:17Z",
        "body": "Duplicate of #3416 "
      }
    ]
  },
  {
    "number": 4718,
    "title": "TypeORM tries to drop views that are needed by the pg_stat_statements extension",
    "created_at": "2019-09-10T08:49:04Z",
    "closed_at": "2020-10-04T02:50:48Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/4718",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[x] `postgres`\r\n[ ] `cockroachdb`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\n1. Enable extension pg_stat_statments\r\n2. Start your application with the synchronize option set to true\r\n\r\nThe error that is caused:\r\n\r\n`QueryFailedError: cannot drop view pg_stat_statements because extension pg_stat_statements requires it`\r\n\r\nWhy is TypeORM trying to drop a view that is needed by the extension? Is TypeORM not compatible with pg_stat_statements?\r\n\r\n<!--\r\n    To answer those questions you need to put \"x\" inside the square brackets, for example:\r\n    [x] `mysql`\r\n    [ ] `postgres`\r\n\r\n    Also, please format your code properly (by taking code blocks into ```ts .... ```)\r\n!>\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/4718/comments",
    "author": "lucaslenz",
    "comments": [
      {
        "user": "Kononnable",
        "created_at": "2019-10-16T08:32:03Z",
        "body": "I don't know this extension, but it looks like it creates it's own tables/views in your schema. Typeorm while synchronizing deletes every database object which isn't described using typeorm decorators(or entity schemas). It can't distinguish if such object is no longer necessary or is it something completely not related to your app code.\r\n\r\nIf you want to use typeorm with tables/views not related to your app code you probably need to make dummy view/table in typeorm and disable synchronization for it - just empty class decorated with Column/ViewEntity with `synchronize:false` and proper name."
      },
      {
        "user": "lucaslenz",
        "created_at": "2019-10-28T12:50:33Z",
        "body": "Thanks for your advice.\r\nI solved the problem by only using Migrations instead of the synchronization feature as you suggested.\r\n\r\nCan be closed."
      },
      {
        "user": "zveljkovic",
        "created_at": "2022-02-25T15:33:15Z",
        "body": "I would like this to be reopened as we have a need to reset the database and would like to use `schema:drop` but it fails with\r\n\r\n`\r\nquery: 'DROP VIEW IF EXISTS \"public\".\"pg_stat_statements\" CASCADE;',\r\n  parameters: undefined,\r\n  driverError: error: must be owner of view pg_stat_statements\r\n`\r\n\r\nIt would be nice to exclude some views/tables from dropping by config."
      },
      {
        "user": "Ginden",
        "created_at": "2022-02-25T16:26:18Z",
        "body": "@zveljkovic You can describe these views and mark them with `synchronize: false`."
      }
    ]
  },
  {
    "number": 4258,
    "title": "Prevent nullification of missing related entities",
    "created_at": "2019-06-08T09:25:52Z",
    "closed_at": "2019-06-22T21:52:44Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/4258",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[x] `postgres`\r\n[ ] `cockroachdb`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[ ] `latest`\r\n[ ] `@next`\r\n[x] `0.2.17` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nIn our backend system, we face the problem of editing entities with relations by several clients. Given the following scenario:\r\n\r\n\r\n```@Entity(\"game\")\r\nexport class game {\r\n\t...some columns ...\r\n\r\n\t@OneToMany(type => gamelanguagerelation, gamelanguagerelations =>\r\n\tgamelanguagerelations.fk_gameid, { cascade: ['insert', 'update'] })\r\n\tgamelanguagerelations:gamelanguagerelation[];\r\n}\r\n```\r\n\r\nIf one client (user A) now creates a new game and submits this to the backend, a second user (user B) could create a new `gamelanguagerelation` for this game on his side. He will submit this relation within the whole game object to the backend. Then, the user A uses its offline copy of this game to also add a new `gamelanguagerelation` with a new (UUID) primary key. When sending this new relation (also within a game object) to the backend, typeorm tries to nullify the first relation (which was inserted by user B) since it is not part of the entity of user A. This even happens if cascade is only set to insert or update (but not remove). Unfortunately, save operation fails in this case because the foreign key (fk_gameid in gamelanguagerelation) is not nullable. Even if it would succeed, I don't want to 'orphanize' missing relations.\r\n\r\nIs there a way in typeorm to not nullify missing relations in a data set, that gets saved?\r\n\r\nThanks in advance!\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/4258/comments",
    "author": "mgreg89",
    "comments": [
      {
        "user": "Kononnable",
        "created_at": "2019-06-22T14:31:05Z",
        "body": "Ok, so problem is that you've got an entity which doesn't have actual data and it destroys some of your new data on `save`? You should use `preload` to load an actual state of data or use an query builder(probably even a relationalQueryBuilder)."
      },
      {
        "user": "mgreg89",
        "created_at": "2019-06-22T15:01:43Z",
        "body": "Thank you for that tip regarding preload! I wasn't aware of this function. But it looks like it is exactly what I was looking for :)\r\n\r\nBut nevertheless, wouldn't it be more intuitive if such missing data will only be removed from the database when `cascade: true` or `cascade: ['remove']` was explicitly set?"
      },
      {
        "user": "Kononnable",
        "created_at": "2019-06-22T21:52:44Z",
        "body": "`cascade:remove` is pretty complex subject and is discussed in few other issues.\r\n\r\nAs for why it is removed - you're telling typeorm to save a state of an object(an entity). Part of the object is the relation(doesn't matter where it is stored) - you're telling it to set entity as empty table(or at least 'not so full'), so it does that. Cascades do something different - they define if related entity should also be saved - other entity fields, not just state of the relation."
      }
    ]
  },
  {
    "number": 4216,
    "title": "How do you get mongodb buildConnectionUrl from TypeORM Connection",
    "created_at": "2019-05-31T05:33:35Z",
    "closed_at": "2019-05-31T14:36:53Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/4216",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[x] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[ ] `cockroachdb`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nIs there any way to get mongodb MongoClient instance or mongodb connection url from below connection.\r\n```typescript\r\nconst connection = await createConnection(connectionOptions);\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/4216/comments",
    "author": "firecrackerz",
    "comments": [
      {
        "user": "rustamwin",
        "created_at": "2019-05-31T07:16:53Z",
        "body": "Did you mean \"Underlying mongodb library\" ?\r\nIf yes then\r\n```typescript\r\nconst connection = await createConnection(connectionOptions);\r\nconst mongodb = connection.driver.mongodb\r\nmongodb.MongoClient // It's mongodb client instance\r\n```\r\n"
      },
      {
        "user": "firecrackerz",
        "created_at": "2019-05-31T11:50:58Z",
        "body": "@rustamwin Property 'mongodb' does not exist on type 'Driver'.ts(2339)"
      },
      {
        "user": "rustamwin",
        "created_at": "2019-05-31T12:59:14Z",
        "body": "@firecrackerz you can use a bit hack ;)\r\n```typescript\r\nconst connection = await createConnection(connectionOptions);\r\nconst mongodb = (connection.driver as any).mongodb\r\nmongodb.MongoClient // It's mongodb client instance\r\n```"
      },
      {
        "user": "firecrackerz",
        "created_at": "2019-05-31T14:36:53Z",
        "body": "@rustamwin thanks."
      },
      {
        "user": "shamanov-d",
        "created_at": "2020-10-14T13:37:24Z",
        "body": "@rustamwin, @firecrackerz \r\nYour decision is wrong.\r\n\r\n```javascript\r\nconst connection = await createConnection(connectionOptions);\r\nconst mongodb = (connection.driver as any).mongodb;\r\nmongodb.MongoClient; // It's mongodb client prototype!!!\r\n// it does not contain connection data\r\n```\r\nIt works.\r\n```javascript\r\nconst connection = await createConnection(connectionOptions);\r\nconst ClientDb = (connection.driver as any).queryRunner.databaseConnection; // class instance\r\nconsole.log(await ClientDb.db(\"pictureDev\").collection('goods').find({}).toArray()); // query example\r\n```\r\n\r\n\r\n"
      }
    ]
  },
  {
    "number": 4200,
    "title": "Multiple unique keys when using one to one",
    "created_at": "2019-05-27T15:45:43Z",
    "closed_at": "2019-05-29T13:34:58Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/4200",
    "body": "**Issue type:**\r\n\r\n[ ] question\r\n[x] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[x] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[ ] `cockroachdb`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[ ] `latest`\r\n[ ] `@next`\r\n[x] `0.2.17` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nHi guys, I'm trying to have unique keys with foreign key associated with one of them but I think typeorm is creating different unique keys.\r\n\r\nHere is my model file:\r\n\r\n```ts\r\nimport {\r\n  Column,\r\n  Entity,\r\n  JoinColumn,\r\n  OneToOne,\r\n  PrimaryGeneratedColumn,\r\n  Unique,\r\n} from 'typeorm';\r\n\r\nimport { BotModel } from './bot.model';\r\n\r\n@Entity('intent')\r\n@Unique(['botId', 'name'])\r\nexport class IntentModel {\r\n  @PrimaryGeneratedColumn('uuid')\r\n  intentId: string;\r\n\r\n  @Column()\r\n  botId: string;\r\n\r\n  @OneToOne(() => BotModel, { cascade: true })\r\n  @JoinColumn({\r\n    name: 'botId',\r\n    referencedColumnName: 'botId',\r\n  })\r\n  bot: BotModel;\r\n\r\n  @Column({ length: 16 })\r\n  name: string;\r\n\r\n  @Column({\r\n    length: 128,\r\n    nullable: true,\r\n  })\r\n  description: string;\r\n}\r\n```\r\n\r\nMy `create table intent` from mysql:\r\n\r\n```mysql\r\nCREATE TABLE `intent` (\r\n  `intentId` varchar(36) NOT NULL,\r\n  `botId` varchar(255) NOT NULL,\r\n  `name` varchar(16) NOT NULL,\r\n  `description` varchar(128) DEFAULT NULL,\r\n  PRIMARY KEY (`intentId`),\r\n  UNIQUE KEY `REL_94de4914fe0a743917de52fe8e` (`botId`),\r\n  UNIQUE KEY `IDX_94de4914fe0a743917de52fe8e` (`botId`),\r\n  UNIQUE KEY `IDX_78750387b2c61fb51adb75b5ab` (`botId`,`name`),\r\n  CONSTRAINT `FK_94de4914fe0a743917de52fe8e7` FOREIGN KEY (`botId`) REFERENCES `bot` (`botId`) ON DELETE NO ACTION ON UPDATE NO ACTION\r\n) ENGINE=InnoDB DEFAULT CHARSET=latin1\r\n```\r\n\r\nWhen I try to insert different name with id(already inserted) I'm getting this:\r\n```mysql\r\nER_DUP_ENTRY: Duplicate entry '0b387f8b-d330-4b39-93d2-5637f11001b7' for key 'REL_94de4914fe0a743917de52fe8e'\r\n```\r\n\r\nI tried in different ways but no success.",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/4200/comments",
    "author": "lucasmonstrox",
    "comments": [
      {
        "user": "vlapo",
        "created_at": "2019-05-28T17:44:07Z",
        "body": "It shouldn't be `ManyToOne` relation? I mean you want allow one `BotModel` to be related with many `IntentModel`.\r\n\r\n`OneToOne` is reason of first `UNIQUE KEY 'REL_94de4914fe0a743917de52fe8e' ('botId'),` but I do not understand second one `UNIQUE KEY 'IDX_94de4914fe0a743917de52fe8e' ('botId'),`. It does not appear in my test."
      },
      {
        "user": "lucasmonstrox",
        "created_at": "2019-05-29T13:34:58Z",
        "body": "Working :-D\r\n\r\nThanks"
      }
    ]
  },
  {
    "number": 4197,
    "title": "Many to Many relation not using jointable when updating entity",
    "created_at": "2019-05-26T21:22:32Z",
    "closed_at": "2019-05-29T07:27:54Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/4197",
    "body": "**Issue type:**\r\n\r\n[ ] question\r\n[x] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[x] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[ ] `cockroachdb`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest` (`^0.2.17`)\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nWhen I try to add a group to a user and update the user entity, the update query results in a an error (`ER_BAD_FIELD_ERROR`). \r\n\r\nTypeorm tries to set the user id, which should go into the join table, to the user table itself. The code should explain the problem a little bit better.\r\n\r\n**TinyUser.ts**\r\n```javascript\r\nimport {Entity, JoinTable, ManyToMany, PrimaryGeneratedColumn} from \"typeorm\";\r\nimport {TinyGroup} from \"./TinyGroup\";\r\n\r\n@Entity()\r\nexport class TinyUser {\r\n    /**\r\n     * Contains the unique number for the Page\r\n     *\r\n     * @name id\r\n     * @type number\r\n     */\r\n    @PrimaryGeneratedColumn()\r\n    id: number = 0;\r\n\r\n    /**\r\n     * Contains the user groups\r\n     *\r\n     * @name groups\r\n     * @type TinyGroup[]\r\n     */\r\n    @ManyToMany(() => TinyGroup)\r\n    @JoinTable({\r\n        name: 'tiny_user_groups',\r\n        joinColumn: {referencedColumnName: 'id', name: 'user_id'},\r\n        inverseJoinColumn: {referencedColumnName: 'id', name: 'group_id'}\r\n    })\r\n    groups?: TinyGroup[];\r\n}\r\n```\r\n\r\n**TinyGroup.ts**\r\n```javascript\r\nimport {Entity, JoinTable, ManyToMany, PrimaryGeneratedColumn} from \"typeorm\";\r\nimport {TinyUser} from \"./TinyUser\";\r\n\r\n@Entity()\r\nexport class TinyGroup\r\n{\r\n    /**\r\n     * Contains the unique number for the Page\r\n     *\r\n     * @name id\r\n     * @type number\r\n     */\r\n    @PrimaryGeneratedColumn()\r\n    id: number = 0;\r\n\r\n    /**\r\n     * Contains the user groups\r\n     *\r\n     * @name users\r\n     * @type TinyUser[]\r\n     */\r\n    @ManyToMany(() => TinyUser)\r\n    @JoinTable({\r\n        name: 'tiny_user_groups',\r\n        joinColumn: {referencedColumnName: 'id', name: 'group_id'},\r\n        inverseJoinColumn: {referencedColumnName: 'id', name: 'user_id'}\r\n    })\r\n    users?: TinyUser[];\r\n}\r\n```\r\n\r\n**App.ts**\r\n```javascript\r\nimport {ConnectionOptions, createConnection} from \"typeorm\";\r\nimport {TinyUser} from \"./Models/TinyUser\";\r\nimport {TinyGroup} from \"./Models/TinyGroup\";\r\nimport {MysqlConnectionOptions} from \"typeorm/driver/mysql/MysqlConnectionOptions\";\r\n\r\n(async function ()\r\n{\r\n    const config: MysqlConnectionOptions = {\r\n        \"type\": \"mysql\",\r\n        \"host\": \"localhost\",\r\n        \"port\": 3306,\r\n        \"username\": \"root\",\r\n        \"password\": \"root\",\r\n        \"database\": \"test\",\r\n        \"synchronize\": true\r\n        , entities: [__dirname + '/Models/*.js']\r\n    };\r\n\r\n    const connection = await createConnection(config);\r\n\r\n    const gr = connection.getRepository(TinyGroup);\r\n    const ur = connection.getRepository(TinyUser);\r\n\r\n    const u: TinyUser = new TinyUser();\r\n    const g: TinyGroup = new TinyGroup();\r\n\r\n    await ur.save(u);\r\n    await gr.save(g);\r\n\r\n    u.groups = [g];\r\n\r\n    try {\r\n        await ur.update(u, {id: 1});\r\n    } catch(e) {\r\n        console.error(e);\r\n    }\r\n})();\r\n```\r\n\r\nThis code results in an `ER_BAD_FIELD_ERROR: Unknown column 'user_id' in 'field list'` error.\r\n\r\nMy expectation would be a query like this:\r\n```SQL\r\nINSERT INTO `tiny_user_groups` SET `user_id` = ?, `group_id` = ?\r\n```\r\n\r\nThe generated query however is the following:\r\n```SQL\r\nUPDATE `tiny_user` SET `id` = 1, `user_id` = NULL WHERE `id` = 1\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/4197/comments",
    "author": "YannikSc",
    "comments": [
      {
        "user": "vlapo",
        "created_at": "2019-05-27T20:33:44Z",
        "body": "You have to use `save`. `update` is only raw update and skip most of ORM based magic features like relations.\r\n```ts\r\nconst gr = connection.getRepository(TinyGroup);\r\nconst ur = connection.getRepository(TinyUser);\r\n\r\nconst u: TinyUser = new TinyUser();\r\nconst g: TinyGroup = new TinyGroup();\r\n\r\nawait ur.save(u);\r\nawait gr.save(g);\r\n\r\nu.groups = [g];\r\n\r\nawait ur.save(u);\r\n```"
      },
      {
        "user": "YannikSc",
        "created_at": "2019-05-29T07:27:36Z",
        "body": "Thanks a lot. Worked for me! :+1: "
      }
    ]
  },
  {
    "number": 3731,
    "title": "Question: How to keep all relations when only filtering by one of them",
    "created_at": "2019-02-28T10:42:23Z",
    "closed_at": "2019-03-01T04:38:35Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/3731",
    "body": "**Issue type:**\r\n\r\n[X] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[X] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[X] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nI have a User table and  a Category table, the relation is many-to-many,\r\n\r\nI want to select all users who are under a specific category.\r\n\r\n```ts\r\n    users = await userRepository\r\n      .createQueryBuilder('user')\r\n      .leftJoinAndSelect('user.categories', 'category')\r\n      .where('category.categoryId = :id', { id: catId})\r\n      .orderBy('user.age', 'DESC', 'NULLS LAST')\r\n      .getMany();\r\n```\r\n\r\nIt filters correct users, but under each user, only the requested category Id is kept. But I want to keep all the categories under each user. I did not find a similar question for this and did not find a solution in the docs.\r\n\r\ni.e.\r\n\r\n```ts\r\nusers = [\r\n{ id = 1, categories: [ cat1, cat2, cat3...] },\r\n{ id = 2, categories: [ cat1, cat2, cat3...] }\r\n...\r\n]\r\n```\r\n\r\nnot \r\n\r\n```ts\r\nusers = [\r\n{ id = 1, categories: [cat2] },\r\n{ id = 2, categories: [cat2] }\r\n...\r\n]\r\n```\r\n\r\nMy current solution is using findByIds with relations, passing in all the userIds got from the previous step,  I can get what I want but I don't think it is optimal.\r\n\r\nDoes anyone know how to handle such query?\r\n\r\nThanks a lot.\r\n\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/3731/comments",
    "author": "Sheng-Xuan",
    "comments": [
      {
        "user": "vlapo",
        "created_at": "2019-02-28T22:29:35Z",
        "body": "Just fast tip but try this:\r\n```typescript\r\nusers = await userRepository\r\n      .createQueryBuilder('user')\r\n      .leftJoin('user.categories', 'category')\r\n      .leftJoinAndSelect('user.categories', 'categorySelect')\r\n      .where('category.categoryId = :id', { id: catId})\r\n      .orderBy('user.age', 'DESC', 'NULLS LAST')\r\n      .getMany();\r\n```"
      },
      {
        "user": "Sheng-Xuan",
        "created_at": "2019-03-01T04:38:29Z",
        "body": "@vlapo That works. Thanks a lot! "
      }
    ]
  },
  {
    "number": 3628,
    "title": "Order by a computed field/column in createQueryBuilder",
    "created_at": "2019-02-12T16:53:30Z",
    "closed_at": "2019-02-14T19:53:59Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/3628",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[x] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\nHi guys,\r\n\r\nI need to order my results by a computed field with `createQueryBuilder`.\r\n\r\nIn the docs, I see that `.orderBy` wants a column as a paramenter, but I cannot compute a column (in this case a boolean colum) with `createQueryBuilder`.\r\n\r\nConsider this simple entity:\r\n```ts\r\nclass Store {\r\n    @Column({ type: 'time' })\r\n    from: string;\r\n    \r\n    @Column({ type: 'time' })\r\n    to: string;\r\n\r\n}\r\n```\r\n\r\nNow, i want to retrieve all products from stores and sort them in order to show first all the products available in that moment (so the store has to be open) and after all the products that are not available.\r\n\r\nThis is the raw sql query to find all stores and order them based on the availability at a specific time:\r\n\r\n```sql\r\nSELECT *, (:time BETWEEN stores.from AND stores.to) as is_open\r\nFROM stores\r\nORDER BY is_open DESC\r\n```\r\n\r\nIs it possible to do this without `getRawMany`?\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/3628/comments",
    "author": "ootkin",
    "comments": [
      {
        "user": "vlapo",
        "created_at": "2019-02-13T23:07:53Z",
        "body": "Did you even try find solution here in issues ? :) You can do custom selects and order by:\r\n```typescript\r\nawait connection.getRepository(Store)\r\n        .createQueryBuilder(\"stores\")\r\n        .select()\r\n        .addSelect(\"(:time BETWEEN stores.from AND stores.to)\", \"is_open\")\r\n        .orderBy(\"is_open\")\r\n        .getMany();\r\n```\r\nor use `getRawAndEntities` if you need `is_open` too."
      },
      {
        "user": "ootkin",
        "created_at": "2019-02-14T09:42:39Z",
        "body": "Hi vlapo, yes I tried to find the solution in other issues, but I didn't find this particular case.\r\n\r\nAnyway, I tried your solutions and it works with that simple entity.\r\n\r\nIn my real case, Store entity is more complex and it has more than one time slot (from, to) and they are handled with another entity (TimeTable) that specify even a week day.\r\n\r\nSo i create a subquery in `addSelect` like this:\r\n\r\n```ts\r\nawait connection.getRepository(Store)\r\n            .createQueryBuilder('store')\r\n            .select()\r\n            .addSelect(sq => {\r\n                return sq\r\n                    .select('bool_or(:day = timeTable.day AND :time BETWEEN timeTable.from AND timeTable.to)', 'is_open')\r\n                    .from('stores', 'sqStore')\r\n                    .innerJoin('sqStore.timeTables', 'timeTable')\r\n                    .where('sqStore.id = store.id')\r\n                    .setParameter('time', time)\r\n                    .setParameter('day', 0);\r\n\r\n            }, 'is_open')\r\n            .orderBy('is_open', 'DESC')\r\n            .getMany()\r\n```\r\n\r\nFor each store I check if it's open in at least one time slot and then with `bool_or` I'm able to aggregate the is_open result and assign it to every row.\r\n\r\nSeems like to works now.\r\n\r\nThanks for help me to figure it out! :)"
      },
      {
        "user": "vlapo",
        "created_at": "2019-02-14T19:53:59Z",
        "body": "You are welcome :)"
      },
      {
        "user": "phucsang0spt",
        "created_at": "2021-01-01T19:21:00Z",
        "body": "hi @vlapo , i did the same when order by additional field and I got this error: \"for SELECT DISTINCT, ORDER BY expressions must appear in select list\". But there is no any DISTINCT in my sql query :|"
      },
      {
        "user": "elapshynov",
        "created_at": "2024-04-19T08:53:39Z",
        "body": "> hi @vlapo , i did the same when order by additional field and I got this error: \"for SELECT DISTINCT, ORDER BY expressions must appear in select list\". But there is no any DISTINCT in my sql query :|\r\n\r\nDistinct might be added by take/skip"
      },
      {
        "user": "amiralammohawk",
        "created_at": "2024-06-04T15:39:57Z",
        "body": "@phucsang0spt  same error"
      }
    ]
  },
  {
    "number": 3614,
    "title": "Update Date column from SQL",
    "created_at": "2019-02-10T15:19:31Z",
    "closed_at": "2019-02-10T16:59:28Z",
    "labels": [
      "question",
      "comp: query builder"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/3614",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[x] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n---\r\n\r\nIs there a way to update `Date` column from SQL. Something like\r\n\r\n```\r\n        await connection\r\n            .createQueryBuilder()\r\n            .update(Session)\r\n            .set({ ip_address: ip, last_login: 'CURRENT_TIMESTAMP'})\r\n            .where('session.user_id = :id', { id: userId })\r\n            .execute()\r\n```\r\n\r\n\r\n`UpdateDateColumn` does not work for me because I need to update the column only in some save actions whereas `UpdateDateColumn` gets triggered in all save actions",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/3614/comments",
    "author": "thellimist",
    "comments": [
      {
        "user": "vlapo",
        "created_at": "2019-02-10T16:08:37Z",
        "body": "Did you try \r\n```typescript\r\n.set({ ip_address: ip, last_login: () => 'CURRENT_TIMESTAMP'})\r\n```"
      },
      {
        "user": "thellimist",
        "created_at": "2019-02-10T16:59:15Z",
        "body": "works \ud83d\udc4d "
      }
    ]
  },
  {
    "number": 3575,
    "title": "ID gets appended to field name",
    "created_at": "2019-02-04T15:43:16Z",
    "closed_at": "2019-02-04T16:20:45Z",
    "labels": [
      "question",
      "comp: relations"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/3575",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[x] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\nI have a problem regarding many to one\r\n```ts\r\n@Entity()\r\nexport class Post {\r\n    @PrimaryGeneratedColumn({type: 'int'})\r\n    id: number\r\n    @ManyToOne(type => User, user => user.id)\r\n    @Column({type: 'int'})\r\n    authorId: User\r\n}\r\n```\r\n```ts\r\n@Entity()\r\nexport class User {\r\n    @PrimaryGeneratedColumn({type: 'int'})\r\n    id: number\r\n}\r\n```\r\nWhen I try to get all posts via\r\n```ts\r\nconst posts = await this.postRepository.find({\r\n                       relations: ['authorId']\r\n                       })\r\n```\r\nI get a ER_BAD_FIELD_ERROR with the message: Unknown column 'Post.authorIdId' in 'field list'\r\n<!--\r\n    To answer those questions you need to put \"x\" inside the square brackets, for example:\r\n    [x] `mysql`\r\n    [ ] `postgres`\r\n\r\n    Also, please format your code properly (by taking code blocks into ```ts .... ```)\r\n!>\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/3575/comments",
    "author": "Murbal",
    "comments": [
      {
        "user": "vlapo",
        "created_at": "2019-02-04T16:14:09Z",
        "body": "You have `ManyToOne` and `Column` defined for one property. if you want to have `authorId` and `author` property in your `Post` entity:\r\n```typescript\r\n@Entity()\r\nexport class Post {\r\n    @PrimaryGeneratedColumn({type: 'int'})\r\n    id: number\r\n\r\n    @Column({type: 'int'})\r\n    authorId: number\r\n\r\n    @ManyToOne(type => User, user => user.id)\r\n    author: User;\r\n}\r\n```\r\nand of course call find like this:\r\n```typescript\r\nconst posts = await this.postRepository.find({\r\n      relations: ['author']\r\n})\r\n```"
      },
      {
        "user": "Murbal",
        "created_at": "2019-02-04T16:21:07Z",
        "body": "Thanks this solved my issue"
      }
    ]
  },
  {
    "number": 3444,
    "title": "Hydration of Embedded (json) types into proper class instances",
    "created_at": "2019-01-18T00:40:21Z",
    "closed_at": "2019-01-18T09:35:00Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/3444",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n\r\n**Database system/driver:**\r\n\r\n[x] `postgres`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n\r\nWhen working with JSON fields, we end up embedding a lot of objects that aren't just data blobs (but have utility methods attached to them too).\r\n\r\nOne (rather simple) example:\r\n\r\n```\r\n@Entity(\"Tenants\")\r\nexport class Tenant extends Schema {\r\n    @Column(\"varchar\", { length: 64 })\r\n    public slug: string;\r\n\r\n    @Column(\"uuid\")\r\n    public addressId: string;\r\n\r\n    @Column(\"jsonb\", {\r\n        transformer: {\r\n            to: value => value,\r\n            from: value => plainToClass(Organization, value)\r\n        }\r\n    })\r\n    public organization: Organization;\r\n}\r\n```\r\n\r\nWhile the Organization class looks like this\r\n```\r\nexport class Organization {\r\n    public legalName: string;\r\n\r\n    public test(): string {\r\n        return \"test\";\r\n    }\r\n}\r\n```\r\n\r\nThe goal is to be able to do `const tenant = await repo.findOne(someId); tenant.organization.test()` (effectively).\r\n\r\nI tried this:\r\n\r\n```\r\n    @Column(type => Organization)\r\n    public organization: Organization;\r\n```\r\n\r\nBut as the docs state, this isn't what I want (pulls in the fields from Org into the base Tenant class). \r\n\r\nMy query is, is using the transformer the proper way to get the right instance, or does TypeORM have something built in that can assist with this?\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/3444/comments",
    "author": "Wintereise",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2019-01-18T09:24:08Z",
        "body": "no, TypeORM doesn't have anything for this functionality and I don't think it will. Converting plain objects to class instances is a tricky thing (for example if it has inner objects we need to introduce extra decorator to get known about its type, just like class-transformer's `@Type`), this is out of TypeORM scope. So yes, in your case using transformer option is a right way to do things."
      },
      {
        "user": "pleerock",
        "created_at": "2019-01-18T09:25:01Z",
        "body": "And generally I don't recommend using classes, use plain objects - it will save your life in most cases. Separate utility classes is a good place for your utility functions in most cases."
      },
      {
        "user": "Wintereise",
        "created_at": "2019-01-18T09:35:00Z",
        "body": "@pleerock Understood, thanks for clarifying."
      }
    ]
  },
  {
    "number": 3339,
    "title": "Unable to run an update using getMongoRepository",
    "created_at": "2018-12-28T06:49:57Z",
    "closed_at": "2019-01-04T20:23:48Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/3339",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[x] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[ ] `latest`\r\n[ ] `@next`\r\n[x] `0.2.10` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nThe current model looks like this.\r\n\r\n```typescript\r\n\r\nimport { Answer } from \"./Answer\";\r\n\r\n@Entity({ database: DATABASE_MONGO_NAME })\r\n\r\nexport class StudentRecord {\r\n  @ObjectIdColumn()\r\n  _id: ObjectID;\r\n\r\n /* many more columns */\r\n\r\n  @Column()\r\n  answers: Answer[];\r\n\r\n}\r\n\r\n```\r\n\r\nThe `Answer` collection model looks like this\r\n\r\n```typescript\r\n@Entity({ database: DATABASE_MONGO_NAME })\r\n\r\nexport class Answer {\r\n  @ObjectIdColumn()\r\n  _id: ObjectID;\r\n\r\n /* many more columns */\r\n\r\n  @ObjectIdColumn()\r\n  mongo_id_question: ObjectID;\r\n\r\n  @Column()\r\n  selected: string[];\r\n}\r\n\r\n```\r\nSo essentially the data stored in a document looks like this \r\n\r\n```json\r\n{\r\n    \"_id\": {\r\n        \"$oid\": \"5c1e60352f73e9000494e33f\"\r\n    },\r\n    \"answers\": [\r\n        {\r\n            \"_id\": {\r\n                \"$oid\": \"5c0e507f0da2560004c9003e\"\r\n            },\r\n            \"mongo_id_question\": {\r\n                \"$oid\": \"5c0e507f0da2560004c9003e\"\r\n            },\r\n            \"selected\": [\r\n                \"5c0e507f0da2560004c9003b\"\r\n            ]\r\n        }\r\n    ]\r\n}\r\n```\r\n\r\nThe query I am trying to run, sets the `updatedAt` column for an object with a given `mongo_id_question` in the `answers` list based on a given `record_id` \r\n\r\n```typescript\r\nStudentRecordsRepository.update(\r\n      {\r\n        _id: new ObjectID(record_id),\r\n        \"answers.mongo_id_question\": new ObjectID(\"5c0e507f0da2560004c9003e\"),\r\n      },\r\n      { $set: { \"answers.$.updatedAt\": new Date() } },\r\n    );\r\n```\r\nI get the following error in `typescript`\r\n\r\n```typescript\r\nerror TS2345: Argument of type '{ _id: ObjectID; \"answers.mongo_id_question\": ObjectID; }' is not assignable to parameter of type 'string | number | Date | ObjectID | FindConditions<StudentRecord> | string[] | number[] | Date[] | ObjectID[]'.\r\n  Object literal may only specify known properties, and '\"answers.mongo_id_question\"' does not exist in type 'string | number | Date | ObjectID | FindConditions<StudentRecord> | string[] | number[] | Date[] | ObjectID[]'\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/3339/comments",
    "author": "judemanutd",
    "comments": [
      {
        "user": "mohamed-badaoui",
        "created_at": "2018-12-28T10:33:00Z",
        "body": "IMHO I never got why people need an ORM for mongoDb. It is already object oriented. What advantages bring an ORM ? \r\nUsing an ORM for mongoDB means that models are stored as relational models and that's a pity because you loose all the benefits of an object oriented database.\r\n\r\nIn PHP world, Doctrine try to do it with DoctrineODM but it was a failure and poorly used "
      },
      {
        "user": "judemanutd",
        "created_at": "2018-12-28T15:46:05Z",
        "body": "> IMHO I never got why people need an ORM for mongoDb. It is already object oriented. What advantages bring an ORM ?\r\n> Using an ORM for mongoDB means that models are relational models and that's a pity because you loose all the benefits of an object oriented database.\r\n> \r\n> In PHP world, Doctrine try to do it with DoctrineODM but it was a failure and poorly used\r\n\r\nBe that as it may, this seems like a question for stack overflow and not the answer to the current issue that is being faced."
      },
      {
        "user": "judemanutd",
        "created_at": "2018-12-28T17:54:57Z",
        "body": "@mohamed-badaoui tried that, didn't work, I'm guessing because the `dot` in a key is not counted as a valid json key so it throws even more errors. \r\n\r\n```typescript\r\n[ERROR] 23:24:34 \u2a2f Unable to compile TypeScript:\r\nsrc/repo/StudentRecordsRepo.ts(160,16): error TS1005: ',' expected.\r\nsrc/repo/StudentRecordsRepo.ts(160,34): error TS1005: ',' expected.\r\nsrc/repo/StudentRecordsRepo.ts(160,40): error TS1005: ':' expected.\r\nsrc/repo/StudentRecordsRepo.ts(160,9): error TS2304: Cannot find name 'answers'.\r\nsrc/repo/StudentRecordsRepo.ts(160,16): error TS2345: Argument of type '{ _id: ObjectID; answers: any; (Missing): any; new: any; }' is not assignable to parameter of type 'string | number | Date | ObjectID | FindConditions<StudentRecord> | string[] | number[] | Date[] | ObjectID[]'.\r\n  Object literal may only specify known properties, and '(Missing)' does not exist in type 'string | number | Date | ObjectID | FindConditions<StudentRecord> | string[] | number[] | Date[] | ObjectID[]'.\r\nsrc/repo/StudentRecordsRepo.ts(160,40): error TS2348: Value of type 'typeof ObjectID' is not callable. Did you mean to include 'new'?\r\n```"
      },
      {
        "user": "pleerock",
        "created_at": "2019-01-04T08:59:18Z",
        "body": "You should use `updateOne` or `updateMany` methods instead."
      },
      {
        "user": "judemanutd",
        "created_at": "2019-01-04T20:23:48Z",
        "body": "It was as simple as that, thank you @pleerock "
      }
    ]
  },
  {
    "number": 3281,
    "title": "Relation entity does not load on findOne",
    "created_at": "2018-12-18T22:06:16Z",
    "closed_at": "2018-12-19T06:41:01Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/3281",
    "body": "**Issue type:**\r\n[X] bug report\r\n\r\n**Database system/driver:**\r\n[X] `mysql` / `mariadb`\r\n\r\n**TypeORM version:**\r\n[X] `@next`\r\n\r\nOn 2.9.0, with findOne repository method, we can load association with FindOptions **relations**  \r\nSo that code line will return Entity and its association\r\n`await connection.getRepository(Entity).findOne({id: 12}, {relations: ['association']});`\r\n\r\nThe same call **does not work** on on @next branch 3.0.0-alpha22\r\nIt return the entity WITHOUT the association. The only way it works is to give as it first parameter directly the id number. So we can't use query :(\r\n\r\n\r\n\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/3281/comments",
    "author": "mohamed-badaoui",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2018-12-19T06:27:46Z",
        "body": "Why you don't use `await connection.getRepository(Entity).findOne({ where: {id: 12}, relations: ['association']});`"
      },
      {
        "user": "pleerock",
        "created_at": "2018-12-19T06:28:20Z",
        "body": "I don't remember motivation of this change, but probably it was made to prevent a confusion since second argument also can have its own `where` argument."
      },
      {
        "user": "mohamed-badaoui",
        "created_at": "2018-12-19T06:41:01Z",
        "body": "All right, thanks @pleerock.\r\n"
      }
    ]
  },
  {
    "number": 3274,
    "title": "Fail to detect PK existing constraint name on migration:generate",
    "created_at": "2018-12-17T19:17:36Z",
    "closed_at": "2018-12-19T15:35:16Z",
    "labels": [
      "question",
      "by design"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/3274",
    "body": "**Issue type:**\r\n\r\n[x] bug report\r\n\r\n**Database system/driver:**\r\n\r\n[x] `postgres`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nI have a psql table created with the following queries:\r\n\r\n```sql\r\nCREATE TABLE users (\r\n    id uuid DEFAULT gen_random_uuid() PRIMARY KEY,\r\n    first_name character varying(50) NOT NULL,\r\n    last_name character varying(50) NOT NULL,\r\n    email character varying(255) NOT NULL UNIQUE,\r\n    password character varying(60) NOT NULL,\r\n    created_at timestamp with time zone DEFAULT now(),\r\n    updated_at timestamp with time zone DEFAULT now()\r\n);\r\n\r\nCREATE UNIQUE INDEX users_pkey ON users(id uuid_ops);\r\nCREATE UNIQUE INDEX users_email_key ON users(email text_ops);\r\n```\r\n\r\nI've created entity that matches the table but right now I want to change type of the `id` field. Everything ok, so far. Now I run command: `typeorm migration:generate -n Init` which creates migration file but it fails to properly detect constraint name. It does not see the ID field with the constraint named as `users_pkey` but instead it just uses random hash. So, the migration query looks like follows:\r\n\r\n```sql\r\nALTER TABLE \"users\" DROP CONSTRAINT \"PK_a3ffb1c0c8416b9fc6f907b7433\"\r\nALTER TABLE \"users\" DROP COLUMN \"id\"\r\nALTER TABLE \"users\" ADD \"id\" BIGSERIAL NOT NULL\r\nALTER TABLE \"users\" ADD CONSTRAINT \"PK_a3ffb1c0c8416b9fc6f907b7433\" PRIMARY KEY (\"id\")\r\n```\r\n\r\nand it should look like this:\r\n\r\n```sql\r\nALTER TABLE \"users\" DROP CONSTRAINT \"users_pkey\"\r\nALTER TABLE \"users\" DROP COLUMN \"id\"\r\nALTER TABLE \"users\" ADD \"id\" BIGSERIAL NOT NULL\r\nALTER TABLE \"users\" ADD CONSTRAINT \"PK_a3ffb1c0c8416b9fc6f907b7433\" PRIMARY KEY (\"id\")\r\n```\r\n\r\nI was trying to provide my own constraint name that would match the old one but it doesn't look like possible for the primary key. Do you know about this bug?",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/3274/comments",
    "author": "lukejagodzinski",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2018-12-18T07:00:40Z",
        "body": "own constraint name aren't supported in typeorm. Typeorm rely on its own names to make a proper schema sync. So, current behaviour you see is correct."
      },
      {
        "user": "lukejagodzinski",
        "created_at": "2018-12-20T01:19:08Z",
        "body": "@pleerock ok so I assume that this library is not intended to work with existing databases where we can use custom constraint name? That's not a big deal as I can rename constraint in migration but would be great to at least detect that change on migration. Thanks anyway!"
      },
      {
        "user": "pleerock",
        "created_at": "2018-12-20T05:08:00Z",
        "body": "@lukejagodzinski we try to support existing databases as much as possible, but there are some things like custom constraint name that aren't supported. Maybe we'll try to add this feature in the future, but its not in our priority list currently."
      },
      {
        "user": "lukejagodzinski",
        "created_at": "2018-12-20T14:41:23Z",
        "body": "@pleerock ok thanks for info :) It's definitely nothing blocking anyone from using it. I can just make some manual changes. Thanks!"
      },
      {
        "user": "vegerot",
        "created_at": "2020-03-17T19:05:44Z",
        "body": "@pleerock what about something similar to what you have for migrations: where there is a unique id generated in the front, then a custom name can be given after.  Best of both worlds"
      }
    ]
  },
  {
    "number": 3272,
    "title": "How to get changes/diff inside model hooks",
    "created_at": "2018-12-17T17:26:02Z",
    "closed_at": "2018-12-24T16:30:25Z",
    "labels": [
      "question",
      "can be closed?"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/3272",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[ ] bug report\r\n[ ] feature request\r\n[x] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[x] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)z\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nI can't find in the documentation a way to get \"changes\" inside Listeners and/or Subscribers ?\r\n\r\nThe behaviour I'm lookig for is something like this :\r\n```\r\n@Entity()\r\nexport class User extends BaseEntity {\r\n  @BeforeUpdate()\r\n  doSomething(changes: Partial<User>) {\r\n    if (this.field != changes.field) {\r\n      // Then do your thing\r\n    }\r\n  }\r\n}\r\n```",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/3272/comments",
    "author": "Kayyow",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2018-12-18T07:15:02Z",
        "body": "you can't. Some of information is available in subscribers, try subscribers instead. "
      },
      {
        "user": "Kayyow",
        "created_at": "2018-12-24T16:36:44Z",
        "body": "Thanks. I created a Subscriber and I can now get changes by comparing `event.entity` to `event.databaseEntity` fields :\r\n\r\n```\r\n@EventSubscriber()\r\nexport class UserSubscriber implements EntitySubscriberInterface<User> {\r\n\r\n  beforeUpdate(event: UpdateEvent<User>) {\r\n    const { entity, databaseEntity } = event\r\n    if (entity && databaseEntity) {\r\n      // entity = user with updated fields\r\n      // databaseEntity = user currently in database before update\r\n      // Then check changes between :entity and :databaseEntity\r\n    }\r\n  }\r\n\r\n}\r\n```\r\n"
      }
    ]
  },
  {
    "number": 3250,
    "title": "[psql] Creating migration for already existing table",
    "created_at": "2018-12-14T00:15:16Z",
    "closed_at": "2018-12-14T13:07:33Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/3250",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[x] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\nI'm trying to create migration that would work with already existing database. I have a table which has two fields:\r\n\r\n```\r\nid BIGSERIAL PRIMARY KEY,\r\norg_id BIGSERIAL UNIQUE,\r\n```\r\n\r\nand in the TS class I have fields defined in the following way:\r\n\r\n```ts\r\n@PrimaryGeneratedColumn()\r\nreadonly id: number;\r\n\r\n@Column(\"bigint\", { name: \"org_id\", unique: true })\r\norgId: number;\r\n```\r\n\r\nand it keeps creating migrations for those two fields. Is there a way to define those two fields that would not create migration?",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/3250/comments",
    "author": "lukejagodzinski",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2018-12-14T03:55:49Z",
        "body": "Try following:\r\n\r\n```ts\r\n@PrimaryColumn(\"bigint\")\r\n@Generated()\r\nreadonly id: number;\r\n\r\n@Column(\"bigint\", { name: \"org_id\", unique: true })\r\n@Generated()\r\norgId: number;\r\n```"
      },
      {
        "user": "lukejagodzinski",
        "created_at": "2018-12-14T13:07:33Z",
        "body": "@pleerock thanks! It worked!"
      }
    ]
  },
  {
    "number": 3237,
    "title": "Still can't get the update result.raw?",
    "created_at": "2018-12-13T03:51:32Z",
    "closed_at": "2018-12-14T07:08:06Z",
    "labels": [
      "question",
      "can be closed?"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/3237",
    "body": "**Issue type:**\r\n\r\n[ x] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ x] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[ ] `latest`\r\n[ x] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\n<!--\r\n    To answer those questions you need to put \"x\" inside the square brackets, for example:\r\n    [x] `mysql`\r\n    [ ] `postgres`\r\n\r\n    Also, please format your code properly (by taking code blocks into ```ts .... ```)\r\n!>\r\n\r\nUpdateResult {\r\n  generatedMaps: [],\r\n  raw:\r\n   OkPacket {\r\n     fieldCount: 0,\r\n     affectedRows: 1,\r\n     insertId: 0,\r\n     serverStatus: 2,\r\n     warningCount: 0,\r\n     message: '(Rows matched: 1  Changed: 0  Warnings: 0',\r\n     protocol41: true,\r\n     changedRows: 0 }\r\n}\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/3237/comments",
    "author": "copyPrinter",
    "comments": [
      {
        "user": "copyPrinter",
        "created_at": "2018-12-13T03:52:28Z",
        "body": "UpdateResult {\r\n  generatedMaps: [],\r\n  raw:\r\n   OkPacket {\r\n     fieldCount: 0,\r\n     affectedRows: 1,\r\n     insertId: 0,\r\n     serverStatus: 2,\r\n     warningCount: 0,\r\n     message: '(Rows matched: 1  Changed: 0  Warnings: 0',\r\n     protocol41: true,\r\n     changedRows: 0 } \r\n}"
      },
      {
        "user": "pleerock",
        "created_at": "2018-12-13T07:22:47Z",
        "body": "More details?"
      },
      {
        "user": "copyPrinter",
        "created_at": "2018-12-14T00:51:03Z",
        "body": "sorry, is generatedMaps.... I want to know the number of rows and ids updated. But now generatedMaps is always empty"
      },
      {
        "user": "pleerock",
        "created_at": "2018-12-14T03:48:12Z",
        "body": "I'll close this issue if you won't provide more details with a good explanation of your problem."
      },
      {
        "user": "copyPrinter",
        "created_at": "2018-12-14T06:43:06Z",
        "body": "like this, i want 'generatedMaps' can return affectedRows id or entity.\r\n`let ret = await getRepository(Cart).update({`\r\n  `goods_id: goodsId,`\r\n           ` buyer_id: memberId`\r\n        `},{`\r\n          ` goods_num : num`\r\n` });`\r\n\r\n`UpdateResult {`\r\n  `generatedMaps: [],`\r\n  `raw:`\r\n  ` OkPacket {\r\n     fieldCount: 0,\r\n     affectedRows: 1,\r\n     insertId: 0,\r\n     serverStatus: 2,\r\n     warningCount: 0,\r\n     message: '(Rows matched: 1  Changed: 1  Warnings: 0',\r\n     protocol41: true,\r\n     changedRows: 1 } }`\r\n\r\nMy English is bad\uff0c If you don't understand I mean\uff0cplease you close."
      },
      {
        "user": "pleerock",
        "created_at": "2018-12-14T07:08:06Z",
        "body": "`generatedMaps` is used mostly internally. `update` method executes a raw sql query, that's only thing it does. If you want more you need to use `save` method instead."
      },
      {
        "user": "copyPrinter",
        "created_at": "2018-12-14T08:40:20Z",
        "body": "thanks"
      }
    ]
  },
  {
    "number": 3219,
    "title": "current URL string parser is deprecated, and will be removed in a future version. To use the new parser, pass option { useNewUrlParser: true } to MongoClient.connect. SERVER IS RUNNING ON localhost:4000",
    "created_at": "2018-12-09T17:02:59Z",
    "closed_at": "2018-12-13T08:16:58Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/3219",
    "body": "**Issue type:**\r\n\r\n[ ] question\r\n[ ] bug report\r\n[x] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[x] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nHey and again same Issue like the quoted one:\r\n\r\n#2270 \r\n\r\nMongoDb asks to select the **new Url Parser**.\r\n\r\n`(node:25768) DeprecationWarning: current URL string parser is deprecated, and will be removed in a future version. To use the new parser, pass option { useNewUrlParser: true } to MongoClient.connect.` #",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/3219/comments",
    "author": "ArcticSpaceFox",
    "comments": [
      {
        "user": "vlapo",
        "created_at": "2018-12-12T22:56:43Z",
        "body": "There is `useNewUrlParser` option in mongodb connection. Set it to `true` if you are using mongodb driver that requires it. If you do not see `useNewUrlParser` option you are using `next` branch and this change is not merge yet."
      },
      {
        "user": "pleerock",
        "created_at": "2018-12-13T08:16:53Z",
        "body": "@vlapo thank you very much for your answer!"
      }
    ]
  },
  {
    "number": 2924,
    "title": "BeforeInsert Issue",
    "created_at": "2018-10-12T23:56:44Z",
    "closed_at": "2018-10-24T20:17:28Z",
    "labels": [
      "question",
      "comp: subscribers and listeners"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/2924",
    "body": "**Issue type:**\r\n\r\n[ ] question\r\n[x ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[x ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[x ] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[x ] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nPlacing @BeforeInsert() and @AfterInsert do not work\r\n\r\n```\r\n@AfterInsert()\r\n  modifyText() {\r\n    console.log(\"Something is being inserted\");\r\n  }\r\n```\r\n\r\n```\r\n@BeforeInsert()\r\n  modifyText() {\r\n    this.text = `${this.text} was modified before insert`;\r\n  }\r\n```\r\n\r\n```\r\n@BeforeInsert()\r\nhashpassword(){\r\n   this.password = ........\r\n}\r\n```\r\n\r\nI've seen this in other issues and they were closed but the issue was never actually resolved.",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/2924/comments",
    "author": "JamesCoonce",
    "comments": [
      {
        "user": "billyjov",
        "created_at": "2018-10-14T20:18:34Z",
        "body": "@JamesCoonce  `@BeforeInsert` work for me using version `0.2.7`. You have to be extra careful when working with asynchronous processes e.g your last use case for hashing a password.\r\n\r\nIt should work with the folowing syntax: \r\n\r\n```\r\n@BeforeInsert\r\nasync hashpassword() {\r\n    this.password = await your-hash-process;\r\n}\r\n```"
      },
      {
        "user": "rustamwin",
        "created_at": "2018-10-15T10:25:47Z",
        "body": "try it in subscribers"
      },
      {
        "user": "JamesCoonce",
        "created_at": "2018-10-16T13:50:22Z",
        "body": "I'm also using 0.2.7. Here is a basic example. This doesn't even work. It does no modify.\r\n```\r\nimport { Entity, Column, PrimaryGeneratedColumn, BeforeInsert} from 'typeorm';\r\n\r\n@Entity()\r\nexport class Todo {\r\n  @PrimaryGeneratedColumn()\r\n  id: number;\r\n\r\n  @Column({ length: 500 })\r\n  text: string;\r\n\r\n  @Column()\r\n  complete: boolean;\r\n\r\n  @BeforeInsert()\r\n  modifyText() {\r\n    this.text = `${this.text} was modified before insert`;\r\n  }\r\n}\r\n```\r\n\r\nInside of my todoService I have this\r\n\r\n```\r\npublic async create(todo: CreateTodosDTO): Promise<Todo> {\r\n        return await this.todoRepository.save(todo);\r\n    }\r\n```"
      },
      {
        "user": "feather-jmalone",
        "created_at": "2018-10-16T14:23:33Z",
        "body": "what does the value of `todo` look like? is it an object that has the properties of `Todo` (e.g. `{id: 1, text: 'text', complete: true}`, or is it an actual instance (e.g. `const todo = new Todo()`)?"
      },
      {
        "user": "JamesCoonce",
        "created_at": "2018-10-16T14:31:23Z",
        "body": "When I send the post request it's \r\n\r\n```\r\n{\r\n  \"text\": \"Today is Monday\",\r\n  \"complete\": false\r\n}\r\n```\r\n\r\nWhat I get back is \r\n\r\n```\r\n{\r\n\t\"text\": \"Today is Monday\",\r\n\t\"complete\": false,\r\n\t\"id\": 5\r\n}\r\n```\r\n\r\nI check the database and it's the same. It's not being modified before insert."
      },
      {
        "user": "feather-jmalone",
        "created_at": "2018-10-16T14:44:06Z",
        "body": "i could be wrong about this, but my understanding is that because `BeforeInsert` is an instance-level method, you need an actual instance of `Todo` in order for it to be invoked (you can't reference `this.password` if there's no `this`). The object you're passing in the request is just an object that happens to have the same properties as `Todo`. "
      },
      {
        "user": "JamesCoonce",
        "created_at": "2018-10-16T15:53:42Z",
        "body": "That works. I need to create an actual instance first."
      },
      {
        "user": "gintsgints",
        "created_at": "2018-10-21T09:33:42Z",
        "body": "@JamesCoonce consider closing issue then."
      },
      {
        "user": "pilattebe",
        "created_at": "2019-06-19T18:24:37Z",
        "body": "I know why this works that way but it shouldn\u2019t IMO. "
      },
      {
        "user": "vinimdocarmo",
        "created_at": "2019-08-14T15:15:22Z",
        "body": "> That works. I need to create an actual instance first.\r\n\r\nHow can one call a validation method using repository.save passing just a plain object instead of an entity instance?"
      },
      {
        "user": "liqwid",
        "created_at": "2019-10-11T00:39:29Z",
        "body": "> > That works. I need to create an actual instance first.\r\n> \r\n> How can one call a validation method using repository.save passing just a plain object instead of an entity instance?\r\n\r\n`Entity.prototype[methodName].apply(object, args)`\r\ngiven entity often is a DTO, that's useful IMO\r\n\r\nof course this brings the problem that any other instance methods would be unavailable in the call\r\n\r\nanother obvious solution is to instantiate.\r\n\r\nAnyway it should be explicitly mentioned in docs that instantiation is _required_ to use hooks"
      },
      {
        "user": "niyodusengaclement",
        "created_at": "2021-03-12T08:11:10Z",
        "body": "You can use the create method to create an instance`const data = repository.create(yourDto)` and then save returned data `repository.save(data)`\r\n\r\nThis will solve the issue"
      }
    ]
  },
  {
    "number": 2577,
    "title": "Is there a reason why listeners and subscribers would not work at all?",
    "created_at": "2018-07-24T16:22:46Z",
    "closed_at": "2018-09-29T10:49:25Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/2577",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[x] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\nUsing getRepository(Entity).save(data) or entityManager.save(Entity, data) will not fire the @AfterUpdate or @AfterInsert methods on the entity.\r\n\r\n```\r\n@AfterInsert()\r\n@AfterUpdate()\r\nsomeMethod() { \r\n console.log(\"It worked!\")\r\n}\r\n```\r\n\r\n\r\n<!--\r\n    To answer those questions you need to put \"x\" inside the square brackets, for example:\r\n    [x] `mysql`\r\n    [ ] `postgres`\r\n\r\n    Also, please format your code properly (by taking code blocks into ```ts .... ```)\r\n!>\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/2577/comments",
    "author": "joebieb",
    "comments": [
      {
        "user": "joebieb",
        "created_at": "2018-07-24T16:28:27Z",
        "body": "Actual project code:\r\n```\r\n  /**\r\n   * Create a new ReportDetail\r\n   * @param req\r\n   * @param res\r\n   * @param next\r\n   */\r\n  public async save(req: Request, res: Response, next: NextFunction) {\r\n    let result = getRepository(ReportDetail)\r\n                .save(req.body)\r\n                .then(result => res.send(result))\r\n                .catch(error => console.log(error));\r\n  };\r\n```\r\nEntity:\r\n```\r\nImports ...\r\n@Entity()\r\nexport class ReportDetail {\r\ncolumns ...\r\n\r\n  @UpdateDateColumn({ type: 'timestamp without time zone', name: 'updated_at' })\r\n  updatedAt: Date;\r\n\r\n  @AfterUpdate()\r\n  @AfterInsert()\r\n  someMethod() {\r\n    console.log(\"This worked!\");\r\n  }\r\n}\r\n```\r\n"
      },
      {
        "user": "pleerock",
        "created_at": "2018-07-28T09:50:56Z",
        "body": "I guess its because your `req.body` is not instance of `ReportDetail`, and since its not instance of `ReportDetail` there is no method to call on `req.body`, e.g. you can't call `req.body.someMethod()`"
      },
      {
        "user": "joebieb",
        "created_at": "2018-07-28T20:18:11Z",
        "body": "Thank you for the help. This code works and fires the @AfterUpdate method. There's probably a better way to map the req.body to the new ReportDetail object, but this works.\r\n\r\n```\r\n  public async save(req: Request, res: Response, next: NextFunction) {\r\n    let _detail = new ReportDetail();\r\n    for(var key in req.body) _detail[key]=req.body[key];\r\n    let result = getRepository(ReportDetail)\r\n                .save(_detail)\r\n                .then(result => res.send(result))\r\n                .catch(error => console.log(error));\r\n  };\r\n```"
      }
    ]
  },
  {
    "number": 2425,
    "title": "Is there any way to just check if query return a result or nothing ?",
    "created_at": "2018-06-28T16:53:34Z",
    "closed_at": "2018-07-02T19:47:12Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/2425",
    "body": "**Issue type:**\r\n\r\n[X] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[X] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n\r\n**TypeORM version:**\r\n\r\n[ ] `latest`\r\n[ ] `@next`\r\n[0.2.7] `0.x.x` (or put your version here)\r\n\r\nHi,\r\nFirst of all I'd like to thank you for your job, this tool is really good and easy to use.\r\n\r\nI would like to know if there is any way to know if my query return a result or not\r\n\r\nBasically something like this.\r\n\r\ncheckIfExist(value: string): Promise<boolean> {\r\n        const myRepository = getConnection().getRepository(Entity).createQueryBuilder('entity')\r\n            .where('entity.value= :value', { value: value});\r\n\r\n        return accidentRepository.Any();\r\n    }\r\n\r\nHope you can help me.\r\n\r\nHave a nice day\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\n<!--\r\n    To answer those questions you need to put \"x\" inside the square brackets, for example:\r\n    [x] `mysql`\r\n    [ ] `postgres`\r\n\r\n    Also, please format your code properly (by taking code blocks into ```ts .... ```)\r\n!>\r\n\r\n\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/2425/comments",
    "author": "ecalafat",
    "comments": [
      {
        "user": "DirkDeVisser",
        "created_at": "2018-06-29T08:36:36Z",
        "body": "If you use `getMany` on the query builder you will get an empty array if there are no results. For example:\r\n\r\n``` ts\r\npublic async checkAtLeastOne(value: string): Promise<boolean> {\r\n    const result = await getConnection()\r\n        .getRepository(Entity)\r\n        .createQueryBuilder('entity')\r\n        .where('entity.value= :value', { value: value})\r\n        .getMany();\r\n    return result.length >= 1;\r\n}\r\n```\r\nIf you want one result and use `getOne` on the query builder then you can check if it is undefined. For example: \r\n\r\n``` ts\r\npublic async checkIfExists(value: string): Promise<boolean> {\r\n    const result = await getConnection()\r\n        .getRepository(Entity)\r\n        .createQueryBuilder('entity')\r\n        .where('entity.value= :value', { value: value})\r\n        .getOne();\r\n    return result !== undefined;\r\n}\r\n```"
      },
      {
        "user": "hielkehoeve",
        "created_at": "2018-06-29T11:13:58Z",
        "body": "```I would like to know if there is any way to know if my query return a result or not```\r\n\r\nYou could use a count query to check how many rows you would fetch. This is the fastest option out of all the API calls.\r\n\r\n```\r\npublic async checkIfExists(value: string): Promise<boolean> {\r\n    return await getConnection()\r\n        .getRepository(Entity)\r\n        .createQueryBuilder('entity')\r\n        .where('entity.value= :value', { value: value})\r\n        .getCount() > 0;\r\n}\r\n```"
      },
      {
        "user": "pleerock",
        "created_at": "2018-07-02T19:47:07Z",
        "body": "I guess this can be closed, thanks everyone for the help!"
      }
    ]
  },
  {
    "number": 2080,
    "title": "@CreateDateColumn does not auto populate upon insertion.",
    "created_at": "2018-05-04T00:29:39Z",
    "closed_at": "2018-05-10T19:36:40Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/2080",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[x] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[x] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n\r\n**TypeORM version:**\r\n\r\n[ ] `latest`\r\n[ ] `@next`\r\n[x] `0.2.2` \r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nSample entity definition.\r\n```\r\nexport class MyEntity {\r\n    @PrimaryGeneratedColumn()\r\n    public id: number;\r\n\r\n    @Column({type: \"int\"})\r\n    public password_reset_id: number;\r\n\r\n    @Column({type: \"varchar\"})\r\n    public password_hash: string;\r\n\r\n    @CreateDateColumn()\r\n    public created_at: Date;\r\n\r\n    @UpdateDateColumn()\r\n    public updated_at: Date;\r\n\r\n    @Column({type: \"timestamp\"})\r\n    public deleted_at: Date;\r\n}\r\n```\r\n\r\nIt would seem that after updating to version `0.2.2` my `created_at` columns are no longer being populated upon record insertion. Has the `@CreateDateColumn()` decorator changed in someway? Am I missing something completely obvious?\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/2080/comments",
    "author": "jonathan-palumbo",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2018-05-04T10:32:02Z",
        "body": "Can you please check on latest version?"
      },
      {
        "user": "lihue",
        "created_at": "2018-05-04T16:10:28Z",
        "body": "I have the same problem with version 0.2.5"
      },
      {
        "user": "pleerock",
        "created_at": "2018-05-04T19:44:34Z",
        "body": "sounds strange, there are tests which confirm this functionality...  can you please provide a reproduction repo?"
      },
      {
        "user": "jonathan-palumbo",
        "created_at": "2018-05-04T21:14:35Z",
        "body": "I have since rolled back to `0.1.9` which was the version I was on before upgrading to `0.2.2`. Prior to rolling back I had noticed that the `INSERT` queries where using the `DEFAULT` keyword for the `CreatedDateColumns` in `0.2.2` where as in `0.1.9` they contain a string literal of the current timestamp.\r\n\r\nQuery in `0.1.9`:\r\n\r\n```\r\nINSERT INTO `table_name`(`created_at`, `updated_at`) VALUES (?,?) -- PARAMETERS: [\"2018-05-04T21:07:38.711Z\",\"2018-05-04T21:07:38.711Z\"]\r\n```\r\n\r\nQuery in `0.2.2`:\r\n\r\n```\r\nINSERT INTO `table_name`(`created_at`, `updated_at`) VALUES (?,?) -- PARAMETERS: [DEFAULT,DEFAULT]\r\n```\r\n\r\nI am not entirely sure of the mechanism TypeORM is using to get the timestamp in place of `DEFAULT`. Does the database schema need to be altered in anyway to accommodate this? \r\n\r\nFurthermore, for what it is worth we are using mysql 5.6 if that could possible be the difference. If I can find the time I will try to provided an example that exhibits the observed behavior.\r\n\r\n"
      },
      {
        "user": "jonathan-palumbo",
        "created_at": "2018-05-04T21:52:27Z",
        "body": "I forked the repository in the hopes of running the tests locally and perhaps trying the tests against a `mysql 5.6` container. However I cannot seem to get the tests to pass in their current state even though they appear to be passing in the CI build?"
      },
      {
        "user": "pleerock",
        "created_at": "2018-05-05T07:56:01Z",
        "body": "okay, so in 0.1.x we used our own value as a date. Now in 0.2.x we are using column's DEFAULT which is equal to NOW(). You don't have created date because you schema is not in sync."
      },
      {
        "user": "jonathan-palumbo",
        "created_at": "2018-05-07T14:42:56Z",
        "body": "So I should just define defaults for `CURRENT_TIMESTAMP` for both my created and updated  columns in my schema?"
      },
      {
        "user": "pleerock",
        "created_at": "2018-05-09T08:52:53Z",
        "body": "yes"
      },
      {
        "user": "jonathan-palumbo",
        "created_at": "2018-05-10T19:36:40Z",
        "body": "\ud83d\udc4d Thanks pleerock "
      },
      {
        "user": "dcworldwide",
        "created_at": "2018-07-26T11:50:50Z",
        "body": "@pleerock  @jonathan-palumbo  Just upgraded to 0.2.x and hit the same issue.\r\n\r\nI can't rebuild the production schema. Instead I need to patch it via sql with zero outage. If I ran the following for all createdAt updatedAt columns (postgres) and then afterwards deploy the new code (with 0.2.x) can I expect any issues?\r\n\r\n`ALTER TABLE ONLY \"public\".\"app_config\" ALTER COLUMN \"createdAt\" SET DEFAULT CURRENT_DATE;`\r\n"
      },
      {
        "user": "mrsauravsahu",
        "created_at": "2020-06-18T14:42:12Z",
        "body": "you can try \r\n```\r\n@CreateDateColumn({ default: () => 'NOW()' })\r\ncreatedAt: Date\r\n```\r\nin your entity. This should generate the right migration."
      },
      {
        "user": "emmyduruc",
        "created_at": "2022-07-05T10:04:25Z",
        "body": "> you can try\r\n> \r\n> ```\r\n> @CreateDateColumn({ default: () => 'NOW()' })\r\n> createdAt: Date\r\n> ```\r\n> \r\n> in your entity. This should generate the right migration.\r\n\r\ni have tried this and it did not work either"
      },
      {
        "user": "mrsauravsahu",
        "created_at": "2022-07-07T12:02:24Z",
        "body": "> > you can try\r\n> > ```\r\n> > @CreateDateColumn({ default: () => 'NOW()' })\r\n> > createdAt: Date\r\n> > ```\r\n> > \r\n> > \r\n> >     \r\n> >       \r\n> >     \r\n> > \r\n> >       \r\n> >     \r\n> > \r\n> >     \r\n> >   \r\n> > in your entity. This should generate the right migration.\r\n> \r\n> i have tried this and it did not work either\r\n\r\nOdd, tried this again. I'm still able to generate the right migration.\r\n\r\n```typescript\r\nimport { Entity, PrimaryGeneratedColumn, Column, CreateDateColumn } from \"typeorm\"\r\n\r\n@Entity()\r\nexport class User {\r\n\r\n    @PrimaryGeneratedColumn()\r\n    id: number\r\n\r\n    @Column()\r\n    firstName: string\r\n\r\n    @Column()\r\n    lastName: string\r\n\r\n    @Column()\r\n    age: number\r\n\r\n    @CreateDateColumn({ default: () => 'NOW()' })\r\n    createdAt: Date\r\n}\r\n```\r\n\r\n```bash\r\nnpm run typeorm -- migration:generate src/migration/InitialCreate -d src/data-source.ts\r\n```\r\n\r\nwhich generated this migration\r\n\r\n```typescript\r\nimport { MigrationInterface, QueryRunner } from \"typeorm\";\r\n\r\nexport class InitialCreate1657194989813 implements MigrationInterface {\r\n    name = 'InitialCreate1657194989813'\r\n\r\n    public async up(queryRunner: QueryRunner): Promise<void> {\r\n        await queryRunner.query(`CREATE TABLE \"user\" (\"id\" SERIAL NOT NULL, \"firstName\" character varying NOT NULL, \"lastName\" character varying NOT NULL, \"age\" integer NOT NULL, \"createdAt\" TIMESTAMP NOT NULL DEFAULT NOW(), CONSTRAINT \"PK_cace4a159ff9f2512dd42373760\" PRIMARY KEY (\"id\"))`);\r\n    }\r\n\r\n    public async down(queryRunner: QueryRunner): Promise<void> {\r\n        await queryRunner.query(`DROP TABLE \"user\"`);\r\n    }\r\n\r\n}\r\n```\r\n\r\n```typescript\r\nimport \"reflect-metadata\"\r\nimport { AppDataSource } from \"./data-source\"\r\nimport { User } from \"./entity/User\"\r\n\r\nAppDataSource.initialize().then(async () => {\r\n\r\n    console.log(\"Inserting a new user into the database...\")\r\n    const user = new User()\r\n    user.firstName = \"Saurav\"\r\n    user.lastName = \"Sahu\"\r\n    user.age = 25\r\n    await AppDataSource.manager.save(user)\r\n    console.log(\"Saved a new user with id: \" + user.id)\r\n\r\n    console.log(\"Loading users from the database...\")\r\n    const users = await AppDataSource.manager.find(User)\r\n    console.log(\"Loaded users: \", users)\r\n}).catch(error => console.log(error))\r\n```\r\n\r\nwhich fills the `createdAt` property with the current timestamp\r\n```\r\n\u2514\u2500$ npm start\r\n\r\n> repro-postgres-auto-populate-dates@1.0.0 start\r\n> ts-node src/index.ts\r\n\r\nInserting a new user into the database...\r\nSaved a new user with id: 1\r\nLoading users from the database...\r\nLoaded users:  [\r\n  User {\r\n    id: 1,\r\n    firstName: 'Saurav',\r\n    lastName: 'Sahu',\r\n    age: 25,\r\n    createdAt: 2022-07-07T06:27:59.987Z\r\n  }\r\n]\r\n```"
      }
    ]
  },
  {
    "number": 2009,
    "title": "Set sqlite database path programmatically.",
    "created_at": "2018-04-24T04:25:32Z",
    "closed_at": "2018-04-24T15:17:21Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/2009",
    "body": "**Issue type:**\r\n\r\n[ x ] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[ x ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n\r\n**TypeORM version:**\r\n\r\n[ x ] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nI'm writing an app in electron, and I want to set the path to my sqlite databse like this:\r\n`${require('os').homedir()}/.HyperAI/database.sqlite`\r\n\r\nIs there a code example of how to do this programmatically?\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/2009/comments",
    "author": "cjackson234",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2018-04-24T05:24:34Z",
        "body": "use create connection and pass connection options:\r\n\r\n```ts\r\nimport {createConnection} from \"typeorm\";\r\n\r\ncreateConnection({\r\n     type: \"sqlite\",\r\n     database: `${require('os').homedir()}/.HyperAI/database.sqlite`\r\n});\r\n```"
      },
      {
        "user": "cjackson234",
        "created_at": "2018-04-24T15:17:18Z",
        "body": "Thanks, @pleerock ! "
      }
    ]
  },
  {
    "number": 2008,
    "title": "\u201cCONSTRAINT PK_payment_vendor PRIMARY KEY (vendor_id ASC)\u201c",
    "created_at": "2018-04-24T03:37:44Z",
    "closed_at": "2018-04-24T06:11:03Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/2008",
    "body": "**Issue type:**\r\n\r\n[ ] question\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `mysql` / `mariadb`\r\n\r\n**TypeORM version:**\r\n\r\n[ ] `0.1.20` \r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nIn MYSQL, create constraint is: CONSTRAINT PK_payment_vendor PRIMARY KEY (vendor_id ASC)\r\n\r\nhow to write in Typeorm? Thanks!\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/2008/comments",
    "author": "JingMo",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2018-04-24T05:23:37Z",
        "body": "you don't need to define a CONSTRAINT with typeorm. Instead you create an entity and add a property with `@PrimaryColumn` decorator applied."
      },
      {
        "user": "JingMo",
        "created_at": "2018-04-24T06:10:31Z",
        "body": "Thank you\uff01"
      }
    ]
  },
  {
    "number": 1945,
    "title": "invalid input syntax for uuid for PrimaryGeneratedColumn(\"uuid\") when initializing property",
    "created_at": "2018-04-15T01:01:39Z",
    "closed_at": "2018-04-19T12:55:18Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/1945",
    "body": "**Issue type:**\r\n\r\n[ ] question\r\n[X] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[X] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `websql`\r\n\r\n**TypeORM version:**\r\n\r\n[ ] `latest`\r\n[X] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\n```ts\r\n\r\nexport class EntityBase {\r\n  @PrimaryGeneratedColumn(\"uuid\") public id: string = \"\"; // NOTICE: I'm initializing this property to \"\"\r\n  @CreateDateColumn() public created: Date = new Date();\r\n  @UpdateDateColumn() public updated: Date = new Date();\r\n  @Column() public inactive: boolean = false;\r\n}\r\n\r\n@Entity(\"user_accounts\")\r\nexport class User extends EntityBase {\r\n  @Index(\"username_unique\", { unique: true })\r\n  @Column()\r\n  public username: string = \"\";\r\n\r\n  @Column() public passwordHash: string = \"\";\r\n  public password: string | undefined;\r\n}\r\n\r\n```\r\n\r\nTrying to insert entries of the above entity type but getting an error when calling `save` on the repository. My TypeScript project is set to `strict: true`, which requires property initialization.  I recently upgraded to `typeorm@next` (currently `0.2.0-alpha.46`) and began having this problem.  Before, I was running an earlier version of 0.2.0 and using `sqlite` instead of `postgres`. \r\n\r\nIn one of my other entities, I was initializing a relation property to empty array (`[]`) and received an error in the console, which was very clear that I shouldn't initialize that property.  \r\n\r\nI remove the initialization code and everything is now working.\r\n\r\nIs this something that TypeOrm could detect and throw a clearer error for?\r\n\r\n```\r\nQueryFailedError: invalid input syntax for uuid: \"\"\r\n    at new QueryFailedError (/src/error/QueryFailedError.ts:7:9)\r\n    at Query.callback (/src/driver/postgres/PostgresQueryRunner.ts:170:26)\r\n    at Query.handleError (/node_modules/pg/lib/query.js:143:17)\r\n    at Connection.connectedErrorHandler (/node_modules/pg/lib/client.js:132:26)\r\n    at emitOne (events.js:116:13)\r\n    at Connection.emit (events.js:211:7)\r\n    at Socket.<anonymous> (/pg/lib/connection.js:117:12)\r\n    at emitOne (events.js:116:13)\r\n    at Socket.emit (events.js:211:7)\r\n    at addChunk (_stream_readable.js:263:12)\r\n```",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/1945/comments",
    "author": "marpstar",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2018-04-16T08:18:38Z",
        "body": "`uuid` column value is generated by database in case if you did not specify your own value. In your case you specified your own value (empty string) and it thinks that you pass your own uuid and does not use default database's uuid generation. But since empty string is not equal to uuid you have an error. Solution is to generate a proper uuid or remove value assignment. \r\n\r\nAlso I recommend you to consider value of strict property initialization and put \"!\" to your properties instead of initialization if you think that value is higher then overhead.  "
      },
      {
        "user": "pleerock",
        "created_at": "2018-04-19T12:55:18Z",
        "body": "Let me know if I did not answer your question."
      },
      {
        "user": "marpstar",
        "created_at": "2018-04-19T15:22:20Z",
        "body": "thanks @pleerock. this is a satisfactory answer for me. I appreciate your help."
      }
    ]
  },
  {
    "number": 1944,
    "title": "Is it possible to use the joined entity instead?",
    "created_at": "2018-04-14T18:58:59Z",
    "closed_at": "2018-04-16T15:07:38Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/1944",
    "body": "**Issue type:**\r\n\r\n[ x] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[x ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `websql`\r\n\r\n**TypeORM version:**\r\n\r\n[ ] `latest`\r\n[ ] `@next`\r\n[2.0.0] `0.x.x` (or put your version here)\r\n\r\nI wasn't able to gather from the docs and this question go no traction on SO.\r\n\r\n**Question:**\r\n\r\nI've got an auth_token table and user table. I'd like to resolve a user from a given auth token using the query builder. The issue I'm having is that after joining, the return type still thinks it's going to be an AuthToken. Is there a way to tell the query builder to use the joined entity instead?\r\n\r\n```\r\nreturn await this.authTokenRepository\r\n  .createQueryBuilder()\r\n  .where({\r\n    token: token\r\n  })\r\n  .innerJoinAndSelect(User, 'user')\r\n  .getOne();\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/1944/comments",
    "author": "micah-williamson",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2018-04-16T08:21:19Z",
        "body": "If you want a user, you need to select use and join token, are you doing your query from the wrong side. If you need a user, you take a user repository, join token, say where token is equal to token and thats all.\r\n\r\n```ts\r\nreturn await this.userRepository\r\n  .createQueryBuilder(\"user\")\r\n  .innerJoinAndSelect(\"user.authToken\", \"authToken\", \"authToken.token = :token\", { token })\r\n  .getOne();\r\n```"
      },
      {
        "user": "micah-williamson",
        "created_at": "2018-04-16T15:07:38Z",
        "body": "Makes sense. I arrived at this eventually but wanted to leave the question open in case it were possible to resolve the user in the way I was trying. Thank you"
      }
    ]
  },
  {
    "number": 1827,
    "title": "Question on query building to select a single column of the original table",
    "created_at": "2018-03-26T20:48:43Z",
    "closed_at": "2018-03-28T15:34:01Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/1827",
    "body": "```\r\n@Entity()\r\nexport class Script {\r\n    @PrimaryGeneratedColumn()\r\n    id: number;\r\n\r\n    @Column()\r\n    name: string;\r\n\r\n    @OneToMany(type => Session, session => session.script)\r\n    sessions: Session[];\r\n\r\n    @ManyToMany(type => User)\r\n    @JoinTable()\r\n    users: User[];\r\n}\r\n```\r\n\r\n```\r\n@Entity()\r\nexport class User {\r\n    @PrimaryGeneratedColumn()\r\n    id: number;\r\n\r\n    @Column()\r\n    username: string;\r\n\r\n    @OneToMany(type => Session, session => session.user)\r\n    sessions: Session[];\r\n}\r\n```\r\n\r\nI am trying to select the Script.name of users who have Script.\r\n\r\n```\r\n    async findScripts(username: string): Promise<Script[]> {\r\n        return await this.scriptRepository\r\n            .createQueryBuilder('script')\r\n            .select('script.name')\r\n            .leftJoin('script.users', 'user')\r\n            .where('user.username = :name', { name: username })\r\n            .getMany();\r\n    }\r\n```\r\n\r\n```\r\n[\r\n  {\r\n    \"name\": \"Script A\",\r\n    \"users\": [\r\n      \r\n    ]\r\n  },\r\n  {\r\n    \"name\": \"Script B\",\r\n    \"users\": [\r\n      \r\n    ]\r\n  }\r\n]\r\n```\r\n\r\nIt works, only issue is my left join is also adding an unwanted empty users array, I'm sure it is something dumb I overlooked. Any tips?\r\n\r\nBeen playing around with NestJS / TypeORM today overall very pleased and happy with this library, hats off to the contributors this is absolutely fantastic.\r\n\r\nThanks.\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/1827/comments",
    "author": "Tyler-V",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2018-03-27T04:34:25Z",
        "body": "First, you must select primary columns, its a requirement. Second, you need to use `leftJoinAndSelect` if you want users to be returned in the array"
      },
      {
        "user": "Tyler-V",
        "created_at": "2018-03-27T14:11:21Z",
        "body": "Hey thanks for the reply @pleerock \r\n\r\nI should clarify, I am trying to only get the names of the scripts and not the users array however that is the relationship between the two tables.\r\n\r\nThis is what I am trying to achieve, how would I write this in typeorm using the query builder?\r\n\r\n```\r\nSELECT DISTINCT name FROM script\r\nLEFT JOIN script_users_user ON script_users_user.scriptId\r\nLEFT JOIN user ON script_users_user.userId\r\nWHERE username = 'User A'\r\n```\r\n\r\n```\r\n[\r\n  {\r\n    \"name\": \"Script A\",\r\n  },\r\n  {\r\n    \"name\": \"Script B\",\r\n  }\r\n]\r\n```\r\n"
      },
      {
        "user": "pleerock",
        "created_at": "2018-03-28T07:16:55Z",
        "body": "I don't understand why you need two joins when you don't use them. Is `username` part of `script` ?\r\n\r\nSomething like this shall work:\r\n\r\n```ts\r\nthis.scriptRepository\r\n            .createQueryBuilder('script')\r\n            .select('script.name', 'name')\r\n// add joins and wheres here\r\n            .groupBy(\"user.name\")\r\n            .getRawMany();\r\n ```"
      },
      {
        "user": "Tyler-V",
        "created_at": "2018-03-28T15:24:33Z",
        "body": "@pleerock the difference in all of this was using getMany() vs getRawMany()\r\n\r\nThis indeed returns what I am looking for, returning the entities returned from getRawMany() only returns the script names.\r\n\r\n```\r\n        return await this.scriptRepository\r\n            .createQueryBuilder('script')\r\n            .select('name')\r\n            .leftJoin('script.users', 'user')\r\n            .where('user.username = :name', { name: username })\r\n            .getRawMany();\r\n```\r\n```\r\n[\r\n  {\r\n    \"name\": \"Script A\"\r\n  },\r\n  {\r\n    \"name\": \"Script B\"\r\n  }\r\n]\r\n```"
      },
      {
        "user": "pleerock",
        "created_at": "2018-03-28T15:34:08Z",
        "body": "btw, can you try it on `@next`? On `@next` for sure it should not return empty users array if you are not using `leftJoinAndSelect`"
      },
      {
        "user": "pleerock",
        "created_at": "2018-03-28T15:42:15Z",
        "body": "`@next` is the latest version (0.2.0 final will be released soon) that contains lot of changes and fixed we have made in past 6 month. Try it via `npm i typeorm@next`"
      },
      {
        "user": "Tyler-V",
        "created_at": "2018-03-28T15:45:05Z",
        "body": "Using @next,\r\n\r\n```\r\n        return await this.scriptRepository\r\n            .createQueryBuilder('script')\r\n            .select('name')\r\n            .leftJoinAndSelect('script.users', 'user')\r\n            .where('user.username = :name', { name: username })\r\n            .getMany();\r\n```\r\nReturns just an empty array\r\n\r\n```\r\n[\r\n\r\n]\r\n```"
      },
      {
        "user": "pleerock",
        "created_at": "2018-03-28T15:50:36Z",
        "body": "Something is definitely wrong, can you please show your script and user entities?"
      },
      {
        "user": "Tyler-V",
        "created_at": "2018-03-28T15:52:49Z",
        "body": "```\r\n@Entity()\r\nexport class Script {\r\n    @PrimaryGeneratedColumn()\r\n    id: number;\r\n\r\n    @Column({ unique: true })\r\n    name: string;\r\n\r\n    @OneToMany(type => Session, session => session.script)\r\n    sessions: Session[];\r\n\r\n    @ManyToMany(type => User)\r\n    @JoinTable()\r\n    users: User[];\r\n}\r\n```\r\n\r\n```\r\n@Entity()\r\nexport class User {\r\n    @PrimaryGeneratedColumn()\r\n    id: number;\r\n\r\n    @Column({ unique: true })\r\n    email: string;\r\n\r\n    @Column({ unique: true })\r\n    username: string;\r\n\r\n    @Column()\r\n    password: string;\r\n\r\n    @OneToMany(type => Session, session => session.user)\r\n    sessions: Session[];\r\n}\r\n```"
      },
      {
        "user": "pleerock",
        "created_at": "2018-03-28T15:55:48Z",
        "body": "ah, wait. QueryBuilder code is not correct. Correct is:\r\n\r\n```ts\r\n        return await this.scriptRepository\r\n            .createQueryBuilder('script')\r\n            .select('script.name')\r\n            .leftJoinAndSelect('script.users', 'user')\r\n            .where('user.username = :name', { name: username })\r\n            .getMany();\r\n```\r\n\r\nAlso, try \r\n\r\n```ts\r\n        return await this.scriptRepository\r\n            .createQueryBuilder('script')\r\n            .select('script.name')\r\n            .leftJoin('script.users', 'user')\r\n            .where('user.username = :name', { name: username })\r\n            .getMany();\r\n```"
      },
      {
        "user": "Tyler-V",
        "created_at": "2018-03-28T16:02:51Z",
        "body": "1. Returns the script name and full user entity, instead of just the script.name as desired.\r\n\r\n```\r\n[\r\n  {\r\n    \"name\": \"Script A\",\r\n    \"users\": [\r\n      {\r\n        \"id\": 1,\r\n        \"email\": \"email1\",\r\n        \"username\": \"user1\",\r\n        \"password\": \"password1\"\r\n      }\r\n    ]\r\n  },\r\n  {\r\n    \"name\": \"Script B\",\r\n    \"users\": [\r\n      {\r\n        \"id\": 1,\r\n        \"email\": \"email1\",\r\n        \"username\": \"user1\",\r\n        \"password\": \"password1\"\r\n      }\r\n    ]\r\n  }\r\n]\r\n```\r\n\r\n2. Returns the desired result, just the script names.\r\n\r\n```\r\n[\r\n  {\r\n    \"name\": \"Script A\"\r\n  },\r\n  {\r\n    \"name\": \"Script B\"\r\n  }\r\n]\r\n```"
      },
      {
        "user": "pleerock",
        "created_at": "2018-03-28T16:08:33Z",
        "body": "okay so everything as expected"
      },
      {
        "user": "Tyler-V",
        "created_at": "2018-03-28T16:16:43Z",
        "body": "Yes looks good! Let me know if I can help with anything else @pleerock "
      },
      {
        "user": "webmobiles",
        "created_at": "2018-12-04T05:33:34Z",
        "body": "@Tyler-V what about select only the field users.email ? where use '.select()' ?\r\nis not working with me, only select direct fields from the join table. thanks"
      },
      {
        "user": "jaimedeverall",
        "created_at": "2020-03-20T11:20:15Z",
        "body": "Hi there, is there any follow up on @webmobiles question. I can select fields of `script` just fine but can't select the fields of the relation table, `user`"
      },
      {
        "user": "elle86a",
        "created_at": "2020-07-29T08:53:23Z",
        "body": "I Have the same issues, can't select the leftjoin column in version 0.2.25"
      },
      {
        "user": "webmobiles",
        "created_at": "2020-07-29T09:34:14Z",
        "body": "try to do:\r\n\r\n      .select([\r\n        'secondtable.name as name2',\r\n        'SUM(investments.amount) as startup_amount_invested_in',\r\n        'COUNT(lists) as startup_list_count'\r\n      ])"
      },
      {
        "user": "lakhandeshpande",
        "created_at": "2020-08-14T03:07:09Z",
        "body": "   return await this.scriptRepository\r\n            .createQueryBuilder('script')\r\n            .select('script.name')\r\n            .leftJoin('script.users', 'user')\r\n            .where('user.username = :name', { name: username })\r\n            .getMany();\r\n\r\nI would like to know how this get executed or called? In which file I should write this code to execute?"
      }
    ]
  },
  {
    "number": 1688,
    "title": "@next QueryBuilder IN clause error",
    "created_at": "2018-03-02T01:39:03Z",
    "closed_at": "2018-03-02T06:54:02Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/1688",
    "body": "**Issue type:**\r\n\r\n[ ] question\r\n[ x] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[x ] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `websql`\r\n\r\n**TypeORM version:**\r\n\r\n[ ] `latest`\r\n[ x] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce:**\r\nWhen use IN clause using QueryBuilder and pass array of numbers, an error happens:\r\n\r\n```\r\ntypeorm:query:error parameters: [ [ 1, 2, 3 ] ]\r\ntypeorm:query:error error:  { error: invalid input syntax for integer: \"{\"1\",\"2\",\"3\"}\"\r\n```\r\nQuey:\r\n`query.andWhere(\"entity.id IN (:idInParam)\", { idInParam: [1, 2, 3] })`\r\n\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/1688/comments",
    "author": "hugoserrana",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2018-03-02T03:15:15Z",
        "body": "Syntax for array parameter has been changed. New syntax for array parameters is:\r\n\r\n```ts\r\n\"entity.id IN (:...idInParam)\"\r\n```\r\n\r\nPurpose of this change is to support native arrays, before it was not possible to use them for example this way:\r\n\r\n```ts\r\n\"entity.id = ANY(:idInParam)\"\r\n```\r\n\r\nNow it is."
      },
      {
        "user": "hugoserrana",
        "created_at": "2018-03-02T03:44:29Z",
        "body": "This worked! \r\nI didn't knew that syntax had changed. \r\nThanks @pleerock!!"
      },
      {
        "user": "pleerock",
        "created_at": "2018-03-02T06:54:02Z",
        "body": "yw"
      }
    ]
  },
  {
    "number": 1673,
    "title": "How to wirte 'decimal(5,2)' in entity?",
    "created_at": "2018-02-28T07:42:24Z",
    "closed_at": "2018-02-28T16:51:37Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/1673",
    "body": "**Issue type:**\r\n\r\n[ ] question\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `mysql` / `mariadb`\r\n\r\n**TypeORM version:**\r\n\r\n[ ] `latest`\r\n\r\n**How to wirte 'decimal(5,2)' in entity?:**\r\n\r\nI want to set the field in the table. the field type is decimal, store like data: $123.23.\r\n\r\nIn entity, how to wirte?\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/1673/comments",
    "author": "kaimiyang",
    "comments": [
      {
        "user": "AlexMesser",
        "created_at": "2018-02-28T08:08:29Z",
        "body": "```typescript\r\n@Column(\"decimal\", { precision: 5, scale: 2 })\r\nvalue: number;\r\n```"
      },
      {
        "user": "kaimiyang",
        "created_at": "2018-02-28T08:17:50Z",
        "body": "@AlexMesser thank you!\r\nmany times I write like this : \r\n`@Column({\r\n    type: 'decimal',\r\n    precision: 5,\r\n    scale: 2,\r\n    default: 0,\r\n  })\r\n`\r\nand then `desc tablename`, result in:\r\n`\r\ndecimal(5,0)\r\n`\r\n\r\nnow is okey!"
      },
      {
        "user": "rinoymjoseph",
        "created_at": "2018-09-03T06:11:17Z",
        "body": "For me below one worked..\r\n` @Column({ name: \"R1ContentWidth\", type: \"decimal\", precision: 2, scale: 2, nullable: true })\r\n    r1ContentWidth: number`\r\nresulted in a column with Decimal(2,2) in DB"
      }
    ]
  },
  {
    "number": 1608,
    "title": "Create from nested object with lazy relation",
    "created_at": "2018-02-19T04:30:29Z",
    "closed_at": "2018-02-19T08:59:03Z",
    "labels": [
      "question",
      "comp: lazy loading"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/1608",
    "body": "**Issue type:**\r\n\r\n[] question\r\n[ ] bug report\r\n[x] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[x] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `websql`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nGiven\r\n```ts\r\nimport { BaseEntity, ManyToOne, OneToMany } from 'typeorm'\r\n\r\nclass Author extends BaseEntity {\r\n  @Column()\r\n  name: string\r\n\r\n  @OneToMany(() => Post)\r\n  posts: Promise<Post[]>\r\n}\r\n\r\nclass Post extends BaseEntity {\r\n  @ManyToOne(() => Author, 'posts', { cascadeInsert: true })\r\n  author: Promise<Author>\r\n}\r\n\r\nawait Post.create({author: Promise.resolve({name: 'author1'})}).save\r\n```\r\n\r\nGot\r\n```\r\nSTART TRANSACTION\r\nexecuting query:  INSERT INTO \"author\" DEFAULT VALUES  RETURNING \"id\"\r\nquery failed:  INSERT INTO \"author\" DEFAULT VALUES  RETURNING \"id\"\r\nerror:  { error: null value in column \"name\" violates not-null constraint\r\n...\r\n```\r\n\r\nBut eager relation works:  `Post.create({author: {name: 'author1'}})`\r\n\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/1608/comments",
    "author": "gutenye",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2018-02-19T07:05:11Z",
        "body": "You need to use following syntax:\r\n\r\n```ts\r\nawait Post.create({author: PromiseUtils.create({name: 'author1'})}).save\r\n```\r\n\r\nLazy relations aren't what people usually need to use. Just be aware."
      },
      {
        "user": "gutenye",
        "created_at": "2018-02-21T10:44:14Z",
        "body": "@pleerock\r\n It works, thanks.\r\n\r\nI use `typeorm` with `GraphQL`. If I understand it right, Lazy relations are the only way to use inside `GraphQL` resolvers. \r\n\r\nBut lazy relations are more complex than eager relations in many cases, is there a way to use eager relations with `GraphQL`?"
      },
      {
        "user": "pleerock",
        "created_at": "2018-02-21T11:26:10Z",
        "body": "I don't use lazy relations with graphql. Instead I created abstraction and use `connection.relationIdLoader` (can be found in latest `@next`) to find related entities for relation resolvers. I'll publish a framework with concrete implementation in the near future."
      },
      {
        "user": "gutenye",
        "created_at": "2018-02-21T12:40:58Z",
        "body": "That's great news! Looking forward to the framework.\n"
      }
    ]
  },
  {
    "number": 1592,
    "title": "get a relation key for side of OneToOne",
    "created_at": "2018-02-14T10:56:57Z",
    "closed_at": "2018-02-15T14:09:05Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/1592",
    "body": "**Issue type:**\r\n[X ] question\r\n**Database system/driver:**\r\n[X ] `mysql` / `mariadb`\r\n**TypeORM version:**\r\n[X ] `latest`\r\n\r\n**How now it is possible to find out from which column they are related?**\r\n\r\nI performed a search I need links\r\n``` \r\ngetRepository (this.constructor) .metadata.findRelationWithPropertyPath ('l10n');\r\n```\r\n\r\n**Expected Result: id_category**\r\n\r\n```\r\n@Entity(\"categories\", {})\r\nexport class CategoriesModel extends ORM {\r\n\r\n    @OneToOne(type => L10nCategoriesModel, l10n => l10n.categories, {\r\n        eager: true,\r\n        cascadeInsert: true,\r\n        cascadeUpdate: true,\r\n        cascadeRemove: true,\r\n        onDelete: 'CASCADE'\r\n    })\r\n    l10n: L10nCategoriesModel[];\r\n\r\n}\r\n\r\n@Entity(\"l10n-categories\", {})\r\nexport class L10nCategoriesModel extends ORM {\r\n\r\n    /* id_category */\r\n    @OneToOne(type => CategoriesModel, category => category.l10n, {\r\n        onDelete: 'CASCADE'\r\n    })\r\n    @JoinColumn({\r\n        name: 'id_category',\r\n    })\r\n    categories: CategoriesModel;\r\n}\r\n\r\n```",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/1592/comments",
    "author": "Flexiink",
    "comments": [
      {
        "user": "Flexiink",
        "created_at": "2018-02-14T11:49:32Z",
        "body": "Here's how to get the related key\r\n```\r\nconst relation = getRepository(this.constructor).metadata.findRelationWithPropertyPath('l10n');\r\nconst relationIdInDatabaseEntity = relation.inverseRelation!.joinColumns[ 0 ].databaseName;\r\n```\r\nAny comments?"
      },
      {
        "user": "pleerock",
        "created_at": "2018-02-15T05:12:16Z",
        "body": "You can do it only from the owner side of the relationship this way:\r\n\r\n```ts\r\n@Entity(\"l10n-categories\", {})\r\nexport class L10nCategoriesModel extends ORM {\r\n\r\n    @OneToOne(type => CategoriesModel, category => category.l10n)\r\n    @JoinColumn({ name: 'id_category' })\r\n    category: CategoriesModel;\r\n\r\n    @Column({ name: 'id_category' })\r\n    categoryId: number;\r\n}\r\n```"
      },
      {
        "user": "Flexiink",
        "created_at": "2018-02-15T09:20:39Z",
        "body": "What is the meaning of '!' in this line ?\r\n```\r\nrelation.inverseRelation!.joinColumns[ 0 ].databaseName; \r\n```\r\nI saw it in your code."
      },
      {
        "user": "pleerock",
        "created_at": "2018-02-15T09:33:42Z",
        "body": "its typescript syntax to enforce undefined properties in strict mode"
      },
      {
        "user": "Flexiink",
        "created_at": "2018-02-15T14:09:05Z",
        "body": "Thank you!"
      }
    ]
  },
  {
    "number": 1586,
    "title": "nullable column/relation option set to false only works on undefined",
    "created_at": "2018-02-13T19:54:02Z",
    "closed_at": "2018-02-16T14:16:49Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/1586",
    "body": "**Issue type:**\r\n\r\n[ ] question\r\n[x] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[x] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `websql`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nI have two fields within my entity that have _nullable_ set to _false_, which will set the field null during an update (both in the relation and column).\r\n\r\n```ts\r\n@Entity('Account')\r\nexport class AccountEntity {\r\n\r\n    @ManyToOne(type => RecordTypeEntity, {\r\n        nullable: false\r\n    })\r\n    @JoinColumn({ name: 'RecordTypeId' })\r\n    recordType: RecordTypeEntity;\r\n\r\n    @Column({\r\n        name: 'Phone',\r\n        type: 'varchar',\r\n        nullable: false\r\n    })\r\n    phone: string;\r\n}\r\n```\r\n\r\nHowever, when running (I'm showing the Jest test I have it in), setting the fields to null will set them null in the database during the update, and the test will fail. **This does happen in the running server, I'm just showing the test because it's more concise.**\r\n\r\n```ts\r\nreturn AccountEntity.save(account).then(() => {\r\n    return AccountEntity.findOneById(account.sfid, {\r\n        join: {\r\n            alias: 'account',\r\n            innerJoinAndSelect: {\r\n                'recordType': 'account.recordType'\r\n            }\r\n        }\r\n    }).then(result => {\r\n\r\n        result.phone = null;\r\n        result.recordType = null;\r\n\r\n        return AccountEntity.save(result).then(() => {\r\n            return AccountEntity.findOneById(account.sfid, {\r\n                join: {\r\n                    alias: 'account',\r\n                    innerJoinAndSelect: {\r\n                        'recordType': 'account.recordType'\r\n                    }\r\n                }\r\n            }).then(result => {\r\n\r\n                expect(result).toBeDefined();\r\n\r\n                expect(result.recordType).toEqual(account.recordType);\r\n                expect(result.phone).toEqual(account.phone);\r\n\r\n            });\r\n        });\r\n\r\n    });\r\n\r\n});\r\n```\r\n\r\nThis is spit out in the logs during the test - so you can see that it's updating the field.\r\n\r\n```console\r\nconsole.log node_modules/typeorm/platform/PlatformTools.js:207\r\nexecuting query:  START TRANSACTION\r\n\r\nconsole.log node_modules/typeorm/platform/PlatformTools.js:207\r\nexecuting query:  UPDATE `Account` SET `Phone`=?, `RecordTypeId`=?  WHERE `Id`=? -- PARAMETERS: [null,null,\"1e6ecbc2-6890-44bd\"]\r\n\r\nconsole.log node_modules/typeorm/platform/PlatformTools.js:207\r\nexecuting query:  COMMIT\r\n```\r\n\r\nThe only way I can get it to work is to set the fields to undefined instead of null\r\n\r\n```ts\r\nresult.phone = undefined;\r\nresult.recordType = undefined;\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/1586/comments",
    "author": "anigenero",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2018-02-15T06:16:15Z",
        "body": "`nullable: false` means it will set your column `NOT NULL` constraint in the database, it does not mean it will skip your columns from the updation if they are equal to null. So, behaviour you are getting is expected."
      },
      {
        "user": "anigenero",
        "created_at": "2018-02-15T15:36:41Z",
        "body": "Ok. Was expecting that the behavior on that would be similar to how JPA deals with non-nullable columns, and the way the documentation is worded, it seemed that it would. Is this something you would consider putting in as a feature for instances like this? Or is that not within the scope of the project?"
      },
      {
        "user": "pleerock",
        "created_at": "2018-02-16T05:13:06Z",
        "body": "We could add a check and throw an exception if some of the values are null. The only difference will be that instead of database throwing error orm will be doing that. Im not sure if its a good design because it is only one database constraint we'll check. But there are other constraints that database has besides NOT NULL checks and its not possible for orm to check them all (even half of them). So, Im not really sure about \"validate some constraints, left others for database to check\" design."
      },
      {
        "user": "anigenero",
        "created_at": "2018-02-16T14:16:49Z",
        "body": "Ok. Not optimal, but I understand your overall reasoning why not to include it. So, in my case I just need to do the check for the null values I'm validating. Thanks for your help."
      }
    ]
  },
  {
    "number": 1490,
    "title": "Undefined does not affect model objects",
    "created_at": "2018-01-23T04:33:54Z",
    "closed_at": "2018-01-23T06:17:51Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/1490",
    "body": "When trying to update a user, I mistakenly ran the following commands:\r\n```\r\n      user.resetPasswordToken = undefined;\r\n      user.resetPasswordExpires = undefined;\r\n      userRepo.save(user)\r\n```\r\n\r\nBut I noticed that it wasn't doing anything to the user object. However, when I changed this to:\r\n```\r\n      user.resetPasswordToken = null;\r\n      user.resetPasswordExpires = null;\r\n      userRepo.save(user)\r\n```\r\n\r\nIt had the expected behavior. This could be different from most people's expectations (even if this is expected behavior from the project), and should be clearly documented",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/1490/comments",
    "author": "crutchcorn",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2018-01-23T06:10:21Z",
        "body": "Its by design and allows partial updations. You can lets say do `userRepo.save({ id: 1, middleName: \"Lalala\" })` without being worried that other data will be removed. Also setting properties to `null` is actually making column values null in the database as well, so logically everything fit good.\r\n\r\nand btw you always can contribute in documentation, its quite easy to do and will help others to solve issues you faced."
      },
      {
        "user": "crutchcorn",
        "created_at": "2018-01-23T06:12:07Z",
        "body": "I understand and think it's a great design choice. \n\nI know I can contribute, and do plan to, but often find these bugs in the middle of a code session and just need to log them out. I'll try getting a PR in with doc additions here soon. "
      },
      {
        "user": "pleerock",
        "created_at": "2018-01-23T06:17:51Z",
        "body": "nice!"
      }
    ]
  },
  {
    "number": 1357,
    "title": "Bug: invalid reference to FROM-clause entry for table",
    "created_at": "2017-12-18T14:32:16Z",
    "closed_at": "2017-12-18T15:04:00Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/1357",
    "body": "I have this query for finding an user by email:\r\n\r\n```typescript\r\nthis.repo.findOne({ email: normalizeEmail(email) })\r\n```\r\n\r\nThis query fails with the following error:\r\n\r\n```\r\nquery failed:  SELECT \"Person\".\"createdAt\" AS \"Person_createdAt\", \"Person\".\"updatedAt\" AS \"Person_updatedAt\", \"Person\".\"id\" AS \"Person_id\", \"Person\".\"creationAction\" AS \"Person_creationAction\", \"Person\".\"emailVerified\" AS \"Person_emailVerified\", \"Person\".\"emailVerificationTokenId\" AS \"Person_emailVerificationTokenId\", \"Person\".\"passwordHash\" AS \"Person_passwordHash\", \"Person\".\"passwordResetTokenId\" AS \"Person_passwordResetTokenId\", \"Person\".\"isAdmin\" AS \"Person_isAdmin\", \"Person\".\"firstName\" AS \"Person_firstName\", \"Person\".\"lastName\" AS \"Person_lastName\", \"Person\".\"email\" AS \"Person_email\" \r\nFROM \"person\" \"Person\" WHERE Person.email=$1 -- PARAMETERS: [\"cuwe@natatih.pw\"]\r\nerror:  { error: invalid reference to FROM-clause entry for table \"person\"\r\n  name: 'error',\r\n  length: 189,\r\n  severity: 'ERROR',\r\n  code: '42P01',\r\n  detail: undefined,\r\n  hint: 'Perhaps you meant to reference the table alias \"Person\".',\r\n  position: '612',\r\n  internalPosition: undefined,\r\n  internalQuery: undefined,\r\n  where: undefined,\r\n  schema: undefined,\r\n  table: undefined,\r\n  column: undefined,\r\n  dataType: undefined,\r\n  constraint: undefined,\r\n  file: 'parse_relation.c',\r\n  line: '3233',\r\n  routine: 'errorMissingRTE' }\r\n\r\n```\r\n\r\nThe `WHERE` clause is the problem:\r\n\r\n```sql\r\nWHERE Person.email=$1\r\n```\r\nIt should be:\r\n\r\n```sql\r\nWHERE \"Person\".\"email\"=$1\r\n```\r\nWithout the quotes `Person` refers to the `person` table, which can only be referred to by its alias `\"Person\"`.\r\n\r\nThis query is my current workaround:\r\n\r\n```typescript\r\nreturn this.repo.createQueryBuilder('person')\r\n      .where('person.email = :email', { email: normalizeEmail(email) })\r\n      .getOne()\r\n```\r\n\r\n```\r\nexecuting query:  SELECT \"person\".\"createdAt\" AS \"person_createdAt\", \"person\".\"updatedAt\" AS \"person_updatedAt\", \"person\".\"id\" AS \"person_id\", \"person\".\"creationAction\" AS \"person_creationAction\", \"person\".\"emailVerified\" AS \"person_emailVerified\", \"person\".\"emailVerificationTokenId\" AS \"person_emailVerificationTokenId\", \"person\".\"passwordHash\" AS \"person_passwordHash\", \"person\".\"passwordResetTokenId\" AS \"person_passwordResetTokenId\", \"person\".\"isAdmin\" AS \"person_isAdmin\", \"person\".\"firstName\" AS \"person_firstName\", \"person\".\"lastName\" AS \"person_lastName\", \"person\".\"email\" AS \"person_email\" \r\nFROM \"person\" \"person\" WHERE person.email = $1 -- PARAMETERS: [\"usuzovaw@wiwgi.gov\"]\r\n```\r\n\r\nIt works because then the table alias is the same as the table name.\r\n\r\n- typeorm: ^0.1.9\r\n- postgresql: 10.1-1.pgdg90+1",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/1357/comments",
    "author": "blaugold",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-12-18T14:56:45Z",
        "body": "when creating query you must use entity property names, not database name. Can you show me your entity?"
      },
      {
        "user": "blaugold",
        "created_at": "2017-12-18T15:01:11Z",
        "body": "@pleerock I was wrong. I changed the issue. Please read it again.\r\n\r\nThe entity is quite large so this is just the property:\r\n\r\n```typescript\r\n  @IsEmail()\r\n  @IsOptional()\r\n  @Column({ name: 'email', type: String, nullable: true, unique: true })\r\n  private _email: string | null = null\r\n```"
      },
      {
        "user": "pleerock",
        "created_at": "2017-12-18T15:03:00Z",
        "body": "you need to use `_email` in your query instead of `email` as I said:\r\n\r\n> when creating query you must use entity property names, not database names\r\n\r\n```ts\r\nthis.repo.findOne({ _email: normalizeEmail(email) })\r\n```\r\n\r\n```ts\r\nreturn this.repo.createQueryBuilder('person')\r\n      .where('person._email = :email', { email: normalizeEmail(email) })\r\n      .getOne()\r\n```\r\n\r\n"
      },
      {
        "user": "blaugold",
        "created_at": "2017-12-18T15:03:58Z",
        "body": "@pleerock Sorry just got what you meant. Thanks. Love typeorm."
      },
      {
        "user": "obedm503",
        "created_at": "2018-02-17T04:49:19Z",
        "body": "just got the same error. It would be nice to get better error messages. maybe doing some checks like if the `where` key exists in the entity, but only do these checks if `process.env.NODE_ENV` === `development`?"
      }
    ]
  },
  {
    "number": 1345,
    "title": "Is it possible to define (A | B)[] relation?",
    "created_at": "2017-12-14T17:34:07Z",
    "closed_at": "2017-12-14T22:57:26Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/1345",
    "body": "First of all, thank you all for this great package \u2013 it's a breeze \ud83d\ude47\ud83c\udffb\u200d\u2642\ufe0f\r\n\r\nQuestion I have is this.\r\n\r\n```ts\r\n@Entity()\r\nclass A {\r\n  @Column()\r\n  a: string\r\n}\r\n\r\n@Entity()\r\nclass B {\r\n  @Column()\r\n  b: number\r\n}\r\n```\r\n\r\n**how to make such `C`?**\r\n\r\n```ts\r\n@Entity()\r\nclass C {\r\n  @Column(/* ??? */)\r\n  entries: (A | B)[]\r\n}\r\n```",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/1345/comments",
    "author": "dempfi",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-12-14T19:52:48Z",
        "body": "no, its not possible. If you want to bind C with A and B you need to create two relations in C with A and with B"
      },
      {
        "user": "dempfi",
        "created_at": "2017-12-14T22:54:33Z",
        "body": "I somehow missed simple fact \u2013 I can do whatever I want with the `C` class (like define entries aggregated getter). Thank you @pleerock."
      }
    ]
  },
  {
    "number": 1342,
    "title": "Left-joining single table multiple time with different conditions",
    "created_at": "2017-12-14T04:29:00Z",
    "closed_at": "2017-12-14T09:25:26Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/1342",
    "body": "When trying to join a single table multiple times with different conditions, parameter values don't seem to be updated:\r\n\r\n```js\r\n        this.createQueryBuilder('claim')\r\n            .select('claim.id')\r\n            .leftJoin(ClaimHistory, 'repairerDelivery',\r\n                '\"repairerDelivery\".\"claimId\" = claim.id AND \"repairerDelivery\".status = :status',\r\n                { status: 80 })\r\n            .leftJoin(ClaimHistory, 'buyerDelivery',\r\n                '\"buyerDelivery\".\"claimId\" = claim.id AND \"buyerDelivery\".status = :status',\r\n                { status: 100 })\r\n            .where('claim.\"repairerId\" = :id', { id: \"1\" })\r\n            .getRawMany();\r\n```\r\n\r\nGives this query\r\n\r\n```sql\r\nexecuting query:  SELECT \"claim\".\"id\" AS \"claim_id\" FROM \"claim\" \"claim\"\r\nLEFT JOIN \"claim_history\" \"repairerDelivery\" ON \"repairerDelivery\".\"claimId\" = \"claim\".\"id\" AND \"repairerDelivery\".status = $1 \r\nLEFT JOIN \"claim_history\" \"buyerDelivery\" ON \"buyerDelivery\".\"claimId\" = \"claim\".\"id\" AND \"buyerDelivery\".status = $2\r\nWHERE claim.\"repairerId\" = $3 -- PARAMETERS: [80,80,\"1\"] <---\r\n```\r\nIs this expected?",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/1342/comments",
    "author": "bytely",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-12-14T06:07:21Z",
        "body": "yes, parameter names must be unique across single query, you need to provide `status1` and `status2` variable names instead of single `status`"
      },
      {
        "user": "bytely",
        "created_at": "2017-12-14T09:25:26Z",
        "body": "I see, thank you."
      },
      {
        "user": "pookdeveloper",
        "created_at": "2019-06-21T11:07:30Z",
        "body": "Example:\r\n\r\n````javascript\r\n  var manager = getManager().getRepository(\"usuarios\").createQueryBuilder(\"usuarios\");\r\n        manager\r\n            .innerJoinAndSelect(\"usuarios.persona\", \"persona\")\r\n            .innerJoinAndSelect(\"usuarios.empleado\", \"empleado\")\r\n            .where(\"1 = 1\")\r\n            .andWhere(\"usuarios.id_categoria = :id_categoria\", { id_categoria: 1 })\r\n            .andWhere(\"persona.dni = :dni\", { dni: \"5399522a\" })\r\n            .andWhere(\"empleado.dni = :dni2\", { dni2: \"5399522d\" })\r\n\r\n        const datos = await manager.getMany();\r\n````"
      }
    ]
  },
  {
    "number": 1322,
    "title": "queryBuilder parameters: duplicated parameters name",
    "created_at": "2017-12-09T05:52:28Z",
    "closed_at": "2017-12-16T10:38:13Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/1322",
    "body": "        const tokens = s.split(' ');\r\n        for (const token of tokens) {\r\n          queryBuilder.andWhere(new Brackets(tokenQb => {\r\n            tokenQb.where('person.name ILIKE :token');\r\n            tokenQb.orWhere('person.lastName ILIKE :token');\r\n          })).setParameters({token: token});\r\n        }\r\n\r\nWhen s = \"foo bar\", I should get the query ... WHERE (person.firstName ILIKE 'foo' OR person.lastName ILIKE 'foo') AND (person.firstName ILIKE 'bar' OR person.lastName ILIKE 'bar').\r\n\r\nHowever, I got ... WHERE (person.firstName ILIKE 'bar' OR person.lastName ILIKE 'bar') AND (person.firstName ILIKE 'bar' OR person.lastName ILIKE 'bar') instead.\r\n\r\nHow can I achieve this?",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/1322/comments",
    "author": "dvh312",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-12-12T12:03:22Z",
        "body": "Parameters must be unique. The way you can change your code:\r\n\r\n```ts\r\ns.split(' ').forEach((token, index) => {\r\n      const parameterName = \"token\" + index;\r\n      queryBuilder.andWhere(new Brackets(tokenQb => {\r\n        tokenQb.where('person.name ILIKE :' + parameterName);\r\n        tokenQb.orWhere('person.lastName ILIKE :' + parameterName);\r\n      })).setParameter(parameterName, token);\r\n    });\r\n```"
      },
      {
        "user": "dvh312",
        "created_at": "2017-12-16T07:59:16Z",
        "body": "Thanks!"
      },
      {
        "user": "pimplibence",
        "created_at": "2018-11-10T14:00:31Z",
        "body": "> Parameters must be unique. The way you can change your code:\r\n> \r\n> ```ts\r\n> s.split(' ').forEach((token, index) => {\r\n>       const parameterName = \"token\" + index;\r\n>       queryBuilder.andWhere(new Brackets(tokenQb => {\r\n>         tokenQb.where('person.name ILIKE :' + parameterName);\r\n>         tokenQb.orWhere('person.lastName ILIKE :' + parameterName);\r\n>       })).setParameter(parameterName, token);\r\n>     });\r\n> ```\r\n\r\n@pleerock why should be the parameters unique? Programatically the parameter naming belongs to the it own 'where' function scope. If you would like to use a huge parameter bag you have to use query level naming despite of function scope level. "
      },
      {
        "user": "lovinu99",
        "created_at": "2021-09-13T15:14:17Z",
        "body": "for someone looking the way to combine conditions into your queryBuilder, u r right to come here \u270c\ufe0f this answer saved my life \ud83d\udcaf  "
      }
    ]
  },
  {
    "number": 1274,
    "title": "Conflicting columns?",
    "created_at": "2017-11-30T10:19:50Z",
    "closed_at": "2017-11-30T11:41:24Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/1274",
    "body": "I noticed this in the docs:\r\n\r\n```js\r\n// example how to load DM entities\r\nconst users = await userRepository.find({ skip: 2, take: 5 });\r\nconst newUsers = await userRepository.find({ isActive: true });\r\nconst timber = await userRepository.findOne({ firstName: \"Timber\", lastName: \"Saw\" });\r\n```\r\n\r\nWhat happens if there are columns named `skip` or `take`?",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/1274/comments",
    "author": "leebenson",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-11-30T10:49:59Z",
        "body": "ORM kinda reserves these property names and it will use `skip` and `take` for pagination instead of column criteria. To use column criteria you'll need to do:\r\n\r\n```ts\r\nconst users = await userRepository.find({ where: { skip: 2, take: 5 } });\r\n```\r\n\r\nYes, its a bit tricky, but its a small downside compared with benefits find options bring."
      },
      {
        "user": "leebenson",
        "created_at": "2017-11-30T10:54:54Z",
        "body": "Np. I've literally just started using TypeORM, so this wasn't a use-case I'd run up against- just something I spotted in the docs that wasn't explained."
      },
      {
        "user": "pleerock",
        "created_at": "2017-11-30T11:05:00Z",
        "body": "I did not add note in the docs because possibility of having such conflicts is very low, and I did not want to confuse users. But this totally should be documented somewhere, in kinda \"secondary place\" for user eyes."
      }
    ]
  },
  {
    "number": 1225,
    "title": "Property mapping in querybuilder",
    "created_at": "2017-11-23T18:17:23Z",
    "closed_at": "2017-11-24T12:01:15Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/1225",
    "body": "Does the querybuilder map the entity properties to their database column names when filtering?\r\n\r\n```javascript\r\n@Entity(\"users\")\r\nexport class User {\r\n    @PrimaryGeneratedColumn()\r\n    id:number;\r\n\r\n    @Column(\"varchar\",{\r\n        name: \"first_name\"\r\n    })\r\n    firstName: string;\r\n\r\n    @Column(\"varchar\",{\r\n        name: \"last_name\"\r\n    })\r\n    lastName: string;\r\n}\r\n```\r\n\r\nCan i use ***firstName***  here or do i have to do use the actual column name that is in the database?\r\n\r\n```javascript\r\nconst user = await getManager()\r\n    .createQueryBuilder(User, \"user\")\r\n    .where(\"user.firstName = :bind\", { bind: \"John\" })\r\n    .getOne();\r\n```\r\n\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/1225/comments",
    "author": "ibox4real",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-11-24T04:25:21Z",
        "body": "Correct, it maps. You must use property names, not database names."
      },
      {
        "user": "ibox4real",
        "created_at": "2017-11-24T12:01:15Z",
        "body": ":thumbsup:"
      }
    ]
  },
  {
    "number": 1213,
    "title": "How to show rows changed from createQueryBuilder",
    "created_at": "2017-11-22T08:19:52Z",
    "closed_at": "2017-11-22T08:51:21Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/1213",
    "body": "Given a simple query like this:\r\n\r\n```typescript\r\ntypeorm.connection.manager\r\n       .createQueryBuilder()\r\n       .insert()\r\n       .into(User)\r\n       .values(req.body)\r\n       .execute()\r\n       .then((user: User) => console.info('user =', user, ';'))\r\n```\r\n\r\nIt succeeds, but the output is: `user = [] ;`. How do I show the created rows?\r\n\r\nOr do I need to add a select query in the `.then` callback?",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/1213/comments",
    "author": "SamuelMarks",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-11-22T08:50:50Z",
        "body": "correct, you need to select data, insert query just inserts your entity, nothing more."
      },
      {
        "user": "SamuelMarks",
        "created_at": "2017-11-22T08:51:21Z",
        "body": "Thanks"
      }
    ]
  },
  {
    "number": 1185,
    "title": "Can not use alias in find()",
    "created_at": "2017-11-15T13:11:32Z",
    "closed_at": "2017-11-16T11:23:43Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/1185",
    "body": "Hi,\r\n\r\ntypeorm:0.0.11\r\n\r\nwhen i use \r\n```\r\n...find({alias: 'test'});\r\n```\r\n\r\nthen typeorm throws unhandled rejections: \r\n```\r\nUnhandled rejection Error: ER_BAD_FIELD_ERROR: Unknown column 'test.alias' in 'where clause'\r\n```\r\n\r\nis it fixed in newest version? i.e. typeorm@0.1.2?",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/1185/comments",
    "author": "szymonskirgajllo",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-11-16T06:07:28Z",
        "body": "Yes new version find syntax is simplified and does not have an `alias` parameter. Find now accepts set of typeorm-specific options or conditions, e.g. entity column - value set. See updated find options docs on site."
      },
      {
        "user": "szymonskirgajllo",
        "created_at": "2017-11-16T11:23:42Z",
        "body": "@pleerock thanks, so we need to update typeorm ;)"
      }
    ]
  },
  {
    "number": 1127,
    "title": "postresql primary column with type \"bigint\" maps property as string",
    "created_at": "2017-11-01T12:13:13Z",
    "closed_at": "2017-11-01T13:02:56Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/1127",
    "body": "Hello, \r\nI noticed that primary column with type `bigint` maps property as `string` instead of `number`",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/1127/comments",
    "author": "darioxtx",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-11-01T12:44:38Z",
        "body": "Its a correct behaviour because regular `number` has `integer` length and cannot contain a bigint number values."
      },
      {
        "user": "darioxtx",
        "created_at": "2017-11-01T13:02:56Z",
        "body": "Thank you, I forgot about that."
      }
    ]
  },
  {
    "number": 1028,
    "title": "Property isModified function?",
    "created_at": "2017-10-14T16:58:00Z",
    "closed_at": "2017-10-16T09:55:31Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/1028",
    "body": "Mongoose has the `isModified` function to see if a property has been modified. This is really helpful in a pre-save hook (or for typeorm, when extending save()) to make sure a password always gets hashed. \r\n\r\nIs there something like that for typeorm? I couldn't find it in the docs.",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/1028/comments",
    "author": "Christilut",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-10-15T08:01:16Z",
        "body": "typeorm follows a bit different strategy and does not store object loaded from the database in the model. So if you want to check if its modified or not by explicitly load an object from the database "
      },
      {
        "user": "Christilut",
        "created_at": "2017-10-16T09:55:31Z",
        "body": "I guess the mongoose way is not the typescript way (I'm still adjusting).\r\n\r\nI made the password property private and changing the password must go through the setPassword function. \ud83d\udc4d "
      },
      {
        "user": "pleerock",
        "created_at": "2017-10-16T11:10:05Z",
        "body": "Don't forget you can use accessors, e.g. `get password`, `set password`"
      },
      {
        "user": "Christilut",
        "created_at": "2017-10-16T16:26:27Z",
        "body": "Thanks, great point."
      },
      {
        "user": "upendra-web",
        "created_at": "2020-01-26T12:50:46Z",
        "body": "Hello @Christilut, Can you post an example of your implementation?\r\nThank you!"
      },
      {
        "user": "Christilut",
        "created_at": "2020-01-26T13:02:45Z",
        "body": "Sorry, this was a long time ago. I'm on Typegoose now."
      }
    ]
  },
  {
    "number": 999,
    "title": "Update/remove all with auto-completion",
    "created_at": "2017-10-05T03:12:53Z",
    "closed_at": "2017-10-16T13:20:09Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/999",
    "body": "Is there a simple syntax to update or remove multiple entities via Active Record or Data-Mapper? I'm looking for something like (in sequelize):\r\n\r\n`await User.update({ name: 'a' }, { where: { name: 'b' } });`\r\n`// UPDATE users SET name = 'a' WHERE name = 'b';`\r\n\r\nand\r\n\r\n`await User.update({ name: 'a' });`\r\n`// UPDATE users SET name = 'a';`\r\n\r\nEntityManager throws `Cannot find entity to update by a given criteria` if there are no matches, and only updates one record:\r\n\r\n`await connection.manager.update(User, { name: 'a' }, { name: 'b' });`\r\n`await connection.manager.update(User, { where: { name: 'a'  } }, { name: 'b' });`\r\n\r\nQueryBuilder works, but is verbose and has no type checking on `.where()`:\r\n\r\n```\r\nawait User.createQueryBuilder('user')\r\n      .update({ name: 'b' })\r\n      .where('user.name = :name', { name: 'a' }) // hard to maintain, no type check\r\n      .execute();\r\n```\r\n\r\n\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/999/comments",
    "author": "soncodi",
    "comments": [
      {
        "user": "daniel-lang",
        "created_at": "2017-10-05T13:37:08Z",
        "body": "Repositories have an update function that has a very similar syntax. Only, that the parameters are switched (first the condition and than the part you want to change)\r\n\r\n```typescript\r\nawait repository.update({ firstName: \"Timber\" }, { firstName: \"Rizzrak\" });\r\n// executes UPDATE user SET firstName = Rizzrak WHERE firstName = Timber\r\n```"
      },
      {
        "user": "pleerock",
        "created_at": "2017-10-05T17:21:11Z",
        "body": "@daniel-lang is right, in your case its  a method from `BaseEntity`:\r\n\r\n```ts\r\nawait User.update({ firstName: \"Timber\" }, { firstName: \"Rizzrak\" });\r\n```\r\n"
      },
      {
        "user": "soncodi",
        "created_at": "2017-10-05T17:50:55Z",
        "body": "@daniel-lang, @pleerock: I tried the following (`0.1.0-alpha.50`) with both AR and DM:\r\n\r\nAR\r\n`await User.update({ name: 'a' }, { name: 'b' });`\r\n`await User.update({ where: { name: 'a' } }, { name: 'b' });`\r\n\r\nDM\r\n`await UserRepo.update({ name: 'a' }, { name: 'b' });`\r\n`await UserRepo.update({ where: { name: 'a' } }, { name: 'b' });`\r\n\r\n\r\nLogger results:\r\n\r\n    executing query:  SELECT `User`.`id` AS `User_id`, `User`.`name` AS `User_name` FROM `users` `User` WHERE `User`.`name`=? -- PARAMETERS: [\"a\"]\r\n    executing query:  SELECT `subject`.`id` AS `subject_id`, `subject`.`name` AS `subject_name` FROM `users` `subject` WHERE `subject`.`id`=? -- PARAMETERS: [2]\r\n    executing query:  START TRANSACTION\r\n    executing query:  UPDATE `users` SET `name`=?  WHERE `id`=? -- PARAMETERS: [\"b\",2]\r\n    executing query:  COMMIT\r\n\r\nObserved this behavior:\r\n- issues a `SELECT` first\r\n- only updates the first user.\r\n- errors if no rows matched `Error: Cannot find entity to update by a given criteria`\r\n\r\nExpected this behavior:\r\n- no `SELECT` issued, just a direct query\r\n- updates all users\r\n- no failure if no rows match `WHERE` clause\r\n\r\n\r\n"
      },
      {
        "user": "daniel-lang",
        "created_at": "2017-10-05T18:46:39Z",
        "body": "You are right. Looking at the source code it executes `findOne()` and than updates the found entity if it exists, otherwise throws an error.\r\nSo even though it's the same syntax, the `update` function does something every different. Sorry, for suggesting it, I should have checked the source code.\r\n\r\nSo I guess the only way to do what you want is with the QueryBuilder.\r\n@pleerock is that true?"
      },
      {
        "user": "soncodi",
        "created_at": "2017-10-05T18:57:41Z",
        "body": "It seems the goal is to act as an entity cache layer in front of the db. That's valid design but, for my use-case, it would be great to be able to opt-out of that behavior, and just use TypeORM as a simple mapper with type-checking. It could essentially be a drop-in replacement for Sequelize. I assumed this was implied by disabling `cache` on the connection, but I have not yet looked through the code.\r\n"
      },
      {
        "user": "pleerock",
        "created_at": "2017-10-06T03:58:40Z",
        "body": "`update` method currently using `find` and `save methods. Instead it should just use update query builder functionality. Ive got sick, thats why release is delayed this week, I'll fix update methods next week and publish a new version with those changes."
      },
      {
        "user": "soncodi",
        "created_at": "2017-10-06T04:07:30Z",
        "body": "@pleerock perfect, thanks!"
      },
      {
        "user": "pleerock",
        "created_at": "2017-10-16T13:20:09Z",
        "body": "I have updated `update` methods. Now they should work fine. This change will be released in `0.1.1`"
      }
    ]
  },
  {
    "number": 917,
    "title": "[Question] findByIds with another field",
    "created_at": "2017-09-20T06:21:28Z",
    "closed_at": "2017-09-20T17:04:29Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/917",
    "body": "Hello everyone :)\r\n\r\nAfter some researches I do not find an answer to my question. Thus, I post here.\r\n\r\nIs it possible to use  SQL `IN` in where clause of a query or an equivalent of `findByIds` with another field than id ?\r\n\r\nFor instance, I have Users that have an email. I want to load users where their emails match an email in a list.\r\nIn SQL that will look something like that : \r\n`SELECT * FROM users WHERE email IN ('aa@aa.aa', 'bb@bb.bb');`\r\n\r\nThanks.",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/917/comments",
    "author": "Porquepix",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-09-20T06:36:04Z",
        "body": "Hi, \r\n\r\nyes for your purpose you need to use `QueryBuilder`:\r\n\r\n```ts\r\nconst users = await manager.createQueryBuilder(User, \"user\")  // manager can be repository or connection objects too\r\n    .where(\"user.email IN (:emails)\", { emails: [...] })\r\n    .getMany();\r\n```"
      },
      {
        "user": "Porquepix",
        "created_at": "2017-09-20T17:04:29Z",
        "body": "Ok thanks a lot :+1: "
      }
    ]
  },
  {
    "number": 899,
    "title": "Repository: differents between .save() and .persist() and would a .insert() be possible?",
    "created_at": "2017-09-18T06:19:49Z",
    "closed_at": "2017-09-18T06:29:21Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/899",
    "body": "The title more or less says it all, what is the difference right know (or the difference planed) between `.save()` and `.persist()` of a repository? Since looking at the source code, would suggest, that they do the same.\r\nAnd is there a way to just insert the entities without the check beforehand? Because when I try to insert 700 entities at once a select statement is executed for each one of them, which isn't neccesary in every use case. Mine for example is, inserting entities that have been loaded from an api where I can be certain, that they do not exist in the table.",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/899/comments",
    "author": "daniel-lang",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-09-18T06:25:28Z",
        "body": "> .save() and .persist()\r\n\r\n`persist` is just old name of `save`. It just calls save method right now and there is zero difference, just naming. persist method is deprecated and will be removed in the future. Its there only because of old users who use persist when there was not save method.\r\n\r\n> And is there a way to just insert the entities without the check beforehand?\r\n\r\nYes, using insert functionality of `QueryBuilder`. Example:\r\n\r\n```ts\r\n        await connection.createQueryBuilder()\r\n            .insert()\r\n            .into(User)\r\n            .values([\r\n                { name: \"Umed Khudoiberdiev\" }, // or your entities\r\n                { name: \"Bakhrom Baubekov\" },\r\n                { name: \"Bakhodur Kandikov\" },\r\n            ])\r\n            .execute();\r\n```"
      },
      {
        "user": "daniel-lang",
        "created_at": "2017-09-18T06:29:20Z",
        "body": "Okay, thanks for clearing that up for me!"
      }
    ]
  },
  {
    "number": 877,
    "title": "How to set Current time stamp as default value",
    "created_at": "2017-09-13T12:12:40Z",
    "closed_at": "2017-09-13T14:04:14Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/877",
    "body": "How to set Current time stamp as default value",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/877/comments",
    "author": "imhari213",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-09-13T12:14:33Z",
        "body": "How do you do it in your database using sql? I guess its something like:\r\n\r\n```ts\r\n@Column({ type: \"timestamp\", default: () => \"CURRENT_TIMESTAMP\"))\r\ntime: string;\r\n```\r\n\r\n`() => ` syntax for `default` allows to use SQL expressions."
      },
      {
        "user": "imhari213",
        "created_at": "2017-09-13T13:08:41Z",
        "body": "THANK YOU :)"
      },
      {
        "user": "roeehershko",
        "created_at": "2018-05-29T21:38:52Z",
        "body": "For the copy paste lovers like me (typo):\r\n```\r\n    @Column({ type: 'timestamp', default: () => 'CURRENT_TIMESTAMP'})\r\n```"
      },
      {
        "user": "armanfatahi",
        "created_at": "2019-07-25T06:22:50Z",
        "body": "There is something else you need to consider:\r\n\r\nCURRENT_TIMESTAMP should be used with `timestamp with time zone`:\r\n\r\n```\r\n  @Column('timestamp with time zone', { nullable: false, default: () => 'CURRENT_TIMESTAMP' })  \r\n  created: Date;\r\n```\r\n\r\nUnless the Postgres converts the value to the timezone _AGAIN_ which will cause some trouble later on.\r\n"
      },
      {
        "user": "billyjov",
        "created_at": "2020-02-17T01:16:37Z",
        "body": "> How do you do it in your database using sql? I guess its something like:\r\n> \r\n> ```ts\r\n> @Column({ type: \"timestamp\", default: () => \"CURRENT_TIMESTAMP\"))\r\n> time: string;\r\n> ```\r\n> \r\n> `() => ` syntax for `default` allows to use SQL expressions.\r\n\r\n@pleerock i get an error trying to use an SQL statement with the syntax: \r\n\r\n```\r\ndefault: () => 'DATE_ADD(NOW(), INTERVAL 2 HOUR)',\r\n\r\n```\r\n\r\nnot working as expected and typeorm throw an error: \r\n\r\n```\r\n errno: 1064,\r\n  sqlMessage:\r\n   'You have an error in your SQL syntax; check the manual that corresponds to your MariaDB server version for the right syntax to use near \\'DATE_ADD(NOW(), INTERVAL 2 HOUR)\\' at line 1',\r\n  sqlState: '42000',\r\n  index: 0,\r\n  sql:\r\n   'ALTER TABLE `dueDate` CHANGE `dueDate` `dueDate` timestamp NOT NULL DEFAULT DATE_ADD(NOW(), INTERVAL 2 HOUR)' }\r\n```\r\nPS. i use mysql with the latest typorm version."
      },
      {
        "user": "jdnichollsc",
        "created_at": "2020-07-18T17:16:15Z",
        "body": "Other option could be this:\r\n```\r\n@CreateDateColumn({ type: 'timestamp without time zone', default: 'NOW()' })\r\ncreatedAt: Date\r\n\r\n@UpdateDateColumn({ type: 'timestamp without time zone', onUpdate: 'NOW()', nullable: true })\r\nupdatedAt: Date\r\n```\r\nWhat do you think?"
      },
      {
        "user": "baublet",
        "created_at": "2021-02-02T22:26:12Z",
        "body": "FYI, for those looking as of Tuesday, February 2, 2021, for some reason TypeORM converts `default: () => \"CURRENT_TIMESTAMP\"` to `now()` when using postgres 9.6. This meant that TypeORM generates new migrations changing their default type from `now()` to `CURRENT_TIMESTAMP` every time you try to generate new migrations.\r\n\r\nThe fix for us was to use this instead:\r\n\r\n```ts\r\n@Column({ type: \"timestamp\", default: () => \"now()\"))\r\ntime: string;\r\n```"
      },
      {
        "user": "xiongsongsong",
        "created_at": "2021-04-25T08:48:08Z",
        "body": "In MySQL 8:\r\n```\r\n@Column('date', { default: () => '(CURRENT_DATE)' })\r\nlast_date: Date;\r\n```"
      },
      {
        "user": "ghost",
        "created_at": "2021-06-01T12:18:31Z",
        "body": "Can we use a Javascript function in the default instead of a SQL expression? For scenarios like calculating the year based on some current date conditions. I am using MySQL"
      },
      {
        "user": "seltsamonkel",
        "created_at": "2021-07-30T02:09:37Z",
        "body": "For postgres I first created a migration with\r\n```\r\n@Column('date', { default: () => 'CURRENT_DATE::text::date' })\r\nlast_date: Date;\r\n```\r\nThis created the column in postgres as `default ((CURRENT_DATE))`, then I changed the code to\r\n```\r\n@Column('date', { default: () => '((CURRENT_DATE))' })\r\nlast_date: Date;\r\n```\r\nWith this change, the TypeORM generated default and the default on postgres are both `((CURRENT_DATE))`, so no migrations are created afterward."
      },
      {
        "user": "NateFerrero",
        "created_at": "2021-11-24T04:44:45Z",
        "body": "When creating a table using `queryRunner` on Postgres, I didn't need to use `() => ` to get an expression default:\r\n\r\n```TypeScript\r\nawait queryRunner.createTable(\r\n  new Table({\r\n  name: 'my-table',\r\n  columns: [\r\n    {\r\n      name: \"status\",\r\n      default: \"'created'\", // constant default\r\n      type: \"text\"\r\n    },\r\n    {\r\n      name: \"created_at\",\r\n      type: \"timestamp(0) without time zone\",\r\n      default: 'now()' // expression default\r\n    }\r\n  ]\r\n  }),\r\n  true, true, true\r\n)\r\n```"
      },
      {
        "user": "PRossetti",
        "created_at": "2022-07-21T21:56:09Z",
        "body": "You can do \r\n```\r\n@Column({ type: \"timestamp\", default: () => \"now()\" })\r\ntime: Date;\r\n```\r\n\r\nHave in mind this is not the same as doing:\r\n```\r\n@Column({ type: \"timestamp\", default: \"now()\" })\r\ntime: Date;\r\n```\r\n\r\nThis last option in my case at least throw error in CI because it wasn't doing what it looks, so try going with the first alternative I mentioned."
      },
      {
        "user": "abu18saud",
        "created_at": "2023-11-15T20:25:39Z",
        "body": "using () => 'CURRENT_TIMESTAMP' with add 2 years by nestjs?"
      }
    ]
  },
  {
    "number": 876,
    "title": "How to select appropriate column from join table?",
    "created_at": "2017-09-12T21:03:21Z",
    "closed_at": "2017-09-14T18:16:15Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/876",
    "body": "I would like to remove some column from my result, in order to get rid of the user details. I tried with  .select(['uad.*', 'ua.*', 'u.name']) but doesn't work. How should I do?\r\n\r\n\r\n```\r\n    const query = db.getRepository(UserActivityDo)\r\n        .createQueryBuilder('uad')\r\n        .innerJoinAndSelect('uad.idUserActivity', 'ua')\r\n        .innerJoinAndSelect('ua.idUser', 'u')\r\n        // .select(['uad.*', 'ua.*', 'u.name'])\r\n        .where(`ua.idUser IN (${userIds.join(',')})`)       \r\n        .orderBy('uad.created', 'DESC');\r\n\r\n```\r\n\r\nThis is the result I get from the previous query. How can I only keep the user.name of the user relation?\r\n\r\n```\r\n[\r\n            {\r\n                \"idUserActivityDo\": 10,\r\n                \"description\": \"\",\r\n                \"created\": \"2017-09-11T22:13:15.327Z\",\r\n                \"idUserActivity\": {\r\n                    \"idUserActivity\": 21,\r\n                    \"activityName\": \"lolololol\",\r\n                    \"i18n\": \"en_US\",\r\n                    \"created\": \"2017-09-11T22:11:27.855Z\",\r\n                    \"idUser\": {\r\n                        \"idUser\": 41,\r\n                        \"email\": \"ooooo@ooooo.com\",\r\n                        \"hashedPassword\": \"$2a$10$gf3m/6FP/a/8V.Q7K\",\r\n                        \"salt\": \"$2a$10$55SB/gk0.\",\r\n                        \"name\": \"jgfhfhfhfhfj\",\r\n                        \"created\": \"2017-09-10T16:10:36.861Z\",\r\n                        \"pushToken\": \"ExponentPushToken[ssffsdfds]\"\r\n                    }\r\n                }\r\n            },\r\n            {\r\n                \"idUserActivityDo\": 9,\r\n                \"description\": \"\",\r\n                \"created\": \"2017-09-11T22:13:04.320Z\",\r\n                \"idUserActivity\": {\r\n                    \"idUserActivity\": 21,\r\n                    \"activityName\": \"lolololol\",\r\n                    \"i18n\": \"en_US\",\r\n                    \"created\": \"2017-09-11T22:11:27.855Z\",\r\n                    \"idUser\": {\r\n                        \"idUser\": 40,\r\n                        \"email\": \"world@ooooo.com\",\r\n                        \"hashedPassword\": \"$2a$10$gf3m/6FP/a/8V.Q7K\",\r\n                        \"salt\": \"$2a$10$55SB/gk0.\",\r\n                        \"name\": \"jgfhfhfhfhfj\",\r\n                        \"created\": \"2017-09-10T16:10:36.861Z\",\r\n                        \"pushToken\": \"ExponentPushToken[ssffsdfds]\"\r\n                    }\r\n                }\r\n            },\r\n            {\r\n                \"idUserActivityDo\": 8,\r\n                \"description\": \"\",\r\n                \"created\": \"2017-09-11T22:08:12.452Z\",\r\n                \"idUserActivity\": {\r\n                    \"idUserActivity\": 12,\r\n                    \"activityName\": \"fffgghgf\",\r\n                    \"i18n\": \"en_US\",\r\n                    \"created\": \"2017-09-10T19:01:41.373Z\",\r\n                    \"idUser\": {\r\n                        \"idUser\": 42,\r\n                        \"email\": \"helo@ooooo.com\",\r\n                        \"hashedPassword\": \"$2a$10$gf3m/6FP/a/8V.Q7K\",\r\n                        \"salt\": \"$2a$10$55SB/gk0.\",\r\n                        \"name\": \"jgfhfhfhfhfj\",\r\n                        \"created\": \"2017-09-10T16:10:36.861Z\",\r\n                        \"pushToken\": \"ExponentPushToken[ssffsdfds]\"\r\n                    }\r\n                }\r\n            },...\r\n```",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/876/comments",
    "author": "appwudo",
    "comments": [
      {
        "user": "varHarrie",
        "created_at": "2017-09-13T01:54:13Z",
        "body": "```typescript\r\nconst query = db.getRepository(UserActivityDo)\r\n        .select(['uad', 'ua', 'u.name'])\r\n        .createQueryBuilder('uad')\r\n        .innerJoin('uad.idUserActivity', 'ua')\r\n        .innerJoin('ua.idUser', 'u')\r\n        .where(`ua.idUser IN (${userIds.join(',')})`)       \r\n        .orderBy('uad.created', 'DESC')\r\n```\r\nReplace `innerJoinAndSelect` with `innerJoin`\r\n"
      },
      {
        "user": "appwudo",
        "created_at": "2017-09-15T17:20:38Z",
        "body": "Ah yes, after upgrading to the last version of typeORM it is finally working ;-) thanks"
      },
      {
        "user": "kwehrle",
        "created_at": "2018-06-28T06:35:54Z",
        "body": "Hi, this is not working for me (using V 0.2.7). \r\n\r\n1. the select cannot be the first after getRepository() (VSCode is throwing an error)\r\n2. With the select I only get the values from the Inquriy-Table (inq) and not the values from the joined Table DocUnitType (dut).\r\n3. The generated SQL-Statement seems to be correct and executed in the database works fine: \r\n\r\n``` SQL\r\nSELECT \r\n\t\"inq\".\"id\" AS \"inq_id\", \"inq\".\"bsnr\" AS \"inq_bsnr\", \"inq\".\"dt\" AS \"inq_dt\", \"inq\".\"status\" AS \"inq_status\", \r\n\t\"dut\".\"name\" AS \"dut_name\", \"dut\".\"id\" AS \"dut_id\"\r\nFROM \"mdat\".\"inquiry\" \"inq\"\r\n\tINNER JOIN \"def\".\"doc_unit_type\" \"dut\" ON \"inq\".\"doc_unit_type_id\" = \"dut\".\"id\" \r\nWHERE \"inq\".\"participant_id\" = $1 \r\nORDER BY \"inq\".\"dt\" DESC \r\n-- PARAMETERS: [\"6d964e85-a6b2-4a1b-b3c2-8b49074f6082\"]\r\n```\r\n\r\nWhat is going wrong?\r\n\r\n``` javascript\r\nawait db.getRepository(Inquiry)\r\n\t.createQueryBuilder('inq')\r\n\t.innerJoin(DocUnitType, 'dut', 'inq.docUnitTypeID = dut.ID')\r\n\t.select(['inq.ID','inq.dt','inq.status','inq.bsnr','dut.name'])\r\n\t.where('inq.participantID = :partID', { partID })\r\n\t.orderBy('inq.dt', 'DESC')\r\n\t.getMany();\r\n```\r\n\r\n"
      },
      {
        "user": "timothyvanderaerden",
        "created_at": "2018-10-26T09:49:32Z",
        "body": "@kwehrle not sure if you are still looking for the answer. But you should use addSelect in this case.\r\n\r\n```javascript\r\nawait db.getRepository(Inquiry)\r\n\t.createQueryBuilder('inq')\r\n\t.innerJoin(DocUnitType, 'dut', 'inq.docUnitTypeID = dut.ID')\r\n        .select(['inq.ID','inq.dt','inq.status','inq.bsnr'])\r\n\t.addSelect('dut.name')\r\n\t.where('inq.participantID = :partID', { partID })\r\n\t.orderBy('inq.dt', 'DESC')\r\n\t.getMany();\r\n```"
      },
      {
        "user": "kongbt",
        "created_at": "2018-11-01T10:12:35Z",
        "body": "I always get the undefined value of the variable id_port when I call this function but other values still exist. Please help me\r\nthanks!\r\nasync getAvaiableMobile(_amount:number,_type:string):Promise<any>{         \r\n        return this.repository.createQueryBuilder(\"mobile_list\")            \r\n            .select(\"mobile_list\")\r\n            .addSelect(\"portussd.id_port\")\r\n            .innerJoinAndSelect(sms_portussd, \"portussd\", \"mobile_list.mobile = portussd.mobile\")\r\n            .where(\"need_amount - charg_amount >= :amount\", {amount:_amount})\r\n            .andWhere(\"portussd.status=:status1\",{status1:1})\r\n            .orderBy(\"need_amount - charg_amount\",\"DESC\")\r\n            .addOrderBy(\"portussd.last_update\", \"DESC\")   \r\n            .getOne();\r\n    }"
      },
      {
        "user": "OLDIN",
        "created_at": "2020-01-18T18:48:18Z",
        "body": "A have same problem.\r\nVersion: _0.2.22_\r\nDB: _postgresql_\r\n\r\nMy code:\r\n```\r\nconst result = await this._orderCfRepo.createQueryBuilder('ocf')\r\n      .select('ocf')\r\n      .addSelect('cf.id')\r\n      .addSelect('cf.type')\r\n      .innerJoin(CustomField, 'cf', 'cf.id = ocf.customFieldId')\r\n      .getOne();\r\n```\r\n\r\nGenerated SQL:\r\n```\r\nSELECT\r\n\"ocf\".\"deletedAt\" AS \"ocf_deletedAt\",\r\n\"ocf\".\"inputValue\" AS \"ocf_inputValue\",\r\n\"ocf\".\"customFieldId\" AS \"ocf_customFieldId\",\r\n\"ocf\".\"orderId\" AS \"ocf_orderId\",\r\n\"ocf\".\"customFieldItemId\" AS \"ocf_customFieldItemId\", \r\n\"cf\".\"id\" AS \"cf_id\", \r\n\"cf\".\"type\" AS \"cf_type\"\r\nFROM \"orderCFItem\" \"ocf\"\r\nINNER JOIN \"customField\" \"cf\" ON \"cf\".\"id\" = \"ocf\".\"customFieldId\"\r\n```\r\n\r\nExpected:\r\n```\r\nOrderCFItem {\r\n  deletedAt: null,\r\n  inputValue: '380454635552',\r\n  customFieldId: 1,\r\n  orderId: 80,\r\n  customFieldItemId: null\r\n  customField: CustomField {\r\n    id: 1\r\n    type: 'list'\r\n  }\r\n}\r\n```\r\n\r\n\r\nBut in console:\r\n```\r\nOrderCFItem {\r\n  deletedAt: null,\r\n  inputValue: '380454635552',\r\n  customFieldId: 1,\r\n  orderId: 80,\r\n  customFieldItemId: null\r\n}\r\n```"
      },
      {
        "user": "OLDIN",
        "created_at": "2020-01-18T18:54:10Z",
        "body": "only works if replaced:\r\n\r\n```.innerJoin(CustomField, 'cf', 'cf.id = ocf.customFieldId')```\r\n\r\nat\r\n\r\n```.innerJoin('ocf.customField', 'cf', 'cf.id = ocf.customFieldId')```"
      },
      {
        "user": "elle86a",
        "created_at": "2020-07-29T08:51:23Z",
        "body": "@OLDIN i think you not have added the relations in the entity.\r\nThe 'cf.id = ocf.customFieldId' is a join where not needed if have the relation upset\r\n\r\ni have same version of typeOrm"
      },
      {
        "user": "OLDIN",
        "created_at": "2020-07-29T09:34:19Z",
        "body": "@elle86a no, the first argument must be a string instead an entity (no need to focus on the third argument)."
      },
      {
        "user": "RocaManuel",
        "created_at": "2020-08-07T22:32:42Z",
        "body": "i think what elle86a says is that if you create the relation in the Entity you will have a field that is the relation for ex:\r\n\r\n@ManyToMany(..)\r\n@JoinColumn(...)\r\nfield_name: Entity;\r\n\r\nso the first argument is the \"field_name\" that represents that relation (and where you will display it) if i'm not wrong or if i didn't miss understood"
      },
      {
        "user": "vinitkantrod",
        "created_at": "2021-04-20T16:54:31Z",
        "body": "> @kwehrle not sure if you are still looking for the answer. But you should use addSelect in this case.\r\n> \r\n> ```js\r\n> await db.getRepository(Inquiry)\r\n> \t.createQueryBuilder('inq')\r\n> \t.innerJoin(DocUnitType, 'dut', 'inq.docUnitTypeID = dut.ID')\r\n>         .select(['inq.ID','inq.dt','inq.status','inq.bsnr'])\r\n> \t.addSelect('dut.name')\r\n> \t.where('inq.participantID = :partID', { partID })\r\n> \t.orderBy('inq.dt', 'DESC')\r\n> \t.getMany();\r\n> ```\r\n\r\nI am getting error in `Select disctinct` query which typeorm calls by default for innerjoin and count. \r\n\r\nThis is my query\r\n```\r\nconst query = getRepository(ProductListing)\r\n      .createQueryBuilder('productListing')\r\n      .innerJoin('productListing.sellerProduct', 'sellerProduct',\r\n        'sellerProduct.deletedToken = :token',\r\n        { token: application.NOT_APPLICABLE })\r\n        .select([\r\n          'productListing.label',\r\n          'productListing.pricing_type',\r\n          'productListing.selling_price',\r\n          'productListing.status',\r\n          'productListing.start_date',\r\n          'productListing.end_date',\r\n          'sellerProduct.spin']).skip(0).take(10).getManyAndCount();\r\n```"
      },
      {
        "user": "QauseenMaab",
        "created_at": "2022-03-22T14:23:01Z",
        "body": "In my case using `getRawMany()` worked instead of `getMany`.\r\n\r\nFor example:\r\n```\r\n const res = await createQueryBuilder('profiles', 'profile')\r\n    .select(['profile.*', 'user.name'])\r\n    .where('profile.user.id = :userId', { userId })\r\n    .innerJoin(User, 'user', 'user.id = :userId', { userId })\r\n    .getRawMany();\r\n```"
      },
      {
        "user": "vtereshyn",
        "created_at": "2023-05-19T15:44:06Z",
        "body": "@QauseenMaab but `getRawMany` is a bit different thing. I am also looking for the reason why `getRawMany` works, but `getMany` doesn't"
      }
    ]
  },
  {
    "number": 869,
    "title": "Question - Deep joining",
    "created_at": "2017-09-12T10:28:47Z",
    "closed_at": "2017-09-12T10:37:24Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/869",
    "body": "Is the following possible with 1 query?\r\n\r\nI have the following relationship:\r\n\r\n`User` 1-* `Account` 1-* `Expense` *-1 `Project`\r\n\r\nI'm trying to get all the projects a certain user has made expenses for through any of their accounts.\r\n\r\nI can get as far as getting the expenses for each account:\r\n\r\n```\r\n    const user = await this.repo\r\n      .createQueryBuilder('user')\r\n      .innerJoinAndSelect('user.accounts', 'accounts')\r\n      .leftJoinAndSelect('accounts.expenses', 'expenses')\r\n      // next line breaks\r\n      .leftJoinAndSelect('accounts.expenses.projects', 'projects')\r\n      .where('user.id=:user_id')\r\n      .setParameter('user_id', id)\r\n      .getOne()\r\n```\r\n\r\nI've tried multiple variations of the breaking line - but I'm not sure if it's even possible what I'm trying to do.",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/869/comments",
    "author": "shotor",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-09-12T10:32:07Z",
        "body": "Try this way:\r\n\r\n```ts\r\nconst user = await this.repo\r\n      .createQueryBuilder('user')\r\n      .innerJoinAndSelect('user.accounts', 'accounts')\r\n      .leftJoinAndSelect('accounts.expenses', 'expenses')\r\n      .leftJoinAndSelect('expenses.projects', 'projects')\r\n      .where('user.id=:user_id')\r\n      .setParameter('user_id', id)\r\n      .getOne()\r\n```"
      },
      {
        "user": "shotor",
        "created_at": "2017-09-12T10:37:24Z",
        "body": "That gives me the following error:\r\n```\r\nError: Relation with property path projects in entity was not found.\r\n```\r\nBut it got me thinking, `Expense` has a `ManyToOne` to `Project`. So it's correct that it doesn't have a `projects` property, it simply has `project` (confirmed by looking at my code). Changing `projects` from plural to singular fixed the problem.\r\n\r\nQuestion: Can you infinitely join relationships like this?"
      },
      {
        "user": "pleerock",
        "created_at": "2017-09-12T10:42:21Z",
        "body": "Yeah but you are limited by number of joins your database supports (for example mysql can support max 64 joins, etc.)"
      }
    ]
  },
  {
    "number": 859,
    "title": "Question - entity relations ",
    "created_at": "2017-09-11T15:08:36Z",
    "closed_at": "2017-09-12T08:25:42Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/859",
    "body": "What is the expected behavior regarding the update of relations ? Are the inverse relations updated automatically ? What about their RelationId columns (assuming they are explicitly declared on the classes)\r\n\r\nFor example, assuming I have a master - detail relation as below (please note the Author and AuthorId columns - AuthorId exists on the class declaration)\r\n\r\n```ts\r\n@Entity(\"Persons\")\r\nexport class Author {\r\n\r\n    @PrimaryGeneratedColumn()\r\n    Id: number;\r\n\r\n    @Column()\r\n    Name: string;\r\n\r\n    @OneToMany(type => Photo, photo => photo.Author) // Note: we will create author property in the Photo class below\r\n    Photos: Photo[];\r\n}\r\n\r\n@Entity(\"Photos\")\r\nexport class Photo {\r\n\r\n    @PrimaryGeneratedColumn()\r\n    Id: number;\r\n\r\n    @Column({\r\n        length: 800,\r\n        nullable: false\r\n    })\r\n    Name: string;\r\n\r\n    @Column(\"text\")\r\n    Description: string;\r\n\r\n    @Column()\r\n    Filename: string;\r\n\r\n    @ManyToOne(type => Author, author => author.Photos, {\r\n        onDelete: \"CASCADE\"\r\n    })\r\n    Author: Author;\r\n\r\n    @RelationId((photo: Photo) => photo.Author)\r\n    AuthorId: number;\r\n\r\n}\r\n```\r\nAssume that I load an author from DB and a photo using 2 distinct calls from their repositories.\r\nThe photo is not related to this author.\r\n\r\nIf I set the Author property on the photo instance would the AuthorId  contain the Id of the Author instance ? Will this happen automatically or I would have to set it manually ? Also is the Author.Photos updated so that it contains the linked photo ?\r\n\r\nAlso if I push a Photo instance to the author.Photos array, will the inverse relations be updated automatically (Author instance would contain the author and AuthorId will contain the Author.Id)\r\n\r\nThank you\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/859/comments",
    "author": "ghost",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-09-11T16:42:14Z",
        "body": "> Are the inverse relations updated automatically\r\n\r\nNo. This would create a circular dependency which I would like to avoid, because most of the time people return object tree directly to client and circular relationship will bring them problems\r\n\r\n> What about their RelationId columns (assuming they are explicitly declared on the classes)\r\n\r\nRelationId columns are updated when you change relation, there is a test for this case, I dont remember where someone in `github-issues` directory"
      },
      {
        "user": "iz-iznogood",
        "created_at": "2017-09-11T19:05:11Z",
        "body": "Hmm, ok I just wanted to be sure what the expected behavior is.\r\nHowever IMHO it would be best to update it both ways and create a proper toJSON or serialize or wrap method, since this can create inconsistencies on the model graph\r\n\r\nFor me I am good with how it works, I can handle it in my code, so you may close the issue\r\n\r\nThank you"
      },
      {
        "user": "pleerock",
        "created_at": "2017-09-12T03:51:31Z",
        "body": "> I can handle it in my code\r\n\r\nbe careful, what you want to do may not fit orm design and you'll just bring problems yourself\r\n\r\n> IMHO it would be best to update it both ways and create a proper toJSON or serialize or wrap method, \r\n\r\nDon't think its possible to effectively do it\r\n\r\n> since this can create inconsistencies on the model graph\r\n\r\nit can't be called graph actually... Keep in mind that orm does not use identity map to store all entities, and each loaded/joined entity is unique object even if it is same object, for example if you load post then join its categories and join same posts of categories, you'll have different instances of post, even if they are same in the database"
      },
      {
        "user": "iz-iznogood",
        "created_at": "2017-09-12T08:23:33Z",
        "body": "Thanks,\r\n\r\nwe use a number of extra layers on top of the orm (or not) depending on the task and in some cases it is useful to see the entities as a tree other (typeorm, sequelise) times as a graph (EF, Hibernate).\r\n\r\nSo we are good, you may close the issue"
      }
    ]
  },
  {
    "number": 825,
    "title": "Question - Joining tables.",
    "created_at": "2017-09-05T05:40:39Z",
    "closed_at": "2017-09-12T06:10:22Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/825",
    "body": "I'm trying to introduce some privilege control to my project. \r\n\r\nFirst, I have a File entity here. Each file has a owner group, and only members of its owner group can see the file.\r\n\r\n``` typescript\r\n@Entity()\r\nexport class File {\r\n\r\n    @PrimaryGeneratedColumn()\r\n    public id: number;\r\n\r\n    @Column('varchar')\r\n    public content: string;\r\n\r\n    @Column('int')\r\n    public groupId: number,\r\n\r\n}\r\n```\r\n\r\nAnd I have a group_map entity to store the relations between users and groups.\r\n\r\n``` typescript\r\n@Entity()\r\nexport class GroupMap {\r\n\r\n  @PrimaryColumn('int')\r\n  public groupId: number;\r\n\r\n  @PrimaryColumn('int')\r\n  public userId: number;\r\n\r\n}\r\n```\r\n\r\nWhen a particular user tries to list all the files that he could access, I would like to check whether this user belongs to the owner group of the file.  So to achieve this goal I would like to join the second table ON **File.groupId = groupMap.groupId AND groupMap.userId = :currentUserId (passed in as a parameter)**. \r\n\r\nI'm not sure whether this is possible using relations (or something else?) provided by TypeORM.\r\n\r\nAppreciate any help.",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/825/comments",
    "author": "codgician",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-09-05T20:22:48Z",
        "body": "so, why dont you use relations?:\r\n\r\n```ts\r\n@Entity()\r\nexport class File {\r\n\r\n    @PrimaryGeneratedColumn()\r\n    public id: number;\r\n\r\n    @Column('varchar')\r\n    public content: string;\r\n\r\n    @ManyToOne(type => Group) // you told one file has one group, right?\r\n    public group: Group;\r\n\r\n}\r\n```\r\n\r\n```ts\r\n@Entity()\r\nexport class Group {\r\n\r\n  @PrimaryColumn('int')\r\n  public id: number;\r\n\r\n  @ManyToMany(type => User) // you told each user can have their own groups, right?\r\n  @JoinTable() // or this can be on User side if you want a bi-directional relation \r\n  public users: User[];\r\n\r\n}\r\n```\r\n\r\nNow if you need to files with groups owned by a current user:\r\n\r\n```ts\r\nconst files = await fileRepository.createQueryBuilder(\"file\")\r\n    .innerJoin(\"file.group\", \"fileGroup\")\r\n    .innerJoin(\"fileGroup.users\", \"fileGroupUser\", \"fileGroupUser.id = :currentUserId\")\r\n    .setParameter(\"currentUserId\", currentUserId)\r\n    .getMany();\r\n```"
      },
      {
        "user": "codgician",
        "created_at": "2017-09-06T07:25:10Z",
        "body": "Thanks for your solution!\r\nAnd does that mean when I'm adding a user to a group I'll have to fetch the user instance and then group.users = [UserInstance]?"
      },
      {
        "user": "pleerock",
        "created_at": "2017-09-06T07:42:15Z",
        "body": "right"
      },
      {
        "user": "codgician",
        "created_at": "2017-09-06T13:47:43Z",
        "body": "Emm, one more question (sorry), is it possible if I want to add another column \"privilege\" into the mapping table? Like a member of a group can either be a common user or a group administrator? Thanks. \ud83c\udf39 "
      },
      {
        "user": "pleerock",
        "created_at": "2017-09-06T14:00:12Z",
        "body": "in many-to-many table? If yes, then no, its not possible. You can too create entity and add there 3 columns with proper relations."
      },
      {
        "user": "codgician",
        "created_at": "2017-09-06T14:14:33Z",
        "body": "You mean I can create a standalone entity \"GroupMap\" and put two ManyToOne relationships inside, like:\r\n``` typescript\r\n\r\n@Entity()\r\nexport class GroupMap {\r\n\r\n  @ManyToOne(type => Group)\r\n  @JoinColumn()\r\n  public group: Group;\r\n\r\n  @ManyToOne(type => User)\r\n  @JoinColumn()\r\n  public user: User;\r\n\r\n  @Column('int')\r\n  public privilege: number;\r\n\r\n}\r\n```\r\n\r\nIs that appropriate? Thanks for your patience.\r\n\r\nP.S. If the method above won't work, does that mean I can't use relations to achieve this? Then how can I join the mapping table in a query?"
      },
      {
        "user": "pleerock",
        "created_at": "2017-09-06T14:17:48Z",
        "body": "Yes,  right"
      },
      {
        "user": "codgician",
        "created_at": "2017-09-06T14:45:39Z",
        "body": "So is it possible to create index on user and group as well if they have ManyToOne and JoinColumn decorators (perhaps a stupid question)?  "
      },
      {
        "user": "pleerock",
        "created_at": "2017-09-06T15:03:03Z",
        "body": "You can use `@Index` decorator if you want to create index."
      },
      {
        "user": "codgician",
        "created_at": "2017-09-12T06:10:22Z",
        "body": "Solved. Thanks for your help."
      },
      {
        "user": "ruslanchek",
        "created_at": "2018-07-05T20:42:30Z",
        "body": "Ok then DTO has to include User Object. How to create records in this case?"
      }
    ]
  },
  {
    "number": 794,
    "title": "Question - What does @JoinTable in @ManyToMany does?",
    "created_at": "2017-08-24T16:20:32Z",
    "closed_at": "2017-09-06T15:36:06Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/794",
    "body": "Hi and sorry for the stupid question:\r\n\r\nWhat is the difference between the two connected entities with @ManyToMany ?\r\nWhat does the `owner side` means?",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/794/comments",
    "author": "Urigo",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-08-24T18:24:47Z",
        "body": "\r\nLet's start with `one-to-one` relation.\r\nLet's say we have two entities: `User` and `Photo`:\r\n\r\n```typescript\r\n@Entity()\r\nexport class User {\r\n    \r\n    @PrimaryGeneratedColumn()\r\n    id: number;\r\n    \r\n    @Column()\r\n    name: string;\r\n    \r\n    @OneToOne()\r\n    photo: Photo;\r\n    \r\n}\r\n```\r\n\r\n```typescript\r\n@Entity()\r\nexport class Photo {\r\n    \r\n    @PrimaryGeneratedColumn()\r\n    id: number;\r\n    \r\n    @Column()\r\n    url: string;\r\n    \r\n    @OneToOne()\r\n    user: User;\r\n    \r\n}\r\n```\r\n\r\nThis example does not have `@JoinColumn` decorator which is not correct.\r\nWhy? Because to make a real relation we need to create a column in the database.\r\nWe need to create a column `userId` in `photo` table or `photoId` in `user` table.\r\nBut which exactly column should be created - `userId` or `photoId`?\r\nORM cannot decide it for you. \r\nTo make a decision you must `@JoinColumn` decorator on one of the side.\r\nIf you put `@JoinColumn` in `Photo` entity then `userId` column will be created in `photo` table.\r\nIf you put `@JoinColumn` in `User` entity then `photoId` column will be created in `user` table.\r\nWhere you put `@JoinColumn` decorator that side will be called \"owner side of the relationship\".\r\nOther side of relation, without `@JoinColumn` decorator is called \"inverse (non-owner) side of relationship\".\r\n\r\nSame in `@ManyToMany` relation you use `@JoinTable` decorator to show owner side of relation.\r\n\r\nIn `@ManyToOne` or `@OneToMany` relations `@JoinColumn` decorator is not necessary because \r\nboth decorators are different and where you put `@ManyToOne` decorator that table will have relational column. \r\n\r\n`@JoinColumn` and `@JoinTable` decorators are also can be used to specify additional\r\njoin column / junction table settings, like join column name or junction table name. \r\n"
      },
      {
        "user": "Urigo",
        "created_at": "2017-08-25T00:52:06Z",
        "body": "@pleerock thank you for the detailed answer.\r\n\r\nSo in case of `@ManyToMany`, it will create a separate table that will have two columns - `photoId` and `UserId`.  \r\nso no need for a column on the `Photo` table nor the `User` table (and creating that with TypeORM I also see that behaviour).\r\nSo where does `@JoinTable` owner comes into play?\r\nI mean, does it change anything in the implementation?\r\nIf so, what if there is no owner, they are both just connected to each other and each side can create the other side with connection as well?\r\n\r\nThanks\r\n"
      },
      {
        "user": "pleerock",
        "created_at": "2017-08-25T15:58:33Z",
        "body": "I don't remember all places where it does matter, but it does. For example naming thing. It names table like this: `user_photos`. ORM makes decision to name it `user_photos` or `photo_users` based on which side is owning. Same with columns order inside this table.\r\n\r\nAlso having join table on one side prevents it to create two tables and makes it really bi-directional.\r\n\r\nIf you are confused where to put join table decorator, just try to think about data side. What is \"original\" side of relation. For example if user has photos and photos cannot exist without users then probably join table must be set on user side."
      },
      {
        "user": "Urigo",
        "created_at": "2017-09-03T21:21:13Z",
        "body": "@pleerock what if both sides are really \"equal\" also in the logical sense?"
      },
      {
        "user": "pleerock",
        "created_at": "2017-09-04T08:08:09Z",
        "body": "Its all about decision. If you think both sides are equal then put jointable/joincolumn decorator on any side you want."
      },
      {
        "user": "pleerock",
        "created_at": "2017-09-06T15:36:06Z",
        "body": "I think this can be closed"
      },
      {
        "user": "lefebvresam",
        "created_at": "2019-01-24T13:36:43Z",
        "body": "Putting joincolumn on a ManyToMany has no effect."
      },
      {
        "user": "pleerock",
        "created_at": "2019-01-25T07:50:55Z",
        "body": "@lefebvresam ManyToMany uses JoinTable instead of JoinColumn"
      },
      {
        "user": "chetanc97",
        "created_at": "2020-06-19T16:03:09Z",
        "body": "@pleerock   But can we use just JoinColumn to get granchildren data . \r\nFore example -  table A has foreign key from table B & table B has foreign key from table C  .\r\nHow do you get data from table C as well . Does Typeorm support this ? "
      }
    ]
  },
  {
    "number": 776,
    "title": "QueryRunnerProviderAlreadyReleasedError for Transaction",
    "created_at": "2017-08-18T21:32:29Z",
    "closed_at": "2017-09-06T15:26:21Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/776",
    "body": "Hi,\r\nI'm using typeorm 0.0.11 version. I got below error message when running a transaction. It seems when I was trying to persist to a second table, the database connection is closed:\r\n\r\nIn propse trade, fail in 2nd persit[2017-08-18 14:14:57.577] - INFO - In propse trade, fail in 2nd persit (my error log).\r\n\r\nQueryRunnerProviderAlreadyReleasedError: Database connection provided by a query runner was already released, cannot continue to use its querying methods anymore  (This is error message).\r\n\r\nThe database driver I'm using is mysql. Do we have to implement the connection pool for mysql for this to work?\r\n\r\nHere is partial code:\r\n\r\n     this.db.entityManager.transaction(async transactionalEntityManager => {\r\n                            transactionalEntityManager.persist(table1)\r\n                            .then((result) => {\r\n\r\n                                console.log('successful in 1st persist');\r\n                                let sAction: SAction = new SAction();\r\n                \r\n                                sActionId.Id = result.sId;\r\n                                sActionId.stateId = TS.TRIED;\r\n         \r\n                                transactionalEntityManager.persist(sAction)\r\n                                .then((result) => {\r\n                                    console.log('successful in 2nd persist');\r\n                                  })\r\n                              .catch((err) => {\r\n                                    console.log('fail in 2nd persit');\r\n                                    return reject(err);\r\n                                });\r\n                           })\r\n                           .catch((err) => {\r\n                                return reject(err);                              \r\n                            }); \r\n\r\n\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/776/comments",
    "author": "guanhongtan",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-08-19T05:24:14Z",
        "body": "You simply not awaiting promises inside your transaction. Try to change your code to:\r\n```ts\r\n this.db.entityManager.transaction(async transactionalEntityManager => {\r\n                        return transactionalEntityManager.persist(table1)\r\n                        .then((result) => {\r\n\r\n                            console.log('successful in 1st persist');\r\n                            let sAction: SAction = new SAction();\r\n            \r\n                            sActionId.Id = result.sId;\r\n                            sActionId.stateId = TS.TRIED;\r\n     \r\n                            return transactionalEntityManager.persist(sAction)\r\n                            .then((result) => {\r\n                                console.log('successful in 2nd persist');\r\n                              })\r\n                          .catch((err) => {\r\n                                console.log('fail in 2nd persit');\r\n                                return reject(err);\r\n                            });\r\n                       })\r\n                       .catch((err) => {\r\n                            return reject(err);                              \r\n                        }); \r\n```"
      },
      {
        "user": "pleerock",
        "created_at": "2017-09-06T15:26:21Z",
        "body": "I think this can be closed "
      },
      {
        "user": "erald14",
        "created_at": "2021-07-12T08:48:38Z",
        "body": "@pleerock  helpful thanks"
      }
    ]
  },
  {
    "number": 717,
    "title": "[Question] Subscriber Events using QueryBuilder Update",
    "created_at": "2017-07-28T14:10:38Z",
    "closed_at": "2018-03-12T08:16:00Z",
    "labels": [
      "question",
      "comp: subscribers and listeners"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/717",
    "body": "Hi,\r\n\r\nWondering if it is expected functionality for a subscriber, such as ``afterUpdate`` to be triggered on a Repository ``.save()`` method, but not to be triggered on a QueryBuilder ``.update()`` method?\r\n\r\nThanks!",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/717/comments",
    "author": "MitchellCorish",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-07-28T14:14:06Z",
        "body": "Yes. There are LOT OF THINGS HAPPENING in `save` method. \r\nQueryBuilder's `.update()` method is simple - it just updates entity within a single sql query. We can't afford same overhead as we do in `save` method."
      },
      {
        "user": "MitchellCorish",
        "created_at": "2017-07-28T14:29:57Z",
        "body": "Okay, thanks for the info.\r\n\r\n I am needing to use the ```afterUpdate``` subscriber, so I will need to use ```.save()```.\r\n\r\nIs there anything I can use in the ```SaveOptions``` to allow ```where``` clauses and such, as I am using this for an update API endpoint, and it seems ```save()``` by default if there is nothing matching what is in the table, it will create a new one, and I only want it to update one or many records depending on the parameters passed in, and not create any new ones.\r\n\r\nThanks again."
      },
      {
        "user": "pleerock",
        "created_at": "2017-07-28T16:07:26Z",
        "body": "no there is no way to update by some property using `save` method. `save` method simply updates a single model. I suggest you to call manually methods you call in your subscribers for such specific use cases."
      },
      {
        "user": "MitchellCorish",
        "created_at": "2017-07-28T16:13:41Z",
        "body": "Do you think the ```.update()``` method work from Repository any better than the .```save()``` method in my case?"
      },
      {
        "user": "pleerock",
        "created_at": "2017-07-28T19:27:36Z",
        "body": "I don't know your case. `update` within query builder should be used if you want to:\r\n\r\n* make update based on special where statement\r\n* make bulk update\r\n* make it the fastest way\r\n\r\nI assume you are using update within query builder because you want to achieve one or more of those three goals. Because otherwise you can use simply `save` method"
      },
      {
        "user": "MitchellCorish",
        "created_at": "2017-07-28T19:34:03Z",
        "body": "Okay, thanks for the help.\r\n\r\nWould there ever by any consideration into adding subscribers to querybuilder methods so that could also utilize those methods?"
      },
      {
        "user": "pleerock",
        "created_at": "2017-07-28T20:14:26Z",
        "body": "I'll think about it."
      },
      {
        "user": "pleerock",
        "created_at": "2018-03-12T08:16:00Z",
        "body": "Closing as this is already implemented in `@next`."
      }
    ]
  },
  {
    "number": 700,
    "title": "Creating a relation with a join table",
    "created_at": "2017-07-24T19:36:32Z",
    "closed_at": "2017-07-24T21:32:47Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/700",
    "body": "Hey, This is a great project. Really well done.\r\n\r\nI have a  a many to many relationship between two entities (ex: `Vendor` and `Material`) which creates a join table. I have a separate entity `Quote` that I would like to relate to the join table of the previous relationship. How would I go about achieving that?\r\n\r\nThanks",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/700/comments",
    "author": "BrainMaestro",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-07-24T20:35:44Z",
        "body": "instead of using `@ManyToMany` relation you create a new entity called like `VendorMaterialQuote` with proper many-to-one/one-to-many relations inside to `Vendor`, `Material` and `Quote`. Its not possible to add something to the table generated by `@ManyToMany` decorator - because it is used only to generate basic relationship. If you need something more you just create your own entity with proper relations."
      },
      {
        "user": "BrainMaestro",
        "created_at": "2017-07-24T21:32:47Z",
        "body": "Alright, I guess that works. Thanks!"
      }
    ]
  },
  {
    "number": 698,
    "title": "Raw query with json columns (Postgres)",
    "created_at": "2017-07-23T22:45:26Z",
    "closed_at": "2017-07-26T10:01:42Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/698",
    "body": "Folks, I am trying to build a query like this\r\n\r\n  ```\r\n  let query = `SELECT \"incident\".* FROM \"incident\" \"incident\"  \r\n     WHERE incidents::jsonb @> '[{\"name\":$1}]' ORDER BY \"incident\".\"id\" ASC`;\r\n\r\n    const results: any = await repository.query(query, ['Briga']);\r\n```\r\nI want to add the value of the json as a parameter, but I am getting an error\r\n\r\n`error during executing query:error: invalid input syntax for type json\r\n`\r\n\r\nThe final query I want is this one:\r\n```\r\nSELECT \"incident\".* \r\nFROM \"incident\" \"incident\" WHERE incidents::jsonb @> '[{\"name\":\"briga\"}]' \r\nORDER BY \"incident\".\"id\" ASC\r\n```\r\n\r\nI searched in the documentation how to parametrize queries with json fields but could not find anything. Could you help me?",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/698/comments",
    "author": "brunosiqueira",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-07-25T07:51:34Z",
        "body": "`repository.query` calls underlying `pg` package's query method and uses its parameters syntax. Refer to `pg` package how to resolve your problem. But in my opinion you should do: \r\n`incidents::jsonb @> $1` and set to parameter the whole json."
      },
      {
        "user": "brunosiqueira",
        "created_at": "2017-07-25T16:26:29Z",
        "body": "Perfect, @pleerock! It worked!"
      },
      {
        "user": "ghost",
        "created_at": "2020-11-17T20:49:36Z",
        "body": "@pleerock @brunosiqueira This saved me! It was hard to find an example similar to this one. Thank you."
      }
    ]
  },
  {
    "number": 676,
    "title": "Junction tables not generated for ManyToMany relation.",
    "created_at": "2017-07-16T22:21:01Z",
    "closed_at": "2017-07-18T20:39:59Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/676",
    "body": "Hi there,\r\n\r\nI have a rather simple many to many relationship in my project, some properties have been removed for brevity:\r\n\r\n```\r\n@Entity()\r\nexport class Item {\r\n\r\n    @PrimaryGeneratedColumn()\r\n    public id: number;\r\n    \r\n    @JoinColumn()\r\n    @ManyToMany(type => Location, location => location.items)\r\n    public locations: Location[];\r\n}\r\n```\r\nand\r\n```\r\n@Entity()\r\nexport class Location {\r\n\r\n    @PrimaryGeneratedColumn()\r\n    public id: number;\r\n\r\n    @Column({ length: 128 })\r\n    public name: string;\r\n    \r\n    @JoinColumn()\r\n    @ManyToMany(type => Item, item => item.locations, { \r\n        cascadeInsert: true,\r\n        cascadeUpdate: true\r\n    })\r\n    public items: Item[];\r\n}\r\n```\r\nUnfortunately no junction table is being generated, it seems the properties in question are simply being ignored as the SQL debug output shows.\r\n\r\n```\r\nexecuting query: START TRANSACTION\r\nexecuting query: CREATE TABLE `location` (`id` int(11) NOT NULL PRIMARY KEY AUTO_INCREMENT, `name` varchar(128) NOT NULL, `updated_at` datetime(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6), `created_at` datetime(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6)) ENGINE=InnoDB\r\nexecuting query: CREATE TABLE `item` (`id` int(11) NOT NULL PRIMARY KEY AUTO_INCREMENT, `name` varchar(128) NOT NULL, `description` varchar(512) NOT NULL, `price` int(11) NOT NULL, `updated_at` datetime(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6), `created_at` datetime(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6)) ENGINE=InnoDB\r\nexecuting query: CREATE TABLE `tag` (`id` int(11) NOT NULL PRIMARY KEY AUTO_INCREMENT, `name` varchar(255) NOT NULL, `updated_at` datetime(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6), `created_at` datetime(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6)) ENGINE=InnoDB\r\nexecuting query: COMMIT\r\n```\r\n\r\nPlatform: Windows 10\r\nDatabase: MariaDB\r\nVersion: typeorm@0.1.0-alpha.31\r\n\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/676/comments",
    "author": "crystalbyte",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-07-17T08:38:10Z",
        "body": "for many-to-many you should use `@JoinTable` instead of `@JoinColumn` - and only on one side (owner side), e.g.:\r\n\r\n```ts\r\n@Entity()\r\nexport class Location {\r\n\r\n    @PrimaryGeneratedColumn()\r\n    public id: number;\r\n\r\n    @Column({ length: 128 })\r\n    public name: string;\r\n    \r\n    @ManyToMany(type => Item, item => item.locations, { \r\n        cascadeInsert: true,\r\n        cascadeUpdate: true\r\n    })\r\n    @JoinTable()\r\n    public items: Item[];\r\n}\r\n```"
      },
      {
        "user": "crystalbyte",
        "created_at": "2017-07-18T20:39:59Z",
        "body": "Thanks for pointing me to the right direction, the junction table is now being generated."
      },
      {
        "user": "raghav196",
        "created_at": "2019-06-14T09:37:16Z",
        "body": "@pleerock \r\n\r\nI'm also facing this issue of junction table not getting generated for ManyToMay relation. And I'm using `@JoinTable()` decorator.\r\n```typescript\r\nimport { Entity, PrimaryGeneratedColumn, Column, CreateDateColumn, UpdateDateColumn, ManyToMany, JoinTable } from 'typeorm';\r\nimport { Role } from '../role/role.entity';\r\n\r\n@Entity('users')\r\nexport class User {\r\n  @PrimaryGeneratedColumn()\r\n  id: number;\r\n\r\n  @Column({ type: 'uuid' })\r\n  remoteId: string;\r\n\r\n  @Column({ type: 'varchar', length: 255, nullable: false })\r\n  name: string;\r\n\r\n  @Column({ type: 'varchar', length: 3, nullable: false })\r\n  countryCode: string;\r\n\r\n  @Column({ type: 'varchar', length: 15, nullable: false })\r\n  phone: string;\r\n\r\n  @Column({ type: 'varchar', length: 255, nullable: false })\r\n  email: string;\r\n\r\n  @CreateDateColumn({ type: 'timestamptz' })\r\n  createdAt: Date;\r\n\r\n  @UpdateDateColumn({ type: 'timestamptz' })\r\n  updatedAt: Date;\r\n\r\n  @ManyToMany(type => Role, role => role.users, {\r\n    eager: true,\r\n    nullable: false\r\n  })\r\n  @JoinTable()\r\n  roles: Role[]\r\n}\r\n```\r\n\r\nand \r\n\r\n```typescript\r\nimport { Entity, PrimaryGeneratedColumn, Column, CreateDateColumn, UpdateDateColumn, ManyToMany, JoinTable } from 'typeorm';\r\nimport { User } from '../user/user.entity';\r\n\r\n@Entity('roles')\r\nexport class Role {\r\n  @PrimaryGeneratedColumn({ type: 'integer' })\r\n  id: number;\r\n\r\n  @Column({ type: 'integer' })\r\n  remoteId: number;\r\n\r\n  @Column({ type: 'varchar' })\r\n  role: string;\r\n\r\n  @CreateDateColumn({ type: 'timestamptz' })\r\n  createdAt: Date;\r\n\r\n  @UpdateDateColumn({ type: 'timestamptz' })\r\n  updatedAt: Date;\r\n\r\n  @ManyToMany(type => User, user => user.roles)\r\n  users: User[]\r\n\r\n}\r\n```\r\nI'm using **postgres**.\r\n\r\nI'm unable to figure out what can be the issue."
      }
    ]
  },
  {
    "number": 662,
    "title": "Updating an entity without selecting beforehand.",
    "created_at": "2017-07-13T20:56:07Z",
    "closed_at": "2017-07-14T07:20:19Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/662",
    "body": "Hi there,\r\n\r\nis there a way to update an entity without fetching it beforehand?\r\n\r\nRegards",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/662/comments",
    "author": "crystalbyte",
    "comments": [
      {
        "user": "yonilerner",
        "created_at": "2017-07-14T00:51:43Z",
        "body": "Just instantiate an instance of the model class and make sure it has a primary key, and then persist it.\r\n\r\nExample:\r\n```javascript\r\n@Entity()\r\nclass Person {\r\n  @PrimaryGeneratedColumn()\r\n  id: number\r\n\r\n  @Column()\r\n  name: string\r\n}\r\n\r\nconst person = new Person()\r\nperson.id = 1\r\nperson.name = 'Yoni'\r\nawait entityManager.getRepository(Person).persist(person) // value is essentially upserted\r\n"
      },
      {
        "user": "crystalbyte",
        "created_at": "2017-07-14T07:20:19Z",
        "body": "Beautiful, thank you :)"
      },
      {
        "user": "pleerock",
        "created_at": "2017-07-14T08:21:22Z",
        "body": "note you shall use `save` instead of `persist` method because `persist` is deprecated in latest versions."
      },
      {
        "user": "crystalbyte",
        "created_at": "2017-07-16T20:25:51Z",
        "body": "Thanks for the update."
      },
      {
        "user": "aseerkt",
        "created_at": "2021-12-13T02:42:10Z",
        "body": "I want to increment the value of column `comment_count` without fetching it beforehand. Is it possible? @pleerock \r\n```ts\r\nawait Post.update({ id: postId }, { commentCount:  { /* How to deal with this section */ } } );\r\n```"
      }
    ]
  },
  {
    "number": 642,
    "title": "Data type \"boolean\" is not supported in \"mysql\" database.",
    "created_at": "2017-07-10T09:59:36Z",
    "closed_at": "2017-07-12T06:17:31Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/642",
    "body": "typeorm `0.1.0-alpha.28` is giving now error `Data type \"boolean\" is not supported in \"mysql\" database.` if using boolean datatype. Running with sqlite this works fine. \r\n\r\nThis used to work with 0.0.11. I suppose I could fallback to tinyint as solution for now.",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/642/comments",
    "author": "jounii",
    "comments": [
      {
        "user": "hugoserrana",
        "created_at": "2017-07-10T10:47:59Z",
        "body": "@jounii The MySql does not have internal BOOLEAN data type. Types like BOOLEAN and BOOL are TINYINT(1) internally. \r\n\r\nIn Changelog the TypeOrm team wrote this:\r\n> some column types were removed. Now orm uses directly column types of underlying database\r\n\r\nI think they made the right decision because the types are mapped explicitly. I imagine this will reduce errors in maintaining this awesome library."
      },
      {
        "user": "pleerock",
        "created_at": "2017-07-10T13:56:26Z",
        "body": "@jounii if you define column type explicitly then you must use `tinyint` because explicitly defined types are now only database-supported types as @hugoserrana said. \r\n\r\nBut if you variable is `boolean` you can simply omit type definition and it will be converted to tinyint automatically, e.g. for `@Column() enabled: boolean` you don't need to specify type - its automatically mapped to tinyint."
      },
      {
        "user": "jounii",
        "created_at": "2017-07-10T14:24:39Z",
        "body": "Mysql does have alias for BOOLEAN and BOOL to mapped to TINYINT. If you logic is right, shouldn't the sqlite implementation driver also rule tinyint and others out too? Sqlite uses internally only \"integer\" type and aliases rest.\r\n\r\nHave to try if the boolean entity member is properly mapped if I don't specify the types manually. "
      },
      {
        "user": "jounii",
        "created_at": "2017-07-12T05:57:35Z",
        "body": "Works ok without defining the type. Problem solved for now, thanks. \r\n\r\nRelated to this is if the tinyint (and others specific data size types) go out of fashion, the Column options would need some sort of data length/type hinting options so the driver could choose best suiting internal type.\r\n\r\nMaybe possibility to define data type converter class/function so you could customise these yourself. I suppose I could override the DriverFactory to provide own wrapper driver, but it'll be exercise for later. "
      },
      {
        "user": "feather-jmalone",
        "created_at": "2017-08-25T00:02:48Z",
        "body": "maybe i'm missing something, but in `0.1.0-alpha.34` and `0.1.0-alpha.35`, i'm unable to work around the issue as recommended. i tried the following in my entity definition:\r\n\r\n`@Column({\r\n        nullable: false,\r\n        default: false\r\n    })\r\n    someFlag: boolean;`\r\n\r\nand also \r\n\r\n`@Column()\r\n    someFlag: boolean;`\r\n\r\nboth result in the following exception: `TypeORM connection error:  { DataTypeNotSupportedError: Data type \"\" is not supported in \"mysql\" database.`\r\n\r\ndid something change?\r\n\r\ni can't get the column working unless i specify `'tinyint'` as the first parameter for `@Column`. consequently, values come back as `1` or `0` instead of `true` or `false`. "
      },
      {
        "user": "pleerock",
        "created_at": "2017-08-25T16:11:21Z",
        "body": "Looks like it cannot figure out parameter type. Parameter type is automatically determined only if you setup reflect-metadata properly and setup tsconfig properly. Read more about them on a homepage"
      },
      {
        "user": "feather-jmalone",
        "created_at": "2017-08-25T21:06:42Z",
        "body": "ah, you're right. i did not have `reflect-metadata`. however, when i added `import \"reflect-metadata\"` to my main `app.ts` file as the docs suggested, i still got the error. adding the same line to the entity `.ts` file is what ultimately fixed the issue.\r\n\r\nthanks for the help!"
      },
      {
        "user": "pleerock",
        "created_at": "2017-08-26T06:09:33Z",
        "body": "reflect-metadata should be loaded before any your entity is loaded. Probably you have loaded entities before your imported reflect-metadata in your app.ts "
      },
      {
        "user": "feather-jmalone",
        "created_at": "2017-08-26T07:06:26Z",
        "body": "i don't think so, but i am still new to TypeScript and TypeORM. here's an abbreviated version of my `app.ts` (took out Express-related code in the `createConnection` callback), does anything seem strange to you?\r\n\r\n```\r\nimport {createConnection} from 'typeorm';\r\nimport \"reflect-metadata\";\r\n\r\n// Establish the database connection before doing anything else\r\ncreateConnection({\r\n    type: 'mysql',\r\n    host: process.env.DB_HOST,\r\n    port: process.env.DB_PORT,\r\n    username: process.env.DB_USER,\r\n    password: process.env.DB_PASS,\r\n    database: process.env.DB_NAME,\r\n    entities: [\r\n        __dirname + '/entity/*.js'\r\n    ],\r\n    autoSchemaSync: true\r\n}).then(connection => {\r\n\r\n    // Initialize Express and other things\r\n\r\n// Log database connection errors\r\n}).catch(error => \r\n{\r\n    console.log('TypeORM connection error: ', error)\r\n});\r\n```\r\nthanks again for your help. although my particular issue is solved, i wanna help with future documentation if this is in fact a scenario that's unaccounted for."
      },
      {
        "user": "pleerock",
        "created_at": "2017-08-26T17:46:26Z",
        "body": "its not an unaccounted scenario, Im sure its something on your side. You can create a demo git repo with problem reproduction and I'll take why its happening on you"
      }
    ]
  },
  {
    "number": 635,
    "title": "Specifying relations to support legacy database",
    "created_at": "2017-07-09T17:40:09Z",
    "closed_at": "2017-07-10T17:23:03Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/635",
    "body": "Hi,\r\n\r\nI'm rewriting data-related part of an older application which was created for non-SPA environment with dynamic pages (MVC app with some AJAX parts) approach. I chose to rewrite API with TS & Node.js because of decorators and all the things that make code easily readable. However, I wanted to reconstruct database with entities in typeorm, so in case that application is bootstrapped from zero (without existing DB), the database doesn't need any script to be run in order to initialize it. Database which I'm using is MySQL. To achieve that I need to retain the whole structure of fields in tables, but there must be also defined some foreign keys and other things which are needed to preserve relations. I already rewrote current tables into entities, but the part with relations seems a bit impossible to do for me at the moment. I tried to use `@ManyToOne` decorator for defining foreign key in one table, but I always get another field in table which doesn't have correct name. Here is the example:\r\n\r\nWe have two entities - User and Post. User can create zero or more posts, but post is always created by a single user. So we should have the following two tables:\r\n\r\n- user - user_id (PK), name, username, password, email\r\n- post - post_id (PK), title, content, publish_date, user_id (FK)\r\n\r\nSo we would specify both models as:\r\n```\r\n@Entity()\r\nexport class User {\r\n\r\n  @PrimaryGeneratedColumn()\r\n  user_id: number;\r\n\r\n  @Column({ length: 255 })\r\n  name: string;\r\n\r\n  @Column({ length: 20, unique: true })\r\n  @Index()\r\n  username: string;\r\n\r\n  @Column({ length: 128 })\r\n  password: string;\r\n\r\n  @Column({ length: 255, unique: true })\r\n  email: string;\r\n\r\n}\r\n```\r\n\r\n```\r\n@Entity()\r\nexport class Post {\r\n\r\n  @PrimaryGeneratedColumn()\r\n  post_id: number;\r\n\r\n  @Column({ length: 255 })\r\n  @Index()\r\n  title: string;\r\n\r\n  @Column(\"text\")\r\n  content: string;\r\n\r\n  @Column(\"date\")\r\n  publish_date: Date;\r\n\r\n  @Column(\"int\")\r\n  user_id: number;\r\n\r\n}\r\n```\r\n\r\nAs stated above, I need to retain user_id in Post entity to support the existing state of database entries. I tried to add `@ManyToOne` decorator to Post's user_id as ...\r\n\r\n```\r\n@Column(\"int\")\r\n@ManyToOne(() => User)\r\nuser_id: number;\r\n```\r\n\r\nBut that didn't work well, because then I got the following structure of table:\r\n\r\n- post - post_id (PK), title, content, publish_date, user_id, **userUserId (FK)**\r\n\r\nSo the problem here is that the foreign key is always being inserted at the end of table and has specific naming strategy which isn't ok in my case. So my question here it is - do I have to handle my case manually and run database init script in case of a new environment, or I am missing something and there actually is a way to support such cases?\r\n\r\nAny answer/recommendation will be highly appreciated. Thanks in advance!",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/635/comments",
    "author": "truewt",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-07-10T07:16:44Z",
        "body": "relations should always be objects. To specify a custom referenced column name try this apporach:\r\n\r\n```ts\r\n@ManyToOne(() => User)\r\n@JoinColumn({ name: \"user_id\" })\r\nuser: User;\r\n```"
      },
      {
        "user": "truewt",
        "created_at": "2017-07-10T16:24:55Z",
        "body": "Thanks, it worked. I have additional questions about `@ManyToOne` and `@JoinColumn`. I changed parameters of decorators to:\r\n```\r\n@ManyToOne(() => User, { nullable: false, lazy: true })\r\n@JoinColumn({ name: \"user_id\" })\r\nuser: User;\r\n```\r\nI added `nullable: false` because each post must have user_id (cannot not be null) and `lazy: true`. If I understand correctly, this lazy is not executed until object (actually promise) returned in results is not awaited?\r\n\r\nDo I have to specify `referencedName` in `@JoinColumn` if it's same as `name`?\r\nI got additional question, looking at the User object in Post. What's the correct way to insert Post then - do I have to do another lookup for user before I'm assigning it to Post, or can I just create new User and assign it ID I already know (example below)?\r\n```\r\nlet user = new User();\r\nuser.user_id = 5; // actual value retrieved from token/session\r\n// or do I have to run find on User table to get the whole object back with all properties?\r\n// user = await userRepository.findOne(user);\r\n\r\nlet post = new Post();\r\npost.title = \"Testing Post\";\r\npost.content = \"Testing Content\";\r\npost.publish_date = new Date();\r\npost.user = user;\r\n\r\nawait postRepository.persist(post);\r\n```\r\nThank you in advance!"
      },
      {
        "user": "pleerock",
        "created_at": "2017-07-10T17:10:49Z",
        "body": "> If I understand correctly, this lazy is not executed until object (actually promise) returned in results is not awaited?\r\n\r\nright\r\n\r\n> Do I have to specify referencedName in @JoinColumn if it's same as name?\r\n\r\nyou specify `referencedName` only if you need it. If you don't it by default referenced to entity primary keys.\r\n\r\n> and assign it ID I already know\r\n\r\nyes you can update by simply assign an id"
      },
      {
        "user": "truewt",
        "created_at": "2017-07-10T17:23:03Z",
        "body": "Thanks! :)"
      }
    ]
  },
  {
    "number": 631,
    "title": "join not working in case of findOptions",
    "created_at": "2017-07-09T11:34:50Z",
    "closed_at": "2017-07-25T13:43:14Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/631",
    "body": "\"typeorm\": \"0.1.0-alpha.31\",\r\n\r\nI tried writing join query using entity manager and query builder. It works fine using query builder but  the related table data is not loaded when using findOptions.\r\n\r\nQuerBuilder: `claims` array added to the `roles`\r\n```javascript\r\nconst [roles, count] = await this.roleRepository.createQueryBuilder(\"role\")\r\n            .where(\"role.tenantId = tenantId\", { tenantId: ctx.state.user.tenantId })\r\n            .leftJoinAndSelect(\"role.claims\", \"claims\")\r\n            .offset(offset)\r\n            .limit(limit)\r\n            .getManyAndCount();\r\n```\r\nFindOptions: `claims` array **not** added to the `roles`\r\n```javascript\r\nconst [roles, count] = await this.roleRepository.findAndCount({\r\n            where: { tenantId: ctx.state.user.tenantId },\r\n            alias: \"role\",\r\n            leftJoinAndSelect: {\r\n                \"claims\": \"role.claims\"\r\n            },\r\n            limit: limit,\r\n            offset: offset\r\n        });\r\n```\r\n\r\nFollowing are the entities:\r\n\r\n```javascript\r\n@Entity()\r\nexport class Role extends BaseTenantEntity{\r\n\r\n    @Column({ nullable: false })\r\n    name: string;\r\n\r\n    @Column({ nullable: false })\r\n    description: string;\r\n\r\n    @ManyToMany(type => User, user => user.roles, {\r\n        cascadeInsert: true,\r\n        cascadeUpdate: true\r\n    })\r\n    users: User[]; \r\n    @OneToMany(type => RoleClaim, roleClaim => roleClaim.role, {\r\n        cascadeInsert: true,\r\n        cascadeUpdate: true\r\n    })\r\n    claims: RoleClaim[];\r\n}\r\n\r\n@Entity()\r\nexport class RoleClaim extends BaseEntity {\r\n\r\n    @Column({ nullable: false })\r\n    claimType: string;\r\n\r\n    @Column({ nullable: false })\r\n    claimValue: string;\r\n\r\n    @ManyToOne(type => Role, role => role.claims, {\r\n        cascadeInsert: true,\r\n        cascadeUpdate: true,\r\n        cascadeRemove: true\r\n    })\r\n    role: Role;\r\n}\r\n```",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/631/comments",
    "author": "adnan-kamili",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-07-10T07:21:39Z",
        "body": "In latest versions `FindOptions` syntax has changed. Use joins this way:\r\n\r\n```ts\r\nconst posts = await connection.manager.find(Post, {\r\n                join: {\r\n                    alias: \"post\",\r\n                    innerJoinAndSelect: {\r\n                        category: \"post.category\"\r\n                    }\r\n                },\r\n                order: {\r\n                    category: \"ASC\"\r\n                }\r\n            });\r\n```"
      },
      {
        "user": "adnan-kamili",
        "created_at": "2017-07-10T08:05:56Z",
        "body": "Thanks a lot, it worked now. It wasted my lot of time. \r\n\r\nPlease update the docs. And thanks for creating this amazing ORM. "
      },
      {
        "user": "pleerock",
        "created_at": "2017-07-10T14:01:00Z",
        "body": "> Please update the docs.\r\n\r\nplease feel free to contribute"
      }
    ]
  },
  {
    "number": 593,
    "title": "ManyToMany Mysql database only stores one row",
    "created_at": "2017-06-28T12:16:51Z",
    "closed_at": "2017-06-29T11:14:00Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/593",
    "body": "Hello. I have 2 files, Playlist.ts and Song.ts\r\n\r\n```import {Entity, PrimaryGeneratedColumn, Column, ManyToMany, JoinTable} from \"typeorm\";\r\nimport {Song} from \"./Song\";\r\n@Entity()\r\nexport class Playlist {\r\n\r\n    @PrimaryGeneratedColumn()\r\n    id: number;\r\n\r\n    @Column()\r\n    name: string;\r\n\r\n    @Column()\r\n    users: string;\r\n\r\n    @ManyToMany(type => Song, song => song.playlists, { \r\n        cascadeInsert: true,\r\n        cascadeUpdate: true,\r\n    })\r\n    @JoinTable()\r\n    songs: Song[] =[];\r\n```\r\n\r\n\r\n```import {Entity, Column, PrimaryGeneratedColumn, ManyToMany} from \"typeorm\";\r\nimport {Playlist} from \"./Playlist\";\r\n\r\n@Entity()\r\nexport class Song {\r\n\r\n    @PrimaryGeneratedColumn()\r\n    id: number;\r\n\r\n    @Column()\r\n    name: string;\r\n\r\n    @Column()\r\n    mainArtist: string;\r\n\r\n    @Column()\r\n    allArtists: string;\r\n\r\n    @Column()\r\n    thumbnailURL: string;\r\n\r\n    @ManyToMany(type => Playlist, playlist => playlist.songs, {\r\n        cascadeInsert: true,\r\n        cascadeUpdate: true\r\n    })\r\n    playlists: Playlist[] = [];\r\n}\r\n```\r\n\r\nThen I run this snippet.\r\n\r\n```\r\n var db = req.app.locals.db;\r\n    var params = req.params;\r\n    let newSong = new Song();\r\n      newSong.mainArtist = \"Drake\";\r\n      newSong.allArtists = \"Drake\";\r\n      newSong.name = \"Signs\"\r\n      newSong.thumbnailURL = \"random_url\";\r\n      \r\n    let playlist = await db\r\n    .getRepository(Playlist)\r\n    .findOneById(1);\r\n\r\n    newSong.playlists.push(playlist);\r\n    let songRepository = db.getRepository(Song)\r\n    .save(newSong)\r\n    .then(song => console.log(\"Song has been saved\"))\r\n    .catch(error => console.log(\"Cannot save. Error: \", error));\r\n```\r\n\r\nThe mysql joined table is `playlist_songs_song_playlists`, but there is only one row at a time. It always just adds the latest one. It is like it is overwriting the table. Any ideas why this is happening? I would appreciate the help!\r\n\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/593/comments",
    "author": "AAAstorga",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-06-28T12:52:50Z",
        "body": "try to remove intitialization from all your relations, e.g. `songs: Song[] =[];` replace to `songs: Song[];` and assign array manually when you write value. You have such problem because you are loading object without loading its elements and when you save it again with empty array ORM thinks you removed all items from your relation and removes them from the database."
      },
      {
        "user": "AAAstorga",
        "created_at": "2017-06-29T11:14:00Z",
        "body": "That seemed to do it! Thank you so much."
      }
    ]
  },
  {
    "number": 581,
    "title": "QueryBuilder Update seems to generate incorrect SQL statement for MSSQL",
    "created_at": "2017-06-26T20:51:16Z",
    "closed_at": "2017-06-29T16:29:11Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/581",
    "body": "QueryBuilder's update() seems to generate:\r\n\r\nUPDATE Table1 Alias SET Column1=\"Value1\" ...\r\n\r\nWhereas I think MSSQL only accepts:\r\n\r\nUPDATE Alias SET Column1=\"Value1\" FROM Table1 Alias ...\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/581/comments",
    "author": "tjme",
    "comments": [
      {
        "user": "tjme",
        "created_at": "2017-06-26T22:07:54Z",
        "body": "A work-around seems to be to add .from(\"Table1\",\"\")"
      },
      {
        "user": "pleerock",
        "created_at": "2017-06-27T10:49:41Z",
        "body": "Since `0.1.0-alpha.20` proper way of doing that:\r\n\r\n```ts\r\n        await connection.createQueryBuilder()\r\n            .update(User)\r\n            .set({\r\n                name: \"Dima Zotov\"\r\n            })\r\n            .where(\"name = :name\", { name: \"Alex Messer\" })\r\n            .execute();\r\n```\r\n\r\nor\r\n\r\n```ts\r\nawait connection.getRepository(User)\r\n            .createQueryBuilder(\"user\")\r\n            .update()\r\n            .set({ name: \"Dima Zotov\" })\r\n            .where(\"user.name = :name\", { name: \"Alex Messer\" })\r\n            .execute();\r\n```"
      },
      {
        "user": "tjme",
        "created_at": "2017-06-29T16:29:11Z",
        "body": "Many thanks! I got the second option working, using alpha.22, but it does currently report type error:\r\n\"Supplied parameters do not match any signature of call target\"."
      }
    ]
  },
  {
    "number": 580,
    "title": "OneToMany with where clause?",
    "created_at": "2017-06-26T20:01:54Z",
    "closed_at": "2017-06-30T17:23:41Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/580",
    "body": "So I have two entities that are relevant for this. They are `Organization` and `Group`\r\n\r\n```\r\n@Entity()\r\nexport class Organization extends EntityModel {\r\n    @PrimaryGeneratedColumn()\r\n    id: number;\r\n\r\n    @Column()\r\n    name: string;\r\n\r\n    @OneToMany(type => Group, group => group.organization, { cascadeInsert: true, cascadeUpdate: true })\r\n    groups: Group[];\r\n}\r\n```\r\n\r\n```\r\n@Entity()\r\nexport class Group extends EntityModel {\r\n    @PrimaryGeneratedColumn()\r\n    id: number;\r\n\r\n    @Column()\r\n    name: string;\r\n\r\n    @ManyToOne(type => Group, group => group.subgroups, { cascadeUpdate: true })\r\n    @JoinColumn()\r\n    parent: Group;\r\n\r\n    @OneToMany(type => Group, group => group.parent, { cascadeInsert: true, cascadeUpdate: true })\r\n    subgroups: Group[];\r\n\r\n    @ManyToOne(type => Organization, organization => organization.groups, { cascadeUpdate: true, onDelete: \"SET NULL\" })\r\n    @JoinColumn()\r\n    organization: Organization;\r\n}\r\n```\r\n\r\nAnd this works great! But my issue here is that I am trying to do something that MAY not be supported. Let me know if I've just missed the functionality. If the functionality does not exist then I guess this is a feature request.. \r\n\r\nI have it set up so that a `Group` can contain many `Group`s and each `Group` can have a parent which is a `Group` as well. So I want all groups to have an `Organization` but an organization should only have an array of groups that have that `Organization` as their `Organization`, but **NOT** have any parent group. Does this make sense? \r\n\r\n<hr>\r\n\r\nIn other words, I have the following:\r\n\r\n`Organization`\r\n<table>\r\n<tr><th>id</th><th>name</th></tr>\r\n<tr><td>1</td><td>Org 1</td></tr>\r\n<tr><td>2</td><td>Org 2</td></tr>\r\n</table>\r\n\r\n\r\n`Group`\r\n<table>\r\n<tr><th>id</th><th>name</th><th>parentId</th><th>organizationId</th></tr>\r\n<tr><td>1</td><td>Group 1</td><td>NULL</td><td>1</td></tr>\r\n<tr><td>2</td><td>Group 2</td><td>1</td><td>1</td></tr>\r\n<tr><td>3</td><td>Group 3</td><td>NULL</td><td>2</td></tr>\r\n<tr><td>4</td><td>Group 4</td><td>NULL</td><td>2</td></tr>\r\n</table>\r\n</body>\r\n</html>\r\n\r\n<hr>\r\n\r\nWhen I execute the following:\r\n```\r\nOrganization\r\n.createQueryBuilder(\"organization\")\r\n.leftJoinAndSelect(\"organization.groups\", \"groups\")\r\n.getMany()\r\n.then(organizations => {\r\n      // Do stuff with organizations here\r\n      // organizations should contain 2 values\r\n\r\n      // organizations[0] will be \"Org 1\" \r\n      // organizations[0].group will contain \"Group 1\" and \"Group 2\" but I want it to only contain \"Group 1\"\r\n\r\n      // organizations[1] will be \"Org 2\"\r\n      // organizations[1].group will contain \"Group 3\" and \"Group 4\" as desired\r\n});\r\n```\r\n\r\nMaybe that makes more sense. :)\r\n\r\nSo how could I achieve this? Basically I need to be able to create a `where` clause on the `inverseSide` of `OneToMany`",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/580/comments",
    "author": "joshuamking",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-06-27T11:56:47Z",
        "body": "probably first you should ask yourself how to achieve that using sql. How do you do that using sql?"
      },
      {
        "user": "joshuamking",
        "created_at": "2017-06-30T16:34:13Z",
        "body": "Sorry for the late reply.. I'm still stuck on this.\r\n\r\nOkay, well I would do something like this:\r\n\r\n```\r\nSELECT *\r\nFROM organization\r\n  LEFT JOIN \"group\" ON \"group\".\"organizationId\" = organization.id\r\nWHERE organization.id = 1 AND \"parentId\" IS NULL\r\n```"
      },
      {
        "user": "joshuamking",
        "created_at": "2017-06-30T17:01:26Z",
        "body": "So I have this:\r\n\r\n```\r\nOrganization\r\n.createQueryBuilder(\"organization\")\r\n.where(\"organization.id = :id\")\r\n.setParameters({ id: 1 })\r\n.leftJoinAndSelect(\"organization.groups\", \"group\", \"group.parent is null\")\r\n.getOne()\r\n```\r\n\r\nAnd it works great. But it would be nice, and I think it makes sense to be able to specify something like that in the model. Am I wrong in this paradigm? Thanks"
      },
      {
        "user": "pleerock",
        "created_at": "2017-06-30T17:03:35Z",
        "body": "your query is correct. If you want to have this in model then simply create a method in it with the code you provided."
      },
      {
        "user": "joshuamking",
        "created_at": "2017-06-30T17:23:41Z",
        "body": "Okay well this will work then I guess. Not perfect, but manageable. Thanks"
      }
    ]
  },
  {
    "number": 577,
    "title": "Impossible to execute the Quick Start",
    "created_at": "2017-06-24T17:40:20Z",
    "closed_at": "2017-06-27T20:00:15Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/577",
    "body": "Hi everybody,\r\n\r\nI would like to test typeorm with MySQL 2.13.0 on Visual code studio. The version used is 0.1.0-alpha.19. I have copied your following example \r\n\r\n```ts\r\nimport \"reflect-metadata\";\r\nimport {createConnection} from \"typeorm\";\r\nimport {Photo} from \"./entity/Photo\";\r\n\r\ncreateConnection({\r\n    driver: {\r\n        type: \"mysql\",\r\n        host: \"localhost\",\r\n        port: 3306,\r\n        username: \"root\",\r\n        password: \"admin\",\r\n        database: \"test\"\r\n    },\r\n    entities: [\r\n        Photo\r\n    ],\r\n    autoSchemaSync: true,\r\n}).then(connection => {\r\n    // here you can start to work with your entities\r\n}).catch(error => console.log(error));\r\n```\r\nand I have the following message error \r\n\r\nfile: 'file:///d%3A/sandbox/nest-test/src/tests/orm/app.ts'\r\nseverity: 'Erreur'\r\nmessage: 'Argument of type '{ driver: { type: \"mysql\"; host: string; port: number; username: string; password: string; databa...' is not assignable to parameter of type 'ConnectionOptions'.\r\n  Type '{ driver: { type: \"mysql\"; host: string; port: number; username: string; password: string; databa...' is not assignable to type '**MongoConnectionOptions**'.\r\n    Property 'type' is missing in type '{ driver: { type: \"mysql\"; host: string; port: number; username: string; password: string; databa...'.'\r\nat: '20,18'\r\nsource: 'ts'\r\n\r\nI have try to use connectionOptions \r\n\r\nimport \"reflect-metadata\";\r\nimport {createConnection} from \"typeorm\";\r\nimport {Photo} from \"./entity/Photo\";\r\nimport {MysqlConnectionOptions} from \"../../../node_modules/typeorm/driver/mysql/MysqlConnectionOptions.js\";\r\n\r\nconst connectionOptions: MysqlConnectionOptions = {\r\n    driver: {\r\n        type: \"mysql\",\r\n        host: \"localhost\",\r\n        port: 3306,\r\n        username: \"root\",\r\n        password: \"admin\",\r\n        database: \"test\"\r\n    },\r\n    entities: [Photo],\r\n    autoSchemaSync: true\r\n};\r\n\r\nand I have the following message\r\n\r\nfile: 'file:///d%3A/sandbox/nest-test/src/tests/orm/app.ts'\r\nseverity: 'Erreur'\r\nmessage: 'Type '{ driver: { type: \"mysql\"; host: string; port: number; username: string; password: string; databa...' **is not assignable to type 'MysqlConnectionOptions**'.\r\n  Property 'type' is missing in type '{ driver: { type: \"mysql\"; host: string; port: number; username: string; password: string; databa...'.'\r\nat: '7,7'\r\nsource: 'ts'\r\n\r\nI don't understand why it is checking connectionOptions from MongoDb and not MySQL. If there is somebody who can give me an indication, I will be happy.\r\n\r\nThanks in advance.",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/577/comments",
    "author": "afontange",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-06-27T12:03:20Z",
        "body": "Can you please try to extract \"driver\" section into connection options this way:\r\n\r\n```ts\r\ncreateConnection({\r\n        type: \"mysql\",\r\n        host: \"localhost\",\r\n        port: 3306,\r\n        username: \"root\",\r\n        password: \"admin\",\r\n        database: \"test\",\r\n    entities: [\r\n        Photo\r\n    ],\r\n    autoSchemaSync: true,\r\n}).then(connection => {\r\n    // here you can start to work with your entities\r\n}).catch(error => console.log(error));\r\n```"
      },
      {
        "user": "afontange",
        "created_at": "2017-06-27T16:29:49Z",
        "body": "Thanks for your quick answer : without \"driver\" the error disappeared. I will continue to evaluate typeorm next week-end. I have another question : is there a way to define unique keys?"
      },
      {
        "user": "pleerock",
        "created_at": "2017-06-27T19:59:52Z",
        "body": "yes you can create `@Index({ unique: true })`, you can put index to class and create composite indices, or you can put in on columns. Also you can mark column as unique: `@Column({ unqiue: true })`"
      },
      {
        "user": "pleerock",
        "created_at": "2017-06-27T20:00:15Z",
        "body": "I'll close it - let me know if you will still have issues with it."
      },
      {
        "user": "JoshGlazebrook",
        "created_at": "2017-07-25T04:00:08Z",
        "body": "Is this an issue of the docs being out of date? I also ran into this.\r\n\r\nEdit: Actually it appears the alpha versions are being published under the latest tag rather than a alpha/beta tag on npm, so these alpha versions are being installed by default for everyone.\r\n\r\nIs there a reason these aren't on a special tag?"
      },
      {
        "user": "pleerock",
        "created_at": "2017-07-25T11:22:50Z",
        "body": "actually latest alpha versions overall are much more stable then 0.0.11 version, so I recommend to use it instead. Some of the docs are out of date unfortunately, I'll fix it once I get more free time (or anyone can help me ;))"
      }
    ]
  },
  {
    "number": 562,
    "title": "MySQL column type: Medium/Long Text",
    "created_at": "2017-06-21T04:57:44Z",
    "closed_at": "2017-06-21T10:01:41Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/562",
    "body": "Hi, does TypeORM support Medium/Long Text column data type for MySQL, Seem it only support Text when I add column with type 'text' or 'json'.",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/562/comments",
    "author": "brookshi",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-06-21T07:44:17Z",
        "body": "what typeorm version are you using?"
      },
      {
        "user": "brookshi",
        "created_at": "2017-06-21T09:31:51Z",
        "body": "I'm using 0.0.9."
      },
      {
        "user": "pleerock",
        "created_at": "2017-06-21T09:45:55Z",
        "body": "Medium/Long Text is supported only in latest 0.1.0-alpha versions."
      },
      {
        "user": "brookshi",
        "created_at": "2017-06-21T10:00:42Z",
        "body": "Great, Thanks. "
      }
    ]
  },
  {
    "number": 544,
    "title": "groupBy() and getCount() cannot be used at the same time",
    "created_at": "2017-06-15T02:26:52Z",
    "closed_at": "2017-06-20T11:56:59Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/544",
    "body": "During my development, I found there is literally no way to count the number of kinds of data in a query with Typeorm. The getCount wiil return the fist value of groupBy(). For example, if we have 9 fruits in the db, 4 apples, 3 bananas, and 2 cherries. The getCount after groupBy will return us 4 coz we have 4 apples. Any idea?",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/544/comments",
    "author": "bobmayuze",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-06-15T17:58:47Z",
        "body": "`getCount` of `QueryBuilder` is for pagination purposes. For example if you have 1000 bananas, but your query to load bananas uses `skip`/`take` for pagination purposes which returns you only 20 bananas, you need to get know how many bananas do you have overall to create correct number of pages. Thats what `getCount` stays for. For your purposes you probably need to use regular SQL COUNT() in your queries and get raw results."
      },
      {
        "user": "pleerock",
        "created_at": "2017-06-20T09:47:16Z",
        "body": "Did I answer your question?"
      },
      {
        "user": "bobmayuze",
        "created_at": "2017-06-20T10:00:54Z",
        "body": "Thanks for answering the question, but I wonder if I can do so with typeorm. "
      },
      {
        "user": "pleerock",
        "created_at": "2017-06-20T11:56:37Z",
        "body": "> For your purposes you probably need to use regular SQL COUNT() in your queries and get raw results.\r\n\r\nyeah you simply do something like \r\n\r\n```ts\r\nconst results = await queryBuilder.select(\"COUNT(post.id) AS cnt\").getRawMany()\r\n```"
      },
      {
        "user": "bobmayuze",
        "created_at": "2017-06-21T00:51:01Z",
        "body": "Thanks for the help! Really appreciate for that"
      },
      {
        "user": "wodka",
        "created_at": "2020-02-18T19:24:45Z",
        "body": "I created a helper for myself to do the same thing:\r\n\r\n```typescript\r\nimport { SelectQueryBuilder } from 'typeorm'\r\n\r\nexport class CoreQbHelper {\r\n  public static async getRawManyAndCount<T>(qb: SelectQueryBuilder<any>, groupColumns: string[]): Promise<[number, T[]]> {\r\n    return Promise.all([\r\n      new Promise<number>((resolve, reject) => {\r\n        const cQb = qb.clone()\r\n        cQb.skip(0)\r\n        cQb.select(`COUNT(DISTINCT (${groupColumns.join(', ')})) as c`)\r\n        cQb.orderBy(null)\r\n        cQb.getRawOne()\r\n          .then(value => resolve(value.c ? Number(value.c) : 0))\r\n          .catch(e => reject(e))\r\n      }),\r\n      new Promise<T[]>((resolve, reject) => {\r\n        const vQb = qb.clone()\r\n        vQb.groupBy(groupColumns.join(', '))\r\n        vQb.getRawMany()\r\n          .then(values => resolve(values))\r\n          .catch(e => reject(e))\r\n      }),\r\n    ])\r\n  }\r\n}\r\n```\r\n\r\nAnd to use it pass the columns you are grouping to it as well like `CoreQbHelper.getRawManyAndCount(qb, ['b.type'])`"
      },
      {
        "user": "Logic-Bits",
        "created_at": "2021-02-18T07:54:16Z",
        "body": "> I created a helper for myself to do the same thing:\r\n> \r\n> ```ts\r\n> import { SelectQueryBuilder } from 'typeorm'\r\n> \r\n> export class CoreQbHelper {\r\n>   public static async getRawManyAndCount<T>(qb: SelectQueryBuilder<any>, groupColumns: string[]): Promise<[number, T[]]> {\r\n>     return Promise.all([\r\n>       new Promise<number>((resolve, reject) => {\r\n>         const cQb = qb.clone()\r\n>         cQb.skip(0)\r\n>         cQb.select(`COUNT(DISTINCT (${groupColumns.join(', ')})) as c`)\r\n>         cQb.orderBy(null)\r\n>         cQb.getRawOne()\r\n>           .then(value => resolve(value.c ? Number(value.c) : 0))\r\n>           .catch(e => reject(e))\r\n>       }),\r\n>       new Promise<T[]>((resolve, reject) => {\r\n>         const vQb = qb.clone()\r\n>         vQb.groupBy(groupColumns.join(', '))\r\n>         vQb.getRawMany()\r\n>           .then(values => resolve(values))\r\n>           .catch(e => reject(e))\r\n>       }),\r\n>     ])\r\n>   }\r\n> }\r\n> ```\r\n> \r\n> And to use it pass the columns you are grouping to it as well like `CoreQbHelper.getRawManyAndCount(qb, ['b.type'])`\r\n\r\nThanks!\r\n\r\nI just flipped number and T[] so its works just like the getManyAndCount()"
      },
      {
        "user": "choninoa",
        "created_at": "2022-03-21T03:16:59Z",
        "body": "count = await (await qb.getRawMany()).length"
      },
      {
        "user": "ernestdolog",
        "created_at": "2023-07-14T19:11:00Z",
        "body": "> count = await (await qb.getRawMany()).length\r\n\r\nunless You are paginating, and set a `first` and/or an `after`"
      }
    ]
  },
  {
    "number": 539,
    "title": "Allow manual rollback or commit of transaction",
    "created_at": "2017-06-14T01:51:23Z",
    "closed_at": "2017-06-15T18:29:45Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/539",
    "body": "",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/539/comments",
    "author": "yonilerner",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-06-14T12:23:36Z",
        "body": "Everything you wrap into transaction will be executed and in the end transaction will be commited. You can throw exception in your transaction function and rollback will be executed. Why do you need more then this? But yeah, you can do manual rollback and commit, but using more low-level api."
      },
      {
        "user": "yonilerner",
        "created_at": "2017-06-14T17:59:05Z",
        "body": "@pleerock How can I access this lower level API? I dont see any references in the documentation.\r\n\r\nThrowing exceptions of course works, but its often more cumbersome than really necessary if all I want to do is rollback a transaction based on a condition "
      },
      {
        "user": "pleerock",
        "created_at": "2017-06-15T17:55:00Z",
        "body": "as of `0.1.0-alpha.9` its possible using this syntax:\r\n\r\n```ts\r\nconst queryRunner = connection.driver.createQueryRunner(); // queryRunner is a single real connection to the database obtained from a connection pool\r\nawait queryRunner.startTransaction();\r\n// execute sql queries using queryRunner\r\nawait queryRunner.commitTransaction(); // or .rollbackTransaction()\r\nawait queryRunner.release(); // don't forget to release connection, very important!\r\n```\r\n\r\nExecute any sql operations using queryRunner. USE ONLY this queryRunner to execute queries, don't use entity managers, repositories because they are running queries on their own query runners. In the case you want to use managers/repositories you need to create them using this api:\r\n\r\n```ts\r\nconst entityManager = connection.createIsolatedManager(yourQueryRunner);\r\n```\r\n\r\nor \r\n\r\n```ts\r\nconst entityRepository = connection.createIsolatedRepository(Entity, yourQueryRunner);\r\n```"
      },
      {
        "user": "yonilerner",
        "created_at": "2017-06-15T18:29:45Z",
        "body": "Great, thank you!"
      },
      {
        "user": "EVINK",
        "created_at": "2020-09-11T01:04:48Z",
        "body": "@pleerock\r\n\r\nHi, there! I am using UPDATE SQL in queryRunner.query API, and I do not commit it, but it has changed data to db later.\r\n\r\nHere is my code\r\n\r\n```ts\r\n// A request is coming, since I do not commit it , so the data in db not changes after responded\r\n// but it is changed while an another request arrived (this new request had calling \"startTransaction() \")\r\nconst queryRunner = getConnection().createQueryRunner()\r\ntry{\r\n    await queryRunner.startTransaction() \r\n    await queryRunner.connect()\r\n    await queryRunner.query('UPDATE ...')\r\n}catch(err){\r\n    return next(err)\r\n}finally{\r\n   queryRunner.release()\r\n}\r\n\r\n```\r\nHow I gonna do if I want to ensure the data not changed?\r\n\r\n"
      }
    ]
  },
  {
    "number": 506,
    "title": "Schema sync/drop in 0.1.0-alpha.3",
    "created_at": "2017-05-31T14:38:02Z",
    "closed_at": "2017-06-03T19:49:52Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/506",
    "body": "I've got some problems with typeorm@0.1.0-alpha.3:\r\n\r\n`typeorm schema:sync`\r\n\r\n`UnhandledPromiseRejectionWarning: Unhandled promise rejection (rejection id: 1): TypeError: this.metadataArgsStorage.filterTables is not a function`\r\n\r\nThe same issue with `schema:drop` command.\r\nnodejs: v6.10.3\r\nenv: windows 10 x64\r\nserver: PostgreSQL 9.4.11 on x86_64-unknown-linux-gnu, compiled by gcc (Debian 4.9.2-10) 4.9.2, 64-bit\"\r\n\r\nBy the way: where can i find the information about debug way for typeorm cli commands?\r\nThanks.",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/506/comments",
    "author": "rkylsyi",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-06-03T05:50:02Z",
        "body": "You have this issue because your `ormconfig.json` is not an array, ormconfig.json should contain an array of connection options, e.g.:\r\n\r\n```json\r\n[{\r\n  \"driver\": {\r\n    \"type\": \"mysql\",\r\n    \"host\": \"localhost\",\r\n    \"port\": 3306,\r\n    \"username\": \"test\",\r\n    \"password\": \"test\",\r\n    \"database\": \"test\",\r\n    \"usePool\": true,\r\n    \"extra\": {\r\n      \"timezone\": \"utc\"\r\n    }\r\n  },\r\n  \"autoSchemaSync\": true,\r\n  \"entities\": [\r\n    \"modules/**/entity/{*.ts,*.js}\"\r\n  ],\r\n  \"subscribers\": [\r\n    \"modules/**/subscriber/{*.ts,*.js}\"\r\n  ]\r\n}]\r\n```\r\n\r\n> where can i find the information about debug way for typeorm cli commands? \r\n\r\nyou debug it just the regular way you usually debug javascript"
      },
      {
        "user": "rkylsyi",
        "created_at": "2017-06-03T19:49:52Z",
        "body": "Thank you very much! "
      }
    ]
  },
  {
    "number": 461,
    "title": "Use ManyToMany decorator alongside with PrimaryGeneratedColumn",
    "created_at": "2017-05-09T12:59:05Z",
    "closed_at": "2017-05-10T13:53:33Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/461",
    "body": "Let's say I have 3 classes / tables : 'Artist', 'Artwork' and 'Tag'. \r\nArtist and Artwork both have a ManyToMany relation with Tag. What I'd like to do is the following : \r\n\r\n```\r\nclass Tag {\r\n    @PrimaryGeneratedColumn()\r\n    @ManyToMany(type => Artwork, artwork => artwork.tags)\r\n    @ManyToMany(type => Artist, artist => artist.tags)\r\n    id: number;\r\n} \r\n```\r\n\r\n```\r\nclass Artwork {\r\n    @PrimaryGeneratedColumn()\r\n    id: number;\r\n   \r\n    @ManyToMany(type => Tag, tag => tag.id, {\r\n        cascadeInsert: true\r\n    })\r\n    @JoinTable()\r\n    public tags: Tag[];\r\n  \r\n}\r\n```\r\n\r\n```\r\nclass Artist {\r\n    @PrimaryGeneratedColumn()\r\n    id: number;\r\n   \r\n    @ManyToMany(type => Tag, tag => tag.id, {\r\n        cascadeInsert: true\r\n    })\r\n    @JoinTable()\r\n    public tags: Tag[];\r\n    \r\n}\r\n```\r\n\r\nCurrently, it doesn't seem to work: tags are created but relationship between Tag and Artwork / Artist is not saved in 'join' table . How could I manage to setup such a mechanism without having to implement 2 specific Tag classes (one for each class) ? \r\n\r\nBy the way I'm using @next version of typeorm with mysql-driver.\r\n\r\nThank you and keep up the good work !\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/461/comments",
    "author": "cclaim",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-05-10T05:18:53Z",
        "body": "In second argument of relation you should provide `inverse relation`, not `id column` as you do right now:\r\n\r\n\r\n```ts\r\nclass Tag {\r\n    @PrimaryGeneratedColumn()\r\n    id: number;\r\n\r\n    @ManyToMany(type => Artwork, artwork => artwork.tags)\r\n    artworks: Artwork[];\r\n\r\n    @ManyToMany(type => Artist, artist => artist.tags)\r\n    artists: Artist[];\r\n} \r\n```\r\n\r\n```ts\r\nclass Artwork {\r\n    @PrimaryGeneratedColumn()\r\n    id: number;\r\n   \r\n    @ManyToMany(type => Tag, tag => tag.artworks, {\r\n        cascadeInsert: true\r\n    })\r\n    @JoinTable()\r\n    public tags: Tag[];\r\n  \r\n}\r\n```\r\n```ts\r\nclass Artist {\r\n    @PrimaryGeneratedColumn()\r\n    id: number;\r\n   \r\n    @ManyToMany(type => Tag, tag => tag.artists, {\r\n        cascadeInsert: true\r\n    })\r\n    @JoinTable()\r\n    public tags: Tag[];\r\n    \r\n}\r\n```"
      },
      {
        "user": "cclaim",
        "created_at": "2017-05-10T10:28:33Z",
        "body": "Thank you !"
      }
    ]
  },
  {
    "number": 450,
    "title": "Saving a relationship",
    "created_at": "2017-05-02T22:14:30Z",
    "closed_at": "2017-05-04T18:37:31Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/450",
    "body": "I'm probably just doing this wrong. I'm trying to add related object to another object through a many2many relationship.\r\n\r\nHere's my scenario:\r\n\r\nUser->hasFriends [User] (many2many)\r\nUser->hasGroups [Group] (many2many)\r\n\r\nWhen i want to add a group to a user I\r\n1) fetch the respective user\r\n2) left join the groups\r\n3) fetch my respective group\r\n4) push my group, user.addGroup(group)\r\n5) persist my user object.\r\n\r\nThis works; but deletes all friend relationships. If I add a friend to my user; all group relationships get deleted.\r\n\r\nHere are my model definitions:\r\n\r\nUser:\r\n\r\n\trequire(\"reflect-metadata\");\r\n\timport {Entity, PrimaryColumn, Column, ManyToMany, JoinTable} from \"typeorm\";\r\n\timport Group from './Group';\r\n\t\r\n\t\r\n\t@Entity()\r\n\texport default class User {\r\n\t\r\n\t    @PrimaryColumn(\"int\", { generated: true })\r\n\t    id = undefined;\r\n\t\r\n\t    @Column(\"string\")\r\n\t    email = \"\";\r\n\t\r\n\t    @Column(\"string\")\r\n\t    firstname = \"\";\r\n\t\r\n\t    @Column(\"string\")\r\n\t    lastname = \"\";    \r\n\t    \r\n\t    @Column(\"string\")\r\n\t    middlename = \"\";\r\n\t    \r\n\t    @Column(\"string\")\r\n\t    password = \"\";\r\n\t    \r\n\t    @Column(\"string\")\r\n\t    salt = \"\";\r\n\t       \r\n\t    \r\n\t    setEmail(email) {\r\n\t\t    this.email = email;\r\n\t\t    return this;\r\n\t    }\r\n\t    \r\n\t    getEmail() {\r\n\t\t    return this.email;\t    \r\n\t    }\r\n\t    \r\n\t    setFirstname(firstname) {\r\n\t\t    this.firstname = firstname;\r\n\t\t    return this;\r\n\t    }\r\n\t    \r\n\t    getFirstname() {\r\n\t\t    return this.firstname;\r\n\t    }\r\n\t    \r\n\t    setLastname(lastname) {\r\n\t\t    this.lastname = lastname;\r\n\t\t    return this;\r\n\t    }\r\n\t    \r\n\t    getLastname() {\r\n\t\t    return this.lastname;\r\n\t    }\r\n\t    \r\n\t    setMiddlename(middlename) {\r\n\t\t    this.middlename = middlename;\r\n\t\t    return this;\r\n\t    }\r\n\t    \r\n\t    getMiddlename() {\r\n\t\t    return this.middlename;\r\n\t    }\r\n\t    \r\n\t    setPassword(password) {\r\n\t\t    this.password = password;\r\n\t\t    return this;\r\n\t    }\r\n\t    \r\n\t    getPassword() {\r\n\t\t    return this.password;\r\n\t    }\r\n\t    \r\n\t    setSalt(salt) {\r\n\t\t    this.salt = salt;\r\n\t\t    return this;\r\n\t    }\r\n\t    \r\n\t    getSalt() {\r\n\t\t    return this.salt;\r\n\t    }\r\n\t    \r\n\t    addFriend(friend) {\r\n\t\t    this.friends.push(friend);\r\n\t    }\r\n\t\r\n\t    getGroups() {\r\n\t\t    return this.groups;\r\n\t    }\r\n\t    \r\n\t    addGroup(group) {\r\n\t\t    this.groups.push(group);\r\n\t    }\r\n\t    \r\n\t    getFriends() {\r\n\t\t    return this.friends;\r\n\t    }\r\n\t    \r\n\t    getFriendsInverse() {\r\n\t\t    return this.friends;\r\n\t    }\r\n\t    \r\n\t\r\n\t\t@ManyToMany(type => User, user => user.friendsInverse, {\r\n\t\t\tcascadeInsert: false,\r\n\t\t\tcascadeUpdate: false,\r\n\t\t})\r\n\t\t@JoinTable()\r\n\t\tfriends = [];\r\n\t\r\n\t\t@ManyToMany(type => User, user => user.friends, {\r\n\t\t\tcascadeInsert: true,\r\n\t\t\tcascadeUpdate: true,\r\n\t\t\tcascadeRemove: false,\r\n\t\t})\r\n\t\tfriendsInverse = [];\r\n\t\t\r\n\t\t\r\n\t    @ManyToMany(type => Group, group => group.users, {\r\n\t        cascadeInsert: true,\r\n\t        cascadeUpdate: true,\r\n\t        cascadeRemove: false\r\n\t    })\r\n\t    groups = [];\r\n\t    \r\n\t    \r\n\t}\r\n\r\n\r\nGroup:\r\n\r\n\trequire(\"reflect-metadata\");\r\n\timport {Entity, PrimaryColumn, Column, ManyToMany, JoinTable} from \"typeorm\";\r\n\timport User from './User';\r\n\t\r\n\t@Entity()\r\n\texport default class Group {\r\n\t\r\n\t    @PrimaryColumn(\"int\", { generated: true })\r\n\t    id = undefined;\r\n\t\r\n\t    @Column(\"string\")\r\n\t    title = \"\";\r\n\t\r\n\t    @Column(\"string\")\r\n\t    description = \"\";\r\n\t\r\n\t    \r\n\t    setTitle(title) {\r\n\t\t    this.title = title;\r\n\t\t    return this;\r\n\t    }\r\n\t    \r\n\t    getTitle() {\r\n\t\t    return this.title;\t    \r\n\t    }\r\n\t    \r\n\t    setDescription(description) {\r\n\t\t    this.description = description;\r\n\t\t    return this;\r\n\t    }\r\n\t    \r\n\t    getDescription() {\r\n\t\t    return this.description;\r\n\t    }\r\n\t\r\n\t\t@ManyToMany(type => User, user => user.groups, {\r\n\t\t\tcascadeInsert: true,\r\n\t        cascadeUpdate: true,\r\n\t        cascadeRemove: true\r\n\t\t})\r\n\t\t@JoinTable()\r\n\t\tusers = [];\r\n\t    \r\n\t    \r\n\t}\r\n\r\n-------\r\n\r\nIs this the expected behaviour?\r\n\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/450/comments",
    "author": "Matt007",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-05-03T04:40:44Z",
        "body": "Remove initializations from your model ` = []`. When you load object without friends and there is initialization orm thinks that you have remove all friends from your object and removes them. There is no way it can understand is it just initialized empty array or its empty because all entities were removed."
      },
      {
        "user": "Matt007",
        "created_at": "2017-05-04T16:09:19Z",
        "body": "Oh, makes sense! Thanks a lot for your help!\r\n\r\nMaybe it would help to point this out in the example. I'm sure a lot of people might run into the same issue when they copy&paste the example from the docs.\r\n"
      },
      {
        "user": "pleerock",
        "created_at": "2017-05-04T18:37:31Z",
        "body": "you are right, thanks."
      }
    ]
  },
  {
    "number": 449,
    "title": "Event subscribers not affecting abstract entities",
    "created_at": "2017-05-02T20:34:13Z",
    "closed_at": "2017-05-10T05:58:20Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/449",
    "body": "Tried to create a new abstract entity with created_at and updated_at to be automatically update on change, it's not working, only if I put the columns in the entity itself.\r\n\r\nbtw, is there any built in soft deletes?",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/449/comments",
    "author": "ghost",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-05-03T04:42:43Z",
        "body": "> btw, is there any built in soft deletes?\r\n\r\nno\r\n\r\n> Tried to create a new abstract entity with created_at and updated_at to be automatically update on change, it's not working, only if I put the columns in the entity itself.\r\n\r\nthey should work. Did you include your abstract entity in the `entities` of the configuration?"
      },
      {
        "user": "ghost",
        "created_at": "2017-05-05T18:47:32Z",
        "body": "Thanks! that was the issue,\r\nis there any why I can put global condition on each entity so I can add for example\r\n\"deleted_at\" is null?"
      },
      {
        "user": "pleerock",
        "created_at": "2017-05-10T05:58:20Z",
        "body": "no there is no such way, put your queries always if you need this."
      }
    ]
  },
  {
    "number": 427,
    "title": "delete via join",
    "created_at": "2017-04-27T23:04:37Z",
    "closed_at": "2017-04-30T00:26:51Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/427",
    "body": "Hi,\r\n\r\nI'm trying to delete via join, though with postgres join doesn't work with delete.\r\n\r\nwith this query (assuming `Account` <-> `Project` as 1:many join):\r\n\r\n```\r\nconn.getRepository(Project)\r\n  .createQueryBuilder('p')\r\n  .innerJoin('p.account = account', 'account')\r\n  .where('account.accountId = :accountId', { accountId: 'test' })\r\n  .delete();\r\n```\r\nit generates the following SQL:\r\n\r\n```\r\nDELETE FROM \"projects\" INNER JOIN \"accounts\" \"account\" ON \"account\".\"account_id\"=\"p\".\"account_id\" WHERE \"account\".\"name\" = 'test';\r\n```\r\n\r\nWhich causes postgres to throw the following error:\r\n\r\n```\r\nLINE 1: DELETE FROM \"projects\" INNER JOIN \"accounts\" \"account\" ON \"a...\r\n```\r\n\r\nIt looks like the alias `p` isn't used in the query generation, also, the way to make inner join work for postgres is via `using <alias>`, as follows:\r\n\r\n```\r\nDELETE FROM \"projects\" *USING \"projects\" AS \"p\"* INNER JOIN \"accounts\" \"account\" ON \"account\".\"account_id\"=\"p\".\"account_id\" WHERE \"account\".\"name\" = 'test';\r\n```\r\n\r\nThis can certainly be me not knowing how to use the query builder correctly. Can anyone help verify if I need a different query or if this is not implemented at this time?\r\n\r\nThanks.\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/427/comments",
    "author": "yinso",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-04-28T05:04:10Z",
        "body": "No, deletion \"via join\" is not supported. Consider object deletion manually for each your relation."
      },
      {
        "user": "yinso",
        "created_at": "2017-04-28T18:02:56Z",
        "body": "If this isn't supported, it means that I'll need to retrieve the data first before I delete them right?\r\n\r\nSomething like below?\r\n\r\n```\r\nconn.getRepository(Project)\r\n  .createQueryBuilder('p')\r\n  .innerJoin('p.account = account', 'account')\r\n  .where('account.accountId = :accountId', { accountId: 'test' })\r\n  .getMany()\r\n  .then((projects) => {\r\n    return conn.getRepository(Project).remove(projects)\r\n  })\r\n```\r\n\r\n"
      },
      {
        "user": "pleerock",
        "created_at": "2017-04-29T05:12:06Z",
        "body": "right"
      },
      {
        "user": "yinso",
        "created_at": "2017-04-30T00:26:51Z",
        "body": "k thanks."
      },
      {
        "user": "jun9358",
        "created_at": "2019-02-13T08:20:56Z",
        "body": "Please support this feature..."
      },
      {
        "user": "Ezard",
        "created_at": "2020-01-04T16:26:12Z",
        "body": "@pleerock are you open to a PR to provide this functionality?"
      },
      {
        "user": "j1i-ian",
        "created_at": "2020-03-31T02:08:22Z",
        "body": "any progress ?"
      },
      {
        "user": "joaquinaraujo",
        "created_at": "2020-07-06T17:54:33Z",
        "body": "My solution, I hope it will soon be available in TypeORM\r\n\r\n```\r\nasync delete(id, { order, customer }): Promise<OrderItem> {\r\n    const [ orderItemErr, orderItem ] = await to(\r\n      this.orderItemsRepository.createQueryBuilder('order_item')\r\n        .select([\r\n          'order_item.id',\r\n          'order_item.quantity',\r\n          'order_item.price'\r\n        ])\r\n        .innerJoin('order_item.order', 'order')\r\n        .where({ id, order })\r\n        .andWhere('order.customer = :customer', { customer })\r\n        .getOne()\r\n    )\r\n    // track: console.log(orderItemErr)\r\n\r\n    if (orderItemErr || !Boolean(orderItem)) throw new Error('item-not-found')\r\n\r\n    const [ err, deletedOrderItem ]: [ Error, DeleteResult ] = await to(this.orderItemsRepository.delete({ id: orderItem.id }))\r\n    // track: console.log(err)\r\n\r\n    if (err || !Boolean(deletedOrderItem) || !Boolean(deletedOrderItem.affected)) throw new Error()\r\n\r\n    return orderItem\r\n  }\r\n```"
      },
      {
        "user": "dfenerski",
        "created_at": "2021-03-09T10:53:20Z",
        "body": "why is this closed?"
      },
      {
        "user": "MichaelSp",
        "created_at": "2021-03-19T11:35:47Z",
        "body": "that would be actually quite useful. "
      },
      {
        "user": "TheProgrammer21",
        "created_at": "2021-07-27T11:04:25Z",
        "body": "Extremely useful.. @pleerock could you please open the issue again? "
      },
      {
        "user": "imnotjames",
        "created_at": "2021-07-27T14:30:35Z",
        "body": "This was closed by the author.\r\n\r\nShould you want this feature please open a properly formatted feature request."
      }
    ]
  },
  {
    "number": 355,
    "title": "InnerjoinAndSelect returns undefined",
    "created_at": "2017-03-19T15:15:33Z",
    "closed_at": "2017-03-23T21:34:03Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/355",
    "body": "Hello,\r\n\r\nI have a many to one relation. Every photo has one photoCollectionId and photoCollection and every PhotoCollection has an array of Photo. Now I want to load a collection with its photos:\r\n```typescript\r\n let collection = await this.collectionRepository.findOneById(id\r\n        , {\r\n          alias: \"collection\",\r\n          innerJoinAndSelect: {\r\n            \"photos\": \"collection.photos\"\r\n          }\r\n        });\r\n```\r\nWhen there is no photo related to the collection this returns undefined. However, if there is a related photo, it works as expected. \r\n\r\nFor now I have worked around the issue like this:\r\n```typescript\r\n@Get(\"/:id/photos\")\r\n  async getOne( @Param(\"id\") id: number) {\r\n    let photo = await this.photoRepository.findOne({ photoCollectionId: id });\r\n    if (photo) {\r\n      let collection = await this.collectionRepository.findOneById(id\r\n        , {\r\n          alias: \"collection\",\r\n          innerJoinAndSelect: {\r\n            \"photos\": \"collection.photos\"\r\n          }\r\n        });\r\n      console.log(collection);\r\n      return collection;\r\n    }\r\n    else {\r\n      let collection = await this.collectionRepository.findOneById(id);\r\n      console.log(collection);\r\n      return collection;\r\n    }\r\n  }\r\n```\r\n\r\nHowever, this is probably not how it should be I suppose. Is there a better/easier way to do this?",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/355/comments",
    "author": "Christian24",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-03-22T13:06:08Z",
        "body": "can you try `QueryBuilder` instead? Using \r\n\r\n```ts\r\n{\r\n          alias: \"collection\",\r\n          innerJoinAndSelect: {\r\n            \"photos\": \"collection.photos\"\r\n          }\r\n        }\r\n``` \r\n\r\nis deprecated and will be removed in next typeorm version. Use `QueryBuilder` instead:\r\n\r\n\r\n```ts\r\nrepository.createQueryBuilder(\"collection\")\r\n     .innerJoinAndSelect(\"collection.photos\", \"photos\")\r\n     .where(\"collection.id = :id\", { id })\r\n     .getOne();\r\n```"
      },
      {
        "user": "MichalLytek",
        "created_at": "2017-03-23T18:34:31Z",
        "body": "Could you paste here you entities classes?"
      },
      {
        "user": "Christian24",
        "created_at": "2017-03-23T21:31:09Z",
        "body": "@pleerock How do I know it is deprecated? Is there any way to know?\r\n\r\nUsing QueryBuilder works like a charm. Thanks a lot. \r\n\r\n"
      },
      {
        "user": "Christian24",
        "created_at": "2017-03-23T21:34:03Z",
        "body": "@19majkel94 \r\n\r\nPhotoCollection.ts:\r\n```typescript\r\n@Entity()\r\nexport class PhotoCollection extends BaseEntity {\r\n    @OneToMany(type => Photograph, photo => photo.photoCollection)\r\n    public photos:Array<Photograph> = new Array<Photograph>();\r\n     @Column(\"string\",{nullable:true})\r\n    public title:string;\r\n     @Column()\r\n    public showPhotoTitle:boolean = false;\r\n     @Column()\r\n    public showCollectionTitle:boolean = false;\r\n     @Column(\"string\",{nullable:true})\r\n\r\n    public titlePhotoUrl:string;\r\n     @Column()\r\n    public hidden:boolean = true;\r\n    @OneToMany(type => PhotoInfoSetting, infoSetting => infoSetting.photoCollection)\r\n    public infoSettings:Array<PhotoInfoSetting> = new Array<PhotoInfoSetting>();\r\n}\r\n```\r\nPhoto.ts:\r\n```typescript\r\n@Entity()\r\nexport class Photograph extends BaseEntity {\r\n     @Column(\"int\")\r\n   public photoCollectionId:number;\r\n   @ManyToOne(type => PhotoCollection, photoCollection => photoCollection.photos)\r\n   @JoinColumn({name:\"photoCollectionId\"})\r\n   public photoCollection:PhotoCollection;\r\n   @OneToMany(type => PhotoInfo, photoInfo => photoInfo.photo)\r\n   public photoInfos:Array<PhotoInfo> = new Array<PhotoInfo>();\r\n     @Column(\"string\",{nullable:true})\r\n   public title:string;\r\n     @Column(\"string\",{nullable:true})\r\n   public source:string;\r\n     @Column(\"string\",{nullable:true})\r\n   public preview:string;\r\n    @Column()\r\n   public hidden:boolean = false;\r\n}\r\n```\r\nThose are my entities. I will be offline for a week, so please expect a delay in response. "
      }
    ]
  },
  {
    "number": 351,
    "title": "execute migrations through code",
    "created_at": "2017-03-16T15:58:39Z",
    "closed_at": "2017-03-16T19:06:48Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/351",
    "body": "Is there a way to execute migrations through my code?",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/351/comments",
    "author": "natanielkdias",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-03-16T18:10:55Z",
        "body": "you can do that using `connection.runMigrations()` method"
      },
      {
        "user": "natanielkdias",
        "created_at": "2017-03-16T18:32:24Z",
        "body": "Thank you! I'm developing  a solution on electron and sqlite. It will be so helpful to my application updates. "
      },
      {
        "user": "pleerock",
        "created_at": "2017-03-16T19:06:48Z",
        "body": "good to help \ud83d\udc4d "
      }
    ]
  },
  {
    "number": 303,
    "title": "Connection pooling doesn't really pool connections",
    "created_at": "2017-02-22T00:41:50Z",
    "closed_at": "2017-02-23T17:25:22Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/303",
    "body": "It looks like when you create a connection and have connection pooling on type orm creates a \"pool of 1 connection\", and then when you close the connection type orm ends the pool.  Ideally what we want to do is create a pool of 50 connections in our web api that type orm re-uses across requests.  I'm new to type orm.  Hopefully I'm just missing some way to configure this.",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/303/comments",
    "author": "swilliams-a3digital",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-02-22T06:18:15Z",
        "body": "> when you close the connection type orm ends the pool\r\n\r\nyou should not close connection in the app lifecycle. You open connection once in application bootstrap and close only when application shut downs. Connection pools are handled in a single orm connection, and when you are closing connection - you are closing pool too. If you don't close connection - pool will work as you expect."
      },
      {
        "user": "swilliams-a3digital",
        "created_at": "2017-02-22T20:36:01Z",
        "body": "Thanks for the quick reply.  If I create the \"type orm connection\" in the app bootstrap, and I have a bunch of simultaneous requests that all use the one \"type orm connection\" will there be any issues?  \r\n\r\nMy concern is:\r\nrequest A comes in, type orm does a persist and while its waiting for the promise to resolve node handles request B that uses the same type orm connection and there is some problem because the connection is in use.\r\n\r\nI'm hoping the answer is the one \"type orm\" connection will open multiple my sql db connections if it needs to do multiple things at the same time\r\n\r\n"
      },
      {
        "user": "pleerock",
        "created_at": "2017-02-23T03:19:01Z",
        "body": "> If I create the \"type orm connection\" in the app bootstrap, and I have a bunch of simultaneous requests that all use the one \"type orm connection\" will there be any issues\r\n\r\nno, because its designed to work this way.\r\n\r\n> I'm hoping the answer is the one \"type orm\" connection will open multiple my sql db connections if it needs to do multiple things at the same time\r\n\r\nyes it is. Real database connection is used from pull per each `persist` / `remove`/ or any other `find` method call"
      },
      {
        "user": "swilliams-a3digital",
        "created_at": "2017-02-23T17:14:21Z",
        "body": "Thank you so much for the fast answer to my question.  You can close this issue.\r\n"
      },
      {
        "user": "zxr90",
        "created_at": "2017-04-22T06:48:05Z",
        "body": "> yes it is. Real database connection is used from pull per each persist / remove/ or any other find method call\r\n\r\nSorry to hijack this issue but i have a similar question while browsing the docs. Is there an option to control the max number of real database connection? If no, what is the default pool size?\r\n\r\nI'm coming off Activerecord and in Rails, they allow you to setup your own connection pool size when initializing the app."
      },
      {
        "user": "pleerock",
        "created_at": "2017-04-24T08:33:07Z",
        "body": "@zxr90 I have created separate issue for your issue. You can setup connection pool using \"extra\" option in connection driver options and pass there underlying driver options (for example if you are using mysql see mysql driver options on how to do this)"
      }
    ]
  },
  {
    "number": 294,
    "title": "Troubles with UglifyJS",
    "created_at": "2017-02-17T21:51:17Z",
    "closed_at": "2017-02-23T17:29:23Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/294",
    "body": "I use webpack and babel. I pass imported models to the connectionConfig. When I build the app for production with UglifyJsPlugin, an error occurs: `ER_NO_SUCH_TABLE: Table 'posts-app.e' doesn't exist`. How to avoid it without disabling the plugin? I found only one way: pass such options: ```  mangle: {\r\n    except: ['Post','User']\r\n  } ```",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/294/comments",
    "author": "SPAHI4",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-02-18T05:12:05Z",
        "body": "You have such error because table names are generated from class names, e.g. `Post` and `User`, but when you minify your code uglifier made your names `p` and `e` now. You have several choices: set explicit names for your tables, e.g. `@Entity(\"post\")` and `@Entity(\"user\")` or enable `mangle` (no need to specify entities, just mangle them all) or simply don't use uglify because its really pointless to use it and webpack on the backend."
      },
      {
        "user": "pleerock",
        "created_at": "2017-02-23T17:29:23Z",
        "body": "I guess I've answered your question and now this issue can be closed."
      },
      {
        "user": "SPAHI4",
        "created_at": "2017-02-23T18:25:05Z",
        "body": "@pleerock sure. Much thanks!"
      }
    ]
  },
  {
    "number": 238,
    "title": "How to save an int value to a foreign key ",
    "created_at": "2017-01-26T09:55:18Z",
    "closed_at": "2017-02-04T05:58:11Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/238",
    "body": "In the `Post` table, there is a one-to-one foreign key on `user_id` which links to the table `Members`, there is no problem with fetching the data like this:\r\n\r\n`[{ \"post_id\":1,\"user_id\":{\"user_name\":'Someone','user_id':4}, 'comment':'xxxxxx'}]`\r\n\r\nSuppose someone makes a comment, I get his comment and user id from express session, and want to save it to the `Post` table. Since `user_id` uses `Members` type, how can I save an int value to it? \r\nWould you please suggest a solution?\r\n\r\nHere's an example:\r\n\r\n````\r\n@Table()\r\nexport class Post {\r\n    @PrimaryGeneratedColumn()\r\n    post_id: number;\r\n\r\n    @OneToOne(type => Members,entity=>entity.user_id,{\r\n        cascadeRemove: true\r\n    })\r\n    @JoinColumn()\r\n    user_id: Members;\r\n\r\n    @Column()\r\n    comment:string;\r\n}\r\n\r\nexport class Members {\r\n    @PrimaryGeneratedColumn()\r\n    user_id: number;\r\n\r\n    @Column()\r\n    user_name:string;\r\n}\r\n````\r\n\r\n````\r\n    let post = new Post()\r\n    post.comment = \"sadsadsa\"\r\n    post.user_id = 44 <<=== type error!\r\n````\r\n\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/238/comments",
    "author": "laukaichung",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-01-26T10:52:26Z",
        "body": "you need to define both relation and id of the relation as a regular column. Example:\r\n\r\n```typescript\r\n@Table()\r\nexport class Post {\r\n    @PrimaryGeneratedColumn()\r\n    post_id: number;\r\n\r\n    @OneToOne(type => Members,entity=>entity.user_id)\r\n    @JoinColumn({ name: \"memberId\" })\r\n    member: Members;\r\n\r\n   @Column({  type: \"int\", nullable: true })\r\n   memberId: number;\r\n\r\n    @Column()\r\n    comment:string;\r\n}\r\n```\r\n"
      },
      {
        "user": "laukaichung",
        "created_at": "2017-01-26T16:00:23Z",
        "body": "@pleerock , I just did per your suggestion, I can save it to the table but \r\nit gives me this error/warning in the console: \r\n````\r\n(node:10665) UnhandledPromiseRejectionWarning: \r\nUnhandled promise rejection (rejection id: 1): \r\nError: Relation metadata for tag#user_id was not found.\r\n````\r\n````\r\n@Table()\r\nexport class Tag{\r\n\r\n    @OneToOne(type=>Members, entity=>entity.user_id,{onDelete:\"CASCADE\"})\r\n    @JoinColumn({name:'user_id'})\r\n    user_data:Members;\r\n\r\n    @Column({type:'int',nullable: true})\r\n    user_id:number;\r\n\r\n  \r\n}\r\n````\r\n\r\n"
      },
      {
        "user": "Tobias4872",
        "created_at": "2017-01-30T23:21:58Z",
        "body": "Not quite sure what you are trying to do. You have defined \"Post.user_id\" as type \"Members\" which obviously is not only an id. So, if you want to create a post, you will need to assign an instance of type \"Members\" to \"user_id\", so let's say you have two models like the following (please notice that I have changed the naming a bit.\r\n\r\n```\r\n@Table()\r\nexport class Member {\r\n    @PrimaryGeneratedColumn()\r\n    public userId: number;\r\n\r\n    @Column()\r\n    public userName: string;\r\n}\r\n\r\n@Table()\r\nexport class Post {\r\n    @PrimaryGeneratedColumn()\r\n    public postId: number;\r\n\r\n    @OneToOne(type => Member, (entity) => entity.userId,{\r\n        cascadeRemove: true,\r\n    })\r\n    @JoinColumn()\r\n    public user: Member;\r\n\r\n    @Column()\r\n    public comment: string;\r\n}\r\n```\r\n\r\nYou would then need to either create a new Member instance in advance or retrieve one from the db.\r\n\r\n```\r\n    const user = new Member();\r\n    user.userId = 1;\r\n    user.userName = \"Username\";\r\n\r\n    const memberRepo = connection.getRepository(Member);\r\n    await memberRepo.persist(user);\r\n\r\n    const post = new Post();\r\n    post.comment = \"Test\";\r\n    post.user = user;\r\n\r\n    const postRepo = connection.getRepository(Post);\r\n    await postRepo.persist(post);\r\n```\r\n\r\nLet me know if this helps.\r\n"
      },
      {
        "user": "vance",
        "created_at": "2017-09-20T17:13:43Z",
        "body": "If I use an existing `user:Member` entity, I get a violation of unique constraint when i update the 2nd post (since it uses the same `user` entity). How do a make a 2nd update to post?"
      },
      {
        "user": "Jood80",
        "created_at": "2021-05-12T17:32:21Z",
        "body": "These answers were absolutely helpful, thank you both @pleerock @Tobias4872 :pray: "
      }
    ]
  },
  {
    "number": 186,
    "title": "Single file @Table definition order is important",
    "created_at": "2017-01-10T05:24:30Z",
    "closed_at": "2017-01-10T10:08:48Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/186",
    "body": "It is worth nothing, that if you define all of your Entities (i.e. @Table classes) in a single file, that the order is important. If you reference a Entity as part of a relation (i.e. @OneToOne) before that referenced Entity is defined, you'll receive an error like below:\r\n\r\n```\r\n/Users/Danijel/projects/am/am-api/lib/model/model.js:175\r\n[1]     __metadata(\"design:type\", StoreBillingPlan)\r\n[1]                               ^\r\n[1]\r\n[1] ReferenceError: StoreBillingPlan is not defined\r\n[1]     at Object.<anonymous> (/Users/x/projects/am/am-api/lib/model/model.js:175:31)\r\n[1]     at Module._compile (module.js:571:32)\r\n[1]     at Object.Module._extensions..js (module.js:580:10)\r\n[1]     at Module.load (module.js:488:32)\r\n[1]     at tryModuleLoad (module.js:447:12)\r\n[1]     at Function.Module._load (module.js:439:3)\r\n[1]     at Module.require (module.js:498:17)\r\n[1]     at require (internal/module.js:20:19)\r\n[1]     at Object.<anonymous> (/Users/x/projects/am/am-api/lib/services/auth.js:10:17)\r\n[1]     at Module._compile (module.js:571:32)\r\n```\r\n\r\nIn my case, defining StoreBillingPlan before the above code was run solved my issue.  Is it possible to make order not important? \r\n\r\nNote: For those splitting Entities across files this shouldn't be an issue. ",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/186/comments",
    "author": "dcworldwide",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-01-10T10:08:48Z",
        "body": "No, its not possible. It is a language limitation and can't be avoided. Thats a dynamic nature of javascript. Its basically the same as:\r\n\r\n\r\n```typescript\r\nconsole.log(b); // will not work because b is not defined at this time\r\nlet a = 1;\r\nlet b = 2;\r\nconsole.log(a); // everything is fine because a is defined\r\n```\r\n\r\nSame rules applies to classes."
      },
      {
        "user": "dcworldwide",
        "created_at": "2017-01-10T10:59:00Z",
        "body": "Yeah I figured as much. Happy to modularise my code. "
      }
    ]
  },
  {
    "number": 149,
    "title": "AbstractTable doesnt work in inherited classes",
    "created_at": "2016-12-25T16:21:16Z",
    "closed_at": "2016-12-25T18:59:23Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/149",
    "body": "Hi all!\r\nI have problem with AbstractTable decorator. Error:\r\n_MissingPrimaryColumnError: Entity \"Post\" does not have a primary column. Primary column is required to have in all your entities. Use @PrimaryColumn decorator to add a primary column to your entity._\r\nFiles:\r\n**BasePost.ts**:\r\n```\r\nimport {PrimaryGeneratedColumn, Column} from \"typeorm\";\r\nimport {AbstractTable} from \"typeorm\";\r\n\r\n@AbstractTable()\r\nexport class BasePost {\r\n    @PrimaryGeneratedColumn()\r\n    id: number;\r\n\r\n    @Column()\r\n    title: string;\r\n}\r\n```\r\n**Post.ts**:\r\n```\r\nimport {Column, Table} from \"typeorm\";\r\nimport {BasePost} from \"./BasePost\";\r\n\r\n@Table(\"post\")\r\nexport class Post extends BasePost {\r\n    @Column()\r\n    text: string;\r\n}\r\n```\r\n**app.ts**:\r\n```\r\nimport \"reflect-metadata\";\r\nimport { createConnection } from \"typeorm\";\r\nimport { Post } from \"./entities/Post\";\r\n\r\ncreateConnection({\r\n  driver: {\r\n    type: \"postgres\",\r\n    host: \"host\",\r\n    port: 7755,\r\n    username: \"postgres\",\r\n    password: \"pass\",\r\n    database: \"testdatabase\"\r\n  },\r\n  entities: [\r\n    Post\r\n  ],\r\n  autoSchemaSync: true\r\n  }).then(connection => {\r\n    console.log('Good!');\r\n  })\r\n  .catch(reason => {\r\n    console.log(reason);\r\n});\r\n```\r\nWhat is wrong?\r\nNodeJS version: 7.3.0\r\nTypescript version: 2.1.4\r\nTypeORM version: 0.0.5",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/149/comments",
    "author": "CocaColaBear",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2016-12-25T18:46:34Z",
        "body": "Please include `BasePost` in a list of your `entities: [Post, BasePost]`"
      },
      {
        "user": "CocaColaBear",
        "created_at": "2016-12-25T18:59:23Z",
        "body": "@pleerock thanks a lot! :)"
      },
      {
        "user": "pleerock",
        "created_at": "2016-12-25T19:00:10Z",
        "body": "one star from you ;)"
      }
    ]
  },
  {
    "number": 142,
    "title": "innerJoinAndSelect with no matching rows results in rejected promise",
    "created_at": "2016-12-22T22:40:54Z",
    "closed_at": "2016-12-23T18:28:29Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/142",
    "body": "Hi,\r\n\r\nThere's a OneToMany relation between \"ent\" (one) and \"some_stuff\" (many).\r\n\r\nI'm doing something similar to this:\r\n\r\n```\r\nentRepository.createQueryBuilder('ent')\r\n\t.innerJoinAndSelect('ent.some_stuff', 'some_stuff')\r\n\t.getOne();\r\n```\r\n\r\nWhenever some_stuff has corresponding rows for ent, it works.\r\nWhenever there're no corresponding rows for ent, the promise is rejected.\r\n\r\nHow can I simply have some_stuff set to an empty array in ent whenever there're no corresponding rows instead of having the promise rejected?",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/142/comments",
    "author": "royibernthal",
    "comments": [
      {
        "user": "eduardoweiland",
        "created_at": "2016-12-23T00:36:09Z",
        "body": "If you want to get the result for `ent` when it does not have any `some_stuff`, you should use a `LEFT JOIN`. When doing an `INNER JOIN`, the database will not return the `ent` row if it does not have corresponding rows in the joined table.\r\n\r\n@royibernthal can you try using `leftJoinAndSelect` and see if it works?\r\n\r\n```typescript\r\nentRepository.createQueryBuilder('ent')\r\n\t.leftJoinAndSelect('ent.some_stuff', 'some_stuff')\r\n\t.getOne();\r\n```"
      },
      {
        "user": "royibernthal",
        "created_at": "2016-12-23T09:15:05Z",
        "body": "True, works.\r\n\r\nIs that the only difference between innerJoinAndSelect and leftJoinAndSelect?\r\nIs there a reason not to always use leftJoinAndSelect?"
      },
      {
        "user": "pleerock",
        "created_at": "2016-12-23T13:01:38Z",
        "body": "yes. same applies for `INNER JOIN` vs `LEFT JOIN` in SQL."
      },
      {
        "user": "royibernthal",
        "created_at": "2016-12-24T00:48:41Z",
        "body": "Thanks"
      }
    ]
  }
]