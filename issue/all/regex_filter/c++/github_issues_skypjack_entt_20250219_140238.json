[
  {
    "number": 1181,
    "title": "Runtime Eror with groups",
    "created_at": "2024-10-05T16:50:43Z",
    "closed_at": "2024-10-12T17:02:24Z",
    "labels": [
      "question",
      "solved"
    ],
    "url": "https://github.com/skypjack/entt/issues/1181",
    "body": "I get this runtime error: \r\n```Assertion failed: ((std::all_of(groups.cbegin(), groups.cend(), [](const auto &data) { return !(data.second->owned(type_id<Owned>().hash()) || ...); })) && (\"Conflicting groups\")), file ...file/path/to/source...\\entt\\entity/registry.hpp, line 1105```\r\n\r\ncode:\r\n```EntityManager::GetWorld().group<MeshInstance>(entt::get<Transform>).size()```\r\nEntityManager::GetWorld() basically returns the registry",
    "comments_url": "https://api.github.com/repos/skypjack/entt/issues/1181/comments",
    "author": "MineStorm999",
    "comments": [
      {
        "user": "skypjack",
        "created_at": "2024-10-07T10:23:01Z",
        "body": "Groups cannot share ownership of a same type. In this case, you're violating their rules. You have another group somewhere taking ownership of `MeshInstance`. Thus, the assert."
      },
      {
        "user": "MineStorm999",
        "created_at": "2024-10-07T11:58:35Z",
        "body": "Ok is it the same with Views?"
      },
      {
        "user": "skypjack",
        "created_at": "2024-10-07T12:46:28Z",
        "body": "No, they don't _own_ anything."
      },
      {
        "user": "MineStorm999",
        "created_at": "2024-10-07T17:58:44Z",
        "body": "Thanks a lot "
      }
    ]
  },
  {
    "number": 1170,
    "title": "Feature request: Make 'entt::null' available in <entt/entity/fwd.hpp>",
    "created_at": "2024-08-25T08:44:26Z",
    "closed_at": "2024-09-02T15:44:13Z",
    "labels": [
      "invalid",
      "question",
      "solved"
    ],
    "url": "https://github.com/skypjack/entt/issues/1170",
    "body": "```cpp\r\n#include <entt/entity/fwd.hpp>\r\n\r\nstruct Thing\r\n{\r\n\tentt::entity target { entt::null }; // ERROR : Can not resolve symbol 'null'\r\n};\r\n```\r\n\r\nWould be nice if this worked.\r\nCheers!\r\nKind regards /kraybit\r\n\r\nPS. Or I'm doing this wrong, of course. Then please enlighten me : ) ",
    "comments_url": "https://api.github.com/repos/skypjack/entt/issues/1170/comments",
    "author": "kraybit",
    "comments": [
      {
        "user": "skypjack",
        "created_at": "2024-08-26T10:00:25Z",
        "body": "You should include `entity.hpp` for that, which is another small and self-contained file that contains only entity related stuff.\r\nThe problem with including `entt::null` into `fwd.hpp` is that it needs the `entt::null_t` type, which is out of scope for a forward file."
      }
    ]
  },
  {
    "number": 1150,
    "title": "Iterating over all entities",
    "created_at": "2024-06-21T11:22:45Z",
    "closed_at": "2024-06-21T12:39:14Z",
    "labels": [
      "question",
      "solved"
    ],
    "url": "https://github.com/skypjack/entt/issues/1150",
    "body": "For some housekeeping tasks in a game after a level is complete I wish to iterate over all entities in a registry and delete every entity that does not have the persistence compontnt.\r\n\r\n`registry::each` would be the function that I wanted to use since that ahs been widely noted as the function for this exact task but it appears that in version `3.13.2` this function is no longer available on the registry.\r\nWhat replaced this functionality or how do I createh the desired behavior with this version of the library?\r\n\r\n```\r\n---\\sources\\GameplayScreen.cpp(208): error C2039: 'each': is not a member of 'entt::basic_registry<entt::entity,std::allocator<Entity>>'\r\n        with\r\n        [\r\n            Entity=entt::entity\r\n        ]\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/skypjack/entt/issues/1150/comments",
    "author": "KiviTK",
    "comments": [
      {
        "user": "skypjack",
        "created_at": "2024-06-21T11:34:35Z",
        "body": "Something along this line: `for(auto entity: registry.view<entt::entity>(entt::exclude<T>)) { ... }`.\r\nEntities have their own (fully customizable) storage now, as it happens with the components.\r\nThis means that they work with views, they support signals and mixins, and so on. üëç "
      },
      {
        "user": "KiviTK",
        "created_at": "2024-06-21T12:39:14Z",
        "body": "I see, makes complete sense, I was jus tlooking for each so I didnt figure this on my own. Thanks a lot for the quick reply."
      }
    ]
  },
  {
    "number": 1144,
    "title": "Get a view of components with a certain trait",
    "created_at": "2024-05-11T16:29:49Z",
    "closed_at": "2024-05-30T06:16:25Z",
    "labels": [
      "question",
      "solved"
    ],
    "url": "https://github.com/skypjack/entt/issues/1144",
    "body": "As the title suggest, is there anyway to get a view with different types of components, but that they match a certain compile time predicate?\r\n\r\nFor example, lets say I have a trait `IsEnergy`\r\n\r\n```\r\ntemplate <typename T>\r\nstruct IsEnergy : public std::false_type{};\r\n\r\ntemplate <>\r\nstruct IsEnergy<A> : public std::true_type{};\r\n\r\ntemplate <>\r\nstruct IsEnergy<B> : public std::true_type{};\r\n```\r\n\r\nIs there anyway I can get all the entities that have components A or B?",
    "comments_url": "https://api.github.com/repos/skypjack/entt/issues/1144/comments",
    "author": "jjcasmar",
    "comments": [
      {
        "user": "skypjack",
        "created_at": "2024-05-13T08:01:56Z",
        "body": "> is there anyway to get a view with different types of components, but that they match a certain compile time predicate?\r\n\r\nNo, there isn't.\r\n\r\n> Is there anyway I can get all the entities that have components A or B?\r\n\r\nThe simplest solution is to redesign your component and turn the template parameter into a member, so as to have a single type to filter later on.\r\nAnother option is that of using listeners for `IsEnergy<T>` pools that fill a `storage<void>` pool somewhere else with the entities of interest. Then you can use the latter to construct your view.\r\nYou can also refine the last approach with a mixin to make it transparent/automatic. All mixins receive the registry after all and they know when an element is emplaced or erased, so ü§∑‚Äç‚ôÇÔ∏è the sigh mixin is an example to take inspiration from eventually.\r\n"
      },
      {
        "user": "skypjack",
        "created_at": "2024-05-30T06:16:25Z",
        "body": "I assume this was answered. Feel free to continue the discussion here if this isn't the case. Thanks."
      }
    ]
  },
  {
    "number": 1140,
    "title": "Acecss components of an entity, without giving full registry access",
    "created_at": "2024-04-28T15:54:46Z",
    "closed_at": "2024-05-06T11:43:15Z",
    "labels": [
      "question",
      "solved"
    ],
    "url": "https://github.com/skypjack/entt/issues/1140",
    "body": "I have a function to initialize an entity with a bunch of components\r\n\r\nMy first attempt has been something like receiving only an entity, but that doesn't work. I have no way to create new components for that entity\r\n\r\n```\r\ntemplate <>\r\nvoid initialize<SomeObjectType>(entt::entity entity) {\r\n    // Initialize components for this entity\r\n    // but really can initialize anything, I can't store the components in the registry\r\n}\r\n```\r\n\r\nSo I add the registry to the function signature\r\n\r\n```\r\ntemplate <>\r\nvoid initialize<SomeObjectType>(entt:registry reg, entt::entity entity) {\r\n    // Initialize components for this entity\r\n    // This works fine, but it has too much access\r\n}\r\n```\r\n\r\nThis works from a usability perspective, but it gives the control full access to the whole registry, so now all the \"encapsulation\" is gone. Someone implementing that function might make something wrong with the registry, so I will have to double check every commited code...\r\n\r\nIs there anyway to allow to create new components or modify existing components but only for the particular entity I passed to the function? For modifying it might be possible to receive a `view` (althought getting the type right might be tricky), but how can I initialize the components if I only receive the entity?\r\n\r\n",
    "comments_url": "https://api.github.com/repos/skypjack/entt/issues/1140/comments",
    "author": "jjcasmar",
    "comments": [
      {
        "user": "skypjack",
        "created_at": "2024-04-29T11:20:43Z",
        "body": "Something like the `handle` class maybe? It has a method to get the registry though. However, you can use it as an example to implement a custom solution. Does it work for you?"
      },
      {
        "user": "jjcasmar",
        "created_at": "2024-04-29T11:35:37Z",
        "body": "I looked into the handle, and see that it had access to the entity and to the registry, so it doesn't really solves my issue. I guess I could inherit from `handle` and disable the registry access. Would you accept a contribute for this?"
      },
      {
        "user": "skypjack",
        "created_at": "2024-04-30T08:19:19Z",
        "body": "It would be a breaking change, so no. I don't plan to make the `registry` method private in that class. I'm sorry.\r\nHowever, you can inherit or take inspiration from it and do whatever you want that fits your design. üëç "
      },
      {
        "user": "jjcasmar",
        "created_at": "2024-04-30T08:29:48Z",
        "body": "I wasnt thinking about breaking the current design of the class, that would be terrible. "
      },
      {
        "user": "jjcasmar",
        "created_at": "2024-04-30T08:38:37Z",
        "body": "I was thinking on adding a new template parameter to the handle class, and instantiate the entity() and registry() methods depending on that template parameter. But I have checked the code and the basic_handle already has a ...Scope template parameter, which makes it impossible to add a new parameter between the Registry type and the Scope without making a breaking change. \r\n"
      },
      {
        "user": "Innokentiy-Alaytsev",
        "created_at": "2024-04-30T08:41:22Z",
        "body": "I guess Michele suggests doing whatever you want/need in your code base. Adding a new type that is essentially `handle`, but not quite, or complicating the `handle` itself is not a great plan maintenance-wise."
      },
      {
        "user": "jjcasmar",
        "created_at": "2024-04-30T08:49:56Z",
        "body": "Yeah, I think so. \r\nI still think the functionality will be a nice addition to EnTT, I have found my self several times trying to restrict access to the registry. But if there is not enough traction for adding it, we can just close the issue. \r\n\r\nThanks for the answers!"
      },
      {
        "user": "skypjack",
        "created_at": "2024-04-30T09:08:11Z",
        "body": "> I have found my self several times trying to restrict access to the registry\r\n\r\nWhat you're trying to do isn't restricting access to the registry though.\r\nInstead, you're trying to emulate the EC model of Unity or the like, where the entity is the key actor and you can do everything by means of its API.\r\nECS models are slightly different. Systems are meant to operate on a whole set of entities and components rather than on a single entity. Whit this in mind, you can already restrict a system's scope by passing storage classes or views to it.\r\nThat is why there isn't much traction probably. This is a pretty uncommon request. üôÇ "
      },
      {
        "user": "jjcasmar",
        "created_at": "2024-04-30T09:21:55Z",
        "body": "The issue is not when operating on the entities, for that I use views. The issue comes when creating entities. In my use case, I am trying to create an entity with the needed components to simulate a garment. I need to add several components (Mesh, Collider...).\r\n\r\nRight now I have a function which is in charge of creating the components for the entity, but to do so, I need to pass the whole registry, so inside that function, which should only be allowed to create the components I want, now I can modify all the registry. That is why I was thinking on a way of being able to add components to a single entity, without giving full access to the registry. \r\n\r\nIf there is a better way to initialize the entities with its components, I am all ears"
      },
      {
        "user": "Green-Sky",
        "created_at": "2024-04-30T15:14:08Z",
        "body": "Passing in the \"whole\" `registry` is not an issue in your case.\r\n\r\nHowever I see 2 options for you that can enforce this form of separation.\r\n\r\n1. Like @skypjack said, instead of passing in the `registry` to the creation function, you can only pass in the `entity` and all the `storage`s (component pools) that you require.\r\n2. You already found the `Scope... template` on the `handle` :), while this still would allow to access the `registry field` of a `handle`, it would allow you to restrict which `component types` (`storage`s) can be accessed through it's interface. This feels more like the solution you want. You can also declare an alias for the special restricted handle type."
      },
      {
        "user": "jjcasmar",
        "created_at": "2024-04-30T15:58:47Z",
        "body": "Why do you say its not an issue in my case? I am thinking on a teammate doing something wrong like\r\n\r\n```\r\nvoid initialize_garment(entt::registry &reg, entt::entity garment) {\r\n    registry.emplace<Mesh>(garment);\r\n    registry.emplace<Collider>(garment);\r\n    registry.emplace<Material>(garment);\r\n    ...\r\n    auto meshes = reg.view<Mesh>(); // Wrong, we are also accessing already existing meshes\r\n}\r\n```\r\n\r\nI agree the programmer of that code is doing something really bad, and that code will never pass code review. But restricting what the programmer can use in the first place will solve the issue. \r\n\r\nHow would you use the component pools in this case? I have never done something like that. \r\n\r\nThe option of restricting the component types of the handle doesn't totally solve the issue (although it definitely improves it). I can still access entities which have one of the restricted types. \r\n\r\nMaybe there is a third solution. Create entities with a \"to be built\" component and pass a view to those entities. "
      },
      {
        "user": "skypjack",
        "created_at": "2024-05-01T09:05:19Z",
        "body": "I see your point. However, as you correctly pointed out, the handle class cannot be changed easily in this sense.\r\nThat said, if all you want is to restrict access when creating new entities, a small utility with a minimal interface is bettter suited probably. Something like this (completely out of my mind and just to give you a grasp of what I mean):\r\n```cpp\r\nstruct my_utility {\r\n    my_utility(entt::registry &ref, entt::entity target)\r\n        : reg{&ref}, entity{target}\r\n    {}\r\n\r\n    template<typename Type>\r\n    decltype(auto) emplace() { return reg->emplace<Type>(entity); }\r\n\r\nprivate:\r\n    entt::registry *reg;\r\n    entt::entity entity;\r\n```\r\nThat's all. You can pass it as a function argument and use it in the body as:\r\n```cpp\r\nMesh &mesh = util.emplace<Mesh>();\r\n// fill the mesh as needed and proceed with other components\r\n```\r\nI mean, for a grand total of 9 loc you've a fully encapsulated emplace function, which is what you're looking for if I get it correctly? If this is the case, it sounds like a good compromise to me. ü§∑‚Äç‚ôÇÔ∏è \r\n\r\n> How would you use the component pools in this case?\r\n\r\nIt wouldn't fit your requirements anyway. If you pass a pool to a function, your teammate can still remove random elements from it or iterate all the instances in it and do something crazy with them.\r\n\r\n> Create entities with a \"to be built\" component and pass a view to those entities.\r\n\r\nI personally use something similar actually. Sort of _setup this entity as concept C_ component that is handled by a specific system at the _right_ point in the loop (for some definitions of right ofc üòÖ).\r\nThis doesn't solve your _issue_ though. My system still receives the whole registry to setup things."
      },
      {
        "user": "jjcasmar",
        "created_at": "2024-05-01T09:19:10Z",
        "body": "I like that small utility class, and it toally solves the issue. Probably it also need a variadic emplace() method to create the elements, but yeah, something like totally works. \r\n\r\nI was probably overthinking, since its only for creation, I only need the emplace functionality."
      },
      {
        "user": "skypjack",
        "created_at": "2024-05-02T06:32:13Z",
        "body": "Yeah, it was just an example to give you a grasp. I don't even know if it compiles fine. üôÇ \r\nI'm glad it helped btw. Let me know if we can consider the issue closed. Thanks. üëç "
      }
    ]
  },
  {
    "number": 1139,
    "title": "Handling large tilemap",
    "created_at": "2024-04-18T15:22:35Z",
    "closed_at": "2024-05-02T13:57:21Z",
    "labels": [
      "question",
      "solved"
    ],
    "url": "https://github.com/skypjack/entt/issues/1139",
    "body": "Hey! \r\n\r\nCurrently i am working on tilemap based 2D/3D game, where world is made of voxels, something conceptually similiar to Core Keeper. The thing is that i want to be able to handle quite large maps. The obvious choice is to divide scene into smaller chunks, so i will render & calculate only the closest ones - pretty cliche. \r\n\r\nUp until now i was using a single EnTT registry per scene, and it worked quite well. Now i need to implement this chunking mechanism, and i have no idea how to do it. The only ways i can see is to:\r\n\r\n- create multiple registers - one per chunk, and maybe main one - that will keep entities describing those chunks. \r\n- each chunk has its own entity type storage, identified for example by its coords. \r\n\r\nWhat do you suggest? EnTT is awesome and its pretty easy to use in a simple scenarios, however each time i am trying to dig deeper into its guts and functionalities i am being pushed away...",
    "comments_url": "https://api.github.com/repos/skypjack/entt/issues/1139/comments",
    "author": "pawelKapl",
    "comments": [
      {
        "user": "skypjack",
        "created_at": "2024-04-18T16:26:03Z",
        "body": "Do you plan to run all systems on all chunks no matter what or, for example, you want to run full power on central and surrounding chunks while you run less systems as you get far from the player position?"
      },
      {
        "user": "pawelKapl",
        "created_at": "2024-04-18T19:03:59Z",
        "body": "Yeah so second option, chunk with player and surrounding chunks - most probably all the calculations like physics, ai, rendering etc. Other chunks - most probably no operations at all, or almost no operations. Thanks for such quick response! "
      },
      {
        "user": "skypjack",
        "created_at": "2024-04-19T06:50:26Z",
        "body": "You can also have a local registry and a global one for things like the player, an inventory and so on.\r\nThere isn't the _right_ answer, just a bunch of approaches that work fine. Your use case should guide you then. üôÇ "
      },
      {
        "user": "pawelKapl",
        "created_at": "2024-04-19T08:37:53Z",
        "body": "Yeah, good point. I could create one global scene registry, for handling stuff like player, craft, inventory, this registry would also probably keep references to chunks being part of a particular scene. So in systems i would most probably do smth like:\r\n\r\n```\r\nfor (auto chunk : globalRegistry.view<Chunk>())\r\n       if (chunk.loaded) chunk.registry.get<Tile/Decoration/Item>().doStuff();\r\n```"
      },
      {
        "user": "skypjack",
        "created_at": "2024-04-19T10:45:14Z",
        "body": "Another possibility, yeah. I think your question was answered. üôÇ "
      },
      {
        "user": "pawelKapl",
        "created_at": "2024-04-19T10:49:47Z",
        "body": "Yeah, thanks a LOT, apparently needed someone to just confirm that my ideas are not out of this planet! ;) "
      },
      {
        "user": "skypjack",
        "created_at": "2024-04-19T10:51:19Z",
        "body": "You're welcome. The discord server is another good place for that in case. üëç "
      }
    ]
  },
  {
    "number": 1135,
    "title": "Working with multiple storages for the same type and preparing a view for each of the storages",
    "created_at": "2024-04-05T04:03:17Z",
    "closed_at": "2024-05-02T14:04:45Z",
    "labels": [
      "question",
      "solved"
    ],
    "url": "https://github.com/skypjack/entt/issues/1135",
    "body": "There a couple of different posts that are similar to this. I apologize if this seems like a duplicate but I am not clear on how to achieve the following:\r\n\r\nI have a component `UserDefinedStruct` that I would like to add to an Entity multiple times where the component is differentiated by an index that is generated at runtime.\r\n\r\n```\r\nPool<UserDefinedStruct>(0)\r\nPool<UserDefinedStruct>(1)\r\nPool<UserDefinedStruct>(2)\r\n...\r\n```\r\n\r\nWhich then allows an `entity` to have the component `UserDefinedStruct` multiple times as long as they have a different index.\r\n\r\nI would then like to `view` each pool such that I get `UserDefinedStruct&` and the `entity` that the component is associated with.\r\n\r\nI realize this is not a valid call in `entt`, but something like:\r\n```cpp\r\nconst int runtime_id_from_somewhere = Get_RuntimeId();\r\nreg.view<UserDefinedStruct>(runtime_id_from_somewhere).each(...)\r\n```",
    "comments_url": "https://api.github.com/repos/skypjack/entt/issues/1135/comments",
    "author": "samaursa",
    "comments": [
      {
        "user": "skypjack",
        "created_at": "2024-04-05T12:51:08Z",
        "body": "I think it's more similar to:\r\n```cpp\r\nauto &storage = registry.storage<UserDefinedStruct>(id);\r\nstorage.emplace(entity, args...);\r\n```\r\nFor when you want to emplace/erase entities for example, while you can do this for the view:\r\n```cpp\r\nentt::basic_view ud_view{registry.storage<UserDefinedStruct>(id));\r\nfor(auto [entt, my_t, my_ud]: (registry.view<T>() | ud_view)) { ... }\r\n```\r\nIs this on the line of what you're looking for? Not sure I got your request. üòÖ "
      },
      {
        "user": "samaursa",
        "created_at": "2024-04-07T00:17:05Z",
        "body": "@skypjack thanks, this is pretty much exactly what I was looking for. I'll try this out and update here."
      },
      {
        "user": "skypjack",
        "created_at": "2024-04-23T13:18:06Z",
        "body": "I'm marking this issue as solved. Feel free to continue the discussion here if it is not. üëç "
      }
    ]
  },
  {
    "number": 1116,
    "title": "'each': is not a member of 'entt::basic registry<entt::entity,std::allocator<Entity>>",
    "created_at": "2024-02-25T11:34:04Z",
    "closed_at": "2024-02-27T18:48:08Z",
    "labels": [
      "question",
      "solved"
    ],
    "url": "https://github.com/skypjack/entt/issues/1116",
    "body": "`#include \"SceneHierarchyPanel.h\"\r\n\r\n#include <imgui.h>\r\n\r\n#include \"Whiskerscape/Scene/Components.h\"\r\n\r\nnamespace Whiskerscape {\r\n\r\n\tSceneHierarchyPanel::SceneHierarchyPanel(const Ref<Scene>& context)\r\n\t{\r\n\t\tSetContext(context);\r\n\t}\r\n\r\n\tvoid SceneHierarchyPanel::SetContext(const Ref<Scene>& context)\r\n\t{\r\n\t\tm_Context = context;\r\n\t}\r\n\r\n\tvoid SceneHierarchyPanel::OnImGuiRender()\r\n\t{\r\n\t\tImGui::Begin(\"Scene Hierarchy\");\r\n\r\n\t\t\r\n\t\tm_Context->m_Registry.each([&](auto entityID)\r\n\t\t\t{\r\n\t\t\t\tEntity entity{ entityID , m_Context.get() };\r\n\t\t\t\tDrawEntityNode(entity);\r\n\t\t\t});\r\n\r\n\t\tImGui::End();\r\n\t}\r\n\r\n\tvoid SceneHierarchyPanel::DrawEntityNode(Entity entity)\r\n\t{\r\n\t\tauto& tag = entity.GetComponent<TagComponent>().Tag;\r\n\r\n\t\tImGuiTreeNodeFlags flags = ((m_SelectionContext == entity) ? ImGuiTreeNodeFlags_Selected : 0) | ImGuiTreeNodeFlags_OpenOnArrow;\r\n\t\tbool opened = ImGui::TreeNodeEx((void*)(uint64_t)(uint32_t)entity, flags, tag.c_str());\r\n\t\tif (ImGui::IsItemClicked())\r\n\t\t{\r\n\t\t\tm_SelectionContext = entity;\r\n\t\t}\r\n\r\n\t\tif (opened)\r\n\t\t{\r\n\t\t\tImGuiTreeNodeFlags flags = ImGuiTreeNodeFlags_OpenOnArrow;\r\n\t\t\tbool opened = ImGui::TreeNodeEx((void*)9817239, flags, tag.c_str());\r\n\t\t\tif (opened)\r\n\t\t\t\tImGui::TreePop();\r\n\t\t\tImGui::TreePop();\r\n\t\t}\r\n\r\n\t}\r\n\r\n}`",
    "comments_url": "https://api.github.com/repos/skypjack/entt/issues/1116/comments",
    "author": "iojuedioe9rd",
    "comments": [
      {
        "user": "skypjack",
        "created_at": "2024-02-26T07:23:33Z",
        "body": "`registry.each(...)` doesn't exist anymore since a while ago. You can use a view as you do with the components:\r\n```cpp\r\nfor(auto entt: registry.view<entt::entity>()) {\r\n    ...\r\n}\r\n```"
      }
    ]
  },
  {
    "number": 1110,
    "title": "Combine snapshot and meta features",
    "created_at": "2024-02-02T11:35:14Z",
    "closed_at": "2024-02-07T17:46:38Z",
    "labels": [
      "question",
      "solved"
    ],
    "url": "https://github.com/skypjack/entt/issues/1110",
    "body": "Hey\r\nI just started using the library and I love it. I have not fully understood how to use the meta feature but in below code I am trying to serialize components with the help of the meta information. There must be a better way to do what I am trying to do inside the Archive class below. Can you please help me understand how to achive the same thing but without having to compare strings?\r\n\r\n`\r\n\r\n\tstruct SomeStruct\r\n\t{\r\n\t\tfloat x = 0.f;\r\n\t\tfloat y = 0.f;\r\n\t\tfloat z = 0.f;\r\n\t\tbool b = false;\r\n\t\tuint8_t u8 = 0;\r\n\t\tuint16_t u16 = 0;\r\n\r\n\r\n\t\tSomeStruct(float in_x, float in_y, float in_z, bool in_b, uint8_t in_u8, uint16_t in_u16)\r\n\t\t\t: x(in_x), y(in_y), z(in_z), b(in_b), u8(in_u8), u16(in_u16)\r\n\t\t{\r\n\t\t}\r\n\t};\r\n\r\n\ttemplate<typename T>\r\n\tclass BitPacker\r\n\t{\r\n\tpublic:\r\n\t\tBitPacker(T& storage)\r\n\t\t{}\r\n\r\n\t\ttemplate<typename T>\r\n\t\tvoid serialize(T value) \r\n\t\t{}\r\n\t};\r\n\r\n\r\n\ttemplate<typename T>\r\n\tclass Archive\r\n\t{\r\n\tpublic:\r\n\t\tArchive(T& storage)\r\n\t\t\t: m_bitPacker(storage)\r\n\t\t{}\r\n\r\n\t\tvoid operator()(std::underlying_type_t<entt::entity> size) \r\n\t\t{}\r\n\r\n\t\tvoid operator()(entt::entity entity) \r\n\t\t{}\r\n\r\n\t\ttemplate<typename T>\r\n\t\tvoid operator() (const T& component)\r\n\t\t{\r\n\t\t\tentt::meta_any any(component);\r\n\r\n\t\t\tfor (auto&& key_value : any.type().data())\r\n\t\t\t{\r\n\t\t\t\tauto member = key_value.second.get(component);\r\n\t\t\t\tauto type = member.type();\r\n\r\n\t\t\t\tif (type.info().name() == \"bool\")\r\n\t\t\t\t{\r\n\t\t\t\t\tstd::cout << \"bool value \" << member.cast<bool>() << std::endl;\r\n\t\t\t\t\tm_bitPacker.serialize(member.cast<bool>());\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (type.info().name() == \"unsigned char\")\r\n\t\t\t\t{\r\n\t\t\t\t\tstd::cout << \"uint8_t value \" << member.cast<uint8_t>() << std::endl;\r\n\t\t\t\t\tm_bitPacker.serialize(member.cast<uint8_t>());\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (type.info().name() == \"unsigned short\")\r\n\t\t\t\t{\r\n\t\t\t\t\tstd::cout << \"uint16_t value \" << member.cast<uint16_t>() << std::endl;\r\n\t\t\t\t\tm_bitPacker.serialize(member.cast<uint16_t>());\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (type.info().name() == \"float\")\r\n\t\t\t\t{\r\n\t\t\t\t\tstd::cout << \"float value \" << member.cast<float>() << std::endl;\r\n\t\t\t\t\tm_bitPacker.serialize(member.cast<float>());\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\tprivate:\r\n\t\tBitPacker<T> m_bitPacker;\r\n\t};\r\n\r\n\tint main()\r\n\t{\r\n\t\tusing namespace entt::literals;\r\n\t\r\n\t\tentt::meta<SomeStruct>()\r\n\t\t\t.type(entt::type_hash<SomeStruct>::value())\r\n\t\t\t.data<&SomeStruct::x>(\"x\"_hs)\r\n\t\t\t.data<&SomeStruct::y>(\"y\"_hs)\r\n\t\t\t.data<&SomeStruct::y>(\"z\"_hs)\r\n\t\t\t.data<&SomeStruct::b>(\"b\"_hs)\r\n\t\t\t.data<&SomeStruct::u8>(\"u8\"_hs)\r\n\t\t\t.data<&SomeStruct::u16>(\"u16\"_hs);\r\n\r\n\t\tentt::registry registry;\r\n\t\tauto entity1 = registry.create();\r\n\t\tregistry.emplace<SomeStruct>(entity1, 0.f, 0.f, 0.f, false, 0, 0);\r\n\r\n\t\tauto entity2 = registry.create();\r\n\t\tregistry.emplace<SomeStruct>(entity2, 10.f, 10.f, 10.f, true, 10, 1222);\r\n\r\n\t\tstd::stringstream stream;\r\n\t\tArchive<std::stringstream> archive(stream);\r\n\t\r\n\t\tentt::snapshot{ registry }\r\n\t\t\t//.get<entt::entity>(archive)\r\n\t\t\t.get<SomeStruct>(archive);\r\n\r\n\t\treturn 0;\r\n\t}\r\n\r\n`",
    "comments_url": "https://api.github.com/repos/skypjack/entt/issues/1110/comments",
    "author": "bookmagnus",
    "comments": [
      {
        "user": "skypjack",
        "created_at": "2024-02-04T22:42:56Z",
        "body": "> Can you please help me understand how to achive the same thing but without having to compare strings?\r\n\r\nDo you mean here? `type.info().name() == \"bool\"`.\r\nYou can use the compile time hash for that, as in `type.info().hash() == entt::type_id<Type>().hash()`.\r\n\r\nAlso note that you're copying the object here: `entt::meta_any any(component);`.\r\nHowever, `meta_any` also supports creating references to elements: `entt::meta_any any = entt::forward_as_meta(component);`.\r\nThat said, you don't have to wrap the element in an `meta_any` object at all. Just use the meta type directly:\r\n```cpp\r\nfor (auto&& key_value : entt::resolve<Type>().data()) {\r\n    ...\r\n}\r\n```"
      },
      {
        "user": "bookmagnus",
        "created_at": "2024-02-07T17:46:04Z",
        "body": "Great thanks for the help."
      }
    ]
  },
  {
    "number": 1094,
    "title": "One meta c++ class, many meta_type",
    "created_at": "2023-12-10T17:06:57Z",
    "closed_at": "2023-12-11T10:07:55Z",
    "labels": [
      "question",
      "solved"
    ],
    "url": "https://github.com/skypjack/entt/issues/1094",
    "body": "Hi!\r\nI'm trying to create meta_types for my Components from Lua scripts. I thought it would be possible to do it like this\r\n```cpp\r\nvoid ScriptingManager::RegisterScriptComponents()\r\n    {\r\n        for (auto& [scriptAsset, luaTable]  : m_Components)\r\n        {\r\n            entt::hashed_string hashedName{scriptAsset->GetName().c_str()};\r\n            entt::meta<sol::table>()\r\n            .type(hashedName)\r\n            .func<&add_component_to_view<sol::table>>(\"add_component_to_view\"_hs)\r\n            .func<&exclude_component_from_view<sol::table>>(\"exclude_component_from_view\"_hs)\r\n            .func<&add_component<sol::table>>(\"add_component\"_hs)\r\n            .func<&has_component<sol::table>>(\"has_component\"_hs)\r\n            .func<&get_component<sol::table>>(\"get_component\"_hs)\r\n            .func<&remove_component<sol::table>>(\"remove_component\"_hs);\r\n\r\n            entt::meta_type metaType = entt::resolve(hashedName);\r\n            entt::id_type typeId = metaType.id();\r\n            Log::Debug(\"{0} {1}\", scriptAsset->GetName(), typeId);\r\n            \r\n            luaTable.set_function(\"type_id\", [typeId]{ return typeId;});\r\n        }\r\n    }\r\n```\r\n\r\nHowever, as I can see after first ```entt::meta<sol::table>()``` it registers meta tpye with first id and does not change it or creates new types with other type_ids. Is there any way to register many meta_types using same class in temlate arguments?",
    "comments_url": "https://api.github.com/repos/skypjack/entt/issues/1094/comments",
    "author": "4yvakZ",
    "comments": [
      {
        "user": "Innokentiy-Alaytsev",
        "created_at": "2023-12-11T08:57:25Z",
        "body": "No, you cannot, because of how meta-types are registered internally. Basically, the registered type is used as a tag for some static functions and stuff, and you can only have one static functions instantiated for the type. You can do _kinda_ what you want if you wrap your script type into some struct or create an inherited type for each of your script kinds."
      },
      {
        "user": "4yvakZ",
        "created_at": "2023-12-11T10:07:55Z",
        "body": "Thank you!\r\nUnfortunately, I'm trying to create Components directly from Lua without c++ class/struct for every component, to avoid recompilitions after addition of new component. Seems like I need an other solution for it ;)"
      },
      {
        "user": "Innokentiy-Alaytsev",
        "created_at": "2023-12-12T07:50:49Z",
        "body": "Look into named pools."
      }
    ]
  },
  {
    "number": 1084,
    "title": "Is there a way to retrieve a view with at least one of the specified components?",
    "created_at": "2023-10-23T16:19:17Z",
    "closed_at": "2023-10-24T06:54:53Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/skypjack/entt/issues/1084",
    "body": "I am looking through the crash course, and the one thing I found closest to what I need is a view pack. Would this work?\r\nAlso curious about how EnTT works with components with inheritance. Would `registry.view<base>();` yield all entities containing base/derived components?",
    "comments_url": "https://api.github.com/repos/skypjack/entt/issues/1084/comments",
    "author": "kewyj",
    "comments": [
      {
        "user": "skypjack",
        "created_at": "2023-10-24T06:22:19Z",
        "body": "> Is there a way to retrieve a view with at least one of the specified components?\r\n\r\nWhat does it mean _a view with at least one of the specified components_? As if it were an _or_ rather than an _and_?\r\n\r\n> Would registry.view<base>(); yield all entities containing base/derived components?\r\n\r\nDefinitely no. Stop thinking in terms of hierarchies when it comes to using an ECS model."
      },
      {
        "user": "kewyj",
        "created_at": "2023-10-24T06:47:49Z",
        "body": "> As if it were an or rather than an and?\r\n\r\nYes exactly that! \r\n"
      },
      {
        "user": "skypjack",
        "created_at": "2023-10-24T06:53:01Z",
        "body": "Then no, I'm sorry. Views return only the entities that have all the elements.\r\nIf you want those that have at least one of components and you want them only once, probably the best is to iterate multiple views separately and put the entities in a set.\r\nHowever, this really, really, **really** smells of an XY-problem. Something like _I have states idle and jump and I want to find the entities that have a state, no matter what_. Just rethink your design. You don't need an _or-like_ view here. You just need to refactor your component types and probably a more ECS-y thinking. üëç "
      },
      {
        "user": "kewyj",
        "created_at": "2023-10-24T06:54:38Z",
        "body": "Hmm, ok! I'll try to rethink my approach. Thanks so much!"
      }
    ]
  },
  {
    "number": 1083,
    "title": "\"EnTTish\" way to \"get children\" of parent?",
    "created_at": "2023-10-19T19:29:01Z",
    "closed_at": "2023-10-28T13:11:14Z",
    "labels": [
      "question",
      "discussion",
      "solved"
    ],
    "url": "https://github.com/skypjack/entt/issues/1083",
    "body": "Thank you for this amazing library. \r\n\r\nI'm just starting to use EnTT for a project and thought it would be good to ask if my method for finding all the children in a hierarchy can be better implemented using built-in EnTT functions. I'm currently passing the parent I want to find the children of to a function that calls another function that recursively iterates through all the children (accumulating those children in std::vector). Until either a specified depth is reached or it has found all children.\r\n\r\n```\r\npublic:\r\nstd::vector<entt::entity> findChildren(entt::entity parent, size_t searchDepth)\r\n{\r\n\tstd::vector<entt::entity> children;\r\n\r\n\tif (searchDepth == 0)\r\n\t\tsearchDepth= std::numeric_limits<size_t>::max();\r\n\t_findChildren_(parent, children, searchDepth, 0);\r\n\t\r\n\treturn children;\r\n} \r\n```\r\n\r\n```\r\nprivate:\r\nvoid _findChildren_(entt::entity parent, std::vector<entt::entity>& children, size_t searchDepth, size_t depthStep)\r\n{\r\n\tauto& rel = reg.get<Relationship>(parent);\r\n\tsize_t parentDepth = rel.depth;\r\n\tauto child = rel.firstChild;\r\n\r\n\t++depthStep;\r\n\twhile (child != entt::null)\r\n\t{\r\n\t\tchildren.push_back(child);\r\n\t\tif (depthStep < searchDepth)\r\n\t\t\t_findChildren_(child, children, searchDepth, depthStep);\r\n\t\tchild = reg.get<Relationship>(child).nextSibling;\r\n\t}\r\n}\r\n```\r\nAny thoughts? Is std::vector the best container to use in this case?",
    "comments_url": "https://api.github.com/repos/skypjack/entt/issues/1083/comments",
    "author": "keithlostracco",
    "comments": [
      {
        "user": "skypjack",
        "created_at": "2023-10-20T09:48:55Z",
        "body": "There are many ways to address it and the right solution depends on the requirements. To be honest, I don't think there exists a one-fits-all approach for this kind of problem.\r\nFor example, if you access these elements mostly randomly, pointer stability can make everything much easier. On the other hand, if linear access is a thing on hot paths for this hierarchy, a fully packed storage is the  way to go.\r\nYou solution works too, no doubts about it. I can't say if it's the best for your use case because I don't have enough context. However, I can suggest to avoid calling `registry.get<T>` again and again. This triggers a pool lookup all the times and you don't really need it. Just create a view and get the component from there or directly access the storage and use it instead. üëç "
      },
      {
        "user": "keithlostracco",
        "created_at": "2023-10-20T18:08:48Z",
        "body": "Thanks for the quick response. \r\n\r\nAt this time, the only use case I can specifically optimize for is GUI interaction.  I'm not building a game engine. It's more of an application akin to classic 3D animation and rendering software but has the specific requirement of rendering/running fast (like a game). Eventually, as things progress, I'm sure I'll have more specific requirements and will want to optimize for those requirements at that time. \r\n\r\nI do know that I need to adhere to standard 3D formats/workflows, which typically have a scene graph structure (OpenUSD etc...).\r\n\r\nRight now, since I'm just working on UI, my findChildren() function is just used to display the nodes in a tree list. It sounds like my findChildren() modified to use a view rather than a full pool lookup is wise and is likely good enough for now. \r\n\r\nRegarding your mention of \"pointer stability,\" do you mean to simply save children in a Relationship in a std::array (or map)?\r\n"
      },
      {
        "user": "skypjack",
        "created_at": "2023-10-21T14:59:30Z",
        "body": "> I'll have more specific requirements and will want to optimize for those requirements at that time.\r\n\r\nThis makes perfectly sense, do not try to optimize everything just because from the beginning.\r\n\r\n> Regarding your mention of \"pointer stability,\" do you mean to simply save children in a Relationship in a std::array (or map)?\r\n\r\nNo, no, EnTT offers a pointer-stable mode for components. You can enable it for one, N or all components as you like.\r\nThis makes it possible to store pointers aside directly and the latter works pretty well with hierarchies as you can guess."
      },
      {
        "user": "keithlostracco",
        "created_at": "2023-10-21T15:13:35Z",
        "body": "> No, no, EnTT offers a pointer-stable mode for components. You can enable it for one, N or all components as you like.\r\n> This makes it possible to store pointers aside directly and the latter works pretty well with hierarchies as you can guess.\r\n\r\nSweet! I'll look into that."
      }
    ]
  },
  {
    "number": 1074,
    "title": "Get variable from meta_any by reference instead of copy?",
    "created_at": "2023-10-05T17:51:26Z",
    "closed_at": "2023-10-09T16:20:43Z",
    "labels": [
      "question",
      "solved"
    ],
    "url": "https://github.com/skypjack/entt/issues/1074",
    "body": "I'm using entt::meta to automatically serialize data in user-created types. For structs and classes, I'm doing the following for each member:\r\n\r\n```\r\nentt::meta_any value = instance.get(child->GetPropId());\r\nchild->Deserialize(stream, value);\r\ninstance.set(child->GetPropId(), value);\r\n````\r\n\r\nWhere `instance` is a `meta_any` containing the structure object and `child` is a node object that I use for serialization and, in this case, represents a variable inside the struct referenced by `instance`.\r\nAs far as I understand, `value` is a copy of the variable and not a reference. This is not scaling too well on things like large arrays in terms of performance and I haven't measured it yet, but I suspect one of the bottlenecks is this piece of code. Is there a way to get a member variable by ref instead of by copy?\r\n",
    "comments_url": "https://api.github.com/repos/skypjack/entt/issues/1074/comments",
    "author": "meinukey",
    "comments": [
      {
        "user": "skypjack",
        "created_at": "2023-10-05T18:28:01Z",
        "body": "Yeah, sure, it's all about using `entt::as_ref_t` when registering it with the factory.\nYou can find the details in the doc and many examples in the test suite but feel free to reach out for a quick and dirty example if you can't get it to work. "
      },
      {
        "user": "meinukey",
        "created_at": "2023-10-05T21:23:44Z",
        "body": "Thank you so much, that worked a treat!"
      }
    ]
  },
  {
    "number": 1073,
    "title": "registry.create() returning entt::entity of id greater than entt::null?",
    "created_at": "2023-09-27T06:29:01Z",
    "closed_at": "2023-09-27T11:01:36Z",
    "labels": [
      "question",
      "solved"
    ],
    "url": "https://github.com/skypjack/entt/issues/1073",
    "body": "After destroying created entities and creating new ones, registry.create() returns ids that are greater than entt::null. Is this normal?",
    "comments_url": "https://api.github.com/repos/skypjack/entt/issues/1073/comments",
    "author": "michellelor",
    "comments": [
      {
        "user": "skypjack",
        "created_at": "2023-09-27T07:28:38Z",
        "body": "> registry.create() returns ids that are greater than entt::null\r\n\r\nFortunately, it doesn't.\r\n\r\nIdentifiers are split in two parts, the entity and the version. `entt::null` _means_ 0xFFFF for all bits of the entity part.\r\nWhen you destroy an identifier, the version is increased while the entity remains the same. This is what you're observing.\r\nIn any case the resulting entity is greater than `entt::null` (also because `entt::null` is the maximum value allowed for the entity part, so this cannot happen by construction ü§∑‚Äç‚ôÇÔ∏è).\r\n\r\nUse `entt::to_integral` to _convert_ an identifier to its integral value and `entt::to_entity` or `entt::to_version` to _extract_ and verify its parts.\r\nAlso note that identifiers are recycled as soon as possible the avoid wasting space in the entity storage. Therefore, if you destroy then create an identifier, it's likely that you get the same entity with a different version, that is, a completely different identifier."
      },
      {
        "user": "michellelor",
        "created_at": "2023-09-27T11:01:36Z",
        "body": "thank you!"
      }
    ]
  },
  {
    "number": 1051,
    "title": "`entt::registry::empty()` is deprecated, but (...) has no member named `in_use()`",
    "created_at": "2023-08-06T21:48:46Z",
    "closed_at": "2023-08-07T15:35:27Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/skypjack/entt/issues/1051",
    "body": "Hi,\r\nI have the following code:\r\n```c\r\nif(registry.empty()) {\r\n    consoleLog.push_back({0, \"No entities in scene.\"});\r\n    return;\r\n}\r\n```\r\nMy compiler tells me:\r\n```\r\nwarning: 'empty' is deprecated: use .storage<Entity>().in_use() instead\r\n```\r\nSo I change the code to this:\r\n```c\r\nif(!registry.storage().in_use()) {\r\n    consoleLog.push_back({0, \"No entities in scene.\"});\r\n    return;\r\n}\r\n```\r\nNow, my compiler tells me this:\r\n```\r\nerror: no member named 'in_use' in 'entt::iterable_adaptor<entt::internal::registry_storage_iterator<entt::internal::dense_map_iterator<__gnu_cxx::__normal_iterator<entt::internal::dense_map_node<unsigned int, std::shared_ptr<entt::basic_sparse_set<>>> *, std::vector<entt::internal::dense_map_node<unsigned int, std::shared_ptr<entt::basic_sparse_set<>>>>>>>>'\r\n```\r\n\r\nWhat's going on? I'm using `single_include/entt/entt.hpp` with version v3.12.2.",
    "comments_url": "https://api.github.com/repos/skypjack/entt/issues/1051/comments",
    "author": "colleen05",
    "comments": [
      {
        "user": "colleen05",
        "created_at": "2023-08-06T21:53:04Z",
        "body": "Just to add, I'm completely new to EnTT, and I'm not just trying to use the issues page as a support forum. I may be making a mistake that would be obvious to people familiar with the library.\r\n\r\nI still feel like being warned about deprecation, suggested to use a different function, and then finding out that function doesn't actually exist, is a bit odd. Could this be an issue with the single-include header?"
      },
      {
        "user": "skypjack",
        "created_at": "2023-08-07T07:18:43Z",
        "body": "> I still feel like being warned about deprecation, suggested to use a different function, and then finding out that function doesn't actually exist, is a bit odd\r\n\r\nI mean, the warning says `storage<Entity>().in_use()` and you did `storage().in_use()`.\r\nI find being notified of a change with a description of what to do, doing a different thing and then being surprised why it doesn't work is just as weird.\r\nProbably that function exists on the *right* storage though:\r\n```cpp\r\nif(registry.storage<entt::entity>().in_use() == 0u) {\r\n    // no entities currently in use here\r\n}\r\n```"
      },
      {
        "user": "colleen05",
        "created_at": "2023-08-07T15:35:27Z",
        "body": "Thanks for pointing this out to me!\r\nI failed to read the documentation last night, and I misunderstood the use of the function.\r\n\r\nI do have an additional question:\r\nWhy does it want me to specify type _Entity_, when there's just one entity type (essentially a uint32)? Can registries store more than just entities? Or is there some non-purely-ECS thing you can do like, for example, creating an entity class that contains the uint32 EnTT needs, but also storing a name string for in-game referencing?"
      },
      {
        "user": "skypjack",
        "created_at": "2023-08-07T15:39:42Z",
        "body": "Well, yeah, the entity type is customizable as everything else in EnTT. You can have 64b entities or use a custom class if you like.\r\nThat being said, `storage()` has a different purpose and `storage<T>()` wants a `T`. Since you're asking for the entity storage... ü§∑‚Äç‚ôÇÔ∏è "
      }
    ]
  },
  {
    "number": 1049,
    "title": "Checking how much memory is currently in use",
    "created_at": "2023-08-01T17:14:36Z",
    "closed_at": "2023-08-02T08:45:06Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/skypjack/entt/issues/1049",
    "body": "1) Is there a way to check how much memory is currently in use by entt?\r\n2) Can I provide a custom allocator to entt?",
    "comments_url": "https://api.github.com/repos/skypjack/entt/issues/1049/comments",
    "author": "buttception",
    "comments": [
      {
        "user": "skypjack",
        "created_at": "2023-08-02T07:41:07Z",
        "body": "You can provide a custom allocator (almost all classes are allocator-aware, just look at their definition).\r\nThen, yes, you can track memory consumption with your allocator or a debug-only decorator for it."
      },
      {
        "user": "buttception",
        "created_at": "2023-08-02T08:45:06Z",
        "body": "Thanks a lot!"
      }
    ]
  },
  {
    "number": 1048,
    "title": "Store an entity without creating it in a registry",
    "created_at": "2023-07-31T19:23:20Z",
    "closed_at": "2023-08-01T20:40:35Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/skypjack/entt/issues/1048",
    "body": "I'm working on a game and I want to be able to define entity types in TOML files.\r\n\r\nI would load these files at startup and create entities from them without instantiating them in world. When spawning entities, I would copy the saved entity into the active registry and set the position.\r\n\r\nIs there anything like this possible with EnTT?",
    "comments_url": "https://api.github.com/repos/skypjack/entt/issues/1048/comments",
    "author": "samfromcadott",
    "comments": [
      {
        "user": "skypjack",
        "created_at": "2023-08-01T07:09:33Z",
        "body": "What do you mean with _store an entity without creating it in a registry_? Where do you want to store it?\r\nIf you can provide the required data structures or use plain storage classes, then go with it. Otherwise, you can use a prototype registry from which you can copy an entity on demand into the main registry.\r\nThere are plenty of solutions and possible approaches. It's mostly a matter of tastes."
      }
    ]
  },
  {
    "number": 1036,
    "title": "Is it possible to copy a component into an entity?",
    "created_at": "2023-07-11T06:31:17Z",
    "closed_at": "2023-07-11T08:34:59Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/skypjack/entt/issues/1036",
    "body": "I.e. calling\r\n```\r\nregistery.emplace<position>(entity, pos)\r\n```\r\n\r\nwhere pos is a const reference, so that the new component has its copy constructor called?",
    "comments_url": "https://api.github.com/repos/skypjack/entt/issues/1036/comments",
    "author": "SomeGuyDoinWork",
    "comments": [
      {
        "user": "skypjack",
        "created_at": "2023-07-11T08:13:12Z",
        "body": "I mean, that's exactly the way to go. What's wrong with it?"
      }
    ]
  },
  {
    "number": 1020,
    "title": "clone a registry, or at least a subset of components",
    "created_at": "2023-06-09T12:26:33Z",
    "closed_at": "2023-08-31T09:19:29Z",
    "labels": [
      "question",
      "solved"
    ],
    "url": "https://github.com/skypjack/entt/issues/1020",
    "body": "Hey, I have an use case where I need to multi buffer a `registry`, or at least the entities and most of the components. What would be the best way for copy/cloning a `registry`?\r\n\r\nI couldn't manage to find a way to do it, based on previous issues and discussions, the api seems to have changed quite a bit.\r\n\r\nThanks.",
    "comments_url": "https://api.github.com/repos/skypjack/entt/issues/1020/comments",
    "author": "mgiacal",
    "comments": [
      {
        "user": "skypjack",
        "created_at": "2023-06-12T13:17:54Z",
        "body": "Do you want to do it with different registries or within the same registry? Because you can also multi-buffer in-place without having to restort to an external registry, as in `.storage<T>()` and `storage<T>(\"other\"_hs)`."
      },
      {
        "user": "mgiacal",
        "created_at": "2023-06-13T10:20:47Z",
        "body": "> Do you want to do it with different registries or within the same registry?\r\n\r\nDifferent registries, I have a use case where I need to keep copies and be able to rollback to some older state.\r\n"
      },
      {
        "user": "skypjack",
        "created_at": "2023-06-14T15:35:57Z",
        "body": "Well, you've a couple of possibilities here. If you want to copy everything at once, the best approach would be using meta or an erased function that you _bind_ to the given component type.\r\nDo you happen to use meta already? Otherwise I can provide an example without it. Let me know. üëç "
      },
      {
        "user": "mgiacal",
        "created_at": "2023-06-15T10:20:30Z",
        "body": "> Do you happen to use meta already? Otherwise I can provide an example without it. Let me know. üëç\r\n\r\nI have no idea yet :) Yes please, few examples on different approaches would help me, thanks!"
      },
      {
        "user": "skypjack",
        "created_at": "2023-06-16T15:54:16Z",
        "body": "Ok, so, if you want to only copy some types and know them, it's as easy as:\r\n```cpp\r\nauto &storage = from.storage<T>();\r\nto.insert<T>(src.entt::sparse_set::begin(), src.entt::sparse_set::end(), src.begin());\r\n```\r\nWhere `from` and `to` are the two registries. If you want to use named pools, just use the storage directly in all cases:\r\n```cpp\r\nauto &src = from.storage<T>(\"name\"_hs);\r\nto.storage<T>(\"name\"_hs).insert(src.entt::sparse_set::begin(), src.entt::sparse_set::end(), src.begin());\r\n```\r\nOtherwise, you can do it blindly in a couple of ways. The first option is with meta, that is, a reflection system.\r\nYou can register the meta type on your own or use a storage mixin to do that on creation. Then you can use the meta function to do the copy.\r\nSomething along this line should (almost) work already:\r\n```cpp\r\ntemplate<typename Type>\r\nvoid copy(entt::sparse_set& base, entt::registry &to) {\r\n    auto &src = static_cast<entt::storage_for_t<Type> &>(base);\r\n    to.insert<Type>(src.entt::sparse_set::begin(), src.entt::sparse_set::end(), src.begin());\r\n}\r\n\r\nvoid register_meta() {\r\n    using namespace entt::literals;\r\n    entt::meta<Type>().func<&copy<Type>>(\"copy\"_hs);\r\n    // ...\r\n}\r\n\r\nvoid copy_all(entt::registry &from, entt::registry &to) {\r\n    for (auto [id, storage] : from.storage()) {\r\n        using namespace entt::literals;\r\n        entt::resolve(storage.type()).invoke(\"copy\"_hs, {}, entt::forward_as_meta(storage), entt::forward_as_meta(to));\r\n    }\r\n}\r\n```\r\nFinally, you can obtain something similar without meta too.\r\nJust create a map of type ids and erased functions (like the `copy` function above, it decays to `void(*)(entt::sparse_set&, entt::registry &)` and `Type` disappears, you know), then use it as needed.\r\n\r\nI hope it helped. Let me know if you have any questions. üëç "
      },
      {
        "user": "skypjack",
        "created_at": "2023-06-20T09:49:10Z",
        "body": "I assume this was solved? Let me know if you have any other questions. I'll close the issue in a few days otherwise. Thanks."
      },
      {
        "user": "mgiacal",
        "created_at": "2023-06-20T10:09:11Z",
        "body": "> I assume this was solved? Let me know if you have any other questions. I'll close the issue in a few days otherwise. Thanks.\r\n\r\nhey, sorry for the late response, and thanks for the explanation. It took me a while to test the suggested methods, specially to make sure also entities are copied. I ended up with something like that:\r\n\r\n```\r\ntemplate <typename T>\r\nstatic void copy_storage(entt::registry& dst, entt::registry& src) {\r\n    auto& storage = src.storage<T>();\r\n    dst.insert<T>(storage.entt::sparse_set::begin(), storage.entt::sparse_set::end(), storage.begin());\r\n}\r\n\r\nto.assign(from.storage<Entity>().cbegin(), from.storage<Entity>().cend(), from.storage<Entity>().size());\r\ncopy_storage<Type1>(to, from);\r\ncopy_storage<Type2>(to, from);\r\n[...]\r\n```\r\n\r\nIf you don't see any problems with that, then I would say it is solved :) thanks again!"
      },
      {
        "user": "skypjack",
        "created_at": "2023-06-20T10:12:07Z",
        "body": "Oh, I see. With version 3.12, entities have their own storage, sorry. Forgot to mention it and the answer happened in the middle of the release. üòÖ "
      }
    ]
  },
  {
    "number": 1015,
    "title": "Some questions concerning entt's implementation of ecs",
    "created_at": "2023-05-18T20:08:29Z",
    "closed_at": "2023-05-20T07:20:28Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/skypjack/entt/issues/1015",
    "body": "I loved reading your ECS Back & Forth series. I think I grew as a programmer (at least in theory), and understand your module better so thank you very much. I really appreciate your work. \r\n\r\nThis generated some additional questions however, specifically about entt api.\r\n\r\nq_1. Is there anything in an entity that enforces it to be confined to its creator registry? I realized to my surprise that addition and retrieval is possible for an entity created from another regitry. I suppose it was to be expected... but I realized this was unwanted behavior when I destroyed the entity and could still access/retrieve that component that I enlisted in the other registry.\r\n\r\nq_2. Related to q_1, but how did you implement destroying elements? I understand versioning and recycling now, but everything I read suggests you still have to iterate all the pools somehow, at the very least to set null_entity/tombstone for the relevant sparse index (even if we try to preserve pointers i.e. not pop the actual elements). Is there a way to not iterate the entire pools for this?\r\n\r\nq_3. Part 8 on type_id made me excited since you just casually revealed a way to generate platform independent rtti, and that in compile time too. Believe me I was wondering myself (for years, I'll be honest) why such a thing was not part of the standard api. I tried it myself and really found that it's possible to generate a unique hash per type, order-independent and without enlisting anything manually. \r\nHowever, combined with q_2, this made me curious. The runtime way of incrementing counters ensured that the type_id is continuous. This means the pools could also be ordered as an array, making indexing o(1) and iterating pools trivial. I wonder how you'd do this with a hash value however. I know this may seem like the equivalent of asking how hashes work, but I wanted to know whether you do things differently. Technically, doesn't this make component access amortized o(1) instead of pure o(1)? I mean sure the keys probably won't clash but... (also if it doesn't hurt to answer, what hash function do you use and what hash space size do you target?)\r\n\r\nq_4. This is related to q_3. I was meaning to ask this one for a long time actually... but I didn't know how to word it until now. Due to entt requiring template type as key to access component/pools, there's no simple way in my knowledge to read/write component from other langauges, other than with indirection such as a bunch of get/setters for each component. For obvious reasons, I don't really prefer that method; I'm hoping that I can store entity keys and component hashes in another language and pinvoke directly from it to read/write a component, without having to write boilerplate code for each of them.\r\nYou've convinced me with part8 (q_3) that this is possible in theory. However, I want to know if there's a way to access a specific pool with a hash value directly. I think technically any entt operation would be directly available to another language this way, especially low-level ones (except adding to non-existing pools I suppose?) \r\n\r\nI hope my questions made sense... I want to let you know I'm still terrible at parsing c++ (due to the black magic of tmp), this means I can't read the source code to check if my concerns/queries are valid. So I have to resort to manuals and uh.. just a bit of handholding. Sorry it got too long-winding at the end.",
    "comments_url": "https://api.github.com/repos/skypjack/entt/issues/1015/comments",
    "author": "Sedomanai",
    "comments": [
      {
        "user": "skypjack",
        "created_at": "2023-05-19T08:30:03Z",
        "body": "> I think I grew as a programmer\r\n\r\nThis is the best compliment you can do to a fellow developer. üôÇ \r\n\r\n> q_1\r\n\r\nNo, there is not. EnTT fully supports a registry-less model too. The new version also introduces a storage entity for the purpose.\r\n\r\n> q_2\r\n\r\nThere are many ways but it really depends on the use case and the necessity. The default implementation just iterates them.\r\n\r\nAn alternative approach (that you can implement on top of EnTT) is to use a storage mixin to track the components assigned to an entity, then only touch their pools.\r\nI did it in a game (which was shipped recently). The implementation was slightly different actually. It only tracks additions to save more cpu cycles and support frequent add/remove operations. A couple of false positives on 100 pools when you have more than 1000 of them are pretty much irrelevant anyway.\r\nOtherwise, you can exploit the `bump` function of a storage, mark an entity as _destroyed_ in the entity storage only, then spawn all storage cleanup in parallel at the end of the tick and have a massive deletion of all pending elements.\r\nAnd so on. We can chat for hours about possible solutions to the problem. The fact is: different applications have different requirements (and most of them are just fine with a naive solution).\r\n\r\nAs everything else in EnTT, you have hooks to get the best out of it based on your requirements.\r\nIt rarely tries to offer a one-fits-all solutions that doesn't really fit anything, as it happens with many libraries out there. ü§∑ \r\n\r\n> q_3\r\n\r\nIf you liked it, you are probably interested in the rtti layer of EnTT. I love it and use it a lot actually.\r\nAs for the counter based solution, that's great but it has the problem that it breaks across boundaries. Using hashes is more reliable instead and works literally in all cases.\r\nOf course, it's amortized rather than pure. However, I recently switched to the map based solution for the reasons above. To squeeze everything out of it, I've also imlemented the `dense_map` for the purpose. üòÖ\r\nUnder the hood, it uses fnv-1a but keeps in mind that the hash is computed at compile time, so I don't really do anything at runtime for that. When you ask for a pool, it's all about looking up an element in an array the size of which is a power of two. Your key is the (compile-time) hashed name of the pool mapped with a `fast_mod` technique on this vector.\r\n\r\n> q_4\r\n\r\nYou have the `storage(id)` function that returns a pointer to a base (opaque) storage. With it, you can get the component (as a `void *` ofc, since the type is unknown), emplace or erase it and even copy it across pools if you like. It's pretty easy to work with runtime pools actually but feel free to reach out if you have doubts/problems.\r\n\r\n\r\n> I hope my questions made sense... I want to let you know I'm still terrible at parsing c++ (due to the black magic of tmp), this means I can't read the source code to check if my concerns/queries are valid\r\n\r\nNo worries, you'll get better as the time passes as it happened for all others. üôÇ "
      },
      {
        "user": "Sedomanai",
        "created_at": "2023-05-19T14:52:55Z",
        "body": "Thank you. Just to clarify, I don't mind the performance or safety impact of any of these, I just wanted to know how they were implemented. I'm only beginning to learn about mixins so bear with me; if you mean using creation/destruction signals and mapping each entity with its component hashes, I think it's doable, I'll try it if it ever becomes a bottleneck. I also actually tag each destroyed entity and destroy them all at once at the end of the tick, would this do about as much you explained? I don't think I need to bump them because they're still considered \"alive\" until the end of the tick. \r\n\r\nI was actually shifting through the docs and delving a bit deeper into the module since the last day (and even peering the source). I'm comfortable working with the storage now, but I didn't know it had another constructer that takes a type hash. I love the rtti layer! I'm not sure I know everything of it but type_id and type_info is more than enough for me, I can already think of so many usecases. Other things like finding/iterating all the components of an entity (without mixins) and mapping by type that crosses boundaries are all possible now. \r\n\r\nSo many doors were opened since the past couple of days studying sparse set ecs and parsing this module... I almost thought I had to roll my own (partly why I asked those questions) but only because I didn't investigate enough to use entt properly. Really should've asked and done this sooner, you already thought of everything and it looks like I don't have to reinvent the wheel."
      },
      {
        "user": "skypjack",
        "created_at": "2023-05-19T15:52:19Z",
        "body": "> Just to clarify, I don't mind the performance or safety impact of any of these, I just wanted to know how they were implemented.\r\n\r\nYeah, I tried to give you some hints on different solutions with different tradeoffs for the same reason. üëç \r\n\r\n> if you mean using creation/destruction signals and mapping each entity with its component hashes\r\n\r\nNo, well, kind of. I mean mixins as in C++ mixin. It's a C++ idiom. If you look at the `sigh_mixin` class, that's what I'm talking about. üôÇ \r\nBriefly (very briefly), it's a sort of extension of a storage class that is configured at compile-time. The registry, the views and all other classes in EnTT don't care about it. Therefore, you can add whatever you want on top of a storage class.\r\nSignals are implemented like this. The whole signal support is a mixin that you can turn off for all types or just a few ones with a single line of code.\r\n\r\n> I also actually tag each destroyed entity and destroy them all at once at the end of the tick, would this do about as much you explained?\r\n\r\nYeah, in this case, use the range-destroy function. It's optimized (**A LOT**) when you use built-in iterators.\r\n\r\n> you already thought of everything\r\n\r\nWell, yeah, you're hitting the same walls I faced in the past apparently. üôÇ "
      },
      {
        "user": "Sedomanai",
        "created_at": "2023-05-20T07:20:06Z",
        "body": "Oh okay. I'll be sure to look into mixins and the sigh_mixin class as best as I can. If it's a customizable extension it's not something I can afford to miss. Hopefully understanding it will expand my general repertoire too.\r\n\r\n> Well, yeah, you're hitting the same walls I faced in the past apparently. üôÇ\r\n\r\nApparently üòÑ I never depended on a c++ module this extensively before, already. I just didn't know how to properly read it until now. I was wondering if I wanted to create one on my own for the learning experience but also because I was intimated before to pry into the specifics of entt to get more out of it. But I'm glad I started to do that now.\r\n\r\nAnyway thank you so much for the wonderful library. And your writings too! I'll be sure to come back if I have more questions"
      }
    ]
  },
  {
    "number": 1009,
    "title": "Preallocate for large number of components",
    "created_at": "2023-04-26T18:51:43Z",
    "closed_at": "2023-05-01T18:34:31Z",
    "labels": [
      "question",
      "solved"
    ],
    "url": "https://github.com/skypjack/entt/issues/1009",
    "body": "Hi,\r\n\r\nI am trying to reserve components to avoid reallocation.\r\n\r\nAs I saw, registries use to have the reserve method for components as such.\r\n\r\n```\r\nregistry.reserve<ComponentType>(size);\r\n```\r\n\r\nHowever, this method seems to have been discarded since then.\r\n\r\nHow may I efficiently allocate large number of components without reallocation?\r\n\r\nI apologies if this has already been answered.",
    "comments_url": "https://api.github.com/repos/skypjack/entt/issues/1009/comments",
    "author": "DiantArts",
    "comments": [
      {
        "user": "Green-Sky",
        "created_at": "2023-04-26T19:15:09Z",
        "body": "it moved to the storage api.\r\nit should now be something like (did not test):\r\n```\r\nreg.storage<ComponentType>().reserve(size);\r\n```"
      },
      {
        "user": "skypjack",
        "created_at": "2023-04-27T10:15:43Z",
        "body": "Yeah, @Green-Sky is right here. üëç\r\nI'm removing the function in the registry now that all storage are freely available.\r\nAlso, note that memory for components is allocated in pages of fixed size. You don't have large spikes due to reallocations."
      }
    ]
  },
  {
    "number": 1006,
    "title": "Entity id de/serialize",
    "created_at": "2023-04-13T16:46:57Z",
    "closed_at": "2023-04-14T15:28:24Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/skypjack/entt/issues/1006",
    "body": "How can an entity id be de/serialized in order to send it over network?\r\nI found `entt::to_integral`, which seems to convert the `entt::entity` to the underlying type (guess uint64 is the default).\r\nWhat would be the counterpart, which converts the uint64 back to a `entt::entity`, so it can be get over the registry again?\r\n\r\nBackground: One node has the registry with all it's entities, it sends a network message (containing the `entt::entity`) to another node and this node would respond with the same entt::entity again, on receive of the response, the entt::entity should be get from the registry again.\r\nIt seems like there is some version encoded in the entt::entity as well, so I'm not sure if the to_integral would be enough and how to convert the uint64 back to the corresponding entity.",
    "comments_url": "https://api.github.com/repos/skypjack/entt/issues/1006/comments",
    "author": "immerhart",
    "comments": [
      {
        "user": "skypjack",
        "created_at": "2023-04-14T06:44:04Z",
        "body": "`entt::entity` is just an enum class. `entt::to_integral` is literally a static cast to its underlying type (which is an `std::uint32_t` by default btw). To recreate an identifier from this value, you can use it as `entt::entity entity{value};` and that's it. üôÇ "
      },
      {
        "user": "immerhart",
        "created_at": "2023-04-14T15:28:13Z",
        "body": "Oh, sounds easy, will give it a try, thanks for the quick response! :) "
      },
      {
        "user": "immerhart",
        "created_at": "2023-04-15T06:35:54Z",
        "body": "> Oh, sounds easy, will give it a try, thanks for the quick response! :)\r\n\r\nIt seems to work =)"
      }
    ]
  },
  {
    "number": 1003,
    "title": "Serialize and Deserialize using reflection",
    "created_at": "2023-04-08T14:05:27Z",
    "closed_at": "2023-04-12T09:01:34Z",
    "labels": [
      "question",
      "solved"
    ],
    "url": "https://github.com/skypjack/entt/issues/1003",
    "body": "Hello im trying to create a network system to sync my components between server and client. To do this im thinking that i could use the reflection system of entt to know which component and member to modify. \r\n\r\nAfter googling and asking chatgpt a lot for a solution i can't seem to find one that gets the result im looking for. I'd imagine that this would be the same if i wanted to save/load the data from a file, from the code snippet below is there a way to get/set the data?\r\n```cpp\r\nentt::entity entity = registry.create();\r\nstd::string component_class_name = \"my_type\";\r\nstd::string component_member_name = \"value\";\r\nstd::string component_member_type = \"float\";\r\nfloat component_member_data = 21.4f;\r\n```\r\n\r\nI've tried using a bunch of different ways but all of them require me to use template of the type at some point it seems like which i can't really do since i need it to be runtime. The code below is as far as i've been able get before im requied to use compile time stuff.\r\n```cpp\r\nentt::meta<my_type>()\r\n\t.type(entt::hashed_string(\"my_type\"))\r\n\t.data<&my_type::value>(entt::hashed_string(\"value\"));\r\n\r\nauto type = entt::resolve(entt::hashed_string(\"my_type\"));\r\nauto data = type.data(entt::hashed_string(\"value\"));\r\n```\r\n\r\nIs there no way to set the data of my_type on entity using the 'type' and 'data' variables above? ChatGPT recommended something like this multiple times but there doesn't seem to exist something like this so im not sure where its getting that from but anyway, is there a way to do something like it?\r\n```cpp\r\nauto component = registry.get(type, entity);\r\ndata.set(component, component_member_data);\r\n```",
    "comments_url": "https://api.github.com/repos/skypjack/entt/issues/1003/comments",
    "author": "TheExeQ",
    "comments": [
      {
        "user": "skypjack",
        "created_at": "2023-04-11T16:32:15Z",
        "body": "You can get the storage from the registry using the component id (see `.storage(id)`), then an opaque pointer (as in `void *`) using the `.value(entt)` function of the storage. Since you know the component id, you can also retrieve the meta type for the given component using `resolve(id)` and invoke its `.from_void` function to get a `meta_any` that wraps your component and that you can pass as an argument to your setter. Finally, `data.set(...)` is the way to go. üëç "
      },
      {
        "user": "TheExeQ",
        "created_at": "2023-04-12T08:34:53Z",
        "body": "Do you mean something like this? because storage returns a ``entt::sparse_set*`` where ``.value()`` nor ``->value()`` exists :/\r\n```cpp\r\n    auto storage = registry.storage(componentId);\r\n    \r\n    void* componentPtr = storage.value(entity);\r\n    const auto& metaType = entt::resolve(componentId);\r\n    \r\n    auto componentAny = metaType.from_void(componentPtr);\r\n    componentAny.set(newValue);\r\n```"
      },
      {
        "user": "skypjack",
        "created_at": "2023-04-12T08:43:52Z",
        "body": "Ah, sorry, it's called `get` in the last version maybe? I changed it to `value` to avoid name clashing with derived classes."
      },
      {
        "user": "TheExeQ",
        "created_at": "2023-04-12T09:01:32Z",
        "body": "Yeah that was it, now i got it to work thanks a lot! :D"
      }
    ]
  },
  {
    "number": 999,
    "title": "meta_any::invoke dose not change a instance which is passed as reference.",
    "created_at": "2023-03-22T14:29:07Z",
    "closed_at": "2023-03-22T14:47:55Z",
    "labels": [
      "question",
      "solved"
    ],
    "url": "https://github.com/skypjack/entt/issues/999",
    "body": "### Environment\r\n- entt : v3.11.1\r\n- visual studio 2022 : Version17.4.5\r\n\r\n### Issue\r\nI called meta_any::invoke with a function which receive a reference parameter and modify it.\r\n\r\nI read issue #460, so I used std::ref.\r\n\r\nBut the caller's instance value was not changed.\r\n\r\nMy code is as follow.\r\n\r\n``` cpp\r\nstruct Position\r\n{\r\n\tdouble x, y, z;\r\n\r\n\tvoid get(double& tmp)\r\n\t{\r\n\t\ttmp = x;\r\n\t}\r\n};\r\n\r\nBOOST_AUTO_TEST_CASE(Test)\r\n{\r\n\tusing entt::operator\"\"_hs;\r\n\r\n\tentt::meta<::Position>()\r\n\t\t.type(entt::type_id<::Position>().hash())\r\n\t\t.func<&::Position::get>(\"get\"_hs);\r\n\r\n\t::Position data{ 1.0, 2.0, 3.0 };\r\n\tauto any = entt::resolve(entt::type_id<Position>()).from_void(&data);\r\n\r\n\tdouble value;\r\n\tany.invoke(\"get\"_hs, std::ref(value));\r\n\r\n\tBOOST_TEST(value == data.x);\r\n}\r\n```\r\n\r\nIn addition, I executed the code in 460 with a slight modification.\r\nResults were similar.\r\n\r\n``` cpp\r\nBOOST_AUTO_TEST_CASE(MutateByRef)\r\n{\r\n\tusing entt::operator\"\"_hs;\r\n\r\n\tentt::meta<get_last_hour_data>().type(\"/getLastHourData\"_hs).template base<Base>().\r\n\t\ttemplate func<&get_last_hour_data::exec>(\"exec\"_hs).\r\n\t\ttemplate ctor<&get_last_hour_data::create>();\r\n\tauto type = entt::resolve(\"/getLastHourData\"_hs);\r\n\tassert(type);\r\n\r\n\tauto func = type.func(\"exec\"_hs);\r\n\tassert(func);\r\n\r\n\tauto any = type.construct(std::string{});\r\n\tassert(any);\r\n\r\n\tstd::string s;\r\n\tauto any_2 = func.invoke(any, std::ref(s));\r\n\tassert(any_2);\r\n\tBOOST_TEST(\".\" == s);\r\n}\r\n\r\nBOOST_AUTO_TEST_CASE(MutateBySharedPtrRef)\r\n{\r\n\tusing entt::operator\"\"_hs;\r\n\r\n\tentt::meta<get_last_hour_data>().template func<&get_last_hour_data::exec_ptr>(\"exec_ptr\"_hs);\r\n\r\n\tauto type = entt::resolve(\"/getLastHourData\"_hs);\r\n\tassert(type);\r\n\r\n\r\n\tauto func = type.func(\"exec_ptr\"_hs);\r\n\tassert(func);\r\n\r\n\tauto any = type.construct(std::string{});\r\n\tassert(any);\r\n\r\n\tauto s = std::make_shared<std::string>();\r\n\tauto any_2 = func.invoke(any, std::ref(s));\r\n\tassert(any_2);\r\n\tBOOST_TEST(\".\" == *s);\r\n}\r\n```\r\n\r\nThank you for your help in advance.",
    "comments_url": "https://api.github.com/repos/skypjack/entt/issues/999/comments",
    "author": "tetrisplusplus",
    "comments": [
      {
        "user": "Green-Sky",
        "created_at": "2023-03-22T14:34:50Z",
        "body": "you can use `entt::forward_as_meta(value)` instead of `std::ref(value)`"
      },
      {
        "user": "tetrisplusplus",
        "created_at": "2023-03-22T14:47:55Z",
        "body": "It worked fine by using entt::forward_as_meta.\r\nThank you very much!\r\n\r\n"
      }
    ]
  },
  {
    "number": 996,
    "title": "Get name by meta id_type",
    "created_at": "2023-03-18T14:25:50Z",
    "closed_at": "2023-03-20T07:55:32Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/skypjack/entt/issues/996",
    "body": "Hi,\r\nI have a type which itself and its properties are registered as meta type. I can iterate over its properties (data), however, I don't have any access to property names. While I do have access to each property id_type, I wanted to ask if it is possible to convert id_type (\"foo\"_hs) to an actual string (to \"foo\")?",
    "comments_url": "https://api.github.com/repos/skypjack/entt/issues/996/comments",
    "author": "MohammadMDSA",
    "comments": [
      {
        "user": "skypjack",
        "created_at": "2023-03-20T07:53:36Z",
        "body": "`EnTT` doesn't store aside names for your meta objects automatically. You can use meta properties for that though:\r\n```cpp\r\nentt::meta<T>()\r\n    .data<T::x>(\"x\"_hs).prop(\"name\"_hs, \"x\")\r\n    .data<T::y>(\"y\"_hs).prop(\"name\"_hs, \"y\");\r\n```\r\nAs for the type info, that's the declaration type of the data member. That is, for `int x` it would be `int` and not `x`. So, converting it doesn't really help."
      }
    ]
  },
  {
    "number": 987,
    "title": "Is there any specific component in my entity?",
    "created_at": "2023-02-25T19:43:05Z",
    "closed_at": "2023-02-26T09:29:50Z",
    "labels": [
      "question",
      "solved"
    ],
    "url": "https://github.com/skypjack/entt/issues/987",
    "body": "Hello, I would like to know how I can find out if there is a certain component in my entity. I know there used to be a \"has\" function, but now I can't find it. Thank you in advance for your answer",
    "comments_url": "https://api.github.com/repos/skypjack/entt/issues/987/comments",
    "author": "0LGL0",
    "comments": [
      {
        "user": "Green-Sky",
        "created_at": "2023-02-26T00:44:43Z",
        "body": "yes, they are now called `.all_of<Component>(e)` and `.any_of<Component>(e)`"
      },
      {
        "user": "0LGL0",
        "created_at": "2023-02-26T08:37:49Z",
        "body": "@Green-Sky, thank you so much for your help"
      }
    ]
  },
  {
    "number": 978,
    "title": "any way chance to improve compile-time?",
    "created_at": "2023-01-23T02:40:39Z",
    "closed_at": "2023-02-03T13:59:03Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/skypjack/entt/issues/978",
    "body": "I am using this library in my game and I have a huge compile-time. is there any way to improve that?",
    "comments_url": "https://api.github.com/repos/skypjack/entt/issues/978/comments",
    "author": "VictorQueiroz",
    "comments": [
      {
        "user": "skypjack",
        "created_at": "2023-01-23T14:27:47Z",
        "body": "Well, this boils down to good practices in C++ and it's hard to say how you can improve without looking at your code.\r\nJust to throw a couple of ideas at you, you can avoid to use `entt.hpp` everywhere and start to use the forward files instead. ü§∑‚Äç‚ôÇÔ∏è "
      },
      {
        "user": "skypjack",
        "created_at": "2023-02-03T13:59:03Z",
        "body": "I'm closing the issue due to inactivity. Feel free to continue the discussion here anyway if you want/need."
      }
    ]
  },
  {
    "number": 972,
    "title": "entt::basic_registry<uint64_t> causing bugs",
    "created_at": "2023-01-12T15:15:03Z",
    "closed_at": "2023-01-12T15:37:50Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/skypjack/entt/issues/972",
    "body": "Hi, I want to use entt::basic_registry<uint64_t>, and then I can use the id to serialize in my file, and deserialize to the Entity. (I think uint32_t is not enough for the UUID, so I want to use uint64_t and pass straightly to entt like `mRegistry.create(uuid)`)\r\n\r\nBut it causes some bugs in here:\r\n```\r\n  /**\r\n   * @brief Returns the identifier that occupies the given position.\r\n   * @param pos Position of the element to return.\r\n   * @return The identifier that occupies the given position.\r\n   */\r\n  [[nodiscard]] entity_type operator[](const size_type pos) const {\r\n      return begin()[pos];\r\n  }\r\n\r\n  /**\r\n   * @brief Returns the component assigned to the given entity.\r\n   * @param entt A valid identifier.\r\n   * @return The component assigned to the given entity.\r\n   */\r\n  [[nodiscard]] decltype(auto) operator[](const entity_type entt) const {\r\n      return get<Component>(entt);\r\n  }\r\n```\r\n\r\nbug: `error : functions that differ only in their return type cannot be overloaded`\r\n\r\nAs you can see, because the size_type (std::size_t) is same with the entity_type, which is the template argument of basic_registry.\r\n\r\nMy computer is Windows10 64bit environment.\r\n\r\nHow can I fix these and still use entt::basic_registry<uint64_t>? Hope for your help!",
    "comments_url": "https://api.github.com/repos/skypjack/entt/issues/972/comments",
    "author": "hebohang",
    "comments": [
      {
        "user": "skypjack",
        "created_at": "2023-01-12T15:28:05Z",
        "body": "Just define your entity type as:\r\n```cpp\r\nenum class my_entity_type: std::uint64_t {};\r\n```\r\nThen, create your registry as:\r\n```cpp\r\nentt::basic_registry<my_entity_type> registry;\r\n```\r\nüëç "
      },
      {
        "user": "hebohang",
        "created_at": "2023-01-12T15:37:38Z",
        "body": "It worked! Really appreciate your help!"
      },
      {
        "user": "skypjack",
        "created_at": "2023-01-12T15:49:52Z",
        "body": "Well, this one was easy. üôÇ \r\nI'm glad it worked."
      }
    ]
  },
  {
    "number": 963,
    "title": "Get TypeName and not TypeSignature from type_info",
    "created_at": "2022-12-28T07:04:29Z",
    "closed_at": "2023-01-02T12:01:37Z",
    "labels": [
      "question",
      "solved"
    ],
    "url": "https://github.com/skypjack/entt/issues/963",
    "body": "`entt::type_id<ArcEngine::TransformComponent>().name().data();` results in `\"struct ArcEngine::TransformComponent>(void) noexcept\"`\r\n\r\nWhich is the signature I think, is there any way to get a compile time name which in this case should be: `\"ArcEngine::TransformComponent\"` or `\"struct ArcEngine::TransformComponent\"`",
    "comments_url": "https://api.github.com/repos/skypjack/entt/issues/963/comments",
    "author": "GloriousPtr",
    "comments": [
      {
        "user": "skypjack",
        "created_at": "2022-12-28T15:20:37Z",
        "body": "`.name()` returns an `std::string_view`. You should use both `.data()` **AND** `.size()` to get the right portion of the original string.\r\nIf I get it correctly, this isn't what you did. Am I wrong?"
      },
      {
        "user": "GloriousPtr",
        "created_at": "2023-01-02T12:01:37Z",
        "body": "My bad, using `std::string_view.data()` and `std::string_view.size()` or `static_cast<std::string>(std::string_view)` works. Thanks for the help, closing the issue."
      }
    ]
  },
  {
    "number": 961,
    "title": "One entity with multiple 'same' type components",
    "created_at": "2022-12-14T19:52:18Z",
    "closed_at": "2022-12-14T20:06:06Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/skypjack/entt/issues/961",
    "body": "I know that it is not possible to attach the same component multiple times to an entity.\r\nI was wondering if it would possible through some C++ magic or whatever, though.\r\n\r\nI tried it with:\r\n```cpp\r\n    struct struct1\r\n    {\r\n        int val = 0;\r\n    };\r\n\r\n    typedef struct1 struct2;\r\n    using struct3 = struct1;\r\n\r\n    auto entity = reg.create();\r\n    reg.emplace<struct1>(entity);\r\n    reg.emplace<struct3>(entity);\r\n```\r\nBut it is still causing a runtime assert...\r\nIs there another option I'm not aware of? I would like to avoid smth like:\r\n\r\n```cpp\r\n    struct struct1\r\n    {\r\n        int val = 0;\r\n    };\r\n    \r\n    struct struct2\r\n    {\r\n        int val = 0;\r\n    };\r\n```\r\n\r\nThanks in advance!",
    "comments_url": "https://api.github.com/repos/skypjack/entt/issues/961/comments",
    "author": "immerhart",
    "comments": [
      {
        "user": "immerhart",
        "created_at": "2022-12-14T20:36:26Z",
        "body": "Came up with the following, would be nice if the `MultiComponent` could be somehow iterated:\r\n```cpp\r\n        template<std::size_t N = 0>\r\n        struct MultiComponent\r\n        {\r\n            int val;\r\n        };\r\n    \r\n        auto entity = reg.create();\r\n        reg.emplace<MultiComponent<>>(entity, 12);\r\n        reg.emplace<MultiComponent<1>>(entity, 2);\r\n        reg.emplace<MultiComponent<2>>(entity, 312);\r\n        \r\n        auto view = reg.view<const MultiComponent<1>>();\r\n        for(auto entity: view)\r\n        {\r\n            auto& comp = view.get<const MultiComponent<1>>(entity);\r\n            debug(\"{} has id: {}\", comp.val, entity);\r\n        }\r\n```\r\n"
      },
      {
        "user": "skypjack",
        "created_at": "2022-12-15T08:06:03Z",
        "body": "`using` declarations don't introduce new types (as in C++ types). That is why it doesn't work.\r\nYour solution gets the job done instead. Another approach is to spawn multiple storage for the same type but with different _names_ as in:\r\n```cpp\r\nusing namespace entt::literals;\r\nauto &&storage1 = registry.storage<my_struct>(\"my_struct_1\");\r\nauto &&storage2 = registry.storage<my_struct>(\"my_struct_2\");\r\n```\r\nStorage classes have roughly the same API of the registry:\r\n```cpp\r\nstorage1.emplace(entity, arg1, arg2);\r\nstorage2.erase(entity);\r\n```\r\nAnd you can use them to construct views directly if you like:\r\n```cpp\r\nentt::view view{storage1, storage2};\r\n```\r\nThen you can also combine this view with others from the registry, as in:\r\n```cpp\r\nfor(auto [entity, position, elem1, elem2]: registry.view<position>() | view) {\r\n    // ...\r\n}\r\n```\r\nThe doc contains all the details btw. This should give you a grasp of the whole picture though. üëç "
      },
      {
        "user": "immerhart",
        "created_at": "2022-12-15T09:31:51Z",
        "body": "> `using` declarations don't introduce new types (as in C++ types). That is why it doesn't work. Your solution gets the job done instead. Another approach is to spawn multiple storage for the same type but with different _names_ as in:\r\n> \r\n> ```c++\r\n> using namespace entt::literals;\r\n> auto &&storage1 = registry.storage<my_struct>(\"my_struct_1\");\r\n> auto &&storage2 = registry.storage<my_struct>(\"my_struct_2\");\r\n> ```\r\n> \r\n> Storage classes have roughly the same API of the registry:\r\n> \r\n> ```c++\r\n> storage1.emplace(entity, arg1, arg2);\r\n> storage2.erase(entity);\r\n> ```\r\n> \r\n> And you can use them to construct views directly if you like:\r\n> \r\n> ```c++\r\n> entt::view view{storage1, storage2};\r\n> ```\r\n> \r\n> Then you can also combine this view with others from the registry, as in:\r\n> \r\n> ```c++\r\n> for(auto [entity, position, elem1, elem2]: registry.view<position>() | view) {\r\n>     // ...\r\n> }\r\n> ```\r\n> \r\n> The doc contains all the details btw. This should give you a grasp of the whole picture though. +1\r\n\r\nThanks for the answer (and the ECS :D)!\r\nDo you refer to the Beam me up section (I think I skipped that)?\r\n\r\nDoes it produce overhead to use  N different storages, not sure what `Since the storage are also self-contained, the registry doesn't duplicate its own API for them` means.\r\nAny idea on iterating over it (for creating and viewing), like in an array with unknown size?"
      },
      {
        "user": "skypjack",
        "created_at": "2022-12-15T14:30:31Z",
        "body": "> Does it produce overhead to use N different storages\r\n\r\nI mean, that is exactly what you're doing when you use `MultiComponent<1>` and `MultiComponent<2>`, isn't it? ü§∑‚Äç‚ôÇÔ∏è \r\n\r\n> Any idea on iterating over it (for creating and viewing), like in an array with unknown size?\r\n\r\nCan you elaborate? Not sure I get what you mean. As mentioned above, you can construct views from the storage and iterate them as you would do with any other view."
      },
      {
        "user": "immerhart",
        "created_at": "2022-12-15T15:22:23Z",
        "body": "`MultiComponent<1>` and `MultiComponent<2>` will only add new components, I thought.\r\nCreating N new stores sounds like overhead to me (are those stores not \"big\"?), if there are many same components on an entity (+ different entities which might have multiple same components again), but I don't know the internals...\r\n\r\nI meant something like (which obviously does not work with templates and I didn't understand how to do it with the store approach):\r\n\r\n```cpp\r\n        template<std::size_t N = 0>\r\n        struct MultiComponent\r\n        {\r\n            int val;\r\n        };\r\n    \r\n        auto entity = reg.create();\r\n        int size = 100;\r\n        for(int i = 0; i < size;  i++)\r\n            reg.emplace<MultiComponent<i>>(entity, randomInt());\r\n        \r\n        auto view = reg.view<const MultiComponent<GET_ALL_SOMEHOW>>();\r\n        for(auto entity: view)\r\n        {\r\n            for(int i = 0; i < size; i++)\r\n            {\r\n                auto& comp = view.get<const MultiComponent<i>>(entity);\r\n                debug(\"Entity {} has val: {}\", entity, comp.val,);\r\n            }\r\n        }\r\n```\r\n\r\nI'm trying to represent a 2d-grid with multiple layers (should be used for building stuff, comparable to sim city, where you can build on ground and under it etc.).\r\nAnd my idea was to have some kind of grid entity which holds many cell components, but maybe I shouldn't do it in the ECS, not sure...\r\nWhat would you suggest? :)"
      },
      {
        "user": "skypjack",
        "created_at": "2022-12-19T07:56:03Z",
        "body": "> `MultiComponent<1>` and `MultiComponent<2>` will only add new components, I thought.\r\n> Creating N new stores sounds like overhead to me (are those stores not \"big\"?)\r\n\r\nThere is no difference. `MultiComponent<1>` and `MultiComponent<2>` are different types in C++. Same as let's say `position` and `velocity`. The fact that they _share_ part of the name doesn't really mean anything."
      },
      {
        "user": "immerhart",
        "created_at": "2023-01-03T15:50:18Z",
        "body": "> `using` declarations don't introduce new types (as in C++ types). That is why it doesn't work. Your solution gets the job done instead. Another approach is to spawn multiple storage for the same type but with different _names_ as in:\r\n> \r\n> ```c++\r\n> using namespace entt::literals;\r\n> auto &&storage1 = registry.storage<my_struct>(\"my_struct_1\");\r\n> auto &&storage2 = registry.storage<my_struct>(\"my_struct_2\");\r\n> ```\r\n> \r\n> Storage classes have roughly the same API of the registry:\r\n> \r\n> ```c++\r\n> storage1.emplace(entity, arg1, arg2);\r\n> storage2.erase(entity);\r\n> ```\r\n> \r\n> And you can use them to construct views directly if you like:\r\n> \r\n> ```c++\r\n> entt::view view{storage1, storage2};\r\n> ```\r\n> \r\n> Then you can also combine this view with others from the registry, as in:\r\n> \r\n> ```c++\r\n> for(auto [entity, position, elem1, elem2]: registry.view<position>() | view) {\r\n>     // ...\r\n> }\r\n> ```\r\n> \r\n> The doc contains all the details btw. This should give you a grasp of the whole picture though. +1\r\n\r\nI looked in this once again and still can't get a hold of it. \r\n  ```c++\r\n    struct Name\r\n    {\r\n        std::string value = \"\";\r\n    };\r\n\r\n    auto entity = reg.create();\r\n    reg.emplace<Name>(entity, \"a\");\r\n    auto& s = reg.storage<Name>(1);\r\n    auto& s2 = reg.storage<Name>(2);\r\n    s.emplace(entity, \"b\");\r\n    s2.emplace(entity, \"c\");\r\n\r\n    entt::basic_view view{\r\n        reg.storage<Name>(1),\r\n        reg.storage<Name>(2)\r\n    };\r\n\r\n    auto join = reg.view<Name>() | entt::basic_view{ reg.storage<Name>(1), reg.storage<Name>(2) };\r\n\r\n    for(auto e : join)\r\n    {\r\n        auto& comp = join.get<Name>(e);\r\n        debug(\"{}\", comp.value);\r\n    }\r\n```\r\n\r\n1. How would you iterate over the view and access each components data? (above does not compile as `non-unique type`)\r\n2. How would this whole mechanic be used for dynamic size, like here:\r\n\r\n```c++\r\n    auto entity = reg.create();\r\n    \r\n    for(int i = 0; i < 5; i++)\r\n    {\r\n        auto& s = reg.storage<Name>(i);\r\n        s.emplace(entity, \"b\");\r\n    }\r\n    \r\n    // how to iterate over all entities and all `Name` components of each entity\r\n```\r\nThe solutions seems so close, but I can't figure it out :sweat_smile: "
      },
      {
        "user": "skypjack",
        "created_at": "2023-01-06T18:36:03Z",
        "body": "> How would you iterate over the view and access each components data?\r\n\r\nIt's something along this line (for a non-empty `Name` type):\r\n```cpp\r\nauto join = reg.view<Name>() | entt::basic_view{ reg.storage<Name>(1), reg.storage<Name>(2) };\r\n\r\nfor(auto [e, n1, n2, n3] : join) { ... }\r\n```\r\n\r\n> How would this whole mechanic be used for dynamic size\r\n\r\nNot sure I get what you mean. Let me know if I'm not on the right track.\r\nYou can iterate over all storage instances using `registry.storage()`, check their type info using `.type()` and test it against `entt::type_id<Name>()`. When you find a match, you've the storage, the id, all the entities and their components."
      }
    ]
  },
  {
    "number": 950,
    "title": "About copying registry's signals",
    "created_at": "2022-11-10T01:09:31Z",
    "closed_at": "2022-11-17T07:36:08Z",
    "labels": [
      "question",
      "solved"
    ],
    "url": "https://github.com/skypjack/entt/issues/950",
    "body": "Is there a way I can copy one registry's bound signals (on_construct, on_update, on_destroy) to another? Thanks a lot!",
    "comments_url": "https://api.github.com/repos/skypjack/entt/issues/950/comments",
    "author": "hls333555",
    "comments": [
      {
        "user": "skypjack",
        "created_at": "2022-11-10T08:29:24Z",
        "body": "There is not actually ü§î I'm sorry. Out of curiosity, what's the use case?\r\n"
      },
      {
        "user": "hls333555",
        "created_at": "2022-11-10T09:05:34Z",
        "body": "> > There is not actually ü§î I'm sorry. Out of curiosity, what's the use case?\r\n> \r\n> In my case, I have a scene which inherited from registry, when my game plays in editor, the scene will make a copy of itself so that any runtime changes will not affect the original editor scene. I added some registry signals on construction of scene, when my scene gets copied, I want to copy those already registered callbacks so that I do not need to register them again because those callbacks also need to work in the runtime copied scene.\r\n\r\n"
      },
      {
        "user": "skypjack",
        "created_at": "2022-11-11T07:41:04Z",
        "body": "I see. No, I'm sorry, there is no way to copy signals over to a different storage.\r\nSince signals are part of a mixin, I don't even think it's easily feasible  from a reference to an erased instance.\r\nYou still have to `static_cast` the storage to the mixin type or to get it with the right component type and rely on the `storage_type` for the rest. However, I guess you want to copy them from a plain `sparse_set &storage` reference, is it?"
      },
      {
        "user": "skypjack",
        "created_at": "2022-11-17T07:36:08Z",
        "body": "I assume this was answered. Closing it. Feel free to continue the discussion here if you have any other doubts. Thanks. üëç "
      }
    ]
  },
  {
    "number": 948,
    "title": "No more ``.has<T>`` for ``entt::registry``?",
    "created_at": "2022-10-31T11:06:31Z",
    "closed_at": "2022-11-01T14:08:14Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/skypjack/entt/issues/948",
    "body": "Hello!\r\nThanks for this convenient library, handy.\r\nI'd like to know how I can check if an entity has a particular component. I checked some tutorials online and most of them use ``registry.has<T>(entity)`` to check if the entity has component T. However, there is no ``has`` member for registry :/\r\nCould you tell me what I'm doing wrong, maybe the function was deprecated?",
    "comments_url": "https://api.github.com/repos/skypjack/entt/issues/948/comments",
    "author": "AlexandreImperator",
    "comments": [
      {
        "user": "skypjack",
        "created_at": "2022-10-31T11:54:07Z",
        "body": "It's `.any_of<...>` and `.all_of<...>` since long time ago already. üôÇ "
      },
      {
        "user": "AlexandreImperator",
        "created_at": "2022-11-01T14:08:14Z",
        "body": "Thanks üòÖüôÇ "
      }
    ]
  },
  {
    "number": 947,
    "title": "Questions about registry destruction",
    "created_at": "2022-10-31T06:19:46Z",
    "closed_at": "2022-11-10T14:14:24Z",
    "labels": [
      "question",
      "solved"
    ],
    "url": "https://github.com/skypjack/entt/issues/947",
    "body": "When a registry is destructed, will all components' on_destroy being called? And do I need to disconnect all components' on_XXX callbacks? Thanks!",
    "comments_url": "https://api.github.com/repos/skypjack/entt/issues/947/comments",
    "author": "hls333555",
    "comments": [
      {
        "user": "skypjack",
        "created_at": "2022-10-31T08:43:00Z",
        "body": "You don't need to disconnect signals as they are discarded upon destruction anyway.\r\nAs for the signals, they aren't invoked by default but you can _force_ it by calling `clear` before destroying the registry.\r\nWe can match the tastes of all users this way, you know. üôÇ "
      },
      {
        "user": "skypjack",
        "created_at": "2022-11-10T14:14:24Z",
        "body": "Closing as solved. Feel free to continue the discussion here if this isn't the case."
      }
    ]
  },
  {
    "number": 945,
    "title": "Entity component serialization",
    "created_at": "2022-10-28T01:19:35Z",
    "closed_at": "2022-11-10T14:13:56Z",
    "labels": [
      "question",
      "solved"
    ],
    "url": "https://github.com/skypjack/entt/issues/945",
    "body": "HelloÔºÅ\r\n I would like to ask a question.\r\nif there are more components and you don't have to specify which specific component types to serialize, is there a way to serialize all the components",
    "comments_url": "https://api.github.com/repos/skypjack/entt/issues/945/comments",
    "author": "jaredhan",
    "comments": [
      {
        "user": "skypjack",
        "created_at": "2022-10-28T12:09:34Z",
        "body": "There is a way to iterate all storage classes in a registry. They also return their type id on request.\r\nTherefore, if you're using a reflection system or just stored aside serialization functions, you can lookup the right call."
      },
      {
        "user": "skypjack",
        "created_at": "2022-11-10T14:13:56Z",
        "body": "Closing as solved/starving issue. Feel free to continue the discussion here if this isn't the case."
      }
    ]
  },
  {
    "number": 941,
    "title": "how to pass a component as function argument?",
    "created_at": "2022-10-19T17:36:20Z",
    "closed_at": "2022-10-22T16:40:45Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/skypjack/entt/issues/941",
    "body": "Modern c++ is very difficult for me and the level here is high. please i want to do something like this:\r\n\r\n```cpp\r\n//comp.hpp\r\n\r\nstruct _t1_tag {};\r\nstruct _t2_tag {};\r\nstruct _t3_tag {};\r\n\r\nusing id = entt::identifier<_t1_tag, _t2_tag, _t3_tag>;\r\n \r\n\r\nconstexpr auto ty_t1_tag = id::type<_t1_tag>;\r\nconstexpr auto ty_t2_tag = id::type<_t2_tag>;\r\nconstexpr auto ty_t3_tag = id::type<_t3_tag>;\r\n\r\n\r\n\r\n//other.cpp\r\n#include \"comp.hpp\"\r\nvoid Game::setComp(entt::entity e, const entt::id_type??? p_comp)\r\n\t{\r\n\t\t\tm_registry.emplace<p_comp>(e);\r\n\t}\r\n```\r\n\r\nsorry for the english",
    "comments_url": "https://api.github.com/repos/skypjack/entt/issues/941/comments",
    "author": "peeterdog",
    "comments": [
      {
        "user": "skypjack",
        "created_at": "2022-10-20T12:35:44Z",
        "body": "You can't use a runtime parameter as a template argument.\r\nI mean, you can't do that in C++ and therefore you can't do that with EnTT. ü§∑‚Äç‚ôÇÔ∏è \r\nHowever, you can use the _opaque `emplace`_ to achieve the same result maybe?\r\n```cpp\r\nvoid Game::setComp(entt::entity e, const entt::id_type p_comp) {\r\n    m_registry.storage(p_comp).emplace(e);\r\n}\r\n```"
      },
      {
        "user": "peeterdog",
        "created_at": "2022-10-20T15:59:45Z",
        "body": "Thanks for you response. I am autodidact in programing and i decide to use entt to challenge myself and im working with a very old intel school litle notebook  .. so this beautiful and complicated piece of engineery(entt) helped me to save precious fps. im making a procedural 2d detective simulator(i hope it be ready next year). actually i can iterate over views an groups,sort an basic stuff, but i was triying to make a runtime tagger(maybe is a YAGNI and im only overengineering)  \r\n\r\nmy actual solution(adecuate to my level of knowledge) is:\r\n(sorry for the code block idont know wtf is hapening.)\r\n'''c++\r\n\r\n//comp.hpp\r\nstruct _rmap_tag {};\r\nconstexpr int C_rmap_tag = 0;\r\n\r\nstruct _tex_tag {};\r\nconstexpr int C_tex_tag = 1;\r\n\r\nstruct _til_tag {};\r\nconstexpr int C_til_tag = 2;\r\n\r\n///other.cpp\r\n\r\nvoid Game::tagger(entt::entity e, int p_tag)\r\n\t{\r\n\tswitch (p_tag)\r\n\t\t{\r\n\t\tcase C_rmap_tag:\r\n\t\t\t{\r\n\t\t\tm_registry.emplace<_til_tag>(e);\r\n\t\t\treturn;\r\n\t\t\t}\r\n\t\tcase C_tex_tag:\r\n\t\t\t{\r\n\t\t\tm_registry.emplace<_tex_tag>(e);\r\n\t\t\treturn; \r\n\t\t\t}\r\n\t\tcase C_til_tag:\r\n\t\t\t{\r\n\t\t\tm_registry.emplace<_til_tag>(e);\r\n\t\t\treturn;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t}\r\n\r\n'''\r\ni tryed you solution but give me this error\r\n\r\n\r\n'''\r\n\r\nF:\\l_3\\a1\\src\\OBJ\\GAME\\Game.cpp\tIn member function 'void Game::setComp(entt::entity, entt::id_type)':\r\n67\t36\tF:\\l_3\\a1\\src\\OBJ\\GAME\\Game.cpp\t[Error] 'class entt::internal::storage_proxy_iterator<entt::internal::dense_map_iterator<__gnu_cxx::__normal_iterator<entt::internal::dense_map_node<unsigned int, std::unique_ptr<entt::basic_sparse_set<entt::entity>, std::default_delete<entt::basic_sparse_set<entt::entity> > > >*, std::vector<entt::internal::dense_map_node<unsigned int, std::unique_ptr<entt::basic_sparse_set<entt::entity>, std::default_delete<entt::basic_sparse_set<entt::entity> > > >, std::allocator<entt::internal::dense_map_node<unsigned int, std::unique_ptr<entt::basic_sparse_set<entt::entity>, std::default_delete<entt::basic_sparse_set<entt::entity> > > > > > > > >' has no member named 'emplace'\r\n\r\n\r\n'''\r\n\r\ni was triying with entt::tag and entt::integral_constant but get errors relate with no const initialization.\r\n\r\nany other sugestion or basic snipet that achieve the same?? thanks for you time.\r\n"
      },
      {
        "user": "peeterdog",
        "created_at": "2022-10-20T22:20:53Z",
        "body": "Finally i decided to use a template solution. For nested function calls i modified some other stuff make them templates too.. ... \r\n\r\n\r\n\t\tvoid setComp(const entt::entity e)\r\n\t\t\t{\r\n                       m_registry.emplace<T>(e);\r\n\t\t\t}\r\n\r\n\r\nFor now this simple aproach works super fast in main loop.. im still searching for a param solution..."
      },
      {
        "user": "peeterdog",
        "created_at": "2022-10-20T22:35:05Z",
        "body": "Im really sorry for the mess my browser is very old and my conection is about 10 KB/s and all stuff with asycronous load like actions menu in the posts wont load so i cant edit or delete posts...  i forgot to put  template stuff\r\n\r\n\t\ttemplate <typename T>\r\n\t\tvoid setComp(const entt::entity e)\r\n\t\t\t{\r\n                       m_registry.emplace<T>(e);\r\n\t\t\t}\r\n\r\n:)\r\n\r\n"
      },
      {
        "user": "skypjack",
        "created_at": "2022-10-22T16:40:45Z",
        "body": "No worries at all. I'm glad you solved. Closing the issue then. üëç "
      }
    ]
  },
  {
    "number": 938,
    "title": "About setting shared_ptr value to meta_data using data.set(instance, value)",
    "created_at": "2022-09-24T08:22:20Z",
    "closed_at": "2022-10-07T06:47:19Z",
    "labels": [
      "question",
      "solved"
    ],
    "url": "https://github.com/skypjack/entt/issues/938",
    "body": "I have registered a by-reference shared_ptr getter, but I cannot set value using `data.set(instance, value)`, the following code shows what I mean:\r\n```C++\r\nclass TestClass\r\n{\r\npublic:\r\n\tstd::shared_ptr<int32_t> IntPtr;\r\n};\r\n\r\nstruct TestComponent\r\n{\r\n\tstd::shared_ptr<TestClass> TestPtr;\r\n\tTestComponent() = default;\r\n\tTestComponent(const TestComponent&) = default;\r\n\r\n        std::shared_ptr<int32_t>& GetIntPtr() const { return TestPtr->IntPtr; } // Here I return the non const reference\r\n};\r\n\r\nint main()\r\n{\r\n        using namespace entt::literals;\r\n\tentt::meta<TestComponent>().type().data<nullptr, &TestComponent::GetIntPtr, entt::as_ref_t>(\"TestPtr\"_hs); // Here I register the data by ref\r\n\r\n\tentt::registry reg;\r\n\tauto entity = reg.create();\r\n\tauto& testComp = reg.emplace<TestComponent>(entity);\r\n\ttestComp.TestPtr = std::make_shared<TestClass>();\r\n\tentt::meta_any compInstance{ entt::forward_as_meta(testComp) };\r\n\tconst auto compType = compInstance.type();\r\n\tfor (const auto data : compType.data())\r\n\t{\r\n\t\tdata.set(compInstance, std::make_shared<int32_t>()); // After this, the IntPtr of TestPtr is still nullptr\r\n\t}\r\n}\r\n```\r\nIs there anything I am missing? Please help, thanks!",
    "comments_url": "https://api.github.com/repos/skypjack/entt/issues/938/comments",
    "author": "hls333555",
    "comments": [
      {
        "user": "skypjack",
        "created_at": "2022-09-24T11:31:02Z",
        "body": "I mean, by doing this:\n```cpp\n.data<nullptr, &TestComponent::GetIntPtr, entt::as_ref_t>\n```\nYou're literally creating a read-only property (no setter). If you check the return value of `set`, it likely converts to false.  \nYou don't even need the `GetIntPtr` for the getter by the way. The following should work (take this with a grain of salt, I'm from mobile):\n```cpp\n.data<&TestComponent::TestPtr, entt::as_ref_t>\n```\nIf you've still problems, let me know but also get prepared to wait until Monday since I'm out of home."
      },
      {
        "user": "skypjack",
        "created_at": "2022-09-28T12:58:16Z",
        "body": "I assume this is answered. Let me know if this isn't the case. Otherwise I'll close the issue in a few days. üëç "
      }
    ]
  },
  {
    "number": 937,
    "title": "Collector for construct and destruct?",
    "created_at": "2022-09-23T12:50:14Z",
    "closed_at": "2022-09-23T13:23:27Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/skypjack/entt/issues/937",
    "body": "When using class `entt::observer`, only collector for update signal `entt::collector.update` is available. But we do have three kinds of signals associated with component. Perhaps for some reasons Entt cannot add them?\r\n\r\nIt's not a feature request. Just for curiosity. Maybe don't be worried about adding them.",
    "comments_url": "https://api.github.com/repos/skypjack/entt/issues/937/comments",
    "author": "ShenCiao",
    "comments": [
      {
        "user": "skypjack",
        "created_at": "2022-09-23T13:00:10Z",
        "body": "Poorly named, but that's `.group<T>`. üëç \r\nOtherwise, you can just use an `entt::storage<void>` and connect it to the registry signals. Then you can construct a view with it as in `entt::basic_view view{storage}` and combine it with other views from the registry as in `view | registry.view<U, V>()`.\r\n"
      },
      {
        "user": "ShenCiao",
        "created_at": "2022-09-23T13:06:22Z",
        "body": "My stupidness definitely gonna kill myself. I've read the document about `.group<T>`  four or five times but never realize it can do thatüòµ. I will have a try on it."
      },
      {
        "user": "skypjack",
        "created_at": "2022-09-23T13:12:44Z",
        "body": "No worries at all. It's definitely not your fault. üëç "
      },
      {
        "user": "ShenCiao",
        "created_at": "2022-09-23T13:23:27Z",
        "body": "Great thanks. It works exactly same as my expectation. I used to thought `.group<T>` is working exactly same as `entt::group<T>`."
      }
    ]
  },
  {
    "number": 936,
    "title": "About setting value to entt::meta_data",
    "created_at": "2022-09-20T08:46:39Z",
    "closed_at": "2022-09-21T08:47:13Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/skypjack/entt/issues/936",
    "body": "I have a generic buffer(void*) storing an arbitrary value, I just want to set this buffer back to meta_data using memcpy instead of using the strong type setter(`entt::meta_data.set(instance, value)`), I can get the raw data by `entt::meta_data.get(instance).data()`, but copying memory data seems not work. Is there any way to achieve this? Thanks!",
    "comments_url": "https://api.github.com/repos/skypjack/entt/issues/936/comments",
    "author": "hls333555",
    "comments": [
      {
        "user": "skypjack",
        "created_at": "2022-09-20T11:54:40Z",
        "body": "Well, if you **do** want to use `memcpy` (and I'm tempted to discourage this), you've the `void *` for the source and the destination already while the meta type also returns you the _size_ of the underlying type. That is, you've all you need for a `memcpy`.\r\nWhat's exactly the problem? I don't fully get it to be honest. Sorry. My advice is still to use a _setter_ after a call to `meta_type::from_void` if you want to stay in the erased field without incurring the risks of a `memcpy`."
      },
      {
        "user": "hls333555",
        "created_at": "2022-09-20T12:13:15Z",
        "body": "> Well, if you **do** want to use `memcpy` (and I'm tempted to discourage this), you've the `void *` for the source and the destination already while the meta type also returns you the _size_ of the underlying type. That is, you've all you need for a `memcpy`. What's exactly the problem? I don't fully get it to be honest. Sorry. My advice is still to use a _setter_ after a call to `meta_type::from_void` if you want to stay in the erased field without incurring the risks of a `memcpy`.\r\n\r\nThanks for the reply!\r\nIn fact, I do not stick to using `memcpy`, all I want is to set value to data directly using my buffer (void* pointer) without doing a type casting. However, I cannot find `from_void()` and I don't know how to call this. Please help. Thanks a lot!\r\n\r\nAnd here's my test code:\r\n```C++\r\nstruct TestComponent\r\n{\r\n\tfloat FloatVar;\r\n\tTestComponent() = default;\r\n\tTestComponent(const TestComponent&) = default;\r\n};\r\n\r\nint main()\r\n{\r\n        using namespace entt::literals;\r\n\tentt::meta<TestComponent>().type().data<&TestComponent::FloatVar>(\"FloatVar\"_hs);\r\n\r\n\tentt::registry reg;\r\n\tauto entity = reg.create();\r\n\tauto& testComp = reg.emplace<TestComponent>(entity);\r\n\ttestComp.FloatVar = 100.0f;\r\n\tentt::meta_any compInstance{ entt::forward_as_meta(testComp) };\r\n\tconst auto compType = compInstance.type();\r\n\tuint8_t* buffer = new uint8_t[4];\r\n\t*reinterpret_cast<float*>(buffer) = 4.0f;\r\n\tfor (const auto data : compType.data())\r\n\t{\r\n\t\tvoid* d = data.get(compInstance).data();\r\n\t\tfloat bufferV = *reinterpret_cast<float*>(buffer); // Here is 4.0f\r\n\t\tmemcpy(d, buffer, 4); // After memcpy, the FloatVar is still 100.0f\r\n\t}\r\n\tdelete[] buffer;\r\n}\r\n```\r\nEdit: After digging into memory, I have found that the data address returned from `meta_any::data()` is not stable, I actually set to a not-persist data location when calling `memcpy()` . When calling `meta_any::data()` again after `memcpy()`, the address has changed. Is there a way to get the stable data address or any other way to achieve this?"
      },
      {
        "user": "skypjack",
        "created_at": "2022-09-20T13:34:11Z",
        "body": "`meta_type::from_void` is available on `master` but it isn't part of a release yet.\r\nAs for the pointer stability, the address of the underlying element doesn't change unless you move the containing object (in this case, it only changes if the element is embedded, otherwise it's still stable).\r\n"
      },
      {
        "user": "hls333555",
        "created_at": "2022-09-20T13:37:38Z",
        "body": "> `meta_type::from_void` is available on `master` but it isn't part of a release yet. As for the pointer stability, the address of the underlying element doesn't change unless you move the containing object (in this case, it only changes if the element is embedded, otherwise it's still stable).\r\n\r\nThanks! But it seems that I do not explicitly move the TestComponent above, and it still does not work. Could you please help me fix the above code? Thanks!"
      },
      {
        "user": "skypjack",
        "created_at": "2022-09-21T06:43:21Z",
        "body": "You're not telling to meta to return your data member by reference. Therefore, it's returned by copy.\r\nWhat you want is likely the following:\r\n```cpp\r\n.data<&TestComponent::FloatVar, entt::as_ref_t>(\"FloatVar\"_hs)\r\n````\r\nOtherwise `data.get(compInstance)` returns a copy of the underlying object and this:\r\n```cpp\r\nvoid* d = data.get(compInstance).data();\r\n```\r\nIs a free ticket for a dangling pointer. üôÇ "
      },
      {
        "user": "hls333555",
        "created_at": "2022-09-21T07:13:00Z",
        "body": "> You're not telling to meta to return your data member by reference. Therefore, it's returned by copy. What you want is likely the following:\r\n> \r\n> ```c++\r\n> .data<&TestComponent::FloatVar, entt::as_ref_t>(\"FloatVar\"_hs)\r\n> ```\r\n> \r\n> Otherwise `data.get(compInstance)` returns a copy of the underlying object and this:\r\n> \r\n> ```c++\r\n> void* d = data.get(compInstance).data();\r\n> ```\r\n> \r\n> Is a free ticket for a dangling pointer. üôÇ\r\n\r\n\r\nThanks for explanation! However, I have another question, if my float variable uses getter and setter like this:\r\n```C++\r\nfloat GetValue() const { return FloatVar; }\r\nvoid SetValue(float value) { FloatVar = value; }\r\n```\r\nIn this case, I cannot register the data using `entt::as_ref_t`, so that I am not able to use `memcpy` to properly copy my buffer to the data right? I know maybe I can register a by-reference-getter(`float& GetValue() { return FloatVar; }`) to use `entt::as_ref_t`, but is is a bit weird. Is there a better way to solve this? Thanks!"
      },
      {
        "user": "skypjack",
        "created_at": "2022-09-21T07:18:28Z",
        "body": "Well, the policy is **always** available and you can pass `entt::as_ref_t` also when using a setter and getter pair.\r\nAs you correctly pointed out, the problem is your getter that returns the element by copy. Meta cannot really work around it.\r\nIn this case, you're literally saying (as an user): _I'll never ever return this data member by reference and my getter prevents it_.\r\nSo, no, there is not an easy way to get around the will of the final user in general. üôÇ "
      },
      {
        "user": "hls333555",
        "created_at": "2022-09-21T08:46:53Z",
        "body": "> Well, the policy is **always** available and you can pass `entt::as_ref_t` also when using a setter and getter pair. As you correctly pointed out, the problem is your getter that returns the element by copy. Meta cannot really work around it. In this case, you're literally saying (as an user): _I'll never ever return this data member by reference and my getter prevents it_. So, no, there is not an easy way to get around the will of the final user in general. üôÇ\r\n\r\nThanks for your help! I am sure what I should do now!"
      },
      {
        "user": "skypjack",
        "created_at": "2022-09-21T09:29:34Z",
        "body": "You're welcome. üëç üôÇ "
      }
    ]
  },
  {
    "number": 907,
    "title": "Is there a way to listen to ctx updates?",
    "created_at": "2022-07-09T10:09:07Z",
    "closed_at": "2022-07-26T07:43:55Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/skypjack/entt/issues/907",
    "body": "Hi,\r\nIs there a way to connect/disconnect to context variable updates? similar to how we can subscribe to component updates through `registry.on_construct/on_destruct`?\r\nThanks",
    "comments_url": "https://api.github.com/repos/skypjack/entt/issues/907/comments",
    "author": "grimaldini",
    "comments": [
      {
        "user": "skypjack",
        "created_at": "2022-07-10T10:01:24Z",
        "body": "Hi, no, there is no built-in way, but you can still attach an observable object to the context and achieve your goal, no?"
      },
      {
        "user": "grimaldini",
        "created_at": "2022-07-11T02:39:48Z",
        "body": "do you have a sample or blog on how to achieve this with an observer object? I'm assuming you are referring to the observer in the Reactive System section of the wiki... however, the description and usage is a bit unclear, if you could point me to a sample, it might help, thanks"
      },
      {
        "user": "skypjack",
        "created_at": "2022-07-11T07:36:26Z",
        "body": "No, sorry. I got the covid and I replied/am replying in a bit of a hurry because I'm left behind with some things at the moment. üôÅ \r\nI'm not referring to the observer class. Quite the opposite. I mean that you can just turn or wrap your type `T` into an observable class that also emits signals, then attach the latter to the context.\r\n"
      },
      {
        "user": "grimaldini",
        "created_at": "2022-07-11T20:41:30Z",
        "body": "oh no, feel better!"
      },
      {
        "user": "skypjack",
        "created_at": "2022-07-12T09:44:30Z",
        "body": "Eh, a 6-year-old son going to school is literally a sentence! üòÖ "
      },
      {
        "user": "skypjack",
        "created_at": "2022-07-26T07:43:55Z",
        "body": "I think we can close this issue. Feel free to reopen it or create a new one if there are still doubts. Thank you."
      }
    ]
  },
  {
    "number": 900,
    "title": "Components does not auto-delete? ",
    "created_at": "2022-06-20T18:01:23Z",
    "closed_at": "2022-06-23T13:15:25Z",
    "labels": [
      "question",
      "solved"
    ],
    "url": "https://github.com/skypjack/entt/issues/900",
    "body": "Hi,\r\nI'm working on a ECS-based game-engine project currently, and I noticed something - regardless if I delete the `storage` for an already unused component/class_type/pool, all previously retrieved component's references are still intact and their memory is still allocated. \r\nI'm trying to delete the memory allocation of a component's instance when the `registry`'s `remove<Component>` method is called.\r\nAm I missing something and is there a possibility to retrieve the allocated memory addresses (pointers in this case) for all created, by `emplace`, Components and delete them?",
    "comments_url": "https://api.github.com/repos/skypjack/entt/issues/900/comments",
    "author": "DMitev11",
    "comments": [
      {
        "user": "skypjack",
        "created_at": "2022-06-21T07:02:59Z",
        "body": "> all previously retrieved component's references are still intact and their memory is still allocated\r\n\r\nWhat do you mean with _references are still intact_? When you delete a component, its destructor is invoked. When you clear or throw away a storage, all components are destroyed and the memory is released.\r\nHowever, this has no effect on a _reference_, which is dangling though, as in:\r\n```cpp\r\nint *value = new int{42};\r\nint &ref = *value;\r\ndelete value;\r\nref = 0;\r\n```\r\nThe code above may or may not work as expected, since all expectations are wrong in any case. This is pretty much what happens when you've an undefined behavior. This is how C++ works too. I don't know what you expect to happen to your references instead."
      },
      {
        "user": "skypjack",
        "created_at": "2022-06-23T06:00:22Z",
        "body": "I assume this was answered. I'll close the issue in a couple of days if there are no other comments/doubts. üëç"
      },
      {
        "user": "DMitev11",
        "created_at": "2022-06-23T13:11:36Z",
        "body": "Hello, \r\nApologies for the late reply - haven't seen the answer earlier. \r\nTo clarify, as the question perhaps was kind of ambiguous - I had a case of components still being memory allocated and callable, although deleted through `remove` component.\r\nThe Issue I had was that only the pointers to the components, from the storage, not the allocation itself (tracked through the `memory profiler` of VS) was getting deleted. Apparently I've missed writing the destructors of the classes I use for `components`. \r\nApologies again for misleading, and thanks for the quick response!"
      },
      {
        "user": "skypjack",
        "created_at": "2022-06-23T13:13:04Z",
        "body": "No worries at all. So, did you solve it in the end?"
      },
      {
        "user": "DMitev11",
        "created_at": "2022-06-23T13:13:31Z",
        "body": "@skypjackI I still have a short question - is it an intended behaviour that a `storage` allocation for a class/identifier is created after creating a component of the type, but not deleted after removing the last reference of the component type to an entity? \r\n\r\nI have a small piece of code deleting the `storage` from the `registry`, after the `size` of it is equal to 0, but I am not entirely sure about the behaviour it could have later on during runtime\r\n"
      },
      {
        "user": "DMitev11",
        "created_at": "2022-06-23T13:14:38Z",
        "body": "> No worries at all. So, did you solve it in the end?\r\n\r\nI did indeed - all pointers to the components seem to throw exceptions when calling them, after removing the component from the corresponding entity. Thanks\r\n"
      },
      {
        "user": "skypjack",
        "created_at": "2022-06-23T13:15:18Z",
        "body": "You're welcome. üôÇ "
      }
    ]
  },
  {
    "number": 897,
    "title": "Single component basic_view::get returning tuple",
    "created_at": "2022-06-16T01:37:40Z",
    "closed_at": "2022-06-16T07:54:06Z",
    "labels": [
      "question",
      "solved"
    ],
    "url": "https://github.com/skypjack/entt/issues/897",
    "body": "Is it intended that you can no longer call `registry.view<T>().get(id)` without specifying a component type or index?",
    "comments_url": "https://api.github.com/repos/skypjack/entt/issues/897/comments",
    "author": "james4k",
    "comments": [
      {
        "user": "skypjack",
        "created_at": "2022-06-16T05:59:05Z",
        "body": "Yes, it is. The API of the views (multi and single type) were unified a while ago.\r\nOn the other hand, you've an `operator[]` on the single type view that also takes an entity and returns its component:\r\n```cpp\r\nauto &&value = view[entity];\r\n```"
      },
      {
        "user": "james4k",
        "created_at": "2022-06-16T07:54:06Z",
        "body": "Ah, the operator is probably what I want. I feel like I'm too adverse to multi views, too. Thanks!"
      },
      {
        "user": "skypjack",
        "created_at": "2022-06-16T07:55:11Z",
        "body": "You're welcome. üôÇ "
      }
    ]
  },
  {
    "number": 895,
    "title": "Runtime generated components?",
    "created_at": "2022-06-13T02:10:04Z",
    "closed_at": "2022-07-03T10:04:36Z",
    "labels": [
      "question",
      "solved"
    ],
    "url": "https://github.com/skypjack/entt/issues/895",
    "body": "Hello, I'm currently looking into if I can replace a custom ECS framework I built for one of my projects with Entt. The main reason I built my own is that I need to be able to generate components at runtime. \r\nMy current workflow is like this: First, create a list of variable types, then initialize an instance of a component definition class that figures out the required memory size and offset/padding for each variable, it also stores constructors/destructors if necessary. Then that definition can be used by the entity manager instead of a struct to create archetypes. \r\nIs this currently possible with the Entt reflection system? And if it is not could it be easily added in?",
    "comments_url": "https://api.github.com/repos/skypjack/entt/issues/895/comments",
    "author": "WireWhiz",
    "comments": [
      {
        "user": "skypjack",
        "created_at": "2022-06-13T06:33:06Z",
        "body": "Before answering, let me ask thi: are component types known beforehand? I mean, when you say:\r\n\r\n>  then initialize an instance of a component definition class that figures out the required memory size and offset/padding for each variable\r\n\r\nAre you just trying to figure out what you want from a fixed set of known types (because, well, C++ is a strongly typed language, you know) or are you creating a _fake runtime type_ as it happens for example in a js engine?"
      },
      {
        "user": "WireWhiz",
        "created_at": "2022-06-13T07:26:53Z",
        "body": "The types that are going to be used for the component members are known at compile time. I use templates to create the types themselves, so it looks something like this:\r\n```\r\n        std::vector<std::unique_ptr<VirtualType>> members;\r\n\tmembers.push_back(std::make_unique<VirtualVariable<bool>>());\r\n\tmembers.push_back(std::make_unique<VirtualVariable<int32_t>>());\r\n\tmembers.push_back(std::make_unique<VirtualVariable<float>>());\r\n\tmembers.push_back(std::make_unique<VirtualVariable<std::string>>());\r\n\r\n\tComponentDefinition component(members, \"component id\");\r\n```"
      },
      {
        "user": "skypjack",
        "created_at": "2022-06-13T09:47:17Z",
        "body": "So, all your components have type `std::vector<std::unique_ptr<VirtualType>>`, right?\r\nKind of at least, for example type `T` that is a tiny wrapper around the vector above. Do I get it correctly?\r\n"
      },
      {
        "user": "WireWhiz",
        "created_at": "2022-06-13T16:50:28Z",
        "body": "Pretty much"
      },
      {
        "user": "skypjack",
        "created_at": "2022-06-14T06:43:48Z",
        "body": "You can create multiple pools of the same type using the `storage` function, as long as you give them a different _name_."
      },
      {
        "user": "WireWhiz",
        "created_at": "2022-06-14T07:53:15Z",
        "body": "So it would be relatively simple to create components that only have one member, just a matter of creating a type for each one and then naming them at runtime with the storage system right? Would that mean that if I wanted to create components with multiple members I would need to have every combination of members that I wanted to support be defined in types at compile time? "
      },
      {
        "user": "skypjack",
        "created_at": "2022-06-14T08:10:38Z",
        "body": "ü§î Uhm, no, I'd rather create a bunch of named pools for `std::vector<std::unique_ptr<VirtualType>>`.\r\nTwo pools, two _components_, as many members as you want. Am I missing something?"
      },
      {
        "user": "WireWhiz",
        "created_at": "2022-06-14T19:23:03Z",
        "body": "In my current implementation, VirtualType and ComponentDescritption don't actually store the type, just info about its size and construct/desctruct/copy/move operations. They're passed off to my equivalent of a pool and all the data is stored contiguously in chunks/pages using the ComponentDescritption to know how to interact with the data. If possible I would like to keep the data stored contiguously instead of referencing each member with pointers. "
      },
      {
        "user": "skypjack",
        "created_at": "2022-06-16T06:05:20Z",
        "body": "I think I'm missing something, sorry. You've said that your _types_ are not actual C++ type. Instead, they are maps of _fake_ members (literally pointers to `VirtualType`). Then you said that these _types_ and descriptors are just metadata for existing C++ types.\r\nI'd love to help you and provide you with a way to do what you're trying to achieve, but I'm pretty confused at the moment."
      },
      {
        "user": "codylico",
        "created_at": "2022-06-16T13:20:55Z",
        "body": "If I understand correctly, your _types_ are not actual C++ types. Instead, they are maps of _real_ C++ members _described by_ pointers to `VirtualType`. Both the `VirtualType` and the (`ComponentDefinition`/ComponentDescritption) descriptors are just metadata for existing C++ types, and are _not_ stored in any pool or other thing. However, `struct` instances built using a ComponentDescritption _are_ stored in pools and assigned to actual entity identifiers.\r\n\r\nIt's as if you write this (using a made-up method `build` for demonstration):\r\n```c++\r\n\tstd::vector<std::unique_ptr<VirtualType>> members;\r\n\tmembers.push_back(std::make_unique<VirtualVariable<bool>>());\r\n\tmembers.push_back(std::make_unique<VirtualVariable<int32_t>>());\r\n\tmembers.push_back(std::make_unique<VirtualVariable<float>>());\r\n\tmembers.push_back(std::make_unique<VirtualVariable<std::string>>());\r\n\r\n\tComponentDefinition component(members, \"component id\");\r\n        // ...\r\n\truntime_type* ptr = pool.build(component);\r\n```\r\n... instead of this:\r\n```c++\r\n\tstruct runtime_type {\r\n\t\tbool a;\r\n\t\tint32_t b;\r\n\t\tfloat c;\r\n\t\tstd::string d;\r\n\t};\r\n\truntime_type* ptr = pool.build<runtime_type>();\r\n```\r\n... because you _don't_ know the `runtime_type` beforehand. Do I understand that correctly?"
      },
      {
        "user": "WireWhiz",
        "created_at": "2022-06-16T20:26:11Z",
        "body": "> If I understand correctly, your _types_ are not actual C++ types. Instead, they are maps of _real_ C++ members _described by_ pointers to `VirtualType`. Both the `VirtualType` and the (`ComponentDefinition`/ComponentDescritption) descriptors are just metadata for existing C++ types, and are _not_ stored in any pool or other thing. However, `struct` instances built using a ComponentDescritption _are_ stored in pools and assigned to actual entity identifiers.\r\n\r\nYep, that is exactly what I'm doing."
      },
      {
        "user": "skypjack",
        "created_at": "2022-06-18T13:40:50Z",
        "body": "Ahaaaa ok, so what you want is to store ie all `VirtualVariable<bool>` tightly packed somewhere, then all `VirtualVariable<float>` all tightly packed somewhere else and so on? Or the other way around, that is, all _members_ of a single objects tightly packed, then all members of the next object and so on?"
      },
      {
        "user": "WireWhiz",
        "created_at": "2022-06-20T06:18:49Z",
        "body": "Currently, in my own code, I use the second method and have all the members of an object packed together. Would it make more sense for performance to do it the other way? "
      },
      {
        "user": "skypjack",
        "created_at": "2022-06-21T07:05:01Z",
        "body": "You don't have them packed together if you create them using `std::make_unique`. You've all the pointers to the base class packed together instead. However, every time you try to access a component, you jump somewhere in memory."
      },
      {
        "user": "WireWhiz",
        "created_at": "2022-06-21T07:24:17Z",
        "body": "Only the metadata for the types was created with std::make_unique, and I've since refactored it so that I pass in an array of enums representing the types I want as members to ComponentDescriptions. When actually storing objects described by said description I use a switch statement to find the right constructor for each member and 'new(void*) T' to emplace the type in a paged array of bytes that's used for the actual storage of the components. I do a similar thing for move/copy/destruct operations between archetypes (as my current system is archetypal) "
      },
      {
        "user": "WireWhiz",
        "created_at": "2022-06-21T07:27:16Z",
        "body": "The main question I have is if I could quickly set up a system like this or better in Entt, as it would probably be better for performance. Or if I should continue extending my own system. "
      },
      {
        "user": "codylico",
        "created_at": "2022-06-21T15:07:11Z",
        "body": "To clarify, the `VirtualVariable<T>` is metadata meant to help describe the component; the `VirtualVariable<T>` not store anything, which is _why_ you were able to replace it with an enumeration. Do I understand correctly?\r\n\r\nI wonder if `VirtualVariable<T>` and `ComponentDescription` are trying to do something similar to `meta_type`...."
      },
      {
        "user": "WireWhiz",
        "created_at": "2022-06-21T15:14:21Z",
        "body": "Yes, VirtualVariable did not store anything. It was a template that allowed me to access the constructor/destructor/copy/move functions of types through virtual functions."
      },
      {
        "user": "skypjack",
        "created_at": "2022-06-22T06:58:55Z",
        "body": "> I wonder if VirtualVariable<T> and ComponentDescription are trying to do something similar to meta_type....\r\n\r\n@codylico I wouldn't say so, mostly because his types aren't backed by actual C++ types (we agreed on this, right? üòÖ).\r\n\r\n> The main question I have is if I could quickly set up a system like this or better in Entt, as it would probably be better for performance. Or if I should continue extending my own system.\r\n\r\nIt's your call. I can't tell you to go a way or the other.\r\n\r\nThe way you've implemented it triggers a lot of jumps in memory, literally one for every member you want to access.\r\nYou can likely do better but it really depends on your access patterns. For example, if you want to elaborate a single object at a time and therefore all its members at once, the tradeoff is probably between performance and memory usage. That is, you can store them in a buffer that is large enough to store the largest basic type (or most of them at least, like an `entt::any` with a proper size). This way, you can highly reduce the number of jumps by paying the price in terms of memory usage.\r\nTake this with a grain of salt though, I'm just throwing at you my first thoughts."
      },
      {
        "user": "skypjack",
        "created_at": "2022-06-29T05:49:40Z",
        "body": "The issue is starving. I assume it was answered though. I'll close it in a couple of days if no other comments show up. Thanks."
      }
    ]
  },
  {
    "number": 893,
    "title": "Question : Is it possible to add components (of the same type) while iterating a view?",
    "created_at": "2022-06-05T08:09:42Z",
    "closed_at": "2022-06-07T09:25:13Z",
    "labels": [
      "question",
      "solved"
    ],
    "url": "https://github.com/skypjack/entt/issues/893",
    "body": "Currently, I've created a component (named [ScriptingComponent] ) to contain all user-defined scripts attached to an entity. However, when I was iterating through all of the OnUpdate() functions in scripts with a view, user might need to create entities. During the creation process, [ScriptingComponent] is attached to an entity as default, because one might need to add scripts right afterward. Due to the reason, delay wouldn't be optimal.\r\n\r\nSo, is it possible to add components (of the same type) while iterating a view? Or, are there any other alternatives that I could take?\r\n\r\n(Below is a simplified version of what I'm doing)\r\n```\r\nauto view = registry.view<ScriptingComponent>();\r\nfor (auto e : view)\r\n{\r\n    auto& scriptingComponent = view.get<ScriptingComponent>(e);\r\n    for (Script* script : scriptingComponent.Scripts)\r\n    {\r\n        script->OnUpdate();\r\n    }\r\n}\r\n``` \r\n```\r\nvoid SomeScript::OnUpdate()\r\n{\r\n    // Create an additional entity\r\n    auto entity = registry.create();\r\n    // Adding a component while the view is still alive\r\n    registry.emplace<ScriptingComponent>(entity);\r\n}\r\n```",
    "comments_url": "https://api.github.com/repos/skypjack/entt/issues/893/comments",
    "author": "Oolalalalala",
    "comments": [
      {
        "user": "skypjack",
        "created_at": "2022-06-06T11:36:22Z",
        "body": "Yes, it is. Even more, references to already existing components aren't invalidated if you add new instances.\nThe documentation should contain all the details already. Let me know if something is unclear."
      },
      {
        "user": "Oolalalalala",
        "created_at": "2022-06-07T05:54:36Z",
        "body": "That's what I thought in the first place, too. But there's a bug in my code and I can't quite find it. However, I have reproduced the same error with the following code.\r\n\r\n```\r\n#include <iostream>\r\n#include <unordered_map>\r\n#include \"entt.hpp\"\r\n\r\nentt::registry reg;\r\nclass Script;\r\n\r\nstruct ScriptingComponent\r\n{\r\n\tstd::unordered_map<int, Script*> Scripts;\r\n};\r\n\r\nclass Script\r\n{\r\npublic:\r\n\tvoid OnUpdate()\r\n\t{\r\n\t\tcounter++;\r\n\t\tif (counter % 20 == 0) // Add a new entity per 20 updates\r\n\t\t{\r\n\t\t\tentt::entity e = reg.create();\r\n\t\t\treg.emplace<ScriptingComponent>(e);\r\n\t\t}\r\n\t\tstd::cout << \"Counter = \" << counter << \"\\n\";\r\n\t}\r\nprivate:\r\n\tint counter = 0;\r\n};\r\n\r\nint main()\r\n{\r\n\tentt::entity et = reg.create();\r\n\tauto& scriptingComponent = reg.emplace<ScriptingComponent>(et);\r\n\tscriptingComponent.Scripts.emplace(1, new Script());\r\n\r\n\twhile (1)\r\n\t{\r\n\t\tauto view = reg.view<ScriptingComponent>();\r\n\t\tfor (auto e : view)\r\n\t\t{\r\n\t\t\tauto& scripts = view.get<ScriptingComponent>(e).Scripts;\r\n\t\t\tfor (auto [idx, script] : scripts)\r\n\t\t\t{\r\n\t\t\t\tscript->OnUpdate();\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\nIt seems to work fine if I store the scripts with std::vector, but with std::unordered_map, the program throws an **Access Violation Error**. The unordered_map seems to become invalid when I add [ ScriptingComponent ] to an entity. Am I doing something incorrectly or misunderstanding anything? "
      },
      {
        "user": "Innokentiy-Alaytsev",
        "created_at": "2022-06-07T07:44:46Z",
        "body": "Wouldn't the reference be invalidated due to component pool reallocation during growth? Does this behaviour somehow depend on whether pointer stability is enabled or not?"
      },
      {
        "user": "skypjack",
        "created_at": "2022-06-07T07:54:06Z",
        "body": "Newest releases don't invalidate in this case.\n@Oolalalalala what version of EnTT are you using? This will help to figure it out.\n"
      },
      {
        "user": "Oolalalalala",
        "created_at": "2022-06-07T08:31:18Z",
        "body": "I'm currently using version 3.4.0. So, updating the version would help solve the issue?"
      },
      {
        "user": "skypjack",
        "created_at": "2022-06-07T08:44:04Z",
        "body": "Oh, yeah, transparent pointer stability on creation was added with a later version.\nI'm from mobile and I can't check right away but it's likely v3.7 or v3.8?"
      },
      {
        "user": "Oolalalalala",
        "created_at": "2022-06-07T08:53:10Z",
        "body": "Thanks a lot, @skypjack.\r\nThe issue seems to have been gone in the test when I switch to the latest version.\r\nI will later make changes to my project and hope everything works fine."
      },
      {
        "user": "skypjack",
        "created_at": "2022-06-07T09:16:49Z",
        "body": "You're welcome. I'm glad to help."
      }
    ]
  },
  {
    "number": 891,
    "title": "Issue emplacing component to entity",
    "created_at": "2022-05-28T23:42:30Z",
    "closed_at": "2022-06-03T15:12:42Z",
    "labels": [
      "question",
      "solved"
    ],
    "url": "https://github.com/skypjack/entt/issues/891",
    "body": "Hi,\r\n\r\nI am getting the following error:\r\n`Assertion failed: (entity_traits::to_version(elem) == entity_traits::to_version(tombstone)), function assure_at_least, file sparse_set.hpp, line 210.`\r\n\r\nwhen I emplace a component to an entity that I know is alive (because I have printed out all the entities that have been \"destroyed\" by calling the method destroy and I didn't see that one on the list). The emplace happens within a view each and the entity that I am emplacing the component to is the current entity.\r\n\r\nI basically only call destroy from one single place in the codebase. I am assuming that this error message refers to a emplacing a component to an invalid/tombstoned entity, is that right? if so or not, what could be another situation when this message is shown?\r\nP.S. I am not using the in-place delete functionality.\r\n\r\nThanks",
    "comments_url": "https://api.github.com/repos/skypjack/entt/issues/891/comments",
    "author": "grimaldini",
    "comments": [
      {
        "user": "skypjack",
        "created_at": "2022-05-29T07:49:57Z",
        "body": "Can I ask you what version of EnTT is it? I can't find this line of code anymore. üòÖ \r\nAnyway, at a first glance, this is what replaced it:\r\n```cpp\r\nENTT_ASSERT(elem == null, \"Slot not available\");\r\n```\r\nIt states that the set already contains the component. So, roughly speaking, you're adding a component to an entity that has an instance of the same type already.\r\nYou can try to assert before invoking `emplace` to confirm it."
      },
      {
        "user": "grimaldini",
        "created_at": "2022-05-29T12:38:04Z",
        "body": "I am based off commit a03b88e0eb679ca0fbb79d9c54293e772b4f4a93 \"dense_hash_[map/set]: suppress super annoying warnings\".\r\n\r\n> So, roughly speaking, you're adding a component to an entity that has an instance of the same type already.\r\n\r\nSo, you are saying that the entity already has the same component added to it?"
      },
      {
        "user": "skypjack",
        "created_at": "2022-05-29T13:11:52Z",
        "body": "It looks so from the error, yeah. Hard to confirm 100% without a repro though."
      },
      {
        "user": "grimaldini",
        "created_at": "2022-05-29T14:47:51Z",
        "body": "Ok, that makes sense, I was able to find the issue with your explanation, thanks. Quick question, do you normally use `emplace_or_replace`. I feel that it's hard to keep track of all system dependencies and the components that each add, especially with a large set of systems."
      },
      {
        "user": "skypjack",
        "created_at": "2022-05-29T15:24:01Z",
        "body": "Actually, I don't. The last version of EnTT offers the possibility of getting the storage from a view and this makes passing the registry around pointless. Moreover, the whole library is moving towards a model where you can have storage classes and views but no registry at all if you like."
      },
      {
        "user": "grimaldini",
        "created_at": "2022-05-30T22:00:48Z",
        "body": "Interesting, do you have a post or doc with more details of the model where EnTT is headed to?"
      },
      {
        "user": "skypjack",
        "created_at": "2022-06-01T10:59:12Z",
        "body": "I should but there is not actually. If you have any questions, feel free to drop them here and I'll be glad to answer them."
      },
      {
        "user": "skypjack",
        "created_at": "2022-06-03T15:12:39Z",
        "body": "I'm closing the issue since I think it was answered. Feel free to reopen it if this isn't the case. üëç "
      }
    ]
  },
  {
    "number": 886,
    "title": "What are entity versions used for aside from marking tombstones?",
    "created_at": "2022-05-10T04:03:41Z",
    "closed_at": "2022-05-12T09:58:27Z",
    "labels": [
      "question",
      "solved"
    ],
    "url": "https://github.com/skypjack/entt/issues/886",
    "body": "I have been reading through the documentation and the source for entities and i am a bit confused on what are entity versions used for except for marking tombstones. What i understand is that tombstone entities are identified by a special version number, and that when an entity is removed from a registry the version is incremented (or set explicitly). \r\n\r\nWhat are other possible uses for entity versions (both within the library and in general)?",
    "comments_url": "https://api.github.com/repos/skypjack/entt/issues/886/comments",
    "author": "switch-blade-stuff",
    "comments": [
      {
        "user": "skypjack",
        "created_at": "2022-05-10T09:50:47Z",
        "body": "Identifiers are recycled in `EnTT` since day 0. That is, when you destroy an entity, its version is increased by 1.\r\nImagine to store identifiers aside for some reasons now. For example, in a quad tree. How do you know if that specific entity is still the same or a _recycled_ version with a completely different set of components?\r\nThe version helps with it. You can compare versions and find that the two identifers are not the same element, even though their entity part is the same."
      },
      {
        "user": "switch-blade-stuff",
        "created_at": "2022-05-10T11:03:09Z",
        "body": "I see, thank you! \r\nWhich is why i guess most data-driven systems have entity versions. \r\nCompletely missed that fact, need to get more sleep and less caffeine :D"
      }
    ]
  },
  {
    "number": 878,
    "title": "Is it possible to decay an entt::meta_type which is a pointer?",
    "created_at": "2022-04-25T23:02:31Z",
    "closed_at": "2022-04-28T07:07:13Z",
    "labels": [
      "question",
      "solved"
    ],
    "url": "https://github.com/skypjack/entt/issues/878",
    "body": "For example, say I have the following code:\r\n\r\n```\r\nint* myInt = nullptr;\r\nentt::meta_any meta = myInt;\r\n```\r\n\r\nHow could I get the meta_type for `int` (no pointer) using just the `meta_any` which has a type of `int*`? In versions before 3.10.0 it was possible to do this slightly hacky workaround:\r\n\r\n```\r\nentt::meta_type wrappedType = (*meta).type();\r\n```\r\n\r\nhowever this broke in 3.10.0 if the meta_any has a null value. Is there a supported way to do this?",
    "comments_url": "https://api.github.com/repos/skypjack/entt/issues/878/comments",
    "author": "MatthewLoveday",
    "comments": [
      {
        "user": "skypjack",
        "created_at": "2022-04-26T06:44:27Z",
        "body": "> In versions before 3.10.0 it was possible to do this slightly hacky workaround\r\n\r\nYeah, this was kinda UB I guess. Sort of _safe_ one since you weren't going to use the value but still risky at least.\r\n\r\n> Is there a supported way to do this?\r\n\r\nI guess no (but take this with a grain of salt). However, I think we can make `(*meta).type();` really _safe_ to do.\r\nThe other way around is to add a `remove_pointer` trait or similar but:\r\n* I don't want to add yet another erased function (and thus instantiation) we don't really need most of the times\r\n* It can still be implemented in terms of `(*meta).type();` under the hood and this would be _for free_ (kind of)\r\n\r\nLet me figure it out. I plan to create a v3.10.1 with a couple of small fixes and this one could enter it as well."
      }
    ]
  },
  {
    "number": 877,
    "title": "[Question] destroying multiple entities via registry.destroy()",
    "created_at": "2022-04-25T10:22:08Z",
    "closed_at": "2022-05-02T08:18:51Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/skypjack/entt/issues/877",
    "body": "I'm trying to befriend box2d with entt. This task consists of two parts:\r\n- Tying entity with collision.\r\n- Deleting entity on collision with some specific thing (and because that thing is a mouse pointer - Im using box2d's QueryAABB).\r\n\r\nIn order to achieve first, Im trying to store entity ID inside collision component:\r\n\r\n```cpp\r\nentt::entity ball = registry.create();\r\n\r\nregistry.emplace<BallComponent>(\r\n    ball, &world, ball, pos, size, BLUE,\r\n    b2Vec2{direction.x*speed, -direction.y*speed});\r\n```\r\nAnd then, inside component's constructor - attach pointer to that component to fixture:\r\n\r\n```cpp\r\nclass BallComponent {\r\npublic:\r\n    entt:entity entity_id;\r\n    Color color;\r\n\r\n    BallComponent(\r\n        b2World* world,\r\n        entt::entity eid,\r\n        Vector2 pos,\r\n        float _radius,\r\n        Color _color,\r\n        b2Vec2 velocity) : entity_id(eid), color(_color) {\r\n        // Some code omitted\r\n        b2FixtureDef fixture_def;\r\n        // Some code omitted\r\n        fixture_def.userData.pointer = uintptr_t(this);\r\n        // Some code omitted\r\n    }\r\n};\r\n```\r\n\r\nSo it will be possible to access it on collision and retrieve its public data (including id) via collision handler.\r\nThus far, things work.\r\nI update my collision tree, then try to query collisions that occurred. And thats where things start getting weird\r\n\r\n```cpp\r\n// Everything works, until commented out part\r\n\r\nvoid Level::process_mouse_collisions(b2AABB rect) {\r\n    CollisionQuerryCallback* querry = new CollisionQuerryCallback;\r\n    world.QueryAABB(querry, rect);\r\n\r\n    if (querry->collisions.size() > 0) {\r\n        for (auto collision : querry->collisions) {\r\n            const entt::entity entity_id = collision->entity_id;\r\n            spdlog::info(\r\n                \"Rect collides with with {}\",\r\n                static_cast<uint32_t>(entity_id));\r\n\r\n            auto ball = registry.try_get<BallComponent>(entity_id);\r\n\r\n            if (ball) {\r\n                spdlog::info(\"destroying\");\r\n\r\n                // However stuff commented there has semi-undefined behavior.\r\n                // E.g most of the time it works, but sometimes it either refuses\r\n                // to delete things completely, or delete the wrong entities.\r\n                // Not sure what exactly causes it - entt's documentation specify\r\n                // destruction before the end of update cycle as a fine thing.\r\n                // Unless I've misunderstood something or its only fine in a view?\r\n\r\n                // collision->body->DestroyFixture(collision->body->GetFixtureList());\r\n                // world.DestroyBody(collision->body);\r\n                // // b2Fixture* fixtures = collision->body->GetFixtureList();\r\n                // registry.destroy(entity_id);\r\n            }\r\n        }\r\n    }\r\n\r\n    delete querry;\r\n}\r\n```\r\n\r\nSo yeah - as comment indicates, everything before deletion part seems to work. I think (I've debugged this thing by changing colors of specific components and this seem to always apply to right components).\r\nBut if I try to destroy entity the commented way - sometimes nothing happens, sometimes wrong entity's components get destroyed. What could possibly go wrong? \r\nI thought entt::entity are entity ids which don't get changed even if other things in registry are getting destroyed. Or am I wrong and there should be some other approach to perform entity destruction?",
    "comments_url": "https://api.github.com/repos/skypjack/entt/issues/877/comments",
    "author": "moonburnt",
    "comments": [
      {
        "user": "skypjack",
        "created_at": "2022-04-25T13:17:55Z",
        "body": "> And then, inside component's constructor - attach pointer to that component to fixture\r\n\r\nUnless you enabled pointer stability for `BallComponent`, I bet this is your issue. üôÇ \r\nPointers to components aren't stable by default in `EnTT`. That is, components are moved if necessary to keep all pools tightly packed. Pointer stability flips the problem on its head and uses tombstones to achieve the same.\r\nRoughly speaking, it's literally meant for these cases. You can find more details in the documentation. Feel free to drop a line if you've any problems with it though. üëç "
      },
      {
        "user": "skypjack",
        "created_at": "2022-04-26T10:32:04Z",
        "body": "Please, let me know if that was the problem and close the issue eventually. Thanks."
      },
      {
        "user": "skypjack",
        "created_at": "2022-05-02T08:18:51Z",
        "body": "I assume that was the problem and therefore we can close the issue. Feel free to drop a line if this isn't the case."
      },
      {
        "user": "moonburnt",
        "created_at": "2022-05-02T14:19:56Z",
        "body": "actually just solved this, was about to close the issue. No, entt's default behavior was not the cause of problem - actual culprit was box2d. Still, thanks for bothering - tombstones may come useful later "
      }
    ]
  },
  {
    "number": 856,
    "title": "Question: How deterministic is EnTT (ECS side)?",
    "created_at": "2022-03-22T05:01:48Z",
    "closed_at": "2022-03-22T15:57:56Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/skypjack/entt/issues/856",
    "body": "Context: This is a probing question to see how much effort I need to put into a sync system between a server and clients (or in other network models)\r\n\r\nHope everything's going well @skypjack! Have a broad but hopefully not too broad question on EnTT:\r\n\r\nHow deterministic is the ECS aspect of the library exactly? Specifically...\r\n- If `entt::registry` is provided with the exact same inputs on the same architecture, will it result in identical state? (Such as entity ids and entity + component order)\r\n  - Assuming there's no `<random>` usage or other sources of noise as well\r\n- Would the order when looping via `registry::view` ever differ, assuming groups and sorts are either completely unused or identically used in the same way (ie, same order of calls and relevant inputs on the same machine)?\r\n- Cross-platform determinism: To the best of your knowledge, would any of the above differ across various architectures? Eg, if a simulation on two very different architectures are using EnTT in \"equivalent\" fashion (at least in order of calls and otherwise identical inputs to `entt::registry`), would they always result in the same order of execution for views + identical entity ids and internal component order + otherwise roughly the same (observable) state?\r\n\r\nI've seen a few interesting mentions in other question issues - eg, #24 and #161 - but from a quick skim, they don't seem to answer the above question. Thus I'm interested in learning more about EnTT's determinism before I over- or under-engineer some relevant mechanisms =)",
    "comments_url": "https://api.github.com/repos/skypjack/entt/issues/856/comments",
    "author": "mdragon159",
    "comments": [
      {
        "user": "skypjack",
        "created_at": "2022-03-22T12:06:34Z",
        "body": "Interesting question. In general:\r\n\r\n* If `entt::registry` is provided with the exact same inputs on the same architecture, it results in identical state.\r\n* Would the order when looping via `registry::view` ever differ [...]? No but this derives from the previous question actually.\r\n* Cross-platform determinism: To the best of your knowledge, would any of the above differ across various architectures? Yes.\r\n\r\nAs for the third question, you can make it fully deterministic if you like but it may differ out of the box.\r\nBriefly, EnTT uses `PRETTY_FUNCTION` and `FUNC_SIG` to _create_ an identifier for a given type and the major compilers return different values sometimes.\r\nThis could affect for example the order of iteration of the pools when destroying an entity. It never affects the order of iteration of the entities when iterating a view though.\r\n\r\nLike everything else in EnTT, you have control over this part too. In fact, everything in the type info system is customizable. üëç "
      },
      {
        "user": "mdragon159",
        "created_at": "2022-03-22T15:57:56Z",
        "body": "Interesting, this almost certainly means I have less work ahead of me than I thought and multiple options to knowingly modify the relevant parts of EnTT here as needed.\r\n\r\nThank you for the detailed response! This'll definitely come in handy ^_^"
      }
    ]
  },
  {
    "number": 836,
    "title": "How can I lock components so they can be used between threads ?",
    "created_at": "2022-02-04T08:42:31Z",
    "closed_at": "2022-02-07T22:00:38Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/skypjack/entt/issues/836",
    "body": "I have a multiplayer open world game that has  2 threads, a render thread and a world thread. Both threads access the same entt:registry\r\n\r\nThe render thread iterates transform components and sprite components each frame and getting data from them.\r\n\r\nThe world thread on the other hand, handles the world streaming, whenever a new chunk arrives from the server the world thread handles the packet and creates the entities inside that chunk.\r\n\r\nNow with this approach, the game crashes because while the world thread is creating entities and accessing component pools, the render thread is trying to access the same pool at the same time so a crash occurs inside entt telling me that a view doesn't contain entity.\r\n\r\nany idea on how can I lock components until after the world thread is done with them ?",
    "comments_url": "https://api.github.com/repos/skypjack/entt/issues/836/comments",
    "author": "abdullahoday710",
    "comments": [
      {
        "user": "skypjack",
        "created_at": "2022-02-04T13:23:31Z",
        "body": "EnTT doesn't offer a built-in mechanism for locking a component, mainly because you can easily implement it on top of what it offers and also achieve better results.\r\nAs for you specific case, I'd consider a few options probably:\r\n\r\n* Create a cold copy of the components for the renderer. If it's only about two component types, it may worth it rather than using mutexes or the like everywhere to control accesses. Remember that EnTT offers named and runtime pools, thye look like a good option for this.\r\n\r\n* Add a mutex to the registry context and make your systems use it. Otherwise, inherit from the registry itself and do something similar.\r\n\r\n* Add a mixin to the transform and sprite pools and make it use a local mutex to control all accesses.\r\n\r\nCan any of these work for you? The former is imho the simplest and I dare to say likely the most effective. Though, it's probably a matter of tastes, so let me know what your thoughts are. üëç "
      },
      {
        "user": "abdullahoday710",
        "created_at": "2022-02-04T20:14:27Z",
        "body": "> EnTT doesn't offer a built-in mechanism for locking a component, mainly because you can easily implement it on top of what it offers and also achieve better results. As for you specific case, I'd consider a few options probably:\r\n> \r\n>     * Create a cold copy of the components for the renderer. If it's only about two component types, it may worth it rather than using mutexes or the like everywhere to control accesses. Remember that EnTT offers named and runtime pools, thye look like a good option for this.\r\n> \r\n>     * Add a mutex to the registry context and make your systems use it. Otherwise, inherit from the registry itself and do something similar.\r\n> \r\n>     * Add a mixin to the transform and sprite pools and make it use a local mutex to control all accesses.\r\n> \r\n> \r\n> Can any of these work for you? The former is imho the simplest and I dare to say likely the most effective. Though, it's probably a matter of tastes, so let me know what your thoughts are. üëç\r\n\r\nHi, thanks for your response and your work on this amazing ECS :)\r\n\r\nusing mixins and mutexes would require me to do a lot of refactoring for my engine, same goes with inheriting from the registry so it would just complicate things, and, as you said it might not be the most effective way.\r\n\r\nas for creating cold copies it sounds good  because my components are small. but I don't really know how to implement it, because the only way I used EnTT so far is by just creating views and iterating them each frame. can you please point me to the right docs or provide code example ?"
      },
      {
        "user": "skypjack",
        "created_at": "2022-02-04T21:29:42Z",
        "body": "There are a few ways to do it. Something along this line maybe?\r\n```cpp\r\nauto &view = registry.view<transform>();\r\nauto &copy = registry.storage<transform>(\"tcopy\"_hs);\r\n\r\ncopy.clear();\r\ncopy.insert(view.begin(), view.end(), view.storage().begin());\r\n```\r\nThen you can use the copy in your rendering system as:\r\n```cpp\r\nentt::basic_view view{registry.storage<transform>(\"tcopy\"_hs)};\r\nfor(auto [entt, transform]: view) { ... }\r\n```\r\nLet me know if you've any doubts. üëç "
      },
      {
        "user": "chengts95",
        "created_at": "2022-02-04T23:38:31Z",
        "body": "I think the better way is to use something similar to a command buffer in unity ECS.  That is to say, instead of locking whole data, locking certain synchronous operations is better. And it depends on how the task is allocated to multiple threads."
      },
      {
        "user": "abdullahoday710",
        "created_at": "2022-02-05T21:22:12Z",
        "body": "> There are a few ways to do it. Something along this line maybe?\n> ```cpp\n> auto &view = registry.view<transform>();\n> auto &copy = registry.storage<transform>(\"tcopy\"_hs);\n> \n> copy.clear();\n> copy.insert(view.begin(), view.end(), view.storage().begin());\n> ```\n> Then you can use the copy in your rendering system as:\n> ```cpp\n> entt::basic_view view{registry.storage<transform>(\"tcopy\"_hs)};\n> for(auto [entt, transform]: view) { ... }\n> ```\n> Let me know if you've any doubts. üëç \n\nWhen using ```copy.insert()``` how would I make sure that the component being inserted isn't being accessed by the other thread ? "
      },
      {
        "user": "skypjack",
        "created_at": "2022-02-06T18:22:14Z",
        "body": "That's the only sync point in the whole process. That is for example:\r\n* generate new transforms\r\n* sync\r\n* generate copy\r\n* spawn multiple threads\r\n\r\nThen it's up to you to use all things correctly as you would to with any other data structure.\r\nYour question isn't different from asking _how do I know that a second thread won't access the `std::vector` that I'm modifying on the main thread?_"
      },
      {
        "user": "abdullahoday710",
        "created_at": "2022-02-07T18:54:13Z",
        "body": "> That's the only sync point in the whole process. That is for example:\r\n> \r\n>     * generate new transforms\r\n> \r\n>     * sync\r\n> \r\n>     * generate copy\r\n> \r\n>     * spawn multiple threads\r\n> \r\n> \r\n> Then it's up to you to use all things correctly as you would to with any other data structure. Your question isn't different from asking _how do I know that a second thread won't access the `std::vector` that I'm modifying on the main thread?_\r\n\r\nI have fixed the problem by using a condition variable to lock the world thread when the render thread tries to access the pools, therefore I could create my copies, thank you for your advice it was really helpful üòÉ "
      }
    ]
  },
  {
    "number": 835,
    "title": "Is there a way to deduce the unupdated (the opposite of entt::observer)?",
    "created_at": "2022-02-02T12:39:34Z",
    "closed_at": "2022-02-10T08:26:52Z",
    "labels": [
      "question",
      "solved"
    ],
    "url": "https://github.com/skypjack/entt/issues/835",
    "body": "So far I'm digging the observer design but there's a case where I also need to iterate the unupdated. Is there a way to know if an entity has been updated or not while iterating the entire view?\r\n\r\nI know this seems really strange in hindsight but I just don't want to populate my classes with unnecessary variables and sometimes I only want to iterate the unupdated.",
    "comments_url": "https://api.github.com/repos/skypjack/entt/issues/835/comments",
    "author": "Sonolil",
    "comments": [
      {
        "user": "skypjack",
        "created_at": "2022-02-02T13:22:35Z",
        "body": "There is not actually. If you don't update it, nothing happens. How can one track that _nothing has happened_? ü§î \r\nThough, you can maybe use the `is_updated` tag as a filter in a view and therefore get the non-updated entities this way."
      },
      {
        "user": "Sonolil",
        "created_at": "2022-02-02T13:48:58Z",
        "body": "You're right, I'm content with the tag method. Thank you"
      },
      {
        "user": "Sonolil",
        "created_at": "2022-02-02T14:28:09Z",
        "body": "Hi, sorry again but this is a related question. Is there a remove_if algorithm equivalent for entt? A passage in the sorting section implies I can create a custom sort function object so there must be a way to use this to send all deletable elements to the back?"
      },
      {
        "user": "skypjack",
        "created_at": "2022-02-02T14:33:32Z",
        "body": "Mmm it sounds to me like an XY-problem. Can I ask you what you're trying to achieve? Maybe there is a more EnTT-y way of doing it."
      },
      {
        "user": "Sonolil",
        "created_at": "2022-02-02T15:02:44Z",
        "body": "Not much really, I actually just got it done. I am reloading certain components based on whether my file is modified or not. I serialize a registry and a map of entities, with relative path to my root folder as its key. I deserialize the registry and map, iterate through the root folder and update entities with existing keys in my map comparing file write time and other data, then reiterate the file data view to reload modified file data to my components and remove the none-existing ones. (I know this sort of duplicates data in my registry but it's a cost I'm willing to pay)\r\n\r\nI couldn't find reference for the is_updated tag so I just attached a filedata component which also contains the write time and other info. This was all fine except I needed to detect erased files as well and destroy entities with invalid filepath. I was just hoping I could do ranged destruction on the eraseables as if with std::removed_if algorithm. I just found out I can destroy while iterating through my views so this isn't urgent but I still wonder if this is possible. \r\n\r\n"
      },
      {
        "user": "skypjack",
        "created_at": "2022-02-03T07:33:59Z",
        "body": "Oh, no, sorry, the `is_updated` component doesn't exist, it was just a hint on a possible solution. üòÖ \r\nI see what you want now. `remove_if` just iterates the container and _moves_ things to the end, then you've to use `erase`. With a view, you combine the two as you did. That's perfectly fine."
      },
      {
        "user": "Sonolil",
        "created_at": "2022-02-04T00:45:47Z",
        "body": "Oh, I didn't realize that was possible, thank you! I was thinking of using the algorithm on the pool itself rather than the view entities (especially since the entities effectively only have one component attached). Does the ranged destroy optimize itself in this regard? I've never used it before"
      },
      {
        "user": "skypjack",
        "created_at": "2022-02-04T07:05:41Z",
        "body": "Yeah, range functionalities perform better in general, especially if you use iterators from storage classes or single type views (because of an internal machinery that helps to further optimize this case)."
      },
      {
        "user": "Sonolil",
        "created_at": "2022-02-05T12:40:16Z",
        "body": "That settles all concerns. I've been enjoying entt very much, it pretty much dominates every part of my source code. Thank you for making ECS in c++ easier for us. "
      },
      {
        "user": "skypjack",
        "created_at": "2022-02-05T14:35:22Z",
        "body": "I'm glad to know that you're enjoying the library. üôÇ \r\nLet me know if you've any other questions. Otherwise, I'll close the issue soon. Thanks. üëç "
      }
    ]
  },
  {
    "number": 792,
    "title": "Question about some core/type_info.hpp template overloads ",
    "created_at": "2021-10-17T15:54:38Z",
    "closed_at": "2021-10-18T00:02:13Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/skypjack/entt/issues/792",
    "body": "Hi!\r\n\r\nI have been wondering how are `type_name` and `type_hash` implemented internally, so i have looked at the type_info.hpp header.\r\nI don't exactly understand the purpose of the `auto = stripped_type_name<Type>().find_first_of('.')` overloads for those functions. \r\n\r\nWhy is the template overload checking for existance of any dot characters in the type name and why is the type name & hash not made constexpr in those overloads?",
    "comments_url": "https://api.github.com/repos/skypjack/entt/issues/792/comments",
    "author": "switch-blade-stuff",
    "comments": [
      {
        "user": "skypjack",
        "created_at": "2021-10-17T17:32:42Z",
        "body": "Pretty functions (and similar) aren't necessarily constexpr on all compilers. That is why a non-constexpr overload exists.\r\nThe trick you pointed out helps to pick the _right_ path accordingly instead. Nothing less, nothing more.\r\n`find_first_of` is a constexpr function of a `string_view`. If it works as intended in that context, we choose the constexpr path. Otherwise we fallback on the non-constexpr one.\r\nNothing of which you should worry about as a final user but feel free to ask if you've any other doubts."
      },
      {
        "user": "switch-blade-stuff",
        "created_at": "2021-10-18T00:02:13Z",
        "body": "Thanks for the explanation! Was just curious how it works, im brusbing up on my template metaprogramming skills so im always glad to learn new tricks)"
      },
      {
        "user": "skypjack",
        "created_at": "2021-10-18T05:54:48Z",
        "body": "No worries. You're welcome."
      }
    ]
  },
  {
    "number": 770,
    "title": "[Question] How to discard a group after use?",
    "created_at": "2021-08-25T06:31:09Z",
    "closed_at": "2021-08-25T15:14:55Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/skypjack/entt/issues/770",
    "body": "Hi, another beginner's question here~ I'm trying to use groups inside a function, where I need to process some combinations of components using multiple groups, and I got a runtime assertion error.\r\n```c++\r\nvoid Foo() {\r\n    ....\r\n    \r\n    if (auto group = registry.group<A, B>(); !group.empty()) {\r\n        auto& b = group.get<B>(group.front());\r\n        ....\r\n    }\r\n\r\n    if (ctx.lightmask.test(0)) {\r\n        auto group = registry.group<C, A>();\r\n        group.sort([](const entt::entity a, const entt::entity b) { return a < b; });\r\n        ....\r\n    }\r\n}\r\n```\r\nAs per the documentation, these are conflicting groups and the second one is going to fail, so before creating the second group, I need to somehow discard the first group, but I couldn't find a function for that. I tried to wrap them inside an if-else block so that each group has a local scope, but it seems that the first group is still alive in the registry after it goes out of scope, I wonder if there's a way to manually clean it up? or perhaps the way I'm using groups is not correct?",
    "comments_url": "https://api.github.com/repos/skypjack/entt/issues/770/comments",
    "author": "neo-mashiro",
    "comments": [
      {
        "user": "skypjack",
        "created_at": "2021-08-25T08:30:23Z",
        "body": "Currently, you cannot and it's mostly on purpose. Groups aren't meant to be built and destroyed continuously at runtime. Quite the opposite actually, they are meant to optimize a specific access pattern in the long run."
      },
      {
        "user": "neo-mashiro",
        "created_at": "2021-08-25T15:14:55Z",
        "body": "> \r\n> \r\n> they are meant to optimize a specific access pattern in the long run.\r\n\r\nOK I got your point, so a group is like a rearranged owning subset of the registry, which is somewhat analogous to the RAM of CPU. Groups are intended to be setup once and used repeatedly, where later access can be made blazingly fast, but views do not take ownership so can be considered more \"temporary\" than groups. Is my understanding correct?\r\n\r\nI've re-read the groups part in the documentation and it's now making more sense to me. I removed the ownership of A by using `registry.group<B>(A)` and `registry.group<C>(A)` and the assertion passed, thanks for your clarification!"
      }
    ]
  },
  {
    "number": 763,
    "title": "How to create a new entity with custom identifier",
    "created_at": "2021-08-15T15:01:40Z",
    "closed_at": "2021-08-16T07:39:46Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/skypjack/entt/issues/763",
    "body": "Hello! Excuse me if the question I am going to ask has already been elaborated in the documentation, I was trying to find it there but failed.\r\nI am almost a newbie and currently learning C++ by trying to implement a simple game engine. I added a little networking part to it, and my problem is that I need to have server and client entities synchronized (meaning entt::entity of objects on server and client must be the same no matter what), and the only one solution I could have come up with is transmitting entities of all objects created on server to clients. After receiving them, clients must set these new entities to their registries. However, I could not have found any function that can perform adding entities with custom identifiers to registry. I have found only create() function that simpy adds new entity with id that is being incremented every time. But I would like to have control over what identifiers are being added to entities vector.\r\nThank you in advance!",
    "comments_url": "https://api.github.com/repos/skypjack/entt/issues/763/comments",
    "author": "1TrueNova1",
    "comments": [
      {
        "user": "1TrueNova1",
        "created_at": "2021-08-15T18:34:36Z",
        "body": "Is create() method overload that takes in const entity_type hint as parameter the thing I was asking? Oopsie if so..."
      },
      {
        "user": "skypjack",
        "created_at": "2021-08-15T20:07:53Z",
        "body": "Yeah, more or less. The `create` overload that also accepts a hint does its best to return the requested identifier. However, it fails if the identifier is already in use. So, it's up to you to guarantee the consistency between client and server.\nIn general, you don't replicate identifiers exactly in these cases. Instead, you should use a local-remote map to decouple them. It also has the advantage of working offline if required/needed."
      },
      {
        "user": "1TrueNova1",
        "created_at": "2021-08-16T07:39:46Z",
        "body": "Oh, hm, I've never thought about it. I think it is actually the right way to solve the problem. Thank you very much!"
      }
    ]
  },
  {
    "number": 762,
    "title": "How to access key-only associative container's values with meta?",
    "created_at": "2021-08-15T10:41:11Z",
    "closed_at": "2021-08-15T20:12:46Z",
    "labels": [
      "question",
      "solved"
    ],
    "url": "https://github.com/skypjack/entt/issues/762",
    "body": "Hi!\r\n\r\nI am having issues accessing values of an `std::set` that is stored in a `meta_any` object.\r\nHow i understand it, when iterating over an associative container i get a `pair` where the first item is the key, and the second one is the value.\r\nWhen iterating over a set (which is not empty, i have checked with a debugger) which is a key only type, the returned key has the correct type (`std::string` in this case) but the try_cast returns a nullptr. Am i doing something wrong?",
    "comments_url": "https://api.github.com/repos/skypjack/entt/issues/762/comments",
    "author": "switch-blade-stuff",
    "comments": [
      {
        "user": "switch-blade-stuff",
        "created_at": "2021-08-15T10:55:46Z",
        "body": "In fact even for key-value containers, casting the key to it's type returns nullptr"
      },
      {
        "user": "skypjack",
        "created_at": "2021-08-15T14:46:08Z",
        "body": "Keys in a set are read-only and so are the meta keys returned by an associative container that wraps a set.\nTherefore, what you want is probably:\n```cpp\npair.first.try_cast<const std::string>()\n```\nUsing the non-const counterpart returns a null pointer instead.\nIt works the same with `cast` if you use reference types:\n```cpp\npair.first.cast<const std::string &>()\n```\nOtherwise, you can use `cast` with a non-reference type which creates a copy of the contained element:\n```cpp\npair.first.cast<std::string>()\n```\nLet me know if it works. :+1:"
      },
      {
        "user": "switch-blade-stuff",
        "created_at": "2021-08-15T15:14:32Z",
        "body": "Thanks, that fixed it!"
      }
    ]
  },
  {
    "number": 756,
    "title": "Is there any way to extend meta_type generation currently?",
    "created_at": "2021-08-09T22:53:27Z",
    "closed_at": "2021-08-11T13:27:45Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/skypjack/entt/issues/756",
    "body": "Hello\r\n\r\nI have seen that a way to extend `meta_type` generation is planned, but is there a proper work around to do it iin the current version?\r\nI want to add a special property to all types that are children of some base class automatically, without the need to individually set the property for all of them. I have tried to hook a custom extension function into `type_seq`, however that causes a recursive initialization exception when the extension function attempts to call `meta<T>()` to set the property. \r\n\r\nThe code looks somewhat like this:\r\n```\r\nnamespace entt\r\n{\r\n\ttemplate<typename T>\r\n\tinline void extend_meta_type()\r\n\t{\r\n        \tmeta<T>()\t// Recursive init exception occurs here\r\n\t\t\t.prop(\"my property\"_hs);\r\n\t}\r\n\r\n\ttemplate<typename T>\r\n\tstruct type_seq<T>\r\n\t{\r\n        \tstatic id_type value() noexcept \r\n        \t{\r\n        \t\tstatic const id_type value = (extend_meta_type<T>(), internal::type_seq<T>::next());\r\n\t\t\treturn value;\r\n        \t}\r\n\t}\r\n}\r\n```",
    "comments_url": "https://api.github.com/repos/skypjack/entt/issues/756/comments",
    "author": "switch-blade-stuff",
    "comments": [
      {
        "user": "skypjack",
        "created_at": "2021-08-10T07:31:01Z",
        "body": "> I want to add a special property to all types that are children of some base class automatically, without the need to individually set the property for all of them.\r\n\r\nYou can set the property on the base class if it's registered with the meta system. Properties are looked up in the whole hierarchy when you query them."
      },
      {
        "user": "switch-blade-stuff",
        "created_at": "2021-08-10T07:40:06Z",
        "body": "I see, but what i would like to do is type-dependent. The property is generated individually for each type, that's why i wanted to extend meta generation. Sorry, i forgot to include it in the original message."
      },
      {
        "user": "skypjack",
        "created_at": "2021-08-10T08:26:27Z",
        "body": "Oh, sorry, didn't get it. üëç \r\nThe current version doesn't allow to hook into the meta type generation, you're right. I'm struggling to find the best way for that at the moment, so as to provide something similar with the next version (there exists an open issue too).\r\nUnfortunately, it's not that easy. At least, not as easy as I thought initially. The main issue is that customization points should run on meta types during initialization and before they get returned. Therefore, you can't expect to use a meta factory in your customization function, mainly because the latter wants a properly initialized meta type and aims at extending it.\r\nSo, the TL;DR version of it is that hook points require users to dig into the underlying representation of meta types (i.e. `meta_type_node` rather than the `meta_type` utility wrapper). This makes it a little more complex to use than simply invoking `.prop(\"my property\"_hs);`.\r\nI'm still trying to figure out if there exists an alternative solution that doesn't require me to add a second static variable for all types (this is something to avoid from my point of view). Any feedback or suggestions is appreciated ofc. üôÇ "
      },
      {
        "user": "switch-blade-stuff",
        "created_at": "2021-08-10T09:36:04Z",
        "body": "I see. A quick idea i had could be to initialize the static variable with a lambda, where the lambda would create and initialize a temporary node, then call the extension code and pass it a factory instance for that node. Then it would return the type node. That way if the extension code needs to access the factory it does not need to access the static variable.\r\n\r\nSomething like this (in pseudocode)\r\n```\r\n\r\ntemplate<typename T, typename = void>\r\nstruct meta_type_extender;\r\n\r\nstatic meta_type_node node = [](){\r\n    meta_type_node result = {/* Initialize the meta type*/};\r\n    if constexpr (is_complete_v<meta_type_extender<T>>)\r\n    {\r\n        meta_type_extender<T>{}(meta_factory<Type, Type>{&result->prop});\r\n    }\r\n    return result;\r\n}();\r\n\r\n```\r\n\r\nThen any extension code would have a `void operator()(meta_factory<T>)` function used to extend the meta generation.\r\n\r\nIn the code above `meta_type_extender` is a functor in order to allow the user to choose which types to extend without, for example, requiring the types do be derived from some sort of base `extendable` type. This way user also could, for example, extend types based on their traits. \r\n\r\nAnother good feature could possibly be to allow user to chain meta extensions, for example so that a custom container extension would run it's own code first and then chain the default container extension code. But i am not sure how to make that work. Probably some complex SFINAE and/or CRTP solution for `meta_type_extender` type would do the trick?\r\n\r\nAlthough there could be some roadblocks. For example if the extension code for `type_a` would initialize a node of `type_b`, and `type_b`'s extension code would require node of `type_a`. Because the code effectively still runs during instantiation of `type_a`'s node it would cause a recursive initialization error.\r\n\r\nAnother idea would be to do something like this\r\n```\r\n\r\ntemplate<typename T, typename = void>\r\nstruct meta_type_extender;\r\n\r\nstatic std::unique_ptr<meta_type_node> node;\r\nif (!node)\r\n{\r\n    /* Initialize the node */\r\n\r\n    if constexpr (is_complete_v<meta_type_extender<T>>)\r\n    {\r\n        meta_type_extender<T>{}(meta_factory<Type, Type>{&result->prop});\r\n    }\r\n}\r\n\r\n```\r\n\r\nThis however is not thread safe and would require either locks or atomic access to the node instance, whereas static initialization is guaranteed to be thread safe by the standard. \r\nThe safest version would be to have some throw away static variable be initialized after the node has been initialized that would run the extension code, but that would create two static variables per type which is quite ugly."
      },
      {
        "user": "skypjack",
        "created_at": "2021-08-10T14:53:14Z",
        "body": "> A quick idea i had could be to initialize the static variable with a lambda\r\n\r\nSo, I thought about this. The main issue is that I can't pass a `meta_factory`, because of an include hell.\r\nHowever, we could look up a function that is invocable with a `meta_type_node *` object and you could have a meta factory in the user code. That would by-pass the issue entirely.\r\nThe other problem remains instead. If you reflect A and indirectly reflect it again in the hook, the runtime will enter a lock. I've no idea about how to get around this honestly."
      },
      {
        "user": "switch-blade-stuff",
        "created_at": "2021-08-10T16:37:51Z",
        "body": "Yeah, i currently do not see a valid thread-safe and compiler & platform independent solution that does not use a second static variable.\r\n\r\nThe only way i can think of to make it a little bit better is to put the second static inside an `if constexpr` so that the static variable would exist only for types that have meta extension, while the types that do not extend meta would only have 1 static variable."
      },
      {
        "user": "skypjack",
        "created_at": "2021-08-10T21:37:35Z",
        "body": "Be aware that using two statics would turn it immediately in a non-thread-safe initialization process."
      },
      {
        "user": "skypjack",
        "created_at": "2021-08-11T13:27:37Z",
        "body": "I close this since #735 already contains the same request in the list of additions to meta. Feel free to continue the discussion either here or in the other issue. :+1:"
      }
    ]
  },
  {
    "number": 754,
    "title": "Storing pointers in components",
    "created_at": "2021-08-06T14:35:08Z",
    "closed_at": "2021-08-08T06:17:49Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/skypjack/entt/issues/754",
    "body": "I have a component that contains information needed to render a sprite:\r\n```c++\r\nstruct SpriteRendererComponent\r\n{\r\n    std::shared_ptr<Texture> sprite;\r\n}\r\n```\r\n\r\nAnd a system that renders the sprite:\r\n```c++\r\n// Iterates over TransformCompoennt and SpriteRendererComponent\r\nRenderer::Render(transform.GetMatrix(), spriteRenderer.sprite->GetOpenGLID());\r\n```\r\n\r\nThe whole point of ECS is to make use of the CPU cache by tightly packing components.\r\nBut here; For each `SpriteRendererComponent`; I am fetching the memory that `spriteRenderer.sprite` points to; To retrieve the OpenGL id of the texture.\r\n\r\nWill this ruin optimizations behind ECS (Because data in the cache will become useless after fetching `spriteRenderer.sprite`)?\r\nIf yes; Is there any solution to it?",
    "comments_url": "https://api.github.com/repos/skypjack/entt/issues/754/comments",
    "author": "OverShifted",
    "comments": [
      {
        "user": "skypjack",
        "created_at": "2021-08-06T21:22:49Z",
        "body": "In theory, you can customize your pool and store (and rearrange) entities and components by sprite. This isn't much different from what groups do already. This will minimize the number of jumps in memory and increase locality.\r\nHowever, I would rather go with your approach, measure and change it **only** in case of problems, ie if it shows up as a bottleneck while measuring.\r\nWhat you're doing here is trading some perf for some memory. This approach is very close to the flyweight pattern and I wouldn't turn it off nor add extra code to maintain for a premature optimization."
      },
      {
        "user": "OverShifted",
        "created_at": "2021-08-07T05:15:03Z",
        "body": "Do you mean content in the cache is still useful after fetching `spriteRenderer.sprite` which is far far away from `spriteRenderer`?\r\nWhat about `transform`?\r\n`TransformCompoenent`s are probably stored far away from ‚Äç`SpriteRenderer`s (not sure how EnTT handles it). So when I fetch `transform`; content in the cache will point to `transform` and maybe a few other `TransformCompoenents` after that. So it won't help with `SpriteRenderers`.\r\n\r\nAm I wrong? If yes; please tell why :)"
      },
      {
        "user": "skypjack",
        "created_at": "2021-08-07T12:53:36Z",
        "body": "> Do you mean content in the cache is still useful after fetching spriteRenderer.sprite which is far far away from spriteRenderer?\r\nWhat about transform?\r\n\r\nWhat I mean is that you can try to elaborate all objects with a same sprite together to improve locality and avoid some jumps. You can move around things in parallel in both pools if you want them to have the same order. Though, the real question is: does it worth it in your case?\r\nKeep in mind that using an ecs arch doesn't mean that you won't have any cache misses in your software! Also, the more the context you need to fully elaborate an entity, the greater the likelihood of something being ripped off.\r\nMoreover:\r\n\r\n> TransformCompoenents are probably stored far away from ‚ÄçSpriteRenderers (not sure how EnTT handles it). So when I fetch transform; content in the cache will point to transform and maybe a few other TransformCompoenents after that. So it won't help with SpriteRenderers.\r\n\r\nCache... I mean... it doesn't work like that. It's also hard to predict what the cpu will do. All you can do is to _help_ it and provide it with data that are easy to prefetch and elaborate in a meaningful way.\r\nAs a side note, this is somewhat wrong too, something some companies shouldn't sell as an idea just to make two extra pennies:\r\n\r\n> The whole point of ECS is to make use of the CPU cache by tightly packing components.\r\n\r\nThis is **not** the whole point (fortunately). Don't get obsessed by this kind of things. It's (very very very) likely that the current implementation with a pointer to an object that is shared by many entities is already good enough for 99% of uses.\r\nJust measure before trying to replace a solution that is easy to reason about with something that is way more complex to get correct and to maintain."
      },
      {
        "user": "OverShifted",
        "created_at": "2021-08-08T06:17:49Z",
        "body": "@skypjack Thank you for your reply. The cache can be smarter than I thought."
      }
    ]
  },
  {
    "number": 753,
    "title": "[Question] Cache the result of the `get()` function?",
    "created_at": "2021-08-05T23:22:14Z",
    "closed_at": "2021-08-06T07:19:45Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/skypjack/entt/issues/753",
    "body": "Sorry for the basic question from a beginner, but I'd like to know about the price of calling `registry.get<T>()`. I have a `Entity` class like this:\r\n\r\n```c++\r\nclass Entity {\r\n  private:\r\n    std::string name = \"\";\r\n    entt::entity id = entt::null;\r\n    entt::registry* registry;\r\n\r\n  public:\r\n    Entity(const std::string& name, entt::entity id, entt::registry* registry);\r\n    ~Entity() {}\r\n\r\n    template<typename T>\r\n    T& GetComponent() {\r\n        CORE_ASERT(registry->all_of<T>(id), \"Component T not found in {0}!\", name);\r\n        return registry->get<T>(id);\r\n    }\r\n}\r\n```\r\n\r\nSince I come from Unity, whose `GetComponent()` method is known to be slow and not supposed to be invoked every frame, I'm thinking about caching the result of `registry->get<T>()` so that subsequent calls won't need to query the registry again. While caching is easy outside the class (on caller's side), it's a bit difficult to cache inside the class with generics (I'm still new to C++), and I wonder if this is at all necessary......\r\n\r\nCan you tell me a bit more about the `get()` function? Does it check `registry->all_of<T>()` automatically? Is it costly? Also, I don't understand why the documentation says `get_or_emplace()` is slightly faster. Thank you~!",
    "comments_url": "https://api.github.com/repos/skypjack/entt/issues/753/comments",
    "author": "neo-mashiro",
    "comments": [
      {
        "user": "skypjack",
        "created_at": "2021-08-06T06:47:19Z",
        "body": "The underlying pool in EnTT is based on sparse sets and getting an element is a O(1) lookup.\r\nCaching would be still faster, granted, though pointers aren't stable unless you enable pointer stability on all pools (available since 3.8.x). Also, I confirm that `get` uses `all_of` (well, sort of actually, but let's assume this is the case) under the hood to assert in case the entity doesn't own the component.\r\n`get_or_emplace` is faster than the following:\r\n```cpp\r\nif(registry.all_of<T>(e)) {\r\n    return registry.get<T>(e);\r\n} else {\r\n    return registry.emplace<T>(e);\r\n}\r\n```\r\nThis is due to the fact that the pool lookup takes place only once. Probably not something you'll ever be able to measure but technically speaking it's slightly faster."
      },
      {
        "user": "neo-mashiro",
        "created_at": "2021-08-06T07:19:45Z",
        "body": "Thanks for clearing things up. Glad to hear that it's a O(1) operation, that's amazing. I think I won't cache then since the performance gain is negligible, but easy stability is definitely my first concern.\r\nThanks for sharing such a great open source library. I hope I could get a better understanding of it by reading your ECS back and forth series, cheers! üòÑ "
      },
      {
        "user": "skypjack",
        "created_at": "2021-08-06T07:43:28Z",
        "body": "You're welcome. Feel free to join gitter or discord if you have any question. Usually easier than chatting on GH. Also, you can find many other devs there (by far more skilled than me) that can help you. üòâ "
      }
    ]
  },
  {
    "number": 752,
    "title": "How to Sort Entities",
    "created_at": "2021-08-05T11:31:53Z",
    "closed_at": "2021-08-05T20:21:23Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/skypjack/entt/issues/752",
    "body": "I'm using EnTT for my game and I'm trying to render some objects in a particular order, specifically by their distance to the camera. I need to create a view in which the entities are in a specific order. I read  the docs and I wrote this:\r\n\r\n```\r\nvoid systems::piece_render(entt::registry& registry, entt::entity hovered_entity, entt::entity camera_entity) {\r\n    auto& camera_transform = registry.get<TransformComponent>(camera_entity);\r\n\r\n    auto func = [&camera_transform](const TransformComponent& lhs, const TransformComponent& rhs) {\r\n        float distance1 = glm::length(camera_transform.position - lhs.position);\r\n        float distance2 = glm::length(camera_transform.position - rhs.position);\r\n        return distance1 < distance2;\r\n    };\r\n\r\n    registry.sort<TransformComponent>(func);\r\n\r\n    auto view = registry.view<TransformComponent, MeshComponent,\r\n                              MaterialComponent, TextureComponent,\r\n                              OutlineComponent, PieceComponent>();\r\n\r\n    for (entt::entity entity : view) {\r\n        auto [transform, mesh, material, textures, outline, piece] = view.get(entity);\r\n        // Render code here\r\n    }\r\n}\r\n```\r\n\r\nBut it doesn't seem to do what I want. Looks like the objects are still rendered like before. I think I'm using `sort` wrongly. **The docs aren't clear to me for some reason**. My question is: How can I achieve what I want?",
    "comments_url": "https://api.github.com/repos/skypjack/entt/issues/752/comments",
    "author": "SimonMaracine",
    "comments": [
      {
        "user": "skypjack",
        "created_at": "2021-08-05T12:30:41Z",
        "body": "You probably want to add a `view.use<TransformComponent>()` before iterating the view. It guarantees that the order of your `TransformComponent` is respected."
      },
      {
        "user": "SimonMaracine",
        "created_at": "2021-08-05T14:43:45Z",
        "body": "> You probably want to add a `view.use<TransformComponent>()` before iterating the view. It guarantees that the order of your `TransformComponent` is respected.\r\n\r\nOk. I'll try when I will be back home. Thank you."
      },
      {
        "user": "SimonMaracine",
        "created_at": "2021-08-05T20:21:23Z",
        "body": "Wow! I tried what you said and it works now. It renders the objects back to front. Thank you!\r\n\r\nI didn't know the `use` method before."
      },
      {
        "user": "skypjack",
        "created_at": "2021-08-05T20:49:06Z",
        "body": "You're welcome. "
      },
      {
        "user": "OverShifted",
        "created_at": "2021-08-09T03:45:11Z",
        "body": "@skypjack Who fast (or slow) `registry.sort` is? Since it is called every frame."
      },
      {
        "user": "skypjack",
        "created_at": "2021-08-09T05:55:57Z",
        "body": "It sorts a sparse set. Slower than sorting a vector because it also has to update the sparse array. What remains is a single packed array that is sorted using `std::sort` or any other function you pass to it instead (it's configurable, probably an insertion sort is faster in many cases but this really depends on the application).\nEverything happens in-place. No allocations nor anything else. I also wrote an extensive post on the blog about this topic.\n\nI use it in real world applications, the reason for which it's there \nThis doesn't make it blazing fast automatically but at least confirms that it's not there just because. :)"
      },
      {
        "user": "OverShifted",
        "created_at": "2021-08-09T08:04:31Z",
        "body": "When I want to render my objects; I use a vector to save vertex buffer data before rendering them using a batch renderer.\r\nIs sorting that vector is faster than sorting entities?"
      },
      {
        "user": "skypjack",
        "created_at": "2021-08-09T08:10:42Z",
        "body": "Well, sorting a pool literally sorts a vector (similar cost) and updates the sparse array associated with it (additional cost).\nIt doesn't matter how small the second cost is, its existence is already the answer you're looking for."
      },
      {
        "user": "OverShifted",
        "created_at": "2021-08-09T08:12:29Z",
        "body": "Got it"
      },
      {
        "user": "sourabh-gupta-dev",
        "created_at": "2022-03-31T16:07:29Z",
        "body": "I have a similar use case of sorting entities. But I am not able to use the view.use<Comp>() function.\r\nIt keeps giving me error\r\n```\r\nNo member named 'use' in 'entt::basic_view<entt::entity, entt::get_t<Shutter::SortComponent>, entt::exclude_t<>>'\r\n```\r\n\r\nI am using v3.9.0 and below is my usage.\r\n```\r\nm_Registry.sort<SortComponent>([](const auto &lhs, const auto &rhs) {\r\n            return lhs.sortOrder > rhs.sortOrder;\r\n        }, entt::insertion_sort());\r\n        auto view = m_Registry.view<SortComponent>();\r\n        view.use<SortComponent>();\r\n```\r\nPlease help me with this issue."
      },
      {
        "user": "skypjack",
        "created_at": "2022-03-31T17:00:34Z",
        "body": "@sourabh-gupta-dev `view::use` is only available for multi-type views. It tells to the view what pool to use to drive the iteration.\r\nIt wouldn't make much sense for a single type view actually since you don't really have a choice there. üòÖ "
      },
      {
        "user": "sourabh-gupta-dev",
        "created_at": "2022-04-01T05:57:41Z",
        "body": "Got it. Thanks for the quick reply."
      }
    ]
  },
  {
    "number": 733,
    "title": "Clang format?",
    "created_at": "2021-07-12T08:26:08Z",
    "closed_at": "2021-09-30T05:55:32Z",
    "labels": [
      "question",
      "solved"
    ],
    "url": "https://github.com/skypjack/entt/issues/733",
    "body": "Do you intend to include a clang format file for autoformatting? Or maybe some other tools for autoformatting are used already?",
    "comments_url": "https://api.github.com/repos/skypjack/entt/issues/733/comments",
    "author": "sergio-eld",
    "comments": [
      {
        "user": "skypjack",
        "created_at": "2021-07-12T20:57:17Z",
        "body": "There are no tools in use at the moment actually.\nI plan to add one? Dunno, not really but it's not a big problem either. "
      },
      {
        "user": "sergio-eld",
        "created_at": "2021-07-13T07:08:27Z",
        "body": "For one thing, it is rather convenient to autoformat a document when you make a PR, rather to do it by hand. It *is* not a big deal, until you get used to autoformatting and are tired of people's PRs that don't meet the style for some reason."
      },
      {
        "user": "Innokentiy-Alaytsev",
        "created_at": "2021-07-13T07:15:46Z",
        "body": "The thing is that `clang-format` can't reproduce the current formatting which is there for _reasons_.\r\n\r\nPersonally, I completely understand the benefits of `clang-format` because I use it in all of my projects."
      }
    ]
  },
  {
    "number": 721,
    "title": "Does entt have owning entt::handle ?",
    "created_at": "2021-06-24T10:02:40Z",
    "closed_at": "2021-06-28T13:55:54Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/skypjack/entt/issues/721",
    "body": "I figured out, that I need often only one entity. It allow to add components to an object.\r\n\r\n```c++\r\nclass GameObject {\r\n     entt::registry reg;\r\n     entt::entity_type entity;\r\n};\r\n```\r\n\r\nMy qestions are :\r\n1) Is there anything to facilitate that in `entt` ? I know there is `handle`, but I believe `handle` is non-owning. Basically, a `owning_handle` would be perfect.\r\n2) Is a `registry` a lightweight object, that can be created multiple thousand of times ?\r\n\r\nThanks you!",
    "comments_url": "https://api.github.com/repos/skypjack/entt/issues/721/comments",
    "author": "Eren121",
    "comments": [
      {
        "user": "skypjack",
        "created_at": "2021-06-24T10:13:40Z",
        "body": "Do you mean a registry with a single entity? It seems a waste to me. Why would you use it like this?\r\n\r\n> Is a registry a lightweight object, that can be created multiple thousand of times ?\r\n\r\nYeah, it's cheap to create, I often use multiple registries."
      },
      {
        "user": "Eren121",
        "created_at": "2021-06-24T10:15:03Z",
        "body": "The fact is, when using `registry`, you need to pass a reference of the registry around all of your code. With a `owning_handle`, you can integrate `entt` with only adding a single field to your class."
      },
      {
        "user": "skypjack",
        "created_at": "2021-06-24T10:20:00Z",
        "body": "Though, if you want to create a view and iterate all entities that have components `A` and `B`, the entities managed by your handles **must** be put in the registry. Right? Otherwise, what you're looking for is just an OOP-like approach that has nothing wrong but is not what EnTT tries to achieve."
      },
      {
        "user": "Eren121",
        "created_at": "2021-06-24T10:22:33Z",
        "body": "I was learning about ECS... And entt is more ECSR ;)\r\n\r\nYes, it's less powerful. Hm you're probably right, in fact I was using mostly `entt` like a \"add components to any objects\". I wil stick to registries then."
      },
      {
        "user": "skypjack",
        "created_at": "2021-06-24T10:44:48Z",
        "body": "Yeah, what you describe is mostly similar to the old EC model of engines like Unity, where the entity/game object owns its components. EnTT flips the whole thing on its head and uses the entity as an index to lookup components from pools."
      },
      {
        "user": "skypjack",
        "created_at": "2021-06-28T13:55:54Z",
        "body": "I close the issue because it seems to me that the question has been answered.\r\nFeel free to continue the discussion here if this isn't the case. Thank you."
      }
    ]
  },
  {
    "number": 708,
    "title": "What is the correct to add new components during iteration?",
    "created_at": "2021-05-20T08:51:48Z",
    "closed_at": "2021-05-20T09:09:46Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/skypjack/entt/issues/708",
    "body": "Hi.\r\n\r\nI know that after adding new components duration iteration, the reference will be invalid. But I don't know what is the correct way to do it. Here is an example.\r\n\r\n```c++\r\nauto view = registry.view<const Com>();\r\nfor (auto [parent, c] : view.each()) {\r\n    for (auto i = 0u; i < c.repeat; ++i) {\r\n        const auto child = registry.create();\r\n        const auto new_c = Com(c.value);\r\n        registry.emplace<Com>(child, new_c);\r\n    }\r\n}\r\n```\r\n\r\nShould I generate all `new_c` before emplacing like this?\r\n\r\n```c++\r\nauto view = registry.view<const Com>();\r\nfor (auto [parent, c] : view.each()) {\r\n    std::vector<Com> vec;\r\n    for (auto i = 0u; i < c.repeat; ++i) {\r\n        vec.push_back(Com(c.value)); \r\n    }\r\n    for (auto i = 0u; i < c.repeat; ++i) {\r\n        const auto child = registry.create();\r\n        registry.emplace<Com>(child, vec[i]);\r\n    }\r\n}\r\n```\r\n\r\nThank you.",
    "comments_url": "https://api.github.com/repos/skypjack/entt/issues/708/comments",
    "author": "FishHawk",
    "comments": [
      {
        "user": "skypjack",
        "created_at": "2021-05-20T09:03:18Z",
        "body": "Only the currently iterated reference is invalidated. If you don't plan to use it (and you're not from what I see), you don't have to worry about it.\r\nAlso, as a side note, the next release will have pointer stability when emplacing. You can already try it on branch `experimental`."
      },
      {
        "user": "FishHawk",
        "created_at": "2021-05-20T09:09:33Z",
        "body": "Thanks! That's awesome!"
      }
    ]
  },
  {
    "number": 707,
    "title": "Entity: Best method/optimizations to delete lots of entities at once",
    "created_at": "2021-05-17T12:35:17Z",
    "closed_at": "2021-07-20T14:36:48Z",
    "labels": [
      "question",
      "solved"
    ],
    "url": "https://github.com/skypjack/entt/issues/707",
    "body": "*What version of entt are you using?* 3.6.0\r\n\r\n### The Background Context:\r\nI have \"bundles\" of entities that I store together in a `std::vector<entt::entity>`. A bundle is a logically related group of entities that are created and destroyed together; a particular game level may be a single bundle and the level next to it is a separate bundle. The entities do not have identical components. As an example: 100% of the entities in a level will have a `PositionComponent`, but 85% will have a `WallComponent`, and only 5% will have a `DamageZoneComponent`, etc. There are around 40 component types that could be present on the entities in a bundle, and around 300 pools total in the registry. The entities are always all created at the same time in the order they are stored in the `vector`, but the components are sometimes created later, or in a different order.\r\n\r\n### The Issue:\r\nFor complex levels, these bundles contain thousands of entities. When a level is deleted, I do the following:\r\n```C++\r\nfor (entt::entity e : bundle.entities)\r\n    registry.destroy(e);\r\n```\r\n\r\nFor around 6000 entities, this can take around 37.5ms in entt code (not including `on_destroy` signals). Inlining makes it hard to identify exactly where the time is spent, but I would assume the main culprits are cache misses and time spent moving around components, many of which are just going to be deleted in a few iterations anyway.\r\n\r\n### The Questions:\r\n1. Are there any optimizations I can/should take advantage of here to improve the destroy time? I know there is a range-destroy function, but it is functionally equivalent to what I am doing here (i.e. it is just a `for`-loop that calls `destroy` anyway). Perhaps I should be deleting ranges of the more common components first, or something like that?\r\n\r\n2. Are there any recommendations in general for the bundle pattern that I've described? For example, are there other optimizations I could take advantage of if I used some sort of runtime tag to identify the entities that are part of a particular level instead of putting them in a `vector`? Of course, very few operations are performed on the list of entities in the bundle; `view`s and `group`s of the potential components are used almost always outside of the create/destroy steps.",
    "comments_url": "https://api.github.com/repos/skypjack/entt/issues/707/comments",
    "author": "growlitheharpo",
    "comments": [
      {
        "user": "skypjack",
        "created_at": "2021-05-18T07:08:44Z",
        "body": "> For around 6000 entities, this can take around 37.5ms in entt code (not including on_destroy signals).\r\n\r\nThese numbers seem odd. I'm facing a similar optimization in a project that has a thousand pools and we are talking to save ~1ms or so. I guess it depends on the hw, but still ~40ms seems very high.\r\n\r\n> I know there is a range-destroy function, but it is functionally equivalent to what I am doing here (i.e. it is just a for-loop that calls destroy anyway).\r\n\r\nA review of the range destroy is in my pipeline, but it requires to split view iterators from views before proceeding.\r\nLong story short, it works like that now because I wanted to also support view iterators. In this case, you can't cleanup a pool at a time because the view would appear as empty as soon as you reset one of its types. However, pools already support the range-remove and it's ofc optimized. So, the goal is to unwrap the iterators and use the optimized path when they don't belong to a view.\r\n\r\n> Are there any optimizations I can/should take advantage of here to improve the destroy time?\r\n> Are there any recommendations in general for the bundle pattern that I've described?\r\n\r\nThere are many, from cleaning up pools in parallel and force-destroying entities to using a pool mixin that tracks assigned components (for example with a bloom filter or such) and touches only a few storage classes on destruction and so on. The _best one_ depends on your mt requirements, that is, if you want to remove components/destroy entities in parallel or not.\r\nThe other option is to wait until I come up with and publish an update upstream because I'm working on this specific aspect, so it's probably only a matter of time to have something built-in."
      },
      {
        "user": "growlitheharpo",
        "created_at": "2021-05-18T14:43:59Z",
        "body": "> I guess it depends on the hw, but still ~40ms seems very high.\r\n\r\nThat 37.5ms number was averaged from captures on older hardware. On new hardware, the same code span still takes ~9ms. These numbers are from optimized (`/O2`) code with assertions and iterator debug checks disabled.\r\n\r\n> There are many, from cleaning up pools in parallel and force-destroying entities to using a pool mixin that tracks assigned components (for example with a bloom filter or such) and touches only a few storage classes on destruction and so on. The best one depends on your mt requirements, that is, if you want to remove components/destroy entities in parallel or not.\r\n\r\nI do have a thread pool available, so parallelization is an option. I'm curious what you would recommend here since not every component will be on every entity.\r\n\r\nMy primary alternative is some sort of throttling, i.e. moving the contents of the bundle to a `pendingDeletion` list and draining some smaller number of entities from that every frame.\r\n\r\n> The other option is to wait until I come up with and publish an update upstream because I'm working on this specific aspect, so it's probably only a matter of time to have something built-in.\r\n\r\nDue to API changes since 3.6.0, it's not certain I will be able to update to a new version but I will try to keep this option open if you think it will be soon."
      },
      {
        "user": "skypjack",
        "created_at": "2021-05-19T06:45:51Z",
        "body": "> since not every component will be on every entity\r\n\r\nUpstream `remove` checks if the component exists before removing it and doesn't assert. It also exists a range version for it.\r\n\r\n> i.e. moving the contents of the bundle to a pendingDeletion list and draining some smaller number of entities from that every frame.\r\n\r\nYeah, this is yet another option actually. What does a bundle contain?\r\n\r\n> Due to API changes since 3.6.0, it's not certain I will be able to update to a new version but I will try to keep this option open if you think it will be soon.\r\n\r\nOh, it should be very easy anyway. As for the schedule, it's one of the things I've in the pipeline for work, so whether or not it's _soon_ depends only on your definition of soon. üôÇ "
      },
      {
        "user": "growlitheharpo",
        "created_at": "2021-05-20T15:43:38Z",
        "body": "> What does a bundle contain?\r\n\r\nA bundle is basically just a `std::vector<entt::entity>`, there is no other \"metadata\" attached to it. It is just used to group logically related entities that are created and destroyed together, for example the entities that make up Level 1 would be one bundle, Level 2 is another bundle, Level 3 is another, etc. As you progress into Level 2, you no longer need Level 1, so I want to destroy all of its entities. This is done \"seamlessly\" (i.e. there's no load screen or anything) which is why it is important that it doesn't take too long.\r\n\r\n"
      },
      {
        "user": "skypjack",
        "created_at": "2021-05-21T06:42:07Z",
        "body": "I see. Have you thought of using different registries for different levels, so as to discard one as a whole when needed?\r\nAnyway, let me know if you want to investigate further one of the possible solutions or if you'll just wait me to push upstream the required changes to have something built-in. üôÇ \r\nIn both cases, please, don't close the issue, so that we can track all progresses here."
      },
      {
        "user": "skypjack",
        "created_at": "2021-06-24T12:49:15Z",
        "body": "I made a quick and dirty test: 100k entities with 1k components each. Deleting them with an optimized path takes ~30% of the time if compared to the current implementation. That is, less than half of the time.\r\nI'm trying to figure out how to implement it properly but it should be available upstream (and fully documented) soon."
      },
      {
        "user": "skypjack",
        "created_at": "2021-06-28T13:53:29Z",
        "body": "Branch `wip` contains some general purpose optimizations for the `destroy` function that also work for the single entity version.\r\nMoreover, it offers that _non-`EnTT` iterators optimization_ for the range-`destroy`. It would be great if you could give it a try and let me know."
      }
    ]
  },
  {
    "number": 706,
    "title": "Questions about resource_handle",
    "created_at": "2021-05-17T05:17:48Z",
    "closed_at": "2021-07-20T14:36:47Z",
    "labels": [
      "question",
      "solved"
    ],
    "url": "https://github.com/skypjack/entt/issues/706",
    "body": "1. Is there a way I can clear the reference of resource_handle just like std::shared_ptr::reset?\r\n2. There seems no == operator overloading, how can I compare two resource_handles?\r\nThanks!",
    "comments_url": "https://api.github.com/repos/skypjack/entt/issues/706/comments",
    "author": "hls333555",
    "comments": [
      {
        "user": "skypjack",
        "created_at": "2021-05-17T06:48:26Z",
        "body": "1. `handle = {}`?\r\n2. Do you want to compare the contained objects or their addresses?\r\n    ```cpp\r\n    bool obj = *h1 == *h2;\r\n    bool addr = std::addressof(*h1) == std::addressof(*h2);\r\n    ```"
      },
      {
        "user": "hls333555",
        "created_at": "2021-05-17T07:18:43Z",
        "body": "> 1. `handle = {}`?\r\n> 2. Do you want to compare the contained objects or their addresses?\r\n>    ```c++\r\n>    bool obj = *h1 == *h2;\r\n>    bool addr = std::addressof(*h1) == std::addressof(*h2);\r\n>    ```\r\n\r\nThanks! I'll have a try!"
      },
      {
        "user": "skypjack",
        "created_at": "2021-05-17T07:54:45Z",
        "body": "You're welcome. I'm closing the issue but feel free to reopen it in case of problems. üëç "
      },
      {
        "user": "hls333555",
        "created_at": "2021-05-17T10:44:19Z",
        "body": "I want to fully simulate what std::shared_ptr does so I choose to compare their addresses. Here's what I write:\r\n```\r\ntemplate<typename T>\r\nbool operator==(const entt::resource_handle<T>& lhs, const entt::resource_handle<T>& rhs)\r\n{\r\n    return std::addressof(*lhs) == std::addressof(*rhs);\r\n}\r\n```\r\nBut this will cause an assertion if any of them has null resource assigned. Any ideas? Thanks!"
      },
      {
        "user": "skypjack",
        "created_at": "2021-05-17T10:46:38Z",
        "body": "Handles convert to bool. You can check if both are valid before getting the elements."
      },
      {
        "user": "hls333555",
        "created_at": "2021-05-17T11:06:47Z",
        "body": "> Handles convert to bool. You can check if both are valid before getting the elements.\r\n\r\nSo I just modify like this\r\n```\r\ntemplate<typename T>\r\nbool operator==(const Asset<T>& lhs, const Asset<T>& rhs)\r\n{\r\n    if (lhs && rhs) return std::addressof(*lhs) == std::addressof(*rhs);\r\n    if (!lhs && !rhs) return true;\r\n    return false;\r\n}\r\n```"
      },
      {
        "user": "skypjack",
        "created_at": "2021-05-18T06:10:12Z",
        "body": "Yeah, exactly, something like:\r\n```cpp\r\nreturn (!lhs && !rhs) || (lhs && rhs && std::addressof(*lhs) == std::addressof(*rhs));\r\n```"
      },
      {
        "user": "hls333555",
        "created_at": "2021-06-05T09:20:12Z",
        "body": "Hey~\r\nIs there a way I can assign `entt::resource_handle<Derived>` to `entt::resource_handle<Base>`?\r\n\r\nI have an abstract asset class called IAsset, and a derived class called SceneAsset. I want to implement a getter somewhere to get the appropriate asset with a virtual function like below:\r\n```C++\r\nvirtual entt::resource_handle<IAsset> GetAsset() = 0;\r\n```\r\nBut I cannot get the following to work (it says \"no suitable conversion exists\"):\r\n```C++\r\nvirtual entt::resource_handle<IAsset> GetAsset() override { return m_SceneAsset; /* Its type is entt::resource_handle<SceneAsset> */ }\r\n```\r\n\r\nThanks!"
      },
      {
        "user": "skypjack",
        "created_at": "2021-06-05T21:06:27Z",
        "body": "There is no built-in method to do that with the default implementation of a handle.\r\nHowever, it looks like a good addition. I invite you to create a new issue for that. üôÇ \r\n\r\nThat said, in the meantime you can get around it by specializing the handle class.\r\nIt's more cumbersome than a built-in solution but it can get the job done if you can't wait."
      },
      {
        "user": "hls333555",
        "created_at": "2021-06-06T05:56:51Z",
        "body": "> There is no built-in method to do that with the default implementation of a handle.\r\n> However, it looks like a good addition. I invite you to create a new issue for that. üôÇ\r\n> \r\n> That said, in the meantime you can get around it by specializing the handle class.\r\n> It's more cumbersome than a built-in solution but it can get the job done if you can't wait.\r\n\r\nSure, I'll wait for that!"
      },
      {
        "user": "skypjack",
        "created_at": "2021-06-06T07:45:49Z",
        "body": "Lets' reopen the issue to not forget about it. üëç "
      },
      {
        "user": "skypjack",
        "created_at": "2021-06-22T16:55:15Z",
        "body": "Can you tell me if the conversion functions available on branch `wip` work as expected? Thanks."
      },
      {
        "user": "hls333555",
        "created_at": "2021-06-23T06:18:01Z",
        "body": "> Can you tell me if the conversion functions available on branch `wip` work as expected? Thanks.\r\n\r\nI'm using single-include file in my engine, could you please update that so that I can easily test it? Thanks!"
      },
      {
        "user": "GavinNL",
        "created_at": "2021-07-02T14:52:40Z",
        "body": "Hi @skypjack , is it possible to add a function to resource_handle to return the shared_ptr's `use_count()`?\r\n\r\n"
      },
      {
        "user": "skypjack",
        "created_at": "2021-07-02T22:26:42Z",
        "body": "@GavinNL it makes sense actually but could you open another issue for that?\r\nI want to keep track of all requests and I risk to miss them if they are in a comment of a different issue.\r\nThanks!"
      },
      {
        "user": "GavinNL",
        "created_at": "2021-07-02T22:30:04Z",
        "body": "Sure! I'll do that."
      },
      {
        "user": "hls333555",
        "created_at": "2021-09-25T04:13:27Z",
        "body": "> Can you tell me if the conversion functions available on branch `wip` work as expected? Thanks.\r\n\r\n\r\n> Hey~\r\n> Is there a way I can assign `entt::resource_handle<Derived>` to `entt::resource_handle<Base>`?\r\n> \r\n> I have an abstract asset class called IAsset, and a derived class called SceneAsset. I want to implement a getter somewhere to get the appropriate asset with a virtual function like below:\r\n> \r\n> ```c++\r\n> virtual entt::resource_handle<IAsset> GetAsset() = 0;\r\n> ```\r\n> \r\n> But I cannot get the following to work (it says \"no suitable conversion exists\"):\r\n> \r\n> ```c++\r\n> virtual entt::resource_handle<IAsset> GetAsset() override { return m_SceneAsset; /* Its type is entt::resource_handle<SceneAsset> */ }\r\n> ```\r\n> \r\n> Thanks!\r\n\r\nI have tested this conversion. It works pretty well in 3.8.0_single_include file! Thanks!\r\nCould you please add another conversion function like std::dynamic_pointer_cast<> as down_cast is also important to me. Thanks a lot!"
      },
      {
        "user": "skypjack",
        "created_at": "2021-09-25T16:21:59Z",
        "body": "I strongly suggest to open a dedicated issue for this @hls333555 I can't promise I won't forget about it otherwise. üòÖ "
      }
    ]
  },
  {
    "number": 698,
    "title": "Ordered Rendering by Systems",
    "created_at": "2021-04-26T11:24:36Z",
    "closed_at": "2021-04-28T21:28:25Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/skypjack/entt/issues/698",
    "body": "Is there a way to sort the systems so when they render will be in the correct order?  For example my entity has a grid component a core component and a background component.  While another entity must be render between the grid and the background.  Is it possible with your current implementation to sort systems based on rendering order?",
    "comments_url": "https://api.github.com/repos/skypjack/entt/issues/698/comments",
    "author": "MonkeyToiletLadder",
    "comments": [
      {
        "user": "MonkeyToiletLadder",
        "created_at": "2021-04-26T11:57:49Z",
        "body": "Either i will have to sort the systems or make a rendering manager that stores references to components and sort those.\r\n"
      },
      {
        "user": "MonkeyToiletLadder",
        "created_at": "2021-04-26T12:58:20Z",
        "body": "ah i have read the documentation and realized that there are no systems.  hmm."
      },
      {
        "user": "skypjack",
        "created_at": "2021-04-26T13:16:10Z",
        "body": "Hi, yeah, `EnTT` doesn't take over your systems. It's designed as a _container_ that you can use as you would use a vector or anything else.\r\nSo, you can sort your systems the way you prefer. If you want to sort entities and components instead, pools offer an in-place sorting functionality.\r\nLet me know if you need more details. üëç "
      },
      {
        "user": "MonkeyToiletLadder",
        "created_at": "2021-04-26T22:55:56Z",
        "body": "Would i sort the components from the register or would i have to make a sparse_set of components?  Would it be more efficient to have a seperate manager that stores and renders renderable components instead of sorting the components every draw call?"
      },
      {
        "user": "MonkeyToiletLadder",
        "created_at": "2021-04-27T01:41:22Z",
        "body": "Another option would be to have multiple pools of components that way i dont need to sort them assuming your system allows this.\r\nSorry for the questions im a noob and reading through all the code is daunting."
      },
      {
        "user": "skypjack",
        "created_at": "2021-04-27T07:03:25Z",
        "body": "> Would i sort the components from the register or would i have to make a sparse_set of components?\r\n\r\nYou can sort pools directly from the registry as `reg.sort<T>(comparator)`, but you can also create your own storage class externally and sort it if you prefer.\r\n\r\n> Would it be more efficient to have a seperate manager that stores and renders renderable components instead of sorting the components every draw call?\r\n\r\nYeah, maybe. It would also be more efficient to use for example insertion sort as an algorithm with the sorting functionality if you know that only a couple of elements are to be moved. The main problem I see with a separate manager is that you can't easily mix it with other views (it's possible, though more cumbersome), but maybe you don't even need to do that, so...\r\nIn any case, I'd rather go with what is easier to work with initially, then measure and eventually change approach if needed. I wouldn't try to optimize in advance just because. üôÇ "
      },
      {
        "user": "MonkeyToiletLadder",
        "created_at": "2021-04-28T01:26:12Z",
        "body": "I have one more question.  How are you able to store any structure as components without them having to inherit from a base component class?"
      },
      {
        "user": "skypjack",
        "created_at": "2021-04-28T07:20:42Z",
        "body": "> How are you able to store any structure as components without them having to inherit from a base component class?\r\n\r\nType erasure, nothing special. All pool types are unknown even to the registry.\r\nThis approach has its pros and cons. This one is definetely a pro. üôÇ "
      }
    ]
  },
  {
    "number": 691,
    "title": "What happened to entt::registry.has?",
    "created_at": "2021-04-11T06:50:06Z",
    "closed_at": "2021-04-11T22:28:37Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/skypjack/entt/issues/691",
    "body": "I used to be able to use registry.has, and it is still present in the single include. However, in the most updated version of entt, no such function exists. I can't seem to find an alternative, does anyone know what it is?",
    "comments_url": "https://api.github.com/repos/skypjack/entt/issues/691/comments",
    "author": "hazeled",
    "comments": [
      {
        "user": "Green-Sky",
        "created_at": "2021-04-11T14:27:48Z",
        "body": "It has been renamed to `all_of`.\r\n\r\n@skypjack I told you to deprecate it first! :'D\r\n\r\nedit: @hazeled this is related to #690 , next time search for issues first ^^"
      },
      {
        "user": "hazeled",
        "created_at": "2021-04-11T22:28:37Z",
        "body": "Ah, thank you! I searched first but totally missed that, whoops. Appreciate the help! "
      },
      {
        "user": "skypjack",
        "created_at": "2021-04-12T10:11:30Z",
        "body": "> @skypjack I told you to deprecate it first! :'D\r\n\r\nSo true @Green-Sky thanks for answering!"
      }
    ]
  },
  {
    "number": 679,
    "title": "Would it be reasonable to get the shared_ptr from a resource_handle?",
    "created_at": "2021-03-20T21:48:29Z",
    "closed_at": "2021-03-30T08:11:19Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/skypjack/entt/issues/679",
    "body": "Hello, I've been using the resource management classes and they've been great, but I ran into an issue as I've started to build out my project's accompanying UI library.\r\n\r\nI would like this UI lib to not enforce an entt dependency on the consumer (especially not a requirement that they use an entt::resource_cache), but I would like to continue using it in my own project. Unfortunately, there's no way that I can see to get the underlying shared_ptr from a resource_handle, so I don't seem to have a good way to pass lifetime responsibilities along to the UI objects that will be using the resources.\r\n\r\nMy question is: would it be reasonable to add a way to get the shared_ptr from a resource_handle? Or is there some complication that I'm not seeing?",
    "comments_url": "https://api.github.com/repos/skypjack/entt/issues/679/comments",
    "author": "Net5F",
    "comments": [
      {
        "user": "skypjack",
        "created_at": "2021-03-21T08:38:16Z",
        "body": "Technically speaking, it's trivial.\nOn the other side, I always wanted to remove the constraint on the shared pointer and have stateless loaders that manage their own memory. In this case, your suggestion would break the design.\n\nSince caches are defined on a per-type basis, we could make the handle sfinae-friendly and allow user customizations. This would solve your issue. Actually, it's already possible in fact.\nAnother approach is that your library exports its own handle type to callers rather than the EnTT one. Overall, it would also make it easier to modify your engine internals without affecting other libraries, at least as long as the API of your handle doesn't change. As a first implementation, it can just be an alias for the EnTT handle."
      },
      {
        "user": "Net5F",
        "created_at": "2021-03-21T15:41:19Z",
        "body": "Good ideas, I went with the specialization approach for now and it's working just fine. Thanks!"
      },
      {
        "user": "skypjack",
        "created_at": "2021-03-22T07:22:19Z",
        "body": "Please, leave this issue open. It made me think and I can achieve my goal with a few changes.\r\nBriefly, if the loader returned a handle rather than a shared pointer, I could allow for specializations that don't rely on shared pointers anymore while still offering a default that works as it does nowadays.\r\nA breaking change in the API, but also an easy one to manage, so I don't really care about it."
      }
    ]
  },
  {
    "number": 645,
    "title": "Component using aligned type like Eigen::Matrix3d",
    "created_at": "2021-01-28T19:05:57Z",
    "closed_at": "2021-01-28T22:48:50Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/skypjack/entt/issues/645",
    "body": "Hello! I am looking into using entt and want to know about storing an aligned type, like an Eigen::Matrix3d, as a component type in an entt::registry. I have seen multiple mentions that the only requirement for a component is that the type is movable. But eigen alignment issues have been a pain for me (outside of entt) for a while, so I just wanted to check and see about the consequences of using an aligned type as a component.\r\n\r\nThanks for making entt available!",
    "comments_url": "https://api.github.com/repos/skypjack/entt/issues/645/comments",
    "author": "pwm1234-sri",
    "comments": [
      {
        "user": "sunnlok",
        "created_at": "2021-01-28T19:49:48Z",
        "body": "AFAIK the master branch of eigen as well as the next version of it should support cpp17s aligned new which should solve this problem in general with containers.\r\nOtherwise you would need to write a custom pool implementation for your eigen types. "
      },
      {
        "user": "skypjack",
        "created_at": "2021-01-28T22:01:26Z",
        "body": "Indeed. The rule of thumb is: if it works in an `std::vector`, it works with the default pool of `EnTT`.\r\nOtherwise, `EnTT` offers the possibility to design your own pool for all types or on a per-type and per-traits basis.\r\nSo, one way or the other, you should be able to get it work."
      },
      {
        "user": "pwm1234-sri",
        "created_at": "2021-01-28T22:48:50Z",
        "body": "Thank you - I appreciate your help!"
      },
      {
        "user": "skypjack",
        "created_at": "2021-01-28T23:32:13Z",
        "body": "You're welcome. Let us know if you find anything interesting about this topic. It may help future users in case. Thanks. üôÇ "
      }
    ]
  },
  {
    "number": 631,
    "title": "Performance when accessing component via view.get vs registry.get",
    "created_at": "2021-01-06T09:07:04Z",
    "closed_at": "2021-01-11T11:52:24Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/skypjack/entt/issues/631",
    "body": "If I know that always when an entity has component A it also has component B, is there any difference from a perfomance point of view between\r\n```\r\nauto view = registry.view<A, B>();\r\nfor (auto entity : view) {\r\n\tauto& A = view.get<A>(entity);\r\n        auto& B = view.get<B>(entity);\r\n        ...\r\n}\r\n```\r\nvs\r\n```\r\nauto view = registry.view<A>();\r\nfor (auto entity : view) {\r\n\tauto& A = view.get<A>(entity);\r\n        auto& B = registry.get<B>(entity);\r\n        ...\r\n}\r\n```\r\nCheers",
    "comments_url": "https://api.github.com/repos/skypjack/entt/issues/631/comments",
    "author": "Aardvarklord",
    "comments": [
      {
        "user": "skypjack",
        "created_at": "2021-01-06T22:09:37Z",
        "body": "This is such a common use case that I planned a dedicate custom pool for the next iteration (it's in the TODO list).\r\n\r\nUntil it's done, probably this is your best bet:\r\n```\r\nauto view = registry.view<A, B>();\r\nfor (auto [entity, a, b]: view.each()) {\r\n    ...\r\n}\r\n```\r\nOtherwise, you can use the `.each(F)` function:\r\n```\r\nview.each([](auto entity, auto &a, auto &b) { ... }\r\n```"
      },
      {
        "user": "Aardvarklord",
        "created_at": "2021-01-07T19:41:58Z",
        "body": "Ok, thanks!\r\n\r\nThe second alternative works fine, but for the first alternative Microsoft Visual Studio 2019 (compiling with C++17) gives these errors:\r\n\r\n```\r\nerror C2672: 'entt::basic_view<Entity,entt::exclude_t<>,A,B>::each': no matching overloaded function found\r\nerror C2780: 'void entt::basic_view<Entity,entt::exclude_t<>,A,B>::each(Func) const': expects 1 arguments - 0 provided\r\n```\r\n"
      },
      {
        "user": "skypjack",
        "created_at": "2021-01-08T11:00:09Z",
        "body": "Mmm... because I missed a closing `)`? üôÇ "
      },
      {
        "user": "Aardvarklord",
        "created_at": "2021-01-08T19:00:50Z",
        "body": "I meant this gives the compilation errors:\r\n ```\r\nauto view = registry.view<A, B>();    \r\nfor (auto [entity, a, b] : view.each()) {\r\n        \r\n}\r\n\r\n```\r\nSeems the compiler thinks the each method expects a Func object. I'm probably missing something trivial... not quite up to speed on the modern c++ language constructs :relaxed:"
      },
      {
        "user": "skypjack",
        "created_at": "2021-01-08T22:12:14Z",
        "body": "Aha, that's because it's called `proxy` in v3.5.2, sorry."
      }
    ]
  },
  {
    "number": 614,
    "title": "Search by Component",
    "created_at": "2020-12-19T17:14:55Z",
    "closed_at": "2020-12-26T15:58:21Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/skypjack/entt/issues/614",
    "body": "I'm reimplementing a certain game, and try to map its logical system to entt. In this system, most objects (but not all) have a certain ID, which is used for example for accessing them through scripts. I realized this ID through an additional component, and now my question is what is the \"standard\" way of searching an entity by a component?",
    "comments_url": "https://api.github.com/repos/skypjack/entt/issues/614/comments",
    "author": "Nostritius",
    "comments": [
      {
        "user": "Green-Sky",
        "created_at": "2020-12-19T17:23:19Z",
        "body": "This sounds very inefficient...\r\nI would create a separate data-structure for GAME_ID -> ENTT_ID lookup, like a unordered_map."
      },
      {
        "user": "skypjack",
        "created_at": "2020-12-19T22:18:35Z",
        "body": "Searching an entity by a component or by a value of a data member in a component?\r\nBecause in the first case you can just use a `view`."
      },
      {
        "user": "Nostritius",
        "created_at": "2020-12-23T16:46:47Z",
        "body": "I'm searching for an component by value. View seems to work fine, thanks. Just out of interest, since I found entt::to_entity, which works on the component by reference, why is there no method like this which works by value?"
      },
      {
        "user": "skypjack",
        "created_at": "2020-12-23T22:36:31Z",
        "body": "`to_entity` relies on pointer arithmetic, it dosen't iterate a view. You can't do the same if searching by value. That's all. üôÇ "
      },
      {
        "user": "skypjack",
        "created_at": "2020-12-26T15:58:21Z",
        "body": "I'm closing this issue because I assume it was answered.\r\nFeel free to continue the discussion here if this isn't the case and eventually reopen the issue.\r\nThanks. üôÇ "
      }
    ]
  },
  {
    "number": 604,
    "title": "dll interface type_seq does not work as expected",
    "created_at": "2020-12-06T09:56:59Z",
    "closed_at": "2020-12-06T13:54:15Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/skypjack/entt/issues/604",
    "body": "Hi,\r\n\r\nI have a base component library (Engine* .dll) which contains the _**entt::registry**_ and is built with the _ENTT_API_EXPORT_ flag\r\nand one or more libraries (plugin _ *. dll) with an extended set of components that can be dynamically loaded\r\n\r\nIf you build (plugin*. dll) with the _ENTT_API_IMPORT_ flag, \r\nthere will be a link error if I try to create the components defined in plugin.dll, since in Engine*.dll, _entt::type_seq<Plugin :: Component>::value()_ is not called anywhere\r\n\r\nIf you disable _ENTT_API_IMPORT_, then incorrect _entt::type_seq<T>_ will be generated.\r\n\r\nversion 3.3.6 worked correctly for me, after updating to 3.6.0 it broke.",
    "comments_url": "https://api.github.com/repos/skypjack/entt/issues/604/comments",
    "author": "Logris",
    "comments": [
      {
        "user": "skypjack",
        "created_at": "2020-12-06T13:31:12Z",
        "body": "With v3.6 you mean `master`, `experimental`, `dev`, ...? Because there is no v3.6 release yet. üôÇ \r\nAlso, what's version 3.3.6? There doesn't exist that version, so I dunno exactly to what version you refer, sorry."
      },
      {
        "user": "Logris",
        "created_at": "2020-12-06T13:34:48Z",
        "body": "sorry, version 3.3.2\r\n\r\nI am currently using master 3.6.0"
      },
      {
        "user": "Logris",
        "created_at": "2020-12-06T13:48:59Z",
        "body": " version v3.5.2 works correctly"
      },
      {
        "user": "skypjack",
        "created_at": "2020-12-06T13:49:46Z",
        "body": "Ok, though I don't know how it worked with v3.3.2 to be honest.\r\nThe only version that changed something in this sense what v3.5.2 and it introduced a performance hit because of that in case users created views on the fly all the times. Therefore, we decided to rollback those changes.\r\n\r\nAs far as I know, `ENTT_API_*` works fine if you have the same types on both sides of a boundary or at least such that one side of the boundary uses only a subset of the types used on the other side, otherwise it's expected to result in unresolved symbols.\r\nThe `test/lib` dir contains an example of a shared context to which `type_seq` refers to work properly across boundaries in all other cases instead. It uses `cr` under the hood but it's not mandatory, it's just a lib I liked to manage plugins and shared libraries in general.\r\n\r\nThe new poly storage on which I'm working should introduce yet another tool to work across boundaries without having to specialize `type_seq`, but you've to wait a little for that, since it's still under development."
      },
      {
        "user": "Logris",
        "created_at": "2020-12-06T13:54:08Z",
        "body": "Ok,\r\nThanks"
      },
      {
        "user": "skypjack",
        "created_at": "2020-12-06T14:24:07Z",
        "body": "I invite you to join the `gitter`channel or the `discord` server in case of doubts.\r\nI't pretty easy to make it work in fact, but still. üôÇ "
      },
      {
        "user": "Logris",
        "created_at": "2020-12-06T15:50:50Z",
        "body": "Thanks, \r\nI connected to gitter"
      },
      {
        "user": "Sonolil",
        "created_at": "2021-05-09T07:46:44Z",
        "body": "I had the same problem. I don't remember which version I had but I changed to v3.5.2 and it worked fine."
      }
    ]
  },
  {
    "number": 595,
    "title": "feature request: emplace_or_patch",
    "created_at": "2020-11-23T14:52:04Z",
    "closed_at": "2020-12-03T09:56:13Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/skypjack/entt/issues/595",
    "body": "I find myself often wanting to do an emplate_or_patch operation -- if an entity has the component, patch it as normal.  But if it doesn't exist, create one with initial values and then patch it with the function. \"Initial values\" could be defined as brace-or-equal initializers for structs:\r\n\r\n`struct myComponent {\r\n  int thingy = 10;\r\n};`\r\n\r\nOr a default constructor for classes.",
    "comments_url": "https://api.github.com/repos/skypjack/entt/issues/595/comments",
    "author": "ywwg",
    "comments": [
      {
        "user": "skypjack",
        "created_at": "2020-11-24T07:40:49Z",
        "body": "Hi, sorry for being late.\r\n`get_or_emplace` and `emplace_or_replace` were introduced for this kind of patterns. Wouldn't they work as well in your case?\r\nThe main problem with something like `emplace_or_patch` is that it would trigger two signals because of how `patch` works. On the other side, something like `emplace_or_replace` only triggers the _correct_ event after use."
      },
      {
        "user": "ywwg",
        "created_at": "2020-11-26T04:41:51Z",
        "body": "I often want to update a value in a component that may not exist, so I need to do a multi-step process:\r\n\r\n```\r\nint old_val = 0;\r\nif (reg.has<Component>(ent)) {\r\n  old_val = reg.get<Component>(ent);\r\n}\r\nreg.emplace_or_replace<Component>(ent, old_val + change_val);\r\n```\r\n\r\nit looks like I can use get_or_emplace I think?  I didn't see that before.\r\n\r\n```\r\nint old_val = reg.get_or_emplace<Component>(ent, 0);\r\nreg.replace<Component>(ent, old_val + change);\r\n```\r\n\r\nIf you think that's performant that would fulfill my use-case."
      },
      {
        "user": "skypjack",
        "created_at": "2020-11-26T07:38:47Z",
        "body": "That's definitely the way to go. Yeah.\r\nIt's also far easier to work with and to maintain than a `get_or_patch` from my point of view."
      },
      {
        "user": "skypjack",
        "created_at": "2020-12-03T09:56:13Z",
        "body": "I close this one as I suspect that the answer was satisfactory. üôÇ \r\nFeel free to continue the discussion here if you've any other doubt. üëç "
      }
    ]
  },
  {
    "number": 567,
    "title": "size() of multi component view seems wrong?",
    "created_at": "2020-10-09T10:31:11Z",
    "closed_at": "2020-10-09T13:05:30Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/skypjack/entt/issues/567",
    "body": "```c++\r\n#include <entt/entt.hpp>\r\n\r\nstruct A {};\r\nstruct B {};\r\nstruct C {};\r\n\r\nint main() {\r\n   entt::registry registry;\r\n\r\n   {\r\n      auto A_and_B = registry.create();\r\n      registry.emplace<A>(A_and_B);\r\n      registry.emplace<B>(A_and_B);\r\n   }\r\n   {\r\n      auto A_and_C = registry.create();\r\n      registry.emplace<A>(A_and_C);\r\n      registry.emplace<C>(A_and_C);\r\n   }\r\n\r\n   const auto before = registry.view<A, B>().size(); // 1\r\n   {\r\n      auto only_B = registry.create();\r\n      registry.emplace<B>(only_B);\r\n   }\r\n   const auto after = registry.view<A, B>().size(); // 2\r\n\r\n   return 0;\r\n}\r\n```\r\nAs I understand it, multi component views mean entities that contain *all* the components. Quoting from `view.hpp`: \"Multi component views iterate over those entities that have at least all the given components in their bags\". So why is the view size two when there was no second entity added with both A and B? I'm probably understanding something wrong.",
    "comments_url": "https://api.github.com/repos/skypjack/entt/issues/567/comments",
    "author": "s9w",
    "comments": [
      {
        "user": "skypjack",
        "created_at": "2020-10-09T10:34:29Z",
        "body": "In fact, it's a _size hint_ and it has already been renamed to `size_hint` for the next version, to avoid errors.\r\nThe view estimates only the maximum amount of entities that can be returned during an iteration."
      },
      {
        "user": "s9w",
        "created_at": "2020-10-09T10:36:30Z",
        "body": "I see, so is there a way to get the actual number of such entities other than iterating?"
      },
      {
        "user": "skypjack",
        "created_at": "2020-10-09T11:55:22Z",
        "body": "Groups know the exact number of multi-type sets. Multi-type views do not, unless ofc you iterate them. Single type views know it instead, for obvious reasons."
      },
      {
        "user": "s9w",
        "created_at": "2020-10-09T13:05:30Z",
        "body": "Got it. Thanks a lot!"
      },
      {
        "user": "skypjack",
        "created_at": "2020-10-09T13:16:15Z",
        "body": "You're welcome. I also invite you to join the gitter channel or the discord server if you've any other question like this one. You may get a response much faster from whoever is there! üòâ "
      }
    ]
  },
  {
    "number": 563,
    "title": "Is it possible to create a view from begin/end iterators?",
    "created_at": "2020-10-02T16:29:41Z",
    "closed_at": "2020-10-04T06:32:48Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/skypjack/entt/issues/563",
    "body": "I have a vector of entities that are a subset of all entities within my registry. These entities contain `>=1` component I am interested in viewing. Is this code possible?\r\n\r\n```C++\r\nstd::vector<entt::entity> ids;\r\n...\r\nauto begin = std::begin(ids);\r\nauto end   = std::end(ids);\r\n\r\n// Does something like this exist? (constructing a view from a pair of iterators)\r\nauto view = registry.view<ComponentA, ComponentB>(begin, end);\r\n```\r\n\r\nI know it's possible to do this manually like so: \r\n```C++\r\nfor (auto const id : ids)\r\n{\r\n    auto const& ca = registry.get<ComponentA>(id);\r\n    auto const& cb = registry.get<ComponentB>(id);\r\n    ...\r\n}\r\n```\r\n\r\nHowever this feels like I'm programming at a lower level, instead of programming what I want to do, it feels like I'm programming how to do it. I'm sorry again if I missed a way to do this that's spelled out in the wiki / inline documentation, if it's there I haven't been able to find it.\r\n\r\nThanks :)",
    "comments_url": "https://api.github.com/repos/skypjack/entt/issues/563/comments",
    "author": "bjadamson",
    "comments": [
      {
        "user": "skypjack",
        "created_at": "2020-10-03T16:59:04Z",
        "body": "Hit there,\n\nIt's not possible actually.\nI think the main problem is that the view cannot be sure that those entities really have the components.\n\nWhy don't you just iterate the vector and get the components from the view instead? Something like:\n```\nauto view = registry.view<Component A, ComponentB>();\n\nfor(auto id: ids) {\n    auto [ca, cb] = view.get(id);\n    // ...\n}\n```"
      },
      {
        "user": "bjadamson",
        "created_at": "2020-10-04T06:32:47Z",
        "body": "I hadn't considered creating the view with no arguments before, this should work perfectly. Thank you :)"
      },
      {
        "user": "skypjack",
        "created_at": "2020-10-04T06:58:40Z",
        "body": "You're welcome. :+1:"
      }
    ]
  },
  {
    "number": 545,
    "title": "Question: use member template function as a on_construct callback?",
    "created_at": "2020-08-18T17:51:46Z",
    "closed_at": "2020-08-18T21:43:50Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/skypjack/entt/issues/545",
    "body": "Hello\r\n\r\nIs there any way do do something like this? I'm trying to use a templated member function as a callback, but it doesn't seem to work with templates. Gcc says it is unable to deduce auto\r\n\r\n```\r\nstruct Project\r\n{\r\n    entt::registry m_registry;\r\n\r\n    template<Comp>\r\n    void onDestroy(registry &r, entity e);\r\n\r\n    Project()\r\n    {\r\n        m_registry.on_destroy<MyComp>().connect< &Project::onDestroy<MyComp>  >(*this);\r\n        m_registry.on_destroy<MyComp2>().connect< &Project::onDestroy<MyComp2>  >(*this);\r\n    }\r\n    \r\n};\r\n\r\ntemplate<>\r\ninline void Project::onDestroy<MyComp>(entt::registry & r, entity e )\r\n{\r\n    ...\r\n}\r\n\r\ntemplate<>\r\ninline void Project::onDestroy<MyComp2>(entt::registry & r, entity e )\r\n{\r\n    ...\r\n}\r\n\r\n```",
    "comments_url": "https://api.github.com/repos/skypjack/entt/issues/545/comments",
    "author": "GavinNL",
    "comments": [
      {
        "user": "skypjack",
        "created_at": "2020-08-18T21:05:59Z",
        "body": "Afaik it should work. Can you provide a minimal example (you can use the online tool, see the README) and the error returned by GCC? Thanks."
      },
      {
        "user": "GavinNL",
        "created_at": "2020-08-18T21:43:50Z",
        "body": "Hmmm... you know what I think this is more of a C++ level problem I'm having.  I think i'm trying to do something that's not C++ complaint.\r\n\r\nI will close this."
      }
    ]
  },
  {
    "number": 509,
    "title": "Question: view<> based on base class type",
    "created_at": "2020-06-15T18:11:26Z",
    "closed_at": "2020-06-15T19:33:34Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/skypjack/entt/issues/509",
    "body": "Hello,\r\n\r\nJust getting to know entt, liking it so far :)\r\n\r\nIs it possible to do something like this?\r\n\r\n```C++\r\nclass A{};\r\nclass B : public A {};\r\nclass C : public A {};\r\n\r\nreg.emplace<B>(id);\r\nreg.emplace<C>(id);\r\n\r\nreg.view<A>(id).each(...);\r\n```\r\n\r\nThe above doesn't work, but is there a recommended way to accomplish the same thing?",
    "comments_url": "https://api.github.com/repos/skypjack/entt/issues/509/comments",
    "author": "PerMalmberg",
    "comments": [
      {
        "user": "skypjack",
        "created_at": "2020-06-15T18:18:57Z",
        "body": "No, it's not supported. I'm sorry.\nTo be honest, inheritance based components are a little odd when you decide to move away from typical OOP. This doesn't mean that you shouldn't use inheritance in general. However, it's odd that it entered your component design.\n\nCould it be an XY-problem? What are you trying to solve with this?"
      },
      {
        "user": "PerMalmberg",
        "created_at": "2020-06-15T18:32:45Z",
        "body": "Specifically, I've got this:\r\n\r\n```C++\r\nclass Geometry{};\r\n\r\ntemplate<FinalType, std::size_t VertexCount>\r\nclass Polygon : Geometry\r\n{\r\nprotected:\r\nstd::array<Point<float>, VertexCount> vertices;\r\n};\r\n\r\nclass Triangle : Polygon<Triangle, 3>{}\r\nclass Circle : Polygon<Circle, 16>{}\r\nclass Rect : Polygon<Circle, 4>{}\r\n```\r\nAll the data and functionality is actually in the Polygon-class so the derived classes are really nothing but a name/type, but the inheritance obviously prevents their use in entt.\r\n\r\nI can ofc first iterate Triangle, then Circle etc.\r\n"
      }
    ]
  },
  {
    "number": 492,
    "title": "std::hash is not specialized for entt::hashed_string",
    "created_at": "2020-05-22T16:49:02Z",
    "closed_at": "2020-05-22T17:12:46Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/skypjack/entt/issues/492",
    "body": "Hi there,\r\n\r\nas far as I can tell, there is no specialization of `std::hash` for `entt::hashed_string`, making the simple construction of an `std::unordered_map<hashed_string, T>` impossible without defining a custom hash functor. Is this an oversight or intended? And if it is the latter, why?\r\n\r\nThanks in advance,\r\nScarabytes",
    "comments_url": "https://api.github.com/repos/skypjack/entt/issues/492/comments",
    "author": "Scarabytes",
    "comments": [
      {
        "user": "Innokentiy-Alaytsev",
        "created_at": "2020-05-22T17:03:34Z",
        "body": "Hello!\r\n\r\nKeep in mind that `entt::hashed_string` doesn't store the string data - it only references it. I don't know if it's important for your use case or not. I would just use `entt::hashed_string::value()` as a key in the dictionary."
      },
      {
        "user": "skypjack",
        "created_at": "2020-05-22T17:06:34Z",
        "body": "It's intended actually. `hashed_string` _converts_ to `entt::id_type`, that is, an integral type.\r\nSo, you should rather use `std::unordered_map<entt::id_type, T>` and generate the integral representation both at compile-time or runtime according with your needs.\r\n\r\n@Innokentiy-Alaytsev \r\n>doesn't store the string data\r\n\nProbably the time is come to undertake also this part but it would mean `strcmp` or similar. Not sure I want that all over since in 90% of cases I don't even need to use the string once hashed. "
      },
      {
        "user": "Scarabytes",
        "created_at": "2020-05-22T17:12:46Z",
        "body": "Alright, thanks for the clarification!\r\n"
      }
    ]
  },
  {
    "number": 488,
    "title": "Clarify constructor/destructor calls in documentation",
    "created_at": "2020-05-14T21:21:54Z",
    "closed_at": "2020-05-15T08:52:08Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/skypjack/entt/issues/488",
    "body": "Currently it's not very clear when constructors/destructors are called for components in the ECS wiki text. Could this be clarified?\r\n\r\nFrom my understanding (I could be wrong), component constructors are called before `on_construct` is ever emitted, and `on_destroy` is emitted before destructors are called. Is that correct/guaranteed?",
    "comments_url": "https://api.github.com/repos/skypjack/entt/issues/488/comments",
    "author": "Qix-",
    "comments": [
      {
        "user": "skypjack",
        "created_at": "2020-05-14T21:50:51Z",
        "body": "Not sure what I should clarify exactly. The documentation says that listeners are invoked after components have been assigned to entities. To assign a component to an entity, you've to construct it. So, yeah, constructors are necessarily invoked before any listener is invoked.\r\nThe same applies to destructors. Listeners are invoked before the component is removed and therefore before its destructor is invoked.\r\nIn both cases, the goal is to provide listeners with valid instances of components to use."
      },
      {
        "user": "Qix-",
        "created_at": "2020-05-14T22:07:06Z",
        "body": "Right, but are constructor/destructors invoked when components are replaced? Also, it's not _completely_ unreasonable to assume the the constructors/destructors are not called at all for performance reasons. Could just be me, but I thought the construct/destroy callbacks were in lieu of the constructors and destructors since components could be re-used."
      },
      {
        "user": "skypjack",
        "created_at": "2020-05-14T22:23:05Z",
        "body": ">Right, but are constructor/destructors invoked when components are replaced?\r\n\r\nOf course, before the listeners are invoked. The component is replaced with a new object created as a temporary, so you've a chain of constructor, move constructor, destructor of an object that is in an unspecified but safe state (well, if your objects give this guarantee as stated by the standard, of course).\r\n\r\n>it's not completely unreasonable to assume the the constructors/destructors are not called at all for performance reasons\r\n\r\nIndeed, it is not. However, in case I didn't invoke the constructor, all your objects would be in an invalid state and you couldn't use them after an `emplace`. Am I wrong?\r\n\r\n>Could just be me, but I thought the construct/destroy callbacks were in lieu of the constructors and destructors since components could be re-used.\r\n\r\nOh, no. You can even pass the arguments to use with a constructor when you invoke `emplace`.\r\nThe scope of the listeners isn't this one. To be honest, in C++ it would be odd if I asked to users to attach listeners that perform the construction/destruction of objects.\r\nThese callbacks are meant to perform all other kinds of set up and tear down for components. For example, resource management and such. Also, you can attach the member functions of the registry to the listeners and therefore for example trigger an `emplace` of `T` when you `remove` a `U` from an entity. \r\n"
      },
      {
        "user": "Qix-",
        "created_at": "2020-05-15T05:36:17Z",
        "body": "No, you're right. This was resolved in Discord and it was determined I simply need to pay closer attention.\r\n\r\nThanks @skypjack "
      },
      {
        "user": "skypjack",
        "created_at": "2020-05-15T06:08:41Z",
        "body": "You're welcome. Can I close the issue or are there some changes you want to propose anyway? I didn't get it, sorry. :)"
      },
      {
        "user": "Qix-",
        "created_at": "2020-05-15T08:52:29Z",
        "body": "No sorry, just hit the wrong button :) Thanks again!"
      }
    ]
  },
  {
    "number": 480,
    "title": "on_construct and on_destroy for context variables",
    "created_at": "2020-05-04T16:13:47Z",
    "closed_at": "2020-05-04T16:23:43Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/skypjack/entt/issues/480",
    "body": "Is there a way to attach `on_construct` and `on_destroy` handlers for registry context variables?",
    "comments_url": "https://api.github.com/repos/skypjack/entt/issues/480/comments",
    "author": "Qix-",
    "comments": [
      {
        "user": "skypjack",
        "created_at": "2020-05-04T16:21:41Z",
        "body": "Actually no. What you would expect to receive in the callback exactly?\r\nJust an empty notification that something has been added or deleted?"
      },
      {
        "user": "Qix-",
        "created_at": "2020-05-04T16:23:43Z",
        "body": "Yeah that's what I'd expect....\r\n\r\n... if it weren't for the fact that constructors/destructors were called. You're too fast for me @skypjack ;)\r\n\r\nExisting functionality is fine, idk why I thought you didn't call the constructors. Sorry for the noise <3"
      },
      {
        "user": "skypjack",
        "created_at": "2020-05-04T16:24:48Z",
        "body": "Don't worry. You're welcome. :wink: "
      },
      {
        "user": "alexander-v",
        "created_at": "2020-05-31T10:41:35Z",
        "body": "Hello.\r\nI'm interested in such kind of functionality.\r\nFor example, I'd like to store scene-wide physics settings (gravity etc) in a context variable and make my physics system observe changes in the context variable to push it to PhysX.\r\nHow can I observe changes in contexts without on_update signal?"
      },
      {
        "user": "skypjack",
        "created_at": "2020-05-31T12:22:28Z",
        "body": "@alexander-v your context variable could for example inherit from `entt:emitter`, so that you can update and publish from that."
      }
    ]
  },
  {
    "number": 473,
    "title": "Event dispatcher thread safety",
    "created_at": "2020-04-22T18:33:28Z",
    "closed_at": "2020-04-23T12:19:24Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/skypjack/entt/issues/473",
    "body": "Hi!\r\nAt first - thank you for such awesome library! It helps me a lot!\r\n\r\nI have some question about event dispatcher thread safety. I've read whole available documentation and wiki and found thread-safety notes for `entt::registry` (it isn't thread-safe - that's ok).\r\n\r\nWhat about other classes like event dispatcher? Can I use one instance of event dispatcher from multiple threads?\r\n\r\nWhat is my situation: I have multiple threads, which want to sent some signals to the main thread. Should I create separate dispatcher for every thread or I can share one dispatcher?\r\n\r\nThank you!",
    "comments_url": "https://api.github.com/repos/skypjack/entt/issues/473/comments",
    "author": "zamazan4ik",
    "comments": [
      {
        "user": "skypjack",
        "created_at": "2020-04-23T12:19:24Z",
        "body": "In general, `EnTT` does not guarantee thread safety in any case but most of the times you can easily work with its data structures without even caring about it.\r\nFor example, if your threads aim to send different signals, they use different pools under the hood and will never interfere with each other. In all other cases, you've to provide your own access mechanism to guarantee thread safety.\r\nThe reason behind this is obvious: we, as users, are the only ones that can get the best out of how we use these objects, A built-in mechanism to make it fully thread safe would be a performance penalty in 99% of cases and it doesn't worth it imho.\r\n\r\nI'm closing the issue since we have already discussed this on gitter too (it's you, right?). Feel free to reopen in case. :+1: "
      }
    ]
  },
  {
    "number": 460,
    "title": "invoking an entt::meta function doesn't change caller by-ref parameter ",
    "created_at": "2020-04-10T23:55:57Z",
    "closed_at": "2020-04-11T08:50:49Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/skypjack/entt/issues/460",
    "body": "Hi, \r\n  I was implementing a JsonRPC web-socket server based on entt::meta when I fell into this flaws (??):\r\npassing the parameter by reference (to be mutated) yields no change in the caller's instance.\r\n\r\nBecause I trust reproducibility is still a value, I've written a couple of unit tests which behaves differently, but should (??) be interchangeable in my opinion.\r\n\r\ng++ _Ubuntu 7.5.0-3ubuntu1~18.04_\r\n\r\n```\r\n#include <gtest/gtest.h>\r\n#include <entt/entt.hpp>\r\n\r\nstruct Base {\r\n    virtual ~Base() = 0;\r\n\r\n    static constexpr auto jsonrpc = \"2.0\";\r\n};\r\n\r\ninline Base::~Base() = default;\r\n\r\nstruct get_last_hour_data : public Base {\r\n    static get_last_hour_data create(std::string const &jsonValue);\r\n\r\n    [[nodiscard]] static bool exec(std::string &s);\r\n\r\n    [[nodiscard]] static bool exec_ptr(std::shared_ptr<std::string> &s);\r\n\r\nprivate:\r\n    [[nodiscard]] static bool init(std::string const &options);\r\n};\r\n\r\nget_last_hour_data get_last_hour_data::create(std::string const &jsonValue) {\r\n    get_last_hour_data glhd;\r\n    if(!get_last_hour_data::init(jsonValue)) {\r\n        return {};\r\n    }\r\n    return glhd;\r\n}\r\n\r\nbool get_last_hour_data::exec(std::string &s) {\r\n    s += \".\";\r\n    return true;\r\n}\r\n\r\nbool get_last_hour_data::exec_ptr(std::shared_ptr<std::string> &s) {\r\n    *s += \".\";\r\n    return false;\r\n}\r\n\r\nbool get_last_hour_data::init(std::string const &options) {\r\n    return true;\r\n}\r\n\r\nTEST(EnTTMeta, MutateByRef) {\r\n    entt::meta<get_last_hour_data>().alias(\"/getLastHourData\"_hs).template base<Base>().\r\n            template func<&get_last_hour_data::exec>(\"exec\"_hs).\r\n                                            template ctor<&get_last_hour_data::create>();\r\n    auto type = entt::resolve(\"/getLastHourData\"_hs);\r\n    assert (type);\r\n\r\n    auto func = type.func(\"exec\"_hs);\r\n    assert (func);\r\n\r\n    auto any = type.construct(std::string{});\r\n    assert (any);\r\n\r\n    std::string s;\r\n    auto any_2 = func.invoke(any, s);\r\n    assert (any_2);\r\n    ASSERT_EQ(\".\", s);\r\n}\r\n\r\nTEST(EnTTMeta, MutateBySharedPtrRef) {\r\n    entt::meta<get_last_hour_data>().template func<&get_last_hour_data::exec_ptr>(\"exec_ptr\"_hs);\r\n\r\n    auto type = entt::resolve(\"/getLastHourData\"_hs);\r\n    assert (type);\r\n\r\n\r\n    auto func = type.func(\"exec_ptr\"_hs);\r\n    assert (func);\r\n\r\n    auto any = type.construct(std::string{});\r\n    assert (any);\r\n\r\n    auto s = std::make_shared<std::string>();\r\n    auto any_2 = func.invoke(any, s);\r\n    assert (any_2);\r\n    ASSERT_EQ(\".\", *s);\r\n}\r\n```",
    "comments_url": "https://api.github.com/repos/skypjack/entt/issues/460/comments",
    "author": "stefanofiorentino",
    "comments": [
      {
        "user": "indianakernick",
        "created_at": "2020-04-11T00:20:59Z",
        "body": "Did you try invoking with a reference wrapper? (`std::ref`)"
      },
      {
        "user": "stefanofiorentino",
        "created_at": "2020-04-11T08:50:49Z",
        "body": "Gotcha! Thank you, I'll close the \"issue\"."
      },
      {
        "user": "skypjack",
        "created_at": "2020-04-11T08:58:43Z",
        "body": "Yeah, the doc for meta should be updated.\n\nThere are two ways to pass something by reference:\n* Using an `std::ref` if it's a plain variable.\n* By dereferencing it if it's in a `meta_any` (eg `*any`).\n\nIn other terms, you can always get modified the values in the outer context if you need it, no matter what. :+1:\nIt's up to the user to decide when to pass something by copy or by value at the call site."
      },
      {
        "user": "stefanofiorentino",
        "created_at": "2020-04-11T09:01:03Z",
        "body": "> you can always get modified the values in the outer context if you need it\r\n\r\nThis definitely makes sense. "
      }
    ]
  },
  {
    "number": 427,
    "title": "Unexpected behaviour when iterating a view",
    "created_at": "2020-02-25T06:42:58Z",
    "closed_at": "2020-02-25T08:05:16Z",
    "labels": [
      "invalid",
      "question"
    ],
    "url": "https://github.com/skypjack/entt/issues/427",
    "body": "Sorry if I'm massively misunderstanding here, but I'm getting some quite unexpected behaviour from running the following code (part of my test suite, but I've put together a Minimal Reproducible Example):\r\n\r\n```cpp\r\n#include <iostream>\r\n\r\n#include <entt/entt.hpp>\r\n\r\nstruct Parent\r\n{\r\n    unsigned int children = 0;\r\n    entt::entity first = entt::null;\r\n};\r\n\r\nstruct Child\r\n{\r\n    entt::entity parent = entt::null;\r\n    entt::entity next = entt::null;\r\n};\r\n\r\nint main()\r\n{\r\n    entt::registry registry;\r\n\r\n    const auto parent_entity = registry.create();\r\n    const auto child_entity_1 = registry.create();\r\n    const auto child_entity_2 = registry.create();\r\n\r\n    auto &parent_component = registry.assign<Parent>(parent_entity);\r\n    auto &child_component_1 = registry.assign<Child>(child_entity_1);\r\n    auto &child_component_2 = registry.assign<Child>(child_entity_2);\r\n\r\n    parent_component.children = 2;\r\n    parent_component.first = child_entity_1;\r\n\r\n    child_component_1.next = child_entity_2;\r\n    child_component_1.parent = parent_entity;\r\n    child_component_2.parent = parent_entity;\r\n\r\n    registry.view<Child>().each([&](const auto entity, const auto &child) {\r\n        if (!registry.valid(child.parent))\r\n        {\r\n            registry.destroy(entity);\r\n        }\r\n    });\r\n\r\n    std::cout << registry.valid(child_entity_1) << \"\\n\";\r\n    std::cout << registry.valid(child_entity_2) << \"\\n\";\r\n    std::cout << registry.valid(parent_entity) << \"\\n\";\r\n}\r\n```\r\n\r\nOutput:\r\n```\r\n1\r\n1\r\n0\r\n```\r\n\r\nDuring the `registry.view<Child>().each()` call, first `child_entity_1` is visited, but then `parent_entity` is visited (even though it doesn't have a `Child` component!). This results in `parent_entity` being destroyed. `child_entity_2` is never visited.\r\n\r\nAm I misunderstanding something concept here? I was under the impression that all the entities with a `Child` component should be visited, and since they all have a valid parent entity they shouldn't be destroyed.",
    "comments_url": "https://api.github.com/repos/skypjack/entt/issues/427/comments",
    "author": "Omegastick",
    "comments": [
      {
        "user": "skypjack",
        "created_at": "2020-02-25T07:45:20Z",
        "body": "You're doing a common mistake in C++, it has nothing to do with `EnTT`.\r\nImagine this:\r\n```\r\nstd::vector<int> vec{};\r\nauto &ref = vec.emplate_back(1);\r\nvec.emplate_back(2);\r\n```\r\nIs `ref` still valid after the last line? It's not guaranteed, it may be or may be not invalidated. This depends on the fact that the vector reallocated, thus invalidating the reference.\r\n\r\nYou've exactly the same issue here:\r\n```\r\nauto &child_component_1 = registry.assign<Child>(child_entity_1);\r\nauto &child_component_2 = registry.assign<Child>(child_entity_2);\r\n```\r\nIs `child_component_1` still valid after the second line? If it's not, then you've an UB when you modify it and this means that everything could happen.\r\nPools of components are just containers. They can reallocate as any other container.\r\n\r\nThe following version works as expected:\r\n```\r\nint main()\r\n{\r\n    entt::registry registry;\r\n\r\n    const auto parent_entity = registry.create();\r\n    const auto child_entity_1 = registry.create();\r\n    const auto child_entity_2 = registry.create();\r\n\r\n    registry.assign<Parent>(parent_entity, 2, child_entity_1);\r\n    registry.assign<Child>(child_entity_1, parent_entity, child_entity_2);\r\n    registry.assign<Child>(child_entity_2, parent_entity);\r\n\r\n    registry.view<Child>().each([&](const auto entity, const auto &child) {\r\n        if (!registry.valid(child.parent))\r\n        {\r\n            registry.destroy(entity);\r\n        }\r\n    });\r\n\r\n    std::cout << registry.valid(child_entity_1) << \"\\n\";\r\n    std::cout << registry.valid(child_entity_2) << \"\\n\";\r\n    std::cout << registry.valid(parent_entity) << \"\\n\";\r\n}\r\n```\r\n\r\nIf you don't want to pass arguments on construction, then:\r\n* Initialize your components before creating new ones to avoid using potentially dangling pointers.\r\n* Get (as in `registry::get<T>(entity)`) the component when you want to use it, so that you are guaranteed that the returned reference is a valid one."
      },
      {
        "user": "Omegastick",
        "created_at": "2020-02-25T08:05:16Z",
        "body": "Ah thanks, that's my bad then. Thanks a lot for the help. I had forgotten that the EnTT registry is basically a collection of vectors under the hood."
      },
      {
        "user": "skypjack",
        "created_at": "2020-02-25T08:10:44Z",
        "body": "Yup. It's a collection of pools and you can specialize them but at the end of the day all them are dynamic containers in a way or the other, so this issue is pretty common. :+1: "
      }
    ]
  },
  {
    "number": 387,
    "title": "In which cases would sorting a full-owning group cause an assertion to fail?",
    "created_at": "2020-01-10T17:52:34Z",
    "closed_at": "2020-01-11T00:58:07Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/skypjack/entt/issues/387",
    "body": "Apologies for so many tickets üôÉ \r\n\r\nI have a full-owning group of components called `global_transform_group` that holds a three-component tuple of components. I also have a nested group called `global_render_group` that has the same three components, along with an additional render-related component.\r\n\r\nWith any more than 1 entity belonging to those groups (0 works fine, too), I either get an assertion failure when calling `global_transform_group.sort()` or `false` when calling `global_transform_group.sortable()`.\r\n\r\nThe documentation seems to contradict itself:\r\n\r\n> Sorting owned components is no longer allowed once the group has been created. However, full-owning groups can be sorted by means of their sort member functions. Sorting a full-owning group affects all its instances.\r\n\r\nWhich, at least to me, starts by saying you cannot sort, but then goes on to say that full-owning groups _can_ sort, which leaves me a bit confused üòÖ \r\n\r\nSo, in which circumstances can I sort a full-owning group? Should I eliminate the nested group and just use a single full-owning group with all four components?\r\n\r\nIt's worth mentioning I'm using a custom sort function.",
    "comments_url": "https://api.github.com/repos/skypjack/entt/issues/387/comments",
    "author": "Qix-",
    "comments": [
      {
        "user": "skypjack",
        "created_at": "2020-01-10T21:21:32Z",
        "body": "When you use groups, you can sort only the most restrictive ones, that is the one with the higher number of rules.\r\nFrom your example:\r\n```\r\nauto global_transform_group = registry.group<A, B, C>();\r\nauto global_render_group = registry.group<A, B, C, D>();\r\n```\r\nThis is allowed, they are nested groups. In this case, `global_render_group` is more restrictive because it sets more constraints on the entities that want to enter it. Therefore, it will be fully contained within `global_transform_group` by construction.\r\nNow, consider what would happen if you sorted `global_transform_group`. Since it's _larger_ that `global_render_group`, the elements contained by the latter could be moved around and exit it during the sort. This isn't an option of course.\r\nWhat happens if you sort `global_render_group`? Since it's fully contained within `global_transform_group`, it doesn't matter how it's elements are arranged, they cannot exit the _outer_ group in any case.\r\nTherefore, it's allowed to sort `global_render_group` and this is the reason for which `global_render_group.sortable()` returns true while `global_transform_group` isn't sortable.\r\n\r\n---\r\n\r\nIf you want to sort both, you can't make all them full-owning group.\r\nThere doesn't exist an architecture that allows you to sort stuff and reaches the maximum performance at the same time. Long story short, this is because we need to arrange things in a specific way to get the best from the data and you cannot shuffle them for your purposes.\r\nIf sorting is more important than iterating 1M entities in 0.005ms rather 0.006ms (I guess so), you can define the two groups as partially owning ones in such a way that they don't overlap on owned components. In this case, both will be sortable."
      },
      {
        "user": "Qix-",
        "created_at": "2020-01-11T00:58:07Z",
        "body": "Right okay, that makes much more sense :D Thank you~!"
      }
    ]
  },
  {
    "number": 383,
    "title": "Is there a reason why you can't do single-component full-owning groups?",
    "created_at": "2020-01-04T04:09:36Z",
    "closed_at": "2020-01-04T20:07:10Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/skypjack/entt/issues/383",
    "body": "I have a group of components I'd like packed together and fully-owned via an `entt::group` but the API doesn't like that there's only one component in the `registry.group<component>()` template specifier.\r\n\r\nThis seems like a deliberate design decision, leading me to believe I'm missing something about groups.\r\n\r\nIs what I'm doing an anti-pattern for some reason?",
    "comments_url": "https://api.github.com/repos/skypjack/entt/issues/383/comments",
    "author": "Qix-",
    "comments": [
      {
        "user": "skypjack",
        "created_at": "2020-01-04T17:42:55Z",
        "body": "Uhm... I think you misunderstood how groups work. They are meant to arrange components from different pools in such a way that multi-component iterations are then linear, with no jumps nor branches (the so called _perfect SoA_).\r\nNot sure what you're trying to do but it seems to me it's something more on the line of - _I want to group the entities that have component `position` for which `x` is within 10 and 100_. Am I wrong? "
      },
      {
        "user": "Qix-",
        "created_at": "2020-01-04T19:18:59Z",
        "body": "No, I don't care about filtering based on the component's data.\r\n\r\nI have a particular component that is iterated over for _all_ entities (that have it) unconditionally, but is not paired with any other component at all. I want to make iterating over _all_ instances of that component as fast as possible, so I'd like it to be packed into its own list similar to how groups seem to do so.\r\n\r\nNow that I'm writing this, I'm realizing that this is probably the default way entt structures instances of components, anyway...\r\n\r\nAnyway, I guess the X-Y question is really: _how do I iterate over **all** instances of **a single** component in the most efficient way possible_? üòÖ "
      },
      {
        "user": "skypjack",
        "created_at": "2020-01-04T20:00:16Z",
        "body": "Well, in this case, a single component view is what you want. It iterates all instances at once with no jumps nor branches. :+1:\nIf you want even more performance and you don't plan to add or remove instances of the same component during iterations, you can also use the raw access (`data<T>`, `raw<T>` and `size<T>`) to iterate directly the internal arrays of entities and components for the given type.\nThis is the best you can expect overall, no matter what. You're iterating a plain array from 0 to N-1 in this case. :wink:"
      },
      {
        "user": "Qix-",
        "created_at": "2020-01-04T20:07:08Z",
        "body": "That's exactly the information I needed ^^\r\n\r\nThanks for a great library, it has really been a breeze to use. ‚ù§Ô∏è "
      },
      {
        "user": "skypjack",
        "created_at": "2020-01-04T20:09:35Z",
        "body": "Thank you for using it! I'm looking forward to having your project in the list of showcases. :wink:\nPlease, feel free to give me your feedback whenever you want. This is what helped to improve `EnTT` so far. :+1:"
      },
      {
        "user": "Qix-",
        "created_at": "2020-01-04T20:19:02Z",
        "body": "Absolutely, will do! :)"
      }
    ]
  },
  {
    "number": 369,
    "title": "Signature change question",
    "created_at": "2019-12-03T21:31:39Z",
    "closed_at": "2019-12-04T10:50:52Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/skypjack/entt/issues/369",
    "body": "Hi,\r\n\r\nThis is more of a \"how can I do this better\" question. I just went from 3.1.1 -> 3.2.1 and it went mostly smoothly with one exception, and I was hoping I could get some insight as to what is going on under the hood. The signature to some of my functions have changed, and I'm keen to know why. I've only been using cpp for a few months so excuse my ignorance. Is the `entt::exclude_t` required here?\r\n\r\n```cpp\r\n// 3.1.1\r\nglm::vec3 rule1(entt::basic_view<entt::entity, position, velocity, fish> &sortedFish, entt::entity &ourEntity) {\r\n    // do stuff\r\n}\r\n\r\n// 3.2.1\r\nglm::vec3 rule1(entt::basic_view<entt::entity, entt::exclude_t<>, position, velocity, fish> &sortedFish, entt::entity &ourEntity) {\r\n    // do stuff\r\n}\r\n```\r\n\r\nThanks!",
    "comments_url": "https://api.github.com/repos/skypjack/entt/issues/369/comments",
    "author": "arlyon",
    "comments": [
      {
        "user": "skypjack",
        "created_at": "2019-12-03T21:42:58Z",
        "body": "HI, v3.1.1 didn't have support for exclusion lists on views while v3.2.1 added it.\r\nIn other terms, you can now do this:\r\n```\r\nauto view = registry.view<A, B>(entt::exclude<C>);\r\n```\r\nThe view will return all entities that have both `A` and `B` but don't have `C`.\r\nThis is the reason for which that `entt::exclude_t<>` appeared in your signature.\r\n\r\nBecause you use `entt::entity`, you can use `entt::view` rather than `entt::basic_view` (see `fwd.hpp` for the forward declarations):\r\n```\r\nentt::view<entt::exclude_t<>, position, velocity, fish>\r\n```\r\n\r\nThere isn't much more you can do there. To support exclusion lists, the _types_ of the excluded components are required and thus part of the view type. Because of how parameter packs work in C++, we need to enclose one of them in a type list, in this case `entt::exclude_t`. This has the drawback that an empty type list is still required when no types are excluded.\r\n\r\nLet me know if it's not clear enough."
      },
      {
        "user": "arlyon",
        "created_at": "2019-12-04T10:50:52Z",
        "body": "Hey, thanks for the clear explanation. Must have missed that in the changelogs."
      },
      {
        "user": "skypjack",
        "created_at": "2019-12-04T10:53:37Z",
        "body": "Probably not as clear as it should be but it's part of the changelog for v3.2.0:\r\n>Views support exclusion lists (eg registry.view<T>(exclude<U>)).\r\n\r\nAnyway, you did the right thing by asking. :wink: "
      }
    ]
  },
  {
    "number": 334,
    "title": "Snapshot Loader Feature: Add auto update for entities stored in maps (key & value)",
    "created_at": "2019-10-13T12:44:15Z",
    "closed_at": "2019-10-16T21:45:36Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/skypjack/entt/issues/334",
    "body": "Right now, the update method in snapshot.hpp fails to handle std::map as an input type correctly. There is an implementation for containers though. I had a look, and it's possible to provide the same convenience for std::map/std::map-like types, too.\r\n\r\nI have implemented an extension for this update method and with your permission I could create a PR.",
    "comments_url": "https://api.github.com/repos/skypjack/entt/issues/334/comments",
    "author": "szunhammer",
    "comments": [
      {
        "user": "skypjack",
        "created_at": "2019-10-13T16:30:04Z",
        "body": "You don't need my permission to create a PR. You need my permission to merge it upstream though. :)\n\n---\n\nIf you plan to open a PR, I'll write here what I would write as a comment to the PR otherwise.\n\nPlease, submit only PRs that introduce both new code **and** some tests for it.  \nI won't accept a PR that either reduces the code coverage or that introduces new features without enough tests to guarantee backward compatibility.\n\nThank you for understanding and contributing. :+1: :wink:"
      }
    ]
  },
  {
    "number": 333,
    "title": "Question on approach/entity from component",
    "created_at": "2019-10-11T16:42:18Z",
    "closed_at": "2019-10-12T19:05:20Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/skypjack/entt/issues/333",
    "body": "I have a question as to approach - assume a component;\r\n```\r\nstruct Position\r\n{\r\nint x;\r\nint y;\r\nint x;\r\n}\r\n```\n\r\nAlso assume that I wish to spatially interact with this component - that is \"I want all components within Y distance from point (a,b,c)\".  This I can derive, for the sake of this question, from a r*tree.\r\n\r\nMy question, what is the best way to interact with the entities associated with the resultant component set?  Perhaps I am missing a means to obtain the entity ID from the component - unless I store that within the component (which seems an incorrect approach).  What I would like to do is use a visitor callback to fire an event associated with the entity (which is associated with the component).\r\n\r\nThank you in advance!\r\n\r\n\r\n\r\n\r\n\r\n",
    "comments_url": "https://api.github.com/repos/skypjack/entt/issues/333/comments",
    "author": "jasmt-us-dev",
    "comments": [
      {
        "user": "skypjack",
        "created_at": "2019-10-11T18:00:45Z",
        "body": "I'm not sure I get your problem but let's try to flip the problem on its head.\n\nAssume you use a quadtree or something similar for you spatial queries.  \nThe quadtree **must** contain your entity identifiers, **not** your references or pointers to components because the latter aren't guaranteed to be stable (for optimization purposes).  \n\nThis way you don't have anymore the problem of getting the entity from a component because you're going the other way around. You get the components from their entities and you've always both of them at hand.\n\nDoes it make sense to you?"
      },
      {
        "user": "jasmt-us-dev",
        "created_at": "2019-10-11T19:45:12Z",
        "body": "I had considered this upfront, but what swayed me away was not knowing the components pointer could change.  This would have reduced the overhead of the tree and was trying to approach it from there.  Good thing I asked ;)\r\n\r\nThe other concern I had was the need to reference the entity identifier for each operation within the tree - this I will have to spend a bit more time thinking about.\r\n\r\nThank you!"
      },
      {
        "user": "skypjack",
        "created_at": "2019-10-12T07:28:23Z",
        "body": "I plan to introduce a few alternative pools in future, one for stable pointers to components. It's useful when you make `EnTT` work with other tools UE4 apparently. However, they aren't available out of the box yet (you can implement custom pools by specialization the `storage` class though).\n\nIf I were you, I'd store copies of entities in my tree. There is also a function in the registry to know if an entity identifier is still valid of if the entity has been recycled in the meantime (`registry::valid`).\n\n>The other concern I had was the need to reference the entity identifier for each operation within the tree\n\nI'm not sure what you mean with this. I also invite you to join the gitter channel if you want to talk with me and other devs about how to address your doubts. :+1:\nSee the badges in the README file for the links."
      },
      {
        "user": "skypjack",
        "created_at": "2019-10-12T19:05:02Z",
        "body": "I'm closing this as _question_. I hope you got a proper answer. Feel free to reopen the issue and add more comments if it's not the case. :+1:"
      }
    ]
  },
  {
    "number": 304,
    "title": "Iterate over subclasses?",
    "created_at": "2019-08-31T13:33:03Z",
    "closed_at": "2019-08-31T22:31:14Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/skypjack/entt/issues/304",
    "body": "Would it be possible to without naming each subclass, to iterate over the inherited variables or call the overridden functions?\r\n\r\nFor example:\r\n\r\n```\r\n#include <iostream>\r\n#include \"entt/entt.hpp\"\r\n\r\nclass MainClass{\r\n    public:\r\n    int z = 0;\r\n    virtual void f() = 0;\r\n};\r\n\r\nclass SubClassType1 : public MainClass{\r\n    public:\r\n    int y = 1;\r\n    void f() override {\r\n        std::cout << \"Called SubClassType1 virtual function and z+y= \" << z+y;\r\n    }\r\n};\r\n\r\nclass SubClassType2 : public MainClass{\r\n    public:\r\n    int x = 2;\r\n    void f() override {\r\n        std::cout << \"Called SubClassType2 virtual function and x+z= \" << z+x;\r\n    }\r\n};\r\n\r\nint main()\r\n{\r\n   entt::registry Registry;\r\n   Registry.assign<SubClassType1>(Registry.create());\r\n   Registry.assign<SubClassType2>(Registry.create());\r\n   //   Registry.assign<SubClassTypeX>(Registry.create());\r\n   // Pseudo code: \r\n   Registry.view<MainClass>().each([](MainClass aMainClass) {\r\n    aMainClass.f();\r\n    });\r\n    return 0;\r\n}\r\n```\r\n\r\n",
    "comments_url": "https://api.github.com/repos/skypjack/entt/issues/304/comments",
    "author": "codecnotsupported",
    "comments": [
      {
        "user": "skypjack",
        "created_at": "2019-08-31T14:04:11Z",
        "body": "Indeed no. ECS is mostly about getting rid of hierarchies in the simulation, it wouldn't make sense to allow this and I don't even know how it can be done to be honest. However, there are plenty of techniques to obtain exactly the same result by means of the components."
      },
      {
        "user": "codecnotsupported",
        "created_at": "2019-08-31T14:07:22Z",
        "body": "I kind of was expecting that, so how would it be implemented by the means of components?"
      },
      {
        "user": "skypjack",
        "created_at": "2019-08-31T21:58:01Z",
        "body": "Well, the idiomatic _ECS way_ would be to put your logic in separate systems and use different components to trigger different behaviors.  \nAlternatively, you can use type erasure, pointers to functions and eventually decayed lambdas to store the behavior directly on your components, so as to have only one system that runs this opaque functions (static polymorphism instead of runtime polymorphism).  \nAnother option I wouldn't recommend but that could work is using a variant.  \nYet another approach is to store in your components opaque pointers and meta types, then use the latter to work with the former.\n\nAnd so on. There are several approaches to get there.  \nI'm not a fan of putting the logic in the components though and I'd recommend to use different types and multiple systems here.\n\nThat said, as far as I know it could also be an XY-problem.  \nIt's hard to say what's the best solution for your case without knowing the details of the problem you're trying to solve.  \nIf you feel like discussing with other users, try to join the gitter channel and drop your questions there. :wink:"
      },
      {
        "user": "codecnotsupported",
        "created_at": "2019-08-31T22:31:14Z",
        "body": "Sounds like it's now a project specific design issue. (In my case: trying to combine ImGui & EnTT)\r\nWell, I got my answer, closing issue. (I'll probably discuss it on gitter later like you suggested)\r\nThanks."
      },
      {
        "user": "skypjack",
        "created_at": "2019-09-01T08:05:18Z",
        "body": "You're welcome. I want to let you know that there is online an example of integration between ImGui and EnTT. I think the link is also in the wiki. It may be of inspiration probably. :+1:"
      }
    ]
  },
  {
    "number": 240,
    "title": "Exclude created entities from views and groups",
    "created_at": "2019-05-03T17:22:22Z",
    "closed_at": "2019-05-05T13:53:29Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/skypjack/entt/issues/240",
    "body": "Hi,\r\n\r\nThank you for the library, its very useful!\r\n\r\nI wanted to ask if there's a direct way to **create entities that are ignored by views and groups**.\r\n\r\nThe reason is no other that I want entities to be able to be **created during tick**, but at the same time want them to **wait one frame until they start ticking** on my systems. (Systems usually depend on the previous ones, and it wouldn't be a good idea to start at half the process).\r\n\r\nI \"could\" do a cache registry for all entities that get created during tick but it doesn't seem like the right solution\r\n\r\nThanks!\r\nmuit",
    "comments_url": "https://api.github.com/repos/skypjack/entt/issues/240/comments",
    "author": "muit",
    "comments": [
      {
        "user": "skypjack",
        "created_at": "2019-05-03T20:30:12Z",
        "body": "Hi, I'm glad you're using `EnTT`.\r\n\r\nThere are multiple ways to do what you're asking for. I wouldn't call one of them _the right solution_ though.  \r\nYou can use a side registry, of course. Otherwise you can create a queue of delayed operations to run at the end of your tick. Another approach I've used is to spawn components that are literally _requests to spawn_, then run a system at the end of the loop that uses them (this is nothing more than a built-in version of the queue of delayed operations). You can also spawn entities and attach them a component used then in an exclusion list, with a system that just resets those components at the end of the tick. And so on...\r\n\r\nI kindly invite you to join the gitter chat if you've questions like this one. There are smart people there that can give you answers based on their experiences."
      },
      {
        "user": "skypjack",
        "created_at": "2019-05-05T13:53:29Z",
        "body": "I'm closing this for inactivity. Feel free to reopen the issue if required."
      },
      {
        "user": "muit",
        "created_at": "2019-05-05T16:05:17Z",
        "body": "Hi!\r\nThank you for answering me and sorry my delayed response.\r\n\r\nThose options are very interesting. I already use an entity component just for super basic entity information so I could add a flag there. My worry is that views (or in the future groups) will iterate over them anyway, and I don't want to add a check for each iteration to see if the flag is set.\r\n\r\nAbout gitter, sounds interesting, I may join is a few days when I get some more time!\r\n\r\nThanks"
      },
      {
        "user": "skypjack",
        "created_at": "2019-05-05T16:16:24Z",
        "body": "Groups have exclusion lists. Use a component to exclude newly created entities from groups and reset it at the end of the loop. No `if` there."
      },
      {
        "user": "muit",
        "created_at": "2019-05-05T17:15:26Z",
        "body": "Perfect, and thanks!"
      }
    ]
  },
  {
    "number": 239,
    "title": "Polymorphic components?",
    "created_at": "2019-05-02T06:44:11Z",
    "closed_at": "2019-05-02T07:17:02Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/skypjack/entt/issues/239",
    "body": "Is there a way to have polymorphic components, where a component can do something like:\r\n```cpp\r\nstruct behaviour {\r\n  virtual void print() {}\r\n};\r\n\r\nstruct printer: public behaviour {\r\n  void print() override {\r\n    // Perform print action.\r\n  }\r\n};\r\n\r\n// Later...\r\nentt::registry registrar;\r\nentt::entity e0 = registrar.create();\r\nregistrar.assign<printer>(e0);\r\n\r\n// Even later...\r\nregistrar.view<behaviour>().each([](auto& component) {\r\n  component.print();\r\n});\r\n```\r\n\r\nI've tried this and it didn't work, and after reading the docs I'm not sure what the correct way to do this would be. I could use a bit of guidance to making this work. And I believe I understand why it doesn't work but I'd appreciate it if you could also explain why it doesn't.",
    "comments_url": "https://api.github.com/repos/skypjack/entt/issues/239/comments",
    "author": "SoraKatadzuma",
    "comments": [
      {
        "user": "indianakernick",
        "created_at": "2019-05-02T06:45:51Z",
        "body": "You could use `std::unique_ptr<behaviour>` but polymorphism in a \"pure\" ECS architecture is done a bit differently.\r\n\r\n```C++\r\n// components\r\nstruct printer {};\r\nstruct other_printer {};\r\n// other classes that used to derive from behaviour...\r\n\r\n// systems\r\nvoid printer_print(entt::registry &registrar) {\r\n  registrar.view<printer>().each(auto& component) {\r\n    // Perform print action with printer\r\n  });\r\n}\r\nvoid other_printer_print(entt::registry &registrar) {\r\n  registrar.view<other_printer>().each(auto& component) {\r\n    // Perform print action with other_printer\r\n  });\r\n}\r\n\r\n// setup\r\nentt::registry registrar;\r\nentt::entity e0 = registrar.create();\r\nregistrar.assign<printer>(e0);\r\nentt::entity e1 = registrar.create();\r\nregistrar.assign<other_printer>(e1);\r\n\r\n// game loop\r\nwhile (true) {\r\n  printer_print(registrar);\r\n  other_printer_print(registrar);\r\n}\r\n```\r\n\r\nThis is considerably faster because all of the `printer`s are processed together then all of the `other_printer`s are processed together.\r\n\r\nEnTT doesn't force you to write code in a specific way but it might be easier to you stick to a \"pure\" approach."
      },
      {
        "user": "SoraKatadzuma",
        "created_at": "2019-05-02T06:57:39Z",
        "body": "I see, yes the `unique_ptr` approach worked nicely. I need polymorphism as described in my issue, because I plan to do scripting similar to Unity, where I need virtual functions that which can be overridden. But I thank you for your help üëç "
      },
      {
        "user": "skypjack",
        "created_at": "2019-05-02T07:01:14Z",
        "body": "You can also use a single component and rely on type erasure techniques by mixing non-capturing lambdas and pointers to functions. More or less on the line of the _OOP in C_ book.  \r\nThis way you've **only** `behavior` as a component but different `print`s for different instances."
      },
      {
        "user": "SoraKatadzuma",
        "created_at": "2019-05-02T07:06:51Z",
        "body": "Mkay, I'll take that into consideration. It'll probably be an optimization later if it works into my design.\r\nThank you again for your help üòÑ "
      },
      {
        "user": "skypjack",
        "created_at": "2019-05-02T07:14:28Z",
        "body": "You're welcome. Please, close the issue if you received a proper answer. :+1:  \r\nAlso, I invite you to join the gitter channel if you have other questions. There are smart people there that can help you."
      },
      {
        "user": "SoraKatadzuma",
        "created_at": "2019-05-02T07:17:33Z",
        "body": "Ah that'd be great!"
      }
    ]
  },
  {
    "number": 222,
    "title": "3.0 status? safe to use for new project?",
    "created_at": "2019-04-21T21:00:17Z",
    "closed_at": "2019-05-16T14:18:11Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/skypjack/entt/issues/222",
    "body": "I want to use entt for my hobby project. How safe is to use latest v3 version, or how many breaking api changes are planned etc? Or is there known broken things in current v3 version. I don't mind doing small refactoring as I and entt advance, but I  also don't want to waste to much time unnecessarily if using v2 and migrating after v3 release is easier.\r\n\r\nThanks in advance :)",
    "comments_url": "https://api.github.com/repos/skypjack/entt/issues/222/comments",
    "author": "Deins",
    "comments": [
      {
        "user": "skypjack",
        "created_at": "2019-04-21T21:32:48Z",
        "body": "I'm glad you decided to use `EnTT`. If your project is going to be an open source one, ping me to put it in the wiki when _ready_. :+1:  \r\nFeel free also to join the gitter channel if you have questions or want to discuss your doubts with other users.\r\n\r\nOf course, `master` is stable and there aren't breaking changes planned so far. In any case, I'll change the major and/or minor version if they should come. In general and as a side note, I prefer to change the major version of my projects when I switch to a new revision of the standard or when I drastically change the internals and the API. For (let me say) _small_ braking changes, it's likely that I'll change the minor version and document them in details.  \r\n\r\n`EnTT` is actually ready to cut a `v3`. Please, keep open the issue so that it will remind me to do that the next week. :+1: "
      },
      {
        "user": "Milerius",
        "created_at": "2019-04-24T10:03:36Z",
        "body": "Don't forget to update the Conan package at the same time @skypjack "
      },
      {
        "user": "skypjack",
        "created_at": "2019-04-24T10:22:46Z",
        "body": "Good point @Milerius updated the test file for conan. :+1: "
      },
      {
        "user": "skypjack",
        "created_at": "2019-04-25T13:24:37Z",
        "body": "I'm writing the release note for `EnTT` v3. It's... huge!  \r\nI'll publish it most likely when I'm back home on May, the 2nd. :+1: "
      },
      {
        "user": "Milerius",
        "created_at": "2019-04-25T13:25:48Z",
        "body": "Glad to hear"
      },
      {
        "user": "skypjack",
        "created_at": "2019-05-16T14:18:11Z",
        "body": "Created tag `v3.0.0`. :+1: "
      }
    ]
  },
  {
    "number": 198,
    "title": "idiomatic way to do entity related events and entity id specific listeners.",
    "created_at": "2019-03-07T13:26:44Z",
    "closed_at": "2019-03-07T14:34:22Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/skypjack/entt/issues/198",
    "body": "Is the use case of listening for events specifically related to an entity id and/or listen for an event that is intented to be called with  at least an entity id as payload so widely common and \"generic\" to justify a proper api or there is just a clear idiomatic way to do it with the provided api?\r\nThis because I us to work this way in other systems and I  still have to check if the api may support this elegantly or may require some additional feature or syntactic sugar.",
    "comments_url": "https://api.github.com/repos/skypjack/entt/issues/198/comments",
    "author": "Paolo-Oliverio",
    "comments": [
      {
        "user": "skypjack",
        "created_at": "2019-03-07T13:46:56Z",
        "body": ">Is the use case of listening for events specifically related to an entity id and/or listen for an event that is intented to be called with at least an entity id as payload so widely common and \"generic\" to justify a proper api or there is just a clear idiomatic way to do it with the provided api?\r\n\r\nSignals on a per-entity basis aren't a good idea from my point of view. It would mean either to have thousands of signal handlers (one per entity) or to wrap all the listeners in a function that literally _adds an `if`_ to filter events (and to ruin performance as a side effect).  \r\nSimilarly, application specific events (like the ones _with an entity as a payload_) should not find their ways into the registry for obvious reasons.\r\n\r\nI see you need custom _things_ for your application and you want them to be part of the registry, but you should rather extend the latter if needed."
      },
      {
        "user": "Paolo-Oliverio",
        "created_at": "2019-03-07T21:33:06Z",
        "body": "Amazon Lumberyard has this concept of ebus channels I got used to and while I agree with you on paper I find them quite convenient in practice.Of course you get easily hundreds of handlers but in the end the profiler doesn't care so much. However it doesn't manage so many entities due to other factors so I cannot say how much extensive channel usage scales per se."
      },
      {
        "user": "skypjack",
        "created_at": "2019-03-07T21:46:17Z",
        "body": "How does it work? Do you register listeners on _entities_? I've never used Lumberyard, sorry."
      },
      {
        "user": "Paolo-Oliverio",
        "created_at": "2019-03-07T21:58:16Z",
        "body": "It is component entity indeed so you have component code signal and handle you listen on specific channels of template type mostly entity type. However on a further analysis I can map most of my workflow if not all to actual API and in most cases be more efficient too."
      },
      {
        "user": "skypjack",
        "created_at": "2019-03-07T22:00:34Z",
        "body": "I'm curious because I've never had the need of listening for specific entities. I can be interested in the couple `(component, entity)` either constructed or destroyed, that is what the registry makes available. However, I cannot figure out the use case for the entity only."
      }
    ]
  },
  {
    "number": 187,
    "title": "Why is it bad to store a view? ",
    "created_at": "2019-02-19T20:23:28Z",
    "closed_at": "2019-02-19T21:21:01Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/skypjack/entt/issues/187",
    "body": "Hi,\r\n\r\nI want to ask you for a clarification about views. It's mentioned in the code documentation \r\n\r\n> As a rule of thumb, storing a view should never be an option.\r\n\r\nHowever, the main documentation states that:\r\n\r\n> Views and Groups\r\n> [...]\r\n> Briefly, they are a good tool to enforce single responsibility. A system that has access to a registry can create and destroy entities, as well as assign and remove components. On the other side, a system that has access to a view or a group can only iterate entities and their components, then read or update the data members of the latter. \r\n\r\nHow a system can have access to a view and only a view if it can't store it? Also why shouldn't I store a view? The documentation only mentions that creating a view is quick and cheap but not why storing a view is bad.\r\n\r\nI see solutions but they are less obvious than just storing an instance of a view.\r\n\r\nTo give a better context, let's imagine an `AudioSystem` in an entity-based environment. I don't want that system to be able to create/remove entities. If I can't store a view, the right solution is to pass a lambda (e.g. `[&registry] { return registry.view<CanProduceSound>(); }` over a view (e.g. `entt::view<CanProduceSound>&&`)?\r\n\r\nThanks.\r\n\r\n",
    "comments_url": "https://api.github.com/repos/skypjack/entt/issues/187/comments",
    "author": "Dimrok",
    "comments": [
      {
        "user": "skypjack",
        "created_at": "2019-02-19T21:06:25Z",
        "body": ">How a system can have access to a view and only a view if it can't store it?\r\n\r\nHow can a system have access to a view to store aside? A system can receive the view as a parameter of an hypothetical `update` function, as well as an argument to the constructor. No need to ask for the registry.\r\n\r\n>The documentation only mentions that creating a view is quick and cheap but not why storing a view is bad.\r\n\r\nFor what concerns runtime views, the documentation says (emphasis mine):\r\n\r\n>Runtime view are extremely cheap to construct and should not be stored around in any case. They should be used immediately after creation and then they should be thrown away. **The reasons for this go far beyond the scope of this document**.\r\n\r\nShortly, it could happen that the underlying data structures required for the view don't exist yet when a registry generates the view itself. Because of that, the view is somehow _broken_ and will behave as if it's empty at each invocation. There is no way to literally _fix it_ once the ownership is transferred. Therefore, all what you can do is to throw it away.  \r\nOf course, there is a workaround for that (not mentioned in the documentation). Moreover, runtime views are beasts rarely used and in different contexts.\r\n\r\nFrom what concerns compile-time views, the current implementation allows you to store them aside actually. However, I cannot guarantee they won't bind to (let me say) _unstable_ underlying data structures of the registry in future (mainly things that can move around and thus invalidate pointers). It's unlikely to happen to be honest, but who knows?  \r\nBecause of that, mine is an advice for as _safe use_ of a view now and forever, but feel free to not follow it. Most likely you'll never ever have problems, don't worry.\r\n\r\n---\r\n\r\nThat being said, I invite you to join the gitter channel if you have other questions like this one. There are smart developers that can really help you there. Also, don't forget to star the project if you like and use it. I hope it fits with your requirements.\r\n\r\nIf you received your answer, please close the issue. Otherwise feel free to continue the discussion."
      },
      {
        "user": "indianakernick",
        "created_at": "2019-02-19T21:06:35Z",
        "body": "Conceptually, a system is just behavior so I declare systems like this:\r\n\r\n```\r\nvoid playSounds(entt::registry &reg, AudioContext &ctx) {\r\n  // Create a view, iterate CanProduceSound components, play sounds\r\n}\r\n```\r\n\r\nThat's my two cents. It doesn't really answer your question though!"
      },
      {
        "user": "skypjack",
        "created_at": "2019-02-19T21:09:05Z",
        "body": "Yeah @Kerndog73 I use to have free functions as systems too. However, sometimes they ask directly for a view as a parameter and I submit the registry through the `as_view` utility to satisfy the requirement. This way I'm guaranteed that the system won't create entities and components any time soon."
      },
      {
        "user": "indianakernick",
        "created_at": "2019-02-19T21:14:42Z",
        "body": "@skypjack Oh, using `as_view` seems like a really smart idea. You can avoid having to type out the list of components in the calling code. Genius! Although, you still have the component list in two places (header and implementation).\r\n\r\nI like the idea of ensuring that a system can only iterate components but I'm not really a fan of enforcing **which** particular components can be iterated."
      },
      {
        "user": "Dimrok",
        "created_at": "2019-02-19T21:21:01Z",
        "body": "Thanks for both your answers, I was too focus on having my hypothetical system to own the view but I can certainly pass it when needed (or use a free function).\r\n\r\n> That being said, I invite you to join the gitter channel\r\n\r\nI was looking for a Slack or a gitter but it wasn't mentioned in the README. I should have look by myself. \r\n\r\n> If you received your answer, please close the issue. Otherwise feel free to continue the discussion.\r\n\r\nAnswer received, sir! "
      },
      {
        "user": "skypjack",
        "created_at": "2019-02-19T21:35:04Z",
        "body": ">I was looking for a Slack or a gitter but it wasn't mentioned in the README. I should have look by myself.\r\n\r\nOh, I'm sorry. There is the gitter badge on the top of the readme file but probably people don't see it. You're just confirming this. I'll add a dedicated section to mention the channels to use to contact me. Thanks for pointing it out. :+1: "
      }
    ]
  },
  {
    "number": 164,
    "title": "Get Owner of Component",
    "created_at": "2018-12-05T09:56:47Z",
    "closed_at": "2018-12-05T14:34:24Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/skypjack/entt/issues/164",
    "body": "Assuming that I only have a reference to a component available, would there be any way for that component to get the entity it belongs to, and through that access other components? The best solution I've come up with so far is iterating all entities with the component until the one I want appears, but perhaps I've overlooked a better way of doing this that already exists. Couldn't find anything in the wiki or in other issues.\r\n\r\n```C++\r\ntemplate<typename ComponentType>\r\nuint32_t getOwner(const ComponentType& component)\r\n{   \r\n    auto view = registry.view<ComponentType>();\r\n    for (auto e : view)\r\n    {\r\n        if (&view.get(e) == &component)\r\n        {\r\n            return e;\r\n        }\r\n    }\r\n\r\n    /* It should never come here as all components logically should have an owner */\r\n    return entt::null;\r\n}\r\n```\r\nI'm not sure if this is something you want to have as a part of the library at all, but I had a use for it, so thought I'd ask! Thanks a lot for your great work!",
    "comments_url": "https://api.github.com/repos/skypjack/entt/issues/164/comments",
    "author": "carlfindahl",
    "comments": [
      {
        "user": "indianakernick",
        "created_at": "2018-12-05T10:10:20Z",
        "body": "There is no mapping from the component to the entity ID. If you only have the address of the component you're looking for, the only way to get the entity ID is to iterate.\r\n\r\nHowever, it is recommended that instead of holding onto component references, you hold onto entity IDs. There is a fast mapping from entity ID to component.\r\n\r\n```C++\r\ninstances[reverse[entity & traits_type::entity_mask]]\r\n```\r\n\r\nA bitwise `&` and two array lookups. It's fast! Holding onto a reference to the component isn't much faster than storing the entity ID.\r\n\r\nHolding onto a reference means that you run the risk of having a dangling reference. When you assign a component to an entity, a `std::vector` will be resized and potentially reallocated, leaving you with a dangling reference. An entity ID doesn't suffer from this problem."
      },
      {
        "user": "skypjack",
        "created_at": "2018-12-05T12:01:26Z",
        "body": ">would there be any way for that component to get the entity it belongs to, and through that access other components?\n\nThere is a trick to do that actually but 1) you didn't star the project, so I won't tell you :smile: 2) @Kerndog73 pointed out the right problem.\n\n>Assuming that I only have a reference to a component available\n\nYou should never ever store aside references or pointers to components, they aren't guaranteed to be consistent in time. Use entity identifiers instead.  \nKeep in mind that `EnTT` does reallocate elements in the pools when needed in order to give you fast iterations and some nice-to-have features like a pointer to a packed array of components.\n\n>I'm not sure if this is something you want to have as a part of the library at all, but I had a use for it\n\nBefore to tell you how to do that, may I ask you what's your use case?"
      },
      {
        "user": "carlfindahl",
        "created_at": "2018-12-05T14:12:48Z",
        "body": ">  1) you didn't star the project, so I won't tell you\r\n\r\nWell I fixed that, as this definitely deserves one!\r\n\r\nStoring the entity ID seems like the better options now that it has been pointed out. @Kerndog73 is `instances` and `entity_mask` part of the library? \r\n\r\n> Before to tell you how to do that, may I ask you what's your use case?\r\n\r\nAll right, at the moment some of my components have some member-functions (they are all structs), but I use member functions to bind functionality to LUA, so anyone scripting can't change just anything on components. And some of those functions trigger events that  contain data about which entity fired it, which is the reason I had to find a way to get the entity from within a component. This is my first project using a proper ECS, so it might not be perfectly idiomatic, but it gets the job done. Within C++ I just access members directly, and it's a non-issue.\r\n\r\nThank you very much for swift replies and some great tips on how to better use the library!"
      },
      {
        "user": "skypjack",
        "created_at": "2018-12-05T14:34:24Z",
        "body": "You're welcome!! Feel free also to join us on gitter if you want to discuss your doubts with other users.  \r\nI confirm that I'd use the entity identifier if I was you, because you don't know if the component is going to be moved during its lifetime.  \r\nMoreover, identifiers contain a version and you can test them at any time to know if they are still valid or have been destroyed/recycled in the meantime. :+1: \r\n\r\nI'm closing the issue as invalid. Feel free to reopen it if you think you didn't get a proper answer.\r\n\r\nEnjoy `EnTT`. :+1: "
      }
    ]
  },
  {
    "number": 136,
    "title": "Proper use of Continuous Loader for client-server sync",
    "created_at": "2018-09-02T13:39:09Z",
    "closed_at": "2018-09-03T10:43:27Z",
    "labels": [
      "question",
      "discussion"
    ],
    "url": "https://github.com/skypjack/entt/issues/136",
    "body": "Hey, \r\nThis has been my design:\r\n1) When a client connects send the full snapshot of the registry using a call to snapshot() with appropriate list of components\r\n```\r\nentt::DefaultRegistry registry;\r\n\r\ntemplate<class Archive, class ...ArchiveComponents>\r\nvoid snapshot(Archive &archive) {\r\n    registry.snapshot().entities(archive).template component<ArchiveComponents...>(archive);\r\n}\r\n```\r\nand on the client side restore the registry with the same list of components using a ContinuousLoader:\r\n```\r\nentt::DefaultRegistry registry;\r\nentt::ContinuousLoader<entt::DefaultRegistry::entity_type> loader(registry);\r\n\r\ntemplate<class Archive, class... ArchiveComponents>\r\nvoid restore(Archive &archive) {\r\n    loader.entities(archive).template component<ArchiveComponents...>(archive);\r\n}\r\n```\r\n\r\n2) Every server tick whenever components are updated tag those entities with an empty component that\r\nsignals the need for sync:\r\n```\r\nstruct NeedsSync{};\r\nregistry.accommodate<NeedsSync>(entity);\r\n```\r\nand later send those to the client by taking snapshot of the components for any entity that has been updated:\r\n```\r\ntemplate<class Archive, class ...ArchiveComponents>\r\nvoid snapshotDelta(Archive &archive) {\r\n  auto view = registry.view<components::NeedsSync>();\r\n  if (!view.empty()) {\r\n    registry.snapshot().template component<ArchiveComponents...>(archive, view.cbegin(), view.cend());\r\n  }\r\n}\r\n```\r\nafter the send remove the component:\r\n```\r\nregistry.reset<NeedsSync>();\r\n```\r\nand on the client restore them with the same list of components as the server\r\n```\r\ntemplate<class Archive, class... ArchiveComponents, class... Type, class... Member>\r\nvoid restoreDelta(Archive &archive, Member Type::*... member) {\r\n  loader.template component<ArchiveComponents...>(archive, member...).orphans().shrink(); \r\n}\r\n```\r\n\r\nThe problem is that restoreDelta() kills any entity that is not in the delta snapshot. I feel\r\nI am doing something fundamentally wrong, what would be the correct way to do this?\r\n",
    "comments_url": "https://api.github.com/repos/skypjack/entt/issues/136/comments",
    "author": "sina-",
    "comments": [
      {
        "user": "skypjack",
        "created_at": "2018-09-02T15:34:50Z",
        "body": "Not sure I got what you're doing (I'm out of home, I read this from mobile), but it looks like you're doing something wrong in your second bullet.\n\nYou should either send also the set of living entities each tick or avoid to invoke `shrink` client side.  \nThe idea behind the loader is that you send a full snapshot each time and therefore you can shrink entities that no longer have a counterpart. However, it seems to me that this isn't your case. You send only parts of the entities each time (but the first one) and the loader cannot know the others are still alive."
      },
      {
        "user": "sina-",
        "created_at": "2018-09-02T16:54:56Z",
        "body": "I get the same result even without `shrink`. Sending full snapshot every tick is quite expensive. How would that actually work? My thinking is that I should sent full snapshot once and every tick I just send the delta, things that have changed in the registry, to reduce the amount of data sent over network. "
      },
      {
        "user": "skypjack",
        "created_at": "2018-09-02T17:29:52Z",
        "body": "Oh, I see. The continuous loader resets the components locally before to load the new set. The reason is the same above mentioned: it's meant to satisfy different usage patterns than your.  \nOn the other side, you're not sending all the instances of a given component C each tick, right? It won't work any time soon this way without changes, I'm sorry."
      },
      {
        "user": "sina-",
        "created_at": "2018-09-02T18:03:12Z",
        "body": "Perhaps that's what I'm doing wrong, or understood wrong. I'm trying to avoid sending all the instances of a component, and only send the ones that have changed. Lets look at it from a different angle, since this library is meant to be used in a game engine, how would you sync the registries in a client and server? \r\nWon't you use the snapshot? How would you restore that snapshot client side?"
      },
      {
        "user": "skypjack",
        "created_at": "2018-09-02T19:24:30Z",
        "body": "> I'm trying to avoid sending all the instances of a component, and only send the ones that have changed.\n\nYeah, I got it.  \nThe other problem around is: how would you tell to the receiver that a component no longer exists? You cannot the way you described, but you can do it by sending the entire sets (the loader deduces everything from that).  \nThat's why I'm saying that probably this isn't your use case, because from what you said it seems that you never drop components server side (at least the ones shared with your clients).\n\n> Won't you use the snapshot?\n\nTo be honest, I used snapshot, but I won't use it anymore probably. That's because of some new features on which I'm working that will _replace it_ (more or less, they have several use cases and it happens that they also replace it).\n\n> How would you restore that snapshot client side?\n\nA _partial snapshot_? I think there is no way to do that currently. However I should look into the code to confirm it because I wrote that part a lot of time ago and I forgot almost everything so far."
      },
      {
        "user": "sina-",
        "created_at": "2018-09-02T22:06:54Z",
        "body": "Well if I send the entire snapshot, then why would I use ContinuousLoader? Why not just do a `registry.reset()` and then `registry.restore()` the entire thing?"
      },
      {
        "user": "skypjack",
        "created_at": "2018-09-02T22:09:49Z",
        "body": "No, wait, I mean a single component anyway. The entire set for a single component, not for the whole registry. Sorry if it wasn't clear."
      },
      {
        "user": "skypjack",
        "created_at": "2018-09-03T06:11:39Z",
        "body": "Btw, if the question was _can I do it without snapshot_? The answer is _more or less, yes_.  \nSnapshot stuff was created initially to generate full snapshots of a registry (ie up to destroyed entities, that is something you cannot know otherwise). Moreover, it's meant to reconstruct something by keeping intact entity identifiers and versions, again something you cannot do easily otherwise. But it has drawbacks, first of all the fact that it moves around entire sets (that was fine for the sole snapshot loader but I see it could be annoying with the continuous loader).\n\nIf you aren't interested in this kind of things, snapshot is not the tool to use. As I said, I'm going to deprecate it anyway because I want to replace it with much powerful tools, so don't expect changes on that part but for bug fixing.\n\nHere the options are:\n\n* I stick to the usage pattern of snapshot and use it.\n* I don't want to follow its rules, I can export things and send them to a client anyway somehow.\n* New cool stuff? Interesting, I'll wait for that, I'm not in a rush."
      },
      {
        "user": "vblanco20-1",
        "created_at": "2018-09-03T08:28:09Z",
        "body": "Given that its on the topic, is it logical to use snapshot to copy all the state of a few components you care about into another registry? I was looking to pipeline my game engine and i got everything but a way to separate the state of the game update vs the render update (need to copy all the render related components to a new registry)"
      },
      {
        "user": "skypjack",
        "created_at": "2018-09-03T08:33:13Z",
        "body": "> is it logical to use snapshot to copy all the state of a few components you care about into another registry?\r\n\r\n@vblanco20-1 More than calling it _logical_, I'd say that it could work. :smile: "
      },
      {
        "user": "sina-",
        "created_at": "2018-09-03T10:17:32Z",
        "body": "@skypjack thanks a lot for the help and clarification. Yeah it seems I can't really use snapshots for client-server sync as it is now without trying to work around it. Although without doing a `shrink` my solution should have worked, but for some reason it didn't, maybe I will look a bit closer and try to find out why my entities die when I restore a partial snapshot with ContinuousLoader without `shrink`. \r\n\r\nAs for the options, I think I'll wait for your new shinny snapshot replacement :P "
      },
      {
        "user": "skypjack",
        "created_at": "2018-09-03T10:43:22Z",
        "body": "You're welcome!! :-)\nIs C++17 an option for you? I plan to release most of them only for C++17 actually.\n\n---\n\nI invite you also to join us on gitter to discuss about EnTT and to make more questions in future. There are skilled people in the channel.  \nMoreover, I invite you to star the project if you didn't do it yet.\n\nThanks for using EnTT!!"
      },
      {
        "user": "sina-",
        "created_at": "2018-09-03T11:05:40Z",
        "body": "Yep, I'm on C++17. Thanks for making EnTT :)"
      }
    ]
  },
  {
    "number": 76,
    "title": "Changelog for EnTT",
    "created_at": "2018-05-16T12:25:37Z",
    "closed_at": "2018-05-16T16:39:32Z",
    "labels": [
      "invalid",
      "question"
    ],
    "url": "https://github.com/skypjack/entt/issues/76",
    "body": "Congrats for the last update!! Thank you very much for your hard work, @skypjack ! At times like these I miss a change log and a number version upgrade. :-}\r\n\r\nDJuego\r\n\r\nP.S. Serioulsy, Very happy! My only fear is that EnTT gets too big and slow. :-}",
    "comments_url": "https://api.github.com/repos/skypjack/entt/issues/76/comments",
    "author": "DJuego",
    "comments": [
      {
        "user": "skypjack",
        "created_at": "2018-05-16T13:21:52Z",
        "body": "Thank you @DJuego\nYou're a sort of fan of the library since the first commit and I really appreciate it!!\n\n>At times like these I miss a change log and a number version upgrade.\n\nI want to push something more on `master` before to create a new tag. Consider `v2.5.0` the current stable release and `master` a _work in progress release candidate_.\n\nEhm... A changelog? I'm trying to keep commit messages meaningful and they should already give you an idea of the new features.  \nNever thought about a changelog actually, it could make sense.\n\n>P.S. Serioulsy, Very happy! My only fear is that EnTT gets too big and slow. :-}\n\nTsk tsk. New features are often optional and defined as external classes like `Prototype`. Those that have been integrated with the registry are the result of a discussion and mostly wanted features that worth it.  \nDon't worry, I always keep an eye on performance. Note that what's on `master` right now is even faster than the last stable release. In future I'll push also some other optimizations for multi component standard views and... I plan to get rid of persistent views, mainly because standard views are as fast as the persistent ones nowadays.\n\nWhat's your fear exactly? :-)"
      },
      {
        "user": "skypjack",
        "created_at": "2018-05-16T16:37:43Z",
        "body": "I'm closing the issue because... This isn't an issue? :-)  \nKept note of the request for a changelog along with the next release. I'm lazy, but I'll do my best to write it.\n\nIn the meantime, because there isn't a new release yet, just a few notes about the last merge on `master`:\n\n* Added signals on construction/destruction for components and tags\n* Added `Prototype` class to ease writing sort of templates to use to create new entities.\n* Highly improved multi component standard views (still a work in progress, more has yet to come)\n* Added custom sort function to use to sort pools of components\n* Moved everything towards a model based on tag dispatching to disambiguate overloads\n* Added `dependency` utility\n* `noexcept` is now `ENTT_NOEXCEPT` and exception handling can be fully disabled whether required (ie with UE4)\n* Removed extra `create` functions from the registry as discussed a while ago\n* bug fixing and minor changes all around\n\nEverything is documented both in the code and in the README file, as usual.  \nFeedback are appreciated."
      }
    ]
  },
  {
    "number": 69,
    "title": "How to disable/deactivate components?",
    "created_at": "2018-04-21T14:44:46Z",
    "closed_at": "2018-04-21T15:28:17Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/skypjack/entt/issues/69",
    "body": "Hello! First I want to say, this is great! I'm glad I found this ECS implementation.\r\nEven though I don't understand much of the C++14 template magic I can still use it quite easily.\r\nBut I have some problems finding the best way to do things. It might be a noob question, so I'm sorry if this is the wrong place to ask this.\r\n\r\nSo, I want to have a way to disable components, but store them for later. Is there an easy/obvious way to do this? I want to do this for different purposes, but mostly to hide parts of a GUI.\r\n\r\nI can think of 3 possible ways, but none of them seem optimal:\r\n1. Add a 'bool visible' to every Component that has something to be rendered. \r\n1. Add an empty component 'Visible' that entities must have to be rendered.\r\n1. Keep a storage for components where I move disabled ones temporarily (in this case maybe a PositionComponent).\r\n\r\n1 and 2 feel like a \"hack\" and if I want to do this for other Components, like disabling an Animation, I have to add a bool there as well, or invent another component 'Animating' which isn't very clean.\r\nOption 3 could be reused for all types of components and in theory it sounds like the best solution, but can it be done efficiently? It looks like a feature that should be part of the Registry class to make it efficient, but there is probably a good reason to not add it, right? Could adding a `Registry::deactivate<Comp>(ent)` function (together with `activate`), that creates a new storage space only if needed, work?\r\n\r\nIf I do it in my own code, outside of the Registry class, would it work if I std::move it into my own container and then remove the component from the entity or would that be undefined behaviour? And if it does work, is it much slower than using option 1 or 2 above (for bigger components)?\r\n\r\nI'm fine with using the 'Visible' component option for now, but I wanted to know if someone already found a more general way to do it.\r\n",
    "comments_url": "https://api.github.com/repos/skypjack/entt/issues/69/comments",
    "author": "exilief",
    "comments": [
      {
        "user": "skypjack",
        "created_at": "2018-04-21T15:28:17Z",
        "body": "Hi @exilief \r\n\r\nI'm glad you like `EnTT`. Really appreciated.\r\nWelcome and thank you for participating.\r\n\r\nThere is no way to _deactivate_ a component actually. I wouldn't make it part of the registry, mainly because I don't see a way to make it efficient both in terms of performance and memory usage. It seems to me that the sole viable solution is to create a sort of _secondary pool_ for each component where to store deactivated components, but... isn't it as if you defined a `MyDeactivatedType` component and use it instead?\r\nBecause of this, I prefer to keep it off the registry. I'm trying not to put in uncommon features that can easily implemented user side if required.\r\n\r\nAs a side note, I did something similar more than once. The _component-way_ of doing it is to create a dedicated component and attach or remove it when needed, thus what you mentioned in your second bullet.\r\n\r\nThere are plenty of cases where deactivating a component isn't desired. As an example, if you have one of your systems (rendering?) that gets the entities that have both `Sprite` and `Visible`, you can easily make an entity invisible by removing `Visible`, right? Ok, let's consider you don't use the `Visible` component and the registry lets you deactivate `Sprite`. Same result? Almost.\r\nWhat about the other systems that don't care at all about `Visible` and would have touched instead the entities only because of `Sprite`? What would you expect from them? Should they ignore those entities as well or what else?  \r\nIf you deactivate a component, you are deactivating all the systems that somehow are interested in it, no matter if they were interested also in some other components or not. However, to obtain this you can just remove the component. To obtain the other result around you can attach and remove an auxiliary component like `Visible`, so that you get to disable only some systems.\r\n\r\nI strongly suggest you to go along the _component-way_ if possible. It's far easier to reason on and to keep your codebase well organized. My two cents\r\n\r\n---\r\n\r\nI'm closing the issue for it's not properly an issue. Feel free to continue discussing here anyway if you have other questions."
      },
      {
        "user": "exilief",
        "created_at": "2018-04-21T16:01:00Z",
        "body": "Thank you for responding! It's great to see you so active here :) But you're right it's not really an issue, sorry about that.\r\n\r\nOkay, yes I agree, doing it with the empty auxiliary component works well in this case and I'm doing it this way now. I saw you mention it in the discussion about Spaces as well, but I just thought it's only a dirty trick until we have a better way. I thought this because, as I said in my first post, if you have many components that can be deactivated in this sense the list of components gets very long and I thought this could be a (performance) problem.\r\nBut it probably isn't really now that I think about it... The code just gets a little ugly.\r\n\r\nFor the Animation case I still think it would be nice to deactivate it, as in \"freezing\" it. An animation isn't really used by any system other than the one that updates the animations. But it's not really worth the trouble I guess.\r\n\r\nAlright, I'll keep learning and trying to figure stuff out myself. Thanks again!"
      },
      {
        "user": "skypjack",
        "created_at": "2018-04-21T16:11:34Z",
        "body": "In case of animations, probably I would remove the components instead of freezing them.  \r\nWhat kind of animations are you talking about exactly? If you can provide me with more details, maybe I can try to give you some hints.\r\n\r\n---\r\n\r\nUnfortunately, because of how `EnTT` works internally, there isn't a clean way to _deactivate_ a component. An entity has an instance or it doesn't have it. A pool then exports a packed array of entities that have that component.  \r\nIntroducing another pool for deactivated components would be a great waste of memory, trust me.  \r\nThe other way around could be to mark the entities with a bool in each pool. What's the drawback? Quite easy: when a view iterate components, it must check that bool before to return the entity. it means branches, `if`s all around your codebase that slow down the whole thing!!  \r\nUsing a dedicated component doesn't affect performance instead and doesn't waste more memory than any other solution. So... :-)"
      },
      {
        "user": "exilief",
        "created_at": "2018-04-21T16:22:25Z",
        "body": "Well, the code I have now works, but is still very basic. The advanced stuff is still only happening inside my head :D So I can't give a real use case where this would be needed. I'll see when I have something concrete.\r\n\r\nOkay, yes I took a quick look at the source code to figure out how the storage works and I thought you'd need a separate pool for this. When I mentioned the `deactivate` function I thought it could be done so that this extra pool is only created for the components for which this function is called at least once. So no memory lost if deactivating components is never used. But because I know so little about templates, I might have underestimated how difficult that would be to implement (if it is possible at all).\r\nI know that adding a bool for each entity is a terrible idea, that's why I didn't mention that idea :D\r\n\r\nI thought about storing the deactivated components in my own code with a map for each component type. If I can ever manage to implement it and it's efficient maybe I'll show you my code. But for now it's probably best if we forget this idea :)"
      }
    ]
  },
  {
    "number": 21,
    "title": "Lua bindings",
    "created_at": "2017-11-18T21:34:03Z",
    "closed_at": "2017-11-18T23:21:07Z",
    "labels": [
      "question",
      "discussion"
    ],
    "url": "https://github.com/skypjack/entt/issues/21",
    "body": "A common requirement for game engines is scripting (with lua in my case). As this ECS (and most other) use templates you can't bind most of the important functionality into lua.\r\n\r\nFor example, how would you bind `registry.get<T>(entity);` into lua?\r\n\r\n",
    "comments_url": "https://api.github.com/repos/skypjack/entt/issues/21/comments",
    "author": "tomqwertysdsad",
    "comments": [
      {
        "user": "skypjack",
        "created_at": "2017-11-18T22:04:06Z",
        "body": "You can inherit from the registry or create a wrapper and export from and towards Lua the sole components you want to expose.\nProbably the wrapper will have explicit methods like `get(CompA)`, `get(CompN)` and do on.\nLua and C++ are too much different languages to pretend to use an high performance tool directly. Moreover, Lua has no notion of functions or template, so you cannot use the registry as is.\n\nThat being said, I would proceed by defining specific components for scripting and a dedicated system that interacts with the actual scripts.  \nNo need to use an ECS that isn't based on templates.\n\nI'm at your disposal if you need help."
      },
      {
        "user": "tomqwertysdsad",
        "created_at": "2017-11-18T23:26:59Z",
        "body": "Might not be understanding you correctly.\r\n\r\nAre you suggesting for each component I want to expose to Lua to create a wrapper. So for a Transform component I would create `getTransformComponent()`, `assignTransformComponent(...)` and so on? I know Lua can't work with templates, that is essentially the whole problem I am facing - how to wrap/abstract the ECS in a way which ideally doesn't require a ton of boilerplate code to be written for each component.\r\n\r\nThanks"
      },
      {
        "user": "skypjack",
        "created_at": "2017-11-18T23:37:41Z",
        "body": "Well, think about this.  \nIf I hadn't used template, I had to write N member functions to assign components and N member functions to get them.  \nFortunately, C++ supports templates and I avoided writing all that code. Lua doesn't support template.  \nYou got it.\n\nHowever, I wouldn't expose up to the transform through the scripting system.  \nI mean, try to reduce to a minimum the components your script uses or define only one dedicated component for it. Then a system can write back and forth data from that component to all the others to which it maps. This will force you to write only a couple of functions in a wrapper and a few lines in a system to keep data synced.\n\nYou have not to expose the underlying types to the scripts. Probably you shouldn't."
      }
    ]
  }
]