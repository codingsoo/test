[
  {
    "number": 8798,
    "title": "Entity Metadata not found - Works in production, but fails for integration tests",
    "created_at": "2022-03-25T11:52:21Z",
    "closed_at": "2022-03-26T17:02:42Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/8798",
    "body": "For me the string path entities: ['dist/entity/**/*.entity.js'], works in production code, but for the integration tests this and all above solutions fail. I always need to define the entities explictly by adding them one by one.\r\n\r\nThis can't be the solution as that's not scalable, you always need to manually add the entities. Did anyone have the same problem for integration tests only?",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/8798/comments",
    "author": "wsdt",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2022-03-26T16:26:53Z",
        "body": "You have a configuration issue. Debug how integration tests are running and how it differs from production execution context.\r\n\r\nAlso I recommend to stop using string entity paths because this feature is going to be removed in the next `0.4.0` version. This was discussed multiple times across the repo, but shortly 3 main reasons:\r\n\r\n* problems like you currently have\r\n* unexpected user-facing DX issues due to removed entities persisted in the `outDir`\r\n* we want to make entities explicitly defined to introduce new type-safety features in the future versions"
      },
      {
        "user": "Jo-Chris",
        "created_at": "2022-03-26T16:34:12Z",
        "body": "To me that sounds like an unnecessary additional thing to keep track of. "
      },
      {
        "user": "pleerock",
        "created_at": "2022-03-26T16:46:26Z",
        "body": "You answer the questions and deserve 👎 . Great 🚀 \r\n\r\n> To me that sounds like an unnecessary additional thing to keep track of.\r\n\r\nyes, software engineering is full of pros and cons and you have to leverage.\r\n\r\nSometimes it's better to have additional thing to keep track of rather than spend hours or days on weird bugs because of the cool features.\r\n\r\nSometimes you have to choose between one cool feature and another more cool feature, because they cannot live together.\r\n\r\nSimply said:\r\n\r\n* unnecessary additional thing to keep track of **<** problems like you currently have\r\n* unnecessary additional thing to keep track of **<** unexpected user-facing DX issues due to removed entities persisted in the outDir\r\n* unnecessary additional thing to keep track of **<** new type-safety features in the future versions\r\n\r\n**<** means \"less valuable\"."
      },
      {
        "user": "wsdt",
        "created_at": "2022-03-26T16:49:51Z",
        "body": "Completely understandable, but other frameworks are capable of that feature too. \r\n\r\nBut thank you for the reply :)"
      },
      {
        "user": "pleerock",
        "created_at": "2022-03-26T16:57:59Z",
        "body": "> Completely understandable, but other frameworks are capable of that feature too.\r\n\r\nI have a simple answer to this statement.\r\n\r\nIf you mean \"other frameworks in other languages\" - then yes, they do, because they have a different language and different platform/language specifics. And of course they do not have cool features like JavaScript / TypeScript have.\r\n\r\nIf you mean \"other frameworks in JavaScript / TypeScript\" - then all these frameworks has following problems:\r\n\r\n- problems like you currently have\r\n- unexpected user-facing DX issues due to removed entities persisted in the outDir\r\n- missing cool type-safety features"
      }
    ]
  },
  {
    "number": 8775,
    "title": "Major version",
    "created_at": "2022-03-22T07:21:26Z",
    "closed_at": "2022-03-22T09:15:50Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/8775",
    "body": "## Feature Description\r\n\r\nPlease name any next version as a major version\r\n\r\n### The Problem\r\n\r\nLast 0.3 release has a list of breaking changes.\r\n\r\nDependency update bots like `dependabot` and `renovate` use simple rules - if the version number is second then it means this is a minor update, without breaking changes. I understand that semver allows this, but anyway. Release 0.3 broke all microservices I'm owning.\r\n\r\nTo avoid such problems in the future please make any next release a major release, like `1.0`\r\n\r\n### The Solution\r\n\r\nPlease make a major release 1.0 as soon as possible.\r\n\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/8775/comments",
    "author": "ioncreature",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2022-03-22T09:15:50Z",
        "body": "> I understand that semver allows this, but anyway. Release 0.3 broke all microservices I'm owning.\r\n\r\nYou just answered your question. You need to follow semver as well in order to prevent your code breaking. If dependency bots do not follow it, I'm not sure why they work this way.\r\n\r\nWe are planning to bring more improvements and breaking changes in the future 0.4+ versions, so I don't really want to release 1.0 at the moment. Sorry if it bring inconveniences."
      },
      {
        "user": "acSpock",
        "created_at": "2022-04-07T16:59:45Z",
        "body": "@pleerock that's the point that @ioncreature is making. This package has been in development for over 6 years and still has no major version. Semver says that anything 0.x.z can be breaking and is unstable.\r\n\r\ntypeorm is one of the most widely used orm's for nodejs applications and yet developers are still expected breaking changes with minor version bumps. I understand that this is an open source project but the life of long projects that decided to use typeorm, even years ago, are still expected breaking changes as they try to keep up with patches and mino releases. \r\n\r\nPerhaps the dev teams that decided to use typeorm in their projects should have known the consequences of choosing a pre major release a package. Also, perhaps the typeorm maintainers should consider moving toward a major and stable release version so that dev shops can be more prepared to deal with backward compatibility. \r\n\r\nI appreciate all the work you guys do, just shining some light on dev experience as more and more teams adopt typeorm."
      },
      {
        "user": "ramblingenzyme",
        "created_at": "2023-07-04T04:00:21Z",
        "body": "@pleerock Even just an understanding of what the maintainers think is left before deciding to release 1.0 would be amazing."
      }
    ]
  },
  {
    "number": 8548,
    "title": "Preload function doesn't load soft-deleted entities",
    "created_at": "2022-01-20T10:39:40Z",
    "closed_at": "2022-02-18T20:50:30Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/8548",
    "body": "## Issue Description\r\nWhen i want to preload a soft deleted entity (entities with deleted_at field not null), it returns undefined.\r\nI'm using it to update my entity, so i have a condition in order to throw an error if the preloaded entity is empty.\r\n\r\n### Expected Behavior\r\nI expect that the preload function returns the entity even if the entity is soft deleted.\r\nOR\r\nAdd a parameter that allow us to load soft deleted entities\r\n\r\n### Actual Behavior\r\nThe preload function doesn't load the soft deleted entities  and then it returns undefined.\r\n\r\nMy code:\r\n```typescript\r\nconsole.log({ id });\r\nconst project = await queryRunner.manager.preload(Project, {\r\n        id,\r\n        ...projectDto,\r\n });\r\n\r\nconsole.log({ project });\r\nif (!project) {\r\n   throw new NotFoundException(`Project with id \"${id}\" not found`);\r\n}\r\n```\r\nThe logs:\r\n```\r\n{ id: '85c6d6c2-e279-4993-a0bb-53dafdaed5f2' }\r\n{ project: undefined }\r\nError: Project with id \"85c6d6c2-e279-4993-a0bb-53dafdaed5f2\" not found\r\n```\r\nMy entity (exported as json from my db):\r\n```json\r\n[\r\n\t{\r\n\t\t\"id\": \"85c6d6c2-e279-4993-a0bb-53dafdaed5f2\",\r\n\t\t\"name\": \"Oxygen\",\r\n\t\t\"created_at\": \"2022-01-20 09:10:04.531245+00\",\r\n\t\t\"created_by\": null,\r\n\t\t\"updated_at\": \"2022-01-20 09:10:04.531245+00\",\r\n\t\t\"updated_by\": null,\r\n\t\t\"deleted_at\": \"2022-01-20 09:10:04.53+00\",\r\n\t\t\"deleted_by\": null,\r\n\t\t...\r\n\t}\r\n]\r\n```\r\n\r\n### Steps to Reproduce\r\n1. Create an entity with deleted_at not null in your database\r\n2. Try to preload it\r\n\r\n### My Environment\r\n\r\n<!--\r\n  Please add any other relevant dependencies to this table at the end.\r\n  For example: Electron, React Native, or NestJS.\r\n-->\r\n\r\n| Dependency          | Version  |\r\n| ---                 | ---      |\r\n| Operating System    |  macOs 12.1\r\n| Node.js version     | 16.13.1 \r\n| Typescript version  | 4.5.4 \r\n| TypeORM version     | 0.2.41\r\n| @nestjs/typeorm     | 7.1.5\r\n\r\n### Relevant Database Driver(s)\r\n\r\n| DB Type              | Reproducible  |\r\n| ---                  | ---           |\r\n| `aurora-data-api`    | x            |\r\n| `aurora-data-api-pg` | x            |\r\n| `better-sqlite3`     | x            |\r\n| `cockroachdb`        | x            |\r\n| `cordova`            | x            |\r\n| `expo`               | x            |\r\n| `mongodb`            | x            |\r\n| `mysql`              | x            |\r\n| `nativescript`       | x            |\r\n| `oracle`             | x            |\r\n| `postgres`           | yes            |\r\n| `react-native`       | x            |\r\n| `sap`                | x            |\r\n| `sqlite`             | x            |\r\n| `sqlite-abstract`    | x            |\r\n| `sqljs`              | x            |\r\n| `sqlserver`          | x            |\r\n\r\n\r\n### Are you willing to resolve this issue by submitting a Pull Request?\r\n\r\n - ✖️ Yes, I have the time, and I know how to start.\r\n - ✅ Yes, I have the time, but I don't know how to start. I would need guidance.\r\n - ✖️ No, I don’t have the time, but I can support (using donations) development.\r\n - ✖️ No, I don’t have the time and I’m okay to wait for the community / maintainers to resolve this issue.\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/8548/comments",
    "author": "Anxium",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2022-02-18T20:50:30Z",
        "body": "Looks like a question. Just load it using `.find` method in combination with `withDeleted` option."
      },
      {
        "user": "Anxium",
        "created_at": "2022-02-19T08:19:50Z",
        "body": "Indeed, sorry for the wrong tag.\r\n\r\nBased on the pull request in which this issue was mentioned, do you recommend not using the \"soft delete\" feature and doing a custom implementation in our project ? \r\n\r\nBecause the fact that the preload function will not load the soft-deleted entities is not specified in the doc, it can leads to some issues or maybe a duplicate of this issue, what is a waste of time. Then, can I suggest to add it in the doc ?\r\n\r\nThanks for you response !\r\n"
      },
      {
        "user": "pleerock",
        "created_at": "2022-02-19T09:47:18Z",
        "body": "> Based on the pull request in which this issue was mentioned, do you recommend not using the \"soft delete\" feature and doing a custom implementation in our project ?\r\n\r\nuse it until it satisfy your needs. If it becomes a bottleneck and you miss some features - you can go with your own implementation.\r\n\r\n> Because the fact that the preload function will not load the soft-deleted entities is not specified in the doc, it can leads to some issues or maybe a duplicate of this issue, what is a waste of time. Then, can I suggest to add it in the doc ?\r\n\r\nI'm not sure about future of `preload` method. Better to use `find` to load entity. May I know your use cases (simplified) of `preload` method and why you use it instead of using `find`?"
      },
      {
        "user": "Anxium",
        "created_at": "2022-02-19T10:59:58Z",
        "body": "> May I know your use cases (simplified) of preload method and why you use it instead of using find?\r\n\r\nI'm using it to load the entity and all its relations, and replace the data in one-time. It seemed faster than find and replace. \r\nBut the work-around I did, is what you answered, i'm using a find with `withDeleted: true` now"
      }
    ]
  },
  {
    "number": 8423,
    "title": "pg - parameter save was number return string",
    "created_at": "2021-12-03T15:43:05Z",
    "closed_at": "2022-04-15T17:21:03Z",
    "labels": [
      "question",
      "requires triage"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/8423",
    "body": "## pg - parameter save was number return string\r\n\r\ntypeorm v ^0.2.38\r\n\r\nguys, I noticed that when fetching data from a table saved as number ('decimal') the value is returned as a string.\r\n\r\nto solve it, I used a transformer on the entity like this:\r\n\r\n`\r\n  @Column('decimal', {\r\n    transformer: {\r\n      to(value) {\r\n        return value;\r\n      },\r\n      from(value) {\r\n        return parseFloat(value);\r\n      },\r\n    },\r\n  })\r\n  value: number;\r\n`\r\n\r\nis there any way to get this data or use the transformer? \r\n\r\n-----\r\n\r\npessoal, uma notei que ao buscar os dados de uma tabela salvos como number ('decimal') o valor é retornado como string.\r\n\r\npara resolver, usei um transformer na entity assim:\r\n\r\n`\r\n  @Column('decimal', {\r\n    transformer: {\r\n      to(value) {\r\n        return value;\r\n      },\r\n      from(value) {\r\n        return parseFloat(value);\r\n      },\r\n    },\r\n  })\r\n  value: number;\r\n`\r\n\r\ntem alguma forma de pegar esse dado nem usar o transformer?\r\n\r\n\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/8423/comments",
    "author": "pedromesmer",
    "comments": [
      {
        "user": "Ginden",
        "created_at": "2022-01-25T18:15:12Z",
        "body": "Question is unclear.\r\n\r\n> is there any way to get this data or use the transformer?\r\n\r\nTypeORM automatically use transformer."
      }
    ]
  },
  {
    "number": 8049,
    "title": "Time Zone is not working probably ",
    "created_at": "2021-08-06T23:56:58Z",
    "closed_at": "2021-08-09T14:10:19Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/8049",
    "body": "\r\n## Issue Description\r\nwhen i store a @CreateDateColumn() in a sql database , when i check the time stamp in the database using phpmyadmin , the date and time is stored exactly like it should be but , when i use find method iside the service, the returned time stampe is totally wrong, it's late 2 hours or so ...  \r\n\r\n### Expected Behavior\r\nthe time stamp is returned exactly like how it's actually stored \r\n\r\n\r\n### Actual Behavior\r\n\r\nthe time stamp is late 2 hours or so \r\n\r\noutput\r\n```\r\n\"id\": 1,\r\n\"creationDate\": \"2021-08-06T23:33:02.120Z\",\r\n```\r\n\r\n\r\n\r\n### My Environment\r\n\r\n<!--\r\n  Please add any other relevant dependencies to this table at the end.\r\n  For example: Electron, React Native, or NestJS.\r\n-->\r\n\r\n| Dependency          | Version  |\r\n| ---                 | ---      |\r\n| Operating System    |          |\r\n| Node.js version     | v16.4.2\r\n  | <!-- run `node -v` to obtain this -->\r\n| Typescript version  |  typescript@4.3.5\r\n  | <!-- run `npm list typescript` to obtain this -->\r\n| TypeORM version     | typeorm@0.2.34\r\n  | <!-- run `npm list typeorm` to obtain this -->\r\n\r\n\r\n### Additional Context\r\n:p\r\n<!--\r\n  Add any other context about the bug report here.\r\n-->\r\n\r\n\r\n### Relevant Database Driver(s)\r\n\r\n<!-- Put \"yes\" instead of \"no\" to your issue's relevant databases -->\r\n\r\n| DB Type              | Reproducible  |\r\n| ---                  | ---           |\r\n| `aurora-data-api`    | no            |\r\n| `aurora-data-api-pg` | no            |\r\n| `better-sqlite3`     | no            |\r\n| `cockroachdb`        | no            |\r\n| `cordova`            | no            |\r\n| `expo`               | no            |\r\n| `mongodb`            | no            |\r\n| `mysql`              | YES YES YES        |\r\n| `nativescript`       | no            |\r\n| `oracle`             | no            |\r\n| `postgres`           | no            |\r\n| `react-native`       | no            |\r\n| `sap`                | no            |\r\n| `sqlite`             | no            |\r\n| `sqlite-abstract`    | no            |\r\n| `sqljs`              | no            |\r\n| `sqlserver`          | no            |\r\n\r\n\r\n### Are you willing to resolve this issue by submitting a Pull Request?\r\n\r\n<!-- Put \"✅\" (:white_check_mark:) to one of these options, left \"✖️\" (:heavy_multiplication_x:) others: -->\r\n\r\n - ✖️ Yes, I have the time, and I know how to start.\r\n - ✖️ Yes, I have the time, but I don't know how to start. I would need guidance.\r\n - ✖️ No, I don’t have the time, but I can support (using donations) development.\r\n -  ✅ No, I don’t have the time and I’m okay to wait for the community / maintainers to resolve this issue.\r\n\r\n\r\n<!--\r\n  Remember that first-time contributors are welcome! 🙌\r\n  👋 Have a great day and thank you for the bug report!\r\n-->\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/8049/comments",
    "author": "Abdullah3553",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2021-08-09T14:10:19Z",
        "body": "because the server you are running (I guess your computer) isn't in UTC, and the date is transformed into your local time. Make sure to store your dates in UTC and on your server side also have it in UTC, and when you return date back to the clients you can apply their timezone to have their time on their devices.\r\n\r\nPlease use TypeORM's slack channel or StackOverflow to ask these kind of questions."
      }
    ]
  },
  {
    "number": 7990,
    "title": "Datetime column altered on restart",
    "created_at": "2021-07-30T15:11:33Z",
    "closed_at": "2021-08-02T13:04:53Z",
    "labels": [
      "invalid",
      "question",
      "design issue: directory loaded entities"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/7990",
    "body": "\r\n### Expected Behavior\r\nSame problem as issue #2333\r\n\r\nCreated column with type date, also tried timestamp. Expected to\r\n\r\n\r\n### Actual Behavior\r\n\r\nColum with type Date is getting dropped and created after every restart in sync mode.\r\n\r\n\r\n```\r\nquery ALTER TABLE `database`.`user` DROP COLUMN `lastLoggedOut`\r\nquery: ALTER TABLE `database`.`user` ADD `lastLoggedOut` timestamp(6) NULL\r\n```\r\n\r\n\r\n### Steps to Reproduce\r\n\r\n```\r\n@Entity()\r\nexport class User extends DefaultEntity implements ContactEntity {\r\n\r\n    @Column('timestamp', { precision: 6, nullable: true })\r\n    public lastLoggedOut?: Date\r\n}\r\n\r\n```\r\n\r\n\r\n### My Environment\r\n\r\n\r\nUbuntu 21.04\r\nMySQL 8.0.26\r\nNode.js version v14.17.0\r\ntypescript@4.3.5\r\ntypeorm@0.2.35\r\n@nestjs/core@7.6.18\r\n\r\n\r\n### Additional Context\r\n\r\n\r\n\r\n\r\n### Relevant Database Driver(s)\r\n\r\n<!-- Put \"yes\" instead of \"no\" to your issue's relevant databases -->\r\n\r\n| DB Type              | Reproducible  |\r\n| ---                  | ---           |\r\n| `aurora-data-api`    | no            |\r\n| `aurora-data-api-pg` | no            |\r\n| `better-sqlite3`     | no            |\r\n| `cockroachdb`        | no            |\r\n| `cordova`            | no            |\r\n| `expo`               | no            |\r\n| `mongodb`            | no            |\r\n| `mysql`              | yes            |\r\n| `nativescript`       | no            |\r\n| `oracle`             | no            |\r\n| `postgres`           | no            |\r\n| `react-native`       | no            |\r\n| `sap`                | no            |\r\n| `sqlite`             | no            |\r\n| `sqlite-abstract`    | no            |\r\n| `sqljs`              | no            |\r\n| `sqlserver`          | no            |\r\n\r\n\r\n### Are you willing to resolve this issue by submitting a Pull Request?\r\n\r\n<!-- Put \"✅\" (:white_check_mark:) to one of these options, left \"✖️\" (:heavy_multiplication_x:) others: -->\r\n\r\n - ✖️  Yes, I have the time, and I know how to start.\r\n - ✅  Yes, I have the time, but I don't know how to start. I would need guidance.\r\n - ✖️ No, I don’t have the time, but I can support (using donations) development.\r\n - ✖️ No, I don’t have the time and I’m okay to wait for the community / maintainers to resolve this issue.\r\n\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/7990/comments",
    "author": "lazaroofarrill",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2021-08-02T12:59:42Z",
        "body": "Can you please create github repository with a minimal reproduction code? Or you can create a PR with a failing test if you wish."
      },
      {
        "user": "lazaroofarrill",
        "created_at": "2021-08-02T13:04:53Z",
        "body": "Deleting the dist folder solved the problem, thanks."
      }
    ]
  },
  {
    "number": 7985,
    "title": "How to only select relations_table in many to many, and two relation in one entity?",
    "created_at": "2021-07-30T06:28:50Z",
    "closed_at": "2021-08-02T13:06:24Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/7985",
    "body": "## description\r\n\r\nI have a `User` entity, and it's have a property `follows`. typeof follows is `User[]`, so I declare a follows in the User entity\r\n\r\ncode（abbreviation） : UserEntity↓↓↓\r\n\r\n```typescript\r\nexport class User {\r\n  @PrimaryGeneratedColumn()\r\n  id: number;\r\n  \r\n  // .....\r\n  \r\n  @ManyToMany(() => User, user => user.id)\r\n  @JoinTable()\r\n  follows: User[];\r\n}\r\n```\r\n\r\nnow, I want to select user's follow and paging, so I use innerJoin, take and skip\r\n```typescript\r\n.createQueryBuilder('user')\r\n.innerJoinAndSelect('user.follows', 'follows')\r\n.where('user.id = :id', { id: userId })\r\n.skip(pageSize * (current - 1))\r\n.take(pageSize)\r\n.getMany();\r\n```\r\n\r\nbut the result is one User and all users it follow, I found that skip and take restrict user entity rather than follows.\r\n\r\nIs my operation wrong? Ask for help\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/7985/comments",
    "author": "Fengjing95",
    "comments": [
      {
        "user": "blazmrak",
        "created_at": "2021-07-30T09:30:51Z",
        "body": "If you want to see followers than you should not query the users table, but the follow table (the inbetween table). \r\n\r\n```JavaScript\r\n.createQueryBuilder('follow')\r\n.innerJoinAndSelect('follow.follower', 'follower')\r\n.where('follow.followed.id = :id', { id: userId })\r\n.skip(pageSize * (current - 1))\r\n.take(pageSize)\r\n.getMany();\r\n```"
      },
      {
        "user": "pleerock",
        "created_at": "2021-08-02T13:06:24Z",
        "body": "Please use StackOverflow or TypeORM's slack channel for questions."
      }
    ]
  },
  {
    "number": 7972,
    "title": "Add DeleteOptions for delete() method",
    "created_at": "2021-07-28T19:59:13Z",
    "closed_at": "2021-08-02T15:19:08Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/7972",
    "body": "Dear all,\r\n\r\nUsing version 0.2.34.\r\n\r\nDo you think is possible to add a DeleteOptions like RemoveOptions in order to play with chunk size and other options?\r\nIn docs you say _\"Optional RemoveOptions can be passed as parameter for remove and delete.\"_ but seems to not be true 😄.\r\n\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/7972/comments",
    "author": "michaelsogos",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2021-08-02T14:44:46Z",
        "body": "> In docs you say \r\n\r\ncopy/paste issue...\r\n\r\n> Do you think is possible to add a DeleteOptions like RemoveOptions in order to play with chunk size and other options?\r\n\r\nno, DeleteOptions is used for `delete` operation which uses `DeleteQueryBuilder`. Purpose of  `DeleteQueryBuilder` is to build and execute only one query. If you want something more complex, use `remove` method instead."
      }
    ]
  },
  {
    "number": 7937,
    "title": "How to use or modify database?Thank!  entityManager.options.database = 'otherDB';",
    "created_at": "2021-07-20T07:21:33Z",
    "closed_at": "2021-07-20T11:10:05Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/7937",
    "body": "const entityManager = getConnection();\r\nentityManager.options.database = 'otherDB';\r\n\r\nError:\r\nHow to use or modify database?Thank!",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/7937/comments",
    "author": "luzhihg",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2021-07-20T11:10:05Z",
        "body": "Database is set per connection options. If you want to connect to a different database, you need to create a new connection with new connection options and specify new database name. Depend of what you want to achieve, if you want to execute query against different database, in query builder you can create a query and specify a different database name. \r\n\r\nPlease use our slack channel for questions!"
      }
    ]
  },
  {
    "number": 7769,
    "title": "ConnectionError using mssql package version 7.1.x",
    "created_at": "2021-06-20T03:02:44Z",
    "closed_at": "2021-06-20T04:42:04Z",
    "labels": [
      "question",
      "driver: mssql"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/7769",
    "body": "## Issue Description\r\nRuntime error when using mssql package 7.1.x (7.1.3 is the current latest as of 20210620)\r\n**ConnectionError: Failed to connect to localhost:1433 - self signed certificate**\r\n\r\n### Expected Behavior\r\nNo correction error\r\nPlease note this is/was working in mssql package 6.3.x (with the last version at 6.3.2)\r\n\r\n\r\n### Actual Behavior\r\n```\r\nConnectionError: Failed to connect to localhost:1433 - self signed certificate\r\n    at <project_folder>/node_modules/mssql/lib/tedious/connection-pool.js:71:17\r\n    at Connection.onConnect (<project_folder>/node_modules/tedious/lib/connection.js:1027:9)\r\n    at Object.onceWrapper (events.js:421:26)\r\n    at Connection.emit (events.js:314:20)\r\n    at Connection.emit (<project_folder>/node_modules/tedious/lib/connection.js:1055:18)\r\n    at Connection.socketError (<project_folder>/node_modules/tedious/lib/connection.js:1653:12)\r\n    at Socket.<anonymous> (<project_folder>/node_modules/tedious/lib/connection.js:1417:14)\r\n\r\n```\r\n\r\n\r\n### Steps to Reproduce\r\n1. Install 'npm install mssql@latest'\r\n2. Run application\r\n\r\n\r\n### My Environment\r\nOS Version     : macOS Big Sur\r\nNodeJS Version : v12.20.1\r\nNPM Version    : 7.18.1 \r\nTypescript: 4.3.4\r\n\r\n\r\n\r\n### Additional Context\r\n\r\n### Relevant Database Driver(s)\r\n\r\n- [ ] `aurora-data-api`\r\n- [ ] `aurora-data-api-pg`\r\n- [ ] `better-sqlite3`\r\n- [ ] `cockroachdb`\r\n- [ ] `cordova`\r\n- [ ] `expo`\r\n- [ ] `mongodb`\r\n- [ ] `mysql`\r\n- [ ] `nativescript`\r\n- [ ] `oracle`\r\n- [ ] `postgres`\r\n- [ ] `react-native`\r\n- [ ] `sap`\r\n- [ ] `sqlite`\r\n- [ ] `sqlite-abstract`\r\n- [ ] `sqljs`\r\n- [X] `sqlserver`\r\n\r\n\r\n### Are you willing to resolve this issue by submitting a Pull Request?\r\n- [ ] Yes, I have the time, and I know how to start.\r\n- [ ] Yes, I have the time, but I don't know how to start. I would need guidance.\r\n- [ ] No, I don't have the time, although I believe I could do it if I had the time...\r\n- [X] No, I don't have the time and I wouldn't even know how to start.\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/7769/comments",
    "author": "AcidSlide-Octal",
    "comments": [
      {
        "user": "imnotjames",
        "created_at": "2021-06-20T04:41:44Z",
        "body": "Mssql now throws an error because of self signed certificates.  I'm sure there's an option you can pass to `extra` to bypass this but we won't be updating typeorm to ignore certificate errors."
      },
      {
        "user": "zoubeihua",
        "created_at": "2021-07-20T11:13:20Z",
        "body": "问下这个问题解决了吗？ 我也报这样的错"
      },
      {
        "user": "aixiamomo",
        "created_at": "2022-08-09T02:40:11Z",
        "body": "version: 0.2.x\r\n```\r\nexport const connectionSQlServerOpts: ConnectionOptions = {\r\n  name: 'xx',\r\n  type: 'mssql',\r\n\r\n  host: 'xx',\r\n  port: 433,\r\n  database: 'xx',\r\n  username: 'xx',\r\n  password: 'xx',\r\n\r\n  entities: [\r\n    Model\r\n  ],\r\n  synchronize: true,\r\n  extra: {\r\n    trustServerCertificate: true\r\n  }\r\n}\r\n```\r\n\r\nversion: 0.3.x\r\n```\r\nexport const AppDataSource = new DataSource({\r\n  type: \"mssql\",\r\n  host: \"xxx\",\r\n  port: 433,\r\n  username: \"xx\",\r\n  password: \"xx\",\r\n  database: \"xx\",\r\n  synchronize: true,\r\n  logging: false,\r\n  entities: [User],\r\n  migrations: [],\r\n  subscribers: [],\r\n  extra: {\r\n    trustServerCertificate: true,\r\n  }\r\n})\r\n\r\n```"
      }
    ]
  },
  {
    "number": 7569,
    "title": "How to save Using @Afterload, Nested Relations",
    "created_at": "2021-04-15T06:46:55Z",
    "closed_at": "2022-02-02T13:20:56Z",
    "labels": [
      "bug",
      "question",
      "driver: postgres",
      "requires triage"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/7569",
    "body": "Issue type:\r\n\r\n[x ] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\nDatabase system/driver:\r\n\r\n[ ] cordova\r\n[ ] mongodb\r\n[ ] mssql\r\n[ ] mysql / mariadb\r\n[ ] oracle\r\n[x] postgres\r\n[ ] cockroachdb\r\n[ ] sqlite\r\n[ ] sqljs\r\n[ ] react-native\r\n[ ] expo\r\n\r\nTypeORM version:\r\n\r\n[ ] latest\r\n[ ] @next\r\n[ x] 7.5.4 (or put your version here)\r\n\r\nSteps to reproduce or a small repository showing the problem:\r\n\r\n\r\n* user_profile.entity.ts\r\n```js\r\n@Entity()\r\n@Unique(['username'])\r\nexport class UserProfile {\r\n  /** Columns */\r\n  @PrimaryGeneratedColumn('uuid')\r\n  readonly id: string;\r\n \r\n  @Column('timestamptz')\r\n  @CreateDateColumn()\r\n  readonly created_at: Date;\r\n \r\n  @Column('timestamptz')\r\n  @UpdateDateColumn()\r\n  readonly updated_at: Date;\r\n \r\n  @ApiProperty()\r\n  @Column({ length: 255 })\r\n  @IsString()\r\n  @Length(3, 50)\r\n  username: string;\r\n \r\n  @Column()\r\n  post_count: number;\r\n \r\n  @ApiProperty({ readOnly: true })\r\n  @Column('uuid')\r\n  @IsUUID('4')\r\n  user_id: string;\r\n \r\n  @ApiProperty({ readOnly: true })\r\n  @Column({ default: 0, nullable: true })\r\n  @IsOptional()\r\n  exp?: number;\r\n \r\n  @ApiProperty({ readOnly: true })\r\n  @Column({ default: 1, nullable: true })\r\n  @IsOptional()\r\n  level?: number;\r\n \r\n  /** Relations */\r\n  @OneToOne((type) => User, (user) => user.profile, { onDelete: 'CASCADE' })\r\n  @JoinColumn({ name: 'user_id', referencedColumnName: 'id' })\r\n  user: User;\r\n \r\n  // ** Hooks\r\n \r\n  @AfterLoad()\r\n  updatePostCount() {\r\nthis.post_count = this.user.posts.length;\r\n  }\r\n}\r\n```\r\n\r\n```js\r\nuser.entity.ts\r\n@Entity()\r\n@Unique(['email'])\r\n@Check(`\r\n  COALESCE((provider = 'local')::integer, 0) \r\n  + \r\n  COALESCE(LENGTH(social_id::text)::boolean::integer, 0)\r\n  = 1\r\n`)\r\nexport class User {\r\n  /** Columns */\r\n \r\n  @ApiProperty()\r\n  @PrimaryGeneratedColumn('uuid')\r\n  readonly id: string;\r\n \r\n  @ApiProperty()\r\n  @Column('timestamptz')\r\n  @CreateDateColumn()\r\n  readonly created_at: Date;\r\n \r\n  @ApiProperty()\r\n  @Column('timestamptz')\r\n  @UpdateDateColumn()\r\n  readonly updated_at: Date;\r\n \r\n  @ApiProperty()\r\n  @Column({ length: 255 })\r\n  @IsEmail()\r\n  email: string;\r\n \r\n  /** Relations */\r\n \r\n  @OneToMany((type) => Post, (post) => post.author)\r\n  posts: Post[];\r\n \r\n  @ApiProperty()\r\n  @OneToOne((type) => UserProfile, (userProfile) => userProfile.user, {\r\n    cascade: true,\r\n  })\r\n  profile: UserProfile;\r\n \r\n  @AfterLoad()\r\n  asdfasdf() {\r\n    console.log('유저 entity :');\r\n  }\r\n}\r\n```\r\n* post.entity.ts\r\n\r\n```js\r\n@Entity()\r\nexport class Post {\r\n  /** Columns */\r\n \r\n  @PrimaryGeneratedColumn('uuid')\r\n  readonly id: string;\r\n \r\n  @Column('timestamptz')\r\n  @CreateDateColumn()\r\n  readonly created_at: Date;\r\n \r\n  @Column('timestamptz')\r\n  @UpdateDateColumn()\r\n  readonly updated_at: Date;\r\n \r\n  @ApiProperty()\r\n  @Column({ length: 255 })\r\n  @IsString()\r\n  title: string;\r\n \r\n  @ApiProperty()\r\n  @Column('text')\r\n  @IsString()\r\n  contents: string;\r\n \r\n  @ApiProperty({ readOnly: true })\r\n  @Column('uuid')\r\n  @IsUUID('4')\r\n  user_id: string;\r\n \r\n  /** Relations */\r\n  @ManyToOne((type) => User, (user) => user.posts, {\r\n    cascade: true,\r\n    // eager: true,\r\n    onDelete: 'CASCADE',\r\n  })\r\n  @JoinColumn({ name: 'user_id', referencedColumnName: 'id' })\r\n  author: User;\r\n}\r\n```\r\n* users.service.ts\r\n```js\r\n  async getMyUser(user_id: string) {\r\n    const test = await this.userProfileRepository\r\n      .createQueryBuilder('user_profile')\r\n      .leftJoinAndSelect('user_profile.user', 'user')\r\n      .leftJoinAndSelect('user.posts', 'posts')\r\n      .where('user.id = :id', { id: user_id })\r\n      .getOne();\r\n\r\n    return test;\r\n  }\r\n  async getUserProfile(user_id: string): Promise<UserProfileResponseDto> {\r\n    try {\r\n      const user = await this.userRepository\r\n        .createQueryBuilder('user')\r\n        .leftJoinAndSelect('user.profile', 'user_profile')\r\n        .leftJoinAndSelect('user.followers', 'followers')\r\n        .leftJoinAndSelect('user.following', 'following')\r\n        .leftJoinAndSelect('user.posts', 'posts')\r\n        .where('user.id = :id', { id: user_id })\r\n        .getOne();\r\n\r\n      if (!user) {\r\n        throw new Error();\r\n      }\r\n      return {\r\n        profile: user.profile,\r\n        followers: user.followers.length,\r\n        following: user.following.length,\r\n        posts: user.posts.length,\r\n      };\r\n    } catch (err) {\r\n      throw new BadRequestException('Invalid user_id');\r\n    }\r\n  }\r\n\r\n```\r\n\r\nI want to put the number of posts in my user profile entity (`post_count`).\r\n\r\nIn user_profile entity, I used @Afterload,\r\n\r\nWhen I use userPrifileRepository(getMyUser), the output is good, but if I use userRepository(getUserProfile), it doesn't come out. (this.user or this.user.posts.length was printed as undefined.)\r\n\r\nAnd even if the output was good, it could not be saved. this.post_count = this.user.posts.length\r\n\r\nHow to save `post_count` using `@Afterload`",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/7569/comments",
    "author": "ehgks0000",
    "comments": [
      {
        "user": "ryancraigmartin",
        "created_at": "2022-03-01T20:00:19Z",
        "body": "@ehgks0000 Did you resolve this issue?"
      }
    ]
  },
  {
    "number": 7345,
    "title": "Add hidden classes to the index.ts to allow its usage",
    "created_at": "2021-02-05T21:04:43Z",
    "closed_at": "2021-07-04T04:13:05Z",
    "labels": [
      "question",
      "new feature",
      "requires triage"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/7345",
    "body": "## Feature Description\r\nAdd hidden classes to the index.ts to allow its usage\r\n\r\n### Issue type:\r\n[x] question\r\n[ ] bug report\r\n[x] feature request\r\n[ ] documentation issue\r\n\r\n### The Problem\r\nI'm extending the SelectQueryBuilder in my project to create a custom query builder and add extra behavior to the joins and selects. All was going well and I see very useful typeorm classes like JoinAttribute or QueryBuilderUtils (as an example). The problem is these classes and others have not been added to the index.ts and I can't use them.\r\n\r\nIs there a reason for it?\r\n\r\n### The Solution\r\nAdd missing classes to the index.ts file of the project to allow its usage.\r\n\r\n### Considered Alternatives\r\nImport them using complete reference path, ie:\r\nimport { Alias } from 'typeorm/query-builder/Alias';\r\nimport { JoinAttribute } from 'typeorm/query-builder/JoinAttribute';\r\n\r\n### Are you willing to resolve this issue by submitting a Pull Request?\r\n- [X] Yes, I have the time, and I know how to start.\r\n- [ ] Yes, I have the time, but I don't know how to start. I would need guidance.\r\n- [ ] No, I don't have the time, although I believe I could do it if I had the time...\r\n- [ ] No, I don't have the time and I wouldn't even know how to start.\r\n\r\nI can do it because it's just add the references to the classes in the index.ts, but I think I can't just simply add all the classes. Maybe a discussion must be done first to decide the list of \"exportable\" clases. Or maybe we can just add all the classes.\r\n\r\nGreetings.\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/7345/comments",
    "author": "ibellver",
    "comments": [
      {
        "user": "imnotjames",
        "created_at": "2021-07-04T04:13:05Z",
        "body": "We export loads of the classes already.  If you need some, add them.  This isn't really an actionable issue, though.  We don't export everything because many of the classes are for internal representations of data."
      }
    ]
  },
  {
    "number": 6816,
    "title": "fix: queryRunner.renameTable should not rename enums used by the table",
    "created_at": "2020-09-30T14:16:21Z",
    "closed_at": "2021-07-10T06:44:11Z",
    "labels": [
      "question",
      "comp: migrations"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/6816",
    "body": "**Issue type:**\r\n\r\n[x] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:** [x] `postgres`\r\n\r\n**TypeORM version:** `latest`\r\n\r\n### Description\r\n\r\nWhen a table is renamed via `queryRunner.renameTable` it will rename the enums used by the table. I think this should not be the case as an enum can be used by multiple tables and by prefixing it with the renamed table name will make it strange to use in the other tables. \r\n\r\n### Steps to reproduce or a small repository showing the problem\r\n\r\nAll 3 step should be added in a different transaction. First the enum needs to be created:\r\n\r\n```ts\r\nawait queryRunner.query(\r\n  `CREATE TYPE enum_resolution AS ENUM ('PT15M', 'PT60M', 'P1D', 'P1M', 'P3M', 'P1Y', 'seasonal', 'intraday')`\r\n);\r\n```\r\nThen create a table using the enum:\r\n```ts\r\nimport { MigrationInterface, QueryRunner, Table } from 'typeorm';\r\n\r\nexport class createTableHourlyTemperature1550570592750 implements MigrationInterface {\r\n  public async up(queryRunner: QueryRunner): Promise<any> {\r\n    await queryRunner.createTable(\r\n      new Table({\r\n        name: 'raw_data.hourly_temperature',\r\n        columns: [\r\n          {\r\n            name: 'resolution',\r\n            type: 'enum_resolution',\r\n          },\r\n        ],\r\n      })\r\n    );\r\n  }\r\n\r\n  public async down(queryRunner: QueryRunner): Promise<any> {\r\n    await queryRunner.dropTable('raw_data.hourly_temperature');\r\n  }\r\n}\r\n```\r\nThen rename the table via `queryRunner.renameTable`:\r\n```ts\r\nimport { MigrationInterface, QueryRunner } from 'typeorm';\r\n\r\nexport class renameHourlyTemperatureTableToTemperature1599484493349 implements MigrationInterface {\r\n  public async up(queryRunner: QueryRunner): Promise<void> {\r\n    await queryRunner.renameTable('raw_data.hourly_temperature', 'temperature');\r\n  }\r\n\r\n  public async down(queryRunner: QueryRunner): Promise<void> {\r\n    await queryRunner.renameTable('raw_data.temperature', 'hourly_temperature');\r\n  }\r\n}\r\n```\r\n\r\nObserve the generated queries: \r\n\r\n```\r\nquery: ALTER TABLE \"raw_data\".\"hourly_temperature\" RENAME TO \"temperature\"\r\nquery: ALTER TABLE \"raw_data\".\"temperature\" RENAME CONSTRAINT \"PK_b30b7b3b3657b819b781b5e95b8\" TO \"PK_7810603e74ca71d654ef434a078\"\r\nquery: ALTER TYPE \"public\".\"enum_resolution\" RENAME TO \"temperature_resolution_enum\"\r\nquery: ALTER TYPE \"public\".\"enum_temperature_source\" RENAME TO \"temperature_source_enum\"\r\nquery: INSERT INTO \"migrations\"(\"timestamp\", \"name\") VALUES ($1, $2) -- PARAMETERS: [1599484493349,\"renameHourlyTemperatureTableToTemperature1599484493349\"]\r\nquery: COMMIT\r\nquery: START TRANSACTION\r\n```",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/6816/comments",
    "author": "NoNameProvided",
    "comments": [
      {
        "user": "AlexMesser",
        "created_at": "2021-02-25T15:34:25Z",
        "body": "@NoNameProvided you can use `enumName` property if you want to share enum type across multiple tables.\r\n\r\n```ts\r\ncolumns: [\r\n  {\r\n    name: 'resolution',\r\n    type: 'enum',\r\n    enumName: 'enum_resolution'\r\n  },\r\n],\r\n```"
      },
      {
        "user": "NoNameProvided",
        "created_at": "2021-02-25T16:57:51Z",
        "body": "Thanks for the feedback! I will take a look. Should we close or leave it open as a feature request to make enum name preservation the default? "
      },
      {
        "user": "imnotjames",
        "created_at": "2021-07-10T06:44:11Z",
        "body": "We won't make it the default as it leads to other issues.  I'll be closing this as your question was answered"
      }
    ]
  },
  {
    "number": 6563,
    "title": "MySql for Expo compatibility",
    "created_at": "2020-08-14T01:10:48Z",
    "closed_at": "2020-10-01T04:48:39Z",
    "labels": [
      "invalid",
      "question",
      "driver: mysql",
      "driver: mariadb"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/6563",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[x] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[ ] `cockroachdb`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\n`Im readed the documentation of lib, and i saw that Expo version have support with sqlite, but not find nothing about compatibility for Mysql for react-native (expo) im trying to do this but without succes... is that compatible withExpo?`                ",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/6563/comments",
    "author": "eduardoalba0",
    "comments": [
      {
        "user": "imnotjames",
        "created_at": "2020-08-16T16:18:34Z",
        "body": "There's no MySQL module that works on the browser.  As such, you cannot use the MySQL driver in react native / other browser based contexts"
      }
    ]
  },
  {
    "number": 6556,
    "title": "Using multiple connections with env vars",
    "created_at": "2020-08-12T14:46:31Z",
    "closed_at": "2020-10-05T06:12:09Z",
    "labels": [
      "question",
      "driver: postgres",
      "driver: mongodb"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/6556",
    "body": "**Issue type:**\r\n\r\n[ x ] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ x ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ x ] `postgres`\r\n[ ] `cockroachdb`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[ x ] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\nI want to use multiple databases o my app but I'm using env vars to configure connections. Is there a way to multiple connections using env vars?\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/6556/comments",
    "author": "edilson",
    "comments": [
      {
        "user": "imnotjames",
        "created_at": "2020-09-29T19:41:24Z",
        "body": "You'd have to manually create the connections and map your custom environment variables to the connections."
      }
    ]
  },
  {
    "number": 6555,
    "title": "How to SET PostgreSQL runtime configuration variables safely without transaction",
    "created_at": "2020-08-12T14:44:29Z",
    "closed_at": "2021-02-08T19:53:28Z",
    "labels": [
      "question",
      "driver: postgres"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/6555",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[x] `postgres`\r\n[ ] `cockroachdb`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n\r\nI'd like to set postgres runtime variables for example: \r\n\r\n```SET app.config_a = 'a'```\r\nId like to make that configuration in a context of query execution but without using transaction and ```SET LOCAL```, and most important make it safe, so that when other app user send a request to the server the configuration will be sync with the authenticated app user triggered the query.\r\n\r\nWhat is the recommended way to do it? usually I prefer using BaseEntity API.\r\n\r\nI'd like to have something like this: \r\n```\r\n--- project.service.ts\r\n   import { getConnection } from 'typeorm';\r\n\r\n   async findOneById(id: number): Promise<Project> {\r\n----> Something like: getConnection().query(`SET app.config = $1;`, [thisUserConfig])\r\n        return await Project.findOne({ id });\r\n    }\r\n```",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/6555/comments",
    "author": "nosteiner",
    "comments": [
      {
        "user": "nosteiner",
        "created_at": "2021-02-08T19:53:28Z",
        "body": "The solution is to use `QueryRunner`, the relevant documentation added on #7351 "
      },
      {
        "user": "petmat",
        "created_at": "2021-05-24T08:23:44Z",
        "body": "Can you please clarify how `QueryRunner` is the solution? I don't see anything in the documentation about how to use `SET`."
      }
    ]
  },
  {
    "number": 6497,
    "title": "How to set AUTO_INCREMENT on Typeorm PrimaryGeneratedColumn?",
    "created_at": "2020-07-31T17:01:16Z",
    "closed_at": "2020-10-05T06:14:56Z",
    "labels": [
      "question",
      "driver: mysql",
      "driver: mariadb"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/6497",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[x] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[ ] `cockroachdb`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\nAs MySQL has AUTO_INCREMENT on id (primary key) column, so id can be start from, e.g, 100 by set AUTO_INCREMENT = 100. How to implement it on typeorm PrimaryGeneratedColumn?\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/6497/comments",
    "author": "juststartmeteor",
    "comments": [
      {
        "user": "rubiin",
        "created_at": "2020-08-05T16:27:56Z",
        "body": "As per the docs, `@PrimaryGeneratedColumn() creates a primary column which value will be automatically generated with an auto-increment value. It will create int column with auto-increment/serial/sequence (depend on the database). You don't have to manually assign its value before save - value will be automatically generated` . There is a mention of `depend on the database`. Also I have used postgres and mssql but havent encountered it. So maybe a db restriction or something"
      }
    ]
  },
  {
    "number": 6437,
    "title": "AfterInsert use dababase function (Postgresql)",
    "created_at": "2020-07-21T13:23:11Z",
    "closed_at": "2020-10-05T06:15:22Z",
    "labels": [
      "question",
      "driver: postgres"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/6437",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[x] `postgres`\r\n[ ] `cockroachdb`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[ ] `latest`\r\n[ ] `@next`\r\n[x] `0.2.24` \r\n\r\nI have an entity with two fields, content: type text and contentTSV type: tsvector, contentTSV is populate with content value tsvector.\r\n\r\nHow to use AfeterInsert for convert the content value to tsvector and populate field contentTSV?\r\n\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/6437/comments",
    "author": "pperesbr",
    "comments": [
      {
        "user": "imnotjames",
        "created_at": "2020-07-22T04:05:56Z",
        "body": "I don't think you need to do `@AfterInsert` - you'd want to update before performing the insert.\r\n\r\nBefore you insert you can assign the data from the `content` field into the `contentTSV` field."
      }
    ]
  },
  {
    "number": 6421,
    "title": "One To One Dependency cycle detected",
    "created_at": "2020-07-19T13:14:17Z",
    "closed_at": "2020-10-07T06:20:10Z",
    "labels": [
      "question",
      "driver: postgres"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/6421",
    "body": "**Issue type:**\r\n\r\n[ x ] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[x ] `postgres`\r\n[ ] `cockroachdb`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[x ] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\ni have two entity typeorm with one to one bi-directional:\r\n\r\n**Departament:**\r\n\r\n```\r\n@Entity('Departament')\r\nexport default class Departament {\r\n  @PrimaryGeneratedColumn()\r\n  id: string;\r\n\r\n  @Column()\r\n  departament_name: string;\r\n\r\n  @OneToOne(type => User, user => user.departament)\r\n  @JoinColumn()\r\n  user: User;\r\n\r\n  @CreateDateColumn({ name: 'created_at' })\r\n  createdAt: Date;\r\n\r\n  @UpdateDateColumn({ name: 'updated_at' })\r\n  UpdatedAt: Date;\r\n}\r\n```\r\n**User:**\r\n\r\n```\r\n@Entity('User')\r\nexport default class User {\r\n  @PrimaryGeneratedColumn()\r\n  id: string;\r\n\r\n  @Column()\r\n  name: string;\r\n\r\n  @Column()\r\n  last_name: string;\r\n\r\n  @Column()\r\n  email: string;\r\n\r\n  @Column()\r\n  login: string;\r\n\r\n  @Column()\r\n  password: string;\r\n\r\n  @OneToOne(type => Departament, departament => departament.user)\r\n  departament: Departament;\r\n}\r\n```\r\nand these are my .eslintrc settings:\r\n\r\n```\r\n{\r\n  \"env\": {\r\n    \"es6\": true,\r\n    \"node\": true,\r\n    \"jest\": true\r\n  },\r\n  \"extends\": [\r\n    \"airbnb-base\",\r\n    \"plugin:@typescript-eslint/recommended\",\r\n    \"prettier/@typescript-eslint\",\r\n    \"plugin:prettier/recommended\"\r\n  ],\r\n  \"globals\": {\r\n    \"Atomics\": \"readonly\",\r\n    \"SharedArrayBuffer\": \"readonly\"\r\n  },\r\n  \"parser\": \"@typescript-eslint/parser\",\r\n  \"parserOptions\": {\r\n    \"ecmaVersion\": 2018,\r\n    \"sourceType\": \"module\"\r\n  },\r\n  \"plugins\": [\"@typescript-eslint\", \"prettier\"],\r\n  \"rules\": {\r\n    \"prettier/prettier\": \"error\",\r\n    \"no-new\": \"off\",\r\n    \"no-underscore-dangle\": \"off\",\r\n    \"class-methods-use-this\": \"off\",\r\n    \"no-await-in-loop\": \"off\",\r\n    \"import/prefer-default-export\": \"off\",\r\n    \"import/extensions\": [\r\n      \"error\",\r\n      \"ignorePackages\",\r\n      {\r\n        \"ts\": \"never\"\r\n      }\r\n    ],\r\n    \"import/no-extraneous-dependencies\": [\r\n      \"error\",\r\n      {\r\n        \"devDependencies\": [\"**/*.spec.ts\", \"src/utils/tests/*.ts\"]\r\n      }\r\n    ],\r\n    \"no-useless-constructor\": \"off\",\r\n    \"@typescript-eslint/no-unused-vars\": [\r\n      \"error\",\r\n      {\r\n        \"argsIgnorePattern\": \"_\"\r\n      }\r\n    ],\r\n    \"@typescript-eslint/no-useless-constructor\": \"error\",\r\n    \"camelcase\": \"off\",\r\n    \"@typescript-eslint/camelcase\": \"off\"\r\n  },\r\n  \"overrides\": [\r\n    {\r\n      \"files\": [\"*.js\"],\r\n      \"rules\": {\r\n        \"@typescript-eslint/no-var-requires\": \"off\"\r\n      }\r\n    }\r\n  ],\r\n  \"settings\": {\r\n    \"import/extensions\": [\".ts\", \".js\"],\r\n    \"import/parsers\": {\r\n      \"@typescript-eslint/parser\": [\".ts\", \".js\"]\r\n    },\r\n    \"import/resolver\": {\r\n      \"typescript\": {\r\n        \"alwaysTryTypes\": true\r\n      }\r\n    }\r\n  }\r\n}\r\n```\r\ni got this errors:\r\n\r\ndependency cycle detected.eslintimport/no-cycle\r\n\r\non (user and departament)\r\n\r\nand:\r\n\r\n'type' is defined but never used. Allowed unused args must match /_/u.eslint@typescript-eslint/no-unused-vars\r\n\r\nI'm not able to solve this, and I don't know what is the best option to do, I'm following the getting started of typeorm",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/6421/comments",
    "author": "sptGabriel",
    "comments": [
      {
        "user": "imnotjames",
        "created_at": "2020-07-22T19:56:59Z",
        "body": "This is nothing to do with TypeORM and very much to do with your ESLint configuration.  If you completely removed the TypeORM decorators you'd still get this linting error.\r\n\r\nYou can always loosen up the eslint restrictions or perhaps add a disable before the import?\r\n\r\n```\r\n// eslint-disable-next-line import/no-cycle\r\n```"
      }
    ]
  },
  {
    "number": 6414,
    "title": "ErrorStack: QueryFailedError: Cannot enqueue Query after fatal error.",
    "created_at": "2020-07-17T06:51:52Z",
    "closed_at": "2021-07-04T17:54:45Z",
    "labels": [
      "question",
      "driver: mysql",
      "driver: mariadb"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/6414",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[x] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[ ] `cockroachdb`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[ ] `latest`\r\n[ ] `@next`\r\n[x] `0.2.21`\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\n1. I got this error when some query failed. Is this error handle inside typeorm?\r\n2. This error may cause this connection break. Should I createConnection manually?\r\n3. If this error repeat after 10(connect pool default connections) times. I will disconnect with mysql server until restart my application?\r\n\r\nThank you.\r\n\r\n```\r\nErrorStack: QueryFailedError: Cannot enqueue Query after fatal error.\r\n--\r\n  | Jul 17, 2020 @ 12:06:25.336 | at new QueryFailedError (/app/node_modules/typeorm/error/QueryFailedError.js:11:28)\r\n  | Jul 17, 2020 @ 12:06:25.336 | at Query.<anonymous> (/app/node_modules/typeorm/driver/mysql/MysqlQueryRunner.js:170:45)\r\n  | Jul 17, 2020 @ 12:06:25.336 | at Query.<anonymous> (/app/node_modules/mysql/lib/Connection.js:526:10)\r\n  | Jul 17, 2020 @ 12:06:25.336 | at Query._callback (/app/node_modules/mysql/lib/Connection.js:488:16)\r\n  | Jul 17, 2020 @ 12:06:25.336 | at Query.Sequence.end (/app/node_modules/mysql/lib/protocol/sequences/Sequence.js:83:24)\r\n  | Jul 17, 2020 @ 12:06:25.336 | at /app/node_modules/mysql/lib/protocol/Protocol.js:236:14\r\n  | Jul 17, 2020 @ 12:06:25.336 | at process._tickCallback (internal/process/next_tick.js:61:11)\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/6414/comments",
    "author": "woolson",
    "comments": [
      {
        "user": "imnotjames",
        "created_at": "2020-08-10T02:38:42Z",
        "body": "1. This is a MySQL node module error, not TypeORM.\r\n2. This error means that the connection must be restarted.\r\n3. Not sure I understand what you're mean here.  Are you trying to reconnect after a fatal error to clear up the error?"
      },
      {
        "user": "woolson",
        "created_at": "2020-08-10T03:07:31Z",
        "body": "**1. I mean Should it be handled inside TypeORM.**\r\n2. You are right.\r\n3. You can ignore this question. Sorry!\r\n\r\nIn general, Should TypeORM restart the connection when the error happened？Because of \bTypeORM manage connections.\r\n\r\n@imnotjames Thank you for your replay.😃"
      },
      {
        "user": "imnotjames",
        "created_at": "2020-10-08T20:15:44Z",
        "body": "Maybe related - #2666"
      },
      {
        "user": "imnotjames",
        "created_at": "2021-07-04T17:54:09Z",
        "body": "> **1. I mean Should it be handled inside TypeORM.**\r\n> 2. You are right.\r\n> 3. You can ignore this question. Sorry!\r\n> \r\n> In general, Should TypeORM restart the connection when the error happened？Because of �TypeORM manage connections.\r\n> \r\n> @imnotjames Thank you for your replay.😃\r\n\r\nI believe you just need to release this query runner."
      },
      {
        "user": "imnotjames",
        "created_at": "2021-07-04T17:54:45Z",
        "body": "Closing as duplicate of #2666 otherwise"
      }
    ]
  },
  {
    "number": 6403,
    "title": "Does TypeORM have a way to perform bulk updates?",
    "created_at": "2020-07-14T21:22:38Z",
    "closed_at": "2020-10-07T06:09:50Z",
    "labels": [
      "question",
      "driver: postgres"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/6403",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[x] `postgres`\r\n[ ] `cockroachdb`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\nDoes TypeORM have a way to perform bulk updates?\r\n\r\nI'd like to update multiple records at a time, like repository.update([item1, item2, item3]). Is this possible without resorting to createQueryBuilder()?",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/6403/comments",
    "author": "jaequery",
    "comments": [
      {
        "user": "rubiin",
        "created_at": "2020-07-16T20:02:03Z",
        "body": "I have left a comment on your latest. please close this one"
      }
    ]
  },
  {
    "number": 6387,
    "title": "Unable to run migration using Docker Postgres (ENOTFOUND)",
    "created_at": "2020-07-11T16:41:53Z",
    "closed_at": "2020-10-07T03:56:03Z",
    "labels": [
      "question",
      "comp: migrations",
      "driver: postgres"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/6387",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[x] `postgres`\r\n[ ] `cockroachdb`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\nIm unable to run any migration using docker-compose + postgres setup. Giving the error:\r\n\r\n`PS C:\\_dev\\RM_EletroMec\\backend> npx typeorm migration:run\r\nError during migration run:\r\n    at GetAddrInfoReqWrap.onlookup [as oncomplete] (dns.js:66:26) {\r\n  errno: 'ENOTFOUND',\r\n  code: 'ENOTFOUND',\r\n  syscall: 'getaddrinfo',\r\n  hostname: 'postgres'\r\n}`\r\n\r\ndocker-compose.yml:\r\n\r\n`version: \"3\"\r\n\r\nservices:\r\n  app:\r\n    build: .\r\n    command: npm run dev\r\n    ports:\r\n      - \"3000:3000\"\r\n    volumes:\r\n      - .:/usr/app\r\n    depends_on:\r\n      - database\r\n    networks:\r\n      - default\r\n\r\n  database:\r\n    image: postgres\r\n    environment:\r\n      POSTGRES_USER: \"postgres\"\r\n      POSTGRES_PASSWORD: \"postgres\"\r\n      POSTGRES_DB: \"rm_eletromec\"\r\n      PGDATA: /tmp\r\n      TZ: \"GMT-3\"\r\n      PGTZ: \"GMT-3\"\r\n    volumes:\r\n      - ./postgres:/var/lib/postgresql/data\r\n    ports:\r\n      - 5432:5432\r\n    networks:\r\n      - default\r\n\r\n  pgweb:\r\n    image: sosedoff/pgweb\r\n    ports:\r\n      - \"8081:8081\"\r\n    environment:\r\n      - DATABASE_URL=postgres://postgres:postgres@postgres:5432/rm_eletromec?sslmode=disable\r\n    depends_on:\r\n      - database\r\n    networks:\r\n      - default\r\n`\r\n\r\normconfig.json:\r\n\r\n`{\r\n  \"type\": \"postgres\",\r\n  \"host\": \"database\",\r\n  \"port\": 5432,\r\n  \"username\": \"postgres\",\r\n  \"password\": \"postgres\",\r\n  \"database\": \"rm_eletromec\",\r\n  \"entities\": [\"src/app/models/*.ts\"],\r\n  \"migrations\": [\"src/database/migrations/*.ts\"],\r\n  \"cli\": { \"migrationsDir\": \"src/database/migrations/\" }\r\n}`\r\n\r\n`OBS: On app startup, i'm sucessfully connecting with database`\r\n\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/6387/comments",
    "author": "medeiroshudson",
    "comments": [
      {
        "user": "asomethings",
        "created_at": "2020-07-14T06:10:58Z",
        "body": "You'll have to execute command inside the container since 'postges' will only be available inside docker containers. \r\n\r\nIf you want to connect it outside of the container, you should change DATABASE_URL to `postgres://postgres:postgres@127.0.0.1:5432/rm_eletromec?sslmode=disable`"
      }
    ]
  },
  {
    "number": 6386,
    "title": "When trying to run the tests, connecting to PostgreSQL seems to fail",
    "created_at": "2020-07-11T09:25:57Z",
    "closed_at": "2020-10-06T05:25:19Z",
    "labels": [
      "bug",
      "question",
      "driver: postgres"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/6386",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[x] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[x] `postgres`\r\n[ ] `cockroachdb`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\nI'm trying to run the TypeORM tests locally. I'm using the Docker images to run all the databases by simply running:\r\n\r\n```\r\ndocker-compose up\r\n```\r\n\r\nI copied `ormconfig.json.dist` to `ormconfig.json` and then I run:\r\n\r\n```\r\nnpm run compile ; npm run test\r\n```\r\n\r\nIt crashes with this error:\r\n\r\n```\r\n> npm run compile ; npm run test\r\n\r\n> typeorm@0.2.25 compile C:\\Users\\pupeno\\Documents\\Flexpoint Tech\\js\\typeorm\r\n> rimraf ./build && tsc\r\n\r\n\r\n> typeorm@0.2.25 test C:\\Users\\pupeno\\Documents\\Flexpoint Tech\\js\\typeorm\r\n> rimraf ./build && tsc && mocha --file ./build/compiled/test/utils/test-setup.js --bail --recursive --timeout 60000 ./build/compiled/test\r\n\r\n\r\n\r\n  √ github issues > #3158 Cannot run sync a second time (475ms)\r\n  √ github issues > #3588 Migration:generate issue with onUpdate using mysql 8.0 (116ms)\r\n  benchmark > bulk-save > case1\r\nconnecting\r\n    1) \"before all\" hook for \"testing bulk save of 10.000 objects\"\r\n    2) \"after all\" hook for \"testing bulk save of 10.000 objects\"\r\n\r\n\r\n  2 passing (1m)\r\n  2 failing\r\n\r\n  1) benchmark > bulk-save > case1\r\n       \"before all\" hook for \"testing bulk save of 10.000 objects\":\r\n     Error: Timeout of 60000ms exceeded. For async tests and hooks, ensure \"done()\" is called; if returning a Promise, ensure it resolves. (C:\\Users\\pupeno\\Documents\\Flexpoint Tech\\js\\typeorm\\build\\compiled\\test\\benchmark\\bulk-save-case1\\bulk-save-case1.js)\r\n      at listOnTimeout (internal/timers.js:551:17)\r\n      at processTimers (internal/timers.js:494:7)\r\n\r\n  2) benchmark > bulk-save > case1\r\n       \"after all\" hook for \"testing bulk save of 10.000 objects\":\r\n     TypeError: Cannot read property 'map' of undefined\r\n      at Object.closeTestingConnections (test\\utils\\test-utils.ts:285:36)\r\n      at Context.<anonymous> (test\\benchmark\\bulk-save-case1\\bulk-save-case1.ts:16:17)\r\n      at processImmediate (internal/timers.js:458:21)\r\n\r\n\r\n\r\nnpm ERR! code ELIFECYCLE\r\nnpm ERR! errno 2\r\nnpm ERR! typeorm@0.2.25 test: `rimraf ./build && tsc && mocha --file ./build/compiled/test/utils/test-setup.js --bail --recursive --timeout 60000 ./build/compiled/test`\r\nnpm ERR! Exit status 2\r\nnpm ERR!\r\nnpm ERR! Failed at the typeorm@0.2.25 test script.\r\nnpm ERR! This is probably not a problem with npm. There is likely additional logging output above.\r\n\r\nnpm ERR! A complete log of this run can be found in:\r\nnpm ERR!     C:\\Users\\pupeno\\scoop\\persist\\nodejs\\cache\\_logs\\2020-07-11T09_15_28_115Z-debug.log\r\n```\r\n\r\nTrying to debug what's going on, as far as I can see, it times out when connecting to the PostgreSQL database, but the other databases seem to work and connecting with my PSQL client (DataGrip) using the same credentials as in `ormconfig.json` also works.\r\n\r\nI'm not sure if this is a bug or a question. Any ideas what's going on here?",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/6386/comments",
    "author": "pupeno",
    "comments": [
      {
        "user": "pupeno",
        "created_at": "2020-07-11T09:45:39Z",
        "body": "I have also tried connecting to my locally running PostgreSQL, created a user with appropriate username and password and a database. My own project connects fine to that PostgreSQL, but I can't get the TypeORM tests to connect."
      },
      {
        "user": "imnotjames",
        "created_at": "2020-09-29T19:50:16Z",
        "body": "What version of Postgres is installed?"
      },
      {
        "user": "imnotjames",
        "created_at": "2020-10-06T05:25:19Z",
        "body": "Usually this is because you're using an old version of postgres for the tests.  If this isn't the case, let's reopen."
      }
    ]
  },
  {
    "number": 6373,
    "title": "Queries executed outside the transaction",
    "created_at": "2020-07-09T09:30:01Z",
    "closed_at": "2020-10-06T05:27:59Z",
    "labels": [
      "bug",
      "question",
      "driver: postgres"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/6373",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[x] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[x] `postgres`\r\n[ ] `cockroachdb`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\nBy Using createQueryBuilder, my code is executed outside my current transaction and can't read uncommited data\r\n\r\nCould you explain to me why this is executed inside my transaction\r\n\r\n    let candidatInMyTx: CandidateFileEntity = await  candidateService.getRepo().manager\r\n    .query(\"SELECT * FROM \\\"candidate_files\\\" \\\"candidateFile\\\" WHERE \\\"candidateFile\\\".\\\"candidateId\\\" IN ($1)\",[c1.id])\r\n\r\n\r\nGenerated query:\r\n\r\n        SELECT * FROM \"candidate_files\" \"candidateFile\" WHERE \"candidateFile\".\"candidateId\" IN ($1) -- PARAMETERS: [\"f20a984d-3018-4cef-a5b6-a6c3c2480728\"]\r\n\r\nand this is executed outside (so return nothing) it works if I do a commit before:\r\n\r\n            let candidatOutsideMyTx: CandidateFileEntity =\r\n            await candidateService.getRepo().manager.createQueryBuilder()\r\n            .relation(CandidateEntity,'candidateFile')\r\n            .of(c1).loadOne()\r\n\r\nThis code is wrapped with\r\n  \r\n      runner = getManager().connection.createQueryRunner()\r\n      transaction = await runner.startTransaction()\r\n      entityManager = runner.manager\r\n       candidateFilesService.getRepo().manager = entityManager\r\n\r\n\r\nGenerated query:\r\n\r\n\r\n                  SELECT \"candidateFile\".\"version\" AS \"candidateFile_version\", \"candidateFile\".\"updated_at\" AS \"candidateFile_updated_at\", \"candidateFile\".\"created_at\" AS \"candidateFile_created_at\", \"candidateFile\".\"id\" AS \"candidateFile_id\", \"candidateFile\".\"status\" AS \"candidateFile_status\", \"candidateFile\".\"candidateId\" AS \"candidateFile_candidateId\" FROM \"candidate_files\" \"candidateFile\" WHERE \"candidateFile\".\"candidateId\" IN ($1) -- PARAMETERS: [\"f20a984d-3018-4cef-a5b6-a6c3c2480728\"]\r\n\r\n\r\nWhy using the manager inside the Repository execute the query outside the transaction?\r\n\r\nDo I have a way to log the queries with the transaction id?",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/6373/comments",
    "author": "fstn",
    "comments": [
      {
        "user": "imnotjames",
        "created_at": "2020-10-06T05:27:59Z",
        "body": "You have to work using the same query runner to use the same transaction."
      }
    ]
  },
  {
    "number": 6362,
    "title": "Include \"select: false\" fields in call to \"find\" without having to select every single column",
    "created_at": "2020-07-07T13:19:13Z",
    "closed_at": "2020-10-27T08:33:45Z",
    "labels": [
      "question",
      "driver: postgres"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/6362",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[x] `postgres`\r\n[ ] `cockroachdb`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\nI have an object with a field that can be pretty large and for that reason I don't want to include it in queries and be returned most of the time.\r\n\r\nSelecting the field when calling `findOne` like this does work and all the fields plus the selected field is returned:\r\n```ts\r\npublic findOfferById(id: string, options?: FindOfferOptions): Promise<Offer | undefined> {\r\n  const findOneOptions: FindOneOptions<Offer> = {\r\n    relations: [],\r\n    select: []\r\n  };\r\n\r\n  if (options) {\r\n    if (options.withProducts) {\r\n      findOneOptions.relations.push(\"products\");\r\n    }\r\n\r\n    if (options.withComments) {\r\n      findOneOptions.relations.push(\"comments\");\r\n    }\r\n\r\n    if (options.withSeller) {\r\n      findOneOptions.relations.push(\"seller\");\r\n    }\r\n\r\n    if (options.withImages) {\r\n      findOneOptions.relations.push(\"images\");\r\n    }\r\n\r\n    if (options.withDescription) {\r\n      findOneOptions.select.push(\"description\");\r\n    }\r\n  }\r\n\r\n  return this.repository.findOne(id, findOneOptions);\r\n}\r\n```\r\n\r\nBut trying to return multiple records like this with `find` does not have the same behavior, only returning the selected field:\r\n```ts\r\n    const options: FindManyOptions<Offer> = {\r\n      where: {\r\n        sellerId: user.id\r\n      },\r\n      relations: [],\r\n      select: []\r\n    };\r\n\r\n    if (query.withImages) {\r\n      options.relations.push(\"images\");\r\n    }\r\n\r\n    if (query.withProducts) {\r\n      options.relations.push(\"products\");\r\n    }\r\n\r\n    if (!query.includeInactive) {\r\n      const where = options.where as FindConditions<Offer>;\r\n      where.isActive = true;\r\n    }\r\n\r\n    if (query.withDescription) {\r\n      options.select.push(\"description\");\r\n    }\r\n\r\n    const offers = await this.repository.find(options);\r\n```\r\n\r\nIs there a way I can also select that field without having to also select all of the fields in the entity?",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/6362/comments",
    "author": "gkovalechyn",
    "comments": [
      {
        "user": "imnotjames",
        "created_at": "2020-10-27T08:33:43Z",
        "body": "There's currently no way to get around selecting fields explicitly if you select at least one field."
      }
    ]
  },
  {
    "number": 6326,
    "title": "CHECK constraint failed with SQLite and simple-enum array",
    "created_at": "2020-06-29T11:01:32Z",
    "closed_at": "2021-06-25T02:46:34Z",
    "labels": [
      "question",
      "needs more info",
      "driver: sqlite"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/6326",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[ ] `cockroachdb`\r\n[x] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nHi,\r\n\r\nWhen trying to use a simple-enum array as a column type with SQLite 3.22.0 and TypeORM 0.2.25, I get an SQL_CONSTRAINT CHECK error:\r\n\r\n```\r\n QueryFailedError: SQLITE_CONSTRAINT: CHECK constraint failed: user\r\n    at new QueryFailedError (/path/node_modules/typeorm/error/QueryFailedError.js:11:28)\r\n    at Statement.handler (/path/node_modules/typeorm/driver/sqlite/SqliteQueryRunner.js:48:38) {\r\n  errno: 19,\r\n  code: 'SQLITE_CONSTRAINT',\r\n  query: 'INSERT INTO \"user\"(\"id\", \"username\", \"password\", \"email\", \"roles\", \"support\") VALUES (NULL, ?, ?, ?, ?, ?)',\r\n  parameters: [\r\n    'admin',\r\n    'xxx',\r\n    'bla@bla.com',\r\n    '0,1',\r\n    1\r\n  ]\r\n}\r\n```\r\n\r\nThe enum column in my entity:\r\n\r\n```\r\n    @Column({\r\n        type: 'simple-enum',\r\n        enum: UserRole,\r\n        array: true,\r\n        nullable: false\r\n      })\r\n    roles: UserRole[];\r\n```\r\n\r\nThe UserRole type:\r\n\r\n```\r\nexport enum UserRole {\r\n    ADMIN,\r\n    DEVELOPER,\r\n    USER,\r\n}\r\n```\r\n\r\nThe code I use to instantiate an user:\r\n\r\n```\r\nthis.create({\r\n            username: 'admin',\r\n            password: 'xxx',\r\n            email: 'bla@bla.com',\r\n            roles: [UserRole.ADMIN, UserRole.DEVELOPER],\r\n            support: true\r\n        })\r\n```\r\n\r\nDid I miss something?\r\n\r\nNote: if I put one value only in the roles array during instantiation, the new user is indeed created.\r\n\r\nThanks!",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/6326/comments",
    "author": "khannurien",
    "comments": [
      {
        "user": "imnotjames",
        "created_at": "2020-10-12T19:01:07Z",
        "body": "What is the DDL of your table?\r\n\r\nCan you create a reproducible example as a repo or as a test in a PR that we can use for verifying this erroneous behavior?"
      },
      {
        "user": "imnotjames",
        "created_at": "2021-06-25T02:46:34Z",
        "body": "When opening an issue, people will be better able to provide help if you provide code that they can easily understand and use to reproduce the problem. This boils down to ensuring your code that reproduces the problem follows the following guidelines:\r\n\r\n* Minimal – Use as little code as possible that still produces the same problem\r\n* Complete – Provide all parts someone else needs to reproduce your problem in the question itself\r\n* Reproducible – Test the code you're about to provide to make sure it reproduces the problem\r\n\r\n## Minimal\r\nThe more code there is to go through, the less likely people can find your problem. Streamline your example in one of two ways:\r\n\r\n1. Restart from scratch. Create a new program, adding in only what is needed to see the problem. Use simple, descriptive names for functions and variables – don’t copy the names you’re using in your existing code.\r\n2. Divide and conquer. If you’re not sure what the source of the problem is, start removing code a bit at a time until the problem disappears – then add the last part back.\r\n\r\nDon't sacrifice clarity for brevity when creating a minimal example. Use consistent naming and indentation, and include code comments if needed. Use your code editor’s shortcut for formatting code.\r\n\r\nDon't include any passwords or credentials that must be kept secret.\r\n\r\n## Complete\r\n\r\nMake sure all information necessary to reproduce the problem is included in the issue itself.\r\n\r\nIf the problem requires some code as well as some XML-based configuration, include code for both. The problem might not be in the code that you think it is in.\r\n\r\nUse individual code blocks for each file or snippet you include. Provide a description for the purpose of each block.\r\n\r\n**DO NOT** use images of code. Copy the actual text from your code editor, paste it into the issus, then format it as code. This helps others more easily read and test your code.\r\n\r\n## Reproducible\r\n\r\nTo help you solve your problem, others will need to verify that it exists.\r\n\r\nDescribe the problem. \"It doesn't work\" isn't descriptive enough to help people understand your problem. Instead, tell other readers what the expected behavior should be. Tell other readers what the exact wording of the error message is, and which line of code is producing it. Use a brief but descriptive summary of your problem as the title of your question.\r\n\r\nEliminate any issues that aren't relevant to the problem. If your question isn’t about a compiler error, ensure that there are no compile-time errors.\r\n\r\nDouble-check that your example reproduces the problem! If you inadvertently fixed the problem while composing the example but didn't test it again, you'd want to know that before asking someone else to help."
      }
    ]
  },
  {
    "number": 6296,
    "title": "OracleDB 11 not compatible with FETCH",
    "created_at": "2020-06-23T14:30:31Z",
    "closed_at": "2020-10-05T06:16:15Z",
    "labels": [
      "question",
      "new feature",
      "driver: oracle"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/6296",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[ ] bug report\r\n[x] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[x] `oracle`\r\n[ ] `postgres`\r\n[ ] `cockroachdb`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\n1.Install oracle database 11.2\r\n\r\n2. Create a query using Entity.findOne()\r\n\r\n3.The query that is created contains FETCH instruction wich is not supported until oracle database 12\r\n\r\n\r\n\r\nIs there anyway to tell typeorm that the version or oracle db is 11 so it build the query in another way?\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/6296/comments",
    "author": "joselicht90",
    "comments": [
      {
        "user": "imnotjames",
        "created_at": "2020-08-27T09:25:28Z",
        "body": "TypeORM only supports Oracle 12+ at this time.  I've tested this a few different ways, there's a lot that's not working with oracle 11"
      }
    ]
  },
  {
    "number": 6240,
    "title": "Transactions do not work",
    "created_at": "2020-06-10T17:42:01Z",
    "closed_at": "2020-10-05T06:19:06Z",
    "labels": [
      "question",
      "driver: postgres"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/6240",
    "body": "**Issue type:**\r\n\r\n[ x ] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ x ] `postgres`\r\n[ ] `cockroachdb`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[ x ] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nI have a function that executes some kind of logic\r\n```\r\nasync function handle() {\r\n  const connection = getConnection()\r\n  const queryRunner = connection.createQueryRunner()\r\n  await queryRunner.connect()\r\n  await queryRunner.startTransaction()\r\n  try {\r\n    /* ... */\r\n    /* Logic */\r\n    /* ... */\r\n    const amount = 29\r\n    const user = await queryRunner.manager.findOne(UsersEntity, { where: { id: userId } })\r\n    console.log(user.balance)\r\n    user.balance -= amount\r\n\r\n    await queryRunner.manager.save(user)\r\n\r\n    await queryRunner.commitTransaction()\r\n\r\n    return result\r\n  } catch (e) {\r\n    await queryRunner.rollbackTransaction()\r\n    console.log(e)\r\n  } finally {\r\n    await queryRunner.release()\r\n  }\r\n}\r\n```\r\nIf you execute this function with a loop\r\n```\r\nfor(let i = 0; i < 10; ++i) {\r\n  handle()\r\n}\r\n/* RESULT (change of balance) */\r\n/*\r\n3234683\r\n3234683\r\n3234683\r\n3234683\r\n3234683\r\n3234683\r\n3234654\r\n3234654\r\n3234654\r\n3234654\r\n*/\r\n```",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/6240/comments",
    "author": "red1ng",
    "comments": [
      {
        "user": "mmartinson",
        "created_at": "2020-06-20T00:44:56Z",
        "body": "spicy. you have any SQL logs?"
      },
      {
        "user": "red1ng",
        "created_at": "2020-06-20T01:19:22Z",
        "body": "I solved the problem by replacing\r\n```\r\nconst user = await queryRunner.manager.findOne(UsersEntity, { where: { id: userId } })\r\n```\r\non\r\n```\r\nconst user = await queryRunner.manager\r\n        .getRepository(UsersEntity)\r\n        .createQueryBuilder()\r\n        .useTransaction(true)\r\n        .setLock('pessimistic_write')\r\n        .where('id = :userid', {userid: userId})\r\n        .getOne()\r\n```"
      }
    ]
  },
  {
    "number": 6158,
    "title": "Raw sql always return an empty array",
    "created_at": "2020-05-29T15:22:09Z",
    "closed_at": "2020-10-04T13:46:21Z",
    "labels": [
      "question",
      "driver: postgres"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/6158",
    "body": "**Issue type:**\r\n\r\n[x ] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[x ] `postgres`\r\n[ ] `cockroachdb`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[x ] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n```json\r\n    \"typeorm\": \"0.2.25\"\r\n```\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nThat's what I do in the controller\r\n```ts\r\nconst response = await HistoryClientStoreFavorite.query(\r\n   'select reason, count(reason) * 100 / (select count(*) from history_client_store_favorite where store_from_id = $1) as total  from history_client_store_favorite where store_from_id = $1 group by reason;',\r\n      [id]\r\n )\r\n\r\nconsole.log(response)\r\n```\r\nThat's my entity\r\n```ts\r\nimport {\r\n  Entity,\r\n  BaseEntity,\r\n  PrimaryGeneratedColumn,\r\n  Column,\r\n  CreateDateColumn,\r\n  UpdateDateColumn,\r\n  ManyToOne,\r\n  JoinColumn\r\n} from 'typeorm'\r\nimport { Store } from './Store'\r\nimport { Clients } from './Clients'\r\n\r\n@Entity()\r\nexport class HistoryClientStoreFavorite extends BaseEntity {\r\n  @PrimaryGeneratedColumn()\r\n  id: number\r\n\r\n  @Column({ nullable: false })\r\n  client_id: number\r\n\r\n  @Column({ nullable: false })\r\n  store_from_id: number\r\n\r\n  @Column({ nullable: false })\r\n  store_to_id: number\r\n\r\n  @Column({ nullable: false })\r\n  reason: string\r\n\r\n  @ManyToOne(() => Clients, client => client.historyClientStoreFavorite)\r\n  @JoinColumn({ name: 'client_id' })\r\n  clientConnection: Promise<Store>\r\n\r\n  @ManyToOne(() => Store, store => store.historyFromClientStoreFavorite)\r\n  @JoinColumn({ name: 'store_from_id' })\r\n  storeFromConnection: Promise<Store>\r\n\r\n  @ManyToOne(() => Store, store => store.historyToClientStoreFavorite)\r\n  @JoinColumn({ name: 'store_to_id' })\r\n  storeToConnection: Promise<Store>\r\n\r\n  @CreateDateColumn()\r\n  created_at: Date\r\n\r\n  @UpdateDateColumn()\r\n  updated_at: Date\r\n}\r\n```\r\n\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/6158/comments",
    "author": "ghost",
    "comments": [
      {
        "user": "imnotjames",
        "created_at": "2020-10-01T05:24:53Z",
        "body": "And when you run that query manually you receive records?"
      },
      {
        "user": "ghost",
        "created_at": "2020-10-04T13:46:21Z",
        "body": "I no longer work on that project so I don't have enough material to help on the issue, because of that I'll close this issue, if someone have the same project and want to reopen, all good "
      }
    ]
  },
  {
    "number": 6154,
    "title": "Existing columns are altered and reordered",
    "created_at": "2020-05-29T10:22:52Z",
    "closed_at": "2020-10-17T08:47:18Z",
    "labels": [
      "question",
      "comp: schema sync"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/6154",
    "body": "First of all thank you very much for this awesome library.\r\n\r\n**Issue type:**\r\n\r\n[*] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[*] `mysql`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[ ] `cockroachdb`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[ ] `latest`\r\n[ ] `@next`\r\n[*] `0.2.22`\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\n1. When the table does not exist in the DB the backend creates it:\r\n```\r\nCREATE TABLE `at_variable` (\r\n  `id_version` int(11) NOT NULL,\r\n  `id_variable` int(11) NOT NULL AUTO_INCREMENT,\r\n  `retain` int(1) NOT NULL DEFAULT 0,\r\n  `io` int(1) NOT NULL DEFAULT 0,\r\n  `protocol` int(1) NOT NULL DEFAULT 0,\r\n  `log` int(1) NOT NULL DEFAULT 0,\r\n  `uom` varchar(50) NOT NULL,\r\n    INDEX `retain` (`retain`),\r\n    INDEX `io` (`io`),\r\n    INDEX `protocol` (`protocol`),\r\n    INDEX `log` (`log`),\r\n    PRIMARY KEY (`id_variable`)) ENGINE=InnoDB\r\n```\r\n2. however, when I create manually the table with:\r\n```\r\nCREATE TABLE `at_variable` (\r\n`id_version` int(11) NOT NULL,\r\n`id_variable` int(11) NOT NULL AUTO_INCREMENT,\r\n`retain` tinyint(1) NOT NULL DEFAULT '0',\r\n`io` tinyint(1) NOT NULL DEFAULT '0',\r\n`protocol` tinyint(1) NOT NULL DEFAULT '0',\r\n`log` tinyint(1) NOT NULL DEFAULT '0',\r\n`uom` varchar(50) NOT NULL,\r\n  PRIMARY KEY (`id_variable`),\r\n  KEY `retain` (`retain`),\r\n  KEY `io` (`io`),\r\n  KEY `protocol` (`protocol`),\r\n  KEY `log` (`log`)\r\n) ENGINE=InnoDB AUTO_INCREMENT=35630 DEFAULT CHARSET=latin1;\r\n```\r\n3. Then I launch my server, a bunch of ```ALTER``` instructions are sent:\r\n```\r\nquery: DROP INDEX `retain` ON `at_variable`\r\nquery: ALTER TABLE `at_variable` DROP COLUMN `retain`\r\nquery: ALTER TABLE `at_variable` ADD `retain` int(1) NOT NULL DEFAULT 0\r\nquery: DROP INDEX `io` ON `at_variable`\r\nquery: ALTER TABLE `at_variable` DROP COLUMN `io`\r\nquery: ALTER TABLE `at_variable` ADD `io` int(1) NOT NULL DEFAULT 0\r\nquery: DROP INDEX `protocol` ON `at_variable`\r\nquery: ALTER TABLE `at_variable` DROP COLUMN `protocol`\r\nquery: ALTER TABLE `at_variable` ADD `protocol` int(1) NOT NULL DEFAULT 0\r\nquery: DROP INDEX `log` ON `at_variable`\r\nquery: ALTER TABLE `at_variable` DROP COLUMN `log`\r\nquery: ALTER TABLE `at_variable` ADD `log` int(1) NOT NULL DEFAULT 0\r\nquery: CREATE INDEX `retain` ON `at_variable` (`retain`)\r\nquery: CREATE INDEX `io` ON `at_variable` (`io`)\r\nquery: CREATE INDEX `protocol` ON `at_variable` (`protocol`)\r\nquery: CREATE INDEX `log` ON `at_variable` (`log`)\r\n```\r\nthese ALTER instructions are changing the columns order. Why are they happening?\r\nAm I missing something?\r\nThanks",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/6154/comments",
    "author": "maalej",
    "comments": [
      {
        "user": "imnotjames",
        "created_at": "2020-10-17T08:47:18Z",
        "body": "If you want to have more control over your schema: Turn off synchronize on the connection.\r\n\r\n\r\nThere's a number of things that it can't detect yet & has problems with.  If you check for issues with the label schema sync you'll find them."
      }
    ]
  },
  {
    "number": 6116,
    "title": "how to reconnect after disconnect",
    "created_at": "2020-05-22T10:49:13Z",
    "closed_at": "2020-10-09T20:47:32Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/6116",
    "body": "**Issue type:**\r\n[ x ] question\r\n\r\n**Database system/driver:**\r\n[ x ] `mysql`\r\n\r\n**TypeORM version:**\r\n[ x ] `0.2.24`\r\n\r\n** how to reconnect after disconnect **\r\nUnexpected disconnection\r\n\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/6116/comments",
    "author": "arrebole",
    "comments": [
      {
        "user": "FlorianPfisterer",
        "created_at": "2020-05-25T13:18:37Z",
        "body": "Adding some info: When the database server goes down, I receive \"POOL_NOEXIST\" errors each time a `getConnection()` call is done. When it comes back up again, this behavior does not change. The server needs to be manually restarted.\r\nHow can one trigger the reconnection try after such errors?"
      },
      {
        "user": "j3bb9z",
        "created_at": "2020-09-30T21:41:09Z",
        "body": "The same problem with destroyed pool (slightly different message) occurs with mongodb."
      },
      {
        "user": "imnotjames",
        "created_at": "2020-10-09T20:47:32Z",
        "body": "This issue was first but because the other has more information\r\n\r\nClosing as Duplicate of #6350"
      }
    ]
  },
  {
    "number": 6091,
    "title": "Is it possible to pass LIKE operation to FindOptions as JSON?",
    "created_at": "2020-05-19T06:17:18Z",
    "closed_at": "2020-10-03T04:41:35Z",
    "labels": [
      "question",
      "driver: postgres"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/6091",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[x] `postgres`\r\n[ ] `cockroachdb`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nI want to pass in FindOpts to perform a Like query, preferably like this but i can't:\r\n\r\n```\r\nconst opts = {\r\n  where: {\r\n    name:  { like: \"%j%\" }\r\n  }\r\n}\r\nthis.userRepository.find(opts);\r\n```\r\n\r\ni know you can use \"Like\":\r\n```\r\nimport {Like} from \"typeorm\";\r\nthis.someRepository.find({ name: Like(\"%j%\") })\r\n```\r\n\r\nbut, i want the like query to be passed in as a plain JSON.\r\nanyone know if there's a way?\r\n\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/6091/comments",
    "author": "jaequery",
    "comments": [
      {
        "user": "imnotjames",
        "created_at": "2020-10-03T04:41:34Z",
        "body": "This is not currently possible but might be in the next minor release (0.3.0)"
      }
    ]
  },
  {
    "number": 6086,
    "title": "Typeorm migration:generate not generating \"CREATE TYPE\" query for enum columns",
    "created_at": "2020-05-18T09:03:32Z",
    "closed_at": "2021-06-25T03:15:03Z",
    "labels": [
      "question",
      "needs more info",
      "can be closed?",
      "comp: migrations",
      "driver: postgres"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/6086",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[x] `postgres`\r\n[ ] `cockroachdb`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nJust noticed that whenever I try to generate a migration using typeorm migration:generate, if there are enum columns on my entites I dont see a \"CREATE TYPE\" query generated in the migration? This gives me an error that the enum type does not exist. However, if I were to add or remove a new enum entry and generate another migration, I see the query to create the type and alter it.\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/6086/comments",
    "author": "DanjBethel",
    "comments": [
      {
        "user": "imnotjames",
        "created_at": "2020-10-15T06:43:15Z",
        "body": "When opening an issue, people will be better able to provide help if you provide code that they can easily understand and use to reproduce the problem. This boils down to ensuring your code that reproduces the problem follows the following guidelines:\r\n\r\n* Minimal – Use as little code as possible that still produces the same problem\r\n* Complete – Provide all parts someone else needs to reproduce your problem in the question itself\r\n* Reproducible – Test the code you're about to provide to make sure it reproduces the problem\r\n\r\n## Minimal\r\nThe more code there is to go through, the less likely people can find your problem. Streamline your example in one of two ways:\r\n\r\n1. Restart from scratch. Create a new program, adding in only what is needed to see the problem. Use simple, descriptive names for functions and variables – don’t copy the names you’re using in your existing code.\r\n2. Divide and conquer. If you’re not sure what the source of the problem is, start removing code a bit at a time until the problem disappears – then add the last part back.\r\n\r\nDon't sacrifice clarity for brevity when creating a minimal example. Use consistent naming and indentation, and include code comments if needed. Use your code editor’s shortcut for formatting code.\r\n\r\nDon't include any passwords or credentials that must be kept secret.\r\n\r\n## Complete\r\n\r\nMake sure all information necessary to reproduce the problem is included in the issue itself.\r\n\r\nIf the problem requires some code as well as some XML-based configuration, include code for both. The problem might not be in the code that you think it is in.\r\n\r\nUse individual code blocks for each file or snippet you include. Provide a description for the purpose of each block.\r\n\r\n**DO NOT** use images of code. Copy the actual text from your code editor, paste it into the issus, then format it as code. This helps others more easily read and test your code.\r\n\r\n## Reproducible\r\n\r\nTo help you solve your problem, others will need to verify that it exists.\r\n\r\nDescribe the problem. \"It doesn't work\" isn't descriptive enough to help people understand your problem. Instead, tell other readers what the expected behavior should be. Tell other readers what the exact wording of the error message is, and which line of code is producing it. Use a brief but descriptive summary of your problem as the title of your question.\r\n\r\nEliminate any issues that aren't relevant to the problem. If your question isn’t about a compiler error, ensure that there are no compile-time errors.\r\n\r\nDouble-check that your example reproduces the problem! If you inadvertently fixed the problem while composing the example but didn't test it again, you'd want to know that before asking someone else to help."
      }
    ]
  },
  {
    "number": 5928,
    "title": "How to add uuid as default value using migrations  at the MySQL",
    "created_at": "2020-04-21T13:59:21Z",
    "closed_at": "2020-10-14T05:32:17Z",
    "labels": [
      "question",
      "comp: migrations",
      "driver: mysql",
      "driver: mariadb"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/5928",
    "body": "**Issue type:**\r\n\r\n[x ] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[x ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[ ] `cockroachdb`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[ ] `latest`\r\n[ ] `@next`\r\n[x ] `0.2.24` (or put your version here)\r\n\r\nHow could I add uuid_generate_v4() as a default value using typeorm migrations\r\n\r\n```\r\nimport { MigrationInterface, QueryRunner, Table } from 'typeorm';\r\n\r\nexport default class CreateAppointments1587431673525\r\n  implements MigrationInterface {\r\n  public async up(queryRunner: QueryRunner): Promise<void> {\r\n    await queryRunner.createTable(\r\n      new Table({\r\n        name: 'appointments',\r\n        columns: [\r\n          {\r\n            name: 'id',\r\n            type: 'varchar',\r\n            isPrimary: true,\r\n            generationStrategy: 'uuid',\r\n            default: 'uuid_generate_v4()',\r\n          },\r\n        ],\r\n      }),\r\n    );\r\n  }\r\n\r\n  public async down(queryRunner: QueryRunner): Promise<void> {\r\n    await queryRunner.dropTable('appointments');\r\n  }\r\n}\r\n\r\n```\r\nerrno: 1064,\r\nsql: 'CREATE TABLE `appointments` (`id` varchar(36) NOT NULL DEFAULT uuid_generate_v4(), `provider` varchar(255) NOT NULL, `date` timestamp NOT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB',\r\n<!--\r\n    To answer those questions you need to put \"x\" inside the square brackets, for example:\r\n    [x] `mysql`\r\n    [ ] `postgres`\r\n\r\n    Also, please format your code properly (by taking code blocks into ```ts .... ```)\r\n--!>\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/5928/comments",
    "author": "maiaraborges",
    "comments": [
      {
        "user": "jeffaribeiro",
        "created_at": "2020-05-01T16:26:32Z",
        "body": "@maiaraborges, this solution works for me:\r\n```\r\n\r\nimport { MigrationInterface, QueryRunner, Table } from 'typeorm';\r\n\r\nexport default class CriarTabelaAnexo1588342743485\r\n  implements MigrationInterface {\r\n  public async up(queryRunner: QueryRunner): Promise<void> {\r\n    await queryRunner.createTable(\r\n      new Table({\r\n        name: 'anexo',\r\n        columns: [\r\n          {\r\n            name: 'id',\r\n            type: 'varchar',\r\n            isPrimary: true,\r\n            generationStrategy: 'uuid',\r\n          },\r\n          {\r\n            name: 'descricao',\r\n            type: 'varchar',\r\n            isNullable: false,\r\n          },\r\n          {\r\n            name: 'urlAnexo',\r\n            type: 'varchar',\r\n            isNullable: false,\r\n          },\r\n        ],\r\n      }),\r\n    );\r\n  }\r\n\r\n  public async down(queryRunner: QueryRunner): Promise<void> {\r\n    await queryRunner.dropTable('anexo');\r\n  }\r\n}\r\n\r\n```"
      },
      {
        "user": "imnotjames",
        "created_at": "2020-10-14T05:32:17Z",
        "body": "Looks like this was answered.  Closing out."
      }
    ]
  },
  {
    "number": 5912,
    "title": "'Relation \"photos.url\" was not found, please check if it is correct and really exist in your entity.",
    "created_at": "2020-04-20T08:50:10Z",
    "closed_at": "2021-07-11T15:47:21Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/5912",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[x] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[X] `postgres`\r\n[ ] `cockroachdb`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[ ] `latest`\r\n[ ] `@next`\r\n[X] `0.2.24` (or put your version here)\r\n\r\nFindRelationsNotFoundError: Relation \"photos.url\" was not found, please check if it is correct and really exist in your entity\r\n\r\nif I call only `relations: [\"photos\"]` it brings all the data but I just want \"url\"\r\n\r\n```\r\nconst users = await repoUser.find({\r\n    select: ['email', 'username'],\r\n    relations: [\"photos\", \"photos.url\"],\r\n})\r\n```\r\n\r\nEntitys\r\n- Photo\r\n```\r\n@Entity()\r\nexport class Photo {\r\n  @PrimaryGeneratedColumn()\r\n  id: number;\r\n\r\n  @Column()\r\n  url: string;\r\n\r\n  @ManyToOne(type => User, user => user.photos)\r\n  user: User;\r\n}\r\n```\r\n- User\r\n```\r\n@Entity('User')\r\nexport class User {\r\n    @PrimaryGeneratedColumn('uuid')\r\n    id: string\r\n\r\n    @Column()\r\n    username: string;\r\n\r\n    @Column()\r\n    email: string;\r\n\r\n    @Column()\r\n    password: string;\r\n\r\n    @CreateDateColumn({ type: 'timestamp' })\r\n    createdAt: Date;\r\n\r\n    @UpdateDateColumn({ type: 'timestamp' })\r\n    updatedAt: Date;\r\n\r\n    @OneToMany(type => Photo, photo => photo.user)\r\n    photos: Photo[];\r\n\r\n    @BeforeInsert()\r\n    async hashPassword(): Promise<void> {\r\n      const hash = await bcrypt.hash(this.password, 8)\r\n      this.password = hash\r\n    }\r\n}\r\n```",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/5912/comments",
    "author": "t-heu",
    "comments": [
      {
        "user": "dev-cardenas",
        "created_at": "2020-04-30T23:59:01Z",
        "body": "Same error"
      },
      {
        "user": "GitVijayDv",
        "created_at": "2021-06-13T19:31:48Z",
        "body": "Not resolved…still"
      },
      {
        "user": "imnotjames",
        "created_at": "2021-07-11T15:47:21Z",
        "body": "`relations` is just for specifying what relations you'd like to join. `photos.url` is not a relation.  Try `select` instead.\r\n\r\nIf you'd like to request a new feature please open a new issue with an explicit request and desired API "
      }
    ]
  },
  {
    "number": 5887,
    "title": ".find() WHERE id of relation - not working",
    "created_at": "2020-04-16T15:16:55Z",
    "closed_at": "2020-10-17T16:02:25Z",
    "labels": [
      "question",
      "can be closed?",
      "driver: mysql",
      "driver: mariadb"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/5887",
    "body": "**Issue type:**\r\n\r\n[X] question\r\n\r\n**Database system/driver:**\r\n\r\n[X ] `mysql` / `mariadb`\r\n\r\n**TypeORM version:**\r\n\r\n[X] `^0.2.22`\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\n```ts\r\n# appointment.entity.ts\r\n\r\n@Entity()\r\nexport class Appointment {\r\n    @PrimaryGeneratedColumn('uuid')\r\n    id: string;\r\n\r\n    @Column({nullable: false})\r\n    title: string;\r\n\r\n    @Column({nullable: false})\r\n    description: string;\r\n\r\n    @Column({nullable: false, unique: true})\r\n    link: string;\r\n\r\n    @Column({nullable: false})\r\n    location: string;\r\n\r\n    @Column('timestamp', {nullable: false, default: () => 'CURRENT_TIMESTAMP'})\r\n    date: Date;\r\n\r\n    @Column('timestamp', {default: null})\r\n    deadline: Date;\r\n\r\n    @Column('int', {default: null})\r\n    maxEnrollments: number;\r\n\r\n    @Column('boolean', {default: false})\r\n    hidden: boolean;\r\n\r\n    @OneToMany(type => Enrollment,\r\n        enrollment => enrollment.appointment,\r\n        {\r\n            eager: true\r\n        })\r\n    enrollments: Enrollment[];\r\n\r\n    @OneToMany(type => Addition,\r\n        addition => addition.appointment,\r\n        {\r\n            eager: true,\r\n        })\r\n    additions: Addition[];\r\n\r\n    @Column('smallint', {default: false})\r\n    driverAddition: boolean;\r\n\r\n    @ManyToMany(type => User,\r\n        user => user.administrations)\r\n    @JoinTable()\r\n    administrators: User[];\r\n\r\n    @ManyToMany(type => User,\r\n        user => user.pinned)\r\n    @JoinTable()\r\n    pinners: User[];\r\n\r\n    @OneToMany(type => File,\r\n        file => file.appointment,\r\n        {\r\n            eager: true,\r\n        })\r\n    files: File[];\r\n\r\n    @ManyToOne(type => User,\r\n        user => user.appointments)\r\n    @JoinColumn()\r\n    creator: User;\r\n\r\n    @CreateDateColumn()\r\n    @Exclude({toPlainOnly: true})\r\n    iat: Date;\r\n\r\n    @UpdateDateColumn({name: 'lud', nullable: true})\r\n    @Exclude({toPlainOnly: true})\r\n    lud: Date;\r\n\r\n    reference?: string[] = [];\r\n    numberOfEnrollments?: number;\r\n}\r\n```\r\n\r\n```ts\r\n# user.entity.ts\r\n\r\n@Entity()\r\nexport class User {\r\n    @PrimaryGeneratedColumn('uuid')\r\n    id: string;\r\n\r\n    @Column()\r\n    name: string;\r\n\r\n    @Column({\r\n        unique: true\r\n    })\r\n    username: string;\r\n\r\n    @Column({select: true})\r\n    @Exclude({toPlainOnly: true})\r\n    password: string;\r\n\r\n    @Column({\r\n        unique: true\r\n    })\r\n    mail: string;\r\n\r\n    @Column('smallint', {default: false})\r\n    activated: boolean;\r\n\r\n    @OneToMany(type => Appointment,\r\n        appointment => appointment.creator,\r\n        {\r\n            eager: false\r\n        }\r\n    )\r\n    appointments: Appointment[];\r\n\r\n    @ManyToMany(type => Appointment,\r\n        appointment => appointment.administrators)\r\n    administrations: Appointment[];\r\n\r\n    @ManyToMany(type => Appointment,\r\n        appointment => appointment.pinners,\r\n        {\r\n            eager: true\r\n        }\r\n    )\r\n    pinned: Appointment[];\r\n\r\n    @OneToOne(type => TelegramUser,\r\n        telegramUser => telegramUser.user)\r\n    telegramUser: TelegramUser;\r\n\r\n    @OneToMany(type => Enrollment,\r\n        enrollment => enrollment.creator)\r\n    enrollments: Enrollment[];\r\n\r\n    @OneToMany(type => PasswordReset,\r\n        passwordReset => passwordReset.user,)\r\n    passwordReset: PasswordReset[];\r\n\r\n    @OneToMany(type => EmailChange,\r\n        emailChange => emailChange.user,\r\n        {\r\n            eager: true\r\n        })\r\n    emailChange: EmailChange[];\r\n\r\n    @CreateDateColumn()\r\n    iat: Date;\r\n\r\n    token: string;\r\n}\r\n```\r\n\r\n```ts\r\n# enrollment.entity.ts\r\n\r\n@Entity()\r\n@Index('index_unique_name_appointment', ['name', 'appointment'], {unique: true}) // first style\r\nexport class Enrollment {\r\n    @PrimaryGeneratedColumn('uuid')\r\n    id: string;\r\n\r\n    @Column({nullable: false})\r\n    name: string;\r\n\r\n    @Column({nullable: true})\r\n    comment: string;\r\n\r\n    @OneToOne(type => Driver, driver => driver.enrollment,\r\n        {\r\n            eager: true,\r\n            onUpdate: 'CASCADE',\r\n        })\r\n    driver: Driver;\r\n\r\n    @OneToOne(type => Passenger,\r\n        passenger => passenger.enrollment,\r\n        {\r\n            eager: true,\r\n            onUpdate: 'CASCADE',\r\n        })\r\n    passenger: Passenger;\r\n\r\n    @ManyToMany(type => Addition, {\r\n        eager: true,\r\n        onDelete: 'CASCADE'\r\n    })\r\n    @JoinTable({name: 'enrollment_addition'})\r\n    additions: Addition[];\r\n\r\n    @ManyToOne(type => Appointment,\r\n        appointment => appointment.enrollments)\r\n    appointment: Appointment;\r\n\r\n    @OneToMany(type => Comment,\r\n        comment => comment.enrollment,\r\n        {\r\n            eager: true\r\n        })\r\n    comments: Comment[];\r\n\r\n    @CreateDateColumn()\r\n    iat: Date;\r\n\r\n    @ManyToOne(type => User,\r\n        user => user.enrollments,\r\n        {onDelete: 'CASCADE'})\r\n    @JoinColumn()\r\n    creator: User;\r\n\r\n    @OneToOne(type => Key,\r\n        key => key.enrollment,\r\n        {onDelete: 'CASCADE'})\r\n    key: Key;\r\n\r\n    @OneToOne(type => Mail,\r\n        mail => mail.enrollment,\r\n        {onDelete: 'CASCADE'})\r\n    mail: Mail;\r\n\r\n    @UpdateDateColumn({name: 'lud', nullable: true})\r\n    @Exclude({toPlainOnly: true})\r\n    lud: Date;\r\n\r\n    editKey: string;\r\n    editMail: string;\r\n    token?: string;\r\n    createdByUser: boolean;\r\n}\r\n```\r\n\r\nI am trying to slect all appointments, of which a given user is either the creator or administrator of an appointment, the creator of an enrollment, or knows the link to the appointment.\r\n\r\nCurrently I am selecting the appointments like this\r\n\r\n```ts\r\ngetRepository(Appointment)\r\n            .createQueryBuilder('appointment')\r\n            .leftJoinAndSelect('appointment.creator', 'creator')\r\n            .leftJoinAndSelect('appointment.additions', 'additions')\r\n            .leftJoinAndSelect('appointment.enrollments', 'enrollments')\r\n            .leftJoinAndSelect('enrollments.passenger', 'enrollment_passenger')\r\n            .leftJoinAndSelect('enrollments.driver', 'enrollment_driver')\r\n            .leftJoinAndSelect('enrollments.additions', 'enrollment_additions')\r\n            .leftJoinAndSelect('enrollments.creator', 'enrollment_creator')\r\n            .leftJoinAndSelect('appointment.files', 'files')\r\n            .leftJoinAndSelect('appointment.administrators', 'administrators')\r\n            .leftJoinAndSelect('appointment.pinners', 'pinners')\r\n            .select(['appointment', 'additions', 'enrollments',\r\n                'enrollment_passenger', 'enrollment_driver', 'enrollment_creator',\r\n                'creator.username', 'creator.name', 'files', 'administrators.username', 'administrators.name',\r\n                'enrollment_additions', 'pinners'])\r\n            .where('creator.id = :creatorId', {creatorId: user.id})\r\n            .orWhere('administrators.id = :admin', {admin: user.id})\r\n            .orWhere('enrollments.creatorId = :user', {user: user.id})\r\n            .orWhere('pinners.id = :user', {user: user.id})\r\n            .orWhere('appointment.link IN (:...links)', {links: pins})\r\n            .orderBy('appointment.date', 'DESC')\r\n            .getMany();\r\n```\r\n\r\nThis works totally fine, but i want to change it into the `.find()` methodology.\r\nTherefore I tried to convert it, and ended up with this: \r\n\r\n```ts\r\nthis.appointmentRepository.find(\r\n            {\r\n                join: {\r\n                    alias: 'appointment', innerJoin: {\r\n                        administrators: 'appointment.administrators',\r\n                        enrollments: 'appointment.enrollments',\r\n                        enrollmentsCreator: 'enrollments.creator',\r\n                        pinners: 'appointment.pinners'\r\n                    }\r\n                },\r\n                where: [\r\n                    {creator: {id: user.id}},\r\n                    {administrators: {id: user.id}},\r\n                    {enrollmentsCreator: {id: user.id}},\r\n                    {pinners: {id: user.id}},\r\n                    {link: In(pins)},\r\n                ],\r\n                order: {\r\n                    date: 'DESC'\r\n                },\r\n            }\r\n        );\r\n```\r\n\r\nBut this piece of code gives me an error.\r\n\r\n`\"ER_PARSE_ERROR: You have an error in your SQL syntax; check the manual that corresponds to your MariaDB server version for the right syntax to use near ') OR (`appointment`.`appointmentId` = 'cf3f82b3-1cc2-4fef-89c7-953ddc956df7') OR' at line\r\n1\"`\r\n\r\nIt can't execute the query, because its malformed.\r\nThe important part of the query is the `WHERE` clause.\r\n\r\n```sql\r\n... WHERE (`appointmen\r\nt`.`creatorId` = ?) OR (`appointment`.`appointmentId` = ?) OR () OR (`appointment`.`appointmentId` = ?) OR (`appointment`.`link` IN (?)) ORDER BY `appointment`.`date` DESC\r\n```\r\n\r\nIt is trying to match the `user.id` to the appointment id, instead of the id owned by e.g. the `administrator` relation.\r\n\r\nCan someone explain whats going wrong, or why the relations wont load correctly / can't be uses in the `WHERE` part?\r\n\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/5887/comments",
    "author": "sebamomann",
    "comments": [
      {
        "user": "imnotjames",
        "created_at": "2020-10-14T19:29:46Z",
        "body": "We made a few changes here - has this improved as of 0.2.28?"
      }
    ]
  },
  {
    "number": 5843,
    "title": "How to only updates the @UpdateDateColumn in Entity",
    "created_at": "2020-04-10T02:34:54Z",
    "closed_at": "2024-04-03T01:28:12Z",
    "labels": [
      "question",
      "driver: mysql",
      "driver: mariadb"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/5843",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[x] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[ ] `cockroachdb`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\nIs there any way that only updates the @UpdateDateColumn in Entity? I see TypeORM ignore this filed in computeDiffColumns() function.\r\n`\r\n@Entity()\r\nexport class Post {\r\n    @PrimaryGeneratedColumn('uuid')\r\n    id: string;\r\n\r\n    @Column({nullable: false})\r\n    title: string;\r\n\r\n    @CreateDateColumn({name: 'created_at', nullable: true})\r\n    createdAt: Date;\r\n\r\n    @UpdateDateColumn({name: 'updated_at', nullable: true})\r\n    updatedAt: Date;\r\n}\r\n`\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/5843/comments",
    "author": "hiep-dinh",
    "comments": [
      {
        "user": "tjhiggins",
        "created_at": "2020-04-14T14:48:06Z",
        "body": "+1\r\n\r\nOur workaround\r\n`` transactionalEntityManager.query(`UPDATE \"<table_name>\" SET updated_at = NOW() where id = '${<id>}'`); ``"
      },
      {
        "user": "imnotjames",
        "created_at": "2021-07-04T17:20:18Z",
        "body": "> +1\r\n> \r\n> Our workaround\r\n> `` transactionalEntityManager.query(`UPDATE \"<table_name>\" SET updated_at = NOW() where id = '${<id>}'`); ``\r\n\r\nYou should be using parameters for this."
      },
      {
        "user": "estani",
        "created_at": "2022-08-22T11:13:45Z",
        "body": "I found imo a better way from the repository:\r\n```js\r\nrepository.update({id: entity.id}, {});\r\n```\r\nJust provide the primary keys to the first parameter and an empty changeSet as the second."
      }
    ]
  },
  {
    "number": 5791,
    "title": "Mongo DB support still Experimental?",
    "created_at": "2020-03-31T15:37:01Z",
    "closed_at": "2020-10-06T06:34:34Z",
    "labels": [
      "question",
      "driver: mongodb"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/5791",
    "body": "**Issue type:**\r\n\r\n[X ] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[x] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[ ] `cockroachdb`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\nIn the Documentation the Mongodb support is marked as Experimental - is this still the case or is it a documentation issue?\r\nWe are preparing to use it in Production and the experimental annotation makes us question if it would be the right choice, although it is currently working properly.\r\nCould you maybe supply me with some information as to when mongodb support is going to be \"non-experimental\" \r\n\r\nWould be much appreciated ! Thank you alot :)\r\n\r\n\r\n\r\n\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/5791/comments",
    "author": "meganoob1337",
    "comments": [
      {
        "user": "larsdecker",
        "created_at": "2020-04-02T18:51:06Z",
        "body": "We also use TypeORM together with nestJS. For us it works also well. But in some cases there are small issues.\r\n\r\nThe general support for mongodb could be better. The main focus of project seems to be as a Wrapper for SQL Databases.  But there exists no real alternatives for the same comfort."
      },
      {
        "user": "meganoob1337",
        "created_at": "2020-04-07T11:55:02Z",
        "body": "Yeah for us it works well also, but our client seems to bother that its listed under \"experimental support\" thats why i would like some clarification about it, as it would be a hassle to migrate to postgres or something else :D "
      },
      {
        "user": "imnotjames",
        "created_at": "2020-10-06T06:34:34Z",
        "body": "`mongodb` will be experimental until we split the drivers out and someone takes up maintenance of the driver more seriously.\r\n\r\nHowever, barring some serious direction changes, it's not going away."
      }
    ]
  },
  {
    "number": 5783,
    "title": "getOne fetches all rows instead of one",
    "created_at": "2020-03-30T08:49:57Z",
    "closed_at": "2021-07-04T00:53:18Z",
    "labels": [
      "question",
      "new feature"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/5783",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[ ] bug report\r\n[x] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[ ] `cockroachdb`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\ngetOne function actually pulls all the matching record from table and return one single object. \r\n\r\nif its getting only the single object why its need to pull all the record from db. querying getOne in a large table will pull large amount of data, can resulted into memory exception. ",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/5783/comments",
    "author": "maruf0011",
    "comments": [
      {
        "user": "imnotjames",
        "created_at": "2021-07-04T00:53:18Z",
        "body": "Duplicate of #4852 "
      }
    ]
  },
  {
    "number": 5698,
    "title": "add new condition in the query before query execution",
    "created_at": "2020-03-16T15:34:30Z",
    "closed_at": "2020-10-10T19:42:45Z",
    "labels": [
      "question",
      "driver: mysql",
      "driver: mariadb",
      "driver: mongodb",
      "driver: mssql"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/5698",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[x] `mongodb`\r\n[x] `mssql`\r\n[x] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[ ] `cockroachdb`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\ni need to add where condition before execute the query like mongoose\r\n\r\n```\r\nschema.pre('find', function(next)  {\r\n            this.where({testField: {$in: ['test']}});\r\n        next();\r\n    });\r\n```\r\n\r\nthen this will add new condition to any find query then execute it \r\n\r\ni searched to find something like the in `TypeORM` but i didn't found way to do this\r\n\r\nis there any solution to do it ",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/5698/comments",
    "author": "elgreatly",
    "comments": [
      {
        "user": "elgreatly",
        "created_at": "2020-04-01T21:51:29Z",
        "body": "@pleerock do you have any solution for this issue?"
      },
      {
        "user": "imnotjames",
        "created_at": "2020-10-10T19:42:45Z",
        "body": "Duplicate of #1601"
      }
    ]
  },
  {
    "number": 5655,
    "title": "Postgres: migration:generate drops and recreates all FKs continuously",
    "created_at": "2020-03-10T14:30:32Z",
    "closed_at": "2021-07-12T07:26:43Z",
    "labels": [
      "bug",
      "question",
      "can be closed?",
      "comp: migrations",
      "driver: postgres"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/5655",
    "body": "**Issue type:**\r\n\r\n[X] question\r\n[X] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[X] `postgres`\r\n[ ] `cockroachdb`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[ ] `latest`\r\n[ ] `@next`\r\n[X] `0.2.24` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nHello 👋\r\nIt seems that after upgrading typeORM from version `0.2.22` to version `0.2.24` in my project the cli command `migration:generate -n migrationName` drops all FKs and regenerates them again, even when running the command multiple times without changing relations, entites, etc.\r\n\r\nMaybe 7157cb393b76bfb9152234e4aea428d0d615e5d9 and issue #5119 relate to this?\r\nI'm not so deep into the typeORM code at the moment but the added check `(tableForeignKey.referencedTableName === metadataForeignKey.referencedTablePath)` in line 795 seems to always return `false`...",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/5655/comments",
    "author": "SeWaS",
    "comments": [
      {
        "user": "imnotjames",
        "created_at": "2021-07-11T15:51:49Z",
        "body": "I'm not seeing this any longer.  Is this still an issue?"
      },
      {
        "user": "SeWaS",
        "created_at": "2021-07-12T07:26:43Z",
        "body": "Yes, can be closed! Haven't seen it in later versions  🎉\r\nThanks for your work!"
      }
    ]
  },
  {
    "number": 5645,
    "title": "Delete entity on OneToMany update",
    "created_at": "2020-03-09T07:39:15Z",
    "closed_at": "2020-10-10T12:08:02Z",
    "labels": [
      "question",
      "driver: postgres"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/5645",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[x] `postgres`\r\n[ ] `cockroachdb`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n---\r\n\r\nI am looking for a way to delete an entity by updating a `OneToMany` relation with cascades in typorm. I know, I could do this by diffing the changes and deleting the referenced entity by hand, but since typorm already knows which changes have happened, it would be nice it could also handle this case.\r\n\r\nI could not figure out how to do it, or if it is even possible with typeorm right now.\r\n\r\nI think the best way to explain my problem is through an example:\r\n\r\n## Starting point\r\n\r\n```ts\r\n// Booker Entity\r\n{\r\n  @OneToMany(\r\n        (type) => Attendee,\r\n        (attendee) => attendee.booker,\r\n        {\r\n            nullable: true,\r\n            cascade: [\"insert\", \"update\", \"remove\"],\r\n        },\r\n    )\r\n    attendees?: Array<Attendee>;\r\n}\r\n```\r\n\r\n```ts\r\n// Attendee Entity\r\n{\r\n  @ManyToOne(\r\n      (type) => Booker,\r\n      (booker) => booker.attendees,\r\n  )\r\n  booker!: Booker;\r\n}\r\n```\r\n\r\n__Booker table__\r\n| id | firstname | lastname |\r\n| -: | --------- | -------- |\r\n| 1  | Jane      | Doe      |\r\n\r\n__Attendee table__\r\n| id | firstname | lastname | bookerId |\r\n| -: | --------- | -------- | -------- |\r\n| 2  | June      | Doe      | 1        |\r\n| 3  | Joe       | Doe      | 1        |\r\n\r\n## My steps\r\n\r\n```ts\r\nconst booker = bookerRepository.create({\r\n  id: 1,\r\n  firstname: \"Jane\",\r\n  lastname: \"Doe\",\r\n  attendees: [{\r\n    id: 3,\r\n    firstname: \"Joe\",\r\n    lastname: \"Doe\"\r\n  }]\r\n});\r\n\r\nbookerRepository.save(booker);\r\n```\r\n\r\n## Current outcome\r\n\r\n1. `save` realizes which entity is missing\r\n2. TypeORM tries to set the the `bookerId` of the removed row (id 2) to null`\r\n3. Error because of a foreign key violation\r\n\r\n## Expected outcome\r\n1. `save` realizes which entity is missing\r\n2. TypeORM deletes the row which has been removed from the payload (id 2)\r\n\r\nThe final state should look like this:\r\n\r\n__Booker table__\r\n| id | firstname | lastname |\r\n| -: | --------- | -------- |\r\n| 1  | Jane      | Doe      |\r\n\r\n__Attendee table__\r\n| id | firstname | lastname | bookerId |\r\n| -: | --------- | -------- | -------- |\r\n| 3  | Joe       | Doe      | 1        |",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/5645/comments",
    "author": "hpohlmeyer",
    "comments": [
      {
        "user": "hpohlmeyer",
        "created_at": "2020-03-09T09:48:35Z",
        "body": "Oh this might be a duplicate of\r\n - #1351\r\n - #1761"
      },
      {
        "user": "hakimio",
        "created_at": "2020-03-09T14:45:38Z",
        "body": "Yes, it's definitely a duplicate. Anyway, have you found any workaround apart from manually deleting  child entities?"
      },
      {
        "user": "kruegernet",
        "created_at": "2020-07-16T17:43:31Z",
        "body": "@pleerock \r\n\r\nCan we get clarification on this? It's unclear to users whether this is intended behavior that differs from user expectation or is in fact a bug."
      },
      {
        "user": "itsmamipiyur",
        "created_at": "2020-07-29T11:15:52Z",
        "body": "well, this is a problem amongst all 😭 hoping we can hear some resolutions up in here @pleerock "
      },
      {
        "user": "imnotjames",
        "created_at": "2020-10-10T12:08:02Z",
        "body": "Duplicate of #1351"
      }
    ]
  },
  {
    "number": 5594,
    "title": "Type safety when using query builder",
    "created_at": "2020-03-01T10:06:10Z",
    "closed_at": "2021-07-03T20:19:06Z",
    "labels": [
      "question",
      "driver: mysql",
      "driver: mariadb"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/5594",
    "body": "**Issue type:**\r\n\r\n[X] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[X] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[ ] `cockroachdb`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[X] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nWhen using the query builder and using join operator's would it be possible that you can get the intellisence to show the field names etc, how a large complex database and have to try and remember all the relevant field names and joins.",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/5594/comments",
    "author": "pdashford",
    "comments": [
      {
        "user": "imnotjames",
        "created_at": "2021-07-03T20:19:06Z",
        "body": "We do some amount but because you can set the aliases yourself it's not really possible to represent that with types while allowing flexibility."
      }
    ]
  },
  {
    "number": 5568,
    "title": "dropUniqueConstraint seems not to work",
    "created_at": "2020-02-25T05:32:22Z",
    "closed_at": "2021-06-25T03:49:36Z",
    "labels": [
      "question",
      "can be closed?",
      "driver: postgres"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/5568",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[x] bug report\r\n\r\n**Database system/driver:**\r\n[x] `postgres`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nI'm trying to add a unique constraint.\r\n\r\n`queryRunner.createUniqueConstraint` works as expected.\r\n\r\nBut `queryRunner.dropUniqueConstraint` throws `error: error: constraint \"undefined\" of relation \"user\" does not exist.`\r\n\r\nHere is my migration\r\n\r\n```ts\r\nimport { MigrationInterface, QueryRunner, TableUnique } from 'typeorm'\r\n\r\nexport class UpdateUserTable1582288403747 implements MigrationInterface {\r\n\r\n  public async up(queryRunner: QueryRunner): Promise<any> {\r\n    await queryRunner.createUniqueConstraint('user', new TableUnique({ columnNames: ['email'] }))\r\n  }\r\n\r\n  public async down(queryRunner: QueryRunner): Promise<any> {\r\n    await queryRunner.dropUniqueConstraint('user', new TableUnique({ columnNames: ['email'] }))\r\n  }\r\n\r\n}\r\n```",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/5568/comments",
    "author": "davran-siv",
    "comments": [
      {
        "user": "is-equal",
        "created_at": "2020-04-16T18:51:47Z",
        "body": "It's like when do you need to use `dropForeingKeys`, these functions drop based on the generated name. If you don't have generated a name for unique constraints or foreign keys, you need another way to drop these cases.\r\n\r\nI make these scripts to solve the necessity of my project, and the new unique constraints and foreign keys created on the project have a name to don't need this more. And names on these cases help to identify query errors.\r\n\r\nSee bellow my helper functions:\r\n```ts\r\nexport async function dropForeignKeys(queryRunner: QueryRunner, tableName: string, columnNames: string[]) {\r\n  const table = await queryRunner.getTable(tableName);\r\n\r\n  for (const foreignKey of table.foreignKeys) {\r\n    for (const columnName of columnNames) {\r\n      if (foreignKey.columnNames.includes(columnName)) {\r\n        await queryRunner.dropForeignKey(tableName, foreignKey.name);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport async function dropUniqueConstraints(queryRunner: QueryRunner, tableName: string, columnNames: string[]) {\r\n  const table = await queryRunner.getTable(tableName);\r\n\r\n  for (const uniqueConstraint of table.uniques) {\r\n    for (const columnName of columnNames) {\r\n      if (uniqueConstraint.columnNames.includes(columnName)) {\r\n        await queryRunner.dropUniqueConstraint(tableName, uniqueConstraint.name);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n```"
      },
      {
        "user": "imnotjames",
        "created_at": "2021-06-25T03:49:36Z",
        "body": "yeah, you can't create a new one - it has to know that it exists, too."
      }
    ]
  },
  {
    "number": 5553,
    "title": "Relations limit and offset",
    "created_at": "2020-02-20T13:57:07Z",
    "closed_at": "2021-02-16T02:35:36Z",
    "labels": [
      "question",
      "driver: mssql"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/5553",
    "body": "**Issue type:**\r\n[x] question\r\n\r\n**Database system/driver:**\r\n[x ] `mssql`\r\n\r\n**TypeORM version:**\r\n[ x] `latest`\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nhow to set the comments limit and offset by using the following code or any suggestion??\r\n```\r\nconst store= await this.storeRepository.findOne(id, {\r\n    relations: ['comments', 'comments.user']\r\n });\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/5553/comments",
    "author": "amokio",
    "comments": [
      {
        "user": "artoodeeto",
        "created_at": "2020-02-20T18:29:41Z",
        "body": "@mattia-lau Hello, Have you tried doing the inverse? Finding the comments where user id = ? with limit and skip? property? I'm not sure if that's right but that's what I would do. "
      },
      {
        "user": "amokio",
        "created_at": "2020-02-20T18:37:15Z",
        "body": "> @mattia-lau Hello, Have you tried doing the inverse? Finding the comments where user id = ? with limit and skip? property? I'm not sure if that's right but that's what I would do.\r\n\r\nthank you for the reply. the  findOne api is not providing take and skip function. \r\nand i dont know what is inverse.\r\ncan you provide the simple code for me?"
      },
      {
        "user": "artoodeeto",
        "created_at": "2020-02-20T19:06:25Z",
        "body": "@mattia-lau ohh yea. findOne doesn't have a skip property it would be redundant.\r\n\r\nmaybe you could.\r\n\r\n```\r\ncommentsRepo.find({ relations: [\"user\"], where: [{ userId: id }], skip: 1, take: 5 })\r\n```\r\nsomething like that?\r\n\r\nif I'm wrong you could try query builder:\r\n\r\n```ts\r\nawait getConnection()\r\n    .createQueryBuilder()\r\n    .select(\"comments\")\r\n    .from(Comment, \"comment\")\r\n    .where(\"comment.userId = :id\", { id: 1 })\r\n    .limit(10)\r\n    .offset(10)\r\n    .getMany();\r\n```\r\nI haven't used query builder but just check the syntax on the documentation I might be wrong. hope it helps. :smile: "
      }
    ]
  },
  {
    "number": 5549,
    "title": "update and delete static methods should throw if given Id is incorrect",
    "created_at": "2020-02-20T04:19:03Z",
    "closed_at": "2021-07-04T14:52:56Z",
    "labels": [
      "question",
      "new feature",
      "driver: mysql",
      "driver: mariadb"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/5549",
    "body": "**Issue type:**\r\n\r\n[X] question\r\n[] bug report\r\n[X] feature request\r\n[] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[X] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[ ] `cockroachdb`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[X] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\nI have these code in my codebase that I think would be cleaner if some of static methods throws an error.\r\n\r\nlike:\r\n\r\n```ts\r\nconst { id } = req.params;\r\n    const { title, body } = req.body;\r\n    try {\r\n      await PostModel.findOneOrFail(id);\r\n      await PostModel.update(id, { title, body });\r\n      res.status(200).json({\r\n        meta: {},\r\n        payload: {\r\n          message: 'success'\r\n        }\r\n      });\r\n    } catch (error) {\r\n      res.status(404).json({ error });\r\n    }\r\n```\r\n\r\n```ts\r\nconst { id } = req.params;\r\n    try {\r\n      await User.findOneOrFail(id);\r\n      await User.delete(id);\r\n      res.status(200).json({\r\n        payload: {\r\n          status: 'success'\r\n        }\r\n      });\r\n    } catch (error) {\r\n      res.status(404).json({\r\n        error\r\n      });\r\n    }\r\n```\r\n\r\nthose `findOneOrFail` can be omitted if delete and update methods throws an error if supplied ID can't be located or not in database. I know that in the database level there's no error but it would be nice if this is implemented.\r\n\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/5549/comments",
    "author": "artoodeeto",
    "comments": [
      {
        "user": "imnotjames",
        "created_at": "2021-07-04T14:52:56Z",
        "body": "You can check the result of the delete.  It has the rows affected."
      }
    ]
  },
  {
    "number": 5470,
    "title": "Question: How to continue  to next value ( aport ) if there a duplications error ",
    "created_at": "2020-02-04T13:37:15Z",
    "closed_at": "2020-10-06T06:38:48Z",
    "labels": [
      "question",
      "driver: mysql",
      "driver: mariadb"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/5470",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[x] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[ ] `cockroachdb`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\nI'm scraping from multiple websites and I save the data on MySQL type database using nestJS and TypeOrm frameworks. \r\n\r\nI have a cron job that runs that scraper service every day checking for new data available and inserted into my SQL database, the problem I don't wanna duplication data so I did a unique column in my table, so any duplicated data not getting be saved.\r\n\r\nNow I got the `dup error` as I expected but I can't find a way to handle this error to just ignore that row and continue for the rest instead of stopping everything.\r\n\r\nThe code for saving the data: \r\n```typescriprt\r\nasync clonningFromScraper() {\r\n   //my scraper data ( array of objects )\r\n    let articles = await this.articlesScraper.articles('1'); \r\n\r\n    articles = articles.map( article => ({ ...article, key: decodeURIComponent(article.url).substring(0, 255) }));\r\n\r\n // saving the data into my database\r\n    return this.articleRepository\r\n        .save(articles);\r\n}\r\n```\r\n\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/5470/comments",
    "author": "heshaShawky",
    "comments": [
      {
        "user": "aatecey",
        "created_at": "2020-02-07T13:46:48Z",
        "body": "Don't think save has an option to handle this. Could use the query builder for this case though. Not tested this but something like:\r\n\r\n        await this.articleRepository.createQueryBuilder()\r\n            .insert()\r\n            .orIgnore()\r\n            .into(Article)\r\n            .values(articles)\r\n            .execute();"
      },
      {
        "user": "heshaShawky",
        "created_at": "2020-02-09T23:39:52Z",
        "body": "> Don't think save has an option to handle this. Could use the query builder for this case though. Not tested this but something like:\r\n> \r\n> ```\r\n>     await this.articleRepository.createQueryBuilder()\r\n>         .insert()\r\n>         .orIgnore()\r\n>         .into(Article)\r\n>         .values(articles)\r\n>         .execute();\r\n> ```\r\nthe `save` method supposed to do that as it's documented \r\n```\r\n /**\r\n     * Saves all given entities in the database.\r\n     * If entities do not exist in the database then inserts, otherwise updates.\r\n     */\r\n```\r\nYour code works well for me, thanks.\r\n\r\n"
      }
    ]
  },
  {
    "number": 5436,
    "title": "getRawMany() and getMany() inconsistent results",
    "created_at": "2020-01-30T07:41:52Z",
    "closed_at": "2021-07-04T16:03:52Z",
    "labels": [
      "question",
      "driver: postgres"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/5436",
    "body": "**Issue type:**\r\n\r\n[X] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[X] `postgres`\r\n[ ] `cockroachdb`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[X] `latest`\r\n[ ] `@next`\r\n[ ] `0.2.22` (or put your version here)\r\n\r\nHello,\r\nhaving following Entity declared \r\n```\r\n@Entity('test')\r\nexport default class Test {\r\n  @PrimaryGeneratedColumn({\r\n    name: 'id',\r\n  })\r\n  id: number;\r\n\r\n  @Column({\r\n    unique: true,\r\n  })\r\n  @IsNotEmpty()\r\n  @Length(1, 16)\r\n  name: string;\r\n\r\n  @Column()\r\n  isTest: boolean;\r\n\r\n  @Column()\r\n  @CreateDateColumn()\r\n  createdAt: Date;\r\n\r\n  @Column()\r\n  @UpdateDateColumn()\r\n  updatedAt: Date;\r\n}\r\n```\r\n\r\nI try to get for example a list of results with an additional column (eg. ```count```)\r\nusing a query like: \r\n\r\n```\r\nawait getRepository(Test)\r\n        .createQueryBuilder('test')\r\n        .select([\r\n          'test.id',\r\n          'test.name',\r\n        ])\r\n        .addSelect('COUNT(test.id)', 'count')\r\n        .groupBy('test.id')\r\n        .getMany();\r\n```\r\nthe same example with ```.getRawMany()``` produces the same SQL:\r\n\r\n```\r\nSELECT \"test\".\"id\" AS \"test_id\", \"test\".\"name\" AS \"test_name\", COUNT(\"test\".\"id\") AS \"count\" FROM \"test\" \"test\" GROUP BY \"test\".\"id\"\r\n```\r\n\r\nWith ```getMany()```  I agree that `count` column is not returned, but with `getRawMany()` I'd expect an output like this:\r\n\r\n1. \r\n```\r\n[\r\n    {\r\n      \"id\": 2,\r\n      \"name\": \"name2\",\r\n      \"count\": \"1\"\r\n    },\r\n    {\r\n      \"id\": 1,\r\n      \"name\": \"name1\",\r\n      \"count\": \"1\"\r\n    }\r\n  ]\r\n```\r\n\r\nbut I get \r\n\r\n2. \r\n```\r\n[\r\n    {\r\n      \"test_id\": 2,\r\n      \"test_name\": \"name2\",\r\n      \"count\": \"1\"\r\n    },\r\n    {\r\n      \"test_id\": 1,\r\n      \"test_name\": \"name1\",\r\n      \"count\": \"1\"\r\n    }\r\n  ]\r\n``` \r\ninstead. \r\nIs this a correct behaviour that every Entity's column is prefixed with an alias? According to TypeOrm documentation the 1. should be returned and this is what I want to get.\r\nI can walk around this overwriting each alias manually with separate `.addSelect('test.id', 'id')` and so on, but this doesn't seem to be scaling well. #",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/5436/comments",
    "author": "mszubiczuk",
    "comments": [
      {
        "user": "jinusean",
        "created_at": "2021-04-03T10:33:58Z",
        "body": "Have you tried `.createQueryBuilder()` without an alias? "
      },
      {
        "user": "imnotjames",
        "created_at": "2021-07-04T16:03:52Z",
        "body": "This is intentional because every select field must have a unique alias to be returned.  If you want to customize it, yes, you need to individually add them with aliases.\r\n\r\nYou can preview the query with `getQuery` to understand how this is happening"
      }
    ]
  },
  {
    "number": 5428,
    "title": "Can you use `MIGRATIONS_RUN` against `postgres` with different users ?",
    "created_at": "2020-01-28T14:26:50Z",
    "closed_at": "2021-07-09T18:24:14Z",
    "labels": [
      "question",
      "needs more info",
      "comp: migrations",
      "driver: postgres"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/5428",
    "body": "**Issue type:**\r\n\r\n[X] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[X] `postgres`\r\n[ ] `cockroachdb`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[] `latest`\r\n[ ] `@next`\r\n[X] `0.2.22` \r\n\r\n**Question**\r\n\r\nI create a database and a user will all privileges:\r\n\r\n```\r\nCREATE DATABASE foo_db;\r\nCREATE USER user0 WITH ENCRYPTED PASSWORD '....';\r\nGRANT ALL PRIVILEGES ON DATABASE foo_db TO user0;\r\n```\r\n\r\nI run an application that uses this user, and creates a connection with `TYPEORM_MIGRATIONS_RUN` set to true, so the migrations are created: \r\n\r\n```\r\nquery: SELECT * FROM \"information_schema\".\"tables\" WHERE \"table_schema\" = current_schema() AND \"table_name\" = 'migrations'\r\nquery: CREATE TABLE \"migrations\" (\"id\" SERIAL NOT NULL, \"timestamp\" bigint NOT NULL, \"name\" character varying NOT NULL, CONSTRAINT \"PK_8c82d7f526340ab734260ea46be\" PRIMARY KEY (\"id\"))\r\nquery: SELECT * FROM \"migrations\" \"migrations\" ORDER BY \"id\" DESC\r\nquery: START TRANSACTION\r\nquery: CREATE TABLE ....\r\n...\r\nquery: INSERT INTO \"migrations\"(\"timestamp\", \"name\") VALUES ($1, $2) -- PARAMETERS: [1579718370873,\"createDefaultLineTable1579718370873\"]\r\nquery: COMMIT\r\n``` \r\n\r\nIn particular, the first query into ` \"information_schema\".\"tables\"` returns data: \r\n\r\n```\r\n=> SELECT * FROM \"information_schema\".\"tables\" WHERE \"table_schema\" = current_schema() AND \"table_name\" = 'migrations'\r\nline_service=> SELECT * FROM \"information_schema\".\"tables\" WHERE \"table_schema\" = current_schema() AND \"table_name\" = 'migrations';\r\n table_catalog | table_schema | table_name | table_type | self_referencing_column_name | reference_generation | user_defined_type_catalog | user_defined_type_schema | user_defined_type_name | is_insertable_into | is_typed | commit_action \r\n---------------+--------------+------------+------------+------------------------------+----------------------+---------------------------+--------------------------+------------------------+--------------------+----------+---------------\r\n xxxx  | public       | migrations | BASE TABLE |                              |                      |                           |                          |                        | YES                | NO       | \r\n(1 row)\r\n```\r\n\r\nNow, if I create another user, with the same privileges:\r\n\r\n```\r\nCREATE USER user1 WITH ENCRYPTED PASSWORD '....';\r\nGRANT ALL PRIVILEGES ON DATABASE foo_db TO user1;\r\n```\r\n\r\nWhen I run the application again, the query to check if the migrations table has been created returns no entry:\r\n\r\n```\r\n=> SELECT * FROM \"information_schema\".\"tables\" WHERE \"table_schema\" = current_schema() AND \"table_name\" = 'migrations';\r\n table_catalog | table_schema | table_name | table_type | self_referencing_column_name | reference_generation | user_defined_type_catalog | user_defined_type_schema | user_defined_type_name | is_insertable_into | is_typed | commit_action \r\n---------------+--------------+------------+------------+------------------------------+----------------------+---------------------------+--------------------------+------------------------+--------------------+----------+---------------\r\n(0 rows)\r\n```\r\n\r\nTherefore, my application believes that no migrations have ever run, and try to recreate the `migrations` table, which fails since the table already exists: \r\n\r\n```\r\nquery: SELECT * FROM \"information_schema\".\"tables\" WHERE \"table_schema\" = current_schema() AND \"table_name\" = 'migrations'\r\nquery: CREATE TABLE \"migrations\" (\"id\" SERIAL NOT NULL, \"timestamp\" bigint NOT NULL, \"name\" character varying NOT NULL, CONSTRAINT \"PK_8c82d7f526340ab734260ea46be\" PRIMARY KEY (\"id\"))\r\nquery failed: CREATE TABLE \"migrations\" (\"id\" SERIAL NOT NULL, \"timestamp\" bigint NOT NULL, \"name\" character varying NOT NULL, CONSTRAINT \"PK_8c82d7f526340ab734260ea46be\" PRIMARY KEY (\"id\"))\r\nerror: { error: relation \"migrations\" already exists\r\n```\r\n\r\nWhat am I doing wrong ? Should I specify a separate `typeorm` user to run the migrations and to execute the code ?\r\n\r\nSorry if that's not a `typeorm` concern, in which case, is there another project I should get help about ?\r\n\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/5428/comments",
    "author": "phtrivier",
    "comments": [
      {
        "user": "imnotjames",
        "created_at": "2021-07-04T01:06:18Z",
        "body": "I don't think this a TypeORM concern but a concern with how you're trying to set up postgres - we can't see that the table exists but it exists?  Not sure what to do about that."
      },
      {
        "user": "imnotjames",
        "created_at": "2021-07-04T01:06:37Z",
        "body": "When opening an issue, people will be better able to provide help if you provide code that they can easily understand and use to reproduce the problem. This boils down to ensuring your code that reproduces the problem follows the following guidelines:\r\n\r\n* Minimal – Use as little code as possible that still produces the same problem\r\n* Complete – Provide all parts someone else needs to reproduce your problem in the question itself\r\n* Reproducible – Test the code you're about to provide to make sure it reproduces the problem\r\n\r\n## Minimal\r\nThe more code there is to go through, the less likely people can find your problem. Streamline your example in one of two ways:\r\n\r\n1. Restart from scratch. Create a new program, adding in only what is needed to see the problem. Use simple, descriptive names for functions and variables – don’t copy the names you’re using in your existing code.\r\n2. Divide and conquer. If you’re not sure what the source of the problem is, start removing code a bit at a time until the problem disappears – then add the last part back.\r\n\r\nDon't sacrifice clarity for brevity when creating a minimal example. Use consistent naming and indentation, and include code comments if needed. Use your code editor’s shortcut for formatting code.\r\n\r\nDon't include any passwords or credentials that must be kept secret.\r\n\r\n## Complete\r\n\r\nMake sure all information necessary to reproduce the problem is included in the issue itself.\r\n\r\nIf the problem requires some code as well as some XML-based configuration, include code for both. The problem might not be in the code that you think it is in.\r\n\r\nUse individual code blocks for each file or snippet you include. Provide a description for the purpose of each block.\r\n\r\n**DO NOT** use images of code. Copy the actual text from your code editor, paste it into the issus, then format it as code. This helps others more easily read and test your code.\r\n\r\n## Reproducible\r\n\r\nTo help you solve your problem, others will need to verify that it exists.\r\n\r\nDescribe the problem. \"It doesn't work\" isn't descriptive enough to help people understand your problem. Instead, tell other readers what the expected behavior should be. Tell other readers what the exact wording of the error message is, and which line of code is producing it. Use a brief but descriptive summary of your problem as the title of your question.\r\n\r\nEliminate any issues that aren't relevant to the problem. If your question isn’t about a compiler error, ensure that there are no compile-time errors.\r\n\r\nDouble-check that your example reproduces the problem! If you inadvertently fixed the problem while composing the example but didn't test it again, you'd want to know that before asking someone else to help."
      }
    ]
  },
  {
    "number": 5420,
    "title": "Dry run or pretend run of migrations?",
    "created_at": "2020-01-26T19:06:41Z",
    "closed_at": "2020-10-14T06:28:15Z",
    "labels": [
      "question",
      "comp: migrations"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/5420",
    "body": "**Issue type:**\r\n\r\n[X] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\nIs there any way to try running the migrations to see if there are any errors, and always roll back?  This would be nice for apps where we just want to see if there would be migration errors first (with this dry-run), before stopping the app servers and running the migrations for real.",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/5420/comments",
    "author": "zxti",
    "comments": [
      {
        "user": "imnotjames",
        "created_at": "2020-10-14T06:28:15Z",
        "body": "Duplicate of #3037 "
      }
    ]
  },
  {
    "number": 5401,
    "title": "Entities from `.save()` getter issue",
    "created_at": "2020-01-22T21:32:16Z",
    "closed_at": "2020-10-06T06:43:48Z",
    "labels": [
      "question",
      "driver: postgres"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/5401",
    "body": "**Issue type:**\r\n\r\n[X] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[X] `postgres`\r\n[ ] `cockroachdb`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[X] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\nI have a entity like this, it has a \"getter\".\r\n\r\n```ts\r\n@ObjectType()\r\n@Entity()\r\nexport class User extends BaseEntity {\r\n\r\n  @Field(() => String, { nullable: true })\r\n  @Column({ type: PostgresColumn.VARCHAR, nullable: true })\r\n  stripeCustomerId: NullableColumn<string>\r\n\r\n  get requireStripeCustomerId(): ReadOnlyColumn<string> {\r\n    if (this.stripeCustomerId !== null) return this.stripeCustomerId\r\n    throw new Error('user is missing stripeCustomerId')\r\n  }\r\n\r\n}\r\n```\r\n\r\nFor some reason entities returned with `findOne` have the getter working, but entities returned with `save` do not.\r\n\r\nHow can I fix this?",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/5401/comments",
    "author": "reggi",
    "comments": [
      {
        "user": "imnotjames",
        "created_at": "2020-10-06T06:43:48Z",
        "body": "The values returned from `save` aren't entities.  They're what was persisted to the database and are mostly an artifact of how TypeORM works internally."
      }
    ]
  },
  {
    "number": 5387,
    "title": "Postgres emitted error goes unhandled (when a connection dies) - app crashes",
    "created_at": "2020-01-21T08:08:54Z",
    "closed_at": "2021-06-23T20:37:18Z",
    "labels": [
      "question",
      "driver: postgres"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/5387",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[x] `postgres`\r\n[ ] `cockroachdb`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n[ ] `@next`\r\n[x] `0.2.22` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nCreate a connection of type 'Postgres' with pg version > \"7.13.0\"\r\nRun a query (e.g. `select pg_sleep(8)`)\r\nTerminate the connection unexpectedly (e.g. disconnect from the DB side running the following SQL on your database from a different proccess)\r\n```sql\r\nSELECT pg_terminate_backend(pg_stat_activity.pid)\r\nFROM pg_stat_activity\r\nwhere query = 'select pg_sleep(8)';\r\n```\r\n\r\nThe app crashes with error:\r\n```sh\r\nevents.js:200\r\n      throw er; // Unhandled 'error' event\r\n      ^\r\n\r\nError: Connection terminated unexpectedly\r\n    at Connection.<anonymous> (/typeorm_debug/node_modules/pg/lib/client.js:255:9)\r\n    at Object.onceWrapper (events.js:312:28)\r\n    at Connection.emit (events.js:223:5)\r\n    at Socket.<anonymous> (/typeorm_debug/node_modules/pg/lib/connection.js:133:10)\r\n    at Socket.emit (events.js:228:7)\r\n    at endReadableNT (_stream_readable.js:1185:12)\r\n    at processTicksAndRejections (internal/process/task_queues.js:81:21)\r\nEmitted 'error' event on Client instance at:\r\n    at connectedErrorHandler (/typeorm_debug/node_modules/pg/lib/client.js:202:10)\r\n    at Connection.<anonymous> (/typeorm_debug/node_modules/pg/lib/client.js:272:9)\r\n    at Object.onceWrapper (events.js:312:28)\r\n    [... lines matching original stack trace ...]\r\n    at processTicksAndRejections (internal/process/task_queues.js:81:21)\r\n```\r\n\r\n--------------------------------------------------------\r\n\r\nI guess that there is an error being emitted and not being caught.\r\nCan a change in Typeorm prevent this?\r\n\r\nThanks",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/5387/comments",
    "author": "azigelman",
    "comments": [
      {
        "user": "smdesmet",
        "created_at": "2020-08-20T17:31:41Z",
        "body": "This error is emitted from the databaseConnection in PostgresQueryRunner.ts. If you install an error event listener on that databaseconnection, the application doesn't crash(the transaction is also not rolled back, so the query failed without typeorm knowing about it...)."
      },
      {
        "user": "GnanaRaga",
        "created_at": "2020-09-21T10:54:22Z",
        "body": "Could you please elaborate on how to install an error event listener on the databaseconnection "
      },
      {
        "user": "imnotjames",
        "created_at": "2021-06-23T20:37:18Z",
        "body": "Seems to be a Duplicate of #5112 "
      }
    ]
  },
  {
    "number": 5350,
    "title": "Dynamically switch database at runtime",
    "created_at": "2020-01-15T00:58:53Z",
    "closed_at": "2020-10-06T06:41:49Z",
    "labels": [
      "question",
      "driver: mssql"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/5350",
    "body": "**Issue type:**\r\n\r\n[ x] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[x ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[ ] `cockroachdb`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[x ] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\nHi. I would like to know if it's possible to set the database in a connection at runtime. I'm having a system where there are many tenants and each one has it's own isolated database. The structure of the databases are all exactly the same and i want to use the same entity classes in my code. But for data safety regulations, the data of the tenants need to be isolated in their own databases. So after a user logs in, i want to set the database name to be used at runtime. Is this possible? Thanks.",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/5350/comments",
    "author": "GBeushausen",
    "comments": [
      {
        "user": "totalard",
        "created_at": "2020-01-15T01:14:29Z",
        "body": "Dear,\r\n\r\nYou have to create each Connection per user.. Means, Create each Connection for Each Database and attach same configuration to it..And use newly created connection to query database."
      },
      {
        "user": "Mando75",
        "created_at": "2020-01-15T23:05:46Z",
        "body": "Yes you can. TypeORM exports a createConnection method that lets you specify all of your configurations. For example, here is a runtime connection method. You may want to modify this a bit so you aren't constantly creating new db connections if you already have one for the customer, but it at least gives you a starting place. \r\n\r\n```ts\r\nimport {createConnection} from 'typeorm'\r\nexport const createTypeORMConnection = async (customer) => {\r\n  // get things like cache, migration, subscribers, logging etc\r\n  const defaultOptions = getDefaultOptions()\r\n\r\n  return createConnection({\r\n    ...defaultOptions,\r\n    name: customer.name,\r\n    type: customer.dbType,\r\n    url: customer.dbUrl\r\n  });\r\n};\r\n\r\nconst getDefaultOptions = () => ({\r\n  synchronize: false,\r\n  logging: true,\r\n  entities: [\"dist/entity/**/*.js\"],\r\n  migrationsRun: true,\r\n  migrations: [\"dist/migration/**/*.js\"],\r\n  subscribers: [\"dist/subscriber/**/*.js\"],\r\n  cache: {\r\n    type: \"ioredis\",\r\n    duration: 2000\r\n  },\r\n  cli: {\r\n    entitiesDir: \"src/entity\",\r\n    migrationsDir: \"src/migration\",\r\n    subscribersDir: \"src/subscriber\"\r\n  }\r\n});\r\n\r\n```"
      },
      {
        "user": "KleinMaximus",
        "created_at": "2020-11-01T14:09:10Z",
        "body": "And how many connections can be created simultaneously? If I have 1000 users, each with its own database, can TypeORM support 1000 connections at the same time?"
      },
      {
        "user": "firmanjml",
        "created_at": "2022-03-21T02:46:50Z",
        "body": "> And how many connections can be created simultaneously? If I have 1000 users, each with its own database, can TypeORM support 1000 connections at the same time?\r\n\r\nI'm curious to know about this too.\r\nWill it cause serious performance issues if we created multiple connection simultaneously even when not actively using?"
      },
      {
        "user": "ahmedosama94",
        "created_at": "2022-04-13T09:00:26Z",
        "body": "> > And how many connections can be created simultaneously? If I have 1000 users, each with its own database, can TypeORM support 1000 connections at the same time?\r\n> \r\n\r\n\r\n> I'm curious to know about this too. Will it cause serious performance issues if we created multiple connection simultaneously even when not actively using?\r\n\r\nSame question here\r\n"
      },
      {
        "user": "SpeedoPasanen",
        "created_at": "2022-04-29T07:52:20Z",
        "body": "Here's a (probably) working example. Not tested, just wrote it down here because I think I'll need this in the future. :)\r\n\r\nCache the connections as Promises, so if someone requests a connection while one is being created for the same Tenant, both requesters receive the same instance. Awaiting before caching would cause memory leaks. Keep connections alive for a certain time and then close.\r\n\r\nToo short TTL and  users will constantly have to wait for a new connection. Too long and (maybe) too many simultaneous connections. I'd keep it long and lower it if problems arise.\r\n\r\nAs for performance, I think as long as your DB allows that many connections, having 1000 open won't cause big performance issues in NodeJS. They are basically socket connections, not a big memory or CPU hit. Based on my deduction, take with a grain of salt.\r\n\r\nHaving said all, in my use case all DB:s would be on the same server, so I'll keep investigating if it's possible to use one connection and just change the DB name on the fly.\r\n\r\n```Typescript\r\nimport { Connection, createConnection } from 'typeorm';\r\n\r\nexport interface Tenant {\r\n  id: string | number;\r\n}\r\nexport interface ConnectionCacheItem {\r\n  connection: Promise<Connection>;\r\n  timeout: NodeJS.Timeout;\r\n}\r\n\r\nconst cache = new Map<string | number, ConnectionCacheItem>();\r\n\r\n// Keep connections open for X ms after being last used.\r\nconst TTL =  process.env.DB_CONNECTION_TTL || 8 * 60 * 60 * 1000;\r\n\r\nexport const getTenantConnection = async (tenant: Tenant): Promise<Connection> => {\r\n  const cached = cache.get(tenant.id);\r\n  const connection = cached\r\n    ? cached.connection\r\n    : createConnection(getOptions(tenant));\r\n  if (cached) {\r\n    clearTimeout(cached.timeout);\r\n  }\r\n  cache.set(tenant.id, {\r\n    timeout: setTimeout(() => {\r\n      clearCache(tenant);\r\n    }, TTL),\r\n    connection,\r\n  });\r\n  return cache.get(tenant.id).connection;\r\n};\r\n\r\nconst clearCache = async (tenant: Tenant): Promise<void> => {\r\n  const cached = cache.get(tenant.id);\r\n  if (cached) {\r\n    cache.delete(tenant.id);\r\n    (await cached.connection).close();\r\n  }\r\n};\r\n\r\nconst getOptions = (tenant: Tenant): any => {\r\n  // TODO: implement\r\n  throw new Error('Not implemented');\r\n};\r\n\r\n```"
      },
      {
        "user": "strivelabs-pablorb",
        "created_at": "2023-10-16T10:08:30Z",
        "body": "We do something similar as u mention @SpeedoPasanen. And we have the same use case where all databases are accessible from the same server. I was wondering if you managed to solve what u mentioned: \" I'll keep investigating if it's possible to use one connection and just change the DB name on the fly.\"\r\n\r\nI was thinking of establishing a connection to an empty database or to the Postgres one and then with query builder request data from the db that the user needs. But I am not so sure if there are any risks in having the connection to the Postgres db while having an empty db just for the sake of establishing the connection looks like a Hack that might cause issues latter."
      }
    ]
  },
  {
    "number": 5321,
    "title": "Mongo - properties that aren't defined are saved to database",
    "created_at": "2020-01-11T16:54:40Z",
    "closed_at": "2021-07-05T06:29:13Z",
    "labels": [
      "bug",
      "question",
      "driver: mongodb"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/5321",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[x] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[ ] `cockroachdb`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\n```\r\n@Entity()\r\nexport class User {\r\n  @ObjectIdColumn()\r\n  id: number;\r\n\r\n  @Column()\r\n  firstName?: string;\r\n}\r\n\r\nrepo.save({\r\n  firstName: 'My',\r\n  lastName: 'Me' //<- This is possible, although it's not defined! \r\n})\r\n\r\n```\r\n\r\nIs there a possibility to forbid saving not described properties?\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/5321/comments",
    "author": "flobiber",
    "comments": [
      {
        "user": "Davut97",
        "created_at": "2020-08-28T16:52:48Z",
        "body": "Can i take this? "
      }
    ]
  },
  {
    "number": 5314,
    "title": "getCount(). Perfs issues for multi columns primary key",
    "created_at": "2020-01-10T14:42:25Z",
    "closed_at": "2020-10-09T06:22:09Z",
    "labels": [
      "question",
      "driver: postgres"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/5314",
    "body": "**Issue type:**\r\n\r\n[X ] question\r\n\r\n**Database system/driver:**\r\n[X ] `postgres`\r\n\r\nVersion 0.2.18\r\n\r\nI'm facing a perf issue when running getCount()\r\nWhy when counting all records of a query, queryBuilder creates a SQL query that concatenates the columns that are part of the primary key ?\r\n\r\n**Typescript  :** \r\n```\r\nconst query: SelectQueryBuilder<TEntity> = dbConnection\r\n\t\t\t\t\t.getRepository<TEntity>(entity)\r\n\t\t\t\t\t.createQueryBuilder(entity.name)\r\n\t\t\t\t\t.where(`\"${entity.name}\".\"${id}\"= :val`, {\r\n\t\t\t\t\t\tval: value.toLowerCase(),\r\n\t\t\t\t\t});\r\n\r\n\t\t\t\tconst totalRecords: number = await query.getCount();\r\n```\r\n\r\n**generated sql**\r\n```\r\nSELECT COUNT(DISTINCT(\r\n\tCONCAT(\r\n\t\t\"u\".\"a\", \r\n\t\t\"u\".\"b\",\r\n\t\t\"u\".\"c\")\r\n\t)\r\n) as \"cnt\" FROM \"sc\".\"tbl\" \"u\"\r\n```\r\n\r\nThat is destroying the performances for a table of 140K records. \r\nCreating an index on CONCAT using is not efficient, hard to maintain with 100 of tables, knowing that for some tables, some primay comumns are timestamp...\r\n\r\nIs there a way or a parameter to set to avoid the concat and just running a kind of (`select count(1) FROM \"sc\".\"tbl\" \"u\"`) ?\r\n\r\nRgds\r\n\r\n\r\n\r\n\r\n\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/5314/comments",
    "author": "jeromeSH26",
    "comments": [
      {
        "user": "Destreyf",
        "created_at": "2020-01-10T21:33:06Z",
        "body": "@jeromeSH26 \r\n\r\nI haven't used any multi-column keys, can you try this?\r\n\r\n```typescript\r\nconst query: SelectQueryBuilder<TEntity> = dbConnection\r\n\t\t\t\t\t.getRepository<TEntity>(entity)\r\n\t\t\t\t\t.createQueryBuilder(entity.name)\r\n\t\t\t\t\t.select(\"COUNT(*)\", \"count\")\r\n\t\t\t\t\t.where(`\"${entity.name}\".\"${id}\"= :val`, {\r\n\t\t\t\t\t\tval: value.toLowerCase(),\r\n\t\t\t\t\t});\r\n\r\nconst totalRecords: number = await query.getRawOne().then(r => r.count);\r\n```\r\n\r\nThis is how i perform my queries, but i'm also using it in a mixed scenario of count/sum/avg so i use the getOneRaw quite a bit."
      },
      {
        "user": "jeromeSH26",
        "created_at": "2020-01-11T09:37:30Z",
        "body": "Hi Chris,\r\nthanks for your feedback \r\nI tried your solution and that runs 4.5 faster than the native getCount() (147ms Vs 680ms). Il will go with that solution, since I'm using generic resolvers for typegraphql, so the modification to access DB is easy to maintain, as this is centralized in a single function.\r\nHowever it seems to me more a workaround as a solution. I would expect the native getCount() to be optimizable. But with a `COUNT(DISTINCT(CONCAT(....)))`  query, difficult to optimize as it impacts the design of the DB (need to add specific BTREE indexes) just for a count..\r\n\r\nWill close the issue later on, in case some team guys designing typeorm (which is a fantastic tool btw) want to give us some clues\r\n\r\nRgds\r\n\r\nThis is how I have refactored the query :\r\n```\r\nconst rootQuery = dbConnection\r\n\t.getRepository<TEntity>(entity)\r\n\t.createQueryBuilder(entity.name);\r\n\r\nconst countQuery = rootQuery.select(\"COUNT(1)\", \"cnt\");\r\nconst { cnt }: { cnt: number } = await countQuery.getRawOne();\r\n\r\nlet query = rootQuery\r\n\t.cache(withCache)\r\n\t.skip(start)\r\n\t.take(nbRecords);\r\n\r\n\tconst records: TEntity[] = await query.getMany();\r\n\r\n```"
      },
      {
        "user": "Destreyf",
        "created_at": "2020-01-11T11:38:44Z",
        "body": "@jeromeSH26 i 100% agree that the getCount function should be flexible/adjustable, unfortunately i'm not a maintainer on this project."
      },
      {
        "user": "jeromeSH26",
        "created_at": "2020-01-11T14:18:47Z",
        "body": "Yep, that's why I leave this question opened for a while"
      },
      {
        "user": "dsbert",
        "created_at": "2020-05-01T16:05:31Z",
        "body": "Note this also causes incorrect counts to be returned.\r\n\r\nHere is an example.\r\n\r\nYou have two number columns set as primary keys - `field1` and `field2`.\r\n\r\nThe following two rows will return the incorrect count.\r\n\r\n```\r\n{\r\n\tfield1: 11,\r\n\tfield2: 101\r\n\t// concat(field1, field2) = '11101'\r\n},\r\n{\r\n\tfield1: 1,\r\n\tfield2: 1101\r\n\t// concat(field1, field2) = '11101'\r\n},\r\n```\r\n\r\nCount should be 2, but returns 1.\r\n"
      },
      {
        "user": "imnotjames",
        "created_at": "2020-10-08T08:23:30Z",
        "body": "> Is there a way or a parameter to set to avoid the concat and just running a kind of (select count(1) FROM \"sc\".\"tbl\" \"u\") ?\r\n\r\nIn cases with joins this won't work.  If there are no joins it's possible to be a performance improvement we could apply but we'd need a number of tests to validate behavior."
      },
      {
        "user": "imnotjames",
        "created_at": "2020-10-08T19:35:58Z",
        "body": "Can you confirm that #6870 fixes the issues you're seeing?"
      }
    ]
  },
  {
    "number": 5300,
    "title": "How to enforced not to run update,delete query without condition ?",
    "created_at": "2020-01-08T04:30:35Z",
    "closed_at": "2020-10-12T09:27:28Z",
    "labels": [
      "question",
      "driver: postgres"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/5300",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[x] `postgres`\r\n[ ] `cockroachdb`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n----\r\nHi I am new to typeorm, as I learning how to use, I see that I can easily make a mistake (like typo, misunderstand api,...) when I write update or delete query using query builder and it run without where condition and end up with all data getting updated or deleted. So my question is that in typeorm is there any option or a hacky way that when a update or delete query running without a where condition it will throw error to prevent these kind of mistake for newbie ?. Thank you",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/5300/comments",
    "author": "hong-duc",
    "comments": [
      {
        "user": "angelvega93",
        "created_at": "2020-01-09T10:36:46Z",
        "body": "If you run a delete query without conditions its normal to delete all data.\r\n\r\nThis is not a TypeORM problem, you need to validate before sending the query."
      },
      {
        "user": "hong-duc",
        "created_at": "2020-01-10T00:29:18Z",
        "body": "@angelvega93 yes and that why this is a question, not bug report, thank you very much"
      },
      {
        "user": "Destreyf",
        "created_at": "2020-01-11T04:27:29Z",
        "body": "@hong-duc To answer your question directly, TypeORM does not have any sort of developer safety functionality built into it, you could probably write your own validation/restriction logic, but this could end up being very cumbersome and ultimately may not make a lot of sense for your use case."
      },
      {
        "user": "hong-duc",
        "created_at": "2020-01-11T13:16:31Z",
        "body": "@Destreyf thank you for your answer. \r\nI know this is a naive question but I have my reason. Right now only me using typeorm, but I want my team to use it too. I can guarantee that some will make the same mistake as me. That is why I ask this question to make sure they fail with an error rather than a database delete"
      },
      {
        "user": "anton-bot",
        "created_at": "2020-08-26T12:07:26Z",
        "body": "Just for context, it's possible to unintentionally delete the entire table by providing arguments to .delete() in a wrong format: #6620 "
      },
      {
        "user": "imnotjames",
        "created_at": "2020-10-12T09:27:27Z",
        "body": "Duplicate of #3416 "
      }
    ]
  },
  {
    "number": 5274,
    "title": "findOne({ someField: undefined }) vs findOne({ someField: null})",
    "created_at": "2020-01-01T21:45:47Z",
    "closed_at": "2020-10-12T09:27:17Z",
    "labels": [
      "bug",
      "question",
      "driver: sqlite"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/5274",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[x] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[ ] `cockroachdb`\r\n[x] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nWhen calling findOne() on a table with a column that is marked as nullable, if you pass `undefined` for that column in the select condition, the query does find any entry. If you pass `null` instead of `undefined`, there there is a typing error (see below for the exact message)\r\n\r\nHere's a small example to reproduce the problem:\r\n\r\n```typescript\r\n@Entity()\r\nclass Person {\r\n\r\n    @PrimaryGeneratedColumn()\r\n    id!: number\r\n\r\n    @Column()\r\n    name!: string\r\n\r\n    @Column({ nullable: true })\r\n    age?: number\r\n}\r\n\r\n\r\n(async () => {\r\n\r\n    const connection = await createConnection({\r\n        type: \"sqlite\",\r\n        database: \":memory:\",\r\n        synchronize: true,\r\n        logging: true,\r\n        entities: [Person]\r\n    })\r\n\r\n    const repo = connection.getRepository(Person)\r\n    const name = \"John\"\r\n\r\n    await repo.save(repo.create({ name }))\r\n\r\n    const result = [\r\n        await repo.findOne({ name, }),  // (1) works OK\r\n        await repo.findOne({ name, age: undefined }), // (2) returns undefined\r\n        await repo.findOne({ name, age: null }), // (3) does not compile, typing error\r\n    ]\r\n\r\n    console.log(result)\r\n})()\r\n```\r\nWhen you try and run this with ts-node, this you get typing error on (3):\r\n\r\n```\r\n    return new TSError(diagnosticText, diagnosticCodes)\r\n           ^\r\nTSError: ⨯ Unable to compile TypeScript:\r\nsource/backend/index.ts:92:15 - error TS2769: No overload matches this call.\r\n  Overload 1 of 3, '(id?: string | number | Date | ObjectID | undefined, options?: FindOneOptions<Person> \r\n| undefined): Promise<Person | undefined>', gave the following error.\r\n    Argument of type '{ name: string; age: null; }' is not assignable to parameter of type 'string | number | Date | ObjectID | undefined'.\r\n      Object literal may only specify known properties, and 'name' does not exist in type 'Date | ObjectID'.\r\n  Overload 2 of 3, '(options?: FindOneOptions<Person> | undefined): Promise<Person | undefined>', gave the following error.\r\n    Argument of type '{ name: string; age: null; }' is not assignable to parameter of type 'FindOneOptions<Person>'.\r\n      Object literal may only specify known properties, and 'name' does not exist in type 'FindOneOptions<Person>'.\r\n  Overload 3 of 3, '(conditions?: FindConditions<Person> | undefined, options?: FindOneOptions<Person> | undefined): Promise<Person | undefined>', gave the following error.\r\n    Argument of type '{ name: string; age: null; }' is not assignable to parameter of type 'FindConditions<Person>'.\r\n      Types of property 'age' are incompatible.\r\n        Type 'null' is not assignable to type 'number | FindOperator<number | undefined> | undefined'.    \r\n\r\n92         await repo.findOne({ name, age: null }),\r\n                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n\r\n\r\n    at createTSError (C:\\Code\\mixarr\\node_modules\\ts-node\\src\\index.ts:293:12)\r\n    at reportTSError (C:\\Code\\mixarr\\node_modules\\ts-node\\src\\index.ts:297:19)\r\n    at getOutput (C:\\Code\\mixarr\\node_modules\\ts-node\\src\\index.ts:399:34)\r\n    at Object.compile (C:\\Code\\mixarr\\node_modules\\ts-node\\src\\index.ts:457:32)\r\n    at Module.m._compile (C:\\Code\\mixarr\\node_modules\\ts-node\\src\\index.ts:536:43)\r\n    at Module._extensions..js (internal/modules/cjs/loader.js:995:10)\r\n    at Object.require.extensions.<computed> [as .ts] (C:\\Code\\mixarr\\node_modules\\ts-node\\src\\index.ts:539:12)\r\n    at Module.load (internal/modules/cjs/loader.js:815:32)\r\n    at Function.Module._load (internal/modules/cjs/loader.js:727:14)\r\n    at Function.Module.runMain (internal/modules/cjs/loader.js:1047:10)\r\nerror Command failed with exit code 1.\r\n```\r\n\r\nIf you comment out (3), here's the output:\r\n\r\n```\r\nquery: BEGIN TRANSACTION\r\nquery: SELECT * FROM \"sqlite_master\" WHERE \"type\" = 'table' AND \"name\" IN ('person')\r\nquery: SELECT * FROM \"sqlite_master\" WHERE \"type\" = 'index' AND \"tbl_name\" IN ('person')\r\nquery: SELECT * FROM \"sqlite_master\" WHERE \"type\" = 'table' AND \"name\" = 'typeorm_metadata'\r\nquery: CREATE TABLE \"person\" (\"id\" integer PRIMARY KEY AUTOINCREMENT NOT NULL, \"name\" varchar NOT NULL, \"age\" integer)\r\nquery: COMMIT\r\nquery: BEGIN TRANSACTION\r\nquery: INSERT INTO \"person\"(\"id\", \"name\", \"age\") VALUES (NULL, ?, NULL) -- PARAMETERS: [\"John\"]\r\nquery: COMMIT\r\n\r\n// Here are the generated query\r\nquery: SELECT \"Person\".\"id\" AS \"Person_id\", \"Person\".\"name\" AS \"Person_name\", \"Person\".\"age\" AS \"Person_age\" FROM \"person\" \"Person\" WHERE \"Person\".\"name\" = ? LIMIT 1 -- PARAMETERS: [\"John\"]\r\nquery: SELECT \"Person\".\"id\" AS \"Person_id\", \"Person\".\"name\" AS \"Person_name\", \"Person\".\"age\" AS \"Person_age\" FROM \"person\" \"Person\" WHERE \"Person\".\"name\" = ? AND \"Person\".\"age\" = ? LIMIT 1 -- PARAMETERS: [\"John\",null]\r\n\r\n// Here's the result (1) works, and (2) is undefined\r\n[ Person { id: 1, name: 'John', age: null }, undefined ]\r\n```\r\nSo given a `name`and an `age` (potentially `undefined`), I don't know how to find a match properly:\r\n- if I call `findOne({name,age})` i get `undefined`\r\n- if I call `findOne({name, age: age || null}` i get an error.\r\n\r\nI would expect `findOne({name,age})` to return the match in this case.\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/5274/comments",
    "author": "meuter",
    "comments": [
      {
        "user": "xileftenurb",
        "created_at": "2020-06-02T13:12:00Z",
        "body": "as a possible workaround, you could use this syntax :\r\n```\r\n{\r\n    name,\r\n    ...age && {age}\r\n}\r\n```\r\nthis will send to typeorm `{name}` if age is truthy, and {name, age} if it's falsy.\r\nof course, it would be better to have a correct handling on the typeorm side, but for the moment, the workaround should work."
      },
      {
        "user": "meuter",
        "created_at": "2020-08-01T17:01:51Z",
        "body": "Thanks for the workaround!"
      },
      {
        "user": "imnotjames",
        "created_at": "2020-10-12T09:27:17Z",
        "body": "Duplicate of #3416 "
      }
    ]
  },
  {
    "number": 5247,
    "title": "How to debug TypeOrm with typescript and VisualStudio",
    "created_at": "2019-12-22T15:53:02Z",
    "closed_at": "2020-01-05T20:33:03Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/5247",
    "body": "**Issue type:**\r\n\r\n[ x] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ x] `oracle`\r\n[ ] `postgres`\r\n[ ] `cockroachdb`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[ x] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here\r\n\r\nI have problems to debug a TypeOrm scaffolded application using typescript and VisualStudio.\r\n\r\nCan you give me a valid launch.json configuration and some advice to make it work? \r\n\r\nI can successfully debug other script not using TypeOrm API\r\n\r\nThank you\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/5247/comments",
    "author": "yanosh1982",
    "comments": [
      {
        "user": "Kononnable",
        "created_at": "2020-01-02T14:49:45Z",
        "body": "Ok, but what is the problem? \r\nYou've said that you can debug other scripts but not something connected with typeorm. Any errors?"
      },
      {
        "user": "yanosh1982",
        "created_at": "2020-01-05T20:33:03Z",
        "body": "I've already solved my problem. Thank you and sorry. "
      }
    ]
  },
  {
    "number": 5239,
    "title": "Error: ER_DUP_FIELDNAME: Duplicate column name 'Entity_Id'",
    "created_at": "2019-12-18T15:21:51Z",
    "closed_at": "2021-06-25T03:44:39Z",
    "labels": [
      "bug",
      "question",
      "can be closed?",
      "driver: mysql",
      "driver: mariadb"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/5239",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[x] bug report\r\n**Database system/driver:**\r\n\r\n[x] `mysql` / `mariadb`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `0.3.0-rc.2`\r\n\r\n**Code**\r\n\r\n``` ts\r\n@Entity({name: 'entityAttributes'})\r\nexport class EntityAttribute {\r\n    @PrimaryColumn({name: 'Entity_Id'})\r\n    entityId: number;\r\n\r\n    @ManyToOne(type => Entity, e => e.attributes)\r\n    @JoinColumn({name: 'Entity_Id'})\r\n    entity: Entity;\r\n}\r\n```\r\n** Explanation **\r\nWhen I create this table with Typeorm it tries to create the Entity_Id twice since it was mapped twice too.\r\n\r\n```SQL\r\n...\r\nALTER TABLE `facattributes` ADD `Fac_Id` int NOT NULL\r\nALTER TABLE `facattributes` ADD `Fac_Id` int NOT NULL\r\n\r\nquery failed: ALTER TABLE `facattributes` ADD `fac_Id` int NOT NULL\r\n\r\n    error: { Error: ER_DUP_FIELDNAME: Duplicate column name 'fac_Id'\r\n...\r\n```\r\nCan I do something to solve this problem or do I need to make a schema change?\r\n\r\nAny help is wellcome.\r\nThanks.",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/5239/comments",
    "author": "separovichabel",
    "comments": [
      {
        "user": "ladrahul00",
        "created_at": "2020-07-22T05:06:31Z",
        "body": "@separovichabel any luck with this?\r\nI am trying to use a custom naming strategy but did not get anything till now.\r\nUpdate: Upgrading to typeorm@0.2.25 fixed this for me. \r\n"
      },
      {
        "user": "separovichabel",
        "created_at": "2020-07-22T11:46:19Z",
        "body": "@wolf00 \r\nNice. Because of work, I left this issue aside. \r\nThanks for the comment. I will test and maybe close the issue"
      },
      {
        "user": "imnotjames",
        "created_at": "2021-06-25T03:44:39Z",
        "body": "When opening an issue, people will be better able to provide help if you provide code that they can easily understand and use to reproduce the problem. This boils down to ensuring your code that reproduces the problem follows the following guidelines:\r\n\r\n* Minimal – Use as little code as possible that still produces the same problem\r\n* Complete – Provide all parts someone else needs to reproduce your problem in the question itself\r\n* Reproducible – Test the code you're about to provide to make sure it reproduces the problem\r\n\r\n## Minimal\r\nThe more code there is to go through, the less likely people can find your problem. Streamline your example in one of two ways:\r\n\r\n1. Restart from scratch. Create a new program, adding in only what is needed to see the problem. Use simple, descriptive names for functions and variables – don’t copy the names you’re using in your existing code.\r\n2. Divide and conquer. If you’re not sure what the source of the problem is, start removing code a bit at a time until the problem disappears – then add the last part back.\r\n\r\nDon't sacrifice clarity for brevity when creating a minimal example. Use consistent naming and indentation, and include code comments if needed. Use your code editor’s shortcut for formatting code.\r\n\r\nDon't include any passwords or credentials that must be kept secret.\r\n\r\n## Complete\r\n\r\nMake sure all information necessary to reproduce the problem is included in the issue itself.\r\n\r\nIf the problem requires some code as well as some XML-based configuration, include code for both. The problem might not be in the code that you think it is in.\r\n\r\nUse individual code blocks for each file or snippet you include. Provide a description for the purpose of each block.\r\n\r\n**DO NOT** use images of code. Copy the actual text from your code editor, paste it into the issus, then format it as code. This helps others more easily read and test your code.\r\n\r\n## Reproducible\r\n\r\nTo help you solve your problem, others will need to verify that it exists.\r\n\r\nDescribe the problem. \"It doesn't work\" isn't descriptive enough to help people understand your problem. Instead, tell other readers what the expected behavior should be. Tell other readers what the exact wording of the error message is, and which line of code is producing it. Use a brief but descriptive summary of your problem as the title of your question.\r\n\r\nEliminate any issues that aren't relevant to the problem. If your question isn’t about a compiler error, ensure that there are no compile-time errors.\r\n\r\nDouble-check that your example reproduces the problem! If you inadvertently fixed the problem while composing the example but didn't test it again, you'd want to know that before asking someone else to help."
      }
    ]
  },
  {
    "number": 5229,
    "title": "Why does querybuilder on manager only returns raw results?",
    "created_at": "2019-12-13T13:12:36Z",
    "closed_at": "2021-07-03T05:57:20Z",
    "labels": [
      "question",
      "comp: query builder",
      "driver: postgres"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/5229",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[x] `postgres`\r\n[ ] `cockroachdb`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n\r\nHey, why i can only retrieve raw results when using getManager() and from()?\r\n\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n```ts\r\n// result is undefined\r\nconst tmp = await getManager().createQueryBuilder()\r\n      .from(CronJob, 'cronjob')\r\n      .getOne();\r\n\r\n// contains correct raw results\r\nconst tmp2 = await getManager().createQueryBuilder()\r\n      .from(CronJob, 'cronjob')\r\n      .getRawOne();\r\n\r\n// contains correct entity\r\nconst tmp3 = await getRepository(CronJob).createQueryBuilder()\r\n      .getOne();\r\n```\r\n\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/5229/comments",
    "author": "bobo-le",
    "comments": [
      {
        "user": "imnotjames",
        "created_at": "2021-07-03T05:57:20Z",
        "body": "Pass the entity to `createQueryBuilder`"
      }
    ]
  },
  {
    "number": 5223,
    "title": "\"Connection terminated unexpectedly\" and \"Client has encountered a connection error and is not queryable\"",
    "created_at": "2019-12-11T14:51:53Z",
    "closed_at": "2020-10-06T06:08:48Z",
    "labels": [
      "question",
      "driver: postgres"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/5223",
    "body": "**Issue type:**\r\n\r\n[x ] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[x ] `postgres`\r\n[ ] `cockroachdb`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[ ] `latest`\r\n[ ] `@next`\r\n[x ] `0.2.20` (or put your version here)\r\n\r\nHello,\r\nI'm seeing the problem that at one point in a Google Cloud function environment Typeorm looses the database connection to Postgres \"Connection terminated unexpectedly\".\r\nThat by itselfs is probably not that big of an issue because as I understand it Typeorm automatically reconnects when the connection has been lost. (I confirmed this in local tests where I simply shut down the database server, watching the application recovering on its own)\r\n\r\nMy problem is that this does not happen in our production environment.\r\nAfter seeing the \"Connection terminated unexpectedly\" error the connection continues to fail with the error \"Client has encountered a connection error and is not queryable\".\r\n\r\nCan you point me to some approach to handling this failing connection?\r\nHow can I detect this condition and how can I reconnect?\r\nMaybe there's some configuration that is missing?",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/5223/comments",
    "author": "seriousManual",
    "comments": [
      {
        "user": "0x8f701",
        "created_at": "2020-03-26T12:56:35Z",
        "body": "same problem"
      },
      {
        "user": "stavalfi",
        "created_at": "2020-07-01T10:17:44Z",
        "body": "any update?"
      },
      {
        "user": "AlexSun98",
        "created_at": "2020-07-15T08:45:35Z",
        "body": "same!"
      },
      {
        "user": "imnotjames",
        "created_at": "2020-10-06T06:08:48Z",
        "body": "Pretty sure this is a duplicate of #5112 "
      }
    ]
  },
  {
    "number": 5216,
    "title": "Tables created in custom migrations are not created in the schema defined in the connection",
    "created_at": "2019-12-10T17:34:11Z",
    "closed_at": "2021-05-20T15:13:39Z",
    "labels": [
      "question",
      "comp: migrations",
      "driver: postgres",
      "by design"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/5216",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[x] `postgres`\r\n[ ] `cockroachdb`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nI create a typeorm migration which creates a new table exampletbl: \r\n```\r\nawait queryRunner.query(`CREATE TABLE \"exampletb\" ()`);\r\n```\r\n\r\nMy connection is defined to connect to the `core` schema, which is not the `public` schema: \r\n```\r\nconnectionOptions = {\r\n    ..await getConnectionOptions(),\r\n    name: 'local',\r\n    schema: 'core'\r\n};\r\nawait createConnections([connectionOptions]);\r\nconnection = await getConnection('local');\r\nawait connection.runMigrations();\r\n```\r\n\r\nWhen I execute the migration, the table is created in the `public` schema where I'd expect it to be created in the `core` schema. Is that how typeorm is supposed to work or a is this a bug?\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/5216/comments",
    "author": "paweloque",
    "comments": [
      {
        "user": "harikvpy",
        "created_at": "2019-12-17T15:00:52Z",
        "body": "I believe that is how it is supposed to work.\r\n\r\nCurrently, schema support is 'hard-wired' to the entity in its declaration. Meaning that the schema for an entity can be specified in the Entity decorator and if so declared, those entities will be created in the specified schema.\r\n\r\nYou can test it out. Use `@Entity({schema: <schemaName>})`.\r\n\r\nI'm by no means an expert in TypeORM having picked it up in the last couple of weeks. So do test out my deduction with a live example."
      }
    ]
  },
  {
    "number": 5153,
    "title": "Custom Validator ",
    "created_at": "2019-11-28T17:07:32Z",
    "closed_at": "2020-10-06T06:45:01Z",
    "labels": [
      "question",
      "driver: postgres"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/5153",
    "body": "**Issue type:**\r\n\r\n[X ] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[X ] `postgres`\r\n[ ] `cockroachdb`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[ X] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\nIs there an option to validate a parameter which is a string, that can be one of Enum values or just a string of numbers. \r\n\r\nFor example:\r\n\r\ndto:\r\n```\r\n  @ApiModelProperty()\r\n  @IsString()\r\n  phone_number_expression: string;\r\n```\r\n\r\nenum:\r\n``` \r\nexport enum BlockingOptions {\r\n  INFORMATION = 'INFORMATION',\r\n  BLOCKED = 'BLOCKED',\r\n}\r\n```\r\n\r\nphone_number_expression can be one of the values of BlockingOptions OR some string number: for example \"123\". \r\n\r\nIs it possible to add a special validator for that?\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/5153/comments",
    "author": "mgeisman",
    "comments": [
      {
        "user": "TrejGun",
        "created_at": "2019-11-29T21:59:10Z",
        "body": "yes you can\r\n\r\n```js\r\nimport {\r\n  ValidationArguments,\r\n  ValidationOptions,\r\n  ValidatorConstraint,\r\n  ValidatorConstraintInterface,\r\n} from \"class-validator\";\r\n\r\n\r\n@ValidatorConstraint()\r\nclass CustomValidation implements ValidatorConstraintInterface {\r\n  private reason: string;\r\n\r\n  public validate(value: any, args: ValidationArguments): boolean {\r\n    this.reason = this.isValid(value, args);\r\n    return !this.reason;\r\n  }\r\n\r\n  public defaultMessage(): string {\r\n    return this.reason;\r\n  }\r\n\r\n  private isValid(value: any, args: ValidationArguments): string {\r\n \r\n   // do your validation here\r\n   // return \"error\";\r\n\r\n    return \"\";\r\n  }\r\n}\r\n```"
      },
      {
        "user": "imnotjames",
        "created_at": "2020-10-06T06:45:01Z",
        "body": "I'd definitely suggest using a third party library for business-logic validations.  We're probably not going to add it natively in TypeORM."
      }
    ]
  },
  {
    "number": 5149,
    "title": "Create query builder with \"with\" clause in Postgres",
    "created_at": "2019-11-27T08:19:26Z",
    "closed_at": "2020-10-10T12:05:15Z",
    "labels": [
      "question",
      "driver: postgres"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/5149",
    "body": "**Issue type:**\r\n\r\n[*] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[*] `postgres`\r\n[ ] `cockroachdb`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[*] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nI have raw query like this: \r\n```\r\nWITH w AS (UPDATE foo SET foo_type = 'WOW' WHERE foo_uuid = 17 RETURNING \"foo_uuid\", \"foo_paired_to\", \"foo_type\")\r\nSELECT bar.name, w.foo_uuid, w.foo_type\r\nFROM bar, w\r\nWHERE bar.id = w.foo_paired_to;\r\n```\r\nHow to convert that into a query builder with typeorm? ",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/5149/comments",
    "author": "dennbagas",
    "comments": [
      {
        "user": "Ginden",
        "created_at": "2019-12-04T16:17:59Z",
        "body": "Duplicate of #1116"
      },
      {
        "user": "fullofcaffeine",
        "created_at": "2020-03-14T00:39:18Z",
        "body": "I'm also looking into how to use `with` (recursive) with the `QueryBuilder`."
      },
      {
        "user": "imnotjames",
        "created_at": "2020-10-10T12:05:15Z",
        "body": "Duplicate of #1116"
      }
    ]
  },
  {
    "number": 5144,
    "title": "Strict Entity creation?",
    "created_at": "2019-11-26T06:49:40Z",
    "closed_at": "2021-07-04T01:12:37Z",
    "labels": [
      "question",
      "new feature",
      "documentation"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/5144",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[ ] bug report\r\n[x] feature request\r\n[x] documentation issue\r\n\r\nEntityManager.create() and other similar typeorm methods take a DeepPartial.  This means you can easily omit fields, esp. as you evolve the schema and add more new fields over time - you have to be diligent in ensuring the places that create objects are always passing all fields.\r\n\r\nIs there a way to create a type-safe variant of this (without handcrafting a specialized function for every single DB type in a large schema)?  Something that is similar to .create() but requires all fields, except that foreign relationship fields can still accept e.g. `{id: \"...\"}` objects so that you don't have to actually fetch the full related object if you already have the ID handy? \r\n\r\nWe are thinking of heading down the codegen path, but not sure if there was a simple solution we are overlooking.  Thanks.",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/5144/comments",
    "author": "zxti",
    "comments": [
      {
        "user": "Quesstor",
        "created_at": "2021-02-28T11:24:53Z",
        "body": "Did you find a solution yet?"
      },
      {
        "user": "imnotjames",
        "created_at": "2021-07-04T01:12:37Z",
        "body": "You'll want to use constructors or helpers for this.  `create` is effectively doing exactly what happens with deserialization.  We don't do validation & don't plan on it.  TypeORM relies on the database to enforce this."
      },
      {
        "user": "apiel51",
        "created_at": "2022-07-08T16:45:13Z",
        "body": "Arriving here after hitting a bug caused by failing to update all `create` calls for an entity after adding a non-nullable column.\r\n\r\n@imnotjames Curious what the rationale is behind choosing not to validate entity creation - it seems to follow the TypeORM ethos of providing static type-checking to DB interactions."
      },
      {
        "user": "imnotjames",
        "created_at": "2022-07-08T16:49:05Z",
        "body": "Because the problem set of run time validation in typescript varies widely.  There are a number of tools that solve this, and there are use cases where you would not want run time validation.\n\nPlus, like I said, the database should be performing validation during run time.\n\nAnd typeorm doesn't do the static analysis bits, typescript does :)"
      },
      {
        "user": "apiel51",
        "created_at": "2022-07-28T19:51:00Z",
        "body": "@imnotjames \r\nSorry if I was a bit vague - I'm specifically asking about _static type-checking_ related to `DeepPartial` like the original question outlines. And I understand that TypeORM doesn't provide static analysis, but it _does_ define the types that TS uses for validation. Having the DB handling runtime validation makes sense, but catching these bugs before they run is kind of the whole point of static analysis, right?"
      }
    ]
  },
  {
    "number": 5111,
    "title": "How to return a relation column as top level in response?",
    "created_at": "2019-11-19T17:39:56Z",
    "closed_at": "2021-07-03T21:22:39Z",
    "labels": [
      "question",
      "driver: postgres"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/5111",
    "body": "**Issue type:**\r\n\r\n[X] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[X] `postgres`\r\n[ ] `cockroachdb`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[X] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nSuppose I have 2 Entites:\r\n\r\nEntity1\r\n- id\r\n- entity2Id\r\n\r\nEntity2\r\n- id\r\n- someValue\r\n\r\nI want to join and receive the response as:\r\n\r\nEntity 1 {\r\n  id,\r\n  entity2Id,\r\n  someValue\r\n}\r\n\r\nbut with getMany I receive:\r\n\r\nEntity 1 {\r\n  id,\r\n  entity2Id,\r\n  Entity2: {\r\n    someValue\r\n  }\r\n}\r\n\r\nand doing aliases I can get what I want with getRaw but I lose all the parse that typeorm brings when returning as entity instead of raw.\r\n\r\nWhat's the cleanest way to accomplish this? Currently I'm iterating the array with .map() and flattening but if this could be solved directly from the sql/typeorm then it would be great.",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/5111/comments",
    "author": "ejose19",
    "comments": [
      {
        "user": "papaiatis",
        "created_at": "2020-07-16T12:09:09Z",
        "body": "@ejose19 have you ever found a solution for this? I have the same problem. I do not want to use `leftJoinAndSelect`. I only care about the foreign key column which is part of the source table."
      },
      {
        "user": "ejose19",
        "created_at": "2020-07-16T16:17:24Z",
        "body": "@papaiatis there's no native way as of typeorm 0.2.x, don't know if this is possible for 0.3, but I'm using .map to fix it myself in the meanwhile, as the other solution would be doing a raw query and manually mapping (way less desirable)"
      },
      {
        "user": "imnotjames",
        "created_at": "2021-07-03T21:22:39Z",
        "body": "This isn't possible, and is outside the scope of typeorm at this time."
      }
    ]
  },
  {
    "number": 5064,
    "title": "TypeORM + Webpack: RepositoryNotFoundError: No repository for \"User\" was found. Looks like this entity is not registered in current \"default\" connection?",
    "created_at": "2019-11-10T17:41:46Z",
    "closed_at": "2019-11-12T11:44:49Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/5064",
    "body": "**Issue type:**\r\n\r\n[x ] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[x ] `postgres`\r\n[ ] `cockroachdb`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[x ] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nHi,\r\n\r\nI am using Webpack to build my Typescript app with TypeORM.\r\n\r\nWhen I run the built artefact I have the following problem:\r\n```\r\nRepositoryNotFoundError: No repository for \"User\" was found. Looks like this entity is not registered in current \"default\" connection?\r\n```\r\nAfaik, the reason for this error is that Webpack bundle all files into a single file, which causes the entity setting not correct anymore.\r\n\r\nHas anyone been able to setup TypeORM with Webpack? Please share your config :).\r\n\r\nThanks in advance.",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/5064/comments",
    "author": "dong-dohai",
    "comments": [
      {
        "user": "rustamwin",
        "created_at": "2019-11-12T07:22:36Z",
        "body": "Could you provide your config?"
      },
      {
        "user": "dong-dohai",
        "created_at": "2019-11-12T11:44:48Z",
        "body": "I managed to solve my issue.\r\n\r\nThe problem is that Webpack bundles all of our code into a single file, so my config, which using blob can't find my entities. I fixed the above issue by importing and passing the class directly to `entities` property in my connection option."
      },
      {
        "user": "gtpan77",
        "created_at": "2020-08-04T09:51:04Z",
        "body": "If you are using SnakeNamingStrategy of \"typeorm-naming-strategies\" library, then you can't use entity classes for getting repositories if their name is not in snake case.\r\nI created a entity class UserLedger.\r\n`import { UserLedger } from \"../entity/UserLedger\";`\r\n`this.userLedger = getRepository(UserLedger);`\r\nIt was failing and throwing error. RepositoryNotFoundError: No Repository for \"UserLedger\" was found.\r\n\r\nchanged the entity name to \"user_ledger\", it fixed the issue.\r\n`this.userLedger = getRepository(\"user_ledger\");`"
      },
      {
        "user": "prashant-padwal",
        "created_at": "2020-12-02T11:30:16Z",
        "body": "@dong-dohai can you please provide the code snippets how you have configured it in orm.config.ts ?\r\n\r\nThe problem is that Webpack bundles all of our code into a single file, so my config, which using blob can't find my entities. I fixed the above issue by importing and passing the class directly to entities property in my connection option.\r\n\r\n "
      },
      {
        "user": "Pomile",
        "created_at": "2021-07-18T13:24:24Z",
        "body": "I resolved this issue by setting the entities property to  ```[path.join(__dirname, '/../**/', '*.entity.{ts,js}')]``` in the connection option e.g ```entities: [path.join(__dirname, '/../**/', '*.entity.{ts,js}')]```"
      },
      {
        "user": "Alynva",
        "created_at": "2022-02-23T21:46:37Z",
        "body": "> If you are using SnakeNamingStrategy of \"typeorm-naming-strategies\" library, then you can't use entity classes for getting repositories if their name is not in snake case. I created a entity class UserLedger. `import { UserLedger } from \"../entity/UserLedger\";` `this.userLedger = getRepository(UserLedger);` It was failing and throwing error. RepositoryNotFoundError: No Repository for \"UserLedger\" was found.\r\n> \r\n> changed the entity name to \"user_ledger\", it fixed the issue. `this.userLedger = getRepository(\"user_ledger\");`\r\n\r\nThis solved for me, but as I'm using ts, I had to add `EntityTarget<ContribuicaoEntity>` as the type of the string, so the typings aren't `unkown`"
      }
    ]
  },
  {
    "number": 5058,
    "title": "TypeORM changes native query and loses parameters",
    "created_at": "2019-11-08T08:33:48Z",
    "closed_at": "2021-07-10T03:13:35Z",
    "labels": [
      "question",
      "needs more info",
      "driver: postgres"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/5058",
    "body": "**Issue type:**\r\n\r\n[ x ] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ x ] `postgres`\r\n[ ] `cockroachdb`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[ x ] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\nWhy this\r\n```ts\r\ngetConnection().query('DROP TABLE IF EXISTS public.user CASCADE');\r\n```\r\nexecutes this\r\n```SQL\r\n'TRUNCATE TABLE \"public\".\"user\"'\r\n```\r\n???\r\n\r\nQuery was taken from error returned by TypeORM. The error is thrown when there is no \"user\" table. I've got service function in dev environment that removes all tables to let TypeORM create them from the very start, execute migrations, etc. \"IF EXISTS\" should solve the case, but as I can see DROP becomes to TRUNCATE and CASCADE is lost.\r\nCorrect me if I'm wrong, the .query method should execute exactly the query that was given in.\r\n\r\nIf that's an CASCADE side effect, take a look at the first comment, there is the further issue.\r\n\r\n```ts\r\nQueryFailedError {\r\n    message: 'relation \"public.user\" does not exist',\r\n    name: 'QueryFailedError',\r\n    length: 109,\r\n    severity: 'ERROR',\r\n    code: '42P01',\r\n    detail: undefined,\r\n    hint: undefined,\r\n    position: undefined,\r\n    internalPosition: undefined,\r\n    internalQuery: undefined,\r\n    where: undefined,\r\n    schema: undefined,\r\n    table: undefined,\r\n    column: undefined,\r\n    dataType: undefined,\r\n    constraint: undefined,\r\n    file: 'namespace.c',\r\n    line: '421',\r\n    routine: 'RangeVarGetRelidExtended',\r\n    query: 'TRUNCATE TABLE \"public\".\"user\"',\r\n    parameters: []\r\n}",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/5058/comments",
    "author": "WeekendMan",
    "comments": [
      {
        "user": "WeekendMan",
        "created_at": "2019-11-08T09:02:29Z",
        "body": "Also\r\nTable B depends on table A.\r\n```ts\r\nawait connection.query(`TRUNCATE TABLE public.b CASCADE;`);\r\n```\r\n> Error: 'Table \"B\" references \"A\".'\r\nNow\r\n```ts\r\nawait connection.query(`TRUNCATE TABLE public.a CASCADE;`);\r\n```\r\n> Error: 'Table \"B\" references \"A\".'\r\nWhat am I doing wrong here?"
      },
      {
        "user": "imnotjames",
        "created_at": "2021-07-03T05:55:08Z",
        "body": "Cannot replicate.\r\n\r\nWhen opening an issue, people will be better able to provide help if you provide code that they can easily understand and use to reproduce the problem. This boils down to ensuring your code that reproduces the problem follows the following guidelines:\r\n\r\n* Minimal – Use as little code as possible that still produces the same problem\r\n* Complete – Provide all parts someone else needs to reproduce your problem in the question itself\r\n* Reproducible – Test the code you're about to provide to make sure it reproduces the problem\r\n\r\n## Minimal\r\nThe more code there is to go through, the less likely people can find your problem. Streamline your example in one of two ways:\r\n\r\n1. Restart from scratch. Create a new program, adding in only what is needed to see the problem. Use simple, descriptive names for functions and variables – don’t copy the names you’re using in your existing code.\r\n2. Divide and conquer. If you’re not sure what the source of the problem is, start removing code a bit at a time until the problem disappears – then add the last part back.\r\n\r\nDon't sacrifice clarity for brevity when creating a minimal example. Use consistent naming and indentation, and include code comments if needed. Use your code editor’s shortcut for formatting code.\r\n\r\nDon't include any passwords or credentials that must be kept secret.\r\n\r\n## Complete\r\n\r\nMake sure all information necessary to reproduce the problem is included in the issue itself.\r\n\r\nIf the problem requires some code as well as some XML-based configuration, include code for both. The problem might not be in the code that you think it is in.\r\n\r\nUse individual code blocks for each file or snippet you include. Provide a description for the purpose of each block.\r\n\r\n**DO NOT** use images of code. Copy the actual text from your code editor, paste it into the issus, then format it as code. This helps others more easily read and test your code.\r\n\r\n## Reproducible\r\n\r\nTo help you solve your problem, others will need to verify that it exists.\r\n\r\nDescribe the problem. \"It doesn't work\" isn't descriptive enough to help people understand your problem. Instead, tell other readers what the expected behavior should be. Tell other readers what the exact wording of the error message is, and which line of code is producing it. Use a brief but descriptive summary of your problem as the title of your question.\r\n\r\nEliminate any issues that aren't relevant to the problem. If your question isn’t about a compiler error, ensure that there are no compile-time errors.\r\n\r\nDouble-check that your example reproduces the problem! If you inadvertently fixed the problem while composing the example but didn't test it again, you'd want to know that before asking someone else to help."
      }
    ]
  },
  {
    "number": 5024,
    "title": "Calculate (multiply, plus, minus, ...) in select statement in QueryBuilder?",
    "created_at": "2019-11-02T10:55:31Z",
    "closed_at": "2020-10-17T05:30:01Z",
    "labels": [
      "question",
      "comp: query builder",
      "driver: mysql",
      "driver: mariadb"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/5024",
    "body": "**Issue type:**\r\n\r\n[ x ] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ x ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[ ] `cockroachdb`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[ x ] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\nIs there a way to calculate in select statements with column names?\r\n\r\nI tried it with this line: .addSelect('brokerStockData.purchaseAmount*brokerStockData.purchaseAmount', 'test')\r\n\r\nBut there is not property \"test\" in the data property.\r\n\r\n```\r\nconst [data, amount] = await this.brokerStockDataRepo\r\n      .createQueryBuilder('brokerStockData')\r\n      .leftJoinAndMapOne('brokerStockData.symbol', StockData, 'stockData', 'brokerStockData.symbol = stockData.symbol')\r\n      .innerJoin('brokerStockData.broker', 'broker')\r\n      .innerJoin('broker.user', 'user')\r\n      .innerJoin('brokerStockData.webApiConfig', 'webApiConfig')\r\n      .select('brokerStockData.id')\r\n      .addSelect('brokerStockData.addDate')\r\n      .addSelect('brokerStockData.modifyDate')\r\n      .addSelect('brokerStockData.name')\r\n      .addSelect('brokerStockData.symbol')\r\n      .addSelect('brokerStockData.purchasePrice')\r\n      .addSelect('brokerStockData.purchaseAmount')\r\n      .addSelect('brokerStockData.purchaseAmount*brokerStockData.purchaseAmount', 'test')\r\n      .addSelect('brokerStockData.purchaseDate')\r\n      .addSelect('webApiConfig.id')\r\n      .addSelect('webApiConfig.name')\r\n      .addSelect('stockData.date')\r\n      .addSelect('stockData.close')\r\n      .addSelect('stockData.symbol')\r\n      .addSelect('stockData.webApiConfigId')\r\n      .where('user.id = :userId', { userId })\r\n      .andWhere('broker.id = :brokerId', { brokerId })\r\n      .andWhere(qb => {\r\n        const subQuery = qb\r\n          .subQuery()\r\n          .select('MAX(stockData.date)')\r\n          .from(StockData, 'stockData')\r\n          .getQuery();\r\n        return 'stockData.date = ' + subQuery;\r\n      })\r\n      .take(queryParams.pageSize)\r\n      .skip(queryParams.pageSize * queryParams.pageIndex)\r\n      .orderBy(queryParams.active, queryParams.direction)\r\n      .getManyAndCount();\r\n```\r\n\r\nAnyone has an idea how this may work?",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/5024/comments",
    "author": "MeMeMax",
    "comments": [
      {
        "user": "imnotjames",
        "created_at": "2020-10-17T05:29:43Z",
        "body": "You'll need to use `getRawMany` here"
      },
      {
        "user": "imnotjames",
        "created_at": "2020-10-17T05:30:01Z",
        "body": "If you want it to end up in the model itself then this is a duplicate of #296"
      }
    ]
  },
  {
    "number": 4998,
    "title": "Typeorm add select distinct in my query. I dont want select distinct. Help!",
    "created_at": "2019-10-30T20:31:18Z",
    "closed_at": "2020-10-09T06:22:09Z",
    "labels": [
      "question",
      "driver: postgres"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/4998",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n\r\n[x] `postgres`\r\n\r\n\r\nHello I want to make a query where I get the data above, but the typeorm is putting select distinct in the query and because of this is giving error.\r\n\r\n\r\n`const [response, count] = await this.database\r\n        .getRepository(Rating)\r\n        .createQueryBuilder(\"rating\")\r\n        .select(\r\n          'rating.id as id, station.name as stationname, rating.stationtext as text, rating.operatorrating as orating, rating.stationrating as srating, fillin.created_at, customer.name as cname, rating.operatorname as oname'\r\n        )\r\n        .innerJoin(\"rating.fillin\", \"fillin\")\r\n        .innerJoin(\"fillin.customer\", \"customer\")\r\n        .innerJoin(\"rating.station\", \"station\")\r\n        .where(\"fillin.is_deleted = false AND station.chain_id = :chainId\", {\r\n          chainId\r\n        })\r\n        //.setParameter(\"chainId\", chainId)\r\n        .skip(skip)\r\n        .take(take)\r\n        .getManyAndCount();`\r\n\r\nThe console return this: \r\n\r\n`query: SELECT DISTINCT \"distinctAlias\".\"rating_id\" as \"ids_rating_id\" FROM (SELECT \"rating\".\"id\" as id, \"station\".\"name\" as stationname, rating.stationtext as text,\r\n[1]            rating.operatorrating as orating, rating.stationrating as srating, fillin.created_at,\r\n[1]             \"customer\".\"name\" as cname, rating.operatorname as oname FROM \"rating\" \"rating\" INNER JOIN \"fillin\" \"fillin\" ON \"fillin\".\"id\"=\"rating\".\"fillinid\"  INNER JOIN \"customer\" \"customer\" ON \"customer\".\"id\"=\"fillin\".\"customer_id\"  INNER JOIN \"station\" \"station\" ON \"station\".\"id\"=\"rating\".\"stationid\" WHERE fillin.is_deleted = false AND station.chain_id = $1) \"distinctAlias\" ORDER BY \"rating_id\" ASC LIMIT 10 -- PARAMETERS: [\"aedbcc7f-d336-45d3-b04b-b598bd2445ee\"]\r\n`\r\n`[1] query failed: SELECT DISTINCT \"distinctAlias\".\"rating_id\" as \"ids_rating_id\" FROM (SELECT \"rating\".\"id\" as id, \"station\".\"name\" as stationname, rating.stationtext as text,\r\n[1]            rating.operatorrating as orating, rating.stationrating as srating, fillin.created_at,\r\n[1]             \"customer\".\"name\" as cname, rating.operatorname as oname FROM \"rating\" \"rating\" INNER JOIN \"fillin\" \"fillin\" ON \"fillin\".\"id\"=\"rating\".\"fillinid\"  INNER JOIN \"customer\" \"customer\" ON \"customer\".\"id\"=\"fillin\".\"customer_id\"  INNER JOIN \"station\" \"station\" ON \"station\".\"id\"=\"rating\".\"stationid\" WHERE fillin.is_deleted = false AND station.chain_id = $1) \"distinctAlias\" ORDER BY \"rating_id\" ASC LIMIT 10 -- PARAMETERS: [\"aedbcc7f-d336-45d3-b04b-b598bd2445ee\"]\r\n`\r\n`[1] Debug: handler, error\r\n[1]     QueryFailedError: column distinctAlias.rating_id does not exist`",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/4998/comments",
    "author": "HenriqueRamos13",
    "comments": [
      {
        "user": "constb",
        "created_at": "2020-01-15T09:17:36Z",
        "body": "that's like pre-select query. typeorm does this because JOINs may cause multiple rows be returned for a single row in the original entity table, making it impossible to properly apply LIMIT. typeorm selects distinct ids applying limits to ids only, and then second (real select) applies WHERE id IN instead of LIMIT, so that you get both JOINs and LIMIT working properly at the same time.\r\n\r\nthe error you are getting is because your `.select()` is wrong. typeorm prefixes column aliases with entity alias, and expects names to match in result. you are overriding this by supplying your own aliases with `AS` thus breaking the query.\r\n\r\n`.createQueryBuilder(\"rating\")` - there's your entity alias. `SELECT DISTINCT \"distinctAlias\".\"rating_id\"` – that's what typeorm expects id column to be named like. `rating.id as id` – that's where you broke it.\r\n\r\ngenerally, I'd advise to name columns and entity fields exactly the same and let typeorm do the rest.\r\n\r\nwhen you need extra fields in the entity, use `.addSelect()`, plain `.select()` completely overrides autogenerated field names.\r\n\r\nin case when you need only limited number of fields in result, use entity alias like `.select('rating.id', 'station.name')` only. (though you should always select ids anyway)\r\n\r\nusing `.innerJoin()` to drop some columns from another table into the entity is just wrong. `.innerJoin()` is intended to be able to filter on related entity without selecting it. if you need another entity data, use `.innerJoinAndSelect()` if relation is declared as an entity field, use `.innerJoinAndMapOne()/.innerJoinAndMapMany()` to add a field to an entity without declaring a relation and get one or multiple related entities…"
      },
      {
        "user": "AcrylicShrimp",
        "created_at": "2020-05-02T09:52:59Z",
        "body": "Same here, is there way to remove `id`s from the results? I don't want to select them.\r\nAlso, when I use `addSelect`, DB complains that there are duplicated selects."
      },
      {
        "user": "ardyfeb",
        "created_at": "2020-09-14T16:32:24Z",
        "body": "This is real performance issue"
      },
      {
        "user": "nlucero",
        "created_at": "2020-09-25T19:29:06Z",
        "body": "Facing this very same issue. Paginated queries (i.e. queries using `.skip()` and `.take()`) joining to other tables get split into two queries, which is not ideal. Are there any workarounds for this?"
      },
      {
        "user": "constb",
        "created_at": "2020-09-28T06:02:15Z",
        "body": "@ardyfeb @nlucero I think all ORMs use some sort of \"magic\" when it comes to loading relations with LIMITs on main entity. TypeORM prefers joins, which makes for better performance when pagination is not used. Also, first \"distinct\" query warms up database cache, so I believe \"real\" query should be very fast after that.\r\n\r\nAn alternative would be to load main entity without any relations at all. This would allow one to use plain old LIMIT/OFFSET right there on the main query. But – and this is unavoidable – to load relations, ORM would have to issue separate queries on every requested relation (and relations of relations too). I'm not sure if this would make query faster when pagination is involved, but I'm guessing it would make querying slower when no pagination is used.\r\n\r\nI know Laravel Eloquent uses the latter approach. TypeORM prefers former one, with all its drawbacks and benefits. Personally I used both and I haven't noticed any performance issues with either. Every time I had slow queries, the real issue turned out to be either my mistake (lack of indexes or wrong choice of fields for an index, or forgetting to eagerly load a relation resulting in infamous N+1) or a quirk in a database implementation (like using numeric values in WHERE on a string primary key oddly causes full table scan in mariadb)."
      },
      {
        "user": "drinchev",
        "created_at": "2021-01-13T08:01:13Z",
        "body": "Btw doing : \r\n\r\n```\r\nconst jobIds = await repository.find( {\r\n  skip : 10,\r\n  take : 10,\r\n  order : { startedAt : \"DESC\" },\r\n  select : [\"id\"]\r\n} );\r\nconst jobs = await repository.find( {\r\n  order : { startedAt : \"DESC\" },\r\n  relations : [\"cycles\", \"cycles.materials\"],\r\n  where : { id : In( jobIds.map( job => job.id ) ) }\r\n} );\r\n```\r\n\r\nseems to be way faster. I'm not sure why this would break pagination. Can anyone explain?"
      },
      {
        "user": "MondoGao",
        "created_at": "2021-11-17T11:18:00Z",
        "body": "this is still a problem"
      },
      {
        "user": "rsofista",
        "created_at": "2022-01-04T04:23:15Z",
        "body": "@constb  is there an option to disable this? Some weird, not very well documented parameter?"
      },
      {
        "user": "constb",
        "created_at": "2022-01-21T06:31:10Z",
        "body": "> @constb is there an option to disable this? Some weird, not very well documented parameter?\r\n\r\nI guess just don't load relations when you apply limit? This is a part of typeorm architecture, I don't think this can be changed now without doing massive rewrite.\r\n\r\nI'm not typeorm maintainer, @pleerock does great job maintaining this library."
      },
      {
        "user": "idemax",
        "created_at": "2022-04-26T18:31:06Z",
        "body": "> that's like pre-select query. typeorm does this because JOINs may cause multiple rows be returned for a single row in the original entity table, making it impossible to properly apply LIMIT. typeorm selects distinct ids applying limits to ids only, and then second (real select) applies WHERE id IN instead of LIMIT, so that you get both JOINs and LIMIT working properly at the same time.\r\n> \r\n> the error you are getting is because your `.select()` is wrong. typeorm prefixes column aliases with entity alias, and expects names to match in result. you are overriding this by supplying your own aliases with `AS` thus breaking the query.\r\n> \r\n> `.createQueryBuilder(\"rating\")` - there's your entity alias. `SELECT DISTINCT \"distinctAlias\".\"rating_id\"` – that's what typeorm expects id column to be named like. `rating.id as id` – that's where you broke it.\r\n> \r\n> generally, I'd advise to name columns and entity fields exactly the same and let typeorm do the rest.\r\n> \r\n> when you need extra fields in the entity, use `.addSelect()`, plain `.select()` completely overrides autogenerated field names.\r\n> \r\n> in case when you need only limited number of fields in result, use entity alias like `.select('rating.id', 'station.name')` only. (though you should always select ids anyway)\r\n> \r\n> using `.innerJoin()` to drop some columns from another table into the entity is just wrong. `.innerJoin()` is intended to be able to filter on related entity without selecting it. if you need another entity data, use `.innerJoinAndSelect()` if relation is declared as an entity field, use `.innerJoinAndMapOne()/.innerJoinAndMapMany()` to add a field to an entity without declaring a relation and get one or multiple related entities…\r\n\r\n@constb its not working and now im facing this error: \r\n\r\n`error: error: column reference \"id\" is ambiguous`"
      },
      {
        "user": "JefferyHus",
        "created_at": "2022-04-27T06:47:59Z",
        "body": "This is a super bad decision to wrap the main query inside another one to filter duplicates."
      },
      {
        "user": "JaffParker",
        "created_at": "2022-07-04T15:31:51Z",
        "body": "I may understand this behavior, but it applies my sorting to the outer query in production. My sorting is tied to a column that isn't in the outer query, it breaks it. That is a BUG. It's a query I have zero control over and therefore can't fix without hacks."
      },
      {
        "user": "ericmorand",
        "created_at": "2022-07-23T01:08:51Z",
        "body": "This is especially bad for one-to-one relations, where the is no duplicated row issue. At the very least, this behavior should be disabled for one-to-one relations."
      },
      {
        "user": "Lamarcke",
        "created_at": "2024-03-22T22:44:31Z",
        "body": "It's 2024 and i'm getting massive performance problems because of this. Wish there was a way to disable it."
      },
      {
        "user": "chuckshih09",
        "created_at": "2024-04-27T23:29:55Z",
        "body": "You can use `offset()` & `limit()` to replace `skip()` & `take()`"
      }
    ]
  },
  {
    "number": 4982,
    "title": "How to set initial value of PrimaryGeneratedColumn?",
    "created_at": "2019-10-28T10:13:38Z",
    "closed_at": "2021-07-04T16:00:13Z",
    "labels": [
      "question",
      "driver: postgres"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/4982",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[x] `postgres`\r\n[ ] `cockroachdb`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\nI need the order numbers to start at 1000, and each next incremented. How to achieve this?\r\n\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/4982/comments",
    "author": "eugeneshemonaev",
    "comments": [
      {
        "user": "imnotjames",
        "created_at": "2021-07-04T16:00:13Z",
        "body": "You'll need to use a migration and write this specifically as part of the migration.  It's not something we can set easily as part of the sync because most of these you'd have to set it once and if we execute it again it would reset the counting."
      }
    ]
  },
  {
    "number": 4981,
    "title": "Error on ORACLE servers",
    "created_at": "2019-10-28T09:47:26Z",
    "closed_at": "2021-07-31T06:00:47Z",
    "labels": [
      "bug",
      "question",
      "needs more info",
      "driver: oracle"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/4981",
    "body": "**Issue type:**\r\n\r\n[X] question\r\n[?] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[X] `oracle`\r\n[ ] `postgres`\r\n[ ] `cockroachdb`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[X] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nHi, I'm having a pretty straight forward model that works nicely on sqlite.\r\nWhen I try to run it on it works on the first server start up.\r\n\r\nOn the second startup it queries the schema and tries to alter tables and I get the following kind of error\r\n\r\n```\r\nI20191028-10:43:44.248(1)? query: SELECT \"TABLE_NAME\" FROM \"USER_TABLES\" WHERE \"TABLE_NAME\" = 'typeorm_metadata'\r\nI20191028-10:43:44.297(1)? renaming column \"SYS_C00010_19102217:20:46$\" in to \"id\"\r\nI20191028-10:43:44.300(1)? query: ALTER TABLE \"KRI_DATA_POINTS\" RENAME COLUMN \"SYS_C00010_19102217:20:46$\" TO \"id\"\r\nI20191028-10:43:44.327(1)? query failed: ALTER TABLE \"KRI_DATA_POINTS\" RENAME COLUMN \"SYS_C00010_19102217:20:46$\" TO \"id\"\r\nI20191028-10:43:44.328(1)? error: { Error: ORA-00904: \"SYS_C00010_19102217:20:46$\": invalid identifier errorNum: 904, offset: 44 }\r\nI20191028-10:43:44.330(1)? query: ROLLBACK\r\nW20191028-10:43:44.393(1)? (STDERR) /Users/ap/.meteor/packages/promise/.0.11.2.1ixw4hn.8uhlk++os+web.browser+web.browser.legacy+web.cordova/npm/node_modules/meteor-promise/promise_server.js:218\r\nW20191028-10:43:44.393(1)? (STDERR)       throw error;\r\nW20191028-10:43:44.393(1)? (STDERR)       ^\r\nW20191028-10:43:44.393(1)? (STDERR) \r\nW20191028-10:43:44.394(1)? (STDERR) QueryFailedError: ORA-00904: \"SYS_C00010_19102217:20:46$\": invalid identifier\r\nW20191028-10:43:44.394(1)? (STDERR)     at new QueryFailedError (/Users/ap/Documents/Data/Vilango/workspace/egit/owl-v2/app/node_modules/typeorm/error/QueryFailedError.js:11:28)\r\nW20191028-10:43:44.394(1)? (STDERR)     at handler (/Users/ap/Documents/Data/Vilango/workspace/egit/owl-v2/app/node_modules/typeorm/driver/oracle/OracleQueryRunner.js:175:45)\r\n\r\n```\r\n\r\n\r\nSo my question would be:\r\nHow do I use Oracle in a production setting if I can't use `synchronize = true`\r\nand there is no way to generate the schemas DDL?\r\n\r\nBest,\r\nGerwin\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/4981/comments",
    "author": "gerwinbrunner",
    "comments": [
      {
        "user": "imnotjames",
        "created_at": "2021-07-11T16:15:29Z",
        "body": "Can you include more information? This is a bit limited.\r\n\r\nEntities and Oracle version that exhibit this issue at the least would help debug."
      },
      {
        "user": "imnotjames",
        "created_at": "2021-07-31T06:00:47Z",
        "body": "Without a way to replicate this issue I am closing it."
      }
    ]
  },
  {
    "number": 4977,
    "title": "Querying postgres schema by deeply nested relations",
    "created_at": "2019-10-27T12:51:38Z",
    "closed_at": "2021-07-04T01:21:23Z",
    "labels": [
      "question",
      "driver: postgres"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/4977",
    "body": "**Issue type:**\r\n\r\n[X] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[X] `postgres`\r\n[ ] `cockroachdb`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[ ] `latest`\r\n[X] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\nAt present it seems to only be possible to refer to the columns in the current table, including relation foreign keys (unless you drop to SQL and write the queries manually)\r\n\r\nI'm looking to be able to do something like this:\r\n\r\n\r\n```js\r\nthis.User.find({\r\n    where: {\r\n        photos: {\r\n            name: Like('%Fubar%')\r\n        }\r\n    }\r\n});\r\n```\r\n\r\nIs this currently possible? If not, I'm happy to turn this into an issue and maybe look at putting in a PR if that's agreeable?\r\n\r\n<!--\r\n    To answer those questions you need to put \"x\" inside the square brackets, for example:\r\n    [x] `mysql`\r\n    [ ] `postgres`\r\n\r\n    Also, please format your code properly (by taking code blocks into ```ts .... ```)\r\n!>\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/4977/comments",
    "author": "rmainwork",
    "comments": [
      {
        "user": "imnotjames",
        "created_at": "2021-07-04T01:21:23Z",
        "body": "It was not - should be possible with #7805 "
      }
    ]
  },
  {
    "number": 4971,
    "title": "Refresh Materialized View",
    "created_at": "2019-10-25T14:35:02Z",
    "closed_at": "2020-10-14T19:11:33Z",
    "labels": [
      "question",
      "driver: postgres"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/4971",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[x] `postgres`\r\n[ ] `cockroachdb`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\nHi,\r\n\r\nI have a materialized view in my project and I am trying to refresh it each time I insert or update a related table. At now I am using this solution:\r\n\r\n`@AfterInsert()`\r\n`@AfterUpdate()`\r\n`updateMaterialedView(){`\r\n  `getRepository(MyMaterializedView).query('REFRESH MATERIALIZED VIEW materialized_view')`\r\n  `.then(resp => console.log('update materialized view ok'))`\r\n   `.catch(err => console.error('update materialized view error'))`\r\n`}`\r\n\r\nIs there another solution to avoid writing the query manually ?\r\n\r\nThanks,\r\nLuigi\r\n\r\n<!--\r\n    To answer those questions you need to put \"x\" inside the square brackets, for example:\r\n    [x] `mysql`\r\n    [ ] `postgres`\r\n\r\n    Also, please format your code properly (by taking code blocks into ```ts .... ```)\r\n!>\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/4971/comments",
    "author": "frascaluigi",
    "comments": [
      {
        "user": "imnotjames",
        "created_at": "2020-10-14T19:11:33Z",
        "body": "Unfortunately, I think that's your best bet - you could also do a subscriber instead of a listener but it's roughly the same thing."
      }
    ]
  },
  {
    "number": 4965,
    "title": "Await for entities to be registered.",
    "created_at": "2019-10-24T12:35:19Z",
    "closed_at": "2021-07-31T16:44:01Z",
    "labels": [
      "bug",
      "question",
      "driver: postgres"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/4965",
    "body": "**Issue type:**\r\n[X] question\r\n[X] bug report\r\n\r\n**Database system/driver:**\r\n[X] `postgres`\r\n\r\n**TypeORM version:**\r\n[X] `latest`\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\nFor my application I would like to setup connection on-fly which is already done and works fine based on request details, after request is received the Middleware checks if connections exists, if not is trying to create new connection or return error.\r\n\r\nWhen connection is created with status of connection.isConnected === true, but I send let's say 3 queries in the same time, it is getting errors on Entity registration e.g:\r\n`[Nest] 9257   - 10/24/2019, 2:13:56 PM   [ExceptionsHandler] No repository for \"XXX\" was found. Looks like this entity is not registered in current \"XXX\" connection? +4250ms`\r\n\r\nEvery next query **will work fine**, as the entity is registered in the meantime using:\r\n`entities: [__dirname + '/**/**/*.entity{.ts,.js}']`\r\nIt doesn't matter if I use this example for entities or even calling them [SomethingEntity] it doesn't make any difference.\r\n\r\nThis situation happen always when backend is restarted and after the restart of an app while getting more than one query, some of the entities are not yet registered.\r\nI made really bad workaround for this for now which is working fine (it basically wait 3 secs after connection is established to make sure everything is initialized, this will work only for first queries after app restart, later createConnection is skipped if already exists), however I believe there must be an option to wait if all entities has been already initialized and then let it go.\r\n\r\nWorking workaround  solution:\r\n```ts\r\nawait createConnection(connection);\r\nawait new Promise( resolve => setTimeout(resolve, 3000) );\r\nconst conn = await getConnection(connection.name);\r\nif (conn.isConnected) {\r\n    next( now it will try to get repository and other business logic which will work);\r\n}\r\n```\r\nNot working solution:\r\n```ts\r\ncreateConnection(connection).then(\r\n  (connection) => {\r\n      console.log(connection.isConnected);\r\n      next( not it will try to get repository and other business logic which will fail );\r\n  }\r\n).catch(\r\n  (err) => {\r\n      ...only returns issues related to the connection itself\r\n  }\r\n)\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/4965/comments",
    "author": "wintertime-inc",
    "comments": [
      {
        "user": "imnotjames",
        "created_at": "2021-07-31T16:44:01Z",
        "body": "I cannot replicate this.\r\n\r\nWe connect and build the metadata as part of `createConnection` by awaiting the completion of `connect`"
      }
    ]
  },
  {
    "number": 4963,
    "title": "Chunk Size seems limited",
    "created_at": "2019-10-23T23:13:00Z",
    "closed_at": "2021-06-19T04:40:35Z",
    "labels": [
      "question",
      "needs more info",
      "driver: mssql"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/4963",
    "body": "**Issue type:**\r\n\r\n[X] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[X] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[ ] `cockroachdb`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[X] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nSo I'm just getting started with typeorm (love it)... but I'm running in to a weird issue with saving an array of objects to SQL Server. I am only able to save a very small number before exceeding some type of threshold (that manifests in a connection error). \r\n\r\nusing: \r\n```await connection.manager.save<MyEntity>(itemsToSave, { chunk: 5 });``` works. \r\n\r\nChanging the chunk size to anything higher causes SQL Server (SQL Azure) to barf. There are only 18 columns being inserted and they are all integers - so it's not like I'm pushing hundreds of long-text columns.\r\n\r\nIs setting the chunk-size this low expected, or am I doing it wrong?\r\n\r\n<!--\r\n    To answer those questions you need to put \"x\" inside the square brackets, for example:\r\n    [x] `mysql`\r\n    [ ] `postgres`\r\n\r\n    Also, please format your code properly (by taking code blocks into ```ts .... ```)\r\n!>\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/4963/comments",
    "author": "kevinsherman",
    "comments": [
      {
        "user": "imnotjames",
        "created_at": "2020-10-12T19:06:27Z",
        "body": "Can you elaborate on what you mean by MSSQL barfing?  Perhaps a reproducible example we can run against our docker instance of MSSQL?\r\n"
      },
      {
        "user": "imnotjames",
        "created_at": "2021-06-19T04:40:35Z",
        "body": "When opening an issue, people will be better able to provide help if you provide code that they can easily understand and use to reproduce the problem. This boils down to ensuring your code that reproduces the problem follows the following guidelines:\r\n\r\n* Minimal – Use as little code as possible that still produces the same problem\r\n* Complete – Provide all parts someone else needs to reproduce your problem in the question itself\r\n* Reproducible – Test the code you're about to provide to make sure it reproduces the problem\r\n\r\n## Minimal\r\nThe more code there is to go through, the less likely people can find your problem. Streamline your example in one of two ways:\r\n\r\n1. Restart from scratch. Create a new program, adding in only what is needed to see the problem. Use simple, descriptive names for functions and variables – don’t copy the names you’re using in your existing code.\r\n2. Divide and conquer. If you’re not sure what the source of the problem is, start removing code a bit at a time until the problem disappears – then add the last part back.\r\n\r\nDon't sacrifice clarity for brevity when creating a minimal example. Use consistent naming and indentation, and include code comments if needed. Use your code editor’s shortcut for formatting code.\r\n\r\nDon't include any passwords or credentials that must be kept secret.\r\n\r\n## Complete\r\n\r\nMake sure all information necessary to reproduce the problem is included in the issue itself.\r\n\r\nIf the problem requires some code as well as some XML-based configuration, include code for both. The problem might not be in the code that you think it is in.\r\n\r\nUse individual code blocks for each file or snippet you include. Provide a description for the purpose of each block.\r\n\r\n**DO NOT** use images of code. Copy the actual text from your code editor, paste it into the issus, then format it as code. This helps others more easily read and test your code.\r\n\r\n## Reproducible\r\n\r\nTo help you solve your problem, others will need to verify that it exists.\r\n\r\nDescribe the problem. \"It doesn't work\" isn't descriptive enough to help people understand your problem. Instead, tell other readers what the expected behavior should be. Tell other readers what the exact wording of the error message is, and which line of code is producing it. Use a brief but descriptive summary of your problem as the title of your question.\r\n\r\nEliminate any issues that aren't relevant to the problem. If your question isn’t about a compiler error, ensure that there are no compile-time errors.\r\n\r\nDouble-check that your example reproduces the problem! If you inadvertently fixed the problem while composing the example but didn't test it again, you'd want to know that before asking someone else to help."
      }
    ]
  },
  {
    "number": 4903,
    "title": "EntityManager.find() : Complex where condition ",
    "created_at": "2019-10-14T15:30:25Z",
    "closed_at": "2021-07-04T01:24:06Z",
    "labels": [
      "question",
      "driver: postgres"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/4903",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[x] `postgres`\r\n[ ] `cockroachdb`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nHi,\r\n\r\nI would like to execute a simple query like this : `SELECT * FROM user.user WHERE deleted is NULL AND (lastname = 'Doe' OR (lastname != 'Doe' AND firtname = 'john'))`\r\n\r\nIs it possible to write this where condition with the entityManager.find() function ? If yes, how ??\r\n\r\nThanx a lot for your help\r\n\r\n<!--\r\n    To answer those questions you need to put \"x\" inside the square brackets, for example:\r\n    [x] `mysql`\r\n    [ ] `postgres`\r\n\r\n    Also, please format your code properly (by taking code blocks into ```ts .... ```)\r\n!>\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/4903/comments",
    "author": "JulienB37",
    "comments": [
      {
        "user": "imnotjames",
        "created_at": "2021-07-04T01:24:06Z",
        "body": "You'll need to use the querybuilder."
      }
    ]
  },
  {
    "number": 4898,
    "title": "TypeORM including tables not related to query when using a subquery",
    "created_at": "2019-10-12T17:51:18Z",
    "closed_at": "2020-10-15T14:06:21Z",
    "labels": [
      "question",
      "needs more info",
      "driver: postgres"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/4898",
    "body": "**Issue type:**\r\n\r\n[X] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[X] `postgres`\r\n[ ] `cockroachdb`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[X] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\nI am currently trying to implement the following query in typeorm:\r\n```\r\n select id,\"createdAt\", \"updatedAt\",\"deactivatedAt\",(EXTRACT(EPOCH FROM \"deactivatedAt\" - \"createdAt\")/3600 ) as lifespan\r\n    from (\r\n       select id,\"createdAt\", \"updatedAt\",\"deactivatedAt\", (EXTRACT(EPOCH FROM \"deactivatedAt\" - \"createdAt\")/3600 )as time\r\n       from apartment_listing where active = false)as subquery\r\nwhere subquery.time <24\r\n```\r\nFor this, I have implemented the following code in in TypeScript:\r\n```\r\n    const mainQuery = this.repository\r\n      .createQueryBuilder()\r\n      .select(\"subquery.id\", \"id\")\r\n      .addSelect(\"subquery.time\", \"time\")\r\n      .addSelect(\"subquery.created\", \"createdAt\")\r\n      .addSelect(\"subquery.deactivated\", \"deactivatedAt\")\r\n      .from(qb => {\r\n        const sub = qb.select(\r\n          \"(EXTRACT(EPOCH FROM listing.deactivatedAt - listing.createdAt )/3600 )\",\r\n          \"time\"\r\n        )\r\n        .addSelect(\"listing.deactivatedAt\", \"deactivated\")\r\n        .addSelect(\"listing.id\", \"id\")\r\n        .addSelect(\"listing.createdAt\", \"created\")\r\n        .addSelect(\"listing.active\",\"active\")\r\n        .from(this.type, \"listing\")\r\n        .where(\"listing.active = false\")\r\n        return sub;\r\n      }, \"subquery\")\r\n      .where(\"subquery.time < 24\")\r\n```\r\n\r\nHowever, when executing this code the query generated by typeorm is incorrect and results in an infinite query which ends up using 100% of ram. The query generated is:\r\n```\r\nSELECT subquery.id AS \"id\", subquery.time AS \"time\", subquery.created AS \"createdAt\", subquery.deactivated AS \"deactivatedAt\" \r\nFROM \"apartment_listing\" \"ApartmentListing\", (SELECT \"listing\".\"id\" AS \"id\", \"listing\".\"active\" AS \"active\", \"listing\".\"createdAt\" AS \"created\", \"listing\".\"deactivatedAt\" AS \"deactivated\", (EXTRACT(EPOCH FROM \"listing\".\"deactivatedAt\" - \"listing\".\"createdAt\" )/3600 ) AS \"time\" FROM \"apartment_listing\" \"listing\" WHERE \"listing\".\"active\" = false) \"subquery\" \r\nWHERE subquery.time < 24\r\n```\r\n\r\nAs you can see, in the FROM clause it includes the ```\"apartment_listing\" \"ApartmentListing\"``` table as well as the subquery. If I copy and paste this query in PgAdmin, it also ends up in an infinite query, but if I remove that extra ```\"apartment_listing\" \"ApartmentListing\",``` table from the FROM clause, the result is successfull and I get the correct result.\r\n\r\nWhy is typeORM including this ```\"apartment_listing\" \"ApartmentListing\",```? in my code implementation there is only one FROM and it points to the subquery. How can I get rid of that extra table so the query executes successfully?\r\n\r\nThanks in advance\r\n\r\n\r\n\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/4898/comments",
    "author": "oscar-corredor",
    "comments": [
      {
        "user": "imnotjames",
        "created_at": "2020-10-15T04:42:48Z",
        "body": "Can you create a reproducible example?  It's hard to know what's going on without that.\r\n\r\n---\r\n\r\nWhen opening an issue, people will be better able to provide help if you provide code that they can easily understand and use to reproduce the problem. This boils down to ensuring your code that reproduces the problem follows the following guidelines:\r\n\r\n* Minimal – Use as little code as possible that still produces the same problem\r\n* Complete – Provide all parts someone else needs to reproduce your problem in the question itself\r\n* Reproducible – Test the code you're about to provide to make sure it reproduces the problem\r\n\r\n## Minimal\r\nThe more code there is to go through, the less likely people can find your problem. Streamline your example in one of two ways:\r\n\r\n1. Restart from scratch. Create a new program, adding in only what is needed to see the problem. Use simple, descriptive names for functions and variables – don’t copy the names you’re using in your existing code.\r\n2. Divide and conquer. If you’re not sure what the source of the problem is, start removing code a bit at a time until the problem disappears – then add the last part back.\r\n\r\nDon't sacrifice clarity for brevity when creating a minimal example. Use consistent naming and indentation, and include code comments if needed. Use your code editor’s shortcut for formatting code.\r\n\r\nDon't include any passwords or credentials that must be kept secret.\r\n\r\n## Complete\r\n\r\nMake sure all information necessary to reproduce the problem is included in the issue itself.\r\n\r\nIf the problem requires some code as well as some XML-based configuration, include code for both. The problem might not be in the code that you think it is in.\r\n\r\nUse individual code blocks for each file or snippet you include. Provide a description for the purpose of each block.\r\n\r\n**DO NOT** use images of code. Copy the actual text from your code editor, paste it into the issus, then format it as code. This helps others more easily read and test your code.\r\n\r\n## Reproducible\r\n\r\nTo help you solve your problem, others will need to verify that it exists.\r\n\r\nDescribe the problem. \"It doesn't work\" isn't descriptive enough to help people understand your problem. Instead, tell other readers what the expected behavior should be. Tell other readers what the exact wording of the error message is, and which line of code is producing it. Use a brief but descriptive summary of your problem as the title of your question.\r\n\r\nEliminate any issues that aren't relevant to the problem. If your question isn’t about a compiler error, ensure that there are no compile-time errors.\r\n\r\nDouble-check that your example reproduces the problem! If you inadvertently fixed the problem while composing the example but didn't test it again, you'd want to know that before asking someone else to help."
      }
    ]
  },
  {
    "number": 4891,
    "title": "Virtual Column",
    "created_at": "2019-10-10T14:00:49Z",
    "closed_at": "2020-10-06T07:16:46Z",
    "labels": [
      "question",
      "driver: postgres"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/4891",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[x] `postgres`\r\n[ ] `cockroachdb`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\nHi,\r\nDo you have any idea to create a virtual column?\r\n\r\nexample\r\n```ts\r\n\r\n@Entity('Users')\r\nexport default class User extends Base {\r\n\r\n    public static build(data: any): User {\r\n        const user: User = new User();\r\n        user.id = data.id;\r\n        user.Name = data.name;\r\n\r\n        return user;\r\n    }\r\n    @Column()\r\n    public id?: number;\r\n\r\n    @Column()\r\n    public Name: string;\r\n\r\n    @Column()\r\n    public email?: string;\r\n}\r\n``` \r\nIn this case, I have column `Name` and `id` in my database, and email should be a virtual column. When I need find all of the column I use \r\n```ts\r\n getConnection().getMetadata('Users').ownColumns\r\n```\r\n\r\nand I need an email column here with type `Virtual` or similar.\r\n\r\nDo you have any idea?",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/4891/comments",
    "author": "grzegorzCieslik95",
    "comments": [
      {
        "user": "leonardofalk",
        "created_at": "2019-10-11T12:29:14Z",
        "body": "Virtual columns can be made by simply not wrapping them with typeorm decorators:\r\n\r\n```ts\r\n@Entity('users')\r\nclass User extends BaseEntity {\r\n  @Column()\r\n  email: string\r\n\r\n  @Column()\r\n  encrypted_password: string\r\n\r\n  password: string\r\n\r\n  @BeforeInsert()\r\n  encryptPassword() {\r\n    this.encrypted_password = bcrypt(this.password)\r\n    this.password = null\r\n  }\r\n}\r\n\r\n// then ...\r\n\r\nconst user = User.create({ email: 'example@example.com', password: '123456' })\r\nawait user.save()\r\n\r\nconsole.log(user)\r\n// { email: 'example@example.com', encrypted_password: /* hashed password */ }\r\n```"
      },
      {
        "user": "sornii",
        "created_at": "2020-02-20T12:29:36Z",
        "body": "Sorry to not answer your original question, but I can't stand on a bad decision. Sr. @grzegorzCieslik95, I think you misunderstood the point of builders. I'd recommend you to not do what you've done in your code. You should use builders only in case if the constructor of the User is restrict in receiving id and name. Something like this:\r\n\r\n```\r\nclass User {\r\n  id: string;\r\n  name: string;\r\n  constructor(id: string, name: string) {\r\n    this.id = id;\r\n    this.name = name;\r\n  }\r\n}\r\n\r\nclass UserBuilder {\r\n  private id: string = 'n/a';\r\n  private name: string = 'n/a';\r\n\r\n  withId(id: string) {\r\n    this.id = id;\r\n    return this;\r\n  }\r\n\r\n  withName(name: string) {\r\n    this.name = name;\r\n    return this;\r\n  }\r\n\r\n  build() {\r\n    return new User(this.id, this.name);\r\n  }\r\n}\r\n\r\nclass Main {\r\n    main() {\r\n      const user: User = new UserBuilder().withId('aa').withName('bb').build();\r\n      const userWithoutName: User = new UserBuilder().withId('aa').build();\r\n\r\n      console.log(user);\r\n      console.log(userWithoutName);\r\n    }\r\n}\r\n\r\nnew Main().main();\r\n```"
      },
      {
        "user": "imnotjames",
        "created_at": "2020-10-06T07:16:46Z",
        "body": "Duplicate of #2498"
      }
    ]
  },
  {
    "number": 4868,
    "title": "EntityManager.Query using parameters",
    "created_at": "2019-10-07T18:27:39Z",
    "closed_at": "2020-10-06T06:53:14Z",
    "labels": [
      "question",
      "driver: postgres"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/4868",
    "body": "[ ] question\r\n\r\nHello, I have been looking into parameterized queries using either EntityManager, Connection, or QueryRunner. As I can see everything passes down to the query runner. The problem I am having is that I cannot find anywhere that shows how to use the parameterized queries? They take an array of parameters as an argument but cannot seem to find any way to actually reference them in the query string provided. I have looked around for a few hours and everyone has guesses but nobody actually knows how to use them. Any help would be appreciated please. Thanks in advance.\r\n\r\n**Database system/driver:**\r\n[x] `postgres`\r\n\r\n**TypeORM version:**\r\n[x] `latest`\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nI am trying to pass a value in to search by in a query string such as \r\n`SELECT * FROM USERS WHERE first_name LIKE \"parameterHere\"`\r\n\r\nI am using the EntityManager.Query Method.\r\n\r\n`let queryString = 'SELECT * FROM USERS WHERE first_name LIKE \"parameterHere\"'`\r\n`EntityManager.query(queryString, [stringToCheck]`\r\n\r\nThe problem is I cannot find any documentation on how to use these parameters. There are a lot of different guesses in other issues here and stack overflow resulting in using @0 or $1 to reference them but nothing seems to work at all. Any help would be greatly appreciated",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/4868/comments",
    "author": "Lightk3ira",
    "comments": [
      {
        "user": "veluxa",
        "created_at": "2019-10-11T02:09:02Z",
        "body": "Try this:\r\n\r\n``` typescript\r\nlet queryString = 'SELECT * FROM USERS WHERE first_name LIKE \"?\"'\r\nEntityManager.query(queryString, [stringToCheck])\r\n```"
      },
      {
        "user": "imnotjames",
        "created_at": "2020-10-06T06:53:14Z",
        "body": "It actually would be\r\n\r\n```\r\nlet queryString = 'SELECT * FROM USERS WHERE first_name LIKE ?'\r\nEntityManager.query(queryString, [stringToCheck])\r\n```\r\n\r\nbecause it's a prepared statement you don't need to add the quotes."
      }
    ]
  },
  {
    "number": 4864,
    "title": "Select does not work as I expected - all properties are in reponse",
    "created_at": "2019-10-06T08:46:51Z",
    "closed_at": "2021-07-04T16:27:02Z",
    "labels": [
      "question",
      "driver: mssql"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/4864",
    "body": "**Issue type:**\r\n\r\n[ x] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[x ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[ ] `cockroachdb`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[x ] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\nHi,\r\nI have this query \r\n ```javascript \r\nconst productInstance = await this.entityManager\r\n      .createQueryBuilder(ProductInstance, 'ProductInstance')\r\n      .leftJoinAndSelect('ProductInstance.RentalItems', 'RentalItems')\r\n      .where('ProductInstance.Id = :id', { id: id })\r\n      .select([\r\n        'ProductInstance.Id',\r\n        'ProductInstance.Color',\r\n        'RentalItems.Id',\r\n        'RentalItems.Start',\r\n        'RentalItems.End',\r\n      ])\r\n      .getOne();\r\n```\r\n\r\nwhich return this reponse \r\n\r\n```{\r\n    \"Id\": 3008,\r\n    \"SerialNumber\": \"\",\r\n    \"Color\": \"Silver\",\r\n    \"AvailableForRent\": true,\r\n    \"RequiresConditionRevision\": 0,\r\n    \"Note\": \"\",\r\n    \"IsBorrowed\": 0,\r\n    \"Created\": null,\r\n    \"CreatedBy\": null,\r\n    \"Modified\": null,\r\n    \"ModifiedBy\": null,\r\n    \"RentalItems\": [\r\n        {\r\n            \"Id\": 19868,\r\n            \"Phase\": null,\r\n            \"Condition\": null,\r\n            \"Start\": \"2019-10-07T00:00:00.000Z\",\r\n            \"End\": \"2019-10-09T00:00:00.000Z”… \r\n```\r\n\r\nI used select. All properties are in response. The key names remain here. Those that were not specified do not have values, such as serial number or note. I would like to receive only those properties that I defined in select. Without serial number, note etc.\r\n\r\nIf I use getRawOne instead of getOne, I only get those properties that I defined in select, but the structure of the rental items array is lost.\r\n\r\n\r\n```\r\n{\r\n    \"ProductInstance_Id\": 3008,\r\n    \"ProductInstance_Color\": \"Silver\",\r\n    \"RentalItems_Id\": 19868,\r\n    \"RentalItems_Start\": \"2019-10-07T00:00:00.000Z\",\r\n    \"RentalItems_End\": \"2019-10-09T00:00:00.000Z\"\r\n} \r\n```\r\nI would like to receive a response where all the structure is preserved and there are only the values defined in select. Is it possible? Thanks.\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/4864/comments",
    "author": "mirekuhlir",
    "comments": [
      {
        "user": "veluxa",
        "created_at": "2019-10-09T04:08:27Z",
        "body": "It could be the cause by use leftJoinAndSelect,try to use leftJoin"
      },
      {
        "user": "imnotjames",
        "created_at": "2021-07-04T16:27:01Z",
        "body": "Looks like this has been answered."
      }
    ]
  },
  {
    "number": 4857,
    "title": "get effected rows as orm entity after update query",
    "created_at": "2019-10-03T14:25:35Z",
    "closed_at": "2021-07-03T21:17:35Z",
    "labels": [
      "question",
      "driver: postgres"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/4857",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[x] `postgres`\r\n[ ] `cockroachdb`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[ ] `latest`\r\n[ ] `@next`\r\n[x] `0.2.16` (or put your version here)\r\n\r\nCan I update a table and get the updated rows as orm entity in one query?\r\nI tried to use returning('*') but it returns me the effected rows in original DB format and not as orm entity.\r\n\r\nThe query I tried:\r\n```\r\n\t\t\tawait this.conn\r\n\t\t\t\t.getRepository(User)\r\n\t\t\t\t.createQueryBuilder()\r\n\t\t\t\t.update()\r\n\t\t\t\t.where({ accountID, id: userID })\r\n\t\t\t\t.set(user)\r\n\t\t\t\t.returning('*')\r\n\t\t\t\t.execute();\r\n```",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/4857/comments",
    "author": "oyakovVonage",
    "comments": [
      {
        "user": "imnotjames",
        "created_at": "2021-07-03T21:17:35Z",
        "body": "They get returned as an `UpdateResult`.  For performance reasons we don't create entities from that."
      }
    ]
  },
  {
    "number": 4856,
    "title": "Can TypeORM parse denormalized data like a one-to-many?",
    "created_at": "2019-10-03T14:11:25Z",
    "closed_at": "2021-07-04T16:28:50Z",
    "labels": [
      "question",
      "driver: postgres"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/4856",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[x] `postgres`\r\n[ ] `cockroachdb`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[ ] `latest`\r\n[ ] `@next`\r\n[x] `0.2.18`\r\n\r\n\r\nI have a datasource that I don't control and cannot change that's in a denormalized format.  I need to parse these data into a normalized object graph.  Interestingly, the data are stored in the same shape they would be if they were normalized and joined together.\r\n\r\nI'd like to tell TypeORM to parse these data exactly as it would if the ORM had built the query.\r\n\r\nFor example, consider these data:\r\n```\r\nuserId | userName | photoUrl | photoCaption\r\n-------------------------------------------\r\n1      | Lu       | <url1>   | photo 1\r\n1      | Lu       | <url2>   | photo 2\r\n2      | Pat      | <url3>   | photo 3\r\n2      | Pat      | <url4>   | photo 4\r\n```\r\n\r\nI'd like to get an object graph shaped like this:\r\n```\r\n[\r\n  {\r\n    userId: 1, userName: 'Lu', \r\n    photos: [\r\n      { photoUrl: <url1>, photoCaption: 'photo 1' },\r\n      { photoUrl: <url2>, photoCaption: 'photo 2' }\r\n    ]\r\n  },\r\n  {\r\n    userId: 2, userName: 'Pat', \r\n    photos: [\r\n      { photoUrl: <url3>, photoCaption: 'photo 3' },\r\n      { photoUrl: <url4>, photoCaption: 'photo 4' }\r\n    ]\r\n  }\r\n]\r\n```\r\n\r\nIf my data were normalized, this would be a trivial one to many:\r\n```\r\nid | userName \r\n------------------\r\n1      | Lu       \r\n2      | Pat      \r\n\r\n\r\nuserId | photoUrl | photoCaption\r\n-------------------------------------------\r\n1      | <url1>   | photo 1\r\n1      | <url2>   | photo 2\r\n2      | <url3>   | photo 3\r\n2      | <url4>   | photo 4\r\n```\r\n\r\nThe funny thing is that the query produced would be roughly:\r\n```\r\nSELECT users.*, photos.*\r\nFROM users\r\nLEFT JOIN photos\r\n  ON users.id = photos.userId;\r\n```\r\n\r\nWhich produces the same data structure I have physically stored in my table.\r\n\r\nIs there a way to get TypeORM to parse these data into the parent child structure as though it had generated the query itself?\r\n\r\nSomething like this:\r\n```\r\n@Entity()\r\nclass Photo extends BaseEntity {\r\n  @PrimaryColumn() photoId!: number;\r\n  @Column() photoUrl!: string;\r\n  @Column() photoCaption!: string;\r\n}\r\n\r\n@Entity()\r\nclass UserPhotos extends BaseEntity {\r\n  @PrimaryColumn() id!: number;\r\n  @Column() userName!: string;\r\n\r\n  @SomethingMagicalAndWonderful()\r\n  photos: Photo[]\r\n}\r\n```\r\n\r\nOr maybe using `OneToMany` but having some tricky configuration that indicates it's not really a join?",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/4856/comments",
    "author": "tncbbthositg",
    "comments": [
      {
        "user": "humodz",
        "created_at": "2020-08-19T14:09:56Z",
        "body": "From glancing at SelecQueryBuilder.ts I'd guess no. The logic in SelecQueryBuilder.executeEntitiesAndRawResults, that converts the raw query result to the entities, seems to heavily assume that the tables actually exist."
      },
      {
        "user": "imnotjames",
        "created_at": "2021-07-04T16:28:50Z",
        "body": "The closest you'll get is an embedded entity.\r\n\r\nYou'll need to process the rest yourself."
      }
    ]
  },
  {
    "number": 4852,
    "title": "getOne() method looks not LIMIT query",
    "created_at": "2019-10-03T07:09:17Z",
    "closed_at": "2021-07-10T06:15:03Z",
    "labels": [
      "question",
      "comp: query builder",
      "performance",
      "driver: postgres"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/4852",
    "body": "**Issue type:**\r\n\r\n[ x] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[x ] `postgres`\r\n[ ] `cockroachdb`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[ x] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n \r\nHi!!\r\n\r\nI'm using your lib and it's great!!.. but just one quick doubt ...\r\n\r\nI'm doing a query like:\r\n\r\n```\r\nconst query = await this._accountRepository\r\n            .getOne();\r\n     \r\n```\r\nworks and return a single object ... BUT if i enable the logs of the query .. i can see this:\r\n\r\n`SELECT \"entity\".\"lastname\" AS \"entity_lastname\", \"entity\".\"attivo__c\" AS \"entity_attivo__c\", \"entity\".\"personhasoptedoutofemail\" AS \"entity_personhasoptedoutofemail\", \"entity\".\"id_account_18__c\" AS \"entity_id_account_18__c\", \"entity\".\"sesso__c\" AS \"entity_sesso__c\", \"entity\".\"personcontactid\" AS \"entity_personcontactid\", \"entity\".\"recordtypeid\" AS \"entity_recordtypeid\", \"entity\".\"consenso_marketing__c\" AS \"entity_consenso_marketing__c\", \"entity\".\"personemail\" AS \"entity_personemail\", \"entity\".\"codice_fiscale__c\" AS \"entity_codice_fiscale__c\", \"entity\".\"consenso_marketing_email__c\" AS \"entity_consenso_marketing_email__c\", \"entity\".\"consenso_marketing_tel__c\" AS \"entity_consenso_marketing_tel__c\", \"entity\".\"name\" AS \"entity_name\", \"entity\".\"stato_commerciale__c\" AS \"entity_stato_commerciale__c\", \"entity\".\"prossimo_compleanno__c\" AS \"entity_prossimo_compleanno__c\", \"entity\".\"consenso_marketing_sms__c\" AS \"entity_consenso_marketing_sms__c\", \"entity\".\"has_whatsapp__c\" AS \"entity_has_whatsapp__c\", \"entity\".\"phone\" AS \"entity_phone\", \"entity\".\"altra_email__c\" AS \"entity_altra_email__c\", \"entity\".\"ownerid\" AS \"entity_ownerid\", \"entity\".\"ispersonaccount\" AS \"entity_ispersonaccount\", \"entity\".\"isdeleted\" AS \"entity_isdeleted\", \"entity\".\"data_scadenza_consenso_mktg__c\" AS \"entity_data_scadenza_consenso_mktg__c\", \"entity\".\"systemmodstamp\" AS \"entity_systemmodstamp\", \"entity\".\"persondonotcall\" AS \"entity_persondonotcall\", \"entity\".\"eta__c\" AS \"entity_eta__c\", \"entity\".\"alert_truffa__c\" AS \"entity_alert_truffa__c\", \"entity\".\"createddate\" AS \"entity_createddate\", \"entity\".\"personmobilephone\" AS \"entity_personmobilephone\", \"entity\".\"personbirthdate\" AS \"entity_personbirthdate\", \"entity\".\"salutation\" AS \"entity_salutation\", \"entity\".\"professione__c\" AS \"entity_professione__c\", \"entity\".\"tipo_db__c\" AS \"entity_tipo_db__c\", \"entity\".\"personhomephone\" AS \"entity_personhomephone\", \"entity\".\"firstname\" AS \"entity_firstname\", \"entity\".\"consenso_trattamento_dati__c\" AS \"entity_consenso_trattamento_dati__c\", \"entity\".\"id_anagrafica__c\" AS \"entity_id_anagrafica__c\", \"entity\".\"sfid\" AS \"entity_sfid\", \"entity\".\"id\" AS \"entity_id\", \"entity\".\"_hc_lastop\" AS \"entity__hc_lastop\", \"entity\".\"_hc_err\" AS \"entity__hc_err\", \"entity\".\"id_contatto_18__pc\" AS \"entity_id_contatto_18__pc\" FROM \"salesforce\".\"account\" \"entity\"  `\r\n\r\nAs you can see the select query looks like NOT be LIMITED to one record .. (for example having LIMIT 1 at the end ) .. so i ask if is possible that the limit is done in the memory ONCE the query as been hitted on the DB and has returned all records\r\n\r\nReally thnx!!!",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/4852/comments",
    "author": "freefred81",
    "comments": [
      {
        "user": "jtushman",
        "created_at": "2020-02-07T13:41:48Z",
        "body": "yeah I was also totally confused by this, and had memory issue because of it"
      },
      {
        "user": "cnovoab",
        "created_at": "2020-03-15T19:01:41Z",
        "body": "Same problem over here... 😕 \r\n"
      },
      {
        "user": "natesilva",
        "created_at": "2020-05-17T00:59:18Z",
        "body": "Same problem. This is really a bug. Can be very bad on large tables."
      },
      {
        "user": "imnotjames",
        "created_at": "2021-07-03T18:50:50Z",
        "body": "This is because we can't use a limit when using joins for relations.  If your entity doesn't have any it will add a limit.  Otherwise, we can't."
      },
      {
        "user": "imnotjames",
        "created_at": "2021-07-10T06:15:03Z",
        "body": "Duplicate of #3015"
      },
      {
        "user": "wkalt",
        "created_at": "2023-05-17T18:12:06Z",
        "body": "why can't a limit be used on a join?"
      },
      {
        "user": "quezak",
        "created_at": "2023-06-05T15:01:19Z",
        "body": "Well since I arrived here from google, and @wkalt already resurrected an old thread, let me guess the answer :D \r\n\r\nLet's use the classic example of a `post` table and a `user` table, with a simple one-to-many relation via `post.authorId`.\r\n\r\nIf you make a query builder for users, and request to load a relation to all their posts in the past 30 days, then by adding `.getOne` you mean you want to get **one user and all their posts in relation**. But: when you have JOINs in the query, the DB returns a separate row for every (user, post) pair, so adding a `LIMIT 1` to the query would result in getting a single user with a single post."
      }
    ]
  },
  {
    "number": 4828,
    "title": "why Typeorm slows down when using simple where in operator",
    "created_at": "2019-09-29T00:48:20Z",
    "closed_at": "2021-07-03T06:35:45Z",
    "labels": [
      "question",
      "driver: mssql"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/4828",
    "body": "**Issue type:**\r\n\r\n[X] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[X] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[ ] `cockroachdb`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[X] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\ni am using the typeorm where in operators where i get the max(date) for each location and after about 70 location it returns the data after 90 second where in sql server takes only 5 seconds.\r\n\r\nthis is what i got so far this code works but the after alot of unsynclocations it slows that to the point it wont rerurn data anymore.\r\n\r\n> const getLastTimeIn = await getRepository(TimeInOut)\r\n>   .createQueryBuilder(\"TimeInOut\")\r\n>   .select([\"max(DateTrans) as date\"])\r\n>   .where(\"location IN (:...location)\")\r\n>   .setParameters({ location: unsyncLocations })\r\n>   .groupBy(\"location\")\r\n>   .getRawMany();\r\n\r\n\r\n\r\ni also tried looping the locations but it seems much slower than the code above\r\n\r\n> \r\n> for (let i = 0; i < unsyncLocations.length; i++) {\r\n>   const element = unsyncLocations[i];\r\n>   const getLastTimeIn = await getRepository(TimeInOut)\r\n>     .createQueryBuilder(\"TimeInOut\")\r\n>     .select(\"top 1 DateTrans\")\r\n>     .where(\"location = :location\")\r\n>     .setParameters({ location: element })\r\n>     .orderBy(\"DateTrans\", \"DESC\")\r\n>     .getRawMany();\r\n>   console.log(getLastTimeIn);\r\n>   await unsyncData.push({\r\n>     id: id,\r\n>     location: element,\r\n>     DateTrans: this.dateFormater(getLastTimeIn[0].DateTrans)\r\n>   });\r\n>   id++;\r\n> }\r\n\r\n\r\nthis is the entity for the timeinout\r\n\r\n> \r\n> @Entity(\"TimeInOut\")\r\n> export class TimeInOut {\r\n>   @PrimaryColumn(\"int\")\r\n>   ID: number;\r\n>   @Column(\"datetime\")\r\n>   DateTrans: string;\r\n>   @Column(\"int\")\r\n>   Attrib1: string;\r\n>   @Column(\"varchar\", { length: 30 })\r\n>   Attrib2: string;\r\n>   @Column(\"int\")\r\n>   Attrib3: string;\r\n>   @Column(\"int\")\r\n>   Attrib4: string;\r\n>   @Column(\"int\")\r\n>   IsSync: string;\r\n>   @Column(\"varchar\", { length: 100 })\r\n>   location: string;\r\n>   @Column(\"datetime\")\r\n>   timeStampLog: string;\r\n>   @Column(\"varchar\", { length: 500 })\r\n>   CompanyId: string;\r\n>   @Column(\"varchar\", { length: 500 })\r\n>   sourcelocation: string;\r\n> }\r\n> \r\n\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/4828/comments",
    "author": "uraman2000",
    "comments": [
      {
        "user": "imnotjames",
        "created_at": "2021-07-03T06:35:43Z",
        "body": "Pretty sure this was fixed by #7821 "
      }
    ]
  },
  {
    "number": 4827,
    "title": "ON DUPLICATE KEY UPDATE",
    "created_at": "2019-09-28T17:30:09Z",
    "closed_at": "2020-10-15T06:23:19Z",
    "labels": [
      "question",
      "driver: mysql",
      "driver: postgres",
      "driver: mariadb"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/4827",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[x] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[x] `postgres`\r\n[ ] `cockroachdb`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\nI have User:\r\n\r\n```js\r\nimport { Entity, PrimaryGeneratedColumn, Column, OneToMany, In, Index } from 'typeorm';\r\nimport { Post } from './Post';\r\n\r\n@Entity()\r\nexport class User {\r\n  @PrimaryGeneratedColumn()\r\n  id: number;\r\n\r\n  @Column()\r\n  name: string;\r\n\r\n  @OneToMany(type => Post, post => post.user, { cascade: true })\r\n  posts: Post[];\r\n}\r\n\r\n```\r\n\r\nPost:\r\n\r\n```js\r\nimport { Entity, PrimaryGeneratedColumn, Column, OneToMany, ManyToOne, ManyToMany, JoinTable } from 'typeorm';\r\nimport { User } from './User';\r\nimport { Tag } from './Tag';\r\n\r\n@Entity()\r\nexport class Post {\r\n  @PrimaryGeneratedColumn()\r\n  id: number;\r\n\r\n  @Column()\r\n  title: string;\r\n\r\n  @Column({ type: 'text' })\r\n  text: string;\r\n\r\n  @ManyToOne(type => User, user => user.posts)\r\n  user: User;\r\n\r\n  @ManyToMany(type => Tag, tag => tag.posts, { cascade: true })\r\n  @JoinTable({\r\n    name: 'post_has_tag',\r\n  })\r\n  tags: Tag[];\r\n}\r\n\r\n```\r\n\r\nPost_has_Tag:\r\n\r\n```js\r\nimport { Entity, ManyToOne, PrimaryColumn, Column } from 'typeorm';\r\nimport { Post } from './Post';\r\nimport { Tag } from './Tag';\r\n\r\n@Entity()\r\nexport class PostHasTag {\r\n  @PrimaryColumn()\r\n  tagId: number;\r\n\r\n  @PrimaryColumn()\r\n  postId: number;\r\n\r\n  @Column({ nullable: true })\r\n  newField: string;\r\n}\r\n\r\n```\r\n\r\nAnd Tag:\r\n\r\n```js\r\nimport { Entity, PrimaryGeneratedColumn, Column, ManyToMany, JoinTable } from 'typeorm';\r\nimport { Post } from './Post';\r\n\r\n@Entity()\r\nexport class Tag {\r\n  @PrimaryGeneratedColumn()\r\n  id: number;\r\n\r\n  @Column()\r\n  tag: string;\r\n\r\n  @ManyToMany(type => Post, post => post.tags)\r\n  @JoinTable({\r\n    name: 'post_has_tag',\r\n  })\r\n  posts: Post[];\r\n}\r\n\r\n```\r\n\r\nI am trying to save this data:\r\n```js\r\nconst user = {\r\n  name: 'My user',\r\n  posts: [\r\n    {\r\n      title: 'Post 1',\r\n      text: 'Some text',\r\n      tags: [\r\n        {\r\n          tag: 'Tag 1',\r\n        },\r\n        {\r\n          tag: 'Tag 2',\r\n        },\r\n      ],\r\n    },\r\n    {\r\n      title: 'Post 2',\r\n      text: 'Some text',\r\n      tags: [\r\n        {\r\n          tag: 'Tag 1',\r\n        },\r\n        {\r\n          tag: 'Tag 3',\r\n        },\r\n      ],\r\n    },\r\n  ],\r\n};\r\n\r\n```\r\nSo I do this:\r\n\r\n```js\r\n\r\nimport { User } from '../entity/User';\r\nawait getRepository(User).save(user);\r\n```\r\n\r\nAnd magically everything is saved. But.\r\n\r\nI don't want to have repeated tags in my Tags table. So if any user try to save tags whose names are already in the database, I want to link this posts to the existing tags. This is done via `ON DUPLICATE KEY UPDATE`. So my question is: is there any implementation of `ON DUPLICATE KEY UPDATE` in TypeORM?",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/4827/comments",
    "author": "emilecollin",
    "comments": [
      {
        "user": "morishjs",
        "created_at": "2019-12-11T02:35:26Z",
        "body": ">So my question is: is there any implementation of ON DUPLICATE KEY UPDATE in TypeORM?\r\n\r\nI guess there is no implementation.\r\nCheck out this #1463\r\n"
      },
      {
        "user": "imnotjames",
        "created_at": "2020-10-15T06:23:19Z",
        "body": "Use `orUpdate` in the query builder"
      }
    ]
  },
  {
    "number": 4818,
    "title": "Why are my queries seemingly delayed?",
    "created_at": "2019-09-26T13:08:14Z",
    "closed_at": "2020-10-06T06:56:51Z",
    "labels": [
      "question",
      "driver: postgres"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/4818",
    "body": "**Issue type:**\r\n\r\n[x ] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ x] `postgres`\r\n[ ] `cockroachdb`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[ ] `latest`\r\n[ ] `@next`\r\n[ x] `0.2.0-alpha.46` \r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nMy issue is as follows.\r\n\r\nAttempting to create 2 items from the frontend, we send a POST request with an array to our endpoint. Create (post method in feathersjs) then does this:\r\n\r\n```\r\nif (Array.isArray(data)) {\r\n      const succeeded = []\r\n      const failed = []\r\n      await Promise.all(data.map(async (current) => {\r\n        try {\r\n          console.log('Employee: ', current.employee)\r\n          const result = await this.create(current, params)\r\n          if (params.headers && params.headers.platform === 'iOS') {\r\n            succeeded.push(result.data[0])\r\n          } else {\r\n            succeeded.push(result)\r\n          }\r\n        } catch (e) {\r\n          // eslint-disable-next-line no-console\r\n          console.log(e)\r\n          failed.push(current)\r\n        }\r\n      }, this), this)\r\n      return {\r\n        data: succeeded,\r\n        failed,\r\n      }\r\n```\r\nThen, in each of the calls to this.create (where data is not an array, but an individual assignment we want to create), we handle some of the data and do the following:\r\n```\r\nconst createdAssign = await getConnection()\r\n      .getRepository(Assignment)\r\n      .save(assignment)\r\n\r\nconsole.log('getting this assignment id', createdAssign.id)\r\n    const idToFetch = createdAssign.id // this id is correct\r\n    const finishedAssignment = await this.get(idToFetch, _.clone(params))\r\n    // finishedAssignment is the wrong assignment. it is the last assignment in the array of created assignments.\r\n    if (finishedAssignment) {\r\n      const assignDate = moment.utc(finishedAssignment.start).valueOf()\r\n      const JSONAssign = JSON.stringify(finishedAssignment)\r\n      console.log('assigndate ', assignDate)\r\n      console.log('jsonassign', !!finishedAssignment)\r\n      console.log(finishedAssignment)\r\n      const added = await zadd(`${finishedAssignment.company}_assignments`, assignDate, JSONAssign)\r\n      console.log('created assignment and added it to assigns cache', !!added)\r\n      const added2 = await zadd(`${finishedAssignment.company}_recent_assignments`, moment.utc().valueOf(), JSONAssign)\r\n      console.log('created assignment and added it to recent assigns cache', !!added2)\r\n    }\r\n    return finishedAssignment\r\n```\r\n\r\nIn the call to this.get, the following happens:\r\n\r\n```\r\nparams.query.id = id\r\n// Here, the console.logged id is correct\r\nconsole.log('received this id request', params.query.id)\r\nconst assign = await getConnection()\r\n      .getRepository(Assignment)\r\n      .createQueryBuilder('assignment')\r\n      .select([\r\n        'assignment.id AS \"id\"',\r\n        'assignment.start AS \"start\"',\r\n        'assignment.end AS \"end\"',\r\n        'assignment.hourState AS \"hourState\"',\r\n        'assignment.createdAt AS \"createdAt\"',\r\n        'assignment.updatedAt AS \"updatedAt\"',\r\n        'assignment.exported AS \"exported\"',\r\n        'assignment.weather AS \"weather\"',\r\n        'assignment.company AS \"company\"',\r\n        'assignment.project AS \"project\"',\r\n        'assignment.employee AS \"employee\"',\r\n        'assignment.customerSignature AS \"customerSignature\"',\r\n        'assignment.locatedAt AS \"locatedAt\"',\r\n        'assignment.salaryType AS \"salaryType\"',\r\n        // '(SELECT COALESCE(array_to_json(array_agg(note.id)), \\'[]\\') FROM note WHERE note.\"assignmentId\" = assignment.id) AS notes',\r\n        '(SELECT COALESCE(array_to_json(array_agg(note.text)), \\'[]\\') FROM note WHERE note.\"assignmentId\" = assignment.id) AS notes',\r\n        // '(SELECT COALESCE(array_to_json(array_agg(assignment_history.id)), \\'[]\\') FROM assignment_history WHERE assignment_history.\"assignmentId\" = assignment.id) AS assignmentHistories',\r\n        '(SELECT COALESCE(array_to_json(array_agg(conflict.id)), \\'[]\\') FROM conflict WHERE conflict.\"assignmentId\" = assignment.id) AS conflicts',\r\n      ])\r\n      .where('id = :1 AND \"companyId\" = :2', { 1: params.query.id, 2: params.query.company })\r\n      .limit(1)\r\n      .execute()\r\n// some more code\r\nreturn assign\r\n```\r\n\r\nThe returned result is an array full of the same assignment x times (depending on the amount of assignments we attempted to create. In other words, *the assignments are created just fine, but the select queries to get those new assignments from the database are somehow delayed until the loop ends, and the values in the select WHERE clause are all the values of the last assignment in the loop.*",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/4818/comments",
    "author": "cooperfrench95",
    "comments": [
      {
        "user": "silentroach",
        "created_at": "2019-10-01T06:26:44Z",
        "body": "`_.clone` is 1 level deep clone, so `params.query` in your case is always pointing to the same object and you try to modify its id (`params.query.id = id`). Try to use `_.cloneDeep` if you want to keep your coding style.\r\n\r\nAlso it is better to call `<repository>.save([array of assignments])` and then fetch it with something like `.where('companyId = :companyId and id in (:..ids)', { companyId, ids })` than to insert/read it one by one."
      }
    ]
  },
  {
    "number": 4813,
    "title": "QueryRunner failing to retrieve schemas and tables after successfully running runMigrations()",
    "created_at": "2019-09-25T15:27:31Z",
    "closed_at": "2020-10-07T05:34:55Z",
    "labels": [
      "bug",
      "question",
      "comp: migrations",
      "driver: postgres"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/4813",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[x] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[x] `postgres`\r\n[ ] `cockroachdb`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[ ] `latest`\r\n[ ] `@next`\r\n[ x] `0.x.x` (0.2.19)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\nI am a new user trying to understand QueryRunner and how to run migrations on a PostgreSQL connection using `connection.runMigrations()`. In the code block below, after I successfully issue runMigrations(), why does the `getDatabases()`, `getSchemas()` and `getTables` methods of the queryRunner instance return empty lists? Shouldn't they return the schemas and tables for the database that the connection represents?\r\n\r\nThe output from running the code block below is:\r\n```bash\r\n[Nest] 14607   - 09/25/2019, 4:21:13 PM   createAConnection() => Connecting with options => {...}\r\n[Nest] 14607   - 09/25/2019, 4:21:13 PM   createAConnection() => Dropping database... +146ms\r\n[Nest] 14607   - 09/25/2019, 4:21:13 PM   createAConnection() => Database successfully dropped +26ms\r\n[Nest] 14607   - 09/25/2019, 4:21:13 PM   createAConnection() => connected +0ms\r\n[Nest] 14607   - 09/25/2019, 4:21:13 PM   Running migrations with connection status true +0ms\r\n[Nest] 14607   - 09/25/2019, 4:21:13 PM   Migrations successfully ran, these are... +20ms\r\n[Nest] 14607   - 09/25/2019, 4:21:13 PM   Migration => InitialMigration1568198782367 +1ms\r\n[Nest] 14607   - 09/25/2019, 4:21:13 PM   Creating QueryRunner +1ms\r\n[Nest] 14607   - 09/25/2019, 4:21:13 PM   QueryRunner connected +1ms\r\n[Nest] 14607   - 09/25/2019, 4:21:13 PM   Retrieved databases using queryRunner.getDatabases() :: [] +0ms\r\n[Nest] 14607   - 09/25/2019, 4:21:13 PM   Retrieved schemas using queryRunner.getSchemas() :: [] +1ms\r\n[Nest] 14607   - 09/25/2019, 4:21:13 PM   Retrieved expected tables using queryRunner.getTables => [] +16ms\r\n```\r\n\r\n```ts\r\nimport { Logger } from '@nestjs/common';\r\nimport { createConnection, Connection, QueryRunner, Table } from 'typeorm';\r\n\r\nimport { ConfigOptions } from './config/models/config.options';\r\nimport { ConfigServiceFactory } from './config/factories/configservice.factory';\r\nimport { PostgresConnectionOptions } from 'typeorm/driver/postgres/PostgresConnectionOptions';\r\nimport { Migration } from 'typeorm/migration/Migration';\r\n\r\nasync function dispose(connection: Connection) {\r\n  if (connection && connection.isConnected) {\r\n    await connection.close();\r\n  }\r\n}\r\n\r\nasync function createAConnection(): Promise<Connection> {\r\n  let connection: Connection;\r\n\r\n  // override default connections to avoid dropping schema and running migrations\r\n  // we are doing this manually\r\n  const config: ConfigOptions = ConfigServiceFactory.loadDbConfigSync();\r\n  const dbConfig: PostgresConnectionOptions = config.db as PostgresConnectionOptions;\r\n  const connect: PostgresConnectionOptions = {\r\n    ...dbConfig,\r\n    dropSchema: false,\r\n    logging: false,\r\n    migrationsRun: false,\r\n  };\r\n\r\n  try {\r\n    Logger.log(\r\n      `createAConnection() => Connecting with options => ${JSON.stringify(\r\n        connect,\r\n        null,\r\n        2,\r\n      )}`,\r\n    );\r\n    connection = await createConnection(connect);\r\n    Logger.log('createAConnection() => Dropping database...');\r\n    await connection.dropDatabase();\r\n    Logger.log('createAConnection() => Database successfully dropped');\r\n  } catch (err) {\r\n    Logger.error(`createAConnection() => Failed to connect => ${err}`);\r\n    await dispose(connection);\r\n    throw err;\r\n  }\r\n  Logger.log('createAConnection() => connected');\r\n\r\n  return connection;\r\n}\r\n\r\nasync function driver(connection: Connection) {\r\n  Logger.log(\r\n    `Running migrations with connection status ${connection.isConnected}`,\r\n  );\r\n  const migrations: Migration[] = await connection.runMigrations();\r\n  Logger.log('Migrations successfully ran, these are...');\r\n  migrations.forEach(element => {\r\n    Logger.log(`Migration => ${element.name}`);\r\n  });\r\n\r\n  Logger.log('Creating QueryRunner');\r\n  let queryRunner: QueryRunner = connection.createQueryRunner('master');\r\n  await queryRunner.connect();\r\n  Logger.log('QueryRunner connected');\r\n\r\n  const databases: string[] = await queryRunner.getDatabases();\r\n  Logger.log(\r\n    `Retrieved databases using queryRunner.getDatabases() :: ${JSON.stringify(\r\n      databases,\r\n    )}`,\r\n  );\r\n  const schemas: string[] = await queryRunner.getSchemas();\r\n  Logger.log(\r\n    `Retrieved schemas using queryRunner.getSchemas() :: ${JSON.stringify(\r\n      schemas,\r\n    )}`,\r\n  );\r\n  const tables: Table[] = await queryRunner.getTables([\r\n    'coursemanagement.Course',\r\n    'coursemanagement.Migrations',\r\n  ]);\r\n  Logger.log(\r\n    `Retrieved expected tables using queryRunner.getTables => ${JSON.stringify(\r\n      tables,\r\n    )}`,\r\n  );\r\n}\r\n\r\nasync function main() {\r\n  const myConnection: Connection = await createAConnection();\r\n  await driver(myConnection);\r\n}\r\n\r\nmain();\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/4813/comments",
    "author": "dcs3spp",
    "comments": [
      {
        "user": "imnotjames",
        "created_at": "2020-10-07T05:34:55Z",
        "body": "This is a duplicate of #4489 - It's not because of the migration, it just was never implemented."
      }
    ]
  },
  {
    "number": 4752,
    "title": "Cannot enlarge memory arrays with sqlJS",
    "created_at": "2019-09-16T08:53:01Z",
    "closed_at": "2020-10-06T06:47:58Z",
    "labels": [
      "question",
      "driver: sqljs"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/4752",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[ ] `cockroachdb`\r\n[ ] `sqlite`\r\n[x] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nSqlJsConnectionOptions allow for a sqlJsConfig input but there is no information on how to turn on \r\nALLOW_MEMORY_GROWTH=1 or to use \r\n\r\nfrom sqljs documentation\r\n```\r\nsql-asm-memory-growth.js : Asm.js doesn't allow for memory to grow by default, because it is slower and de-optimizes. If you are using sql-asm.js and you see this error (Cannot enlarge memory arrays), use this file.\r\n```",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/4752/comments",
    "author": "ydstaana",
    "comments": [
      {
        "user": "imnotjames",
        "created_at": "2020-10-06T06:47:58Z",
        "body": "You can pass in options to `sqljs` directly with `extra` in the connection options."
      }
    ]
  },
  {
    "number": 4721,
    "title": "DriverPackageNotInstalledError: SQL Server package has not been found installed",
    "created_at": "2019-09-10T15:01:27Z",
    "closed_at": "2020-10-06T06:50:13Z",
    "labels": [
      "question",
      "driver: mssql"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/4721",
    "body": "**Issue type:**\r\n\r\n[X] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[X] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[ ] `cockroachdb`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[X] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\nI'm trying to use TypeORM in a Sharepoint 2016 Web part to connect to SQL Server and perform a simple query.  I've tried reading the documentation about usage in the Browser and from what I understand I can only use sql.js, is that correct?\r\n\r\nBecause this is part of a Sharepoint Web Part that has many levels of code I can't really provide a sample for you to use that's standalone. \r\n\r\nThe issue i'm running into is:\r\nDriverPackageNotInstalledError: SQL Server package has not been found installed. Try to install it: npm install mssql --save\r\n\r\nI have installed the mssql package several times but continue to receive the same message.\r\nI'm assuming this is because there is no support for mssql in the browser?\r\n\r\nAny info you could give would be greatly appreciated.\r\nI'm very new to typescript and all this stuff.\r\n\r\nThank you for your time.\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/4721/comments",
    "author": "ghost",
    "comments": [
      {
        "user": "silentroach",
        "created_at": "2019-10-01T12:46:46Z",
        "body": "yep, you can't use mssql via browser package"
      },
      {
        "user": "imnotjames",
        "created_at": "2020-10-06T06:50:13Z",
        "body": "mssql is a binary package.  As such, like said above - it can't be installed as part of the browser.  Also as of the latest version we prevent this from occurring at all by replacing the driver with a no-op."
      },
      {
        "user": "emazzu",
        "created_at": "2022-11-30T17:12:37Z",
        "body": "alguien puso solucionar esto ??"
      }
    ]
  },
  {
    "number": 4718,
    "title": "TypeORM tries to drop views that are needed by the pg_stat_statements extension",
    "created_at": "2019-09-10T08:49:04Z",
    "closed_at": "2020-10-04T02:50:48Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/4718",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[x] `postgres`\r\n[ ] `cockroachdb`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\n1. Enable extension pg_stat_statments\r\n2. Start your application with the synchronize option set to true\r\n\r\nThe error that is caused:\r\n\r\n`QueryFailedError: cannot drop view pg_stat_statements because extension pg_stat_statements requires it`\r\n\r\nWhy is TypeORM trying to drop a view that is needed by the extension? Is TypeORM not compatible with pg_stat_statements?\r\n\r\n<!--\r\n    To answer those questions you need to put \"x\" inside the square brackets, for example:\r\n    [x] `mysql`\r\n    [ ] `postgres`\r\n\r\n    Also, please format your code properly (by taking code blocks into ```ts .... ```)\r\n!>\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/4718/comments",
    "author": "lucaslenz",
    "comments": [
      {
        "user": "Kononnable",
        "created_at": "2019-10-16T08:32:03Z",
        "body": "I don't know this extension, but it looks like it creates it's own tables/views in your schema. Typeorm while synchronizing deletes every database object which isn't described using typeorm decorators(or entity schemas). It can't distinguish if such object is no longer necessary or is it something completely not related to your app code.\r\n\r\nIf you want to use typeorm with tables/views not related to your app code you probably need to make dummy view/table in typeorm and disable synchronization for it - just empty class decorated with Column/ViewEntity with `synchronize:false` and proper name."
      },
      {
        "user": "lucaslenz",
        "created_at": "2019-10-28T12:50:33Z",
        "body": "Thanks for your advice.\r\nI solved the problem by only using Migrations instead of the synchronization feature as you suggested.\r\n\r\nCan be closed."
      },
      {
        "user": "zveljkovic",
        "created_at": "2022-02-25T15:33:15Z",
        "body": "I would like this to be reopened as we have a need to reset the database and would like to use `schema:drop` but it fails with\r\n\r\n`\r\nquery: 'DROP VIEW IF EXISTS \"public\".\"pg_stat_statements\" CASCADE;',\r\n  parameters: undefined,\r\n  driverError: error: must be owner of view pg_stat_statements\r\n`\r\n\r\nIt would be nice to exclude some views/tables from dropping by config."
      },
      {
        "user": "Ginden",
        "created_at": "2022-02-25T16:26:18Z",
        "body": "@zveljkovic You can describe these views and mark them with `synchronize: false`."
      }
    ]
  },
  {
    "number": 4716,
    "title": "Custom Function (extends SelectQueryBuilder)",
    "created_at": "2019-09-09T22:31:14Z",
    "closed_at": "2020-10-06T06:51:27Z",
    "labels": [
      "question",
      "driver: mysql",
      "driver: postgres",
      "driver: mariadb",
      "driver: mssql",
      "driver: oracle"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/4716",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[x] `mssql`\r\n[x] `mysql` / `mariadb`\r\n[x] `oracle`\r\n[x] `postgres`\r\n[ ] `cockroachdb`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Questions:**\r\n1. How to add custom functions such as findCustom(params) in Repository object, without using CustomRepository.\r\n```ts\r\nconst params = {\r\n  employeeIds: [1, 2, 3, 4],\r\n};\r\nconst employeeLists = await getRepository(Employeee).findCustom(params);\r\n```\r\n\r\n2. How to add custom functions such as getManyCustom(params) in the SelectQueryBuilder  object\r\n```ts\r\nconst params = {\r\n  employeeIds: [1, 2, 3, 4],\r\n};\r\nconst employeeLists = await Employeee.createQueryBuilder('employee').getManyCustom(params);\r\n```",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/4716/comments",
    "author": "ahmadarif",
    "comments": [
      {
        "user": "ahmadarif",
        "created_at": "2019-09-09T23:46:01Z",
        "body": "Now, I'm using monkey patch to implement custom function.\r\n\r\n```ts\r\nimport { SelectQueryBuilder } from 'typeorm/query-builder/SelectQueryBuilder';\r\nimport { Auth } from './helpers/auth.helper';\r\n\r\n// TypeORM patch :===============================================================================\r\ndeclare module 'typeorm/query-builder/SelectQueryBuilder' {\r\n  interface SelectQueryBuilder<Entity> {\r\n    getOneAuth(auth: Auth): Promise<Entity>;\r\n    getManyAuth(auth: Auth): Promise<Entity[]>;\r\n  }\r\n}\r\n\r\nSelectQueryBuilder.prototype.getOneAuth = function(auth: Auth) {\r\n  console.log(this);\r\n  console.log('getOneAuth called');\r\n  return this.getOne();\r\n};\r\n\r\nSelectQueryBuilder.prototype.getManyAuth = function(auth: Auth) {\r\n  console.log(this);\r\n  console.log('getManyAuth called');\r\n  return this.getMany();\r\n};\r\n```"
      },
      {
        "user": "imnotjames",
        "created_at": "2020-10-06T06:51:27Z",
        "body": "You cannot extend the query builder directly.  If you'd like to monkey-patch it, we can't stop ya, but it's definitely not supported.\r\n\r\nA utility method could give you similar results that you pass a query builder into."
      },
      {
        "user": "ahmadarif",
        "created_at": "2020-10-06T08:32:51Z",
        "body": "Thanks for the response, the complete result is I've added some where clause on query builder before return the results.\r\nBtw, using monkey patch can solve my need 👍 "
      }
    ]
  },
  {
    "number": 4710,
    "title": "How to stub chained functions using sinon in TypeORM ?",
    "created_at": "2019-09-08T15:49:11Z",
    "closed_at": "2020-10-06T06:57:22Z",
    "labels": [
      "question",
      "driver: mysql",
      "driver: mariadb"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/4710",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[x] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[ ] `cockroachdb`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\nI'm currently using TypeORM and Sinonjs in my project. But I'm not sure how to write the unit test in the right way. Especially how to stub a chained function call, like this \r\n\r\n```javascript\r\n  async find(id: number): Promise<User> {\r\n    const user = await this.connection\r\n      .getRepository(User)\r\n      .createQueryBuilder(\"user\")\r\n      .where(\"user.id = :id\", { id: id })\r\n      .getOne();\r\n    return user;\r\n  }\r\n```\r\nMy test file\r\n\r\n```javascript\r\n    // bla bla\r\n    it(\"should return a data from db\", async () => {\r\n      let user = {\r\n        id: 1,\r\n        name: \"my name\"\r\n      };\r\n\r\n      const getOne = Sinon.stub().resolves(user);\r\n      const where = Sinon.stub().callsArg(0);\r\n      const createQueryBuilder = Sinon.stub().callsArg(0);\r\n      const connection = {\r\n        getRepository: Sinon.stub()\r\n      };\r\n\r\n      connection.getRepository.withArgs(User).returns(createQueryBuilder);\r\n      createQueryBuilder.withArgs(\"user\").returns(where);\r\n      where.withArgs(\"user.id = :id\", { id: user.id }).returns(getOne);\r\n      // bla bla\r\n    });\r\n```\r\nI always got this error\r\n\r\n> TypeError: this.connection.getRepository(...).createQueryBuilder is not a function\r\n\r\nAny advice is welcome! \r\nThank you very much!",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/4710/comments",
    "author": "TranBaVinhSon",
    "comments": [
      {
        "user": "DimaIT",
        "created_at": "2019-09-12T16:17:54Z",
        "body": "It seems to me that issue is that `getRepository` returns stub function, but not object that contains property `createQueryBuilder`.\r\n\r\nHere example that works for me:\r\n```typescript\r\n    // bla bla\r\n    it(\"should return a data from db\", async () => {\r\n      let user = {\r\n        id: 1,\r\n        name: \"my name\"\r\n      };\r\n\r\n      const getOne = Sinon.stub().resolves(user);\r\n      const where = Sinon.stub().callsArg(0);\r\n      const createQueryBuilder = Sinon.stub().callsArg(0);\r\n      const connection = {\r\n        getRepository: Sinon.stub()\r\n      };\r\n\r\n      connection.getRepository.withArgs(User).returns({ createQueryBuilder });\r\n      createQueryBuilder.withArgs(\"user\").returns({ where });\r\n      where.withArgs(\"user.id = :id\", { id: user.id }).returns({ getOne });\r\n      // bla bla\r\n    });\r\n```"
      }
    ]
  },
  {
    "number": 4705,
    "title": "Unable to install typeorm-browser",
    "created_at": "2019-09-06T14:44:50Z",
    "closed_at": "2021-05-29T13:28:05Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/4705",
    "body": "**Issue type:**\r\n\r\n[X ] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\nWhile attempting to install typeorm-browser using NPM 6.11.1 IDE: Visual Studio Code (latest).\r\n\r\nCommand: npm i typeorm-browser\r\n\r\nResult:\r\n```\r\nnpm WARN uglifyjs-webpack-plugin@0.4.6 requires a peer of webpack@^1.9 || ^2 || ^2.1.0-beta || ^2.2.0-rc || ^3.0.0 but none is installed. You must install peer dependencies yourself.\r\nnpm WARN optional SKIPPING OPTIONAL DEPENDENCY: fsevents@1.2.9 (node_modules\\fsevents):\r\nnpm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for fsevents@1.2.9: wanted {\"os\":\"darwin\",\"arch\":\"any\"} (current: {\"os\":\"win32\",\"arch\":\"x64\"})\r\n\r\nnpm ERR! code ENOENT\r\nnpm ERR! syscall chmod\r\nnpm ERR! path C:\\SharePoint_PowerShell_SandBox\\SharePoint2016\\sqlconnector-webpart\\node_modules\\typeorm-browser\\cli.js\r\nnpm ERR! errno -4058\r\nnpm ERR! enoent ENOENT: no such file or directory, chmod 'C:\\SharePoint_PowerShell_SandBox\\SharePoint2016\\sqlconnector-webpart\\node_modules\\typeorm-browser\\cli.js'\r\nnpm ERR! enoent This is related to npm not being able to find a file.\r\nnpm ERR! enoent\r\n\r\nnpm ERR! A complete log of this run can be found in:\r\nnpm ERR!     C:\\Users\\xxx\\AppData\\Roaming\\npm-cache\\_logs\\2019-09-06T14_40_56_556Z-debug.log\r\n\r\n```\r\n\r\nAm I doing something wrong?",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/4705/comments",
    "author": "ghost",
    "comments": [
      {
        "user": "Kononnable",
        "created_at": "2019-10-16T07:31:15Z",
        "body": "You should use `typeorm` npm package instead.\r\n@pleerock looks like `typeorm-browser` should be marked as deprecated on npm a long time ago :)"
      }
    ]
  },
  {
    "number": 4687,
    "title": "Why `repository.findOne(null)` returns 1st record of the table?",
    "created_at": "2019-09-04T04:03:47Z",
    "closed_at": "2019-10-16T07:13:01Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/4687",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[x] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[ ] `cockroachdb`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[ ] `latest`\r\n[ ] `@next`\r\n[x] `0.2.15` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\n```ts\r\nconst user = await userRepository.findOne(null); \r\n// user.id is 1\r\n```\r\n\r\nI expect it would returns `undefined`. Is it intended?",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/4687/comments",
    "author": "anthonylau",
    "comments": [
      {
        "user": "DimaIT",
        "created_at": "2019-09-05T16:04:45Z",
        "body": "As we have in documentation: `findOne - Finds first entity that matches some id or find options.`. If no find options given then every record matches.\r\n\r\nIt may be confusing, especially when you are expecting `findOne` to search by id only. In such case it may be better to search by id explicitly: `userRepository.findOne({ id: value })`. Then you 'll get `undefined` for `null` value."
      }
    ]
  },
  {
    "number": 4676,
    "title": "update cascade, it deletes parent instead of updating it",
    "created_at": "2019-09-02T01:57:15Z",
    "closed_at": "2021-07-04T15:46:43Z",
    "labels": [
      "question",
      "driver: mysql",
      "driver: mariadb"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/4676",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[x] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[ ] `cockroachdb`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\ni am facing an issue using update cascade:\r\ni have the following relations for example\r\n\r\nParent <> Child is  OneToMany\r\nChild <> ChildClothes is OneToMany\r\nParent <> ChildClothes is OneToMany\r\n\r\nnow my object consist of:\r\nobject {\r\nchildData:  Child,\r\nparentData: Parent,\r\nchildClothesData: ChildCloths[]\r\n}\r\n\r\nfirst of all, sorry because the database and step to reproduce the problem are not by the book, but the relations i am using are kinda complex, this was the simplest demonstration to explain my problem.\r\n\r\nnow my problem is:\r\n\r\nwhenever i try to update this object with its relations, when i remove the \"parentData\", data is updated successfully, but when i add the \"parentData\", typeorm deletes parent data with the given parent 'id', and case i didn't add the 'id', it deletes whoever the parent this record had and creates new one with the new data.\r\n\r\nbeen surfing the internet for similar case, couldn't find any, any help would be really great.\r\nthank you in advance.\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/4676/comments",
    "author": "mazenmmbadr",
    "comments": [
      {
        "user": "imnotjames",
        "created_at": "2021-07-04T15:46:43Z",
        "body": "When opening an issue, people will be better able to provide help if you provide code that they can easily understand and use to reproduce the problem. This boils down to ensuring your code that reproduces the problem follows the following guidelines:\r\n\r\n* Minimal – Use as little code as possible that still produces the same problem\r\n* Complete – Provide all parts someone else needs to reproduce your problem in the question itself\r\n* Reproducible – Test the code you're about to provide to make sure it reproduces the problem\r\n\r\n## Minimal\r\nThe more code there is to go through, the less likely people can find your problem. Streamline your example in one of two ways:\r\n\r\n1. Restart from scratch. Create a new program, adding in only what is needed to see the problem. Use simple, descriptive names for functions and variables – don’t copy the names you’re using in your existing code.\r\n2. Divide and conquer. If you’re not sure what the source of the problem is, start removing code a bit at a time until the problem disappears – then add the last part back.\r\n\r\nDon't sacrifice clarity for brevity when creating a minimal example. Use consistent naming and indentation, and include code comments if needed. Use your code editor’s shortcut for formatting code.\r\n\r\nDon't include any passwords or credentials that must be kept secret.\r\n\r\n## Complete\r\n\r\nMake sure all information necessary to reproduce the problem is included in the issue itself.\r\n\r\nIf the problem requires some code as well as some XML-based configuration, include code for both. The problem might not be in the code that you think it is in.\r\n\r\nUse individual code blocks for each file or snippet you include. Provide a description for the purpose of each block.\r\n\r\n**DO NOT** use images of code. Copy the actual text from your code editor, paste it into the issus, then format it as code. This helps others more easily read and test your code.\r\n\r\n## Reproducible\r\n\r\nTo help you solve your problem, others will need to verify that it exists.\r\n\r\nDescribe the problem. \"It doesn't work\" isn't descriptive enough to help people understand your problem. Instead, tell other readers what the expected behavior should be. Tell other readers what the exact wording of the error message is, and which line of code is producing it. Use a brief but descriptive summary of your problem as the title of your question.\r\n\r\nEliminate any issues that aren't relevant to the problem. If your question isn’t about a compiler error, ensure that there are no compile-time errors.\r\n\r\nDouble-check that your example reproduces the problem! If you inadvertently fixed the problem while composing the example but didn't test it again, you'd want to know that before asking someone else to help."
      }
    ]
  },
  {
    "number": 4608,
    "title": "entityManager.delete() proving to be a big footgun",
    "created_at": "2019-08-19T19:40:24Z",
    "closed_at": "2020-10-12T09:26:22Z",
    "labels": [
      "question",
      "driver: postgres",
      "comp: find options"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/4608",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[x] `postgres`\r\n[ ] `cockroachdb`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nIf you do this, what happens?\r\n\r\n```ts\r\nentityManager.delete(User, { where: { name: \"Omar\" } });\r\n```\r\n\r\nAnswer: It deletes every `User` in your database, because `delete` doesn't take `FindOptions`, and therefore the `where` key appears to be completely ignored.\r\n\r\nThis is easily avoidable by using it as the documentation says, and instead doing `delete(User, { name: \"Omar\" })`; but since TypeScript won't tell you that you're doing anything wrong due to the overly general types, my team is finding this to be a particularly volatile API choice for TypeORM to not warn against.\r\n\r\nBetter would be stricter types to forbid usage of keys that aren't a part of `User`, but as a general complaint, wish the TypeORM APIs just generally had stricter enforcement of a consistent API invocation syntax.",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/4608/comments",
    "author": "osdiab",
    "comments": [
      {
        "user": "imnotjames",
        "created_at": "2020-10-12T09:26:22Z",
        "body": "Duplicate of #3416 "
      }
    ]
  },
  {
    "number": 4587,
    "title": "dynamic connectionOptions",
    "created_at": "2019-08-15T11:49:20Z",
    "closed_at": "2021-07-04T17:35:37Z",
    "labels": [
      "enhancement",
      "question",
      "new feature",
      "discussion",
      "comp: configuration",
      "driver: postgres"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/4587",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[ ] bug report\r\n[x] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[x] `postgres`\r\n[ ] `cockroachdb`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[ ] `latest`\r\n[ ] `@next`\r\n[x] `0.2.9` \r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nI have an issue with connection management/pooling. We would like to rotate the password on our database regularly, but without restarting all our application code (this is split across many lambdas, so would be painful to automate). What I am looking for is a an API a bit like this:\r\n\r\n```ts\r\nawait createConnection(async () => {\r\n    const secret = await readSecretFromSecretsManager(); \r\n    return {\r\n        type: 'postgres',\r\n        host: secret.host,\r\n        username: secret.userName,\r\n        password: secret.password,\r\n        port: 5432,\r\n        database: secret.database,\r\n        synchronize: false,\r\n        dropSchema: false,\r\n        logging: enableLogging,\r\n        entities: myEntities\r\n    }\r\n});\r\n```\r\nThe goal here is that every time a new connection is added to the pool, the secret is read from the SecretsManager service. This means that if the password changes, when TypeORM tries to create a new connection, it will use the new password. Currently, TypeORM is using the stale, cached connectionOptions.\r\n\r\nThanks for any thoughts or advice on this!\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/4587/comments",
    "author": "MartinHignett",
    "comments": [
      {
        "user": "itonics-tbeauvais",
        "created_at": "2019-09-11T08:38:02Z",
        "body": "This is quite critical in our application. Otherwise, we get a solution, or we will have to think about moving away from TypeORM."
      },
      {
        "user": "imnotjames",
        "created_at": "2021-07-04T17:35:35Z",
        "body": "I think this is better managed within your application code.  When you know the password has rotated, close all connections and connect with the new password.  "
      }
    ]
  },
  {
    "number": 4551,
    "title": "Generate DDL Files",
    "created_at": "2019-08-07T15:28:01Z",
    "closed_at": "2020-10-13T18:04:37Z",
    "labels": [
      "enhancement",
      "question",
      "comp: cli tools",
      "comp: migrations"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/4551",
    "body": "**Issue type:**\r\n\r\n[X] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[ ] `cockroachdb`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[X] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nIs there a way to generate a DDL file from the source code / or the database?\r\nI'm not able to find anything like it.\r\n\r\nOur goal is to generate the schema from the source code for a specific database. \r\nThen pass those files to our DBs for creating the schema + tables on the production db. (there is no other way for us to do it :( )\r\n\r\nAny ideas on how this can be done? ",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/4551/comments",
    "author": "gerwinbrunner",
    "comments": [
      {
        "user": "nvander1",
        "created_at": "2019-08-14T14:50:18Z",
        "body": "Our team would also love to see this feature. We have been using a workaround by launching our application and telling TypeOrm to synchronize the database. But this is clunky for us, and would also love the ability to generate the DDLs.\r\n\r\nI assume this is possible since TypeORM executes create table statements for you, but I'm not sure of the scope of code change involved that would allow this behavior.\r\n\r\n@pleerock @AlexMesser @daniel-lang @rustamwin @iz-iznogood "
      },
      {
        "user": "meltzwho",
        "created_at": "2019-08-14T15:28:54Z",
        "body": "@gerwinbrunner Great idea, would love to see this added. \r\n\r\n@pleerock @AlexMesser Have you thought about this before? How feasible?"
      },
      {
        "user": "ghost",
        "created_at": "2019-08-14T17:16:40Z",
        "body": "@gerwinbrunner Great idea. Managing schemas and entities across teams is hard, and converting entities in code to a common definition like DDL would help a lot.\r\n\r\n@pleerock @AlexMesser "
      },
      {
        "user": "gerwinbrunner",
        "created_at": "2019-09-02T09:11:18Z",
        "body": "Is anybody looking into this? Is there a way that we could get this done?"
      },
      {
        "user": "imnotjames",
        "created_at": "2020-10-07T04:39:04Z",
        "body": "> Is anybody looking into this? Is there a way that we could get this done?\r\n\r\nWe're always accepting pull requests :)"
      },
      {
        "user": "imnotjames",
        "created_at": "2020-10-13T18:04:36Z",
        "body": "duplicate of #1316"
      }
    ]
  },
  {
    "number": 4535,
    "title": "How to orderBy custom field on mysql",
    "created_at": "2019-08-03T10:04:50Z",
    "closed_at": "2019-09-02T15:10:51Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/4535",
    "body": "**Issue type:**\r\n\r\n[ x] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ x] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[ ] `cockroachdb`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[x ] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nI want order by custom sequence，how?\r\nLike this sql \r\nSELECT * FROM table ORDER BY FIELD(status,'offline','available','busy','distance')\r\n\r\n\r\n\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/4535/comments",
    "author": "moosoul",
    "comments": [
      {
        "user": "johannesschobel",
        "created_at": "2019-08-08T14:17:47Z",
        "body": "I think, i dont get your question.. Do you want to order the result by `status, distance`. However, the field `status` has 3 different options (i.e., `offline, available, busy`)?\r\n\r\nyou are looking for a query like\r\n```sql\r\nSELECT * FROM table WHERE ... ORDER BY status, distance\r\n```\r\n\r\nThis returns the results ordered by `status` first and then ordered by `distance`. However, the status values are ordered `available`, `busy`, `offline` (ascending).\r\n\r\nIf you would like to have a completely custom order, i would suggest to add a `sortOrder` field and order by this field.. "
      },
      {
        "user": "Kononnable",
        "created_at": "2019-09-02T15:10:51Z",
        "body": "Closing as no response from the author."
      },
      {
        "user": "xingqiwu55555",
        "created_at": "2020-04-06T13:16:22Z",
        "body": "I met a same issue."
      }
    ]
  },
  {
    "number": 4516,
    "title": "Failed to parse: filter...",
    "created_at": "2019-07-31T08:01:53Z",
    "closed_at": "2019-08-31T16:18:59Z",
    "labels": [
      "question",
      "driver: mongodb"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/4516",
    "body": "**Issue type:**\r\n\r\n[ ] question\r\n[x] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[x] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[ ] `cockroachdb`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[ ] `latest`\r\n[ ] `@next`\r\n[x] `0.2.18`\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\n```ts\r\n// my-migration.ts\r\npublic async down(queryRunner: QueryRunner): Promise<any> {\r\n    const usersRepository = queryRunner.connection.getMongoRepository(User);\r\n    \r\n    const entities = await usersRepository.find({\r\n        where: [\r\n            { email: 'admin@example.com' },\r\n            { email: 'manager@example.com' }\r\n        ]\r\n    });\r\n   await usersRepository.remove(entities);\r\n}\r\n```\r\n\r\nI get an error with conditions: `.find({ where: [...] })`. \r\n```\r\n// Error\r\n{ MongoError: Failed to parse: filter: [ { email: \"admin@example.com\" }, { email: \"manager@example.com\" } ]. 'filter' field must be of BSON type object.\r\n    at Connection.<anonymous> (/Users/kravchyshyn/Projects/chill-chicago/api/node_modules/mongodb/lib/core/connection/pool.js:466:61)\r\n    at Connection.emit (events.js:198:13)\r\n    at Connection.EventEmitter.emit (domain.js:448:20)\r\n    at processMessage (/Users/kravchyshyn/Projects/chill-chicago/api/node_modules/mongodb/lib/core/connection/connection.js:364:10)\r\n    at Socket.<anonymous> (/Users/kravchyshyn/Projects/chill-chicago/api/node_modules/mongodb/lib/core/connection/connection.js:533:15)\r\n    at Socket.emit (events.js:198:13)\r\n    at Socket.EventEmitter.emit (domain.js:448:20)\r\n    at addChunk (_stream_readable.js:288:12)\r\n    at readableAddChunk (_stream_readable.js:269:11)\r\n    at Socket.Readable.push (_stream_readable.js:224:10)\r\n  ok: 0,\r\n  errmsg:\r\n   'Failed to parse: filter: [ { email: \"admin@example.com\" }, { email: \"manager@example.com\" } ]. \\'filter\\' field must be of BSON type object.',\r\n  code: 9,\r\n  codeName: 'FailedToParse',\r\n  name: 'MongoError',\r\n  [Symbol(mongoErrorContextSymbol)]: {} }\r\n```\r\nHow can I resolve it?\r\n\r\n\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/4516/comments",
    "author": "freevital",
    "comments": [
      {
        "user": "rustamwin",
        "created_at": "2019-07-31T08:12:39Z",
        "body": "Use object condition.\r\n```javascript\r\nconst entities = await usersRepository.find({\r\n        where: {\r\n            ....\r\n        }\r\n    });\r\n```"
      },
      {
        "user": "freevital",
        "created_at": "2019-07-31T11:25:01Z",
        "body": "> Use object condition.\r\n> \r\n> ```js\r\n> const entities = await usersRepository.find({\r\n>         where: {\r\n>             ....\r\n>         }\r\n>     });\r\n> ```\r\n\r\nI need to use `OR` condition as { where: [condition1, condition2] }"
      },
      {
        "user": "rustamwin",
        "created_at": "2019-07-31T11:41:22Z",
        "body": "> I need to use OR condition as { where: [condition1, condition2] }\r\n\r\nTry this\r\n```javascript\r\nconst entities = await usersRepository.find({\r\n        where: {\r\n            $or: [condition1, condition2]\r\n        }\r\n    });\r\n```"
      },
      {
        "user": "Yassine-Ezzedini",
        "created_at": "2021-09-01T17:58:17Z",
        "body": "this gives me trust issues, can someone explain why did this error appear ? i had the exact same one, i solved it by using $or, but i wanna understand why ?"
      }
    ]
  },
  {
    "number": 4507,
    "title": "Why is only QueryFailError exported?  It would be nice to export all the errors.",
    "created_at": "2019-07-30T04:18:34Z",
    "closed_at": "2020-10-01T05:27:16Z",
    "labels": [
      "question",
      "can be closed?"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/4507",
    "body": "**Issue type:**\r\n\r\n[X] question\r\n[ ] bug report\r\n[X] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[X] `postgres`\r\n[ ] `cockroachdb`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[X] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\nI'm using custom repositories and I'm wondering if it would be possible to export all the specific errors.  For example, if a bad relation value is passed in, it would be nice to check that it is a FindRelationsNotFoundError (not currently exported) and I could throw my own custom error with an appropriate message.\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/4507/comments",
    "author": "kedarmoghe",
    "comments": [
      {
        "user": "mgbarnech",
        "created_at": "2019-08-13T07:29:08Z",
        "body": "+1\r\nIn my case, I need to show a custom error when someone tries to sort by a column that does not exist.\r\nAt the moment a normal error is being thrown."
      },
      {
        "user": "Kononnable",
        "created_at": "2019-09-02T14:46:31Z",
        "body": "Error is exported, but not directly from index file. You can just use:\r\n```typescript\r\nimport {FindRelationsNotFoundError} from \"typeorm/src/error/FindRelationsNotFoundError\"\r\n```"
      }
    ]
  },
  {
    "number": 4506,
    "title": "Is TypeORM for MongoDB Production Ready?",
    "created_at": "2019-07-30T00:08:00Z",
    "closed_at": "2020-10-04T02:50:15Z",
    "labels": [
      "question",
      "driver: mongodb"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/4506",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[x] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[ ] `cockroachdb`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\nI am planning to use TypeORM for Mongodb in my next project. I've been playing around with TypeORM and MongoDB and I noticed there are many things that doesn't work. Examples,\r\n1) @Column({select:false})\r\n2) @Column({default:___})\r\n3) OneToOne, OneToMany, ManyToOne and ManyToMany\r\n4) createQueryBuilder or Aggregate\r\n\r\nDo you guys recommend to use typeORM and MongoDB for real world application?\r\n\r\nPlease advice.\r\n\r\n<!--\r\n    To answer those questions you need to put \"x\" inside the square brackets, for example:\r\n    [x] `mysql`\r\n    [ ] `postgres`\r\n\r\n    Also, please format your code properly (by taking code blocks into ```ts .... ```)\r\n!>",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/4506/comments",
    "author": "imomin",
    "comments": [
      {
        "user": "Binaryify",
        "created_at": "2020-02-28T06:41:39Z",
        "body": "mongodb's support is bad"
      },
      {
        "user": "imnotjames",
        "created_at": "2020-10-04T02:50:15Z",
        "body": "If specific features don't work as expected, PRs are definitely accepted!  There are definitely projects using TypeORM and mongoDB in production."
      }
    ]
  },
  {
    "number": 4437,
    "title": "BeforeInsert without decorator (in javascript)",
    "created_at": "2019-07-15T09:57:06Z",
    "closed_at": "2020-10-05T05:53:46Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/4437",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[ ] `cockroachdb`\r\n[x] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nI use typeorm with javascript and with entity schema separated.\r\n\r\nIs it possible to call BeforeInsert and AfterLoad function without decorator inside a model class?\r\n\r\nThanks\r\nChiara\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/4437/comments",
    "author": "chiaraperino",
    "comments": [
      {
        "user": "Kononnable",
        "created_at": "2019-08-31T14:36:56Z",
        "body": "Yes, it should be possible, but it  might be easier to use subscribers instead - they provide similar functionality while not require using of decorators(if memory serves correctly)."
      },
      {
        "user": "mrtnzagustin",
        "created_at": "2020-02-17T20:58:17Z",
        "body": "@chiaraperino are you using migrations with the cli? i cant make it work"
      },
      {
        "user": "imnotjames",
        "created_at": "2020-10-05T05:53:46Z",
        "body": "The listeners aren't really accomplished using entity schema but subscribers should do what you need.  As the questions been answered I'm gonna close this out."
      }
    ]
  },
  {
    "number": 4434,
    "title": "Deep relation returns an array",
    "created_at": "2019-07-14T15:45:04Z",
    "closed_at": "2019-09-14T01:56:59Z",
    "labels": [
      "question",
      "needs more info"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/4434",
    "body": "**Issue type:**\r\n\r\n[x ] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[x] `postgres`\r\n[ ] `cockroachdb`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[ ] `latest`\r\n[ ] `@next`\r\n[x] `0.2.16` (or put your version here)\r\n\r\nI need to find an entity (named Case) that has two nested relations (createdBy: employee and employee: Organization). I use deep relations like `['createdBy',  'createdBy.organization]`. It works fine but shows Organization entity inside an array [Organization]. Here is an simplified example:\r\n\r\n```\r\n  Case {\r\n    hash: 'jy31jw3eiydavjbyqvkqgpaleb',\r\n    created_at: 2019-07-14T14:15:23.452Z,\r\n    last_updated: 2019-07-14T14:15:23.452Z,\r\n    createdBy:\r\n     Employees {\r\n       hash_id: 'jy31iphnaindfaiavinj5euv8dhrgrj',\r\n       created_at: 2019-07-14T14:14:28.345Z,\r\n       last_updated: 2019-07-14T14:14:28.345Z,\r\n       organization: [Organizations] } } ]\r\n}\r\n```\r\ncan someone please explain what I'm doing wrong?\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/4434/comments",
    "author": "javid-abd",
    "comments": [
      {
        "user": "Kononnable",
        "created_at": "2019-08-31T14:39:47Z",
        "body": "Please pate your entity definitions. Without them we have no idea how you have declared them(relation might be oneToMany etc.)"
      },
      {
        "user": "javid-abd",
        "created_at": "2019-09-14T01:56:59Z",
        "body": "Thanks for the response. As we no longer use TypeORM, I'm going to close the issue"
      }
    ]
  },
  {
    "number": 4426,
    "title": "UpdateResult is always empty ",
    "created_at": "2019-07-12T01:58:19Z",
    "closed_at": "2020-10-17T08:36:18Z",
    "labels": [
      "question",
      "comp: query builder",
      "driver: sqlite"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/4426",
    "body": "**Issue type:**\r\n\r\n[ x] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[ ] `cockroachdb`\r\n[ x] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[x ] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\ndev environment :  win10(or win7) , node 10\r\n\r\nwhen i call the update function of any Repository ,\r\nthe return value UpdateResult is always two empty array,\r\nwhether or not the update query is succeed\r\n\r\n{\r\n  \"generatedMaps\": [],\r\n  \"raw\": []\r\n}\r\n\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/4426/comments",
    "author": "lianall",
    "comments": [
      {
        "user": "chandrucrm",
        "created_at": "2019-09-04T07:32:48Z",
        "body": "Any resolution for this.\r\nI have tried with repository update and querybuilder update.\r\nboth of them update the table but response is always \r\n{\r\n\"generatedMaps\": [],\r\n\"raw\": []\r\n}"
      },
      {
        "user": "ksvirsky",
        "created_at": "2019-10-09T13:28:43Z",
        "body": "The same issue for TypeORM+postgres."
      },
      {
        "user": "balintsteinbach",
        "created_at": "2020-07-16T08:27:47Z",
        "body": "Same issue here.\r\n\r\n- Sqlite db\r\n- typeorm 0.2.22\r\n\r\nadvance(dashbordToUpdate: Dashboard, regressStatuses: string[]): Promise<UpdateResult> {\r\n    return this.createQueryBuilder()\r\n      .update(Dashboard)\r\n      .set(dashbordToUpdate)\r\n      .where(...)\r\n      .execute();\r\n  }\r\n\r\nThe result is always:\r\n UpdateResult { generatedMaps: [], raw: [] }"
      },
      {
        "user": "imnotjames",
        "created_at": "2020-10-17T08:36:18Z",
        "body": "Duplicate of #2415"
      }
    ]
  },
  {
    "number": 4396,
    "title": "Finding entity with with relation condition",
    "created_at": "2019-07-05T07:15:34Z",
    "closed_at": "2021-06-23T18:14:01Z",
    "labels": [
      "question",
      "driver: mysql",
      "driver: mariadb"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/4396",
    "body": "**Issue type:**\r\n\r\n[ X] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ X] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[ ] `cockroachdb`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[X ] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\nHello,\r\n\r\nIs it possible to query an entity by placing a condition on one of its join columns?\r\n\r\nFor example, let's say I have the user entity that is in relation to the photos entity. (one-to-many relationship)\r\n\r\nWhy can't I use the following find configuration to filter the photos based an owning user's property. ?\r\n\r\nEg. I want all the photos for the users that have the firstName='Dan'\r\n\r\n```Javascript\r\nlet photos = await photosRepo.find({\r\n  where: {\r\n      user: {\r\n          firstName: 'Dan'\r\n      }\r\n  }\r\n})\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/4396/comments",
    "author": "pxr64",
    "comments": [
      {
        "user": "Kononnable",
        "created_at": "2019-08-31T12:29:22Z",
        "body": "I guess you're looking for `relations` in find options parameters."
      },
      {
        "user": "anthonyjlmorel",
        "created_at": "2019-09-10T08:39:11Z",
        "body": "Hi guys, what's the status on this ?\r\n\r\nI would like to be able to request entities placing where condition on joined relations too which seems either missing or undocumented.\r\n\r\nCould you advise on this ?"
      },
      {
        "user": "march08",
        "created_at": "2019-09-26T09:03:10Z",
        "body": "Same issue here. Anyone knows how to perform such a find? \r\n\r\nTo give a better example\r\n ```\r\nCar { id, user }\r\nUser { id, company }\r\nCompany { id }\r\n\r\n// I want to find cars with specific company ID\r\n// something like this, but it's not working\r\n\r\nlet carsOfCompany = await getRepository(Car).find({\r\n  relations: ['user'],\r\n  where: {\r\n      user: {\r\n          companyId: 'someid'\r\n      }\r\n  }\r\n})\r\n```"
      },
      {
        "user": "JunquerGJ",
        "created_at": "2019-10-29T15:37:11Z",
        "body": "@march08 \r\nI cannot check it right now, but maybe this works for you:\r\n\r\n`let carsOfCompany = await getRepository(Car).find({\r\n    join: {\r\n        alias: \"car\",\r\n        leftJoinAndSelect: {\r\n            company: \"car.company\"\r\n        }\r\n    }, where : { company : { id : 'someid'}}\r\n})`\r\n\r\n"
      },
      {
        "user": "ilovett",
        "created_at": "2019-12-04T18:46:59Z",
        "body": "The relation where only seems to work on `id` or perhaps primary columns,\r\n\r\nEG if your Car has `user` with `JoinColumn()` you could successfully query on `where: { user: { id: 123 } }` however it doesnt seem to work for non primary columns or joins such as the user's `companyId`"
      },
      {
        "user": "ilovett",
        "created_at": "2019-12-04T18:47:51Z",
        "body": "I found it unexpected that the orm was not able to consider that relational query"
      },
      {
        "user": "ilovett",
        "created_at": "2019-12-04T18:49:35Z",
        "body": "In my query I tried to `find` where `{ user: { mongoId: \"xxx\" } }` but my `Thing.find({ where: { user: { mongoId: \"xxx\" } })` yielded:\r\n\r\n```\r\nWHERE \"Thing\".\"user_id\" = $1 -- PARAMETERS: [null]\r\n```\r\n\r\nI am guessing because my `Thing.user` `@JoinColumn` is `id` and not `mongoId`"
      },
      {
        "user": "alpharder",
        "created_at": "2019-12-16T21:35:03Z",
        "body": "There's a workaround for filtering based on relation fields for `findOne()`/`find()` methods that I've discovered recently. The problem with filtering related table fields only exists for `ObjectLiteral`-style `where`, while string conditions work perfectly. \r\n\r\nAssume that we have two entities – `User` and `Role`, user belongs to one role, role has many users:\r\n\r\n```typescript\r\n@Entity()\r\nexport class User {\r\n  name: string;\r\n\r\n  @ManyToOne(() => Role, role => role.users)\r\n  role: Role;\r\n}\r\n\r\n@Entity()\r\nexport class Role {\r\n  @OneToMany(() => User, user => user.role)\r\n  users: User[];\r\n}\r\n```\r\n\r\nNow we can call `findOne()`/`find()` methods of `EntityManager` or repository:\r\n\r\n```typescript\r\nroleRepository.find({\r\n  join: { alias: 'roles', innerJoin: { users: 'roles.users' } },\r\n  where: qb => {\r\n    qb.where({ // Filter Role fields\r\n      a: 1,\r\n      b: 2\r\n    }).andWhere('users.name = :userName', { userName: 'John Doe' }); // Filter related field\r\n  }\r\n});\r\n```\r\n\r\nYou can omit the `join` part if you've marked your relation as an eager one."
      },
      {
        "user": "darylcecile",
        "created_at": "2020-03-22T21:08:30Z",
        "body": "> The relation where only seems to work on `id` or perhaps primary columns,\r\n> \r\n> EG if your Car has `user` with `JoinColumn()` you could successfully query on `where: { user: { id: 123 } }` however it doesnt seem to work for non primary columns or joins such as the user's `companyId`\r\n\r\nHonestly, this should stated in docs somewhere - saved me hours!\r\n\r\nThank you"
      },
      {
        "user": "ghost",
        "created_at": "2020-03-27T10:35:40Z",
        "body": "@alpharder I used the same code removed the join part, as I've marked relation as eager, but getting an error\r\n\r\n> [error]: ER_BAD_FIELD_ERROR: Unknown column ''users.name' in 'where clause'  QueryFailedError: ER_BAD_FIELD_ERROR: Unknown column ''users.name' in 'where clause'\r\n\r\n`roleRepository.find({\r\n  where: qb => {\r\n    qb.where({ // Filter Role fields\r\n      a: 1,\r\n      b: 2\r\n    }).andWhere('users.name = :userName', { userName: 'John Doe' }); // Filter related field\r\n  }\r\n});`\r\n\r\nWhat am I missing here?"
      },
      {
        "user": "kop7",
        "created_at": "2020-04-16T10:44:03Z",
        "body": "find cars where model location is 2\r\n\r\n```ts\r\nCar {id, name, model(ManyToOne->model)}\r\nModel{id, name, location(MaynToOne->location), cars(OneToMany->cars)}\r\nLocation{id, name, models(OneToMany->models)}\r\n\r\ncarRepository.find({\r\n            relations: ['model','model.location'],\r\n            where: {\r\n                'model.location': { id: 2},\r\n            },\r\n        });\r\n```\r\n\r\n~~~sql\r\nSELECT\r\n       `Car`.`id` AS `Car_id`,\r\n       `Car`.`title` AS `Car_title`,\r\n       `Car`.`modelId` AS `Car_modelId`,\r\n       `Car__model`.`id` AS `Car__model_id`,\r\n       `Car__model`.`name` AS `Car__model_name`,\r\n       `Car__model`.`locationId` AS `Car__model_locationId`,\r\n       `Car__model__location`.`id` AS `Car__model__location_id`\r\n    FROM `job` `Car` LEFT JOIN `model` `Car__model` ON `Car__model`.`id`=`Car`.`modelId`\r\n    LEFT JOIN `location` `Car__model__location` ON `Car__model__location`.`id`=`Car__model`.`locationId`\r\n~~~~\r\n\r\nbut miss locationId parameter?...\r\nwhat am I doing wrong?\r\n"
      },
      {
        "user": "fchu",
        "created_at": "2020-04-24T03:35:59Z",
        "body": "I found the same issue, but for postgres...\r\nSeems like the find method signatures could be more strict, so that all the different variants don't get mingled without clear error handling"
      },
      {
        "user": "david-macharia",
        "created_at": "2020-05-06T22:19:30Z",
        "body": "@Cop\r\n\r\n> find cars where model location is 2\r\n> \r\n> ```ts\r\n> Car {id, name, model(ManyToOne->model)}\r\n> Model{id, name, location(MaynToOne->location), cars(OneToMany->cars)}\r\n> Location{id, name, models(OneToMany->models)}\r\n> \r\n> carRepository.find({\r\n>             relations: ['model','model.location'],\r\n>             where: {\r\n>                 'model.location': { id: 2},\r\n>             },\r\n>         });\r\n> ```\r\n> \r\n> ```sql\r\n> SELECT\r\n>        `Car`.`id` AS `Car_id`,\r\n>        `Car`.`title` AS `Car_title`,\r\n>        `Car`.`modelId` AS `Car_modelId`,\r\n>        `Car__model`.`id` AS `Car__model_id`,\r\n>        `Car__model`.`name` AS `Car__model_name`,\r\n>        `Car__model`.`locationId` AS `Car__model_locationId`,\r\n>        `Car__model__location`.`id` AS `Car__model__location_id`\r\n>     FROM `job` `Car` LEFT JOIN `model` `Car__model` ON `Car__model`.`id`=`Car`.`modelId`\r\n>     LEFT JOIN `location` `Car__model__location` ON `Car__model__location`.`id`=`Car__model`.`locationId`\r\n> ```\r\n> \r\n> but miss locationId parameter?...\r\n> what am I doing wrong?\r\n\r\nDid you find out why where is ignored?"
      },
      {
        "user": "grigdevelop",
        "created_at": "2020-05-17T16:27:38Z",
        "body": "You can also get entities with all relations.\r\n```\r\n     const repo = manager.getRepository(entityType);\r\n     const relations = repo.metadata.relations.map(m => m.propertyName);\r\n     const entities = await repo.find({ relations });\r\n```"
      },
      {
        "user": "alexander-kiriliuk",
        "created_at": "2020-05-20T09:41:38Z",
        "body": "> You can also get entities with all relations.\r\n> \r\n> ```\r\n>      const repo = manager.getRepository(entityType);\r\n>      const relations = repo.metadata.relations.map(m => m.propertyName);\r\n>      const entities = await repo.find({ relations });\r\n> ```\r\n\r\nThis will return the first level relations, but not return nested relations"
      },
      {
        "user": "niccolofanton",
        "created_at": "2020-07-30T09:10:48Z",
        "body": "I was having the same issue with eager relations, thanks to @alpharder for the workaround.\r\nIn case of eager relations you have to use this syntax: \r\n\r\n```\r\nconst results= await this.genericEntityRepository.find({\r\n    where: (qb: SelectQueryBuilder<genericEntity>) => {\r\n        qb.where('GenericEntity_relationName.relationProperty= :value', { value: ... })\r\n    }\r\n});\r\n```\r\n\r\nreal example: \r\n\r\n```\r\n@Entity()\r\nexport class ConditionKaizenStatus extends BaseEntity {\r\n    @PrimaryGeneratedColumn()\r\n    id: number;\r\n\r\n    @Type(() => Status)\r\n    @ManyToOne(() => Status, { eager: true })\r\n    @JoinColumn({ name: 'from_status_id' })\r\n    statusFrom: Status;\r\n\r\n    @Type(() => Status)\r\n    @ManyToOne(() => Status, { eager: true })\r\n    @JoinColumn({ name: 'to_status_id' })\r\n    statusTo: Status;\r\n\r\n    @Type(() => KaizenType)\r\n    @ManyToOne(() => KaizenType, { eager: true })\r\n    @JoinColumn({ name: 'kaizen_type_id' })\r\n    kaizenType: KaizenType;\r\n\r\n    @Column('varchar', { default: CONDITION_OPERATOR_AND })\r\n    operator: ConditionOperator;\r\n\r\n    @ManyToMany(type => KaizenField, { eager: true })\r\n    @JoinTable({ name: 'conditions-fields'})\r\n    kaizenFields: KaizenField[];\r\n}\r\n```\r\nUse case in action\r\n\r\n```\r\nconst mandatoryFields2 = await this.conditionRepository.find({\r\n    where: (qb: SelectQueryBuilder<ConditionKaizenStatus>) => {\r\n        qb\r\n            .where('ConditionKaizenStatus_statusTo.code = :statusCode', { statusCode: STATUS_CODES.INSERTED })\r\n            .andWhere('ConditionKaizenStatus_kaizenType.code = :typeCode', { typeCode: ACTIVITY_KAIZEN_TYPE })\r\n    }\r\n});\r\n```\r\n\r\nHope this can help! Have a nice day :)\r\n\r\n\r\n\r\n"
      },
      {
        "user": "pvoisin",
        "created_at": "2020-08-26T21:33:52Z",
        "body": "> The relation where only seems to work on `id` or perhaps primary columns,\r\n> \r\n> EG if your Car has `user` with `JoinColumn()` you could successfully query on `where: { user: { id: 123 } }` however it doesn't seem to work for non primary columns or joins such as the user's `companyId`\r\n\r\nHow sad! I just confirmed that too (I'm not using annotations but the results are the same). Searching with something like the following doesn't work whilst using \"branchId\" (primary key) instead of \"languageId\" does work:\r\n```\r\nwhere: {\r\n  name: {\r\n    languageId: 7,\r\n  },\r\n}\r\n```\r\n\r\n@niccolofanton - thanks for the snippet! It does the trick but, to me, having to rely on somewhat raw SQL defeats the ORM purpose a little...\r\n"
      },
      {
        "user": "BenSjoberg",
        "created_at": "2020-11-02T20:07:56Z",
        "body": "Seems related to #2707"
      },
      {
        "user": "nelsonsvo",
        "created_at": "2021-04-21T20:22:24Z",
        "body": "has finding an entity with relation condition been implemented?\r\nI think this is a necessity for an ORM"
      },
      {
        "user": "pradeep0601",
        "created_at": "2021-04-26T06:33:13Z",
        "body": "Eagerly waiting for this feature to search based on relation fields other than the primary key."
      },
      {
        "user": "jeffersonlicet",
        "created_at": "2021-05-15T00:51:40Z",
        "body": "Hi, is anyone working on this? I can take this issue and try to send a pull request."
      },
      {
        "user": "MardariG",
        "created_at": "2021-06-14T12:43:59Z",
        "body": "> Hi, is anyone working on this? I can take this issue and try to send a pull request.\r\n\r\nany status here?"
      },
      {
        "user": "jeffersonlicet",
        "created_at": "2021-06-14T13:52:13Z",
        "body": "> > Hi, is anyone working on this? I can take this issue and try to send a pull request.\r\n> \r\n> any status here?\r\n\r\nBy default only JoinColumns are used (id) I'm trying to include relation cols in a non-intrusive way."
      },
      {
        "user": "Goldziher",
        "created_at": "2021-06-17T07:24:16Z",
        "body": "wow this is a bad bug"
      },
      {
        "user": "jeffersonlicet",
        "created_at": "2021-06-17T13:23:55Z",
        "body": "I'll adventure myself and send a non-optimized pull request so I can get feedback about a better way to do this. But seems like it's working now."
      },
      {
        "user": "salvationarinze",
        "created_at": "2021-06-23T16:01:54Z",
        "body": "Any solution to this yet?"
      },
      {
        "user": "imnotjames",
        "created_at": "2021-06-23T18:13:58Z",
        "body": "This is directly related to #2707.  If that gets fixed, this does."
      }
    ]
  },
  {
    "number": 4393,
    "title": "Is there a way to execute WHERE (column1, column2) IN ( (vala, valb), (valc, vald) ) without using a Raw query?",
    "created_at": "2019-07-04T17:26:20Z",
    "closed_at": "2019-08-31T12:54:52Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/4393",
    "body": "**Issue type:**\r\n\r\n[ X] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ X] `postgres`\r\n[ ] `cockroachdb`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[ ] `latest`\r\n[ ] `@next`\r\n[0.2.11 ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nI want to execute this query\r\n\r\n```sql\r\nselect distinct on (\"lastName\") * from dogs where (\"firstName\", \"lastName\") in (('Mark','Chen'), ('Coco', 'Seth'));\r\n```\r\nI currently got it to this point\r\n\r\n```ts\r\n    return this.dogRepository.createQueryBuilder(\"dog\")\r\n    .select(\"DISTINCT ON (dog.lastName) *\")\r\n    .where(\"(dog.firstName, dog.lastName) IN (:...array)\", { array })\r\n    .getMany();\r\n```\r\n\r\nWhere `array` is a array with nested array of strings, in pairs:\r\n\r\n`[ [ 'Mark', 'Chen'], [ 'Coco', 'Set' ] ]`\r\n\r\nAnd I get the following error\r\n\r\n` input of anonymous composite types is not implemented`\r\n\r\nI assume I'm just doing it wrong. What is the proper way to achieve this? Or is it truly not implemented?",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/4393/comments",
    "author": "avilesj",
    "comments": [
      {
        "user": "haschu",
        "created_at": "2019-07-04T20:50:32Z",
        "body": "You could do:\r\n\r\n```ts\r\nconst array = [['Mark', 'Chen'], ['Coco', 'Set']];\r\n\r\nconst firstNames = array.map(name => name[0]);\r\nconst lastNames = array.map(name => name[1]);\r\n\r\n//...\r\n.where('dog.firstName IN (:...firstNames) AND dog.lastName IN (:...lastNames)', {\r\n  firstNames,\r\n  lastNames\r\n});\r\n```"
      },
      {
        "user": "FelipeTaiarol",
        "created_at": "2019-07-17T19:08:57Z",
        "body": "You can do it like this, for example:\r\n\r\n```typescript\r\nconst subQuery = qb.subQuery()\r\n\t\t.select('assignment.projectId, assignment.taskId')\r\n\t\t.from(TaskAssignment, 'assignment')\r\n\t\t.where('assignment.userId IN (:...assignedToIds)', {assignedToIds});\r\n\r\nqb.andWhere(`(task.projectId, task.taskId) IN ${subQuery.getQuery()}`);\r\n```"
      }
    ]
  },
  {
    "number": 4363,
    "title": "Method save does not return an instance of the entity class",
    "created_at": "2019-06-26T22:07:39Z",
    "closed_at": "2019-08-31T15:42:41Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/4363",
    "body": "**Issue type:**\r\n\r\n[x ] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ x] `postgres`\r\n[ ] `cockroachdb`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[x ] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\nWith an entity like:\r\n\r\n```ts\r\nimport { Exclude } from 'class-transformer';\r\n\r\n@Entity()\r\nexport class Tenant {\r\n  @PrimaryGeneratedColumn('uuid')\r\n  id!: string;\r\n\r\n  @Exclude() // from class-transformer\r\n  @Column()\r\n  name!: string;\r\n}\r\n```\r\n\r\nCalling `.save({ name: 'foobar' })` returns a plain object instead of an instance of `Tenant` class. Due to which: decorators from `class-transformer` package do not run. Is there a work around to this? or am I forced to call `.create()` first?\r\n\r\n<!--\r\n    To answer those questions you need to put \"x\" inside the square brackets, for example:\r\n    [x] `mysql`\r\n    [ ] `postgres`\r\n\r\n    Also, please format your code properly (by taking code blocks into ```ts .... ```)\r\n!>\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/4363/comments",
    "author": "affanshahid",
    "comments": [
      {
        "user": "ajxs",
        "created_at": "2019-06-27T04:23:33Z",
        "body": "Does this work as intended if you instantiate the object using its constructor?"
      },
      {
        "user": "quezak",
        "created_at": "2019-07-24T15:46:52Z",
        "body": "I just found this issue because I thought one of my repositories returned plain objects, where all the others usually returned class instances on `save()`. Turns out that in all other places I indeed called `create()` before `save()`. It looks like `save` returns an entity instance when it was given an entity instance, and a plain object when it's given a plain object."
      },
      {
        "user": "Kononnable",
        "created_at": "2019-08-31T15:42:41Z",
        "body": "Closing as no response from the author."
      },
      {
        "user": "viktornord",
        "created_at": "2022-01-31T12:37:02Z",
        "body": "@Kononnable  why it does not return the entity instance by default?"
      },
      {
        "user": "kn0ll",
        "created_at": "2022-05-24T14:50:19Z",
        "body": "my biggest issue with this is that the types are incorrectly reported. so:\r\n\r\n```\r\nconst foo = await repository.save({ bin: \"bar\" })\r\n```\r\n\r\nthis reports `foo` as having an entity instance type (including instance properties and methods). but instance properties and methods will actually not be available on `foo`."
      }
    ]
  },
  {
    "number": 4353,
    "title": "How to update Tree with closure table?",
    "created_at": "2019-06-24T20:09:12Z",
    "closed_at": "2021-05-18T21:47:26Z",
    "labels": [
      "question",
      "comp: tree tables",
      "driver: postgres"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/4353",
    "body": "**Issue type:**\r\n\r\n[ X] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[X ] `postgres`\r\n[ ] `cockroachdb`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[ X] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\n<!--\r\n    To answer those questions you need to put \"x\" inside the square brackets, for example:\r\n    [x] `mysql`\r\n    [ ] `postgres`\r\n\r\n    Also, please format your code properly (by taking code blocks into ```ts .... ```)\r\n!>\r\n\r\nHi,\r\n\r\nHas anyone figured out how to update a tree stored in closure table?\r\n\r\nI followed the example given in the documentation but there seems to be no obvious way to update a node or for example move a child node to another parent.\r\n\r\nIs this implemented or not?\r\n\r\nI have tried to delete the category from the category table and the categories_closure table in order to re-insert it with a different parent.  try to delete it like this\r\n\r\n```\r\n    await getManager()\r\n      .createQueryBuilder()\r\n      .delete()\r\n      .from('categories_closure')             \r\n      .where('\"id_ancestor\" = :id', { id })\r\n      .execute();\r\n    \r\n    await this.repo.delete(id);\r\n\r\n```\r\n\r\nwhich reasonably produces error:\r\n\r\n```\r\nerror: update or delete on table \"categories\" violates foreign key constraint \"FK_51fff5114cc41723e8ca36cf227\" on table \"categories_closure\"\r\n```\r\n\r\nThank you.\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/4353/comments",
    "author": "YannisMarios",
    "comments": [
      {
        "user": "YannisMarios",
        "created_at": "2019-06-24T20:16:06Z",
        "body": "Hi I am trying to update a tree stored in a closure table.\r\n\r\nWhat I am trying to do (since in the documentation there is no obvious way to achieve this) is to delete the category from the categories table and the closure table and then re-create it.\r\n\r\nI am trying to delete like this: \r\n\r\n```\r\n   let res = await this.repo.findOne(id);\r\n     \r\n    await getManager()\r\n      .createQueryBuilder()\r\n      .delete()\r\n      .from('categories_closure')             \r\n      .where('\"id_ancestor\" = :id', { id })\r\n      .execute();\r\n    \r\n    await this.repo.delete(id);\r\n```\r\n\r\nwhich reasonably produces error:\r\n\r\n```\r\nerror: update or delete on table \"categories\" violates foreign key constraint \"FK_51fff5114cc41723e8ca36cf227\" on table \"categories_closure\"\r\n```\r\n\r\nHas anyone managed to update a tree stored in a closure table?\r\n\r\nThank you."
      },
      {
        "user": "imnotjames",
        "created_at": "2020-10-04T02:26:43Z",
        "body": "What is a closure table?"
      },
      {
        "user": "abbbel2",
        "created_at": "2020-11-20T07:03:56Z",
        "body": "I have this problem too, anybody got a work around for this?"
      }
    ]
  },
  {
    "number": 4341,
    "title": "Error during migration generation: { DriverPackageNotInstalledError: React-Native package has not been found installed. Try to install it: npm install react-native-sqlite-storage --save",
    "created_at": "2019-06-21T16:34:22Z",
    "closed_at": "2020-10-03T05:00:01Z",
    "labels": [
      "question",
      "can be closed?"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/4341",
    "body": "**Issue type:**\r\n\r\n[ ] question\r\n[ x] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[ ] `cockroachdb`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[x ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[x ] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\n1. Create a new TypeORM project using `typeorm init`\r\n2. Install react-native-sqlite-storage\r\n3. Change the `ormconfig.json` to use react-native\r\n4. Try to run `typeorm migration:generate -n Test`\r\n5. Get an error:  \r\n\r\n```{ DriverPackageNotInstalledError: React-Native package has not been found installed. Try to install it: npm install react-native-sqlite-storage --save\r\n    at new DriverPackageNotInstalledError (/usr/local/lib/node_modules/typeorm/error/DriverPackageNotInstalledError.js:10:28)\r\n    at ReactNativeDriver.loadDependencies (/usr/local/lib/node_modules/typeorm/driver/react-native/ReactNativeDriver.js:87:19)\r\n```\r\n\r\nI modified the source of ReactNativeDriver.js to print out the original error, and it shows this:\r\n\r\n```\r\n{ Error: Cannot find module 'warnOnce'\r\n    at Function.Module._resolveFilename (internal/modules/cjs/loader.js:582:15)\r\n    at Function.Module._load (internal/modules/cjs/loader.js:508:25)\r\n    at Module.require (internal/modules/cjs/loader.js:637:17)\r\n    at require (internal/modules/cjs/helpers.js:22:18)\r\n    at Object.<anonymous> (/usr/local/lib/node_modules/react-native/Libraries/react-native/react-native-implementation.js:14:18)\r\n    at Module._compile (internal/modules/cjs/loader.js:701:30)\r\n    at Object.Module._extensions..js (internal/modules/cjs/loader.js:712:10)\r\n    at Module.load (internal/modules/cjs/loader.js:600:32)\r\n    at tryModuleLoad (internal/modules/cjs/loader.js:539:12)\r\n    at Function.Module._load (internal/modules/cjs/loader.js:531:3) code: 'MODULE_NOT_FOUND' }\r\n```\r\n\r\nI definitely have `react-native-sqlite-storage` installed.  Any pointers?\r\n\r\n\r\n<!--\r\n    To answer those questions you need to put \"x\" inside the square brackets, for example:\r\n    [x] `mysql`\r\n    [ ] `postgres`\r\n\r\n    Also, please format your code properly (by taking code blocks into ```ts .... ```)\r\n!>",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/4341/comments",
    "author": "nthsense",
    "comments": [
      {
        "user": "Kononnable",
        "created_at": "2019-06-22T20:41:36Z",
        "body": "In react-native you're running your code on browser-like environment, right? So you won't be able to use migrations cli - there is simply no access to command line while you're running on mobile device - and without running on that environment you won't be able to connect to your db."
      },
      {
        "user": "nthsense",
        "created_at": "2019-06-24T14:19:46Z",
        "body": "My assumption - correct or not - was that the migrations cli would make its own connection via its own run-time environment, not via my react-native code.  As I understand it, there doesn't need to be a server running in order to connect to the SQLite database, since it's just a file, so the cli tool just needs to know where the file is.\r\n\r\nI guess at minimum, a more helpful error message for this situation would be useful... but it seems like it should be possible to use migrations cli with embedded SQLite."
      },
      {
        "user": "Kononnable",
        "created_at": "2019-08-30T21:56:36Z",
        "body": "Sorry for late response.\r\nYes, it's just a file, but could you point typeorm to this file? I'm not 100% sure about react-native, but in most cases like this db is saved inside a secure storage, which can't be accessed and modified from the outside. So in order to connect to db you have to launch a mobile application(i.e. install and launch apk file for android), but when you run code in a mobile app you are loosing the ability to access files on your desktop machine(phone doesn't have access to files on your PC)."
      }
    ]
  },
  {
    "number": 4334,
    "title": "can not set default value for datetime field inside migration",
    "created_at": "2019-06-21T06:38:49Z",
    "closed_at": "2020-10-14T05:41:21Z",
    "labels": [
      "bug",
      "question",
      "new feature",
      "comp: migrations",
      "driver: mysql",
      "driver: mariadb"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/4334",
    "body": "**Issue type:**\r\n\r\n- [x] question\r\n- [x] bug report\r\n- [x] feature request\r\n- [ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n- [ ] `cordova`\r\n- [ ] `mongodb`\r\n- [ ] `mssql`\r\n- [x] `mysql` / `mariadb`\r\n- [ ] `oracle`\r\n- [ ] `postgres`\r\n- [ ] `cockroachdb`\r\n- [ ] `sqlite`\r\n- [ ] `sqljs`\r\n- [ ] `react-native`\r\n- [ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n- [x] `latest`\r\n- [ ] `@next`\r\n- [ ] `0.x.x` (or put your version here)\r\n\r\n\r\nlet's suppose that I want to add a new datetime column to specific table.\r\n\r\n```javascript\r\n      await queryRunner.addColumn('message', new TableColumn({\r\n        name: 'delivered_at',\r\n        type: 'datetime',\r\n        default: new Date('2018-07-30 12:00:00'),\r\n      }));\r\n```\r\n\r\nI've tried:\r\n`default: new Date('2018-07-30 12:00:00')`\r\n`default: new Date()`\r\n`default: '2018-07-30 12:00:00'`\r\n`default: () => '2018-07-30 12:00:00'`\r\n`default: '() =>  '2018-07-30 12:00:00'`\r\n\r\nnone of them works, the only default value works is `default: 'now()'`\r\n\r\nDoes that means typeorm only support setting current_timestamp as datetime field's default value .",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/4334/comments",
    "author": "shinux",
    "comments": [
      {
        "user": "Kononnable",
        "created_at": "2019-06-22T20:20:48Z",
        "body": "Define 'doesn't work'. You got an error during schema creation, default value isn't set correctly or column is added again on every migration."
      },
      {
        "user": "michaelbromley",
        "created_at": "2019-10-15T14:15:02Z",
        "body": "I might be running into the same thing. In my I am passing a JavaScript `Date` object as the `default`, and the resulting migration line looks like:\r\n\r\n```ts\r\nawait queryRunner.query(\"ALTER TABLE `product` ADD `customFieldsBolly` datetime NULL DEFAULT Wed Jan 01 2020 00:11:00 GMT+0100 (Central European Standard Time)\", \r\n```\r\n\r\nwhich is the result of the `Date.toString()` method.\r\n\r\nThis is using the MySQL driver (MariaDB).\r\n"
      },
      {
        "user": "golubvladimir",
        "created_at": "2020-05-01T07:56:00Z",
        "body": "It works for me.\r\n\r\n```\r\n\t@Column({\r\n\t\ttype: 'datetime',\r\n\t\tdefault: () => 'NOW()'\r\n\t})\r\n\tdateCreate: string;\r\n\r\n\t@Column({\r\n\t\ttype: 'timestamp',\r\n\t\tdefault: () => 'CURRENT_TIMESTAMP'\r\n\t})\r\n\tdateEdit: string;\r\n```"
      },
      {
        "user": "Kaminto",
        "created_at": "2020-05-05T17:32:11Z",
        "body": "this will work just add string `CURRENT_TIMESTAMP` to default property\r\n```\r\nawait queryRunner.addColumn('message', new TableColumn({\r\n        name: 'delivered_at',\r\n        type: 'datetime',\r\n        default: 'CURRENT_TIMESTAMP',\r\n      }));\r\n```"
      },
      {
        "user": "shinux",
        "created_at": "2020-05-06T02:29:04Z",
        "body": "@Kaminto @golubvladimir \r\n\r\n`CURRENT_TIMESTAMP` may work.\r\nBut how you guys achieve non-current default value?\r\n\r\n```\r\nALTER TABLE <TABLE_NAME> \r\nCHANGE COLUMN <COLUMN_NAME> <COLUMN_NAME> DATETIME NOT NULL DEFAULT '2015-05-11 13:01:01';\r\n```"
      },
      {
        "user": "golubvladimir",
        "created_at": "2020-05-06T09:46:47Z",
        "body": "@shinux \r\n```\r\nnew Date().toISOString().slice(0, 19).replace('T', ' ');\r\n```"
      },
      {
        "user": "imnotjames",
        "created_at": "2020-10-14T05:41:21Z",
        "body": "Keep in mind that at this time the default value is not escaped - you'll need to manually handle that yourself."
      }
    ]
  },
  {
    "number": 4258,
    "title": "Prevent nullification of missing related entities",
    "created_at": "2019-06-08T09:25:52Z",
    "closed_at": "2019-06-22T21:52:44Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/4258",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[x] `postgres`\r\n[ ] `cockroachdb`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[ ] `latest`\r\n[ ] `@next`\r\n[x] `0.2.17` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nIn our backend system, we face the problem of editing entities with relations by several clients. Given the following scenario:\r\n\r\n\r\n```@Entity(\"game\")\r\nexport class game {\r\n\t...some columns ...\r\n\r\n\t@OneToMany(type => gamelanguagerelation, gamelanguagerelations =>\r\n\tgamelanguagerelations.fk_gameid, { cascade: ['insert', 'update'] })\r\n\tgamelanguagerelations:gamelanguagerelation[];\r\n}\r\n```\r\n\r\nIf one client (user A) now creates a new game and submits this to the backend, a second user (user B) could create a new `gamelanguagerelation` for this game on his side. He will submit this relation within the whole game object to the backend. Then, the user A uses its offline copy of this game to also add a new `gamelanguagerelation` with a new (UUID) primary key. When sending this new relation (also within a game object) to the backend, typeorm tries to nullify the first relation (which was inserted by user B) since it is not part of the entity of user A. This even happens if cascade is only set to insert or update (but not remove). Unfortunately, save operation fails in this case because the foreign key (fk_gameid in gamelanguagerelation) is not nullable. Even if it would succeed, I don't want to 'orphanize' missing relations.\r\n\r\nIs there a way in typeorm to not nullify missing relations in a data set, that gets saved?\r\n\r\nThanks in advance!\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/4258/comments",
    "author": "mgreg89",
    "comments": [
      {
        "user": "Kononnable",
        "created_at": "2019-06-22T14:31:05Z",
        "body": "Ok, so problem is that you've got an entity which doesn't have actual data and it destroys some of your new data on `save`? You should use `preload` to load an actual state of data or use an query builder(probably even a relationalQueryBuilder)."
      },
      {
        "user": "mgreg89",
        "created_at": "2019-06-22T15:01:43Z",
        "body": "Thank you for that tip regarding preload! I wasn't aware of this function. But it looks like it is exactly what I was looking for :)\r\n\r\nBut nevertheless, wouldn't it be more intuitive if such missing data will only be removed from the database when `cascade: true` or `cascade: ['remove']` was explicitly set?"
      },
      {
        "user": "Kononnable",
        "created_at": "2019-06-22T21:52:44Z",
        "body": "`cascade:remove` is pretty complex subject and is discussed in few other issues.\r\n\r\nAs for why it is removed - you're telling typeorm to save a state of an object(an entity). Part of the object is the relation(doesn't matter where it is stored) - you're telling it to set entity as empty table(or at least 'not so full'), so it does that. Cascades do something different - they define if related entity should also be saved - other entity fields, not just state of the relation."
      }
    ]
  },
  {
    "number": 4250,
    "title": "Listening to table updates when running in stateless cluster mode",
    "created_at": "2019-06-06T11:30:25Z",
    "closed_at": "2019-06-22T15:43:05Z",
    "labels": [
      "question",
      "comp: subscribers and listeners"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/4250",
    "body": "**Issue type:**\r\n\r\n[X] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[X] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[ ] `cockroachdb`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[X] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\nHello,\r\n\r\nWhen running my app in cluster mode will my EventSubscriber's get notified only on the instance that they live in or will a global notification take place?\r\n\r\nFor example, take the following example with 2 app instances. running. \r\nI have set up an event subscriber to listen for updates on the user entity.\r\n\r\nIf Instance 1 updates a row in table users will the subscriber on instance 2 receive the update event?\r\n\r\n\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/4250/comments",
    "author": "pxr64",
    "comments": [
      {
        "user": "vlapo",
        "created_at": "2019-06-06T20:51:01Z",
        "body": "Typeorm will run subscribers methods only registered in current connection (using subscribers option). This functionality is not connected with DB. Typeorm broadcast events only in current instance."
      },
      {
        "user": "rustamwin",
        "created_at": "2019-06-19T07:04:51Z",
        "body": "You can to use `stream` method"
      }
    ]
  },
  {
    "number": 4240,
    "title": "how to create table without @Entity",
    "created_at": "2019-06-05T02:22:58Z",
    "closed_at": "2019-06-05T09:35:51Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/4240",
    "body": "**Issue type:**\r\n\r\nquestion\r\n\r\n**Database system/driver:**\r\n\r\nmysql\r\n\r\n**TypeORM version:**\r\n\r\nlatest\r\n\r\n\r\n😀：I want to generate a database table through code control.\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/4240/comments",
    "author": "AntoninSorrento",
    "comments": [
      {
        "user": "vlapo",
        "created_at": "2019-06-05T07:00:52Z",
        "body": "You can use `QueryRunner.createTable(...)` method."
      },
      {
        "user": "AntoninSorrento",
        "created_at": "2019-06-05T08:59:17Z",
        "body": "Thanks a lot @vlapo "
      }
    ]
  },
  {
    "number": 4229,
    "title": "Many to Many, use existing values for relation",
    "created_at": "2019-06-03T17:09:58Z",
    "closed_at": "2019-06-05T15:22:04Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/4229",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[x] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[ ] `cockroachdb`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nHi,\r\n\r\ni'm trying to put together a User/Role Relation so i'm doing a Many to Many however i want to have an existing list of roles and from that make those relations, my issue is that with what i'm doing it seems that is trying to insert the role each time generating issues with duplicates.\r\n\r\nCode.\r\n\r\nUser entity:\r\n\r\n``` ts \r\nimport {\r\n  Entity,\r\n  Column,\r\n  PrimaryGeneratedColumn,\r\n  ManyToMany,\r\n  JoinTable,\r\n} from 'typeorm';\r\nimport { Role } from './role.entity';\r\n\r\n@Entity()\r\nexport class User {\r\n  @PrimaryGeneratedColumn()\r\n  id: number;\r\n\r\n  @Column({ length: 50, unique: true })\r\n  username: string;\r\n\r\n  @Column({ length: 500 })\r\n  email: string;\r\n\r\n  @Column({ length: 100, nullable: true })\r\n  password: string | undefined;\r\n\r\n  @Column({ length: 100, nullable: true })\r\n  passwordHash: string | undefined;\r\n\r\n  @ManyToMany(type => Role, { cascade: ['insert'] })\r\n  @JoinTable({\r\n    name: 'userRoles', // table name for the junction table of this relation\r\n    joinColumn: {\r\n      name: 'userId',\r\n      referencedColumnName: 'id',\r\n    },\r\n    inverseJoinColumn: {\r\n      name: 'roleId',\r\n      referencedColumnName: 'id',\r\n    },\r\n  })\r\n  roles: Role[];\r\n}\r\n\r\n```\r\n\r\nRole entity:\r\n\r\n``` ts\r\nimport { Entity, Column, PrimaryGeneratedColumn, ManyToMany } from 'typeorm';\r\n\r\n@Entity()\r\nexport class Role {\r\n  @PrimaryGeneratedColumn()\r\n  id: number;\r\n\r\n  @Column({ length: 50, unique: true })\r\n  name: string;\r\n}\r\n\r\n```\r\n\r\nUser Service\r\n\r\n``` ts\r\nimport { Injectable } from '@nestjs/common';\r\nimport { InjectRepository } from '@nestjs/typeorm';\r\nimport { Repository } from 'typeorm';\r\nimport { User } from '../_entities/user.entity';\r\nimport * as bcrypt from 'bcrypt';\r\n\r\n@Injectable()\r\nexport class UserService {\r\n  private saltRounds = 10;\r\n\r\n  constructor(\r\n    @InjectRepository(User)\r\n    private readonly userRepository: Repository<User>,\r\n  ) {}\r\n\r\n  async getUsers(): Promise<User[]> {\r\n    return await this.userRepository.find();\r\n  }\r\n\r\n  async getUserByUsername(username: string): Promise<User> {\r\n    return (await this.userRepository.find({ username }))[0];\r\n  }\r\n\r\n  async createUser(user: User): Promise<User> {\r\n    user.passwordHash = await this.getHash(user.password);\r\n\r\n    // clear password as we don't persist passwords\r\n    user.password = undefined;\r\n    // tslint:disable-next-line: no-console\r\n    console.log('User to dave:', user);\r\n\r\n    return this.userRepository.save(user);\r\n  }\r\n\r\n  async getHash(password: string | undefined): Promise<string> {\r\n    return bcrypt.hash(password, this.saltRounds);\r\n  }\r\n\r\n  async compareHash(\r\n    password: string | undefined,\r\n    hash: string | undefined,\r\n  ): Promise<boolean> {\r\n    return bcrypt.compare(password, hash);\r\n  }\r\n}\r\n\r\n```\r\n\r\ni'm testing with postman passing the proper data in the body so when i have let's say a list of roles\r\n\r\n1. Admin\r\n2. User\r\n\r\ni want the relation to be for instance userId = 1 roleId = 1, userId = 1, roleId = 2 if the user is the 1st and it have both roles, but if i want to add another user with the same roles it will say that Admin and User already exists in the roles table because is trying to insert them.\r\n\r\nthanks in advance for the help.\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/4229/comments",
    "author": "luishcastroc",
    "comments": [
      {
        "user": "vlapo",
        "created_at": "2019-06-05T06:52:46Z",
        "body": "Could you please post some short example of code? I mean omit HTTP/postman part and write short example using typeorm functions and entities only. It is really hard for me to understand what do you want to do :) "
      }
    ]
  },
  {
    "number": 4216,
    "title": "How do you get mongodb buildConnectionUrl from TypeORM Connection",
    "created_at": "2019-05-31T05:33:35Z",
    "closed_at": "2019-05-31T14:36:53Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/4216",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[x] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[ ] `cockroachdb`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nIs there any way to get mongodb MongoClient instance or mongodb connection url from below connection.\r\n```typescript\r\nconst connection = await createConnection(connectionOptions);\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/4216/comments",
    "author": "firecrackerz",
    "comments": [
      {
        "user": "rustamwin",
        "created_at": "2019-05-31T07:16:53Z",
        "body": "Did you mean \"Underlying mongodb library\" ?\r\nIf yes then\r\n```typescript\r\nconst connection = await createConnection(connectionOptions);\r\nconst mongodb = connection.driver.mongodb\r\nmongodb.MongoClient // It's mongodb client instance\r\n```\r\n"
      },
      {
        "user": "firecrackerz",
        "created_at": "2019-05-31T11:50:58Z",
        "body": "@rustamwin Property 'mongodb' does not exist on type 'Driver'.ts(2339)"
      },
      {
        "user": "rustamwin",
        "created_at": "2019-05-31T12:59:14Z",
        "body": "@firecrackerz you can use a bit hack ;)\r\n```typescript\r\nconst connection = await createConnection(connectionOptions);\r\nconst mongodb = (connection.driver as any).mongodb\r\nmongodb.MongoClient // It's mongodb client instance\r\n```"
      },
      {
        "user": "firecrackerz",
        "created_at": "2019-05-31T14:36:53Z",
        "body": "@rustamwin thanks."
      },
      {
        "user": "shamanov-d",
        "created_at": "2020-10-14T13:37:24Z",
        "body": "@rustamwin, @firecrackerz \r\nYour decision is wrong.\r\n\r\n```javascript\r\nconst connection = await createConnection(connectionOptions);\r\nconst mongodb = (connection.driver as any).mongodb;\r\nmongodb.MongoClient; // It's mongodb client prototype!!!\r\n// it does not contain connection data\r\n```\r\nIt works.\r\n```javascript\r\nconst connection = await createConnection(connectionOptions);\r\nconst ClientDb = (connection.driver as any).queryRunner.databaseConnection; // class instance\r\nconsole.log(await ClientDb.db(\"pictureDev\").collection('goods').find({}).toArray()); // query example\r\n```\r\n\r\n\r\n"
      }
    ]
  },
  {
    "number": 4200,
    "title": "Multiple unique keys when using one to one",
    "created_at": "2019-05-27T15:45:43Z",
    "closed_at": "2019-05-29T13:34:58Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/4200",
    "body": "**Issue type:**\r\n\r\n[ ] question\r\n[x] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[x] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[ ] `cockroachdb`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[ ] `latest`\r\n[ ] `@next`\r\n[x] `0.2.17` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nHi guys, I'm trying to have unique keys with foreign key associated with one of them but I think typeorm is creating different unique keys.\r\n\r\nHere is my model file:\r\n\r\n```ts\r\nimport {\r\n  Column,\r\n  Entity,\r\n  JoinColumn,\r\n  OneToOne,\r\n  PrimaryGeneratedColumn,\r\n  Unique,\r\n} from 'typeorm';\r\n\r\nimport { BotModel } from './bot.model';\r\n\r\n@Entity('intent')\r\n@Unique(['botId', 'name'])\r\nexport class IntentModel {\r\n  @PrimaryGeneratedColumn('uuid')\r\n  intentId: string;\r\n\r\n  @Column()\r\n  botId: string;\r\n\r\n  @OneToOne(() => BotModel, { cascade: true })\r\n  @JoinColumn({\r\n    name: 'botId',\r\n    referencedColumnName: 'botId',\r\n  })\r\n  bot: BotModel;\r\n\r\n  @Column({ length: 16 })\r\n  name: string;\r\n\r\n  @Column({\r\n    length: 128,\r\n    nullable: true,\r\n  })\r\n  description: string;\r\n}\r\n```\r\n\r\nMy `create table intent` from mysql:\r\n\r\n```mysql\r\nCREATE TABLE `intent` (\r\n  `intentId` varchar(36) NOT NULL,\r\n  `botId` varchar(255) NOT NULL,\r\n  `name` varchar(16) NOT NULL,\r\n  `description` varchar(128) DEFAULT NULL,\r\n  PRIMARY KEY (`intentId`),\r\n  UNIQUE KEY `REL_94de4914fe0a743917de52fe8e` (`botId`),\r\n  UNIQUE KEY `IDX_94de4914fe0a743917de52fe8e` (`botId`),\r\n  UNIQUE KEY `IDX_78750387b2c61fb51adb75b5ab` (`botId`,`name`),\r\n  CONSTRAINT `FK_94de4914fe0a743917de52fe8e7` FOREIGN KEY (`botId`) REFERENCES `bot` (`botId`) ON DELETE NO ACTION ON UPDATE NO ACTION\r\n) ENGINE=InnoDB DEFAULT CHARSET=latin1\r\n```\r\n\r\nWhen I try to insert different name with id(already inserted) I'm getting this:\r\n```mysql\r\nER_DUP_ENTRY: Duplicate entry '0b387f8b-d330-4b39-93d2-5637f11001b7' for key 'REL_94de4914fe0a743917de52fe8e'\r\n```\r\n\r\nI tried in different ways but no success.",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/4200/comments",
    "author": "lucasmonstrox",
    "comments": [
      {
        "user": "vlapo",
        "created_at": "2019-05-28T17:44:07Z",
        "body": "It shouldn't be `ManyToOne` relation? I mean you want allow one `BotModel` to be related with many `IntentModel`.\r\n\r\n`OneToOne` is reason of first `UNIQUE KEY 'REL_94de4914fe0a743917de52fe8e' ('botId'),` but I do not understand second one `UNIQUE KEY 'IDX_94de4914fe0a743917de52fe8e' ('botId'),`. It does not appear in my test."
      },
      {
        "user": "lucasmonstrox",
        "created_at": "2019-05-29T13:34:58Z",
        "body": "Working :-D\r\n\r\nThanks"
      }
    ]
  },
  {
    "number": 4197,
    "title": "Many to Many relation not using jointable when updating entity",
    "created_at": "2019-05-26T21:22:32Z",
    "closed_at": "2019-05-29T07:27:54Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/4197",
    "body": "**Issue type:**\r\n\r\n[ ] question\r\n[x] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[x] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[ ] `cockroachdb`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest` (`^0.2.17`)\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nWhen I try to add a group to a user and update the user entity, the update query results in a an error (`ER_BAD_FIELD_ERROR`). \r\n\r\nTypeorm tries to set the user id, which should go into the join table, to the user table itself. The code should explain the problem a little bit better.\r\n\r\n**TinyUser.ts**\r\n```javascript\r\nimport {Entity, JoinTable, ManyToMany, PrimaryGeneratedColumn} from \"typeorm\";\r\nimport {TinyGroup} from \"./TinyGroup\";\r\n\r\n@Entity()\r\nexport class TinyUser {\r\n    /**\r\n     * Contains the unique number for the Page\r\n     *\r\n     * @name id\r\n     * @type number\r\n     */\r\n    @PrimaryGeneratedColumn()\r\n    id: number = 0;\r\n\r\n    /**\r\n     * Contains the user groups\r\n     *\r\n     * @name groups\r\n     * @type TinyGroup[]\r\n     */\r\n    @ManyToMany(() => TinyGroup)\r\n    @JoinTable({\r\n        name: 'tiny_user_groups',\r\n        joinColumn: {referencedColumnName: 'id', name: 'user_id'},\r\n        inverseJoinColumn: {referencedColumnName: 'id', name: 'group_id'}\r\n    })\r\n    groups?: TinyGroup[];\r\n}\r\n```\r\n\r\n**TinyGroup.ts**\r\n```javascript\r\nimport {Entity, JoinTable, ManyToMany, PrimaryGeneratedColumn} from \"typeorm\";\r\nimport {TinyUser} from \"./TinyUser\";\r\n\r\n@Entity()\r\nexport class TinyGroup\r\n{\r\n    /**\r\n     * Contains the unique number for the Page\r\n     *\r\n     * @name id\r\n     * @type number\r\n     */\r\n    @PrimaryGeneratedColumn()\r\n    id: number = 0;\r\n\r\n    /**\r\n     * Contains the user groups\r\n     *\r\n     * @name users\r\n     * @type TinyUser[]\r\n     */\r\n    @ManyToMany(() => TinyUser)\r\n    @JoinTable({\r\n        name: 'tiny_user_groups',\r\n        joinColumn: {referencedColumnName: 'id', name: 'group_id'},\r\n        inverseJoinColumn: {referencedColumnName: 'id', name: 'user_id'}\r\n    })\r\n    users?: TinyUser[];\r\n}\r\n```\r\n\r\n**App.ts**\r\n```javascript\r\nimport {ConnectionOptions, createConnection} from \"typeorm\";\r\nimport {TinyUser} from \"./Models/TinyUser\";\r\nimport {TinyGroup} from \"./Models/TinyGroup\";\r\nimport {MysqlConnectionOptions} from \"typeorm/driver/mysql/MysqlConnectionOptions\";\r\n\r\n(async function ()\r\n{\r\n    const config: MysqlConnectionOptions = {\r\n        \"type\": \"mysql\",\r\n        \"host\": \"localhost\",\r\n        \"port\": 3306,\r\n        \"username\": \"root\",\r\n        \"password\": \"root\",\r\n        \"database\": \"test\",\r\n        \"synchronize\": true\r\n        , entities: [__dirname + '/Models/*.js']\r\n    };\r\n\r\n    const connection = await createConnection(config);\r\n\r\n    const gr = connection.getRepository(TinyGroup);\r\n    const ur = connection.getRepository(TinyUser);\r\n\r\n    const u: TinyUser = new TinyUser();\r\n    const g: TinyGroup = new TinyGroup();\r\n\r\n    await ur.save(u);\r\n    await gr.save(g);\r\n\r\n    u.groups = [g];\r\n\r\n    try {\r\n        await ur.update(u, {id: 1});\r\n    } catch(e) {\r\n        console.error(e);\r\n    }\r\n})();\r\n```\r\n\r\nThis code results in an `ER_BAD_FIELD_ERROR: Unknown column 'user_id' in 'field list'` error.\r\n\r\nMy expectation would be a query like this:\r\n```SQL\r\nINSERT INTO `tiny_user_groups` SET `user_id` = ?, `group_id` = ?\r\n```\r\n\r\nThe generated query however is the following:\r\n```SQL\r\nUPDATE `tiny_user` SET `id` = 1, `user_id` = NULL WHERE `id` = 1\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/4197/comments",
    "author": "YannikSc",
    "comments": [
      {
        "user": "vlapo",
        "created_at": "2019-05-27T20:33:44Z",
        "body": "You have to use `save`. `update` is only raw update and skip most of ORM based magic features like relations.\r\n```ts\r\nconst gr = connection.getRepository(TinyGroup);\r\nconst ur = connection.getRepository(TinyUser);\r\n\r\nconst u: TinyUser = new TinyUser();\r\nconst g: TinyGroup = new TinyGroup();\r\n\r\nawait ur.save(u);\r\nawait gr.save(g);\r\n\r\nu.groups = [g];\r\n\r\nawait ur.save(u);\r\n```"
      },
      {
        "user": "YannikSc",
        "created_at": "2019-05-29T07:27:36Z",
        "body": "Thanks a lot. Worked for me! :+1: "
      }
    ]
  },
  {
    "number": 4171,
    "title": "PostgreSQL Partial Index creation is weird/ugly/unclear/hard to make it work",
    "created_at": "2019-05-21T09:43:48Z",
    "closed_at": "2022-04-16T13:41:03Z",
    "labels": [
      "question",
      "by design"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/4171",
    "body": "**Issue type:**\r\n\r\n[ ] question\r\n[x] bug report\r\n[ ] feature request\r\n[x] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[x] `postgres`\r\n[ ] `cockroachdb`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nSo I'm having this entity that indexes only unapproved entries:\r\n\r\n```ts\r\n@Entity()\r\nexport class Test {\r\n    @PrimaryGeneratedColumn()\r\n    public id?: number;\r\n\r\n    @Column()\r\n    @Index({ where: \"approvedBy IS NULL\" })\r\n    public theKey?: string;\r\n\r\n    @Column()\r\n    public approvedBy?: string;\r\n}\r\n```\r\n\r\nTrying to sync, I get this error:\r\n\r\n```\r\nquery: CREATE TABLE \"test\" (\"id\" SERIAL NOT NULL, \"theKey\" character varying NOT NULL, \"approvedBy\" character varying NOT NULL, CONSTRAINT \"PK_5417af0062cf987495b611b59c7\" PRIMARY KEY (\"id\"))\r\nquery: CREATE INDEX \"IDX_ff7409e54a06ac21a0ca142a9b\" ON \"test\" (\"theKey\") WHERE approvedBy IS NULL\r\nquery failed: CREATE INDEX \"IDX_ff7409e54a06ac21a0ca142a9b\" ON \"test\" (\"theKey\") WHERE approvedBy IS NULL\r\nerror: error: column \"approvedby\" does not exist\r\n    at Connection.parseE (/Users/constb/PhpstormProjects/finso-crypto-api/node_modules/pg/lib/connection.js:601:11)\r\n    at Connection.parseMessage (/Users/constb/PhpstormProjects/finso-crypto-api/node_modules/pg/lib/connection.js:398:19)\r\n    at Socket.<anonymous> (/Users/constb/PhpstormProjects/finso-crypto-api/node_modules/pg/lib/connection.js:120:22)\r\n    at Socket.emit (events.js:196:13)\r\n    at addChunk (_stream_readable.js:290:12)\r\n    at readableAddChunk (_stream_readable.js:271:11)\r\n    at Socket.Readable.push (_stream_readable.js:226:10)\r\n    at TCP.onStreamRead (internal/stream_base_commons.js:166:17)\r\n```\r\n\r\nError details:\r\n\r\n```\r\n{\r\n  name: 'error',\r\n  length: 172,\r\n  severity: 'ERROR',\r\n  code: '42703',\r\n  detail: undefined,\r\n  hint: 'Perhaps you meant to reference the column \"test.approvedBy\".',\r\n  position: '74',\r\n  internalPosition: undefined,\r\n  internalQuery: undefined,\r\n  where: undefined,\r\n  schema: undefined,\r\n  table: undefined,\r\n  column: undefined,\r\n  dataType: undefined,\r\n  constraint: undefined,\r\n  file: 'parse_relation.c',\r\n  line: '3294',\r\n  routine: 'errorMissingColumn'\r\n}\r\n```\r\n\r\nThe lower-cased column `approvedby` here is a distraction. I enabled logging and it seems that query contains correct name.\r\n\r\nLet's try to explicitly specify table name as `@Index({ where: \"test.approvedBy IS NULL\" })` as hint suggests:\r\n\r\n```\r\nquery: CREATE TABLE \"test\" (\"id\" SERIAL NOT NULL, \"theKey\" character varying NOT NULL, \"approvedBy\" character varying NOT NULL, CONSTRAINT \"PK_5417af0062cf987495b611b59c7\" PRIMARY KEY (\"id\"))\r\nquery: CREATE INDEX \"IDX_24a5f148f75962c2c84eefe956\" ON \"test\" (\"theKey\") WHERE test.approvedBy IS NULL\r\nquery failed: CREATE INDEX \"IDX_24a5f148f75962c2c84eefe956\" ON \"test\" (\"theKey\") WHERE test.approvedBy IS NULL\r\nerror: error: column test.approvedby does not exist\r\n    at Connection.parseE (/Users/constb/PhpstormProjects/finso-crypto-api/node_modules/pg/lib/connection.js:601:11)\r\n    at Connection.parseMessage (/Users/constb/PhpstormProjects/finso-crypto-api/node_modules/pg/lib/connection.js:398:19)\r\n    at Socket.<anonymous> (/Users/constb/PhpstormProjects/finso-crypto-api/node_modules/pg/lib/connection.js:120:22)\r\n    at Socket.emit (events.js:196:13)\r\n    at addChunk (_stream_readable.js:290:12)\r\n    at readableAddChunk (_stream_readable.js:271:11)\r\n    at Socket.Readable.push (_stream_readable.js:226:10)\r\n    at TCP.onStreamRead (internal/stream_base_commons.js:166:17)\r\n```\r\n\r\nAnd also:\r\n\r\n```\r\n{\r\n  name: 'error',\r\n  length: 175,\r\n  severity: 'ERROR',\r\n  code: '42703',\r\n  detail: undefined,\r\n  hint: 'Perhaps you meant to reference the column \"test.approvedBy\".',\r\n  position: '74',\r\n  internalPosition: undefined,\r\n  internalQuery: undefined,\r\n  where: undefined,\r\n  schema: undefined,\r\n  table: undefined,\r\n  column: undefined,\r\n  dataType: undefined,\r\n  constraint: undefined,\r\n  file: 'parse_relation.c',\r\n  line: '3294',\r\n  routine: 'errorMissingColumn'\r\n}\r\n```\r\n\r\nNow this is proper weird, right? After a couple hours of tinkering I managed to make it work, but the solution is ugly, unclear from the docs and it all just was kind of hard to make it work:\r\n\r\n```ts\r\n@Entity()\r\nexport class Test {\r\n    @PrimaryGeneratedColumn()\r\n    public id?: number;\r\n\r\n    @Column()\r\n    @Index({ where: \"\\\"approvedBy\\\" IS NULL\" })\r\n    public theKey?: string;\r\n\r\n    @Column()\r\n    public approvedBy?: string;\r\n}\r\n```\r\n\r\nAm I right? :)",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/4171/comments",
    "author": "constb",
    "comments": [
      {
        "user": "ShaharHD",
        "created_at": "2019-05-30T02:27:52Z",
        "body": "why not use\r\n\r\n```ts\r\n@Entity()\r\nexport class Test {\r\n    @PrimaryGeneratedColumn()\r\n    public id?: number;\r\n\r\n    @Column()\r\n    @Index({ where: '\"approvedBy\" IS NULL' })\r\n    public theKey?: string;\r\n\r\n    @Column()\r\n    public approvedBy?: string;\r\n}\r\n```"
      },
      {
        "user": "gaurav-",
        "created_at": "2019-10-13T07:52:40Z",
        "body": "@constb I don't think this is a `typeorm` issue. That's just how Postgresql behaves when you specify a mixed-case name (column name here) without double-quotes."
      },
      {
        "user": "constb",
        "created_at": "2019-10-15T17:40:34Z",
        "body": "you know, I actually sort of reexperienced this today, when I was trying to set column default value to an empty string in a migration, mysql this time.\r\n\r\n`default: ''` is logical but doesn't really work. you get syntax error. the way that works is `default: '\"\"'`. also – weird. I kinda understand the rationale behind this, trying to give developers an instrument that's a little more universal and less opinionated about things. but at least, please document those corner cases. it takes hours each time to figure out something that should just work, and it just doesn't."
      },
      {
        "user": "AlexMesser",
        "created_at": "2022-04-16T13:41:03Z",
        "body": "`where` parameter accepts any string and there is no way to determine is it a column name, a function or a something else. So, you must properly escape column names yourself."
      }
    ]
  },
  {
    "number": 4154,
    "title": "Eager relation are not loaded from both side...",
    "created_at": "2019-05-18T14:32:07Z",
    "closed_at": "2019-06-22T15:15:32Z",
    "labels": [
      "question",
      "comp: relations"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/4154",
    "body": "**Issue type:**\r\n\r\n[ ] question\r\n[x] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[x] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[ ] `cockroachdb`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[ ] `latest`\r\n[ ] `@next`\r\n[x] `0.2.17` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nHi,\r\n\r\n```\r\n@Entity('Parent')\r\nexport class Parent {\r\n  ...\r\n\r\n @ManyToMany(type => Child, child => child.parents, { nullable: true, eager: true })\r\n  childrens: Child[];\r\n}\r\n\r\n\r\n@Entity('Child')\r\nexport class Child {\r\n...\r\n\r\n  @ManyToMany(type => Parent, parent => parent.children, { nullable: true })\r\n  @JoinTable()\r\n  parents: Parent[];\r\n}\r\n```\r\n\r\nWith this two entities, when you use find() on Parent, the childrens are correctly loaded, but if you use find on Children, the parents are not...\r\nI tried to put the eager tag on both side of the relation because it throw an error...\r\nAnd if you inverse the situation like following, then use find() on Parent will not load the childrens relation but use find() on Children will load parents relation....\r\n\r\n```\r\n@Entity('Parent')\r\nexport class Parent {\r\n  ...\r\n\r\n @ManyToMany(type => Child, child => child.parents, { nullable: true })\r\n  childrens: Child[];\r\n}\r\n\r\n\r\n@Entity('Child')\r\nexport class Child {\r\n...\r\n\r\n  @ManyToMany(type => Parent, parent => parent.children, { nullable: true, eager: true })\r\n  @JoinTable()\r\n  parents: Parent[];\r\n}\r\n```",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/4154/comments",
    "author": "Nooka10",
    "comments": [
      {
        "user": "hamiltop",
        "created_at": "2019-06-10T17:01:45Z",
        "body": "I don't think this is a bug. It's stated in the docs:\r\n\r\n> Eager relations can only be used on one side of the relationship, using eager: true on both sides of relationship is disallowed.\r\n\r\nTo me that says that what you want is just not supported. Might be a worthy feature request though."
      }
    ]
  },
  {
    "number": 4139,
    "title": "Types should correctly display \"null\" or \"undefined\" on nullable: true or select: false",
    "created_at": "2019-05-14T10:21:37Z",
    "closed_at": "2020-10-07T07:09:13Z",
    "labels": [
      "question",
      "new feature",
      "driver: postgres"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/4139",
    "body": "**Issue type:**\r\n\r\n[ ] question\r\n[ ] bug report\r\n[x] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[x] `postgres`\r\n[ ] `cockroachdb`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[ ] `latest`\r\n[ ] `@next`\r\n[x ] `0.2.17`\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nFirst of all: thank you so much for this package. It's really easy to work with!\r\n\r\nLately, I stumbled upon the problem below:\r\n\r\nJust a simple example:\r\n\r\n```typescript\r\n// Article entity\r\n@Column({ nullable: true })\r\ntitle: string;\r\n```\r\n\r\n```typescript\r\nconst article = await articleRepository.findOne(articleId);\r\n```\r\n\r\nTitle:\r\n`(Property) Article.title: string`\r\n\r\nBut it could also be `null`, not only a `string`.\r\n\r\nAnother example:\r\n```typescript\r\n// Article entity\r\n@Column('text', { nullable: true, select: false })\r\ntext: string;\r\n```\r\n`(Property) Article.text: string`\r\n\r\nBut it could also be: `null` and `undefined`.\r\n\r\nIs there any way to get more correct types? Because Typescript does not pick these things up correctly, where you would expect to be notified by possible `null` and `undefined` values.\r\n\r\nI've tried:\r\n```typescript\r\n// Article entity\r\n@Column({ nullable: true })\r\ntitle: string | null;\r\n```\r\n\r\nBut then i get an error: `Data type \"Object\" in \"Article.title\" is not supported by \"postgres\" database`. Probably because `typeof null` is `object`. \r\n\r\nThe library should correctly look for any `nullable` property on the `Column` in this case. Or `nullable: true` should just be removed, and just use the types: `title: string | null` to determine a nullable column. This way it already fixes the problem I describe.",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/4139/comments",
    "author": "jvandenaardweg",
    "comments": [
      {
        "user": "Kononnable",
        "created_at": "2019-05-26T11:31:01Z",
        "body": ">But it could also be null, not only a string.\r\n\r\nAny yet you wrote it yourself, that it can only be a string. We can't change typings of your code - you should use `string | null` instead.\r\nAs for an error with not recognized type - reflect-metadata can store only basic type information - and if something is nullable it always sees it as an object. Because of that typeorm doesn't get enough information to guess column type - you need to pass a `type` option to column decorator.\r\n\r\nAs for undefined - It would be very hard(if it's even possible) to pass correct type from typeorm in case `select:false` is used - types have to be known on compilation while this information is very logic dependent. "
      },
      {
        "user": "jvandenaardweg",
        "created_at": "2019-05-26T19:42:06Z",
        "body": "> As for undefined - It would be very hard(if it's even possible) to pass correct type from typeorm in case select:false is used - types have to be known on compilation while this information is very logic dependent.\r\n\r\nBut what if you just allow to pass in: `string | undefined`? Then its known on compile. In context it’s exactly the same as giving `select: false`. Then TS just warns you you should always check if its defined if you want to use it. "
      },
      {
        "user": "Kononnable",
        "created_at": "2019-05-26T20:11:55Z",
        "body": "You would then have to always check every column if it's value is `undefined` before using it. It would make a tremendous amount of end user code invalid(typescipt would scream about possible undefined) and will make using ORM painful.\r\nI would very much like typeorm to be fully compatible with strict flags, but with current state of affairs I don't see this coming soon. Implementing that on it's own is pretty complex but there are tons of more important bugs to be fixed and not so much time to do that(since no one is working full-time on typeorm)."
      },
      {
        "user": "jvandenaardweg",
        "created_at": "2019-05-27T05:01:54Z",
        "body": "> You would then have to always check every column if it's value is undefined before using it. It would make a tremendous amount of end user code invalid(typescipt would scream about possible undefined) and will make using ORM painful.\r\n\r\nNot every column. Just the ones where you have `select: false`. Now the code just assumes the property is defined, which it is not. Implementing this change would actually warn the users of their (bad) code, instead of really breaking it. \r\n\r\n>  It would make a tremendous amount of end user code invalid(typescipt would scream about possible undefined)\r\n\r\nThat's actually better than having bugs in your code not knowing about, and was the main reason for opening this issue. If the compiler starts screaming at users because of this, then their implementation was already wrong from the beginning as they should properly check if it's defined when using `select: false`\r\n\r\nOr am i missing something here? :-)\r\n\r\nI understand other priorities. Again, thanks for the library and the time you and other contributors put in!"
      },
      {
        "user": "Kononnable",
        "created_at": "2019-05-27T12:56:47Z",
        "body": ">Not every column. Just the ones where you have `select: false`.\r\n\r\nIf you set this option in entity definition you can declare variable as `| undefined`. It will have very similar user experience.\r\n\r\nAs for setting it for every column: It will be hard to determine which columns should have `| undefined`. This is very orm-logic dependent. You pass this information to column decorator, but you need to use it in completely different place. Underneath decorator just saves metadata about config - it's saves a JS object. But type system doesn't have access to it, because it's run during compilation, before JS objects with metadata exists. To make it work we would probably have two different types - one for `select:true`, one for `select:false`. It probably is possible to implement, but it would be really hard to do it properly."
      },
      {
        "user": "cdeutsch",
        "created_at": "2019-08-19T22:22:14Z",
        "body": "> Any yet you wrote it yourself, that it can only be a string. We can't change typings of your code - you should use `string | null` instead.\r\n\r\n`string | null` doesn't work with Postgres.\r\n\r\nI get the error:\r\n\r\n> Data type \"Object\" in \"User.username\" is not supported by \"postgres\" database.\r\n\r\nSame error as @jvandenaardweg reported above.\r\n\r\n------------------------------------------------------\r\n\r\n> You would then have to always check every column if it's value is undefined before using it. It would make a tremendous amount of end user code invalid(typescipt would scream about possible undefined) and will make using ORM painful.\r\n\r\nRight now, I don't think `typeorm` works well for TypeScript, because instead of checking for just `undefined`, I have to also worry about `null`. \r\n\r\nIt's easier to defined \"nullable\" types in TS using `username?: string;` than `username: string | null`;\r\n\r\nWould love to see a typeorm configuration option to just treat `undefined` as `null`."
      },
      {
        "user": "jvandenaardweg",
        "created_at": "2019-08-22T11:20:27Z",
        "body": "I've changed the title, because...\r\n\r\n```typescript\r\n@Column({ select: false })\r\ntitle: string | undefined;\r\n```\r\n\r\n...seems to work fine.\r\n\r\nIt's just about the nullable values:\r\n\r\n```typescript\r\n@Column({ nullable: true })\r\ntitle: string | null;\r\n```\r\n\r\nResults in `Data type \"Object\" in \"Article.title\" is not supported by \"postgres\" `\r\n\r\nIf the `undefined` one works fine with 2 types, I don't really get why `string | null` is a problem\r\n\r\n**edit:** well, i don't know what happened, but `string | undefined` also just does not work. Same error. Guess i'll revert back the title. Sorry for this."
      },
      {
        "user": "kav2k",
        "created_at": "2019-11-06T13:26:39Z",
        "body": "The only workaround that I found is this:\r\n```ts\r\n@Column({ nullable: true, type: \"varchar\" })\r\ntitle: string | null;\r\n```\r\ni.e. manually specifying the type. Otherwise, TypeORM can't guess that type correctly (assumes Object).\r\n\r\nIt would be nice if TypeORM could correctly deduce a `nullable: true` column type from `T | null` (or `T | null | undefined`)."
      }
    ]
  },
  {
    "number": 4134,
    "title": "Automatic switch to ts/ js entities depending on the run mode(ts, node)",
    "created_at": "2019-05-13T13:48:07Z",
    "closed_at": "2019-05-15T16:14:44Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/4134",
    "body": "**Issue type:**\r\n\r\n[x ] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[ ] `cockroachdb`\r\n[ x] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[ x] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\n\r\n\r\nFirst of all, thank you for this awesome project 💯 , its very usefull 👍  !!\r\nI have a question, in the documention to mention the path of the entities. \r\nif we use javascript run,  we specify the path js example : \r\n\r\n```\r\n\"logging\": true,\r\n  \"entities\": [\"dist/main/infrastructure/db/entity/**/*.js\"]\r\n```\r\n\r\nAnd for Ts node, we change to \r\n\r\n```\r\n\"logging\": true,\r\n  \"entities\": [\r\n    \"src/main/infrastructure/db/entity/**/*.ts\"\r\n  ],\r\n```\r\n\r\n\r\nThis is manually action, my question please, \r\nIs there any  automatic configuration for this need ? to reduce this action ?",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/4134/comments",
    "author": "hatim-heffoudhi",
    "comments": [
      {
        "user": "Kononnable",
        "created_at": "2019-05-13T14:27:23Z",
        "body": "Depending on your configuration you might want to use `*.{js,ts}`. If you're compiling typescript to another folder(`outDir` in `tsconfig.json`) this should work just fine."
      },
      {
        "user": "hatim-heffoudhi",
        "created_at": "2019-05-13T14:47:48Z",
        "body": "thank you @Kononnable , for your answer, you see in  my question i put : \r\n```\r\n\"logging\": true,\r\n  \"entities\": [\r\n    \"src/main/infrastructure/db/entity/**/*.ts\"\r\n  ],\r\n\r\n```\r\n\r\n```\r\n\"logging\": true,\r\n  \"entities\": [\"dist/main/infrastructure/db/entity/**/*.js\"]\r\n\r\n```\r\nIn the ormconfig.json , we specify the absolute path of the entities,for ts it's src and for js is dist, is there any option like that  : ?\r\n\r\n  ```\r\n\"entities\": [\r\n    \"__dirname/infrastructure/db/entity/**/*.{js,ts}\"\r\n  ],\r\n\r\n```\r\n"
      },
      {
        "user": "Kononnable",
        "created_at": "2019-05-13T17:54:07Z",
        "body": "I think it is still relative path, not absolute one. Maybe you should change location of ormconfig.json. It's hard to tell without knowledge of your project structure. If it still doesn't help you can pass orm options as js object - then you could write your own logic to choose different entities folder(if it's a complicated logic)."
      },
      {
        "user": "hatim-heffoudhi",
        "created_at": "2019-05-15T13:59:49Z",
        "body": "hello @Kononnable , thank you for your return, i've changed the implementation programmatically."
      }
    ]
  },
  {
    "number": 4129,
    "title": "original database had be modify",
    "created_at": "2019-05-12T10:20:32Z",
    "closed_at": "2020-10-01T06:04:08Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/4129",
    "body": "Why did modify my original database when the framework was initialized?\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/4129/comments",
    "author": "shenhanxing",
    "comments": [
      {
        "user": "Kononnable",
        "created_at": "2019-05-13T14:52:20Z",
        "body": "Probably you've got schema sync enabled, or something similar. It's really hard to guess basing answer just on 11 words you wrote."
      },
      {
        "user": "imnotjames",
        "created_at": "2020-10-01T06:04:08Z",
        "body": "If you still are having issues please feel free to open a new issue with more information to help us replicate the problem you're having & better understand how to help you.\r\n\r\nCheers!"
      }
    ]
  },
  {
    "number": 4071,
    "title": "[MongoDB] Event listener in list of nested documents gives error",
    "created_at": "2019-05-02T16:04:32Z",
    "closed_at": "2021-05-29T16:02:33Z",
    "labels": [
      "bug",
      "question",
      "comp: subscribers and listeners",
      "driver: mongodb"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/4071",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[x] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[x] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[ ] `cockroachdb`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[ ] `latest`\r\n[ ] `@next`\r\n[x] `0.2.16`\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\n```ts\r\nexport class Category {\r\n    @Column()\r\n    public slug: string;\r\n\r\n    @Column()\r\n    public name: string;\r\n    \r\n    @AfterLoad()\r\n    someFunk() {\r\n      console.log('Loaded')\r\n    }\r\n}\r\n\r\n@Entity()\r\nexport class Article {\r\n    @ObjectIdColumn()\r\n    public id: ObjectID;\r\n\r\n    @Column(type => Category)\r\n    public categories: Category[];\r\n}\r\n```\r\n\r\nGives error \r\n```\r\nentity[propertyPath][this.propertyName] is not a function\r\n```\r\n\r\nWhen the entities column is not an array it works, i.e\r\n```ts\r\n...\r\n@Column(type => Category)\r\npublic category: Category;\r\n...\r\n```\r\n\r\nI would expect the event listeners to be called once for every instance in the array.\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/4071/comments",
    "author": "danielsetreus",
    "comments": [
      {
        "user": "ziofat",
        "created_at": "2020-10-26T12:58:21Z",
        "body": "any updates on this?"
      }
    ]
  },
  {
    "number": 4057,
    "title": "Is there any option to have a batch update? I am trying to update 130 records based on indiviual ID's and its taking enough time to casue teh performance issue",
    "created_at": "2019-04-28T18:42:36Z",
    "closed_at": "2019-06-19T07:28:27Z",
    "labels": [
      "question",
      "can be closed?",
      "comp: query builder"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/4057",
    "body": "**Issue type:**\r\n\r\n[ X] question\r\n[X ] documentation issue\r\n\r\n**Database system/driver:**\r\n[ X] `mysql` / `mariadb`\r\n\r\n**TypeORM version:**\r\n\r\n[X] `latest`\r\n\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\n<!--\r\n    To answer those questions you need to put \"x\" inside the square brackets, for example:\r\n    [x] `mysql`\r\n    [ ] `postgres`\r\n\r\n    Also, please format your code properly (by taking code blocks into ```ts .... ```)\r\n!>\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/4057/comments",
    "author": "rk-ravikiran",
    "comments": [
      {
        "user": "Kononnable",
        "created_at": "2019-05-25T10:04:14Z",
        "body": "Please put your question in the issue content, do not put it into it's title.\r\n\r\nYou can use e.g. query builder for that with where similar to: `.where(\"post.authorId IN (:...authors)\", { authors: [3, 7, 9] })`"
      },
      {
        "user": "rustamwin",
        "created_at": "2019-06-19T07:28:27Z",
        "body": "Closing as no response from the author."
      }
    ]
  },
  {
    "number": 4052,
    "title": "ReferenceError on migration:generate",
    "created_at": "2019-04-26T16:45:11Z",
    "closed_at": "2020-10-14T05:43:11Z",
    "labels": [
      "question",
      "comp: migrations"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/4052",
    "body": "Putting the following inside a single file throws\r\n\r\n```\r\nError during migration generation:\r\nReferenceError: Person is not defined\r\n```\r\non migration:generate\r\n\r\n```\r\nimport {\r\n  Column,\r\n  Entity,\r\n  ManyToOne,\r\n  OneToMany,\r\n  PrimaryGeneratedColumn\r\n} from \"typeorm\";\r\n\r\n@Entity()\r\nexport class Car {\r\n  @PrimaryGeneratedColumn()\r\n  id?: number;\r\n\r\n  @ManyToOne(() => Person, Person => Person.cars)\r\n  owner?: Person;\r\n}\r\n\r\n@Entity()\r\nexport class Person {\r\n  @PrimaryGeneratedColumn()\r\n  id?: number;\r\n\r\n  @Column({ type: \"varchar\" })\r\n  name?: string;\r\n\r\n  @OneToMany(() => Car, Car => Car.owner)\r\n  cars?: Array<Car>;\r\n}\r\n\r\n```\r\n\r\nIf I change the order of the classes the error disappears. \r\nWhy does this matter? Typescript can compile it without a problem.",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/4052/comments",
    "author": "Knaackee",
    "comments": [
      {
        "user": "d0p3t",
        "created_at": "2019-05-06T22:45:13Z",
        "body": "I'm experiencing the same issue.\r\n\r\nThis prevents me from defining entities that have relationships in different files. The order of defining entities in the connection options does not matter.\r\n\r\nI'm using `postgres`."
      },
      {
        "user": "Kononnable",
        "created_at": "2019-05-25T20:40:10Z",
        "body": "Unfortunately this is an issue we can't really do much about. Typescript compiles such code, but then when we try to run it we will have a ReferenceError. \r\nThis happens because of how `emitDecoratorMetadata` option works. It requires a type(a variable with class) but in this case it isn't defined yet(in case of newer ES versions). If you change `target` to ES3 it will run correctly(compiled code uses var instead of let and there is a hoisting)."
      }
    ]
  },
  {
    "number": 4037,
    "title": "InsertResult.generatedMaps is an ObjectLiteral[]?",
    "created_at": "2019-04-23T23:42:45Z",
    "closed_at": "2019-05-25T11:41:28Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/4037",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[x] `postgres`\r\n[ ] `cockroachdb`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nWhen I use an `EntityManager` to insert data like so:\r\n\r\n```typescript\r\n    const result = await transactionEntityManager.insert(UserFollow, {\r\n      fromId: fromUser,\r\n      toId: toUser\r\n    });\r\n```\r\n\r\nI can get the inserted elements by calling `result.generatedMaps()`, which returns an `ObjectLiteral[]` that happens to be the same shape as an actual `Entity`.\r\n\r\nI thought, wouldn't it be cooler if `InsertResult` was declared as a generic that could take in an `Entity` class? It's an easy change - change `InsertResult.ts` to look like this:\r\n\r\n```typescript\r\nimport { ObjectLiteral } from \"../../common/ObjectLiteral\";\r\n/**\r\n * Result object returned by InsertQueryBuilder execution.\r\n */\r\nexport declare class InsertResult<Entity = ObjectLiteral> {\r\n  /**\r\n   * Contains inserted entity id.\r\n   * Has entity-like structure (not just column database name and values).\r\n   */\r\n  identifiers: Entity[];\r\n  /**\r\n   * Generated values returned by a database.\r\n   * Has entity-like structure (not just column database name and values).\r\n   */\r\n  generatedMaps: Entity[];\r\n  /**\r\n   * Raw SQL result returned by executed query.\r\n   */\r\n  raw: any;\r\n}\r\n```\r\n\r\nAnd throw in the generic into the `EntityManager.insert()` return type. But I noticed that the comments say that these have \"entity-like structure\", which implies that they aren't actually `Entity` instances.\r\n\r\nWhat exactly does that mean? Trying to understand what separates an `Entity` from an entity-like structure.",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/4037/comments",
    "author": "osdiab",
    "comments": [
      {
        "user": "osdiab",
        "created_at": "2019-04-23T23:44:08Z",
        "body": "In the meantime I'm just type-suggesting `generatedMaps as UserFollow[]` in my code, which is fine since I never actually mutate it from here; but should I be doing something to \"upgrade\" these \"entity-like\" things into real entities? or is what I'm doing already safe?"
      },
      {
        "user": "vlapo",
        "created_at": "2019-04-24T08:50:22Z",
        "body": "In this case `Entity` is instance of entity class with filled data from database. But `entity-like structure` means it is just raw json/data from database. It is not instance of entity so it has to be `ObjectLiteral`.\r\n\r\n`insert(...)` method is just raw insert and typeorm will not convert results into entities. If you want entities returned you have to use `save(...)` method."
      },
      {
        "user": "osdiab",
        "created_at": "2019-04-24T15:39:23Z",
        "body": "Is there a type then that could denote an ObjectLiteral with the same shape as an entity? Like would it make sense to make ObjectLiteral be a generic as well, so that I can denote that we know what the shape would be like but not actually make it a proper Entity class (which is all I need for this API endpoint)? If that’s not something we want in typeorm typings that’s fine I can do the same in my repo and use a type suggestion, but seems like a natural primitive to be expressible by the library "
      },
      {
        "user": "vlapo",
        "created_at": "2019-04-24T20:26:44Z",
        "body": "I think `ObjectLiteral` is not 1:1 with `Entity`. There are some processes between converting raw data into entity."
      }
    ]
  },
  {
    "number": 4034,
    "title": "How to force create when call save()?",
    "created_at": "2019-04-23T19:46:39Z",
    "closed_at": "2019-08-10T18:58:12Z",
    "labels": [
      "question",
      "can be closed?"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/4034",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n\r\n**Database system/driver:**\r\n\r\n[x] `mysql`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n\r\nI'm  loading a entity with 13 entities dependents, and I have that duplicate this register.\r\nBut when I run my `user.findOne (id)` and after `user.save ()` he is updated, is there any possibility to force a new register for my main entity and dependencies?",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/4034/comments",
    "author": "nikoliveira",
    "comments": [
      {
        "user": "vlapo",
        "created_at": "2019-04-24T08:42:53Z",
        "body": "I really did not get you. Could you please provide some simple entity example and procedure of operations with expected and current behaviour?"
      },
      {
        "user": "nikoliveira",
        "created_at": "2019-04-24T12:39:18Z",
        "body": "I have a user and want duplicate this user. For exemple.\r\n\r\n`\r\nlet myUser = await User.findOne(\"abc-123\", {relations: [ \"skils\", \"equipaments\", \"avaliables\", ... ] });\r\nlet newUser = await myUser.create( );\r\n`\r\n\r\nThis new User I want that have  news \"skills\", \"equipments\", \"available\" too\r\n\r\n"
      },
      {
        "user": "Kononnable",
        "created_at": "2019-05-25T12:37:16Z",
        "body": "I guess you're just looking for javascript spread syntax. But remember to clone object without primary key properties(or delete them after cloning/change them if they're not autogenerated by db).\r\n```typescript\r\nconst x = new Ingredient();\r\nx.name = 'a';\r\nawait x.save();\r\nconst y = Ingredient.create({ ...x, id:undefined })\r\nawait y.save();\r\n```"
      },
      {
        "user": "rustamwin",
        "created_at": "2019-08-10T18:58:12Z",
        "body": "No answer from the author. Closing"
      }
    ]
  },
  {
    "number": 4018,
    "title": "Incompatible with typescript strict mode",
    "created_at": "2019-04-20T00:07:12Z",
    "closed_at": "2020-10-05T06:00:44Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/4018",
    "body": "Using typeorm in a `strict: true` project makes it behave in the wrong way.\r\n\r\n**Issue type:**\r\n\r\n[ ] question\r\n[x] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[ ] `cockroachdb`\r\n[x] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n[x] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\n```shell\r\n$ typeorm init --db sqlite\r\n$ npm i\r\n```\r\n\r\n1) Add `strict: true` in `tsconfig.json`\r\n2) Fix all properties in `src/User.ts` from `<property>: <type>` to `<property>!: <type>`\r\n3) `ts-node src/index.ts`\r\n\r\nResult:\r\n```\r\n$ ts-node src/index.ts\r\n\r\nC:\\Users\\valerio\\AppData\\Roaming\\npm\\node_modules\\ts-node\\src\\index.ts:240\r\n    return new TSError(diagnosticText, diagnosticCodes)\r\n           ^\r\nTSError: ⨯ Unable to compile TypeScript:\r\n\r\n9     user.firstName = \"Timber\";\r\n      ~~~~~~~~~~~~~~\r\n\r\nsrc/index.ts(9,5): error TS2322: Type '\"Timber\"' is not assignable to type 'boolean'.\r\n\r\n10     user.lastName = \"Saw\";\r\n       ~~~~~~~~~~~~~\r\n\r\nsrc/index.ts(10,5): error TS2322: Type '\"Saw\"' is not assignable to type 'boolean'.\r\n\r\n11     user.age = 25;\r\n       ~~~~~~~~\r\n\r\nsrc/index.ts(11,5): error TS2322: Type '25' is not assignable to type 'boolean'.\r\n\r\n    at createTSError (C:\\Users\\valerio\\AppData\\Roaming\\npm\\node_modules\\ts-node\\src\\index.ts:240:12)\r\n    at reportTSError (C:\\Users\\valerio\\AppData\\Roaming\\npm\\node_modules\\ts-node\\src\\index.ts:244:19)\r\n    at getOutput (C:\\Users\\valerio\\AppData\\Roaming\\npm\\node_modules\\ts-node\\src\\index.ts:360:34)\r\n    at Object.compile (C:\\Users\\valerio\\AppData\\Roaming\\npm\\node_modules\\ts-node\\src\\index.ts:393:11)\r\n    at Module.m._compile (C:\\Users\\valerio\\AppData\\Roaming\\npm\\node_modules\\ts-node\\src\\index.ts:439:43)\r\n    at Module._extensions..js (internal/modules/cjs/loader.js:712:10)\r\n    at Object.require.extensions.(anonymous function) [as .ts] (C:\\Users\\valerio\\AppData\\Roaming\\npm\\node_modules\\ts-node\\src\\index.ts:442:12)\r\n    at Module.load (internal/modules/cjs/loader.js:600:32)\r\n    at tryModuleLoad (internal/modules/cjs/loader.js:539:12)\r\n    at Function.Module._load (internal/modules/cjs/loader.js:531:3)\r\n```\r\n\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/4018/comments",
    "author": "colthreepv",
    "comments": [
      {
        "user": "Kononnable",
        "created_at": "2019-04-27T19:17:37Z",
        "body": "First of all I wouldn't call adding `!` as fixing properties. You're just telling compiler that property value will never be undefined which isn't true.\r\nHowever I tried to reproduce the issue and failed. It worked as expected for me.\r\nIt looks like you've placed `!` in the wrong place(and made a conversion to boolean) or something similar.\r\n\r\nPlease check your code and if you don't see anything suspicious paste code here(or put it under github repo)."
      },
      {
        "user": "colthreepv",
        "created_at": "2019-04-29T09:03:32Z",
        "body": "I will try to reproduce inside a docker container.\r\nIf so will create a repository.\r\n\r\nI written entities this way\r\n\r\n```\r\n@Column()\r\nsomeField!: string\r\n```\r\nIt seemed to make typescript happy\r\n\r\nThanks for looking into it "
      },
      {
        "user": "ejose19",
        "created_at": "2020-04-29T01:13:45Z",
        "body": "@Kononnable from your comment I get that you don't recommend using ! on Entity definition, is that correct? So what do you do instead to work with \"strict\": true? I see \"strictPropertyInitialization\": false can be used but the drawback is that all non entity classes will miss that feature."
      },
      {
        "user": "Kononnable",
        "created_at": "2020-04-29T21:34:09Z",
        "body": "It really depends on 'how strict' you want to be. The only options with check enabled is lying to compiler(`!`) or adding (`| undefined` or `?`) to every column. Second option is rarely a good solution, because we would have to always check if value is undefined.\r\nAs for the lying part - most of the times it will work as developer wants. However don't always get this value, e.g. we can disable it in a select(or not join the table if it is done on a relationship) and value returned will be undefined. And here comes a dilemma(and personal preference) - should we enable the check and lie to the compilator - when we face this 'bug' no obvious solution to why value is undefined will be find, or disable check and by looking on tsconfig we should be able to tell how are undefined values introduced here.\r\nWhen we look just at the entity reason would be obvious, but if undefined value was already copied somewhere it might be much harder to knew why it is set to undefined while type system tells different story.\r\n\r\nTypeorm is not really compatible with strictPropertyInitialization, it was designed long before such feature came int existence. It can work with this check(with those workarounds), but it's far from ideal.\r\n\r\n\r\nSidenote: At the time of original reply I didn't like `strictPropertyInitialization` very much. There was so many dependencies written without that rule, that I didn't see much value in enabling this setting(it was common that property which could not be initialized to not be marked as optional). Nowadays I don't know what I would choose. This strict check isn't bad, but it's problematic with code which initialize all of the fields in most cases(but there is still a possibility of field being uninitialized). The ideal solution would be to fix this in typeorm, but I don't see it happening anytime soon(or ever)."
      },
      {
        "user": "ejose19",
        "created_at": "2020-04-29T23:00:13Z",
        "body": "@Kononnable Thanks for your detailed reply, regarding select | relations, would be nice if typeorm when using a select modified the return type to be Pick<Entity, selectedValues> (and same for relations, innerJoin* and leftJoinAndMapMany would convert the relation property from ? to !)\r\n\r\nSince this is not the case and may not end up being implemented here, one solution would be doing those cast manually after querying, which depending on app complexity could be a decent workaround."
      }
    ]
  },
  {
    "number": 4013,
    "title": "How to use (OR) AND (OR) in where clause",
    "created_at": "2019-04-18T16:12:25Z",
    "closed_at": "2019-05-14T08:46:27Z",
    "labels": [
      "question",
      "can be closed?"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/4013",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[x] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[ ] `cockroachdb`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nHow to make these query with find options:\r\n\r\n```\r\nSELECT * FROM table WHERE (a = 1 or b = 2) and (c = 1 or d = 2);\r\n```",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/4013/comments",
    "author": "Menci",
    "comments": [
      {
        "user": "v1d3rm3",
        "created_at": "2019-04-21T11:37:54Z",
        "body": "I image that you want a deep description of this query in select query builder mode, but i think it doesn't exists.\r\nYou've to use:\r\n\r\n```\r\nquery\r\n.where('a = 1 OR b = 2')\r\n.andWhere('c = 1 OR d = 2')\r\n``` \r\nOr just use the `where` clause, it's you choose.\r\n"
      },
      {
        "user": "rustamwin",
        "created_at": "2019-05-14T08:46:27Z",
        "body": "Closing - no answer from the author."
      },
      {
        "user": "tusharsrivastava",
        "created_at": "2021-09-06T08:23:05Z",
        "body": "Hi Is there an answer available now?"
      }
    ]
  },
  {
    "number": 3988,
    "title": "How to delete in Closure table of Tree Entities? ",
    "created_at": "2019-04-13T11:25:29Z",
    "closed_at": "2021-05-18T21:47:26Z",
    "labels": [
      "question",
      "comp: tree tables",
      "driver: mysql",
      "driver: mariadb"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/3988",
    "body": "**Issue type:**\r\n[x] question\r\n\r\n**Database system/driver:**\r\n[x] `mysql` / `mariadb`\r\n\r\n**TypeORM version:**\r\n[x] `@next`\r\n\r\n```\r\n@Column({\r\n    length: 500,\r\n    default: '',\r\n  })\r\n  name: string\r\n\r\n@TreeParent()\r\n  parent: Comment\r\n\r\n  @TreeChildren({\r\n    cascade: true,\r\n  })\r\n  children: Comment[]\r\n```\r\nabove code, I want to delete a record, but error report: ` a foreign key constraint fails...`，and how to delete in this case ?",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/3988/comments",
    "author": "kaimiyang",
    "comments": [
      {
        "user": "Kononnable",
        "created_at": "2019-04-20T16:53:56Z",
        "body": "Is this a duplicate of #193? I think you want to achieve the same thing as described there."
      }
    ]
  },
  {
    "number": 3980,
    "title": "Field value letter casing when trying to update a row",
    "created_at": "2019-04-11T21:16:21Z",
    "closed_at": "2019-04-25T07:15:46Z",
    "labels": [
      "question",
      "can be closed?",
      "comp: manager and repository"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/3980",
    "body": "**Issue type:**\r\n\r\n[ ] question\r\n[x] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[x] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[ ] `cockroachdb`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nI got an issue updating an object through repository.save(). It's about letter casing.\r\n\r\nWhen we have an object e.g. User with properties \"email\" ( string / varchar(128) ) and \"active\" (tinyint) and we update only \"email\" to it's lowercase, we can get an update executed properly.\r\nBut when we change both fields e.g. \"email\" to lowercase and \"active\" to another value (0 -> 1) and perform an update, \"email\" field doesn't change and still contains upercase letters.\r\n\r\nI think that letter casing change is only tracked when the field is the only one in a fieldset that is changed before we call an update.\r\n\r\n`\r\n\r\n    let repo = getConnection().getRepository(User);\r\n\r\n    repo.find().then((result: User[]) => {\r\n    \r\n        for(var r in result){\r\n            let row = result[r];\r\n            if(row.email != row.email.toUpperCase()) row.email = row.email.toUpperCase();\r\n            row.active ? row.active = 0 : row.active = 1;\r\n            repo.save(row);\r\n        }\r\n\r\n    })\r\n\r\n`\r\n\r\nthat's the quite common example of an issue: when `row.active` is changed to another value and `row.email` is changed to it's lowercase, 'email' field does not update in a database after `repo.save()` call. However, if we remove `row.active` field change from a code, 'email' field updates properly.",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/3980/comments",
    "author": "zelbov",
    "comments": [
      {
        "user": "vlapo",
        "created_at": "2019-04-13T14:45:31Z",
        "body": "This have to be problem in your code. \r\n\r\n`repo.save(row);` is async operation. You have to handle it properly. Code you posted is wrong and it will not work properly."
      },
      {
        "user": "rustamwin",
        "created_at": "2019-04-25T07:15:46Z",
        "body": "Closing, no response from author"
      }
    ]
  },
  {
    "number": 3972,
    "title": "Manual entity transform",
    "created_at": "2019-04-10T08:55:45Z",
    "closed_at": "2019-04-13T15:07:10Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/3972",
    "body": "**Issue type:**\r\n\r\n[x ] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[x ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[ ] `cockroachdb`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[ x] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\nI query the system-version table with raw sql, since afaik I can't do that with built methods or querybuilder.\r\n```\r\nreturn this.repoResult.query(`SELECT * FROM result **FOR SYSTEM_TIME ALL** WHERE id = ?`, [ id ]);\r\n```\r\nIt works as expected but I'd like to use the result as entity, because one of my fields is a simple-json which is not parsed. I can do it manually of course, but I prefer a better way if it exists.\r\n\r\nSo my question is: is there any example about manual entity transformation? I just like to use what typeorm uses. Or is there a way to use the querybuilder with database specific addons?\r\n\r\nThank you,\r\n\r\ntano\r\n\r\n<!--\r\n    To answer those questions you need to put \"x\" inside the square brackets, for example:\r\n    [x] `mysql`\r\n    [ ] `postgres`\r\n\r\n    Also, please format your code properly (by taking code blocks into ```ts .... ```)\r\n!>\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/3972/comments",
    "author": "ssi-hu-tasi-norbert",
    "comments": [
      {
        "user": "vlapo",
        "created_at": "2019-04-13T15:07:10Z",
        "body": "Hi @ssi-hu-tasi-norbert. Typeorm use some classes to transform raw results from database into entities. But it is internal behaviour of typeorm and we do not provide any exposed api to transform results into entities. You have to transform your query result into class by yourself :)"
      },
      {
        "user": "ozknemoy",
        "created_at": "2020-01-14T11:05:22Z",
        "body": "i write method for this \r\n```\r\nstatic transformEntityManual(entity, _obj) {\r\n    let obj = __.copy(_obj);\r\n    \r\n    connection.getMetadata(entity).columns.forEach(col => {\r\n      const prop = col.propertyName;\r\n      if(col.transformer && obj.hasOwnProperty(prop)) {\r\n        obj[prop] = col.transformer.to( obj[prop])\r\n      }\r\n\r\n    });\r\n    return obj\r\n\r\n  }\r\n```"
      },
      {
        "user": "Helveg",
        "created_at": "2024-08-10T16:28:04Z",
        "body": "The `col.transformer` doesn't work for me in `typeorm@0.3.20`, instead I use this:\r\n\r\n```ts\r\nfunction transformRaw(dataSource: DataSource, entity: Type, raw: Record<string, any>) {\r\n  const metadata = dataSource.getMetadata(entity);\r\n  const obj = metadata.create();\r\n  for (const col of metadata.columns) {\r\n    col.setEntityValue(obj, dataSource.driver.prepareHydratedValue(raw[col.databaseName], col);\r\n  }\r\n  return obj;\r\n}\r\n```\r\n\r\nThe key piece of the puzzle is `dataSource.driver.prepareHydratedValue` which converts the raw db value to the entity value.\r\n\r\nIt doesn't deal with relationships or any other fancy features, just the plain columns."
      }
    ]
  },
  {
    "number": 3945,
    "title": "how to get the foreign's ID?",
    "created_at": "2019-04-05T22:54:52Z",
    "closed_at": "2019-04-09T18:12:13Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/3945",
    "body": "**Issue type:**\r\n\r\n[X] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[x] `postgres`\r\n[ ] `cockroachdb`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\nHello,\r\n\r\nI have two tables here: User and UserInfo\r\nand their relationship is one to one. And the architecture in User like:\r\n\r\n> column_name\r\n> id\r\n> name\r\n> userInfoId\r\n\r\n\r\n\r\nand for me, I do not want directly get the useinfo with the code:\r\n```js\r\ngetRepository(User).createQueryBuilder(\"user\").leftJoinAndSelect(\"user.userInfo\", \"userInfo\").getOne();\r\n```\r\nI hope I can get the userinfoid when I call \r\n```js\r\ngetRepository(User).getOne();\r\n=> user{\r\n id:1\r\nname:\"bubble\"\r\nuserinfoid:1\r\n}\r\n```\r\nIs it possible?",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/3945/comments",
    "author": "Vbubblery",
    "comments": [
      {
        "user": "vlapo",
        "created_at": "2019-04-08T09:02:20Z",
        "body": "Please provide entity definitions."
      }
    ]
  },
  {
    "number": 3939,
    "title": "Using TypeORM with custom mapping to an existing DB structure",
    "created_at": "2019-04-04T17:45:34Z",
    "closed_at": "2019-04-21T07:18:40Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/3939",
    "body": "**Issue type:**\r\n\r\n[X] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[X] `postgres`\r\n[ ] `cockroachdb`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[X] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Question**\r\n\r\nIs there a way to use TypeORM without schema creation, with a custom mapping to plug it to an existing DB?\r\n\r\nThe goal is to have the flexibility of either letting the user of the project have the database created, or use one existing database (for example for user base).\r\n\r\nThanks!",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/3939/comments",
    "author": "mremond",
    "comments": [
      {
        "user": "Kononnable",
        "created_at": "2019-04-20T13:29:11Z",
        "body": "You can disable schema sync - then no structure of database tables will be changed. You will be able to use typeorm just fine if your entity models are compatible with tables in db."
      }
    ]
  },
  {
    "number": 3936,
    "title": "Update",
    "created_at": "2019-04-04T04:53:00Z",
    "closed_at": "2019-04-08T10:46:59Z",
    "labels": [
      "question",
      "needs more info"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/3936",
    "body": "**Issue type:**\r\n\r\n[X ] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ X] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[ ] `cockroachdb`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[X ] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\n<!--\r\n    To answer those questions you need to put \"x\" inside the square brackets, for example:\r\n    [x] `mysql`\r\n    [ ] `postgres`\r\n\r\n    Also, please format your code properly (by taking code blocks into ```ts .... ```)\r\n!>\r\nHi Gurus at typeorm,\r\n\r\nI tried typeorm to update but it does not override item instead it created a new document.\r\nWhen I tried findOne or find using Id, result is always null.\r\nCan someone please kindly provide samples so that I can use typeorm at ease on mongodb?",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/3936/comments",
    "author": "ybchoo",
    "comments": [
      {
        "user": "premalatha-bv",
        "created_at": "2019-04-04T09:37:35Z",
        "body": "when am trying to update the many to many relations tables. It is getting updated successfully, but the relation mapping table data gets cleared.\r\n\r\nAm I doing anything wrong.\r\n\r\nvar parentTableRepo = createConnection().getRepoistory('parentTable');\r\nvar parentTable = {\r\n    id: 1,\r\n    name: 'xyz',\r\n   Childs: {\r\n      id: 2,\r\n      name: 'abc'\r\n   }\r\n}\r\nparentTableRepo.save(parentTable); //saves successfully\r\n// the mapping table parentTable_childTable data is cleared. which has the parentTable id and child Table id."
      },
      {
        "user": "vlapo",
        "created_at": "2019-04-08T10:46:59Z",
        "body": "Closing as no description of problem. Feel free reopen with description and formatted code."
      }
    ]
  },
  {
    "number": 3928,
    "title": "Which reference should I better use in that case?",
    "created_at": "2019-04-02T11:05:46Z",
    "closed_at": "2019-05-29T09:50:06Z",
    "labels": [
      "question",
      "can be closed?"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/3928",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[x] `postgres`\r\n[ ] `cockroachdb`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[ ] `latest`\r\n[x] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\nLet's suppose I have 2 models, `LocalizedString` and `Answer`. `LocalizedString` contains three fields: `locale`, `key`, `value`. `Answer` should connect `LocalizedString` by `LocalizedString.key` but I can't figure a way to do this. `Answer` may contain multiple locale strings which may be connected by `key`.\r\n\r\nWhich decorator should I use to reference `key`? So I don't have to add dedicated field to `LocalizedString` like:\r\n```typescript\r\n// What I'm trying to avoid\r\n@ManyToOne(type => Answer, d => d.locales)\r\n  public answer: Question;\r\n```\r\nWhat I'm trying to achieve\r\n```typescript\r\n@Entity()\r\nexport class LocalizedString extends BaseEntity {\r\n  @Column()\r\n  public key: string;\r\n\r\n  @Column({ default: 'en_US' })\r\n  public locale: string = 'en_US';\r\n\r\n  @Column({ default: '' })\r\n    public value: string;\r\n  }\r\n}\r\n\r\n@Entity()\r\nexport class Answer extends BaseEntity {\r\n   // *How do I reference LocalizedString here by its key so I can load it later with relations?*\r\n   @Column({ nullable: true })\r\n   public localeKey: string;\r\n}\r\n```",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/3928/comments",
    "author": "blitss",
    "comments": [
      {
        "user": "Kononnable",
        "created_at": "2019-04-19T19:44:38Z",
        "body": "I'm not sure what you're trying to achieve - you want to represent OneToMany relationship without ManyToOne decorator?"
      },
      {
        "user": "blitss",
        "created_at": "2019-04-19T19:49:39Z",
        "body": "@Kononnable I wanna join multiple `LocalizedString` entities using `key` field. As I am aware, this is not possible yet, so I dealt with it another way.\r\nSomething like:\r\n`SELECT * FROM answer INNER JOIN localized_string ls on question.localeKey = ls.\"key\"` is what I was trying to achieve."
      },
      {
        "user": "Kononnable",
        "created_at": "2019-04-19T21:13:40Z",
        "body": "Oh, you want to add a 'relation'(answer<->localized_string) based on joining through another table(question). Typeorm decorators like @ManyToOne represents relations in databse - such relations can connect only two tables.\r\nYou can however add property with getter in your entity class which would get the data you want."
      },
      {
        "user": "rustamwin",
        "created_at": "2019-05-29T09:50:06Z",
        "body": "no answer from the author, closing."
      },
      {
        "user": "blitss",
        "created_at": "2019-07-15T18:50:10Z",
        "body": "never mind, figured it out.\r\n\r\nShould use OneToMany – ManyToOne kind of relation in that case.\r\nI was dumb to see what they were really doing."
      }
    ]
  },
  {
    "number": 3927,
    "title": "Massive RAM consumption (NodeJS, Docker)",
    "created_at": "2019-04-01T18:28:24Z",
    "closed_at": "2020-10-01T06:06:56Z",
    "labels": [
      "question",
      "performance"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/3927",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[x] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[x] `postgres`\r\n[ ] `cockroachdb`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nHi,\r\nI am using TypeORM with NestJS.\r\nJust turning it on with just one entity adds 70-80mb to the memory consumption which is massive. Any other NestJS module use that much. With e.g. mongoose or Typegoose it is just 2-3mb of RAM.\r\nAny idea why and how to solve it?\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/3927/comments",
    "author": "murbanowicz",
    "comments": [
      {
        "user": "Kononnable",
        "created_at": "2019-04-05T22:55:56Z",
        "body": "Can you provide simple reproduction repo? Even potentially small change can introduce big difference in RAM utilization. That's why it would be much easier to investigate it on actual example.\r\nAlso usage of ts-node is very important - for simple project with ts-node it took 100.59 MB RAM, while only 25.12 MB with precompiled js files."
      }
    ]
  },
  {
    "number": 3924,
    "title": "Connecting to mssql server",
    "created_at": "2019-04-01T11:49:04Z",
    "closed_at": "2019-04-18T20:53:21Z",
    "labels": [
      "question",
      "comp: configuration",
      "driver: mssql"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/3924",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[x] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[ ] `cockroachdb`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nDone everything as shown in examples of typeorm website but i'm getting error of localhost dosent found any port number. I have checked port numbers also. Please provide a answer",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/3924/comments",
    "author": "trithesh",
    "comments": [
      {
        "user": "vlapo",
        "created_at": "2019-04-02T17:38:29Z",
        "body": "Hey @trithesh. Please provide more info: connection configuration, full text of error and we will try help you. But from your modest description I think this is problem on your site. "
      },
      {
        "user": "Kononnable",
        "created_at": "2019-04-18T20:53:21Z",
        "body": "Closing as no response from the author."
      }
    ]
  },
  {
    "number": 3916,
    "title": "Problem creating entities to reproduce a Many to Many with added attributes.",
    "created_at": "2019-03-28T22:37:07Z",
    "closed_at": "2020-10-03T05:10:55Z",
    "labels": [
      "question",
      "can be closed?",
      "comp: relations"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/3916",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[x] `postgres`\r\n[ ] `cockroachdb`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[ ] `latest`\r\n[ ] `@next`\r\n[x] `0.2.16` \r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nI have two main entities: User and Challenges.\r\nThey have a many to many relationship. Considering I need other attributes in this junction table, after reading about it, I manually created another entity called UserChallenges. I want the three of them to be like this:\r\n\r\nUser:\r\n- id (PK)\r\n- f_name\r\n- l_name\r\n- email\r\n- password\r\n\r\nChallenge:\r\n- id (PK)\r\n- description\r\n// other attributes\r\n\r\nUserChallenge:\r\n- userId (PK, FK)\r\n- challengeId (PK, FK)\r\n- score\r\n- date (PK)\r\n// other attributes\r\n\r\nSo, for this third table I need a composite primary key of userId, challengeId and date.\r\n\r\nThe following are my entities:\r\n\r\nUser:\r\n\r\n```\r\nimport { Entity, PrimaryGeneratedColumn, Column, OneToMany } from \"typeorm\";\r\nimport { UserChallenge } from './UserChallenge';\r\n\r\n@Entity('users')\r\nexport class User {\r\n\r\n  @PrimaryGeneratedColumn()\r\n  public id!: number;\r\n\r\n  @Column({nullable: false})\r\n  public f_name!: string;\r\n\r\n  @Column({nullable: false})\r\n  public l_name!: string;\r\n\r\n  @Column({nullable: false})\r\n  public email!: string;\r\n\r\n  @Column({nullable: false})\r\n  public password!: string;\r\n\r\n  @OneToMany(type => UserChallenge, UserChallenge => UserChallenge.user)\r\n  public challenges!: UserChallenge[];\r\n\r\n  public constructor(\r\n    f_name: string,\r\n    l_name: string,\r\n    email: string,\r\n    password: string\r\n  ){\r\n    this.f_name = f_name;\r\n    this.l_name = l_name;\r\n    this.email = email;\r\n    this.password = password;\r\n  }\r\n\r\n}\r\n```\r\n\r\nChallenge:\r\n\r\n```\r\nimport { Entity, PrimaryGeneratedColumn, Column, OneToMany } from \"typeorm\";\r\nimport { UserChallenge } from \"./UserChallenge\";\r\n\r\nexport enum ChallengeLevel {\r\n  BASIC = \"basic\",\r\n  INTERMEDIATE = \"intermediate\",\r\n  ADVANCED = \"advanced\"\r\n}\r\n\r\n\r\n@Entity('challenges')\r\nexport class Challenge {\r\n\r\n  @PrimaryGeneratedColumn()\r\n  public id!: number;\r\n\r\n  @Column({nullable: false, unique: true})\r\n  public title!: string;\r\n\r\n  @Column({nullable: false, type: 'longtext'})\r\n  public description!: string;\r\n\r\n  @Column({nullable: false, type: 'longtext'})\r\n  public appFile!: string;\r\n\r\n  @Column({nullable: false, type: 'longtext'})\r\n  public testFile!: string;\r\n\r\n  @Column({nullable: false, type: 'longtext'})\r\n  public sampleAnswer!: string;\r\n\r\n  @OneToMany(type => UserChallenge, UserChallenge => UserChallenge.challenge)\r\n  public attempts!: UserChallenge[];\r\n\r\n  @Column({\r\n    nullable: false,\r\n    type: 'enum',\r\n    enum: ChallengeLevel,\r\n    default: ChallengeLevel.INTERMEDIATE\r\n  })\r\n  public level!: string;\r\n\r\n  public constructor(\r\n    title: string,\r\n    description: string,\r\n    sampleAnswer: string,\r\n    level: string,\r\n    appFile: string,\r\n    testFile: string\r\n  ){\r\n    this.title = title;\r\n    this.description = description;\r\n    this.sampleAnswer = sampleAnswer;\r\n    this.level = level;\r\n    this.appFile = appFile;\r\n    this.testFile = testFile;\r\n  }\r\n\r\n}\r\n\r\n```\r\n\r\nUserChallenge:\r\n\r\n``` \r\nimport { Entity, PrimaryGeneratedColumn, Column, Index, CreateDateColumn, PrimaryColumn, ManyToOne, JoinColumn, Unique } from \"typeorm\";\r\nimport { Challenge } from \"./Challenge\";\r\nimport { User } from \"./User\";\r\n\r\n\r\n@Entity('users_challenges')\r\n@Unique([\"userId\", \"challengeId\", \"date\"])\r\nexport class UserChallenge {\r\n\r\n  @Column({nullable: false })()\r\n  @ManyToOne(type => User, user => user.challenges)\r\n  @JoinColumn()\r\n  public user!: User;\r\n\r\n  @Column({nullable: false, name: 'challengeId' })()\r\n  @ManyToOne(type => Challenge, challenge => challenge.attempts)\r\n  @JoinColumn()\r\n  public challenge!: Challenge;\r\n\r\n  @Column({nullable: false, name: 'date', type: 'datetime'})\r\n  public date!: Date;\r\n\r\n  @Column({type: 'int'})\r\n  public score!: number;\r\n\r\n  @Column({nullable: false})\r\n  public user_attempt!: string;\r\n\r\n  public constructor(\r\n    user: User,\r\n    challenge: Challenge,\r\n    date: Date,\r\n    score: number,\r\n    user_attempt: string\r\n  ){\r\n    this.user = user;\r\n    this.challenge = challenge;\r\n    this.date = date;\r\n    this.score = score;\r\n    this.user_attempt = user_attempt;\r\n  }\r\n\r\n}\r\n\r\n```  \r\n\r\nWhen I try to run this, I get TypeError on UserChallenge.\r\n\r\nI've been trying many different things without success.\r\n\r\nI really appreciate your help! And thank you for developing such useful ORM.",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/3916/comments",
    "author": "gustavolessa23",
    "comments": [
      {
        "user": "vlapo",
        "created_at": "2019-03-29T12:06:19Z",
        "body": "Hey @gustavolessa23. You have a wrong syntax. `@Column({nullable: false })()` should be only `@Column({nullable: false })` without `()` in the end. But you are using `@Column` before `@ManyToOne` and it is wrong. Change your definition to:\r\n```ts\r\n  @ManyToOne(type => User, user => user.challenges)\r\n  @JoinColumn()\r\n  public user!: User;\r\n\r\n  @ManyToOne(type => Challenge, challenge => challenge.attempts)\r\n  @JoinColumn()\r\n  public challenge!: Challenge;\r\n```  \r\nIf you need `userId` and `challengeId` in your entity define it as separate properties:\r\n```ts\r\n  @Column()\r\n  public userId!: number;\r\n\r\n  @Column()\r\n  public challengeId!: number;\r\n```"
      },
      {
        "user": "Kononnable",
        "created_at": "2019-04-06T10:36:19Z",
        "body": "`@RelationId()` would probably work a bit better then `@Column()` if you want to have both relation field(field of related entity type), and separate field for related entity id."
      },
      {
        "user": "vlapo",
        "created_at": "2019-06-18T10:34:40Z",
        "body": "@gustavolessa23 did you resolve this problem?"
      }
    ]
  },
  {
    "number": 3898,
    "title": "entity relation @where annotation",
    "created_at": "2019-03-26T06:30:10Z",
    "closed_at": "2020-10-17T09:03:24Z",
    "labels": [
      "question",
      "new feature",
      "comp: relations",
      "driver: postgres"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/3898",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[ ] bug report\r\n[x] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[x] `postgres`\r\n[ ] `cockroachdb`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\nAre there any plans to support a @where clause annotation in an entity for denoting a relation which is always conditionally joined?\r\nHere's an example of how Hibernate annotates it to show what I'm describing:\r\n\r\n```\r\npublic class Parent {\r\n  ...\r\n  @ManyToOne(fetch = FetchType.EAGER) // EAGER forces outer join\r\n  @JoinColumn(name = \"parent_id\")\r\n  @Where(clause = \"parent_id = id AND disabled IS NULL\")\r\n  // ...\r\n}\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/3898/comments",
    "author": "ajxs",
    "comments": [
      {
        "user": "vlapo",
        "created_at": "2019-03-27T09:18:23Z",
        "body": "I am sure I see this kind of FR before but cannot find it. But it was discussed and I think it is in 0.3.0 roadmap. But it is not clear when it will be implemented."
      },
      {
        "user": "imnotjames",
        "created_at": "2020-10-17T09:03:24Z",
        "body": "Duplicate of #1601"
      }
    ]
  },
  {
    "number": 3875,
    "title": "Mysql bit(1) not converted to boolean. How to map this type?",
    "created_at": "2019-03-22T09:07:54Z",
    "closed_at": "2019-03-27T10:37:54Z",
    "labels": [
      "question",
      "driver: mysql"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/3875",
    "body": "**Issue type:**\r\n\r\n[ x] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ x] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[ ] `cockroachdb`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[ x] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nEntity Framework generated bool columns as bit(1) in mysql. When i map those columns in typeorm as bit type and boolean property type they do not read as true/false from db. Instead those props read as complex object. Expected true or false.\r\nHow to properly bind boolean to mysql bit(1) column?\r\n\r\n```\r\n@Column({\r\n    type: 'bit',\r\n    nullable: false,\r\n    default: () => `\"'b'1''\"`,\r\n    name: 'can_read'\r\n  })\r\n can_read!: boolean;\r\n```\r\n\r\n// After db read i receive:\r\n```\r\nconst user = await this.workersRepository.findOne({ login: username });\r\nuser.can_read // Buffer(1) [0] <= Here must be false\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/3875/comments",
    "author": "squalsoft",
    "comments": [
      {
        "user": "squalsoft",
        "created_at": "2019-03-22T15:06:17Z",
        "body": "I can resolve this issue with transformer:\r\n\r\n```\r\nclass BoolBitTransformer implements ValueTransformer {\r\n  // To db from typeorm\r\n  to(value: boolean | null): Buffer | null {\r\n    if (value === null) {\r\n      return null;\r\n    }\r\n    const res = new Buffer(1);\r\n    res[0] = value ? 1 : 0;\r\n    return res;\r\n  }\r\n  // From db to typeorm\r\n  from(value: Buffer): boolean | null {\r\n    if (value === null) {\r\n      return null;\r\n    }\r\n    return value[0] === 1;\r\n  }\r\n}\r\n```\r\nAnd then\r\n\r\n```\r\n  @Column({\r\n    type: 'bit',\r\n    nullable: false,\r\n    default: () => `\"'b'1''\"`,\r\n    name: 'can_read',\r\n    transformer: new BoolBitTransformer()\r\n  })\r\n  can_read!: boolean;\r\n```\r\n\r\n\r\nBut maybe it exists more comfortable solution?"
      },
      {
        "user": "vlapo",
        "created_at": "2019-03-27T10:37:54Z",
        "body": "We are mapping boolean into `tinyint` as DB type for mysql driver. So your solution with transformer is only possible solution for now."
      },
      {
        "user": "webtimo-de",
        "created_at": "2022-12-16T09:29:05Z",
        "body": "Hello, so I have another question. If I then want to search for something with \"where\" and I want to have all \"true\", he can't translate that.\r\n\r\n\r\n```\r\nlet list = await StaffFile.find({\r\n    where: {\r\n        hasBeenNotified: true\r\n    }\r\n});\r\n```"
      },
      {
        "user": "webtimo-de",
        "created_at": "2023-02-18T17:38:45Z",
        "body": "Hello folks, I found a solution because I personally found the fact that typeorm does not offer bit(1) as a boolean in MySQL, found another solution!\r\nTypeORM has a Raw() function, or the In() function.\r\n\r\nHowever, the BoolBitTransformer must be changed for this.\r\n\r\n```typescript\r\nimport {FindOperator, ValueTransformer} from 'typeorm';\r\n\r\nexport class BoolBitTransformer implements ValueTransformer {\r\n    // To db from typeorm\r\n    to(value: boolean | null): Buffer | null {\r\n        if ((value as any) instanceof FindOperator) {\r\n            return <any>value;\r\n        }\r\n        if (value === null) {\r\n            return null;\r\n        }\r\n        const res = Buffer.alloc(1);\r\n        res[0] = value ? 1 : 0;\r\n        return res;\r\n    }\r\n\r\n    // From db to typeorm\r\n    from(value: Buffer): boolean | null {\r\n        if (value === null) {\r\n            return null;\r\n        }\r\n        return value[0] === 1;\r\n    }\r\n}\r\n```\r\n\r\nAnd if you now want to search for true or false, you have to specify this in the query.\r\n\r\nRaw() Function:\r\n```typescript\r\nconst boolean: boolean = true; // true, false\r\nconst data = await Staff.find({\r\n    where: {\r\n        active: boolean ? Raw('true') : Raw('false') \r\n    }\r\n});\r\n```\r\n\r\nIn() Function:\r\n```typescript\r\nconst boolean: boolean = true; // true, false, null\r\nconst data = await Staff.find({\r\n    where: {\r\n        active: In([boolean])\r\n    }\r\n});\r\n```\r\n\r\n\r\nPersonally, I prefer the In() function because you can also pass true, false and null here, even as a variable without any problems.\r\n\r\nSo I'll go and rewrite my code, I hope I could make life easier for others (:"
      },
      {
        "user": "ertl",
        "created_at": "2023-02-18T20:15:49Z",
        "body": "@webtimo-de, your workaround for the FindOperator assignment is excellent. It seems to be addressing the same issue as either #9381 or #9793. With the introduction of PR #9777, the extra if condition in your transformer is no longer required."
      }
    ]
  },
  {
    "number": 3865,
    "title": "Feature: Possibility to constraint decorators to a specific database type",
    "created_at": "2019-03-21T15:21:40Z",
    "closed_at": "2020-10-05T05:44:45Z",
    "labels": [
      "question",
      "comp: entity schemas"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/3865",
    "body": "**Issue type:**\r\n[x] feature request\r\n\r\n**Database system/driver:**\r\n\r\n[x] `mysql` / `mariadb`\r\n[x] `sqlite`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `0.2.6`\r\n\r\nCurrently we need to specify some options in a DBMS specific way, as noted in #2217.\r\n\r\nToday I hit another issue:\r\n```ts\r\n    @Column({ type: String, nullable: true, charset: \"utf8mb4\", collation: \"utf8mb4_unicode_ci\" })\r\n```\r\nThis works fine in MySQL but fails in SQLite, which makes sense because this collation is specific to MySQL.\r\n\r\nThe proposal is some way to define decorators that would apply only to a specific driver.\r\ne.g.:\r\n```ts\r\n    @Column({ type: String, nullable: true, charset: \"utf8\" })\r\n    @Column({ only: \"mysql\", type: \"varchar\", nullable: true, charset: \"utf8mb4\", collation: \"utf8mb4_unicode_ci\" })\r\n    description: string;\r\n```\r\n\r\nBoth decorators get applied to the same column. When using MySQL the second one overwrites the first one.\r\nIf a solution like is possible, it would empower developers that need to support different databases.",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/3865/comments",
    "author": "pmoleri",
    "comments": [
      {
        "user": "Kononnable",
        "created_at": "2019-04-04T09:15:25Z",
        "body": "If you want to use same schema with multiple db drivers you should use entity schemas to define your db structure. It's much better approach in such cases.\r\n\r\nAdding new decorator would make entity definition less readable and I think it would require major changes in typeorm code."
      },
      {
        "user": "imnotjames",
        "created_at": "2020-10-05T05:44:45Z",
        "body": "Unfortunately, this feature is not likely going to happen.  It makes the API much more difficult to document and use.  Per @Kononnable for the foreseeable future user entity schemas."
      }
    ]
  },
  {
    "number": 3864,
    "title": "Injecting dependencies into an entity or repository.",
    "created_at": "2019-03-21T12:14:48Z",
    "closed_at": "2019-04-20T22:56:26Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/3864",
    "body": "**Issue type:**\r\n\r\n[X] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[X] `postgres`\r\n[ ] `cockroachdb`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[ ] `latest`\r\n[ ] `@next`\r\n[X] `0.2.11` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\nIs there a way to inject clases from outside of the typeorm environment, like a class service. This is what i'm trying to do, but it doesn't work in any way:\r\n\r\n``` \r\n@Entity()\r\nexport class Users {\r\n  constructor(private readonly usersService: UsersService){}\r\n  @PrimaryGeneratedColumn()\r\n  @ApiResponseModelProperty()\r\n  id: number;\r\n}\r\n```\r\n\r\nUsersService being a declared class with dependencies injected into it.",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/3864/comments",
    "author": "CesarHuelamo",
    "comments": [
      {
        "user": "vlapo",
        "created_at": "2019-03-27T11:20:05Z",
        "body": "We do not know your environment :) so it is hard to help you with this problem. But I do not think so entity is right place to work with services. You should move this functionality to service or another place with business logic.\r\n\r\nNote: In current version of typeorm constructor parameters have to be optional (this is subject of change in `next` version)."
      },
      {
        "user": "ksuhiyp",
        "created_at": "2020-05-27T19:01:46Z",
        "body": "@vlapo I can give a use case of this, suppose we have an AWS service and we need to trigger deleteObject method from that service by using @BeforeRemove(), How could you do that?"
      },
      {
        "user": "neuro-sys",
        "created_at": "2020-09-07T11:06:18Z",
        "body": "@ksuhiyp\r\n\r\n> @vlapo I can give a use case of this, suppose we have an AWS service and we need to trigger deleteObject method from that service by using @BeforeRemove(), How could you do that?\r\n\r\nHow are you going to rollback if the database operation fails?\r\n\r\nThis is one of the reasons why (also in domain driven design patterns) entities don't do I/O themselves. And in the above specific case (AWS deleteObject), unless you have a global transaction manager, your best bet is to dispatch a persistent message which will be asynchronously processed outside your database transaction and be \"eventually consistent\"."
      }
    ]
  },
  {
    "number": 3862,
    "title": "Is it sql-injection safe if using `FindOption` direction in find?",
    "created_at": "2019-03-21T04:57:27Z",
    "closed_at": "2020-10-03T02:53:40Z",
    "labels": [
      "question",
      "comp: find options"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/3862",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[x] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[ ] `cockroachdb`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[] `latest`\r\n[ ] `@next`\r\n[x] `0.2.15` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nIs it sql-injection safe if using `FindOption` direction in find? for example:\r\nAs the document saying `raw()` is not sql injection safe, but how about other FindOption operation? \r\n\r\n```ts\r\n    typeorm.getRepository(User)\r\n        .find({\r\n            where: { name: typeorm.Like(`%${sqlInjectionVariable}%`) }\r\n        })\r\n```",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/3862/comments",
    "author": "SunnyTam",
    "comments": [
      {
        "user": "Kononnable",
        "created_at": "2019-04-04T09:23:04Z",
        "body": "If you run such query with logging enabled you can see that `sqlInjectionVariable` is passed as sql parameter - so yes, it's sql injection safe."
      }
    ]
  },
  {
    "number": 3861,
    "title": "How does Typeorm migration work to prevent data lose?",
    "created_at": "2019-03-21T03:26:17Z",
    "closed_at": "2020-10-03T02:55:42Z",
    "labels": [
      "question",
      "comp: migrations"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/3861",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[x] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[ ] `cockroachdb`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[ ] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nI am working on a project that wants to reform its backend structure using typeorm. One big thing is about losing data. I havnt seen any official documentation explaining the mechanism. Also, reading migrations.ts didnt help me figure it out. I noticed a similar issue was opened at #3147 . And no discussion was given on that. Is there a way to make sure data will not be lost when migration was run?",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/3861/comments",
    "author": "jyang0110",
    "comments": [
      {
        "user": "Kononnable",
        "created_at": "2019-04-04T08:55:20Z",
        "body": "Migrations just execute sql statements. If sql statements don't do anything unsafe then migration will be safe for data. After generating a migration you should always take a look at them and review if it's ok. There are cases when ORM is unable to know if it is able to alter the column without possibility of loosing data. In such cases you would have to modify generated queries on your own."
      }
    ]
  },
  {
    "number": 3836,
    "title": "Disable Cache Programmatically",
    "created_at": "2019-03-17T13:03:56Z",
    "closed_at": "2019-04-20T22:57:07Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/3836",
    "body": "**Issue type:**\r\n\r\n[ ] question\r\n[ ] bug report\r\n[x] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[x] `postgres`\r\n[ ] `cockroachdb`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n---\r\n\r\nIs there a way to disable cache for integration tests? ",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/3836/comments",
    "author": "thellimist",
    "comments": [
      {
        "user": "Kononnable",
        "created_at": "2019-04-02T10:08:17Z",
        "body": "Cache is enabled in connections options - you can just modify your connectionOptions if running under integration tests. You can also disable cache per specific query if you don't like to disable it completely(you're using same connection in multiple tests)."
      }
    ]
  },
  {
    "number": 3818,
    "title": "Can typeorm support connections to both mysql and oracle simultaneously?",
    "created_at": "2019-03-13T14:17:56Z",
    "closed_at": "2019-04-20T22:47:12Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/3818",
    "body": "**Issue type:**\r\n\r\n[x ] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[x ] `mysql` / `mariadb`\r\n[x ] `oracle`\r\n[ ] `postgres`\r\n[ ] `cockroachdb`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[x ] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\n I am trying to copy a table in MySQL to a table in Oracle.  Due to differences in the column types, once I open a connection for MySQL, I get errors when I try to open a connection to Oracle.   The only work around so far that I have found is to have two separate copies of the entities, but I would like to avoid this.   In the entities, I import in the column types in order to have flexibility between MySQL and Oracle, but it seems once a connection is made, the column types are fixed (thus I have separate copies as a work around).   Is there another way to accomplish this?  Thanks.\r\n\r\n\r\n<!--\r\n    To answer those questions you need to put \"x\" inside the square brackets, for example:\r\n    [x] `mysql`\r\n    [ ] `postgres`\r\n\r\n    Also, please format your code properly (by taking code blocks into ```ts .... ```)\r\n!>\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/3818/comments",
    "author": "cnneel",
    "comments": [
      {
        "user": "Kononnable",
        "created_at": "2019-03-19T23:17:40Z",
        "body": "You could use entity schemas instead of column decorators to define entities. This way you should be able to use same typeorm classes for different specific database types(which are compatible with each others)."
      }
    ]
  },
  {
    "number": 3816,
    "title": "Select certain tables from a db",
    "created_at": "2019-03-13T02:33:43Z",
    "closed_at": "2019-03-14T13:47:55Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/3816",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[ ] `cockroachdb`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nhi, I have a lot of tables in my mssql server db, as much as 3140, some of them with more than 250 fields.\r\nThere is any possibility to select only certain tables?\r\nThank you. \r\n\r\n<!--\r\n    To answer those questions you need to put \"x\" inside the square brackets, for example:\r\n    [x] `mysql`\r\n    [ ] `postgres`\r\n\r\n    Also, please format your code properly (by taking code blocks into ```ts .... ```)\r\n!>\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/3816/comments",
    "author": "vicenteserra",
    "comments": [
      {
        "user": "vlapo",
        "created_at": "2019-03-13T09:31:59Z",
        "body": "Do not understand your question. Could you please describe more whats a problem? Typeorm works only with defined entities and related tables. So just define entities you need and disable synchronization."
      },
      {
        "user": "vicenteserra",
        "created_at": "2019-03-14T13:47:55Z",
        "body": "Sorry, the issue is for the project typeorm-model-generator."
      }
    ]
  },
  {
    "number": 3789,
    "title": "Question: Is using getters only for properties possible in typeorm?",
    "created_at": "2019-03-09T18:25:09Z",
    "closed_at": "2020-05-29T02:49:46Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/3789",
    "body": "**Issue type:**\r\nI'm trying to build a demo app while following a DDD approach but i'm having some issues.\r\nWhen I try to save an entity with the code below using 'connection.manager.save()', I get the following error:\r\n\r\n> UnhandledPromiseRejectionWarning: TypeError: Cannot set property Name of #<CustomerEntity> which has only a getter at ColumnMetadata.setEntityValue\r\n\r\nIs typeorm using setters in the background? is there a way to write the above code while avoiding this error. Great lib by the way!\r\n\r\n[x] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[x ] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[x ] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\n ```\r\n @Entity(\"customer\")\r\n  export default class CustomerEntity {\r\n      private _name: string;\r\n\r\n      @Column({ \r\n        type: String, \r\n        name: \"name\"\r\n       })\r\n       public get Name(): string {\r\n          return this._name;\r\n       }\r\n\r\n      private constructor(name?: string){\r\n           if(!!name) this._name = name;\r\n      }\r\n\r\n      public static create(name: string): CustomerEntity {\r\n           if(!name) throw \"error name is required...\";\r\n           return new CustomerEntity(name);\r\n      }\r\n  }\r\n```\r\n<!--\r\n    To answer those questions you need to put \"x\" inside the square brackets, for example:\r\n    [x] `mysql`\r\n    [ ] `postgres`\r\n\r\n    Also, please format your code properly (by taking code blocks into ```ts .... ```)\r\n!>",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/3789/comments",
    "author": "marrionluaka",
    "comments": [
      {
        "user": "SamKhachatryan",
        "created_at": "2020-02-25T15:29:53Z",
        "body": "No as I know it's don't possible."
      }
    ]
  },
  {
    "number": 3767,
    "title": "Geography column insert data",
    "created_at": "2019-03-06T07:16:53Z",
    "closed_at": "2019-04-20T22:46:02Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/3767",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[x] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nThis is the location entity.\r\n\r\n```\r\nimport {\r\n    Entity,\r\n    PrimaryGeneratedColumn,\r\n    Column,\r\n    CreateDateColumn,\r\n    JoinColumn,\r\n    ManyToOne,\r\n} from 'typeorm';\r\n\r\nimport { TripEntity } from '../trip/trip.entity';\r\n\r\n@Entity('trip_locations')\r\nexport class LocationEntity {\r\n    @PrimaryGeneratedColumn()\r\n    id: number;\r\n\r\n    @Column({ type: 'geography', srid: 4326 })\r\n    location: string;\r\n\r\n    @CreateDateColumn({ type: 'timestamptz' })\r\n    createdAt: Date;\r\n\r\n    @ManyToOne(type => TripEntity, trip => trip.locations)\r\n    @JoinColumn()\r\n    trip: TripEntity;\r\n}\r\n```\r\n\r\nAnd I am inserting the geojson like this:\r\n\r\n```\r\nawait this.locationRepository.insert({\r\n            trip,\r\n            location: {\r\n                type: 'Point',\r\n                coordinates: [data.longitude, data.latitude]\r\n            },\r\n        });\r\n```\r\n\r\nIt gives me error:\r\n\r\n```\r\nsrc/location/location.service.ts(92,63): error TS2345: Argument of type '{ trip: any; location: { type: string; coordinates: number[]; }; }' is not assignable to parameter of type 'QueryPartialEntity<LocationEntity> | QueryPartialEntity<LocationEntity>[]'.\r\n  Type '{ trip: any; location: { type: string; coordinates: number[]; }; }' is not assignable to type 'QueryPartialEntity<LocationEntity>'.\r\n    Types of property 'location' are incompatible.\r\n      Type '{ type: string; coordinates: number[]; }' is not assignable to type 'string | (() => string)'.\r\n        Type '{ type: string; coordinates: number[]; }' is not assignable to type '() => string'.\r\n          Type '{ type: string; coordinates: number[]; }' provides no match for the signature '(): string'.\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/3767/comments",
    "author": "abhyuditjain",
    "comments": [
      {
        "user": "abhyuditjain",
        "created_at": "2019-03-06T07:47:27Z",
        "body": "I get this error when I use `JSON.stringify()`:\r\n\r\n```\r\nquery failed: INSERT INTO \"trip_locations\"(\"location\", \"createdAt\", \"tripId\") VALUES (ST_SetSRID(ST_GeomFromGeoJSON($1), 4326)::geography, DEFAULT, $2) RETURNING \"id\", \"createdAt\" -- PARAMETERS: [\"\\\"{\\\\\\\"type\\\\\\\":\\\\\\\"Point\\\\\\\",\\\\\\\"coordinates\\\\\\\":[77,27]}\\\"\",\"670732b059f047194371\"]\r\nerror: { error: unknown GeoJSON type\r\n    at Connection.parseE (/home/abhyuditjain/Code/Roadzen/telematics/node_modules/pg/lib/connection.js:555:11)\r\n    at Connection.parseMessage (/home/abhyuditjain/Code/Roadzen/telematics/node_modules/pg/lib/connection.js:380:19)\r\n    at Socket.<anonymous> (/home/abhyuditjain/Code/Roadzen/telematics/node_modules/pg/lib/connection.js:120:22)\r\n    at Socket.emit (events.js:189:13)\r\n    at Socket.EventEmitter.emit (domain.js:441:20)\r\n    at addChunk (_stream_readable.js:284:12)\r\n    at readableAddChunk (_stream_readable.js:265:11)\r\n    at Socket.Readable.push (_stream_readable.js:220:10)\r\n    at TCP.onStreamRead [as onread] (internal/stream_base_commons.js:94:17)\r\n  name: 'error',\r\n  length: 76,\r\n  severity: 'ERROR',\r\n  code: 'XX000',\r\n  detail: undefined,\r\n  hint: undefined,\r\n  position: undefined,\r\n  internalPosition: undefined,\r\n  internalQuery: undefined,\r\n  where: undefined,\r\n  schema: undefined,\r\n  table: undefined,\r\n  column: undefined,\r\n  dataType: undefined,\r\n  constraint: undefined,\r\n  file: 'lwgeom_pg.c',\r\n  line: '128',\r\n  routine: 'pg_error' }\r\n[Nest] 7481   - 3/6/2019, 1:16:21 PM   [ExceptionsHandler] unknown GeoJSON type +45ms\r\nQueryFailedError: unknown GeoJSON type\r\n    at new QueryFailedError (/home/abhyuditjain/Code/Roadzen/telematics/src/error/QueryFailedError.ts:9:9)\r\n    at Query.callback (/home/abhyuditjain/Code/Roadzen/telematics/src/driver/postgres/PostgresQueryRunner.ts:176:30)\r\n    at Query.handleError (/home/abhyuditjain/Code/Roadzen/telematics/node_modules/pg/lib/query.js:142:17)\r\n    at Connection.connectedErrorMessageHandler (/home/abhyuditjain/Code/Roadzen/telematics/node_modules/pg/lib/client.js:160:17)\r\n    at Connection.emit (events.js:189:13)\r\n    at Connection.EventEmitter.emit (domain.js:441:20)\r\n    at Socket.<anonymous> (/home/abhyuditjain/Code/Roadzen/telematics/node_modules/pg/lib/connection.js:125:12)\r\n    at Socket.emit (events.js:189:13)\r\n    at Socket.EventEmitter.emit (domain.js:441:20)\r\n    at addChunk (_stream_readable.js:284:12)\r\n```"
      },
      {
        "user": "Kononnable",
        "created_at": "2019-03-17T15:36:53Z",
        "body": "You marked it as question, yet I don't see any question in here :)\r\n\r\nGeoJSON is PostGIS type, do you have PostGIS installed on your db?"
      },
      {
        "user": "Kononnable",
        "created_at": "2019-04-20T22:46:02Z",
        "body": "Closing as no response from the author."
      },
      {
        "user": "hussainwali74",
        "created_at": "2021-05-09T20:24:33Z",
        "body": "@Kononnable  sir I have PostGis installed I am still getting the error unkown geojson.\r\n\r\nthis is my column:\r\n\r\n  @ApiProperty({\r\n    type: String,\r\n    title: 'current_location',\r\n    example: 'POINT(39.807222,-76.984722)',\r\n  })\r\n  @Index({ spatial: true })\r\n  @Column({\r\n    type: 'geometry',\r\n    srid: 4326,\r\n    nullable: true,\r\n    spatialFeatureType: 'Point',\r\n  })\r\n  current_location: string;\r\n\r\nplease help\r\n"
      },
      {
        "user": "alexphamhp",
        "created_at": "2023-03-20T09:51:01Z",
        "body": "Guys, I think the error comes from \r\n`@Column({\r\ntype: 'geometry\r\n})`\r\n\r\nIf you guys try with `@Column(\"geometry)`, it works"
      }
    ]
  },
  {
    "number": 3731,
    "title": "Question: How to keep all relations when only filtering by one of them",
    "created_at": "2019-02-28T10:42:23Z",
    "closed_at": "2019-03-01T04:38:35Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/3731",
    "body": "**Issue type:**\r\n\r\n[X] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[X] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[X] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nI have a User table and  a Category table, the relation is many-to-many,\r\n\r\nI want to select all users who are under a specific category.\r\n\r\n```ts\r\n    users = await userRepository\r\n      .createQueryBuilder('user')\r\n      .leftJoinAndSelect('user.categories', 'category')\r\n      .where('category.categoryId = :id', { id: catId})\r\n      .orderBy('user.age', 'DESC', 'NULLS LAST')\r\n      .getMany();\r\n```\r\n\r\nIt filters correct users, but under each user, only the requested category Id is kept. But I want to keep all the categories under each user. I did not find a similar question for this and did not find a solution in the docs.\r\n\r\ni.e.\r\n\r\n```ts\r\nusers = [\r\n{ id = 1, categories: [ cat1, cat2, cat3...] },\r\n{ id = 2, categories: [ cat1, cat2, cat3...] }\r\n...\r\n]\r\n```\r\n\r\nnot \r\n\r\n```ts\r\nusers = [\r\n{ id = 1, categories: [cat2] },\r\n{ id = 2, categories: [cat2] }\r\n...\r\n]\r\n```\r\n\r\nMy current solution is using findByIds with relations, passing in all the userIds got from the previous step,  I can get what I want but I don't think it is optimal.\r\n\r\nDoes anyone know how to handle such query?\r\n\r\nThanks a lot.\r\n\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/3731/comments",
    "author": "Sheng-Xuan",
    "comments": [
      {
        "user": "vlapo",
        "created_at": "2019-02-28T22:29:35Z",
        "body": "Just fast tip but try this:\r\n```typescript\r\nusers = await userRepository\r\n      .createQueryBuilder('user')\r\n      .leftJoin('user.categories', 'category')\r\n      .leftJoinAndSelect('user.categories', 'categorySelect')\r\n      .where('category.categoryId = :id', { id: catId})\r\n      .orderBy('user.age', 'DESC', 'NULLS LAST')\r\n      .getMany();\r\n```"
      },
      {
        "user": "Sheng-Xuan",
        "created_at": "2019-03-01T04:38:29Z",
        "body": "@vlapo That works. Thanks a lot! "
      }
    ]
  },
  {
    "number": 3726,
    "title": "Error: ER_ACCESS_DENIED_ERROR: Access denied for user 'test'@'localhost' (using password: YES)",
    "created_at": "2019-02-27T12:39:09Z",
    "closed_at": "2019-02-28T22:00:49Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/3726",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[x] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\n<!--\r\n    To answer those questions you need to put \"x\" inside the square brackets, for example:\r\n    [x] `mysql`\r\n    [ ] `postgres`\r\n\r\n    Also, please format your code properly (by taking code blocks into ```ts .... ```)\r\n!>\r\nMy computer is Mac, npm is lastest, node is v10.0.0\r\nI am new to learn typeorm, so I follow quick start\r\nafter i run \r\n```typeorm init --name MyProject --database mysql\r\ncd MyProject\r\nnpm install\r\nnpm start```\r\nIt's not working\r\nshow error ```Error: ER_ACCESS_DENIED_ERROR: Access denied for user 'test'@'localhost' (using password: YES)```\r\n\r\nplz tell me why\r\nDo I need to download mysql in www.mysql.com?",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/3726/comments",
    "author": "KAROTT7",
    "comments": [
      {
        "user": "KAROTT7",
        "created_at": "2019-02-27T12:41:16Z",
        "body": "I am new to learn typeorm\r\nI follow quick start to run this command\r\n```\r\ntypeorm init --name demo --database mysql\r\ncd demo\r\nnpm i\r\nnpm start\r\n```\r\nbut it doesn't work\r\nplz tell me"
      },
      {
        "user": "rustamwin",
        "created_at": "2019-02-27T13:18:35Z",
        "body": "you should configure your connection options in `ormconfig.json`"
      },
      {
        "user": "puttputt",
        "created_at": "2019-02-27T19:45:22Z",
        "body": "👍 to @rustamwin 's answer. \r\n\r\nThe error is showing because typeorm can't connect to your database.\r\nIt appears your database is running because you have received an authentication error. So check these things:\r\n- Ensure your configuration has the right user/pass configuration for localhost.\r\n- Ensure user 'test' has the permission to access the localhost database.\r\n"
      },
      {
        "user": "KAROTT7",
        "created_at": "2019-02-28T11:55:02Z",
        "body": "Thank @rustamwin and @puttputt  very much\r\nI am noob, now I need to learn mysql server"
      },
      {
        "user": "rustamwin",
        "created_at": "2019-02-28T12:14:40Z",
        "body": "Accordingly this issue can be closed @vlapo "
      }
    ]
  },
  {
    "number": 3676,
    "title": "Comparing entities with database table schema",
    "created_at": "2019-02-20T10:11:23Z",
    "closed_at": "2019-04-20T22:43:09Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/3676",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[ ] bug report\r\n[?] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[x] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\nI'm quite new to devops and I'm just deploying my first application thanks to TypeORM! 🎉\r\n\r\nWhen I deploy my application, I rely on deployed database migrations to make the production database reflect my entities. If for some reason however, the migrations aren't sufficient, the application is likely to crash. Between deploying a new version of the application and running the database migrations, I would like to confirm there are no diffs in the production database schema and the TypeORM entity schema. Any way I could do this? Or should this be unnecessary?",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/3676/comments",
    "author": "adamalfredsson",
    "comments": [
      {
        "user": "Kononnable",
        "created_at": "2019-03-15T22:01:59Z",
        "body": "To confirm your your db schema is up to date you can run something like that:\r\n```typescript\r\nconst schemaBuilder = connection.driver.createSchemaBuilder();\r\nconst syncQueries = await schemaBuilder.log();\r\nexpect(syncQueries.downQueries).to.be.eql([]);\r\nexpect(syncQueries.upQueries).to.be.eql([]);\r\n```"
      }
    ]
  },
  {
    "number": 3670,
    "title": "ER_TRUNCATED_WRONG_VALUE_FOR_FIELD on changing relationship type/column",
    "created_at": "2019-02-19T14:37:06Z",
    "closed_at": "2019-04-20T22:43:29Z",
    "labels": [
      "question",
      "comp: schema sync"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/3670",
    "body": "**Issue type:**\r\n\r\n[ ] question\r\n[x] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[x] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n```\r\nimport {Column, Entity, JoinColumn, ManyToOne, OneToOne, PrimaryGeneratedColumn} from \"typeorm\";\r\nimport {Order} from \"./Order\";\r\nimport {OrderLine} from \"./OrderLine\";\r\n\r\n@Entity()\r\nexport class ShipmentInfo\r\n{\r\n    @PrimaryGeneratedColumn()\r\n    id:number;\r\n\r\n    @Column()\r\n    name:string;\r\n\r\n    @ManyToOne(type => Order)\r\n    @JoinColumn()\r\n    order: Order\r\n}\r\n```\r\nChanged ManyToOne relation to a OneToOne with a different model\r\n```\r\nimport {Column, Entity, JoinColumn, ManyToOne, OneToOne, PrimaryGeneratedColumn} from \"typeorm\";\r\nimport {Order} from \"./Order\";\r\nimport {OrderLine} from \"./OrderLine\";\r\n\r\n@Entity()\r\nexport class ShipmentInfo\r\n{\r\n    @PrimaryGeneratedColumn()\r\n    id:number;\r\n\r\n    @Column()\r\n    name:string;\r\n\r\n    @OneToOne(type => OrderLine)\r\n    @JoinColumn()\r\n    line: OrderLine\r\n}\r\n```\r\n\r\nreceived the following error on syncing the db\r\n\r\n> ER_TRUNCATED_WRONG_VALUE_FOR_FIELD: Incorrect integer value: 'NULL' for column 'lineId' at row 1\r\n\r\n**Workaround:** \r\n\r\n1. I managed to get the change I needed by deleting the column relation completely e.g: \r\n```\r\nexport class ShipmentInfo\r\n{\r\n    @PrimaryGeneratedColumn()\r\n    id:number;\r\n\r\n    @Column()\r\n    name:string;\r\n\r\n    // @OneToOne(type => OrderLine)\r\n    // @JoinColumn()\r\n    // line: OrderLine\r\n}\r\n```\r\n\r\n2. Allowing the db to sync \r\n3. Adding new relation \r\n4. Synced again\r\n5. Tada everything works\r\n\r\nThought I'd report this either way\r\n\r\n\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/3670/comments",
    "author": "randomAccessMe",
    "comments": [
      {
        "user": "Kononnable",
        "created_at": "2019-03-15T23:16:44Z",
        "body": "That is expected behavior.\r\nMigrations/schema sync tries to change db as little as possible. It doesn't know you removed a column and added another one with the same name - it thinks you just want to alter it. There is an error because you're table is already populated."
      }
    ]
  },
  {
    "number": 3665,
    "title": "getRepository generic over abstract class shows confusing behaviour",
    "created_at": "2019-02-18T18:34:17Z",
    "closed_at": "2019-02-25T15:05:11Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/3665",
    "body": "**Issue type:**\r\n\r\n[x ] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[x ] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[ ] `latest`\r\n[ ] `@next`\r\n[x] `0.2.12` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\nHello dear typeorm developers and community,\r\nCurrently I am taking my first steps in this most amazing API. Now I have implemented a couple classes and I ran into a problem which I don't quite understand and I hope you can help me with it. I have implemented an abstract class \r\n```\r\nimport { Entity, PrimaryGeneratedColumn } from 'typeorm';\r\n@Entity()\r\nexport abstract class DbEntity {\r\n    @PrimaryGeneratedColumn()\r\n    id!: string;\r\n    public abstract update(data: { [key: string]: any }): void;\r\n}\r\n```\r\nand a User class that inherits from it \r\n```\r\n@Entity()\r\nexport class User extends DbEntity {\r\n    @Column()\r\n    userName!: string;\r\n    ...\r\n}\r\n```\r\nNow I tried to implements some general functions over my `DbEntity` with a new class \r\n```\r\nexport class DbInteraction {\r\n    private repository: Repository<DbEntity>;\r\n    constructor(repository: Repository<DbEntity>) {\r\n        this.repository = repository;\r\n    }\r\n    public async checkExistenceById(id: string): Promise<boolean> {\r\n        return (await this.repository.findByIds([id])).length !== 0;\r\n    }\r\n    ...\r\n}\r\n```\r\nNow I am trying to use the interaction class in my extended `Connection` like this:\r\n```\r\nexport class DbConnection extends Connection {\r\n    public userInteraction: DbInteraction;\r\n\r\n    constructor(config: DatabaseConfig) {\r\n        super(...);\r\n        this.userInteraction = new DbInteraction(this.getRepository(User));\r\n    }\r\n```\r\nI get the following Error from my typescript compiler (version 3.0.1):\r\n```\r\nArgument of type 'Repository<User>' is not assignable to parameter of type 'Repository<DbEntity>'.\r\n  Types of property 'count' are incompatible.\r\n    Type '{ (options?: FindManyOptions<User> | undefined): Promise<number>; (conditions?: FindConditions<User> | undefined): Promise<number>; }' is not assignable to type '{ (options?: FindManyOptions<DbEntity> | undefined): Promise<number>; (conditions?: FindConditions<DbEntity> | undefined): Promise<number>; }'.\r\n      Types of parameters 'options' and 'options' are incompatible.\r\n        Type 'FindManyOptions<DbEntity> | undefined' is not assignable to type 'FindManyOptions<User> | undefined'.\r\n          Type 'FindManyOptions<DbEntity>' is not assignable to type 'FindManyOptions<User>'.\r\n            Type 'DbEntity' is not assignable to type 'User'.\r\n\r\n          this.userInteraction = new DbInteraction(this.getRepository(User));\r\n```\r\nI'm not sure what I'm to do about it. I kindly ask for your help\r\n\r\nKind regards\r\nMaxim\r\n<!--\r\n    To answer those questions you need to put \"x\" inside the square brackets, for example:\r\n    [x] `mysql`\r\n    [ ] `postgres`\r\n\r\n    Also, please format your code properly (by taking code blocks into ```ts .... ```)\r\n!>\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/3665/comments",
    "author": "Eotia-was-taken",
    "comments": [
      {
        "user": "vlapo",
        "created_at": "2019-02-20T09:17:21Z",
        "body": "This looks like some kind of problem in your code. Are you sure you have right `User` class imported in your `DbConnection` class? I try this in one TS file and everything is ok."
      },
      {
        "user": "Eotia-was-taken",
        "created_at": "2019-02-25T10:57:02Z",
        "body": "Hello @vlapo,\r\nSorry for the late answer. I have done some further investigation and I have found out that the problem occurs if the `strict` mode of the tsc compiler is on. \r\n\r\n```\r\n{\r\n    \"compilerOptions\": {\r\n        \"module\": \"commonjs\",\r\n        \"strict\": true,\r\n        \"target\": \"es6\",\r\n        \"emitDecoratorMetadata\": true,\r\n        \"experimentalDecorators\": true\r\n    },\r\n    \"include\": [\"*\"]\r\n}\r\n```\r\nis a minimal `tsconfig.json` that reproduces the behaviour together with the sample code."
      },
      {
        "user": "Eotia-was-taken",
        "created_at": "2019-02-25T11:21:58Z",
        "body": "```\r\n this.userInteraction = new DbInteraction(\r\n            this.getRepository<DbEntity>(User),\r\n```\r\nremoves the compile error, though."
      },
      {
        "user": "vlapo",
        "created_at": "2019-02-25T15:05:11Z",
        "body": "Glad to hear you resolved your problem :)"
      }
    ]
  },
  {
    "number": 3660,
    "title": "Is there any way to save date with with timezone +00:00 in mssql",
    "created_at": "2019-02-18T08:53:17Z",
    "closed_at": "2019-04-20T22:44:05Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/3660",
    "body": "**Issue type:**\r\n\r\n[x ] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[x ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[ ] `latest`\r\n[ ] `@next`\r\n[x ] `0.2.11`\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nHi team,\r\n\r\nI have a entity named Test:\r\n\r\n```typescript\r\nexport class Test {\r\n    \r\n    @CreateDateColumn({\r\n        type: 'datetimeoffset',\r\n        default: () => 'getutcdate()'\r\n    })\r\n    createdAt: Date;\r\n\r\n    @Column({\r\n        type: 'datetimeoffset',\r\n        nullable: true\r\n    })\r\n    deletedAt: Date;\r\n}\r\n```\r\nWhen creating a record, createdAt save the time '2019-02-18 02:50:47.9670000 +00:00'.\r\nHowever, when I update field deleledAt, database will save the time '2019-02-18 10:01:47.3420000 +07:00'. Data saved is correct, but it's inconsistence between timezone createdAt and deleledAt (createdAt: +00:00, deleledAt: +07:00). So is there any way to make deleledAt will save the time  '2019-02-18 03:01:47.3420000 +00:00' ?. \r\n\r\n`UPDATE \"Test\" SET \"deletedAt\" = @0 -- PARAMETERS: [{\"value\":\"2019-02-18T07:57:47.342Z\",\"type\":\"datetimeoffset\",\"params\":[]}]`\r\n\r\nThanks.",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/3660/comments",
    "author": "trantuat",
    "comments": [
      {
        "user": "Kononnable",
        "created_at": "2019-03-15T18:33:14Z",
        "body": "If you don't want to specify the timezone wouldn't it be better to use column type which doesn't save timezone information? In current scenario you're wasting space in db(which also affect performance etc.)."
      },
      {
        "user": "trantuat",
        "created_at": "2019-03-16T01:49:05Z",
        "body": "I need to save timezone. My problem is the value that's saved in createdAt and deletedAt is inconsistency. One saved \"2019-02-18 02:50:47.9670000 +00:00'\" and other one saved \"2019-02-18 10:01:47.3420000 +07:00\". You can see, timezone is different. "
      },
      {
        "user": "Kononnable",
        "created_at": "2019-03-16T09:33:34Z",
        "body": "What's the point of saving timezone if you always want to reset it to 0?\r\n\r\nFirst let's see what timezone should be set 'by default':\r\ncreatedAt - it's populated by the db - it's using db server timezone\r\ndeletedAt - it's populated by client(node app) - it's using timezone of machine node is running\r\n\r\nHowever `getutcdate()` returns datetime which doesn't contains timezone offset(will always be +0). So the only way to have both column with equal timezone offset is to reset set timezone to 0 on node side. And here comes a problem - as far as I know tedious(mssql driver for node) doesn't support setting different timezone. You can change `useUTC` option passed to `createConnection` - it might help, but I don't think it would be enough on its own.\r\n\r\nBut either way - if you wan't to always set timezone offset to zero you don't need a column with timezone offset.\r\n"
      }
    ]
  },
  {
    "number": 3632,
    "title": "Embedded entities with entity schema",
    "created_at": "2019-02-13T09:21:55Z",
    "closed_at": "2022-02-17T17:31:13Z",
    "labels": [
      "question",
      "comp: embeds",
      "comp: entity schemas",
      "driver: postgres"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/3632",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[x] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[ ] `latest`\r\n[ ] `@next`\r\n[x] `0.2.12` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nIn the actual project I can not use decorators, therefore I describe the entities with entity schema.\r\nNow, I wont use embedded entities., but it does not work.\r\n\r\n```\r\nexport const userSchema: EntitySchema<User> = new EntitySchema<User>( {\r\n    name: 'user',\r\n    target: User,\r\n    columns: {\r\n        username: {\r\n            type: 'varchar',\r\n            length: 20,\r\n            unique: true\r\n        },\r\n        password: {\r\n            type: 'varchar',\r\n            length: 20,\r\n            transformer: new PasswordValueTransformer()\r\n        },\r\n        lastLogin: {\r\n            type: 'timestamp with time zone',\r\n            nullable: true,\r\n            name: 'lastlogin'\r\n        }\r\n    }\r\n} );\r\n```\r\n\r\n```\r\nexport const metadataSchema: EntitySchema<Metadata> = new EntitySchema<Metadata>( {\r\n    name: 'metadata',\r\n    target: Metadata,\r\n    columns: {\r\n        createdBy: {\r\n            type: 'varchar'\r\n        },\r\n        createdAt: {\r\n            type: 'timestamp with time zone',\r\n            createDate: true\r\n        },\r\n        modifiedBy: {\r\n            type: 'varchar'\r\n        },\r\n        modifiedAt: {\r\n            type: 'timestamp with time zone',\r\n            updateDate: true\r\n        }\r\n    }\r\n} );\r\n```\r\n\r\n```\r\nexport const dbUserSchema: EntitySchema<DbUser> = new EntitySchema<DbUser>( {\r\n    name: 'dbUser',\r\n    target: DbUser,\r\n    columns: {\r\n        id: {\r\n            type: Number,\r\n            primary: true,\r\n            generated: true\r\n        },\r\n        user: {\r\n            type: User   <--- compile failed\r\n        },\r\n    },\r\n    relations: {\r\n        user: {\r\n            type: User   <--- compile failed\r\n        },\r\n        metadata: {\r\n            type: Metadata   <--- compile failed\r\n        }\r\n    }\r\n} );\r\n```",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/3632/comments",
    "author": "javix",
    "comments": [
      {
        "user": "adamsar",
        "created_at": "2019-03-08T09:09:38Z",
        "body": "I also have a case that I need help with here:\r\n\r\n```javascript\r\nexport const AddressSchema = new EntitySchema<Address>({\r\n    name: \"address\",\r\n    columns: {\r\n        zipcode: {\r\n            name: \"zipcode\",\r\n            type: \"text\",\r\n            nullable: false\r\n        },\r\n\r\n        prefecture: {\r\n            name: \"prefecture\",\r\n            type: \"text\",\r\n            enum: Prefecture,\r\n            nullable: false\r\n        },\r\n\r\n        city: {\r\n            name: \"city\",\r\n            type: \"text\",\r\n            nullable: false\r\n        },\r\n\r\n        line1: [{\r\n            name: \"line1\",\r\n            type: string,\r\n            nullable: false\r\n        }]\r\n    }\r\n})\r\n\r\nexport const UserSchema = new EntitySchema<User>(\r\n\r\n    {\r\n        name: \"user\",\r\n        columns: {\r\n\r\n            id: {\r\n                name: \"user_id\",\r\n                type: \"uuid\",\r\n                primary: true,\r\n                generated: true\r\n            },\r\n\r\n            email: {\r\n                type: \"text\",\r\n                nullable: false\r\n            },\r\n\r\n            address: {\r\n                name: \"address\",\r\n                type: AddressSchema // This is what I need to figure out\r\n            },\r\n\r\n            name: {\r\n                name: \"name\",\r\n                type: string\r\n            },\r\n\r\n            ...timestampColumns,\r\n            ...passwordColumn\r\n        }\r\n    }\r\n)\r\n```"
      },
      {
        "user": "adamsar",
        "created_at": "2019-03-08T09:10:11Z",
        "body": "Ideally I want to hold all of this in the same table with `address_zipcode`... etc as the column names."
      },
      {
        "user": "MaciejSikorski",
        "created_at": "2020-06-01T08:36:08Z",
        "body": "What is the status of this?"
      },
      {
        "user": "igoraguiar",
        "created_at": "2020-06-27T06:14:15Z",
        "body": "I'm switching from decorators to EntitySchema and this feature is essential for me. \r\nI implemented it and sent a PR."
      },
      {
        "user": "mtalbert",
        "created_at": "2021-05-30T22:34:25Z",
        "body": "I would also really like this feature!  Without it, I either have an ugly choice of flattening in my Domain Model or separating my Domain and Data models and adding an extra transformation between them."
      },
      {
        "user": "toneysix",
        "created_at": "2021-10-31T10:01:20Z",
        "body": "> I would also really like this feature! Without it, I either have an ugly choice of flattening in my Domain Model or separating my Domain and Data models and adding an extra transformation between them.\r\n\r\nTS is a pretty raw stack as of me, you should take a look at c#, it ain't suffering from such things (children's issues). as I said before, this feature ought to have kept up with decorators way, IMHO\r\n\r\nP.S.: am gonna implement it"
      }
    ]
  },
  {
    "number": 3628,
    "title": "Order by a computed field/column in createQueryBuilder",
    "created_at": "2019-02-12T16:53:30Z",
    "closed_at": "2019-02-14T19:53:59Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/3628",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[x] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\nHi guys,\r\n\r\nI need to order my results by a computed field with `createQueryBuilder`.\r\n\r\nIn the docs, I see that `.orderBy` wants a column as a paramenter, but I cannot compute a column (in this case a boolean colum) with `createQueryBuilder`.\r\n\r\nConsider this simple entity:\r\n```ts\r\nclass Store {\r\n    @Column({ type: 'time' })\r\n    from: string;\r\n    \r\n    @Column({ type: 'time' })\r\n    to: string;\r\n\r\n}\r\n```\r\n\r\nNow, i want to retrieve all products from stores and sort them in order to show first all the products available in that moment (so the store has to be open) and after all the products that are not available.\r\n\r\nThis is the raw sql query to find all stores and order them based on the availability at a specific time:\r\n\r\n```sql\r\nSELECT *, (:time BETWEEN stores.from AND stores.to) as is_open\r\nFROM stores\r\nORDER BY is_open DESC\r\n```\r\n\r\nIs it possible to do this without `getRawMany`?\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/3628/comments",
    "author": "ootkin",
    "comments": [
      {
        "user": "vlapo",
        "created_at": "2019-02-13T23:07:53Z",
        "body": "Did you even try find solution here in issues ? :) You can do custom selects and order by:\r\n```typescript\r\nawait connection.getRepository(Store)\r\n        .createQueryBuilder(\"stores\")\r\n        .select()\r\n        .addSelect(\"(:time BETWEEN stores.from AND stores.to)\", \"is_open\")\r\n        .orderBy(\"is_open\")\r\n        .getMany();\r\n```\r\nor use `getRawAndEntities` if you need `is_open` too."
      },
      {
        "user": "ootkin",
        "created_at": "2019-02-14T09:42:39Z",
        "body": "Hi vlapo, yes I tried to find the solution in other issues, but I didn't find this particular case.\r\n\r\nAnyway, I tried your solutions and it works with that simple entity.\r\n\r\nIn my real case, Store entity is more complex and it has more than one time slot (from, to) and they are handled with another entity (TimeTable) that specify even a week day.\r\n\r\nSo i create a subquery in `addSelect` like this:\r\n\r\n```ts\r\nawait connection.getRepository(Store)\r\n            .createQueryBuilder('store')\r\n            .select()\r\n            .addSelect(sq => {\r\n                return sq\r\n                    .select('bool_or(:day = timeTable.day AND :time BETWEEN timeTable.from AND timeTable.to)', 'is_open')\r\n                    .from('stores', 'sqStore')\r\n                    .innerJoin('sqStore.timeTables', 'timeTable')\r\n                    .where('sqStore.id = store.id')\r\n                    .setParameter('time', time)\r\n                    .setParameter('day', 0);\r\n\r\n            }, 'is_open')\r\n            .orderBy('is_open', 'DESC')\r\n            .getMany()\r\n```\r\n\r\nFor each store I check if it's open in at least one time slot and then with `bool_or` I'm able to aggregate the is_open result and assign it to every row.\r\n\r\nSeems like to works now.\r\n\r\nThanks for help me to figure it out! :)"
      },
      {
        "user": "vlapo",
        "created_at": "2019-02-14T19:53:59Z",
        "body": "You are welcome :)"
      },
      {
        "user": "phucsang0spt",
        "created_at": "2021-01-01T19:21:00Z",
        "body": "hi @vlapo , i did the same when order by additional field and I got this error: \"for SELECT DISTINCT, ORDER BY expressions must appear in select list\". But there is no any DISTINCT in my sql query :|"
      },
      {
        "user": "elapshynov",
        "created_at": "2024-04-19T08:53:39Z",
        "body": "> hi @vlapo , i did the same when order by additional field and I got this error: \"for SELECT DISTINCT, ORDER BY expressions must appear in select list\". But there is no any DISTINCT in my sql query :|\r\n\r\nDistinct might be added by take/skip"
      },
      {
        "user": "amiralammohawk",
        "created_at": "2024-06-04T15:39:57Z",
        "body": "@phucsang0spt  same error"
      }
    ]
  },
  {
    "number": 3614,
    "title": "Update Date column from SQL",
    "created_at": "2019-02-10T15:19:31Z",
    "closed_at": "2019-02-10T16:59:28Z",
    "labels": [
      "question",
      "comp: query builder"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/3614",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[x] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n---\r\n\r\nIs there a way to update `Date` column from SQL. Something like\r\n\r\n```\r\n        await connection\r\n            .createQueryBuilder()\r\n            .update(Session)\r\n            .set({ ip_address: ip, last_login: 'CURRENT_TIMESTAMP'})\r\n            .where('session.user_id = :id', { id: userId })\r\n            .execute()\r\n```\r\n\r\n\r\n`UpdateDateColumn` does not work for me because I need to update the column only in some save actions whereas `UpdateDateColumn` gets triggered in all save actions",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/3614/comments",
    "author": "thellimist",
    "comments": [
      {
        "user": "vlapo",
        "created_at": "2019-02-10T16:08:37Z",
        "body": "Did you try \r\n```typescript\r\n.set({ ip_address: ip, last_login: () => 'CURRENT_TIMESTAMP'})\r\n```"
      },
      {
        "user": "thellimist",
        "created_at": "2019-02-10T16:59:15Z",
        "body": "works 👍 "
      }
    ]
  },
  {
    "number": 3605,
    "title": "Support for functional index",
    "created_at": "2019-02-08T21:05:33Z",
    "closed_at": "2020-10-15T05:05:16Z",
    "labels": [
      "question",
      "new feature",
      "driver: postgres"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/3605",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[x] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n---\r\n\r\nIs there a way to add functional indexes? The example I'm using is below\r\n\r\n```\r\ncreate unique index users_unique_lower_email_idx on users (lower(email));\r\n```\r\n\r\n```\r\n\\d users\r\n                              Table \"public.users\"\r\n     Column      |  Type   |                     Modifiers\r\n-----------------+---------+----------------------------------------------------\r\n id              | integer | not null default nextval('users_id_seq'::regclass)\r\n email           | text    | not null\r\n password_digest | text    | not null\r\nIndexes:\r\n    \"users_pkey\" PRIMARY KEY, btree (id)\r\n    \"users_email_key\" UNIQUE CONSTRAINT, btree (email)\r\n    \"users_unique_lower_email_idx\" UNIQUE, btree (lower(email))\r\n```",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/3605/comments",
    "author": "thellimist",
    "comments": [
      {
        "user": "imnotjames",
        "created_at": "2020-10-15T04:28:00Z",
        "body": "The only currently supported way to do this is to define the index but turn of synchronization.\r\n\r\n```\r\n@Index(\"users_unique_lower_email_idx\", { unique: true, synchronize: false })\r\n```\r\n\r\nThen manually define it in the migrations."
      },
      {
        "user": "imnotjames",
        "created_at": "2020-10-15T05:05:13Z",
        "body": "Duplicate of #2561"
      }
    ]
  },
  {
    "number": 3602,
    "title": "update query run twice with new data and old data",
    "created_at": "2019-02-08T13:19:31Z",
    "closed_at": "2019-04-20T22:26:30Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/3602",
    "body": "**Issue type:**\r\n\r\n[ x] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ x] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[ ] `latest`\r\n[ ] `@next`\r\n[ x] `0.3.0-alpha.22` (or put your version here)\r\n\r\nHi there,\r\n\r\nI have faced error. I tried to update user data. and there is no error but data not updated.  so I just have looked query,  it looks like run twice. and first query is what I expected run with new data then query run again with old data. \r\n\r\nquery results\r\n\r\nquery: SELECT ... = ? -- PARAMETERS: [15]\r\n//This query is what I expected\r\nquery: UPDATE `user` SET `firstname` = ?, `updatedAt` = CURRENT_TIMESTAMP WHERE `id` = ? -- PARAMETERS: [\"Youngmin\",15]\r\n\r\nquery: SELECT ...  FROM `user` `User` WHERE (`User`.`id` IN (15))\r\nPOST /graphql 200 24.166 ms - 56\r\n\r\nquery: START TRANSACTION\r\n//But this query run the parameter is old data\r\nquery: UPDATE `user` SET `firstname` = ?, `storeId` = ?, `updatedAt` = CURRENT_TIMESTAMP WHERE `id` IN (15) -- PARAMETERS: [\"Gabriel\",null]\r\nquery: SELECT `User`.`id` AS `User_id`, `User`.`updatedAt` AS `User_updatedAt` FROM `user` `User` WHERE (`User`.`id` = ?) -- PARAMETERS: [15]\r\nquery: COMMIT\r\n\r\n\r\nmy code\r\n========================================================================\r\nconst user = req.user;\r\n        const notNull: any = removeNull({ ...args });\r\n\r\n        try {\r\n          if (notNull.password !== null) {\r\n            user.password = args.password;\r\n            user.save();\r\n            delete notNull.password;\r\n          }\r\n\r\n         await User.update({ id: user.id  }, { ...notNull });\r\n\r\n          return {\r\n            success: true,\r\n            error: null\r\n          };\r\n        } catch (error) {\r\n          return {\r\n            success: false,\r\n            error: error.message\r\n          };\r\n        }\r\n========================================================================\r\n\r\nis there a any solution?",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/3602/comments",
    "author": "gabrieljo",
    "comments": [
      {
        "user": "Kononnable",
        "created_at": "2019-02-16T13:08:02Z",
        "body": "You're sure you don't want to await that: `user.save();`?"
      }
    ]
  },
  {
    "number": 3599,
    "title": "CLI generate migration get DriverPackageNotInstalledError",
    "created_at": "2019-02-08T10:39:47Z",
    "closed_at": "2019-04-20T22:26:46Z",
    "labels": [
      "question",
      "comp: migrations",
      "driver: cordova"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/3599",
    "body": "**Issue type:**\r\n\r\n[x ] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[x ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[x ] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\nI've tried to run cli command ts-node ./node_modules/typeorm/cli.js migration:generate -n SimpleMigration to generate migration file but get exception DriverPackageNotInstalledError. I use cordova-sqlite-storage for database. Cordova sqlite storage has been installed and can be found in node_modules folder. This error does not occur when run on device, database can be created and functions well.\r\n\r\nThis is the ormconfig.json:\r\n{    \r\n    \"type\":\"cordova\",\r\n    \"database\":\"msmdb\",\r\n    \"location\":\"default\",\r\n    \"logging\":[\"error\",\"schema\"],\r\n    \"synchronize\":false,\r\n    \"entities\":[\".src/entities/*.ts\"],\r\n    \"migrations\":[\".src/providers/db/migrations/*.ts\"],\r\n    \"cli\":{\r\n        \"migrationsDir\":[\"./src/providers/db/migrations\"],\r\n        \"entitiesDir\":[\"./src/entities\"]\r\n    }\r\n}\r\n\r\nWhy typeorm cannot detect the cordova-sqlite-storage package when run migration generate command?\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/3599/comments",
    "author": "Tyzar",
    "comments": [
      {
        "user": "Kononnable",
        "created_at": "2019-02-16T13:32:28Z",
        "body": "I don't think it's possible to use CLI for migrations with cordova. Cordova driver requires application to be running on a device while you run cli on your PC."
      }
    ]
  },
  {
    "number": 3598,
    "title": "typeorm create mongodb collection on start of server.",
    "created_at": "2019-02-08T08:08:22Z",
    "closed_at": "2019-03-15T22:02:27Z",
    "labels": [
      "question",
      "driver: mongodb"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/3598",
    "body": "**Issue type:**\r\n\r\n[ ] question\r\n[X] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[X ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[ ] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\nIs there any way I can create database and collections based on entities on start of server if not exist. ",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/3598/comments",
    "author": "Shashi-GS",
    "comments": [
      {
        "user": "rustamwin",
        "created_at": "2019-02-20T09:57:40Z",
        "body": "mongodb schema builder only supported to indices build\r\nyou can use migrations :smile: "
      },
      {
        "user": "phil294",
        "created_at": "2020-02-24T11:13:29Z",
        "body": "It makes sense to allow this feature, as `Entity.clear()` fails with `ns not found`, if no entity has been saved beforehand (and as such, the collection doesnt exist). I think this should be reopened."
      }
    ]
  },
  {
    "number": 3596,
    "title": "mongodb support where condition to relations on find options ",
    "created_at": "2019-02-08T06:07:54Z",
    "closed_at": "2019-04-25T07:22:22Z",
    "labels": [
      "question",
      "driver: mongodb"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/3596",
    "body": "**Issue type:**\r\n\r\n[ ] question\r\n[X] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[X] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[ X] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\nWe are not able to query with where condition for many records and not able to execute sql queries also on top of MOngoDB. Could you please help me out.\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/3596/comments",
    "author": "Shashi-GS",
    "comments": [
      {
        "user": "Kononnable",
        "created_at": "2019-02-16T13:19:09Z",
        "body": "Could you elaborate? Some code snippet, more info on what exactly you want to achieve and what is current outcome of executing your code."
      },
      {
        "user": "ghost",
        "created_at": "2019-02-20T16:11:57Z",
        "body": "    const existingUser = await this.userRepository.findOne({\r\n      where: [\r\n        {email: data.email},\r\n        {username: data.username}\r\n      ]\r\n    });\r\n\r\nRunning this WHERE / OR will return:\r\n\r\ncode: 8000\r\ncodeName: 'AtlasError'\r\nname: 'MongoError'"
      },
      {
        "user": "rustamwin",
        "created_at": "2019-04-25T07:22:22Z",
        "body": "Closing no answer from issue author"
      }
    ]
  },
  {
    "number": 3593,
    "title": "Is there any way to configure a `Repository`, `EntityManager` or `Entity` to use a non-default connection?",
    "created_at": "2019-02-07T18:55:41Z",
    "closed_at": "2019-04-20T22:18:25Z",
    "labels": [
      "question",
      "comp: manager and repository"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/3593",
    "body": "**Issue type:**\r\n\r\n[X] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[X] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[X] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n---------------------------------------------------------------------------------------------------\r\n\r\nBy default, if no connection is specified, managers and repositories will act on the default connection.\r\nIs there any way to set a manager or custom repository to always use some other connection?\r\nOr the only way to use a non default connection is to do something like `getConnection(\"myConnection\").manager().doSomething`?",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/3593/comments",
    "author": "rangelfinal",
    "comments": [
      {
        "user": "vlapo",
        "created_at": "2019-02-07T20:10:34Z",
        "body": "I dont think so there is another way than you provide in your question."
      }
    ]
  },
  {
    "number": 3575,
    "title": "ID gets appended to field name",
    "created_at": "2019-02-04T15:43:16Z",
    "closed_at": "2019-02-04T16:20:45Z",
    "labels": [
      "question",
      "comp: relations"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/3575",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[x] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\nI have a problem regarding many to one\r\n```ts\r\n@Entity()\r\nexport class Post {\r\n    @PrimaryGeneratedColumn({type: 'int'})\r\n    id: number\r\n    @ManyToOne(type => User, user => user.id)\r\n    @Column({type: 'int'})\r\n    authorId: User\r\n}\r\n```\r\n```ts\r\n@Entity()\r\nexport class User {\r\n    @PrimaryGeneratedColumn({type: 'int'})\r\n    id: number\r\n}\r\n```\r\nWhen I try to get all posts via\r\n```ts\r\nconst posts = await this.postRepository.find({\r\n                       relations: ['authorId']\r\n                       })\r\n```\r\nI get a ER_BAD_FIELD_ERROR with the message: Unknown column 'Post.authorIdId' in 'field list'\r\n<!--\r\n    To answer those questions you need to put \"x\" inside the square brackets, for example:\r\n    [x] `mysql`\r\n    [ ] `postgres`\r\n\r\n    Also, please format your code properly (by taking code blocks into ```ts .... ```)\r\n!>\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/3575/comments",
    "author": "Murbal",
    "comments": [
      {
        "user": "vlapo",
        "created_at": "2019-02-04T16:14:09Z",
        "body": "You have `ManyToOne` and `Column` defined for one property. if you want to have `authorId` and `author` property in your `Post` entity:\r\n```typescript\r\n@Entity()\r\nexport class Post {\r\n    @PrimaryGeneratedColumn({type: 'int'})\r\n    id: number\r\n\r\n    @Column({type: 'int'})\r\n    authorId: number\r\n\r\n    @ManyToOne(type => User, user => user.id)\r\n    author: User;\r\n}\r\n```\r\nand of course call find like this:\r\n```typescript\r\nconst posts = await this.postRepository.find({\r\n      relations: ['author']\r\n})\r\n```"
      },
      {
        "user": "Murbal",
        "created_at": "2019-02-04T16:21:07Z",
        "body": "Thanks this solved my issue"
      }
    ]
  },
  {
    "number": 3570,
    "title": "[PROBLEM] constraint \"PRIMARY KEY\" of relation \"TABLE\" does not exist ",
    "created_at": "2019-02-04T02:29:32Z",
    "closed_at": "2019-08-31T19:23:20Z",
    "labels": [
      "question",
      "needs more info"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/3570",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[x] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[ ] `latest`\r\n[x] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n\r\n**Question**\r\nI want to use repository to find my sample data in postgres but i'm stuck !!\r\n\r\n**Example Files** \r\nUser.ts\r\n```typescript \r\n@Entity()\r\nexport class User {\r\n  @PrimaryGeneratedColumn()\r\n  userid: number;\r\n\r\n  @Column()\r\n  usermail: string;\r\n}\r\n```\r\n\r\n**My Problem**\r\n{ QueryFailedError: constraint \"PK_04d500b286ce3e4c4cbc20d97ea\" of relation \"user\" does not exist\r\n    at new QueryFailedError (C:\\Users\\develop\\Desktop\\TypeORM\\src\\error\\QueryFailedError.ts:7:9)\r\n    at Query.callback (C:\\Users\\develop\\Desktop\\TypeORM\\src\\driver\\postgres\\PostgresQueryRunner.ts:175:30)\r\n    at Query.handleError (C:\\Users\\develop\\Desktop\\TypeORM\\node_modules\\pg\\lib\\query.js:142:17)\r\n    at Connection.connectedErrorMessageHandler (C:\\Users\\develop\\Desktop\\TypeORM\\node_modules\\pg\\lib\\client.js:160:17)\r\n    at Connection.emit (events.js:182:13)\r\n    at Connection.EventEmitter.emit (domain.js:442:20)\r\n    at Socket.<anonymous> (C:\\Users\\develop\\Desktop\\TypeORM\\node_modules\\pg\\lib\\connection.js:125:12)\r\n    at Socket.emit (events.js:182:13)\r\n    at Socket.EventEmitter.emit (domain.js:442:20)\r\n    at addChunk (_stream_readable.js:283:12)\r\n  message:\r\n   'constraint \"PK_04d500b286ce3e4c4cbc20d97ea\" of relation \"app\" does not exist',\r\n\r\n**I think this is PROBLEM**\r\nALTER TABLE \"user\" DROP CONSTRAINT \"PK_04d500b286ce3e4c4cbc20d97ea\"\r\n\r\n\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/3570/comments",
    "author": "MrJim-06",
    "comments": [
      {
        "user": "vlapo",
        "created_at": "2019-02-07T21:01:13Z",
        "body": "Hi @MrJim-06. I do not understand. When is this error throwing? "
      },
      {
        "user": "MrJim-06",
        "created_at": "2019-02-08T02:58:54Z",
        "body": "> Hi @MrJim-06. I do not understand. When is this error throwing?\r\nWhen I'm used Repository.find to find data in postgres. this error throwing."
      },
      {
        "user": "vlapo",
        "created_at": "2019-02-10T12:07:44Z",
        "body": "Sure but you wrote about `ALTER TABLE \"user\" DROP CONSTRAINT \"PK_04d500b286ce3e4c4cbc20d97ea\"` and I really dont know where this comming from because find method do not generate such SQL.\r\n\r\nCould you please create small reproduction of this problem? Maybe small repository with code or snipped of code with entity definitions?"
      },
      {
        "user": "Zorotic",
        "created_at": "2019-04-04T08:55:20Z",
        "body": "I'm also having an issue with this same thing, and it seems to be throwing cause I'm using the synchronize option as seen here. \r\n```ts \r\nconnectionManager.create({\r\n\tname: 'postgres',\r\n\ttype: 'postgres',\r\n\tport: 5432,\r\n\tusername: 'postgres',\r\n\tpassword: 'password',\r\n        database: 'postgres',\r\n\tentities: [GuildSettings],\r\n\tsynchronize: true\r\n});\r\n```\r\n\r\nWith my one entity looking like this:\r\n ```ts \r\nimport {\r\n\tEntity,\r\n\tColumn,\r\n\tPrimaryColumn\r\n} from 'typeorm';\r\n\r\n@Entity('settings')\r\nexport class GuildSettings {\r\n\r\n\t@PrimaryColumn()\r\n\tguild: string;\r\n\r\n\t@Column({ type: 'jsonb', default: \"'{}'\"})\r\n\tsettings: any;\r\n}\r\n```\r\n\r\nVersions:\r\nTypeORM: 0.2.16\r\npg: 7.9.0"
      },
      {
        "user": "Kononnable",
        "created_at": "2019-05-01T15:35:44Z",
        "body": "@ZoroSC \r\nI couldn't reproduce your issue. You're sure that you've got exactly the same error?\r\nRunning your model threw me an error `error: syntax error at or near \"{\"` but after removing apostrophes from default value it works fine."
      },
      {
        "user": "charlie-wasp",
        "created_at": "2019-05-07T12:33:23Z",
        "body": "Same here as @ZoroSC stated. Disabling `synchronize` option resolved the issue\r\n\r\nVersions:\r\nTypeORM: 0.2.17\r\npg: 9.5.16"
      },
      {
        "user": "1valdis",
        "created_at": "2019-07-19T14:31:51Z",
        "body": "Seems like this is not yet fixed, ran into this just now."
      },
      {
        "user": "haohello",
        "created_at": "2019-07-31T13:51:32Z",
        "body": "@1valdis how are your entities defined? "
      },
      {
        "user": "1valdis",
        "created_at": "2019-08-01T07:00:33Z",
        "body": "@haohello I've changed my entities since then and they're working fine. Unfortunately I'm not able to get to that point in my codebase because I haven't committed or saved it elsewhere."
      },
      {
        "user": "Kononnable",
        "created_at": "2019-08-31T19:23:20Z",
        "body": "Closing as no reproduction code was posted - code posted by @ZoroSC was working correctly after fixing syntax error."
      },
      {
        "user": "jeffmoss",
        "created_at": "2019-10-27T00:09:36Z",
        "body": "@Kononnable  `DROP CONSTRAINT IF EXISTS` instead of just `DROP CONSTRAINT` is one possible solution to this, only for pg 9.0+."
      },
      {
        "user": "Bradleykingz",
        "created_at": "2019-10-27T06:44:03Z",
        "body": "If you're like me and added the constraint after the table was first created, you might have to drop it manually."
      },
      {
        "user": "sandeshgb",
        "created_at": "2020-09-29T11:06:34Z",
        "body": "I'm getting same error while starting my project using command \"yarn start:debug\" (using nestjs).\r\nI'm having a many-to-many relation between products and categories.\r\nMy product entity is as follows:\r\n`  @ManyToMany(type => Category)\r\n  @JoinTable({\r\n    name: 'products_categories',\r\n    joinColumn: { name: 'productId' },\r\n    inverseJoinColumn: { name: 'categoryId' },\r\n  })\r\n  category: Category[];`\r\n\r\nDisabling synchronize isn't an appropriate solution.\r\nI don't understand why is it trying to drop constraint and even if it does then it should use \"if exists\"\r\n\r\n@pleerock @MrJim-06 @Kononnable "
      },
      {
        "user": "sandeshgb",
        "created_at": "2020-09-29T11:45:23Z",
        "body": "> Sure but you wrote about `ALTER TABLE \"user\" DROP CONSTRAINT \"PK_04d500b286ce3e4c4cbc20d97ea\"` and I really dont know where this comming from because find method do not generate such SQL.\r\n> \r\n> Could you please create small reproduction of this problem? Maybe small repository with code or snipped of code with entity definitions?\r\n\r\nIts coming from migrations @vlapo . We need to improvise the queries generated via migrations. Just need to add extra bit of checking drop table / constraints **if exists**"
      },
      {
        "user": "dkamorin",
        "created_at": "2021-01-19T18:12:52Z",
        "body": "I think I've met similar or same issue.\r\nIn my project I have NestJS + Typeorm + Postgres and bunch of migrations. One of these migrations creates a table with a custom PK constraint name:\r\n```\r\ncreate table my_table(id char(26) not null constraint my_table_pk primary key, json json, hash char(40));\r\n```\r\n\r\nSo, if I run migrations and then `nest start --watch` the app I get an error:\r\n```\r\n[Nest] 40830   - 01/19/2021, 11:51:50 PM   [TypeOrmModule] Unable to connect to the database. Retrying (1)... +106ms\r\nQueryFailedError: constraint \"PK_5f3350bd9b6c92a62a2257730b7\" of relation \"my_table\" does not exist\r\n    at new QueryFailedError (myproject/node_modules/typeorm/error/QueryFailedError.js:11:28)\r\n    at Query.callback (myproject/node_modules/typeorm/driver/postgres/PostgresQueryRunner.js:176:38)\r\n    at Query.handleError (myproject/node_modules/pg/lib/query.js:145:17)\r\n    at Connection.connectedErrorMessageHandler (myproject/node_modules/pg/lib/client.js:214:17)\r\n    at Connection.emit (events.js:314:20)\r\n    at Connection.EventEmitter.emit (domain.js:483:12)\r\n    at Socket.<anonymous> (myproject/node_modules/pg/lib/connection.js:134:12)\r\n    at Socket.emit (events.js:314:20)\r\n    at Socket.EventEmitter.emit (domain.js:483:12)\r\n    at addChunk (_stream_readable.js:297:12)\r\n```\r\n\r\nand this constraint definitely does not exist, because this constraint has custom name `my_table_pk` in migration files. For some unknown reasons typeorm (?) tries to use another name for the constraint.\r\n\r\nIf I just `nest start` my application with fresh empty DB, it starts without errors and I see DB with tables and so on, although I didn't run migrations. Moreover, the custom constraint in that case has name _PK_5f3350bd9b6c92a62a2257730b7_ which is exactly as it was in the error. But that case is not appropriate for me, because migration with custom name is already in prod, so I can't reverse it, and because there are some other differences with requirements (e.g. wrong column type for other column)\r\n\r\nAny ideas how it can be fixed? It works with synchronize false, but it seems to me like a just workaround, isn't it?"
      },
      {
        "user": "S-a-k-s-h-i",
        "created_at": "2021-10-11T12:44:39Z",
        "body": "I am also getting this error , while running the migrations,. Basically what this error mean and how can i resolve this?\r\nQueryFailedError: constraint \"PK_93e05a4c85dad3c995adf2b2c09\" of relation \"category\" does not exist"
      },
      {
        "user": "valllentinnaa",
        "created_at": "2021-11-05T18:30:34Z",
        "body": "👋 Hi, I have the same problem. I updated my model, generated new migration via cli and once I run the migration it gives me:\r\n`Error during migration run:\r\nQueryFailedError: constraint \"PK_5faed84e32fb60fd3d65001c06d\" of relation \"user_permission_role\" does not exist\r\nquery: 'ALTER TABLE \"user_permission_role\" DROP CONSTRAINT \"PK_5faed84e32fb60fd3d65001c06d\"'`\r\n\r\nFor me adding manually to the migration `IF EXISTS` after `DROP CONSTRAINT` fixed it, but shouldn't it be generated with the check? 🤔"
      },
      {
        "user": "mmaia",
        "created_at": "2022-02-05T20:07:48Z",
        "body": "I can confirm this issue but it happens, at least in my case, only if the constraint for a table is created by other means, in my case I use flyway to manage migrations in PRD and then forget to set synchronize to false. i.e - typeorm migrations also tries to run. "
      },
      {
        "user": "dberardo-com",
        "created_at": "2023-10-02T15:48:46Z",
        "body": "still happening ... any solution ?"
      }
    ]
  },
  {
    "number": 3562,
    "title": "How to make a many to many relationship to a junction table",
    "created_at": "2019-02-02T09:27:24Z",
    "closed_at": "2019-02-02T19:42:59Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/3562",
    "body": "**Issue type:**\r\n[*] question\r\n\r\nSuppose `A `and `B` are two distinct entities with many to many relationship which results in `AB` junction table. We have another entity named `C` which has many to many relationship with`AB`.  To my knowledge in typeorm to make relationships we need to have entities to be defined and loaded. But there is no entity for a junction table. So how in this case `C` can be related to `AB`?",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/3562/comments",
    "author": "P0oOOOo0YA",
    "comments": [
      {
        "user": "saurabhpati",
        "created_at": "2019-02-02T16:09:05Z",
        "body": "I was searching for a different issue for my problem but landed upon this question. \r\n\r\nI think **maybe** I can help with this.\r\n\r\nSo if you have many to many relationship between A and B and you are needing a many to many relationship between another entity C and AB, \r\n\r\nIt **may be** possible for you to redesign to have \r\n\r\nA <--many2many --> B\r\n\r\nA <--many2many --> C\r\n\r\nB <--many2many --> C\r\n\r\nwhich would create separate join tables AB, AC and BC.\r\n\r\nsuppose you require C for a given value of A and B,\r\nyou can query your repository like \r\nA JOIN B \r\nJOIN C \r\nWHERE A == conditionalParamOfA \r\nAND WHERE B == conditionalParamOfB\r\n\r\nsuppose you require C for a given value of A.\r\nyou can query repository like\r\nA JOIN C \r\nWHERE A == conditionalParamOfA\r\n\r\nand so on and so forth.\r\n\r\nDoes it help?"
      },
      {
        "user": "P0oOOOo0YA",
        "created_at": "2019-02-02T19:30:01Z",
        "body": "@saurabhpati thanks this helps for sure."
      }
    ]
  },
  {
    "number": 3558,
    "title": " MongoError: Authentication failed.",
    "created_at": "2019-02-02T05:43:29Z",
    "closed_at": "2019-02-02T09:00:22Z",
    "labels": [
      "question",
      "driver: mongodb"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/3558",
    "body": "mongodb config 如下\r\nconst option:any= \r\n  { \r\n    name:'db1',\r\n    type: 'mongodb',  //数据库类型\r\n    host: config.db.host, //链接\r\n    port: config.db.port,   //端口号\r\n    username: 'root', //账号\r\n    password: '123456', //密码\r\n    database: 'sshdb', //数据库名字\r\n    entities: [\r\n        \"src/dal/sks_node.js\",\r\n        \"src/dal/sks_ip_log.js\",\r\n        \"src/dal/sks_free_ip.js\"\r\n      ],\r\n    synchronize: false, //同步数据库\r\n    logging: false,//日志 }\r\n    authMechanism :'SCRAM-SHA-1'\r\n };\r\nexport  {option} ;\r\n connection mongodb \r\nUnhandledPromiseRejectionWarning: MongoError: Authentication failed",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/3558/comments",
    "author": "yulintianxia",
    "comments": [
      {
        "user": "vlapo",
        "created_at": "2019-02-02T09:00:22Z",
        "body": "Hey @yulintianxia again. \r\nYou didn't provide sufficient information for us to understand the problem. Root of problem will possible be your auth connection options. Try add `authSource` and also use the latest version of typeorm.\r\n\r\nAnd again we are english speaking community. Please respect this and report your issues/questions in English and using our issue template."
      }
    ]
  },
  {
    "number": 3546,
    "title": "Missing Rows Affected in Oracle Db Delete",
    "created_at": "2019-01-30T19:02:40Z",
    "closed_at": "2020-10-17T08:34:47Z",
    "labels": [
      "enhancement",
      "question",
      "driver: oracle"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/3546",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[x] `oracle`\r\n[ ] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\n1- invoke queryRunner.manager.delete\r\n2- the returned DeleteResult does not include any info at all. Expecting to include the number of affected rows.\r\n\r\nI'm having trouble with queryRunner.manager.delete: the operation successfully removes the entity from the database, but DeleteResult does not contain count of entities deleted, it's just DeleteResult { raw: undefined }. This occurs with v0.2.9.\r\n\r\nWhy doesn't DeleteResult specify a property for the number of rows affected in cases of db is oracle?",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/3546/comments",
    "author": "RobinsonLuiz",
    "comments": [
      {
        "user": "Kononnable",
        "created_at": "2019-02-09T14:31:37Z",
        "body": "#3060 - similar issue but about UpdateResult"
      },
      {
        "user": "imnotjames",
        "created_at": "2020-10-17T08:33:16Z",
        "body": "Duplicate of #2415 "
      }
    ]
  },
  {
    "number": 3542,
    "title": "incorret name to table generate for JoinTable.",
    "created_at": "2019-01-29T20:50:28Z",
    "closed_at": "2019-02-09T14:35:01Z",
    "labels": [
      "question",
      "comp: naming strategy"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/3542",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[x] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\nWith a relationism ManyToMany (@JoinTable) The TypeOrm create the table with repeated name.\r\nSee:\r\n\r\nEntity1:\r\n```\r\n@Entity()\r\nexport default class Category extends BaseEntity{\r\n     ....\r\n    @ManyToMany(type => Product, product => product.category)\r\n    @JoinTable()\r\n    product: Product[];\r\n\r\n}\r\n```\r\n\r\nEntity2:\r\n```\r\n@Entity()\r\nexport default class Product extends BaseEntity{\r\n    ....\r\n    @ManyToMany(type => Category, category => category.product)\r\n    category: Category[];\r\n    \r\n}\r\n```\r\n\r\nTable Generate:\r\n`category_product_product`\r\nShould not be `category_product` ?",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/3542/comments",
    "author": "nikoliveira",
    "comments": [
      {
        "user": "vlapo",
        "created_at": "2019-01-30T09:27:49Z",
        "body": "We are using first property in join table name, because it is possible have more than one `ManyToMany` relation between same entities.\r\n\r\nFrom default naming strategy in typeorm:\r\n```typescript\r\njoinTableName(firstTableName: string,\r\n                  secondTableName: string,\r\n                  firstPropertyName: string,\r\n                  secondPropertyName: string): string {\r\n        return snakeCase(firstTableName + \"_\" + firstPropertyName.replace(/\\./gi, \"_\") + \"_\" + secondTableName);\r\n    }\r\n```\r\n\r\nAlso you should name your property `products` as it is array. But it is up to you :-) "
      }
    ]
  },
  {
    "number": 3532,
    "title": "Getting count of duplicates from query",
    "created_at": "2019-01-28T12:20:33Z",
    "closed_at": "2019-04-20T22:21:57Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/3532",
    "body": "[X] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n[X] `sqlite`\r\n\r\n**TypeORM version:**\r\n\r\n[X] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n\r\nAssuming I have an Entity `Category` and `Photo` and `Photographer`\r\n\r\n```\r\n@Entity()\r\nexport class Category {\r\n  @PrimaryGeneratedColumn()\r\n  id: number\r\n\r\n  @OneToMany(type => Photo, photo => photo.category)\r\n  @JoinTable()\r\n  photos: Photo[]\r\n}\r\n```\r\n\r\n`Photo` has a relation to `Category` and `Photo` also has a relation to `Photographer`. Now I would want to get all the categories for Photos taken by a specific Photographer, to stay close to the examples.\r\n\r\n```\r\nconnection.getRepository('category')\r\n    .createQueryBuilder('category').select('category')\r\n    .leftJoin('category.photos', 'photos')\r\n    .where('photos.photographerId = :photographerId', {photographerId})\r\n    .getMany()\r\n\r\n```\r\nThis would return me all the categories, but I am also interested by how often each category has been found. Let's say there would be 100 photos, each has a category, and it would return me 20 categories as many are duplicates. How would I also find out if \"category 1\" has 10 relations to the photos?",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/3532/comments",
    "author": "Murahnus",
    "comments": [
      {
        "user": "Kononnable",
        "created_at": "2019-02-09T13:09:55Z",
        "body": "If you work with query builder you need to think of the sql query you want typeorm to generate. How would it look like? What is the difference between your current generated query and desired one?\r\nI think you're looking for group by and count."
      },
      {
        "user": "Kononnable",
        "created_at": "2019-04-20T22:21:57Z",
        "body": "Closing as no response from the author."
      }
    ]
  },
  {
    "number": 3530,
    "title": "find method with parameter stuck on mocha test.",
    "created_at": "2019-01-28T08:01:28Z",
    "closed_at": "2019-01-28T09:27:28Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/3530",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[x] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\n\r\n            let assets: Asset[] = await this.assetRepository.find();\r\n            this.logger.info(JSON.stringify(assets));   // this return data\r\n            try {\r\n               // STUCK  in this call or any call with find having parameter\r\n                assets = await this.assetRepository.find({order: {asset_tag: 'ASC', id: 'DESC'}});\r\n            } catch (error) {\r\n                this.logger.info(error);\r\n            }\r\n\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/3530/comments",
    "author": "emanpatricio",
    "comments": [
      {
        "user": "emanpatricio",
        "created_at": "2019-01-28T08:18:32Z",
        "body": "tried this also\r\nassets = await this.assetRepository.findOne({});  <---- returned me the first record\r\n\r\nassets = await this.assetRepository.findOne(); <----- this one stucked"
      },
      {
        "user": "vlapo",
        "created_at": "2019-01-28T08:24:09Z",
        "body": "Tested on latest master and do not have any \"stuck\" problem. Is it throwing any error? How is your `Asset` entity defined? Please try enable logging and share logs with us."
      },
      {
        "user": "emanpatricio",
        "created_at": "2019-01-28T09:01:32Z",
        "body": "version:  \"typeorm\": \"^0.2.12\",\r\ntypeorm config\r\n```\r\nmodule.exports = \r\n  {\r\n    \"type\": \"postgres\",\r\n    \"host\": process.env.NODE_ENV === \"test\" ? process.env.TEST_DB_HOST : process.env.DB_HOST,\r\n    \"port\": process.env.NODE_ENV === \"test\" ? process.env.TEST_DB_PORT : process.env.DB_PORT,\r\n    \"username\": process.env.NODE_ENV === \"test\" ? process.env.TEST_DB_USERNAME : process.env.DB_USERNAME,\r\n    \"password\": process.env.NODE_ENV === \"test\" ? process.env.TEST_DB_PASSWORD : process.env.DB_PASSWORD,\r\n    \"database\": process.env.NODE_ENV === \"test\" ? process.env.TEST_DB_NAME : process.env.DB_NAME,\r\n    \"synchronize\": true,\r\n    \"logging\": true,\r\n    \"dropSchema\": process.env.NODE_ENV === \"test\" ? true : false,\r\n    \"entities\": [\r\n      __dirname + \"/src/entities/**/*.ts\"\r\n    ],\r\n    \"migrations\": [\r\n      __dirname + \"/src/migration/**/*.ts\"\r\n    ],\r\n    \"subscribers\": [\r\n      __dirname + \"/src/subscriber/**/*.ts\"\r\n    ],\r\n    \"cli\": {\r\n      \"entitiesDir\": __dirname + \"/src/entities\",\r\n      \"migrationsDir\": __dirname + \"/src/migration\",\r\n      \"subscribersDir\": __dirname + \"/src/subscriber\"\r\n    }\r\n  }\r\n\r\n```\r\n\r\n//Entities\r\n```\r\nimport uuid4 from 'uuid/v4';\r\nimport {\r\n    BeforeInsert,\r\n    Column,\r\n    CreateDateColumn,\r\n    Entity,\r\n    PrimaryColumn,\r\n    Unique,\r\n    UpdateDateColumn,\r\n} from 'typeorm';\r\n\r\nimport { ColumnNumericTransformer } from '../helpers/transformers.helper';\r\nimport { IDevice, IInletSourceType } from './asset.type';\r\n\r\n\r\n@Entity()\r\n@Unique(['asset_tag'])\r\nexport class Asset {\r\n    @PrimaryColumn('uuid')\r\n    public id: string;\r\n\r\n    @Column('text')\r\n    public asset_tag: string;\r\n\r\n    @Column('text')\r\n    public site: string;\r\n\r\n    @Column('text')\r\n    public trap_location: string;\r\n\r\n    @Column('text')\r\n    public trap_location_detail: string;\r\n\r\n    @Column('text')\r\n    public trap_manufacturer: string;\r\n\r\n    @Column('smallint')\r\n    public trap_type: number;\r\n\r\n    @Column('text')\r\n    public trap_model: string;\r\n\r\n    @Column('int')\r\n    public trap_application: number;\r\n\r\n    .....\r\n    .....\r\n\r\n    @BeforeInsert()\r\n    public async addId() {\r\n        this.id = uuid4();\r\n    }\r\n}\r\n\r\n```\r\n\r\nService\r\n```\r\n try {\r\n                console.log('1 -----');\r\n                assets = await this.assetRepository.findOne({});\r\n                console.log('2 -----', assets.id);\r\n                assets = await this.assetRepository.findOne({asset_tag: 'ST_3'});\r\n                console.log('3 -----', assets.id);\r\n            } catch (error) {\r\n                this.logger.info(error);\r\n            }\r\n            this.logger.info('3 -------');\r\n```\r\n\r\n//console.log\r\n```\r\n1 -----\r\nquery: SELECT \"Asset\".\"id\" AS \"Asset_id\", \"Asset\".\"asset_tag\" AS \"Asset_asset_tag\", \"Asset\".\"site\" AS \"Asset_site\", \"Asset\".\"trap_location\" AS \"Asset_trap_location\", \"Asset\".\"trap_location_detail\" AS \"Asset_trap_location_detail\", \"Asset\".\"trap_manufacturer\" AS \"Asset_trap_manufacturer\", \"Asset\".\"trap_type\" AS \"Asset_trap_type\", \"Asset\".\"trap_model\" AS \"Asset_trap_model\", \"Asset\".\"trap_application\" AS \"Asset_trap_application\", \"Asset\".\"orifice_size\" AS \"Asset_orifice_size\", \"Asset\".\"line_size\" AS \"Asset_line_size\", \"Asset\".\"pressure_in\" AS \"Asset_pressure_in\", \"Asset\".\"pressure_out\" AS \"Asset_pressure_out\", \"Asset\".\"update_rate\" AS \"Asset_update_rate\", \"Asset\".\"boiler_fuel_type\" AS \"Asset_boiler_fuel_type\", \"Asset\".\"install_date\" AS \"Asset_install_date\", \"Asset\".\"trap_critical\" AS \"Asset_trap_critical\", \"Asset\".\"indoor\" AS \"Asset_indoor\", \"Asset\".\"out_of_service\" AS \"Asset_out_of_service\", \"Asset\".\"flag\" AS \"Asset_flag\", \"Asset\".\"configured\" AS \"Asset_configured\", \"Asset\".\"noise_level\" AS \"Asset_noise_level\", \"Asset\".\"temp_deadband\" AS \"Asset_temp_deadband\", \"Asset\".\"high_temp_opt\" AS \"Asset_high_temp_opt\", \"Asset\".\"temp_rate_alarm\" AS \"Asset_temp_rate_alarm\", \"Asset\".\"average_daily_trap_working_time\" AS \"Asset_average_daily_trap_working_time\", \"Asset\".\"serial_number\" AS \"Asset_serial_number\", \"Asset\".\"createdDate\" AS \"Asset_createdDate\", \"Asset\".\"updatedDate\" AS \"Asset_updatedDate\", \"Asset\".\"device\" AS \"Asset_device\" FROM \"asset\" \"Asset\" LIMIT 1\r\n        ✓ should be able to recieve data from mqtt (89ms)\r\n2 ----- ee4262da-6381-453f-84dd-111b262c7bf0\r\nquery: SELECT \"Asset\".\"id\" AS \"Asset_id\", \"Asset\".\"asset_tag\" AS \"Asset_asset_tag\", \"Asset\".\"site\" AS \"Asset_site\", \"Asset\".\"trap_location\" AS \"Asset_trap_location\", \"Asset\".\"trap_location_detail\" AS \"Asset_trap_location_detail\", \"Asset\".\"trap_manufacturer\" AS \"Asset_trap_manufacturer\", \"Asset\".\"trap_type\" AS \"Asset_trap_type\", \"Asset\".\"trap_model\" AS \"Asset_trap_model\", \"Asset\".\"trap_application\" AS \"Asset_trap_application\", \"Asset\".\"orifice_size\" AS \"Asset_orifice_size\", \"Asset\".\"line_size\" AS \"Asset_line_size\", \"Asset\".\"pressure_in\" AS \"Asset_pressure_in\", \"Asset\".\"pressure_out\" AS \"Asset_pressure_out\", \"Asset\".\"update_rate\" AS \"Asset_update_rate\", \"Asset\".\"boiler_fuel_type\" AS \"Asset_boiler_fuel_type\", \"Asset\".\"install_date\" AS \"Asset_install_date\", \"Asset\".\"trap_critical\" AS \"Asset_trap_critical\", \"Asset\".\"indoor\" AS \"Asset_indoor\", \"Asset\".\"out_of_service\" AS \"Asset_out_of_service\", \"Asset\".\"flag\" AS \"Asset_flag\", \"Asset\".\"configured\" AS \"Asset_configured\", \"Asset\".\"noise_level\" AS \"Asset_noise_level\", \"Asset\".\"temp_deadband\" AS \"Asset_temp_deadband\", \"Asset\".\"high_temp_opt\" AS \"Asset_high_temp_opt\", \"Asset\".\"temp_rate_alarm\" AS \"Asset_temp_rate_alarm\", \"Asset\".\"average_daily_trap_working_time\" AS \"Asset_average_daily_trap_working_time\", \"Asset\".\"serial_number\" AS \"Asset_serial_number\", \"Asset\".\"createdDate\" AS \"Asset_createdDate\", \"Asset\".\"updatedDate\" AS \"Asset_updatedDate\", \"Asset\".\"device\" AS \"Asset_device\" FROM \"asset\" \"Asset\" WHERE \"Asset\".\"asset_tag\" = $1 LIMIT 1 -- PARAMETERS: [\"ST_3\"]\r\n```\r\n"
      },
      {
        "user": "vlapo",
        "created_at": "2019-01-28T09:16:06Z",
        "body": "Cannot reproduce with your entity either. It has to be something on your side. Try run logged query direct to your database. Maybe it stuck on DB side.\r\n```\r\n1 -----\r\nquery: SELECT \"Asset\".\"id\" AS \"Asset_id\", \"Asset\".\"asset_tag\" AS \"Asset_asset_tag\", \"Asset\".\"site\" AS \"Asset_site\", \"Asset\".\"trap_location\" AS \"Asset_trap_location\", \"Asset\".\"trap_location_detail\" AS \"Asset_trap_location_detail\", \"Asset\".\"trap_manufacturer\" AS \"Asset_trap_manufacturer\", \"Asset\".\"trap_type\" AS \"Asset_trap_type\", \"Asset\".\"trap_model\" AS \"Asset_trap_model\", \"Asset\".\"trap_application\" AS \"Asset_trap_application\" FROM \"asset\" \"Asset\" LIMIT 1\r\n2 ----- 2e392b60-b268-4a62-8c4b-911de7fa0566\r\nquery: SELECT \"Asset\".\"id\" AS \"Asset_id\", \"Asset\".\"asset_tag\" AS \"Asset_asset_tag\", \"Asset\".\"site\" AS \"Asset_site\", \"Asset\".\"trap_location\" AS \"Asset_trap_location\", \"Asset\".\"trap_location_detail\" AS \"Asset_trap_location_detail\", \"Asset\".\"trap_manufacturer\" AS \"Asset_trap_manufacturer\", \"Asset\".\"trap_type\" AS \"Asset_trap_type\", \"Asset\".\"trap_model\" AS \"Asset_trap_model\", \"Asset\".\"trap_application\" AS \"Asset_trap_application\" FROM \"asset\" \"Asset\" WHERE \"Asset\".\"asset_tag\" = $1 LIMIT 1 -- PARAMETERS: [\"tag\"]\r\n3 ----- 2e392b60-b268-4a62-8c4b-911de7fa0566\r\n4 -----\r\n```"
      },
      {
        "user": "emanpatricio",
        "created_at": "2019-01-28T09:26:18Z",
        "body": "I found the issue its on my side, it was a silly mistake forgot the await keyword when calling the service.\r\n\r\nplease help to close, thank you very much for you help."
      }
    ]
  },
  {
    "number": 3527,
    "title": "error: could not determine data type of parameter $1 when trying to query tree entity",
    "created_at": "2019-01-27T21:54:47Z",
    "closed_at": "2021-07-04T03:40:55Z",
    "labels": [
      "question",
      "comp: tree tables",
      "driver: postgres"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/3527",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[x] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\nI am trying to query an entity with a self-referencing tree structure :\r\n```ts\r\nimport {\r\n  Entity,\r\n  PrimaryGeneratedColumn,\r\n  Column,\r\n  BaseEntity,\r\n  Tree,\r\n  TreeChildren, TreeParent\r\n} from \"typeorm\";\r\n\r\n@Entity(\"category\")\r\n@Tree(\"materialized-path\")\r\nexport class Category extends BaseEntity {\r\n\r\n  @PrimaryGeneratedColumn(\"uuid\")\r\n  id: string;\r\n\r\n  @Column({length: 100})\r\n  name: string;\r\n\r\n  @TreeChildren()\r\n  children: Category[];\r\n\r\n  @TreeParent()\r\n  parent: Category;\r\n\r\n}\r\n```\r\nI would like to get a filtered part of the table, either flattened or as a tree structure (ideally, I would like to be able to do both).\r\n\r\nIf I understand correctly, the `findTrees` method of `TreeRepository` always returns the whole table. So in order to be able to join other tables and add WHERE statements I tried something like this:\r\n\r\n```ts\r\n// ...\r\n  const category = new Category();\r\n  const query = getTreeRepository(Category)\r\n    .createDescendantsQueryBuilder(\"c\", \"categoryClosure\", category)\r\n    .leftJoin(\"c.taxonomy\", \"t\")\r\n    .where(`t.\"userId\" = :userId`, {userId: req.user.id});\r\n  const categories: Category[] = await query.getMany();\r\n// ...\r\n```\r\nSince, I was hoping that by providing a new (empty) instance of the `Category` class as the third parameter of `createDescendantsQueryBuilder`, I could get a result that includes all roots and their children that match the WHERE condition.\r\n\r\nnb: From `src/repository/TreeRepository.ts` I figure the second argument (here: \"categoryClosure\") is ignored for materialized path entities?\r\n\r\nHowever, this leads to the following SQL:\r\n```sql\r\nSELECT \"c\".\"id\" AS \"c_id\", \"c\".\"name\" AS \"c_name\", \"c\".\"mpath\" AS \"c_mpath\", \"c\".\"parentId\" AS \"c_parentId\", \"c\".\"taxonomyId\" AS \"c_taxonomyId\" FROM \"category\" \"c\" \r\nLEFT JOIN \"taxonomy\" \"t\" ON \"t\".\"id\"=\"c\".\"taxonomyId\" \r\nWHERE t.\"userId\" = $2 AND \"t\".\"id\" = $3 \r\n-- PARAMETERS: [undefined,\"381f9e0c-b88a-4edb-a2d2-88d948e9e57d\",\"2e46634e-826c-4104-b722-60b9ae6eb60b\"]\r\n```\r\n\r\nand the following error:\r\n\r\n```\r\nerror: could not determine data type of parameter $1\r\n```\r\n\r\nWhen I provide a non-empty `category`, I get the same error even though the `category.id` turns up in the parameters array instead of `undefined` (but still not in the SQL statement).\r\n\r\nI also tried simply using `createQueryBuilder` to query the table, but the `mpath` and `parentId` columns are never returned, even if specified explicitly using `addSelect`.\r\n\r\nAm I missing something or is it not possible to do what I intend with TypeORM? \r\n\r\nAlso, is implementing the `ltree` type from PostgreSQL on the road map (it is not yet implemented, if I'm not mistaken)?\r\n\r\nThank you.",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/3527/comments",
    "author": "nimame",
    "comments": [
      {
        "user": "nimame",
        "created_at": "2019-01-28T11:59:26Z",
        "body": "I think this issue is related: #3481\r\n\r\nedited: @Kononnable Thanks for reminding me to explain why I referenced this issue."
      },
      {
        "user": "Kononnable",
        "created_at": "2019-02-09T13:12:56Z",
        "body": "@nimame  Why did you referenced another issue? You find this as duplicate or is it related somehow? Without a short description nobody knows."
      },
      {
        "user": "imnotjames",
        "created_at": "2021-07-04T03:40:55Z",
        "body": "I believe this to have been fixed by #7821 "
      }
    ]
  },
  {
    "number": 3516,
    "title": "Is there a way to get the last item from an entity?",
    "created_at": "2019-01-25T18:27:03Z",
    "closed_at": "2019-02-09T11:29:10Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/3516",
    "body": "I wana be able to get the last time when querying an entity, like rails' active record's .last\r\n\r\nIs there something in typeorm like this, i can't find it in the docs\r\n\r\n**Issue type:**\r\n\r\n[ ] question\r\n[ ] bug report\r\n[-] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[-] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[-] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\n<!--\r\n    To answer those questions you need to put \"x\" inside the square brackets, for example:\r\n    [x] `mysql`\r\n    [ ] `postgres`\r\n\r\n    Also, please format your code properly (by taking code blocks into ```ts .... ```)\r\n!>\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/3516/comments",
    "author": "JClackett",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2019-01-25T18:37:46Z",
        "body": "I guess you need query entity and order it by id desc?"
      }
    ]
  },
  {
    "number": 3513,
    "title": "Best way to convert exec SP raw results to Entities ?",
    "created_at": "2019-01-25T11:02:19Z",
    "closed_at": "2019-04-20T22:20:34Z",
    "labels": [
      "question",
      "can be closed?"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/3513",
    "body": "**Issue type:**\r\n\r\n[X ] question\r\n\r\n**Database system/driver:**\r\n\r\n[ X] `mssql`\r\n\r\n**TypeORM version:**\r\n\r\n[ X] `latest`\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nHi,\r\nI have some Stored Procedure to call that return rows of an already defined entity.\r\nSo far, I have no way to tell TypeORM that the result will be a list of this entity so I tried to transform it like:\r\n```ts\r\n// Execute SP then bind each row with given type\r\nfunction execSP<Entity>(sql: string, entityClass: ObjectType<Entity>): Promise<Entity[]> {\r\n\tconst repo= getRepository(entityClass);\r\n\tconst meta= repo.manager.connection.getMetadata(entityClass);\r\n\tconst transfomer= new PlainObjectToDatabaseEntityTransformer(repo.manager);\r\n\r\n\treturn repo.query(sql).then(async (rows: any) => {\r\n\t\tawait Promise.all(\r\n\t\t\trows.map( async (row: any) => await transfomer.transform(row, meta))\r\n\t\t);\r\n\t\treturn rows;\r\n\t});\r\n\r\n}\r\n\r\n// and how to use it:\r\nconst customerList= execSP(\"execute GetAllCustomers\", Customer);\r\n```\r\n~~It's only a test so I'm keeping only the first row.~~\r\nIs this the best way to do it or is there a better ?\r\nTIA,\r\n/Thierry\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/3513/comments",
    "author": "kktos",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2019-01-25T12:43:46Z",
        "body": "I think there is no other way currently. Use it if it works for you."
      },
      {
        "user": "kktos",
        "created_at": "2019-01-25T13:01:32Z",
        "body": "There's something I've noticed while at it:\r\n```ts\r\n    @PrimaryGeneratedColumn({name: \"id_customer\"})\r\n\tpublic id: number;\r\n```\r\nThe column name, in the DB, is \"id_customer\" and I want to have a simple \"id\" in the code.\r\nBut it seems it isn't working with this method (PlainObjectToDatabaseEntityTransformer), it seems it didn't transform id_customer to id.\r\nDid I miss something ?\r\nThx\r\n_ps: btw, I've updated my function execSP with the final version._"
      },
      {
        "user": "pleerock",
        "created_at": "2019-01-25T14:01:01Z",
        "body": "I can't tell you this way why its not working. You need to debug and figure it out."
      }
    ]
  },
  {
    "number": 3470,
    "title": "When use .save() method, select all left join",
    "created_at": "2019-01-21T09:16:58Z",
    "closed_at": "2019-01-22T03:35:19Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/3470",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[x] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[ ] `latest`\r\n[ ] `@next`\r\n[x ] `0.2.7` (or put your version here)\r\n\r\n```ts\r\n@Entity()\r\nclass Book {\r\n   ....\r\n   @OneToMany()\r\n   ...\r\n   @OneToMany()\r\n   ....\r\n   @ManyToMany()\r\n   as: A[];\r\n\r\n   @ManyToMany()\r\n}\r\n\r\n@Entity()\r\nclass A {\r\n  ...\r\n @OneToMany()\r\n  ...\r\n@OneToMany()\r\n  ...\r\n@OneToMany()\r\n  ...\r\n}\r\n```\r\n\r\n```\r\nlet book = new Book()\r\nbook.as = aList // A[]\r\nconst result = await Book.save(book)\r\nconsole.log(result)\r\n```\r\nWhen I Use Book.save(book) and print log,\r\n\r\nI saw sql log so many left join that I didn't want\r\n\r\nI want to see only Book and A(cascade) not book.tests[].test2s[].test3s[]\r\n \r\nthis query make slow query.\r\n\r\nrows_sent are 62496.\r\n\r\nhow can i fix this query?\r\n\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/3470/comments",
    "author": "taehyeong224",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2019-01-21T10:14:52Z",
        "body": "it executes multiple queries to **check** if you added anything to your relations (compares what you have in models with what you have in the database). Without those queries it cannot understand if you added or removed something from your model or not."
      },
      {
        "user": "taehyeong224",
        "created_at": "2019-01-22T03:35:19Z",
        "body": "thank you I was mistaken"
      }
    ]
  },
  {
    "number": 3463,
    "title": "Migration Usage",
    "created_at": "2019-01-20T20:19:04Z",
    "closed_at": "2019-01-27T17:47:57Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/3463",
    "body": "**Issue type:**\r\n\r\n**[x] question**\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n**[x] `postgres`**\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n**[x] `latest`**\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n\r\nPlease forgive me but I'm relatively new to DB related development and I am trying to understand setting up Migrations.\r\n\r\nI currently have about 7 entities setup and in development, with synchronize, have had no issues. I know that when I go to production, I want to switch off sync and work with migrations. When I try to generate a migration, currently, it sees no changes so it generates nothing. That makes sense, because I've never set up any migrations but I do have some schema changes to at least one of my entities. \r\n\r\nI assume running .. \r\n`typeorm migration:generate -n Initialize` \r\n.. would write migrations for the schemas of my entities as they are currently setup but it does not. \r\n\r\nSo I am curious, when I go to production, will I just need to create migrations and use them as needed? Should I run with sync: true at first deploy to production and turn it off to then use migrations as needed?\r\n\r\nThanks for any knowledge you can provide!\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/3463/comments",
    "author": "robotlemons",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2019-01-21T10:45:05Z",
        "body": "> Should I run with sync: true at first deploy to production and turn it off to then use migrations as needed?\r\n\r\nyes you can do it this way, I think its more optimal if you are flexible."
      }
    ]
  },
  {
    "number": 3448,
    "title": "select max value with specific column in typeorm ",
    "created_at": "2019-01-18T09:59:52Z",
    "closed_at": "2019-01-27T17:05:37Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/3448",
    "body": "**Issue type:**\r\n\r\n[ ] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[*] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[ ] `latest`\r\n[ ] `@next`\r\n[ ] `0.2.8` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n \r\n**Is it possible to use existing sql function Max() in Typeorm?\r\n\r\n`getOneMaximumQuotationVersion() {\r\n    return this.createQueryBuilder(\"Quotation\")\r\n    .select([\"Quotation.id\", \"Quotation.quotationVersion\"])\r\n    .addSelect(\"MAX(Quotation.id)\", \"max\")\r\n    .getOne();\r\n  }  ` \r\n\r\n\r\n ",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/3448/comments",
    "author": "hengsoheak",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2019-01-18T10:06:12Z",
        "body": "you need to use `getRawOne` method instead"
      }
    ]
  },
  {
    "number": 3444,
    "title": "Hydration of Embedded (json) types into proper class instances",
    "created_at": "2019-01-18T00:40:21Z",
    "closed_at": "2019-01-18T09:35:00Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/3444",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n\r\n**Database system/driver:**\r\n\r\n[x] `postgres`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n\r\nWhen working with JSON fields, we end up embedding a lot of objects that aren't just data blobs (but have utility methods attached to them too).\r\n\r\nOne (rather simple) example:\r\n\r\n```\r\n@Entity(\"Tenants\")\r\nexport class Tenant extends Schema {\r\n    @Column(\"varchar\", { length: 64 })\r\n    public slug: string;\r\n\r\n    @Column(\"uuid\")\r\n    public addressId: string;\r\n\r\n    @Column(\"jsonb\", {\r\n        transformer: {\r\n            to: value => value,\r\n            from: value => plainToClass(Organization, value)\r\n        }\r\n    })\r\n    public organization: Organization;\r\n}\r\n```\r\n\r\nWhile the Organization class looks like this\r\n```\r\nexport class Organization {\r\n    public legalName: string;\r\n\r\n    public test(): string {\r\n        return \"test\";\r\n    }\r\n}\r\n```\r\n\r\nThe goal is to be able to do `const tenant = await repo.findOne(someId); tenant.organization.test()` (effectively).\r\n\r\nI tried this:\r\n\r\n```\r\n    @Column(type => Organization)\r\n    public organization: Organization;\r\n```\r\n\r\nBut as the docs state, this isn't what I want (pulls in the fields from Org into the base Tenant class). \r\n\r\nMy query is, is using the transformer the proper way to get the right instance, or does TypeORM have something built in that can assist with this?\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/3444/comments",
    "author": "Wintereise",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2019-01-18T09:24:08Z",
        "body": "no, TypeORM doesn't have anything for this functionality and I don't think it will. Converting plain objects to class instances is a tricky thing (for example if it has inner objects we need to introduce extra decorator to get known about its type, just like class-transformer's `@Type`), this is out of TypeORM scope. So yes, in your case using transformer option is a right way to do things."
      },
      {
        "user": "pleerock",
        "created_at": "2019-01-18T09:25:01Z",
        "body": "And generally I don't recommend using classes, use plain objects - it will save your life in most cases. Separate utility classes is a good place for your utility functions in most cases."
      },
      {
        "user": "Wintereise",
        "created_at": "2019-01-18T09:35:00Z",
        "body": "@pleerock Understood, thanks for clarifying."
      }
    ]
  },
  {
    "number": 3430,
    "title": "Migration Generation Without Database Connection",
    "created_at": "2019-01-16T08:24:08Z",
    "closed_at": "2019-02-09T09:33:02Z",
    "labels": [
      "question",
      "wontfix"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/3430",
    "body": "**Issue type:**\r\n\r\n[ ] question\r\n[ ] bug report\r\n[x] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[x] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nCurrently, from what I can tell, generating a migration requires that typeorm's CLI is able to connect to a database. However, in an development environment, there are situations where it is less then ideal to run it against an live database. For example, I am running my application inside of a Docker container for development.\r\n\r\nI understand the way migration:generate command works at the moment is entirely based on a database connection, but I'm wondering what the feasibility is of generating new migrations based off of a comparison with existing migrations.\r\n\r\nThank you so much for your time!",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/3430/comments",
    "author": "devmattrick",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2019-01-16T11:22:33Z",
        "body": "To be able to generate a migration tool needs to know what queries it should generate. Generated queries are result of difference between your real schema and entities in your code. Without difference tool can't generate you anything and without real schema its impossible to get difference. The only way to get a real schema is to connect to your database."
      },
      {
        "user": "Diluka",
        "created_at": "2019-01-24T09:34:44Z",
        "body": "@devmattrick No matter where the application or the database is running. The application can connect to a database and docker can bind mounts and execute commands. So it's not a problem."
      },
      {
        "user": "felixhayashi",
        "created_at": "2020-02-11T16:17:23Z",
        "body": "@pleerock isn't it possible for typeorm to simply generate the whole schema if no connection is provided :thinking:  ...it seems a bit superfluous to me having to setup and boot a db just for the sake of generating an initial schema for the first migration. "
      },
      {
        "user": "varanauskas",
        "created_at": "2020-07-13T06:30:57Z",
        "body": "Additionally, this possibly extends to a feature request, but the way migrations could be generated without a database connection is by simulating all of the existing migrations in order on a mock database (to get the schema, if no migrations exist, then schema is empty) and then add the new migration based on the constructed schema on the mock database."
      },
      {
        "user": "fan-tom",
        "created_at": "2020-10-25T14:53:45Z",
        "body": "+1 for @varanauskas suggession, Django ORM works in this way, also it keeps migrations abstract and declarative (no backend-specific things in migrations, migration is just changeset that needs to be transformed to sql for actual backend)"
      },
      {
        "user": "varanauskas",
        "created_at": "2021-04-28T12:41:47Z",
        "body": "In the meantime I am using a quick and dirty solution, it creates a new database locally on developer machine, runs all migrations on it and then drops the database, effectively not having to touch any production database but only a local development one. (Only tested in postgres)\r\n\r\n```ts\r\nimport { Query } from \"typeorm/driver/Query\";\r\nimport { SqlInMemory } from \"typeorm/driver/SqlInMemory\";\r\nimport { promises } from \"fs\";\r\nimport { createConnection, getConnectionOptions } from \"typeorm\";\r\n\r\nconst queryParams = (parameters: unknown[] | undefined) =>\r\n  !parameters || !parameters.length ? \"\" : `, ${JSON.stringify(parameters)}`;\r\nconst queryToStatement = ({ query, parameters }: Query) =>\r\n  `    await queryRunner.query(\\`${query.replace(/`/g, \"\\\\`\")}\\`${queryParams(\r\n    parameters\r\n  )});`;\r\nconst renderTemplate = (\r\n  name: string,\r\n  { upQueries, downQueries }: SqlInMemory\r\n) => `import { Service } from \"typedi\";\r\nimport { MigrationInterface, QueryRunner } from \"typeorm\";\r\n\r\nexport class ${name} implements MigrationInterface {\r\n  public async up(queryRunner: QueryRunner): Promise<void> {\r\n${upQueries.map(queryToStatement).join(\"\\n\")}\r\n  }\r\n\r\n  public async down(queryRunner: QueryRunner): Promise<void> {\r\n${downQueries.map(queryToStatement).join(\"\\n\")}\r\n  }\r\n}\r\n`;\r\n\r\nasync function createMigrationQueries() {\r\n  const options = await getConnectionOptions();\r\n  if (options.type !== \"postgres\")\r\n    throw new Error(\"Postgres database required\");\r\n  const connection = await createConnection({ ...options, synchronize: false });\r\n  const queryRunner = await connection.createQueryRunner();\r\n  try {\r\n    await queryRunner.startTransaction();\r\n    await connection.runMigrations({ transaction: \"none\" });\r\n    return await connection.driver.createSchemaBuilder().log();\r\n  } finally {\r\n    await queryRunner.rollbackTransaction();\r\n    await queryRunner.release();\r\n    await connection.close();\r\n  }\r\n}\r\n\r\nexport async function generateMigration(name: string) {\r\n  const timestamp = Date.now();\r\n  const { cli: { migrationsDir } } = await getConnectionOptions();\r\n  const queries = await createMigrationQueries();\r\n  const content = renderTemplate(`${name}${timestamp}`, queries);\r\n  const filename = `${migrationsDir}/${timestamp}-${name}.ts`;\r\n  await promises.writeFile(filename, content);\r\n}\r\n```"
      },
      {
        "user": "AlissonRS",
        "created_at": "2023-10-31T00:53:31Z",
        "body": "Coming from .NET Core, I miss this. Entity Framework can generate migrations without connecting to database, so it's a shame TypeORM not only does not support, but the team behind it is not interested in improving it."
      }
    ]
  },
  {
    "number": 3390,
    "title": "Repo.FindByIds do not preserve item order?",
    "created_at": "2019-01-08T23:38:12Z",
    "closed_at": "2019-01-09T20:38:16Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/3390",
    "body": "**Issue type:**\r\n\r\n[x ] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[x] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[ ] `latest`\r\n[ ] `@next`\r\n[x] `0.2.9` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\n```js\r\nconst ids = [ 75, 185, 722]\r\n\r\nconsole.log(await conn.getRepository(Product).findByIds(ids)); \r\n/**\r\n [\r\n    {id:722, ...},\r\n    {id:185, ...},\r\n    {id:75, ...}\r\n  ]\r\n\r\n\r\n*/\r\n\r\n```\r\nIs this behavior by design? How to preserve the same order as input?\r\n<!--\r\n    To answer those questions you need to put \"x\" inside the square brackets, for example:\r\n    [x] `mysql`\r\n    [ ] `postgres`\r\n\r\n    Also, please format your code properly (by taking code blocks into ```ts .... ```)\r\n!>\r\n\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/3390/comments",
    "author": "michael-land",
    "comments": [
      {
        "user": "vlapo",
        "created_at": "2019-01-09T20:38:16Z",
        "body": "I dont think so this is typeorm by design problem. This method generate simple SQL and typeorm do not modify order of returned rows by default. \r\n\r\nYou can define order with order option:\r\n```typescript\r\nawait conn.getRepository(Product).findByIds(ids, { order: { id: \"ASC\" } })\r\n```"
      }
    ]
  },
  {
    "number": 3378,
    "title": "How to query relation table different set ?",
    "created_at": "2019-01-07T14:19:59Z",
    "closed_at": "2019-01-10T08:09:59Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/3378",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[x] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[ ] `latest`\r\n[ ] `@next`\r\n[x] `0.2.9` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nSorry... I don't know how to describe this question in title better..\r\n\r\nI have two table\r\nclassroom  1---*  shcedule, relation is one to many\r\n\r\n## classroom\r\n\r\n id | className \r\n----|-----------\r\n 1  | A         \r\n 2  | B         \r\n 3  | C         \r\n 4  | D\r\n\r\n## schedule\r\n\r\n| id \t| curTime \t| classRoomId \t|\r\n|----\t|---------\t|-------------\t|\r\n| 1  \t| 101     \t| 1           \t|\r\n| 2  \t| 103     \t| 1           \t|\r\n| 3  \t| 104     \t| 1           \t|\r\n| 4  \t| 102     \t| 3           \t|\r\n| 5  \t| 202     \t| 2           \t|\r\n\r\ncurTime is mean day + section\r\n101 is monday's first section\r\n\r\nNow I want to query the classroom is free time in curTime array like this\r\nFor example:\r\nI have a curTime array [102,103,201]\r\nI want to find the classroom in this array time is free (not in schedule), so in this case I want to query out classroom id 2 and 4 because id 2 and 4 in schedule had no curTime in [102,103,201]\r\n\r\nPlease help~~\r\nMy algorithm now is query all classroom in to array, then query all shedule curTime in [102,103,201] and find out the classRoomId to splice it, but I think it's so stupid. Thanks!!!\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/3378/comments",
    "author": "zerox12311",
    "comments": [
      {
        "user": "vlapo",
        "created_at": "2019-01-07T15:13:34Z",
        "body": "Hi @zerox12311, \r\n\r\nI think this question is pretty simple. You have to use query builder with left join.\r\n\r\n```typescript\r\nawait connection.getRepository(ClassRoom).createQueryBuilder(\"classroom\")\r\n            .select()\r\n            .leftJoinAndSelect(Schedule, \"schedule\", \"schedule.classRoomId = classroom.id AND schedule.curTime IN (:...currTimes)\", { currTimes: [102, 103, 201] })\r\n            .where(\"schedule.id IS NULL\")\r\n            .getMany();\r\n```"
      },
      {
        "user": "zerox12311",
        "created_at": "2019-01-07T15:22:32Z",
        "body": "@vlapo thank you!\r\nI will try it tomorrow!!"
      }
    ]
  },
  {
    "number": 3369,
    "title": "Querybuilder: Join many-to-many relation and filter results",
    "created_at": "2019-01-05T21:17:53Z",
    "closed_at": "2019-04-20T22:05:02Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/3369",
    "body": "**Issue type:**\r\n\r\n[ ] question\r\n[ ] bug report\r\n[ ] feature request\r\n[X] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[X] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[ ] `latest`\r\n[ ] `@next`\r\n[X] `0.2.9`\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nI have 2 tables: `users` and `groups` and they are connected via many-to-many relation. So a user can belong to multiple groups and groups can be related to multiple users. Now I want to query (select) all users belonging to a list of groups BUT if they match all of their groups should be included in the result.\r\n\r\nI found no hint how to implement that with TypeORM's query builder. In raw SQL I would propably do it with sub-selects. Now, in this case, I didnt want to add all the user groups with additional querys and attach that data via Typescript, because that has propably poor performance with large datasets.\r\n\r\nMinimal example (includes all matching users, but only matching groups -> should include all groups of a matching user):\r\n\r\n```ts\r\nlet qb = this.repository.createQueryBuilder('user');\r\n\r\nqb = qb.leftJoinAndSelect('user.groups', 'userGroups');\r\n\r\nconst groupIds = [1, 5];\r\nqb.where('userGroups.id IN (:...groupIds)', { groupIds });\r\n\r\nqb.getMany();\r\n\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/3369/comments",
    "author": "vrilcode",
    "comments": [
      {
        "user": "vrilcode",
        "created_at": "2019-01-05T23:33:02Z",
        "body": "This is how I would solve it in pure SQL:\r\n\r\n```sql\r\nSELECT users.id, users.last_name, users.first_name, groups.id, groups.name\r\nFROM users,\r\n     (\r\n      SELECT ugm.user_id AS id\r\n      FROM user_group_map ugm\r\n      WHERE ugm.group_id IN (1, 5)\r\n      GROUP BY user_id\r\n     ) users_with_certain_groups,\r\n     users_groups_map,\r\n     groups\r\nWHERE users.id = users_with_certain_groups.id\r\n  AND users.id = users_groups_map.user_id\r\n  AND users_groups_map.group_id = groups.id\r\n```"
      },
      {
        "user": "vrilcode",
        "created_at": "2019-01-06T02:16:40Z",
        "body": "This is my solution now, it's working. Is there a more elegant alternative?\r\n\r\n```ts\r\nconst groupIds = [1, 5];\r\n\r\nconst qb = this.repository\r\n  .createQueryBuilder('user')\r\n  .innerJoin(qb2 => {\r\n    return qb2\r\n      .select('user.id', 'id')\r\n      .from(User, 'user')\r\n      .innerJoin('user.groups', 'userGroups')\r\n      .where('userGroups.id IN (:...groupIds)', { groupIds });\r\n    }, 'userWithCertainGroups', 'user.id = \"userWithCertainGroups\".id')\r\n  .leftJoinAndSelect('user.groups', 'userGroups');\r\n\r\nqb.getMany();\r\n```"
      },
      {
        "user": "pleerock",
        "created_at": "2019-01-06T18:31:20Z",
        "body": "You should ask yourself how you would do this query using joins instead of subselects. You need something like this:\r\n\r\n```ts\r\nconst qb = this.repository\r\n  .createQueryBuilder('user')\r\n  .innerJoin('user.groups', 'userGroup', 'userGroup.id IN (:...groupIds)', { groupIds });\r\n```"
      },
      {
        "user": "willyguevara",
        "created_at": "2020-12-02T19:18:43Z",
        "body": "> You should ask yourself how you would do this query using joins instead of subselects. You need something like this:\r\n> \r\n> ```ts\r\n> const qb = this.repository\r\n>   .createQueryBuilder('user')\r\n>   .innerJoin('user.groups', 'userGroup', 'userGroup.id IN (:...groupIds)', { groupIds });\r\n> ```\r\n\r\nGot problems with the parameters order when adding the `qb.where()` it put the `groupIds` at the end of the array.\r\n\r\nI.E.:\r\n\r\n``` \r\nconst qb = this.repository\r\n  .createQueryBuilder('user')\r\n  .innerJoin('user.groups', 'userGroup', 'userGroup.id IN (:...groupIds)', { groupIds })\r\n  .where({\r\n                    name: Like(`%wil%`)\r\n                })\r\n```\r\n\r\nParameters --> `[\"%wil%\", \"1,2\"]`\r\ninstead of Parameters correct order --> `[\"1,2\", \"%wil%\"]`"
      },
      {
        "user": "aadrianras",
        "created_at": "2024-02-11T21:29:52Z",
        "body": "I've followed all the suggestions on this page, and I was able to complete a complex query. I'm going to leave it here; it may be helpful to see a full example of the implementation. Good luck!\r\n\r\n`const { skip = 0, take = 20, select = undefined, artStyles = [], bodyParts = [], states = [], search } = queryParams;\r\n\r\n    try {\r\n      const queryBuilder = this.tattooRepository\r\n        .createQueryBuilder('tattoo')\r\n        .leftJoinAndSelect('tattoo.artist', 'artist')\r\n        .leftJoinAndSelect('artist.user', 'user')\r\n        .skip(skip)\r\n        .take(take);\r\n\r\n      if (search) {\r\n        queryBuilder.where(\r\n          new Brackets((qb) => {\r\n            qb.where('tattoo.description ILIKE :search', { search: `%${search}%` });\r\n            qb.orWhere('user.nickname ILIKE :search', { search: `%${search}%` });\r\n            qb.orWhere('user.name ILIKE :search', { search: `%${search}%` });\r\n            qb.orWhere('user.lastname ILIKE :search', { search: `%${search}%` });\r\n          }),\r\n        );\r\n      }\r\n\r\n      if (states.length > 0) {\r\n        queryBuilder.andWhere('user.stateId IN (:...states)', { states });\r\n      }\r\n\r\n      if (artStyles.length > 0) {\r\n        queryBuilder.innerJoin('tattoo.artStyles', 'artStyles', 'artStyles.id IN (:...artStyles)', {\r\n          artStyles: artStyles,\r\n        });\r\n      }\r\n\r\n      if (bodyParts.length > 0) {\r\n        queryBuilder.innerJoin('tattoo.bodyParts', 'bodyParts', 'bodyParts.id IN (:...bodyParts)', {\r\n          bodyParts: bodyParts,\r\n        });\r\n      }\r\n\r\n      if (select) {\r\n        queryBuilder.select(select);\r\n      }\r\n\r\n      const tattoos = await queryBuilder.getMany();\r\n\r\n      return {\r\n        data: tattoos.map((tattoo) => instanceToPlain(tattoo)),\r\n        total: tattoos.length,\r\n        skip,\r\n        take,\r\n      };\r\n    } catch (error) {\r\n      console.log(error)\r\n    }`"
      }
    ]
  },
  {
    "number": 3349,
    "title": "How do I use prepared statements in SQlite?",
    "created_at": "2019-01-02T10:59:17Z",
    "closed_at": "2019-01-15T14:40:48Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/3349",
    "body": "**Issue type:**\r\n[*] question\r\n\r\n**Database system/driver:**\r\n[*] `sqlite`\r\n\r\n**TypeORM version:**\r\n[*] `latest`\r\n\r\nThis is how you can use prepared statements in `node-sqlite3`. \r\n\r\n```js\r\nvar sqlite3 = require('sqlite3')\r\nvar db = new sqlite3.Database('data.db');\r\n\r\ndb.serialize(function() {\r\n    var stmt = db.prepare(\"SELECT * FROM table WHERE \"+KEY_FIELD_NAME+\"=(?)\");\r\n    stmt.get(fieldName,function(err,row){\r\n        var callbckObj = null;\r\n\r\n        if(row != undefined){\r\n            callbckObj = new callbckObj(row);\r\n        }\r\n        callback(err, callbckObj);      \r\n    });\r\n    stmt.finalize();\r\n});\r\ndb.close();\r\n```\r\nHow we can do the same in `TypeORM`?\r\n\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/3349/comments",
    "author": "P0oOOOo0YA",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2019-01-03T19:43:02Z",
        "body": "TypeORM doesn't have additional api for prepared statements. You need to use underlying driver, e.g. `node-sqlite3` itself. You can use it via `connection.driver`"
      }
    ]
  },
  {
    "number": 3339,
    "title": "Unable to run an update using getMongoRepository",
    "created_at": "2018-12-28T06:49:57Z",
    "closed_at": "2019-01-04T20:23:48Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/3339",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[x] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[ ] `latest`\r\n[ ] `@next`\r\n[x] `0.2.10` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nThe current model looks like this.\r\n\r\n```typescript\r\n\r\nimport { Answer } from \"./Answer\";\r\n\r\n@Entity({ database: DATABASE_MONGO_NAME })\r\n\r\nexport class StudentRecord {\r\n  @ObjectIdColumn()\r\n  _id: ObjectID;\r\n\r\n /* many more columns */\r\n\r\n  @Column()\r\n  answers: Answer[];\r\n\r\n}\r\n\r\n```\r\n\r\nThe `Answer` collection model looks like this\r\n\r\n```typescript\r\n@Entity({ database: DATABASE_MONGO_NAME })\r\n\r\nexport class Answer {\r\n  @ObjectIdColumn()\r\n  _id: ObjectID;\r\n\r\n /* many more columns */\r\n\r\n  @ObjectIdColumn()\r\n  mongo_id_question: ObjectID;\r\n\r\n  @Column()\r\n  selected: string[];\r\n}\r\n\r\n```\r\nSo essentially the data stored in a document looks like this \r\n\r\n```json\r\n{\r\n    \"_id\": {\r\n        \"$oid\": \"5c1e60352f73e9000494e33f\"\r\n    },\r\n    \"answers\": [\r\n        {\r\n            \"_id\": {\r\n                \"$oid\": \"5c0e507f0da2560004c9003e\"\r\n            },\r\n            \"mongo_id_question\": {\r\n                \"$oid\": \"5c0e507f0da2560004c9003e\"\r\n            },\r\n            \"selected\": [\r\n                \"5c0e507f0da2560004c9003b\"\r\n            ]\r\n        }\r\n    ]\r\n}\r\n```\r\n\r\nThe query I am trying to run, sets the `updatedAt` column for an object with a given `mongo_id_question` in the `answers` list based on a given `record_id` \r\n\r\n```typescript\r\nStudentRecordsRepository.update(\r\n      {\r\n        _id: new ObjectID(record_id),\r\n        \"answers.mongo_id_question\": new ObjectID(\"5c0e507f0da2560004c9003e\"),\r\n      },\r\n      { $set: { \"answers.$.updatedAt\": new Date() } },\r\n    );\r\n```\r\nI get the following error in `typescript`\r\n\r\n```typescript\r\nerror TS2345: Argument of type '{ _id: ObjectID; \"answers.mongo_id_question\": ObjectID; }' is not assignable to parameter of type 'string | number | Date | ObjectID | FindConditions<StudentRecord> | string[] | number[] | Date[] | ObjectID[]'.\r\n  Object literal may only specify known properties, and '\"answers.mongo_id_question\"' does not exist in type 'string | number | Date | ObjectID | FindConditions<StudentRecord> | string[] | number[] | Date[] | ObjectID[]'\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/3339/comments",
    "author": "judemanutd",
    "comments": [
      {
        "user": "mohamed-badaoui",
        "created_at": "2018-12-28T10:33:00Z",
        "body": "IMHO I never got why people need an ORM for mongoDb. It is already object oriented. What advantages bring an ORM ? \r\nUsing an ORM for mongoDB means that models are stored as relational models and that's a pity because you loose all the benefits of an object oriented database.\r\n\r\nIn PHP world, Doctrine try to do it with DoctrineODM but it was a failure and poorly used "
      },
      {
        "user": "judemanutd",
        "created_at": "2018-12-28T15:46:05Z",
        "body": "> IMHO I never got why people need an ORM for mongoDb. It is already object oriented. What advantages bring an ORM ?\r\n> Using an ORM for mongoDB means that models are relational models and that's a pity because you loose all the benefits of an object oriented database.\r\n> \r\n> In PHP world, Doctrine try to do it with DoctrineODM but it was a failure and poorly used\r\n\r\nBe that as it may, this seems like a question for stack overflow and not the answer to the current issue that is being faced."
      },
      {
        "user": "judemanutd",
        "created_at": "2018-12-28T17:54:57Z",
        "body": "@mohamed-badaoui tried that, didn't work, I'm guessing because the `dot` in a key is not counted as a valid json key so it throws even more errors. \r\n\r\n```typescript\r\n[ERROR] 23:24:34 ⨯ Unable to compile TypeScript:\r\nsrc/repo/StudentRecordsRepo.ts(160,16): error TS1005: ',' expected.\r\nsrc/repo/StudentRecordsRepo.ts(160,34): error TS1005: ',' expected.\r\nsrc/repo/StudentRecordsRepo.ts(160,40): error TS1005: ':' expected.\r\nsrc/repo/StudentRecordsRepo.ts(160,9): error TS2304: Cannot find name 'answers'.\r\nsrc/repo/StudentRecordsRepo.ts(160,16): error TS2345: Argument of type '{ _id: ObjectID; answers: any; (Missing): any; new: any; }' is not assignable to parameter of type 'string | number | Date | ObjectID | FindConditions<StudentRecord> | string[] | number[] | Date[] | ObjectID[]'.\r\n  Object literal may only specify known properties, and '(Missing)' does not exist in type 'string | number | Date | ObjectID | FindConditions<StudentRecord> | string[] | number[] | Date[] | ObjectID[]'.\r\nsrc/repo/StudentRecordsRepo.ts(160,40): error TS2348: Value of type 'typeof ObjectID' is not callable. Did you mean to include 'new'?\r\n```"
      },
      {
        "user": "pleerock",
        "created_at": "2019-01-04T08:59:18Z",
        "body": "You should use `updateOne` or `updateMany` methods instead."
      },
      {
        "user": "judemanutd",
        "created_at": "2019-01-04T20:23:48Z",
        "body": "It was as simple as that, thank you @pleerock "
      }
    ]
  },
  {
    "number": 3317,
    "title": "Why not getRawManyAndCount method?",
    "created_at": "2018-12-24T00:40:21Z",
    "closed_at": "2018-12-24T07:16:58Z",
    "labels": [
      "question",
      "comp: manager and repository"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/3317",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[x ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[ ] `latest`\r\n[ ] `@next`\r\n[ ] `0.2.98` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nmy sql like this:\r\n\r\n```\r\nselect max(date) as maxDate , min(data) as minData, name, email from user group by sessionId\r\n```\r\n\r\ni need mapping select columns to one Entity , but i can not found getRawManyAndCount method.\r\n\r\n<!--\r\n    To answer those questions you need to put \"x\" inside the square brackets, for example:\r\n    [x] `mysql`\r\n    [ ] `postgres`\r\n\r\n    Also, please format your code properly (by taking code blocks into ```ts .... ```)\r\n!>\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/3317/comments",
    "author": "zhongzhong0505",
    "comments": [
      {
        "user": "vlapo",
        "created_at": "2018-12-24T00:46:06Z",
        "body": "I think this is not possible now. But I was looking for this method before so maybe it is time to introduce in typeorm api. Lets see what @pleerock say."
      },
      {
        "user": "zhongzhong0505",
        "created_at": "2018-12-24T05:46:59Z",
        "body": "> I think this is not possible now. But I was looking for this method before so maybe it is time to introduce in typeorm api. Lets see what @pleerock say.\r\n\r\n@vlapo  i use getManyAndCount method, but this method can not return maxTs and minTs to Entity,  the Entity like this:\r\n\r\n```\r\n@Entity()\r\nclass User {\r\n    @Column()\r\n     name: string\r\n    ...\r\n    maxTs: number\r\n    minTs: number\r\n}\r\n``` "
      },
      {
        "user": "pleerock",
        "created_at": "2018-12-24T07:16:45Z",
        "body": "this request doesn't make much sense. `getManyAndCount` does two queries anyway, so consider to call `getRawMany` and `getCount` separately to get the result you need."
      }
    ]
  },
  {
    "number": 3303,
    "title": "How to add multiple JoinColumn \"OR\" conditions? (OneToOne)",
    "created_at": "2018-12-21T02:44:54Z",
    "closed_at": "2018-12-21T08:28:08Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/3303",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[x] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[ ] `latest`\r\n[x] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nI'd like to create below sql.\r\n```\r\n  INNER JOIN \"accounts\" \"Accounts\" \r\n    ON \"Accounts\".\"id\" = \"Friends\".\"account_id\" \r\n    OR \"Accounts\".\"id\" = \"Friends\".\"account_id\" \r\n```\r\n\r\nBut, below entity settings made this sql.\r\n```\r\n  @OneToOne(() => Accounts)\r\n  @JoinColumn([\r\n    { name: 'account_id', referencedColumnName: 'id' },\r\n    { name: 'friend_account_id', referencedColumnName: 'id' },\r\n  ])\r\n  accounts: Accounts;\r\n```\r\n\r\n```\r\n  INNER JOIN \"accounts\" \"Accounts\" \r\n    ON \"Accounts\".\"id\" = \"Friends\".\"account_id\" \r\n    AND \"Accounts\".\"id\" = \"Friends\".\"account_id\"         <--- I'd like to change \"OR\". \r\n```\r\n\r\nPlease tell me how to change the code?",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/3303/comments",
    "author": "ghost",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2018-12-21T07:38:03Z",
        "body": "`@JoinColumn` is used to define table columns and relation between entities. Your question is completely invalid. What you want isn't related to relations. You probably want to manually build query using QueryBuilder instead."
      },
      {
        "user": "ghost",
        "created_at": "2018-12-21T08:28:08Z",
        "body": "@pleerock I also think so. Thank you reply to me."
      }
    ]
  },
  {
    "number": 3290,
    "title": "Handling SQL Local Variables",
    "created_at": "2018-12-19T19:35:38Z",
    "closed_at": "2019-04-20T21:56:00Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/3290",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[x] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[ ] `latest`\r\n[ ] `@next`\r\n[x] `0.2.7` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nGetting an ER_PARSE_ERROR when trying to use local variables in a raw sql query:\r\n\r\nawait manager.query(`SET @rowindex := -1;\r\n \r\nSELECT\r\n   AVG(g.grade)\r\nFROM\r\n   (SELECT @rowindex:=@rowindex + 1 AS rowindex,\r\n           grades.grade AS grade\r\n    FROM grades\r\n    ORDER BY grades.grade) AS g\r\nWHERE\r\ng.rowindex IN (FLOOR(@rowindex / 2) , CEIL(@rowindex / 2));\r\n\r\n  `);\r\n\r\n\r\nWhat's the correct way to use local variables within the raw SQL query?",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/3290/comments",
    "author": "projectyang",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2018-12-20T05:40:16Z",
        "body": "You shall use underlying driver API for this purpose. Read `mssql` documentation on how to do it, you can access mssql connection from `connection.driver`"
      }
    ]
  },
  {
    "number": 3287,
    "title": "Annotation of overridden entity attribute is ignored",
    "created_at": "2018-12-19T15:44:59Z",
    "closed_at": "2018-12-20T16:37:04Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/3287",
    "body": "**Issue type:**\r\n\r\n[X] question\r\n[X] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[X] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[X] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\nAssume I have the following entity structure:\r\n\r\n```\r\n@Entity()\r\nexport class Company {\r\n    @OneToMany(type => Person, person=> person.company)\r\n    persons: Array<Person>;\r\n}\r\n\r\n@Entity()\r\nexport class Person {\r\n    @ManyToOne(type => Company , company => company.persons)\r\n    company: Company;\r\n}\r\n```\r\n\r\nNow I want to extend `Person` in a new class and add a new column to it:\r\n```\r\n@Entity(\"Person\")\r\nexport class CustomPerson extends Person {\r\n    @Column()\r\n    newShinyColumn: string;\r\n}\r\n```\r\n\r\nHow do I need to load the `Company` with relations so that the `CustomPerson`, and not the `Person` entity is loaded?\r\nI tried to override the `Company` entity as well and redefine the `persons` attribute:\r\n```\r\n@Entity(\"Company\")\r\nexport class CustomCompany {\r\n    @OneToMany(type => CustomPerson, person=> person.company)\r\n    persons: Array<CustomPerson>;\r\n}\r\n```\r\n\r\nBut trying to load the company entity (`getRepository(CustomCompany).find({ relations: [\"persons\"]})`) still has a reference only to the `Person`, and not to the `CustomPerson` entity.\r\n\r\nShould this work or is this structure not supported by TypeORM? I would assume that if I override an attribute in a subclass (`CustomCompany.persons`), the annotations of the overridden attribute should be applied, and not the annotations of the attribute in the parent class anymore.\r\n\r\nWhat I am trying to achieve is having a default project (Company, Person), and a customer specific project which has an extra column on the Person entity.\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/3287/comments",
    "author": "dominic-simplan",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2018-12-20T07:21:00Z",
        "body": "Don't create a mess. Simply add columns you need to original entity. If you want to add columns dynamically you can try to play around with object proptotype and use more low-level typeorm api."
      },
      {
        "user": "dominic-simplan",
        "created_at": "2018-12-20T07:29:45Z",
        "body": "Hi,\r\nthanks for your feedback! I need to add the columns dynamically. Any hint for the low-level API where I could start looking into?"
      },
      {
        "user": "pleerock",
        "created_at": "2018-12-20T08:02:05Z",
        "body": "Explore source code of the `Column` decorator and you'll find an example."
      },
      {
        "user": "dominic-simplan",
        "created_at": "2018-12-20T16:37:04Z",
        "body": "thanks!"
      }
    ]
  },
  {
    "number": 3281,
    "title": "Relation entity does not load on findOne",
    "created_at": "2018-12-18T22:06:16Z",
    "closed_at": "2018-12-19T06:41:01Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/3281",
    "body": "**Issue type:**\r\n[X] bug report\r\n\r\n**Database system/driver:**\r\n[X] `mysql` / `mariadb`\r\n\r\n**TypeORM version:**\r\n[X] `@next`\r\n\r\nOn 2.9.0, with findOne repository method, we can load association with FindOptions **relations**  \r\nSo that code line will return Entity and its association\r\n`await connection.getRepository(Entity).findOne({id: 12}, {relations: ['association']});`\r\n\r\nThe same call **does not work** on on @next branch 3.0.0-alpha22\r\nIt return the entity WITHOUT the association. The only way it works is to give as it first parameter directly the id number. So we can't use query :(\r\n\r\n\r\n\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/3281/comments",
    "author": "mohamed-badaoui",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2018-12-19T06:27:46Z",
        "body": "Why you don't use `await connection.getRepository(Entity).findOne({ where: {id: 12}, relations: ['association']});`"
      },
      {
        "user": "pleerock",
        "created_at": "2018-12-19T06:28:20Z",
        "body": "I don't remember motivation of this change, but probably it was made to prevent a confusion since second argument also can have its own `where` argument."
      },
      {
        "user": "mohamed-badaoui",
        "created_at": "2018-12-19T06:41:01Z",
        "body": "All right, thanks @pleerock.\r\n"
      }
    ]
  },
  {
    "number": 3274,
    "title": "Fail to detect PK existing constraint name on migration:generate",
    "created_at": "2018-12-17T19:17:36Z",
    "closed_at": "2018-12-19T15:35:16Z",
    "labels": [
      "question",
      "by design"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/3274",
    "body": "**Issue type:**\r\n\r\n[x] bug report\r\n\r\n**Database system/driver:**\r\n\r\n[x] `postgres`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nI have a psql table created with the following queries:\r\n\r\n```sql\r\nCREATE TABLE users (\r\n    id uuid DEFAULT gen_random_uuid() PRIMARY KEY,\r\n    first_name character varying(50) NOT NULL,\r\n    last_name character varying(50) NOT NULL,\r\n    email character varying(255) NOT NULL UNIQUE,\r\n    password character varying(60) NOT NULL,\r\n    created_at timestamp with time zone DEFAULT now(),\r\n    updated_at timestamp with time zone DEFAULT now()\r\n);\r\n\r\nCREATE UNIQUE INDEX users_pkey ON users(id uuid_ops);\r\nCREATE UNIQUE INDEX users_email_key ON users(email text_ops);\r\n```\r\n\r\nI've created entity that matches the table but right now I want to change type of the `id` field. Everything ok, so far. Now I run command: `typeorm migration:generate -n Init` which creates migration file but it fails to properly detect constraint name. It does not see the ID field with the constraint named as `users_pkey` but instead it just uses random hash. So, the migration query looks like follows:\r\n\r\n```sql\r\nALTER TABLE \"users\" DROP CONSTRAINT \"PK_a3ffb1c0c8416b9fc6f907b7433\"\r\nALTER TABLE \"users\" DROP COLUMN \"id\"\r\nALTER TABLE \"users\" ADD \"id\" BIGSERIAL NOT NULL\r\nALTER TABLE \"users\" ADD CONSTRAINT \"PK_a3ffb1c0c8416b9fc6f907b7433\" PRIMARY KEY (\"id\")\r\n```\r\n\r\nand it should look like this:\r\n\r\n```sql\r\nALTER TABLE \"users\" DROP CONSTRAINT \"users_pkey\"\r\nALTER TABLE \"users\" DROP COLUMN \"id\"\r\nALTER TABLE \"users\" ADD \"id\" BIGSERIAL NOT NULL\r\nALTER TABLE \"users\" ADD CONSTRAINT \"PK_a3ffb1c0c8416b9fc6f907b7433\" PRIMARY KEY (\"id\")\r\n```\r\n\r\nI was trying to provide my own constraint name that would match the old one but it doesn't look like possible for the primary key. Do you know about this bug?",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/3274/comments",
    "author": "lukejagodzinski",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2018-12-18T07:00:40Z",
        "body": "own constraint name aren't supported in typeorm. Typeorm rely on its own names to make a proper schema sync. So, current behaviour you see is correct."
      },
      {
        "user": "lukejagodzinski",
        "created_at": "2018-12-20T01:19:08Z",
        "body": "@pleerock ok so I assume that this library is not intended to work with existing databases where we can use custom constraint name? That's not a big deal as I can rename constraint in migration but would be great to at least detect that change on migration. Thanks anyway!"
      },
      {
        "user": "pleerock",
        "created_at": "2018-12-20T05:08:00Z",
        "body": "@lukejagodzinski we try to support existing databases as much as possible, but there are some things like custom constraint name that aren't supported. Maybe we'll try to add this feature in the future, but its not in our priority list currently."
      },
      {
        "user": "lukejagodzinski",
        "created_at": "2018-12-20T14:41:23Z",
        "body": "@pleerock ok thanks for info :) It's definitely nothing blocking anyone from using it. I can just make some manual changes. Thanks!"
      },
      {
        "user": "vegerot",
        "created_at": "2020-03-17T19:05:44Z",
        "body": "@pleerock what about something similar to what you have for migrations: where there is a unique id generated in the front, then a custom name can be given after.  Best of both worlds"
      }
    ]
  },
  {
    "number": 3273,
    "title": "how do I get an empty array when nested join is null? ",
    "created_at": "2018-12-17T17:55:16Z",
    "closed_at": "2019-04-05T20:21:32Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/3273",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[x] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\n\r\nI have this createQueryBuilder below:\r\n\r\n```\r\nconst i = await Item.createQueryBuilder()\r\n        .innerJoinAndSelect('Item.PrimaryUOM', 'uom')\r\n        .leftJoinAndSelect('Item.CycleCountInventorys', 'cci')\r\n        .leftJoinAndSelect('cci.CycleCountDetail', 'ccd')\r\n        .leftJoinAndSelect('ccd.Location', 'cl')\r\n        .where('Item.IsActive = 1')\r\n        .andWhere('(ccd.Id = :CycleCountDetailId OR ccd.Id IS NULL)', { CycleCountDetailId })\r\n        .andWhere(`(Item.Number = :search\r\n                  OR Item.Name = :search\r\n                  OR Item.Barcode = :search)`, { search })\r\n        .getOne()\r\n        console.log(i)\r\n```\r\n\r\nHere is what it logs:\r\n\r\n```\r\nItem {\r\n  Id: 16237,\r\n  IsActive: true,\r\n  IsKitted: false,\r\n  Number: 'Item 1',\r\n  Name: 'Item Name 1',\r\n  Barcode: '023535819999',\r\n  UnitPrice: 2.99,\r\n  UnitCost: 0.88,\r\n  UnitsOnHand: 18,\r\n  UnitsOnOrder: 0,\r\n  UnitsReserved: 0,\r\n  UnitsAvailable: 18,\r\n  LastModifiedBy: 1,\r\n  LastModifiedDate: 2018-09-21T15:20:02.217Z,\r\n  CycleCountInventorys:\r\n   [ CycleCountInventory {\r\n       IsApproved: null,\r\n       Units: null,\r\n       CreatedDate: null,\r\n       LastModifiedDate: null,\r\n       CycleCountDetail: null } ] }\r\n```\r\nHow can I get CycleCountInventorys to return an empty array when everything inside of it is null?\r\n\r\nI notice if I remove the second .leftJoinAndSelect, it returns an empty array.\r\n\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/3273/comments",
    "author": "wrod7",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2018-12-18T07:02:32Z",
        "body": "results that you have is built from SQL query you have built. Determine what SQL you need to create, create it and execute to get results are you expecting."
      },
      {
        "user": "wrod7",
        "created_at": "2018-12-18T15:11:08Z",
        "body": "If I remove these two left joins:\r\n\r\n```\r\n.leftJoinAndSelect('cci.CycleCountDetail', 'ccd')\r\n.leftJoinAndSelect('ccd.Location', 'cl')\r\n```\r\n\r\nI get the results that I want. An empty array for \"CycleCountInventorys\"\r\n```\r\nItem {\r\n  Id: 16237,\r\n  IsActive: true,\r\n  IsKitted: false,\r\n  Number: 'Item 1',\r\n  Name: 'Item Name 1',\r\n  Barcode: '023535819999',\r\n  UnitPrice: 2.99,\r\n  UnitCost: 0.88,\r\n  UnitsOnHand: 18,\r\n  UnitsOnOrder: 0,\r\n  UnitsReserved: 0,\r\n  UnitsAvailable: 18,\r\n  LastModifiedBy: 1,\r\n  LastModifiedDate: 2018-09-21T15:20:02.217Z,\r\n  CycleCountInventorys: [ ] }\r\n```\r\n\r\nhow can I get an empty array when I have those two joins added when the cyclecountinventory object is full of nulls?"
      },
      {
        "user": "pleerock",
        "created_at": "2018-12-19T11:16:28Z",
        "body": "I think you didn't read my message properly. First determine what SQL you need to build, then build and run it. Then try to build it using typeorm."
      }
    ]
  },
  {
    "number": 3272,
    "title": "How to get changes/diff inside model hooks",
    "created_at": "2018-12-17T17:26:02Z",
    "closed_at": "2018-12-24T16:30:25Z",
    "labels": [
      "question",
      "can be closed?"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/3272",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[ ] bug report\r\n[ ] feature request\r\n[x] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[x] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)z\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nI can't find in the documentation a way to get \"changes\" inside Listeners and/or Subscribers ?\r\n\r\nThe behaviour I'm lookig for is something like this :\r\n```\r\n@Entity()\r\nexport class User extends BaseEntity {\r\n  @BeforeUpdate()\r\n  doSomething(changes: Partial<User>) {\r\n    if (this.field != changes.field) {\r\n      // Then do your thing\r\n    }\r\n  }\r\n}\r\n```",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/3272/comments",
    "author": "Kayyow",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2018-12-18T07:15:02Z",
        "body": "you can't. Some of information is available in subscribers, try subscribers instead. "
      },
      {
        "user": "Kayyow",
        "created_at": "2018-12-24T16:36:44Z",
        "body": "Thanks. I created a Subscriber and I can now get changes by comparing `event.entity` to `event.databaseEntity` fields :\r\n\r\n```\r\n@EventSubscriber()\r\nexport class UserSubscriber implements EntitySubscriberInterface<User> {\r\n\r\n  beforeUpdate(event: UpdateEvent<User>) {\r\n    const { entity, databaseEntity } = event\r\n    if (entity && databaseEntity) {\r\n      // entity = user with updated fields\r\n      // databaseEntity = user currently in database before update\r\n      // Then check changes between :entity and :databaseEntity\r\n    }\r\n  }\r\n\r\n}\r\n```\r\n"
      }
    ]
  },
  {
    "number": 3269,
    "title": "Paginate by updatedAt from previous results",
    "created_at": "2018-12-17T11:57:39Z",
    "closed_at": "2018-12-20T07:19:30Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/3269",
    "body": "**Issue type:**\r\n\r\n[ X] question\r\n\r\n**Database system/driver:**\r\n\r\n[X ] `postgres`\r\n\r\n**TypeORM version:**\r\n\r\n[X ] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\nHi,\r\n\r\nI'm trying to build a cursor based pagination and using `updatedAt` to sort the results, for that I need the previous latest cursor with the value of `updatedAt`. But the problem is that the data returned as an object, but I need to use the value in the database to be able to sort by it. \r\n\r\nAny ideas? \r\n\r\nThanks!",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/3269/comments",
    "author": "pontusab",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2018-12-19T14:21:41Z",
        "body": "Can you please explain in details and how your request is related to typeorm?"
      },
      {
        "user": "pontusab",
        "created_at": "2018-12-19T19:06:02Z",
        "body": "Yep, how can I get the value return exactly as it is in the database? If the saved value is `2018-12-15 14:25:47.032796` but instead it gives me a date object. Is there a way to get the value like how its saved in the column? "
      },
      {
        "user": "pleerock",
        "created_at": "2018-12-20T05:44:13Z",
        "body": "Its returned as a Date because almost all use cases prefer to use Date object. You have a Date object, so if you need it in a string format, just convert it to the format you need."
      }
    ]
  },
  {
    "number": 3252,
    "title": "QueryFailedError: ER_PARSE_ERROR when I am trying update data with createQueryBuilder",
    "created_at": "2018-12-14T07:37:34Z",
    "closed_at": "2018-12-27T20:07:27Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/3252",
    "body": "**Issue type:**\r\n\r\n[x ] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[x ] `mssql`\r\n[ x] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[ ] `latest`\r\n[ ] `@next`\r\n[ x] `0.x.x` (^0.2.9)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nI am using an example from your official documentation. And I am getting the next error.\r\nAm I doing something wrong?\r\n> QueryFailedError: ER_PARSE_ERROR: You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'WHERE `id` = 12' at line 1\r\n\r\n```\r\n@httpPatch('/:userId')\r\n    public async updateUserProfile(@requestParam(\"userId\") userId: number, @request() req: express.Request, @response() res: express.Response) {\r\n        const authData: UserDataInterface = req.body; \r\n        const user = await getConnection()\r\n        .createQueryBuilder()\r\n        .update(User)\r\n        .set(authData)\r\n        .where(\"id = :id\", { id: Number(userId) })\r\n        .execute();\r\n       return user;\r\n    }\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/3252/comments",
    "author": "aroksetx",
    "comments": [
      {
        "user": "vlapo",
        "created_at": "2018-12-16T11:18:15Z",
        "body": "Hi @aroksetx.\r\n\r\nCould you please use method `getQueryAndParameters()` instead of execute and provide output? Maybe there is problem with `authData`. This is really hard to say. "
      },
      {
        "user": "pleerock",
        "created_at": "2018-12-20T08:07:34Z",
        "body": "Yes my guess is also to `authData`. Try to log it, if its empty, make sure you are passing your data correctly from the client you use."
      },
      {
        "user": "aroksetx",
        "created_at": "2018-12-27T20:07:14Z",
        "body": "@vlapo 10x. I changed on `getQueryAndParameters `"
      },
      {
        "user": "vlapo",
        "created_at": "2018-12-28T00:26:22Z",
        "body": "Happy to help @aroksetx :-)"
      }
    ]
  },
  {
    "number": 3250,
    "title": "[psql] Creating migration for already existing table",
    "created_at": "2018-12-14T00:15:16Z",
    "closed_at": "2018-12-14T13:07:33Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/3250",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[x] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\nI'm trying to create migration that would work with already existing database. I have a table which has two fields:\r\n\r\n```\r\nid BIGSERIAL PRIMARY KEY,\r\norg_id BIGSERIAL UNIQUE,\r\n```\r\n\r\nand in the TS class I have fields defined in the following way:\r\n\r\n```ts\r\n@PrimaryGeneratedColumn()\r\nreadonly id: number;\r\n\r\n@Column(\"bigint\", { name: \"org_id\", unique: true })\r\norgId: number;\r\n```\r\n\r\nand it keeps creating migrations for those two fields. Is there a way to define those two fields that would not create migration?",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/3250/comments",
    "author": "lukejagodzinski",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2018-12-14T03:55:49Z",
        "body": "Try following:\r\n\r\n```ts\r\n@PrimaryColumn(\"bigint\")\r\n@Generated()\r\nreadonly id: number;\r\n\r\n@Column(\"bigint\", { name: \"org_id\", unique: true })\r\n@Generated()\r\norgId: number;\r\n```"
      },
      {
        "user": "lukejagodzinski",
        "created_at": "2018-12-14T13:07:33Z",
        "body": "@pleerock thanks! It worked!"
      }
    ]
  },
  {
    "number": 3238,
    "title": "can't set ManyToOne columns as primary 0.3.0",
    "created_at": "2018-12-13T05:43:57Z",
    "closed_at": "2018-12-13T07:26:11Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/3238",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[x] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[ ] `latest`\r\n[x] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\n`@ManyToOne(type => Type, { primary: true }) `\r\nerror: primary is not an available option anymore.\r\n\r\nI cannot set a column primary for @ManyToOne columns. It worked for 0.2.9. Why this was removed?\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/3238/comments",
    "author": "fixako",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2018-12-13T07:26:11Z",
        "body": "> `primary` flag has been removed from relation decorators. Now if you want to make a relation primary you must define a primary column with the same name relation uses\r\n\r\njust define a primary column you need, for example:\r\n\r\n```ts\r\n@PrimaryColumn()\r\ntypeId: number\r\n\r\n@ManyToOne(() => Type) // you can also specify a primary column name, e.g. @JoinColumn({ name: \"typeId\" })\r\ntype: Type\r\n```\r\n\r\nThis change was made to simplify lot of things and fix some serious bugs."
      },
      {
        "user": "vogler",
        "created_at": "2019-08-28T09:37:19Z",
        "body": "@pleerock following your example:\r\n~~~typescript\r\n@Entity()\r\nexport class Order extends AutoMeta {\r\n  @PrimaryColumn()\r\n  id: string;\r\n  // ...\r\n  @OneToMany(() => Item, item => item.order, { cascade: true, eager: true })\r\n  items: Item[]\r\n}\r\n@Entity()\r\nexport class Item {\r\n  @ManyToOne(() => Order, order => order.items)\r\n  order: Order;\r\n\r\n  // Use orderId+productId as a composite primary key. PrimaryColumn decoration on ManyToOne directly does not work; need to list the resulting orderId explicitly.\r\n  @PrimaryColumn()\r\n  orderId: string;\r\n\r\n  @PrimaryColumn()\r\n  productId: string;\r\n  // ...\r\n}\r\n  // somewhere else\r\n  await dbm.save(Order, orders);\r\n~~~\r\nThis works once on an empty database, but then fails with `QueryFailedError: SQLITE_CONSTRAINT: NOT NULL constraint failed: item.orderId`.\r\nIs there some further setup needed? Why is it not null for the initial run?"
      },
      {
        "user": "vogler",
        "created_at": "2019-08-28T09:50:23Z",
        "body": "Changing it to this:\r\n~~~typescript\r\n@Entity()\r\nexport class Item {\r\n  @ManyToOne(() => Order, order => order.items, { primary: true })\r\n  order: Order;\r\n\r\n  @PrimaryColumn()\r\n  productId: string;\r\n  // ...\r\n}\r\n~~~\r\nmade it work:\r\n~~~\r\nlitecli> PRAGMA table_info(item)\r\n+-----+---------------+---------+---------+------------+----+\r\n| cid | name          | type    | notnull | dflt_value | pk |\r\n+-----+---------------+---------+---------+------------+----+\r\n| 0   | orderId       | varchar | 1       | <null>     | 1  |\r\n| 1   | productId     | varchar | 1       | <null>     | 2  |\r\n| 2   | name          | varchar | 1       | <null>     | 0  |\r\n...\r\n~~~\r\nuntil I deleted the database - then this approach fails with `QueryFailedError: SQLITE_CONSTRAINT: FOREIGN KEY constraint failed`."
      },
      {
        "user": "vogler",
        "created_at": "2019-08-28T09:57:18Z",
        "body": "Using the first approach, setting orderId explicitly, it fails with `QueryFailedError: SQLITE_CONSTRAINT: UNIQUE constraint failed: item.productId, item.orderId`.\r\nI save the same orders with the same items, `save` should detect that the records are already  there and not try to insert them."
      },
      {
        "user": "vegerot",
        "created_at": "2020-03-17T16:45:34Z",
        "body": "> > `primary` flag has been removed from relation decorators. Now if you want to make a relation primary you must define a primary column with the same name relation uses\r\n> \r\n> just define a primary column you need, for example:\r\n> \r\n> ```ts\r\n> @PrimaryColumn()\r\n> typeId: number\r\n> \r\n> @ManyToOne(() => Type) // you can also specify a primary column name, e.g. @JoinColumn({ name: \"typeId\" })\r\n> type: Type\r\n> ```\r\n> \r\n> This change was made to simplify lot of things and fix some serious bugs.\r\n\r\nI believe he wanted the `ManyToMany` to BE a primary column.  Which, btw, I am getting the same error in PostgreSQL"
      },
      {
        "user": "rjborba",
        "created_at": "2020-05-07T02:23:48Z",
        "body": "I'm also interested on it\r\nFK and PK should coexist on same column."
      },
      {
        "user": "imagine10255",
        "created_at": "2020-05-22T05:15:07Z",
        "body": "+1"
      },
      {
        "user": "willrnch",
        "created_at": "2021-09-30T13:56:11Z",
        "body": "+1"
      },
      {
        "user": "griebdaniel",
        "created_at": "2021-11-17T10:55:51Z",
        "body": "I experienced the same issue in the following scenario: when a table has composite primary keys you have to specify both in the @JoinColumn. \r\n```\r\n@Entity()\r\nexport class PhaseDependency {\r\n  @ManyToOne(type => Phase, {  onDelete: \"CASCADE\", onUpdate: \"CASCADE\", primary: true })\r\n  @JoinColumn([{ name: 'phase', referencedColumnName: 'name' }, { name: 'product', referencedColumnName: 'product' }])\r\n  phase: Phase;\r\n\r\n  @ManyToOne(type => Phase, { onDelete: \"CASCADE\", onUpdate: \"CASCADE\", primary: true })\r\n  @JoinColumn({ name: 'dependency' })\r\n  dependency: string;\r\n}\r\n```\r\nThe issue is that Phase entity had composite primary key, thus I needed to change the second (dependency relation to this):\r\n```\r\n  @ManyToOne(type => Phase, { onDelete: \"CASCADE\", onUpdate: \"CASCADE\", primary: true })\r\n  @JoinColumn([{ name: 'dependency', referencedColumnName: 'name' }, { name: 'productDependency', referencedColumnName: 'product' }])\r\n  dependency: Phase;\r\n```\r\n"
      },
      {
        "user": "shroomist",
        "created_at": "2022-10-04T15:18:39Z",
        "body": "I'm in the same boat, it should be possible to do FK and PK on the same column, did you guys figure out in the end of the day on how to do that correctly in typeorm? the accepted solution seem to be reporting issues, was it fixed? \r\nshould I open a new issue since this was closed?"
      },
      {
        "user": "fabienlege",
        "created_at": "2023-09-14T13:50:10Z",
        "body": "I don't understand : why is this issue closed when there is no solution to this ? @pleerock "
      },
      {
        "user": "jongomes",
        "created_at": "2023-11-07T10:29:16Z",
        "body": "issue too"
      },
      {
        "user": "JesusJimenezG",
        "created_at": "2023-11-13T13:07:11Z",
        "body": "You can add the `@PrimaryColumn` decorator after the `@ManyToOne`, or any other relational decorator where the `@JoinColumn` exists:\r\n\r\n```typescript\r\n  @ManyToOne(() => EventLeaderboard, {\r\n    cascade: false,\r\n    eager: false,\r\n    nullable: false,\r\n    onDelete: 'CASCADE',\r\n  })\r\n  @JoinColumn({\r\n    name: 'event_window_id',\r\n    referencedColumnName: 'eventWindow',\r\n    foreignKeyConstraintName: 'FK_event_leaderboard_entry_event_window_id',\r\n  })\r\n  @PrimaryColumn({\r\n    name: 'event_window_id',\r\n    type: 'varchar',\r\n    length: 255,\r\n    primaryKeyConstraintName: 'PK_event_leaderboard_entry_id',\r\n  })\r\n  leaderboard: EventLeaderboard;\r\n\r\n  @ManyToOne(() => Team, (team) => team.eventLeaderboardEntry, {\r\n    cascade: false,\r\n    eager: false,\r\n    nullable: false,\r\n    onDelete: 'RESTRICT',\r\n  })\r\n  @JoinColumn({\r\n    name: 'team_id',\r\n    referencedColumnName: 'teamId',\r\n    foreignKeyConstraintName: 'FK_event_leaderboard_entry_team_id',\r\n  })\r\n  @PrimaryColumn({\r\n    name: 'team_id',\r\n    type: 'text',\r\n    primaryKeyConstraintName: 'PK_event_leaderboard_entry_id',\r\n  })\r\n  team: Team;\r\n  ```\r\n  \r\n This is an example of composite primary keys, both `@PrimaryColumn`'s `primaryKeyConstraintName` must have the same value/name for TypeORM to generate the correct SQL syntax.\r\n \r\n Now, as for @griebdaniel, when referencing multiple columns as an array in the `@JoinColumn`, you need to explicitly define new `@PrimaryColumn` for each one because the `@PrimaryColumn` decorator doesn't support an array of columns as the `@JoinColumn` decorator does.\r\n \r\n ```typescript\r\n   @PrimaryColumn({\r\n    name: 'event_window_id',\r\n    type: 'varchar',\r\n    length: 255,\r\n    primaryKeyConstraintName: 'PK_event_session_id',\r\n  })\r\n  eventWindowId: string;\r\n\r\n  @PrimaryColumn({\r\n    name: 'team_id',\r\n    type: 'text',\r\n    primaryKeyConstraintName: 'PK_event_session_id',\r\n  })\r\n  teamId: string;\r\n\r\n  @ManyToOne(() => EventLeaderboardEntry, {\r\n    cascade: false,\r\n    eager: false,\r\n    nullable: false,\r\n    onDelete: 'CASCADE',\r\n  })\r\n  @JoinColumn([\r\n    {\r\n      name: 'event_window_id',\r\n      referencedColumnName: 'leaderboard',\r\n      foreignKeyConstraintName: 'FK_event_session_event_window_id',\r\n    },\r\n    {\r\n      name: 'team_id',\r\n      referencedColumnName: 'team',\r\n      foreignKeyConstraintName: 'FK_event_session_team_id',\r\n    },\r\n  ])\r\n  eventLeaderboardEntry: EventLeaderboardEntry;\r\n ```\r\n \r\n Although unnecessary in the business logic side, they're mainly used for TypeORM to create the correct syntax when generating SQL migrations."
      }
    ]
  },
  {
    "number": 3237,
    "title": "Still can't get the update result.raw?",
    "created_at": "2018-12-13T03:51:32Z",
    "closed_at": "2018-12-14T07:08:06Z",
    "labels": [
      "question",
      "can be closed?"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/3237",
    "body": "**Issue type:**\r\n\r\n[ x] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ x] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[ ] `latest`\r\n[ x] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\n<!--\r\n    To answer those questions you need to put \"x\" inside the square brackets, for example:\r\n    [x] `mysql`\r\n    [ ] `postgres`\r\n\r\n    Also, please format your code properly (by taking code blocks into ```ts .... ```)\r\n!>\r\n\r\nUpdateResult {\r\n  generatedMaps: [],\r\n  raw:\r\n   OkPacket {\r\n     fieldCount: 0,\r\n     affectedRows: 1,\r\n     insertId: 0,\r\n     serverStatus: 2,\r\n     warningCount: 0,\r\n     message: '(Rows matched: 1  Changed: 0  Warnings: 0',\r\n     protocol41: true,\r\n     changedRows: 0 }\r\n}\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/3237/comments",
    "author": "copyPrinter",
    "comments": [
      {
        "user": "copyPrinter",
        "created_at": "2018-12-13T03:52:28Z",
        "body": "UpdateResult {\r\n  generatedMaps: [],\r\n  raw:\r\n   OkPacket {\r\n     fieldCount: 0,\r\n     affectedRows: 1,\r\n     insertId: 0,\r\n     serverStatus: 2,\r\n     warningCount: 0,\r\n     message: '(Rows matched: 1  Changed: 0  Warnings: 0',\r\n     protocol41: true,\r\n     changedRows: 0 } \r\n}"
      },
      {
        "user": "pleerock",
        "created_at": "2018-12-13T07:22:47Z",
        "body": "More details?"
      },
      {
        "user": "copyPrinter",
        "created_at": "2018-12-14T00:51:03Z",
        "body": "sorry, is generatedMaps.... I want to know the number of rows and ids updated. But now generatedMaps is always empty"
      },
      {
        "user": "pleerock",
        "created_at": "2018-12-14T03:48:12Z",
        "body": "I'll close this issue if you won't provide more details with a good explanation of your problem."
      },
      {
        "user": "copyPrinter",
        "created_at": "2018-12-14T06:43:06Z",
        "body": "like this, i want 'generatedMaps' can return affectedRows id or entity.\r\n`let ret = await getRepository(Cart).update({`\r\n  `goods_id: goodsId,`\r\n           ` buyer_id: memberId`\r\n        `},{`\r\n          ` goods_num : num`\r\n` });`\r\n\r\n`UpdateResult {`\r\n  `generatedMaps: [],`\r\n  `raw:`\r\n  ` OkPacket {\r\n     fieldCount: 0,\r\n     affectedRows: 1,\r\n     insertId: 0,\r\n     serverStatus: 2,\r\n     warningCount: 0,\r\n     message: '(Rows matched: 1  Changed: 1  Warnings: 0',\r\n     protocol41: true,\r\n     changedRows: 1 } }`\r\n\r\nMy English is bad， If you don't understand I mean，please you close."
      },
      {
        "user": "pleerock",
        "created_at": "2018-12-14T07:08:06Z",
        "body": "`generatedMaps` is used mostly internally. `update` method executes a raw sql query, that's only thing it does. If you want more you need to use `save` method instead."
      },
      {
        "user": "copyPrinter",
        "created_at": "2018-12-14T08:40:20Z",
        "body": "thanks"
      }
    ]
  },
  {
    "number": 3229,
    "title": "How to save entity with ManyToOne with nullable: false set?",
    "created_at": "2018-12-11T10:29:49Z",
    "closed_at": "2018-12-12T15:30:49Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/3229",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[x] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nI'm terribly tired so apologies if the answer is obvious, and I'm just blind and not seeing it.\r\n\r\nAssuming the following two entities:\r\n\r\n```typescript\r\n@Entity()\r\nexport class Parent {\r\n  @PrimaryGeneratedColumn()\r\n  id!: number\r\n\r\n  @OneToMany(type => Child, child => child.parent)\r\n  children!: Child[]\r\n}\r\n\r\n@Entity()\r\nexport class Child {\r\n  @PrimaryGeneratedColumn()\r\n  id!: number\r\n\r\n  @ManyToOne(type => Parent, parent => parent.children, { nullable: false })\r\n  parent!: Parent\r\n}\r\n```\r\n\r\nWhen doing `entityManager.insert(Child, {})`, naturally the error `null value in column \\\"parentId\\\" violates not-null constraint` is thrown. When trying to do `entityManager.insert(Child, { parentId: 1 })`, the same error is thrown though.\r\n\r\nSo how do I create and save new `Child`s with the above model? ",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/3229/comments",
    "author": "draoncc",
    "comments": [
      {
        "user": "vlapo",
        "created_at": "2018-12-12T15:11:51Z",
        "body": "Your `Child` entity do not have defined `parentId` column in entity class. I am getting error in IDE\r\n```\r\nObject literal may only specify known properties, and 'parentId' does not exist in type 'QueryPartialEntity<Child> | QueryPartialEntity<Child>[]'. [2345]\r\n```\r\nSo typeorm will ignore this property value during query build. Of course typeorm know about this join column but entity argument of insert is `QueryPartialEntity<Child>|(QueryPartialEntity<Child>[])` so does not expect `parentId` property.\r\n\r\nThere are two options:\r\n\r\n1. Define additional `parentId` column in `Child` class.\r\n```typescript\r\n@Entity()\r\nexport class Child {\r\n    @PrimaryGeneratedColumn()\r\n    id!: number;\r\n\r\n    @Column()\r\n    parentId: number;\r\n\r\n    @ManyToOne(type => Parent, parent => parent.children, { nullable: false })\r\n    parent!: Parent;\r\n}\r\n```\r\n2. Use little trick and call `insert` method like this:\r\n```typescript\r\nawait entityManager.insert(Child, { parent: { id: 1 } as Parent });\r\n```"
      }
    ]
  },
  {
    "number": 3228,
    "title": "Inserting big arrays",
    "created_at": "2018-12-11T08:10:30Z",
    "closed_at": "2018-12-13T07:20:54Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/3228",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[x] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nI have an array (>50,000 entries) which I want to insert into my table via TypeORM. When doing `entityRepository.insert(entities)` I get an error:\r\n\r\n```\r\nError: bind message supplies 13868 parameters, but prepared statement \"\" requires 669228\r\n```\r\n\r\nThis does not happen when I split the array into multiple arrays (e.g. length of 1000).\r\nWhy does this happen? Isn't this something that TypeORM should handle? Why do I have to split the array myself?",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/3228/comments",
    "author": "wederer",
    "comments": [
      {
        "user": "havenchyk",
        "created_at": "2018-12-11T08:14:43Z",
        "body": "@wederer it can be a good improvement, we have several similar issues, but the general advice would be to split array by yourself, PR is appreciated"
      },
      {
        "user": "wederer",
        "created_at": "2018-12-11T08:30:14Z",
        "body": "@havenchyk Do you have an idea how to implement it, or how other ORMs do it? I have looked at the codebase and InsertQueryBuilder is probably the correct class, but am unsure on the specifics."
      },
      {
        "user": "havenchyk",
        "created_at": "2018-12-11T19:49:14Z",
        "body": "@pleerock @Kononnable ^^"
      },
      {
        "user": "vlapo",
        "created_at": "2018-12-12T22:35:45Z",
        "body": "@wederer Did you try `entityRepository.save(entities, { chunk: entities.length / 1000 })`? This solution works for me.\r\n\r\nBut I think this is nasty contradiction here because `insert` method of manager also contains options with `chunk` but this options are never used in `next` or in `master` branch."
      },
      {
        "user": "pleerock",
        "created_at": "2018-12-13T07:20:54Z",
        "body": "@vlapo is correct, for exactly this problem `chunk` option was created to prevent max parameters problem."
      },
      {
        "user": "chriszrc",
        "created_at": "2019-09-11T21:00:50Z",
        "body": "Is the chunk option anywhere in the current documentation? And why is it missing from insert, since that runs into the same problem?"
      }
    ]
  },
  {
    "number": 3224,
    "title": "createConnection should wait untill database tables are created from entities",
    "created_at": "2018-12-10T07:38:33Z",
    "closed_at": "2019-04-20T21:52:28Z",
    "labels": [
      "question",
      "needs more info"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/3224",
    "body": "**Issue type:**\r\n\r\n[ *] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[* ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[* ] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\nWhen creating a connection using `createConnection` my understanding is it makes a connection object add it to the connection pool and calls its connection method. then what happens if we get the connection from the pool and does a query against a table which is not created yet. (synchronize: true). I think when we use `await` before `createConnection` it should wait until all the entities are created.  \r\n\r\nThis is how i create a connection.\r\n\r\n```ts\r\n(async () => {\r\n  try {\r\n    await createConnection(\"dict\");\r\n  } catch (err) {\r\n   throw err\r\n  }\r\n})()\r\n```\r\nNow make a query fast before database tables are created.\r\n\r\n```ts\r\n  try {\r\n    const dictConnection = await getConnection(\"dict\");\r\n    const entries: Entry[] = [];\r\n\r\n    lines2BeSaved.forEach(item => {\r\n      const entry = new Entry();      \r\n     // adding entry properties\r\n      entries.push(entry);\r\n    });\r\n\r\n    const entryRepo = dictConnection.getRepository(\"entry\");\r\n    await entryRepo.save(entries)\r\n  } catch (err) {\r\n     thow err\r\n  }\r\n```\r\nthe result is the following error:\r\n```\r\nerror: { [Error: SQLITE_ERROR: no such table: entry] errno: 1, code: 'SQLITE_ERROR' }\r\n```\r\nfor now i solved my  problem by adding `setTimeout` around query.",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/3224/comments",
    "author": "P0oOOOo0YA",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2018-12-13T08:11:16Z",
        "body": "it does await everything. It can't be wrong. You definitely do something wrong, please check your code and reproduce your issue in minimal reproduction. You can pull typeorm example repository and check that it works."
      },
      {
        "user": "Kononnable",
        "created_at": "2019-04-20T21:52:28Z",
        "body": "Closing as no response from the author."
      },
      {
        "user": "zment",
        "created_at": "2020-01-26T11:31:45Z",
        "body": "Same pb for me with an ionic cordova angular app and a typeorm cordova connection\r\n\r\nIn my app.component constructor or async ngOnInit(), I call :\r\nawait createConnection(dbOptions);\r\n\r\nIn my first displayed page, in IonViewWillEnter() or IonViewDidEnter(), I call :\r\nconst repository = getConnection().getRepository(Entity);\r\n\r\nI can't await the createConnection and the getRepository(Entity) is called too early :\r\ncore.js:7376 ERROR RepositoryNotFoundError: No repository for \"Entity\" was found\r\n\r\nIn ionic cordova app, it seems that I can't use ormconfig.json"
      },
      {
        "user": "wintertime-inc",
        "created_at": "2020-05-09T23:03:11Z",
        "body": "> Same pb for me with an ionic cordova angular app and a typeorm cordova connection\r\n> \r\n> In my app.component constructor or async ngOnInit(), I call :\r\n> await createConnection(dbOptions);\r\n> \r\n> In my first displayed page, in IonViewWillEnter() or IonViewDidEnter(), I call :\r\n> const repository = getConnection().getRepository(Entity);\r\n> \r\n> I can't await the createConnection and the getRepository(Entity) is called too early :\r\n> core.js:7376 ERROR RepositoryNotFoundError: No repository for \"Entity\" was found\r\n> \r\n> In ionic cordova app, it seems that I can't use ormconfig.json\r\n\r\nI have a feeling that this is common issue, same for me, if process fire too quick, the connection doesn't wait for connected status, problem is that while you await createConnection() it is not connected yet for some milliseconds, looks like bug in library to me.\r\nWhen I tested it with 100ms delay, everything works just fine, otherwise it doesn't work for 1st request on the app."
      },
      {
        "user": "lausek",
        "created_at": "2022-11-08T11:14:04Z",
        "body": "For typeorm v0.2.41 there seems to be an issue with the handling of parallel requests. In case of two requests happening at the same time, the following behavior occurs:\n\n```typescript\nconst connection = container.get<ConnectionProvider>()();\n// First request:   blocks until connection is established.\n// Second request:  returns connection object but isConnected is false.\n```\n\nAs the connection is not established for the second request, it cannot locate any repository.\n\nFor me, this only happens in dev setup. The production service starts way slower, giving the service time to establish the connection.\n\nI \"fixed\" it with some polling:\n\n```typescript\nconst getEstablishedConnection = async (): Promise<Connection> => {\n  const sleep = (ms: number) => new Promise((r) => setTimeout(r, ms));\n\n  return new Promise(async (ok, fail) => {\n    // this should at most take 3s = retriesLeft * sleep = 3 * 1000ms\n    for(let retriesLeft = 3; 0 < retriesLeft; retriesLeft--) {\n      const connection = await container.get<ConnectionProvider>(TYPES.ORMConnection)();\n      if(connection.isConnected) return ok(connection);\n      await sleep(1000);\n    }\n    return fail();\n  });\n};\n```"
      }
    ]
  },
  {
    "number": 3222,
    "title": "VS Code: Cannot find module 'typeorm' with target ES6",
    "created_at": "2018-12-10T03:25:48Z",
    "closed_at": "2018-12-10T16:29:10Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/3222",
    "body": "When I use 'es6' as my target, VS Code will not resolve the 'typeorm' import (other imports are fine).\r\n\r\n``` typescript\r\nimport { Entity, PrimaryGeneratedColumn, Column } from 'typeorm' // [ts] Cannot find module 'typeorm'. [2307]\r\n```\r\n\r\n``` json\r\n{\r\n    \"compilerOptions\": {\r\n        \"allowSyntheticDefaultImports\": true,\r\n        \"esModuleInterop\": true,\r\n        \"outDir\": \"build\",\r\n        \"sourceMap\": true,\r\n        \"target\": \"es6\",\r\n        \"emitDecoratorMetadata\": true,\r\n        \"experimentalDecorators\": true\r\n    },\r\n    \"include\": [\"src/**/*\"],\r\n    \"exclude\": [\"node_modules\"]\r\n}\r\n```\r\n\r\nIf I use `\"target\": \"es5\"` or omit target all together, the import resolves.",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/3222/comments",
    "author": "BinaryShrub",
    "comments": [
      {
        "user": "havenchyk",
        "created_at": "2018-12-10T09:27:21Z",
        "body": "@BinaryShrub what's the result of `tsc --noEmit`?"
      },
      {
        "user": "Telperien",
        "created_at": "2018-12-10T15:52:35Z",
        "body": "Did you try to set the option `\"moduleResolution\": \"node\"` ?"
      },
      {
        "user": "havenchyk",
        "created_at": "2018-12-10T16:29:10Z",
        "body": "Since it's a question, I'm closing this issue for housekeeping purposes, if no answer, try to ask in slack"
      },
      {
        "user": "saltyshiomix",
        "created_at": "2018-12-26T16:24:15Z",
        "body": "@BinaryShrub @havenchyk \r\n\r\nI tested on Mac and Windows with `typeorm@0.2.9`, and I found that there is no `index.js` when installing on Windows. On my Mac works fine.\r\n\r\nThis problem solves `typeorm@0.2.10-rc.2` so I think this is a bug.\r\n\r\nI hope you helped :)"
      },
      {
        "user": "lexNwimue",
        "created_at": "2023-06-28T12:51:30Z",
        "body": "Encountered the same issue today. I'm using typeorm v0.3.17 and typescript v5.1.3. Here's my tsconfig.json:\r\n```ts\r\n{\r\n  \"compilerOptions\": {\r\n    \"target\": \"ES5\",\r\n    \"strictNullChecks\": true,\r\n    \"alwaysStrict\": true,\r\n    \"noUnusedLocals\": true,\r\n    \"noUnusedParameters\": true,\r\n    \"allowJs\": true,\r\n    \"outDir\": \"./dist\",\r\n    \"noEmit\": true,\r\n    \"noEmitOnError\": true,\r\n    \"esModuleInterop\": true,\r\n    \"forceConsistentCasingInFileNames\": true,\r\n    // \"strict\": true,\r\n    \"skipLibCheck\": true,\r\n    \"experimentalDecorators\": true,\r\n    \"emitDecoratorMetadata\": true,\r\n    \"noImplicitAny\": true,\r\n    \"allowSyntheticDefaultImports\": true\r\n  },\r\n  \"exclude\": [\"node_modules\"]\r\n}\r\n\r\n```\r\n\r\nOnly when I changed target to ES5 like @BinaryShrub mentioned, did the error go away. "
      }
    ]
  },
  {
    "number": 3219,
    "title": "current URL string parser is deprecated, and will be removed in a future version. To use the new parser, pass option { useNewUrlParser: true } to MongoClient.connect. SERVER IS RUNNING ON localhost:4000",
    "created_at": "2018-12-09T17:02:59Z",
    "closed_at": "2018-12-13T08:16:58Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/3219",
    "body": "**Issue type:**\r\n\r\n[ ] question\r\n[ ] bug report\r\n[x] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[x] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nHey and again same Issue like the quoted one:\r\n\r\n#2270 \r\n\r\nMongoDb asks to select the **new Url Parser**.\r\n\r\n`(node:25768) DeprecationWarning: current URL string parser is deprecated, and will be removed in a future version. To use the new parser, pass option { useNewUrlParser: true } to MongoClient.connect.` #",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/3219/comments",
    "author": "ArcticSpaceFox",
    "comments": [
      {
        "user": "vlapo",
        "created_at": "2018-12-12T22:56:43Z",
        "body": "There is `useNewUrlParser` option in mongodb connection. Set it to `true` if you are using mongodb driver that requires it. If you do not see `useNewUrlParser` option you are using `next` branch and this change is not merge yet."
      },
      {
        "user": "pleerock",
        "created_at": "2018-12-13T08:16:53Z",
        "body": "@vlapo thank you very much for your answer!"
      }
    ]
  },
  {
    "number": 3218,
    "title": "Cascade delete doesn't work in one-to-one relationship ",
    "created_at": "2018-12-09T11:48:07Z",
    "closed_at": "2020-10-06T07:26:18Z",
    "labels": [
      "bug",
      "question",
      "driver: postgres"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/3218",
    "body": "**Issue type:**\r\n\r\n[ ] question\r\n[x] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[x] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nNot sure it's a bug or a feature, but here it goes: For the one-to-one relationship, cascade delete works only for the inverse side.\r\n\r\nHaving entities like this:\r\n```typescript\r\n@Entity()\r\nclass User {\r\n  @PrimaryGeneratedColumn('uuid')\r\n  id!: string\r\n\r\n  @OneToOne(\r\n    () => Profile,\r\n    profile => profile.user,\r\n    { cascade: true, onDelete: 'CASCADE' },\r\n  )\r\n  @JoinColumn()\r\n  profile!: Profile\r\n}\r\n\r\n@Entity()\r\nclass Profile {\r\n  @PrimaryGeneratedColumn('uuid')\r\n  id!: string\r\n\r\n  @OneToOne(\r\n    () => User,\r\n    user => user.profile,\r\n    { onDelete: 'CASCADE' }, // This line doesn't actually make any difference\r\n  )\r\n  user!: User\r\n}\r\n```\r\nwhat happens is:\r\n```typescript\r\nawait getManager().remove(someProfile) // The profile gets deleted along with the user\r\n```\r\nbut\r\n```typescript\r\nawait getManager().remove(someUser) // The user gets deleted, but the profile stays in place\r\n```\r\n\r\nHow I would like it to work, is the related entities to be actually removed when I define `onDelete: 'CASCADE'` on both sides of the relation.",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/3218/comments",
    "author": "jalooc",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2018-12-13T08:19:52Z",
        "body": "@jalooc do you know how SQL's `onDelete` works? Because it requires this understanding to understand how it works in typeorm (it works same way)"
      },
      {
        "user": "jalooc",
        "created_at": "2018-12-15T17:48:40Z",
        "body": "@pleerock I know how SQL's `ON DELETE` works, but wasn't aware that it's the only thing typeorm does when setting `onDelete: \"CASCADE\"`. Now I know :)\r\n\r\nSo, to get it right - there's no way to perform a cascade delete on one-to-one relation from both sides then? All I'm left with is programatic delete of both entities?"
      },
      {
        "user": "pleerock",
        "created_at": "2018-12-24T09:08:43Z",
        "body": "@jalooc yes, exactly. There is opened issue on programatic cascade remove, but there is no time for its implementation yet (#2784).\r\n\r\n"
      },
      {
        "user": "mateothegreat",
        "created_at": "2020-02-12T06:41:04Z",
        "body": "Put your `@JoinColumn()` on the inverse side (on Profile)."
      },
      {
        "user": "maximosdrr",
        "created_at": "2021-08-31T19:13:15Z",
        "body": "> your `@JoinColumn()` on the inverse side (on Profile).\r\n\r\nIf you do this it will create a circular dependence, so it doesn't works "
      },
      {
        "user": "GreenTech-Solutions",
        "created_at": "2023-08-07T08:22:08Z",
        "body": "Why is this closed, however problem is still persist after 2 years?"
      },
      {
        "user": "vasreb",
        "created_at": "2023-08-22T17:51:19Z",
        "body": "it's still a problem "
      },
      {
        "user": "ashfaqnisar",
        "created_at": "2023-11-13T13:48:45Z",
        "body": "++\r\n"
      },
      {
        "user": "isarojdahal",
        "created_at": "2023-12-14T11:54:10Z",
        "body": "still not working in 2023, Dec 14."
      },
      {
        "user": "tech-magnety-ai",
        "created_at": "2024-02-18T11:51:00Z",
        "body": "Sill not working :( "
      },
      {
        "user": "hamza-trimulabs",
        "created_at": "2024-04-02T07:33:01Z",
        "body": "yeah, still not working!"
      },
      {
        "user": "kuiamenhmartin",
        "created_at": "2024-05-13T14:56:20Z",
        "body": "I was also able to replicate the issue. The cascase on delete does not seem to work on onetoone relatioship."
      },
      {
        "user": "phosmium",
        "created_at": "2024-05-15T15:21:00Z",
        "body": "@pleerock reopen, this is not solved, still a thing"
      },
      {
        "user": "fullstackmaverick",
        "created_at": "2024-05-21T06:38:51Z",
        "body": "This is still an issue! Tried mostly all. I can't logically assign the ownership to the child side to handle case :/ "
      },
      {
        "user": "thekennysong",
        "created_at": "2024-05-31T22:34:31Z",
        "body": "STILL AN ISSUE HELP!"
      },
      {
        "user": "sinapirani",
        "created_at": "2024-09-06T18:46:28Z",
        "body": "Still an issue"
      },
      {
        "user": "joaoaugustogrobe",
        "created_at": "2025-01-08T15:35:32Z",
        "body": "Still an issue"
      },
      {
        "user": "james-astra",
        "created_at": "2025-01-13T00:44:04Z",
        "body": "This is still an issue to this day, why was the ticket closed?"
      },
      {
        "user": "skpn",
        "created_at": "2025-01-21T10:21:21Z",
        "body": "still an issue for me as well\n\nI have multiple tables with one to one relationships to a single child table, meaning I don't want to add a one to one for every single parent table on the child, but just delete from the parent when needed"
      },
      {
        "user": "antoineheseque",
        "created_at": "2025-01-23T13:26:34Z",
        "body": "After a few searches  with OneToOne relations, removing automatically with parent is possible only when JoinColumn is defined in child part, not in parent, in a bidirectional relation.\n```\n@Entity()\nclass Parent {\n  @PrimaryGeneratedColumn('uuid')\n  id!: string\n\n  @OneToOne(\n    () => Children,\n    children => children.parent,\n    { cascade: true }, // Automatically save children when calling \"*.save()\" on Repository<Parent>.\n  )\n  children!: Children\n}\n```\n\n```\n@Entity()\nclass Children {\n  @PrimaryGeneratedColumn('uuid')\n  id!: string\n\n  @OneToOne(\n    () => Parent,\n    parent => parent.children,\n    { onDelete: 'CASCADE' }, // Automatically remove associated Children when calling \"*.remove()\" or \"*.delete()\" on Repository<Parent>.\n  )\n  @JoinColumn()\n  parent!: Parent\n}\n```\n\nBut yeah, it seems that it cannot work on both sides."
      }
    ]
  },
  {
    "number": 3216,
    "title": "Unable to update the length of a column because typeorm would drop the column first",
    "created_at": "2018-12-08T13:21:13Z",
    "closed_at": "2018-12-18T19:12:53Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/3216",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[x] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[x] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[ ] `latest`\r\n[ ] `@next`\r\n[x] `0.2.9`\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\n[x] `postgres`\r\n\r\nI couldn't alter the size of an existing column. These are the queries run by `typeorm` on the altered column:\r\n\r\n````\r\nquery: ALTER TABLE \"feedback\" DROP COLUMN \"plainText\"\r\nquery: ALTER TABLE \"feedback\" ADD \"plainText\" character varying(4000) NOT NULL\r\nquery failed: ALTER TABLE \"feedback\" ADD \"plainText\" character varying(4000) NOT NULL\r\nerror: { error: column \"plainText\" contains null values\r\n````\r\nI don't understand why typeorm would drop the existing column just for updating the size of it. If the column is non-null, dropping it and adding it back would cause data loss and an error. \r\nI would expect a query like this to update the column size:\r\n````\r\nALTER TABLE feedback ALTER \"plainText\" TYPE varchar(4000);\r\n````\r\nIs it a bug in postgres? \r\n\r\n\r\n\r\nTable:\r\n\r\n````\r\nimport {Field, ID, Int, ObjectType} from \"type-graphql\";\r\nimport {\r\n    Column,\r\n    CreateDateColumn,\r\n    Entity,\r\n    Index,\r\n    JoinColumn,\r\n    ManyToOne,\r\n    PrimaryGeneratedColumn,\r\n    UpdateDateColumn\r\n} from \"typeorm\";\r\n\r\n@ObjectType()\r\n@Entity()\r\n@Index(\"suggestion_userId_modelId\", (entity: Feedback) => [entity.userId,entity.modelId])\r\nexport class Feedback{\r\n\r\n    @Field(type=>ID)\r\n    @PrimaryGeneratedColumn()\r\n    id: number;\r\n\r\n    @Field(type=>Int)\r\n    @Column({type:'int'})\r\n    modelId:number;\r\n\r\n    @Field(type=>Int)\r\n    @Column({type:'int'})\r\n    userId;\r\n\r\n    @Field(type=>String)\r\n    @Column({type:'varchar',length:1000})\r\n    plainText:string;\r\n\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/3216/comments",
    "author": "laukaichung",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2018-12-13T08:55:40Z",
        "body": "It is by design. Why? Because not all databases gracefully support this feature, and implementing it to cover all edge cases is too complex.\r\n\r\nLets say you have a length set to `100`. And you have data in. Now lets say you changed it to `10`. What should happen with your data? Right, data loss. Some database ignore this and allow data loss, more strict databases will give you error. Do people want to have errors when they change their `length`? No.\r\n\r\nI suggest you to manually write migration if in your case you can safely convert data length."
      },
      {
        "user": "baio",
        "created_at": "2019-12-19T18:29:04Z",
        "body": "uh oh, that's should be done better at least some clear guidelines how to do this properly since as I suspect the whole word now just run scripts directly on db which is road to hell."
      }
    ]
  },
  {
    "number": 3203,
    "title": "can save many at once",
    "created_at": "2018-12-06T10:07:56Z",
    "closed_at": "2018-12-10T16:38:49Z",
    "labels": [
      "question",
      "can be closed?"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/3203",
    "body": "Repository.save(entityList)\r\nRepository.saveMany(entityList)",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/3203/comments",
    "author": "ewrfedf",
    "comments": [
      {
        "user": "rustamwin",
        "created_at": "2018-12-06T13:40:57Z",
        "body": "Yep"
      },
      {
        "user": "vlapo",
        "created_at": "2018-12-07T11:49:07Z",
        "body": "From Repository.ts:\r\n```typescript\r\n/**\r\n * Saves all given entities in the database.\r\n * If entities do not exist in the database then inserts, otherwise updates.\r\n */\r\nsave<T extends DeepPartial<Entity>>(entities: T[], options: SaveOptions & { reload: false }): Promise<T[]>;\r\nsave<T extends DeepPartial<Entity>>(entities: T[], options?: SaveOptions): Promise<(T & Entity)[]>;\r\n```"
      },
      {
        "user": "havenchyk",
        "created_at": "2018-12-10T16:38:49Z",
        "body": "I'm closing this issue for housekeeping purposes, if something is not clear yet, just continue the conversation or post a message in slack"
      }
    ]
  },
  {
    "number": 3178,
    "title": "Using this.save() in @AfterInsert() to set default json values leads to ER_DUP_ENTRY",
    "created_at": "2018-11-29T11:23:44Z",
    "closed_at": "2018-11-29T11:49:01Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/3178",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[x] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[ ] `latest`\r\n[ ] `@next`\r\n[x] `0.2.8` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\nHello! I would like to add default values to a json field in sql. Since this is not supported i thought to use the after insert method to change the values. \r\n\r\nMinimal demo: \r\n```typescript\r\n\r\n@Entity('sample')\r\nexport class SampleEntity {\r\n  @Column()\r\n  @PrimaryGeneratedColumn('uuid')\r\n  id: string;\r\n\r\n  @Column('json', {\r\n    nullable: true\r\n  })\r\n  sampleObject: SampleObject;\r\n\r\n  @AfterInsert()\r\n  initDefaultValues() {\r\n    if (!this.sampleObject) {\r\n      this.sampleObject = {\r\n        foo: []\r\n      };\r\n    }\r\n    this.save();\r\n  }\r\n}\r\n```\r\nThis leads to: \r\n`error: { Error: ER_DUP_ENTRY: Duplicate entry '531c026c-a7e6-480a-9530-0e3510e82edc' for key 'PRIMARY'\r\n`\r\nand the default values are not set. \r\n\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/3178/comments",
    "author": "creadicted",
    "comments": [
      {
        "user": "creadicted",
        "created_at": "2018-11-29T11:27:39Z",
        "body": "After writing this I had an idea that worked. Solution is to switching to @BeforeInsert() and remove the save. Which makes total sense. \r\n\r\nMinimal demo: \r\n```typescript\r\n\r\n@Entity('sample')\r\nexport class SampleEntity {\r\n  @Column()\r\n  @PrimaryGeneratedColumn('uuid')\r\n  id: string;\r\n\r\n  @Column('json', {\r\n    nullable: true\r\n  })\r\n  sampleObject: SampleObject;\r\n\r\n  @BeforeInsert()\r\n  initDefaultValues() {\r\n    if (!this.sampleObject) {\r\n      this.sampleObject = {\r\n        foo: []\r\n      };\r\n    }\r\n  }\r\n}"
      },
      {
        "user": "pleerock",
        "created_at": "2018-11-29T11:49:01Z",
        "body": "Correct, sometimes reviewing your code really helps 👍 "
      }
    ]
  },
  {
    "number": 3164,
    "title": "Running migrations on MS SQL db tries to create the migrations table on every run",
    "created_at": "2018-11-27T10:24:25Z",
    "closed_at": "2021-07-13T08:44:31Z",
    "labels": [
      "bug",
      "question",
      "comp: migrations",
      "driver: mssql"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/3164",
    "body": "**Issue type:**\r\n\r\n[X] question\r\n[X] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n**Database system/driver:**\r\n[X] `mssql`\r\n**TypeORM version:**\r\n\r\n[ ] `latest`\r\n[ ] `@next`\r\n[X] `0.2.9` (or put your version here)\r\n\r\nHi all\r\n\r\nWe are initiate my first step with TypeORM and GraphQL, we came from Django both on MS and CentOS.\r\n\r\nWe defined a entity User.ts\r\n\r\n`import {Entity, Column, BaseEntity, PrimaryColumn, BeforeInsert} from \"typeorm\";\r\nimport { v4 }  from \"uuid\";\r\n\r\n@Entity('Site.Users')\r\nexport class User extends BaseEntity {\r\n\r\n    @PrimaryColumn(\"uuid\") id: string;\r\n    @Column('varchar', { length: 255 } )\r\n    email: string;\r\n    @Column(\"text\") password: string;\r\n    @Column(\"bit\", { default: false }) confirmed: boolean;\r\n    @Column(\"datetime2\", { precision: 3, default: () => \"CURRENT_TIMESTAMP\", onUpdate: \"CURRENT_TIMESTAMP\"})\r\n    lastUpdate: Date;\r\n    @BeforeInsert()\r\n    addId(){\r\n        this.id = v4();\r\n    }  \r\n}`\r\nand after ran a migration:generate for frist time, we got the following file.\r\n\r\n`\r\nimport {MigrationInterface, QueryRunner} from \"typeorm\";\r\n\r\nexport class initialize1543170970746 implements MigrationInterface {\r\n\r\n    public async up(queryRunner: QueryRunner): Promise<any> {\r\n        await queryRunner.query(`CREATE TABLE \"Site\".\"Users\" (\"id\" uniqueidentifier NOT NULL, \"email\" varchar(255) NOT NULL, \"password\" text NOT NULL, \"confirmed\" bit NOT NULL CONSTRAINT \"DF_73213f34d537ab34e7fef69e996\" DEFAULT 0, \"lastUpdate\" datetime2(3) NOT NULL CONSTRAINT \"DF_8ee361a626ea3fc24b24b04b388\" DEFAULT CURRENT_TIMESTAMP, CONSTRAINT \"PK_21084ba4d97b75818da72d9314a\" PRIMARY KEY (\"id\"))`);\r\n    }\r\n\r\n    public async down(queryRunner: QueryRunner): Promise<any> {\r\n        await queryRunner.query(`DROP TABLE \"Site\".\"Users\"`);\r\n    }\r\n}\r\n`\r\n\r\nwe need to add feature, add two column blocked and retries, to my entity User and change User.ts like this:\r\n`\r\nimport {Entity, Column, BaseEntity, PrimaryColumn, BeforeInsert} from \"typeorm\";\r\nimport { v4 }  from 'uuid';\r\n\r\n@Entity('Site.Users')\r\nexport class User extends BaseEntity {\r\n\r\n    @PrimaryColumn(\"uuid\") id: string;\r\n    @Column('varchar', { length: 255 } )\r\n    email: string;\r\n    @Column(\"text\") password: string;\r\n    @Column(\"bit\", { default: false }) confirmed: boolean;\r\n    @Column(\"bit\", { default: false }) blocked: boolean;\r\n    @Column(\"int\", { default: 0 }) retries: number;**\r\n    @Column(\"datetime2\", { precision: 3, default: () => \"CURRENT_TIMESTAMP\", onUpdate: \"CURRENT_TIMESTAMP\"})\r\n    lastUpdate: Date;\r\n\r\n    @BeforeInsert()\r\n    addId(){\r\n        this.id = v4();\r\n    }  \r\n}\r\n`\r\n\r\nand after migration:generate we got this file:\r\n`import {MigrationInterface, QueryRunner} from \"typeorm\";\r\n\r\nexport class userBlockedRetries1543251926792 implements MigrationInterface {\r\n        await queryRunner.query(`CREATE TABLE \"Site\".\"Users\" (\"id\" uniqueidentifier NOT NULL, \"email\" varchar(255) NOT NULL, \"password\" text NOT NULL, \"confirmed\" bit NOT NULL CONSTRAINT \"DF_73213f34d537ab34e7fef69e996\" DEFAULT 0, \"blocked\" bit NOT NULL CONSTRAINT \"DF_a0be8c102f7105d34cf2daef02b\" DEFAULT 0, \"retries\" int NOT NULL CONSTRAINT \"DF_995cc9d2d7fd0cba57e3e3e8bd3\" DEFAULT 0, \"lastUpdate\" datetime2(3) NOT NULL CONSTRAINT \"DF_8ee361a626ea3fc24b24b04b388\" DEFAULT CURRENT_TIMESTAMP, CONSTRAINT \"PK_21084ba4d97b75818da72d9314a\" PRIMARY KEY (\"id\"))`);\r\n    }\r\n\r\n    public async down(queryRunner: QueryRunner): Promise<any> {\r\n        await queryRunner.query(`DROP TABLE \"Site\".\"Users\"`);\r\n    }\r\n}`\r\n\r\nSo was we told we came from django/python and in there this is create and update my schemas as we need, here is look the **TypeORM** try to create all the time all tables.\r\n\r\nOf, course we can change manually each migration file, but we prefered to do automatically all **sql files** we need to do that refreash my database.\r\n\r\nAlso, when we implement on production we have sure all stuff are write done.\r\n\r\nAny ideais we can walk to resolve this, or any more information, to help me please just say.\r\n\r\nThks to all.",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/3164/comments",
    "author": "PJCAfonso",
    "comments": [
      {
        "user": "JJesi",
        "created_at": "2019-04-10T07:28:09Z",
        "body": "how to add new columns  programmatic because my application on production."
      },
      {
        "user": "osnersanchez",
        "created_at": "2019-05-27T00:59:03Z",
        "body": "I am having this same problem when generating a second migration"
      },
      {
        "user": "osnersanchez",
        "created_at": "2019-06-12T02:39:14Z",
        "body": "Looking more closely at my problem I came to the conclusion that it was caused by the use of CamelCase in the names of my tables, when generating the tables they were all created with mini letters, and in the next migration to create the same tables, solve it Substituting CamelCase for '_' for tables with compound names."
      },
      {
        "user": "imnotjames",
        "created_at": "2021-07-13T08:44:31Z",
        "body": "This seems to be fixed at this point.  I can't replicate, at least.  Closing!"
      },
      {
        "user": "nwinger",
        "created_at": "2021-10-05T11:05:06Z",
        "body": "Still experiencing this issue, when generating new migrations it also tries to recreate existing tables in the database.\r\n\r\nInitial migration:\r\n```\r\nimport {MigrationInterface, QueryRunner} from \"typeorm\";\r\n\r\nexport class SetupTables1632990676704 implements MigrationInterface {\r\n    name = 'SetupTables1632990676704'\r\n\r\n    public async up(queryRunner: QueryRunner): Promise<void> {\r\n        await queryRunner.query(`CREATE TABLE \"CommandCenterDB\"..\"tenant\" (\"id\" uniqueidentifier NOT NULL CONSTRAINT \"DF_da8c6efd67bb301e810e56ac139\" DEFAULT NEWSEQUENTIALID(), \"azureTenantId\" nvarchar(255) NOT NULL, \"azureTenantName\" nvarchar(255) NOT NULL, \"azureAnalyticsId\" nvarchar(255), \"createdAt\" datetime2 NOT NULL CONSTRAINT \"DF_32013feb275f7a0f41c451cd0df\" DEFAULT getdate(), \"updatedAt\" datetime2 NOT NULL CONSTRAINT \"DF_f2facb95edfc89041b6ed1fdbf6\" DEFAULT getdate(), CONSTRAINT \"PK_da8c6efd67bb301e810e56ac139\" PRIMARY KEY (\"id\"))`);\r\n        await queryRunner.query(`CREATE TABLE \"CommandCenterDB\"..\"action\" (\"id\" uniqueidentifier NOT NULL CONSTRAINT \"DF_2d9db9cf5edfbbae74eb56e3a39\" DEFAULT NEWSEQUENTIALID(), \"tenantId\" uniqueidentifier NOT NULL, \"azureTenantId\" nvarchar(255) NOT NULL, \"description\" nvarchar(255) NOT NULL, \"handledByCustomer\" bit NOT NULL, \"createdAt\" datetime2 NOT NULL CONSTRAINT \"DF_e71b65767b8c972fdc972c878fd\" DEFAULT getdate(), \"updatedAt\" datetime2 NOT NULL CONSTRAINT \"DF_5b3b6c0dd17aaa4d15741324380\" DEFAULT getdate(), CONSTRAINT \"PK_2d9db9cf5edfbbae74eb56e3a39\" PRIMARY KEY (\"id\"))`);\r\n        await queryRunner.query(`ALTER TABLE \"CommandCenterDB\"..\"action\" ADD CONSTRAINT \"FK_ca0d00bd66ca6bc1376f8823026\" FOREIGN KEY (\"tenantId\") REFERENCES \"CommandCenterDB\"..\"tenant\"(\"id\") ON DELETE NO ACTION ON UPDATE NO ACTION`);\r\n    }\r\n\r\n    public async down(queryRunner: QueryRunner): Promise<void> {\r\n        await queryRunner.query(`ALTER TABLE \"CommandCenterDB\"..\"action\" DROP CONSTRAINT \"FK_ca0d00bd66ca6bc1376f8823026\"`);\r\n        await queryRunner.query(`DROP TABLE \"CommandCenterDB\"..\"action\"`);\r\n        await queryRunner.query(`DROP TABLE \"CommandCenterDB\"..\"tenant\"`);\r\n    }\r\n\r\n}\r\n```\r\n\r\n\r\nGenerating a new migration, which adds a table:\r\n```\r\nimport {MigrationInterface, QueryRunner} from \"typeorm\";\r\n\r\nexport class AddAlert1633431056839 implements MigrationInterface {\r\n    name = 'AddAlert1633431056839'\r\n\r\n    public async up(queryRunner: QueryRunner): Promise<void> {\r\n        await queryRunner.query(`CREATE TABLE \"CommandCenterDB\"..\"alert\" (\"id\" uniqueidentifier NOT NULL CONSTRAINT \"DF_ad91cad659a3536465d564a4b2f\" DEFAULT NEWSEQUENTIALID(), \"azureTenantId\" nvarchar(255) NOT NULL, \"tenantId\" uniqueidentifier, \"title\" nvarchar(255) NOT NULL, \"alert\" nvarchar(255) NOT NULL, \"alertDescription\" nvarchar(255) NOT NULL, \"alertType\" nvarchar(255) NOT NULL, \"severity\" int NOT NULL, \"customer\" nvarchar(255) NOT NULL, \"pointOfContact\" nvarchar(255) NOT NULL, \"email\" nvarchar(255) NOT NULL, \"phone\" nvarchar(255) NOT NULL, \"statusValue\" nvarchar(255) NOT NULL, CONSTRAINT \"PK_ad91cad659a3536465d564a4b2f\" PRIMARY KEY (\"id\"))`);\r\n        await queryRunner.query(`CREATE TABLE \"CommandCenterDB\"..\"tenant\" (\"id\" uniqueidentifier NOT NULL CONSTRAINT \"DF_da8c6efd67bb301e810e56ac139\" DEFAULT NEWSEQUENTIALID(), \"azureTenantId\" nvarchar(255) NOT NULL, \"azureTenantName\" nvarchar(255) NOT NULL, \"azureAnalyticsId\" nvarchar(255), \"createdAt\" datetime2 NOT NULL CONSTRAINT \"DF_32013feb275f7a0f41c451cd0df\" DEFAULT getdate(), \"updatedAt\" datetime2 NOT NULL CONSTRAINT \"DF_f2facb95edfc89041b6ed1fdbf6\" DEFAULT getdate(), CONSTRAINT \"PK_da8c6efd67bb301e810e56ac139\" PRIMARY KEY (\"id\"))`);\r\n        await queryRunner.query(`CREATE TABLE \"CommandCenterDB\"..\"action\" (\"id\" uniqueidentifier NOT NULL CONSTRAINT \"DF_2d9db9cf5edfbbae74eb56e3a39\" DEFAULT NEWSEQUENTIALID(), \"tenantId\" uniqueidentifier NOT NULL, \"azureTenantId\" nvarchar(255) NOT NULL, \"description\" nvarchar(255) NOT NULL, \"handledByCustomer\" bit NOT NULL, \"createdAt\" datetime2 NOT NULL CONSTRAINT \"DF_e71b65767b8c972fdc972c878fd\" DEFAULT getdate(), \"updatedAt\" datetime2 NOT NULL CONSTRAINT \"DF_5b3b6c0dd17aaa4d15741324380\" DEFAULT getdate(), CONSTRAINT \"PK_2d9db9cf5edfbbae74eb56e3a39\" PRIMARY KEY (\"id\"))`);\r\n        await queryRunner.query(`ALTER TABLE \"CommandCenterDB\"..\"alert\" ADD CONSTRAINT \"FK_fb7bb5dc8fa0b2e5d1459c977be\" FOREIGN KEY (\"tenantId\") REFERENCES \"CommandCenterDB\"..\"tenant\"(\"id\") ON DELETE NO ACTION ON UPDATE NO ACTION`);\r\n        await queryRunner.query(`ALTER TABLE \"CommandCenterDB\"..\"action\" ADD CONSTRAINT \"FK_ca0d00bd66ca6bc1376f8823026\" FOREIGN KEY (\"tenantId\") REFERENCES \"CommandCenterDB\"..\"tenant\"(\"id\") ON DELETE NO ACTION ON UPDATE NO ACTION`);\r\n    }\r\n\r\n    public async down(queryRunner: QueryRunner): Promise<void> {\r\n        await queryRunner.query(`ALTER TABLE \"CommandCenterDB\"..\"action\" DROP CONSTRAINT \"FK_ca0d00bd66ca6bc1376f8823026\"`);\r\n        await queryRunner.query(`ALTER TABLE \"CommandCenterDB\"..\"alert\" DROP CONSTRAINT \"FK_fb7bb5dc8fa0b2e5d1459c977be\"`);\r\n        await queryRunner.query(`DROP TABLE \"CommandCenterDB\"..\"action\"`);\r\n        await queryRunner.query(`DROP TABLE \"CommandCenterDB\"..\"tenant\"`);\r\n        await queryRunner.query(`DROP TABLE \"CommandCenterDB\"..\"alert\"`);\r\n    }\r\n\r\n}\r\n\r\n```\r\nNotice the tables \"tenant\" and \"action\" are being recreated with the last migration, which yields this error:\r\n`Error: There is already an object named 'tenant' in the database.`\r\n\r\nCurrently running typeorm version 0.2.37\r\n"
      }
    ]
  },
  {
    "number": 3145,
    "title": "No empty array on one to many relationship",
    "created_at": "2018-11-21T19:38:31Z",
    "closed_at": "2021-03-29T10:34:56Z",
    "labels": [
      "bug",
      "question",
      "driver: mysql",
      "driver: postgres",
      "driver: mariadb"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/3145",
    "body": "**Issue type:**\r\n\r\n[x ] question\r\n[x ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[x ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[x ] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\nWith the following setup, relation does not return an empty array, but an object with all properties set to null:\r\n\r\n```ts\r\n@Entity()\r\nexport class MenuItemPrice {\r\n    @Column()\r\n    price: number;\r\n\r\n    @ManyToOne(type => Menu, menu => menu.menuItems, { primary: true })\r\n    @JoinColumn({ name: 'menu_id' })\r\n    menu: Menu;\r\n\r\n    @ManyToOne(type => MenuItem, menuItem => menuItem.menus, { primary: true })\r\n    @JoinColumn({ name: 'menu_item_id' })\r\n    menuItem: MenuItem;\r\n}\r\n```\r\n\r\n```ts\r\n@Entity()\r\nexport class Menu {\r\n    @PrimaryColumn()\r\n    id: number;\r\n\r\n    @Type(() => MenuItemPrice)\r\n    @OneToMany(type => MenuItemPrice, menuItemPrice => menuItemPrice.menu)\r\n    menuItems: MenuItemPrice[];\r\n}\r\n```\r\n\r\n```ts\r\n@Entity()\r\nexport class MenuItem {\r\n    @PrimaryColumn()\r\n    id: number;\r\n\r\n    @OneToMany(type => MenuItemPrice, menuItemPrice => menuItemPrice.menuItem)\r\n    menus: MenuItemPrice[];\r\n}\r\n```\r\n\r\nNow, when fetching with e.g. `findOne(1)` and table `Menu` has 1 record and table `MenuItem` has no records, I get the following result, when `menuItems` property should be just an empty array:\r\n\r\n```json\r\n{\r\n    \"id\": 1,\r\n    \"menuItems\": [\r\n        {\r\n            \"price\": null,\r\n            \"menuItem\": null\r\n        }\r\n    ]\r\n}\r\n```\r\n\r\nAm I doing something wrong or is this expected?",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/3145/comments",
    "author": "atte-backman",
    "comments": [
      {
        "user": "mfaizanse",
        "created_at": "2019-09-06T11:55:38Z",
        "body": "Related to #3163. "
      }
    ]
  },
  {
    "number": 3085,
    "title": "How do you create a new bit field using default?",
    "created_at": "2018-11-09T17:56:58Z",
    "closed_at": "2021-07-04T03:39:23Z",
    "labels": [
      "question",
      "driver: mssql"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/3085",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[x] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[x ] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n1. Create an Entity class with a mssql typeORM configuration\r\n2. Synchronize to create the table for your entity\r\n3. Attempt to add a new bit field to the entity using a default and synchronize\r\n\r\nI am trying to create a new bit field on my User class by using the synchronize feature and I keep running into this error ```QueryFailedError: Error: ALTER TABLE only allows columns to be added that can contain nulls, or have a DEFAULT definition specified, or the column being added is an identity or timestamp column, or alternatively if none of the previous conditions are satisfied the table must be empty to allow addition of this column. Column 'enabled' cannot be added to non-empty table 'User' because it does not satisfy these conditions.```\r\n\r\nSince I'm using mssql, the field would be a bit and I have tried the following with no luck:\r\n```\r\n@Column({ default: 'true' })\r\n    enabled: boolean;\r\n\r\n@Column({ default: true })\r\n    enabled: boolean;\r\n\r\n@Column({ default: '1' })\r\n    enabled: boolean;\r\n\r\n@Column({ default: 1 })\r\n    enabled: boolean;\r\n```\r\nAm I doing something incorrectly, or is this possibly a bug? Thank you for your help\r\n\r\n<!--\r\n    To answer those questions you need to put \"x\" inside the square brackets, for example:\r\n    [x] `mysql`\r\n    [ ] `postgres`\r\n\r\n    Also, please format your code properly (by taking code blocks into ```ts .... ```)\r\n!>",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/3085/comments",
    "author": "ccarbonellbh",
    "comments": [
      {
        "user": "btxtiger",
        "created_at": "2018-11-09T18:32:22Z",
        "body": "Did you try it this way? In MySQL you would store a boolean as `tinyint`, which results in type number. I guess it should work for MSSQL in the same way.\r\n```ts\r\n@Column('bit', { default: 1 })\r\n   enabled: number;\r\n```"
      },
      {
        "user": "ccarbonellbh",
        "created_at": "2018-11-09T18:43:08Z",
        "body": "Thanks for the suggestion! Still no luck that way either though :("
      },
      {
        "user": "btxtiger",
        "created_at": "2018-11-09T18:45:44Z",
        "body": "Does it fail with the same error? What happens if you don't set a default or you set type to :any instead number?"
      },
      {
        "user": "ccarbonellbh",
        "created_at": "2018-11-09T19:33:48Z",
        "body": "Yep, it fails with the same error. Same with not using default and with using :any"
      },
      {
        "user": "pburrows",
        "created_at": "2018-11-15T15:57:13Z",
        "body": "I am experiencing the same issue. I am trying to add a new column to a pre-existing entity, defined like this:\r\n\r\n```\r\n    @Column({type: 'bit', default: true})\r\n    public isRequired: boolean;\r\n```\r\n\r\nyet the SQL that TypeOrm generates and tries to run is this:\r\n\r\n```\r\nALTER TABLE \"PayCategoryNoteSettingRecords\" ADD \"isRequired\" bit NOT NULL\r\n```\r\n\r\nNote the lack of a DEFAULT keyword in the sql statement.\r\n\r\nThis behaves the same if I put true or 1 or false or 0, it does not try to set the default at all.\r\n\r\n"
      },
      {
        "user": "kuklei",
        "created_at": "2019-10-14T13:10:11Z",
        "body": "personal test show that this should be the correct syntax from in mssql. note the double and single quotes inside \" 'true' \"\r\n@Column(\"bit\",{ \r\n        nullable:true,\r\n        default: () => \"'true'\",\r\n        name:\"active\"\r\n        })\r\n    active:boolean | null;"
      },
      {
        "user": "imnotjames",
        "created_at": "2021-07-04T03:39:23Z",
        "body": "This seems to be resolved in the latest release."
      }
    ]
  },
  {
    "number": 3084,
    "title": "Transaction with arrays",
    "created_at": "2018-11-09T15:52:28Z",
    "closed_at": "2018-12-10T18:00:37Z",
    "labels": [
      "question",
      "can be closed?"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/3084",
    "body": "**Issue type:**\r\n\r\n[x ] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[x ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[ x] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nIs there a way to add queries from array.map to a transaction? I have tried both approach in the transactions doc but I always get \"Query runner already released. Cannot run queries anymore.\" error.\r\n\r\n```ts\r\nconst queryRunner = getConnection().createQueryRunner();\r\n\r\nawait queryRunner.startTransaction();\r\n\r\ntry {\r\n    const manager = queryRunner.manager;\r\n\r\n    // update name, members and custom field values\r\n    await manager.save(EntryEntity.create({\r\n        id: entry.id,\r\n        name: data.name,\r\n        members: data.members.map(id => ({ id })),\r\n        fieldValues: data.customFields,\r\n    }));\r\n\r\n    if (!entryCompleted) {\r\n        await data.documents.map(async document => {\r\n            const docToSave = { ...document, entryId: entry.id };\r\n            // executes the first iteration and then fails\r\n            if (!document.id) {\r\n                await manager.save(DocumentEntity.create(docToSave)); // create new\r\n            } else if (document.id) {\r\n                const origin = entries.documents.find(doc => doc.id === document.id);\r\n                if (origin.status === 0) {\r\n                    await manager.save(Document.create(docToSave)); // update existing\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    await queryRunner.commitTransaction();\r\n} catch (err) {\r\n    await queryRunner.rollbackTransaction();\r\n} finally {\r\n    await queryRunner.release();\r\n}\r\n```\r\nWithout the documents.map it works as expected, updates the entry name, members and fieldValues but it returns too early from the loop.\r\n\r\nDo you have any suggestions please?\r\nThanks.",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/3084/comments",
    "author": "univerze",
    "comments": [
      {
        "user": "Kononnable",
        "created_at": "2018-12-08T21:36:22Z",
        "body": "`Array.map()` is not awaitable - it doesn't return promise. You should use `Promise.all()`."
      },
      {
        "user": "havenchyk",
        "created_at": "2018-12-10T18:00:37Z",
        "body": "I'm closing this issue for housekeeping purposes, if something is not clear yet, just continue the conversation or post a message in slack"
      }
    ]
  },
  {
    "number": 3035,
    "title": "Same table column with reference for two foreign key of different tables",
    "created_at": "2018-11-02T20:37:28Z",
    "closed_at": "2020-10-10T09:54:15Z",
    "labels": [
      "bug",
      "question",
      "new feature",
      "driver: postgres",
      "driver: oracle"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/3035",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[x] bug report\r\n[x] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[x] `oracle`\r\n[x] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\n**-- Create table**\r\ncreate table LINE(id   NUMBER not null, name VARCHAR2(30) not null);\r\nalter table LINE add constraint LINE_PK primary key (ID);\r\ncreate table MODEL(id NUMBER not null, line_id NUMBER not null, name VARCHAR2(30) not null);\r\nalter table MODEL add constraint MODEL_PK primary key (LINE_ID, ID);\r\nalter table MODEL add constraint MODEL_LINE_FK foreign key (LINE_ID) references LINE (ID);\r\ncreate table PRODUCT(id NUMBER not null, line_id NUMBER, model_id NUMBER, name VARCHAR2(50) not null);\r\nalter table PRODUCT add constraint PRODUCT_PK primary key (ID);\r\nalter table PRODUCT add constraint PRODUCT_LINE_FK foreign key (LINE_ID) references LINE (ID);\r\nalter table PRODUCT add constraint PRODUCT_MODEL_FK foreign key (LINE_ID, MODEL_ID) references MODEL (LINE_ID, ID);\r\n\r\n**-- Insert records**\r\ninsert into LINE (id, name) values (1, 'Line 1');\r\ninsert into MODEL (id, line_id, name) values (1, 1, 'Model 1');\r\ninsert into PRODUCT (id, line_id, model_id, name) values (1, 1, null, 'Product 1 - Only Line without Model');\r\ninsert into PRODUCT (id, line_id, model_id, name) values (2, 1, 1, 'Product 1 - With Model');\r\ncommit;\r\n\r\n**Entities**\r\n```\r\n// Line.ts\r\nimport { Entity, PrimaryColumn, Column } from \"typeorm\";\r\n\r\n@Entity({ name: \"LINE\" })\r\nexport class Line {\r\n    @PrimaryColumn({ name: \"ID\" })\r\n    id: number;\r\n\r\n    @Column({ name: \"NAME\" })\r\n    name: string;\r\n}\r\n\r\n```\r\n\r\n```\r\n// Model.ts\r\nimport { Entity, PrimaryColumn, Column, ManyToOne, JoinColumn } from \"typeorm\";\r\nimport { Line } from \"./Line\";\r\n\r\n@Entity({ name: \"MODEL\" })\r\nexport class Model {\r\n    @PrimaryColumn({ name: \"ID\" })\r\n    id: number;\r\n\r\n    @Column({ name: \"NAME\" })\r\n    name: string;\r\n\r\n    @ManyToOne((type) => Line, { primary: true })\r\n    @JoinColumn({ name: \"LINE_ID\" })\r\n    line: Line;\r\n}\r\n```\r\n\r\n```\r\n// Product.ts\r\nimport { Entity, PrimaryColumn, Column, ManyToOne, JoinColumn } from \"typeorm\";\r\nimport { Line } from \"./Line\";\r\nimport { Model } from \"./Model\";\r\n\r\n@Entity({ name: \"PRODUCT\" })\r\nexport class Product {\r\n    @PrimaryColumn({ name: \"ID\" })\r\n    id: number;\r\n\r\n    @Column({ name: \"NAME\" })\r\n    name: string;\r\n\r\n    @ManyToOne((type) => Line)\r\n    @JoinColumn({ name: \"LINE_ID\" })\r\n    line: Line;\r\n\r\n    @ManyToOne((type) => Model)\r\n    @JoinColumn([ { name: \"LINE_ID\", referencedColumnName: \"line\" }, { name: \"MODEL_ID\", referencedColumnName: \"id\" } ])\r\n    model: Model;\r\n}\r\n```\r\n\r\n```\r\n// file Controller.ts\r\nimport { Request, Response } from \"express\";\r\nimport { getRepository } from \"typeorm\";\r\nimport { Product } from \"../../model/entity/test/Product\";\r\n\r\nexport class Controller {\r\n    public async getAllLines(req: Request, res: Response) {\r\n        try {\r\n            let lines = await getRepository(Product)\r\n                .createQueryBuilder(\"pro\")\r\n                .leftJoinAndSelect(\"pro.line\", \"line\")\r\n                .leftJoinAndSelect(\"pro.model\", \"model\")\r\n                .getMany();\r\n\r\n            res.json(lines);\r\n        } catch (err) {\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n**get this error**\r\n```\r\nError: ORA-00904: \"LINE\".\"LINE\".\"ID\": invalid identifier errorNum: 904, offset: 330\r\nthis query...\r\nSELECT \"pro\".\"ID\" AS \"pro_ID\"\r\n       ,\"pro\".\"NAME\" AS \"pro_NAME\"\r\n       ,\"pro\".\"LINE_ID\" AS \"pro_LINE_ID\"\r\n       ,\"pro\".\"MODEL_ID\" AS \"pro_MODEL_ID\"\r\n       ,\"line\".\"ID\" AS \"line_ID\"\r\n       ,\"line\".\"NAME\" AS \"line_NAME\"\r\n       ,\"model\".\"ID\" AS \"model_ID\"\r\n       ,\"model\".\"NAME\" AS \"model_NAME\"\r\n       ,\"model\".\"LINE_ID\" AS \"model_LINE_ID\"\r\n  FROM \"PRODUCT\" \"pro\"\r\n  LEFT JOIN \"LINE\" \"line\"\r\n    ON line.line.id = \"pro\".\"LINE_ID\" <--error join line.line.id-->\r\n  LEFT JOIN \"MODEL\" \"model\"\r\n    ON \"model\".\"LINE_ID\" = \"pro\".\"LINE_ID\"\r\n   AND \"model\".\"ID\" = \"pro\".\"MODEL_ID\"\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/3035/comments",
    "author": "paipeco",
    "comments": [
      {
        "user": "Kononnable",
        "created_at": "2018-12-08T19:14:52Z",
        "body": "@paipeco  Did you resolve your issue?"
      },
      {
        "user": "paipeco",
        "created_at": "2018-12-11T17:56:02Z",
        "body": "Hi @Kononnable.\r\n\r\nI decided to do a duplicate column mapping with a different attribute name.\r\nIn one of them I used a decorator @ManyToOne and another just an @Column decorator.\r\nI also created a false attribute to set the value with an @AfterLoad function.\r\n\r\nin Product.ts looks like this:\r\n```\r\n// Product.ts\r\nimport { Entity, PrimaryColumn, Column, ManyToOne, JoinColumn, AfterLoad, getRepository } from \"typeorm\";\r\nimport { Line } from \"./Line\";\r\nimport { Model } from \"./Model\";\r\n\r\n@Entity({ name: \"PRODUCT\" })\r\nexport class Product {\r\n    @PrimaryColumn({ name: \"ID\" })\r\n    id: number;\r\n\r\n    @Column({ name: \"NAME\" })\r\n    name: string;\r\n\r\n    @Column({ name: \"LINE_ID\" })\r\n    lineId: number;\r\n    // fake object\r\n    line: Line;\r\n\r\n    @ManyToOne((type) => Model)\r\n    @JoinColumn([ { name: \"LINE_ID\", referencedColumnName: \"line\" }, { name: \"MODEL_ID\", referencedColumnName: \"id\" } ])\r\n    model: Model;\r\n\r\n    // set line object\r\n    @AfterLoad()\r\n    async afterLoad() {\r\n        this.line = await getRepository(Line).findOne(this.lineId);\r\n        delete this.lineId;\r\n    }\r\n}\r\n```\r\n\r\nMy controller class:\r\n```\r\n// Controller.ts\r\n...\r\nlet products = await getRepository(Product)\r\n        .createQueryBuilder(\"pro\")\r\n        .leftJoinAndSelect(\"pro.model\", \"model\")\r\n        .leftJoinAndSelect(\"model.line\", \"line\")\r\n        .getMany();\r\n...\r\n```\r\nIt's working, but in unnormalized way!\r\nDo you have any idea?\r\n"
      },
      {
        "user": "pleerock",
        "created_at": "2019-01-04T14:34:26Z",
        "body": "Can you try to change following:\r\n\r\n```ts\r\n    @ManyToOne((type) => Model)\r\n    @JoinColumn([ { name: \"LINE_ID\", referencedColumnName: \"line\" }, { name: \"MODEL_ID\", referencedColumnName: \"id\" } ])\r\n    model: Model;\r\n```\r\n\r\nto: \r\n\r\n```ts\r\n    @ManyToOne((type) => Model)\r\n    @JoinColumn([ { name: \"LINE_ID\", referencedColumnName: \"LINE_ID\" }, { name: \"MODEL_ID\", referencedColumnName: \"id\" } ])\r\n    model: Model;\r\n```\r\n\r\n?"
      },
      {
        "user": "alfonsoal1983",
        "created_at": "2019-03-29T10:13:18Z",
        "body": "Hi, I know where the problem is. I'm going to paste an example, an example:\r\n\r\n`\r\n@Entity({name: 'Cars'})\r\nexport class Cars {\r\n\r\n    @PrimaryColumn({name: 'CARID'})\r\n    carId: string;\r\n\r\n    @Column({name: 'DESCRIPTION'})\r\n    description: string;\r\n\r\n    @OneToMany(type => Tires, tire => tire.car)\r\n    tires?: Tires[];\r\n}\r\n\r\n@Entity({name: 'Bikes'})\r\nexport class Bikes {\r\n\r\n    @PrimaryColumn({name: 'BIKEID'})\r\n    bikeId: string;\r\n\r\n    @Column({name: 'DESCRIPTION'})\r\n    description: string;\r\n\r\n    @OneToMany(type => Tires, tire => tire.bike)\r\n    tires?: Tires[];\r\n}\r\n\r\n@Entity({name: 'Tires'})\r\nexport class Tires {\r\n\r\n    @PrimaryColumn({name: 'id'})\r\n    id: string;\r\n\r\n    @Column({name: 'DESCRIPTION'})\r\n    description: string;\r\n\t\r\n    @ManyToOne(type => Bikes, bike => bike.tires)\r\n    @JoinColumn({name: 'VEHICLEID', referencedColumnName: 'bikeId'})\r\n    bike?: Bikes;\r\n\r\n    @ManyToOne(type => Cars, car => car.tires)\r\n    @JoinColumn({name: 'VEHICLEID', referencedColumnName: 'carId'})\r\n    car?: Cars;\r\n}\r\n\r\nawait getRepository(Tires)\r\n\t.createQueryBuilder(\"tires\")\r\n\t.leftJoinAndSelect(\"tires.car\", \"car\")\r\n\t.leftJoinAndSelect(\"tires.bike\", \"bike\")\r\n\t.getMany();\r\n\r\n\r\nSELECT \"tires\".\"id\" AS \"tires_id\", \"tires\".\"DESCRIPTION\" AS \"tires_DESCRIPTION\", etc...\r\nFROM \"Tires\" \"tires\"\r\nLEFT JOIN \"Bikes\" \"bike\" ON bike.carId=\"tires\".\"VEHICLEID\" <-- This is the problem\r\nLEFT JOIN \"Cars\" \"car\" ON \"car\".\"CARID\"=\"tires\".\"VEHICLEID\"\r\n`\r\n\r\nWhen a column is a foreign key of two tables and the reference id of those tables is not the same, it does not create the query well.\r\n\r\nIf you try this:\r\n`\r\n@JoinColumn({name: 'VEHICLEID', referencedColumnName: 'CARID'})\r\n`\r\nIt throws this error:\r\nReferenced column CARID was not found in entity Cars"
      },
      {
        "user": "imnotjames",
        "created_at": "2020-10-10T09:54:15Z",
        "body": "Duplicate of #1668 "
      }
    ]
  },
  {
    "number": 3008,
    "title": "leftJoinAndMap with nested relations",
    "created_at": "2018-10-29T17:27:24Z",
    "closed_at": "2019-04-20T22:05:33Z",
    "labels": [
      "question",
      "driver: postgres"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/3008",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[x] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[ ] `latest`\r\n[ ] `@next`\r\n[x] `0.2.7` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nHow can I do `leftJoinAndMapOne` with nested relations? I want to accomplish `CardEntity.itemRequested` from following:\r\n\r\n    const cards = await getRepository(CardEntity).createQueryBuilder(\"CardEntity\")\r\n      .leftJoinAndSelect(\"CardEntity.cardItems\", \"cardItemsEntity\")\r\n      .leftJoinAndSelect(\"cardItemsEntity.item\", \"ItemEntity\")\r\n      .getMany();\r\n\r\nI tried to put `leftJoinAndMapOne` instead of last joinAndSelect `.leftJoinAndMapOne(\"CardEntity.itemRequested\",\"cardItemsEntity.item\", \"item\")` , but that does not map the property.\r\n\r\nI tried to put the both JoinAndSelect to subquery, using signature `leftJoinAndMapOne(mapToProperty: string, subQueryFactory: (qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>, alias: string,` but that does not observe the \"CardEntity\" within the querybuilder. \r\n\r\nWhat am I missing?\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/3008/comments",
    "author": "WojtylaCZ",
    "comments": [
      {
        "user": "v1d3rm3",
        "created_at": "2018-11-24T16:35:45Z",
        "body": "I have the same problem. Entities are not being mapped with SelectQueryBuilder, only with Find operation from Repository. "
      },
      {
        "user": "jakubknejzlik",
        "created_at": "2019-01-06T23:06:17Z",
        "body": "@WojtylaCZ I'm trying this with sqlite/mysql driver and it works, is it related only to postgres? I'm using aliases though...so your example should be:\r\n```\r\nconst cards = await getRepository(CardEntity).createQueryBuilder(\"CardEntity\")\r\n  . leftJoinAndMapOne(\"CardEntity.cardItems\", \"cardItemsEntity\",\"CardEntity_cardItemsEntity\")\r\n  . leftJoinAndMapOne(\"CardEntity_cardItemsEntity.item\", \"ItemEntity\")\r\n  .getMany();\r\n```"
      },
      {
        "user": "pleerock",
        "created_at": "2019-01-07T08:10:22Z",
        "body": "@WojtylaCZ did you resolve your issue? You don't need to use `leftJoinAndMapOne`. Code you provided with leftJoinAndSelect looks right."
      },
      {
        "user": "Kononnable",
        "created_at": "2019-04-20T22:05:33Z",
        "body": "Closing as no response from the author."
      }
    ]
  },
  {
    "number": 3002,
    "title": "Typeorm becomes unresponsive when i execute bulk findOne queries in parallel",
    "created_at": "2018-10-29T11:34:11Z",
    "closed_at": "2018-12-17T14:10:16Z",
    "labels": [
      "question",
      "needs more info"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/3002",
    "body": "**Issue type:**\r\n\r\n[ ] question\r\n[x] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[x] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[ ] `latest`\r\n[x] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nHi,\r\n\r\nI have the following function that i am calling 100 times in parallel:\r\n\r\n```\r\nexport const findByCityNameAndStateId = async (cityName: string, stateId: number):\r\n  Promise<City | undefined> => {\r\n  return getRepository(City).findOne({\r\n    where: {\r\n      value: cityName,\r\n      state: {\r\n        id: stateId\r\n      }\r\n    },\r\n    relations: ['state']\r\n  });\r\n};\r\n\r\n```\r\n\r\nThe problem is that Typeorm starts to behave erratically when i execute this method in parallel a 100 times and does not return. And i have noticed this behavior on and off in alot of other methods.  I even tried replacing findOne with find and a query builder but the same problem existed. \r\n\r\nThe problem went away when i reduced the number of parallel executions from 100 to 10.\r\n\r\nMy question is that am i doing something wrong here or does this problem exist in Typeorm?\r\n\r\nLooking forward to hearing on this!",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/3002/comments",
    "author": "HussainAliAkbar",
    "comments": [
      {
        "user": "StrikeForceZero",
        "created_at": "2018-10-30T00:21:30Z",
        "body": "By default the connection manager creates a pool with 10 connections. I have no answer to why it locks up, but maybe increasing your pool size to match your desired parallel executions? Unless it's a known issue, an example bare-bones repository that reproduces it would probably be required to assist any further."
      },
      {
        "user": "HussainAliAkbar",
        "created_at": "2018-10-31T17:36:11Z",
        "body": "Thanks. I'll try increasing the pool size if it resolves the problem or not. If not, then i'll create a base bones repo and share."
      },
      {
        "user": "havenchyk",
        "created_at": "2018-11-26T10:31:15Z",
        "body": "@HussainAliAkbar did you solve your problem with increasing the number of connections?"
      },
      {
        "user": "HussainAliAkbar",
        "created_at": "2018-11-26T13:25:57Z",
        "body": "@havenchyk i got stuck in work and forgot to create a barebones repository. I'll make it over the weekend."
      },
      {
        "user": "HussainAliAkbar",
        "created_at": "2018-12-01T10:26:42Z",
        "body": "@havenchyk , i tried to recreate the issue but wasn't able to. Maybe something was wrong on my end but i am not able to pick what it was.\r\n\r\nThis is the code that i used and it worked fine:\r\n\r\n**Entities/User.ts**\r\n\r\n```ts\r\n\r\nimport {Entity, PrimaryGeneratedColumn, Column, UpdateDateColumn, CreateDateColumn} from \"typeorm\";\r\n\r\n@Entity('users')\r\nexport class User {\r\n\r\n    @PrimaryGeneratedColumn('uuid')\r\n    id: number;\r\n\r\n    @Column({\r\n        type: 'character varying',\r\n        length: 200,\r\n        nullable: false,\r\n    })\r\n    public email: string;\r\n\r\n    @Column({\r\n        type: 'character varying',\r\n        length: 100,\r\n        nullable: false,\r\n    })\r\n    public firstName: string;\r\n\r\n\r\n    @Column({\r\n        type: 'character varying',\r\n        length: 100,\r\n        nullable: false,\r\n    })\r\n    public lastName: string;\r\n\r\n    @Column({\r\n        type: 'boolean',\r\n        default: true,\r\n    })\r\n    public isActive: boolean;\r\n\r\n    @Column({\r\n        type: 'boolean',\r\n        default: false,\r\n    })\r\n    public isDeleted: boolean;\r\n\r\n    @UpdateDateColumn()\r\n    public updatedAt: Date;\r\n\r\n    @CreateDateColumn()\r\n    public createdAt: Date;\r\n\r\n}\r\n\r\n```\r\n\r\n**index.ts**\r\n\r\n```ts\r\n\r\n 1  import \"reflect-metadata\";\r\n 2  import {createConnection, getConnection, getRepository} from \"typeorm\";\r\n 3  import {User} from \"./entity/User\";\r\n 4  \r\n 5  const findByNameAndEmail = async (firstName: string, lastName: string, email: string): Promise<User | undefined> => {\r\n 6      return getRepository(User).findOne({\r\n 7          where: {\r\n 8              firstName,\r\n 9              lastName,\r\n10              email\r\n11          }\r\n12      })\r\n13  };\r\n14  \r\n15  createConnection().then(async connection => {\r\n16  \r\n17      await getConnection().query(`CREATE TABLE users (\r\n18      id uuid NOT NULL DEFAULT uuid_generate_v4(),\r\n19      email varchar(200) NULL,\r\n20      \"lastName\" varchar(100) NOT NULL,\r\n21      \"firstName\" varchar(100) NOT NULL,\r\n22      \"isActive\" bool NOT NULL DEFAULT true,\r\n23      \"isDeleted\" bool NOT NULL DEFAULT false,\r\n24      \"createdAt\" timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,\r\n25      \"updatedAt\" timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP\r\n26  )`);\r\n27  \r\n28      const insertions = [];\r\n29      const promises: any = [];\r\n30  \r\n31      for (let i =0; i < 10000; i++) {\r\n32          const stringified = i.toString();\r\n33          insertions.push({\r\n34              email: stringified,\r\n35              firstName: stringified,\r\n36              lastName: stringified\r\n37          });\r\n38  \r\n39          promises.push(findByNameAndEmail(stringified,stringified,stringified));\r\n40  \r\n41      }\r\n42      await getRepository(User).save(insertions);\r\n43      const responses = await Promise.all(promises);\r\n44      console.log(responses)\r\n45  \r\n46  }).catch(error => console.log(error));\r\n47  \r\n\r\n```\r\n\r\nIf no one has any leads as to why this happened then i guess this issue can be closed. "
      },
      {
        "user": "sahebte",
        "created_at": "2022-10-06T14:50:58Z",
        "body": "I have faced same issue on typeorm 0.2.34"
      },
      {
        "user": "kiracle-metacrew",
        "created_at": "2024-02-21T08:07:40Z",
        "body": "I have same issue on typeorm ^0.3.17\r\n\r\nI run create/update parallel on local (my desktop) fine, but when deploy to env dev and staging, typeorm unresponsive and hang the server, therefor I obligatory restart docker."
      }
    ]
  },
  {
    "number": 2999,
    "title": "Can not get WHERE...IN to work",
    "created_at": "2018-10-28T21:03:19Z",
    "closed_at": "2020-10-05T06:07:30Z",
    "labels": [
      "question",
      "needs more info"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/2999",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[x] bug report\r\n[ ] feature request\r\n[x] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[x] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n```ts\r\nconst usersModifiedStrings = [\r\n  '1_2018-10-23T20:53:35.000Z',\r\n  '2_2018-10-23T20:53:35.000Z',\r\n  '3_2018-10-23T20:53:35.000Z',\r\n]\r\n\r\ngetRepository(User)\r\n    .createQueryBuilder('user')\r\n    .select([\r\n        'user.userId',\r\n        'user.username',\r\n        'user.lastModified'\r\n    ])\r\n    .where(\"CONCAT(user.userId, '_', user.lastModified) NOT IN (:...values)\", {\r\n        values: usersModifiedStrings\r\n    })\r\n    .getMany()\r\n````\r\n\r\nI'd like to filter the rows by these unique identifiers `userId_lastModifiedDate`. It works inside MySQL Workbench, but when using the query builder, the strings will never match.\r\nExample:\r\n- User table has 20 users\r\n- with these 3 filter values, 17 rows should be returned. But it will be always 20 rows returned when using the query builder. The query looks correct, so it must be an issue of bind param.\r\n\r\n```sql\r\nSELECT\r\n       user.user_id AS user_user_id,\r\n       user.username AS user_username,\r\n       user.last_modified AS user_last_modified\r\nFROM user user\r\nWHERE CONCAT(user.user_id, '_', user.last_modified) NOT IN (?) \r\n-- PARAMETERS: [[\"9_2018-10-23T20:53:35.000Z\",\"43_2018-10-23T20:53:35.000Z\",\"98_2018-10-23T20:53:35.000Z\"]]\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/2999/comments",
    "author": "btxtiger",
    "comments": [
      {
        "user": "btxtiger",
        "created_at": "2018-11-01T03:18:07Z",
        "body": "The issue seem to be caused by date to UTC conversion. I saw some issues on that topic. But I still do not understand why this happens."
      },
      {
        "user": "nakul5harma",
        "created_at": "2020-06-02T16:13:01Z",
        "body": "Facing similar issue - \r\n\r\nDatabase - PostgreSQL 11.6\r\nTypeORM - 0.2.22 \r\n\r\n#### TypeORM -\r\n\r\n```typescript\r\nthis.createQueryBuilder('packet')\r\n  .where('packet.\"packetId\" IN (:...packetIds)', { packetIds })\r\n  .getMany()\r\n```\r\n\r\n#### Generated Query -\r\n\r\n```sql\r\nSELECT\r\n  \"packet\".\"id\" AS \"packet_id\",\r\n  \"packet\".\"packetId\" AS \"packet_packetId\",\r\n  \"packet\".\"consignmentId\" AS \"packet_consignmentId\"\r\nFROM\r\n  \"packet\" \"packet\"\r\nWHERE\r\n  packet.\"packetId\" IN ($1) -- PARAMETERS: [\"abcd\"]\r\n```\r\n\r\n#### Field Details -\r\n\r\n```typescript\r\n@Column({ type: 'text', nullable: false })\r\npacketId: string;\r\n```\r\n\r\nI have a database row matching this condition, but not getting the data from TypeORM.\r\n\r\nThe query is working fine in pgAdmin with `packetId` = 'abcd' but getting error while keeping `packetId` as \"abcd\". Not sure if the problem is because of double quotes.\r\n"
      },
      {
        "user": "imnotjames",
        "created_at": "2020-10-05T06:07:30Z",
        "body": "The in clause works in our tests.  If you're finding there's an actual issue please create a new issue with a Reproducible example.\r\n\r\n---\r\n\r\nWhen opening an issue, people will be better able to provide help if you provide code that they can easily understand and use to reproduce the problem. This boils down to ensuring your code that reproduces the problem follows the following guidelines:\r\n\r\n* Minimal – Use as little code as possible that still produces the same problem\r\n* Complete – Provide all parts someone else needs to reproduce your problem in the question itself\r\n* Reproducible – Test the code you're about to provide to make sure it reproduces the problem\r\n\r\n## Minimal\r\nThe more code there is to go through, the less likely people can find your problem. Streamline your example in one of two ways:\r\n\r\n1. Restart from scratch. Create a new program, adding in only what is needed to see the problem. Use simple, descriptive names for functions and variables – don’t copy the names you’re using in your existing code.\r\n2. Divide and conquer. If you’re not sure what the source of the problem is, start removing code a bit at a time until the problem disappears – then add the last part back.\r\n\r\nDon't sacrifice clarity for brevity when creating a minimal example. Use consistent naming and indentation, and include code comments if needed. Use your code editor’s shortcut for formatting code.\r\n\r\nDon't include any passwords or credentials that must be kept secret.\r\n\r\n## Complete\r\n\r\nMake sure all information necessary to reproduce the problem is included in the issue itself.\r\n\r\nIf the problem requires some code as well as some XML-based configuration, include code for both. The problem might not be in the code that you think it is in.\r\n\r\nUse individual code blocks for each file or snippet you include. Provide a description for the purpose of each block.\r\n\r\n**DO NOT** use images of code. Copy the actual text from your code editor, paste it into the issus, then format it as code. This helps others more easily read and test your code.\r\n\r\n## Reproducible\r\n\r\nTo help you solve your problem, others will need to verify that it exists.\r\n\r\nDescribe the problem. \"It doesn't work\" isn't descriptive enough to help people understand your problem. Instead, tell other readers what the expected behavior should be. Tell other readers what the exact wording of the error message is, and which line of code is producing it. Use a brief but descriptive summary of your problem as the title of your question.\r\n\r\nEliminate any issues that aren't relevant to the problem. If your question isn’t about a compiler error, ensure that there are no compile-time errors.\r\n\r\nDouble-check that your example reproduces the problem! If you inadvertently fixed the problem while composing the example but didn't test it again, you'd want to know that before asking someone else to help."
      }
    ]
  },
  {
    "number": 2996,
    "title": "An ORM Independent From Electron main and render thread",
    "created_at": "2018-10-26T21:55:47Z",
    "closed_at": "2020-10-01T05:33:58Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/2996",
    "body": "I have a Dream !!!\r\n\r\nNode is running on Electrons main thread and we can do any type of process over there.\r\nWhen creating a desktop application it will be tedious to work on both threads.\r\n\r\nsending messages b/w render and main threads for queries.\r\n\r\nIs there any way we can get around this ?\r\na part of TypeORM working on main thread and on render thread we just create connection and query our data without noticing.\r\n1- can we do it now ?\r\n2-if not 1 then can we will be able to do it in future ? \r\n\r\n[ X] question\r\n[ ] bug report\r\n[X ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ X] `mssql`\r\n[ X] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ X] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[ ] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\n<!--\r\n    To answer those questions you need to put \"x\" inside the square brackets, for example:\r\n    [x] `mysql`\r\n    [ ] `postgres`\r\n\r\n    Also, please format your code properly (by taking code blocks into ```ts .... ```)\r\n!>\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/2996/comments",
    "author": "aammfe",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2018-10-27T02:26:46Z",
        "body": "So the problem is basically not with a typeorm, but with how electron works. If you ask if we change something in a near future - answer is I don't think so. If you ask if we would like to add a new feature into typeorm to run long-running processes in a separate thread - I answer is yes, we would. The biggest deal is to make it cross-platform since typeorm runs on server, browser, electron, nativescript, etc. "
      },
      {
        "user": "aammfe",
        "created_at": "2018-10-27T04:45:15Z",
        "body": "Basically My background is enityframework where threads and architecture was not an issue.\r\nNow Issue is these two threads are making life uneasy.\r\n\r\n\r\n\r\n> If you ask if we would like to add a new feature into typeorm to run long-running processes in a separate thread\r\n\r\ndoes it means we can use typeorm from ui thread with any database(mysql etc) supported by typeorm with out thread messaging mess ?\r\n\r\nIf yes then when I will see this feature ? :)"
      },
      {
        "user": "pleerock",
        "created_at": "2018-10-27T10:31:19Z",
        "body": "> Basically My background is enityframework where threads and architecture was not an issue.\r\nNow Issue is these two threads are making life uneasy.\r\n\r\nyou basically were working in non asynchronous environment\r\n\r\n> If yes then when I will see this feature ? :)\r\n\r\nas I told not soon :)\r\n\r\n> does it means we can use typeorm from ui thread with any database(mysql etc) supported by typeorm with out thread messaging mess ?\r\n\r\nin electron its not exactly UI thread... I don't know exactly but from what I know this system in electron is strange, they have two threads or processes but for some reason they are tightly coupled (sure they have design decisions docs).\r\n\r\nIf you have heavy database computations and you don't wanna block your dekstop process, solution for you is to create a separate thread or process and run all typeorm in there."
      },
      {
        "user": "aammfe",
        "created_at": "2018-10-27T11:43:40Z",
        "body": "> you basically were working in non asynchronous environment\r\n\r\nIt is an asynchronous environment but application have different threads with same memory poll.\r\n\r\nbut in electron things are different. two different threads with different memory poll. means we can not access variable from different thread.\r\n\r\n\r\n  \r\n\r\n> as I told not soon :)\r\n\r\nis there any way it can be use now ? \r\ncan we run typeorm on different node thread ?"
      },
      {
        "user": "pleerock",
        "created_at": "2018-10-27T16:35:42Z",
        "body": "all java threading problems are actually because of same memory poll =)\r\n\r\n> can we run typeorm on different node thread ?\r\n\r\nyes, you can, just like any code you can run on different thread."
      }
    ]
  },
  {
    "number": 2990,
    "title": "Empty string in findOne",
    "created_at": "2018-10-25T10:16:57Z",
    "closed_at": "2020-10-12T09:30:06Z",
    "labels": [
      "question",
      "driver: mssql"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/2990",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[x] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[ ] `latest`\r\n[ ] `@next`\r\n[x] `0.2.7` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nIf i pass an empty string to the findOne method, it will ignore the param and doesn't use a where clause in the query. \r\n\r\nexample:\r\n- `repo.findOne(\"foo\")` returns `SELECT ... FROM ... WHERE id = ? -- PARAMETERS: [\"foo\"]`\r\n- `repo.findOne(\"\")` returns `SELECT ... FROM ...` (here without WHERE and PARAMETERS)\r\n\r\nIs it intended? Probably it's not very usefull to set an empty string as a primary key for one of the entities, but in some cases, this behaviour will produce heavy problems (eg. passing an empty string by mistake to the server, typeorm will return the first entity of the table).",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/2990/comments",
    "author": "dkirchhof",
    "comments": [
      {
        "user": "riadhriadh",
        "created_at": "2018-10-25T11:32:06Z",
        "body": " example\r\n```\r\nfindOnebyName(name: string): Promise<any> {\r\n    return (await this.footRepository.find({ name }))[0];\r\n  }\r\n```\r\n\r\n"
      },
      {
        "user": "imnotjames",
        "created_at": "2020-10-12T09:30:05Z",
        "body": "Duplicate of #3416 "
      }
    ]
  },
  {
    "number": 2982,
    "title": "[Question] Automatically upsert entities with compound primary keys?",
    "created_at": "2018-10-24T16:53:49Z",
    "closed_at": "2020-10-04T01:58:54Z",
    "labels": [
      "question",
      "comp: manager and repository",
      "driver: postgres"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/2982",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[x] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nI've read through all the issues and discussions I could find related to this (namely #1463, #1926, and #2027). That said, I'm still not sure whether we should expect the `EntityManager.save(...)` API to automatically `UPDATE` existing entities based on their compound primary key.\r\n\r\nIf this is expected to work I can update this issue with a reproducible test case, but I just wanted to clarify the expected behavior first.",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/2982/comments",
    "author": "marshall007",
    "comments": [
      {
        "user": "kyle-mccarthy",
        "created_at": "2018-11-27T20:40:48Z",
        "body": "I am having this issue as well.  I would expect that it should perform and update if the record exists rather than trying to reinsert it based on the documentation, especially since that is the functionality when there is a single primary key vs a composite primary key.  To give a concrete example this will not work\r\n\r\n```\r\n@Entity()\r\nexport class Region {\r\n  @PrimaryColumn()\r\n  public id: string;\r\n\r\n  @Column()\r\n  public name: string;\r\n\r\n  @OneToMany(type => Location, location => location.region)\r\n  @JoinColumn([\r\n    { referencedColumnName: 'regionId', name: 'id' },\r\n    { referencedColumnName: 'regionSyncId', name: 'syncId' },\r\n  ])\r\n  public locations: Location[];\r\n\r\n  @ManyToOne(type => Sync)\r\n  public sync: Sync;\r\n\r\n  @PrimaryColumn()\r\n  public syncId: number;\r\n}\r\n\r\n@Entity()\r\nexport class Location {\r\n  @PrimaryColumn()\r\n  public id: string;\r\n\r\n  // ...\r\n\r\n  @ManyToOne(type => Region, region => region.locations)\r\n  @JoinColumn([\r\n    { referencedColumnName: 'id', name: 'regionId' },\r\n    { referencedColumnName: 'syncId', name: 'regionSyncId' },\r\n  ])\r\n  public region: Region;\r\n\r\n  @Index()\r\n  @Column({ nullable: true })\r\n  @RelationId((location: Location) => location.region)\r\n  public regionId: string;\r\n\r\n  @ManyToOne(type => Sync)\r\n  public sync: Sync;\r\n\r\n  @PrimaryColumn()\r\n  public syncId: number;\r\n}\r\n\r\n// ...\r\n\r\nconst sync = new Sync();\r\nawait connection.manager.save(sync);\r\n\r\nconst location = new Location();\r\nlocation.id = 'l-pk-1';\r\nlocation.sync = sync;\r\nawait connection.manager.save(location);\r\n\r\nconst region = new Region();\r\nregion.id = 'r-1';\r\nregion.name = 'First region';\r\nregion.sync = sync;\r\nawait connection.manager.save(region);\r\n\r\n// next save will cause an error because it tries to insert rather than update\r\nlocation.region = region;\r\nawait connection.manager.save(location);\r\n```\r\n\r\nAs of right now you can't use save on the existing record and you have to manually update it and pass the constraints.\r\n\r\n```\r\nawait manager.update(\r\n  LocationEntity,\r\n  {\r\n    id: location.id,\r\n    syncId: location.syncId,\r\n  },\r\n  location,\r\n);\r\n```"
      },
      {
        "user": "imnotjames",
        "created_at": "2020-10-04T01:58:54Z",
        "body": "Quite a lot of work has been done since then on composite primary key entities - if you still have issues with the latest release, please open a new issue with a means to replicate the problem :)"
      }
    ]
  },
  {
    "number": 2953,
    "title": "Mongodb Raw Spatial query",
    "created_at": "2018-10-20T17:43:25Z",
    "closed_at": "2019-03-14T22:07:42Z",
    "labels": [
      "question",
      "driver: mongodb"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/2953",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[x] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\nI want use this query with typeorm\r\n`{ location:\r\n   { $geoWithin:\r\n      { $centerSphere: [ [ -73.93414657, 40.82302903 ], 5 / 3963.2 ] } } })\r\n`\r\n\r\nWhat is the correct type for location field? I have tried GeoJson.Point, but it is incorrect\r\n`@ColumnORM(\"point\")\r\nlocation: Point;\r\n`\r\n\r\nTypes of property 'location' are incompatible.\r\nType '{ $geoWithin: { $centerSphere: (number | number[])[]; }; }' is not assignable to type 'Point'.\r\nProperty 'type' is missing in type '{ $geoWithin: { $centerSphere: (number | number[])[]; }; }'.\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/2953/comments",
    "author": "mabuonomo",
    "comments": [
      {
        "user": "rustamwin",
        "created_at": "2019-03-12T19:30:57Z",
        "body": "@mabuonomo You can use `cursor` for not implemented find options"
      }
    ]
  },
  {
    "number": 2952,
    "title": "Efficiently inserting parent and children one-to-many",
    "created_at": "2018-10-20T13:20:52Z",
    "closed_at": "2025-02-10T14:57:31Z",
    "labels": [
      "question",
      "driver: postgres"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/2952",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n\r\n**Database system/driver:**\r\n\r\n[x] `postgres`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n\r\nI have the following code that works as expected but I am unsure if this is the most efficient solution.\r\n\r\n```ts\r\n        // Insert release\r\n        const release = Release.create(input);\r\n        await release.save();\r\n\r\n        // Assign each track the release ID\r\n        const tracks = input.tracks.map(track => ({\r\n          ...track,\r\n          releaseId: release.id,\r\n        }));\r\n\r\n        // Bulk insert tracks\r\n        await getConnection()\r\n          .createQueryBuilder()\r\n          .insert()\r\n          .into(Track)\r\n          .values(tracks)\r\n          .execute();\r\n```\r\n\r\nI would like to be able to insert a parent (`Release`) and its multiple children (`Track`) in one operation. I'm not sure if I have missed something in the documentation, or if this is just not possible. Thanks\r\n\r\n**`Release` entity:**\r\n\r\n```ts\r\n@Entity('releases')\r\nexport class Release extends BaseEntity {\r\n  @PrimaryGeneratedColumn('uuid')\r\n  id: string;\r\n\r\n  @OneToMany(() => Track, track => track.release)\r\n  tracks: Track[];\r\n}\r\n```\r\n\r\n**`Track` entity:**\r\n\r\n```ts\r\n@Entity('tracks')\r\nexport class Track extends BaseEntity {\r\n  @PrimaryGeneratedColumn('uuid')\r\n  id: string;\r\n\r\n  @Column({ type: 'uuid', name: 'release_id' })\r\n  releaseId: string;\r\n\r\n  @ManyToOne(() => Release, release => release.tracks)\r\n  @JoinColumn({ name: 'release_id' })\r\n  release: Release;\r\n}\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/2952/comments",
    "author": "malimccalla",
    "comments": [
      {
        "user": "premalatha-bv",
        "created_at": "2019-04-17T07:15:59Z",
        "body": "Any answers for this?"
      },
      {
        "user": "malimccalla",
        "created_at": "2019-05-18T09:43:19Z",
        "body": "Came back to this part of the codebase yesterday and still can't seem to find a better way to do this 😕  "
      },
      {
        "user": "LordShiroe",
        "created_at": "2019-05-30T21:17:47Z",
        "body": "I have the same question! I thought that setting `{ cascade: true}` in the relation would do the trick but no, it tries to save the children without the parent id even if it already knows it. For now, I'm going to use the snippet shared here."
      },
      {
        "user": "jagabs",
        "created_at": "2020-02-08T15:26:16Z",
        "body": "same with @LordShiroe do you have any suggestions?"
      },
      {
        "user": "jmls",
        "created_at": "2020-03-20T20:11:20Z",
        "body": "oh - I've just come across this. I naively thought it would just work \"out of the box\". Is this not the case ?"
      },
      {
        "user": "essam-abdelrahman",
        "created_at": "2020-06-04T11:47:10Z",
        "body": "> **Issue type:**\r\n> \r\n> [x] question\r\n> \r\n> **Database system/driver:**\r\n> \r\n> [x] `postgres`\r\n> \r\n> **TypeORM version:**\r\n> \r\n> [x] `latest`\r\n> \r\n> I have the following code that works as expected but I am unsure if this is the most efficient solution.\r\n> \r\n> ```ts\r\n>         // Insert release\r\n>         const release = Release.create(input);\r\n>         await release.save();\r\n> \r\n>         // Assign each track the release ID\r\n>         const tracks = input.tracks.map(track => ({\r\n>           ...track,\r\n>           releaseId: release.id,\r\n>         }));\r\n> \r\n>         // Bulk insert tracks\r\n>         await getConnection()\r\n>           .createQueryBuilder()\r\n>           .insert()\r\n>           .into(Track)\r\n>           .values(tracks)\r\n>           .execute();\r\n> ```\r\n> \r\n> I would like to be able to insert a parent (`Release`) and its multiple children (`Track`) in one operation. I'm not sure if I have missed something in the documentation, or if this is just not possible. Thanks\r\n> \r\n> **`Release` entity:**\r\n> \r\n> ```ts\r\n> @Entity('releases')\r\n> export class Release extends BaseEntity {\r\n>   @PrimaryGeneratedColumn('uuid')\r\n>   id: string;\r\n> \r\n>   @OneToMany(() => Track, track => track.release)\r\n>   tracks: Track[];\r\n> }\r\n> ```\r\n> \r\n> **`Track` entity:**\r\n> \r\n> ```ts\r\n> @Entity('tracks')\r\n> export class Track extends BaseEntity {\r\n>   @PrimaryGeneratedColumn('uuid')\r\n>   id: string;\r\n> \r\n>   @Column({ type: 'uuid', name: 'release_id' })\r\n>   releaseId: string;\r\n> \r\n>   @ManyToOne(() => Release, release => release.tracks)\r\n>   @JoinColumn({ name: 'release_id' })\r\n>   release: Release;\r\n> }\r\n> ```\r\n\r\ntry this\r\n        // Assign each track the release ID\r\n        const tracks = input.tracks.map(track => ({\r\n          ...track,\r\n          releaseId: release.identifiers[0].id,\r\n        }));"
      },
      {
        "user": "rivanbello",
        "created_at": "2020-10-19T03:41:39Z",
        "body": "Same problem. =("
      },
      {
        "user": "jtownsley",
        "created_at": "2020-10-28T20:23:34Z",
        "body": "I think you may need to add the `cascade: ['insert']` option to to your parent relation, like this `@OneToMany(() => Track, track => track.release, { cascade: ['insert'] })`. That should allow you to save the release and automatically associate the child Tracks to it."
      },
      {
        "user": "Sahl-A",
        "created_at": "2021-06-21T09:23:34Z",
        "body": "same questions? "
      },
      {
        "user": "tahir-jamil",
        "created_at": "2021-07-08T21:50:32Z",
        "body": "same questions after 18 days \r\ndoes anyone finds any solution please guide"
      },
      {
        "user": "tahir-jamil",
        "created_at": "2021-07-08T21:51:39Z",
        "body": "> Came back to this part of the codebase yesterday and still can't seem to find a better way to do this 😕\r\n\r\nwell sir any work around for us?"
      },
      {
        "user": "mohsinamjad",
        "created_at": "2021-07-27T11:27:52Z",
        "body": "+1\r\n"
      },
      {
        "user": "clevercodenl",
        "created_at": "2021-09-06T09:56:15Z",
        "body": "+1"
      },
      {
        "user": "avdicsaid90",
        "created_at": "2021-10-14T11:10:09Z",
        "body": "+1"
      },
      {
        "user": "thalysonalexr",
        "created_at": "2022-01-14T17:12:10Z",
        "body": "+1"
      },
      {
        "user": "j1i-ian",
        "created_at": "2022-04-25T06:43:16Z",
        "body": "why do u guys not resolve with foriegn key relations ? \r\n\r\nThis issue can be resovled with cascade option in SaveOption.\r\n\r\nlike this:\r\n\r\n```typescript\r\n\r\nconst repo = getRepository(Release);\r\nconst release = repo.create(input);\r\n\r\n// you don't need assgin release id to tracks\r\nrelease.tracks = tracks;\r\n\r\n// Even you can process transactionally with options\r\nawait repo.save(release, {\r\n  transaction: true\r\n});\r\n```"
      },
      {
        "user": "doojin",
        "created_at": "2023-04-22T03:46:27Z",
        "body": "> I think you may need to add the `cascade: ['insert']` option to to your parent relation, like this `@OneToMany(() => Track, track => track.release, { cascade: ['insert'] })`. That should allow you to save the release and automatically associate the child Tracks to it.\r\n\r\nHmm, actually this worked for me.\r\n\r\nSo you need:\r\n1. Change this:\r\n```\r\n@OneToMany(() => Track, track => track.release)\r\n```\r\nto this:\r\n```\r\n@OneToMany(() => Track, track => track.release, { cascade: ['insert'] })\r\n```\r\n2. Then you can just set your tracks array to the partent. You don't need to explicitly set release id to the children (tracks)\r\n```\r\nrelease.tracks = [ /* your track objects */ ]\r\n```\r\n3. Save the release:\r\n```\r\nawait releaseRepository.save(release, {\r\n  transaction: true // <- pay attention to this one!\r\n});\r\n```\r\nThis should save release and it's children track objects together.\r\nWorks for One-to-one as well."
      },
      {
        "user": "Serializ3r",
        "created_at": "2024-04-04T21:52:38Z",
        "body": "> > I think you may need to add the `cascade: ['insert']` option to to your parent relation, like this `@OneToMany(() => Track, track => track.release, { cascade: ['insert'] })`. That should allow you to save the release and automatically associate the child Tracks to it.\r\n> \r\n> Hmm, actually this worked for me.\r\n> \r\n> So you need:\r\n> \r\n> 1. Change this:\r\n> \r\n> ```\r\n> @OneToMany(() => Track, track => track.release)\r\n> ```\r\n> \r\n> to this:\r\n> \r\n> ```\r\n> @OneToMany(() => Track, track => track.release, { cascade: ['insert'] })\r\n> ```\r\n> \r\n> 2. Then you can just set your tracks array to the partent. You don't need to explicitly set release id to the children (tracks)\r\n> \r\n> ```\r\n> release.tracks = [ /* your track objects */ ]\r\n> ```\r\n> \r\n> 3. Save the release:\r\n> \r\n> ```\r\n> await releaseRepository.save(release, {\r\n>   transaction: true // <- pay attention to this one!\r\n> });\r\n> ```\r\n> \r\n> This should save release and it's children track objects together. Works for One-to-one as well.\r\n\r\nThis worked for me, thx!"
      },
      {
        "user": "OSA413",
        "created_at": "2025-02-10T14:57:31Z",
        "body": "Closing since several solutions are provided, feel free to ask to reopen the issue."
      }
    ]
  },
  {
    "number": 2951,
    "title": "Add support for AWS Redshift and Google BigQuery",
    "created_at": "2018-10-20T07:46:20Z",
    "closed_at": "2019-04-20T21:43:57Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/2951",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[ ] bug report\r\n[x] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\nIs there any plan for adding support for Redshift and BigQuery and How much work do you think it would take?\r\n\r\nI love to use typeorm to rewrite the current API app because currently, it's the only one ORM library that is written in typescript, but the problem is I need to use AWS Redshift for BI.",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/2951/comments",
    "author": "sandangel",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2018-10-20T09:19:02Z",
        "body": "TypeORM is a relational database mostly, so writing support for Redshift and BigQuery will become wring a different ORM here. So no, we don't have plans to write another ORM for those databases. You should take initiative on your own!"
      },
      {
        "user": "sandangel",
        "created_at": "2018-10-20T09:30:29Z",
        "body": "hi @pleerock, thank you for your reply. but as I'm aware of there is also support for mongodb right? Redshift is a fork of posgresql, is that it makes more sense for adding support for Redshift rather than mongodb? "
      },
      {
        "user": "Kononnable",
        "created_at": "2018-10-26T12:06:24Z",
        "body": "The difference is that there already is support for mongodb. So there is no more time needed to make it work. Mongodb is mostly maintained/developed by the community right now - because lack of time."
      },
      {
        "user": "annymosse",
        "created_at": "2020-03-21T04:43:20Z",
        "body": "@sandangel i think mongoDB not a relational database ,however google Bigquery also sql like queries , i think it's not hard to maintain it ."
      },
      {
        "user": "samirspatel",
        "created_at": "2021-02-01T14:05:39Z",
        "body": "@Kononnable why did you close this issue? If there is no time I'm sure other developers with interest could take this work on. We are also in need of TypeORM working with BigQuery. BigQuery is a fully relational database and will definitely work with an ORM. Please reopen this issue. "
      },
      {
        "user": "ciekawy",
        "created_at": "2021-09-28T13:20:45Z",
        "body": "any chances for reopening? and/or possibly some community discussion "
      },
      {
        "user": "chetanbillore-hitachi",
        "created_at": "2022-11-29T17:36:58Z",
        "body": "So finally there is no support of AWS Redshift in typeORM??\r\nPlease share some confirmation either way Yes/No."
      },
      {
        "user": "bauti-defi",
        "created_at": "2023-10-27T13:21:51Z",
        "body": "BigQuery support would be great! "
      }
    ]
  },
  {
    "number": 2941,
    "title": " Relation with property path professional in entity was not found. -Typeorm",
    "created_at": "2018-10-17T06:35:57Z",
    "closed_at": "2018-12-08T22:10:27Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/2941",
    "body": "\r\n ```\r\n   async getProfessionByIdAndLang(professionId: string, lang?: string): Promise<ProfessionTranslation> {\r\n        const language = lang ? lang : \"en\";\r\n        return await this.em.createQueryBuilder().select(\"professionalTrans\").from(ProfessionTranslation, \"professionalTrans\")\r\n            .innerJoinAndSelect(\"professionalTrans.professional\", \"professional\")\r\n            .where(\"professionalTrans.lang = :lang\", { lang: language })\r\n            .andWhere(\"professional.id = :id\", { id: professionId }).getOne();\r\n\r\n    }\r\n\r\n```\r\n\r\n**ProfessionTranslation**\r\n\r\n```\r\nimport { Index, Entity, PrimaryColumn, Column, OneToOne, OneToMany, ManyToOne, ManyToMany, JoinColumn, JoinTable, PrimaryGeneratedColumn, CreateDateColumn, UpdateDateColumn } from \"typeorm\";\r\nimport { Profession } from \"./Profession\";\r\n\r\n\r\n@Entity(\"profession_translation\")\r\n@Index(\"fk_profession_translation_1_idx\", [\"profession\"])\r\nexport class ProfessionTranslation {\r\n\r\n    @PrimaryGeneratedColumn(\"uuid\")\r\n    id: string;\r\n\r\n\r\n\r\n    @ManyToOne(type => Profession, profession => profession.professionTranslations)\r\n    @JoinColumn({ name: \"profession_id\" })\r\n    profession: Promise<Profession>;\r\n\r\n\r\n    @Column(\"char\", {\r\n        nullable: true,\r\n        length: 36,\r\n        name: \"profession_name\"\r\n    })\r\n    professionName: string;\r\n\r\n\r\n    @Column(\"varchar\", {\r\n        nullable: true,\r\n        length: 45,\r\n        name: \"lang\"\r\n    })\r\n    lang: string;\r\n\r\n\r\n    @CreateDateColumn({type: \"timestamp\"})\r\n    @Column(\"timestamp\", {\r\n        nullable: true,\r\n        name: \"created_on\"\r\n    })\r\n    createdOn: Date;\r\n\r\n\r\n    @UpdateDateColumn({type: \"timestamp\"})\r\n    @Column(\"timestamp\", {\r\n        nullable: true,\r\n        name: \"updated_on\"\r\n    })\r\n    updatedOn: Date;\r\n\r\n    constructor(init?: Partial<ProfessionTranslation>) {\r\n        Object.assign(this, init);\r\n    }\r\n}\r\n\r\n```",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/2941/comments",
    "author": "vjsingh96",
    "comments": [
      {
        "user": "ssgiant",
        "created_at": "2018-11-10T05:58:09Z",
        "body": "Hope you have it working already, you are referencing a field \"professionalTrans.professional\" which does not exist on class ProfessionTranslation. You have the relation mapped in the class as field \"professionalTrans.profession\". So, \r\n\r\n`.innerJoinAndSelect(\"professionalTrans.profession\", \"professional\")`\r\n\r\nshould do the trick. "
      },
      {
        "user": "Mansvini",
        "created_at": "2023-05-20T13:49:02Z",
        "body": "@ManyToOne(type => Profession, profession => profession.professionTranslations)\r\n    @JoinColumn({ name: \"profession_id\" })\r\n    profession: Promise <Profession>\r\n    \r\n    Maybe this should not be a promise, and instead be \r\n\r\n```\r\n@ManyToOne(type => Profession, profession => profession.professionTranslations)\r\n    @JoinColumn({ name: \"profession_id\" })\r\n    profession: Profession;\r\n\r\n```"
      }
    ]
  },
  {
    "number": 2924,
    "title": "BeforeInsert Issue",
    "created_at": "2018-10-12T23:56:44Z",
    "closed_at": "2018-10-24T20:17:28Z",
    "labels": [
      "question",
      "comp: subscribers and listeners"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/2924",
    "body": "**Issue type:**\r\n\r\n[ ] question\r\n[x ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[x ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[x ] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[x ] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nPlacing @BeforeInsert() and @AfterInsert do not work\r\n\r\n```\r\n@AfterInsert()\r\n  modifyText() {\r\n    console.log(\"Something is being inserted\");\r\n  }\r\n```\r\n\r\n```\r\n@BeforeInsert()\r\n  modifyText() {\r\n    this.text = `${this.text} was modified before insert`;\r\n  }\r\n```\r\n\r\n```\r\n@BeforeInsert()\r\nhashpassword(){\r\n   this.password = ........\r\n}\r\n```\r\n\r\nI've seen this in other issues and they were closed but the issue was never actually resolved.",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/2924/comments",
    "author": "JamesCoonce",
    "comments": [
      {
        "user": "billyjov",
        "created_at": "2018-10-14T20:18:34Z",
        "body": "@JamesCoonce  `@BeforeInsert` work for me using version `0.2.7`. You have to be extra careful when working with asynchronous processes e.g your last use case for hashing a password.\r\n\r\nIt should work with the folowing syntax: \r\n\r\n```\r\n@BeforeInsert\r\nasync hashpassword() {\r\n    this.password = await your-hash-process;\r\n}\r\n```"
      },
      {
        "user": "rustamwin",
        "created_at": "2018-10-15T10:25:47Z",
        "body": "try it in subscribers"
      },
      {
        "user": "JamesCoonce",
        "created_at": "2018-10-16T13:50:22Z",
        "body": "I'm also using 0.2.7. Here is a basic example. This doesn't even work. It does no modify.\r\n```\r\nimport { Entity, Column, PrimaryGeneratedColumn, BeforeInsert} from 'typeorm';\r\n\r\n@Entity()\r\nexport class Todo {\r\n  @PrimaryGeneratedColumn()\r\n  id: number;\r\n\r\n  @Column({ length: 500 })\r\n  text: string;\r\n\r\n  @Column()\r\n  complete: boolean;\r\n\r\n  @BeforeInsert()\r\n  modifyText() {\r\n    this.text = `${this.text} was modified before insert`;\r\n  }\r\n}\r\n```\r\n\r\nInside of my todoService I have this\r\n\r\n```\r\npublic async create(todo: CreateTodosDTO): Promise<Todo> {\r\n        return await this.todoRepository.save(todo);\r\n    }\r\n```"
      },
      {
        "user": "feather-jmalone",
        "created_at": "2018-10-16T14:23:33Z",
        "body": "what does the value of `todo` look like? is it an object that has the properties of `Todo` (e.g. `{id: 1, text: 'text', complete: true}`, or is it an actual instance (e.g. `const todo = new Todo()`)?"
      },
      {
        "user": "JamesCoonce",
        "created_at": "2018-10-16T14:31:23Z",
        "body": "When I send the post request it's \r\n\r\n```\r\n{\r\n  \"text\": \"Today is Monday\",\r\n  \"complete\": false\r\n}\r\n```\r\n\r\nWhat I get back is \r\n\r\n```\r\n{\r\n\t\"text\": \"Today is Monday\",\r\n\t\"complete\": false,\r\n\t\"id\": 5\r\n}\r\n```\r\n\r\nI check the database and it's the same. It's not being modified before insert."
      },
      {
        "user": "feather-jmalone",
        "created_at": "2018-10-16T14:44:06Z",
        "body": "i could be wrong about this, but my understanding is that because `BeforeInsert` is an instance-level method, you need an actual instance of `Todo` in order for it to be invoked (you can't reference `this.password` if there's no `this`). The object you're passing in the request is just an object that happens to have the same properties as `Todo`. "
      },
      {
        "user": "JamesCoonce",
        "created_at": "2018-10-16T15:53:42Z",
        "body": "That works. I need to create an actual instance first."
      },
      {
        "user": "gintsgints",
        "created_at": "2018-10-21T09:33:42Z",
        "body": "@JamesCoonce consider closing issue then."
      },
      {
        "user": "pilattebe",
        "created_at": "2019-06-19T18:24:37Z",
        "body": "I know why this works that way but it shouldn’t IMO. "
      },
      {
        "user": "vinimdocarmo",
        "created_at": "2019-08-14T15:15:22Z",
        "body": "> That works. I need to create an actual instance first.\r\n\r\nHow can one call a validation method using repository.save passing just a plain object instead of an entity instance?"
      },
      {
        "user": "liqwid",
        "created_at": "2019-10-11T00:39:29Z",
        "body": "> > That works. I need to create an actual instance first.\r\n> \r\n> How can one call a validation method using repository.save passing just a plain object instead of an entity instance?\r\n\r\n`Entity.prototype[methodName].apply(object, args)`\r\ngiven entity often is a DTO, that's useful IMO\r\n\r\nof course this brings the problem that any other instance methods would be unavailable in the call\r\n\r\nanother obvious solution is to instantiate.\r\n\r\nAnyway it should be explicitly mentioned in docs that instantiation is _required_ to use hooks"
      },
      {
        "user": "niyodusengaclement",
        "created_at": "2021-03-12T08:11:10Z",
        "body": "You can use the create method to create an instance`const data = repository.create(yourDto)` and then save returned data `repository.save(data)`\r\n\r\nThis will solve the issue"
      }
    ]
  },
  {
    "number": 2920,
    "title": "Auto increment on non primary key field",
    "created_at": "2018-10-11T20:53:01Z",
    "closed_at": "2019-03-12T19:46:03Z",
    "labels": [
      "question",
      "driver: mongodb"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/2920",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[x] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n[x] `0.1.21`\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\nHello,\r\n\r\nHow can we include a non primary key as field and auto increment? \r\n\r\nThe `_id` should be ObjectIdColumn and I would like to have another property `code` as AutoIncrement (for example). \r\nIs it possible?",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/2920/comments",
    "author": "nuno-morais",
    "comments": [
      {
        "user": "rustamwin",
        "created_at": "2019-03-12T19:46:03Z",
        "body": "1. No. MongoDB does not support auto increment like as rdbms\r\n2. You have to do it yourself (maybe can use `$inc` option)"
      }
    ]
  },
  {
    "number": 2903,
    "title": "Is MongoDB still experimental?",
    "created_at": "2018-10-08T07:27:03Z",
    "closed_at": "2018-12-20T05:42:17Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/2903",
    "body": "**Issue type:**\r\n\r\n[x ] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ x ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[ x] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n\r\nIs MongoDB still experimental?\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/2903/comments",
    "author": "rluvaton",
    "comments": [
      {
        "user": "Kononnable",
        "created_at": "2018-10-16T21:53:40Z",
        "body": "Depends what you define as experimental(I know it's used in readme). Some features are working, but not all of them(comparing to other drivers). Typeorm is mostly RDBMs focused and some functionalities will never be implemented to Mongo driver(because of differences between SQL and NO-SQL databases works). New features are mostly implemented by the community."
      },
      {
        "user": "ruscon",
        "created_at": "2018-11-20T11:58:18Z",
        "body": "We use, generally satisfied.\r\nThere are a lot of small notes, but most things work without problems."
      },
      {
        "user": "phil294",
        "created_at": "2018-12-16T00:52:40Z",
        "body": "Documentation does not really reflect what works and what doesnt, however. That would be great. For example, \r\n```\r\n.find({ where: {\r\nfoo: 'bar'\r\n}})\r\n```\r\nworks, but\r\n```\r\n.find({ where: {\r\nfoo: Not('bar')\r\n}})\r\n```\r\nDoesnt. (in which case you could of course simply do `foo: { $ne: 'bar }`\r\n\r\nEdit: to below comment: I'd love to, but have just started *using* this lib. I am way too confused about everything typeorm to contribute anything meaningful. The crux of open source :p"
      },
      {
        "user": "havenchyk",
        "created_at": "2018-12-19T19:08:09Z",
        "body": "@phil294 PR with a fix is welcome :)"
      },
      {
        "user": "pleerock",
        "created_at": "2018-12-20T05:42:17Z",
        "body": "I guess answer to this question was given and we can close this issue. Thanks for everyone's feedback!"
      },
      {
        "user": "lonix1",
        "created_at": "2019-03-09T18:52:11Z",
        "body": "@phil294 and @rluvaton and others:\r\n\r\nNow that you've been using it for a while, can you recommend it? Is it stable enough and feature complete enough for use in a production environment?\r\n\r\nI'm using mongoose and I'm tired of all its shortcomings, but I don't want to adopt a new library that is still beta...\r\n\r\nAny advice appreciated!"
      },
      {
        "user": "phil294",
        "created_at": "2019-04-22T21:44:29Z",
        "body": "@lonix1 sorry the delay. Havent used it a lot, but so far, it was very good. Especially the ActiveRecord syntax feels very natural:\r\n`let entity = new MyEntity(); entity.save()`\r\nthis is the reason I left mongoose behind where you can do the same thing, but there it's not a native class and you have no typings. I compared most mongodb typescript ORMs for this and TypeORM is somehow the only decent one which does not require you to write an extra interface for every class declaration (which is, as a general pattern, a really questionable decision imo)\r\nFor find() queries, you are simply using the MongoDB driver. Works fine so far. The only real problem I have had so far was #3266 but maybe there is a good workaround. Joins are also not possible. In my experience however, once you actually require collection joins (which *are* possible with mongodb), you should probably be using a relational database instead :D "
      }
    ]
  },
  {
    "number": 2890,
    "title": "TypeORM Repository throws error on return types when wrapping it in a custom class",
    "created_at": "2018-10-04T11:59:31Z",
    "closed_at": "2020-10-03T05:03:37Z",
    "labels": [
      "question",
      "can be closed?"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/2890",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[x] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[x] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[] `latest`\r\n[x] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nI needed to add some custom functionality to the Repository so I made a wrapper class for Typeorm Repository. This wrapper class adds some new functions to the Repository class as well as overrides existing ones such as save,update etc.\r\n\r\n```ts\r\nexport class TypeORMRepositoryWrapper<Entity> {\r\n  public entityTableName: string;\r\n  public roleName: string;\r\n  public entityClass: ObjectType<Entity>;\r\n\r\n  constructor(entityTableName: string, roleName: string, entityClass: ObjectType<Entity>) {\r\n    this.entityTableName = entityTableName;\r\n    this.roleName = roleName;\r\n    this.entityClass = entityClass;\r\n  }\r\n\r\n  public getRepository<Entity>(connectionName: string = 'default'): Repository<Entity> {\r\n    const repository = getConnectionManager()\r\n      .get(connectionName)\r\n      .getRepository<Entity>(this.entityClass);\r\n\r\n    /*\r\n    insert custom functions as well\r\n    repository.customFunction = some function\r\n\r\n    override default functions such as save, update, insert\r\n    repository.insert = async (entity: Entity | Entity[], options?: SaveOptions): Promise<InsertResult> => {\r\n      // custom functionality here\r\n      return repository.manager.insert(repository.metadata.target, entity, options);\r\n    };\r\n    */\r\n    return repository;\r\n  }\r\n}\r\n```\r\n\r\nnext, I have a function which creates an instance of this TypeORMRepositoryWrapper and then invokes the getRepository method of that class which gives me a TypeORM Repository.\r\n\r\n```ts\r\nexport const findById = async (id: number): Promise<City | undefined> => {\r\n  const customRepo = new TypeORMRepositoryWrapper( 'some entity name','some role',City).getRepository();\r\n  return customRepo.findOne({\r\n    where: {\r\n      id,\r\n    }\r\n  });\r\n};\r\n```\r\nnow, according to the documentation and the code that i went through, findOne will either return an instance of the entity (in this case City) or it will return undefined. However, Typescript throws an error here that: \r\n\r\n> Type '{} | undefined' is not assignable to type 'City | undefined'.\r\n>   Type '{}' is not assignable to type 'City | undefined'.\r\n>     Type '{}' is not assignable to type 'City'.\r\n>       Property 'id' is missing in type '{}'. (2322)\r\n\r\nsame is the case with the find function. It should return an array of the Entities and an empty array however it throws a similar error:\r\n\r\n> type '{}[]' is not assignable to type 'City[]'.\r\n>   Type '{}' is not assignable to type 'City'. (2322)\r\n\r\nPlease note that i have not tinkered with the find and findOne functions in any way. I have not touched them neither have i overridden them.\r\n\r\nWhen i change the return types to Promise < any >, all of these problems go away!!\r\n\r\nHowever, using Promise < any > here seems extremely hacky so i would like to know if there's another way to do this or if there's something wrong in my implementation which can be fixed to fix this issue!\r\n\r\nThanks!\r\n\r\n\r\n**UPDATE: I FIXED IT!**\r\nI managed to fix this issue by adding an instance of the repository as an attribute of the wrapper class like this:\r\n```ts\r\nexport class TypeORMRepositoryWrapper<Entity> {\r\n  public entityTableName: string;\r\n  public roleName: string;\r\n  public entityClass: ObjectType<Entity>;\r\n  public repository: Repository<Entity>;\r\n\r\n  constructor(\r\n    entityTableName: string,\r\n    roleName: string,\r\n    entityClass: ObjectType<Entity>,\r\n    connectionName: string = 'default',\r\n  ) {\r\n    this.entityTableName = entityTableName;\r\n    this.roleName = roleName;\r\n    this.entityClass = entityClass;\r\n    this.repository = getConnectionManager()\r\n      .get(connectionName)\r\n      .getRepository<Entity>(this.entityClass);\r\n      \r\n    // add custom methods to this.repository as needed\r\n  }\r\n}\r\n```\r\n\r\nthis now works perfectly. But, i would still very much like to know what was wrong in my initial implementation and what i could have done to fix that.\r\nlooking forward to the feedback!",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/2890/comments",
    "author": "HussainAliAkbar",
    "comments": [
      {
        "user": "Quynh-Nguyen",
        "created_at": "2019-03-13T09:13:03Z",
        "body": "@HussainAliAkbar \r\n\r\nThank you so much,\r\nI'm also finding the way for implement BaseRepository extends Repository (of typeorm)\r\n\r\n--\r\nBut how you can call your `TypeORMRepositoryWrapper` from Services, Controllers?"
      },
      {
        "user": "HussainAliAkbar",
        "created_at": "2019-03-14T03:39:04Z",
        "body": "apologies @Quynh-Nguyen , I did not understand your question. Could you please elaborate it more?"
      }
    ]
  },
  {
    "number": 2870,
    "title": "Query the same ID after inserting",
    "created_at": "2018-10-01T08:42:26Z",
    "closed_at": "2021-06-19T04:29:12Z",
    "labels": [
      "bug",
      "question",
      "can be closed?",
      "driver: mysql",
      "driver: mariadb"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/2870",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[x] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n[x] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\n```\r\n    const arr = [\r\n        {name: 'name1', identify: 'identify1'},\r\n        {name: 'name2', identify: 'identify2'},\r\n        {name: 'name3', identify: 'identify3'},\r\n      ]\r\n      \r\n      await resourceRepository.insert(arr)\r\n```\r\n\r\nSQL:\r\n```\r\nquery: INSERT INTO `resource`(`id`, `name`, `identify`) VALUES (DEFAULT, ?, ?), (DEFAULT, ?, ?), (DEFAULT, ?, ?) -- PARAMETERS: [\"name1\",\"identify1\",\"name2\",\"identify2\",\"name3\",\"identify3\"]\r\nquery: SELECT `Resource`.`id` AS `Resource_id`, `Resource`.`name` AS `Resource_name` FROM `resource` `Resource` WHERE (`Resource`.`id` = ?) -- PARAMETERS: [1]\r\nquery: SELECT `Resource`.`id` AS `Resource_id`, `Resource`.`name` AS `Resource_name` FROM `resource` `Resource` WHERE (`Resource`.`id` = ?) -- PARAMETERS: [1]\r\nquery: SELECT `Resource`.`id` AS `Resource_id`, `Resource`.`name` AS `Resource_name` FROM `resource` `Resource` WHERE (`Resource`.`id` = ?) -- PARAMETERS: [1]\r\n```\r\nThe same ID was queried three times\r\n\r\n<!--\r\n    To answer those questions you need to put \"x\" inside the square brackets, for example:\r\n    [x] `mysql`\r\n    [ ] `postgres`\r\n\r\n    Also, please format your code properly (by taking code blocks into ```ts .... ```)\r\n!>\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/2870/comments",
    "author": "aapplet",
    "comments": [
      {
        "user": "mario-bware",
        "created_at": "2018-12-18T11:51:36Z",
        "body": "I've just run into this same issue. Makes the insert query builder unusable as you end up with incorrect duplicate PK's in your entities.\r\n\r\nAlso, is there a way to disable the select after insert? It would be nice if the selects were optimised rather than one per record."
      },
      {
        "user": "pleerock",
        "created_at": "2018-12-19T11:39:15Z",
        "body": "Actually, it wasn't supposed for `insert` to execute any additional query or return `InsertResult` result. So looks like a bug.\r\n\r\nFor now, to fix your issues you need to create insert query builder instead of using `insert` method from manager. Example:\r\n\r\n```ts\r\n        manager.createQueryBuilder()\r\n            .insert()\r\n            .into(EntityCls)\r\n            .values(entities)\r\n            .updateEntity(false)\r\n            .execute();\r\n```"
      },
      {
        "user": "mario-bware",
        "created_at": "2019-01-07T04:10:14Z",
        "body": "In my case, I was using the `createQueryBuilder()` and had the same issue. Including `updateEntity(false)` removes the bad selects after the insert and allows me to optimise the query so that is helpful, thank you!"
      },
      {
        "user": "imnotjames",
        "created_at": "2020-10-10T21:24:16Z",
        "body": "Is this still a problem?  We made a few changes that might have fixed this problem."
      }
    ]
  },
  {
    "number": 2830,
    "title": "[Q] Custom repository from Entity Schema",
    "created_at": "2018-09-21T11:08:02Z",
    "closed_at": "2020-10-04T02:18:48Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/2830",
    "body": "**Issue type:**\r\n\r\n[x ] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[] `mssql`\r\n[x] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[ ] `latest`\r\n[ ] `@next`\r\n[x] `0.1.16` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nCan I create a custom repository from Entity Schema? Example:\r\nSchema:\r\n\r\n```\r\nexport default new EntitySchema({\r\n  name: 'ReportStatus',\r\n  columns: {\r\n    id: {\r\n      primary: true,\r\n      type: 'int',\r\n      generated: true,\r\n      readonly: true,\r\n    },\r\n    name: {\r\n      type: 'varchar',\r\n      nullable: false,\r\n      unique: true,\r\n    },\r\n  },\r\n  relations: {\r\n    reports: {\r\n      target: 'Report',\r\n      type: 'one-to-many',\r\n      cascade: true,\r\n      inverseSide: 'status',\r\n    },\r\n  },\r\n} as EntitySchemaOptions<any>);\r\n```\r\n\r\nand custom repository:\r\n\r\n```\r\nimport ReportStatus from '../models/ReportStatus';\r\n@EntityRepository(ReportStatus)\r\nexport default class CustomRepository extends Repository<ReportStatus> {\r\n\r\n    foo() {...}\r\n}\r\n```\r\n\r\nNow it gives me  error in @EntityRepository(ReportStatus) part:\r\n```\r\nArgument of type 'EntitySchema<any>' is not assignable to parameter of type 'Function'.\r\n  Property 'apply' is missing in type 'EntitySchema<any>'.\r\n```\r\n\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/2830/comments",
    "author": "hrzepinski",
    "comments": [
      {
        "user": "aescarcha",
        "created_at": "2018-09-24T08:29:53Z",
        "body": "I have the same issue, can't put the two features together"
      },
      {
        "user": "aescarcha",
        "created_at": "2018-09-24T09:07:24Z",
        "body": "I've had some success by casting my `EntitySchema` to `any`, but of course this is not ideal. My code is:\r\n\r\n```\r\nexport const paidLinkMapping = new EntitySchema({\r\n    name: 'PaidLink',\r\n    tableName: 'paid_link',\r\n    columns: {\r\n        id: {\r\n            type: Number,\r\n            primary: true,\r\n            generated: true,\r\n            name: 'pl_id'\r\n        }.....\r\n}\r\n```\r\n\r\n```\r\n\r\n@EntityRepository(paidLinkMapping as any)\r\nexport class PaidLinkRepository extends Repository<PaidLink> implements IPaidLinkRepository {\r\n\r\n    public getByProvince(province?: number): Promise<IPaidLink[]> {\r\n        const qb = this.createQueryBuilder();\r\n        if (province) {\r\n            qb.where('PaidLink.province = :province', { province: province })\r\n        }\r\n        return qb\r\n            .andWhere('PaidLink.validUntil >= NOW()')\r\n            .orderBy('RAND()')\r\n            .limit(8)\r\n            .getMany();\r\n    }\r\n}\r\n\r\nexport function getPaidLinkRepository(): IPaidLinkRepository {\r\n    const conn = getConnection();\r\n    return conn.getCustomRepository(PaidLinkRepository);\r\n}\r\n\r\n```"
      },
      {
        "user": "MrTravisB",
        "created_at": "2019-02-28T17:17:53Z",
        "body": "Has anyone figured out how to get this working?"
      },
      {
        "user": "gcaraciolo",
        "created_at": "2019-06-05T00:10:43Z",
        "body": "any plans for this?"
      },
      {
        "user": "imnotjames",
        "created_at": "2020-10-04T02:18:48Z",
        "body": "We're actually phasing out some of the custom repository features - so I don't think this will be on the radar."
      }
    ]
  },
  {
    "number": 2808,
    "title": "Electron React Webpack Typescript project configuration file entity not recognized",
    "created_at": "2018-09-16T22:45:57Z",
    "closed_at": "2020-10-03T02:07:25Z",
    "labels": [
      "question",
      "comp: browser"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/2808",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[x] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nI am using nodev`8.11.4` npmv`5.6.0` and the latest `electron` `react` `webpack` in my project.\r\n\r\nI was able to get everything to work with the `sqlite3` driver albeit after using a `postinstall` `npm` script to have `electron-builder` rebuild the driver for `electron`.\r\n\r\nMy difficulties were with `webpack`. \r\n\r\nOriginally, I wished to use a standard options in a `ormconfig.json` file but I am unable to get `typeorm` to recognize any of my entities.\r\n\r\nHowever, after several hours playing around with different configurations like using `webpack` `file-loader` I got everything to work but just not with the config file rather I needed to specify my entities in a `ConnectionOption`s object passed to `createConnection`.\r\n\r\nThis also required me to provide a table name in the `Entity` decorator.\r\n\r\nI think this may be more of a `webpack` issue but since `electron` and `node webkit` are gaining steam rapidly it may be worth the time to get `typeorm` to play nice with `webpack`.\r\n\r\nI believe `webpack` renames things and handles all the links to all resources. At first I figured I could point typeorm to look for entities int the `webpack` produced bundle since maybe it just looks for types marked with the decorator. This didn't work. \r\n\r\nEventually, I needed to specify `typeorm` as a external dep in `webpack` as with `sqlite3` as well. Also, I only referenced `typeorm` and any entities in the rendered process.\r\n\r\nI know `webpack` is mostly considered a client side tool and db related stuff with usually be in the backend or on server in node environment, however, `electron` and others have essentially merged the 2 and like in the case of my project I require db related code in node environment and `webpack` has been great for me for things like loading my sass and loading svg and other files.\r\n\r\nI marked question at the top of this issue rather then bug.\r\n\r\nI do have a working project that I put together to get Electron, React, Webpack, and Typeorm all working. I noticed a Electron sample project that uses a basic typescript config but not webpack.\r\n\r\nIf you would like the project please let me know. I do not have any experience with public repos and such else I would have just put a link to it here.",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/2808/comments",
    "author": "RuntimeRascal",
    "comments": [
      {
        "user": "dominicdesu",
        "created_at": "2018-09-23T19:39:23Z",
        "body": "Hi, is your question how to use the ormconfig.json together with Electron?"
      },
      {
        "user": "imnotjames",
        "created_at": "2020-10-03T02:07:25Z",
        "body": "Hi there - there have been a number of improvements in this area and many of the problems you've mentioned should be better now.\r\n\r\nIf, for some reason, you're still having issues let's open a fresh issue with a way to replicate and I'm sure we can find a way to improve the experience."
      }
    ]
  },
  {
    "number": 2789,
    "title": "Querying nested fields",
    "created_at": "2018-09-12T04:26:06Z",
    "closed_at": "2019-04-20T22:38:12Z",
    "labels": [
      "question",
      "can be closed?",
      "driver: mongodb"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/2789",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[x] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n[x] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Question:**\r\n\r\nHow do you query on nested fields? For example, given a collection of records like:\r\n\r\n```javascript\r\n{\r\n    foo: {\r\n        bar: 'baz'\r\n    }\r\n},\r\n{\r\n    foo: {\r\n        bar: 'qux'\r\n    }\r\n}\r\n```\r\n\r\nhow do I get this query to work?:\r\n\r\n```javascript\r\nThings.find({\r\n    foo: {\r\n        bar: 'baz'\r\n    }\r\n});\r\n```",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/2789/comments",
    "author": "rosshadden",
    "comments": [
      {
        "user": "rosshadden",
        "created_at": "2018-09-12T04:30:33Z",
        "body": "Also, how do I index nested fields? This should technically be a separate issue/question, but it is very related.\r\n\r\nIf I have an `@orm.Index()` decorator on a field that is not at the root level of an entity, it seems to create an index for the field as if it were at the root level, as best as I can tell.\r\nThat is, if the path of the field I am trying to index is `foo.bar` like in my example above, an index is created for `bar`, not `foo.bar`."
      },
      {
        "user": "nicolas-marien",
        "created_at": "2018-12-14T15:05:24Z",
        "body": "I think I've managed to have it worked by querying \"mongo style\".\r\n\r\n```typscript\r\nThings.find({'foo.bar': 'baz'};\r\n```\r\n\r\nThe query seems to be unaltered and sent as is to the Mongo driver, but this does not pass type checking.\r\n\r\nBut `Things.find({ where: { 'foo.bar': 'baz' } })` should work and pass type checking :)\r\n"
      },
      {
        "user": "rustamwin",
        "created_at": "2019-03-12T07:24:04Z",
        "body": "Please follow a discussion in #3756"
      }
    ]
  },
  {
    "number": 2768,
    "title": "possible bug with eager loading?",
    "created_at": "2018-09-04T15:18:52Z",
    "closed_at": "2019-04-20T22:10:09Z",
    "labels": [
      "question",
      "can be closed?",
      "comp: lazy loading"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/2768",
    "body": "**Issue type:**\r\n\r\n[ x] question\r\n[ x] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[ x] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[ ] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nHi,\r\n\r\nmaybe I am doing something wrong, but I noticed definitely, that whatever side the eager goes on a one-to-many relationship, only that side will show the value.\r\n\r\n    in Termin:\r\n    @ManyToOne(type => Rezept, rezept => rezept.termine, {nullable: true})\r\n    rezept: Rezept\r\n\r\n    in Rezept:\r\n    @OneToMany(type => Termin, termin => termin.rezept, { eager: true })    \r\n    termine: Termin[]\r\n\r\nI just moved the eager from the \"termine\"-place to \"rezept\" (see above) and now I got a count of \"termine\", which was undefined before, but the other place where I show the linked \"rezept\" is now undefined?!\r\n\r\nBoth, \"Termin\" and \"Rezept\" are linked from patient, which is the \"entry point\", so I am loading patient first:\r\nlet termin of patient.termine\r\n    termin.rezept is undefined if \"eager\" is on rezept.termine and set correctly to the \"rezept\" if \"eager\" is on termin.rezept\r\nlet rezept of patient.rezepte\r\n   rezept.termine is an array of termine if \"eager\" is on rezept.termine, but is undefined if eager is on termine.rezept\r\n\r\n    Patient:\r\n    @OneToMany(type => Termin, termin => termin.patient, { eager: true})\r\n    termine: Termin[];  \r\n\r\n    @OneToMany(type => Rezept, rezept => rezept.patient, {eager: true})\r\n    rezepte: Rezept[]\r\n\r\nBest regards,\r\nThomas\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/2768/comments",
    "author": "tombolala",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2019-01-07T12:56:48Z",
        "body": "its not a bug, its just how lazy load works - it loads eagerly only from one side, to prevent circular issues."
      },
      {
        "user": "tombolala",
        "created_at": "2019-01-07T19:57:22Z",
        "body": "then, how do you load it from the other side? "
      },
      {
        "user": "pleerock",
        "created_at": "2019-01-08T07:17:27Z",
        "body": "its the same data as you have from first side, right? You can manually assign data if you need."
      }
    ]
  },
  {
    "number": 2756,
    "title": "The default column is not present after calling save",
    "created_at": "2018-09-01T20:31:19Z",
    "closed_at": "2021-07-31T01:48:11Z",
    "labels": [
      "bug",
      "question",
      "driver: postgres"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/2756",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[x] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[x] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\nGiven the following migration\r\n```ts\r\nexport class Post1535782493710 implements MigrationInterface {\r\n\r\n    public async up(queryRunner: QueryRunner): Promise<any> {\r\n      await queryRunner.query(`CREATE SEQUENCE IF NOT EXISTS incr_by_db_seq;`);\r\n      await queryRunner.query(`\r\n        CREATE TABLE IF NOT EXISTS \"post\"\r\n          (\r\n              id serial NOT NULL,\r\n              incr integer NOT NULL DEFAULT nextval('incr_by_db_seq'),\r\n              title character varying(255),\r\n              CONSTRAINT post_pkey PRIMARY KEY (id)\r\n          );\r\n      `);\r\n    }\r\n\r\n    public async down(queryRunner: QueryRunner): Promise<any> {\r\n      await queryRunner.query(`DROP SEQUENCE IF EXISTS incr_by_db_seq;`);\r\n      await queryRunner.query(`DROP TABLE IF EXISTS \"post\";`);\r\n    }\r\n\r\n}\r\n```\r\nThe entity looks like\r\n```ts\r\n\r\n@Entity()\r\nexport class Post {\r\n\r\n    @PrimaryGeneratedColumn()\r\n    id: number;\r\n\r\n    @Column()\r\n    incr: number;\r\n\r\n    @Column()\r\n    title: string;\r\n\r\n}\r\n```\r\n\r\nIf perform a save call, then the result doesn't contain the column ```incr```\r\n```ts\r\nconst post = new Post();\r\npost.title = \"Super title\";\r\nconst result = await connection.manager.save(post);\r\n\r\nexpect(result).not.to.be.empty;\r\nexpect(result!.title).not.to.be.empty;\r\nresult!.title.should.be.equal(\"Super title\");\r\n\r\nexpect(result!.incr_by_db, \"incr field is present\").not.to.be.empty;\r\nexpect(result!.incr_by_db).to.be.greaterThan(0);\r\n```",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/2756/comments",
    "author": "rianby64",
    "comments": [
      {
        "user": "rianby64",
        "created_at": "2018-09-01T20:36:37Z",
        "body": "If you configure the entity as follows\r\n```ts\r\n@Entity()\r\nexport class Post {\r\n\r\n    @PrimaryGeneratedColumn()\r\n    id: number;\r\n\r\n    @Column({\r\n        default: \"whatever\"\r\n    })\r\n    incr: number;\r\n\r\n    @Column()\r\n    title: string;\r\n\r\n}\r\n```\r\n\r\nthen, the field ```incr``` will be present after calling ```save```. Notice the presence of ```default: \"whatever\"``` in the model."
      },
      {
        "user": "pleerock",
        "created_at": "2018-10-27T14:54:52Z",
        "body": "@Kononnable can you help here? Im not sure I understood what author means here. Also he provided a PR but it doesn't change any file, only tests, and, at the same time, tests aren't failed."
      },
      {
        "user": "rianby64",
        "created_at": "2018-10-27T15:54:11Z",
        "body": "Here the meaning is that the behavior for `default` values is working incorrectly. Take a look to the field `incr`. Notice that this field has a default value given by Postgres. But for some strange reasons that default value from Postgres is not available when performing a post action."
      },
      {
        "user": "Kononnable",
        "created_at": "2018-10-27T16:54:09Z",
        "body": "Tbh description isn't very helpful. It requires to run the code, play with it a bit to see whats actually issue is about. Tests in PR can't be even merged because it is only postgres specific(sql syntax) and there is `connection.dropDatabase()`.\r\n\r\nThe important part: after `const result = await connection.manager.save(post);` there is no `incr` property in the result.\r\n```\r\nquery: INSERT INTO \"post\"(\"incr\", \"title\") VALUES (DEFAULT, $1) RETURNING \"id\" -- PARAMETERS: [\"Super title\"]\r\nquery: COMMIT\r\nPost { title: 'Super title', id: 3 }\r\n```\r\n"
      },
      {
        "user": "rianby64",
        "created_at": "2018-10-28T08:03:38Z",
        "body": "My PR is not intended to be merged. It's an explanation of this case. You correctly found the root of this issue. If you define a model, and one field of this model has a default value given by postgres, then I'm expecting to see that field in the result of a `post` action. If not, then I'm forced to write a second request based on the last id, which is undesirable."
      },
      {
        "user": "imnotjames",
        "created_at": "2021-07-31T01:48:11Z",
        "body": "The related PR tests passed.  I don't believe this is an issue any longer."
      }
    ]
  },
  {
    "number": 2683,
    "title": "[Question, possible issue] Can I use .update() on data returned by a QB with a partial field selection?",
    "created_at": "2018-08-20T07:31:54Z",
    "closed_at": "2022-12-29T15:44:17Z",
    "labels": [
      "question",
      "new feature",
      "can be closed?",
      "driver: postgres"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/2683",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[ ] bug report\r\n[x] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[x] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nFor performance reasons, I would like to use a query builder, followed by repository.update() call. However, it appears that update() can break in this scenario?\r\n\r\nE.g.\r\n\r\n\r\n let data = repository\r\n                        .createQueryBuilder(\"ac\")\r\n                        .select([\"ac.id\", \"ac.fieldToEdit\"])\r\n                        .where(\"ac.sId = :sId\", { sId: s.id })\r\n                        .andWhere(\"ac.status = :status\", { status: AffiliateCodeStatus.Active })\r\n                        .andWhere(\"ac.pId = :pId\", { pId: p.id })\r\n                        .andWhere(\"ac.aId IN (:...aIds)\", { aIds: affected.map(x => x.id) })\r\n\r\nthen... manipulate some of the data,\r\n\r\nthen.... data.forEach(x => repository.update(x).\r\n\r\nWhen I ran this code as an experiment, update blanked out the columns that were not returned by the QB. Is this correct behaviour? It would be nice for perf reasons if this scenario was supported by the update api.",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/2683/comments",
    "author": "dcworldwide",
    "comments": [
      {
        "user": "imnotjames",
        "created_at": "2021-07-10T06:03:30Z",
        "body": "Is this still the case?  I cannot replicate it anymore."
      }
    ]
  },
  {
    "number": 2659,
    "title": "cascadeRelations Entity",
    "created_at": "2018-08-14T09:21:58Z",
    "closed_at": "2021-07-04T15:48:08Z",
    "labels": [
      "question",
      "driver: postgres"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/2659",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[x] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[ ] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nHello,\r\n\r\nI encounter a problem on save on postgres for link between three tables in cascade.\r\n\r\nI have an Entity \"Freelance\" base on base Entity, with a link to account:\r\n```\r\n  @OneToOne(type => AccountEntity, {\r\n    cascade: ['update'],\r\n    eager: true,\r\n    nullable: false,\r\n    onDelete: 'CASCADE',\r\n  })\r\n  @JoinColumn()\r\n  public account: AccountEntity;\r\n```\r\n\r\nThe account detail is linked successfully. Otherwise, I have in account:\r\n\r\n```\r\n  @OneToOne(type => MediaEntity, {\r\n    eager: true,\r\n    cascade: true,\r\n    nullable: true,\r\n    onDelete: 'SET NULL',\r\n  })\r\n  @JoinColumn()\r\n  public profilePicture?: MediaEntity;\r\n``` \r\n\r\nthis media exists in postgres, but the id is not set in account on column \r\n\r\n\"profilPictureId\".\r\n\r\nI check the source code, and I found in node_modules/typeorm/persistence/subject-builder/CascadesSubjectBuilder.js\r\n\r\non line 25:\r\n\r\n```\r\nsubject.metadata\r\n           .extractRelationValuesFromEntity(subject.entity, subject.metadata.relations) // todo: we can create EntityMetadata.cascadeRelations\r\n           .forEach(function (_a) {\r\n```\r\n\r\nIt doesn't go in forearch, and it is in this case that the id is not saved. I saw a \"todo\" comment, maybe this part is not done yet ? I am in version 0.2.6.\r\n```\r\n    \"typeorm\": \"^0.2.6\",\r\n```\r\n\r\nDo you have any idea ? It is not possible in this version ?\r\nThanks in advance,\r\n\r\nMax.",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/2659/comments",
    "author": "MaxDesplanches",
    "comments": [
      {
        "user": "imnotjames",
        "created_at": "2021-07-04T15:48:08Z",
        "body": "Cascades happen in database now, so this is no longer relevant."
      }
    ]
  },
  {
    "number": 2637,
    "title": "Querying json column without query builder in Postgres",
    "created_at": "2018-08-08T12:57:59Z",
    "closed_at": "2019-02-19T22:00:28Z",
    "labels": [
      "question",
      "driver: postgres"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/2637",
    "body": "**Issue type:**\r\n\r\n[X] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[X] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[X] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\n I have created an entity with a json column in it as below.\r\n\r\n```typescript\r\n@Entity()\r\nexport class Approvers  {\r\n\r\n    @PrimaryGeneratedColumn()\r\n    public id: number;\r\n\r\n    @Column('jsonb')\r\n    public approversJson: IApprovers[]\r\n     }\r\n```\r\n```typescript\r\ninterface IApprovers{\r\n  approverName: string;\r\n  approverEmployeeCode: string;\r\n  emailAddress: string;\r\n}\r\n```\r\nI am querying table with conditions on json column as below.\r\n\r\n```typescript\r\nconst query = SELECT * from approvers WHERE approversJson @> '[{\"approverEmployeeCode\":\"SomeEmployeeCode\"}]' ;\r\n const data =  await this.approverRepository.query(query);\r\n ```\r\n\r\nI would like to know if above querying can be done without query builder.\r\n\r\n\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/2637/comments",
    "author": "santhan456",
    "comments": [
      {
        "user": "Kononnable",
        "created_at": "2019-02-19T16:38:29Z",
        "body": "Did you resolve your issue?"
      },
      {
        "user": "vlapo",
        "created_at": "2019-02-19T22:00:09Z",
        "body": "This is not possible without query builder and I do not think we will support this in near future."
      },
      {
        "user": "jay-coditas",
        "created_at": "2020-02-21T14:40:17Z",
        "body": "@santhan456 Can you help me figure out adding a LIKE constraint against the \"approverEmployeeCode\" field?\r\n"
      }
    ]
  },
  {
    "number": 2636,
    "title": "Question: Using mongodb and sql from the same entity",
    "created_at": "2018-08-08T12:09:36Z",
    "closed_at": "2019-02-26T22:43:00Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/2636",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[x] `mongodb`\r\n[x] `mssql`\r\n[x] `mysql` / `mariadb`\r\n[x] `oracle`\r\n[x] `postgres`\r\n[x] `sqlite`\r\n[x] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nHi\r\n\r\nI want to use mongodb and sql together with one entity. \r\n\r\nThe problem now is that I have to define and ObjectId type for mongodb which is not compatible with sql. Is there some generic primary column field which maps to both? ",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/2636/comments",
    "author": "simonhoss",
    "comments": [
      {
        "user": "Kononnable",
        "created_at": "2019-02-19T16:37:58Z",
        "body": "You should probably use entity schemas instead of decorator approach."
      },
      {
        "user": "vlapo",
        "created_at": "2019-02-19T22:20:54Z",
        "body": "Entity schema will not help. Right now mongodb and SQL based DBs have different implementation in typeorm (mainly because of `ObjectIdColumn` and not implemented query builder for mongodb). So this is no possible now."
      },
      {
        "user": "kraikov",
        "created_at": "2020-04-30T13:46:23Z",
        "body": "Is it now possible to use the same entity for MongoDB and SQLite?"
      },
      {
        "user": "mxvsh",
        "created_at": "2021-09-21T09:08:13Z",
        "body": "any updates?"
      }
    ]
  },
  {
    "number": 2577,
    "title": "Is there a reason why listeners and subscribers would not work at all?",
    "created_at": "2018-07-24T16:22:46Z",
    "closed_at": "2018-09-29T10:49:25Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/2577",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[x] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\nUsing getRepository(Entity).save(data) or entityManager.save(Entity, data) will not fire the @AfterUpdate or @AfterInsert methods on the entity.\r\n\r\n```\r\n@AfterInsert()\r\n@AfterUpdate()\r\nsomeMethod() { \r\n console.log(\"It worked!\")\r\n}\r\n```\r\n\r\n\r\n<!--\r\n    To answer those questions you need to put \"x\" inside the square brackets, for example:\r\n    [x] `mysql`\r\n    [ ] `postgres`\r\n\r\n    Also, please format your code properly (by taking code blocks into ```ts .... ```)\r\n!>\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/2577/comments",
    "author": "joebieb",
    "comments": [
      {
        "user": "joebieb",
        "created_at": "2018-07-24T16:28:27Z",
        "body": "Actual project code:\r\n```\r\n  /**\r\n   * Create a new ReportDetail\r\n   * @param req\r\n   * @param res\r\n   * @param next\r\n   */\r\n  public async save(req: Request, res: Response, next: NextFunction) {\r\n    let result = getRepository(ReportDetail)\r\n                .save(req.body)\r\n                .then(result => res.send(result))\r\n                .catch(error => console.log(error));\r\n  };\r\n```\r\nEntity:\r\n```\r\nImports ...\r\n@Entity()\r\nexport class ReportDetail {\r\ncolumns ...\r\n\r\n  @UpdateDateColumn({ type: 'timestamp without time zone', name: 'updated_at' })\r\n  updatedAt: Date;\r\n\r\n  @AfterUpdate()\r\n  @AfterInsert()\r\n  someMethod() {\r\n    console.log(\"This worked!\");\r\n  }\r\n}\r\n```\r\n"
      },
      {
        "user": "pleerock",
        "created_at": "2018-07-28T09:50:56Z",
        "body": "I guess its because your `req.body` is not instance of `ReportDetail`, and since its not instance of `ReportDetail` there is no method to call on `req.body`, e.g. you can't call `req.body.someMethod()`"
      },
      {
        "user": "joebieb",
        "created_at": "2018-07-28T20:18:11Z",
        "body": "Thank you for the help. This code works and fires the @AfterUpdate method. There's probably a better way to map the req.body to the new ReportDetail object, but this works.\r\n\r\n```\r\n  public async save(req: Request, res: Response, next: NextFunction) {\r\n    let _detail = new ReportDetail();\r\n    for(var key in req.body) _detail[key]=req.body[key];\r\n    let result = getRepository(ReportDetail)\r\n                .save(_detail)\r\n                .then(result => res.send(result))\r\n                .catch(error => console.log(error));\r\n  };\r\n```"
      }
    ]
  },
  {
    "number": 2566,
    "title": "Unable to use async config",
    "created_at": "2018-07-22T21:43:08Z",
    "closed_at": "2020-10-06T07:30:21Z",
    "labels": [
      "enhancement",
      "question",
      "new feature",
      "comp: configuration",
      "driver: postgres"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/2566",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[ ] bug report\r\n[x] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[x] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n[x] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nIt seems that currently it is impossible to have `ormconfig.js` (required by cli tools to operate) to return credentials asynchronously. In case when actual credentials are not in env, but rather need to be fetched from network (e.g. from Vault, AWS SSM, etc.), it is currently impossible to have `await/async` in `ormconfig.js` and return value for cli tools to operate.\r\n\r\nIt seems that even simple `await require( 'ormconfig' )` kind of code would solve the problem (and fall back to current behaior in case of sync config.",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/2566/comments",
    "author": "Nopik",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2018-07-28T11:02:45Z",
        "body": "just create a connection manually using `createConnection({ ... options ... })`, that will fit your requirements "
      },
      {
        "user": "Nopik",
        "created_at": "2018-07-28T12:41:29Z",
        "body": "@pleerock I was talking about invoking `typeorm migrations:run` - it can't use async config."
      },
      {
        "user": "ajhodges",
        "created_at": "2018-09-07T15:46:43Z",
        "body": ":+1: "
      },
      {
        "user": "valimero",
        "created_at": "2018-10-26T13:09:37Z",
        "body": "What's new there ?\r\n\r\nSame problem with MYSQL !"
      },
      {
        "user": "leonardfactory",
        "created_at": "2020-04-14T23:08:52Z",
        "body": "Actually, this is supported right now"
      },
      {
        "user": "wdimmit",
        "created_at": "2020-04-24T14:54:04Z",
        "body": "@leonardfactory How should `ormconfig.js` be setup to allow for returning an async thunk?"
      },
      {
        "user": "leonardfactory",
        "created_at": "2020-04-24T14:56:59Z",
        "body": "I'm using `ts-node`, but it should be doable with plain js. I'll take a guess:\r\n\r\n```js\r\nasync function getConnectionOptions() {\r\n  const config = await configLoader.load(); // Do whatever you need in order to load asynchronously the configuration\r\n  return config;\r\n}\r\n\r\nmodule.exports = getConnectionOptions(); // So we are returning a Promise here\r\n```\r\n\r\nYou can also do this with plain promises:\r\n\r\n```js\r\nfunction loadConfig() {\r\n  return configLoader.load().then(config => {\r\n    return {\r\n       ...\r\n    }\r\n  });\r\n}\r\nmodule.exports = loadConfig();\r\n```"
      }
    ]
  },
  {
    "number": 2545,
    "title": "repository.save() returns only the updated fields.",
    "created_at": "2018-07-19T04:23:30Z",
    "closed_at": "2020-10-05T06:03:42Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/2545",
    "body": "**Issue type:**\r\n\r\n[ ] question\r\n[x] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[x] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nWhen you use the `repository.save()` method to save an entity with an id (which means the entity exists in the database, thus it should be an update operation). The api only returns the updated fields rather than all fields. Is this a behavior by design?\r\n\r\n<!--\r\n    To answer those questions you need to put \"x\" inside the square brackets, for example:\r\n    [x] `mysql`\r\n    [ ] `postgres`\r\n\r\n    Also, please format your code properly (by taking code blocks into ```ts .... ```)\r\n!>\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/2545/comments",
    "author": "RedTailBullet",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2018-07-28T12:56:10Z",
        "body": "Yes, it is, it just returns you want it updated, e.g. you pass `{ id: x, name: y }` it will only return you `{ id: x, name: y, createdDate: \"some updated values\", someColumnWithDefault }`"
      },
      {
        "user": "RedTailBullet",
        "created_at": "2018-07-28T13:44:08Z",
        "body": "@pleerock Thanks for replying. But Why is the behavior set like this? Is there any consideration? Or just this is how mysql's library work?"
      },
      {
        "user": "Diluka",
        "created_at": "2019-02-28T06:19:45Z",
        "body": "@pleerock why it is just a pojo not entity? If I using ActiveRecord pattern to declare entity class, the `repository.save` returned object is not extending from `BaseEntity`!"
      },
      {
        "user": "PerminovEugene",
        "created_at": "2020-01-29T20:18:13Z",
        "body": "This is still actual issue for me :("
      },
      {
        "user": "kennylbj",
        "created_at": "2020-07-24T09:04:56Z",
        "body": "What should I do if I want to update only partial fields but return the entire entity? "
      },
      {
        "user": "imnotjames",
        "created_at": "2020-10-05T06:03:42Z",
        "body": "Select the entity again afterwards.  The existing output from this is not intended for use outside the internals of the framework and will change in the future."
      },
      {
        "user": "nlucero",
        "created_at": "2021-04-08T16:47:33Z",
        "body": "This won't work if you are using database replication :confused: "
      }
    ]
  },
  {
    "number": 2517,
    "title": "Shouldn't schema:sync create a migration table with a record with the current timestamp?",
    "created_at": "2018-07-13T18:47:58Z",
    "closed_at": "2020-10-16T04:57:05Z",
    "labels": [
      "question",
      "comp: migrations",
      "driver: postgres"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/2517",
    "body": "**Issue type:**\r\n\r\n[ x ] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ x ] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n**TypeORM version:**\r\n\r\n[ x ] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nShouldn't the `schema:sync` command create a `migration` table with a record with the current timestamp? Otherwise, `migration:run` will try to run all the migrations, even the ones that are not needed anymore (since we already have the most recent schema)",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/2517/comments",
    "author": "ericaprieto",
    "comments": [
      {
        "user": "imnotjames",
        "created_at": "2020-08-10T02:04:18Z",
        "body": "The `schema:sync` doesn't run migrations so I think that's why it doesn't write the migrations table.  This is ONLY for use in development.  It's not possible for us to know what migrations had been run and what hadn't."
      }
    ]
  },
  {
    "number": 2508,
    "title": "Problem with many-to-one relations using js with SAP tables",
    "created_at": "2018-07-12T13:57:11Z",
    "closed_at": "2018-12-10T16:39:26Z",
    "labels": [
      "question",
      "can be closed?",
      "comp: entity schemas"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/2508",
    "body": "**Issue type:**\r\n[ x] question\r\n\r\n**Database system/driver:**\r\n[ x] `postgres`\r\n\r\n\r\n**TypeORM version:**\r\n[x]`0.2.4`\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nI'm having problems to set up TypeOrm... In my project I need to access to some SAP tables and y can't generate extra fields for relations.\r\n\r\nThis is the main Entity (reduced), I need to create four relations (VBKD, VBEP, VBAP and VBPA)\r\n```\r\nvar vbak = new EntitySchema({\r\n    name: 'VBAK',\r\n    tableName: 'VBAK',\r\n    skipSync: false,\r\n    columns: {\r\n        VBELN: {\r\n            type:\"varchar\",\r\n            primary: true,\r\n            generated: false,\r\n        },\r\n    },\r\n    relations: {\r\n        comercials: {\r\n            target: \"VBKD\",\r\n            type: \"one-to-many\",\r\n            cascade: true,\r\n            joinColumn: \"VBELN\",\r\n        },\r\n        positions: {\r\n            target: \"VBAP\",\r\n            type: \"one-to-many\",\r\n            cascade: true,\r\n            joinColumn: \"VBELN\",\r\n        },\r\n        interlocutors: {\r\n            target: \"VBPA\",\r\n            type: \"one-to-many\",\r\n            cascade: true,\r\n            joinColumn: \"VBELN\",\r\n        },\r\n        distributions: {\r\n            target: \"VBEP\",\r\n            type: \"one-to-many\",\r\n            cascade: true,\r\n            joinColumn: \"VBELN\",\r\n        },\r\n    }\r\n}); \r\n\r\n```\r\nThis one is working, relation name is \"empty\" because it's the only way I found to avoid field auto-creation.\r\n```\r\n\r\nvar vbep = new EntitySchema({\r\n    name: 'VBEP',\r\n    tableName: 'VBEP',\r\n    skipSync: true,\r\n    columns: {\r\n        VBELN: {\r\n            type:\"varchar\",\r\n            primary: true,\r\n            generated: false,\r\n        },\r\n    },\r\n    relations: {\r\n        \"\": {\r\n            target: 'VBAK',\r\n            type: 'many-to-one',\r\n            inverseSide: \"distributions\",\r\n            joinColumn: \"VBELN\",\r\n        },\r\n    }\r\n});\r\n```\r\n\r\nThis one give me the headache... look at the Final SQL.\r\n```\r\nvar vbap = new EntitySchema({\r\n    name: 'VBAP',\r\n    tableName: 'VBAP',\r\n    skipSync: false,\r\n    columns: {\r\n        VBELN: {\r\n            type:\"varchar\",\r\n            primary: true,\r\n            generated: false,\r\n        },\r\n    },\r\n    relations: {\r\n        \"\": {\r\n            target: 'VBAK',\r\n            type: 'many-to-one',\r\n            inverseSide: \"positions\",\r\n            joinColumn: \"VBELN\"\r\n        },\r\n        \"\": {\r\n            target: 'MARA',\r\n            type: 'many-to-one',\r\n            inverseSide: \"orders\",\r\n            joinColumn: \"MATNR\",\r\n        }\r\n    }\r\n});\r\n\r\nmodule.exports = vbap;\r\n```\r\n\r\nThis is the SQL launched\r\n```\r\nSELECT *\r\nFROM \"VBAK\" \"VBAK\" \r\nLEFT JOIN \"VBKD\" \"VBAK_comercials\" ON \"VBAK_comercials\".\"VBELN\"=\"VBAK\".\"VBELN\"  \r\nLEFT JOIN \"VBEP\" \"VBAK_distributions\" ON \"VBAK_distributions\".\"VBELN\"=\"VBAK\".\"VBELN\"  \r\nLEFT JOIN \"VBAP\" \"VBAK_positions\" ON \"VBAK_positions\".\"MATNR\"=VBAK.MATNR  \r\nLEFT JOIN \"VBPA\" \"VBAK_interlocutors\" ON \"VBAK_interlocutors\".\"KUNNR\"=VBAK.KUNNR;\r\n```\r\n\r\nAs you can see last two joins are using a bad joincolumn, it should be\r\n```\r\nLEFT JOIN \"VBAP\" \"VBAK_positions\" ON \"VBAK_positions\".\"VBELN\"=VBAK.VBELN  \r\nLEFT JOIN \"VBPA\" \"VBAK_interlocutors\" ON \"VBAK_interlocutors\".\"VBELN\"=VBAK.VBELN;\r\n```\r\n\r\nI think that it's using the second joincolumn instead first one.\r\n\r\nIs there another way to do what I actually need?\r\nThanks.\r\n\r\n**Resume:**\r\nHow can I add an Entity with two relations from the same field and avoiding the creation of new fields on the table?",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/2508/comments",
    "author": "ikito",
    "comments": [
      {
        "user": "seaice",
        "created_at": "2018-10-12T09:49:16Z",
        "body": "joinColumn is object\r\n```\r\nrelations: {\r\n        folder: {\r\n            target: \"Folder\",\r\n            type: \"many-to-one\",\r\n            cascade: true,\r\n            joinColumn: {\r\n                name: \"fid\",\r\n                referencedColumnName: \"id\"\r\n            },\r\n        },\r\n}\r\n```"
      },
      {
        "user": "havenchyk",
        "created_at": "2018-12-10T16:39:26Z",
        "body": "I'm closing this issue for housekeeping purposes, if something is not clear yet, just continue the conversation or post a message in slack"
      }
    ]
  },
  {
    "number": 2487,
    "title": "New record  from object literal ? ",
    "created_at": "2018-07-08T20:23:15Z",
    "closed_at": "2018-07-11T19:39:30Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/2487",
    "body": "[x ] question\r\n\r\nHi. Is it a normal behavior that the save() function in the repository creates a new record in the database based on the object literal instead of the entity instance without the previously used preload() function ? \r\n\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/2487/comments",
    "author": "andrzepakula",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2018-07-11T19:09:47Z",
        "body": "yes it is. You can send partial objects to save method and it will only update what you sent."
      }
    ]
  },
  {
    "number": 2470,
    "title": "Error persisting quoted field names inside entity",
    "created_at": "2018-07-06T09:36:11Z",
    "closed_at": "2021-07-04T22:24:22Z",
    "labels": [
      "bug",
      "question",
      "driver: sqlite"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/2470",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[x] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[x] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nI have an `Building` entity containing a quoted (`\"`) field like:\r\n\r\n```\r\n@JoinColumn({ name: \"constructor_id\" })\r\n@ManyToOne(type => Constructor, { eager: true })\r\npublic \"constructor\"?: Constructor;\r\n```\r\n\r\nI'm quoting the constructor field as `constructor` is a reserved word and and I have the need to call it `constructor` anyway.\r\n\r\nWhen trying:\r\n\r\n```\r\n// constructing building and setting other properties omitted...\r\nbuilding[\"constructor\"] = await constructorRepository.findOne(constructorId);\r\nbuildingRepository.save(building);\r\n```\r\n\r\nIt gives the following error:\r\n\r\n```\r\nquery failed: INSERT INTO \"building\"(\"name\", \"city_id\", \"constructor_id\") VALUES (?, ?, [object Object]) -- PARAMETERS: [\"building 1\",\"amsterdam\",1]\r\nerror: { Error: SQLITE_ERROR: no such column: object Object errno: 1, code: 'SQLITE_ERROR' }\r\n```\r\n\r\nI think the problem is that typeorm tries to save the reference to he constructor as a `[object Object]` as can be seen in the logging.\r\n\r\n\r\nI will make a test case later.",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/2470/comments",
    "author": "marceloverdijk",
    "comments": [
      {
        "user": "imnotjames",
        "created_at": "2021-07-04T15:58:07Z",
        "body": "This should be fixed as of #7821 but I'll double check"
      },
      {
        "user": "imnotjames",
        "created_at": "2021-07-04T22:24:20Z",
        "body": "Actually, I can't replicate this because it's no longer valid Typescript.\r\n\r\nI think the issue primarily had to do with you overloading `constructor` as a field rather than the quotes.  I tried a few other ways to try to replicate this and couldn't."
      }
    ]
  },
  {
    "number": 2439,
    "title": "Add an ability to set postgresql schema per call",
    "created_at": "2018-07-01T21:06:35Z",
    "closed_at": "2018-09-29T08:02:40Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/2439",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[ ] bug report\r\n[x] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[x] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\nIt would be a huge step to support multi-tenant systems with providing `schema` to `getManager` or to `getRepository`.  I've read @pleerock answer in #1577 and instead of it I suppose to open a connection per schema. \r\n\r\nBut I don't get how many connections I have to open. Imagine I have 10k tenants. Does it mean I have to have 10k connections in the pool? How much memory will it consume?\r\n\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/2439/comments",
    "author": "syabro",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2018-07-02T19:09:45Z",
        "body": "You can use schema name in a query builder, e.g. `createQueryBuilder(\"schema.tableName\")`"
      },
      {
        "user": "osman-mohamad",
        "created_at": "2019-12-23T13:07:46Z",
        "body": "@syabro can it be setup per repository ? to query with it ?"
      }
    ]
  },
  {
    "number": 2429,
    "title": "Force DISTINCT?",
    "created_at": "2018-06-29T09:32:55Z",
    "closed_at": "2018-09-29T11:10:46Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/2429",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[x] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\nIs there a way to force DISTINCT? I have a few use cases where I need to perform a SELECT DISTINCT without take or skip. i.e. if (firstField) { sqb.selectDISTINCT(<field>) } else { sqb.addSelect(<field>) }\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/2429/comments",
    "author": "iamgmd",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2018-07-02T19:33:21Z",
        "body": "can you show a complete sql query you need?"
      },
      {
        "user": "zWaR",
        "created_at": "2018-07-04T03:02:28Z",
        "body": "@pleerock \r\nThe objective is to generate a query like this:\r\n```sql\r\nSELECT DISTINCT t1.a\r\nFROM table t1;\r\n```\r\n\r\nThe following will not work, even though `getSql()` will return a correct SQL statement:\r\n\r\n```ts\r\ngetConnection()\r\n  .createQueryBuilder(Table, 't1')\r\n  .select('DISTINCT t1.a')\r\n  .getMany();\r\n```\r\n\r\nSo the question is how to correctly get a SELECT DISTINCT clause?"
      },
      {
        "user": "LogansUA",
        "created_at": "2018-07-04T10:02:37Z",
        "body": "Same question, how can I use DISTINCT in query builder?"
      },
      {
        "user": "pleerock",
        "created_at": "2018-07-04T19:02:13Z",
        "body": "you need to get raw results if you select something other than entity, use `getRawMany` instead of `getMany()`"
      },
      {
        "user": "JorgeBrs",
        "created_at": "2019-10-24T16:44:22Z",
        "body": "@zWaR @iamgmd @pleerock \r\n\r\nbut when I want to pass more than one property in the select it throws me an error.\r\n\r\nwhat I did to solve my mistake while I found a solution proposed by typeOrm was to change the distinct to a groupby\r\n\r\nsomething like this:\r\n\r\ngetConnection()\r\n  .createQueryBuilder(Table, 't1')\r\n  .select('t1.a')\r\n ..groupBy('t1.id')\r\n  .getRawMany();\r\n\r\n"
      },
      {
        "user": "Diegorandom",
        "created_at": "2020-07-27T20:25:03Z",
        "body": "What if I need something like this\r\n`let mbolScan = await getRepository(L)\r\n        .createQueryBuilder(\"l\")\r\n        .select('l.a')\r\n        .addSelect('b')\r\n        .addSelect('loadout.c')\r\n        .groupBy('loadout.al')\r\n        .addGroupBy('loadout.b')\r\n        .getRawMany()`"
      }
    ]
  },
  {
    "number": 2425,
    "title": "Is there any way to just check if query return a result or nothing ?",
    "created_at": "2018-06-28T16:53:34Z",
    "closed_at": "2018-07-02T19:47:12Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/2425",
    "body": "**Issue type:**\r\n\r\n[X] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[X] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n\r\n**TypeORM version:**\r\n\r\n[ ] `latest`\r\n[ ] `@next`\r\n[0.2.7] `0.x.x` (or put your version here)\r\n\r\nHi,\r\nFirst of all I'd like to thank you for your job, this tool is really good and easy to use.\r\n\r\nI would like to know if there is any way to know if my query return a result or not\r\n\r\nBasically something like this.\r\n\r\ncheckIfExist(value: string): Promise<boolean> {\r\n        const myRepository = getConnection().getRepository(Entity).createQueryBuilder('entity')\r\n            .where('entity.value= :value', { value: value});\r\n\r\n        return accidentRepository.Any();\r\n    }\r\n\r\nHope you can help me.\r\n\r\nHave a nice day\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\n<!--\r\n    To answer those questions you need to put \"x\" inside the square brackets, for example:\r\n    [x] `mysql`\r\n    [ ] `postgres`\r\n\r\n    Also, please format your code properly (by taking code blocks into ```ts .... ```)\r\n!>\r\n\r\n\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/2425/comments",
    "author": "ecalafat",
    "comments": [
      {
        "user": "DirkDeVisser",
        "created_at": "2018-06-29T08:36:36Z",
        "body": "If you use `getMany` on the query builder you will get an empty array if there are no results. For example:\r\n\r\n``` ts\r\npublic async checkAtLeastOne(value: string): Promise<boolean> {\r\n    const result = await getConnection()\r\n        .getRepository(Entity)\r\n        .createQueryBuilder('entity')\r\n        .where('entity.value= :value', { value: value})\r\n        .getMany();\r\n    return result.length >= 1;\r\n}\r\n```\r\nIf you want one result and use `getOne` on the query builder then you can check if it is undefined. For example: \r\n\r\n``` ts\r\npublic async checkIfExists(value: string): Promise<boolean> {\r\n    const result = await getConnection()\r\n        .getRepository(Entity)\r\n        .createQueryBuilder('entity')\r\n        .where('entity.value= :value', { value: value})\r\n        .getOne();\r\n    return result !== undefined;\r\n}\r\n```"
      },
      {
        "user": "hielkehoeve",
        "created_at": "2018-06-29T11:13:58Z",
        "body": "```I would like to know if there is any way to know if my query return a result or not```\r\n\r\nYou could use a count query to check how many rows you would fetch. This is the fastest option out of all the API calls.\r\n\r\n```\r\npublic async checkIfExists(value: string): Promise<boolean> {\r\n    return await getConnection()\r\n        .getRepository(Entity)\r\n        .createQueryBuilder('entity')\r\n        .where('entity.value= :value', { value: value})\r\n        .getCount() > 0;\r\n}\r\n```"
      },
      {
        "user": "pleerock",
        "created_at": "2018-07-02T19:47:07Z",
        "body": "I guess this can be closed, thanks everyone for the help!"
      }
    ]
  },
  {
    "number": 2389,
    "title": "Unable to create createdAt/upadtedAt fileds without decorators.",
    "created_at": "2018-06-22T12:27:39Z",
    "closed_at": "2018-09-29T08:01:22Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/2389",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[ ] bug report\r\n[ ] feature request\r\n[x] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[x] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nExcuse me if I'm just blind and didn't found it, but I cannot find anything in docs and examples on how to create autogenerated columns `createdAt`,`updatedAt` without use of decorators, in javascript only. Aka @CreateDateColumn @UpdateDateColumn if used by decorators.\r\n\r\nIs it possible and I'm just missing something, or is it not currently supported?\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/2389/comments",
    "author": "atomicus",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2018-06-22T12:31:58Z",
        "body": "you can do it following way:\r\n\r\n```ts\r\ncolumns: {\r\n     updatedAt: {\r\n           /// other column properties\r\n           updateDate: true\r\n     }\r\n}\r\n```"
      }
    ]
  },
  {
    "number": 2374,
    "title": "Create relation entity question",
    "created_at": "2018-06-21T01:33:17Z",
    "closed_at": "2018-06-25T06:36:29Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/2374",
    "body": "Issue type:\r\n\r\n[x] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\nDatabase system/driver:\r\n\r\n[ ] cordova\r\n[ ] mongodb\r\n[ ] mssql\r\n[x ] mysql / mariadb\r\n[ ] oracle\r\n[ ] postgres\r\n[ ] sqlite\r\n[ ] sqljs\r\n[ ] react-native\r\n\r\nTypeORM version:\r\n\r\n[ ] latest\r\n[ ] @next\r\n[^2.0.0 ] 0.x.x (or put your version here)\r\n\r\nSteps to reproduce or a small repository showing the problem:\r\n\r\nI have two table.\r\nOne is userBasic and other is userextensions\r\nuserBasic is onetomany to userextensions\r\n\r\nbelong is my schema\r\n```javascript\r\n@Entity(\"UserBasic\")\r\nexport class UserBasic {\r\n\r\n    @PrimaryGeneratedColumn()\r\n    id: number;\r\n\r\n     ....\r\n\r\n    @OneToMany(type => UserExtension, userextensions => userextensions.userbasic,\r\n        {\r\n            cascade: true,\r\n            onDelete: \"CASCADE\",\r\n            onUpdate: \"CASCADE\",\r\n        })\r\n    userextensions: UserExtension[];\r\n\r\n}\r\n```\r\n```javascript\r\n@Entity(\"UserExtension\")\r\nexport class UserExtension {\r\n\r\n    @PrimaryGeneratedColumn()\r\n    id:number;\r\n        \r\n    @ManyToOne(type => UserBasic, userbasic=> userbasic.userextensions)\r\n    @JoinColumn({ name:'fk_id'})\r\n    userbasic:UserBasic;\r\n    \r\n    .....\r\n\r\n    @Column(\"tinyint\",{ \r\n        nullable:true,\r\n        default:\"NULL\",\r\n        name:\"K_Delete\"\r\n        })\r\n    K_Delete:number;\r\n```\r\n\r\nI want only create a new userextension \r\n\r\n**my Json**\r\n```javascript\r\n{ id: null,\r\n  Admit_Type:  'aa',\r\n  Unit:  'aa',\r\n  Title: 'aa',\r\n  Date_Start: '2018-06-05',\r\n  Date_Leave: '2018-06-05',\r\n  Lead_Class:  'aa',\r\n  Office_Tel:  'aa',\r\n  Office_Ext:  'aa',\r\n  Update_Date: '2018-06-21T09:20:42+08:00',\r\n  Update_User: 'test',\r\n  fk_id: '1' }\r\n```\r\nhow can i save userextension  ?\r\n\r\nwhen I save\r\n```javascript\r\nthis.userExtensionRepository.save(userExtension);\r\n```\r\n\r\nI got this error\r\n```javascript\r\nerror:\"ER_NO_DEFAULT_FOR_FIELD: Field 'fk_id' doesn't have a default value\"\r\n```\r\nwhen I create\r\n```javascript\r\nrtnVal = this.userExtensionRepository.create(userExtension);\r\n```\r\n\r\nnothing saved in database\r\n\r\nbut I can update and deletet...\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/2374/comments",
    "author": "lalalalaluk",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2018-06-22T12:28:47Z",
        "body": "you create a user object, fill values, then you create user extension object and set this object to user and save it. Please follow typeorm homepage tutorials to understand more how typeorm relations work, this is very basic question."
      },
      {
        "user": "lalalalaluk",
        "created_at": "2018-06-25T01:30:28Z",
        "body": "Really thank you!"
      }
    ]
  },
  {
    "number": 2373,
    "title": "Primary Key column not included in returned object if primary key is is a foreign key of one-to-one relationship",
    "created_at": "2018-06-20T19:44:43Z",
    "closed_at": "2021-07-09T05:39:26Z",
    "labels": [
      "question",
      "driver: cordova"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/2373",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[x] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nI have a table (ProjectSettings) whose primary key is also the foreign key of a one-to-one relation. My entities look like this:\r\n```\r\n@Entity()\r\nexport class Project {\r\n    @PrimaryGeneratedColumn()\r\n    id: number;\r\n    @OneToOne(number => ProjectSettings, projectSettings => projectSettings.project, { onDelete: 'CASCADE', cascade: true })\r\n    settings: ProjectSettings;\r\n}\r\n```\r\nand\r\n```\r\n@Entity()\r\nexport class ProjectSettings {\r\n    @JoinColumn()\r\n    @OneToOne(type => Project, { primary: true })\r\n    project: Project;\r\n}\r\n```\r\n\r\nHowever, if I use the repository to find the ProjectSettings by the Project, the returned class does not contain the projectId:\r\n```\r\nlet repository = getConnection().getRepository(ProjectSettings);\r\nrepository.findOne({ project: project }).then(projectSettings => { ...})\r\n```\r\nThus, when trying to persist the ProjectSettings again, a new entry is created, as the projectId is unknown.\r\nActually I've tried many combinations of various annotation properties, however I am not able to get it working.\r\n\r\nCould someone advise what I am doing wrong here?",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/2373/comments",
    "author": "dominic-simplan",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2018-06-22T13:28:25Z",
        "body": "> the returned class does not contain the projectId:\r\n\r\nbecause your class does not contain projectId property.\r\n\r\nTo avoid this kind of issues we are deprecating this format of definition of primary foreign keys in favour of following format:\r\n\r\n```ts\r\n@Entity()\r\nexport class ProjectSettings {\r\n\r\n    @PrimaryColumn()\r\n    projectId: number;\r\n\r\n    @OneToOne(type => Project)\r\n    @JoinColumn()\r\n    project: Project;\r\n}\r\n```\r\n\r\nplease use it and probably you'll get rid of \"strange\" issues."
      },
      {
        "user": "dominic-simplan",
        "created_at": "2018-06-26T06:56:58Z",
        "body": "@pleerock thanks for the explanation! Saving and loading is working fine now, however I am getting an error when trying to delete the Project entity. (I want that the ProjectSettings are cascaded on insert, update and delete of the Project entity.)\r\n\r\n```\r\n@Entity('Project')\r\nexport class Project {\r\n    @OneToOne(type => ProjectSettings, projectSettings => projectSettings.project, { cascade: true }) \r\n    settings: ProjectSettings;\r\n}\r\n```\r\n\r\n```\r\n@Entity('ProjectSettings')\r\nexport class ProjectSettings {\r\n    @PrimaryColumn()\r\n    projectId: number;\r\n    @JoinColumn({ name: \"projectId\" })\r\n    @OneToOne(type => Project, project => project.settings, { onDelete: 'CASCADE' })\r\n    project: Project;\r\n}\r\n```\r\n\r\nTrying to delete the project:\r\n```\r\ngetConnection().getRepository(Project).remove(project);\r\n```\r\ncreates an INSERT statement for the ProjectSettings, which fails because the ProjectSettings already exist:\r\n```\r\nquery failed:  INSERT INTO \"ProjectSettings\"(\"projectId\", \"otherColumn\", ) VALUES (?, ?) -- PARAMETERS: [17,\"2018-06-25T00:00:00Z\"]\r\n```\r\n\r\nI wonder why this INSERT statement is created? \r\nIf I change the @OneToOne and set the cascade to update only, deletion is working, however the cascade insert is not working anymore (obviously):\r\n```\r\n@OneToOne(type => ProjectSettings, projectSettings => projectSettings.project, { cascade: [\"update\"] }) \r\n```"
      },
      {
        "user": "pleerock",
        "created_at": "2018-06-26T19:56:02Z",
        "body": "that is strange, deletion can't cause cascade insert anyhow, this is something I need to investigate.\r\n\r\nCan you contribute and create a failing test for this issue?"
      },
      {
        "user": "dominic-simplan",
        "created_at": "2018-06-27T08:19:25Z",
        "body": "Hi,\r\nI've created a PR with an according test case: #2416.\r\nIf you need any other information please let me know!"
      },
      {
        "user": "imnotjames",
        "created_at": "2021-07-09T04:59:16Z",
        "body": "I've fixed the tests in your test PR.  You forgot to `await` the `remove` call.\r\n\r\nThey pass locally and I'll be confirming they pass in the CI as well."
      },
      {
        "user": "imnotjames",
        "created_at": "2021-07-09T05:39:26Z",
        "body": "The tests passed in CI.  I think they overlap a few other tests we have so I won't be merging them in.\r\n\r\nThey also show that this is not an actual issue.  I think you need to `await`."
      }
    ]
  },
  {
    "number": 2360,
    "title": "cordova and migrations",
    "created_at": "2018-06-19T13:22:57Z",
    "closed_at": "2018-10-06T06:16:54Z",
    "labels": [
      "question",
      "comp: migrations",
      "comp: ionic"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/2360",
    "body": "**Issue type:**\r\n[X] bug\r\n[X] question\r\n\r\n**Database system/driver:**\r\n[X] `cordova` (ionic)\r\n\r\n**TypeORM version:**\r\n[x] `latest`\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nI'm still playing around with typeorm (awesome lib, thanks!) as I may want to use it in my next ionic/cordova project. My test project works nicely, I have some entities now with some relations, all is fine. But I'm currently having a problem to understand how to keep the user databases on their devices in sync with my entities. \r\n\r\nAs far as I understand the typeorm cli and its migration generation or schema sync features does not help me much in this case, as it doesn't have any access to any database (which would only be available on a mobile device). Currently it throws a misleading error message when trying to use it with a cordova database in ormconfig.json, f.i.:\r\n\r\n````\r\n{ DriverPackageNotInstalledError: Cordova-SQLite package has not been found installed. Try to install it: npm install cordova-sqlite-storage --save\r\n    at new DriverPackageNotInstalledError (/usr/local/lib/node_modules/typeorm/error/DriverPackageNotInstalledError.js:19:28)\r\n    at CordovaDriver.loadDependencies (/usr/local/lib/node_modules/typeorm/driver/cordova/CordovaDriver.js:133:19)\r\n```` \r\n\r\n(cordova-sqlite-storage is installed, but the driver just tries to access window.sqlitePlugin which node doesn't know about and just throws \"window is not defined\")\r\n\r\nNext, I wanted to define the migrations in the connection options I use in my own code like this:\r\n\r\n```` \r\nthis.connection = await createConnection({\r\n\ttype: 'cordova',\r\n\tdatabase: 'database',\r\n\tlocation: 'default',\r\n\tlogging: ['error', 'query', 'schema'],\r\n\tsynchronize: false,\r\n\tmigrations: [\"migrations/*\"],\r\n\tentities\r\n});\r\n```` \r\nThe project is an ionic project and is using the custom webpack.config.js from the example project. But I get this error as soon as I open the connection:\r\n\r\n```` \r\nError: This option/function is not supported in the browser environment. Failed operation: require(\"glob\").\r\nload — PlatformTools.js:23\r\n(anonyme Funktion) — DirectoryExportedClassesLoader.js:21\r\nreduce\r\nimportClassesFromDirectories — DirectoryExportedClassesLoader.js:20\r\nbuildMigrations — ConnectionMetadataBuilder.js:26\r\nbuildMetadatas — Connection.js:510\r\n```` \r\n\r\nAs soon as I remove the \"migrations\" property and set \"synchronize\" to \"true\" its working again.\r\n\r\nSo how is migrations supposed to work with cordova? Can I check if the current database conforms to the current schema that would be created with the current entities?\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/2360/comments",
    "author": "marcorinck",
    "comments": [
      {
        "user": "daniel-lang",
        "created_at": "2018-07-07T19:45:40Z",
        "body": "Sorry for the late response.\r\n\r\nMigrations are supported in cordova but with some limitations.\r\nAs mentioned in your issue, CLI won't be of only help when creating migrations as it doesn't know anything of the cordova plugin. You can still create empty migrations just to get the current file naming.\r\n\r\nWhen loading migrations you will have to import and specify each and every migration in your migrations file like:\r\n\r\n```ts\r\nimport { FirstMigration1517339641128 } from 'migrations/1517339641128-First-Migration';\r\nimport { SecondMigration1517340398662 } from 'migrations/1517340398662-Second-Migration';\r\n\r\n...\r\n\r\ncreateConnection({\r\n   ...\r\n   migrations: [FirstMigration1517339641128, SecondMigration1517340398662]\r\n});\r\n```"
      },
      {
        "user": "dominicdesu",
        "created_at": "2018-09-23T19:29:55Z",
        "body": "@marcorinck I am using the migrations in cordova just as @daniel-lang described. Do you still have issues with this?"
      },
      {
        "user": "daniel-lang",
        "created_at": "2018-10-06T06:16:54Z",
        "body": "Since @marcorinck didn't respond in three months I'm going to close this issue."
      },
      {
        "user": "tindn",
        "created_at": "2019-04-10T18:59:21Z",
        "body": "@daniel-lang I'm seeing the same issue with RN, and adding migration manually works. Do you have any insights into why that's the case?"
      }
    ]
  },
  {
    "number": 2345,
    "title": "breaking changes to NamingStrategy",
    "created_at": "2018-06-15T20:07:51Z",
    "closed_at": "2020-10-07T02:23:39Z",
    "labels": [
      "question",
      "documentation",
      "comp: naming strategy",
      "driver: postgres",
      "driver: mssql"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/2345",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[ ] bug report\r\n[ ] feature request\r\n[x] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[x] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[x] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n\r\n**TypeORM version:**\r\n\r\n[ ] `latest`\r\n[ ] `@next`\r\n[ ] `0.2.0` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nwe have a custom naming strategy for a project, and we are updating from 0.1.x to 0.2.x\r\n\r\ncurrently we have:\r\n\r\n```\r\n  public foreignKeyName(\r\n    tableName: string,\r\n    columnNames: string[],\r\n     referencedTableName: string,\r\n     referencedColumnNames: string[],\r\n  ): string {\r\n    return [tableName]\r\n      .concat(columnNames)\r\n       .concat([`_${referencedTableName}`])\r\n       .concat(referencedColumnNames)\r\n      .join('_');\r\n  }\r\n\r\n// result: \r\n// local_table_local_column__remote_table_target_column\r\n\r\n```\r\n\r\n\r\nbut the last two params are removed. Can we assume param 1 and 2 are now the \"referenced\" table? \r\nis there control over the linking character between original and fk, or is `_` assumed?\r\n\r\nwe also had indexName with 3 Params, but param 1 is now removed in 0.2.0:\r\n\r\n```\r\n  public indexName(\r\n    customName: string | undefined,\r\n    tableName: string,\r\n    columns: string[],\r\n  ): string {\r\n    return (\r\n      customName ||\r\n      [tableName]\r\n        .concat(columns)\r\n        .concat(['fkey'])\r\n        .join('_')\r\n    );\r\n  }\r\n```\r\ni think this was due to bug with generated join tables... maybe `custom || tableName...` not needed anymore? \r\nclarification much appreciated!\r\n\r\n\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/2345/comments",
    "author": "vance",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2018-06-19T12:02:45Z",
        "body": "Those changes were made by @AlexMesser . As he told me, first change was made because those parameters were not used anymore - he removed them. Second change was made because check for \"customName\" was extract out of the naming strategy.\r\n\r\nNaming strategy is something we have in future plans to completely revisit and refactor thats why it still lefts undocumented functionality. Feel free to contribute and add missing options if you need them."
      },
      {
        "user": "vance",
        "created_at": "2018-06-25T23:18:42Z",
        "body": "Hm. It seems that removing the parameters from the interfaces of these method blocks upgrade from 1.x. \r\n\r\nFor instance we overrode many of these methods to use non-sha, human readable names. Without the missing parameters, we are unable to define names in the same way that our current database uses. \r\n\r\nWe also used the pattern for unique constraints etc, which also do not provide enough options. I could submit a PR that adds them back, but it seems if it is due to refactor, that those changes may be lost. \r\n\r\n**what was the intent in refactoring the naming strategy?** \r\n\r\nKnowing that may be helpful if I undertake that. I'm a little nervous as each method has dozens of references throughout the app.\r\n"
      },
      {
        "user": "vance",
        "created_at": "2018-06-26T16:52:39Z",
        "body": "May be able to contribute. Gathering minimum requirements to allow for Postgres community standards for naming. I think it would be similar to adding back the parameters used in the 0.1.x implementations, but keeping the new defaults provided in 0.2.x"
      },
      {
        "user": "pleerock",
        "created_at": "2018-06-26T18:22:47Z",
        "body": "I remember only few people who told they are using naming strategy stuff. Its not documented feature, you know. And as I told its not documented because its not complete yet. If you want to contribute on some options we can add them but in the future we may change them once we finish naming strategy refactoring. \r\n\r\nWhat I can also suggest is to take owning on this feature, implement everything user might need, document everything and make this functionality stable, finally.\r\n\r\nSo, feel free to contribute!"
      }
    ]
  },
  {
    "number": 2344,
    "title": "Data loss warning when field is removed from Entity and the column already contained data",
    "created_at": "2018-06-15T15:09:49Z",
    "closed_at": "2018-06-19T10:21:08Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/2344",
    "body": "**Issue type:**\r\n\r\n[ ] question\r\n[ ] bug report\r\n[X ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[X] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n\r\n**TypeORM version:**\r\n\r\n[ ] `latest`\r\n[ ] `@next`\r\n[X] `0.2.7` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nI am not sure if this is by design or a bug:\r\nCreate an entity with two fields, doesn't matter which fields. Keep `synchronize` set to `true`. Now run the program, it will create two columns in the table. Insert some data in the table.\r\n\r\nNext remove 1 field from the entity, and run again. The field is gone, together with the data in the column without any warning.\r\n\r\nEntity has data loss protection for this. Now one mistake in the entity fields could lead to dataloss without warning.",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/2344/comments",
    "author": "basvdijk",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2018-06-19T10:21:02Z",
        "body": "it is by design and it is called a schema synchronization which you explicitly enable. Working with schema is always a responsible work, so you should know what you are doing by explicitly enabling synchronization. In the case if you wan't to control something you can enable logging and always check what queries are executing for your actions in the entity."
      },
      {
        "user": "basvdijk",
        "created_at": "2018-06-19T10:30:16Z",
        "body": "@pleerock I still think a safeguard to prevent \"mistakes\" by having an explicit confirmation when data will go loss and not remove data by default without a prompt. Especially with these delicate operations.   \r\n\r\nWhen you delete a file on your computer, you are prompted as well. The `rm` command a has a force parameter to skip the prompt and not a parameter to invoke a prompt. But neither of these remove without prompt by default. The Entity Framework doesn't remove data unless it is forced to.\r\n\r\nI would ask you with the arguments above in mind to reconsider the design. Thanks :)"
      },
      {
        "user": "pleerock",
        "created_at": "2018-06-19T11:57:43Z",
        "body": "Thanks for the suggestion, but the answer would be no.\r\n\r\nIf we talk about synchronize option in config, then its not possible to \"prompt\" something. If we talk about CLI then there are two commands - `schema:log` to see what queries and gonna execute and `schema:sync` to do that."
      },
      {
        "user": "basvdijk",
        "created_at": "2018-06-19T12:02:20Z",
        "body": "Ah I see, I was just about to propose to implement a 'dry run' option, didn't know about`schema:log` :)\r\n\r\nDoes `schema:log` show a warning about data loss?\r\n\r\nHow do you invoke this command? I've tried `nest schema:log` but it gave me an empty output."
      },
      {
        "user": "pleerock",
        "created_at": "2018-06-19T12:04:42Z",
        "body": "it won't show you warning about \"data loss\", it shows you queries it gonna execute. If you want DROP COLUMN it means you will have data loss in the case if you have data in those columns.\r\n\r\nI don't know about nest, try using typeorm cli directly."
      },
      {
        "user": "basvdijk",
        "created_at": "2018-06-19T12:06:56Z",
        "body": "Ok, thanks so far for your help!"
      },
      {
        "user": "GarryOne",
        "created_at": "2020-08-11T17:32:00Z",
        "body": "@basvdijk I also faced this problem, even when I was using Doctrine's `schema:update --force`. \r\nI think this issue can be handled at CI/CD pipeline with a command like this. Didn't tested it, just wanted to show the idea.\r\n```\r\nnpm run typeorm schema:log | grep \"DROP \" && echo \"Found data loss. Exiting\" && exit\r\n```\r\n"
      }
    ]
  },
  {
    "number": 2325,
    "title": "Partial select a related entity via queryBuilder",
    "created_at": "2018-06-12T05:21:32Z",
    "closed_at": "2018-06-12T05:40:40Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/2325",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[x] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nI read through the query builder docs and couldn't quite figure out if the case below is supported:\r\n\r\n* User Entity\r\n-- has an id, age and profilePhotoId\r\n-- profilePhotoId is a one-to-one on ProfilePhoto entity (each user has unique profile photo)\r\n\r\n* ProfilePhoto Entity\r\n-- has an id and userId\r\n-- userId is a one-to-one on User entity (each profilePhoto has a unique user)\r\n\r\nI can build a query to select all users over the age of 18 and load the profile photo relation. That returns an array of UserEntity[] with a profilePhoto entity in each user entity.\r\n\r\nHowever, I'd like to select on users but have the response be *only* the array of ProfilePhoto[] entities associated with the users found in the search. Something like:\r\n\r\n```javascript\r\nconst profilePhotos: ProfilePhoto[] = await createQueryBuilder(\"user\")\r\n    .select(user.profilePhoto) // just deserialize the ProfilePhoto in the user\r\n    .where(\"user.age > 18\") // filtered set of users\r\n    .leftJoinAndSelect(ProfilePhoto, \"profilePhoto\", \"profilePhoto.userId = user.id\") // Get all the ProfilePhoto info\r\n    .getMany(); // looking for an array of ProfilePhoto[]\r\n```\r\n\r\nIs it possible to have the queryBuilder return an entity other than the table it's selecting on by \"filtering\" the proper relation?",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/2325/comments",
    "author": "kodayashi",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2018-06-12T05:25:45Z",
        "body": "If there is a relation you simply need to do \r\n\r\n```ts\r\nawait createQueryBuilder(\"user\")\r\n    .leftJoinAndSelect(\"user.profilePhoto\", \"profilePhoto\")\r\n    .getMany();\r\n```"
      },
      {
        "user": "kodayashi",
        "created_at": "2018-06-12T05:32:09Z",
        "body": "Thanks @pleerock, can I use the repository pattern as well? Something like:\r\n\r\n```javascript\r\nconst profilePhotos: ProfilePhoto[] = await this.userRepository.find({\r\n  select: [\"user.profilePhoto\"],\r\n  relations: [\"profilePhoto\"],\r\n});"
      },
      {
        "user": "pleerock",
        "created_at": "2018-06-12T05:36:27Z",
        "body": "yes but you don't need to do ` select: [\"user.profilePhoto\"]` there"
      },
      {
        "user": "kodayashi",
        "created_at": "2018-06-12T05:39:32Z",
        "body": "Oh ok, without the select, I figured I would get an array of User[] back, witch each user having the hydrated ProfilePhoto. I will try that out thanks!"
      },
      {
        "user": "kodayashi",
        "created_at": "2018-06-13T22:25:29Z",
        "body": "Hi @pleerock -- With just the `relations` option, I get the full User entity and the associated ProfilePhoto entity is just hydrated instead of just the profilePhotoId.\r\n\r\nI'm trying to get *only* the columns from the matching ProfilePhotos. If I try to select just the relation with `select: ['profilePhoto']` I just get an empty response. The query that's generated work though."
      },
      {
        "user": "pleerock",
        "created_at": "2018-06-14T04:16:54Z",
        "body": "> With just the relations option, I get the full User entity and the associated ProfilePhoto entity is just hydrated\r\n\r\ncorrect behaviour. \r\n\r\n>  instead of just the profilePhotoId.\r\n\r\nif you want to get `profilePhotoId` from `user` you don't need to select a relation, simply add `@Column({ nullable: true }) profilePhotoId` into user entity and it will be always selected you don't need to specify any other options."
      }
    ]
  },
  {
    "number": 2315,
    "title": "Lazy loading with eager loading in combination doesn't work",
    "created_at": "2018-06-10T18:26:23Z",
    "closed_at": "2018-06-19T10:23:41Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/2315",
    "body": "**Issue type:**\r\n\r\n[ ] question\r\n[x] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[x] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n\r\n**TypeORM version:**\r\n\r\n[ ] `latest`\r\n[ ] `@next`\r\n[x] `0.2.5` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nGiving the below entities;\r\n```ts\r\nclass User extends BaseEntity{\r\n    @OneToMany(type => Reservation, reservation => reservation.client)\r\n    reservations: Promise<Reservation[]>;\r\n}\r\n\r\nclass Reservation extends BaseEntity{\r\n    @ManyToOne(type => Hotel, hotel => hotel.reservations, {eager: true})\r\n    hotel: Hotel;\r\n\r\n    @ManyToOne(type => User, user => user.reservations, {eager: true})\r\n    user: User;\r\n}\r\n\r\nclass Hotel extends BaseEntity{\r\n    @OneToMany(type => Reservation, reservation => reservation.hotel)\r\n    reservations: Promise<Reservation[]>;\r\n}\r\n```\r\n\r\nDoing `User.find(1).reservations`  returns a list of reservations but without any eagerly loaded relations(for Hotel and User). \r\n\r\nI know there is some redundancy because the `User` under the `Reservation` is the same, but what I really want are the hotels (and if I request using some hotel, like `hotel.reservations` what I really I want are the users. But it's ok if there is some redundancy)\r\n\r\nDoing `Reservation.find(1)` returns the expected result.\r\n\r\n1. Is this intended behavior?\r\n2. How can I get the expected result without manually getting every reservation and then load their relationships? Like:\r\n```ts\r\nlet user = User.find(1).\r\nlet reservations = users.reservations;\r\nreservations.forEach((reservation)=>{\r\n    reservation.user...// load the relations somehow using query builder???.  this is really messy\r\n    ....\r\n})\r\n```\r\nThe `Reservation.find(1)` works just fine and `User.find(1).reservations`  should also.",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/2315/comments",
    "author": "IonelLupu",
    "comments": [
      {
        "user": "IonelLupu",
        "created_at": "2018-06-18T21:12:52Z",
        "body": "Anyone?"
      },
      {
        "user": "MarkMatute",
        "created_at": "2018-06-19T07:09:34Z",
        "body": "await user.reservations ?"
      },
      {
        "user": "MarkMatute",
        "created_at": "2018-06-19T07:14:32Z",
        "body": "@JCWolf let me know if this worked. "
      },
      {
        "user": "pleerock",
        "created_at": "2018-06-19T07:53:00Z",
        "body": "You can't mix eager and lazy relations. Use one of them on both sides."
      },
      {
        "user": "IonelLupu",
        "created_at": "2018-06-19T10:19:20Z",
        "body": "@pleerock, why I can't mix them? I wanted to use just one but my current configuration doesn't allow me that. :("
      },
      {
        "user": "pleerock",
        "created_at": "2018-06-19T10:23:41Z",
        "body": "bad idea. Just like using lazy relations. Use query builder and get any data you want."
      },
      {
        "user": "IonelLupu",
        "created_at": "2018-06-19T11:03:33Z",
        "body": "I am trying to get rid of the query builder as much as possible and use Active Record for simple queries like this. Why? I want the code to be simpler, more readable and easier to understand. The query builder looks redundant for these types of queries. Yes, it is OK for complex queries but for this I find it not needed.\r\n\r\nFor example this query:\r\n\r\n```ts\r\nconst userId = await getRepository(User)\r\n    .createQueryBuilder(\"user\")\r\n    .select(\"user.id\")\r\n    .where(\"user.id = :id\", { id: 1 })\r\n    .getRawOne();\r\n// here, the word user is written 4 times\r\n```\r\n\r\nIt would be nice to just write:\r\n```ts\r\nconst photosSums = User.where('id',1).getRawOne('id')\r\n// the `.where` will create a query parameter automatically\r\n```\r\n\r\nor\r\n```ts\r\nconst users = await getRepository(User)\r\n    .createQueryBuilder(\"user\")\r\n    .leftJoinAndSelect(\"user.photos\", \"photo\")\r\n    .where(\"user.group = :id\", { id: 1 })\r\n    .where(\"photo.album = :album\", { album: 3 })\r\n    .getMany();\r\n```\r\nCan be written like this maybe?:\r\n```ts\r\nconst users = User\r\n    .where('group',1) // get users that have the column group = 1\r\n    .with({\r\n        'photos': photo => photo.where('album',3) // eager loaded. `photo` is a query builder. here we have the full power of a query builder\r\n    })\r\n    .getMany()\r\n// the `.with` for example will get the relationships. the `photo` argument is a query builder maybe?\r\n```\r\n\r\nI am just borrowing syntax from Laravel's Eloquent ORM. It just an idea to make it work easier with Active Record as I said in #2285. \r\n\r\n"
      },
      {
        "user": "pleerock",
        "created_at": "2018-06-19T12:00:50Z",
        "body": "Using lazy relations for this purpose is a bad idea. Really, really better to contribute into ORM and add needed features 😆 "
      },
      {
        "user": "jckw",
        "created_at": "2019-06-15T12:05:17Z",
        "body": "Why is this a \"really bad idea\"? "
      },
      {
        "user": "jronnybravo",
        "created_at": "2019-07-19T03:34:27Z",
        "body": "@pleerock I am not sure why it's a bad idea, can you explain further?\r\n\r\nAs for it being a good idea, it's very useful when one needs to get related items especially when they are circular. Laravel's Eloquent can do both lazy loading (by default) and use the function `with` for eager loading... Can we reconsider this approach? Thanks."
      },
      {
        "user": "npeham",
        "created_at": "2019-08-26T09:15:58Z",
        "body": "Why is this closed? Why are lazy-loaded relations bad / an anti-pattern?"
      },
      {
        "user": "johannesschobel",
        "created_at": "2019-10-31T06:49:12Z",
        "body": "i also stumbled upon this thread - can you give more details about this issue please?\r\n@IonelLupu : how did you manage to solve / work around your issue?\r\n\r\nAll the best and thanks a lot for your help"
      },
      {
        "user": "IonelLupu",
        "created_at": "2019-10-31T13:07:07Z",
        "body": "@johannespfeiffer I didn't solve it. Sorry :("
      },
      {
        "user": "venarius",
        "created_at": "2020-02-25T23:10:13Z",
        "body": "Any news on this? "
      },
      {
        "user": "xenoterracide",
        "created_at": "2020-02-27T19:27:24Z",
        "body": "hmm... I suspect this may be my issue... lame"
      },
      {
        "user": "fixpunkt",
        "created_at": "2020-07-24T09:46:01Z",
        "body": "It would be really nice to have an explanation of why this isn't supported (and why it seems to be considered a bad idea) here. Also, the docs should probably mention that this doesn't work.\r\n\r\nIn particular, since the error message you get when you try to make both sides of a relation `eager` actually suggests mixing eager and lazy:\r\n\r\n> `Error: Circular eager relations are disallowed. A#bs contains \"eager: true\", and its inverse side B#a contains \"eager: true\" as well. Remove \"eager: true\" from one side of the relation.`\r\n\r\n"
      }
    ]
  },
  {
    "number": 2309,
    "title": "TypeORM Angular 6 sample/seed application or a how-to setup",
    "created_at": "2018-06-08T14:36:01Z",
    "closed_at": "2018-06-11T05:37:03Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/2309",
    "body": "**Issue type:**\r\n\r\n[ ] question\r\n[ ] bug report\r\n[x] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[x] `sqlite`\r\n[x] `sqljs`\r\n[ ] `react-native`\r\n[x] `webSql`\r\n\r\n**TypeORM version:**\r\n\r\n[x ] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nIs it possible to provide an Angular 6 sample/seed application or a how-to to get such application setup?\r\nIt seems Angular CLI 6 is different than before (you cannot eject webpack anymore?!) so it would be great to use that (newest) version.",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/2309/comments",
    "author": "codessentials",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2018-06-11T05:37:02Z",
        "body": "I have already provided you information via email. Typeorm is not frontend-specific and does not care what framework you use. If you use typeorm in the browser but still need webpack config to change then ask solution from angular team how to use custom webpack config (I think there are hacky ways?)"
      },
      {
        "user": "aammfe",
        "created_at": "2018-10-01T21:33:09Z",
        "body": "> I have already provided you information via email. Typeorm is not frontend-specific and does not care what framework you use. If you use typeorm in the browser but still need webpack config to change then ask solution from angular team how to use custom webpack config (I think there are hacky ways?)\r\n\r\nPlease tell us what information you have provided in email. bcs I m having same issue. \r\n\r\n\r\nwe want to create applications on electron using local db and typeorm seems to be the best . It would be great to create an example dedicated to angular.\r\n\r\nThanx "
      },
      {
        "user": "ZiadJ",
        "created_at": "2019-01-11T15:34:56Z",
        "body": "Angular is one of the most popular Typescript based frontend frameworks out there yet TypeORM doesn't care to provide an integration sample for it? @pleerock I'm not sure I can get that. \r\nTo be clear, I'm only trying to reuse the backend models on the frontend."
      },
      {
        "user": "pleerock",
        "created_at": "2019-01-13T15:30:41Z",
        "body": "@ZiadJ right, angular is popular, and following your logic we shall also create samples for react/vue/preact and something else? And even if we do so, the most important is that even we create such sample, shall we create it with shared models or not? Because its architecture-level decision and some prefer having models shared and some not. Which one we should choose? And if we choose to share models, its going to mean for people that we recommend to do same when using angular+typeorm. However I can't recommend this approach to anyone."
      },
      {
        "user": "ZiadJ",
        "created_at": "2019-01-15T06:45:39Z",
        "body": "@pleerock Those alternative frameworks are not based on Typescript so they're not really within scope here I guess, at least not if resources are lacking to consider them all."
      },
      {
        "user": "darkguy2008",
        "created_at": "2019-01-28T08:24:18Z",
        "body": "@pleerock heck, even a simple Angular CLI + TypeORM starter would suffice. If the user wants shared or non-shared models, up to them, but at least give us the chance to integrate both tools. I just did a quick google search and it was **really discouraging** to find out that it's not possible, or there's a big lack of documentation or willing to integrate with one of the most popular frameworks out there. It was going to be my choice, yet the search continues..."
      },
      {
        "user": "ZiadJ",
        "created_at": "2019-02-04T23:29:57Z",
        "body": "@darkguy2008 Loopback 4 might be the best way out of this mess. I haven't had time to give it a try myself to be honest but TypeORM definitely doesn't care about it being used with other frameworks and even if you manage to make it work with Angular now there's no guarantee it won't break later like it happened to me a year ago."
      }
    ]
  },
  {
    "number": 2301,
    "title": "How to add a comment to the reference fields",
    "created_at": "2018-06-07T08:07:21Z",
    "closed_at": "2018-06-08T10:50:42Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/2301",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[x] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\n\r\nIn an ordinary column, this is done like this:\r\n    @Column({\r\n        nullable: true,\r\n        comment: 'MyComment' // <---\r\n    })\r\n    my_field: string;\r\n\r\n\r\nHow do I add a comment to reference types?\r\n    @ManyToOne(type => Appeal, appeal => appeal.callphoneIdappeals, {\r\n        nullable: true\r\n    })\r\n    @JoinColumn({ name: 'idappeal' })\r\n    appeal: Appeal;\r\n\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/2301/comments",
    "author": "nikolay-rogovoy",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2018-06-07T12:00:28Z",
        "body": "You can create a column with the same name and attach comment to it:\r\n\r\n```ts\r\n@column({\r\nnullable: true,\r\ncomment: 'MyComment' // <---\r\n})\r\nmy_field: string;\r\n\r\n@Column({ nullable: true, comment: 'your comment' })\r\nidappeal: number;\r\n\r\n@manytoone(type => Appeal, appeal => appeal.callphoneIdappeals, {\r\nnullable: true\r\n})\r\n@joincolumn({ name: 'idappeal' })\r\nappeal: Appeal;\r\n```\r\n\r\np.s. please format your code properly."
      },
      {
        "user": "nikolay-rogovoy",
        "created_at": "2018-06-08T10:50:42Z",
        "body": "Thank you so much!"
      },
      {
        "user": "Hilson-Alex",
        "created_at": "2021-10-12T17:47:08Z",
        "body": "> \r\n> \r\n> You can create a column with the same name and attach comment to it:\r\n> \r\n> ```ts\r\n> @column({\r\n> nullable: true,\r\n> comment: 'MyComment' // <---\r\n> })\r\n> my_field: string;\r\n> \r\n> @Column({ nullable: true, comment: 'your comment' })\r\n> idappeal: number;\r\n> \r\n> @manytoone(type => Appeal, appeal => appeal.callphoneIdappeals, {\r\n> nullable: true\r\n> })\r\n> @joincolumn({ name: 'idappeal' })\r\n> appeal: Appeal;\r\n> ```\r\n> \r\n> p.s. please format your code properly.\r\n\r\nSo.. I using TypeORM to synchronize a group project database, and we used this solution to comment a foreign key column. \r\nIt works for who already had the db, but it causes error (duplicated column) when creating the table for those who run it for the first time.\r\n\r\nWould be cool a way to comment our relations that doesn't break the synchronize scripts when creating a table."
      },
      {
        "user": "greenkarmic",
        "created_at": "2023-10-08T23:09:14Z",
        "body": "Is there really still no other way to add a comment to a reference field then duplicating the column this way?"
      }
    ]
  },
  {
    "number": 2299,
    "title": "Postgresql time - how to save just hours",
    "created_at": "2018-06-07T06:49:55Z",
    "closed_at": "2018-09-29T07:50:17Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/2299",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[x] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n\r\n**TypeORM version:**\r\n\r\n[ ] `latest`\r\n[ ] `@next`\r\n[x ] `0.1.9`\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nI have below entity\r\n```ts  \r\n@Entity()\r\nexport class Availability {\r\n\r\n    @PrimaryGeneratedColumn() id: number;\r\n\r\n    @Column({ name: 'available_from', type: 'time without time zone', length: 9}) availableFrom: string;\r\n}\r\n```\r\n\r\nWhen i save an entity which has \"18:30:00\" as value of \"availableFrom\" then in result that entity looks in database this way: \"1970-01-01 18:30:00\". The question is how to force TypeORM to save just hour? In that case \"18:30:00\" should be saved. Thx!",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/2299/comments",
    "author": "rafal-rudnicki",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2018-06-07T07:05:54Z",
        "body": "I think you need to use different database type which only stores hours."
      }
    ]
  },
  {
    "number": 2297,
    "title": "find data with filtered relations  ",
    "created_at": "2018-06-07T03:15:37Z",
    "closed_at": "2018-06-20T15:55:22Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/2297",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[x ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n\r\n**TypeORM version:**\r\n\r\n[ ] `latest`\r\n[ ] `@next`\r\n[^2.0.0 ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nI want to filter with userextensions.K_Delete equal to NULL\r\nI have two table.\r\nOne is userBasic and other is userextensions\r\nBoth have K_Delete field\r\n\r\n```\r\n        try {\r\n            rtnVal = await this.userBasicRepository.find({\r\n                relations: ['userextensions'],\r\n                where: {\r\n                    K_Delete: IsNull(),\r\n                    userextensions: ??\r\n                }\r\n            })\r\n            result.Success = true;\r\n        } catch (ex) {\r\n            result.Exception = ex;\r\n        }\r\n```\r\n\r\nthey have relations like below\r\n\r\n```\r\n@Entity(\"UserBasic\")\r\nexport class UserBasic {\r\n\r\n    // @Column(\"int\",{ \r\n    //     generated:true,\r\n    //     nullable:false,\r\n    //     primary:true,\r\n    //     name:\"id\"\r\n    //     })\r\n    @PrimaryGeneratedColumn()\r\n    id: number;\r\n\r\n....\r\n\r\n    @OneToMany(type => UserExtension, userextensions => userextensions.fk_id,\r\n        {\r\n            cascade: true,\r\n            onDelete: \"CASCADE\",\r\n            onUpdate: \"CASCADE\",\r\n        })\r\n    userextensions: UserExtension[];\r\n\r\n}\r\n\r\n```\r\n\r\n```\r\n@Entity(\"UserExtension\")\r\n@Index(\"FK_id\",[\"fk_id\",])\r\nexport class UserExtension {\r\n\r\n    @PrimaryGeneratedColumn()\r\n    id:number;\r\n        \r\n\r\n   \r\n    @ManyToOne(type => UserBasic, fk_id => fk_id.userextensions)\r\n    @JoinColumn({ name:'fk_id'})\r\n    fk_id:UserBasic;\r\n    \r\n  .....\r\n\r\n    @Column(\"tinyint\",{ \r\n        nullable:true,\r\n        default:\"NULL\",\r\n        name:\"K_Delete\"\r\n        })\r\n    K_Delete:number;\r\n```\r\n\r\nHow can i get data with the K_Delete in UserExtension is NULL?\r\n\r\nplease!",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/2297/comments",
    "author": "lalalalaluk",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2018-06-07T06:43:11Z",
        "body": "You need to use QueryBuilder. Please read QueryBuilder documentation, try and experiment and you'll find a solution. Think of what SQL you'll build using it."
      }
    ]
  },
  {
    "number": 2278,
    "title": "event.entity is undefined in subscriber when deleteing using queryBuilder",
    "created_at": "2018-06-05T07:32:53Z",
    "closed_at": "2018-06-05T07:38:21Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/2278",
    "body": "**Issue type:**\r\n\r\n[ ] question\r\n[x] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[x] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[x] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n\r\n**TypeORM version:**\r\n\r\n[ ] `latest`\r\n[ ] `@next`\r\n[x] `0.2.5` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nI am removing object in my custom repository using the method\r\n```\r\nremoveById(id: number): Observable<DeleteResult> {\r\n    return Observable.fromPromise(\r\n      this.createQueryBuilder()\r\n        .delete()\r\n        .from(InspectionResult)\r\n        .where('id = :inspectionResultId', { inspectionResultId: id })\r\n        .execute()\r\n    );\r\n  }\r\n```\r\nMy Subscriber looks like this\r\n```\r\n@EventSubscriber()\r\nexport class InspectionResultSubscriber implements EntitySubscriberInterface<InspectionResult> {\r\n\r\n  listenTo() {\r\n    return InspectionResult;\r\n  }\r\n\r\n  afterRemove(event: RemoveEvent<InspectionResult>) {\r\n    console.log(event.entity);\r\n  }\r\n}\r\n```\r\n\r\nafterRemove is triggered, but I get undefined in event.entity. event object doesn't hold the info about removed entity at all. Can I use queryBuilder to remove the entity and get info about this entity in subscriber?",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/2278/comments",
    "author": "EugeniaM",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2018-06-05T07:38:20Z",
        "body": "please checkout similar discussion in #2246 . In this case when you call delete you don't have any entities that orm can send you to subscriber. query builder just executes you DELETE * FROM table WHERE x. To fix this behaviour ORM needs to execute SELECT * FROM table WHERE x. Its not efficient of course =) entity is being passed to subscriber only when you call manager/repository's .remove method with entity passed."
      }
    ]
  },
  {
    "number": 2272,
    "title": "Selecting embedded entities",
    "created_at": "2018-06-04T18:54:18Z",
    "closed_at": "2018-09-29T07:42:16Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/2272",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[x] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nHow can embedded entities be selected?\r\n\r\n```ts\r\n\r\n@Entity()\r\nexport class User {\r\n\r\n    @PrimaryGeneratedColumn()\r\n    id: number;\r\n\r\n    @Column()\r\n    age: number;\r\n\r\n    @Column(() => Device)\r\n    device: Device;\r\n\r\n}\r\n\r\nexport class Device {\r\n    @Column()\r\n    type: string;\r\n\r\n    @Column()\r\n    token: string;\r\n}\r\n\r\nconst user = await getRepository(User).find({\r\n    select: [\"id\", \"device\"],\r\n});\r\n\r\n```\r\nThis results in \r\n\r\n```\r\nError: device column was not found in the User entity.\r\n```\r\nTrying to fetch it as a relation doesn't work either.",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/2272/comments",
    "author": "SharmaTushar",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2018-06-04T19:06:36Z",
        "body": "they are always selected automatically, you don't need to explicitly select them."
      },
      {
        "user": "SharmaTushar",
        "created_at": "2018-06-04T19:14:47Z",
        "body": "It doesn't work if you also need to include columns which are decorated with ```@Column({select: false})```."
      },
      {
        "user": "pleerock",
        "created_at": "2018-06-04T19:22:49Z",
        "body": "in 0.3.0 (@next) syntax has changed, but in 0.2.0 not sure if such functionality was implemented for embed, but try following:\r\n\r\n```ts\r\nselect: [\"id\", \"device.type\"],\r\n```"
      },
      {
        "user": "SharmaTushar",
        "created_at": "2018-06-04T19:52:01Z",
        "body": "I have already tried this and other variations with 0.2.x but they fail to compile. Same with `@next`."
      },
      {
        "user": "pleerock",
        "created_at": "2018-06-05T03:41:18Z",
        "body": "> I have already tried this and other variations with 0.2.x but they fail to compile\r\n\r\nah okay then 0.2.x does not support it.\r\n\r\n>  Same with @next.\r\n\r\n`@next` have different syntax:\r\n\r\n```ts\r\nselect: {\r\n    id: true,\r\n    device: {\r\n         type: true\r\n    }\r\n}\r\n```"
      }
    ]
  },
  {
    "number": 2267,
    "title": "How to save an array of integer in MSSQL using typeorm?",
    "created_at": "2018-06-04T07:26:37Z",
    "closed_at": "2018-09-29T07:34:53Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/2267",
    "body": "I want to save an array of int(say [1,2,3]) in one column. I tried to use the following lines but typeorm is not recognizing array\r\nI want to save the below request,\r\n{\r\n\t\"title\":\"Hello\", \r\n\t\"simpleIntArray\":[1,2]\r\n}\r\nEntity I used is,\r\n@Entity()\r\nexport class ArrayTest {\r\n\r\n    @PrimaryGeneratedColumn()\r\n    id: number;\r\n\r\n    @Column()\r\n    title: string; \r\n\r\n    @Column()\r\n    simpleIntArray: number[];\r\n    \r\n}\r\n\r\nI tried by declaring array in different ways but nothing was working. Am i doing anything wrongly?\r\n\r\n @Column(\"int\", { isArray: true })\r\n    simpleIntArray: number[];\r\n\r\n\r\n @Column(\"int\", { isArray: true })\r\n    simpleIntArray: Array<number>;\r\n\r\n\r\n\r\nquery failed:  CREATE TABLE \"array_test\" (\"id\" int NOT NULL IDENTITY(1,1), \"title\" nvarchar(255) NOT NULL, \"modifiedDate\" datetime2 NOT NULL CONSTRAINT \"df_array_test_modifiedDate\" DEFAULT (getdate()), \"createdDate\" datetime2 NOT NULL CONSTRAINT \"df_array_test_createdDate\" DEFAULT (getdate()), \"testDate\" datetime, \"simpleIntArray\"\r\nint array NOT NULL, PRIMARY KEY(\"id\"))\r\nerror:  { RequestError: Incorrect syntax near 'array'.\r\n\r\nPlease let me know how to save array of integer\r\n\r\n**Issue type:**\r\n\r\n[ X] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[X ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n\r\n**TypeORM version:** \r\n\r\n[ ] `latest`\r\n[ ] `@next`\r\n[0.1.21 ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\n<!--\r\n    To answer those questions you need to put \"x\" inside the square brackets, for example:\r\n    [x] `mysql`\r\n    [ ] `postgres`\r\n\r\n    Also, please format your code properly (by taking code blocks into ```ts .... ```)\r\n!>\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/2267/comments",
    "author": "KrishnaAnanthi",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2018-06-04T09:26:58Z",
        "body": "mssql does not support arrays. \r\n\r\nyou can use \"simple-array\" type (`@Column(\"simple-array\")`) which is very trivial orm-level implementation of array, and it can be only string array."
      }
    ]
  },
  {
    "number": 2255,
    "title": "Best Practices for running multiple servers against a single database",
    "created_at": "2018-06-01T22:18:33Z",
    "closed_at": "2018-09-29T07:39:27Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/2255",
    "body": "**Issue type:**\r\n\r\n[X] question\r\n\r\n**Database system/driver:**\r\n\r\n[X] `postgres`\r\n\r\n**TypeORM version:**\r\n\r\n[X] `latest`\r\n\r\n\r\nFirst off, I love working with typeorm, it's an amazing framework. \r\n\r\nI'm looking to scale up my express typeorm app and run multiple instances on different hosts that all use the same database.\r\n\r\nI couldn't find any documentation written on this, but what are some best practices and things to watch out for? For example, do Subscribers and Listeners work any differently?\r\n\r\nThanks!",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/2255/comments",
    "author": "HipsterZipster",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2018-06-04T13:02:42Z",
        "body": "I don't see any issues with scaling on multiple instances, typeorm does not care about it."
      }
    ]
  },
  {
    "number": 2244,
    "title": "Missing primary column with composition - @next",
    "created_at": "2018-05-31T12:59:33Z",
    "closed_at": "2018-09-29T07:40:45Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/2244",
    "body": "**Issue type:**\r\n\r\n[ ] question\r\n[x ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[x] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n\r\n**TypeORM version:**\r\n\r\n[ ] `latest`\r\n[x] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n```ts\r\nimport { Entity, ManyToOne, Column } from 'typeorm';\r\nimport { CandidateEntity } from '../candidate/candidate.entity';\r\nimport { SocialEntity } from './social.entity';\r\n\r\n@Entity()\r\nexport class CandidateSocialEntity {\r\n  @ManyToOne(type => CandidateEntity, candidate => candidate.candidateSocials, {\r\n    primary: true,\r\n  })\r\n  public candidate: CandidateEntity;\r\n\r\n  @ManyToOne(type => SocialEntity, social => social.candidateSocials, {\r\n    primary: true,\r\n  })\r\n  public social: SocialEntity;\r\n\r\n  @Column('text') public link: string;\r\n}\r\n```\r\n\r\nThis is basically a custom joint table, as I wanted to add another column to it (`link`). My primary key is a composition of foreign keys.\r\n\r\nThis was working in 0.2.0-alpha-9 but not anymore in 0.3.0-alpha.5.\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/2244/comments",
    "author": "RDeluxe",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2018-06-04T13:20:17Z",
        "body": "its a breaking change of 0.3.0. We would not allow to use primary relations without having a primary columns defined. This decision was made because of hundred issues bring by previous approach. New way is:\r\n\r\n```ts\r\n@Entity()\r\nexport class CandidateSocialEntity {\r\n\r\n  @PrimaryColumn()\r\n  candidateId: number;\r\n \r\n  @ManyToOne(type => CandidateEntity, candidate => candidate.candidateSocials)\r\n  public candidate: CandidateEntity;\r\n\r\n  @PrimaryColumn()\r\n  socialId: number;\r\n\r\n  @ManyToOne(type => SocialEntity, social => social.candidateSocials)\r\n  public social: SocialEntity;\r\n\r\n  @Column('text') public link: string;\r\n}\r\n```"
      }
    ]
  },
  {
    "number": 2242,
    "title": "Uncaught TypeError: Cannot read property 'constructor' of undefined",
    "created_at": "2018-05-31T01:30:13Z",
    "closed_at": "2018-12-08T20:28:10Z",
    "labels": [
      "question",
      "needs more info"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/2242",
    "body": "**Issue type:**\r\n\r\n[ x] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[x] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[x] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nWhen serve the example \r\n\r\nand call the createConnection in  HomePage.ts\r\n\r\nInside contructor I have this call \r\n\r\n   ```ts\r\ncreateConnection().then(async connection => {\r\n\r\n      console.log(\"Inserting a new user into the database...\");\r\n      const user = new User();\r\n      user.firstName = \"Timber\";\r\n      user.lastName = \"Saw\";\r\n      user.age = 25;\r\n      await connection.manager.save(user);\r\n      console.log(\"Saved a new user with id: \" + user.id);\r\n\r\n      console.log(\"Loading users from the database...\");\r\n      const users = await connection.manager.find(User);\r\n      console.log(\"Loaded users: \", users);\r\n\r\n      console.log(\"Here you can setup and run express/koa/any other framework.\");\r\n\r\n}).catch(error => console.log(error));\r\n```\r\n\r\n\r\n\r\nionic info\r\n\r\n```\r\ncli packages:\r\n    @ionic/cli-utils  : 1.19.2\r\n    ionic (Ionic CLI) : 3.20.0\r\n\r\nglobal packages:\r\n\r\n    cordova (Cordova CLI) : not installed\r\n\r\nlocal packages:\r\n\r\n    @ionic/app-scripts : 3.1.9\r\n    Cordova Platforms  : none\r\n    Ionic Framework    : ionic-angular 3.9.2\r\n\r\nSystem:\r\n\r\n    Node : v8.11.1\r\n    npm  : 5.6.0\r\n    OS   : Windows 10\r\n\r\nEnvironment Variables:\r\n\r\n    ANDROID_HOME : not set\r\n\r\nMisc:\r\n\r\n    backend : pro\r\n```\r\n\r\npackage.ts\r\n```js\r\n{\r\n   \"name\": \"pidoionic\",\r\n   \"version\": \"0.0.1\",\r\n   \"description\": \"\",\r\n   \"scripts\": {\r\n      \"build\": \"ionic-app-scripts build\",\r\n      \"clean\": \"ionic-app-scripts clean\",\r\n      \"lint\": \"ionic-app-scripts lint\",\r\n      \"ionic:build\": \"npm run build\",\r\n      \"ionic:serve\": \"npm run serve\",\r\n      \"ionic:lint\": \"npm run lint\",\r\n      \"start\": \"ts-node src/index.ts\"\r\n   },\r\n   \"dependencies\": {\r\n      \"@agm/core\": \"^1.0.0-beta.3\",\r\n      \"@angular/animations\": \"5.2.9\",\r\n      \"@angular/common\": \"5.2.9\",\r\n      \"@angular/compiler\": \"5.2.9\",\r\n      \"@angular/compiler-cli\": \"5.2.9\",\r\n      \"@angular/core\": \"^5.2.9\",\r\n      \"@angular/forms\": \"5.2.9\",\r\n      \"@angular/http\": \"^5.2.9\",\r\n      \"@angular/platform-browser\": \"5.2.9\",\r\n      \"@angular/platform-browser-dynamic\": \"5.2.9\",\r\n      \"@ionic-native/camera\": \"4.3.3\",\r\n      \"@ionic-native/core\": \"^4.7.0\",\r\n      \"@ionic-native/file\": \"^4.7.0\",\r\n      \"@ionic-native/firebase\": \"^4.7.0\",\r\n      \"@ionic-native/google-plus\": \"^4.7.0\",\r\n      \"@ionic-native/image-resizer\": \"^4.6.0\",\r\n      \"@ionic-native/in-app-browser\": \"^4.7.0\",\r\n      \"@ionic-native/splash-screen\": \"4.6.0\",\r\n      \"@ionic-native/sqlite\": \"^4.7.0\",\r\n      \"@ionic-native/sqlite-porter\": \"^4.7.0\",\r\n      \"@ionic-native/status-bar\": \"4.6.0\",\r\n      \"@ionic/storage\": \"2.1.3\",\r\n      \"@ngx-translate/core\": \"8.0.0\",\r\n      \"@ngx-translate/http-loader\": \"^2.0.0\",\r\n      \"angularfire2\": \"^5.0.0-rc.5-next\",\r\n      \"bluebird\": \"^3.5.1\",\r\n      \"cordova-android\": \"^6.2.3\",\r\n      \"cordova-browser\": \"5.0.3\",\r\n      \"cordova-plugin-camera\": \"^4.0.2\",\r\n      \"cordova-plugin-compat\": \"^1.2.0\",\r\n      \"cordova-plugin-crosswalk-webview\": \"^1.1.6\",\r\n      \"cordova-plugin-device\": \"^2.0.1\",\r\n      \"cordova-plugin-firebase\": \"^1.0.0\",\r\n      \"cordova-plugin-geolocation\": \"^2.4.3\",\r\n      \"cordova-plugin-googleplus\": \"^5.3.0\",\r\n      \"cordova-plugin-inappbrowser\": \"~1.7.2\",\r\n      \"cordova-plugin-ionic-webview\": \"^1.1.15\",\r\n      \"cordova-plugin-splashscreen\": \"^5.0.2\",\r\n      \"cordova-plugin-statusbar\": \"^2.4.1\",\r\n      \"cordova-plugin-whitelist\": \"^1.3.3\",\r\n      \"cordova-sqlite-storage\": \"^2.3.2\",\r\n      \"firebase\": \"^4.13.1\",\r\n      \"imagemin\": \"^5.3.1\",\r\n      \"info.protonet.imageresizer\": \"~0.1.1\",\r\n      \"ionic-angular\": \"3.9.2\",\r\n      \"ionicons\": \"3.0.0\",\r\n      \"local-storage\": \"^1.4.2\",\r\n      \"moment\": \"^1.7.2\",\r\n      \"mysql\": \"^2.14.1\",\r\n      \"ng2-reactive-forms-validators\": \"^1.1.0\",\r\n      \"node-sass\": \"^4.9.0\",\r\n      \"reflect-metadata\": \"^0.1.10\",\r\n      \"rxjs\": \"5.5.8\",\r\n      \"sw-toolbox\": \"3.6.0\",\r\n      \"typeorm\": \"0.2.6\",\r\n      \"zone.js\": \"0.8.20\"\r\n   },\r\n   \"devDependencies\": {\r\n      \"@angular/cli\": \"^1.5.3\",\r\n      \"@angular/flex-layout\": \"2.0.0-beta.12\",\r\n      \"@angular/tsc-wrapped\": \"^4.4.6\",\r\n      \"@ionic/app-scripts\": \"^3.1.9\",\r\n      \"@types/googlemaps\": \"^3.26.16\",\r\n      \"@types/node\": \"^8.0.29\",\r\n      \"ionic\": \"3.20.0\",\r\n      \"typescript\": \"2.5.2\",\r\n      \"sql.js\": \"^0.5.0\",\r\n      \"ts-node\": \"3.3.0\"\r\n   },\r\n   \"cordovaPlugins\": [\r\n      \"cordova-plugin-whitelist\",\r\n      \"cordova-plugin-device\",\r\n      \"cordova-plugin-statusbar\",\r\n      \"cordova-plugin-console\",\r\n      \"cordova-plugin-splashscreen\",\r\n      \"ionic-plugin-keyboard\"\r\n   ],\r\n   \"cordovaPlatforms\": [],\r\n   \"cordova\": {\r\n      \"plugins\": {\r\n         \"cordova-sqlite-storage\": {},\r\n         \"cordova-plugin-geolocation\": {\r\n            \"GEOLOCATION_USAGE_DESCRIPTION\": \" \"\r\n         },\r\n         \"cordova-plugin-console\": {},\r\n         \"cordova-plugin-device\": {},\r\n         \"cordova-plugin-splashscreen\": {},\r\n         \"cordova-plugin-statusbar\": {},\r\n         \"cordova-plugin-whitelist\": {},\r\n         \"ionic-plugin-keyboard\": {},\r\n         \"info.protonet.imageresizer\": {},\r\n         \"cordova-plugin-camera\": {},\r\n         \"cordova-plugin-inappbrowser\": {},\r\n         \"cordova-plugin-googleplus\": {\r\n            \"REVERSED_CLIENT_ID\": \"com.googleusercontent.apps.781145103219-a87b3bd7d7858i8lrr2531nm8ml2bj6c\",\r\n            \"WEB_APPLICATION_CLIENT_ID\": \"781145103219-vn75hrm8tv0b54hkck4dokv5nnr0pvao.apps.googleusercontent.com\"\r\n         },\r\n         \"cordova-plugin-crosswalk-webview\": {\r\n            \"XWALK_VERSION\": \"22+\",\r\n            \"XWALK_LITEVERSION\": \"xwalk_core_library_canary:17+\",\r\n            \"XWALK_COMMANDLINE\": \"--disable-pull-to-refresh-effect\",\r\n            \"XWALK_MODE\": \"embedded\",\r\n            \"XWALK_MULTIPLEAPK\": \"true\"\r\n         },\r\n         \"cordova-plugin-ionic-webview\": {}\r\n      },\r\n      \"platforms\": [\r\n         \"android\",\r\n         \"browser\"\r\n      ]\r\n   }\r\n}\r\n`\r\n\r\normconfig\r\n`\r\n{\r\n   \"type\": \"mysql\",\r\n   \"host\": \"localhost\",\r\n   \"port\": 3306,\r\n   \"username\": \"test\",\r\n   \"password\": \"test\",\r\n   \"database\": \"test\",\r\n   \"synchronize\": true,\r\n   \"logging\": false,\r\n   \"entities\": [\r\n      \"src/entity/**/*.ts\"\r\n   ],\r\n   \"migrations\": [\r\n      \"src/migration/**/*.ts\"\r\n   ],\r\n   \"subscribers\": [\r\n      \"src/subscriber/**/*.ts\"\r\n   ],\r\n   \"cli\": {\r\n      \"entitiesDir\": \"src/entity\",\r\n      \"migrationsDir\": \"src/migration\",\r\n      \"subscribersDir\": \"src/subscriber\"\r\n   }\r\n}\r\n```\r\n\r\n\r\n<!--\r\n    To answer those questions you need to put \"x\" inside the square brackets, for example:\r\n    [x] `mysql`\r\n    [ ] `postgres`\r\n\r\n    Also, please format your code properly (by taking code blocks into ```ts .... ```)\r\n!>\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/2242/comments",
    "author": "exequielc",
    "comments": [
      {
        "user": "daniel-lang",
        "created_at": "2018-06-22T19:23:44Z",
        "body": "Could you provide a bit more information? Like:\r\n* Where/in which line is the error reported?\r\n* Entities\r\n* Connection options"
      },
      {
        "user": "exequielc",
        "created_at": "2018-08-13T13:29:20Z",
        "body": "@daniel-lang The line  is createConnection().then(async connection => {\r\n\r\naparently is the word ->async / await\r\n\r\nI don't understand how to solve this.. apparently this is not a problem of typeorm but if you can help me I appreciate it"
      },
      {
        "user": "havenchyk",
        "created_at": "2018-11-08T16:03:16Z",
        "body": "hey @exequielc. did you solve your problem? If so could you please close the issue? Otherwise, please, create a small repo with an example where we can catch the problem"
      },
      {
        "user": "Kononnable",
        "created_at": "2018-12-08T20:28:10Z",
        "body": "Closing as no answer from the reporter."
      }
    ]
  },
  {
    "number": 2213,
    "title": "Question: How would you go about getting a value for a field from a cache",
    "created_at": "2018-05-25T09:02:42Z",
    "closed_at": "2018-09-29T07:40:26Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/2213",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[x] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\nI am building a GraphQL server and having a hard time trying to work out how I can return a getter that is looked up from a cache. Suppose I have this getter for a field in my entity class:\r\n\r\n```\r\n@Entity(\"accountbase\")\r\nexport class Account extends BaseEntity {\r\n  \r\n  @Column(\"int\") accountcategorycode: number;\r\n  @Column({ select: false })\r\n  get accountcategorycode_name(): string {\r\n    return this.accountcategorycode !== null\r\n      ? this.accountcategorycode.toString()\r\n      : \"\";\r\n  }\r\n```\r\n\r\nI need to be able to return a value looked up in a cache but I have no idea how I am going to get the cache context injected here, even with a constructor, how do I pass the cache context to it if I have a resolver like so:\r\n\r\n```\r\n  const connection = await createTypeOrmConnection(req);\r\n      const records = await connection\r\n        .getRepository(Account)\r\n        .createQueryBuilder(\"accountbase\")\r\n        .leftJoinAndSelect(\"accountbase.primarycontactid_ref\", \"accountbase.primarycontactid_ref\")\r\n        .leftJoinAndSelect(\"accountbase.t4a_secondarycontactid_ref\", \"accountbase.t4a_secondarycontactid_ref\")\r\n        .getMany()\r\n        .catch(error => { throw error as Error; });\r\n        await connection.close();\r\n      return records;\r\n```\r\n\r\nI am pretty new to TypeORM/TypeScript but I would of thought this use-case is pretty common-place, just haven't found any example of how to go about it so thanks in advance if you could help a fellow out.\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/2213/comments",
    "author": "iamgmd",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2018-05-25T12:19:56Z",
        "body": "```ts\r\n\r\n  @Column(\"int\") accountcategorycode: number;\r\n  @Column({ select: false })\r\n  get accountcategorycode_name(): string {\r\n    return this.accountcategorycode !== null\r\n      ? this.accountcategorycode.toString()\r\n      : \"\";\r\n  }\r\n```\r\n\r\nuse decorators on class properties, not methods or getter/setters. Probably its better to implement what you want with a better approach.  "
      },
      {
        "user": "iamgmd",
        "created_at": "2018-05-31T14:14:19Z",
        "body": "Hi @pleerock, I struggled with this somewhat and it is mostly to do with my lack of knowledge. \r\n\r\nFrom this code below in my GraphQL resolver, I am creating a typeORM connection passing in Express.Request and a Redis client that has been passed down through the GraphQL context.\r\n\r\n```\r\n    contact_all: async (_, {}, { req, redis }) => {\r\n      const connection = await createTypeOrmConnection(req, redis);\r\n      const records = await connection\r\n        .getRepository(Contact)\r\n        .createQueryBuilder(\"contactbase\")\r\n        .getMany()\r\n        .catch(error => { throw error as Error; });\r\n        await connection.close();\r\n      return records;\r\n    },\r\n```\r\n\r\nI am not sure if it is the .getRespository(Contact) or .createQueryBuilder(\"contactbase\") that is responsible for instantiating the Contact objects but it is at this point where I need the Express.Request and Redis client to be accessible so that I can use it in the getter.\r\n\r\nIf anyone has any examples of decorators to do this I would really appreciate it."
      },
      {
        "user": "pleerock",
        "created_at": "2018-06-04T13:13:55Z",
        "body": "@iamgmd sorry but I don't understand your request. You need to use redis client or request in the getter? In entity getter? If yes then don't do it its a bad practice. Handle logic in your resolver code."
      }
    ]
  },
  {
    "number": 2209,
    "title": "Database Compatibility with Lower Version of MariaDB",
    "created_at": "2018-05-24T18:12:52Z",
    "closed_at": "2018-06-05T09:20:26Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/2209",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[x] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\nHi, I would like to understand if I can target a lower version of MariaDB than the latest version. Does typeorm correctly identified the MariaDB version and generates appropriate queries. I am getting following error when running my project on MariaDB 5.5.X \r\n\r\n`QueryFailedError: ER_PARSE_ERROR: You have an error in your SQL syntax; check the manual that corresponds to your MariaDB server version for the right syntax to use near '6), updatedAt datetime(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6), deletedAt d' at line 1`\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/2209/comments",
    "author": "naveensky",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2018-06-05T09:15:36Z",
        "body": "I guess issue in `CURRENT_TIMESTAMP(6)`. You can change it by changing your UpdateColumn usage to:\r\n\r\n```ts\r\n@UpdateColumn({ default: () => \"CURRENT_TIMESTAMP\" })\r\nupdatedAt;\r\n```"
      },
      {
        "user": "naveensky",
        "created_at": "2018-06-05T09:20:26Z",
        "body": "@pleerock - Thanks for this. I was able to resolve the issue by upgrading the DB to latest version of MariaDB. For now, we can close this issue."
      }
    ]
  },
  {
    "number": 2194,
    "title": "Force to export all database schema in one migration",
    "created_at": "2018-05-22T17:56:47Z",
    "closed_at": "2018-09-29T07:22:31Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/2194",
    "body": "**Issue type:**\r\n\r\n[x ] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[x ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\nHi!\r\nI have been working with synchronize option so when I start my project (using TS.ED framework) all the database creates itself but now we are releasing production version so I want to create all the database schema BEFORE run the server. I've tried `migrations:generate` command to generate the migration containing all the database schema but it says that no changes were found on model, so is there any way to force the migration?",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/2194/comments",
    "author": "jorge-indigo",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2018-05-22T19:29:59Z",
        "body": "migrations:generate shall work, I guess you have something wrong in your setup"
      }
    ]
  },
  {
    "number": 2187,
    "title": "Ionic migration class names get replaced by \"a\" or 's' when using --prod",
    "created_at": "2018-05-21T15:35:47Z",
    "closed_at": "2018-05-24T08:42:16Z",
    "labels": [
      "question",
      "comp: ionic"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/2187",
    "body": "**Issue type:**\r\n\r\n[ ] question\r\n[x] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[x] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nSteps to reproduce or a small repository showing the problem:\r\nCan't make Ionic work using the --prod flag.\r\nEverything works perfectly when using ionic cordova run android or ionic cordova run android --release but as soon as we add the --prod flag, things start to break.\r\n\r\nThe file names are changed to 'a','s' like that.\r\n\r\nError: \r\nn migration name is wrong. Migration class name should have a UNIX timestamp appended.\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/2187/comments",
    "author": "praveenraji2i",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2018-05-22T12:09:21Z",
        "body": "try to disable mangling in your uglify options"
      },
      {
        "user": "pleerock",
        "created_at": "2018-05-22T12:25:14Z",
        "body": "see #2164"
      },
      {
        "user": "daniel-lang",
        "created_at": "2018-05-24T08:42:15Z",
        "body": "duplicate of #2164"
      }
    ]
  },
  {
    "number": 2179,
    "title": "InnerJoin and InnerJoinAndSelect not working on nested object",
    "created_at": "2018-05-20T12:54:26Z",
    "closed_at": "2018-05-23T03:12:14Z",
    "labels": [
      "question",
      "by design"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/2179",
    "body": "**Issue type:**\r\n\r\n[ ] question\r\n[ X] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n\r\n**TypeORM version:**\r\n\r\n[X ] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\n```\r\n.createQueryBuilder('answerLog')\r\n.innerJoin('answerLog.answer', 'answer')\r\n.innerJoinAndSelect('answer.todo', 'todo')\r\n```\r\n\r\nI'm using this query to get the todo and select thad, but this query results in an answer undefined cause as you can see I'm not using `innerJoinAndSelect` on the `'answer'` in my query. On the previous version of typeorm it was possible to do is, I don't know if this is a change that was planned or something that broke?\r\n\r\nI can easily solve this by doing:\r\n\r\n```\r\n.createQueryBuilder('answerLog')\r\n.innerJoinAndSelect('answerLog.answer', 'answer')\r\n.innerJoinAndSelect('answer.todo', 'todo')\r\n```\r\n\r\nBut this will put unnecessary data in my result.",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/2179/comments",
    "author": "toonvanstrijp",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2018-05-22T13:57:44Z",
        "body": "but where do you expect answer.todo to go into your model? Since you are selecting logs and todos but there is no logs.todos where do you expect todos to be in?"
      },
      {
        "user": "toonvanstrijp",
        "created_at": "2018-05-22T17:18:44Z",
        "body": "It's a nested structure:\r\n```\r\nAnswerLog {\r\n answer: Answer;\r\n}\r\nAnswer {\r\n todo: Todo;\r\n}\r\nTodo {\r\n}\r\n```\r\n\r\nSo I expect Typeorm to add answer to the query but not select the values of it, only the relationship `Todo`."
      },
      {
        "user": "pleerock",
        "created_at": "2018-05-22T19:33:21Z",
        "body": "yeap, so you expect anser to be inside todo, right? If yes, then you must select it."
      },
      {
        "user": "toonvanstrijp",
        "created_at": "2018-05-22T22:05:13Z",
        "body": "No I expect todo to be inside answer"
      },
      {
        "user": "pleerock",
        "created_at": "2018-05-23T03:12:14Z",
        "body": "Okay I already gave you answer. If you want something to be you need to select it."
      }
    ]
  },
  {
    "number": 2174,
    "title": "Relation column name is transformed to small letter in a query",
    "created_at": "2018-05-19T11:08:32Z",
    "closed_at": "2018-09-27T19:52:49Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/2174",
    "body": "**Issue type:**\r\n\r\n[ ] question\r\n[x ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[x ] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n\r\n**TypeORM version:**\r\n\r\n[ ] `latest`\r\n[ ] `@next`\r\n[x ] `0.1.9` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nI have below entity:\r\n\r\n```ts \r\nimport { Entity, Column, PrimaryGeneratedColumn, OneToOne, JoinColumn, CreateDateColumn } from 'typeorm';\r\nimport { PageLanguage } from './page-language.entity';\r\nimport { Page } from './page.entity';\r\n\r\n@Entity()\r\nexport class PageContent {\r\n\r\n    @PrimaryGeneratedColumn() id: number;\r\n\r\n    @Column({ length: 40}) name: string;\r\n\r\n    @Column('text') content: string;\r\n\r\n    @OneToOne(type => Page, page => page.id)\r\n    @JoinColumn()\r\n    page: Page;\r\n\r\n    @OneToOne(type => PageLanguage, pageLanguage => pageLanguage.id)\r\n    @JoinColumn()\r\n    pageLanguage: PageLanguage;\r\n}\r\n ```\r\nwhich generates me table with column names: id, name, content, pageId, pageLanguageId. The problem is when i try to do a query like below:\r\n```ts    \r\n async checkIfPageContentExistsAlready(pageId: number, pageLanguageId: number) {\r\n        const result = this.pageContentRepository\r\n            .createQueryBuilder('page_content')\r\n            .where('page_content.pageId = :pageId AND page_content.pagelanguageId = :pageLanguageId', { pageId, pageLanguageId })\r\n            .getOne();\r\n\r\n        return result;\r\n    } \r\n```\r\n\r\nthen i have that error:\r\n> QueryFailedError: column page_content.pageid does not exist\r\n    at new QueryFailedError (/var/www/project/src/error/QueryFailedError.ts:7:9)\r\n   at Query.callback (/var/www/project/src/driver/postgres/PostgresQueryRunner.ts:216:26)\r\n    at Query.handleError (/var/www/project/node_modules/pg/lib/query.js:143:17)\r\n    at Connection.connectedErrorHandler (/var/www/project/node_modules/pg/lib/client.js:132:26)\r\n    at emitOne (events.js:115:13)\r\n    at Connection.emit (events.js:210:7)\r\n    at Socket.<anonymous> (/var/www/project/node_modules/pg/lib/connection.js:117:12)\r\n    at emitOne (events.js:115:13)\r\n    at Socket.emit (events.js:210:7)\r\n    at addChunk (_stream_readable.js:264:12)\r\n\r\n\r\nSo looks like typeorm wrongly generates query with small letters instead camel case. When i switch database to mysql then everything is ok, but unfortunatelly i have to use postgres. Could someone share with me his solution for that problem?\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/2174/comments",
    "author": "rafal-rudnicki",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2018-05-22T14:39:50Z",
        "body": "you should use class property names instead of your database column names to let typeorm automatically escape your database column names:\r\n\r\n```ts\r\n.where('page_content.page = :pageId AND page_content.pageLanguage = :pageLanguageId', { pageId, pageLanguageId })\r\n```"
      },
      {
        "user": "RafalR86",
        "created_at": "2018-05-22T17:03:58Z",
        "body": "@pleerock Could you write me an example how to do that?"
      },
      {
        "user": "pleerock",
        "created_at": "2018-05-22T19:33:43Z",
        "body": "I already did, read my last message."
      }
    ]
  },
  {
    "number": 2172,
    "title": "Method to see if FB needs migration or possible pre-migration hook?",
    "created_at": "2018-05-18T14:36:30Z",
    "closed_at": "2018-12-24T08:14:39Z",
    "labels": [
      "question",
      "comp: migrations"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/2172",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[x] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nI'm looking to see if there is a quick/convenient  way to find out if the connected DB needs to run a migration through the migration API (not cli). I need to perform some actions before `runMigrations()` is performed. I was hoping for something along the lines of `currentVersion()` or `latestVersion()` or `needsMigration()`. Maybe there is a pre-migration hook that is able to be tapped into?\r\n\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/2172/comments",
    "author": "jmca",
    "comments": [
      {
        "user": "vlapo",
        "created_at": "2018-12-22T17:39:47Z",
        "body": "Hi @jmca. Maybe using `MigrationExecutor` and use `getMigrations` method to get all migrations and filter it like in code:\r\n```typescript\r\n// find all migrations that needs to be executed\r\nconst pendingMigrations = allMigrations.filter(migration => {\r\n      // check if we already have executed migration\r\n      const executedMigration = executedMigrations.find(executedMigration => executedMigration.name === migration.name);\r\n      if (executedMigration)\r\n          return false;\r\n      return true;\r\n});\r\n```\r\nBut I think there is no official way to do that."
      },
      {
        "user": "pleerock",
        "created_at": "2018-12-24T08:14:39Z",
        "body": "no, there is no, and I don't think we need it.\r\n\r\nYou can control flow on your own - you have all methods you need in. Just create connection without running migrations or sync, do what you need and use connection.runMigrations after that.\r\n\r\nThink we can close it."
      }
    ]
  },
  {
    "number": 2165,
    "title": "Why SelectQueryBuilder always add primary columns to selections?",
    "created_at": "2018-05-17T14:19:48Z",
    "closed_at": "2018-09-27T19:49:09Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/2165",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[x] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nHi, I would like know why `select: false` on `PrimaryColumn` is not working.\r\n\r\nTypeorm uses same Interface `ColumnOptions` for defining detailed options of the column, For both `Column` and `PrimaryColumn`. However, For `select` option, setting `select: false` when declaring `PrimaryColumn` is not working.  As a result of the code below in `buildEscapedEntityColumnSelects` of `SelectQueryBuilder.ts`.\r\n\r\n```typescript\r\n        const nonSelectedPrimaryColumns = this.expressionMap.queryEntity ? metadata.primaryColumns.filter(primaryColumn => columns.indexOf(primaryColumn) === -1) : [];\r\n        const allColumns = [...columns, ...nonSelectedPrimaryColumns];\r\n\r\n        return allColumns.map(column => {\r\n                /* generating selection paths  */ \r\n        }\r\n```\r\n\r\nWhat should I do if I want to results without primary columns in it?\r\nPlus, Adding the primary columns always to the selection list is on purpose? ",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/2165/comments",
    "author": "astrohsy",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2018-05-18T05:04:26Z",
        "body": "yes its by design. Primary columns are required for selection orm rely heavily on them"
      }
    ]
  },
  {
    "number": 2159,
    "title": "Search Engine Integration",
    "created_at": "2018-05-16T20:35:13Z",
    "closed_at": "2018-09-27T19:47:20Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/2159",
    "body": "**Issue type:**\r\n\r\n[X] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[X] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n\r\n**TypeORM version:**\r\n\r\n[X] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\nHi folks,\r\n\r\nI'm researching to use an ORM for a new project. But I need to be sure to have the possibility to easily index the DB to ElasticSearch, I can't see in the documentation that TypeORM support easy integration to ElasticSearch or similar search engines. Or maybe there is a third party plugin that allows that it would be great too.\r\n\r\nThanks in advance for the information.\r\n\r\nBest regards,\r\nLeonardo Monge García.\r\n\r\n\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/2159/comments",
    "author": "leomongeg",
    "comments": [
      {
        "user": "dcworldwide",
        "created_at": "2018-05-16T22:17:33Z",
        "body": "It's very simple to just write code that bridges the two technologies. There is no es integration and I don't think there needs to be. I do it myself with little code using the official es npm package. "
      },
      {
        "user": "dcworldwide",
        "created_at": "2018-05-16T22:18:34Z",
        "body": "It's very simple to just write code that bridges the two technologies. There is no es integration and I don't think there needs to be. I do it myself with little code using the official es npm package. "
      },
      {
        "user": "pleerock",
        "created_at": "2018-05-17T09:39:35Z",
        "body": "yeap, agree with everything @dcworldwide told"
      }
    ]
  },
  {
    "number": 2141,
    "title": "When I use this @PrimaryGeneratedColumn(\"uuid\"),  is this auto generated value universal in the world like the name?",
    "created_at": "2018-05-15T11:04:49Z",
    "closed_at": "2018-09-27T19:46:39Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/2141",
    "body": "**Issue type:**\r\n\r\n[*] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[*] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n\r\n**TypeORM version:**\r\n\r\n[*] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\n<!--\r\n    To answer those questions you need to put \"x\" inside the square brackets, for example:\r\n    [x] `mysql`\r\n    [ ] `postgres`\r\n\r\n    Also, please format your code properly (by taking code blocks into ```ts .... ```)\r\n!>\r\n\r\nHello, I have two questions.\r\nWhen I use this @PrimaryGeneratedColumn(\"uuid\"), \r\nAt first, is this auto generated value universal in the world like the name?\r\nSecond, can the uuid be generated by this decorator at Sqlite without any problem?\r\n\r\nThanks,\r\nJJ",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/2141/comments",
    "author": "JeongJun-Lee",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2018-05-15T12:02:57Z",
        "body": "its just regular generated uuid, see wiki on topic of uniqueness of uuid "
      }
    ]
  },
  {
    "number": 2134,
    "title": "type bigint",
    "created_at": "2018-05-14T05:34:24Z",
    "closed_at": "2018-05-14T12:13:32Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/2134",
    "body": "**Issue type:**\r\n\r\n[*] question\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `mysql` / `mariadb`\r\n\r\n**TypeORM version:**\r\n\r\n[ ] `latest`\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nIf a define a column with type bigint, then i got this field as string?\r\n\r\nfor example:\r\n\r\n```\r\n\r\n@Entity()\r\nexport class Follow {\r\n  @PrimaryGeneratedColumn()\r\n  id: number\r\n\r\n  @Column({ type: \"bigint\" })\r\n  uid: number   \r\n\r\n\r\n  static async testBigInt(id: number) {\r\n    let f = await getRepository(Follow).findOne({uid: id})\r\n    console.log(typeof f.uid)\r\n  }\r\n}\r\n\r\nFollow.testBigint(1)\r\n```\r\n\r\nthen, I got string\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/2134/comments",
    "author": "guotie",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2018-05-14T12:11:43Z",
        "body": "its an expected behaviour. javascript's numbers can't fit huge bigint values"
      },
      {
        "user": "guotie",
        "created_at": "2018-05-14T12:13:32Z",
        "body": "Ok.\r\n"
      },
      {
        "user": "jbamlee",
        "created_at": "2018-07-05T07:34:53Z",
        "body": "It might be helpful to represent `bigint` columns using the `Long` library.\r\nThis is the approach that the javascript/typescript implementation of Protocol Buffers uses."
      },
      {
        "user": "pleerock",
        "created_at": "2018-07-05T16:44:01Z",
        "body": "make requests to underlying libraries. But I guess they won't implement it. We have to wait until bigint come within next es standard. "
      },
      {
        "user": "imjamesb",
        "created_at": "2020-12-26T05:28:11Z",
        "body": "What about the `BigInt` type? It has been supported since Node v10, if not longer."
      }
    ]
  },
  {
    "number": 2130,
    "title": "When would the type argument to typeFunction of the ManyToOne and OneToMany decorators be used?",
    "created_at": "2018-05-12T00:20:46Z",
    "closed_at": "2018-09-27T19:45:37Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/2130",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[ ] bug report\r\n[ ] feature request\r\n[x] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nIn the case referenced in the documentation the type argument to the typeFunction of a ManyToOne or OneToMany decorator is unused.  Thus the more appropriate declaration would be\r\n\r\n```\r\n    @ManyToOne(() => User, user => user.photos)\r\n    user: User;\r\n```\r\nand\r\n\r\n```\r\n   @OneToMany(() => Photo, photo => photo.user)\r\n    photos: Photo[];\r\n```\r\n\r\nThis prevents an error when compiling with --noUnusedParameters. \r\n\r\nIs there a good example of how the parameters might be used?",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/2130/comments",
    "author": "rduncan",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2018-05-14T12:47:58Z",
        "body": "they are never used. Its just \"syntax sugar\". You can use () instead without any issues. Especially if you have noUnusedParameters flag enabled."
      }
    ]
  },
  {
    "number": 2115,
    "title": "Updating to new QueryRunner",
    "created_at": "2018-05-09T23:57:36Z",
    "closed_at": "2018-09-27T19:44:29Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/2115",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[x] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[x] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nFrom the changelog: \r\n\r\n> insert, update and delete methods of QueryRunner now use InsertQueryRunner, UpdateQueryRunner and DeleteQueryRunner inside\r\n\r\nCan you please clarify? When I upgrade, I do not find the types for `InsertQueryRunner` or `UpdateQueryRunner` etc. I do find the new QueryBuilders though.\r\n```js\r\n// The old implementation inside our migrations:\r\nqueryRunner: QueryRunner;\r\nqueryRunner.update(\r\n      'public.someTechnologyTable',\r\n      { technology: 'someTechnology' },\r\n      { name: 'banana-pad' },\r\n)\r\n```\r\nHowever queryRunner.update() is no longer defined and not sure what the new equivalent is.\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/2115/comments",
    "author": "vance",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2018-05-10T03:15:43Z",
        "body": "looks like this change in changelog is a bit wrong. it was working this way but lately we completely removed those methods. Now you need to use query runner instead:\r\n\r\n```ts\r\nqueryRunner.manager.createQueryBuilder()\r\n   .insert()\r\n  .into(...)\r\n  .values({ ... })\r\n  .execute()\r\n```"
      }
    ]
  },
  {
    "number": 2102,
    "title": "TypeORM-MSSQL 2017 \"Failed to connect\" errors after changing from LINUX to Win Server 2012",
    "created_at": "2018-05-08T17:01:02Z",
    "closed_at": "2018-09-27T19:38:24Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/2102",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[x] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n\r\n**TypeORM version:**\r\n\r\n[ ] `latest`\r\n[ ] `@next`\r\n[x] `0.0.11`\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nI have this config for typeorm and create a connection normally with the server\r\n\r\n> {\r\n>         \"name\": \"default\",\r\n>         \"driver\": {\r\n>             \"type\": \"mssql\",\r\n>             \"host\": \"192.168.0.55\",\r\n>             \"port\": 1433,\r\n>             \"username\": \"user\",\r\n>             \"password\": \"password\",\r\n>             \"database\": \"DataBase\",\r\n>             \"autoSchemaSync\": false,\r\n>             \"enabledDrivers\": [\"mssql\"]\r\n>         },\r\n>         \"autoSchemaSync\": true,\r\n>         \"entities\": [\r\n>             \"build/entity/*.js\"\r\n>         ],\r\n>         \"cli\": {\r\n>             \"entitiesDir\": \"src/entity\"\r\n>         }\r\n>     }\r\n\r\n> createConnection(options).then(async connection => {\r\n>   const app = express();\r\n>   app.listen(port);\r\n> }).catch(error => console.log(\"TypeORM connection error: \", error));\r\n\r\nI'm receiving this error often when trying to start a connection to mssql 2017.\r\n\r\n`TypeORM connection error:  { ConnectionError: Failed to connect to 192.168.0.55:1433 in 15000ms`\r\n\r\nThe problem started happening after I changed the OS of the Database from linux to Windows server 2012. The MSSQL was reconfigured but this error started occurring. The problems is that sometimes the DataBase responds fine and sometimes it doesn't. So I have to keep trying until the server starts without problems. I installed PM2, a npm server monitor that auto restarts the server so I dont have to do it manually and its working. But the problem also occurs when I try to communicate with the database to get some info, so the server throw an error saying a promise rejection was unhandled.\r\n\r\n> You have triggered an unhandledRejection, you may have forgotten to catch a Promise rejection:\r\n> ConnectionError: Failed to connect to 192.168.0.55: 1433 in 15000ms \r\n> at Connection.tedious.once.err (/Backend/node_modules/mssql/lib/tedious.js:216:17)\r\n> at Object.onceWrapper (events.js:272:13)\r\n> at Connection.emit (events.js:180:13)\r\n> at Connection.emit (domain.js:422:20)\r\n> at Connection.connectTimeout (/Backend/node_modules/tedious/lib/connection.js:795:12)\r\n> at ontimeout (timers.js:466:11)\r\n> at tryOnTimeout (timers.js:304:5)\r\n> at Timer.listOnTimeout (timers.js:267:5)\r\n\r\nAngular also trows an error when the communication doesn't respond\r\n\r\n> ERROR Error: Uncaught (in promise): Response with status: 0  for URL: null at resolvePromise (zone.js:783)\r\n>     at resolvePromise (zone.js:754)\r\n>     at zone.js:831\r\n>     at ZoneDelegate.webpackJsonp.../../../../zone.js/dist/zone.js.ZoneDelegate.invokeTask (zone.js:424)\r\n>     at Object.onInvokeTask (core.es5.js:3881)\r\n>     at ZoneDelegate.webpackJsonp.../../../../zone.js/dist/zone.js.ZoneDelegate.invokeTask (zone.js:423)\r\n>     at Zone.webpackJsonp.../../../../zone.js/dist/zone.js.Zone.runTask (zone.js:191)\r\n>     at drainMicroTaskQueue (zone.js:595)\r\n>     at ZoneTask.webpackJsonp.../../../../zone.js/dist/zone.js.ZoneTask.invokeTask [as invoke] (zone.js:502)\r\n>     at invokeTask (zone.js:1364)\r\n\r\n**Is there any configuration of the TCP protocol or the windows firewall that maybe blocking the communication? Is there any TypeORM config on windows server that I'm missing?\r\nAny light on the problem is appreciated!**\r\n\r\nThanks",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/2102/comments",
    "author": "tr0p5",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2018-05-09T07:22:34Z",
        "body": "Have no idea. Its something your local specific. If you think its typeorm issue then I recommend you to try to setup connection using mssql npm package and check if it work to you (this way it will be easier to find a problem)"
      }
    ]
  },
  {
    "number": 2092,
    "title": "[sqlite] default value of columns in migration throw an error",
    "created_at": "2018-05-06T03:05:36Z",
    "closed_at": "2018-09-27T19:37:23Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/2092",
    "body": "**Issue type:**\r\n\r\n- [+] bug report\r\n\r\n**Database system/driver:**\r\n\r\n- [+] `sqlite`\r\n\r\n**TypeORM version:**\r\n\r\n- [+] `latest`\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\n```ts\r\nawait queryRunner.createTable(new Table({\r\n  name: 'User',\r\n  columns: [\r\n    {\r\n      name: 'id',\r\n      type: 'varchar',\r\n      isPrimary: true,\r\n    },\r\n    {\r\n      name: 'verified',\r\n      type: 'boolean',\r\n      default: false,\r\n    }\r\n  ]\r\n}))\r\n```\r\nand enable `migrationsRun` in `createConnection()`.\r\n\r\nThen `UnhandledPromiseRejectionWarning: QueryFailedError: SQLITE_ERROR: default value of column [verified] is not constant` is thrown.",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/2092/comments",
    "author": "kdby-io",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2018-05-07T03:48:45Z",
        "body": "Try to set `default: 0` instead `default: false` - since sqlite does not support real boolean and use tinyint instead you may have this error."
      }
    ]
  },
  {
    "number": 2088,
    "title": "Several names in JoinColumn (ManyToOne relation)",
    "created_at": "2018-05-05T09:28:23Z",
    "closed_at": "2018-09-27T19:36:30Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/2088",
    "body": "[X ] question\r\n**Database system/driver:**\r\n[X] `postgres`\r\n**TypeORM version:**\r\n[X] `0.2.0` (or put your version here)\r\n\r\nHi, \r\nI've got a composite primary key on one table, antoher one has a relation 0,n - 1,1 and get the composite primary key as foreign key.\r\n\r\nHow can I reference, on JoinColumn, several keys.\r\nTo be clearly :\r\n\r\nScore has id_user, id_exercice, date as composite primary key\r\n    0, n\r\n    1, 1\r\nAnd Historic_score.\r\n\r\nSo, in my code, I've got something like this:\r\n\r\nexport class Historic_score {\r\n    @PrimaryGeneratedColumn()\r\n    id: number;\r\n\r\n    @Column()\r\n    date: string;\r\n\r\n    @ManyToOne(type => Score)\r\n    @JoinColumn({name: 'userId', 'exerciceId', 'scoreDateId'})\r\n      user: User,\r\n      exercice: Exercice,\r\n      score: Score\r\n\r\nBut it seems like JoinColumn doesn't accept several referenced name. How could I do?\r\n\r\nThanks to you for help\r\n\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/2088/comments",
    "author": "lukile",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2018-05-05T11:19:09Z",
        "body": "You have to do it this way:\r\n\r\n```ts\r\n@JoinColumn([\r\n    { name: 'userId', referencedColumnName: 'id1' },\r\n    { name: 'exerciceId', referencedColumnName: 'id2' },\r\n    { name: 'scoreDateId', referencedColumnName: 'id3' },\r\n])\r\n```"
      }
    ]
  },
  {
    "number": 2084,
    "title": "Documentation: Find params",
    "created_at": "2018-05-04T13:44:35Z",
    "closed_at": "2018-05-04T20:51:52Z",
    "labels": [
      "question",
      "needs more info"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/2084",
    "body": "**Issue type:**\r\n\r\n[ ] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ x ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n\r\n**TypeORM version:**\r\n\r\n[ x ] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\nIn the documentation, you have the following:\r\n\r\n```\r\nconst user = new User();\r\nuser.firstName = \"Timber\";\r\nuser.lastName = \"Saw\";\r\nuser.age = 25;\r\nawait repository.save(user);\r\n\r\nconst timber = await repository.findOne({ firstName: \"Timber\", lastName: \"Saw\" });\r\n```\r\n\r\nwhich throws an error like \r\n\r\n> Object literal may only specify known properties\r\n\r\nThe following is found later in the docs and does not have this issue.\r\n\r\n`const timber = await repository.findOne({ where: { firstName: \"Timber\", lastName: \"Saw\" }});`\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/2084/comments",
    "author": "cjackson234",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2018-05-04T15:30:47Z",
        "body": "nope, first example is working and we have dozen of tests proven this basic functionality. Please provide a minimal reproduction for this issue."
      },
      {
        "user": "cjackson234",
        "created_at": "2018-05-04T16:34:50Z",
        "body": "I was indeed incorrect. There was more to my case that caused the issue. \r\n\r\nI have a one to many relationship kinda like this\r\n\r\n```\r\n@Entity()\r\nexport class ParentEntity{\r\n    @PrimaryColumn()\r\n    Id: string;\r\n\r\n    @Column()\r\n    Name: string;\r\n\r\n    @OneToMany(type => ChildEntity, c => c.Parent, { cascade: ['insert'] })\r\n    Children: Array<ChildEntity>;\r\n}\r\n\r\n@Entity()\r\nexport class ChildEntity{\r\n    @PrimaryColumn()\r\n    Id: string;\r\n\r\n    @Column()\r\n    Name: string;\r\n\r\n    @ManyToOne(type => ParentEntity, e => e.Children, { cascade: ['insert'] })\r\n    Parent: ParentEntity;\r\n}\r\n```\r\n\r\nThe child table will create a \"parentId\". If I wanted to search for the children without loading data from the parent I would do this:\r\n\r\n`const children= await repository.find({ parentId: id });`\r\n\r\nThis gives me the following error \r\n\r\n> Object literal may only specify known properties, and 'parentId' does not exist in type 'FindConditions<ParentEntity>'.\r\n"
      },
      {
        "user": "cjackson234",
        "created_at": "2018-05-04T16:35:24Z",
        "body": "But it still returns the correct data."
      },
      {
        "user": "pleerock",
        "created_at": "2018-05-04T19:41:59Z",
        "body": "Correct query is:\r\n\r\n```ts\r\nconst children= await repository.find({ parent: { id: id } });\r\n```"
      }
    ]
  },
  {
    "number": 2080,
    "title": "@CreateDateColumn does not auto populate upon insertion.",
    "created_at": "2018-05-04T00:29:39Z",
    "closed_at": "2018-05-10T19:36:40Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/2080",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[x] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[x] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n\r\n**TypeORM version:**\r\n\r\n[ ] `latest`\r\n[ ] `@next`\r\n[x] `0.2.2` \r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nSample entity definition.\r\n```\r\nexport class MyEntity {\r\n    @PrimaryGeneratedColumn()\r\n    public id: number;\r\n\r\n    @Column({type: \"int\"})\r\n    public password_reset_id: number;\r\n\r\n    @Column({type: \"varchar\"})\r\n    public password_hash: string;\r\n\r\n    @CreateDateColumn()\r\n    public created_at: Date;\r\n\r\n    @UpdateDateColumn()\r\n    public updated_at: Date;\r\n\r\n    @Column({type: \"timestamp\"})\r\n    public deleted_at: Date;\r\n}\r\n```\r\n\r\nIt would seem that after updating to version `0.2.2` my `created_at` columns are no longer being populated upon record insertion. Has the `@CreateDateColumn()` decorator changed in someway? Am I missing something completely obvious?\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/2080/comments",
    "author": "jonathan-palumbo",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2018-05-04T10:32:02Z",
        "body": "Can you please check on latest version?"
      },
      {
        "user": "lihue",
        "created_at": "2018-05-04T16:10:28Z",
        "body": "I have the same problem with version 0.2.5"
      },
      {
        "user": "pleerock",
        "created_at": "2018-05-04T19:44:34Z",
        "body": "sounds strange, there are tests which confirm this functionality...  can you please provide a reproduction repo?"
      },
      {
        "user": "jonathan-palumbo",
        "created_at": "2018-05-04T21:14:35Z",
        "body": "I have since rolled back to `0.1.9` which was the version I was on before upgrading to `0.2.2`. Prior to rolling back I had noticed that the `INSERT` queries where using the `DEFAULT` keyword for the `CreatedDateColumns` in `0.2.2` where as in `0.1.9` they contain a string literal of the current timestamp.\r\n\r\nQuery in `0.1.9`:\r\n\r\n```\r\nINSERT INTO `table_name`(`created_at`, `updated_at`) VALUES (?,?) -- PARAMETERS: [\"2018-05-04T21:07:38.711Z\",\"2018-05-04T21:07:38.711Z\"]\r\n```\r\n\r\nQuery in `0.2.2`:\r\n\r\n```\r\nINSERT INTO `table_name`(`created_at`, `updated_at`) VALUES (?,?) -- PARAMETERS: [DEFAULT,DEFAULT]\r\n```\r\n\r\nI am not entirely sure of the mechanism TypeORM is using to get the timestamp in place of `DEFAULT`. Does the database schema need to be altered in anyway to accommodate this? \r\n\r\nFurthermore, for what it is worth we are using mysql 5.6 if that could possible be the difference. If I can find the time I will try to provided an example that exhibits the observed behavior.\r\n\r\n"
      },
      {
        "user": "jonathan-palumbo",
        "created_at": "2018-05-04T21:52:27Z",
        "body": "I forked the repository in the hopes of running the tests locally and perhaps trying the tests against a `mysql 5.6` container. However I cannot seem to get the tests to pass in their current state even though they appear to be passing in the CI build?"
      },
      {
        "user": "pleerock",
        "created_at": "2018-05-05T07:56:01Z",
        "body": "okay, so in 0.1.x we used our own value as a date. Now in 0.2.x we are using column's DEFAULT which is equal to NOW(). You don't have created date because you schema is not in sync."
      },
      {
        "user": "jonathan-palumbo",
        "created_at": "2018-05-07T14:42:56Z",
        "body": "So I should just define defaults for `CURRENT_TIMESTAMP` for both my created and updated  columns in my schema?"
      },
      {
        "user": "pleerock",
        "created_at": "2018-05-09T08:52:53Z",
        "body": "yes"
      },
      {
        "user": "jonathan-palumbo",
        "created_at": "2018-05-10T19:36:40Z",
        "body": "👍 Thanks pleerock "
      },
      {
        "user": "dcworldwide",
        "created_at": "2018-07-26T11:50:50Z",
        "body": "@pleerock  @jonathan-palumbo  Just upgraded to 0.2.x and hit the same issue.\r\n\r\nI can't rebuild the production schema. Instead I need to patch it via sql with zero outage. If I ran the following for all createdAt updatedAt columns (postgres) and then afterwards deploy the new code (with 0.2.x) can I expect any issues?\r\n\r\n`ALTER TABLE ONLY \"public\".\"app_config\" ALTER COLUMN \"createdAt\" SET DEFAULT CURRENT_DATE;`\r\n"
      },
      {
        "user": "mrsauravsahu",
        "created_at": "2020-06-18T14:42:12Z",
        "body": "you can try \r\n```\r\n@CreateDateColumn({ default: () => 'NOW()' })\r\ncreatedAt: Date\r\n```\r\nin your entity. This should generate the right migration."
      },
      {
        "user": "emmyduruc",
        "created_at": "2022-07-05T10:04:25Z",
        "body": "> you can try\r\n> \r\n> ```\r\n> @CreateDateColumn({ default: () => 'NOW()' })\r\n> createdAt: Date\r\n> ```\r\n> \r\n> in your entity. This should generate the right migration.\r\n\r\ni have tried this and it did not work either"
      },
      {
        "user": "mrsauravsahu",
        "created_at": "2022-07-07T12:02:24Z",
        "body": "> > you can try\r\n> > ```\r\n> > @CreateDateColumn({ default: () => 'NOW()' })\r\n> > createdAt: Date\r\n> > ```\r\n> > \r\n> > \r\n> >     \r\n> >       \r\n> >     \r\n> > \r\n> >       \r\n> >     \r\n> > \r\n> >     \r\n> >   \r\n> > in your entity. This should generate the right migration.\r\n> \r\n> i have tried this and it did not work either\r\n\r\nOdd, tried this again. I'm still able to generate the right migration.\r\n\r\n```typescript\r\nimport { Entity, PrimaryGeneratedColumn, Column, CreateDateColumn } from \"typeorm\"\r\n\r\n@Entity()\r\nexport class User {\r\n\r\n    @PrimaryGeneratedColumn()\r\n    id: number\r\n\r\n    @Column()\r\n    firstName: string\r\n\r\n    @Column()\r\n    lastName: string\r\n\r\n    @Column()\r\n    age: number\r\n\r\n    @CreateDateColumn({ default: () => 'NOW()' })\r\n    createdAt: Date\r\n}\r\n```\r\n\r\n```bash\r\nnpm run typeorm -- migration:generate src/migration/InitialCreate -d src/data-source.ts\r\n```\r\n\r\nwhich generated this migration\r\n\r\n```typescript\r\nimport { MigrationInterface, QueryRunner } from \"typeorm\";\r\n\r\nexport class InitialCreate1657194989813 implements MigrationInterface {\r\n    name = 'InitialCreate1657194989813'\r\n\r\n    public async up(queryRunner: QueryRunner): Promise<void> {\r\n        await queryRunner.query(`CREATE TABLE \"user\" (\"id\" SERIAL NOT NULL, \"firstName\" character varying NOT NULL, \"lastName\" character varying NOT NULL, \"age\" integer NOT NULL, \"createdAt\" TIMESTAMP NOT NULL DEFAULT NOW(), CONSTRAINT \"PK_cace4a159ff9f2512dd42373760\" PRIMARY KEY (\"id\"))`);\r\n    }\r\n\r\n    public async down(queryRunner: QueryRunner): Promise<void> {\r\n        await queryRunner.query(`DROP TABLE \"user\"`);\r\n    }\r\n\r\n}\r\n```\r\n\r\n```typescript\r\nimport \"reflect-metadata\"\r\nimport { AppDataSource } from \"./data-source\"\r\nimport { User } from \"./entity/User\"\r\n\r\nAppDataSource.initialize().then(async () => {\r\n\r\n    console.log(\"Inserting a new user into the database...\")\r\n    const user = new User()\r\n    user.firstName = \"Saurav\"\r\n    user.lastName = \"Sahu\"\r\n    user.age = 25\r\n    await AppDataSource.manager.save(user)\r\n    console.log(\"Saved a new user with id: \" + user.id)\r\n\r\n    console.log(\"Loading users from the database...\")\r\n    const users = await AppDataSource.manager.find(User)\r\n    console.log(\"Loaded users: \", users)\r\n}).catch(error => console.log(error))\r\n```\r\n\r\nwhich fills the `createdAt` property with the current timestamp\r\n```\r\n└─$ npm start\r\n\r\n> repro-postgres-auto-populate-dates@1.0.0 start\r\n> ts-node src/index.ts\r\n\r\nInserting a new user into the database...\r\nSaved a new user with id: 1\r\nLoading users from the database...\r\nLoaded users:  [\r\n  User {\r\n    id: 1,\r\n    firstName: 'Saurav',\r\n    lastName: 'Sahu',\r\n    age: 25,\r\n    createdAt: 2022-07-07T06:27:59.987Z\r\n  }\r\n]\r\n```"
      }
    ]
  },
  {
    "number": 2068,
    "title": "Adding an additional column to a closure table",
    "created_at": "2018-05-02T18:42:00Z",
    "closed_at": "2018-09-27T19:36:07Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/2068",
    "body": "**Issue type:**\r\n\r\n[X] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ X `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n\r\n**TypeORM version:**\r\n\r\n[X] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\nIs it possible to add an additional column to a closure table?  We are using a postgres plugin(Citus) to shard data based on distribution keys and need to add an additional column to support sharding for a multi-tenant application.\r\n\r\nDoesn't look like its possible to create the closure table as a separate entity?  I see closure-junction as a table type but can't seem to use it directly?\r\n\r\nIf this isn't something that's currently support any thoughts on a work around or level of effort to implement?  Ideally I would also be able to add this column to the primary key of the generated closure table.\r\n\r\nLooking around seems like there would be a few main changes.\r\n - Create a new decorator type `@TreeAdditionalColumn` ?\r\n - Update ClosureJunctionEntityMetadataBuilder to support adding an additional set of columns.\r\n - Update ClosureSubjectExecutor to correctly insert the closure table additional columns.\r\n\r\nSure I am missing some additional parts but thanks in advance for any thoughts here.\r\n\r\nThanks!",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/2068/comments",
    "author": "ldadams",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2018-05-04T09:18:43Z",
        "body": "no, its not possible. Even if you let's say add this additional column, typeorm won't use it anyway, right?"
      },
      {
        "user": "derblitz",
        "created_at": "2019-05-04T23:52:43Z",
        "body": "In general Citus should work with typeorm, right?"
      },
      {
        "user": "ldadams",
        "created_at": "2019-05-05T03:29:38Z",
        "body": "Yep works fine.  The question was specific to closure tables.  We ended up using an adjacency list. "
      },
      {
        "user": "derblitz",
        "created_at": "2019-05-05T14:53:46Z",
        "body": "OK thanks!"
      }
    ]
  },
  {
    "number": 2052,
    "title": "multiple connections, Active Record, Connection \"default\" was not found",
    "created_at": "2018-04-30T06:03:02Z",
    "closed_at": "2018-09-29T12:07:24Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/2052",
    "body": "**Issue type:**\r\n\r\n[ x ] question\r\n[ ] bug report\r\n[x] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n\r\n [x] `sqlite`\r\n\r\n\r\n**TypeORM version:**\r\n\r\n0.1.21\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\normconfig.json\r\n```\r\n[\r\n  {\r\n    \"type\": \"sqlite\",\r\n    \"name\": \"default\",\r\n    ......\r\n  },\r\n  {\r\n    \"type\": \"sqlite\",\r\n    \"name\": \"test\",\r\n    \"database\": \":memory:\",\r\n    \"entities\": [\"./server/models/*.js\"],\r\n    \"migrations\": [\"migration/*.js\"],\r\n    \"synchronize\": true,\r\n    \"cli\": {\r\n      \"migrationsDir\": \"migration\"\r\n    }\r\n  }\r\n]\r\n```\r\n\r\nmytest.test.js\r\n```\r\nimport { createConnection, getConnection } from 'typeorm'\r\nimport User from '../user'\r\n\r\nit('db', (done) => {\r\n  createConnection(\"test\")\r\n    .then((connection) => {\r\n      const u = new User()\r\n      u.name=\"123\"\r\n      u.save()\r\n      console.log(connection.name)\r\n    })\r\n    .then(() => { \r\n      done()\r\n    })\r\n})\r\n```\r\n ConnectionNotFoundError: Connection \"default\" was not found.\r\n\r\n\r\nBut it work\r\n```\r\nit('db', (done) => {\r\n  createConnection(\"test\")\r\n    .then((connection) => {\r\n      User.useConnection(connection)\r\n      const u = new User()\r\n      u.name=\"123\"\r\n      u.save()\r\n      console.log(connection.name) // test\r\n    })\r\n    .then(() => { \r\n      done()\r\n    })\r\n})\r\n```\r\nIs there a better way, I don't want to call useConnection every time\r\n\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/2052/comments",
    "author": "eightHundreds",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2018-04-30T06:45:40Z",
        "body": "active record is global that's an issue about it. You have to use different models or use data mapper instead if you want to work with multiple connections."
      }
    ]
  },
  {
    "number": 2050,
    "title": "One-to-many using EntitySchema",
    "created_at": "2018-04-29T15:21:41Z",
    "closed_at": "2018-09-29T12:07:01Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/2050",
    "body": "**Issue type:**\r\n\r\n[X ] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ X] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ X] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n\r\n**TypeORM version:**\r\n\r\n[ X] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\nI seek for a long time a documentation on how to set relations using EntitySchema. Saw only very specific docs on setting many-to-many. I simply want to define my \"Job\" entity schema to have multiple \"Payments\" (each job has multiple payments), in other words the job object should have an array of payments[]. so I tried this:\r\n```relations: {\r\n    payments: {\r\n      type: \"one-to-many\",\r\n      target: \"payment\"\r\n    }\r\n  }\r\n```\r\n\r\n+ created a payment entity schema as well. \r\n\r\nBut I get an error message:\r\n\"Entity metadata for Job#payments was not found\"\r\n\r\nAppreciate some help and also a reference, if exists, to a doc that explains about the EntitySchema schema.\r\n<!--\r\n    To answer those questions you need to put \"x\" inside the square brackets, for example:\r\n    [x] `mysql`\r\n    [ ] `postgres`\r\n\r\n    Also, please format your code properly (by taking code blocks into ```ts .... ```)\r\n!>\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/2050/comments",
    "author": "goldbergyoni",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2018-04-30T05:38:18Z",
        "body": "in `target` you need to specify inverse entity name, e.g. \r\n\r\n`Post`:\r\n\r\n```ts\r\n\"images\": {\r\n      \"target\": \"Image\",\r\n      \"type\": \"one-to-many\",\r\n      \"inverseSide\": \"post\"\r\n    }\r\n```\r\n\r\n`Image`:\r\n\r\n```ts\r\n    \"post\": {\r\n      \"target\": \"Post\",\r\n      \"type\": \"many-to-one\",\r\n      \"inverseSide\": \"images\"\r\n    },\r\n```\r\n\r\n\"Post\" and \"Image\" are the names, e.g.:\r\n\r\n```ts\r\n{\r\n  \"name\": \"Image\"\r\n}\r\n```"
      }
    ]
  },
  {
    "number": 2009,
    "title": "Set sqlite database path programmatically.",
    "created_at": "2018-04-24T04:25:32Z",
    "closed_at": "2018-04-24T15:17:21Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/2009",
    "body": "**Issue type:**\r\n\r\n[ x ] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[ x ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n\r\n**TypeORM version:**\r\n\r\n[ x ] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nI'm writing an app in electron, and I want to set the path to my sqlite databse like this:\r\n`${require('os').homedir()}/.HyperAI/database.sqlite`\r\n\r\nIs there a code example of how to do this programmatically?\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/2009/comments",
    "author": "cjackson234",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2018-04-24T05:24:34Z",
        "body": "use create connection and pass connection options:\r\n\r\n```ts\r\nimport {createConnection} from \"typeorm\";\r\n\r\ncreateConnection({\r\n     type: \"sqlite\",\r\n     database: `${require('os').homedir()}/.HyperAI/database.sqlite`\r\n});\r\n```"
      },
      {
        "user": "cjackson234",
        "created_at": "2018-04-24T15:17:18Z",
        "body": "Thanks, @pleerock ! "
      }
    ]
  },
  {
    "number": 2008,
    "title": "“CONSTRAINT PK_payment_vendor PRIMARY KEY (vendor_id ASC)“",
    "created_at": "2018-04-24T03:37:44Z",
    "closed_at": "2018-04-24T06:11:03Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/2008",
    "body": "**Issue type:**\r\n\r\n[ ] question\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `mysql` / `mariadb`\r\n\r\n**TypeORM version:**\r\n\r\n[ ] `0.1.20` \r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nIn MYSQL, create constraint is: CONSTRAINT PK_payment_vendor PRIMARY KEY (vendor_id ASC)\r\n\r\nhow to write in Typeorm? Thanks!\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/2008/comments",
    "author": "JingMo",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2018-04-24T05:23:37Z",
        "body": "you don't need to define a CONSTRAINT with typeorm. Instead you create an entity and add a property with `@PrimaryColumn` decorator applied."
      },
      {
        "user": "JingMo",
        "created_at": "2018-04-24T06:10:31Z",
        "body": "Thank you！"
      }
    ]
  },
  {
    "number": 2002,
    "title": "Support fo Oracle V11?",
    "created_at": "2018-04-23T17:12:32Z",
    "closed_at": "2018-09-29T16:08:20Z",
    "labels": [
      "question",
      "driver: oracle"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/2002",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[ ] bug report\r\n[? ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[x ] `oracle`\r\n[ ] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n\r\n**TypeORM version:**\r\n\r\n[ ] `latest`\r\n[ ] `@next`\r\n[x ] `0.1.20` (or put your version here)\r\n\r\n\r\nI have successfully started using typeorm with a mysql back end for development. However, my customer requires us to use their existing oracle backend. Their configuration  is limited to Oracle Version 11. However, when I try to initialize entities for the oracle backend I get an error telling me that I COMPATIBLE parameter needs to be 12.0.0.0.0 or greater.\r\n\r\nFrom the error message, this looks to be because the driver is trying to create a table wiht \"SQL identity columns\"?\r\n\r\nI could see no discussion of required versions for oracle in the code repository. Am I missing something, or am I required to have oracle v12?\r\n\r\nTIA,\r\nBill\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\n<!--\r\n    To answer those questions you need to put \"x\" inside the square brackets, for example:\r\n    [x] `mysql`\r\n    [ ] `postgres`\r\n\r\n    Also, please format your code properly (by taking code blocks into ```ts .... ```)\r\n!>\r\n\r\n\r\nBill",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/2002/comments",
    "author": "wdmcgrory",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2018-04-23T19:16:30Z",
        "body": "correct, we do not support old oracle versions"
      },
      {
        "user": "hohler",
        "created_at": "2018-07-11T18:41:10Z",
        "body": "That's bad, because Oracle XE is only available as Version 11. V12 was never released and V18 is not yet finished. How are people able to test locally with a free version if it's not supported but there is no other option?"
      },
      {
        "user": "pleerock",
        "created_at": "2018-07-11T18:46:55Z",
        "body": "we do run oracle tests in a docker container, so you should be able to do same as well."
      },
      {
        "user": "StetHD",
        "created_at": "2018-09-30T12:32:12Z",
        "body": "please open this case, I have two remote oracle 11g setup, for one of them it's working fine, for the other it gets ORA-00904"
      }
    ]
  },
  {
    "number": 1985,
    "title": "Invalid input syntax for type uuid with typeorm@0.2.0 and postgres",
    "created_at": "2018-04-21T05:41:04Z",
    "closed_at": "2018-04-26T15:32:21Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/1985",
    "body": "**Issue type:**\r\n\r\n[x] bug report\r\n\r\n**Database system/driver:**\r\n\r\n[x] `postgres`\r\n\r\n**TypeORM version:**\r\n\r\n[x] ^0.2.0\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nCode:\r\n\r\n```typescript\r\nimport { Repository } from \"typeorm\";\r\n\r\nexport const queryBatchFunction = <T extends { id: string }>(repository: Repository<T>) => async (\r\n  keys: string[],\r\n): Promise<(T | null)[]> => {\r\n  const docs = await repository\r\n    .createQueryBuilder(\"TableName\")\r\n    .where(`TableName.id IN (:keys)`, { keys })\r\n    .getMany();\r\n\r\n  return keys.map(k => docs.find(d => d.id === k) || null);\r\n};\r\n```\r\n\r\nLog:\r\n\r\n```\r\nquery failed: SELECT \"TableName\".\"id\" AS \"TableName_id\", \"TableName\".\"name\" AS \"TableName_name\", \"TableName\".\"email\" AS \"TableName_email\", \"TableName\".\"password\" AS \"TableName_password\", \"TableName\".\"versionKey\" AS \"TableName_versionKey\", \"TableName\".\"createdAt\" AS \"TableName_createdAt\", \"TableName\".\"updatedAt\" AS \"TableName_updatedAt\" FROM \"users\" \"TableName\" WHERE \"TableName\".\"id\" IN ($1) -- PARAMETERS: [[\"f9aeae36-39f0-4063-9866-75b8504c754e\",\"bc7d42bc-3f7f-4502-8e23-751bf5c191b0\",\"950514f5-0f82-4575-bbe9-88d52e99019b\",\"5ad3603c-4db9-463d-9176-9f01a96cf6e4\",\"3997e43a-50ee-423d-a16a-42fd5615f6c2\",\"c5d3f0fe-0cef-4a29-951c-c869ce345e6e\",\"054135f8-14bd-41b9-accb-f0426ede3278\"]]\r\n```\r\n\r\nError message:\r\n\r\n```\r\nerror: { error: invalid input syntax for type uuid: \"{\"f9aeae36-39f0-4063-9866-75b8504c754e\",\"bc7d42bc-3f7f-4502-8e23-751bf5c191b0\",\"950514f5-0f82-4575-bbe9-88d52e99019b\",\"5ad3603c-4db9-463d-9176-9f01a96cf6e4\",\"3997e43a-50ee-423d-a16a-42fd5615f6c2\",\"c5d3f0fe-0cef-4a29-951c-c869ce345e6e\",\"054135f8-14bd-41b9-accb-f0426ede3278\"}\"\r\n    at Connection.parseE (C:\\Users\\klnhat\\workspace\\my-hackernews-server\\node_modules\\pg\\lib\\connection.js:545:11)\r\n    at Connection.parseMessage (C:\\Users\\klnhat\\workspace\\my-hackernews-server\\node_modules\\pg\\lib\\connection.js:370:19)\r\n    at Socket.<anonymous> (C:\\Users\\klnhat\\workspace\\my-hackernews-server\\node_modules\\pg\\lib\\connection.js:113:22)\r\n    at Socket.emit (events.js:180:13)\r\n    at addChunk (_stream_readable.js:274:12)\r\n    at readableAddChunk (_stream_readable.js:261:11)\r\n    at Socket.Readable.push (_stream_readable.js:218:10)\r\n    at TCP.onread (net.js:581:20)\r\n  name: 'error',\r\n  length: 369,\r\n  severity: 'ERROR',\r\n  code: '22P02',\r\n  detail: undefined,\r\n  hint: undefined,\r\n  position: undefined,\r\n  internalPosition: undefined,\r\n  internalQuery: undefined,\r\n  where: undefined,\r\n  schema: undefined,\r\n  table: undefined,\r\n  column: undefined,\r\n  dataType: undefined,\r\n  constraint: undefined,\r\n  file: 'uuid.c',\r\n  line: '137',\r\n  routine: 'string_to_uuid' }\r\n```\r\n\r\nIt used to work fine with older version, but when I updated typeorm to 0.2.0, the problem occurs.",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/1985/comments",
    "author": "lednhatkhanh",
    "comments": [
      {
        "user": "lednhatkhanh",
        "created_at": "2018-04-21T05:50:15Z",
        "body": "I found the solution:\r\n\r\n```typescript\r\nexport const queryBatchFunction = <T extends { id: string }>(repository: Repository<T>) => async (\r\n  keys: string[],\r\n): Promise<(T | null)[]> => {\r\n  const docs = await repository\r\n    .createQueryBuilder(\"TableName\")\r\n    .where(`TableName.id IN (:...keys)`, { keys })\r\n    .getMany();\r\n\r\n  return keys.map(k => docs.find(d => d.id === k) || null);\r\n};\r\n```\r\n\r\nNote the `:...key` thing, but I don't see this's being mentioned anywhere in the changelog... Am I missing anything?"
      },
      {
        "user": "dcworldwide",
        "created_at": "2018-04-22T00:03:53Z",
        "body": "I remember seeing it in the cl"
      },
      {
        "user": "pleerock",
        "created_at": "2018-04-23T05:36:56Z",
        "body": "This change was required to support native postgres arrays. From changelog:\r\n\r\n> breaking change on how array parameters work in queries - now instead of (:param) new syntax must be used (:...param)."
      },
      {
        "user": "lednhatkhanh",
        "created_at": "2018-04-26T15:32:21Z",
        "body": "So then I'm going to close this issued now"
      }
    ]
  },
  {
    "number": 1984,
    "title": "Startup schema synchronization deletes data automatically - expected behavior?",
    "created_at": "2018-04-21T04:29:12Z",
    "closed_at": "2018-09-29T11:58:35Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/1984",
    "body": "**Issue type:**\r\n\r\nI wanted to get some clarification on behavior I witnessed. I was pleasantly surprised to see TypeORM able to automatically create and apply a migration to add a column to my table if I add a property to a model. I thought to myself that if that same behavior works in reverse, it would be safe for TypeORM to throw an error if there was data in that column and it were to be removed from the model. I was wrong though, I noticed that it just deletes the column along with any data in it when you start the app again.\r\n\r\nI was wondering, is this intended behavior? Is synchronization considered dangerous, and should we be using manual migrations instead?\r\n\r\n[*] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[*] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n\r\n**TypeORM version:**\r\n\r\n[ ] `latest`\r\n[ ] `@next`\r\n[*] `0.2.0` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\n* Have a table's schema include a nullable column\r\n* Add data to at least one row in that table for that column\r\n* Remove the property from the class definition for that model\r\n* Start app with synchronization enabled\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/1984/comments",
    "author": "mattwelke",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2018-04-23T05:55:39Z",
        "body": ">  it would be safe for TypeORM to throw an error if there was data in that column and it were to be removed from the model.\r\n\r\nno, it won't. If you remove column from the model it means you want to remove it and all its data, otherwise why did you remove it. (for the cases when you want to rename a column you need to make single-change migrations, this is the only way orm can determine if you renamed column and not added a new one and removed old one, there are other requirements as well, but this one is the most basic, JFYI)\r\n\r\n>  Is synchronization considered dangerous, and should we be using manual migrations instead?\r\n\r\nany migration considered dangerous, working with data is always a serious thing and you have to confirm before executing it. On production the flow can be:\r\n\r\n* you generate a migration\r\n* you check if it won't break your data by analyzing generated queries\r\n* you append additional logic if you want to change something\r\n* you run the migration"
      }
    ]
  },
  {
    "number": 1977,
    "title": "What's the difference between query.changeColumn and query.renameColumn?",
    "created_at": "2018-04-20T08:20:12Z",
    "closed_at": "2018-12-10T16:34:34Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/1977",
    "body": "**Issue type:**\r\n\r\n[ ] question\r\n\r\n**Database system/driver:**\r\n\r\n\r\n[ ] `mysql`\r\n\r\n\r\n**TypeORM version:**\r\n\r\n[ ] `latest`\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nToday, I want to change comment description of one column, so I use `query.changeColumn()`, it seems so right, but not as my expect. Framework drop my column and create a new for me. It's unnecessary exactly. \r\n\r\nThen, I use `query.renameColumn()`, I got the right response. But, don't u think it's strange? It seems just will rename my column name.",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/1977/comments",
    "author": "fwh1990",
    "comments": [
      {
        "user": "fwh1990",
        "created_at": "2018-04-20T08:27:53Z",
        "body": "I don't think `drop and create` is the best way to migrate. You will delete all data in this column, that's  very very dangerous operation. May refactor this method to: `dropAndCreateColumn()`"
      },
      {
        "user": "pleerock",
        "created_at": "2018-04-23T06:27:59Z",
        "body": ">  I want to change comment description of one column, so I use query.changeColumn(), it \r\n\r\ndo you only change the name? Are you sure about it?"
      },
      {
        "user": "fwh1990",
        "created_at": "2018-04-23T06:46:34Z",
        "body": "I don't want to change my column's name, I want to change my column's comment schema. I think, or somebody also think, we should use `queryRunner.changeCloumn()`. \r\n\r\nBut now, we can only use `queryRunner.renameCloumn()`, because `queryRunner.changeCloumn()`  will drop my column at first, and then create it again."
      },
      {
        "user": "fwh1990",
        "created_at": "2018-04-23T06:50:52Z",
        "body": "The method `queryRunner.renameCloumn()` seems like a method only change column name. But it can do more things now. Maybe the method name `renameCloumn` is not proper here."
      },
      {
        "user": "pleerock",
        "created_at": "2018-04-23T07:15:45Z",
        "body": "> because queryRunner.changeCloumn() will drop my column at first, and then create it again.\r\n\r\neverything is much more complicated as it may seem. There are reasons behind this behaviour. Column is dropped if you change type or length, because its required or operation may fail. If you only change name it will simply rename it."
      },
      {
        "user": "fwh1990",
        "created_at": "2018-04-23T07:43:53Z",
        "body": "That may be dangerous. You can't drop column because the data in this column will gone, and the developers may don't realize that. So I suggest you refactor the method's name. \r\n\r\nIf I just change length from 20 to 30, or change type from int to float, that's ok. When migrate fail, the developers should migrate the data by themselves  before they change the column schema.\r\n\r\n### Just don't drop column dangerously.\r\n\r\nIf somebody who really want to drop it's column, he can use `queryRunner.dropColumn`."
      },
      {
        "user": "sabau",
        "created_at": "2018-10-16T13:30:13Z",
        "body": "I agree, I had the same issue few days ago, luckily we found out this behaviour in the logs before applying migrations to production but the naming was making me think of an ALTER command."
      },
      {
        "user": "havenchyk",
        "created_at": "2018-12-10T16:34:34Z",
        "body": "I'm closing this issue for housekeeping purposes, if something is not clear yet, just continue the conversation or post a message in slack"
      },
      {
        "user": "jyang0110",
        "created_at": "2019-03-22T02:01:54Z",
        "body": "> The method `queryRunner.renameCloumn()` seems like a method only change column name. But it can do more things now. Maybe the method name `renameCloumn` is not proper here.\r\n\r\n\r\n@fwh1990 You mentioned that renameColumn can do more things. What else can it do other than change column name? Any suggestion is appreciated."
      },
      {
        "user": "greenreign",
        "created_at": "2020-05-14T14:46:05Z",
        "body": "Agree, this almost just caused a catastrophe in our application.  The naming is counter-intuitive.  It should be something like `replaceColumn`.  The change column implies an update/change to a column in place.  Further, the SQL `CHANGE COLUMN` command is an update that would not lose data.  It stands that anyone familiar with SQL would expect `changeColumn` would be executing a `CHANGE COLUMN`  and NOT A DROP!!"
      },
      {
        "user": "fwh1990",
        "created_at": "2020-05-14T17:15:43Z",
        "body": "This is a huge trap, and the author seems don't want to fix it. **Am I right?** I turn to use sequelize these years, and have no idea what happened to typeorm.\r\n\r\nAnd I will not reuse typeorm before it fixes this issue. Sorry."
      },
      {
        "user": "chief-austinc",
        "created_at": "2022-08-26T14:52:01Z",
        "body": "+1"
      }
    ]
  },
  {
    "number": 1966,
    "title": "how about setting column options nullable true by default",
    "created_at": "2018-04-19T09:13:09Z",
    "closed_at": "2018-04-19T12:48:53Z",
    "labels": [
      "question",
      "by design"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/1966",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[x] `mssql`\r\n[x] `mysql` / `mariadb`\r\n[x] `oracle`\r\n[ ] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `websql`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\nIn common databases such as mysql、sql server and so on, when we add a new column in a table, its nullable property is true by default.\r\nIn a table with many columns, nullable columns is always the majority. however, we have to add {nullable: true} for every one of them.\r\nHow about setting column options nullable true by default?",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/1966/comments",
    "author": "ReganHe",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2018-04-19T09:47:26Z",
        "body": "no, they are non nullable and it is by design. We will follow an inclusion strategy instead of exclusion. "
      }
    ]
  },
  {
    "number": 1945,
    "title": "invalid input syntax for uuid for PrimaryGeneratedColumn(\"uuid\") when initializing property",
    "created_at": "2018-04-15T01:01:39Z",
    "closed_at": "2018-04-19T12:55:18Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/1945",
    "body": "**Issue type:**\r\n\r\n[ ] question\r\n[X] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[X] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `websql`\r\n\r\n**TypeORM version:**\r\n\r\n[ ] `latest`\r\n[X] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\n```ts\r\n\r\nexport class EntityBase {\r\n  @PrimaryGeneratedColumn(\"uuid\") public id: string = \"\"; // NOTICE: I'm initializing this property to \"\"\r\n  @CreateDateColumn() public created: Date = new Date();\r\n  @UpdateDateColumn() public updated: Date = new Date();\r\n  @Column() public inactive: boolean = false;\r\n}\r\n\r\n@Entity(\"user_accounts\")\r\nexport class User extends EntityBase {\r\n  @Index(\"username_unique\", { unique: true })\r\n  @Column()\r\n  public username: string = \"\";\r\n\r\n  @Column() public passwordHash: string = \"\";\r\n  public password: string | undefined;\r\n}\r\n\r\n```\r\n\r\nTrying to insert entries of the above entity type but getting an error when calling `save` on the repository. My TypeScript project is set to `strict: true`, which requires property initialization.  I recently upgraded to `typeorm@next` (currently `0.2.0-alpha.46`) and began having this problem.  Before, I was running an earlier version of 0.2.0 and using `sqlite` instead of `postgres`. \r\n\r\nIn one of my other entities, I was initializing a relation property to empty array (`[]`) and received an error in the console, which was very clear that I shouldn't initialize that property.  \r\n\r\nI remove the initialization code and everything is now working.\r\n\r\nIs this something that TypeOrm could detect and throw a clearer error for?\r\n\r\n```\r\nQueryFailedError: invalid input syntax for uuid: \"\"\r\n    at new QueryFailedError (/src/error/QueryFailedError.ts:7:9)\r\n    at Query.callback (/src/driver/postgres/PostgresQueryRunner.ts:170:26)\r\n    at Query.handleError (/node_modules/pg/lib/query.js:143:17)\r\n    at Connection.connectedErrorHandler (/node_modules/pg/lib/client.js:132:26)\r\n    at emitOne (events.js:116:13)\r\n    at Connection.emit (events.js:211:7)\r\n    at Socket.<anonymous> (/pg/lib/connection.js:117:12)\r\n    at emitOne (events.js:116:13)\r\n    at Socket.emit (events.js:211:7)\r\n    at addChunk (_stream_readable.js:263:12)\r\n```",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/1945/comments",
    "author": "marpstar",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2018-04-16T08:18:38Z",
        "body": "`uuid` column value is generated by database in case if you did not specify your own value. In your case you specified your own value (empty string) and it thinks that you pass your own uuid and does not use default database's uuid generation. But since empty string is not equal to uuid you have an error. Solution is to generate a proper uuid or remove value assignment. \r\n\r\nAlso I recommend you to consider value of strict property initialization and put \"!\" to your properties instead of initialization if you think that value is higher then overhead.  "
      },
      {
        "user": "pleerock",
        "created_at": "2018-04-19T12:55:18Z",
        "body": "Let me know if I did not answer your question."
      },
      {
        "user": "marpstar",
        "created_at": "2018-04-19T15:22:20Z",
        "body": "thanks @pleerock. this is a satisfactory answer for me. I appreciate your help."
      }
    ]
  },
  {
    "number": 1944,
    "title": "Is it possible to use the joined entity instead?",
    "created_at": "2018-04-14T18:58:59Z",
    "closed_at": "2018-04-16T15:07:38Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/1944",
    "body": "**Issue type:**\r\n\r\n[ x] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[x ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `websql`\r\n\r\n**TypeORM version:**\r\n\r\n[ ] `latest`\r\n[ ] `@next`\r\n[2.0.0] `0.x.x` (or put your version here)\r\n\r\nI wasn't able to gather from the docs and this question go no traction on SO.\r\n\r\n**Question:**\r\n\r\nI've got an auth_token table and user table. I'd like to resolve a user from a given auth token using the query builder. The issue I'm having is that after joining, the return type still thinks it's going to be an AuthToken. Is there a way to tell the query builder to use the joined entity instead?\r\n\r\n```\r\nreturn await this.authTokenRepository\r\n  .createQueryBuilder()\r\n  .where({\r\n    token: token\r\n  })\r\n  .innerJoinAndSelect(User, 'user')\r\n  .getOne();\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/1944/comments",
    "author": "micah-williamson",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2018-04-16T08:21:19Z",
        "body": "If you want a user, you need to select use and join token, are you doing your query from the wrong side. If you need a user, you take a user repository, join token, say where token is equal to token and thats all.\r\n\r\n```ts\r\nreturn await this.userRepository\r\n  .createQueryBuilder(\"user\")\r\n  .innerJoinAndSelect(\"user.authToken\", \"authToken\", \"authToken.token = :token\", { token })\r\n  .getOne();\r\n```"
      },
      {
        "user": "micah-williamson",
        "created_at": "2018-04-16T15:07:38Z",
        "body": "Makes sense. I arrived at this eventually but wanted to leave the question open in case it were possible to resolve the user in the way I was trying. Thank you"
      }
    ]
  },
  {
    "number": 1935,
    "title": "Question about migrating data to new system buillt using typeorm.",
    "created_at": "2018-04-13T17:41:06Z",
    "closed_at": "2018-04-19T12:56:13Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/1935",
    "body": "**Issue type:**\r\n\r\n[ x] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[x ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `websql`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\nNot really much of an issue with the framework (really has helped speed up my development, you guys are doing a great job) just a bit of confusion on how to do something. I have an excel spreadsheet that has all my initial data and relationships in it. Things are associated accordingly in there with id's and what not and I want to migrate the data to a database built using typeorm.\r\n\r\nWhat is the best way to migrate existing data to a database built using typeorm such that I can ensure the current primary keys and relationships are preserved?\r\n\r\n\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/1935/comments",
    "author": "KrisChambers",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2018-04-16T08:54:14Z",
        "body": "there are multiple ways but most safe probably is to create a migration script, load all the data from your old database (using separate connection and raw queries), create entities, relations, etc. via code and call `save` for them. e.g. everything is manual"
      },
      {
        "user": "pleerock",
        "created_at": "2018-04-19T12:56:13Z",
        "body": "Let me know if you still have questions."
      }
    ]
  },
  {
    "number": 1933,
    "title": "Mongo: name in columnOptions is not being passed to find query",
    "created_at": "2018-04-13T15:30:53Z",
    "closed_at": "2018-04-19T12:56:43Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/1933",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[x] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[x] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `websql`\r\n\r\n**TypeORM version:**\r\n\r\n[ ] `latest`\r\n[ ] `@next`\r\n[x] `0.1.20` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nI have an entity that has a name db name mapping to property name using ColumnOptions:\r\n\r\n```typescript\r\n @Column({\r\n    name: 'node_id',\r\n  })\r\n  nodeId!: string;\r\n```\r\n\r\nI have a query using a repository for this model\r\n\r\n```typescript\r\n  async getPageAssociationsForNodeId(nodeId: string) {\r\n    const pageAssociations = await this.pageAssociationRepository.find({\r\n      nodeId, //typed to Model so this cant be \"node_id\"\r\n    });\r\n\r\n    return pageAssociations;\r\n  }\r\n```\r\n\r\nWhen I issue this query, looking at the logs in mongo, `nodeId` is being passed in the query, not `node_id` (name provided in column options):\r\n\r\n```js\r\n{\r\n\t\"op\" : \"query\",\r\n\t\"ns\" : \"<myDb>.PageAssociation\",\r\n\t\"command\" : {\r\n\t\t\"find\" : \"PageAssociation\",\r\n\t\t\"filter\" : {\r\n\t\t\t\"nodeId\" : \"12345\"\r\n\t\t},\r\n\t\t\"$db\" : \"slingshot\"\r\n\t},\r\n\r\n```\r\n\r\n`nodeId` is not the column name in the collection so no results are being returned.\r\n\r\nMy questions are:\r\n\r\n1) am I using find appropriately?\r\n2) is it wrong to assume that the ColumnOptions.name will be used instead of the property name of the class\r\n3) if the answers to the above are \"yes\" and \"no\" respectively, is this a bug?\r\n\r\n\r\n\r\n\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/1933/comments",
    "author": "mcMickJuice",
    "comments": [
      {
        "user": "mcMickJuice",
        "created_at": "2018-04-14T15:51:34Z",
        "body": "Looking through the code, it doesn't look like the column metadata is being taken into account for the `find` path, or any of the other `find` methods.  The name mapping DOES work with `save` operation but not the `insert` operations.\r\n"
      },
      {
        "user": "pleerock",
        "created_at": "2018-04-16T08:23:47Z",
        "body": "You need to use names you are using in the database, not names you are using in the models. Mongodb queries are very dynamic and its impossible to know when to replace your column names in your queries. I don't recommend to use `name` at all to prevent all this kinds of confusions. "
      },
      {
        "user": "pleerock",
        "created_at": "2018-04-19T12:56:43Z",
        "body": "I think this question was answered. "
      },
      {
        "user": "mcMickJuice",
        "created_at": "2018-04-19T13:12:18Z",
        "body": "I understand that Mongo queries CAN be dynamic, but if you're using an ORM, doesn't this enforce a structure on your collection structure and property names?  In what situation when running a \"find\" query would this column mapping between property and name in your model and collection property not work?  Embedded documents?\r\n\r\nIf your position is that you don't think name property should be used in mongo, I would suggest then adding that to the docs and removing the functionality entirely from the MongoRepository/manager.  As I mentioned above, this mapping works when running a \"save\" operation but not any querying functions. This should be considered a bug.\r\n\r\nFWIW, I'm willing to contribute to this repo to implement this feature.  I'm just wondering what the edge cases are that prevent you from wanting to have this implemented."
      },
      {
        "user": "pleerock",
        "created_at": "2018-04-19T15:00:14Z",
        "body": ">  I would suggest then adding that to the docs and removing the functionality entirely from the MongoRepository/manager. \r\n\r\nyes I was thinking about it\r\n\r\n> \"save\" operation but not any querying functions. This should be considered a bug.\r\n\r\nits not a bug, its just designed this way and there are reasons of such design (I described before)\r\n\r\n> I'm willing to contribute to this repo to implement this feature. I'm just wondering what the edge cases are that prevent you from wanting to have this implemented.\r\n\r\nokay, how do you think you can handle all kind of queries are replace property names to proper ones?"
      },
      {
        "user": "mcMickJuice",
        "created_at": "2018-04-20T13:35:49Z",
        "body": "There are two issues here:\r\n\r\n### Save operation\r\n\r\nIf the name column is respected on the save operation but no other query, that is a bug. How am I supposed to use the `find` operation if I have the name property respected on save but not on querying?  Either support the name feature 100% or don't support it at all.\r\n\r\n### Dynamic queries\r\n\r\nYes, mongo supports dynamic queries and polymorphic collections but if you're using an ORM with models that are typed, aside from the aggregate (which is a custom query and shouldn't be typed to the Entity) and query (which isnt supported) methods, what's dynamic about these queries? \r\n Methods like find and findOne are executed in the context of a specific collection, so what would be dynamic about these queries?  The properties should all be the same in the collection so where's the issue with column mappings if the queries themselves are typed to the Entity?\r\n\r\nPlease remember that I am trying to help here.  I've offered to look into this and am asking for specific examples of where this name mapping won't work.  In my experience, this is a standard feature in ORMs and it would be great if it were supported in TypeORM for mongo.  I still fail to see why it can not be done as all you're telling me is that mongo is dynamic and therefore it's not possible."
      },
      {
        "user": "pleerock",
        "created_at": "2018-04-23T06:23:41Z",
        "body": "> aside from the aggregate (which is a custom query and shouldn't be typed to the Entity) and query (which isnt supported) methods\r\n\r\nI don't see any app that won't use `query` method. 99% apps need more then find dummy `{ x: y } ` operations. So by fixing {x: y} problem you'll cover only 1% of problems and bring a confusion for other 99%. \r\n\r\nThe proper solution is to remove this \"name\" property - this feature has almost zero real benefit and 100% confusion. "
      },
      {
        "user": "matthijn",
        "created_at": "2019-02-26T09:30:41Z",
        "body": "I'm more confused about not having this feature actually. In our system, I want to move from a homemade 'orm' to `typeorm`. But our database fields are all already `snake_cased`. While in typescript I'd like all my properties to be `camelCased`. \r\n\r\nI'm confused about why it is 'confusing' to have this feature on mongo because on other databases it is supported. I'm failing to see why mongo is different in this regard, or why that is wanted. \r\n\r\nImplementing a `NamingStrategyInterface` doesn't seem to work either, it does work for the table names, and the `columnName` method in the naming strategy is called, but it's result are ignored. "
      },
      {
        "user": "TakeshiDaveau",
        "created_at": "2020-07-21T14:27:50Z",
        "body": "Why don't make this behaviour configurable ?\r\n\r\nThe ability to decorrelate the technical database name of an attribute from its object representation in programmation language is a key feature of an ORM. The \"don't use `name`\" doesn't match my conception of a professional ORM.\r\n\r\nI disagree with the fact that 99% of the query are made over `query` in real app. When you create a CRUD API you need this simple `find` query. \r\nMoreover for me it's more dangerous to apply an unpredictable behaviour for simple things than for complexe things."
      },
      {
        "user": "Monstermash28425R1",
        "created_at": "2025-01-31T11:35:08Z",
        "body": "so this wasn't solved at the end? i still find this behavior when working with mongo"
      }
    ]
  },
  {
    "number": 1930,
    "title": "@beforeUpdate @afterUpdate not triggered on Array modification",
    "created_at": "2018-04-13T09:18:15Z",
    "closed_at": "2018-04-19T12:57:00Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/1930",
    "body": "**Issue type:**\r\n\r\n[*] question\r\n[*] feature request\r\n\r\n**Database system/driver:**\r\n\r\n[*] `postgres`\r\n\r\n**TypeORM version:**\r\n\r\n[*] `latest`\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nEntity listeners are not triggered when pushing a new Entity to another Entity's Array.\r\n\r\ne.g.\r\n```TypeScript\r\naudioItem.comments.push(audioComment);\r\nawait audioRepository.save(audioItem);\r\n```\r\n\r\nWould it be possible for this to become a feature in the long run or is there another approach to reproduce this functionality?\r\n\r\nObviously checking the whole of the Array would become too slow on a large set, so would there be any chance to watch the Array length changing?\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/1930/comments",
    "author": "2xAA",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2018-04-16T09:06:47Z",
        "body": "you need to handle this manually. Listeners are only notify about database columns changes, not relations."
      },
      {
        "user": "pleerock",
        "created_at": "2018-04-19T12:57:00Z",
        "body": "Let me know if you still have questions."
      },
      {
        "user": "velociraptor111",
        "created_at": "2020-04-10T19:49:24Z",
        "body": "how do you suggest we handle this manually?"
      }
    ]
  },
  {
    "number": 1916,
    "title": "Find where for sub relation fields",
    "created_at": "2018-04-12T08:34:30Z",
    "closed_at": "2018-04-12T09:54:06Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/1916",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[x] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `websql`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nHello!\r\nIs that possible to do something like this ? \r\n```\r\nconst [results,count] = await this.repository.findAndCount({\r\n\twhere: {\r\n\t\trelation: [\r\n\t\t\t{\r\n\t\t\t\tsubRelation: [\r\n\t\t\t\t\tsubRelationField: value\r\n\t\t\t\t]\r\n\t\t\t}\r\n\t\t]\r\n\t}\r\n});\r\n```\r\nI want to get and count rows, but params which i need to match is one of nested relation fields.\r\n\r\n\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/1916/comments",
    "author": "hyze2d",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2018-04-12T09:10:34Z",
        "body": "you need to use QueryBuilder for this purpose. It will be much cleaner btw."
      },
      {
        "user": "hyze2d",
        "created_at": "2018-04-12T09:51:24Z",
        "body": "Thank you! Can you give some example ? How to query this with query builder."
      },
      {
        "user": "pleerock",
        "created_at": "2018-04-12T09:53:22Z",
        "body": "see docs on site on how to use query builder. Basically its something like this:\r\n\r\n```ts\r\nrepository.createQueryBuilder(\"photo\")\r\n    .innerJoin(\"photo.albums\", \"album\", \"album.name = :name\", { name })\r\n    .getManyAndCount()\r\n```"
      },
      {
        "user": "hyze2d",
        "created_at": "2018-04-12T09:54:06Z",
        "body": "Great! Thanks."
      }
    ]
  },
  {
    "number": 1912,
    "title": "Advanced where options in find",
    "created_at": "2018-04-11T11:06:33Z",
    "closed_at": "2018-04-19T08:02:21Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/1912",
    "body": "**Issue type:**\r\n\r\n[ ] question\r\n[ ] bug report\r\n[*] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[*] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `websql`\r\n\r\n**TypeORM version:**\r\n\r\n[*] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\ni am using this library for a while now, and its awesome! \r\ni mainly used php/doctrine in my project and i can see alot of similarity that came from there in typeorm which is great, one feature that i like in typeorm is the lack of use of the custom repository, its not a \"must have\" like anther frameworks, the \"find\" query is cappable of doing basic queries without the need for custom repository, what i wish it had, is just -alittle- more complex options such as:\r\n\r\nThis line will retrieve customers with status id equal to 1 2 or 3 (IN(1,2,3)\r\n```\r\nthis.customerRepository.find({\r\n   where: {\r\n      status_id: [1, 2 ,3]\r\n   }\r\n})\r\n``` \r\n\r\nor some mongo style stuff:\r\n```\r\nthis.customerRepository.find({\r\n   where: {\r\n      age: { gt: 10 },   }\r\n})\r\n```",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/1912/comments",
    "author": "roeehershko",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2018-04-11T11:15:59Z",
        "body": "It is supported in `@next` `(npm i typeorm@next)`. More info in #1101."
      }
    ]
  },
  {
    "number": 1906,
    "title": "When to start supporting the latest version of the mongodb",
    "created_at": "2018-04-10T16:29:22Z",
    "closed_at": "2018-04-11T10:47:16Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/1906",
    "body": "",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/1906/comments",
    "author": "xieshiCoder",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2018-04-11T10:47:16Z",
        "body": "It is already supported in `next`. Try it via `npm i typeorm@next`"
      }
    ]
  },
  {
    "number": 1903,
    "title": "Cordova/Sqlite maximum depth 1000",
    "created_at": "2018-04-10T11:32:43Z",
    "closed_at": "2018-04-11T10:56:56Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/1903",
    "body": "**Issue type:**\r\n\r\n[ ] question\r\n[ x] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[x ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `websql`\r\n\r\n**TypeORM version:**\r\n\r\n[ ] `latest`\r\n[ ] `@next`\r\n[x ] `0.1.20` (or put your version here)\r\n\r\nI am getting this error when saving a table A that cascade updates to a table B: \"could not prepare statement (1 Expression tree is too large (maximum depth 1000))\". I think this error is present in sqlite whe more than 1000 params are used. If I print sql, only 999 are used.\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/1903/comments",
    "author": "jondediego",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2018-04-11T10:56:56Z",
        "body": "Use `@next` where persistence is optimized A LOT. Try it via `npm i typeorm@next`. This issue must be fixed in there."
      },
      {
        "user": "masseelch",
        "created_at": "2018-04-24T13:47:51Z",
        "body": "@pleerock I have the same isseu with `npm i typeorm@next`. Should i open a new issue?"
      },
      {
        "user": "pleerock",
        "created_at": "2018-04-24T15:03:20Z",
        "body": "yes, with more details and reproduction example please"
      },
      {
        "user": "masseelch",
        "created_at": "2018-04-26T14:50:49Z",
        "body": "Will do after my vacation"
      }
    ]
  },
  {
    "number": 1893,
    "title": "Postgres creating stored procedures from migrations and calling them?",
    "created_at": "2018-04-05T19:48:51Z",
    "closed_at": "2018-04-19T13:05:52Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/1893",
    "body": "**Issue type:**\r\n\r\n[ X ] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ X ] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `websql`\r\n\r\n**TypeORM version:**\r\n\r\n[ X ] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\nNot a bug, but I am using postgres and cant see any documentation on postgres stored procedures/ functions. I'm looking for, how to call them and create the procedures during a migration.\r\n\r\nI have a procedure that creates a timestamptz (timestamp with timezone) for when a entity is created and updated, any example on how to do this?",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/1893/comments",
    "author": "nshCore",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2018-04-11T11:38:32Z",
        "body": "Its a specific functionality and specific functionality must be used... specific way. To create a procedure you need to use a `query` method that executes raw queries. To insert or update can try to use `insert` and `update` methods of repository which are able to do following:\r\n\r\n```ts\r\nrepository.insert({\r\n      ...,\r\n      myDate: () => \"timestamptz()\" // RAW SQL, you'll be able to use your procedure\r\n})\r\n```\r\n\r\nIt should work in most scenarios, but for some you'll still need to use `query` method."
      },
      {
        "user": "pleerock",
        "created_at": "2018-04-19T13:05:52Z",
        "body": "Let me know if you still have questions."
      },
      {
        "user": "hypeofpipe",
        "created_at": "2021-01-15T17:14:49Z",
        "body": "Is there any way to create stored procedures right in the migrations with TypeORM?"
      }
    ]
  },
  {
    "number": 1864,
    "title": "Support for de-serialization using arguments constructor or factory method",
    "created_at": "2018-03-31T16:20:54Z",
    "closed_at": "2018-04-17T04:58:41Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/1864",
    "body": "**Issue type:**\r\n\r\n[x ] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ x] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `websql`\r\n\r\n**TypeORM version:**\r\n\r\n[x ] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Question**\r\nHi. I have an entity with an arguments constructor. The constructor enforces some validation by calling the setter method for the required fields. This tries to prevent having instances of this entity in inavalid states at any given point of the execution. Problem is, during de-serialization Typeorm invokes my constructor ignoring the required arguments, causing the assertion to fail and the loading process ends unsuccessful.\r\n\r\nSo my question is: Is there a way to work around this? I would like to either register a custom Factory Method that Typeorm should use during deserialization or instruct Typeorm how to invoke my constructor passing the required arguments.\r\n\r\nThanks!\r\n\r\nHere's a snippet to contextualize:\r\n\r\n```typescript\r\n@Entity()\r\nclass Person {\r\n\r\n  @Column()\r\n  private _name: string\r\n\r\n  constructor ( name: string ) {\r\n    this.name = name;\r\n  }\r\n\r\n  set name(name: string) {\r\n    assert.ok(name, 'Persons name cannot be empty!');\r\n    this._name = name;\r\n  }\r\n\r\n}\r\n\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/1864/comments",
    "author": "julianosam",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2018-03-31T20:01:02Z",
        "body": "Change your constructor to:\r\n\r\n```ts\r\nconstructor ( name: string ) {\r\n    this._name = name;\r\n  }\r\n```\r\n\r\nand you should not get the assertion error."
      },
      {
        "user": "julianosam",
        "created_at": "2018-03-31T20:43:14Z",
        "body": "@pleerock Thanks for your suggestion. However, I want to have the assertion at instantiation time so to avoid creating invalid instances. If I do as you suggest, instantiations like the one below are valid:\r\n\r\n```typescript\r\nconst p = new Person(null); // invalid, all persons should have a name\r\n```\r\nLooking at your suggestion, is there a way I can instruct Typeorm to invoke my constructor passing the persons name as the argument? Or alternatively, is there a way to configure a factory method that Typeorm could use during data loading?\r\n\r\nThanks!\r\n\r\n"
      },
      {
        "user": "pleerock",
        "created_at": "2018-04-02T06:25:18Z",
        "body": ">  Or alternatively, is there a way to configure a factory method that Typeorm could use during data loading?\r\n\r\nNo, and I don't think there will be.\r\n\r\nLooks like your problems with language and understanding of types with a bit of overengineering applied. \r\n\r\n> const p = new Person(null); // invalid, all persons should have a name\r\n\r\nThis WON'T be possible since `name: string` in your constructor does not allow you `null` values."
      },
      {
        "user": "julianosam",
        "created_at": "2018-04-02T07:34:51Z",
        "body": "> This WON'T be possible since name: string in your constructor does not allow you null values.\r\n\r\nNot sure what you mean here. Just like in any other language, TS accepts null as a valid value of any type, including string. I want to prevent that by asserting a valid string was passed.\r\n\r\nIf you are talking about enabling ``strictNullChecks``, I guess that could help. However, this still:\r\n\r\n1. Won’t prevent instantiating Person with the empty string. (also not a valid name)\r\n2. Disables nullable fields everywhere, even for the ones that may make sense (ie non required)\r\n\r\nAlso, enabling strictNullChecks does not prevent typeorm to continue ignoring the required name argument of the constructor of my Person class anyways. Do you have any suggestions for this?\r\n\r\nI am really trying to follow the DDD entity concept, keeping all my invariants within the entity. Having a way to customize the desserialization would be a great addition to the framework in my opinion."
      },
      {
        "user": "pleerock",
        "created_at": "2018-04-02T08:35:50Z",
        "body": "See it as a requirement to have constructor-less entities or a entities with optional constructor arguments. Of course we can add this feature, but it looks redundant to me in most designs. If you want to implement this functionality, im okay with it.\r\n\r\nDDD does not enforce you to define models the way you do it. If you want a class OOP-design then I suggest you to use factory class or factory method. The fact that TypeORM won't use them isn't an issue - your model is stored the way user initialize them using factories, so mismatch is not possible."
      },
      {
        "user": "pleerock",
        "created_at": "2018-04-17T04:58:41Z",
        "body": "I think this can be closed."
      }
    ]
  },
  {
    "number": 1837,
    "title": "get CustomRepository with dependency resolve",
    "created_at": "2018-03-28T03:23:54Z",
    "closed_at": "2018-03-28T06:58:48Z",
    "labels": [
      "question",
      "can be closed?"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/1837",
    "body": "**Issue type:**\r\n\r\n[ ] question\r\n[ ] bug report\r\n[x] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `websql`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:*\r\n\r\nIt's a feture request. \r\nI found that typeorm use \"new\" when create a  \"CustomRepository\",\r\nso can not use typedi or other Container in CustomRepository.\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/1837/comments",
    "author": "xujif",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2018-03-28T06:44:52Z",
        "body": "It is by design. Repositories can't be global because they have specific dependencies, e.g. multiple instances of `CustomRepositoryX` class which may have their own managers, connection instances,  transactional query runners."
      }
    ]
  },
  {
    "number": 1827,
    "title": "Question on query building to select a single column of the original table",
    "created_at": "2018-03-26T20:48:43Z",
    "closed_at": "2018-03-28T15:34:01Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/1827",
    "body": "```\r\n@Entity()\r\nexport class Script {\r\n    @PrimaryGeneratedColumn()\r\n    id: number;\r\n\r\n    @Column()\r\n    name: string;\r\n\r\n    @OneToMany(type => Session, session => session.script)\r\n    sessions: Session[];\r\n\r\n    @ManyToMany(type => User)\r\n    @JoinTable()\r\n    users: User[];\r\n}\r\n```\r\n\r\n```\r\n@Entity()\r\nexport class User {\r\n    @PrimaryGeneratedColumn()\r\n    id: number;\r\n\r\n    @Column()\r\n    username: string;\r\n\r\n    @OneToMany(type => Session, session => session.user)\r\n    sessions: Session[];\r\n}\r\n```\r\n\r\nI am trying to select the Script.name of users who have Script.\r\n\r\n```\r\n    async findScripts(username: string): Promise<Script[]> {\r\n        return await this.scriptRepository\r\n            .createQueryBuilder('script')\r\n            .select('script.name')\r\n            .leftJoin('script.users', 'user')\r\n            .where('user.username = :name', { name: username })\r\n            .getMany();\r\n    }\r\n```\r\n\r\n```\r\n[\r\n  {\r\n    \"name\": \"Script A\",\r\n    \"users\": [\r\n      \r\n    ]\r\n  },\r\n  {\r\n    \"name\": \"Script B\",\r\n    \"users\": [\r\n      \r\n    ]\r\n  }\r\n]\r\n```\r\n\r\nIt works, only issue is my left join is also adding an unwanted empty users array, I'm sure it is something dumb I overlooked. Any tips?\r\n\r\nBeen playing around with NestJS / TypeORM today overall very pleased and happy with this library, hats off to the contributors this is absolutely fantastic.\r\n\r\nThanks.\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/1827/comments",
    "author": "Tyler-V",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2018-03-27T04:34:25Z",
        "body": "First, you must select primary columns, its a requirement. Second, you need to use `leftJoinAndSelect` if you want users to be returned in the array"
      },
      {
        "user": "Tyler-V",
        "created_at": "2018-03-27T14:11:21Z",
        "body": "Hey thanks for the reply @pleerock \r\n\r\nI should clarify, I am trying to only get the names of the scripts and not the users array however that is the relationship between the two tables.\r\n\r\nThis is what I am trying to achieve, how would I write this in typeorm using the query builder?\r\n\r\n```\r\nSELECT DISTINCT name FROM script\r\nLEFT JOIN script_users_user ON script_users_user.scriptId\r\nLEFT JOIN user ON script_users_user.userId\r\nWHERE username = 'User A'\r\n```\r\n\r\n```\r\n[\r\n  {\r\n    \"name\": \"Script A\",\r\n  },\r\n  {\r\n    \"name\": \"Script B\",\r\n  }\r\n]\r\n```\r\n"
      },
      {
        "user": "pleerock",
        "created_at": "2018-03-28T07:16:55Z",
        "body": "I don't understand why you need two joins when you don't use them. Is `username` part of `script` ?\r\n\r\nSomething like this shall work:\r\n\r\n```ts\r\nthis.scriptRepository\r\n            .createQueryBuilder('script')\r\n            .select('script.name', 'name')\r\n// add joins and wheres here\r\n            .groupBy(\"user.name\")\r\n            .getRawMany();\r\n ```"
      },
      {
        "user": "Tyler-V",
        "created_at": "2018-03-28T15:24:33Z",
        "body": "@pleerock the difference in all of this was using getMany() vs getRawMany()\r\n\r\nThis indeed returns what I am looking for, returning the entities returned from getRawMany() only returns the script names.\r\n\r\n```\r\n        return await this.scriptRepository\r\n            .createQueryBuilder('script')\r\n            .select('name')\r\n            .leftJoin('script.users', 'user')\r\n            .where('user.username = :name', { name: username })\r\n            .getRawMany();\r\n```\r\n```\r\n[\r\n  {\r\n    \"name\": \"Script A\"\r\n  },\r\n  {\r\n    \"name\": \"Script B\"\r\n  }\r\n]\r\n```"
      },
      {
        "user": "pleerock",
        "created_at": "2018-03-28T15:34:08Z",
        "body": "btw, can you try it on `@next`? On `@next` for sure it should not return empty users array if you are not using `leftJoinAndSelect`"
      },
      {
        "user": "pleerock",
        "created_at": "2018-03-28T15:42:15Z",
        "body": "`@next` is the latest version (0.2.0 final will be released soon) that contains lot of changes and fixed we have made in past 6 month. Try it via `npm i typeorm@next`"
      },
      {
        "user": "Tyler-V",
        "created_at": "2018-03-28T15:45:05Z",
        "body": "Using @next,\r\n\r\n```\r\n        return await this.scriptRepository\r\n            .createQueryBuilder('script')\r\n            .select('name')\r\n            .leftJoinAndSelect('script.users', 'user')\r\n            .where('user.username = :name', { name: username })\r\n            .getMany();\r\n```\r\nReturns just an empty array\r\n\r\n```\r\n[\r\n\r\n]\r\n```"
      },
      {
        "user": "pleerock",
        "created_at": "2018-03-28T15:50:36Z",
        "body": "Something is definitely wrong, can you please show your script and user entities?"
      },
      {
        "user": "Tyler-V",
        "created_at": "2018-03-28T15:52:49Z",
        "body": "```\r\n@Entity()\r\nexport class Script {\r\n    @PrimaryGeneratedColumn()\r\n    id: number;\r\n\r\n    @Column({ unique: true })\r\n    name: string;\r\n\r\n    @OneToMany(type => Session, session => session.script)\r\n    sessions: Session[];\r\n\r\n    @ManyToMany(type => User)\r\n    @JoinTable()\r\n    users: User[];\r\n}\r\n```\r\n\r\n```\r\n@Entity()\r\nexport class User {\r\n    @PrimaryGeneratedColumn()\r\n    id: number;\r\n\r\n    @Column({ unique: true })\r\n    email: string;\r\n\r\n    @Column({ unique: true })\r\n    username: string;\r\n\r\n    @Column()\r\n    password: string;\r\n\r\n    @OneToMany(type => Session, session => session.user)\r\n    sessions: Session[];\r\n}\r\n```"
      },
      {
        "user": "pleerock",
        "created_at": "2018-03-28T15:55:48Z",
        "body": "ah, wait. QueryBuilder code is not correct. Correct is:\r\n\r\n```ts\r\n        return await this.scriptRepository\r\n            .createQueryBuilder('script')\r\n            .select('script.name')\r\n            .leftJoinAndSelect('script.users', 'user')\r\n            .where('user.username = :name', { name: username })\r\n            .getMany();\r\n```\r\n\r\nAlso, try \r\n\r\n```ts\r\n        return await this.scriptRepository\r\n            .createQueryBuilder('script')\r\n            .select('script.name')\r\n            .leftJoin('script.users', 'user')\r\n            .where('user.username = :name', { name: username })\r\n            .getMany();\r\n```"
      },
      {
        "user": "Tyler-V",
        "created_at": "2018-03-28T16:02:51Z",
        "body": "1. Returns the script name and full user entity, instead of just the script.name as desired.\r\n\r\n```\r\n[\r\n  {\r\n    \"name\": \"Script A\",\r\n    \"users\": [\r\n      {\r\n        \"id\": 1,\r\n        \"email\": \"email1\",\r\n        \"username\": \"user1\",\r\n        \"password\": \"password1\"\r\n      }\r\n    ]\r\n  },\r\n  {\r\n    \"name\": \"Script B\",\r\n    \"users\": [\r\n      {\r\n        \"id\": 1,\r\n        \"email\": \"email1\",\r\n        \"username\": \"user1\",\r\n        \"password\": \"password1\"\r\n      }\r\n    ]\r\n  }\r\n]\r\n```\r\n\r\n2. Returns the desired result, just the script names.\r\n\r\n```\r\n[\r\n  {\r\n    \"name\": \"Script A\"\r\n  },\r\n  {\r\n    \"name\": \"Script B\"\r\n  }\r\n]\r\n```"
      },
      {
        "user": "pleerock",
        "created_at": "2018-03-28T16:08:33Z",
        "body": "okay so everything as expected"
      },
      {
        "user": "Tyler-V",
        "created_at": "2018-03-28T16:16:43Z",
        "body": "Yes looks good! Let me know if I can help with anything else @pleerock "
      },
      {
        "user": "webmobiles",
        "created_at": "2018-12-04T05:33:34Z",
        "body": "@Tyler-V what about select only the field users.email ? where use '.select()' ?\r\nis not working with me, only select direct fields from the join table. thanks"
      },
      {
        "user": "jaimedeverall",
        "created_at": "2020-03-20T11:20:15Z",
        "body": "Hi there, is there any follow up on @webmobiles question. I can select fields of `script` just fine but can't select the fields of the relation table, `user`"
      },
      {
        "user": "elle86a",
        "created_at": "2020-07-29T08:53:23Z",
        "body": "I Have the same issues, can't select the leftjoin column in version 0.2.25"
      },
      {
        "user": "webmobiles",
        "created_at": "2020-07-29T09:34:14Z",
        "body": "try to do:\r\n\r\n      .select([\r\n        'secondtable.name as name2',\r\n        'SUM(investments.amount) as startup_amount_invested_in',\r\n        'COUNT(lists) as startup_list_count'\r\n      ])"
      },
      {
        "user": "lakhandeshpande",
        "created_at": "2020-08-14T03:07:09Z",
        "body": "   return await this.scriptRepository\r\n            .createQueryBuilder('script')\r\n            .select('script.name')\r\n            .leftJoin('script.users', 'user')\r\n            .where('user.username = :name', { name: username })\r\n            .getMany();\r\n\r\nI would like to know how this get executed or called? In which file I should write this code to execute?"
      }
    ]
  },
  {
    "number": 1778,
    "title": "Two table join that have no relations",
    "created_at": "2018-03-19T08:01:52Z",
    "closed_at": "2018-03-29T10:07:49Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/1778",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[x] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `websql`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\nThere is no relations between the user table and the photo table\r\nThis code returns only user's data, how can we return to photo data?\r\n```\r\nconst user = await createQueryBuilder(\"user\")\r\n    .leftJoinAndSelect(\"photos\", \"photo\", \"photo.userId = user.id\")\r\n    .getMany();\r\n```",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/1778/comments",
    "author": "shengxq",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2018-03-26T11:24:02Z",
        "body": "Use `leftJoinAndMap` method instead. But I would really recommend you to execute a separate query instead."
      }
    ]
  },
  {
    "number": 1775,
    "title": "leftJoinAndMapMany not working without entity to correctly map data.",
    "created_at": "2018-03-17T20:22:07Z",
    "closed_at": "2018-03-29T10:01:58Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/1775",
    "body": "**Issue type:**\r\n\r\n[ ] question\r\n[ X] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ X] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `websql`\r\n\r\n**TypeORM version:**\r\n\r\n[X ] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\nSome background. I have an `AuditTrailRecord` entity, with a OneToMany relationship with `Customer`\r\n```ts   \r\n@OneToMany(type => Customer, customer => customer.auditTrailRecord)\r\n  customers: Customer[]; \r\n```\r\n\r\nThen I also have a view table: customers_with_history.  I want to use this view to join customers, like in this example:\r\n```ts\r\n        let auditTrailRecord = await getManager()\r\n        .createQueryBuilder(AuditTrailRecord, 'auditTrailRecord')\r\n        .where('auditTrailRecord.id = :id', { id: id })\r\n        .leftJoinAndMapMany('auditTrailRecord.customers', 'customer_with_history', 'customers', 'customers.\"auditTrailRecordId\"=auditTrailRecord.id')\r\n        .getOne();\r\n```\r\n\r\nunlike in other examples I've seen 'customer_with_history' here is the name of a view. I am expecting auditTrailRecord to have a key `customer` from the `customer_with_history` table, but it does not.\r\n\r\nResulting query is missing the `AS` query syntax that exists when joining an entity, such as\r\n```\"customers\".\"auditTrailRecordId\" AS \"customers_auditTrailRecordId\" FROM \"audit_trail_record\" \"auditTrailRecord\" LEFT JOIN \"customer\"...```\r\n\r\nIf this difference is intended behavior of how to handle join statements with a table name instead of an entity, this should be included in the documentation.\r\n\r\n<!--\r\n    To answer those questions you need to put \"x\" inside the square brackets, for example:\r\n    [x] `mysql`\r\n    [ ] `postgres`\r\n\r\n    Also, please format your code properly (by taking code blocks into ```ts .... ```)\r\n!>\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/1775/comments",
    "author": "chrisstpierre",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2018-03-26T11:32:02Z",
        "body": "Aliases are not generated for non-entities because of multiple issues with them. I really recommend you to execute a separate query and map data manually - this approach is much effective."
      }
    ]
  },
  {
    "number": 1728,
    "title": "create of ConnectionManager and createConnection work differently",
    "created_at": "2018-03-09T07:37:51Z",
    "closed_at": "2018-03-09T08:05:20Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/1728",
    "body": "**Issue type:**\r\n\r\n[ ] question\r\n[x] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[x] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `websql`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n[ ] `@next`\r\n[x] `0.1.16` \r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\n```typescript\r\nconst connectionString = \"your connection string\";\r\n(async () => {\r\n    const c = new ConnectionManager();\r\n    try {\r\n        // It doesn't work!!!\r\n        // const db = await c.create({type: \"mysql\", url: connectionString});\r\n\r\n        // But it works!!!\r\n        const db = await createConnection({type: \"mysql\", url: connectionString});\r\n        console.log(await db.query(`SELECT 1`));\r\n    } catch (ex) {\r\n        console.error(ex);\r\n    }\r\n    // console.log(a);\r\n})();\r\n```\r\n\r\nI think they both have to show the same behavior, but they don't.\r\nWhat's the difference between `create` of ConnectionManager and `createConnection`?",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/1728/comments",
    "author": "worudso",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2018-03-09T08:05:20Z",
        "body": "Just take a look on source. `create` does not return you a promise, it simply return you instance of `Connection`. Basically create is equal to `new Connection(options)` and registering this connection inside connection manager."
      }
    ]
  },
  {
    "number": 1724,
    "title": "Using QueryRunner control state of Transactions of multiple databases",
    "created_at": "2018-03-08T19:07:50Z",
    "closed_at": "2018-03-12T08:04:41Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/1724",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[x] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `websql`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\nI need to use transactions in two different databases, is that ok? Is there a better way?\r\n```\r\n        const main_QueryRunner = mian_connection.createQueryRunner();\r\n        const sub_QueryRunner = sub_connection.createQueryRunner();\r\n\r\n        await main_QueryRunner.startTransaction();\r\n        await sub_QueryRunner.startTransaction();\r\n        try {\r\n            .....\r\n            \r\n            await main_QueryRunner.commitTransaction();\r\n            await sub_QueryRunner.commitTransaction();\r\n        } catch (err) {\r\n            await main_QueryRunner.rollbackTransaction();\r\n            await sub_QueryRunner.rollbackTransaction();\r\n            return;\r\n        } finally {\r\n            await main_QueryRunner.release();\r\n            await sub_QueryRunner.release();\r\n        }\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/1724/comments",
    "author": "shengxq",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2018-03-09T07:26:26Z",
        "body": "yes, it is okay."
      }
    ]
  },
  {
    "number": 1719,
    "title": "DTOs while using typeorm",
    "created_at": "2018-03-08T15:58:27Z",
    "closed_at": "2018-03-12T08:04:47Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/1719",
    "body": "Hi,\r\n\r\nWe are developing our application using typeorm(MSSQL database) and angular 5 as frontend framework. When i checked the sample programs , everything has just a controller method where entities are directly passed as API response.  If we look at old applications, most of them have a domain(like our entities), services, controllers and DTO's(this will be send as API response). How can we acheive such DTO object in typeorm. Since we dont like to expose database as such to front end. Is there any library to do so? Or you are suggesting to go ahead with controller and entity framework? Which one would the best practice ? What kind of architecture will be best suited for typeorm\r\n\r\n\r\n[X ] question \r\n\r\n**Database system/driver:**\r\n \r\n[X ] `mssql` \r\n\r\n**TypeORM version:**\r\n\r\n[ ] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n ",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/1719/comments",
    "author": "KrishnaAnanthi",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2018-03-09T07:45:42Z",
        "body": "Samples are just simple samples written in a short and understandable way.\r\n\r\nSo, your question is not related to typeorm anyhow, typeorm is architecture agnostic, choose whatever architecture you prefer or your app requires. \r\n\r\nIf you ask me I usually don't do separate DTOs since data I have in my models in db are direct representation of what I need on the frontend and I think separate layer brings complexity and redundancy in most cases. If you want to control what you are going to return to the frontend, you simply do not select / remove not needed properties before sending to the frontend. I create separate models for the frontend only when its completely different data rather then what I have in the database."
      }
    ]
  },
  {
    "number": 1706,
    "title": "When you do an update with an alias, alias is not in the generated SQL",
    "created_at": "2018-03-06T18:42:03Z",
    "closed_at": "2018-03-12T08:08:26Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/1706",
    "body": "**Issue type:**\r\n\r\n[ ] question\r\n[ x] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[x ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `websql`\r\n\r\n**TypeORM version:**\r\n\r\n[ ] `latest`\r\n[ ] `@next`\r\n[ x] `0.1.11` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nWhen we have an alias in create query builder, for selects it correctly adds the alias in the SQL Statement.  For updates however the alias is left out:\r\n\r\nUpdateQueryBuilder {connection: Connection, queryRunner: undefined, expressionMap: QueryExpressionMap}\r\nalias:\"Transfer\"\r\nconnection:Connection {isConnected: true, migrations: Array(0), subscribers: Array(0), …}\r\n\r\nGenerated SQL for an update:\r\n\"UPDATE `transfer` SET  ....\r\n\r\nHere the name of the table is provided, but not the alias with the upper case T.\r\n\r\nWe created the query builder like this:\r\nlet myquery = this.dbConnection\r\n                .getRepository(Transfer)\r\n                .createQueryBuilder()\r\n\r\nIf we use this syntax for selects it creates a select statement with an alias with a capital T.\r\nHowever on updates the alias is missing and it goes to the table name which is lowercase T.\r\n\r\nThe behavior between selects and updates should be consitent.  \r\n\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/1706/comments",
    "author": "swilliams-a3digital",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2018-03-09T08:29:18Z",
        "body": "> The behavior between selects and updates should be consitent.\r\n\r\nonly some databases support aliases in update statements, that's why they are being cut out in the update query builder."
      }
    ]
  },
  {
    "number": 1688,
    "title": "@next QueryBuilder IN clause error",
    "created_at": "2018-03-02T01:39:03Z",
    "closed_at": "2018-03-02T06:54:02Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/1688",
    "body": "**Issue type:**\r\n\r\n[ ] question\r\n[ x] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[x ] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `websql`\r\n\r\n**TypeORM version:**\r\n\r\n[ ] `latest`\r\n[ x] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce:**\r\nWhen use IN clause using QueryBuilder and pass array of numbers, an error happens:\r\n\r\n```\r\ntypeorm:query:error parameters: [ [ 1, 2, 3 ] ]\r\ntypeorm:query:error error:  { error: invalid input syntax for integer: \"{\"1\",\"2\",\"3\"}\"\r\n```\r\nQuey:\r\n`query.andWhere(\"entity.id IN (:idInParam)\", { idInParam: [1, 2, 3] })`\r\n\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/1688/comments",
    "author": "hugoserrana",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2018-03-02T03:15:15Z",
        "body": "Syntax for array parameter has been changed. New syntax for array parameters is:\r\n\r\n```ts\r\n\"entity.id IN (:...idInParam)\"\r\n```\r\n\r\nPurpose of this change is to support native arrays, before it was not possible to use them for example this way:\r\n\r\n```ts\r\n\"entity.id = ANY(:idInParam)\"\r\n```\r\n\r\nNow it is."
      },
      {
        "user": "hugoserrana",
        "created_at": "2018-03-02T03:44:29Z",
        "body": "This worked! \r\nI didn't knew that syntax had changed. \r\nThanks @pleerock!!"
      },
      {
        "user": "pleerock",
        "created_at": "2018-03-02T06:54:02Z",
        "body": "yw"
      }
    ]
  },
  {
    "number": 1684,
    "title": "Bulk Update with typeorm",
    "created_at": "2018-03-01T15:15:47Z",
    "closed_at": "2018-03-29T09:04:15Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/1684",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[x] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `websql`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\nIs is possible to perform bulk updates using typeorm? I mean use data from a different table to update my table based a JOIN. Currently, I am bumping up against the fact that an update query builder does not support inner joins\r\n\r\n```\r\nUPDATE TableOne\r\nSET TableOne.TotalNumber = TableTwo.FirstNumber+TableTwo.SecondNumber\r\nFROM TableOne JOIN TableTwo\r\nON TableOne.PrimaryKey = TableTwo.PrimaryKey\r\n```\r\n\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/1684/comments",
    "author": "muamichali",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2018-03-02T07:17:19Z",
        "body": "no, joins are not supported by query builder, you'll need to execute raw query."
      }
    ]
  },
  {
    "number": 1673,
    "title": "How to wirte 'decimal(5,2)' in entity?",
    "created_at": "2018-02-28T07:42:24Z",
    "closed_at": "2018-02-28T16:51:37Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/1673",
    "body": "**Issue type:**\r\n\r\n[ ] question\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `mysql` / `mariadb`\r\n\r\n**TypeORM version:**\r\n\r\n[ ] `latest`\r\n\r\n**How to wirte 'decimal(5,2)' in entity?:**\r\n\r\nI want to set the field in the table. the field type is decimal, store like data: $123.23.\r\n\r\nIn entity, how to wirte?\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/1673/comments",
    "author": "kaimiyang",
    "comments": [
      {
        "user": "AlexMesser",
        "created_at": "2018-02-28T08:08:29Z",
        "body": "```typescript\r\n@Column(\"decimal\", { precision: 5, scale: 2 })\r\nvalue: number;\r\n```"
      },
      {
        "user": "kaimiyang",
        "created_at": "2018-02-28T08:17:50Z",
        "body": "@AlexMesser thank you!\r\nmany times I write like this : \r\n`@Column({\r\n    type: 'decimal',\r\n    precision: 5,\r\n    scale: 2,\r\n    default: 0,\r\n  })\r\n`\r\nand then `desc tablename`, result in:\r\n`\r\ndecimal(5,0)\r\n`\r\n\r\nnow is okey!"
      },
      {
        "user": "rinoymjoseph",
        "created_at": "2018-09-03T06:11:17Z",
        "body": "For me below one worked..\r\n` @Column({ name: \"R1ContentWidth\", type: \"decimal\", precision: 2, scale: 2, nullable: true })\r\n    r1ContentWidth: number`\r\nresulted in a column with Decimal(2,2) in DB"
      }
    ]
  },
  {
    "number": 1648,
    "title": "How do I create a connection from ormconfig.json by name?",
    "created_at": "2018-02-26T13:26:45Z",
    "closed_at": "2018-03-12T08:12:30Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/1648",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `websql`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nI have multiple connections outlined in my ormconfig.json file. I now want to create one of those connections (not all of them). How can I create a specific connection from my ormconfig.json file by name?\r\n\r\nI don't see anywhere in the documentation or on Google where it says how to do this. It sounds like my options for creating a connection are:\r\n\r\n1. Use `createConnection()` with no parameters. This creates the connection using options in ormconfig.json, but this will always create the connection with no name, or the one named 'default'.\r\n2. Use `createConnection()` and pass in all of the connection options, but this does not use ormconfig.json.\r\n3. Use `createConnections()` with no parameters. This creates all of the connections in ormconfig.json, and then I would have to find the one I need. I don't want to do this, because most of the time I don't need all of the connections for a particular process.\r\n\r\nI suppose this may turn into a feature request if this functionality doesn't already exist, but I'm very surprised to not find this question asked before now.",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/1648/comments",
    "author": "HillTravis",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2018-02-26T14:27:08Z",
        "body": "This sounds like a specific request. You need to use third method to create all connections. If you don't need some of connections, you can parse ormconfig (take a look on `createConnections` source code) and filter out what you don't need and call `createConnection` for each of filtered connection."
      }
    ]
  },
  {
    "number": 1646,
    "title": "dynamic entity",
    "created_at": "2018-02-25T09:43:08Z",
    "closed_at": "2018-02-27T09:29:03Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/1646",
    "body": "**Issue type:**\r\n[x] feature request\r\n\r\n**Database system/driver:**\r\n[x] `postgres`\r\n\r\n**TypeORM version:**\r\n[x ] `latest`\r\n\r\nI have dynamic schemes in the form of json models. The system administrator can add or remove some columns in the table. I just can not find a way to implement such opportunities.\r\n1) load entity from json model\r\n2) update entitiy when changing json model\r\n3) use the updated entity\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/1646/comments",
    "author": "TripleMap",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2018-02-26T05:22:12Z",
        "body": "you need to re-create connection.\r\n\r\n```ts\r\nconst connection = getConnection();\r\nawait connection.close();\r\nawait connection.connect();\r\n```"
      },
      {
        "user": "pleerock",
        "created_at": "2018-02-27T09:29:03Z",
        "body": "Let me know if you still have questions."
      },
      {
        "user": "guotie",
        "created_at": "2018-04-08T01:16:28Z",
        "body": "re-create connection cannot dynamic create Entity."
      }
    ]
  },
  {
    "number": 1639,
    "title": "beforeUpdate subscriber, check updated field",
    "created_at": "2018-02-23T11:28:26Z",
    "closed_at": "2018-03-29T09:00:08Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/1639",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ x] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `websql`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nI want to hash user.password in beforeUpdate subscriber.\r\n\r\nIs there any way to know that password field has been updated? So I will hash password only then.\r\n\r\n```\r\nbeforeUpdate(event: InsertEvent<User>) {\r\n    event.entity.password = 'new hashed password';\r\n  }\r\n```",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/1639/comments",
    "author": "MardariG",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2018-02-26T05:44:42Z",
        "body": "for now only option you have is to query your entity from the database and compare with your current entity value."
      }
    ]
  },
  {
    "number": 1608,
    "title": "Create from nested object with lazy relation",
    "created_at": "2018-02-19T04:30:29Z",
    "closed_at": "2018-02-19T08:59:03Z",
    "labels": [
      "question",
      "comp: lazy loading"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/1608",
    "body": "**Issue type:**\r\n\r\n[] question\r\n[ ] bug report\r\n[x] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[x] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `websql`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nGiven\r\n```ts\r\nimport { BaseEntity, ManyToOne, OneToMany } from 'typeorm'\r\n\r\nclass Author extends BaseEntity {\r\n  @Column()\r\n  name: string\r\n\r\n  @OneToMany(() => Post)\r\n  posts: Promise<Post[]>\r\n}\r\n\r\nclass Post extends BaseEntity {\r\n  @ManyToOne(() => Author, 'posts', { cascadeInsert: true })\r\n  author: Promise<Author>\r\n}\r\n\r\nawait Post.create({author: Promise.resolve({name: 'author1'})}).save\r\n```\r\n\r\nGot\r\n```\r\nSTART TRANSACTION\r\nexecuting query:  INSERT INTO \"author\" DEFAULT VALUES  RETURNING \"id\"\r\nquery failed:  INSERT INTO \"author\" DEFAULT VALUES  RETURNING \"id\"\r\nerror:  { error: null value in column \"name\" violates not-null constraint\r\n...\r\n```\r\n\r\nBut eager relation works:  `Post.create({author: {name: 'author1'}})`\r\n\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/1608/comments",
    "author": "gutenye",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2018-02-19T07:05:11Z",
        "body": "You need to use following syntax:\r\n\r\n```ts\r\nawait Post.create({author: PromiseUtils.create({name: 'author1'})}).save\r\n```\r\n\r\nLazy relations aren't what people usually need to use. Just be aware."
      },
      {
        "user": "gutenye",
        "created_at": "2018-02-21T10:44:14Z",
        "body": "@pleerock\r\n It works, thanks.\r\n\r\nI use `typeorm` with `GraphQL`. If I understand it right, Lazy relations are the only way to use inside `GraphQL` resolvers. \r\n\r\nBut lazy relations are more complex than eager relations in many cases, is there a way to use eager relations with `GraphQL`?"
      },
      {
        "user": "pleerock",
        "created_at": "2018-02-21T11:26:10Z",
        "body": "I don't use lazy relations with graphql. Instead I created abstraction and use `connection.relationIdLoader` (can be found in latest `@next`) to find related entities for relation resolvers. I'll publish a framework with concrete implementation in the near future."
      },
      {
        "user": "gutenye",
        "created_at": "2018-02-21T12:40:58Z",
        "body": "That's great news! Looking forward to the framework.\n"
      }
    ]
  },
  {
    "number": 1598,
    "title": "VersionColumn",
    "created_at": "2018-02-15T09:26:18Z",
    "closed_at": "2018-02-19T08:58:27Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/1598",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[x] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `websql`\r\n\r\n**TypeORM version:**\r\n\r\n[ ] `latest`\r\n[x] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\nHello, how version column works? Could I get old versions of entity or this is just a number which incremets when entitity update?\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/1598/comments",
    "author": "alekseymakhankov",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2018-02-15T09:32:26Z",
        "body": "> this is just a number which incremets when entitity update?\r\n\r\ncorrect, its not revision control functionality."
      }
    ]
  },
  {
    "number": 1592,
    "title": "get a relation key for side of OneToOne",
    "created_at": "2018-02-14T10:56:57Z",
    "closed_at": "2018-02-15T14:09:05Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/1592",
    "body": "**Issue type:**\r\n[X ] question\r\n**Database system/driver:**\r\n[X ] `mysql` / `mariadb`\r\n**TypeORM version:**\r\n[X ] `latest`\r\n\r\n**How now it is possible to find out from which column they are related?**\r\n\r\nI performed a search I need links\r\n``` \r\ngetRepository (this.constructor) .metadata.findRelationWithPropertyPath ('l10n');\r\n```\r\n\r\n**Expected Result: id_category**\r\n\r\n```\r\n@Entity(\"categories\", {})\r\nexport class CategoriesModel extends ORM {\r\n\r\n    @OneToOne(type => L10nCategoriesModel, l10n => l10n.categories, {\r\n        eager: true,\r\n        cascadeInsert: true,\r\n        cascadeUpdate: true,\r\n        cascadeRemove: true,\r\n        onDelete: 'CASCADE'\r\n    })\r\n    l10n: L10nCategoriesModel[];\r\n\r\n}\r\n\r\n@Entity(\"l10n-categories\", {})\r\nexport class L10nCategoriesModel extends ORM {\r\n\r\n    /* id_category */\r\n    @OneToOne(type => CategoriesModel, category => category.l10n, {\r\n        onDelete: 'CASCADE'\r\n    })\r\n    @JoinColumn({\r\n        name: 'id_category',\r\n    })\r\n    categories: CategoriesModel;\r\n}\r\n\r\n```",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/1592/comments",
    "author": "Flexiink",
    "comments": [
      {
        "user": "Flexiink",
        "created_at": "2018-02-14T11:49:32Z",
        "body": "Here's how to get the related key\r\n```\r\nconst relation = getRepository(this.constructor).metadata.findRelationWithPropertyPath('l10n');\r\nconst relationIdInDatabaseEntity = relation.inverseRelation!.joinColumns[ 0 ].databaseName;\r\n```\r\nAny comments?"
      },
      {
        "user": "pleerock",
        "created_at": "2018-02-15T05:12:16Z",
        "body": "You can do it only from the owner side of the relationship this way:\r\n\r\n```ts\r\n@Entity(\"l10n-categories\", {})\r\nexport class L10nCategoriesModel extends ORM {\r\n\r\n    @OneToOne(type => CategoriesModel, category => category.l10n)\r\n    @JoinColumn({ name: 'id_category' })\r\n    category: CategoriesModel;\r\n\r\n    @Column({ name: 'id_category' })\r\n    categoryId: number;\r\n}\r\n```"
      },
      {
        "user": "Flexiink",
        "created_at": "2018-02-15T09:20:39Z",
        "body": "What is the meaning of '!' in this line ?\r\n```\r\nrelation.inverseRelation!.joinColumns[ 0 ].databaseName; \r\n```\r\nI saw it in your code."
      },
      {
        "user": "pleerock",
        "created_at": "2018-02-15T09:33:42Z",
        "body": "its typescript syntax to enforce undefined properties in strict mode"
      },
      {
        "user": "Flexiink",
        "created_at": "2018-02-15T14:09:05Z",
        "body": "Thank you!"
      }
    ]
  },
  {
    "number": 1586,
    "title": "nullable column/relation option set to false only works on undefined",
    "created_at": "2018-02-13T19:54:02Z",
    "closed_at": "2018-02-16T14:16:49Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/1586",
    "body": "**Issue type:**\r\n\r\n[ ] question\r\n[x] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[x] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `websql`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nI have two fields within my entity that have _nullable_ set to _false_, which will set the field null during an update (both in the relation and column).\r\n\r\n```ts\r\n@Entity('Account')\r\nexport class AccountEntity {\r\n\r\n    @ManyToOne(type => RecordTypeEntity, {\r\n        nullable: false\r\n    })\r\n    @JoinColumn({ name: 'RecordTypeId' })\r\n    recordType: RecordTypeEntity;\r\n\r\n    @Column({\r\n        name: 'Phone',\r\n        type: 'varchar',\r\n        nullable: false\r\n    })\r\n    phone: string;\r\n}\r\n```\r\n\r\nHowever, when running (I'm showing the Jest test I have it in), setting the fields to null will set them null in the database during the update, and the test will fail. **This does happen in the running server, I'm just showing the test because it's more concise.**\r\n\r\n```ts\r\nreturn AccountEntity.save(account).then(() => {\r\n    return AccountEntity.findOneById(account.sfid, {\r\n        join: {\r\n            alias: 'account',\r\n            innerJoinAndSelect: {\r\n                'recordType': 'account.recordType'\r\n            }\r\n        }\r\n    }).then(result => {\r\n\r\n        result.phone = null;\r\n        result.recordType = null;\r\n\r\n        return AccountEntity.save(result).then(() => {\r\n            return AccountEntity.findOneById(account.sfid, {\r\n                join: {\r\n                    alias: 'account',\r\n                    innerJoinAndSelect: {\r\n                        'recordType': 'account.recordType'\r\n                    }\r\n                }\r\n            }).then(result => {\r\n\r\n                expect(result).toBeDefined();\r\n\r\n                expect(result.recordType).toEqual(account.recordType);\r\n                expect(result.phone).toEqual(account.phone);\r\n\r\n            });\r\n        });\r\n\r\n    });\r\n\r\n});\r\n```\r\n\r\nThis is spit out in the logs during the test - so you can see that it's updating the field.\r\n\r\n```console\r\nconsole.log node_modules/typeorm/platform/PlatformTools.js:207\r\nexecuting query:  START TRANSACTION\r\n\r\nconsole.log node_modules/typeorm/platform/PlatformTools.js:207\r\nexecuting query:  UPDATE `Account` SET `Phone`=?, `RecordTypeId`=?  WHERE `Id`=? -- PARAMETERS: [null,null,\"1e6ecbc2-6890-44bd\"]\r\n\r\nconsole.log node_modules/typeorm/platform/PlatformTools.js:207\r\nexecuting query:  COMMIT\r\n```\r\n\r\nThe only way I can get it to work is to set the fields to undefined instead of null\r\n\r\n```ts\r\nresult.phone = undefined;\r\nresult.recordType = undefined;\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/1586/comments",
    "author": "anigenero",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2018-02-15T06:16:15Z",
        "body": "`nullable: false` means it will set your column `NOT NULL` constraint in the database, it does not mean it will skip your columns from the updation if they are equal to null. So, behaviour you are getting is expected."
      },
      {
        "user": "anigenero",
        "created_at": "2018-02-15T15:36:41Z",
        "body": "Ok. Was expecting that the behavior on that would be similar to how JPA deals with non-nullable columns, and the way the documentation is worded, it seemed that it would. Is this something you would consider putting in as a feature for instances like this? Or is that not within the scope of the project?"
      },
      {
        "user": "pleerock",
        "created_at": "2018-02-16T05:13:06Z",
        "body": "We could add a check and throw an exception if some of the values are null. The only difference will be that instead of database throwing error orm will be doing that. Im not sure if its a good design because it is only one database constraint we'll check. But there are other constraints that database has besides NOT NULL checks and its not possible for orm to check them all (even half of them). So, Im not really sure about \"validate some constraints, left others for database to check\" design."
      },
      {
        "user": "anigenero",
        "created_at": "2018-02-16T14:16:49Z",
        "body": "Ok. Not optimal, but I understand your overall reasoning why not to include it. So, in my case I just need to do the check for the null values I'm validating. Thanks for your help."
      }
    ]
  },
  {
    "number": 1568,
    "title": "Lack of isolation of where conditions",
    "created_at": "2018-02-08T10:32:47Z",
    "closed_at": "2018-02-20T08:08:41Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/1568",
    "body": "**Issue type:** Bug report\r\n**Database system/driver:** All SQL databases\r\n**TypeORM version:** All\r\n\r\nWHERE conditions generated by the query builder should all be isolated with parenthesis to avoid bugs due to operators priorities.\r\n\r\n**Example:**\r\n\r\n```ts\r\n  const entries = await repository.createQueryBuilder()\r\n    .where('field1 = :value OR field2 = :value', { value: 'foo' })\r\n    .andWhere('field3 = :value', { value: 'bar' })\r\n    .getMany();\r\n```\r\n\r\nResult conditions:\r\n`WHERE field1 = 'foo' OR field2 = 'foo' AND field3 = 'bar'`\r\n\r\nExpected conditions:\r\n`WHERE (field1 = 'foo' OR field2 = 'foo') AND (field3 = 'bar')`",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/1568/comments",
    "author": "Godefroy",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2018-02-15T07:30:06Z",
        "body": "its not a bug, its by design. If you want brackets isolation you can do following: \r\n\r\n```ts\r\n        const users = await connection.createQueryBuilder(User, \"user\")\r\n            .where(\"user.isAdmin = :isAdmin\", { isAdmin: true })\r\n            .orWhere(new Brackets(qb => {\r\n                qb.where(\"user.firstName = :firstName1\", { firstName1: \"Timber\" })\r\n                    .andWhere(\"user.lastName = :lastName1\", { lastName1: \"Saw\" });\r\n            }))\r\n            .orWhere(new Brackets(qb => {\r\n                qb.where(\"user.firstName = :firstName2\", { firstName2: \"Alex\" })\r\n                    .andWhere(\"user.lastName = :lastName2\", { lastName2: \"Messer\" });\r\n            }))\r\n            .getMany();\r\n```"
      },
      {
        "user": "pleerock",
        "created_at": "2018-02-20T08:08:41Z",
        "body": "Looks like the issue was resolved. Reopen if needed."
      },
      {
        "user": "RDeluxe",
        "created_at": "2018-05-15T15:26:16Z",
        "body": "I'm sorry, but how is this enormous and unreadable query could be by design ?\r\n\r\n`.where('field1 = :value OR field2 = :value', { value: 'foo' }, brackets: true)` would be okayish. But the current implementation is far from optimal, readable and intuitive.\r\n\r\n"
      },
      {
        "user": "dellert",
        "created_at": "2020-12-14T10:18:31Z",
        "body": "still has this bug "
      },
      {
        "user": "zamanzamzz",
        "created_at": "2020-12-17T02:22:08Z",
        "body": "```\r\n.where(\r\n    '(post.timePosted < :cursorTime OR (post.timePosted = :cursorTime AND post.id < :cursorId))',\r\n    {\r\n      cursorTime: cursorTime,\r\n      cursorId: cursorId\r\n    }\r\n);\r\n```\r\nI found that adding the required brackets straight into the where string works as expected. I find this more readable. The brackets syntax seems a bit wordy to me."
      },
      {
        "user": "fumieval",
        "created_at": "2022-12-27T05:34:03Z",
        "body": "We've been bitten by this issue today and __we almost leaked confidential information \"by design\"__!  Simply wrapping the expression with parentheses would have prevented this issue and I don't really see why not to do so. Does anyone __want__ `query.andWhere('A OR B')` to be interpreted as `(... AND A) OR B`?\r\n\r\n"
      },
      {
        "user": "alper",
        "created_at": "2024-11-20T14:32:36Z",
        "body": "We'll have an ESlint rule to check for this nonsense."
      }
    ]
  },
  {
    "number": 1546,
    "title": "schema autosync vs migrations",
    "created_at": "2018-02-03T00:41:18Z",
    "closed_at": "2018-02-20T07:35:43Z",
    "labels": [
      "question",
      "comp: migrations"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/1546",
    "body": "**Issue type:**\r\n\r\n[x ] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[x] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `websql`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\nHi there,\r\n\r\nI might be missing something, but it seems to me that the `synchronize: true` setting is not compatible with the concept of migrations in `typeorm`.\r\n\r\nI took an existing project that uses `typeorm` and added a new entity. Being used to Rails' ActiveRecord, I started adding the migration to create the relation, I then proceeded to write the entity (sometimes I do in the reverse order, but that doesn't matter here).\r\n\r\nI then ran the ` yarn typeorm migrations:run` command and it correctly ran the migration and created the relation. When I started the node app though, I started seeing a lot of SQL logs and just moments afterwards errors of fields already existing. It took some time for me to figure out it was the autosync trying to sync the entities to the (already existing) relations.\r\n\r\nI don't understand the autosync very well yet. I don't think it'd be useful for production use right? You can't just automagically let a diff algorithm update your schema, it might result in loss of data. Migrations are needed to safely re-structure the schema and data. Why would someone use autosync? I'm looking for real-world cases.\r\n\r\nIn my case, I think I'll just disable it and use migrations instead. I'm still looking to hear your opinions about best-practices here though.\r\n\r\nThanks in advance.\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/1546/comments",
    "author": "fullofcaffeine",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2018-02-05T08:38:35Z",
        "body": ">  You can't just automagically let a diff algorithm update your schema, it might result in loss of data. \r\n\r\nCorrect.\r\n\r\n> Migrations are needed to safely re-structure the schema and data.\r\n\r\nCorrect, if you manually write migrations. There is a migration auto-generation feature (now works only in mysql) which does the same as `synchronize: true` but it writes generation logic into migration file. Such approach also is not safe and you should be careful with it.\r\n\r\n`synchronize: true` is a feature mostly for development purpose. Its easy to do development with this feature, you don't need to care about your schema. It can also be used in production, but you need to be careful with it, use it when you are sure you did not make any changes in your entities which may lead to data loose. \r\n\r\nIn development I always use `synchronize: true` and in production I use hybrid approach - use schema sync when its safe to do, and use manual data correction before schema sync when I need to correct my data."
      },
      {
        "user": "fullofcaffeine",
        "created_at": "2018-02-09T01:14:38Z",
        "body": "> In development I always use synchronize: true and in production I use hybrid approach - use schema sync when its safe to do, and use manual data correction before schema sync when I need to correct my data.\r\n\r\nWould you mind sharing a sample script/workflow for this? It's still not clear to me how one would combine both.\r\n\r\nAlso, as a related question, I've seen somewhere in the `typeorm` docs that __migrations can be generated from the entity__, but I failed miserably at doing so. I've created a new entity, added the fields and associations, and then generated a migration, but it's generated with an empty `up` and `down` methods. It's not clear either from the CLI command how `typeorm` infers the actual entity to generate from. Am I missing something?\r\n\r\nThanks!"
      },
      {
        "user": "pleerock",
        "created_at": "2018-02-15T06:35:44Z",
        "body": "> Would you mind sharing a sample script/workflow for this? It's still not clear to me how one would combine both.\r\n\r\nthere is no specific script. I explained conception, you apply it on your data/cases individually.\r\n\r\n> typeorm docs that migrations can be generated from the entity,\r\n\r\nMigration generation can be done by `typeorm migrations:generate` command, however it works only in mysql and *partially* in postgres currently, we are planning to ship complete support in 0.2.0"
      },
      {
        "user": "pleerock",
        "created_at": "2018-02-20T07:35:43Z",
        "body": "Looks like the issue was resolved. Reopen if needed."
      },
      {
        "user": "CalaxDev",
        "created_at": "2019-06-14T15:04:52Z",
        "body": "Does this already work with like, postgres, MongoDB etc?"
      },
      {
        "user": "biels",
        "created_at": "2020-11-19T10:20:39Z",
        "body": "Are generated migrations supported in postgres in typeorm v0.2.29 at the moment? Thanks"
      }
    ]
  },
  {
    "number": 1529,
    "title": "Set CreateDateColumn programmatically",
    "created_at": "2018-01-30T09:26:51Z",
    "closed_at": "2018-02-20T08:06:25Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/1529",
    "body": "Is there a way to set a CreateDateColumn in the code?\r\nI'm on version two of an app and i want to import the data of the old application which is in another format. Normally the behavior of CreateDateColumn is what I need but not when importing the old data.\r\n\r\n\r\n**Issue type:**\r\n\r\n[ x ] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ x ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `websql`\r\n\r\n**TypeORM version:**\r\n\r\n[ ] `latest`\r\n[ ] `@next`\r\n[ x ] `^0.1.7` (or put your version here)\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/1529/comments",
    "author": "timojokinen",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2018-01-31T06:09:37Z",
        "body": "no, there is no. If your data does not fit CreateDateColumn requirements then you just need to create a regular column and implement creation / updation functionality manually. Its easy to implement having subscribers and listeners functionality."
      },
      {
        "user": "pleerock",
        "created_at": "2018-02-20T08:06:25Z",
        "body": "Looks like the issue was resolved. Reopen if needed."
      },
      {
        "user": "EduardsE",
        "created_at": "2018-04-24T15:21:41Z",
        "body": "This issue is also relevant when in automated tests you wish to create a record in the database with a past creation date."
      },
      {
        "user": "pleerock",
        "created_at": "2018-04-25T05:21:37Z",
        "body": "@EduardsE do you have this issue in 0.2.0 ?"
      },
      {
        "user": "EduardsE",
        "created_at": "2018-04-25T06:41:12Z",
        "body": "@pleerock We tried to upgrade to 0.2 but it had some other issues, so we had to rollback previous version. I'll check it out later."
      },
      {
        "user": "EduardsE",
        "created_at": "2018-04-25T08:39:44Z",
        "body": "@pleerock The issue previously was that the **CreateDateColumn** and **UpdateDateColumn** decorators stopped working and I couldn't figure out why. Now I know that you have to take care of the timestamp saving in the database yourself. "
      }
    ]
  },
  {
    "number": 1521,
    "title": "Transactions with custom repositories",
    "created_at": "2018-01-27T23:00:11Z",
    "closed_at": "2018-02-20T08:00:52Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/1521",
    "body": "**Issue type:**\r\n\r\n[X] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[X] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `websql`\r\n\r\n**TypeORM version:**\r\n\r\n[X] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nI'm just starting to look at typeorm as a replacement for sequelize. \r\n\r\nI'm wondering if it's possible to use transactions using custom repositories. Our code base uses that structure at the moment and we heavily rely on transactions. \r\n\r\nThanks!",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/1521/comments",
    "author": "bilby91",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2018-01-31T06:57:49Z",
        "body": "yes:\r\n\r\n```ts\r\nconnection.transaction(async entityManager => {\r\n   await entityManager.getCustomRepository(YourRepository).someMethod();\r\n});"
      },
      {
        "user": "pleerock",
        "created_at": "2018-02-20T08:00:52Z",
        "body": "Looks like the issue was resolved. Reopen if needed."
      },
      {
        "user": "natikos",
        "created_at": "2020-06-19T11:09:13Z",
        "body": "@pleerock, should it work with two custom repositories? \r\nbecause in my case I have a record in the database, credentialsRepository throw Exception though.\r\n```typescript\r\nawait getConnection().transaction(async (manager) => {\r\n      const adminEntity = await manager.getCustomRepository(WorkerRepository)\r\n        .createWorker({ ...admin, position: WorkerPosition.ADMIN, phoneNumber: null });\r\n      await manager.getCustomRepository(CredentialsRepository).savePassword(admin.password, adminEntity.id);\r\n});\r\n```\r\n\r\nThe following code doesn't work either.\r\n```typescript\r\n// worker.service.ts\r\n@Transaction()\r\n  async addAdmin(admin: INewAdmin, @TransactionManager() manager?: EntityManager): Promise<void> {\r\n    await manager.getCustomRepository(WorkerRepository)\r\n      .createWorker({ ...admin, position: WorkerPosition.ADMIN, phoneNumber: null });\r\n  }\r\n\r\n// worker.repository.ts\r\nasync createWorker(worker: INewWorker): Promise<WorkerEntity> {\r\n    const { fullName, accountName, phoneNumber, position, restaurantId, password } = worker;\r\n    let entity = new WorkerEntity();\r\n    entity.phoneNumber = phoneNumber;\r\n    entity.fullName = fullName;\r\n    entity.accountName = accountName;\r\n    entity.position = position;\r\n    entity.restaurantId = restaurantId;\r\n    entity = await entity.save();\r\n    await getCustomRepository(CredentialsRepository).savePassword(password, entity.id);\r\n    return entity;\r\n  }\r\n```"
      },
      {
        "user": "sumeet-bansal",
        "created_at": "2020-07-26T00:17:24Z",
        "body": "@natikos did you figure out a solution for your issue? I'm running into the same problem."
      }
    ]
  },
  {
    "number": 1511,
    "title": "Self many-to-many relation for followers system",
    "created_at": "2018-01-25T19:05:55Z",
    "closed_at": "2018-02-20T07:42:14Z",
    "labels": [
      "question",
      "comp: relations"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/1511",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[x] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `websql`\r\n\r\n**TypeORM version:**\r\n\r\n[ ] `latest`\r\n[ ] `@next`\r\n`0.1.11` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nHi all, I need to create a basic followers system like Twitter or Instagram; I have the following entity:\r\n\r\n```\r\n@Entity()\r\nclass User {\r\n\r\n  // columns\r\n  @PrimaryGeneratedColumn()\r\n  id: number;\r\n\r\n  @Column('varchar', { length: 30 })\r\n  firstName: string;\r\n\r\n  @Column('varchar', { length: 30 })\r\n  lastName: string;\r\n\r\n  @Column('varchar')\r\n  description: string;\r\n\r\n  @Column('varchar')\r\n  profileImgUrl: string;\r\n\r\n  // Works!\r\n  @ManyToMany(type => User, user => user.following)\r\n  @JoinTable()\r\n  followers: User[];\r\n\r\n  // This not works as expected\r\n  @ManyToMany(type => User)\r\n  following: User[];\r\n\r\n  // Works like a charm!\r\n  @RelationCount((user: User) => user.followers)\r\n  followersCount: number;\r\n  \r\n  // Then, this not works\r\n  @RelationCount((user: User) => user.following)\r\n  followingCount: number;\r\n}\r\n```\r\n\r\nThis creates two pivot tables in my database; not the best way. I only need the the `user` table and the `user_followers_user` that contains the columns `userId_1` and `userId_2` (user `userId_1` follows `userId_2`, then `userId_2`is followeb by ``userId_1)",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/1511/comments",
    "author": "lewyuburi",
    "comments": [
      {
        "user": "daniel-lang",
        "created_at": "2018-01-26T07:44:35Z",
        "body": "I modified your entity so that the second `@ManyToMany` (following) is complete.\r\n\r\n```ts\r\n@Entity()\r\nexport class User {\r\n  @PrimaryGeneratedColumn()\r\n  id: number;\r\n\r\n  @Column(\"varchar\", { length: 30 })\r\n  firstName: string;\r\n\r\n  @Column(\"varchar\", { length: 30 })\r\n  lastName: string;\r\n\r\n  @Column(\"varchar\")\r\n  description: string;\r\n\r\n  @Column(\"varchar\")\r\n  profileImgUrl: string;\r\n\r\n  @ManyToMany(type => User, user => user.following)\r\n  @JoinTable()\r\n  followers: User[];\r\n\r\n  @ManyToMany(type => User, user => user.followers)\r\n  following: User[];\r\n\r\n  @RelationCount((user: User) => user.followers)\r\n  followersCount: number;\r\n  \r\n  @RelationCount((user: User) => user.following)\r\n  followingCount: number;\r\n}\r\n```\r\n\r\nWith this change, I can load both `following` and `followers` and check `followersCount` and `followingCount`.\r\nCan you try if that would do the trick for you?"
      },
      {
        "user": "pleerock",
        "created_at": "2018-02-20T07:42:14Z",
        "body": "Closing as no answer from reporter. Looks like issue was resolved."
      },
      {
        "user": "arthur-mts",
        "created_at": "2020-04-14T21:50:30Z",
        "body": "@lewyuburi can you post the migration of this relation?"
      },
      {
        "user": "santina",
        "created_at": "2020-09-01T21:05:23Z",
        "body": "For some reason when I try something similar, the migration doesn't contain that relation. The migration script just ignores all those relation, and only create the columns and the primary key. :( "
      }
    ]
  },
  {
    "number": 1501,
    "title": "Sharing a connection with a utility package",
    "created_at": "2018-01-24T23:33:49Z",
    "closed_at": "2018-02-20T09:57:04Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/1501",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[ ] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[x] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `websql`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\nI have my project set up where one of the services consumes a utility package (via a private npm package), both of which use typeorm.  The service creates the typeorm connection using configurations in environment variables, and **I'd like to have the utility package use the same connection to query my database**.\r\n\r\nIf I try simply calling `getManager()` from the utility package, I get a `ConnectionNotFoundError`.  \r\n\r\nIf I try passing the connection from the main service to the utility functions in the utility package, and using that connection to getRepository() with an entity, I get a `RepositoryNotFoundError`.  I can, however, call getRepository with the table name as a string, and that \"works\", except doesn't have typings.  I'm guessing that the connection is retaining its configurations here, but the entities path is now wrong.  However, I'm defining the entities path using node_modules/my_package/*.js, which should be exactly the same for the service and the utility package (the entities live in a separate package and both the service and the utility package consume that package).  I also couldn't figure out if it was possible to change the \"entities\" path of an active connection, or add new paths.\r\n\r\nHere's a minimal example of my main service:\r\n```\r\nimport \"reflect-metadata\"\r\nimport { createConnection, getManager } from \"typeorm\";\r\nimport * as dotenv from \"dotenv\";\r\ndotenv.config();\r\n\r\nimport { ApiUser } from \"@gather/entities\"; // entities defined here\r\nimport { utilities } from \"@gather/permissions\"; // utility functions here\r\n\r\ncreateConnection() // defined in .env\r\n    .then(async (connection) => {\r\n        // works\r\n        const test = await getManager().getRepository(ApiUser);\r\n        console.log(await test.find());\r\n\r\n        // Error: Postgres connection not initialized.  If I pass in the connection then it can't find my entities\r\n        const apiUserPermissions = new utilities.ApiUserPermissions(10); // try also passing connection as a param\r\n        const companiesWithPermission = await apiUserPermissions.getApiUser();\r\n        console.log(\"listening\");\r\n    })\r\n    .catch((err) => {\r\n        console.error(err);\r\n    })\r\n```\r\n\r\nand here's a minimal version of that utility class (get rid of this.connection to test with the default connection):\r\n```\r\nimport { ApiUser } from \"@gather/entities\";\r\nimport { getManager, Connection } from \"typeorm\";\r\n\r\nexport class ApiUserPermissions {\r\n    private apiUser: ApiUser;\r\n\r\n    constructor(private apiUserID: number, private connection: Connection) {}\r\n\r\n    public async getApiUser(): Promise<ApiUser> {\r\n        let ApiUserRepository;\r\n        try {\r\n            ApiUserRepository = this.connection.getRepository(ApiUser);\r\n        } catch (err) {\r\n            if (err.name === \"ConnectionNotFoundError\") {\r\n                throw new Error(\"Postgres connection not initialized\");\r\n            }\r\n            throw err;\r\n        }\r\n        return ApiUserRepository.findOneById(this.apiUserID);\r\n    }\r\n}\r\n```\r\n\r\nin my env file, I have `TYPEORM_ENTITIES = node_modules/@gather/entities/dist/entities/*.js`\r\n\r\nAm I doing something wrong here, or if not, what's the recommended approach?\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/1501/comments",
    "author": "malbertSC",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2018-01-31T09:37:11Z",
        "body": "you need to load configuration from your `.env` (and transform them into connection options object) and append entities from your package. Something like this:\r\n\r\n```ts\r\nconst connectionOptions = new ConnectionOptionsEnvReader().read();\r\nconnectionOptions.entities.push(...entitiesFromDifferentPackage);\r\ncreateConnection(connectionOptions)\r\n    .then(async (connection) => {\r\n         /// ....\r\n```"
      },
      {
        "user": "pleerock",
        "created_at": "2018-02-20T09:57:04Z",
        "body": "Looks like the issue was resolved. Reopen if needed."
      }
    ]
  },
  {
    "number": 1490,
    "title": "Undefined does not affect model objects",
    "created_at": "2018-01-23T04:33:54Z",
    "closed_at": "2018-01-23T06:17:51Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/1490",
    "body": "When trying to update a user, I mistakenly ran the following commands:\r\n```\r\n      user.resetPasswordToken = undefined;\r\n      user.resetPasswordExpires = undefined;\r\n      userRepo.save(user)\r\n```\r\n\r\nBut I noticed that it wasn't doing anything to the user object. However, when I changed this to:\r\n```\r\n      user.resetPasswordToken = null;\r\n      user.resetPasswordExpires = null;\r\n      userRepo.save(user)\r\n```\r\n\r\nIt had the expected behavior. This could be different from most people's expectations (even if this is expected behavior from the project), and should be clearly documented",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/1490/comments",
    "author": "crutchcorn",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2018-01-23T06:10:21Z",
        "body": "Its by design and allows partial updations. You can lets say do `userRepo.save({ id: 1, middleName: \"Lalala\" })` without being worried that other data will be removed. Also setting properties to `null` is actually making column values null in the database as well, so logically everything fit good.\r\n\r\nand btw you always can contribute in documentation, its quite easy to do and will help others to solve issues you faced."
      },
      {
        "user": "crutchcorn",
        "created_at": "2018-01-23T06:12:07Z",
        "body": "I understand and think it's a great design choice. \n\nI know I can contribute, and do plan to, but often find these bugs in the middle of a code session and just need to log them out. I'll try getting a PR in with doc additions here soon. "
      },
      {
        "user": "pleerock",
        "created_at": "2018-01-23T06:17:51Z",
        "body": "nice!"
      }
    ]
  },
  {
    "number": 1455,
    "title": "using full text search in cordova sqlite",
    "created_at": "2018-01-15T16:10:44Z",
    "closed_at": "2018-02-20T10:55:05Z",
    "labels": [
      "question",
      "needs more info"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/1455",
    "body": "There doesn't seem to be a way to do a full text search over all of a table's columns without specifying all of the columns by name. How would I achieve this in the cordova sqlite implementation?",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/1455/comments",
    "author": "MeyerSurix",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2018-01-16T05:12:09Z",
        "body": "how do you accomplish it via sql?"
      },
      {
        "user": "pleerock",
        "created_at": "2018-02-20T10:55:05Z",
        "body": "Closing as no answer from reporter."
      }
    ]
  },
  {
    "number": 1418,
    "title": "BUG or SUPPORT something wrong with joinable tables",
    "created_at": "2018-01-07T15:16:29Z",
    "closed_at": "2018-01-23T06:22:47Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/1418",
    "body": "I have `TestEntity.ts`:\r\n```js\r\n@Entity('test_1288');\r\nexport class TestEntity {\r\n    @PrimaryGeneratedColumn()\r\n    id: number;\r\n\r\n    @Column(type => JoinEntity)\r\n    jName: JoinEntity = new JoinEntity({spec: \"fffffffff\"});\r\n}\r\n```\r\nand joinable table `JoinEntity.ts`:\r\n```js\r\n@Entity(\"join_1288\")\r\nexport class JoinEntity {\r\n    @PrimaryGeneratedColumn()\r\n    id: number;\r\n\r\n    @Column()\r\n    spec: string;\r\n}\r\n```\r\n\r\nand of course `test.ts`:\r\n```js\r\ndescribe(\"github issues > #1288 check calculated columns (sql in @Column)\", () => {\r\n\r\n    let connections: Connection[];\r\n    before(async () => {\r\n        return connections = await createTestingConnections({\r\n            entities: [__dirname + \"/entity/*{.js,.ts}\"]\r\n        });\r\n    });\r\n    beforeEach(() => {\r\n        return reloadTestingDatabases(connections);\r\n    });\r\n    after(() => {\r\n        return closeTestingConnections(connections);\r\n    });\r\n\r\n    it(\"should persist successfully and return entity\", () => Promise.all(connections.map(async connection => {\r\n        // create objects to save\r\n        const joinEntity1 = new JoinEntity();\r\n        joinEntity1.spec = \"Entity #1 spec (for TestEntity)\";\r\n\r\n        const testEntity1 = new TestEntity();\r\n        testEntity1.name = \"Entity #1\";\r\n        testEntity1.jName.spec = \"Entity #1 some spec\";\r\n\r\n        const testEntity2 = new TestEntity();\r\n        testEntity2.name = \"Entity #2\";\r\n\r\n        // persist\r\n        await connection.manager.save([\r\n            testEntity1,\r\n            testEntity2\r\n        ]);\r\n```\r\n\r\nbut what I see in a query?:\r\n```SQL\r\nINSERT INTO \"test_1288\"(\"name\", \"jNameSpec\") VALUES ($1,$2)  RETURNING \"id\", \"jNameId\"\r\n```\r\nany comments about this?",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/1418/comments",
    "author": "cybermerlin",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2018-01-08T13:14:54Z",
        "body": "Thank you for clear example. Looks correct. What issue do you have? What do you think is wrong?\r\n  "
      },
      {
        "user": "pleerock",
        "created_at": "2018-01-08T13:20:56Z",
        "body": "You are using a concept called \"embedded entities\". When you embed entity it merges all properties from it into your original entity. In your case result will be `test_1288` table with 4 columns:\r\n\r\n* id\r\n* name\r\n* jNameId\r\n* jNameSpec\r\n\r\nWhere `id` and `jNameSpec` are both primary columns and they are resulted in a *composite primary key*. This is how embedded entities are working. Im not sure why are you using \"joinable\" table terminology here, but looks like you are confusing this with concept of real relations (many-to-many, one-to-many, etc.) \r\n\r\nAlso there are two issues with your code:\r\n\r\n* your second entity does not need a decorator. Remove `@Entity(\"join_1288\")` from JoinEntity.\r\n* you have multiple primary keys and both are auto-generated columns - this is not supported (and will not be because of database-level limitations)"
      },
      {
        "user": "cybermerlin",
        "created_at": "2018-01-13T10:39:03Z",
        "body": "I was thinking something like: \r\ntables: test_1288, join_1288\r\n and \r\ntest_1288.jName are FK to join_1288.id \r\n      and if I have to get spec value then all I need is just call testEntity1.jName.spec (like in ibatis on advanced types)"
      },
      {
        "user": "cybermerlin",
        "created_at": "2018-01-13T10:42:01Z",
        "body": "thank for waiting for my reaction (I was very busy)."
      },
      {
        "user": "pleerock",
        "created_at": "2018-01-15T09:22:47Z",
        "body": "you need to use relations, not `@Column(() => Entity)` syntax for your purpose."
      },
      {
        "user": "cybermerlin",
        "created_at": "2018-01-21T20:00:43Z",
        "body": "thx.\r\nmaybe u show me some link to that helping page, it's will be helpful for me?"
      },
      {
        "user": "pleerock",
        "created_at": "2018-01-23T06:22:47Z",
        "body": "open a documentation site and take a look on section panel, you'll see \"Relations\" there."
      }
    ]
  },
  {
    "number": 1415,
    "title": "Cancel query from listener",
    "created_at": "2018-01-06T17:03:09Z",
    "closed_at": "2018-02-20T11:08:44Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/1415",
    "body": "Currently i use `@BeforeInsert` and `@BeforeUpdate` to validate some data and i don't find a way to cancel the query without throwing an error.\r\n\r\nCan you check the return of the function and if it's an instance of Error just emit a failed query error with our custom code/message?\r\n  ",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/1415/comments",
    "author": "antoine-pous",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2018-01-08T13:28:42Z",
        "body": "As I already answered in gitter you need to throw an error and catch it."
      }
    ]
  },
  {
    "number": 1412,
    "title": "order by [column_name] null last for MySQL/MarieDB",
    "created_at": "2018-01-06T05:39:54Z",
    "closed_at": "2018-02-20T11:10:13Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/1412",
    "body": "As this is not supported in MySQL/MarieDB, I think the only way is to add \"-\" infront of the ordered column, but it cause error like table alias not found. \r\n\r\nAre there a ready method or way to do NULL last in mysql/MarieDB? beside executing raw sql statement?",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/1412/comments",
    "author": "csim-sg",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2018-01-08T13:54:36Z",
        "body": "Following should work:\r\n\r\n```ts\r\n\r\n        const loadedPost1 = await connection.manager\r\n            .createQueryBuilder(Post, \"post\")\r\n            .addOrderBy(\"post.myOrder IS NULL\", \"ASC\")\r\n            .getOne();\r\n\r\n        const loadedPost2 = await connection.manager\r\n            .createQueryBuilder(Post, \"post\")\r\n            .addOrderBy(\"post.myOrder IS NOT NULL\", \"ASC\")\r\n            .getOne();\r\n\r\n```\r\n\r\nproduces:\r\n\r\n```sql\r\nSELECT `post`.`id` AS `post_id`, `post`.`myOrder` AS `post_myOrder`, `post`.`num1` AS `post_num1`, `post`.`num2` AS `post_num2` FROM `post` `post` ORDER BY `post`.`myOrder` IS NULL ASC\r\nSELECT `post`.`id` AS `post_id`, `post`.`myOrder` AS `post_myOrder`, `post`.`num1` AS `post_num1`, `post`.`num2` AS `post_num2` FROM `post` `post` ORDER BY `post`.`myOrder` IS NOT NULL ASC\r\n```"
      },
      {
        "user": "pleerock",
        "created_at": "2018-02-20T11:10:13Z",
        "body": "Looks like the issue was resolved. Reopen if needed."
      }
    ]
  },
  {
    "number": 1406,
    "title": "Enhancement: CREATE DATABASE",
    "created_at": "2018-01-04T17:10:37Z",
    "closed_at": "2018-03-12T08:14:15Z",
    "labels": [
      "question",
      "discussion"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/1406",
    "body": "Today TypeORM can connect to an existing database, but afaik it does not allow you to create a database. This means we cannot have a full lifecycle DB which is configured-as-code. Is this feature request consistent with or out of scope for the vision of this library?",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/1406/comments",
    "author": "Vandivier",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2018-02-20T11:19:06Z",
        "body": "I don't think we are going to implement this. Why? Because CREATE DATABASE needs privileges which usually absent in proper setup environments. "
      },
      {
        "user": "Vandivier",
        "created_at": "2018-02-20T13:42:52Z",
        "body": "Obviously you could make it optional and fall back to the current assumption that it's already there"
      },
      {
        "user": "pleerock",
        "created_at": "2018-02-20T14:00:04Z",
        "body": "what do you mean by \"optional\"? Add some flag in connection options for user that automatically creates it?"
      },
      {
        "user": "Vandivier",
        "created_at": "2018-02-20T15:39:04Z",
        "body": "Let there be some method app.dataSources.makeDB(config)\r\n\r\nIf this method is called with a valid config object, drop specified DB if it exists and create the specified DB.\r\n\r\nIf this method is not called then proceed as currently implemented: assume there already is a valid DB and if that is not the case then throw."
      },
      {
        "user": "pleerock",
        "created_at": "2018-02-20T17:59:04Z",
        "body": "If you are asking about \"create database method\", then it already exist in `QueryRunner` and its called `createDatabase`. But its not called inside ORM, you shall call it on your own."
      },
      {
        "user": "pleerock",
        "created_at": "2018-03-12T08:14:15Z",
        "body": "I think answer to original question was already given."
      }
    ]
  },
  {
    "number": 1386,
    "title": "How to make custom error handler?",
    "created_at": "2017-12-26T12:33:16Z",
    "closed_at": "2018-01-02T15:03:33Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/1386",
    "body": "I have an entity like below.\r\n\r\n```ts\r\nimport {\r\n  Entity,\r\n  PrimaryGeneratedColumn,\r\n  Column\r\n} from 'typeorm'\r\n\r\n@Entity()\r\nexport class User {\r\n  @PrimaryGeneratedColumn()\r\n  id: number\r\n\r\n  @Column({\r\n    length: 30,\r\n    unique: true,\r\n    nullable: true\r\n  })\r\n  username: string\r\n\r\n  @Column({\r\n    length: 255,\r\n    unique: true\r\n  })\r\n  @IsEmail()\r\n  email: string\r\n}\r\n```\r\n\r\nAs you can see, I have 2 unique columns (`username` and `email`). When I insert a new data `username` and `email` that existed on the database, it will throw an error something like this.\r\n\r\n```json\r\n\t{\r\n        \"message\": \"ER_DUP_ENTRY: Duplicate entry 'lodddrem@ipsumemail.com' for key 'email'\",\r\n        \"code\": \"ER_DUP_ENTRY\",\r\n        \"errno\": 1062,\r\n        \"sqlMessage\": \"Duplicate entry 'lodddrem@ipsum.com' for key 'email'\",\r\n        \"name\": \"QueryFailedError\",\r\n        \"parameters\": [\r\n          \"lodddrem_username\",\r\n          \"lodddrem@ipsumemail.com\"\r\n        ]\r\n    }\r\n```\r\n\r\nMy problem is, the error message is not good enough for reporting the errors. It just says that the error just in `email` field.\r\nWhat I want to achieve is error message something like this.\r\n\r\n```json\r\n[\r\n    {\r\n\t\t\"column\": \"email\",\r\n        \"message\": \"ER_DUP_ENTRY: Duplicate entry 'lodddrem@ipsumemail.com' for key 'email'\",\r\n        \"code\": \"ER_DUP_ENTRY\",\r\n        \"errno\": 1062,\r\n        \"sqlMessage\": \"Duplicate entry 'lodddrem@ipsum.com' for key 'email'\"\r\n    },\r\n   {\r\n\t\t\"column\": \"username\",\r\n        \"message\": \"ER_DUP_ENTRY: Duplicate entry 'loremusernme' for key 'username'\",\r\n        \"code\": \"ER_DUP_ENTRY\",\r\n        \"errno\": 1062,\r\n        \"sqlMessage\": \"Duplicate entry 'loremusernme' for key 'username'\"\r\n    }\r\n]\r\n```\r\nIt looks more obvious for error reporting which you get the `column` name of error data.\r\n\r\nThe question is, how can I achieve that? Any good solution for it?",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/1386/comments",
    "author": "rohmanhm",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2018-01-02T10:07:42Z",
        "body": "Its not possible. \r\n\r\nThe error you have (`Duplicate entry 'lodddrem@ipsum.com' for key 'email'`) is given by a database. Database returns you only ONE (first) error, it does not return you what you want. \r\n\r\nSolution is not to use database errors, but use validation library instead (like class-validator), create a separate validation logic and provide a good messages."
      },
      {
        "user": "rohmanhm",
        "created_at": "2018-01-02T15:03:33Z",
        "body": "Thanks for the solution, I thought your library already doing checking for the unique column."
      },
      {
        "user": "deepchudasama",
        "created_at": "2019-04-09T12:11:37Z",
        "body": "**Problem:** I want the key which is Duplicate.\r\n**Technical Specs:**\r\nnodejs: 10\r\ntypeorm: ^0.2.7\r\n\r\nIt's kind of weird but I got error differently like,\r\n`ER_DUP_ENTRY: Duplicate entry '1234567891' for key 'IDX_94885a1050f3e1d57a431de011'`\r\n\r\nThanks in advance"
      },
      {
        "user": "visualcookie",
        "created_at": "2019-10-23T07:18:22Z",
        "body": "@rohmanhm Did you figure out how to do it with `class-validator`? I'm struggling at it right now."
      },
      {
        "user": "AnechaS",
        "created_at": "2022-04-30T22:38:17Z",
        "body": "replacing message.\r\nexample case unique\r\n```js\r\nif (error instanceof QueryFailedError && error['code'] === '23505') {\r\n      const message = error['detail'].replace(\r\n        /^Key \\((.*)\\)=\\((.*)\\) (.*)/,\r\n        'This $1 $2 already exists.',\r\n      )\r\n     // => This COLUMN VALUE already exists.\r\n}\r\n```"
      }
    ]
  },
  {
    "number": 1385,
    "title": "Passing array object in find Method (TypeORM)",
    "created_at": "2017-12-26T09:21:00Z",
    "closed_at": "2018-01-12T10:22:05Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/1385",
    "body": "I am migrating the API to TypeORM from mongoose. I have an array(conversationIds) containing list of id to be searched from the Database and it should return me the available id. Below are the query which i have tried.\r\n\r\n`const conversationMessagesWithDuplicates = await consversationRepository.createQueryBuilder(\"conversation\").where(\"conversation.channel_message_ID = :channel_message_ID\",{channel_message_ID : conversationIds}).getMany();`\r\n\r\nOR\r\n\r\n`const conversationMessagesWithDuplicates = await consversationRepository.find({channel_message_ID: conversationIds});`\r\n\r\nBut i am getting below issue:\r\n`(node:11548) UnhandledPromiseRejectionWarning: Unhandled promise rejection (rejection id: 1): QueryFailedError: Error: Incorrect syntax near ','.`\r\n\r\nBelow is the MoongoseAPI which is working fine:\r\n\r\n`Conversation.find( { channel_message_ID: { $in: conversationMessageIdArray } } ).exec(function(err, conversationMessagesDuplicatesArray) {}`",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/1385/comments",
    "author": "PawanKr2feb",
    "comments": [
      {
        "user": "daniel-lang",
        "created_at": "2017-12-26T10:22:36Z",
        "body": "you can do the following:\r\n\r\n```typescript\r\nconst conversationMessagesWithDuplicates = await consversationRepository\r\n   .createQueryBuilder(\"conversation\")\r\n   .where(\"conversation.channel_message_ID IN (:channel_message_IDs)\",{channel_message_ID : conversationIds})\r\n   .getMany()\r\n```\r\n\r\nWhich should be the equivalent of your moongose query."
      },
      {
        "user": "daniel-lang",
        "created_at": "2018-01-12T10:22:05Z",
        "body": "@PawanKr2feb I'm going to close this. If you have more questions about the find method or TypeORM in general, feel free to reopen it."
      },
      {
        "user": "mentos1386",
        "created_at": "2018-01-19T21:23:19Z",
        "body": "@daniel-lang it would be nice if it would work with arrays, without using query builder. I think this is quite common use case."
      },
      {
        "user": "daniel-lang",
        "created_at": "2018-01-19T21:28:16Z",
        "body": "@pleerock what are your thoughts on this?"
      },
      {
        "user": "pleerock",
        "created_at": "2018-01-22T09:43:30Z",
        "body": "Yes we have this feature request already in #1101"
      }
    ]
  },
  {
    "number": 1357,
    "title": "Bug: invalid reference to FROM-clause entry for table",
    "created_at": "2017-12-18T14:32:16Z",
    "closed_at": "2017-12-18T15:04:00Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/1357",
    "body": "I have this query for finding an user by email:\r\n\r\n```typescript\r\nthis.repo.findOne({ email: normalizeEmail(email) })\r\n```\r\n\r\nThis query fails with the following error:\r\n\r\n```\r\nquery failed:  SELECT \"Person\".\"createdAt\" AS \"Person_createdAt\", \"Person\".\"updatedAt\" AS \"Person_updatedAt\", \"Person\".\"id\" AS \"Person_id\", \"Person\".\"creationAction\" AS \"Person_creationAction\", \"Person\".\"emailVerified\" AS \"Person_emailVerified\", \"Person\".\"emailVerificationTokenId\" AS \"Person_emailVerificationTokenId\", \"Person\".\"passwordHash\" AS \"Person_passwordHash\", \"Person\".\"passwordResetTokenId\" AS \"Person_passwordResetTokenId\", \"Person\".\"isAdmin\" AS \"Person_isAdmin\", \"Person\".\"firstName\" AS \"Person_firstName\", \"Person\".\"lastName\" AS \"Person_lastName\", \"Person\".\"email\" AS \"Person_email\" \r\nFROM \"person\" \"Person\" WHERE Person.email=$1 -- PARAMETERS: [\"cuwe@natatih.pw\"]\r\nerror:  { error: invalid reference to FROM-clause entry for table \"person\"\r\n  name: 'error',\r\n  length: 189,\r\n  severity: 'ERROR',\r\n  code: '42P01',\r\n  detail: undefined,\r\n  hint: 'Perhaps you meant to reference the table alias \"Person\".',\r\n  position: '612',\r\n  internalPosition: undefined,\r\n  internalQuery: undefined,\r\n  where: undefined,\r\n  schema: undefined,\r\n  table: undefined,\r\n  column: undefined,\r\n  dataType: undefined,\r\n  constraint: undefined,\r\n  file: 'parse_relation.c',\r\n  line: '3233',\r\n  routine: 'errorMissingRTE' }\r\n\r\n```\r\n\r\nThe `WHERE` clause is the problem:\r\n\r\n```sql\r\nWHERE Person.email=$1\r\n```\r\nIt should be:\r\n\r\n```sql\r\nWHERE \"Person\".\"email\"=$1\r\n```\r\nWithout the quotes `Person` refers to the `person` table, which can only be referred to by its alias `\"Person\"`.\r\n\r\nThis query is my current workaround:\r\n\r\n```typescript\r\nreturn this.repo.createQueryBuilder('person')\r\n      .where('person.email = :email', { email: normalizeEmail(email) })\r\n      .getOne()\r\n```\r\n\r\n```\r\nexecuting query:  SELECT \"person\".\"createdAt\" AS \"person_createdAt\", \"person\".\"updatedAt\" AS \"person_updatedAt\", \"person\".\"id\" AS \"person_id\", \"person\".\"creationAction\" AS \"person_creationAction\", \"person\".\"emailVerified\" AS \"person_emailVerified\", \"person\".\"emailVerificationTokenId\" AS \"person_emailVerificationTokenId\", \"person\".\"passwordHash\" AS \"person_passwordHash\", \"person\".\"passwordResetTokenId\" AS \"person_passwordResetTokenId\", \"person\".\"isAdmin\" AS \"person_isAdmin\", \"person\".\"firstName\" AS \"person_firstName\", \"person\".\"lastName\" AS \"person_lastName\", \"person\".\"email\" AS \"person_email\" \r\nFROM \"person\" \"person\" WHERE person.email = $1 -- PARAMETERS: [\"usuzovaw@wiwgi.gov\"]\r\n```\r\n\r\nIt works because then the table alias is the same as the table name.\r\n\r\n- typeorm: ^0.1.9\r\n- postgresql: 10.1-1.pgdg90+1",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/1357/comments",
    "author": "blaugold",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-12-18T14:56:45Z",
        "body": "when creating query you must use entity property names, not database name. Can you show me your entity?"
      },
      {
        "user": "blaugold",
        "created_at": "2017-12-18T15:01:11Z",
        "body": "@pleerock I was wrong. I changed the issue. Please read it again.\r\n\r\nThe entity is quite large so this is just the property:\r\n\r\n```typescript\r\n  @IsEmail()\r\n  @IsOptional()\r\n  @Column({ name: 'email', type: String, nullable: true, unique: true })\r\n  private _email: string | null = null\r\n```"
      },
      {
        "user": "pleerock",
        "created_at": "2017-12-18T15:03:00Z",
        "body": "you need to use `_email` in your query instead of `email` as I said:\r\n\r\n> when creating query you must use entity property names, not database names\r\n\r\n```ts\r\nthis.repo.findOne({ _email: normalizeEmail(email) })\r\n```\r\n\r\n```ts\r\nreturn this.repo.createQueryBuilder('person')\r\n      .where('person._email = :email', { email: normalizeEmail(email) })\r\n      .getOne()\r\n```\r\n\r\n"
      },
      {
        "user": "blaugold",
        "created_at": "2017-12-18T15:03:58Z",
        "body": "@pleerock Sorry just got what you meant. Thanks. Love typeorm."
      },
      {
        "user": "obedm503",
        "created_at": "2018-02-17T04:49:19Z",
        "body": "just got the same error. It would be nice to get better error messages. maybe doing some checks like if the `where` key exists in the entity, but only do these checks if `process.env.NODE_ENV` === `development`?"
      }
    ]
  },
  {
    "number": 1345,
    "title": "Is it possible to define (A | B)[] relation?",
    "created_at": "2017-12-14T17:34:07Z",
    "closed_at": "2017-12-14T22:57:26Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/1345",
    "body": "First of all, thank you all for this great package – it's a breeze 🙇🏻‍♂️\r\n\r\nQuestion I have is this.\r\n\r\n```ts\r\n@Entity()\r\nclass A {\r\n  @Column()\r\n  a: string\r\n}\r\n\r\n@Entity()\r\nclass B {\r\n  @Column()\r\n  b: number\r\n}\r\n```\r\n\r\n**how to make such `C`?**\r\n\r\n```ts\r\n@Entity()\r\nclass C {\r\n  @Column(/* ??? */)\r\n  entries: (A | B)[]\r\n}\r\n```",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/1345/comments",
    "author": "dempfi",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-12-14T19:52:48Z",
        "body": "no, its not possible. If you want to bind C with A and B you need to create two relations in C with A and with B"
      },
      {
        "user": "dempfi",
        "created_at": "2017-12-14T22:54:33Z",
        "body": "I somehow missed simple fact – I can do whatever I want with the `C` class (like define entries aggregated getter). Thank you @pleerock."
      }
    ]
  },
  {
    "number": 1342,
    "title": "Left-joining single table multiple time with different conditions",
    "created_at": "2017-12-14T04:29:00Z",
    "closed_at": "2017-12-14T09:25:26Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/1342",
    "body": "When trying to join a single table multiple times with different conditions, parameter values don't seem to be updated:\r\n\r\n```js\r\n        this.createQueryBuilder('claim')\r\n            .select('claim.id')\r\n            .leftJoin(ClaimHistory, 'repairerDelivery',\r\n                '\"repairerDelivery\".\"claimId\" = claim.id AND \"repairerDelivery\".status = :status',\r\n                { status: 80 })\r\n            .leftJoin(ClaimHistory, 'buyerDelivery',\r\n                '\"buyerDelivery\".\"claimId\" = claim.id AND \"buyerDelivery\".status = :status',\r\n                { status: 100 })\r\n            .where('claim.\"repairerId\" = :id', { id: \"1\" })\r\n            .getRawMany();\r\n```\r\n\r\nGives this query\r\n\r\n```sql\r\nexecuting query:  SELECT \"claim\".\"id\" AS \"claim_id\" FROM \"claim\" \"claim\"\r\nLEFT JOIN \"claim_history\" \"repairerDelivery\" ON \"repairerDelivery\".\"claimId\" = \"claim\".\"id\" AND \"repairerDelivery\".status = $1 \r\nLEFT JOIN \"claim_history\" \"buyerDelivery\" ON \"buyerDelivery\".\"claimId\" = \"claim\".\"id\" AND \"buyerDelivery\".status = $2\r\nWHERE claim.\"repairerId\" = $3 -- PARAMETERS: [80,80,\"1\"] <---\r\n```\r\nIs this expected?",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/1342/comments",
    "author": "bytely",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-12-14T06:07:21Z",
        "body": "yes, parameter names must be unique across single query, you need to provide `status1` and `status2` variable names instead of single `status`"
      },
      {
        "user": "bytely",
        "created_at": "2017-12-14T09:25:26Z",
        "body": "I see, thank you."
      },
      {
        "user": "pookdeveloper",
        "created_at": "2019-06-21T11:07:30Z",
        "body": "Example:\r\n\r\n````javascript\r\n  var manager = getManager().getRepository(\"usuarios\").createQueryBuilder(\"usuarios\");\r\n        manager\r\n            .innerJoinAndSelect(\"usuarios.persona\", \"persona\")\r\n            .innerJoinAndSelect(\"usuarios.empleado\", \"empleado\")\r\n            .where(\"1 = 1\")\r\n            .andWhere(\"usuarios.id_categoria = :id_categoria\", { id_categoria: 1 })\r\n            .andWhere(\"persona.dni = :dni\", { dni: \"5399522a\" })\r\n            .andWhere(\"empleado.dni = :dni2\", { dni2: \"5399522d\" })\r\n\r\n        const datos = await manager.getMany();\r\n````"
      }
    ]
  },
  {
    "number": 1331,
    "title": "typeorm with pure SQL output",
    "created_at": "2017-12-11T19:23:07Z",
    "closed_at": "2017-12-22T13:43:36Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/1331",
    "body": "I have been using knex for a while and I know it is totally different from typeorm, but I didnt found one feature that is present there. The `.toString()` method that returns an array of query strings filled out with the correct values based on bindings, etc.\r\n\r\nEx.: \r\n```javascript\r\nvar toStringQuery = knex.select('*').from('users').where('id', 1).toString();\r\n\r\n// Outputs: console.log(toStringQuery); \r\n// select * from \"users\" where \"id\" = 1\r\n\r\n```\r\n\r\nIs there some similar feature on typeorm?",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/1331/comments",
    "author": "calebeaires",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-12-12T07:03:45Z",
        "body": "Yes you can use `getSql` method or `printSql` to instantly print sql query to console:\r\n\r\n```ts\r\nconst sql = connection.createQueryBuilder()\r\n    .select(\"user\")\r\n    .from(User, \"user\")\r\n    .where(\"user.id = :id\", { id: 1 })\r\n    .getSql();\r\n```\r\n\r\nor\r\n\r\n```ts\r\nconst users = await connection.createQueryBuilder()\r\n    .select(\"user\")\r\n    .from(User, \"user\")\r\n    .where(\"user.id = :id\", { id: 1 })\r\n    .printSql()\r\n    .getMany();\r\n```"
      },
      {
        "user": "calebeaires",
        "created_at": "2017-12-22T13:43:36Z",
        "body": "Awesome"
      },
      {
        "user": "guotie",
        "created_at": "2018-05-16T08:30:56Z",
        "body": "why printSql() did not print sql to console\r\n\r\nversion: 0.2.5\r\n"
      },
      {
        "user": "DcsPeterDickten",
        "created_at": "2018-09-15T08:21:16Z",
        "body": "> why printSql() did not print sql to console\r\n> \r\n> version: 0.2.5\r\n\r\nMake sure you have logging enabled (in the database connection or the ormconfig.json file):\r\n\"logging\": true,\r\n"
      },
      {
        "user": "muamichali",
        "created_at": "2018-09-18T17:40:24Z",
        "body": "When I turn on logging in the database connection, I get ALL of the queries not just the ones with printSql (upgrading to 0.2.7 -- this used to work as I expect it to in older typeorm versions)"
      },
      {
        "user": "sanderboom",
        "created_at": "2018-11-05T12:44:31Z",
        "body": "Is there a handy way to print raw SQL with integrated parameters when I'm using not using the QueryBuilder but e.g. `this.connection.query(sql, parameters)`?\r\n\r\nI know when using mysql/mariadb the extra `debug: ['ComQueryPacket']` option will give me the query and a lot more, but something like `getSql()` would be extremely handy :)"
      },
      {
        "user": "darkyelox",
        "created_at": "2018-11-18T15:23:01Z",
        "body": "printSql must print SQL without the logging: true parameter, it doesn't"
      },
      {
        "user": "havenchyk",
        "created_at": "2018-11-18T18:07:43Z",
        "body": "@darkyelox could you please create a new issue for this?"
      },
      {
        "user": "werts",
        "created_at": "2019-05-10T06:28:13Z",
        "body": "> > why printSql() did not print sql to console\r\n> > version: 0.2.5\r\n> \r\n> Make sure you have logging enabled (in the database connection or the ormconfig.json file):\r\n> \"logging\": true,\r\n\r\nAha, you save my life"
      },
      {
        "user": "kuklei",
        "created_at": "2019-10-26T15:04:07Z",
        "body": "And now it prints it twice. Once by the logger in the ormconfig and once by the directive"
      },
      {
        "user": "awHamer",
        "created_at": "2020-09-11T16:39:27Z",
        "body": "> > why printSql() did not print sql to console\r\n> > version: 0.2.5\r\n> \r\n> Make sure you have logging enabled (in the database connection or the ormconfig.json file):\r\n> \"logging\": true,\r\n\r\nIn this case it will turn on logging for any query (including the one we want to print - it will print it twice) \r\n+ it prints with an array of parameters instead of print a RAW sql in the way it will go to db...\r\n\r\nI want to log exactly what goes to db w/o having manually put data replacing each `?` mark.\r\nAny progress ? It's very important thing :( Enabling all query log creates a lot of mess and it's hard to get a correct one + it also doesn't print RAW sql."
      },
      {
        "user": "royalcala",
        "created_at": "2020-09-14T15:38:05Z",
        "body": "printSql and getSql it's only avaible for print queries?, I didn't see in jsDoc how to print from table definitions. \r\nlike \r\nknex.schema.createTable('users', function (table) {\r\n  table.increments();\r\n  table.string('name');\r\n  table.timestamps();\r\n}).toQuery()\r\nprints:\r\ncreate table `users` (`id` integer not null primary key autoincrement, `name` varchar(255), `created_at` datetime, `updated_at` datetime)\r\n\r\nthanks,\r\nregards. \r\n"
      },
      {
        "user": "mimoid-prog",
        "created_at": "2021-03-13T20:12:00Z",
        "body": "`printSql` still doesn't work in 2021. The only way I can see the sql queries right now is by setting `logging: true`, which is not good because it prints every possible query."
      }
    ]
  },
  {
    "number": 1322,
    "title": "queryBuilder parameters: duplicated parameters name",
    "created_at": "2017-12-09T05:52:28Z",
    "closed_at": "2017-12-16T10:38:13Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/1322",
    "body": "        const tokens = s.split(' ');\r\n        for (const token of tokens) {\r\n          queryBuilder.andWhere(new Brackets(tokenQb => {\r\n            tokenQb.where('person.name ILIKE :token');\r\n            tokenQb.orWhere('person.lastName ILIKE :token');\r\n          })).setParameters({token: token});\r\n        }\r\n\r\nWhen s = \"foo bar\", I should get the query ... WHERE (person.firstName ILIKE 'foo' OR person.lastName ILIKE 'foo') AND (person.firstName ILIKE 'bar' OR person.lastName ILIKE 'bar').\r\n\r\nHowever, I got ... WHERE (person.firstName ILIKE 'bar' OR person.lastName ILIKE 'bar') AND (person.firstName ILIKE 'bar' OR person.lastName ILIKE 'bar') instead.\r\n\r\nHow can I achieve this?",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/1322/comments",
    "author": "dvh312",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-12-12T12:03:22Z",
        "body": "Parameters must be unique. The way you can change your code:\r\n\r\n```ts\r\ns.split(' ').forEach((token, index) => {\r\n      const parameterName = \"token\" + index;\r\n      queryBuilder.andWhere(new Brackets(tokenQb => {\r\n        tokenQb.where('person.name ILIKE :' + parameterName);\r\n        tokenQb.orWhere('person.lastName ILIKE :' + parameterName);\r\n      })).setParameter(parameterName, token);\r\n    });\r\n```"
      },
      {
        "user": "dvh312",
        "created_at": "2017-12-16T07:59:16Z",
        "body": "Thanks!"
      },
      {
        "user": "pimplibence",
        "created_at": "2018-11-10T14:00:31Z",
        "body": "> Parameters must be unique. The way you can change your code:\r\n> \r\n> ```ts\r\n> s.split(' ').forEach((token, index) => {\r\n>       const parameterName = \"token\" + index;\r\n>       queryBuilder.andWhere(new Brackets(tokenQb => {\r\n>         tokenQb.where('person.name ILIKE :' + parameterName);\r\n>         tokenQb.orWhere('person.lastName ILIKE :' + parameterName);\r\n>       })).setParameter(parameterName, token);\r\n>     });\r\n> ```\r\n\r\n@pleerock why should be the parameters unique? Programatically the parameter naming belongs to the it own 'where' function scope. If you would like to use a huge parameter bag you have to use query level naming despite of function scope level. "
      },
      {
        "user": "lovinu99",
        "created_at": "2021-09-13T15:14:17Z",
        "body": "for someone looking the way to combine conditions into your queryBuilder, u r right to come here ✌️ this answer saved my life 💯  "
      }
    ]
  },
  {
    "number": 1298,
    "title": "Logger.log is unused",
    "created_at": "2017-12-04T17:37:05Z",
    "closed_at": "2017-12-05T14:39:05Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/1298",
    "body": "I have search for usages for Logger.log and is not being used is there any intention to use it?",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/1298/comments",
    "author": "pravdomil",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-12-05T05:06:41Z",
        "body": "Currently we are logging mostly queries only, in the future we are planning to provide more detailed logs on what internally happens in typeorm, and `log` method will be used for that"
      }
    ]
  },
  {
    "number": 1276,
    "title": "about couchbase(couchdb) driver",
    "created_at": "2017-11-30T13:12:31Z",
    "closed_at": "2018-02-20T11:55:20Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/1276",
    "body": "hello\r\n\r\n     I use couchbase server, It's like Mongodb, a json database.  typeorm haven't the driver supports.\r\nCan I define driver myself? or offical can provide the driver?\r\n\r\n    thanks!",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/1276/comments",
    "author": "zhuangpeng",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-11-30T13:28:13Z",
        "body": "Official support is not planned and unlikely will be. Yes you can implement your own driver, take a look how mongodb driver is implemented. But tbh its not a trivial task because of difference you may have with rdbms drivers."
      },
      {
        "user": "marc0s",
        "created_at": "2018-03-09T09:54:59Z",
        "body": "@zhuangpeng did you start any development on this?  I'd be interested in a couchbase driver, willing to develop it myself if needed.  I'm in an evaluation phase, but chances to have the resources to work on this are high.\r\n\r\nAny other advice/tip apart from studying the mongodb driver, @pleerock ?\r\n\r\nThanks!"
      },
      {
        "user": "pleerock",
        "created_at": "2018-03-09T09:58:23Z",
        "body": "source code is place of studying, just take a look on mongodb driver and start digging things "
      },
      {
        "user": "zi9o",
        "created_at": "2019-02-25T13:57:59Z",
        "body": "Hi guys, I hope everyone is doing good. @zhuangpeng and @marc0s would it be rude when asking if you worked on this driver for couchbase?"
      },
      {
        "user": "corbinu",
        "created_at": "2019-02-25T14:08:30Z",
        "body": "@zi9o I have been working on a fork for Couchbase. It is a little complicated as the MongoDB driver really is missing a lot of features Couchbase supports due to N1QL. I will update when I am getting closer to having something to release."
      },
      {
        "user": "yf-hk",
        "created_at": "2020-03-11T09:25:31Z",
        "body": "Any progress?"
      },
      {
        "user": "corbinu",
        "created_at": "2020-03-11T17:03:16Z",
        "body": "@dzcpy Sorry I am no longer using typeORM"
      },
      {
        "user": "yf-hk",
        "created_at": "2020-12-25T07:01:34Z",
        "body": "Is there any one interested in developing one?"
      }
    ]
  },
  {
    "number": 1274,
    "title": "Conflicting columns?",
    "created_at": "2017-11-30T10:19:50Z",
    "closed_at": "2017-11-30T11:41:24Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/1274",
    "body": "I noticed this in the docs:\r\n\r\n```js\r\n// example how to load DM entities\r\nconst users = await userRepository.find({ skip: 2, take: 5 });\r\nconst newUsers = await userRepository.find({ isActive: true });\r\nconst timber = await userRepository.findOne({ firstName: \"Timber\", lastName: \"Saw\" });\r\n```\r\n\r\nWhat happens if there are columns named `skip` or `take`?",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/1274/comments",
    "author": "leebenson",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-11-30T10:49:59Z",
        "body": "ORM kinda reserves these property names and it will use `skip` and `take` for pagination instead of column criteria. To use column criteria you'll need to do:\r\n\r\n```ts\r\nconst users = await userRepository.find({ where: { skip: 2, take: 5 } });\r\n```\r\n\r\nYes, its a bit tricky, but its a small downside compared with benefits find options bring."
      },
      {
        "user": "leebenson",
        "created_at": "2017-11-30T10:54:54Z",
        "body": "Np. I've literally just started using TypeORM, so this wasn't a use-case I'd run up against- just something I spotted in the docs that wasn't explained."
      },
      {
        "user": "pleerock",
        "created_at": "2017-11-30T11:05:00Z",
        "body": "I did not add note in the docs because possibility of having such conflicts is very low, and I did not want to confuse users. But this totally should be documented somewhere, in kinda \"secondary place\" for user eyes."
      }
    ]
  },
  {
    "number": 1262,
    "title": "QUESTION: can I use my models inside a migration?",
    "created_at": "2017-11-29T11:41:13Z",
    "closed_at": "2018-02-20T11:56:23Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/1262",
    "body": "",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/1262/comments",
    "author": "toonvanstrijp",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-11-29T11:59:07Z",
        "body": "yes, what is the purpose, please provide concrete examples of what you are trying to accomplish "
      },
      {
        "user": "pleerock",
        "created_at": "2018-02-20T11:56:23Z",
        "body": "Closing as no answer from reporter."
      }
    ]
  },
  {
    "number": 1249,
    "title": "leftJoinAndSelect not return all selected entities",
    "created_at": "2017-11-28T12:14:13Z",
    "closed_at": "2018-03-12T08:15:23Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/1249",
    "body": "I'm working with postgres.\r\n\r\nI use this way to join the tables (I try to link two unrelated tables: Data --> Device)\r\n```typescript\r\nconst list = await this.sensorDataRepository.createQueryBuilder(\"data\")\r\n            .leftJoinAndSelect(Device, 'device', **'device.id = data.device.id'**)\r\n            .getMany();\r\n```\r\n\r\nQuery: \r\n```\r\nSELECT \"data\".\"id\" AS \"data_id\", \"data\".\"value\" AS \"data_value\", \"data\".\"createdDate\" AS \"data_createdDate\", \"data\".\"createdBy\" AS \"data_createdBy\", \"data\".\"lastUpdatedDate\" AS \"data_lastUpdatedDate\", \"data\".\"lastUpdatedBy\" AS \"data_lastUpdatedBy\", \"data\".\"deviceId\" AS \"data_deviceId\", \"data\".\"sensorId\" AS \"data_sensorId\", \"_device\".\"id\" AS \"device_id\", \"device\".\"name\" AS \"device_name\", \"device\".\"location\" AS \"device_location\", \"device\".\"mac\" AS \"device_mac\", \"device\".\"refreshTime\" AS \"device_refreshTime\", \"device\".\"status\" AS \"device_status\", \"device\".\"notes\" AS \"device_notes\", \"device\".\"createdDate\" AS \"device_createdDate\", \"device\".\"createdBy\" AS \"device_createdBy\", \"device\".\"lastUpdatedDate\" AS \"device_lastUpdatedDate\", \"device\".\"lastUpdatedBy\" AS \"device_lastUpdatedBy\", \"device\".\"companyId\" AS \"device_companyId\" FROM \"SensorsData\" \"data\" LEFT JOIN \"Devices\" \"device\" ON \"device\".\"id\" = \"data\".\"deviceId\"_\r\n```\r\n\r\nThis Query select all columns for data an device but the orm only return the 'data' columns:\r\n```json\r\n   {\r\n            \"id\": 1,\r\n            \"value\": \"2720\",\r\n            \"createdDate\": \"2017-10-30T02:19:39.000Z\",\r\n            \"createdBy\": 1,\r\n            \"lastUpdatedDate\": null,\r\n            \"lastUpdatedBy\": 0\r\n    },\r\n```\r\nI do not know what I'm doing wrong, since with a ManyToMany field it returns all the columns. \r\n```typescript\r\nconst list = await this.sensorDataRepository.createQueryBuilder(\"data\")\r\n            .leftJoinAndSelect(**'data.device'**, 'device')\r\n            .getMany();\r\n```\r\n\r\nDala returned:\r\n\r\n```json\r\n\"data\": [\r\n        {\r\n            \"id\": 1,\r\n            \"value\": \"2720\",\r\n            \"createdDate\": \"2017-10-30T02:19:39.000Z\",\r\n            \"createdBy\": 1,\r\n            \"lastUpdatedDate\": null,\r\n            \"lastUpdatedBy\": 0,\r\n            \"device\": {\r\n                \"id\": \"1\",\r\n                \"name\": \"PLC 95\",\r\n                \"location\": \"Location A\",\r\n                \"mac\": \"00:0a:95:9d:68:16\",\r\n                \"refreshTime\": 15000,\r\n                \"status\": 1,\r\n                \"notes\": null,\r\n                \"createdDate\": \"2017-11-25T16:36:44.936Z\",\r\n                \"createdBy\": 1,\r\n                \"lastUpdatedDate\": null,\r\n                \"lastUpdatedBy\": 0\r\n            }\r\n        },\r\n```\r\n\r\nShould not return the same information both joins?\r\n\r\nThanks, for your time.\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/1249/comments",
    "author": "andenis",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-11-29T15:58:28Z",
        "body": "Use `leftJoinAndMapOne` method for this purpose.\r\n\r\n```ts\r\nconst list = await this.sensorDataRepository.createQueryBuilder(\"data\")\r\n            .leftJoinAndMapOne(\"data.device\", Device, 'device', **'device.id = data.device.id'**)\r\n            .getMany();\r\n```"
      }
    ]
  },
  {
    "number": 1225,
    "title": "Property mapping in querybuilder",
    "created_at": "2017-11-23T18:17:23Z",
    "closed_at": "2017-11-24T12:01:15Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/1225",
    "body": "Does the querybuilder map the entity properties to their database column names when filtering?\r\n\r\n```javascript\r\n@Entity(\"users\")\r\nexport class User {\r\n    @PrimaryGeneratedColumn()\r\n    id:number;\r\n\r\n    @Column(\"varchar\",{\r\n        name: \"first_name\"\r\n    })\r\n    firstName: string;\r\n\r\n    @Column(\"varchar\",{\r\n        name: \"last_name\"\r\n    })\r\n    lastName: string;\r\n}\r\n```\r\n\r\nCan i use ***firstName***  here or do i have to do use the actual column name that is in the database?\r\n\r\n```javascript\r\nconst user = await getManager()\r\n    .createQueryBuilder(User, \"user\")\r\n    .where(\"user.firstName = :bind\", { bind: \"John\" })\r\n    .getOne();\r\n```\r\n\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/1225/comments",
    "author": "ibox4real",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-11-24T04:25:21Z",
        "body": "Correct, it maps. You must use property names, not database names."
      },
      {
        "user": "ibox4real",
        "created_at": "2017-11-24T12:01:15Z",
        "body": ":thumbsup:"
      }
    ]
  },
  {
    "number": 1213,
    "title": "How to show rows changed from createQueryBuilder",
    "created_at": "2017-11-22T08:19:52Z",
    "closed_at": "2017-11-22T08:51:21Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/1213",
    "body": "Given a simple query like this:\r\n\r\n```typescript\r\ntypeorm.connection.manager\r\n       .createQueryBuilder()\r\n       .insert()\r\n       .into(User)\r\n       .values(req.body)\r\n       .execute()\r\n       .then((user: User) => console.info('user =', user, ';'))\r\n```\r\n\r\nIt succeeds, but the output is: `user = [] ;`. How do I show the created rows?\r\n\r\nOr do I need to add a select query in the `.then` callback?",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/1213/comments",
    "author": "SamuelMarks",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-11-22T08:50:50Z",
        "body": "correct, you need to select data, insert query just inserts your entity, nothing more."
      },
      {
        "user": "SamuelMarks",
        "created_at": "2017-11-22T08:51:21Z",
        "body": "Thanks"
      }
    ]
  },
  {
    "number": 1204,
    "title": "[question] Transactional test case with repositories",
    "created_at": "2017-11-20T18:35:51Z",
    "closed_at": "2018-01-02T12:20:46Z",
    "labels": [
      "question",
      "comp: testing"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/1204",
    "body": "What is a right way of implementing the e2e tests ?\r\n\r\nIn current solution I test database in mysql server - this allow me to test exactly the same state of database as in usuall way with enviroments and migrations. I tried to use sqlite as in memory database - but it fails due to differences in sql syntax.\r\n\r\nIn application I'm using repositories with `connection.getRepository(entityClass)`\r\n\r\nActually I want to achive the reset of database state per each test case. Is there any confirmed solution which will work or a right way of doing it ?\r\n\r\nWith this solution internal transaction used by repository is finally committed.\r\n\r\nThe test case looks:\r\n\r\n```ts\r\nimport \"mocha\";\r\nimport * as request from 'supertest';\r\nimport {getConnection} from \"typeorm\";\r\n\r\ndescribe('ControllerE2E', function () {\r\n\r\n    const server; /* server initialization where connection is bootstrapped */\r\n    \r\n    beforeEach(async () => {\r\n\r\n        this.connection = getConnection();\r\n        this.queryRunner = this.connection.driver.createQueryRunner(\"master\");\r\n        await this.queryRunner.startTransaction();\r\n\r\n    });\r\n\r\n    afterEach(async () => {\r\n        await this.queryRunner.rollbackTransaction();\r\n        await this.queryRunner.release();\r\n    });\r\n\r\n    it(`return 200`, async () => {\r\n\r\n        const entityRepository = this.connection.getRepository(Entity);\r\n        const entity = new Entity();\r\n\r\n        Object.assign(entity, {\r\n            value1: 1,\r\n            value2: '2',\r\n            value3: '3'\r\n        });\r\n\r\n        await entityRepository.save(entity);\r\n\r\n        return request(server)\r\n            .post('/api/endpoint')\r\n            .expect(200)\r\n        \r\n});\r\n```",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/1204/comments",
    "author": "szkumorowski",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-11-21T16:10:29Z",
        "body": "complete testing strategy and guidelines are not implemented yet, however I recommend you to use separate connection with separate database and clear database after each test run,  something like this:\r\n\r\n```ts\r\nimport \"mocha\";\r\nimport * as request from 'supertest';\r\nimport {createConnection} from \"typeorm\";\r\n\r\ndescribe('ControllerE2E', function () {\r\n\r\n    const server; /* server initialization where connection is bootstrapped */\r\n    \r\n    beforeEach(async () => {\r\n        this.connection = createConnection({ separate configuration for testing });\r\n    });\r\n\r\n    afterEach(async () => {\r\n        await this.connection.dropDatabase();\r\n    });\r\n\r\n    it(`return 200`, async () => {\r\n\r\n        const entityRepository = this.connection.getRepository(Entity);\r\n        const entity = new Entity();\r\n\r\n        Object.assign(entity, {\r\n            value1: 1,\r\n            value2: '2',\r\n            value3: '3'\r\n        });\r\n\r\n        await entityRepository.save(entity);\r\n\r\n        return request(server)\r\n            .post('/api/endpoint')\r\n            .expect(200)\r\n        \r\n});\r\n```\r\n\r\nAnd apparently you'll need to run your api server under those \"testing connection options\" as well"
      },
      {
        "user": "ilvsx",
        "created_at": "2017-12-30T08:28:51Z",
        "body": "@pleerock\r\n\r\nrun the test will return:\r\n\r\n```\r\n  2) \"after each\" hook for \"return 200\":\r\n     TypeError: this.connection.clearDatabase is not a function\r\n      at Object.<anonymous> (src/test/test.ts:24:27)\r\n      at Generator.next (<anonymous>)\r\n      at src/test/test.ts:7:71\r\n      at new Promise (<anonymous>)\r\n      at __awaiter (src/test/test.ts:3:12)\r\n      at Context.afterEach (src/test/test.ts:21:17)\r\n```"
      },
      {
        "user": "pleerock",
        "created_at": "2018-01-02T11:38:37Z",
        "body": "@ilvsx sorry its called `dropDatabase`"
      },
      {
        "user": "ilvsx",
        "created_at": "2018-01-02T12:08:02Z",
        "body": "@pleerock  Thanks, My mistake"
      },
      {
        "user": "Kurry",
        "created_at": "2018-04-17T18:02:03Z",
        "body": "@pleerock can you add an example for a `POST` test? and how you would think about the app connection and the test connection, to validate the new resource was created."
      }
    ]
  },
  {
    "number": 1199,
    "title": "Entity.find with relations returns whole table and ignores conditions",
    "created_at": "2017-11-18T17:20:35Z",
    "closed_at": "2017-11-20T07:07:04Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/1199",
    "body": "In order to receive an entity with its relations (let's say, Photo and Author as in the example).\r\n```\r\nAuthor.find({ name: 'Author name', relations: ['photos']);\r\n```\r\n\r\nI would expect this to return only authors who's name is \"Author name\", and return them with the photos. Instead, this returns all authors. My way around this is to first get the author (without the `relations: ['photos']` part), and then use `Photo.find({ authorId: author.id })`.\r\n\r\nUnless I'm missing something, as long as I add the relations part to the object, the \"name\" criteria is ignored?\r\n\r\nThanks",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/1199/comments",
    "author": "arielweinberger",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-11-18T19:14:37Z",
        "body": "`find` accepts either `FindOptions` either column names to search by. You need to change it this way:\r\n\r\n```ts\r\nAuthor.find({ where: { name: \"Author name\" }, relations: ['photos']);\r\n```"
      }
    ]
  },
  {
    "number": 1195,
    "title": "Problem pagination with getRawMany() : either skip or offset don't work",
    "created_at": "2017-11-17T11:12:33Z",
    "closed_at": "2017-11-17T14:48:24Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/1195",
    "body": "Hi.\r\n\r\nI'm creating a query with QueryBuilder created from an entity repository.\r\n\r\n`q = this.appsRepository.createQueryBuilder('apps');`\r\n\r\nI'm adding multiple options depending on multiple conditions. One of those is to add a \"from - to\" pagination like :\r\n\r\n`this.oResult.limit = {\r\n    from: (limitFrom < 1) ? 1 : limitFrom,\r\n    to: limitTo ? limitTo : ((limitFrom > 0) ? limitFrom - 1 : 0) + 100,\r\n    previous_element: (limitFrom > 0) ? limitFrom - 1 : 0,\r\n    returned_element: 0,\r\n    remaining_element : 0,\r\n    total_element: 0,\r\n    next: '',\r\n};\r\n\r\nq.limit(this.oResult.limit.to - this.oResult.limit.previous_element)\r\n  .offset(this.oResult.limit.previous_element);`\r\n\r\nThis work well while using .getMany() function but when I try with .getRawMany() only limit option works.\r\nI also tried using skip & take, but none of those works on .getRawMany()\r\n\r\nI didn't found many documentation on using getRawMany function, is there a way to make the offset (or skip, or any other working same way) to work on getRawMany ?\r\n\r\nThanks for your time and answer.\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/1195/comments",
    "author": "CFA-Wisolv",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-11-17T11:33:58Z",
        "body": "with `getRawMany` both `offset` and `limit` must work. `skip` and `take` don't work for raw queries. Can you provide a minimal reproduction code of your issue and what SQL it generates for you? (you can enable query logging by setting `logging: true` in connection options)"
      },
      {
        "user": "CFA-Wisolv",
        "created_at": "2017-11-17T14:01:14Z",
        "body": "Sorry, looks like the problem came from something different than I was thinking. Offset works great thanks."
      }
    ]
  },
  {
    "number": 1188,
    "title": "Failed to connect to tcp:server.windows.net:1433 - getaddrinfo ENOTFOUND",
    "created_at": "2017-11-16T07:15:23Z",
    "closed_at": "2017-11-20T07:07:38Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/1188",
    "body": "how can i connect to my server database 'MSSQL'\r\n\r\nhere is my config file\r\n```\r\nimport 'reflect-metadata';\r\nimport { ConnectionOptions } from 'typeorm';\r\n\r\nimport { UserEntity } from '../models/entities/user.entity';\r\nimport { UserRoleEntity } from '../models/entities/user-roles.entity';\r\n\r\nexport let dbOptions: ConnectionOptions = {\r\n    type: 'mssql',\r\n    host: 'tcp:server.windows.net',\r\n    port: 1433,\r\n    username: 'user@sqlserver.database.windows.net',\r\n    password: 'password',\r\n    database: 'TestDB',\r\n    entities: [\r\n        UserEntity,\r\n        UserRoleEntity\r\n    ],\r\n    synchronize: true,\r\n    logging: ['error', 'warn', 'schema'],\r\n    maxQueryExecutionTime: 1000,\r\n    logger: 'file'\r\n};\r\n```\r\n\r\nhere is error i got\r\n\r\n> TypeORM connection error:  { ConnectionError: Failed to connect to tcp:server.windows.net:1433 - getaddrinfo ENOTFOUND tcp:server.windows.net:1433\r\n>     at Connection.tedious.once.err (D:\\Projects\\Finception\\dev\\node_modules\\mssql\\lib\\tedious.js:216:17)\r\n>     at Object.onceWrapper (events.js:316:30)\r\n>     at emitOne (events.js:115:13)\r\n>     at Connection.emit (events.js:210:7)\r\n>     at Connection.socketError (D:\\Projects\\Finception\\dev\\node_modules\\tedious\\lib\\connection.js:869:14)\r\n>     at D:\\Projects\\Finception\\dev\\node_modules\\tedious\\lib\\connection.js:739:25\r\n>     at GetAddrInfoReqWrap.callback (D:\\Projects\\Finception\\dev\\node_modules\\tedious\\lib\\connector.js:68:18)\r\n>     at GetAddrInfoReqWrap.onlookupall [as oncomplete] (dns.js:107:17)\r\n>   code: 'ESOCKET',\r\n>   originalError:\r\n>    { ConnectionError: Failed to connect to tcp:server.windows.net:1433 - getaddrinfo ENOTFOUND tcp:server.windows.net:1433\r\n>     at ConnectionError (D:\\Projects\\Finception\\dev\\node_modules\\tedious\\lib\\errors.js:12:12)\r\n>     at Connection.socketError (D:\\Projects\\Finception\\dev\\node_modules\\tedious\\lib\\connection.js:869:30)\r\n>     at D:\\Projects\\Finception\\dev\\node_modules\\tedious\\lib\\connection.js:739:25\r\n>     at GetAddrInfoReqWrap.callback (D:\\Projects\\Finception\\dev\\node_modules\\tedious\\lib\\connector.js:68:18)\r\n>     at GetAddrInfoReqWrap.onlookupall [as oncomplete] (dns.js:107:17)\r\n>      message: 'Failed to connect to tcp:server.windows.net:1433 - getaddrinfo ENOTFOUND tcp:server.windows.net:1433',\r\n>      code: 'ESOCKET' },\r\n>   name: 'ConnectionError' }\r\n\r\nplease tell what to change in my config for connecting to server database...",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/1188/comments",
    "author": "vipswelt",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-11-16T11:44:30Z",
        "body": "its not related to typeorm somehow. Check your connection credentials, server settings, etc."
      },
      {
        "user": "pleerock",
        "created_at": "2017-11-16T11:45:04Z",
        "body": "also you have a strange username"
      },
      {
        "user": "vipswelt",
        "created_at": "2017-11-16T12:00:47Z",
        "body": "i cannot post real credentials so that i have posted similar one... its an azure database"
      },
      {
        "user": "vipswelt",
        "created_at": "2017-11-16T12:17:05Z",
        "body": "this is my connection string... \r\n```\r\n<databases>\r\n      <add name=\"defaultConnection\" connectionString=\"Data Source=tcp:testdevsqlserver.database.windows.net,1433;Initial Catalog=TestCoreDb;User Id=testadmin@testdevsqlserver.database.windows.net;Password=Test123;\" providerName=\"System.Data.SqlClient\" type=\"Sql\" targetDatabaseEngineType=\"sqlazuredatabase\" targetServerVersion=\"Version100\" />\r\n    </databases>\r\n```"
      },
      {
        "user": "vipswelt",
        "created_at": "2017-11-16T12:53:26Z",
        "body": "is there any support for azure database...?"
      },
      {
        "user": "vipswelt",
        "created_at": "2017-11-16T12:53:44Z",
        "body": "please reply... #urgent"
      },
      {
        "user": "pleerock",
        "created_at": "2017-11-16T13:47:20Z",
        "body": "yeah there are were people who were using typeorm with azure. Try to ask people on gitter"
      },
      {
        "user": "vipswelt",
        "created_at": "2017-11-16T13:50:43Z",
        "body": "thanks... its connected i used\r\n\r\n`options: {encrypt: true}, in my config file`\r\n\r\nbut getting a warning now, help me if it could be solved\r\n\r\n> (node:73628) [DEP0064] DeprecationWarning: tls.createSecurePair() is deprecated. Please use tls.Socket instead."
      },
      {
        "user": "pleerock",
        "created_at": "2017-11-16T13:53:59Z",
        "body": "I guess its a question to underlying driver - node-mssql"
      },
      {
        "user": "mehtanilay10",
        "created_at": "2020-09-03T16:15:43Z",
        "body": "**Yes**, Azure SQL Server is supported. I'm using it in one of my projects. \r\nI'm using the below config to connect Azure SQL Server with username/password.\r\nPosting here so it can help someone else.\r\n\r\n> **Note**: I have not included tcp or port in `host` as well as db-server name not added in `username` configs.\r\n\r\n```\r\n{\r\n    \"type\": \"mssql\",\r\n    \"host\": \"<db-server-name>.database.windows.net\",\r\n    \"username\": \"<just-username>\",\r\n    \"password\": \"<your-db-server-password>\",\r\n    \"database\": \"<your-db-name>\",\r\n    \"extra\": {\r\n        \"options\": {\r\n            \"encrypt\": true\r\n        }\r\n    },\r\n    ...\r\n}\r\n```"
      }
    ]
  },
  {
    "number": 1185,
    "title": "Can not use alias in find()",
    "created_at": "2017-11-15T13:11:32Z",
    "closed_at": "2017-11-16T11:23:43Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/1185",
    "body": "Hi,\r\n\r\ntypeorm:0.0.11\r\n\r\nwhen i use \r\n```\r\n...find({alias: 'test'});\r\n```\r\n\r\nthen typeorm throws unhandled rejections: \r\n```\r\nUnhandled rejection Error: ER_BAD_FIELD_ERROR: Unknown column 'test.alias' in 'where clause'\r\n```\r\n\r\nis it fixed in newest version? i.e. typeorm@0.1.2?",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/1185/comments",
    "author": "szymonskirgajllo",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-11-16T06:07:28Z",
        "body": "Yes new version find syntax is simplified and does not have an `alias` parameter. Find now accepts set of typeorm-specific options or conditions, e.g. entity column - value set. See updated find options docs on site."
      },
      {
        "user": "szymonskirgajllo",
        "created_at": "2017-11-16T11:23:42Z",
        "body": "@pleerock thanks, so we need to update typeorm ;)"
      }
    ]
  },
  {
    "number": 1175,
    "title": "Remap Raw Query",
    "created_at": "2017-11-13T14:48:35Z",
    "closed_at": "2017-11-20T07:20:02Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/1175",
    "body": "How I remap raw query in typeorm?\r\n\r\n**TypeScript**\r\n```\r\nclass UserEntity {\r\n   @PrimaryColumn({ name: \"ID\" })\r\n   id:number;\r\n\r\n   @Column({ name: \"NAME\" })\r\n   name:string;\r\n}\r\n\r\ngetManager().getRepository(UserEntity).query('SELECT ID, NAME FROM USER').then(retJSON => {\r\n     console.log(retJSON[0]['id']);\r\n});\r\n\r\ngetManager().getRepository(UserEntity).query('SELECT ID, NAME FROM USER').then((user:UserEntity ) => {\r\n     console.log(user.id);\r\n});\r\n```\r\n\r\n**JAVA**\r\n```\r\nQuery query = entityManager.createNativeQuery(\"SELECT ID, NAME FROM USER\", UserEntity.class);\r\nUserEntity user = (UserEntity)query.getSingleResult();\r\n```\r\n\r\n ",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/1175/comments",
    "author": "niveo",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-11-16T06:20:12Z",
        "body": "If we are talking about remaping raw results into entity then its not possible. are you executing raw query and raw results are expected. You can map them into real entity by yourself. Raw results are rows which database returns you when you are executing sql query.\r\n\r\nIf we are talking about just write a plain sql query to get entities, its kinda not possible because `query`'s method purpose is to return you raw results of your executed query. So, you have to use query builder functionality. TBH I don't see big value in adding \"raw and limited sql to real entity support\" when you can do same via query builder methods in a much more flexible and beautiful way."
      },
      {
        "user": "pleerock",
        "created_at": "2017-11-20T07:20:02Z",
        "body": "Let me know if you have something to add..."
      },
      {
        "user": "niveo",
        "created_at": "2019-03-21T18:15:13Z",
        "body": "\r\n```\r\nimport { plainToClass } from 'class-transformer';\r\n\r\nexport class Client{\r\n\t@Expose({ name: 'ID' })\r\n\tid: number;\r\n}\r\n\r\nexport class User {\r\n\t@Expose({ name: 'ID' })\r\n\tid: number;\r\n\t@Expose({ name: 'NAME' })\r\n\tname: string;\r\n\t@Type(() => Client)\r\n        client: Client;\r\n}\r\n\r\nlet ret = await this.connection.query(\"SELECT ID, NAME, CLIENT.ID AS 'client.ID' FROM USER JOIN CLIENT ON CLIENT.ID = USER.ID;\");\r\nret.forEach((e: any) => {\r\n\tObject.keys(e).forEach(key => {\r\n\t\tif (key.indexOf('.') != -1) {\r\n\t\t\tlet nameStart = key.substring(0, key.indexOf('.'));\r\n\t\t\tlet nameLast = key.substring(key.indexOf('.') + 1, key.length);\r\n\t\t\tif (!e[nameStart]) {\r\n\t\t\t\te[nameStart] = {};\r\n\t\t\t}\r\n\t\t\te[nameStart][nameLast] = e[key];\r\n\t\t\tdelete e[key]\r\n\t\t}\r\n\t});\r\n});\r\n\r\nconsole.log(plainToClass(User, ret as Object[]));\r\n\r\n/* JSON\r\n[ \r\n\tUser {\r\n    id: 1,\r\n    name: 'test1',\r\n    client:\r\n     Client {\r\n       id: 1,\r\n     } \r\n    }\r\n]\r\n```"
      }
    ]
  },
  {
    "number": 1173,
    "title": "`repository.updateById` won't trigger `BeforeUpdate` or `AfterUpdate`",
    "created_at": "2017-11-13T00:00:04Z",
    "closed_at": "2017-11-20T07:20:48Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/1173",
    "body": "`repository.updateById` won't trigger `BeforeUpdate` or `AfterUpdate`. When you updated entities using `updatedById` `BeforeUpdate` never get called `AfterUpdate`.\r\n\r\nTested on typeorm@0.1.2 and typeorm@next.",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/1173/comments",
    "author": "typeofweb",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-11-16T06:28:56Z",
        "body": "subscribers and listeners are very tricky. Lets say we have a post model with listeners applied:\r\n\r\n```ts\r\n@Entity()\r\nexport class Post {\r\n     ....\r\n     @BeforeUpdate()\r\n     beforeUpdate() {\r\n           this.counter += 1;\r\n     }\r\n}\r\n```\r\n\r\nWhen you are calling `updateById(id, updateMap)` by id it does roughly following:\r\n\r\n```ts\r\nupdateById(id, updateMap) {\r\n   return createQueryBuilder()\r\n     .update()\r\n     .set(updateMap)\r\n     .where({ id: id })\r\n     .execute();\r\n}\r\n```\r\n\r\nWhat this query builder does - it builds `UPDATE post SET ... WHERE id = :id` and executes it. That's all. There is no entity which method can be called, e.g. to call this listener we need to do `post.beforeUpdate()` because there is no `post` instance anywhere in this method.\r\n\r\nThose methods (delete, update, query builders) must be used when you want to execute quick query without extra checks and queries. `save` and `remove` methods do much more, but they cover all functionality typeorm has. So, you must use them instead."
      },
      {
        "user": "pleerock",
        "created_at": "2017-11-20T07:20:48Z",
        "body": "Let me know if I did not answer your question."
      }
    ]
  },
  {
    "number": 1127,
    "title": "postresql primary column with type \"bigint\" maps property as string",
    "created_at": "2017-11-01T12:13:13Z",
    "closed_at": "2017-11-01T13:02:56Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/1127",
    "body": "Hello, \r\nI noticed that primary column with type `bigint` maps property as `string` instead of `number`",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/1127/comments",
    "author": "darioxtx",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-11-01T12:44:38Z",
        "body": "Its a correct behaviour because regular `number` has `integer` length and cannot contain a bigint number values."
      },
      {
        "user": "darioxtx",
        "created_at": "2017-11-01T13:02:56Z",
        "body": "Thank you, I forgot about that."
      }
    ]
  },
  {
    "number": 1093,
    "title": "When we can expect cascade remove ",
    "created_at": "2017-10-25T08:13:11Z",
    "closed_at": "2017-11-17T15:11:43Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/1093",
    "body": "Hello, \r\n\r\nWe know that cascade remove is currently removed, but we want to check do you have any information when we can expect that functionality? \r\n\r\n\r\n ",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/1093/comments",
    "author": "harishajdarevic",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-10-25T11:40:46Z",
        "body": "cascade remove will be removed completely in `0.2.0` because of:\r\n\r\n* complexity it brings (the most complex part of orm, almost unmaintainable)\r\n* functionality brings lot of unexpected deep bugs\r\n* brings confusion to users between cascade remove or database-level cascades \r\n* can bring too much implicit magic to users\r\n\r\nWhat use instead? Use database-level remove, e.g. `onDelete: \"SET NULL\"` or `onDelete: \"CASCADE\"`"
      },
      {
        "user": "xmlking",
        "created_at": "2019-02-05T16:21:11Z",
        "body": "Please remove `remove` option for cascade = [‘insert’, ‘update’, ‘remove’] type definition "
      }
    ]
  },
  {
    "number": 1084,
    "title": "BUG? - Update using Repository.createQueryBuilder",
    "created_at": "2017-10-24T08:57:09Z",
    "closed_at": "2017-11-21T08:29:36Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/1084",
    "body": "`Repository.createQueryBuilder` must pass a string as alias but update sql doesn't declare alias.\r\n\r\n```ts\r\n        await giftRepository.createQueryBuilder(\"g\")\r\n            .update()\r\n            .set({\"used\": () => \"used + 1\"})\r\n            .where(\"g.id = :id\", {id: gift.id})\r\n            .execute();\r\n```\r\n\r\n```sql\r\nUPDATE `G0002_Gift` SET `used` = used + 1 WHERE g.id = ?\r\n```\r\n\r\n`Error: Unknown column 'g.id' in 'where clause'`",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/1084/comments",
    "author": "Diluka",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-10-24T10:05:27Z",
        "body": "in delete/update/insert query builders you don't need to use aliases, e.g. replace `g.id` to simply `id`"
      },
      {
        "user": "Diluka",
        "created_at": "2017-10-24T12:55:45Z",
        "body": "If `await giftRepository.createQueryBuilder()` compiler tells me there must be 1 parameter"
      },
      {
        "user": "Diluka",
        "created_at": "2017-10-26T05:44:59Z",
        "body": "Any update? @pleerock \r\nIs there a typing error or I should not use `Repository.createQueryBuilder` to update?\r\n\r\n`Repository.createQueryBuilder` need at least 1 parameter"
      },
      {
        "user": "pleerock",
        "created_at": "2017-10-26T06:01:10Z",
        "body": "maybe we can make alias argument optional in repository too"
      }
    ]
  },
  {
    "number": 1078,
    "title": "SyntaxError: Unexpected token import at createScript (vm.js:53:10)",
    "created_at": "2017-10-24T06:52:57Z",
    "closed_at": "2017-11-17T15:10:31Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/1078",
    "body": "```\r\nSyntaxError: Unexpected token import\r\n    at createScript (vm.js:53:10)\r\n    at Object.runInThisContext (vm.js:95:10)\r\n    at Module._compile (module.js:543:28)\r\n    at Object.Module._extensions..js (module.js:580:10)\r\n    at Module.load (module.js:488:32)\r\n    at tryModuleLoad (module.js:447:12)\r\n    at Function.Module._load (module.js:439:3)\r\n    at Module.require (module.js:498:17)\r\n    at require (internal/module.js:20:19)\r\n    at Function.PlatformTools.load (C:\\Users\\xxx\\Documents\\projects\\xxx\\node_modules\\typeorm\\platform\\PlatformTools.js:33:20)\r\n```\r\n\r\nUnexpected syntaxError when attemping to run `postgres `in an Angular app.\r\n\r\nroot folder: ormconfig.json\r\n```\r\n{\r\n  \"type\": \"postgres\",\r\n  \"host\": \"localhost\",\r\n  \"port\": 5432,\r\n  \"username\": \"postgres\",\r\n  \"password\": \"admin\",\r\n  \"database\": \"test\",\r\n  \"synchronize\": true,\r\n  \"logging\": false,\r\n  \"entities\": [\r\n    \"src/app/entity/**/*.ts\"\r\n  ]\r\n}\r\n```\r\nsrc/app/entity/User.ts\r\n```\r\nimport { Entity, PrimaryGeneratedColumn, Column } from 'typeorm';\r\n\r\n@Entity()\r\nexport class User {\r\n\r\n    @PrimaryGeneratedColumn()\r\n    id: number;\r\n\r\n    @Column()\r\n    firstName: string;\r\n\r\n    @Column()\r\n    lastName: string;\r\n\r\n    @Column()\r\n    age: number;\r\n\r\n}\r\n\r\n\r\n```\r\n\r\npg.component.ts\r\n```\r\nimport { Component, OnInit } from '@angular/core';\r\nimport { createConnection } from 'typeorm';\r\nimport { User } from './../entity/User';\r\n\r\ncreateConnection().then(async connection => {\r\n\r\n      console.log('Inserting a new user into the database...');\r\n\r\n      const user = new User();\r\n      user.firstName = 'Timber';\r\n      user.lastName = 'Saw';\r\n      user.age = 25;\r\n      await connection.manager.save(user);\r\n      console.log('Saved a new user with id: ' + user.id);\r\n\r\n      console.log('Loading users from the database...');\r\n      const users = await connection.manager.find(User);\r\n      console.log('Loaded users: ', users);\r\n\r\n      console.log('Here you can setup and run express/koa/any other framework.');\r\n      connection.close();\r\n    }).catch((error) => { console.log(error);  });\r\n\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/1078/comments",
    "author": "celestale",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-10-24T10:11:39Z",
        "body": "```\r\n  \"entities\": [\r\n    \"src/app/entity/**/*.ts\"\r\n  ]\r\n```\r\n\r\nIf you are executing your .js file then try to specify path to `.js` files instead of `.ts`"
      },
      {
        "user": "celestale",
        "created_at": "2017-10-27T02:39:44Z",
        "body": "I compiled `tsc user.ts` file into `.js `and changed the path to `.js` and started my postgre server with this error\r\n\r\n```\r\ncore.es5.js:1020 ERROR Error: Uncaught (in promise): DataTypeNotSupportedError: Data type \"undefined\" in \"User.firstName\" is not supported by \"postgres\" database.\r\nDataTypeNotSupportedError: Data type \"undefined\" in \"User.firstName\" is not supported by \"postgres\" database.\r\n```\r\n\r\nI have also checked that my postgre `database=test` and `user table(id, firstName, lastName, age)` exist.\r\n\r\nuser.js\r\n```\r\n\"use strict\";\r\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nexports.__esModule = true;\r\nvar typeorm_1 = require(\"typeorm\");\r\nvar User = (function () {\r\n    function User() {\r\n    }\r\n    __decorate([\r\n        typeorm_1.PrimaryGeneratedColumn()\r\n    ], User.prototype, \"id\");\r\n    __decorate([\r\n        typeorm_1.Column()\r\n    ], User.prototype, \"firstName\");\r\n    __decorate([\r\n        typeorm_1.Column()\r\n    ], User.prototype, \"lastName\");\r\n    __decorate([\r\n        typeorm_1.Column()\r\n    ], User.prototype, \"age\");\r\n    User = __decorate([\r\n        typeorm_1.Entity()\r\n    ], User);\r\n    return User;\r\n}());\r\nexports.User = User;\r\n```\r\n\r\npostgre.component.ts\r\n```\r\nimport { Component, OnInit } from '@angular/core';\r\nimport { createConnection } from 'typeorm';\r\nimport { User } from './../entity/User';\r\n\r\n@Component({\r\n  selector: 'app-postgre',\r\n  templateUrl: './postgre.component.html'\r\n})\r\nexport class PostgreComponent implements OnInit {\r\n  constructor() { }\r\n\r\n  ngOnInit() {\r\n  }\r\n\r\n  startConnection() {\r\n    createConnection().then(async connection => {\r\n\r\n      console.log('Inserting a new user into the database...');\r\n      const user = new User();\r\n      user.firstName = 'Timber';\r\n      user.lastName = 'Saw';\r\n      user.age = 25;\r\n      await connection.manager.save(user);\r\n      console.log('Saved a new user with id: ' + user.id);;\r\n\r\n      console.log('Loading users from the database...');\r\n      const users = await connection.manager.find(User);\r\n      console.log('Loaded users: ', users);\r\n\r\n      console.log('Here you can setup and run express/koa/any other framework.');\r\n      connection.close();\r\n    }).catch((error) => { console.log(error);});\r\n  }\r\n\r\n}\r\n```\r\n\r\n"
      },
      {
        "user": "pleerock",
        "created_at": "2017-10-27T12:28:43Z",
        "body": "Are you running app in the browser? Can you create a demo repo with your issue without angular or any other third party dependencies  "
      },
      {
        "user": "sierranevadan",
        "created_at": "2017-11-12T22:22:03Z",
        "body": "I was also seeing this error while making my way through the express example. After enabling logging, I saw this error:\r\n\r\n```\r\n(node:7223) UnhandledPromiseRejectionWarning: Unhandled promise rejection (rejection id: 1): DataTypeNotSupportedError: Data type \"undefined\" in \"User.firstName\" is not supported by \"postgres\" database.\r\n(node:7223) [DEP0018] DeprecationWarning: Unhandled promise rejections are deprecated. In the future, promise rejections that are not handled will terminate the Node.js process with a non-zero exit code.\r\nError starting app\r\n{ QueryFailedError: type \"undefined\" does not exist\r\n    at new QueryFailedError (/Users/r629541/Documents/user/src/error/QueryFailedError.ts:7:9)\r\n    at Query.callback (/Users/r629541/Documents/user/src/driver/postgres/PostgresQueryRunner.ts:216:26)\r\n    at Query.handleError (/Users/r629541/Documents/user/node_modules/pg/lib/query.js:143:17)\r\n    at Connection.connectedErrorHandler (/Users/r629541/Documents/user/node_modules/pg/lib/client.js:132:26)\r\n    at emitOne (events.js:116:13)\r\n    at Connection.emit (events.js:211:7)\r\n    at Socket.<anonymous> (/Users/r629541/Documents/user/node_modules/pg/lib/connection.js:118:12)\r\n    at emitOne (events.js:116:13)\r\n    at Socket.emit (events.js:211:7)\r\n    at addChunk (_stream_readable.js:263:12)\r\n  name: 'QueryFailedError',\r\n  length: 92,\r\n  severity: 'ERROR',\r\n  code: '42704',\r\n  detail: undefined,\r\n  hint: undefined,\r\n  position: undefined,\r\n  internalPosition: undefined,\r\n  internalQuery: undefined,\r\n  where: undefined,\r\n  schema: undefined,\r\n  table: undefined,\r\n  column: undefined,\r\n  dataType: undefined,\r\n  constraint: undefined,\r\n  file: 'parse_type.c',\r\n  line: '257',\r\n  routine: 'typenameType',\r\n  query: 'ALTER TABLE \"public\".\"user\" ALTER COLUMN \"firstName\" TYPE undefined',\r\n  parameters: [] }\r\n```\r\n\r\nI then specified types for the columns in `entity/User.ts` and it appears to work now. For example:\r\n\r\n```javascript\r\n  @Column(\"varchar\", { length: 200 })\r\n  firstName: string\r\n```"
      },
      {
        "user": "pleerock",
        "created_at": "2017-11-17T15:09:45Z",
        "body": "Its a common user mistake when they forgot to enable needed compiler options (as readme says) or they do not include reflect-metadata or include it in a wrong place (it must be included before you start working with typeorm or entities)"
      },
      {
        "user": "pleerock",
        "created_at": "2017-11-17T15:10:31Z",
        "body": "If someone is doubt about my point, please checkout demo repository and make a fork which breaks its behaviour and let me know."
      }
    ]
  },
  {
    "number": 1066,
    "title": "Creating two OneToMany relationships onto the same entity",
    "created_at": "2017-10-22T12:31:40Z",
    "closed_at": "2017-10-23T08:47:48Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/1066",
    "body": "I want to depict a customer and his/her respective billing and/or shipping addresses as follows:\r\n\r\nCurrently, my customer entity looks like this\r\n```js\r\n@Entity()\r\nexport class Customer {\r\n    @PrimaryGeneratedColumn()\r\n    public id: number;\r\n    @Column()\r\n    public name: string;\r\n    @OneToMany(type => Address, address => address.customer, {cascadeInsert: true, eager: true})\r\n    public billingAddresses: Address[];\r\n    @OneToMany(type => Address, address => address.customer, {cascadeInsert: true, eager: true})\r\n    public shippingAddresses: Address[];\r\n}\r\n```\r\nwhile my Address entity is\r\n```js\r\n@Entity()\r\nexport class Address {\r\n    @PrimaryGeneratedColumn()\r\n    public id: number;\r\n    @Column()\r\n    public street: string;\r\n    @Column()\r\n    public zip: string;\r\n    @Column()\r\n    public city: string;\r\n    @Column()\r\n    public country: string;\r\n    @ManyToOne(type => Customer, customer => customer.billingAddresses)\r\n    @ManyToOne(type => Customer, customer => customer.shippingAddresses)\r\n    public customer: Customer;\r\n}\r\n```\r\n\r\nI realize that the method used in my Address entity, where two relationship decorators are bound to one attribute, is likely not the intended implementation. \r\nIs there any way to implement these relations in this fashion or should I just add another attribute `type` to Address, signaling if it is a billing or an shipping address?",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/1066/comments",
    "author": "KieranKaelin",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-10-23T05:28:20Z",
        "body": "Right, you cannot define models this way, because following code:\r\n\r\n```ts\r\n    @ManyToOne(type => Customer, customer => customer.billingAddresses)\r\n    @ManyToOne(type => Customer, customer => customer.shippingAddresses)\r\n    public customer: Customer;\r\n```\r\n\r\nThen ORM does not know what customers need to be set into `billingAddresses: Address[]` property and what customers need to be set into  `shippingAddresses: Address[];` property. Best solution as you said is to create a \"type\" in the address model."
      },
      {
        "user": "samifall",
        "created_at": "2019-09-06T10:46:04Z",
        "body": "Hi,\r\nI did not get it.\r\nhow will you fix this if you introduce type?"
      },
      {
        "user": "doub1ejack",
        "created_at": "2019-12-06T21:35:31Z",
        "body": "I just ran into this and mentally stumbled over the same thing.  The trick is just to use different names for both the `billingAddresses` and the `shippingAddresses` relations in the `Address` entity. \r\n\r\nThis seems to work fine for me in an analogous scenario:\r\n\r\n```javascript\r\n@Entity()\r\nexport class Company extends BaseEntity {\r\n  @OneToMany( () => Group, group => group.friendlyCo )\r\n  friendlyGroups: Group;\r\n  @OneToMany( () => Group, group => group.rivalCo )\r\n  rivalGroups: Group;\r\n```\r\n\r\n...and in the other relation:\r\n\r\n```javascript\r\n@Entity()\r\nexport class Group extends BaseEntity {\r\n  @ManyToOne( () => Company, friendlyCo => friendlyCo.friendlyGroups )\r\n  friendlyCo: Company;\r\n  @ManyToOne( () => Company, rivalCo => rivalCo.rivalGroups )\r\n  rivalCo: Company;\r\n```\r\n\r\nSo I think you would want to do something like this\r\n\r\n```javascript\r\n    @ManyToOne(type => Customer, customer => customer.billingAddresses)\r\n    public billingCustomer: Customer;\r\n    @ManyToOne(type => Customer, customer => customer.shippingAddresses)\r\n    public shippingCustomer: Customer;\r\n```"
      },
      {
        "user": "iljab",
        "created_at": "2020-08-03T13:58:56Z",
        "body": "I'm facing the same problem, the example of @doub1ejack helped me with the structure. But is it possible to get the relations using Query Builder?\r\n\r\nI tried the following based on the example of @doub1ejack:\r\n```js\r\n... .createQueryBuilder('groups')\r\n.leftJoinAndSelect(\"groups.friendlyCo\", \"friendlyCo\", \"friendlyCo.isActive = true\")\r\n.leftJoinAndSelect(\"groups. rivalCo\", \"rivalCo\", \"rivalCo.isActive = true\")\r\n```\r\nThis works as long as i'm not using where statements, if i use where the last join only seems to work (rivalCo). "
      }
    ]
  },
  {
    "number": 1028,
    "title": "Property isModified function?",
    "created_at": "2017-10-14T16:58:00Z",
    "closed_at": "2017-10-16T09:55:31Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/1028",
    "body": "Mongoose has the `isModified` function to see if a property has been modified. This is really helpful in a pre-save hook (or for typeorm, when extending save()) to make sure a password always gets hashed. \r\n\r\nIs there something like that for typeorm? I couldn't find it in the docs.",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/1028/comments",
    "author": "Christilut",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-10-15T08:01:16Z",
        "body": "typeorm follows a bit different strategy and does not store object loaded from the database in the model. So if you want to check if its modified or not by explicitly load an object from the database "
      },
      {
        "user": "Christilut",
        "created_at": "2017-10-16T09:55:31Z",
        "body": "I guess the mongoose way is not the typescript way (I'm still adjusting).\r\n\r\nI made the password property private and changing the password must go through the setPassword function. 👍 "
      },
      {
        "user": "pleerock",
        "created_at": "2017-10-16T11:10:05Z",
        "body": "Don't forget you can use accessors, e.g. `get password`, `set password`"
      },
      {
        "user": "Christilut",
        "created_at": "2017-10-16T16:26:27Z",
        "body": "Thanks, great point."
      },
      {
        "user": "upendra-web",
        "created_at": "2020-01-26T12:50:46Z",
        "body": "Hello @Christilut, Can you post an example of your implementation?\r\nThank you!"
      },
      {
        "user": "Christilut",
        "created_at": "2020-01-26T13:02:45Z",
        "body": "Sorry, this was a long time ago. I'm on Typegoose now."
      }
    ]
  },
  {
    "number": 1018,
    "title": "Database migrations support",
    "created_at": "2017-10-11T20:19:35Z",
    "closed_at": "2017-10-17T12:55:16Z",
    "labels": [
      "question",
      "comp: migrations"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/1018",
    "body": "What databases are supported with migrations feature as of typeorm 0.1.0?",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/1018/comments",
    "author": "Deilan",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-10-12T04:27:19Z",
        "body": "All databases. Migrations is just mechanizm that runs your files with your code that makes actual migration. There is also a \"generate migration\" functionality which works only in mysql and partially in postgres right now. We are planning to ship complete generation support for all databases in 0.2.0"
      }
    ]
  },
  {
    "number": 1012,
    "title": "[Bug] RelationCount cannot be used with default OrderBy",
    "created_at": "2017-10-10T03:39:38Z",
    "closed_at": "2017-10-13T12:48:21Z",
    "labels": [
      "invalid",
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/1012",
    "body": "For some reason using a `RelationCount` with a relation that has a default `OrderBy` generates an invalid query for count:\r\n```sql\r\nSELECT \r\n\t\"MON_ROUTE_LINE\".\"routeId\" AS \"parentId\", \r\n        COUNT(*) AS \"cnt\" \r\nFROM \r\n\t\"adempiere\".\"MON_ROUTE_LINE\" \"MON_ROUTE_LINE\" \r\nWHERE \r\n\t\"MON_ROUTE_LINE\".\"routeId\" IN (1) \r\nGROUP BY \r\n\t\"MON_ROUTE_LINE\".\"routeId\" \r\nORDER BY \r\n\t\"MON_ROUTE_LINE\".\"MON_ROUTE_LINE_ID\" DESC\r\n```\r\nCheck that last `ORDER BY`, if it is just a count operation, why in the world would it need to order?\r\n\r\nPing @pleerock.",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/1012/comments",
    "author": "luchillo17",
    "comments": [
      {
        "user": "luchillo17",
        "created_at": "2017-10-10T03:50:55Z",
        "body": "Confirmed, if i remove the default `OrderBy` config in the `Entity` decorator the query goes all right."
      },
      {
        "user": "pleerock",
        "created_at": "2017-10-10T04:29:31Z",
        "body": "`@RelationCount` is considered experimental, it does not work properly and I even plan to remove this functionality."
      },
      {
        "user": "luchillo17",
        "created_at": "2017-10-10T14:42:28Z",
        "body": "Really? then if i rely on it how would i replace it? raw SQL?"
      },
      {
        "user": "pleerock",
        "created_at": "2017-10-11T05:05:05Z",
        "body": "nope you can build sql query you need using query builder, execute it and get raw results."
      },
      {
        "user": "luchillo17",
        "created_at": "2017-10-13T15:07:30Z",
        "body": "Yeah but i would have to make 2 separate queries, one just for counting? is there a way to embed that sql query in a column so i don't have to use the query builder whenever i want to count the relations?"
      },
      {
        "user": "pleerock",
        "created_at": "2017-10-13T15:23:11Z",
        "body": "If relation count makes it in a single request then you can make it in a single request as well. Relation count is a bit tricky and huge functionality with relative high maintenance cost to value it brings. So, for now decision is to remove it. If one day we'll bring ORM into ideal condition with everything polished and all features implemented we'll think about bring this feature back."
      },
      {
        "user": "luchillo17",
        "created_at": "2017-10-13T18:15:32Z",
        "body": "So if i wanted to get both the count and the relations in single query i would have to use `QueryBuilder` to get the count in the same query i have for an entity, while still getting those relations at the same time with joins, indeed sounds tricky."
      }
    ]
  },
  {
    "number": 999,
    "title": "Update/remove all with auto-completion",
    "created_at": "2017-10-05T03:12:53Z",
    "closed_at": "2017-10-16T13:20:09Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/999",
    "body": "Is there a simple syntax to update or remove multiple entities via Active Record or Data-Mapper? I'm looking for something like (in sequelize):\r\n\r\n`await User.update({ name: 'a' }, { where: { name: 'b' } });`\r\n`// UPDATE users SET name = 'a' WHERE name = 'b';`\r\n\r\nand\r\n\r\n`await User.update({ name: 'a' });`\r\n`// UPDATE users SET name = 'a';`\r\n\r\nEntityManager throws `Cannot find entity to update by a given criteria` if there are no matches, and only updates one record:\r\n\r\n`await connection.manager.update(User, { name: 'a' }, { name: 'b' });`\r\n`await connection.manager.update(User, { where: { name: 'a'  } }, { name: 'b' });`\r\n\r\nQueryBuilder works, but is verbose and has no type checking on `.where()`:\r\n\r\n```\r\nawait User.createQueryBuilder('user')\r\n      .update({ name: 'b' })\r\n      .where('user.name = :name', { name: 'a' }) // hard to maintain, no type check\r\n      .execute();\r\n```\r\n\r\n\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/999/comments",
    "author": "soncodi",
    "comments": [
      {
        "user": "daniel-lang",
        "created_at": "2017-10-05T13:37:08Z",
        "body": "Repositories have an update function that has a very similar syntax. Only, that the parameters are switched (first the condition and than the part you want to change)\r\n\r\n```typescript\r\nawait repository.update({ firstName: \"Timber\" }, { firstName: \"Rizzrak\" });\r\n// executes UPDATE user SET firstName = Rizzrak WHERE firstName = Timber\r\n```"
      },
      {
        "user": "pleerock",
        "created_at": "2017-10-05T17:21:11Z",
        "body": "@daniel-lang is right, in your case its  a method from `BaseEntity`:\r\n\r\n```ts\r\nawait User.update({ firstName: \"Timber\" }, { firstName: \"Rizzrak\" });\r\n```\r\n"
      },
      {
        "user": "soncodi",
        "created_at": "2017-10-05T17:50:55Z",
        "body": "@daniel-lang, @pleerock: I tried the following (`0.1.0-alpha.50`) with both AR and DM:\r\n\r\nAR\r\n`await User.update({ name: 'a' }, { name: 'b' });`\r\n`await User.update({ where: { name: 'a' } }, { name: 'b' });`\r\n\r\nDM\r\n`await UserRepo.update({ name: 'a' }, { name: 'b' });`\r\n`await UserRepo.update({ where: { name: 'a' } }, { name: 'b' });`\r\n\r\n\r\nLogger results:\r\n\r\n    executing query:  SELECT `User`.`id` AS `User_id`, `User`.`name` AS `User_name` FROM `users` `User` WHERE `User`.`name`=? -- PARAMETERS: [\"a\"]\r\n    executing query:  SELECT `subject`.`id` AS `subject_id`, `subject`.`name` AS `subject_name` FROM `users` `subject` WHERE `subject`.`id`=? -- PARAMETERS: [2]\r\n    executing query:  START TRANSACTION\r\n    executing query:  UPDATE `users` SET `name`=?  WHERE `id`=? -- PARAMETERS: [\"b\",2]\r\n    executing query:  COMMIT\r\n\r\nObserved this behavior:\r\n- issues a `SELECT` first\r\n- only updates the first user.\r\n- errors if no rows matched `Error: Cannot find entity to update by a given criteria`\r\n\r\nExpected this behavior:\r\n- no `SELECT` issued, just a direct query\r\n- updates all users\r\n- no failure if no rows match `WHERE` clause\r\n\r\n\r\n"
      },
      {
        "user": "daniel-lang",
        "created_at": "2017-10-05T18:46:39Z",
        "body": "You are right. Looking at the source code it executes `findOne()` and than updates the found entity if it exists, otherwise throws an error.\r\nSo even though it's the same syntax, the `update` function does something every different. Sorry, for suggesting it, I should have checked the source code.\r\n\r\nSo I guess the only way to do what you want is with the QueryBuilder.\r\n@pleerock is that true?"
      },
      {
        "user": "soncodi",
        "created_at": "2017-10-05T18:57:41Z",
        "body": "It seems the goal is to act as an entity cache layer in front of the db. That's valid design but, for my use-case, it would be great to be able to opt-out of that behavior, and just use TypeORM as a simple mapper with type-checking. It could essentially be a drop-in replacement for Sequelize. I assumed this was implied by disabling `cache` on the connection, but I have not yet looked through the code.\r\n"
      },
      {
        "user": "pleerock",
        "created_at": "2017-10-06T03:58:40Z",
        "body": "`update` method currently using `find` and `save methods. Instead it should just use update query builder functionality. Ive got sick, thats why release is delayed this week, I'll fix update methods next week and publish a new version with those changes."
      },
      {
        "user": "soncodi",
        "created_at": "2017-10-06T04:07:30Z",
        "body": "@pleerock perfect, thanks!"
      },
      {
        "user": "pleerock",
        "created_at": "2017-10-16T13:20:09Z",
        "body": "I have updated `update` methods. Now they should work fine. This change will be released in `0.1.1`"
      }
    ]
  },
  {
    "number": 995,
    "title": "How to perform search operations on Mapping table which is automatically created in many-many relationship",
    "created_at": "2017-10-04T12:21:31Z",
    "closed_at": "2017-10-13T12:57:07Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/995",
    "body": "i want to perform search operation on regular_product_sku_maapper table which is automatically created by typeorm while establishing many-many relationship between regular_consumption table & product_sku table",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/995/comments",
    "author": "imhari213",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-10-05T17:41:21Z",
        "body": "Depend on your task, in most cases you don't really need to work with tables created by many-to-many relation.\r\n\r\nBut if you really need, you can specify a table name in QueryBuilder:\r\n\r\n```ts\r\nconst results = await connection.createQueryBuilder()\r\n    .select()\r\n    .from(\"regular_product_sku_maapper\", \"sku_mapper\")\r\n    .where(\"...\")\r\n    .getRawMany();\r\n```"
      },
      {
        "user": "imhari213",
        "created_at": "2017-10-05T18:37:34Z",
        "body": "Thanks,I will try it and get you back."
      }
    ]
  },
  {
    "number": 962,
    "title": "Postgres OneToOne",
    "created_at": "2017-09-29T16:56:31Z",
    "closed_at": "2017-10-01T05:39:39Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/962",
    "body": "When using the following entities\r\n\r\n```js\r\n@Entity()\r\nexport class Token {\r\n    @PrimaryGeneratedColumn()\r\n    public id: number;\r\n    @OneToOne(type => User, user => user.email)\r\n    public email: string;\r\n    @Column()\r\n    public token: string;\r\n}\r\n\r\n@Entity()\r\nexport class User {\r\n    @PrimaryGeneratedColumn()\r\n    public id: number;\r\n    @OneToOne(type => Token, token => token.email)\r\n    @Column({unique: true})\r\n    public email: string;\r\n}\r\n```\r\n\r\ntrying to get the token (find and findOne) yields the following error\r\n```\r\nerror:  QueryFailedError: invalid reference to FROM-clause entry for table \"token\"\r\n    at Connection.parseE (C:\\server\\node_modules\\pg\\lib\\connection.js:567:11)\r\n    at Connection.parseMessage (C:\\server\\node_modules\\pg\\lib\\connection.js:391:17)\r\n    at Socket.<anonymous> (C:\\server\\node_modules\\pg\\lib\\connection.js:129:22)\r\n    at emitOne (events.js:96:13)\r\n    at Socket.emit (events.js:188:7)\r\n    at readableAddChunk (_stream_readable.js:176:18)\r\n    at Socket.Readable.push (_stream_readable.js:134:10)\r\n    at TCP.onread (net.js:547:20)\r\n```\r\nand in the database log the following errors appear\r\n```\r\nERROR:  invalid reference to FROM-clause entry for table \"token\" at character 96\r\nHINT:  Perhaps you meant to reference the table alias \"Token\".\r\nSTATEMENT:  SELECT \"Token\".\"id\" AS \"Token_id\", \"Token\".\"token\" AS \"Token_token\" FROM \"token\" \"Token\" WHERE Token.email=$1\r\n```\r\notherwise typeorm is awesome so far, keep up the good work   :heart:",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/962/comments",
    "author": "ghost",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-10-01T05:38:29Z",
        "body": "You have a wrong entity. First, you forgot to use `@JoinColumn` - its required for use on one side of one-to-one relation. Second, you don't need a `@Column` decorator on a relation. Third, relations are OBJECTS, not \"email\".\r\n\r\n```ts\r\n@Entity()\r\nexport class Token {\r\n    @PrimaryGeneratedColumn()\r\n    public id: number;\r\n    @OneToOne(type => User, user => user.token)\r\n    @JoinColumn()\r\n    public user: User;\r\n    @Column()\r\n    public token: string;\r\n}\r\n\r\n@Entity()\r\nexport class User {\r\n    @PrimaryGeneratedColumn()\r\n    public id: number;\r\n    @Column({ unique: true })\r\n    public email: string;\r\n    @OneToOne(type => Token, token => token.user)\r\n    public token: Token;\r\n}\r\n```\r\n\r\nIf you want to bind them via `email` instead of `id` use following code:\r\n\r\n\r\n```ts\r\n    @OneToOne(type => User, user => user.token)\r\n    @JoinColumn({ referencedColumnName: \"email\" })\r\n    public user: User;\r\n}\r\n```"
      },
      {
        "user": "pleerock",
        "created_at": "2017-10-01T05:39:38Z",
        "body": "Okay, I see in #968 you already found a solution"
      }
    ]
  },
  {
    "number": 949,
    "title": "ConnectionOptions does not allow variable assigned to type",
    "created_at": "2017-09-27T21:32:24Z",
    "closed_at": "2017-10-16T06:02:30Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/949",
    "body": "```\r\nsrc/db.ts(14,39): error TS2352: Type '{ type: string; host: string; port: number; username: string; password: string; database: string;...' cannot be converted to type 'ConnectionOptions'.\r\n  Type '{ type: string; host: string; port: number; username: string; password: string; database: string;...' is not comparable to type 'CordovaConnectionOptions'.\r\n    Types of property 'type' are incompatible.\r\n      Type 'string' is not comparable to type '\"cordova\"'.\r\n```\r\n\r\nWhere I am trying to pass in the connection options.   ie:\r\n```\r\nconst opts: ConnectionOptions = {\r\n   type: wConfig.type,\r\n   host: wConfig.host,\r\n   ...\r\n```\r\n\r\nFWIW, I am actually trying to create a Postgres connection in this case.  Not sure why it chose to report cordova as the type   The Postgres config isn't directly exposed, either\r\n\r\nmy workaround:\r\n```\r\nconst opts: ConnectionOptions = {\r\n   type: 'postgres',\r\n   host: wConfig.host,\r\n   ...\r\n};\r\n(opts.type as any) = wConfig.type;\r\n```\r\n\r\nI'm not using any specific features of postgres, so any db connection as configured should be fine, and would/should not require code modification.",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/949/comments",
    "author": "vrachels",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-09-28T03:57:22Z",
        "body": "You pass a string into `type`, but it expects a `string literal type`. You simply pass a wrong type there. If you really need to pass type in a variable, then cast it:\r\n\r\n```ts\r\nconst opts: ConnectionOptions = {\r\n   type: wConfig.type as DatabaseType,\r\n   host: wConfig.host,\r\n   ...\r\n```"
      },
      {
        "user": "vrachels",
        "created_at": "2017-09-28T18:14:49Z",
        "body": "DatabaseType does not seem to be exported for external use.  Am I missing something?"
      },
      {
        "user": "pleerock",
        "created_at": "2017-09-28T19:10:06Z",
        "body": "yeah, I cant add it to external, you can use full path for now. Also you can do:\r\n\r\n```\r\n   type: wConfig.type as \"postgres\"\r\n```\r\n\r\nbut it does not make sense because if you have a type stored inside a variable then it suppose to be other then postgres too"
      },
      {
        "user": "pleerock",
        "created_at": "2017-10-16T06:08:02Z",
        "body": "I added export for DatabaseType, this change will be released in `0.1.1`"
      },
      {
        "user": "ghost",
        "created_at": "2018-01-14T12:28:38Z",
        "body": "> You pass a string into type, but it expects a string literal type. You simply pass a wrong type there. If you really need to pass type in a variable, then cast it:\r\n```typescript\r\nconst opts: ConnectionOptions = {\r\n    type: wConfig.type as DatabaseType,\r\n    host: wConfig.host,\r\n    ...\r\n```\r\n\r\nWith this code:\r\n```typescript\r\nthis.typeormConnection = getConnectionManager().create({\r\n    database: process.env.TYPEORM_DATABASE,\r\n    entities: [`${this.modelPath}/*.js`],\r\n    host: process.env.TYPEORM_HOST,\r\n    password: process.env.TYPEORM_PASSWORD,\r\n    port: Number(process.env.TYPEORM_PORT),\r\n    type: process.env.TYPEORM_TYPE as DatabaseType,\r\n    username: process.env.TYPEORM_USERNAME,\r\n});\r\n```\r\nI am getting this error:\r\n> source/database/connection.ts(16,64): error TS2345: Argument of type '{ database: string | undefined; entities: string[]; host: string | undefined; password: string | ...' is not assignable to parameter of type 'ConnectionOptions'.\r\n  Type '{ database: string | undefined; entities: string[]; host: string | undefined; password: string | ...' is not assignable to type 'SqljsConnectionOptions'.\r\n    Types of property 'type' are incompatible.\r\n      Type 'DatabaseType' is not assignable to type '\"sqljs\"'.\r\n        Type '\"mysql\"' is not assignable to type '\"sqljs\"'."
      },
      {
        "user": "pleerock",
        "created_at": "2018-01-15T09:19:22Z",
        "body": "Guys, just use the database you are really using, its pointless to set a type from the configuration because each type has its own specifics, you cannot practically really have it dynamic."
      },
      {
        "user": "billybarnum",
        "created_at": "2018-07-14T00:52:04Z",
        "body": "There are lots of use cases for wanting a variable for the database type ... for tools, or testing, or for that matter apps that need to connect to more than one type of database are pretty common.\r\n\r\nI recognize this issue isn't exactly a show-stopper, but it got in my way too, and I had to write some ugly code to work around it. \r\n\r\nAnd dismissing the request as \"pointless\" is offensive. :-(\r\n"
      },
      {
        "user": "emirhg",
        "created_at": "2019-03-27T00:31:19Z",
        "body": "The Issue is marked as Closed but seems to be persistent \r\n\r\n@ typeorm 0.2.15\r\n\r\n> const database: ConnectionOptions = {\r\n>  type: process.env.TYPEORM_CONNECTION as DatabaseType,\r\n>  host: process.env.TYPEORM_HOST || 'localhost',\r\n>  port: Number(process.env.TYPEORM_PORT) || 3306,\r\n>  name: 'default',\r\n>  username: process.env.TYPEORM_USERNAME,\r\n>  password: process.env.TYPEORM_PASSWORD, \r\n>  database: process.env.TYPEORM_DATABASE,\r\n>  synchronize: Boolean(process.env.TYPEORM_SYNCHRONIZE) || true,\r\n>  logging: false,\r\n>  entityPrefix: process.env.TYPEORM_ENTITY_PREFIX,\r\n>  connectTimeout: 30000,\r\n>  entities: [\r\n>    OAuth2Token,\r\n>    User,\r\n>    Role,\r\n>    Permission,\r\n>    Client,\r\n>  ],\r\n>};\r\n`\r\n\r\nThrows error:\r\n> error TS2322: Type '{ type: DatabaseType; host: string; port: number; name: string; username: string; password: string; database: string; synchronize: true; logging: false; entityPrefix: string; connectTimeout: number; entities: (typeof Permission | ... 3 more ... | typeof OAuth2Token)[]; }' is not assignable to type 'ConnectionOptions'.\r\n>Type '{ type: DatabaseType; host: string; port: number; name: string; username: string; password: string; database: string; synchronize: true; logging: false; entityPrefix: string; connectTimeout: number; entities: (typeof Permission | ... 3 more ... | typeof OAuth2Token)[]; }' is not assignable to type 'MysqlConnectionOptions'.\r\n>    Types of property 'type' are incompatible.\r\n>      Type 'DatabaseType' is not assignable to type '\"mysql\" | \"mariadb\"'.\r\n>        Type '\"postgres\"' is not assignable to type '\"mysql\" | \"mariadb\"'.\r\n>\r\n>15 const database: ConnectionOptions = {\r\n\r\n"
      },
      {
        "user": "proutek",
        "created_at": "2019-07-07T18:25:15Z",
        "body": "This one works for me but it's ugly. You can add more types in switch section.\r\n\r\n```javascript\r\n      useFactory: (configService: ConfigService) => {\r\n        let type;\r\n        switch (configService.DB_TYPE) {\r\n          case \"mysql\": type = \"mysql\"; break;\r\n          case \"postgres\": type = \"postgres\"; break;\r\n          default: type = \"postgres\";\r\n        }\r\n        return ({\r\n          retryAttempts: 5,\r\n          retryDelay: 1000,\r\n          keepConnectionAlive: true,\r\n          type,\r\n          host: configService.DB_HOST,\r\n          port: configService.DB_PORT,\r\n          username: configService.DB_USER,\r\n          password: configService.DB_PASS,\r\n          database: configService.DB_DATABASE,\r\n          entities: [__dirname + '/**/*.entity{.ts,.js}'],\r\n          synchronize: configService.DB_SYNC,\r\n        })\r\n      },\r\n```"
      },
      {
        "user": "taos-thiagoaos",
        "created_at": "2019-07-30T19:54:53Z",
        "body": "@proutek thx. But is this the only \"dynamic\" solution?"
      },
      {
        "user": "dugajean",
        "created_at": "2019-08-12T14:42:35Z",
        "body": "> Guys, just use the database you are really using, its pointless to set a type from the configuration because each type has its own specifics, you cannot practically really have it dynamic.\r\n\r\n?? \r\n\r\nOr maybe allow your code to be testable and a little more dynamic?"
      },
      {
        "user": "JavierMendozaGomez",
        "created_at": "2020-01-25T16:35:38Z",
        "body": "This is what it worked for me in typescript \r\nimport {ConnectionOptions, DatabaseType} from 'typeorm';\r\n```\r\nimport {ConnectionOptions, DatabaseType} from 'typeorm';\r\n\r\nconst postgresDatabase: DatabaseType = 'postgres';\r\nconst baseConfig = {\r\n    host: DB_HOST,\r\n    port: DB_PORT,\r\n    password: DB_PASSWORD,\r\n    database: DB_NAME,\r\n    synchronize: false,\r\n    logging: false,\r\n    type: postgresDatabase,\r\n    entities: [ConcertsEntitySchema]\r\n};\r\n```"
      },
      {
        "user": "christhegrand",
        "created_at": "2020-05-14T23:58:45Z",
        "body": "```type: 'postgres' as const``` should also work."
      },
      {
        "user": "im4aLL",
        "created_at": "2020-05-30T13:55:16Z",
        "body": "I had to put ```type: any;```"
      },
      {
        "user": "ivmello",
        "created_at": "2022-06-09T13:16:54Z",
        "body": "where this issue happened too and the solution was add type `DataSourceOptions` on return. The solved code:\r\n> ```js\r\n> useFactory: (configService: ConfigService) => {\r\n>     return (\r\n>         {\r\n>             retryAttempts: 5,\r\n>             retryDelay: 1000,\r\n>             keepConnectionAlive: true,\r\n>             type: configService.DB_TYPE,\r\n>             host: configService.DB_HOST,\r\n>             port: configService.DB_PORT,\r\n>             username: configService.DB_USER,\r\n>             password: configService.DB_PASS,\r\n>             database: configService.DB_DATABASE,\r\n>             entities: [__dirname + '/**/*.entity{.ts,.js}'],\r\n>             synchronize: configService.DB_SYNC,\r\n>         } as DataSourceOptions\r\n>     )\r\n> }),\r\n> ```\r\n\r\nfor some reason typeorm understand 'mysql | postgres | sqlite...' as custom types so if you inject string it will break\r\n"
      }
    ]
  },
  {
    "number": 917,
    "title": "[Question] findByIds with another field",
    "created_at": "2017-09-20T06:21:28Z",
    "closed_at": "2017-09-20T17:04:29Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/917",
    "body": "Hello everyone :)\r\n\r\nAfter some researches I do not find an answer to my question. Thus, I post here.\r\n\r\nIs it possible to use  SQL `IN` in where clause of a query or an equivalent of `findByIds` with another field than id ?\r\n\r\nFor instance, I have Users that have an email. I want to load users where their emails match an email in a list.\r\nIn SQL that will look something like that : \r\n`SELECT * FROM users WHERE email IN ('aa@aa.aa', 'bb@bb.bb');`\r\n\r\nThanks.",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/917/comments",
    "author": "Porquepix",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-09-20T06:36:04Z",
        "body": "Hi, \r\n\r\nyes for your purpose you need to use `QueryBuilder`:\r\n\r\n```ts\r\nconst users = await manager.createQueryBuilder(User, \"user\")  // manager can be repository or connection objects too\r\n    .where(\"user.email IN (:emails)\", { emails: [...] })\r\n    .getMany();\r\n```"
      },
      {
        "user": "Porquepix",
        "created_at": "2017-09-20T17:04:29Z",
        "body": "Ok thanks a lot :+1: "
      }
    ]
  },
  {
    "number": 907,
    "title": "Question: why was ColumnTypes.COLUMN_TYPE left out in new release? It was very handy. Now we need to check everytime if column type string actually exists in specific database",
    "created_at": "2017-09-19T08:05:06Z",
    "closed_at": "2017-10-16T08:07:03Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/907",
    "body": "Thanks!",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/907/comments",
    "author": "idchlife",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-09-19T08:33:30Z",
        "body": "Before orm was supported only generic data types. I think such approach has more cons then pros. Now you aren't limited to set of data types and can use any database type which is awesome. Anyway you always work with a single database and you just use types its supported, its one time thing to get known what types it supports and better for both application (performance) and you (knowledge) "
      }
    ]
  },
  {
    "number": 899,
    "title": "Repository: differents between .save() and .persist() and would a .insert() be possible?",
    "created_at": "2017-09-18T06:19:49Z",
    "closed_at": "2017-09-18T06:29:21Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/899",
    "body": "The title more or less says it all, what is the difference right know (or the difference planed) between `.save()` and `.persist()` of a repository? Since looking at the source code, would suggest, that they do the same.\r\nAnd is there a way to just insert the entities without the check beforehand? Because when I try to insert 700 entities at once a select statement is executed for each one of them, which isn't neccesary in every use case. Mine for example is, inserting entities that have been loaded from an api where I can be certain, that they do not exist in the table.",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/899/comments",
    "author": "daniel-lang",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-09-18T06:25:28Z",
        "body": "> .save() and .persist()\r\n\r\n`persist` is just old name of `save`. It just calls save method right now and there is zero difference, just naming. persist method is deprecated and will be removed in the future. Its there only because of old users who use persist when there was not save method.\r\n\r\n> And is there a way to just insert the entities without the check beforehand?\r\n\r\nYes, using insert functionality of `QueryBuilder`. Example:\r\n\r\n```ts\r\n        await connection.createQueryBuilder()\r\n            .insert()\r\n            .into(User)\r\n            .values([\r\n                { name: \"Umed Khudoiberdiev\" }, // or your entities\r\n                { name: \"Bakhrom Baubekov\" },\r\n                { name: \"Bakhodur Kandikov\" },\r\n            ])\r\n            .execute();\r\n```"
      },
      {
        "user": "daniel-lang",
        "created_at": "2017-09-18T06:29:20Z",
        "body": "Okay, thanks for clearing that up for me!"
      }
    ]
  },
  {
    "number": 887,
    "title": "how to write Right join in typeorm",
    "created_at": "2017-09-14T14:31:48Z",
    "closed_at": "2017-09-14T15:12:55Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/887",
    "body": "",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/887/comments",
    "author": "imhari213",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-09-14T15:12:55Z",
        "body": "Its not possible to do right joins in concept of such ORMs and I'll try to explain why.\r\n\r\nLets say we have `Post` and `Category` entities. \r\nIf we do left or inner joins we just select posts and all their categories and query builder it returns you posts with or without categories.\r\n\r\nIf we do a right join we start with posts and return posts with categories and just categories without posts. Since query builder selects and returns `Post[]` where do we insert categories without posts? We can't afford to return separate list of posts and categories it will break current query builder design.\r\n\r\nI suggest you to revisit sql you want to write with only left and inner joins, or maybe use subselects, or in worth case scenario you can write raw sql query, execute it and transform to entity manually."
      }
    ]
  },
  {
    "number": 877,
    "title": "How to set Current time stamp as default value",
    "created_at": "2017-09-13T12:12:40Z",
    "closed_at": "2017-09-13T14:04:14Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/877",
    "body": "How to set Current time stamp as default value",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/877/comments",
    "author": "imhari213",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-09-13T12:14:33Z",
        "body": "How do you do it in your database using sql? I guess its something like:\r\n\r\n```ts\r\n@Column({ type: \"timestamp\", default: () => \"CURRENT_TIMESTAMP\"))\r\ntime: string;\r\n```\r\n\r\n`() => ` syntax for `default` allows to use SQL expressions."
      },
      {
        "user": "imhari213",
        "created_at": "2017-09-13T13:08:41Z",
        "body": "THANK YOU :)"
      },
      {
        "user": "roeehershko",
        "created_at": "2018-05-29T21:38:52Z",
        "body": "For the copy paste lovers like me (typo):\r\n```\r\n    @Column({ type: 'timestamp', default: () => 'CURRENT_TIMESTAMP'})\r\n```"
      },
      {
        "user": "armanfatahi",
        "created_at": "2019-07-25T06:22:50Z",
        "body": "There is something else you need to consider:\r\n\r\nCURRENT_TIMESTAMP should be used with `timestamp with time zone`:\r\n\r\n```\r\n  @Column('timestamp with time zone', { nullable: false, default: () => 'CURRENT_TIMESTAMP' })  \r\n  created: Date;\r\n```\r\n\r\nUnless the Postgres converts the value to the timezone _AGAIN_ which will cause some trouble later on.\r\n"
      },
      {
        "user": "billyjov",
        "created_at": "2020-02-17T01:16:37Z",
        "body": "> How do you do it in your database using sql? I guess its something like:\r\n> \r\n> ```ts\r\n> @Column({ type: \"timestamp\", default: () => \"CURRENT_TIMESTAMP\"))\r\n> time: string;\r\n> ```\r\n> \r\n> `() => ` syntax for `default` allows to use SQL expressions.\r\n\r\n@pleerock i get an error trying to use an SQL statement with the syntax: \r\n\r\n```\r\ndefault: () => 'DATE_ADD(NOW(), INTERVAL 2 HOUR)',\r\n\r\n```\r\n\r\nnot working as expected and typeorm throw an error: \r\n\r\n```\r\n errno: 1064,\r\n  sqlMessage:\r\n   'You have an error in your SQL syntax; check the manual that corresponds to your MariaDB server version for the right syntax to use near \\'DATE_ADD(NOW(), INTERVAL 2 HOUR)\\' at line 1',\r\n  sqlState: '42000',\r\n  index: 0,\r\n  sql:\r\n   'ALTER TABLE `dueDate` CHANGE `dueDate` `dueDate` timestamp NOT NULL DEFAULT DATE_ADD(NOW(), INTERVAL 2 HOUR)' }\r\n```\r\nPS. i use mysql with the latest typorm version."
      },
      {
        "user": "jdnichollsc",
        "created_at": "2020-07-18T17:16:15Z",
        "body": "Other option could be this:\r\n```\r\n@CreateDateColumn({ type: 'timestamp without time zone', default: 'NOW()' })\r\ncreatedAt: Date\r\n\r\n@UpdateDateColumn({ type: 'timestamp without time zone', onUpdate: 'NOW()', nullable: true })\r\nupdatedAt: Date\r\n```\r\nWhat do you think?"
      },
      {
        "user": "baublet",
        "created_at": "2021-02-02T22:26:12Z",
        "body": "FYI, for those looking as of Tuesday, February 2, 2021, for some reason TypeORM converts `default: () => \"CURRENT_TIMESTAMP\"` to `now()` when using postgres 9.6. This meant that TypeORM generates new migrations changing their default type from `now()` to `CURRENT_TIMESTAMP` every time you try to generate new migrations.\r\n\r\nThe fix for us was to use this instead:\r\n\r\n```ts\r\n@Column({ type: \"timestamp\", default: () => \"now()\"))\r\ntime: string;\r\n```"
      },
      {
        "user": "xiongsongsong",
        "created_at": "2021-04-25T08:48:08Z",
        "body": "In MySQL 8:\r\n```\r\n@Column('date', { default: () => '(CURRENT_DATE)' })\r\nlast_date: Date;\r\n```"
      },
      {
        "user": "ghost",
        "created_at": "2021-06-01T12:18:31Z",
        "body": "Can we use a Javascript function in the default instead of a SQL expression? For scenarios like calculating the year based on some current date conditions. I am using MySQL"
      },
      {
        "user": "seltsamonkel",
        "created_at": "2021-07-30T02:09:37Z",
        "body": "For postgres I first created a migration with\r\n```\r\n@Column('date', { default: () => 'CURRENT_DATE::text::date' })\r\nlast_date: Date;\r\n```\r\nThis created the column in postgres as `default ((CURRENT_DATE))`, then I changed the code to\r\n```\r\n@Column('date', { default: () => '((CURRENT_DATE))' })\r\nlast_date: Date;\r\n```\r\nWith this change, the TypeORM generated default and the default on postgres are both `((CURRENT_DATE))`, so no migrations are created afterward."
      },
      {
        "user": "NateFerrero",
        "created_at": "2021-11-24T04:44:45Z",
        "body": "When creating a table using `queryRunner` on Postgres, I didn't need to use `() => ` to get an expression default:\r\n\r\n```TypeScript\r\nawait queryRunner.createTable(\r\n  new Table({\r\n  name: 'my-table',\r\n  columns: [\r\n    {\r\n      name: \"status\",\r\n      default: \"'created'\", // constant default\r\n      type: \"text\"\r\n    },\r\n    {\r\n      name: \"created_at\",\r\n      type: \"timestamp(0) without time zone\",\r\n      default: 'now()' // expression default\r\n    }\r\n  ]\r\n  }),\r\n  true, true, true\r\n)\r\n```"
      },
      {
        "user": "PRossetti",
        "created_at": "2022-07-21T21:56:09Z",
        "body": "You can do \r\n```\r\n@Column({ type: \"timestamp\", default: () => \"now()\" })\r\ntime: Date;\r\n```\r\n\r\nHave in mind this is not the same as doing:\r\n```\r\n@Column({ type: \"timestamp\", default: \"now()\" })\r\ntime: Date;\r\n```\r\n\r\nThis last option in my case at least throw error in CI because it wasn't doing what it looks, so try going with the first alternative I mentioned."
      },
      {
        "user": "abu18saud",
        "created_at": "2023-11-15T20:25:39Z",
        "body": "using () => 'CURRENT_TIMESTAMP' with add 2 years by nestjs?"
      }
    ]
  },
  {
    "number": 876,
    "title": "How to select appropriate column from join table?",
    "created_at": "2017-09-12T21:03:21Z",
    "closed_at": "2017-09-14T18:16:15Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/876",
    "body": "I would like to remove some column from my result, in order to get rid of the user details. I tried with  .select(['uad.*', 'ua.*', 'u.name']) but doesn't work. How should I do?\r\n\r\n\r\n```\r\n    const query = db.getRepository(UserActivityDo)\r\n        .createQueryBuilder('uad')\r\n        .innerJoinAndSelect('uad.idUserActivity', 'ua')\r\n        .innerJoinAndSelect('ua.idUser', 'u')\r\n        // .select(['uad.*', 'ua.*', 'u.name'])\r\n        .where(`ua.idUser IN (${userIds.join(',')})`)       \r\n        .orderBy('uad.created', 'DESC');\r\n\r\n```\r\n\r\nThis is the result I get from the previous query. How can I only keep the user.name of the user relation?\r\n\r\n```\r\n[\r\n            {\r\n                \"idUserActivityDo\": 10,\r\n                \"description\": \"\",\r\n                \"created\": \"2017-09-11T22:13:15.327Z\",\r\n                \"idUserActivity\": {\r\n                    \"idUserActivity\": 21,\r\n                    \"activityName\": \"lolololol\",\r\n                    \"i18n\": \"en_US\",\r\n                    \"created\": \"2017-09-11T22:11:27.855Z\",\r\n                    \"idUser\": {\r\n                        \"idUser\": 41,\r\n                        \"email\": \"ooooo@ooooo.com\",\r\n                        \"hashedPassword\": \"$2a$10$gf3m/6FP/a/8V.Q7K\",\r\n                        \"salt\": \"$2a$10$55SB/gk0.\",\r\n                        \"name\": \"jgfhfhfhfhfj\",\r\n                        \"created\": \"2017-09-10T16:10:36.861Z\",\r\n                        \"pushToken\": \"ExponentPushToken[ssffsdfds]\"\r\n                    }\r\n                }\r\n            },\r\n            {\r\n                \"idUserActivityDo\": 9,\r\n                \"description\": \"\",\r\n                \"created\": \"2017-09-11T22:13:04.320Z\",\r\n                \"idUserActivity\": {\r\n                    \"idUserActivity\": 21,\r\n                    \"activityName\": \"lolololol\",\r\n                    \"i18n\": \"en_US\",\r\n                    \"created\": \"2017-09-11T22:11:27.855Z\",\r\n                    \"idUser\": {\r\n                        \"idUser\": 40,\r\n                        \"email\": \"world@ooooo.com\",\r\n                        \"hashedPassword\": \"$2a$10$gf3m/6FP/a/8V.Q7K\",\r\n                        \"salt\": \"$2a$10$55SB/gk0.\",\r\n                        \"name\": \"jgfhfhfhfhfj\",\r\n                        \"created\": \"2017-09-10T16:10:36.861Z\",\r\n                        \"pushToken\": \"ExponentPushToken[ssffsdfds]\"\r\n                    }\r\n                }\r\n            },\r\n            {\r\n                \"idUserActivityDo\": 8,\r\n                \"description\": \"\",\r\n                \"created\": \"2017-09-11T22:08:12.452Z\",\r\n                \"idUserActivity\": {\r\n                    \"idUserActivity\": 12,\r\n                    \"activityName\": \"fffgghgf\",\r\n                    \"i18n\": \"en_US\",\r\n                    \"created\": \"2017-09-10T19:01:41.373Z\",\r\n                    \"idUser\": {\r\n                        \"idUser\": 42,\r\n                        \"email\": \"helo@ooooo.com\",\r\n                        \"hashedPassword\": \"$2a$10$gf3m/6FP/a/8V.Q7K\",\r\n                        \"salt\": \"$2a$10$55SB/gk0.\",\r\n                        \"name\": \"jgfhfhfhfhfj\",\r\n                        \"created\": \"2017-09-10T16:10:36.861Z\",\r\n                        \"pushToken\": \"ExponentPushToken[ssffsdfds]\"\r\n                    }\r\n                }\r\n            },...\r\n```",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/876/comments",
    "author": "appwudo",
    "comments": [
      {
        "user": "varHarrie",
        "created_at": "2017-09-13T01:54:13Z",
        "body": "```typescript\r\nconst query = db.getRepository(UserActivityDo)\r\n        .select(['uad', 'ua', 'u.name'])\r\n        .createQueryBuilder('uad')\r\n        .innerJoin('uad.idUserActivity', 'ua')\r\n        .innerJoin('ua.idUser', 'u')\r\n        .where(`ua.idUser IN (${userIds.join(',')})`)       \r\n        .orderBy('uad.created', 'DESC')\r\n```\r\nReplace `innerJoinAndSelect` with `innerJoin`\r\n"
      },
      {
        "user": "appwudo",
        "created_at": "2017-09-15T17:20:38Z",
        "body": "Ah yes, after upgrading to the last version of typeORM it is finally working ;-) thanks"
      },
      {
        "user": "kwehrle",
        "created_at": "2018-06-28T06:35:54Z",
        "body": "Hi, this is not working for me (using V 0.2.7). \r\n\r\n1. the select cannot be the first after getRepository() (VSCode is throwing an error)\r\n2. With the select I only get the values from the Inquriy-Table (inq) and not the values from the joined Table DocUnitType (dut).\r\n3. The generated SQL-Statement seems to be correct and executed in the database works fine: \r\n\r\n``` SQL\r\nSELECT \r\n\t\"inq\".\"id\" AS \"inq_id\", \"inq\".\"bsnr\" AS \"inq_bsnr\", \"inq\".\"dt\" AS \"inq_dt\", \"inq\".\"status\" AS \"inq_status\", \r\n\t\"dut\".\"name\" AS \"dut_name\", \"dut\".\"id\" AS \"dut_id\"\r\nFROM \"mdat\".\"inquiry\" \"inq\"\r\n\tINNER JOIN \"def\".\"doc_unit_type\" \"dut\" ON \"inq\".\"doc_unit_type_id\" = \"dut\".\"id\" \r\nWHERE \"inq\".\"participant_id\" = $1 \r\nORDER BY \"inq\".\"dt\" DESC \r\n-- PARAMETERS: [\"6d964e85-a6b2-4a1b-b3c2-8b49074f6082\"]\r\n```\r\n\r\nWhat is going wrong?\r\n\r\n``` javascript\r\nawait db.getRepository(Inquiry)\r\n\t.createQueryBuilder('inq')\r\n\t.innerJoin(DocUnitType, 'dut', 'inq.docUnitTypeID = dut.ID')\r\n\t.select(['inq.ID','inq.dt','inq.status','inq.bsnr','dut.name'])\r\n\t.where('inq.participantID = :partID', { partID })\r\n\t.orderBy('inq.dt', 'DESC')\r\n\t.getMany();\r\n```\r\n\r\n"
      },
      {
        "user": "timothyvanderaerden",
        "created_at": "2018-10-26T09:49:32Z",
        "body": "@kwehrle not sure if you are still looking for the answer. But you should use addSelect in this case.\r\n\r\n```javascript\r\nawait db.getRepository(Inquiry)\r\n\t.createQueryBuilder('inq')\r\n\t.innerJoin(DocUnitType, 'dut', 'inq.docUnitTypeID = dut.ID')\r\n        .select(['inq.ID','inq.dt','inq.status','inq.bsnr'])\r\n\t.addSelect('dut.name')\r\n\t.where('inq.participantID = :partID', { partID })\r\n\t.orderBy('inq.dt', 'DESC')\r\n\t.getMany();\r\n```"
      },
      {
        "user": "kongbt",
        "created_at": "2018-11-01T10:12:35Z",
        "body": "I always get the undefined value of the variable id_port when I call this function but other values still exist. Please help me\r\nthanks!\r\nasync getAvaiableMobile(_amount:number,_type:string):Promise<any>{         \r\n        return this.repository.createQueryBuilder(\"mobile_list\")            \r\n            .select(\"mobile_list\")\r\n            .addSelect(\"portussd.id_port\")\r\n            .innerJoinAndSelect(sms_portussd, \"portussd\", \"mobile_list.mobile = portussd.mobile\")\r\n            .where(\"need_amount - charg_amount >= :amount\", {amount:_amount})\r\n            .andWhere(\"portussd.status=:status1\",{status1:1})\r\n            .orderBy(\"need_amount - charg_amount\",\"DESC\")\r\n            .addOrderBy(\"portussd.last_update\", \"DESC\")   \r\n            .getOne();\r\n    }"
      },
      {
        "user": "OLDIN",
        "created_at": "2020-01-18T18:48:18Z",
        "body": "A have same problem.\r\nVersion: _0.2.22_\r\nDB: _postgresql_\r\n\r\nMy code:\r\n```\r\nconst result = await this._orderCfRepo.createQueryBuilder('ocf')\r\n      .select('ocf')\r\n      .addSelect('cf.id')\r\n      .addSelect('cf.type')\r\n      .innerJoin(CustomField, 'cf', 'cf.id = ocf.customFieldId')\r\n      .getOne();\r\n```\r\n\r\nGenerated SQL:\r\n```\r\nSELECT\r\n\"ocf\".\"deletedAt\" AS \"ocf_deletedAt\",\r\n\"ocf\".\"inputValue\" AS \"ocf_inputValue\",\r\n\"ocf\".\"customFieldId\" AS \"ocf_customFieldId\",\r\n\"ocf\".\"orderId\" AS \"ocf_orderId\",\r\n\"ocf\".\"customFieldItemId\" AS \"ocf_customFieldItemId\", \r\n\"cf\".\"id\" AS \"cf_id\", \r\n\"cf\".\"type\" AS \"cf_type\"\r\nFROM \"orderCFItem\" \"ocf\"\r\nINNER JOIN \"customField\" \"cf\" ON \"cf\".\"id\" = \"ocf\".\"customFieldId\"\r\n```\r\n\r\nExpected:\r\n```\r\nOrderCFItem {\r\n  deletedAt: null,\r\n  inputValue: '380454635552',\r\n  customFieldId: 1,\r\n  orderId: 80,\r\n  customFieldItemId: null\r\n  customField: CustomField {\r\n    id: 1\r\n    type: 'list'\r\n  }\r\n}\r\n```\r\n\r\n\r\nBut in console:\r\n```\r\nOrderCFItem {\r\n  deletedAt: null,\r\n  inputValue: '380454635552',\r\n  customFieldId: 1,\r\n  orderId: 80,\r\n  customFieldItemId: null\r\n}\r\n```"
      },
      {
        "user": "OLDIN",
        "created_at": "2020-01-18T18:54:10Z",
        "body": "only works if replaced:\r\n\r\n```.innerJoin(CustomField, 'cf', 'cf.id = ocf.customFieldId')```\r\n\r\nat\r\n\r\n```.innerJoin('ocf.customField', 'cf', 'cf.id = ocf.customFieldId')```"
      },
      {
        "user": "elle86a",
        "created_at": "2020-07-29T08:51:23Z",
        "body": "@OLDIN i think you not have added the relations in the entity.\r\nThe 'cf.id = ocf.customFieldId' is a join where not needed if have the relation upset\r\n\r\ni have same version of typeOrm"
      },
      {
        "user": "OLDIN",
        "created_at": "2020-07-29T09:34:19Z",
        "body": "@elle86a no, the first argument must be a string instead an entity (no need to focus on the third argument)."
      },
      {
        "user": "RocaManuel",
        "created_at": "2020-08-07T22:32:42Z",
        "body": "i think what elle86a says is that if you create the relation in the Entity you will have a field that is the relation for ex:\r\n\r\n@ManyToMany(..)\r\n@JoinColumn(...)\r\nfield_name: Entity;\r\n\r\nso the first argument is the \"field_name\" that represents that relation (and where you will display it) if i'm not wrong or if i didn't miss understood"
      },
      {
        "user": "vinitkantrod",
        "created_at": "2021-04-20T16:54:31Z",
        "body": "> @kwehrle not sure if you are still looking for the answer. But you should use addSelect in this case.\r\n> \r\n> ```js\r\n> await db.getRepository(Inquiry)\r\n> \t.createQueryBuilder('inq')\r\n> \t.innerJoin(DocUnitType, 'dut', 'inq.docUnitTypeID = dut.ID')\r\n>         .select(['inq.ID','inq.dt','inq.status','inq.bsnr'])\r\n> \t.addSelect('dut.name')\r\n> \t.where('inq.participantID = :partID', { partID })\r\n> \t.orderBy('inq.dt', 'DESC')\r\n> \t.getMany();\r\n> ```\r\n\r\nI am getting error in `Select disctinct` query which typeorm calls by default for innerjoin and count. \r\n\r\nThis is my query\r\n```\r\nconst query = getRepository(ProductListing)\r\n      .createQueryBuilder('productListing')\r\n      .innerJoin('productListing.sellerProduct', 'sellerProduct',\r\n        'sellerProduct.deletedToken = :token',\r\n        { token: application.NOT_APPLICABLE })\r\n        .select([\r\n          'productListing.label',\r\n          'productListing.pricing_type',\r\n          'productListing.selling_price',\r\n          'productListing.status',\r\n          'productListing.start_date',\r\n          'productListing.end_date',\r\n          'sellerProduct.spin']).skip(0).take(10).getManyAndCount();\r\n```"
      },
      {
        "user": "QauseenMaab",
        "created_at": "2022-03-22T14:23:01Z",
        "body": "In my case using `getRawMany()` worked instead of `getMany`.\r\n\r\nFor example:\r\n```\r\n const res = await createQueryBuilder('profiles', 'profile')\r\n    .select(['profile.*', 'user.name'])\r\n    .where('profile.user.id = :userId', { userId })\r\n    .innerJoin(User, 'user', 'user.id = :userId', { userId })\r\n    .getRawMany();\r\n```"
      },
      {
        "user": "vtereshyn",
        "created_at": "2023-05-19T15:44:06Z",
        "body": "@QauseenMaab but `getRawMany` is a bit different thing. I am also looking for the reason why `getRawMany` works, but `getMany` doesn't"
      }
    ]
  },
  {
    "number": 874,
    "title": "[Question] Docs location - typeorm.github.io or /docs? ",
    "created_at": "2017-09-12T19:13:04Z",
    "closed_at": "2017-09-12T19:28:44Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/874",
    "body": "Where would you like to have the up-to-date docs for typeorm in the future? typeorm.github.io or /docs? Or is the plan to keep both up-to-date?\r\nI'm just curious where the updated docs for the browser version would go.",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/874/comments",
    "author": "daniel-lang",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-09-12T19:26:28Z",
        "body": "go and update `docs`. It contains latest documentation. Once I finish all planned 0.1.0 features and will be close to release final 0.1.0 I'll publish a new site with all docs from \"docs\" directory."
      },
      {
        "user": "daniel-lang",
        "created_at": "2017-09-12T19:27:35Z",
        "body": "Great!"
      }
    ]
  },
  {
    "number": 869,
    "title": "Question - Deep joining",
    "created_at": "2017-09-12T10:28:47Z",
    "closed_at": "2017-09-12T10:37:24Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/869",
    "body": "Is the following possible with 1 query?\r\n\r\nI have the following relationship:\r\n\r\n`User` 1-* `Account` 1-* `Expense` *-1 `Project`\r\n\r\nI'm trying to get all the projects a certain user has made expenses for through any of their accounts.\r\n\r\nI can get as far as getting the expenses for each account:\r\n\r\n```\r\n    const user = await this.repo\r\n      .createQueryBuilder('user')\r\n      .innerJoinAndSelect('user.accounts', 'accounts')\r\n      .leftJoinAndSelect('accounts.expenses', 'expenses')\r\n      // next line breaks\r\n      .leftJoinAndSelect('accounts.expenses.projects', 'projects')\r\n      .where('user.id=:user_id')\r\n      .setParameter('user_id', id)\r\n      .getOne()\r\n```\r\n\r\nI've tried multiple variations of the breaking line - but I'm not sure if it's even possible what I'm trying to do.",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/869/comments",
    "author": "shotor",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-09-12T10:32:07Z",
        "body": "Try this way:\r\n\r\n```ts\r\nconst user = await this.repo\r\n      .createQueryBuilder('user')\r\n      .innerJoinAndSelect('user.accounts', 'accounts')\r\n      .leftJoinAndSelect('accounts.expenses', 'expenses')\r\n      .leftJoinAndSelect('expenses.projects', 'projects')\r\n      .where('user.id=:user_id')\r\n      .setParameter('user_id', id)\r\n      .getOne()\r\n```"
      },
      {
        "user": "shotor",
        "created_at": "2017-09-12T10:37:24Z",
        "body": "That gives me the following error:\r\n```\r\nError: Relation with property path projects in entity was not found.\r\n```\r\nBut it got me thinking, `Expense` has a `ManyToOne` to `Project`. So it's correct that it doesn't have a `projects` property, it simply has `project` (confirmed by looking at my code). Changing `projects` from plural to singular fixed the problem.\r\n\r\nQuestion: Can you infinitely join relationships like this?"
      },
      {
        "user": "pleerock",
        "created_at": "2017-09-12T10:42:21Z",
        "body": "Yeah but you are limited by number of joins your database supports (for example mysql can support max 64 joins, etc.)"
      }
    ]
  },
  {
    "number": 867,
    "title": "result of `findAndCount` is wrong when apply `skip` and `take` option",
    "created_at": "2017-09-12T09:54:33Z",
    "closed_at": "2017-09-12T10:31:10Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/867",
    "body": "bellow test case failed\r\n\r\n````js\r\n        const userRepository = connection.getRepository(User);\r\n        const users = new Array(5).fill(0).map((n, i) => {\r\n            const user = new User();\r\n            user.username = `User_${i}`;\r\n            return user;\r\n        });\r\n        await userRepository.save(users);\r\n        const [ foundUsers, totalCount ] = await userRepository.findAndCount({\r\n            skip: 1,\r\n            take: 2\r\n        });\r\n        expect(foundUsers).to.have.lengthOf(2); \r\n````\r\n\r\nthe output is:\r\n\r\n`AssertionError: expected [ Array(5) ] to have a length of 2 but got 5`\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/867/comments",
    "author": "YuhangGe",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-09-12T10:04:28Z",
        "body": "`count` does not return number of selected users - it has different purpose. If you want to get number of selected users just use `foundUsers.length`. Count returns you number of all users you have queried (including where and other conditions) and IGNORES skip/take you set. This allows you to create a proper pagination/infinite scroll/etc knowing where is your limit of users."
      },
      {
        "user": "YuhangGe",
        "created_at": "2017-09-12T10:17:42Z",
        "body": "@pleerock yeah, I know. \r\n\r\nI found this problem just when I want to use findAndCount to make pagination search. I just call findAndCount without any `where` conditions. But it ignore my `skip` and `take` parameters, and the generated SQL has no `LIMIT`.\r\n\r\nI checked the source code and guess it's a logic bug, so I have submit a pr #868 , please see if it's really a logic bug."
      },
      {
        "user": "pleerock",
        "created_at": "2017-09-12T10:21:20Z",
        "body": "@YuhangGe please read my comment once again. Count MUST ignore `skip` and `take` params, its by design. Your test MUST look this way:\r\n\r\n```ts\r\n const userRepository = connection.getRepository(User);\r\n        const users = new Array(5).fill(0).map((n, i) => {\r\n            const user = new User();\r\n            user.username = `User_${i}`;\r\n            return user;\r\n        });\r\n        await userRepository.save(users);\r\n        const [ foundUsers, totalCount ] = await userRepository.findAndCount({\r\n            skip: 1,\r\n            take: 2\r\n        });\r\n        expect(foundUsers).to.have.lengthOf(5);  // CORRECT is 5, NOT 2. If you want to get \"2\" use foundUsers.length instead\r\n```"
      },
      {
        "user": "pleerock",
        "created_at": "2017-09-12T10:23:43Z",
        "body": "Hmm you made same in your test. Probably I misunderstood you, let me see your PR in details "
      },
      {
        "user": "YuhangGe",
        "created_at": "2017-09-12T10:24:58Z",
        "body": "@pleerock okey. so what about bellow case:\r\n\r\n````js\r\nconst userRepository = connection.getRepository(User);\r\n        const users = new Array(5).fill(0).map((n, i) => {\r\n            const user = new User();\r\n            user.username = `User_${i}`;\r\n            return user;\r\n        });\r\n        await userRepository.save(users);\r\n        const foundUsers = await userRepository.find({\r\n            skip: 1,\r\n            take: 2\r\n        });\r\n        expect(foundUsers.length).to.equal(2)\r\n````\r\n\r\nthe output is: `AssertionError: expected 5 to equal 2`"
      },
      {
        "user": "YuhangGe",
        "created_at": "2017-09-12T10:25:44Z",
        "body": "@pleerock actually both `find` and `findAndCount` have same problem"
      },
      {
        "user": "pleerock",
        "created_at": "2017-09-12T10:30:41Z",
        "body": "Sorry, stupid me. I misunderstood your issue - i thought you have issue with count and not  users count. Let me merge your PR and take a look on issue more closely "
      }
    ]
  },
  {
    "number": 864,
    "title": "Coloumns are not creating in MYSQL Database",
    "created_at": "2017-09-12T07:03:41Z",
    "closed_at": "2017-09-12T16:18:40Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/864",
    "body": "`My` code is running successfully but  **all columns** in **entity** file are not creating in mysql table i dont know why? but remaining table columns are creating successfully.\r\n\r\n```ts\r\n@Entity(\"product_skus\")\r\nexport class ProductSku{\r\n    @PrimaryGeneratedColumn({name:\"id\"})\r\n    id:number;\r\n\r\n    @JoinColumn({name:\"products_id\"})\r\n    @ManyToOne(type=>Product)\r\n    products_id:Product;\r\n\r\n\r\n    @Column({name:\"active\"})\r\n    active:boolean;\r\n\r\n    @Column({\r\n        name:\"name\",\r\n        length:128\r\n    })\r\n    name:string;\r\n\r\n    @JoinColumn({name:\"user_billings\"})\r\n    @ManyToOne(type=>UserBilling)\r\n    user_billings:UserBilling;\r\n\r\n}\r\n```\r\n\r\n**From above entity only user_billings field is creating in db and no any other column is creating**",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/864/comments",
    "author": "imhari213",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-09-12T08:15:44Z",
        "body": "what do you call `remaining table columns` ? Do you have `synchronize` option set to true in your connection options? did you try to run `typeorm schema:sync` command?"
      },
      {
        "user": "imhari213",
        "created_at": "2017-09-12T14:46:15Z",
        "body": "yes solved.Thank you"
      }
    ]
  },
  {
    "number": 859,
    "title": "Question - entity relations ",
    "created_at": "2017-09-11T15:08:36Z",
    "closed_at": "2017-09-12T08:25:42Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/859",
    "body": "What is the expected behavior regarding the update of relations ? Are the inverse relations updated automatically ? What about their RelationId columns (assuming they are explicitly declared on the classes)\r\n\r\nFor example, assuming I have a master - detail relation as below (please note the Author and AuthorId columns - AuthorId exists on the class declaration)\r\n\r\n```ts\r\n@Entity(\"Persons\")\r\nexport class Author {\r\n\r\n    @PrimaryGeneratedColumn()\r\n    Id: number;\r\n\r\n    @Column()\r\n    Name: string;\r\n\r\n    @OneToMany(type => Photo, photo => photo.Author) // Note: we will create author property in the Photo class below\r\n    Photos: Photo[];\r\n}\r\n\r\n@Entity(\"Photos\")\r\nexport class Photo {\r\n\r\n    @PrimaryGeneratedColumn()\r\n    Id: number;\r\n\r\n    @Column({\r\n        length: 800,\r\n        nullable: false\r\n    })\r\n    Name: string;\r\n\r\n    @Column(\"text\")\r\n    Description: string;\r\n\r\n    @Column()\r\n    Filename: string;\r\n\r\n    @ManyToOne(type => Author, author => author.Photos, {\r\n        onDelete: \"CASCADE\"\r\n    })\r\n    Author: Author;\r\n\r\n    @RelationId((photo: Photo) => photo.Author)\r\n    AuthorId: number;\r\n\r\n}\r\n```\r\nAssume that I load an author from DB and a photo using 2 distinct calls from their repositories.\r\nThe photo is not related to this author.\r\n\r\nIf I set the Author property on the photo instance would the AuthorId  contain the Id of the Author instance ? Will this happen automatically or I would have to set it manually ? Also is the Author.Photos updated so that it contains the linked photo ?\r\n\r\nAlso if I push a Photo instance to the author.Photos array, will the inverse relations be updated automatically (Author instance would contain the author and AuthorId will contain the Author.Id)\r\n\r\nThank you\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/859/comments",
    "author": "ghost",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-09-11T16:42:14Z",
        "body": "> Are the inverse relations updated automatically\r\n\r\nNo. This would create a circular dependency which I would like to avoid, because most of the time people return object tree directly to client and circular relationship will bring them problems\r\n\r\n> What about their RelationId columns (assuming they are explicitly declared on the classes)\r\n\r\nRelationId columns are updated when you change relation, there is a test for this case, I dont remember where someone in `github-issues` directory"
      },
      {
        "user": "iz-iznogood",
        "created_at": "2017-09-11T19:05:11Z",
        "body": "Hmm, ok I just wanted to be sure what the expected behavior is.\r\nHowever IMHO it would be best to update it both ways and create a proper toJSON or serialize or wrap method, since this can create inconsistencies on the model graph\r\n\r\nFor me I am good with how it works, I can handle it in my code, so you may close the issue\r\n\r\nThank you"
      },
      {
        "user": "pleerock",
        "created_at": "2017-09-12T03:51:31Z",
        "body": "> I can handle it in my code\r\n\r\nbe careful, what you want to do may not fit orm design and you'll just bring problems yourself\r\n\r\n> IMHO it would be best to update it both ways and create a proper toJSON or serialize or wrap method, \r\n\r\nDon't think its possible to effectively do it\r\n\r\n> since this can create inconsistencies on the model graph\r\n\r\nit can't be called graph actually... Keep in mind that orm does not use identity map to store all entities, and each loaded/joined entity is unique object even if it is same object, for example if you load post then join its categories and join same posts of categories, you'll have different instances of post, even if they are same in the database"
      },
      {
        "user": "iz-iznogood",
        "created_at": "2017-09-12T08:23:33Z",
        "body": "Thanks,\r\n\r\nwe use a number of extra layers on top of the orm (or not) depending on the task and in some cases it is useful to see the entities as a tree other (typeorm, sequelise) times as a graph (EF, Hibernate).\r\n\r\nSo we are good, you may close the issue"
      }
    ]
  },
  {
    "number": 847,
    "title": "database driver bug",
    "created_at": "2017-09-09T16:20:52Z",
    "closed_at": "2017-09-14T05:23:45Z",
    "labels": [
      "question",
      "documentation"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/847",
    "body": "when i create connections always throw error ,then step debug into the Connection \r\nthis  should be `connection.options.driver.type`\r\n```\r\nexport class DriverFactory {\r\n\r\n    /**\r\n     * Creates a new driver depend on a given connection's driver type.\r\n     */\r\n    create(connection: Connection): Driver {\r\n        const type = connection.options.type;\r\n        switch (type) {\r\n            case \"mysql\":\r\n                return new MysqlDriver(connection);\r\n            case \"postgres\":\r\n                return new PostgresDriver(connection);\r\n          /*....*/\r\n            default:\r\n                throw new MissingDriverError(type);\r\n        }\r\n    }\r\n\r\n}\r\n```\r\n\r\n\r\nmy `ormconfig.js` content is \r\n\r\n```js\r\n[\r\n  {\r\n    name: \"default\",\r\n    driver: {\r\n      type: \"mysql\",\r\n      host: \"***\",\r\n      port: 3306,\r\n      username: \"**\",\r\n      password: \"**\",\r\n      database: \"***\"\r\n    },\r\n    autoSchemaSync: true,\r\n    entities: [\"build/server/entity/*.js\"],\r\n    subscribers: [\"build/server/subscriber/*.js,\"],\r\n    migrations: [\"build/server/migration/*.js\"],\r\n    cli: {\r\n      entitiesDir: \"build/server/entity\",\r\n      migrationsDir: \"build/server/migration\",\r\n      subscribersDir: \"build/server/subscriber\"\r\n    }\r\n  }\r\n];\r\n```\r\nbut can not read  so i changed to this\r\n`ormconfig.dev.json`\r\n```json\r\n[{\r\n  \"name\": \"default\",\r\n  \"type\": \"mysql\",  \r\n  \"driver\": {\r\n    \"type\": \"mysql\",\r\n    \"host\": \"****\",\r\n    \"port\": 3306,\r\n    \"username\": \"**\",\r\n    \"password\": \"**\",\r\n    \"database\": \"***\"\r\n  },\r\n  \"autoSchemaSync\": true,\r\n  \"entities\": [\"server/entity/*.js\"],\r\n  \"subscribers\": [\"server/subscriber/*.js,\"],\r\n  \"migrations\": [\"server/migration/*.js\"],\r\n  \"cli\": {\r\n    \"entitiesDir\": \"server/entity\",\r\n    \"migrationsDir\": \"server/migration\",\r\n    \"subscribersDir\": \"server/subscriber\"\r\n  }\r\n}]\r\n```\r\n\r\ncreate connections code\r\n\r\n```typescript\r\nimport {\r\n  Connection,\r\n  createConnections,\r\n  ConnectionManager,\r\n  ConnectionOptionsReader\r\n} from \"typeorm\";\r\nimport { Container } from \"typedi\";\r\nimport { dev } from \"./server\";\r\nconst connectionManager = Container.get(ConnectionManager);\r\nexport async function createDbConnections(): Promise<Connection[]> {\r\n  let ormCfgName = dev ? \"ormconfig.dev\" : \"ormconfig\";\r\n  let reader = new ConnectionOptionsReader({\r\n    // root: `${__dirname}`,\r\n    root: `${process.cwd()}/server`,\r\n    // root: `server`,\r\n    configName: ormCfgName\r\n  });\r\n  \r\n  try {\r\n    let option = await reader.all();\r\n    let connections = await createConnections(option);\r\n    return connections;\r\n  } catch (err) {\r\n    console.error(err);\r\n    throw err;\r\n  }\r\n}\r\n\r\n```",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/847/comments",
    "author": "foxundermoon",
    "comments": [
      {
        "user": "foxundermoon",
        "created_at": "2017-09-09T18:10:29Z",
        "body": "the doc is old .\r\nchange to flat config is ok"
      },
      {
        "user": "pleerock",
        "created_at": "2017-09-10T04:21:29Z",
        "body": "yes you are right, docs are outdated"
      },
      {
        "user": "pleerock",
        "created_at": "2017-09-14T05:23:45Z",
        "body": "All new docs are inside `docs` directory in the root of the project. I'll publish them to site once 0.1.0 final release is out"
      }
    ]
  },
  {
    "number": 829,
    "title": "Can not inherit Select Query Builder",
    "created_at": "2017-09-06T08:25:14Z",
    "closed_at": "2017-09-08T06:44:06Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/829",
    "body": "We used an \"extended\" Query Builder, that inherited your SelectQueryBuilder (which was \"QueryBuilder\" all the way back). As you recently changed the return types of a few functions (e.g. select) within your SelectQueryBuilder.ts from \"this\" to \"SelectQueryBuilder<Entity>\" we can not inherit it anymore.\r\n\r\nAre there any future plans on changing that back so the methods of that Query Builder can be inherited?",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/829/comments",
    "author": "lukasdietrich93",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-09-06T09:44:31Z",
        "body": "Right now you can transform query builder from one type to another. There are several query builder types:\r\n\r\n* InsertQueryBuilder\r\n* UpdateQueryBuilder\r\n* DeleteQueryBuilder\r\n* SelectQueryBuilder\r\n\r\neach has its own methods, and you can easily switch between query builder types, for example:\r\n\r\n```ts\r\ncreateQueryRunner(\"post\") // returns you SelectQueryBuilder\r\n\r\n// but lets say you want to use update query instead. You can do:\r\ncreateQueryRunner(\"post\")\r\n   .update() // returns you UpdateQueryBuilder\r\n\r\n// to make it possible update return signature is (): UpdateQueryBuilder<Entity> {\r\n// if we change it to this, then update will still return us SelectQueryBuilder\r\n// same with all other methods - delete, insert and select\r\n// because if you create update query builder and wanna switch it to select\r\n// using select() method if do \"this\" in return type we still will have UpdateQueryBuilder\r\n\r\n```\r\n\r\nI don't think its possible for `select` method to return `this` anymore."
      },
      {
        "user": "pleerock",
        "created_at": "2017-09-08T06:44:06Z",
        "body": "Feel free to continue discussion if you have something to add."
      },
      {
        "user": "lukasdietrich93",
        "created_at": "2017-09-08T07:06:11Z",
        "body": "We have some helper functions in our Extended Query Builder like \"addPaging\", but are stuck to the old version of typeorm because we can not inherit it anymore. What do you suggest, e.g. some kind of Mixins?"
      },
      {
        "user": "pleerock",
        "created_at": "2017-09-08T07:27:50Z",
        "body": "I don't know what you are doing and why to suggest something. My suggestion for now is - don't extend query builder. Create a separate class which will use query builder instead of creating its extending version."
      }
    ]
  },
  {
    "number": 825,
    "title": "Question - Joining tables.",
    "created_at": "2017-09-05T05:40:39Z",
    "closed_at": "2017-09-12T06:10:22Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/825",
    "body": "I'm trying to introduce some privilege control to my project. \r\n\r\nFirst, I have a File entity here. Each file has a owner group, and only members of its owner group can see the file.\r\n\r\n``` typescript\r\n@Entity()\r\nexport class File {\r\n\r\n    @PrimaryGeneratedColumn()\r\n    public id: number;\r\n\r\n    @Column('varchar')\r\n    public content: string;\r\n\r\n    @Column('int')\r\n    public groupId: number,\r\n\r\n}\r\n```\r\n\r\nAnd I have a group_map entity to store the relations between users and groups.\r\n\r\n``` typescript\r\n@Entity()\r\nexport class GroupMap {\r\n\r\n  @PrimaryColumn('int')\r\n  public groupId: number;\r\n\r\n  @PrimaryColumn('int')\r\n  public userId: number;\r\n\r\n}\r\n```\r\n\r\nWhen a particular user tries to list all the files that he could access, I would like to check whether this user belongs to the owner group of the file.  So to achieve this goal I would like to join the second table ON **File.groupId = groupMap.groupId AND groupMap.userId = :currentUserId (passed in as a parameter)**. \r\n\r\nI'm not sure whether this is possible using relations (or something else?) provided by TypeORM.\r\n\r\nAppreciate any help.",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/825/comments",
    "author": "codgician",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-09-05T20:22:48Z",
        "body": "so, why dont you use relations?:\r\n\r\n```ts\r\n@Entity()\r\nexport class File {\r\n\r\n    @PrimaryGeneratedColumn()\r\n    public id: number;\r\n\r\n    @Column('varchar')\r\n    public content: string;\r\n\r\n    @ManyToOne(type => Group) // you told one file has one group, right?\r\n    public group: Group;\r\n\r\n}\r\n```\r\n\r\n```ts\r\n@Entity()\r\nexport class Group {\r\n\r\n  @PrimaryColumn('int')\r\n  public id: number;\r\n\r\n  @ManyToMany(type => User) // you told each user can have their own groups, right?\r\n  @JoinTable() // or this can be on User side if you want a bi-directional relation \r\n  public users: User[];\r\n\r\n}\r\n```\r\n\r\nNow if you need to files with groups owned by a current user:\r\n\r\n```ts\r\nconst files = await fileRepository.createQueryBuilder(\"file\")\r\n    .innerJoin(\"file.group\", \"fileGroup\")\r\n    .innerJoin(\"fileGroup.users\", \"fileGroupUser\", \"fileGroupUser.id = :currentUserId\")\r\n    .setParameter(\"currentUserId\", currentUserId)\r\n    .getMany();\r\n```"
      },
      {
        "user": "codgician",
        "created_at": "2017-09-06T07:25:10Z",
        "body": "Thanks for your solution!\r\nAnd does that mean when I'm adding a user to a group I'll have to fetch the user instance and then group.users = [UserInstance]?"
      },
      {
        "user": "pleerock",
        "created_at": "2017-09-06T07:42:15Z",
        "body": "right"
      },
      {
        "user": "codgician",
        "created_at": "2017-09-06T13:47:43Z",
        "body": "Emm, one more question (sorry), is it possible if I want to add another column \"privilege\" into the mapping table? Like a member of a group can either be a common user or a group administrator? Thanks. 🌹 "
      },
      {
        "user": "pleerock",
        "created_at": "2017-09-06T14:00:12Z",
        "body": "in many-to-many table? If yes, then no, its not possible. You can too create entity and add there 3 columns with proper relations."
      },
      {
        "user": "codgician",
        "created_at": "2017-09-06T14:14:33Z",
        "body": "You mean I can create a standalone entity \"GroupMap\" and put two ManyToOne relationships inside, like:\r\n``` typescript\r\n\r\n@Entity()\r\nexport class GroupMap {\r\n\r\n  @ManyToOne(type => Group)\r\n  @JoinColumn()\r\n  public group: Group;\r\n\r\n  @ManyToOne(type => User)\r\n  @JoinColumn()\r\n  public user: User;\r\n\r\n  @Column('int')\r\n  public privilege: number;\r\n\r\n}\r\n```\r\n\r\nIs that appropriate? Thanks for your patience.\r\n\r\nP.S. If the method above won't work, does that mean I can't use relations to achieve this? Then how can I join the mapping table in a query?"
      },
      {
        "user": "pleerock",
        "created_at": "2017-09-06T14:17:48Z",
        "body": "Yes,  right"
      },
      {
        "user": "codgician",
        "created_at": "2017-09-06T14:45:39Z",
        "body": "So is it possible to create index on user and group as well if they have ManyToOne and JoinColumn decorators (perhaps a stupid question)?  "
      },
      {
        "user": "pleerock",
        "created_at": "2017-09-06T15:03:03Z",
        "body": "You can use `@Index` decorator if you want to create index."
      },
      {
        "user": "codgician",
        "created_at": "2017-09-12T06:10:22Z",
        "body": "Solved. Thanks for your help."
      },
      {
        "user": "ruslanchek",
        "created_at": "2018-07-05T20:42:30Z",
        "body": "Ok then DTO has to include User Object. How to create records in this case?"
      }
    ]
  },
  {
    "number": 812,
    "title": "[Question] Cancel updating/removing an Entity in @beforeRemove/@beforeUpdate. Use same transaction for other queries.",
    "created_at": "2017-08-31T12:39:04Z",
    "closed_at": "2017-09-06T10:47:59Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/812",
    "body": "Hi,\r\n\r\ni have two questions: \r\n\r\n- how can I stop silently updating or removing an entity by using @beforeUpdate @beforeRemove - (eg. by returning false in the functions, or call event.cancel() ?)\r\n\r\n- how can I use the same transaction in events for another queries\r\n\r\nmy idea:\r\n\r\n`\r\n    @AbstractEntity()\r\n    export class ArchiveModel {\r\n\r\n        @PrimaryColumn('uuid')\r\n        id: string\r\n\r\n        @PrimaryColumn('int')\r\n        version: number\r\n\r\n        @Column()\r\n        createdAt: Date\r\n\r\n        @Column({ nullable: true })\r\n        updatedAt: Date\r\n\r\n        @Column({ nullable: true })\r\n        deletedAt: Date\r\n\r\n        @BeforeInsert()\r\n        beforeInsert(event: InsertEvent<ArchiveModel>) {\r\n            if (!event.entity.id) {\r\n                event.entity.id = uuid()\r\n                event.entity.version = 1\r\n                event.entity.createdAt = new Date()\r\n            }\r\n        }\r\n\r\n        @BeforeUpdate()\r\n        beforeUpdate(event: UpdateEvent<ArchiveModel>) {\r\n            // stop updating original entity\r\n\r\n            // begin transaction\r\n\r\n            // only update updatedAt attribute in original entity\r\n            event.databaseEntity.updatedAt = new Date()\r\n\r\n            // increase version (optimistic concurrency ?)\r\n            event.entity.version = event.databaseEntity.version + 1\r\n\r\n            // remove old updated at information\r\n            event.entity.updatedAt = null\r\n            event.manager.save(event.entity)\r\n\r\n            // end transaction\r\n        }\r\n\r\n        @BeforeRemove()\r\n        beforeRemove(event: UpdateEvent<ArchiveModel>) {\r\n            // stop removing original entity\r\n\r\n            // only update deletetAt in original entity\r\n            event.entity.deletedAt = new Date()\r\n        }\r\n    }`\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/812/comments",
    "author": "mattmeye",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-08-31T14:38:57Z",
        "body": "> how can I stop silently updating or removing an entity by using @beforeupdate @beforeremove - (eg. by returning false in the functions, or call event.cancel() ?)\r\n\r\nyou can't. And I don't think you'll even be able to do it, don't think its a good idea.\r\n\r\n> how can I use the same transaction in events for another queries\r\n\r\nsubscribers accept event object which holds instance of queryRunner/entityManager. Use that instance to perform all queries inside subscribers/listeners"
      },
      {
        "user": "pleerock",
        "created_at": "2017-09-06T10:47:59Z",
        "body": "I hope I answered your question."
      }
    ]
  },
  {
    "number": 806,
    "title": "Creating a foreign key for a composite key",
    "created_at": "2017-08-29T14:29:11Z",
    "closed_at": "2017-09-06T11:27:03Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/806",
    "body": "Hi, I've been trying to create a foreign key, but could not find out how to do it properly. My entities are as the following:\r\n\r\n    @Entity()\r\n    export class LocationName {\r\n       @PrimaryColumn('string')\r\n       locationNameSpace: LocationNameSpace;\r\n\r\n       @PrimaryColumn('string')\r\n       name: string;\r\n\r\n       @Column('string')\r\n       description: string;\r\n    }\r\n\r\n    @Entity()\r\n    export class LocationNameTranslation {\r\n\r\n      @ManyToOne(type => LocationName, locationName => (locationName))\r\n      sourceLocationName:LocationName;\r\n\r\n      @ManyToOne(type => LocationName, locationName => (locationName))\r\n      targetLocationName:LocationName;\r\n    }\r\n\r\nHowever, I'm getting the following error:\r\n\"Cannot automatically determine a referenced column of the \"LocationName\", because it has multiple primary columns. Try to specify a referenced column explicitly.\" Checked the examples but could not find any similar. What is the correct way to define a foreign key for a composite primary key? Checked the examples but could not see a similar one...",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/806/comments",
    "author": "dorukokan",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-08-29T19:07:28Z",
        "body": "what typeorm version are you using?"
      },
      {
        "user": "dorukokan",
        "created_at": "2017-08-29T19:47:30Z",
        "body": "I'm using the following:\r\n\"typeorm\": \"0.0.8\",\r\n\"typeorm-routing-controllers-extensions\": \"0.0.6\""
      },
      {
        "user": "pleerock",
        "created_at": "2017-08-29T19:57:04Z",
        "body": "ohh very old version. Composite foreign key support was added in the latest 0.1.0-alpha versions. Please consider upgrade your typeorm version "
      },
      {
        "user": "pleerock",
        "created_at": "2017-09-06T11:27:03Z",
        "body": "This must work in latest versions. Please let me know if its not."
      }
    ]
  },
  {
    "number": 802,
    "title": "Support object instances in migrations list",
    "created_at": "2017-08-28T00:19:02Z",
    "closed_at": "2017-09-07T06:13:48Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/802",
    "body": "Essentially what I would like to do is dependency inject database migrations, so allowing object instances that implement `MigrationInterface` would make the following possible:\r\n```\r\nmigrations: [\r\n  context.resolve<PerformAMigration2808718439522>()\r\n]\r\n```\r\nMigration names could still be retrieved with `this.constructor.name` in this case.\r\n\r\nKeen to hear what you think.\r\n\r\nThanks",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/802/comments",
    "author": "guscastro",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-08-28T17:54:28Z",
        "body": "Migrations are created using container. If you setup for example container with typedi you can then inject dependencies. Example with typedi:\r\n\r\n```ts\r\n// before creating connection somewhere like in app.ts\r\nimport {Container} from \"typedi\";\r\nimport {useContainer} from \"typeorm\";\r\n\r\nuseContainer(Container);\r\n```\r\n\r\nThen this will work:\r\n\r\n```ts\r\nimport {Service} from \"typedi\";\r\n\r\n@Service()\r\nexport class SomeMigration implements MigrationInterface {\r\n\r\n    constructor(private userService: UserService, \r\n                         private passwordManager: PasswordManager) {\r\n    }\r\n\r\n}\r\n```\r\n\r\nIf you don't use typedi then simply provide factory function to `useContainer` method"
      }
    ]
  },
  {
    "number": 796,
    "title": "Repository.findOne() cannot select by foreign key with DeepPartial",
    "created_at": "2017-08-25T05:30:08Z",
    "closed_at": "2017-09-07T06:17:10Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/796",
    "body": "Now that Repository.findOne() requires a deep partial, it's not possible to query on a foreign key. For example, if you were to find a photo with name \"my photo\" by author with id 1, you could previously make the following query\r\n\r\nphotoRepository.findOne({ name: \"my photo\", author: 1 });\r\n\r\nNow that findOne expects a deep partial, author must be look like an Author type. So to get it to build, you have to change the query to something like the following:\r\n\r\nphotoRepository.findOne({ name: \"my photo\", author: { id: 1 } });\r\n\r\nThe query tries to find a photo with an author column value of '{ id: 1 }' instead of the actual value in the Photo table, which is '1'\r\n\r\n\r\nThis was reproduced on Postgres running typeorm version 0.1.0-alpha.35",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/796/comments",
    "author": "jwclark",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-08-25T16:06:39Z",
        "body": "It was working before not be design. It worked before only because column names match (author was called author in the database). Right now column for author is called \"authorId\" and probably by old way you should do photoRepository.findOne({ name: \"my photo\", authorId: 1 });\r\n\r\nTo fix your issue I recommend you to add a new column called \"authorId\" and it will fix your issue. \"authorId\" will be automatically picked up by relation since they both have same name\r\n"
      },
      {
        "user": "llwt",
        "created_at": "2017-09-18T01:59:19Z",
        "body": "@pleerock I just ran into this myself and find it a bit confusing. If the current design is to add a new column for the id of the relation rather than using the relation, what is the reasoning behind using `DeepPartial<Entity>` as the type for `.findOne(conditions?)`?"
      },
      {
        "user": "pleerock",
        "created_at": "2017-09-18T04:57:16Z",
        "body": "> If the current design is to add a new column for the id of the relation rather than using the relation, what is the reasoning behind using \r\n\r\nI don't see relation there.. DeepPartial is simply to keep it kinda type-safe. Find method never was suppose to work with database columns. Database columns are known only internally by orm. It was always suppose to work with your entity properties"
      },
      {
        "user": "llwt",
        "created_at": "2017-09-18T16:14:08Z",
        "body": "I guess my question is more why `DeepPartial<entity>` instead of just `Partial<Entity>`?"
      },
      {
        "user": "pleerock",
        "created_at": "2017-09-18T17:33:50Z",
        "body": "There are lot of deep stuff under the hood...\r\n\r\nRight now I think `DeepPartial` is not used somehow, but it probably must be used for embeddded functionality. If lets say you have a column inside embedded class inside entity then your query probably must look like this way:\r\n\r\n```ts\r\nfind({  counter: { likes: 1 } })\r\n```\r\n\r\nBut this functionality is not implemented yet. Something we totally need to finish there"
      },
      {
        "user": "llwt",
        "created_at": "2017-09-18T20:50:21Z",
        "body": "Thanks for the clarification."
      },
      {
        "user": "snaquaye",
        "created_at": "2018-01-17T19:58:03Z",
        "body": "@pleerock so if i use the `@JoinColumn` decorator to rename the field in the database to say `author`, would I be able to do something like `photoRepository.findOne({ name: \"my photo\", author: 1 });`.\r\n\r\nThanks"
      },
      {
        "user": "pleerock",
        "created_at": "2018-01-18T05:06:17Z",
        "body": "@snaquaye you will still need to use property names instead of database column names in findOne options."
      }
    ]
  },
  {
    "number": 794,
    "title": "Question - What does @JoinTable in @ManyToMany does?",
    "created_at": "2017-08-24T16:20:32Z",
    "closed_at": "2017-09-06T15:36:06Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/794",
    "body": "Hi and sorry for the stupid question:\r\n\r\nWhat is the difference between the two connected entities with @ManyToMany ?\r\nWhat does the `owner side` means?",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/794/comments",
    "author": "Urigo",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-08-24T18:24:47Z",
        "body": "\r\nLet's start with `one-to-one` relation.\r\nLet's say we have two entities: `User` and `Photo`:\r\n\r\n```typescript\r\n@Entity()\r\nexport class User {\r\n    \r\n    @PrimaryGeneratedColumn()\r\n    id: number;\r\n    \r\n    @Column()\r\n    name: string;\r\n    \r\n    @OneToOne()\r\n    photo: Photo;\r\n    \r\n}\r\n```\r\n\r\n```typescript\r\n@Entity()\r\nexport class Photo {\r\n    \r\n    @PrimaryGeneratedColumn()\r\n    id: number;\r\n    \r\n    @Column()\r\n    url: string;\r\n    \r\n    @OneToOne()\r\n    user: User;\r\n    \r\n}\r\n```\r\n\r\nThis example does not have `@JoinColumn` decorator which is not correct.\r\nWhy? Because to make a real relation we need to create a column in the database.\r\nWe need to create a column `userId` in `photo` table or `photoId` in `user` table.\r\nBut which exactly column should be created - `userId` or `photoId`?\r\nORM cannot decide it for you. \r\nTo make a decision you must `@JoinColumn` decorator on one of the side.\r\nIf you put `@JoinColumn` in `Photo` entity then `userId` column will be created in `photo` table.\r\nIf you put `@JoinColumn` in `User` entity then `photoId` column will be created in `user` table.\r\nWhere you put `@JoinColumn` decorator that side will be called \"owner side of the relationship\".\r\nOther side of relation, without `@JoinColumn` decorator is called \"inverse (non-owner) side of relationship\".\r\n\r\nSame in `@ManyToMany` relation you use `@JoinTable` decorator to show owner side of relation.\r\n\r\nIn `@ManyToOne` or `@OneToMany` relations `@JoinColumn` decorator is not necessary because \r\nboth decorators are different and where you put `@ManyToOne` decorator that table will have relational column. \r\n\r\n`@JoinColumn` and `@JoinTable` decorators are also can be used to specify additional\r\njoin column / junction table settings, like join column name or junction table name. \r\n"
      },
      {
        "user": "Urigo",
        "created_at": "2017-08-25T00:52:06Z",
        "body": "@pleerock thank you for the detailed answer.\r\n\r\nSo in case of `@ManyToMany`, it will create a separate table that will have two columns - `photoId` and `UserId`.  \r\nso no need for a column on the `Photo` table nor the `User` table (and creating that with TypeORM I also see that behaviour).\r\nSo where does `@JoinTable` owner comes into play?\r\nI mean, does it change anything in the implementation?\r\nIf so, what if there is no owner, they are both just connected to each other and each side can create the other side with connection as well?\r\n\r\nThanks\r\n"
      },
      {
        "user": "pleerock",
        "created_at": "2017-08-25T15:58:33Z",
        "body": "I don't remember all places where it does matter, but it does. For example naming thing. It names table like this: `user_photos`. ORM makes decision to name it `user_photos` or `photo_users` based on which side is owning. Same with columns order inside this table.\r\n\r\nAlso having join table on one side prevents it to create two tables and makes it really bi-directional.\r\n\r\nIf you are confused where to put join table decorator, just try to think about data side. What is \"original\" side of relation. For example if user has photos and photos cannot exist without users then probably join table must be set on user side."
      },
      {
        "user": "Urigo",
        "created_at": "2017-09-03T21:21:13Z",
        "body": "@pleerock what if both sides are really \"equal\" also in the logical sense?"
      },
      {
        "user": "pleerock",
        "created_at": "2017-09-04T08:08:09Z",
        "body": "Its all about decision. If you think both sides are equal then put jointable/joincolumn decorator on any side you want."
      },
      {
        "user": "pleerock",
        "created_at": "2017-09-06T15:36:06Z",
        "body": "I think this can be closed"
      },
      {
        "user": "lefebvresam",
        "created_at": "2019-01-24T13:36:43Z",
        "body": "Putting joincolumn on a ManyToMany has no effect."
      },
      {
        "user": "pleerock",
        "created_at": "2019-01-25T07:50:55Z",
        "body": "@lefebvresam ManyToMany uses JoinTable instead of JoinColumn"
      },
      {
        "user": "chetanc97",
        "created_at": "2020-06-19T16:03:09Z",
        "body": "@pleerock   But can we use just JoinColumn to get granchildren data . \r\nFore example -  table A has foreign key from table B & table B has foreign key from table C  .\r\nHow do you get data from table C as well . Does Typeorm support this ? "
      }
    ]
  },
  {
    "number": 788,
    "title": " Docs: Use case for migrations?",
    "created_at": "2017-08-21T19:08:00Z",
    "closed_at": "2017-08-22T15:33:04Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/788",
    "body": "Since entities (ie. `@Entities` in code) are the source of truth, and can be synced to the DB schema with `typeorm schema:sync`, what is the use case for manually running migrations?\r\n\r\nAre migrations and `schema:sync` meant to be used together for different use cases? Or is it one or the other, depending on your risk tolerance? Or am I totally missing the point here?",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/788/comments",
    "author": "bcherny",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-08-21T20:58:51Z",
        "body": "on production you may want more control. Schema sync can simply drop your exist data, in migrations you can write code which prevents it. For example first you copy exist data into new table then delete column with all data."
      },
      {
        "user": "bcherny",
        "created_at": "2017-08-21T23:10:50Z",
        "body": "Thanks for the quick response @pleerock.\r\n\r\nWould you avoid using schema sync in production, and stick to just migrations? It would be nice if there there was a \"safe\" mode for schema sync, which threw on destructive changes and suggested the user create a migration instead."
      },
      {
        "user": "pleerock",
        "created_at": "2017-08-22T10:58:11Z",
        "body": "you can run `typeorm schema:log` to see what sql queries `schema:sync` will execute. On production you can use it before running schema:sync. You run it and check and analyze what sql queries orm will execute. If you are okay with all queries and sure it wont hard your database you run schema:sync. If you aren't okay with changes you can create a migration and write sql code manually to make schema updation as your production needs"
      },
      {
        "user": "bcherny",
        "created_at": "2017-08-22T15:33:04Z",
        "body": "Excellent - thanks for the explanation @pleerock. Great work with TypeORM. Scheme syncing (and everything else about it) is a pleasure to use."
      }
    ]
  },
  {
    "number": 776,
    "title": "QueryRunnerProviderAlreadyReleasedError for Transaction",
    "created_at": "2017-08-18T21:32:29Z",
    "closed_at": "2017-09-06T15:26:21Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/776",
    "body": "Hi,\r\nI'm using typeorm 0.0.11 version. I got below error message when running a transaction. It seems when I was trying to persist to a second table, the database connection is closed:\r\n\r\nIn propse trade, fail in 2nd persit[2017-08-18 14:14:57.577] - INFO - In propse trade, fail in 2nd persit (my error log).\r\n\r\nQueryRunnerProviderAlreadyReleasedError: Database connection provided by a query runner was already released, cannot continue to use its querying methods anymore  (This is error message).\r\n\r\nThe database driver I'm using is mysql. Do we have to implement the connection pool for mysql for this to work?\r\n\r\nHere is partial code:\r\n\r\n     this.db.entityManager.transaction(async transactionalEntityManager => {\r\n                            transactionalEntityManager.persist(table1)\r\n                            .then((result) => {\r\n\r\n                                console.log('successful in 1st persist');\r\n                                let sAction: SAction = new SAction();\r\n                \r\n                                sActionId.Id = result.sId;\r\n                                sActionId.stateId = TS.TRIED;\r\n         \r\n                                transactionalEntityManager.persist(sAction)\r\n                                .then((result) => {\r\n                                    console.log('successful in 2nd persist');\r\n                                  })\r\n                              .catch((err) => {\r\n                                    console.log('fail in 2nd persit');\r\n                                    return reject(err);\r\n                                });\r\n                           })\r\n                           .catch((err) => {\r\n                                return reject(err);                              \r\n                            }); \r\n\r\n\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/776/comments",
    "author": "guanhongtan",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-08-19T05:24:14Z",
        "body": "You simply not awaiting promises inside your transaction. Try to change your code to:\r\n```ts\r\n this.db.entityManager.transaction(async transactionalEntityManager => {\r\n                        return transactionalEntityManager.persist(table1)\r\n                        .then((result) => {\r\n\r\n                            console.log('successful in 1st persist');\r\n                            let sAction: SAction = new SAction();\r\n            \r\n                            sActionId.Id = result.sId;\r\n                            sActionId.stateId = TS.TRIED;\r\n     \r\n                            return transactionalEntityManager.persist(sAction)\r\n                            .then((result) => {\r\n                                console.log('successful in 2nd persist');\r\n                              })\r\n                          .catch((err) => {\r\n                                console.log('fail in 2nd persit');\r\n                                return reject(err);\r\n                            });\r\n                       })\r\n                       .catch((err) => {\r\n                            return reject(err);                              \r\n                        }); \r\n```"
      },
      {
        "user": "pleerock",
        "created_at": "2017-09-06T15:26:21Z",
        "body": "I think this can be closed "
      },
      {
        "user": "erald14",
        "created_at": "2021-07-12T08:48:38Z",
        "body": "@pleerock  helpful thanks"
      }
    ]
  },
  {
    "number": 766,
    "title": "How to do a RIGHT JOIN and SELECT",
    "created_at": "2017-08-15T09:26:04Z",
    "closed_at": "2017-09-14T15:14:08Z",
    "labels": [
      "question",
      "comp: query builder"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/766",
    "body": "How does one do the following query using typeorm please\r\n\r\n```sql\r\nSELECT *\r\nFROM \"UserStrength\"\r\nRIGHT JOIN \"Strength\" ON \"Strength\".\"id\" = \"UserStrength\".\"strengthId\"\r\n```\r\n\r\nWhere the UserStrengthEntity is defined as:\r\n\r\n```typescript\r\n@Entity(\"UserStrength\")\r\nexport class UserStrengthEntity extends BaseEntity implements IUserStrength {\r\n    @Column({default: false}) isCompleted: boolean;\r\n\r\n    @ManyToOne(type => UserEntity, user => user.userStrengthArray, {\r\n        cascadeAll: true\r\n    })\r\n    @JoinColumn({name: \"userId\"})\r\n    user: UserEntity;\r\n\r\n    @OneToMany(type => UserStrengthItemEntity, userStrengthItem => userStrengthItem.userStrength, {\r\n        cascadeInsert: true,\r\n        cascadeUpdate: true\r\n    })\r\n    userStrengthItemArray?: UserStrengthItemEntity[];\r\n\r\n    @ManyToOne(type => StrengthEntity, strength => strength.userStrengthArray, {\r\n        cascadeAll: true\r\n    })\r\n    @JoinColumn({name: \"strengthId\"})\r\n    strength: StrengthEntity;\r\n}\r\n```\r\n\r\nand the StrengthEntity is:\r\n\r\n```typescript\r\n@Entity(\"Strength\")\r\nexport class StrengthEntity extends BaseEntity implements IStrength {\r\n    @Column({length: 50}) name: string;\r\n    @Column({length: 100}) title: string;\r\n    @Column() strengthType: StrengthType;\r\n    @Column({length: 10, nullable: true}) titleColor: string;\r\n    @Column({nullable: true}) titleIcon: string;\r\n\r\n    @ManyToOne(type => ClientEntity, clientEntity => clientEntity.strengthArray, {\r\n        cascadeAll: true\r\n    })\r\n    @JoinColumn({name: \"clientId\"}) client: ClientEntity\r\n\r\n    @OneToMany(type => StrengthItemEntity, strengthItem => strengthItem.strength, {\r\n        cascadeInsert: true,\r\n        cascadeUpdate: true\r\n    })\r\n    strengthItemArray: StrengthItemEntity[];\r\n\r\n    @OneToMany(type => UserStrengthEntity, userStrength => userStrength.strength, {\r\n        cascadeInsert: true,\r\n        cascadeUpdate: true\r\n    })\r\n    userStrengthArray: UserStrengthEntity[];\r\n}\r\n```\r\n\r\nI want to load a UserStrength which may or may not exist along with the Strength with a given strengthType (I would also need to RIGHT JOIN to the UserEntity to further filter by UserEntity.id)\r\n\r\nCould anyone explain how this is accomplished with typeorm please?",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/766/comments",
    "author": "StickNitro",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-09-14T15:14:07Z",
        "body": "Its not possible to do right joins in concept of such ORMs and I'll try to explain why.\r\n\r\nLets say we have `Post` and `Category` entities. \r\nIf we do left or inner joins we just select posts and all their categories and query builder it returns you posts with or without categories.\r\n\r\nIf we do a right join we start with posts and return posts with categories and just categories without posts. Since query builder selects and returns `Post[]` where do we insert categories without posts? We can't afford to return separate list of posts and categories it will break current query builder design.\r\n\r\nI suggest you to revisit sql you want to write with only left and inner joins, or maybe use subselects, or in worth case scenario you can write raw sql query, execute it and transform to entity manually."
      }
    ]
  },
  {
    "number": 744,
    "title": "Persist is overwriting the not loaded relationships",
    "created_at": "2017-08-07T16:24:03Z",
    "closed_at": "2017-09-08T15:27:13Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/744",
    "body": "I created a one to many relationship between two of my models:\r\n\r\nOrganization:\r\n```\r\n@Entity()\r\nexport class Organization {\r\n  @PrimaryColumn('uuid')\r\n  @IsUUID('4')\r\n  id: string;\r\n\r\n  @Column('string', { nullable: false })\r\n  name: string;\r\n\r\n  @OneToMany((type) => PersonOrganization, (personOrganization) => personOrganization.organization,\r\n    { cascadeInsert: false, cascadeUpdate: false })\r\n  personOrganizations: PersonOrganization[] = [];\r\n}\r\n```\r\nAnd PersonOrganization:\r\n```\r\n@Entity()\r\nexport class PersonOrganization {\r\n  @PrimaryColumn('uuid')\r\n  @IsUUID('4')\r\n  id: string;\r\n\r\n  @Column('string', { nullable: true })\r\n  matricula: string;\r\n\r\n  @ManyToOne((type) => Organization, (organization) => organization.personOrganizations,\r\n    { cascadeAll: false, nullable: false, onDelete: 'RESTRICT' })\r\n  @JoinColumn({ name: 'organization_id' })\r\n  organization: Organization;\r\n\r\n  @ManyToOne((type) => Person, (person) => person.personOrganizations,\r\n    { cascadeAll: false, nullable: false, onDelete: 'RESTRICT' })\r\n  @JoinColumn({ name: 'person_id' })\r\n  person: Person;\r\n}\r\n```\r\n\r\nI want to retrieve Organization from the database, update with some new values and persist it afterwards. With no cascade and no associated model.\r\n\r\nWhen I retrieve one organization model from the db though findOneById() I get this:\r\n\r\n```\r\nOrganization {\r\n  personOrganizations: [],\r\n  id: '0c3a1312-8f71-445e-bc93-f8e2e64af792',\r\n  name: 'E.M.MARTIM DE SÁ Atualizado',\r\n  createdAt: 2017-06-01T17:16:51.811Z,\r\n  updatedAt: 2017-06-02T17:16:51.000Z }\r\n```\r\nThe object brings personOrganizations empty, even though there are records associated in the person_organization table. The problem starts when I try to persist the Organization. It updates organization and tries to set organization_id in all the associated personOrganization records as null. Which generates a constraint error.\r\n\r\nIf I delete from the object the atribute personOrganization then it works properly:\r\n```\r\n    repository\r\n      .findOneById(params.id)\r\n      .then((organization: Organization) => {\r\n        delete organization.personOrganizations;\r\n        return repository.persist(merge(organization, body));\r\n      });\r\n```\r\nBut how can I do this in the correct way?",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/744/comments",
    "author": "brunosiqueira",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-08-10T12:00:47Z",
        "body": "```ts\r\n  personOrganizations: PersonOrganization[] = [];\r\n```\r\n\r\nremove initialization (`= [];`) from your model. Since after you load your model and it has intialized property orm thinks you removed all items from your relation and removes them."
      },
      {
        "user": "avermeulen",
        "created_at": "2017-08-12T10:24:33Z",
        "body": "This is quirky! I ran into the same problem. I will stop initializing collections in Entity Class. It's clearly not something one should be doing. I was very happy to find this post though!"
      },
      {
        "user": "pleerock",
        "created_at": "2017-08-12T19:28:17Z",
        "body": "Yeah its quirky and I would like to avoid such behaviour, but there is no other way I came up at the moment."
      }
    ]
  },
  {
    "number": 717,
    "title": "[Question] Subscriber Events using QueryBuilder Update",
    "created_at": "2017-07-28T14:10:38Z",
    "closed_at": "2018-03-12T08:16:00Z",
    "labels": [
      "question",
      "comp: subscribers and listeners"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/717",
    "body": "Hi,\r\n\r\nWondering if it is expected functionality for a subscriber, such as ``afterUpdate`` to be triggered on a Repository ``.save()`` method, but not to be triggered on a QueryBuilder ``.update()`` method?\r\n\r\nThanks!",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/717/comments",
    "author": "MitchellCorish",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-07-28T14:14:06Z",
        "body": "Yes. There are LOT OF THINGS HAPPENING in `save` method. \r\nQueryBuilder's `.update()` method is simple - it just updates entity within a single sql query. We can't afford same overhead as we do in `save` method."
      },
      {
        "user": "MitchellCorish",
        "created_at": "2017-07-28T14:29:57Z",
        "body": "Okay, thanks for the info.\r\n\r\n I am needing to use the ```afterUpdate``` subscriber, so I will need to use ```.save()```.\r\n\r\nIs there anything I can use in the ```SaveOptions``` to allow ```where``` clauses and such, as I am using this for an update API endpoint, and it seems ```save()``` by default if there is nothing matching what is in the table, it will create a new one, and I only want it to update one or many records depending on the parameters passed in, and not create any new ones.\r\n\r\nThanks again."
      },
      {
        "user": "pleerock",
        "created_at": "2017-07-28T16:07:26Z",
        "body": "no there is no way to update by some property using `save` method. `save` method simply updates a single model. I suggest you to call manually methods you call in your subscribers for such specific use cases."
      },
      {
        "user": "MitchellCorish",
        "created_at": "2017-07-28T16:13:41Z",
        "body": "Do you think the ```.update()``` method work from Repository any better than the .```save()``` method in my case?"
      },
      {
        "user": "pleerock",
        "created_at": "2017-07-28T19:27:36Z",
        "body": "I don't know your case. `update` within query builder should be used if you want to:\r\n\r\n* make update based on special where statement\r\n* make bulk update\r\n* make it the fastest way\r\n\r\nI assume you are using update within query builder because you want to achieve one or more of those three goals. Because otherwise you can use simply `save` method"
      },
      {
        "user": "MitchellCorish",
        "created_at": "2017-07-28T19:34:03Z",
        "body": "Okay, thanks for the help.\r\n\r\nWould there ever by any consideration into adding subscribers to querybuilder methods so that could also utilize those methods?"
      },
      {
        "user": "pleerock",
        "created_at": "2017-07-28T20:14:26Z",
        "body": "I'll think about it."
      },
      {
        "user": "pleerock",
        "created_at": "2018-03-12T08:16:00Z",
        "body": "Closing as this is already implemented in `@next`."
      }
    ]
  },
  {
    "number": 709,
    "title": "[Bug] Invalid ColumnSchema max length checking",
    "created_at": "2017-07-27T05:49:43Z",
    "closed_at": "2017-07-27T11:06:46Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/709",
    "body": "In migration, creating table by `queryRunner.createTable`, `type: 'varchar', length: 5000,` causes an Error, showing max row size is 65535.\r\n\r\nThe sql `typeorm` outputed\r\n\r\n```\r\nCREATE TABLE `doctor` (\r\n\t`id` INT (11) NOT NULL PRIMARY KEY AUTO_INCREMENT,\r\n\t`referralDiseaseRange` varchar (5000)',\r\n) ENGINE = INNODB\r\n```\r\n\r\nThe error\r\n\r\n```\r\nError: ER_TOO_BIG_ROWSIZE: Row size too large. The maximum row size for the used table type, not counting BLOBs, is 65535. This includes storage overhead, check the manual. You have to chan\r\nge some columns to TEXT or BLOBs\r\n    at Query.Sequence._packetToError (E:\\work\\crawler\\spider\\node_modules\\mysql\\lib\\protocol\\sequences\\Sequence.js:52:14)\r\n    at Query.ErrorPacket (E:\\work\\crawler\\spider\\node_modules\\mysql\\lib\\protocol\\sequences\\Query.js:77:18)\r\n    at Protocol._parsePacket (E:\\work\\crawler\\spider\\node_modules\\mysql\\lib\\protocol\\Protocol.js:280:23)\r\n    at Parser.write (E:\\work\\crawler\\spider\\node_modules\\mysql\\lib\\protocol\\Parser.js:76:12)\r\n    at Protocol.write (E:\\work\\crawler\\spider\\node_modules\\mysql\\lib\\protocol\\Protocol.js:39:16)\r\n    at Socket.<anonymous> (E:\\work\\crawler\\spider\\node_modules\\mysql\\lib\\Connection.js:103:28)\r\n    at emitOne (events.js:115:13)\r\n    at Socket.emit (events.js:210:7)\r\n    at addChunk (_stream_readable.js:252:12)\r\n    at readableAddChunk (_stream_readable.js:239:11)\r\n    --------------------\r\n    at Protocol._enqueue (E:\\work\\crawler\\spider\\node_modules\\mysql\\lib\\protocol\\Protocol.js:141:48)\r\n    at PoolConnection.query (E:\\work\\crawler\\spider\\node_modules\\mysql\\lib\\Connection.js:208:25)\r\n    at MysqlQueryRunner.<anonymous> (E:\\work\\crawler\\spider\\node_modules\\typeorm\\driver\\mysql\\MysqlQueryRunner.js:180:44)\r\n    at step (E:\\work\\crawler\\spider\\node_modules\\typeorm\\driver\\mysql\\MysqlQueryRunner.js:32:23)\r\n    at Object.next (E:\\work\\crawler\\spider\\node_modules\\typeorm\\driver\\mysql\\MysqlQueryRunner.js:13:53)\r\n    at fulfilled (E:\\work\\crawler\\spider\\node_modules\\typeorm\\driver\\mysql\\MysqlQueryRunner.js:4:58)\r\n    at <anonymous>\r\n    at process._tickCallback (internal/process/next_tick.js:169:7)\r\n```",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/709/comments",
    "author": "dinfer",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-07-27T09:24:49Z",
        "body": "It does not check length. Length is checked by your database, and as you can see it did that and showed you an error"
      }
    ]
  },
  {
    "number": 702,
    "title": "TYPEORM will support Oracle Database with oracledb",
    "created_at": "2017-07-25T11:01:46Z",
    "closed_at": "2017-09-08T15:50:15Z",
    "labels": [
      "question",
      "needs more info"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/702",
    "body": "Hi TYPEORM Team,\r\n\r\nwhile am working with Oracle Database getting below error.  installed npm install oracledb --save and it's available under node_modules and also \\node_modules\\typeorm\\driver\\oracle.\r\n\r\nUnhandledPromiseRejectionWarning: Unhandled promise rejection (rejection id: 2): DriverPackageNotInstalledError: Oracle package has not been found installed.\r\n\r\n\r\nBut whereas it's work for me MySQL.\r\n\r\nPlease give me the solution any steps to be install / included.",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/702/comments",
    "author": "kotapatikk",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-07-25T11:25:06Z",
        "body": "Check if oracle was REALLY installed. Try to remove node modules and reinstall everything again. If nothing works for you - simply try to do `require(\"oracledb\")` in your code and check if it works."
      },
      {
        "user": "kotapatikk",
        "created_at": "2017-07-25T13:50:38Z",
        "body": "thanks peelrock\r\n\r\nAgain same issue facing all the times."
      },
      {
        "user": "pleerock",
        "created_at": "2017-07-25T14:01:52Z",
        "body": "make sure you have installed oracle without errors. Plus as I told try to do require(\"oracledb\") in your code and check if it works.\r\n\r\n\r\n"
      },
      {
        "user": "rajancherma",
        "created_at": "2018-01-07T12:51:33Z",
        "body": "Hello pleerock,\r\nI have been facing similar connectivity issues as mentioned in the issue opened. Meanwhile, it is also being claimed in some online community that typeorm-oracle connectivity and DB operations like loading, inserting are experimental.\r\n\r\nAnd, upon searching for various sources on the Internet for a sample project which uses Oracle DB connectivity, I couldn't find any. \r\n\r\nIt'd be helpful if you can provide a github link to a sample working project(if any exists already!)  which uses Oracle DB instead of mysql with at least two DB operations like select, insert, update.  It'll also provide an assurance or a green signal that it is safe to proceed using typeorm for Oracle DB. \r\n\r\nThanks. "
      },
      {
        "user": "pleerock",
        "created_at": "2018-01-07T19:18:58Z",
        "body": "@rajancherma oracle is supported, but not completely, there are several issues not yet fixed in the latest version. We already have some progress on resolving those issues and we are planning to release complete oracle support with all issues fixed in next 0.2.0 version (planned for release probably end of feb, beginning of march)."
      }
    ]
  },
  {
    "number": 700,
    "title": "Creating a relation with a join table",
    "created_at": "2017-07-24T19:36:32Z",
    "closed_at": "2017-07-24T21:32:47Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/700",
    "body": "Hey, This is a great project. Really well done.\r\n\r\nI have a  a many to many relationship between two entities (ex: `Vendor` and `Material`) which creates a join table. I have a separate entity `Quote` that I would like to relate to the join table of the previous relationship. How would I go about achieving that?\r\n\r\nThanks",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/700/comments",
    "author": "BrainMaestro",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-07-24T20:35:44Z",
        "body": "instead of using `@ManyToMany` relation you create a new entity called like `VendorMaterialQuote` with proper many-to-one/one-to-many relations inside to `Vendor`, `Material` and `Quote`. Its not possible to add something to the table generated by `@ManyToMany` decorator - because it is used only to generate basic relationship. If you need something more you just create your own entity with proper relations."
      },
      {
        "user": "BrainMaestro",
        "created_at": "2017-07-24T21:32:47Z",
        "body": "Alright, I guess that works. Thanks!"
      }
    ]
  },
  {
    "number": 698,
    "title": "Raw query with json columns (Postgres)",
    "created_at": "2017-07-23T22:45:26Z",
    "closed_at": "2017-07-26T10:01:42Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/698",
    "body": "Folks, I am trying to build a query like this\r\n\r\n  ```\r\n  let query = `SELECT \"incident\".* FROM \"incident\" \"incident\"  \r\n     WHERE incidents::jsonb @> '[{\"name\":$1}]' ORDER BY \"incident\".\"id\" ASC`;\r\n\r\n    const results: any = await repository.query(query, ['Briga']);\r\n```\r\nI want to add the value of the json as a parameter, but I am getting an error\r\n\r\n`error during executing query:error: invalid input syntax for type json\r\n`\r\n\r\nThe final query I want is this one:\r\n```\r\nSELECT \"incident\".* \r\nFROM \"incident\" \"incident\" WHERE incidents::jsonb @> '[{\"name\":\"briga\"}]' \r\nORDER BY \"incident\".\"id\" ASC\r\n```\r\n\r\nI searched in the documentation how to parametrize queries with json fields but could not find anything. Could you help me?",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/698/comments",
    "author": "brunosiqueira",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-07-25T07:51:34Z",
        "body": "`repository.query` calls underlying `pg` package's query method and uses its parameters syntax. Refer to `pg` package how to resolve your problem. But in my opinion you should do: \r\n`incidents::jsonb @> $1` and set to parameter the whole json."
      },
      {
        "user": "brunosiqueira",
        "created_at": "2017-07-25T16:26:29Z",
        "body": "Perfect, @pleerock! It worked!"
      },
      {
        "user": "ghost",
        "created_at": "2020-11-17T20:49:36Z",
        "body": "@pleerock @brunosiqueira This saved me! It was hard to find an example similar to this one. Thank you."
      }
    ]
  },
  {
    "number": 681,
    "title": "Working with Entities (In Subscribers?)",
    "created_at": "2017-07-18T20:02:02Z",
    "closed_at": "2017-07-21T14:32:29Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/681",
    "body": "Hello, \r\n\r\nI'd like to be able to work with an Entity that is sent to my server, whether the full object is sent, or only part of it. \r\n\r\ni.e.\r\nSay we have two tables, `Meal`, and `MealHistory`. If someone ordered a meal, it is in the `Meal` table, when it is complete it gets moved to the `MealHistory` table.\r\n\r\nThe full meal object is ` { id: int, name: string, quantity: int, complete: boolean }`\r\nWhich belongs to the Meal table, the `MealHistory` table has the exact same structure.\r\n\r\nWhen a meal is completed, it is moved to the `MealHistory` table.\r\nI want to be able to move the Meal object by only passing the PK, and complete field like:\r\n`{ id: 1, complete: true }`\r\n\r\nHowever, to do this, we need to pass the whole object to add the complete record into `MealHistory`, additionally, I am not able to remove the original record from the `Meal` table.\r\n\r\nMy questions are\r\n1. How can I get the whole object at this point? \r\n2. How can I remove the original object after it has been saved in history?\r\n\r\nRight now I am trying to get around this with subscribers.\r\nI am on alpha 31.\r\n\r\nThanks",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/681/comments",
    "author": "DaveMacNeil",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-07-19T07:12:50Z",
        "body": "Please provide a minimal code sample with what you have, what you are doing to resolve your issue and what you want it to be"
      },
      {
        "user": "DaveMacNeil",
        "created_at": "2017-07-19T13:29:09Z",
        "body": "OK, So I found out that I can access the whole entity object using `event.databaseEntity`. in the afterUpdate subscriber.\r\n\r\nSo, to copy over I can do\r\n```\r\nafterUpdate(event: UpdateEvent <Meal>) {\r\n    ...\r\n    mealHistory = new MealHistory();\r\n    mealHistory.id = event.databaseEntity.id; \r\n    mealHistory.name = event.databaseEntity.name;\r\n    mealHistory.quantity = event.databaseEntity.quantity;\r\n    mealHistory.complete = event.databaseEntity.complete;\r\n\r\n    mealHistoryRepo.save(mealHistory);\r\n}\r\n```\r\n\r\nBut then, since the meal is complete and I have it moved to history, I don't want the meal to be in the non-history table anymore. However, trying to add `mealRepo.remove(event.databaseEntity)`, or creating a new Meal object and calling remove on it `mealRepo.remove(meal)`, or trying to work on removing the original entity from an `afterInsert` subscriber in `MealHistory` fails, all with the same error.\r\n\r\nThe error is: \r\n```\r\nquery failed: SELECT \"subject\".\"id\" AS \"subject_id\", \"subject\".\"name\" AS \"subject_name\", \r\n\"subject\".\"quantity\" AS \"subject_quantity\", \"subject\".\"complete\" AS \"subject_complete\" \r\nFROM \"Meal\" WHERE \"subject\".\"id\"=@0 -- PARAMETERS [1]\r\n{ \r\n    RequestError: Timeout: Request failed to complete in 1500ms \r\n    ... \r\n}\r\n```\r\n\r\nIt seems like this is failing because the record is still locked, and it won't allow the original record to be removed, even in the `afterInsert` of `MealHistory`. Am I doing this wrong? Or how should I approach this? "
      },
      {
        "user": "DaveMacNeil",
        "created_at": "2017-07-19T19:03:13Z",
        "body": "OK the issue is solved. To fix it, had to await the connection, and not the removal. It will also not work if both are awaited. \r\n\r\ni.e.\r\n```\r\nasync afterUpdate(event: UpdateEvent <Meal>) {\r\n    ...\r\n    const mealRepo = await getEntityManager().getRepository(Meal);\r\n    ...\r\n    mealRepo.remove(event.databaseEntity);\r\n}\r\n```"
      },
      {
        "user": "DaveMacNeil",
        "created_at": "2017-07-20T17:36:59Z",
        "body": "So I found out what is really happening here, or at least what is happening for MSSQL.\r\n\r\nIn a subscriber event, you can `insert`, `remove`, and `select`, on a different table.\r\nIf, however, you are working with the table that the subscriber is listening to, you can only `insert`, and `remove`. Selection is not working and is causing a timeout error.\r\n\r\nSay we have entities in our database of:\r\n\r\n```\r\nMeal, Dog\r\n```\r\n\r\nNow we have a MealSubscriber\r\n```\r\n@EventSubscriber()\r\nexport class MealSubscriber implements EntitySubsciberInterface < Meal > {\r\n    listenTo() {\r\n        return Meal;\r\n    }\r\n\r\n    async afterUpdate(event: UpdateEvent < Meal >) {\r\n        if (event.databaseEntity.complete) {\r\n            const mealRepo = await getEntityManager().getRepository(Meal);\r\n            const dogRepo = await getEntityManager().getRepository(Dog);\r\n\r\n            const meal = new Meal();\r\n            meal.name= 'Ratatouille';\r\n            meal.complete = false;\r\n\r\n            // This works\r\n            await mealRepo.save(meal);\r\n\r\n            // This also works\r\n            mealRepo.remove(meal);\r\n\r\n            // This does not work\r\n            const results = await mealRepo.createQueryBuilder('Meal')\r\n                                                               .where('complete = 1')\r\n                                                               .getMany();\r\n            // This works\r\n            const dogResults = await dogRepo.createQueryBuilder('Dog')\r\n                                                              .where('id > 1')\r\n                                                              .getMany();\r\n        }\r\n    }\r\n}\r\n```"
      },
      {
        "user": "pleerock",
        "created_at": "2017-07-21T09:45:40Z",
        "body": "again you forgot to await `remove` in your code. Please don't forget to await your promises or you'll end up creating lot of issues in this repo, I don't have a time to answer them each time.\r\n\r\nBut your problem here is different. If you want to perform database operations use `event.manager` and only it to do that. Don't use `getEntityManager()` or `getRepository()` or any other global function.\r\n\r\nThis is due to a transaction. Save is running in a transaction and your data is saved in a transaction which is not committed yet. But global functions you use are running out of transaction."
      },
      {
        "user": "DaveMacNeil",
        "created_at": "2017-07-21T12:45:46Z",
        "body": "Thanks for the information.\r\n\r\nAlso, since we should use `event.manager`, how do you save to another table using it? Sorry for asking so many questions, but I'm not finding the info!"
      },
      {
        "user": "pleerock",
        "created_at": "2017-07-22T06:52:05Z",
        "body": "event.manager is `EntityManager` which has all method to access any table, or even get a repository for entity you need, e.g. `event.manager.getRepository(Post)`"
      }
    ]
  },
  {
    "number": 679,
    "title": "Question on update query",
    "created_at": "2017-07-18T02:38:31Z",
    "closed_at": "2017-07-28T07:47:40Z",
    "labels": [
      "invalid",
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/679",
    "body": "May be this has to do with my understanding of Javascript. Still let me ask.\r\n\r\n```\r\nconst siteDetails = {name:\"hello\", type:1};\r\n\r\nconst result = await dbConnection\r\n      .getRepository(Site)\r\n      .createQueryBuilder(\"site\")\r\n      .update(siteDetails)\r\n      .where(\"site.id = :siteId and site.owner = :ownerId\", { siteId, ownerId: userId })\r\n      .execute();\r\n```\r\n\r\nThis raises the following error:\r\n\r\n```\r\nCannot perform update query because update values are not defined. Call \"qb.set(...)\" method to specify inserted values.\r\n```\r\nHowever, if I do \r\n\r\n```\r\nconst result = await dbConnection\r\n      .getRepository(Site)\r\n      .createQueryBuilder(\"site\")\r\n      .update({name:\"hello\", type:1})\r\n      .where(\"site.id = :siteId and site.owner = :ownerId\", { siteId, ownerId: userId })\r\n      .execute();\r\n```\r\n\r\nit works. How do I pass update values in a variable?",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/679/comments",
    "author": "jjude",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-07-18T07:29:49Z",
        "body": "no, its the same. I don't know what problem you have but this code is identical, please recheck everything once again."
      },
      {
        "user": "pleerock",
        "created_at": "2017-07-25T07:48:57Z",
        "body": "any updates?"
      },
      {
        "user": "peterhoneder",
        "created_at": "2018-06-18T08:08:49Z",
        "body": "just one note where just this error can come along: the object passed in to set() or something similar in query builder to set the attributes to be updated in update or inserted in insert needs to be instanceof Object. In my case graphql objects returned from apollo server where not instanceof Object, which makes passing them directly on to TypeORM fail (you can Object.assign them e.g. to solve it).\r\n\r\nThis easily happens if you have something like this:\r\nconst {a,b} = params;\r\nwhere params is instanceOf Object, but the resulting a and b are not."
      },
      {
        "user": "intsco",
        "created_at": "2018-08-29T14:45:32Z",
        "body": "In my case, the object I was trying to pass to the query builder didn't have a prototype.\r\nI solved the issue the following way\r\n```\r\nconst group = await connection.createQueryBuilder()\r\n        .update(GroupModel)\r\n        //.set(groupDetails)\r\n        .set({...groupDetails})\r\n        .where('id = :id', { id: groupId })\r\n        .execute();\r\n```"
      }
    ]
  },
  {
    "number": 677,
    "title": "Identity Map",
    "created_at": "2017-07-17T06:53:48Z",
    "closed_at": "2017-07-25T07:48:23Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/677",
    "body": "Hello!\r\n\r\nThe TypeORM is not utilizing the **identity map** pattern, often found in enterprise ORMs. Could you please share the reasoning behind this design decision or exact problems you've faced when trying to implement it?\r\n\r\nRight now, this approach makes event-driven decoupled systems very difficult to implement, because different parts of application is not aware of entities already fetched and modified (but not yet persisted) in other parts of application, and there is no guarantees about order of events. Does it mean, that TypeORM is not suitable for such decoupled code, or are you planning to address this issue in the future somehow?\r\n\r\nThank you!",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/677/comments",
    "author": "slavafomin",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-07-17T08:36:52Z",
        "body": "I don't see any relation between identity map and decoupling. I don't know how you design `event-driven decoupled systems` but when you say `different parts of application is not aware of entities` it already smells like different part of application are coupled on shared state of entities. But they shouldn't be, right? They must use events instead of sharing state.\r\n\r\nI don't see identity map as good fit in TypeORM. TypeORM has its own way and have some difference with other ORMs. Plus TypeORM uses different environment and language - JavaScript which is more functional then Java, PHP and others. \r\n\r\nThe fact they use identity map does not necessary mean its better, sometimes they force to use such patterns because of platform specifics/limitations they have.\r\n\r\nIdentity map has its own pros and cons and at the moment I don't think TypeORM needs it. If I introduce it in TypeORM there will be lot of new unpleasant problems we'll need to design, implement and fix. There are few problems it will solve as well however."
      }
    ]
  },
  {
    "number": 676,
    "title": "Junction tables not generated for ManyToMany relation.",
    "created_at": "2017-07-16T22:21:01Z",
    "closed_at": "2017-07-18T20:39:59Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/676",
    "body": "Hi there,\r\n\r\nI have a rather simple many to many relationship in my project, some properties have been removed for brevity:\r\n\r\n```\r\n@Entity()\r\nexport class Item {\r\n\r\n    @PrimaryGeneratedColumn()\r\n    public id: number;\r\n    \r\n    @JoinColumn()\r\n    @ManyToMany(type => Location, location => location.items)\r\n    public locations: Location[];\r\n}\r\n```\r\nand\r\n```\r\n@Entity()\r\nexport class Location {\r\n\r\n    @PrimaryGeneratedColumn()\r\n    public id: number;\r\n\r\n    @Column({ length: 128 })\r\n    public name: string;\r\n    \r\n    @JoinColumn()\r\n    @ManyToMany(type => Item, item => item.locations, { \r\n        cascadeInsert: true,\r\n        cascadeUpdate: true\r\n    })\r\n    public items: Item[];\r\n}\r\n```\r\nUnfortunately no junction table is being generated, it seems the properties in question are simply being ignored as the SQL debug output shows.\r\n\r\n```\r\nexecuting query: START TRANSACTION\r\nexecuting query: CREATE TABLE `location` (`id` int(11) NOT NULL PRIMARY KEY AUTO_INCREMENT, `name` varchar(128) NOT NULL, `updated_at` datetime(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6), `created_at` datetime(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6)) ENGINE=InnoDB\r\nexecuting query: CREATE TABLE `item` (`id` int(11) NOT NULL PRIMARY KEY AUTO_INCREMENT, `name` varchar(128) NOT NULL, `description` varchar(512) NOT NULL, `price` int(11) NOT NULL, `updated_at` datetime(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6), `created_at` datetime(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6)) ENGINE=InnoDB\r\nexecuting query: CREATE TABLE `tag` (`id` int(11) NOT NULL PRIMARY KEY AUTO_INCREMENT, `name` varchar(255) NOT NULL, `updated_at` datetime(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6), `created_at` datetime(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6)) ENGINE=InnoDB\r\nexecuting query: COMMIT\r\n```\r\n\r\nPlatform: Windows 10\r\nDatabase: MariaDB\r\nVersion: typeorm@0.1.0-alpha.31\r\n\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/676/comments",
    "author": "crystalbyte",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-07-17T08:38:10Z",
        "body": "for many-to-many you should use `@JoinTable` instead of `@JoinColumn` - and only on one side (owner side), e.g.:\r\n\r\n```ts\r\n@Entity()\r\nexport class Location {\r\n\r\n    @PrimaryGeneratedColumn()\r\n    public id: number;\r\n\r\n    @Column({ length: 128 })\r\n    public name: string;\r\n    \r\n    @ManyToMany(type => Item, item => item.locations, { \r\n        cascadeInsert: true,\r\n        cascadeUpdate: true\r\n    })\r\n    @JoinTable()\r\n    public items: Item[];\r\n}\r\n```"
      },
      {
        "user": "crystalbyte",
        "created_at": "2017-07-18T20:39:59Z",
        "body": "Thanks for pointing me to the right direction, the junction table is now being generated."
      },
      {
        "user": "raghav196",
        "created_at": "2019-06-14T09:37:16Z",
        "body": "@pleerock \r\n\r\nI'm also facing this issue of junction table not getting generated for ManyToMay relation. And I'm using `@JoinTable()` decorator.\r\n```typescript\r\nimport { Entity, PrimaryGeneratedColumn, Column, CreateDateColumn, UpdateDateColumn, ManyToMany, JoinTable } from 'typeorm';\r\nimport { Role } from '../role/role.entity';\r\n\r\n@Entity('users')\r\nexport class User {\r\n  @PrimaryGeneratedColumn()\r\n  id: number;\r\n\r\n  @Column({ type: 'uuid' })\r\n  remoteId: string;\r\n\r\n  @Column({ type: 'varchar', length: 255, nullable: false })\r\n  name: string;\r\n\r\n  @Column({ type: 'varchar', length: 3, nullable: false })\r\n  countryCode: string;\r\n\r\n  @Column({ type: 'varchar', length: 15, nullable: false })\r\n  phone: string;\r\n\r\n  @Column({ type: 'varchar', length: 255, nullable: false })\r\n  email: string;\r\n\r\n  @CreateDateColumn({ type: 'timestamptz' })\r\n  createdAt: Date;\r\n\r\n  @UpdateDateColumn({ type: 'timestamptz' })\r\n  updatedAt: Date;\r\n\r\n  @ManyToMany(type => Role, role => role.users, {\r\n    eager: true,\r\n    nullable: false\r\n  })\r\n  @JoinTable()\r\n  roles: Role[]\r\n}\r\n```\r\n\r\nand \r\n\r\n```typescript\r\nimport { Entity, PrimaryGeneratedColumn, Column, CreateDateColumn, UpdateDateColumn, ManyToMany, JoinTable } from 'typeorm';\r\nimport { User } from '../user/user.entity';\r\n\r\n@Entity('roles')\r\nexport class Role {\r\n  @PrimaryGeneratedColumn({ type: 'integer' })\r\n  id: number;\r\n\r\n  @Column({ type: 'integer' })\r\n  remoteId: number;\r\n\r\n  @Column({ type: 'varchar' })\r\n  role: string;\r\n\r\n  @CreateDateColumn({ type: 'timestamptz' })\r\n  createdAt: Date;\r\n\r\n  @UpdateDateColumn({ type: 'timestamptz' })\r\n  updatedAt: Date;\r\n\r\n  @ManyToMany(type => User, user => user.roles)\r\n  users: User[]\r\n\r\n}\r\n```\r\nI'm using **postgres**.\r\n\r\nI'm unable to figure out what can be the issue."
      }
    ]
  },
  {
    "number": 675,
    "title": "Changing the selector for joined data.",
    "created_at": "2017-07-16T20:32:15Z",
    "closed_at": "2017-07-28T07:48:01Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/675",
    "body": "Hi there,\r\n\r\ngiven the query\r\n\r\n```\r\nlet location = await context.locations\r\n            .createQueryBuilder(\"location\")\r\n            .whereInIds([locId])\r\n            .innerJoinAndSelect(\"location.items\", \"items\")\r\n            .getOne();\r\n```\r\n\r\nIs it possible to limit the columns to be retrieved by the inner join? \r\nThe example above fetches all columns from the items table, I would like to only get the name and id.",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/675/comments",
    "author": "crystalbyte",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-07-17T13:15:37Z",
        "body": "There is partial selection support but its limited at the moment. Try to do it this way:\r\n\r\n```ts\r\nlet location = await context.locations\r\n            .createQueryBuilder(\"location\")\r\n            .select(\"location\")\r\n            .addSelect(\"items.id\")\r\n            .addSelect(\"items.name\")\r\n            .whereInIds([locId])\r\n            .innerJoin(\"location.items\", \"items\") // no selection, just join\r\n            .getOne();\r\n```"
      },
      {
        "user": "crystalbyte",
        "created_at": "2017-07-17T21:11:52Z",
        "body": "Thank you, I will try your solution and report back :)"
      }
    ]
  },
  {
    "number": 662,
    "title": "Updating an entity without selecting beforehand.",
    "created_at": "2017-07-13T20:56:07Z",
    "closed_at": "2017-07-14T07:20:19Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/662",
    "body": "Hi there,\r\n\r\nis there a way to update an entity without fetching it beforehand?\r\n\r\nRegards",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/662/comments",
    "author": "crystalbyte",
    "comments": [
      {
        "user": "yonilerner",
        "created_at": "2017-07-14T00:51:43Z",
        "body": "Just instantiate an instance of the model class and make sure it has a primary key, and then persist it.\r\n\r\nExample:\r\n```javascript\r\n@Entity()\r\nclass Person {\r\n  @PrimaryGeneratedColumn()\r\n  id: number\r\n\r\n  @Column()\r\n  name: string\r\n}\r\n\r\nconst person = new Person()\r\nperson.id = 1\r\nperson.name = 'Yoni'\r\nawait entityManager.getRepository(Person).persist(person) // value is essentially upserted\r\n"
      },
      {
        "user": "crystalbyte",
        "created_at": "2017-07-14T07:20:19Z",
        "body": "Beautiful, thank you :)"
      },
      {
        "user": "pleerock",
        "created_at": "2017-07-14T08:21:22Z",
        "body": "note you shall use `save` instead of `persist` method because `persist` is deprecated in latest versions."
      },
      {
        "user": "crystalbyte",
        "created_at": "2017-07-16T20:25:51Z",
        "body": "Thanks for the update."
      },
      {
        "user": "aseerkt",
        "created_at": "2021-12-13T02:42:10Z",
        "body": "I want to increment the value of column `comment_count` without fetching it beforehand. Is it possible? @pleerock \r\n```ts\r\nawait Post.update({ id: postId }, { commentCount:  { /* How to deal with this section */ } } );\r\n```"
      }
    ]
  },
  {
    "number": 646,
    "title": "Problem with migrations execution and transactions",
    "created_at": "2017-07-10T16:01:59Z",
    "closed_at": "2017-08-01T18:58:20Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/646",
    "body": "Hello!\r\n\r\nI have a migration which first executes SQL-queries from a file and then creates and persists couple of entities. When I execute these two operations separately, it works correctly. But when I'm trying to do this in one go, I'm getting an error.\r\n\r\nPlease consider the code below:\r\n\r\n```typescript\r\nexport class Migration1493717870000 implements MigrationInterface {\r\n\r\n  public async up (queryRunner: QueryRunner, connection: Connection): Promise<any> {\r\n\r\n    await MigrationHelper.executeSqlFile(__dirname + '/up.pgsql', queryRunner);\r\n\r\n    const product = new Product();\r\n    product.title = 'Some Nice Product';\r\n    await connection.entityManager.persist(product);\r\n\r\n  }\r\n\r\n}\r\n```\r\n\r\n```typescript\r\nexport class MigrationHelper {\r\n  public static async executeSqlFile (filePath: string, queryRunner: QueryRunner): Promise<void> {\r\n    const sql = await this.readFile(filePath);\r\n    await queryRunner.query(sql);\r\n  }\r\n}\r\n```\r\n\r\nThe error is this: `relation \"products\" does not exist`.\r\n\r\nMy guess is that two different transactions are used for these two operations. I've tried to introduce some manual transaction management, but it's not working either. When I'm trying to do `queryRunner.beginTransaction()`, I'm getting an error: `Transaction already started for the given connection, commit current transaction before starting a new one.`. However, when I try to do `queryRunner.commitTransaction()`, I'm getting `Transaction is not started yet, start transaction before committing or rolling it back.`, which is kinda controversial.\r\n\r\nI think the correct solution would be to use the same transaction, that is created for migration initially, however, how do I use it with `connection.entityManager`?\r\n\r\nThank you!",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/646/comments",
    "author": "slavafomin",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-07-25T11:17:00Z",
        "body": "Migration is wrapped into transaction already, you should not create any new transactions. Your problem is that you are using `connection.entityManager`. You you should not use it. Instead `up` provides you `entityManager` that you must use instead (its a different instance of EntityManager used special for current query runner) \r\n\r\n```ts\r\nasync up (queryRunner: QueryRunner, connection: Connection, entityManager: EntityManager): Promise<any> \r\n```\r\n\r\nNote that in latest (0.1.0-alpha.33) signature of `up` has changed and now is:\r\n\r\n```ts\r\nasync up (queryRunner: QueryRunner): Promise<any> \r\n```\r\n\r\nand connection and *isolated entity manager* can be accessed via:\r\n\r\n```ts\r\nqueryRunner.connection\r\nqueryRunner.manager\r\n```\r\n"
      },
      {
        "user": "slavafomin",
        "created_at": "2017-07-25T11:35:05Z",
        "body": "I see, thanks!"
      },
      {
        "user": "slavafomin",
        "created_at": "2017-07-26T00:26:20Z",
        "body": "I've refactored my code to look like this:\r\n\r\n```typescript\r\npublic async up (queryRunner: QueryRunner): Promise<any> {\r\n  await queryRunner.query(`CREATE TABLE users …`);\r\n\r\n  const user = new User();\r\n  await queryRunner.connection.manager.save(user);\r\n\r\n}\r\n```\r\n\r\nBut I'm getting the same error: `error: relation \"users\" does not exist`.\r\n\r\nI'm using `typeorm@^0.1.0-alpha.32`.\r\n\r\nAlso, there is no `queryRunner.manager` property (at least in version `32`)."
      },
      {
        "user": "slavafomin",
        "created_at": "2017-07-26T00:32:20Z",
        "body": "And here's the minimum sample you can use to reproduce the issue:\r\n\r\n```typescript\r\npublic async up (queryRunner: QueryRunner): Promise<any> {\r\n\r\n  // Both works OK.\r\n  await queryRunner.query('CREATE TABLE apples (id SERIAL, variety TEXT)');\r\n  await queryRunner.query('INSERT INTO apples (variety) VALUES (\\'Braeburn\\')');\r\n\r\n  // Throws: error: relation \"apples\" does not exist\r\n  await queryRunner.connection.query('INSERT INTO apples (variety) VALUES (\\'Cortland\\')');\r\n\r\n}\r\n```"
      },
      {
        "user": "pleerock",
        "created_at": "2017-07-26T09:21:39Z",
        "body": "again DONT use `connection.manager`. I'll release `0.1.0-alpha.33` later this week, it has `queryRunner.manager`"
      },
      {
        "user": "llwt",
        "created_at": "2017-08-01T15:38:43Z",
        "body": "Can confirm updating to `alpha.33` and using `queryRunner.manager` fixes the issue! "
      },
      {
        "user": "pleerock",
        "created_at": "2017-08-01T18:58:20Z",
        "body": "@llwt thank you for confirmation. I think this issue can be closed now"
      }
    ]
  },
  {
    "number": 642,
    "title": "Data type \"boolean\" is not supported in \"mysql\" database.",
    "created_at": "2017-07-10T09:59:36Z",
    "closed_at": "2017-07-12T06:17:31Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/642",
    "body": "typeorm `0.1.0-alpha.28` is giving now error `Data type \"boolean\" is not supported in \"mysql\" database.` if using boolean datatype. Running with sqlite this works fine. \r\n\r\nThis used to work with 0.0.11. I suppose I could fallback to tinyint as solution for now.",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/642/comments",
    "author": "jounii",
    "comments": [
      {
        "user": "hugoserrana",
        "created_at": "2017-07-10T10:47:59Z",
        "body": "@jounii The MySql does not have internal BOOLEAN data type. Types like BOOLEAN and BOOL are TINYINT(1) internally. \r\n\r\nIn Changelog the TypeOrm team wrote this:\r\n> some column types were removed. Now orm uses directly column types of underlying database\r\n\r\nI think they made the right decision because the types are mapped explicitly. I imagine this will reduce errors in maintaining this awesome library."
      },
      {
        "user": "pleerock",
        "created_at": "2017-07-10T13:56:26Z",
        "body": "@jounii if you define column type explicitly then you must use `tinyint` because explicitly defined types are now only database-supported types as @hugoserrana said. \r\n\r\nBut if you variable is `boolean` you can simply omit type definition and it will be converted to tinyint automatically, e.g. for `@Column() enabled: boolean` you don't need to specify type - its automatically mapped to tinyint."
      },
      {
        "user": "jounii",
        "created_at": "2017-07-10T14:24:39Z",
        "body": "Mysql does have alias for BOOLEAN and BOOL to mapped to TINYINT. If you logic is right, shouldn't the sqlite implementation driver also rule tinyint and others out too? Sqlite uses internally only \"integer\" type and aliases rest.\r\n\r\nHave to try if the boolean entity member is properly mapped if I don't specify the types manually. "
      },
      {
        "user": "jounii",
        "created_at": "2017-07-12T05:57:35Z",
        "body": "Works ok without defining the type. Problem solved for now, thanks. \r\n\r\nRelated to this is if the tinyint (and others specific data size types) go out of fashion, the Column options would need some sort of data length/type hinting options so the driver could choose best suiting internal type.\r\n\r\nMaybe possibility to define data type converter class/function so you could customise these yourself. I suppose I could override the DriverFactory to provide own wrapper driver, but it'll be exercise for later. "
      },
      {
        "user": "feather-jmalone",
        "created_at": "2017-08-25T00:02:48Z",
        "body": "maybe i'm missing something, but in `0.1.0-alpha.34` and `0.1.0-alpha.35`, i'm unable to work around the issue as recommended. i tried the following in my entity definition:\r\n\r\n`@Column({\r\n        nullable: false,\r\n        default: false\r\n    })\r\n    someFlag: boolean;`\r\n\r\nand also \r\n\r\n`@Column()\r\n    someFlag: boolean;`\r\n\r\nboth result in the following exception: `TypeORM connection error:  { DataTypeNotSupportedError: Data type \"\" is not supported in \"mysql\" database.`\r\n\r\ndid something change?\r\n\r\ni can't get the column working unless i specify `'tinyint'` as the first parameter for `@Column`. consequently, values come back as `1` or `0` instead of `true` or `false`. "
      },
      {
        "user": "pleerock",
        "created_at": "2017-08-25T16:11:21Z",
        "body": "Looks like it cannot figure out parameter type. Parameter type is automatically determined only if you setup reflect-metadata properly and setup tsconfig properly. Read more about them on a homepage"
      },
      {
        "user": "feather-jmalone",
        "created_at": "2017-08-25T21:06:42Z",
        "body": "ah, you're right. i did not have `reflect-metadata`. however, when i added `import \"reflect-metadata\"` to my main `app.ts` file as the docs suggested, i still got the error. adding the same line to the entity `.ts` file is what ultimately fixed the issue.\r\n\r\nthanks for the help!"
      },
      {
        "user": "pleerock",
        "created_at": "2017-08-26T06:09:33Z",
        "body": "reflect-metadata should be loaded before any your entity is loaded. Probably you have loaded entities before your imported reflect-metadata in your app.ts "
      },
      {
        "user": "feather-jmalone",
        "created_at": "2017-08-26T07:06:26Z",
        "body": "i don't think so, but i am still new to TypeScript and TypeORM. here's an abbreviated version of my `app.ts` (took out Express-related code in the `createConnection` callback), does anything seem strange to you?\r\n\r\n```\r\nimport {createConnection} from 'typeorm';\r\nimport \"reflect-metadata\";\r\n\r\n// Establish the database connection before doing anything else\r\ncreateConnection({\r\n    type: 'mysql',\r\n    host: process.env.DB_HOST,\r\n    port: process.env.DB_PORT,\r\n    username: process.env.DB_USER,\r\n    password: process.env.DB_PASS,\r\n    database: process.env.DB_NAME,\r\n    entities: [\r\n        __dirname + '/entity/*.js'\r\n    ],\r\n    autoSchemaSync: true\r\n}).then(connection => {\r\n\r\n    // Initialize Express and other things\r\n\r\n// Log database connection errors\r\n}).catch(error => \r\n{\r\n    console.log('TypeORM connection error: ', error)\r\n});\r\n```\r\nthanks again for your help. although my particular issue is solved, i wanna help with future documentation if this is in fact a scenario that's unaccounted for."
      },
      {
        "user": "pleerock",
        "created_at": "2017-08-26T17:46:26Z",
        "body": "its not an unaccounted scenario, Im sure its something on your side. You can create a demo git repo with problem reproduction and I'll take why its happening on you"
      }
    ]
  },
  {
    "number": 635,
    "title": "Specifying relations to support legacy database",
    "created_at": "2017-07-09T17:40:09Z",
    "closed_at": "2017-07-10T17:23:03Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/635",
    "body": "Hi,\r\n\r\nI'm rewriting data-related part of an older application which was created for non-SPA environment with dynamic pages (MVC app with some AJAX parts) approach. I chose to rewrite API with TS & Node.js because of decorators and all the things that make code easily readable. However, I wanted to reconstruct database with entities in typeorm, so in case that application is bootstrapped from zero (without existing DB), the database doesn't need any script to be run in order to initialize it. Database which I'm using is MySQL. To achieve that I need to retain the whole structure of fields in tables, but there must be also defined some foreign keys and other things which are needed to preserve relations. I already rewrote current tables into entities, but the part with relations seems a bit impossible to do for me at the moment. I tried to use `@ManyToOne` decorator for defining foreign key in one table, but I always get another field in table which doesn't have correct name. Here is the example:\r\n\r\nWe have two entities - User and Post. User can create zero or more posts, but post is always created by a single user. So we should have the following two tables:\r\n\r\n- user - user_id (PK), name, username, password, email\r\n- post - post_id (PK), title, content, publish_date, user_id (FK)\r\n\r\nSo we would specify both models as:\r\n```\r\n@Entity()\r\nexport class User {\r\n\r\n  @PrimaryGeneratedColumn()\r\n  user_id: number;\r\n\r\n  @Column({ length: 255 })\r\n  name: string;\r\n\r\n  @Column({ length: 20, unique: true })\r\n  @Index()\r\n  username: string;\r\n\r\n  @Column({ length: 128 })\r\n  password: string;\r\n\r\n  @Column({ length: 255, unique: true })\r\n  email: string;\r\n\r\n}\r\n```\r\n\r\n```\r\n@Entity()\r\nexport class Post {\r\n\r\n  @PrimaryGeneratedColumn()\r\n  post_id: number;\r\n\r\n  @Column({ length: 255 })\r\n  @Index()\r\n  title: string;\r\n\r\n  @Column(\"text\")\r\n  content: string;\r\n\r\n  @Column(\"date\")\r\n  publish_date: Date;\r\n\r\n  @Column(\"int\")\r\n  user_id: number;\r\n\r\n}\r\n```\r\n\r\nAs stated above, I need to retain user_id in Post entity to support the existing state of database entries. I tried to add `@ManyToOne` decorator to Post's user_id as ...\r\n\r\n```\r\n@Column(\"int\")\r\n@ManyToOne(() => User)\r\nuser_id: number;\r\n```\r\n\r\nBut that didn't work well, because then I got the following structure of table:\r\n\r\n- post - post_id (PK), title, content, publish_date, user_id, **userUserId (FK)**\r\n\r\nSo the problem here is that the foreign key is always being inserted at the end of table and has specific naming strategy which isn't ok in my case. So my question here it is - do I have to handle my case manually and run database init script in case of a new environment, or I am missing something and there actually is a way to support such cases?\r\n\r\nAny answer/recommendation will be highly appreciated. Thanks in advance!",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/635/comments",
    "author": "truewt",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-07-10T07:16:44Z",
        "body": "relations should always be objects. To specify a custom referenced column name try this apporach:\r\n\r\n```ts\r\n@ManyToOne(() => User)\r\n@JoinColumn({ name: \"user_id\" })\r\nuser: User;\r\n```"
      },
      {
        "user": "truewt",
        "created_at": "2017-07-10T16:24:55Z",
        "body": "Thanks, it worked. I have additional questions about `@ManyToOne` and `@JoinColumn`. I changed parameters of decorators to:\r\n```\r\n@ManyToOne(() => User, { nullable: false, lazy: true })\r\n@JoinColumn({ name: \"user_id\" })\r\nuser: User;\r\n```\r\nI added `nullable: false` because each post must have user_id (cannot not be null) and `lazy: true`. If I understand correctly, this lazy is not executed until object (actually promise) returned in results is not awaited?\r\n\r\nDo I have to specify `referencedName` in `@JoinColumn` if it's same as `name`?\r\nI got additional question, looking at the User object in Post. What's the correct way to insert Post then - do I have to do another lookup for user before I'm assigning it to Post, or can I just create new User and assign it ID I already know (example below)?\r\n```\r\nlet user = new User();\r\nuser.user_id = 5; // actual value retrieved from token/session\r\n// or do I have to run find on User table to get the whole object back with all properties?\r\n// user = await userRepository.findOne(user);\r\n\r\nlet post = new Post();\r\npost.title = \"Testing Post\";\r\npost.content = \"Testing Content\";\r\npost.publish_date = new Date();\r\npost.user = user;\r\n\r\nawait postRepository.persist(post);\r\n```\r\nThank you in advance!"
      },
      {
        "user": "pleerock",
        "created_at": "2017-07-10T17:10:49Z",
        "body": "> If I understand correctly, this lazy is not executed until object (actually promise) returned in results is not awaited?\r\n\r\nright\r\n\r\n> Do I have to specify referencedName in @JoinColumn if it's same as name?\r\n\r\nyou specify `referencedName` only if you need it. If you don't it by default referenced to entity primary keys.\r\n\r\n> and assign it ID I already know\r\n\r\nyes you can update by simply assign an id"
      },
      {
        "user": "truewt",
        "created_at": "2017-07-10T17:23:03Z",
        "body": "Thanks! :)"
      }
    ]
  },
  {
    "number": 631,
    "title": "join not working in case of findOptions",
    "created_at": "2017-07-09T11:34:50Z",
    "closed_at": "2017-07-25T13:43:14Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/631",
    "body": "\"typeorm\": \"0.1.0-alpha.31\",\r\n\r\nI tried writing join query using entity manager and query builder. It works fine using query builder but  the related table data is not loaded when using findOptions.\r\n\r\nQuerBuilder: `claims` array added to the `roles`\r\n```javascript\r\nconst [roles, count] = await this.roleRepository.createQueryBuilder(\"role\")\r\n            .where(\"role.tenantId = tenantId\", { tenantId: ctx.state.user.tenantId })\r\n            .leftJoinAndSelect(\"role.claims\", \"claims\")\r\n            .offset(offset)\r\n            .limit(limit)\r\n            .getManyAndCount();\r\n```\r\nFindOptions: `claims` array **not** added to the `roles`\r\n```javascript\r\nconst [roles, count] = await this.roleRepository.findAndCount({\r\n            where: { tenantId: ctx.state.user.tenantId },\r\n            alias: \"role\",\r\n            leftJoinAndSelect: {\r\n                \"claims\": \"role.claims\"\r\n            },\r\n            limit: limit,\r\n            offset: offset\r\n        });\r\n```\r\n\r\nFollowing are the entities:\r\n\r\n```javascript\r\n@Entity()\r\nexport class Role extends BaseTenantEntity{\r\n\r\n    @Column({ nullable: false })\r\n    name: string;\r\n\r\n    @Column({ nullable: false })\r\n    description: string;\r\n\r\n    @ManyToMany(type => User, user => user.roles, {\r\n        cascadeInsert: true,\r\n        cascadeUpdate: true\r\n    })\r\n    users: User[]; \r\n    @OneToMany(type => RoleClaim, roleClaim => roleClaim.role, {\r\n        cascadeInsert: true,\r\n        cascadeUpdate: true\r\n    })\r\n    claims: RoleClaim[];\r\n}\r\n\r\n@Entity()\r\nexport class RoleClaim extends BaseEntity {\r\n\r\n    @Column({ nullable: false })\r\n    claimType: string;\r\n\r\n    @Column({ nullable: false })\r\n    claimValue: string;\r\n\r\n    @ManyToOne(type => Role, role => role.claims, {\r\n        cascadeInsert: true,\r\n        cascadeUpdate: true,\r\n        cascadeRemove: true\r\n    })\r\n    role: Role;\r\n}\r\n```",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/631/comments",
    "author": "adnan-kamili",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-07-10T07:21:39Z",
        "body": "In latest versions `FindOptions` syntax has changed. Use joins this way:\r\n\r\n```ts\r\nconst posts = await connection.manager.find(Post, {\r\n                join: {\r\n                    alias: \"post\",\r\n                    innerJoinAndSelect: {\r\n                        category: \"post.category\"\r\n                    }\r\n                },\r\n                order: {\r\n                    category: \"ASC\"\r\n                }\r\n            });\r\n```"
      },
      {
        "user": "adnan-kamili",
        "created_at": "2017-07-10T08:05:56Z",
        "body": "Thanks a lot, it worked now. It wasted my lot of time. \r\n\r\nPlease update the docs. And thanks for creating this amazing ORM. "
      },
      {
        "user": "pleerock",
        "created_at": "2017-07-10T14:01:00Z",
        "body": "> Please update the docs.\r\n\r\nplease feel free to contribute"
      }
    ]
  },
  {
    "number": 606,
    "title": "should I use the alpha branch?",
    "created_at": "2017-07-02T23:58:15Z",
    "closed_at": "2017-07-04T05:47:56Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/606",
    "body": "sort of a weird question, but you guys seem well into 0.1 development at this point. If I am using typeorm for the first time today, should I use stable or master?\r\n\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/606/comments",
    "author": "mbriggs",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-07-03T06:03:28Z",
        "body": "`master`. There are some features broken in 0.1.0 (like class/single table inheritance, cascades), but they were not properly worked in 0.0.x too. In other ways 0.1.0 is better because there are tons of new features and bugfixes already."
      }
    ]
  },
  {
    "number": 593,
    "title": "ManyToMany Mysql database only stores one row",
    "created_at": "2017-06-28T12:16:51Z",
    "closed_at": "2017-06-29T11:14:00Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/593",
    "body": "Hello. I have 2 files, Playlist.ts and Song.ts\r\n\r\n```import {Entity, PrimaryGeneratedColumn, Column, ManyToMany, JoinTable} from \"typeorm\";\r\nimport {Song} from \"./Song\";\r\n@Entity()\r\nexport class Playlist {\r\n\r\n    @PrimaryGeneratedColumn()\r\n    id: number;\r\n\r\n    @Column()\r\n    name: string;\r\n\r\n    @Column()\r\n    users: string;\r\n\r\n    @ManyToMany(type => Song, song => song.playlists, { \r\n        cascadeInsert: true,\r\n        cascadeUpdate: true,\r\n    })\r\n    @JoinTable()\r\n    songs: Song[] =[];\r\n```\r\n\r\n\r\n```import {Entity, Column, PrimaryGeneratedColumn, ManyToMany} from \"typeorm\";\r\nimport {Playlist} from \"./Playlist\";\r\n\r\n@Entity()\r\nexport class Song {\r\n\r\n    @PrimaryGeneratedColumn()\r\n    id: number;\r\n\r\n    @Column()\r\n    name: string;\r\n\r\n    @Column()\r\n    mainArtist: string;\r\n\r\n    @Column()\r\n    allArtists: string;\r\n\r\n    @Column()\r\n    thumbnailURL: string;\r\n\r\n    @ManyToMany(type => Playlist, playlist => playlist.songs, {\r\n        cascadeInsert: true,\r\n        cascadeUpdate: true\r\n    })\r\n    playlists: Playlist[] = [];\r\n}\r\n```\r\n\r\nThen I run this snippet.\r\n\r\n```\r\n var db = req.app.locals.db;\r\n    var params = req.params;\r\n    let newSong = new Song();\r\n      newSong.mainArtist = \"Drake\";\r\n      newSong.allArtists = \"Drake\";\r\n      newSong.name = \"Signs\"\r\n      newSong.thumbnailURL = \"random_url\";\r\n      \r\n    let playlist = await db\r\n    .getRepository(Playlist)\r\n    .findOneById(1);\r\n\r\n    newSong.playlists.push(playlist);\r\n    let songRepository = db.getRepository(Song)\r\n    .save(newSong)\r\n    .then(song => console.log(\"Song has been saved\"))\r\n    .catch(error => console.log(\"Cannot save. Error: \", error));\r\n```\r\n\r\nThe mysql joined table is `playlist_songs_song_playlists`, but there is only one row at a time. It always just adds the latest one. It is like it is overwriting the table. Any ideas why this is happening? I would appreciate the help!\r\n\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/593/comments",
    "author": "AAAstorga",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-06-28T12:52:50Z",
        "body": "try to remove intitialization from all your relations, e.g. `songs: Song[] =[];` replace to `songs: Song[];` and assign array manually when you write value. You have such problem because you are loading object without loading its elements and when you save it again with empty array ORM thinks you removed all items from your relation and removes them from the database."
      },
      {
        "user": "AAAstorga",
        "created_at": "2017-06-29T11:14:00Z",
        "body": "That seemed to do it! Thank you so much."
      }
    ]
  },
  {
    "number": 591,
    "title": "Is this production ready?",
    "created_at": "2017-06-28T08:03:52Z",
    "closed_at": "2017-06-30T09:37:33Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/591",
    "body": "Just want to ask the author @pleerock this. Are you confident with this project to be used in production? and aside from you do you know others that use this project on production?\r\n\r\nI love this project and it is great. Just want to know directly from you, a sort of assurance that this project will be maintained longer and somehow if not completely that I can rely on this project I know there will be bugs I know that.\r\n\r\nI'm planning to use this on big projects for corporate and startups.",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/591/comments",
    "author": "tontonskie",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-06-28T12:50:29Z",
        "body": "> Are you confident with this project to be used in production?\r\n\r\nit really depends on what kind of \"production\" is it and what kind of team working in this production. For example personally I use it on production in a very HUGE project. I use it there because I know that anytime my team is able to do version updates easily (bugfixes, new features, etc.) and my team is writing a very clean code and they are using typeorm properly, thats why all processes are easy in our production.\r\n\r\n>  want to know directly from you, a sort of assurance that this project will be maintained longer\r\n\r\nI spent almost two years of my life on this project, I don't know how many hours it is, but this time cost me probably hundreds of thousands dollars. I won't stop.\r\n\r\n> I know there will be bugs I know that\r\n\r\nyeah, there will be bugs. Some of them critical and will be fixed quickly. There are prioritable bugs and not prioritable. If you faced not prioritable bugs you will have to wait, because there are lot of things to be done. Some of bugs require lot of redesign and refactor and it takes time. Bugs exist always in any complex software. And typeorm is a very complex software. Thats a price of its features.\r\n\r\n> I'm planning to use this on big projects for corporate and startups.\r\n\r\nThis decision is up to you, personally I would use it in any project, especially in startups because nodejs together with typescript do a good job in startups, especially in lean startups. And all my tools (including typeorm) are great if you do lean and productive development."
      },
      {
        "user": "tontonskie",
        "created_at": "2017-06-28T12:58:27Z",
        "body": "@pleerock thanks for the time in attending my concern and I appreciate it. I'm going to use this on startups and plan to contribute also but I'm going to start first with integrating it with a framework.\r\n\r\nAgain thanks and keep it up."
      },
      {
        "user": "dcworldwide",
        "created_at": "2017-06-29T00:36:58Z",
        "body": "In case it helps, my company is using typeorm and postgres in a production system for ~6 months now.  It's been very solid. Typeorm's use of decorators and strongly typed apis has kept our code simple and robust. \r\n\r\nAs typeorm is a growing project, we've deliberately kept things simple. We use transactions, query builder, table CRUD abstractions, migrations and auto-schema sync (this is a killer feature). We've held off on using relations for now as a personal preference largely because we want to keep things simple. \r\n"
      },
      {
        "user": "avin-kavish",
        "created_at": "2020-02-12T13:48:31Z",
        "body": "@dcworldwide you don't use relations in a relational database using an object-relational mapper?"
      }
    ]
  },
  {
    "number": 583,
    "title": "Export relations from models",
    "created_at": "2017-06-26T22:25:36Z",
    "closed_at": "2017-06-27T12:10:06Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/583",
    "body": "Can I get list of relations of models? \r\nI want to write library for automated building REST API over this relations, for example, as in LoopBack framework.",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/583/comments",
    "author": "oneassasin",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-06-27T09:24:06Z",
        "body": "you can do that using internal api, example:\r\n\r\n```ts\r\nconst postMetadata = connection.getMetadata(Post);\r\npostMetadata.relations.forEach(relation => {\r\n     // here you have relation with lot of properties inside, debug to figure out which of them you need\r\n});\r\n```"
      }
    ]
  },
  {
    "number": 581,
    "title": "QueryBuilder Update seems to generate incorrect SQL statement for MSSQL",
    "created_at": "2017-06-26T20:51:16Z",
    "closed_at": "2017-06-29T16:29:11Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/581",
    "body": "QueryBuilder's update() seems to generate:\r\n\r\nUPDATE Table1 Alias SET Column1=\"Value1\" ...\r\n\r\nWhereas I think MSSQL only accepts:\r\n\r\nUPDATE Alias SET Column1=\"Value1\" FROM Table1 Alias ...\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/581/comments",
    "author": "tjme",
    "comments": [
      {
        "user": "tjme",
        "created_at": "2017-06-26T22:07:54Z",
        "body": "A work-around seems to be to add .from(\"Table1\",\"\")"
      },
      {
        "user": "pleerock",
        "created_at": "2017-06-27T10:49:41Z",
        "body": "Since `0.1.0-alpha.20` proper way of doing that:\r\n\r\n```ts\r\n        await connection.createQueryBuilder()\r\n            .update(User)\r\n            .set({\r\n                name: \"Dima Zotov\"\r\n            })\r\n            .where(\"name = :name\", { name: \"Alex Messer\" })\r\n            .execute();\r\n```\r\n\r\nor\r\n\r\n```ts\r\nawait connection.getRepository(User)\r\n            .createQueryBuilder(\"user\")\r\n            .update()\r\n            .set({ name: \"Dima Zotov\" })\r\n            .where(\"user.name = :name\", { name: \"Alex Messer\" })\r\n            .execute();\r\n```"
      },
      {
        "user": "tjme",
        "created_at": "2017-06-29T16:29:11Z",
        "body": "Many thanks! I got the second option working, using alpha.22, but it does currently report type error:\r\n\"Supplied parameters do not match any signature of call target\"."
      }
    ]
  },
  {
    "number": 580,
    "title": "OneToMany with where clause?",
    "created_at": "2017-06-26T20:01:54Z",
    "closed_at": "2017-06-30T17:23:41Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/580",
    "body": "So I have two entities that are relevant for this. They are `Organization` and `Group`\r\n\r\n```\r\n@Entity()\r\nexport class Organization extends EntityModel {\r\n    @PrimaryGeneratedColumn()\r\n    id: number;\r\n\r\n    @Column()\r\n    name: string;\r\n\r\n    @OneToMany(type => Group, group => group.organization, { cascadeInsert: true, cascadeUpdate: true })\r\n    groups: Group[];\r\n}\r\n```\r\n\r\n```\r\n@Entity()\r\nexport class Group extends EntityModel {\r\n    @PrimaryGeneratedColumn()\r\n    id: number;\r\n\r\n    @Column()\r\n    name: string;\r\n\r\n    @ManyToOne(type => Group, group => group.subgroups, { cascadeUpdate: true })\r\n    @JoinColumn()\r\n    parent: Group;\r\n\r\n    @OneToMany(type => Group, group => group.parent, { cascadeInsert: true, cascadeUpdate: true })\r\n    subgroups: Group[];\r\n\r\n    @ManyToOne(type => Organization, organization => organization.groups, { cascadeUpdate: true, onDelete: \"SET NULL\" })\r\n    @JoinColumn()\r\n    organization: Organization;\r\n}\r\n```\r\n\r\nAnd this works great! But my issue here is that I am trying to do something that MAY not be supported. Let me know if I've just missed the functionality. If the functionality does not exist then I guess this is a feature request.. \r\n\r\nI have it set up so that a `Group` can contain many `Group`s and each `Group` can have a parent which is a `Group` as well. So I want all groups to have an `Organization` but an organization should only have an array of groups that have that `Organization` as their `Organization`, but **NOT** have any parent group. Does this make sense? \r\n\r\n<hr>\r\n\r\nIn other words, I have the following:\r\n\r\n`Organization`\r\n<table>\r\n<tr><th>id</th><th>name</th></tr>\r\n<tr><td>1</td><td>Org 1</td></tr>\r\n<tr><td>2</td><td>Org 2</td></tr>\r\n</table>\r\n\r\n\r\n`Group`\r\n<table>\r\n<tr><th>id</th><th>name</th><th>parentId</th><th>organizationId</th></tr>\r\n<tr><td>1</td><td>Group 1</td><td>NULL</td><td>1</td></tr>\r\n<tr><td>2</td><td>Group 2</td><td>1</td><td>1</td></tr>\r\n<tr><td>3</td><td>Group 3</td><td>NULL</td><td>2</td></tr>\r\n<tr><td>4</td><td>Group 4</td><td>NULL</td><td>2</td></tr>\r\n</table>\r\n</body>\r\n</html>\r\n\r\n<hr>\r\n\r\nWhen I execute the following:\r\n```\r\nOrganization\r\n.createQueryBuilder(\"organization\")\r\n.leftJoinAndSelect(\"organization.groups\", \"groups\")\r\n.getMany()\r\n.then(organizations => {\r\n      // Do stuff with organizations here\r\n      // organizations should contain 2 values\r\n\r\n      // organizations[0] will be \"Org 1\" \r\n      // organizations[0].group will contain \"Group 1\" and \"Group 2\" but I want it to only contain \"Group 1\"\r\n\r\n      // organizations[1] will be \"Org 2\"\r\n      // organizations[1].group will contain \"Group 3\" and \"Group 4\" as desired\r\n});\r\n```\r\n\r\nMaybe that makes more sense. :)\r\n\r\nSo how could I achieve this? Basically I need to be able to create a `where` clause on the `inverseSide` of `OneToMany`",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/580/comments",
    "author": "joshuamking",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-06-27T11:56:47Z",
        "body": "probably first you should ask yourself how to achieve that using sql. How do you do that using sql?"
      },
      {
        "user": "joshuamking",
        "created_at": "2017-06-30T16:34:13Z",
        "body": "Sorry for the late reply.. I'm still stuck on this.\r\n\r\nOkay, well I would do something like this:\r\n\r\n```\r\nSELECT *\r\nFROM organization\r\n  LEFT JOIN \"group\" ON \"group\".\"organizationId\" = organization.id\r\nWHERE organization.id = 1 AND \"parentId\" IS NULL\r\n```"
      },
      {
        "user": "joshuamking",
        "created_at": "2017-06-30T17:01:26Z",
        "body": "So I have this:\r\n\r\n```\r\nOrganization\r\n.createQueryBuilder(\"organization\")\r\n.where(\"organization.id = :id\")\r\n.setParameters({ id: 1 })\r\n.leftJoinAndSelect(\"organization.groups\", \"group\", \"group.parent is null\")\r\n.getOne()\r\n```\r\n\r\nAnd it works great. But it would be nice, and I think it makes sense to be able to specify something like that in the model. Am I wrong in this paradigm? Thanks"
      },
      {
        "user": "pleerock",
        "created_at": "2017-06-30T17:03:35Z",
        "body": "your query is correct. If you want to have this in model then simply create a method in it with the code you provided."
      },
      {
        "user": "joshuamking",
        "created_at": "2017-06-30T17:23:41Z",
        "body": "Okay well this will work then I guess. Not perfect, but manageable. Thanks"
      }
    ]
  },
  {
    "number": 578,
    "title": "Use entityManager or Repository for bulk insert ",
    "created_at": "2017-06-25T10:22:51Z",
    "closed_at": "2017-06-27T04:28:36Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/578",
    "body": "Is it better to use a transaction from `entityManager` when doing bulk insert?\r\nI notice that this one is slow when inserting hundreds of rows:\r\n \r\n````\r\nthis.ormRepository.persist(rows)\r\n````\r\nBut using  a transaction feels faster:\r\n\r\n````\r\nawait this.entityManager.transaction(async entityManager => {\r\n        await entityManager.persist(rows)\r\n })\r\n````\r\nOr are they just the same?",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/578/comments",
    "author": "laukaichung",
    "comments": [
      {
        "user": "NoNameProvided",
        "created_at": "2017-06-25T10:36:14Z",
        "body": "> But using a transaction feels faster\r\n\r\nSome basic benchmark from you would help to backup your claim with data, without it, when @pleerock reads this, will probably ask you for it."
      },
      {
        "user": "pleerock",
        "created_at": "2017-06-27T13:05:32Z",
        "body": "If you saving a single object you should not use transaction. If you are saving multiple objects and you need transaction to make sure to revert everything is something went wrong. With your first example transaction is created for each row you are persisting thats why its slower. Its something I'll fix soon - if array of entities is passed is should use a single transaction."
      },
      {
        "user": "pawan-saxena-srijan",
        "created_at": "2019-03-26T20:04:11Z",
        "body": "@pleerock have we added it already  ? ; if not i can try to contribute."
      }
    ]
  },
  {
    "number": 577,
    "title": "Impossible to execute the Quick Start",
    "created_at": "2017-06-24T17:40:20Z",
    "closed_at": "2017-06-27T20:00:15Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/577",
    "body": "Hi everybody,\r\n\r\nI would like to test typeorm with MySQL 2.13.0 on Visual code studio. The version used is 0.1.0-alpha.19. I have copied your following example \r\n\r\n```ts\r\nimport \"reflect-metadata\";\r\nimport {createConnection} from \"typeorm\";\r\nimport {Photo} from \"./entity/Photo\";\r\n\r\ncreateConnection({\r\n    driver: {\r\n        type: \"mysql\",\r\n        host: \"localhost\",\r\n        port: 3306,\r\n        username: \"root\",\r\n        password: \"admin\",\r\n        database: \"test\"\r\n    },\r\n    entities: [\r\n        Photo\r\n    ],\r\n    autoSchemaSync: true,\r\n}).then(connection => {\r\n    // here you can start to work with your entities\r\n}).catch(error => console.log(error));\r\n```\r\nand I have the following message error \r\n\r\nfile: 'file:///d%3A/sandbox/nest-test/src/tests/orm/app.ts'\r\nseverity: 'Erreur'\r\nmessage: 'Argument of type '{ driver: { type: \"mysql\"; host: string; port: number; username: string; password: string; databa...' is not assignable to parameter of type 'ConnectionOptions'.\r\n  Type '{ driver: { type: \"mysql\"; host: string; port: number; username: string; password: string; databa...' is not assignable to type '**MongoConnectionOptions**'.\r\n    Property 'type' is missing in type '{ driver: { type: \"mysql\"; host: string; port: number; username: string; password: string; databa...'.'\r\nat: '20,18'\r\nsource: 'ts'\r\n\r\nI have try to use connectionOptions \r\n\r\nimport \"reflect-metadata\";\r\nimport {createConnection} from \"typeorm\";\r\nimport {Photo} from \"./entity/Photo\";\r\nimport {MysqlConnectionOptions} from \"../../../node_modules/typeorm/driver/mysql/MysqlConnectionOptions.js\";\r\n\r\nconst connectionOptions: MysqlConnectionOptions = {\r\n    driver: {\r\n        type: \"mysql\",\r\n        host: \"localhost\",\r\n        port: 3306,\r\n        username: \"root\",\r\n        password: \"admin\",\r\n        database: \"test\"\r\n    },\r\n    entities: [Photo],\r\n    autoSchemaSync: true\r\n};\r\n\r\nand I have the following message\r\n\r\nfile: 'file:///d%3A/sandbox/nest-test/src/tests/orm/app.ts'\r\nseverity: 'Erreur'\r\nmessage: 'Type '{ driver: { type: \"mysql\"; host: string; port: number; username: string; password: string; databa...' **is not assignable to type 'MysqlConnectionOptions**'.\r\n  Property 'type' is missing in type '{ driver: { type: \"mysql\"; host: string; port: number; username: string; password: string; databa...'.'\r\nat: '7,7'\r\nsource: 'ts'\r\n\r\nI don't understand why it is checking connectionOptions from MongoDb and not MySQL. If there is somebody who can give me an indication, I will be happy.\r\n\r\nThanks in advance.",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/577/comments",
    "author": "afontange",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-06-27T12:03:20Z",
        "body": "Can you please try to extract \"driver\" section into connection options this way:\r\n\r\n```ts\r\ncreateConnection({\r\n        type: \"mysql\",\r\n        host: \"localhost\",\r\n        port: 3306,\r\n        username: \"root\",\r\n        password: \"admin\",\r\n        database: \"test\",\r\n    entities: [\r\n        Photo\r\n    ],\r\n    autoSchemaSync: true,\r\n}).then(connection => {\r\n    // here you can start to work with your entities\r\n}).catch(error => console.log(error));\r\n```"
      },
      {
        "user": "afontange",
        "created_at": "2017-06-27T16:29:49Z",
        "body": "Thanks for your quick answer : without \"driver\" the error disappeared. I will continue to evaluate typeorm next week-end. I have another question : is there a way to define unique keys?"
      },
      {
        "user": "pleerock",
        "created_at": "2017-06-27T19:59:52Z",
        "body": "yes you can create `@Index({ unique: true })`, you can put index to class and create composite indices, or you can put in on columns. Also you can mark column as unique: `@Column({ unqiue: true })`"
      },
      {
        "user": "pleerock",
        "created_at": "2017-06-27T20:00:15Z",
        "body": "I'll close it - let me know if you will still have issues with it."
      },
      {
        "user": "JoshGlazebrook",
        "created_at": "2017-07-25T04:00:08Z",
        "body": "Is this an issue of the docs being out of date? I also ran into this.\r\n\r\nEdit: Actually it appears the alpha versions are being published under the latest tag rather than a alpha/beta tag on npm, so these alpha versions are being installed by default for everyone.\r\n\r\nIs there a reason these aren't on a special tag?"
      },
      {
        "user": "pleerock",
        "created_at": "2017-07-25T11:22:50Z",
        "body": "actually latest alpha versions overall are much more stable then 0.0.11 version, so I recommend to use it instead. Some of the docs are out of date unfortunately, I'll fix it once I get more free time (or anyone can help me ;))"
      }
    ]
  },
  {
    "number": 575,
    "title": "Why doesn't this api leftJoinAndSelect work in SQLite?",
    "created_at": "2017-06-23T14:11:27Z",
    "closed_at": "2017-06-30T09:44:54Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/575",
    "body": " I use the following code, but it didn't seem to be working normally.\r\n```\r\nlet query = commentRepository\r\n      .createQueryBuilder('comments')\r\n      .leftJoinAndSelect('comments.article_id', 'article')\r\n      .getMany()\r\n```\r\nexcute above code , the result is :\r\n`[{\r\n  \"id\": 1,\r\n  \"nick_name\": \"1\",\r\n  \"email\": \"1\",\r\n  \"content\": \"1\",\r\n  \"article_id\": {\r\n    \"_id\": 1,\r\n    \"title\": \"11\"\r\n  }\r\n}]`\r\nIn my opinion,  the article_id should be replaced by string-\"article\".\r\nCan you tell me why I met this problem? Thank you!",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/575/comments",
    "author": "bs32g1038",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-06-24T05:25:48Z",
        "body": "can you show me your entity? Your Comment particularly "
      },
      {
        "user": "bs32g1038",
        "created_at": "2017-06-25T00:33:25Z",
        "body": "well! I list the entity classes. @pleerock \r\n\r\n> entity/article.ts\r\n\r\n`import {\r\n    Entity,\r\n    Column,\r\n    PrimaryGeneratedColumn,\r\n    CreateDateColumn,\r\n    UpdateDateColumn,\r\n    OneToMany,\r\n    JoinColumn\r\n} from \"typeorm\";\r\nimport { Comment } from './comment';\r\n\r\n\r\n`\r\n@Entity()\r\nexport class Article {\r\n\r\n    @PrimaryGeneratedColumn()\r\n    _id: number;\r\n\r\n    @Column({\r\n        nullable: false\r\n    })\r\n    title: string;\r\n\r\n    @Column()\r\n    img_url: string;\r\n\r\n    @Column()\r\n    category: string;\r\n\r\n    @Column()\r\n    summary: string;\r\n\r\n    @Column(\"text\")\r\n    content: string;\r\n\r\n    @Column({\r\n        default: 0\r\n    })\r\n    visit_count: number;\r\n\r\n    @Column({\r\n        default: 0\r\n    })\r\n    comment_count: number;\r\n\r\n    @Column({\r\n        default: false\r\n    })\r\n    is_deleted: boolean;\r\n\r\n    @Column({\r\n        default: true\r\n    })\r\n    is_pushlied: boolean;\r\n\r\n    @CreateDateColumn({\r\n        nullable: true\r\n    })\r\n    create_at: Date;\r\n\r\n    @UpdateDateColumn({\r\n        nullable: true\r\n    })\r\n    update_at: Date;\r\n\r\n    @Column({\r\n        default: true\r\n    })\r\n    is_html: boolean;\r\n\r\n    @OneToMany(type => Comment, Comment => Comment.article_id)\r\n    comments: Comment[];\r\n\r\n}`\r\n\r\n\r\n> entity/comment.ts\r\n\r\n `import {\r\n    Column,\r\n    CreateDateColumn,\r\n    Entity,\r\n    JoinColumn,\r\n    OneToOne,\r\n    PrimaryGeneratedColumn\r\n} from 'typeorm';\r\nimport { Article } from './article'\r\n`\r\n`\r\n@Entity()\r\nexport class Comment {\r\n\r\n    @PrimaryGeneratedColumn()\r\n    id: number;\r\n\r\n    @Column({\r\n        nullable: false\r\n    })\r\n    nick_name: string;\r\n\r\n    @Column({\r\n        nullable: false\r\n    })\r\n    email: string;\r\n\r\n    @Column({\r\n        nullable: false\r\n    })\r\n    content: string;\r\n\r\n    @Column({\r\n        default: ''\r\n    })\r\n    reply: string;\r\n\r\n    @OneToOne(type => Article, Article => Article._id)\r\n    @JoinColumn({\r\n        name: 'article_id'\r\n    })\r\n    article_id: number;\r\n\r\n    @CreateDateColumn()\r\n    create_at: Date;\r\n\r\n    @Column({\r\n        default: true\r\n    })\r\n    pass: boolean;\r\n\r\n    @Column()\r\n    identity: number;\r\n\r\n}`\r\n\r\n> Additional \r\n\r\nthe db config code :\r\n\r\n` db: {\r\n    driver: {\r\n      type: 'sqlite',\r\n      database: path.resolve(__dirname, '../../database.sqlite'),\r\n    },\r\n    entities: [\r\n      path.resolve(__dirname, \"../entity/*.js\")\r\n    ],\r\n    autoSchemaSync: true,\r\n  }\r\n`"
      },
      {
        "user": "pleerock",
        "created_at": "2017-06-27T12:09:50Z",
        "body": "Thats not how relations are working. Relations are **objects**.\r\n\r\n```ts\r\n@OneToOne(type => Article, Article => Article._id)\r\n@JoinColumn({\r\n    name: 'article_id'\r\n})\r\narticle_id: number;\r\n```\r\n\r\nMUST BE:\r\n\r\n```ts\r\n@OneToOne(type => Article, Article => Article._id)\r\n@JoinColumn({ name: 'article_id' })\r\narticle: Article;\r\n```\r\n\r\nthen you can access its id simply: `comment.article.id`"
      },
      {
        "user": "pleerock",
        "created_at": "2017-06-30T09:44:54Z",
        "body": "Let me know if you still have questions."
      }
    ]
  },
  {
    "number": 562,
    "title": "MySQL column type: Medium/Long Text",
    "created_at": "2017-06-21T04:57:44Z",
    "closed_at": "2017-06-21T10:01:41Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/562",
    "body": "Hi, does TypeORM support Medium/Long Text column data type for MySQL, Seem it only support Text when I add column with type 'text' or 'json'.",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/562/comments",
    "author": "brookshi",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-06-21T07:44:17Z",
        "body": "what typeorm version are you using?"
      },
      {
        "user": "brookshi",
        "created_at": "2017-06-21T09:31:51Z",
        "body": "I'm using 0.0.9."
      },
      {
        "user": "pleerock",
        "created_at": "2017-06-21T09:45:55Z",
        "body": "Medium/Long Text is supported only in latest 0.1.0-alpha versions."
      },
      {
        "user": "brookshi",
        "created_at": "2017-06-21T10:00:42Z",
        "body": "Great, Thanks. "
      }
    ]
  },
  {
    "number": 544,
    "title": "groupBy() and getCount() cannot be used at the same time",
    "created_at": "2017-06-15T02:26:52Z",
    "closed_at": "2017-06-20T11:56:59Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/544",
    "body": "During my development, I found there is literally no way to count the number of kinds of data in a query with Typeorm. The getCount wiil return the fist value of groupBy(). For example, if we have 9 fruits in the db, 4 apples, 3 bananas, and 2 cherries. The getCount after groupBy will return us 4 coz we have 4 apples. Any idea?",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/544/comments",
    "author": "bobmayuze",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-06-15T17:58:47Z",
        "body": "`getCount` of `QueryBuilder` is for pagination purposes. For example if you have 1000 bananas, but your query to load bananas uses `skip`/`take` for pagination purposes which returns you only 20 bananas, you need to get know how many bananas do you have overall to create correct number of pages. Thats what `getCount` stays for. For your purposes you probably need to use regular SQL COUNT() in your queries and get raw results."
      },
      {
        "user": "pleerock",
        "created_at": "2017-06-20T09:47:16Z",
        "body": "Did I answer your question?"
      },
      {
        "user": "bobmayuze",
        "created_at": "2017-06-20T10:00:54Z",
        "body": "Thanks for answering the question, but I wonder if I can do so with typeorm. "
      },
      {
        "user": "pleerock",
        "created_at": "2017-06-20T11:56:37Z",
        "body": "> For your purposes you probably need to use regular SQL COUNT() in your queries and get raw results.\r\n\r\nyeah you simply do something like \r\n\r\n```ts\r\nconst results = await queryBuilder.select(\"COUNT(post.id) AS cnt\").getRawMany()\r\n```"
      },
      {
        "user": "bobmayuze",
        "created_at": "2017-06-21T00:51:01Z",
        "body": "Thanks for the help! Really appreciate for that"
      },
      {
        "user": "wodka",
        "created_at": "2020-02-18T19:24:45Z",
        "body": "I created a helper for myself to do the same thing:\r\n\r\n```typescript\r\nimport { SelectQueryBuilder } from 'typeorm'\r\n\r\nexport class CoreQbHelper {\r\n  public static async getRawManyAndCount<T>(qb: SelectQueryBuilder<any>, groupColumns: string[]): Promise<[number, T[]]> {\r\n    return Promise.all([\r\n      new Promise<number>((resolve, reject) => {\r\n        const cQb = qb.clone()\r\n        cQb.skip(0)\r\n        cQb.select(`COUNT(DISTINCT (${groupColumns.join(', ')})) as c`)\r\n        cQb.orderBy(null)\r\n        cQb.getRawOne()\r\n          .then(value => resolve(value.c ? Number(value.c) : 0))\r\n          .catch(e => reject(e))\r\n      }),\r\n      new Promise<T[]>((resolve, reject) => {\r\n        const vQb = qb.clone()\r\n        vQb.groupBy(groupColumns.join(', '))\r\n        vQb.getRawMany()\r\n          .then(values => resolve(values))\r\n          .catch(e => reject(e))\r\n      }),\r\n    ])\r\n  }\r\n}\r\n```\r\n\r\nAnd to use it pass the columns you are grouping to it as well like `CoreQbHelper.getRawManyAndCount(qb, ['b.type'])`"
      },
      {
        "user": "Logic-Bits",
        "created_at": "2021-02-18T07:54:16Z",
        "body": "> I created a helper for myself to do the same thing:\r\n> \r\n> ```ts\r\n> import { SelectQueryBuilder } from 'typeorm'\r\n> \r\n> export class CoreQbHelper {\r\n>   public static async getRawManyAndCount<T>(qb: SelectQueryBuilder<any>, groupColumns: string[]): Promise<[number, T[]]> {\r\n>     return Promise.all([\r\n>       new Promise<number>((resolve, reject) => {\r\n>         const cQb = qb.clone()\r\n>         cQb.skip(0)\r\n>         cQb.select(`COUNT(DISTINCT (${groupColumns.join(', ')})) as c`)\r\n>         cQb.orderBy(null)\r\n>         cQb.getRawOne()\r\n>           .then(value => resolve(value.c ? Number(value.c) : 0))\r\n>           .catch(e => reject(e))\r\n>       }),\r\n>       new Promise<T[]>((resolve, reject) => {\r\n>         const vQb = qb.clone()\r\n>         vQb.groupBy(groupColumns.join(', '))\r\n>         vQb.getRawMany()\r\n>           .then(values => resolve(values))\r\n>           .catch(e => reject(e))\r\n>       }),\r\n>     ])\r\n>   }\r\n> }\r\n> ```\r\n> \r\n> And to use it pass the columns you are grouping to it as well like `CoreQbHelper.getRawManyAndCount(qb, ['b.type'])`\r\n\r\nThanks!\r\n\r\nI just flipped number and T[] so its works just like the getManyAndCount()"
      },
      {
        "user": "choninoa",
        "created_at": "2022-03-21T03:16:59Z",
        "body": "count = await (await qb.getRawMany()).length"
      },
      {
        "user": "ernestdolog",
        "created_at": "2023-07-14T19:11:00Z",
        "body": "> count = await (await qb.getRawMany()).length\r\n\r\nunless You are paginating, and set a `first` and/or an `after`"
      }
    ]
  },
  {
    "number": 539,
    "title": "Allow manual rollback or commit of transaction",
    "created_at": "2017-06-14T01:51:23Z",
    "closed_at": "2017-06-15T18:29:45Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/539",
    "body": "",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/539/comments",
    "author": "yonilerner",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-06-14T12:23:36Z",
        "body": "Everything you wrap into transaction will be executed and in the end transaction will be commited. You can throw exception in your transaction function and rollback will be executed. Why do you need more then this? But yeah, you can do manual rollback and commit, but using more low-level api."
      },
      {
        "user": "yonilerner",
        "created_at": "2017-06-14T17:59:05Z",
        "body": "@pleerock How can I access this lower level API? I dont see any references in the documentation.\r\n\r\nThrowing exceptions of course works, but its often more cumbersome than really necessary if all I want to do is rollback a transaction based on a condition "
      },
      {
        "user": "pleerock",
        "created_at": "2017-06-15T17:55:00Z",
        "body": "as of `0.1.0-alpha.9` its possible using this syntax:\r\n\r\n```ts\r\nconst queryRunner = connection.driver.createQueryRunner(); // queryRunner is a single real connection to the database obtained from a connection pool\r\nawait queryRunner.startTransaction();\r\n// execute sql queries using queryRunner\r\nawait queryRunner.commitTransaction(); // or .rollbackTransaction()\r\nawait queryRunner.release(); // don't forget to release connection, very important!\r\n```\r\n\r\nExecute any sql operations using queryRunner. USE ONLY this queryRunner to execute queries, don't use entity managers, repositories because they are running queries on their own query runners. In the case you want to use managers/repositories you need to create them using this api:\r\n\r\n```ts\r\nconst entityManager = connection.createIsolatedManager(yourQueryRunner);\r\n```\r\n\r\nor \r\n\r\n```ts\r\nconst entityRepository = connection.createIsolatedRepository(Entity, yourQueryRunner);\r\n```"
      },
      {
        "user": "yonilerner",
        "created_at": "2017-06-15T18:29:45Z",
        "body": "Great, thank you!"
      },
      {
        "user": "EVINK",
        "created_at": "2020-09-11T01:04:48Z",
        "body": "@pleerock\r\n\r\nHi, there! I am using UPDATE SQL in queryRunner.query API, and I do not commit it, but it has changed data to db later.\r\n\r\nHere is my code\r\n\r\n```ts\r\n// A request is coming, since I do not commit it , so the data in db not changes after responded\r\n// but it is changed while an another request arrived (this new request had calling \"startTransaction() \")\r\nconst queryRunner = getConnection().createQueryRunner()\r\ntry{\r\n    await queryRunner.startTransaction() \r\n    await queryRunner.connect()\r\n    await queryRunner.query('UPDATE ...')\r\n}catch(err){\r\n    return next(err)\r\n}finally{\r\n   queryRunner.release()\r\n}\r\n\r\n```\r\nHow I gonna do if I want to ensure the data not changed?\r\n\r\n"
      }
    ]
  },
  {
    "number": 529,
    "title": "Persist new object without supplying full relation",
    "created_at": "2017-06-08T22:51:46Z",
    "closed_at": "2017-06-09T23:52:08Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/529",
    "body": "My entities:\r\n```\r\n@Entity('games')\r\nclass Game {\r\n  @PrimaryColumn('uuid', { generated: true })\r\n  id: string;\r\n}\r\n\r\n@Entity('runs')\r\nclass Run {\r\n  @PrimaryColumn('uuid', { generated: true })\r\n  id: string\r\n\r\n  @RelationId((run: Run) => run.game)\r\n  gameId: string;\r\n\r\n  @ManyToOne(type => Game)\r\n  @JoinColumn({ name: 'game_id' })\r\n  game: Game;\r\n}\r\n```\r\n\r\nHow can I create and persist a new run, without supplying the full game object (I just have the ID)?\r\nRight now I have to do something like this:\r\n```\r\nconst run = new Run();\r\nrun.game = game;\r\n\r\nrepos.Runs.persist(run);\r\n```\r\nbut I would prefer being able to do something like\r\n```\r\nconst run = new Run();\r\nrun.gameId = gameId;\r\n\r\nrepos.Runs.persist(run);\r\n```\r\nThanks.",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/529/comments",
    "author": "cameronpickham",
    "comments": [
      {
        "user": "NoNameProvided",
        "created_at": "2017-06-08T23:24:16Z",
        "body": "You can write \r\n\r\n```ts\r\nconst run = new Run();\r\nrun.game = { id: gameId };\r\n\r\nrepos.Runs.persist(run);\r\n```"
      },
      {
        "user": "cameronpickham",
        "created_at": "2017-06-08T23:58:07Z",
        "body": "If Game has additional properties, TypeScript complains because `{ id: gameId }` is not the correct shape. Would you recommend doing something like `run.game = { id: gameId } as Game` or is there a different preference for this case?"
      },
      {
        "user": "pleerock",
        "created_at": "2017-06-09T05:31:35Z",
        "body": "relation id is just to `get` your relation id, it won't work if you want to save through it. You have two options, first is what @NoNameProvided suggested (to prevent casting simply do: `run.game = new Game(gameId)`, second is to define column together with relation:\r\n\r\n```ts\r\n@Entity('runs')\r\nclass Run {\r\n  @PrimaryColumn('uuid', { generated: true })\r\n  id: string\r\n\r\n  @Column({ type: \"int\", nullable: true }) // both options must be set\r\n  gameId: number;\r\n\r\n  @ManyToOne(type => Game)\r\n  @JoinColumn({ name: 'gameId' })\r\n  game: Game;\r\n}\r\n```"
      }
    ]
  },
  {
    "number": 511,
    "title": "Allow for Generics to be used to define Entities on the connection",
    "created_at": "2017-06-01T22:39:45Z",
    "closed_at": "2017-06-09T09:06:29Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/511",
    "body": "I am looking to structure my code by feature rather than tier. I want to create a folder structure that allows me to put my implementation of the database for a specific feature in the same folder with the rest of the code. To that end, I want to create a single framework file that allows me to pass in the type I want to connect to and persist and use this class generically. \r\n\r\nHere is an example of what I would like to do:\r\n\r\n```\r\nimport { createConnection } from \"typeorm\";\r\n\r\nexport class Orm {\r\n\r\n    public getConnection<T>(): Promise<Connection> {\r\n\r\n        return createConnection({\r\n            driver: {\r\n                type: \"mysql\",\r\n                host: \"localhost\",\r\n                port: 3306,\r\n                username: \"root\",\r\n                password: \"admin\",\r\n                database: \"test\"\r\n            },\r\n            entities: [ T ],\r\n            autoSchemaSync: true,\r\n        });\r\n    }\r\n}\r\n```\r\n\r\nHowever, when doing this I get the error `'T only refers to a Type, but is being used as a value here.'`. I would appreciate it if you would provide a way to pass the type the createConnection method and use the connection for only that object (or multiple types if passed).\r\n\r\nThe idea here is that I would be able to return the connection inside of a promise and use async/await syntax after receiving the connection to operate on that table or tables.\r\n\r\nThanks!",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/511/comments",
    "author": "ScottMGerstl",
    "comments": [
      {
        "user": "hugoserrana",
        "created_at": "2017-06-02T20:51:12Z",
        "body": "I think that you doesn't have to take connection always. Get all entities by path and configure typeorm only once, at start your application: \r\n\r\n```\r\n //Use options or ormconfig.json\r\n let dbOptions = {}  \r\n createConnection(dbOptions).then(connection => {\r\n            console.log('Database connected!');\r\n        }).catch(error => {\r\n            console.log(error)\r\n        });\r\n```\r\n\r\nWharever you want use a connection, use getConnectionManager  for this. TypeOrm will handle this for you. Then you may try (I don't tested this):\r\n\r\n```\r\nimport { getConnectionManager } from \"typeorm\";\r\n\r\nexport default class Orm {\r\n    private repo: any;\r\n\r\n    constructor(T) {\r\n        this.repo = getConnectionManager().get().getRepository(T);\r\n    }\r\n\r\n    public getRepo(){\r\n        return this.repo;\r\n    }\r\n}\r\n```\r\n\r\nbut, is more simplier use directly where you need it:\r\n\r\n```\r\nimport { getConnectionManager } from \"typeorm\";\r\nimpot User from './entity/User';\r\n\r\nlet repo = getConnectionManager().get().getRepository(User);\r\n\r\n//And use repo to queries etc\r\n```"
      },
      {
        "user": "pleerock",
        "created_at": "2017-06-03T05:24:23Z",
        "body": "@ScottMGerstl  I think you didn't get how generics are working. \r\n\r\n`T` is needed to implement type safety, but in your case its not used anywhere which means you don't have something to make it type safe. Also `T` is compile-time stuff, its not actual code that will be outputed anywhere, so you can do what you did.\r\n\r\nYou simply need to do:\r\n\r\n```ts\r\nexport class Orm {\r\n\r\n    public getConnection(entities: Function[]): Promise<Connection> {\r\n\r\n        return createConnection({\r\n            driver: {\r\n                type: \"mysql\",\r\n                host: \"localhost\",\r\n                port: 3306,\r\n                username: \"root\",\r\n                password: \"admin\",\r\n                database: \"test\"\r\n            },\r\n            entities: entities,\r\n            autoSchemaSync: true,\r\n        });\r\n    }\r\n}\r\n```"
      },
      {
        "user": "pleerock",
        "created_at": "2017-06-09T09:06:29Z",
        "body": "Reopen discussion if you still have questions."
      }
    ]
  },
  {
    "number": 506,
    "title": "Schema sync/drop in 0.1.0-alpha.3",
    "created_at": "2017-05-31T14:38:02Z",
    "closed_at": "2017-06-03T19:49:52Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/506",
    "body": "I've got some problems with typeorm@0.1.0-alpha.3:\r\n\r\n`typeorm schema:sync`\r\n\r\n`UnhandledPromiseRejectionWarning: Unhandled promise rejection (rejection id: 1): TypeError: this.metadataArgsStorage.filterTables is not a function`\r\n\r\nThe same issue with `schema:drop` command.\r\nnodejs: v6.10.3\r\nenv: windows 10 x64\r\nserver: PostgreSQL 9.4.11 on x86_64-unknown-linux-gnu, compiled by gcc (Debian 4.9.2-10) 4.9.2, 64-bit\"\r\n\r\nBy the way: where can i find the information about debug way for typeorm cli commands?\r\nThanks.",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/506/comments",
    "author": "rkylsyi",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-06-03T05:50:02Z",
        "body": "You have this issue because your `ormconfig.json` is not an array, ormconfig.json should contain an array of connection options, e.g.:\r\n\r\n```json\r\n[{\r\n  \"driver\": {\r\n    \"type\": \"mysql\",\r\n    \"host\": \"localhost\",\r\n    \"port\": 3306,\r\n    \"username\": \"test\",\r\n    \"password\": \"test\",\r\n    \"database\": \"test\",\r\n    \"usePool\": true,\r\n    \"extra\": {\r\n      \"timezone\": \"utc\"\r\n    }\r\n  },\r\n  \"autoSchemaSync\": true,\r\n  \"entities\": [\r\n    \"modules/**/entity/{*.ts,*.js}\"\r\n  ],\r\n  \"subscribers\": [\r\n    \"modules/**/subscriber/{*.ts,*.js}\"\r\n  ]\r\n}]\r\n```\r\n\r\n> where can i find the information about debug way for typeorm cli commands? \r\n\r\nyou debug it just the regular way you usually debug javascript"
      },
      {
        "user": "rkylsyi",
        "created_at": "2017-06-03T19:49:52Z",
        "body": "Thank you very much! "
      }
    ]
  },
  {
    "number": 503,
    "title": "Transactions wrapping tests",
    "created_at": "2017-05-29T20:16:20Z",
    "closed_at": "2017-06-17T06:43:19Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/503",
    "body": "Noob question here.\r\n\r\nAny example on how to use typeORM with mocha/ava/jest.... wrapping each test case in a transaction using async/await?\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/503/comments",
    "author": "banduk",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-06-03T05:29:11Z",
        "body": "nope there is not examples I can provide. You have to figure out those things on your own. Once typeorm go stable and all features will be finished I'll get some time to provide tools to use them in tests."
      },
      {
        "user": "pleerock",
        "created_at": "2017-06-17T06:43:19Z",
        "body": "closing this for now"
      },
      {
        "user": "greyblake",
        "created_at": "2018-08-10T09:44:35Z",
        "body": "@banduk I have the same issue. Please let us know if you find something out. "
      }
    ]
  },
  {
    "number": 500,
    "title": "@Table decorator does not exist anymore ?",
    "created_at": "2017-05-27T09:28:47Z",
    "closed_at": "2017-06-01T09:34:17Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/500",
    "body": "Hi ,\r\n@Table decorator does not exist anymore ?\r\nDavid",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/500/comments",
    "author": "ghost",
    "comments": [
      {
        "user": "dcworldwide",
        "created_at": "2017-05-31T12:47:42Z",
        "body": "It's been replaced with @entity "
      },
      {
        "user": "pleerock",
        "created_at": "2017-06-01T09:34:17Z",
        "body": "yes, please use `@Entity` decorator"
      }
    ]
  },
  {
    "number": 497,
    "title": "How to retrieve data from  the many to many relationship",
    "created_at": "2017-05-26T15:33:08Z",
    "closed_at": "2017-05-27T11:55:14Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/497",
    "body": "Hello again,\r\nI need help I have implemented the many to many relationship but problem is how to retrieve the data from it. How to join the tables.",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/497/comments",
    "author": "okYadav",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-05-27T07:22:50Z",
        "body": "Use query builder:\r\n\r\n```ts\r\nconnection.getRepository(Post)\r\n    .createQueryBuilder(\"post\")\r\n    .leftJoinAndSelect(\"post.categories\", \"category\")\r\n    .getMany();\r\n```\r\n\r\nwhere Post has many-to-many with categories."
      }
    ]
  },
  {
    "number": 461,
    "title": "Use ManyToMany decorator alongside with PrimaryGeneratedColumn",
    "created_at": "2017-05-09T12:59:05Z",
    "closed_at": "2017-05-10T13:53:33Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/461",
    "body": "Let's say I have 3 classes / tables : 'Artist', 'Artwork' and 'Tag'. \r\nArtist and Artwork both have a ManyToMany relation with Tag. What I'd like to do is the following : \r\n\r\n```\r\nclass Tag {\r\n    @PrimaryGeneratedColumn()\r\n    @ManyToMany(type => Artwork, artwork => artwork.tags)\r\n    @ManyToMany(type => Artist, artist => artist.tags)\r\n    id: number;\r\n} \r\n```\r\n\r\n```\r\nclass Artwork {\r\n    @PrimaryGeneratedColumn()\r\n    id: number;\r\n   \r\n    @ManyToMany(type => Tag, tag => tag.id, {\r\n        cascadeInsert: true\r\n    })\r\n    @JoinTable()\r\n    public tags: Tag[];\r\n  \r\n}\r\n```\r\n\r\n```\r\nclass Artist {\r\n    @PrimaryGeneratedColumn()\r\n    id: number;\r\n   \r\n    @ManyToMany(type => Tag, tag => tag.id, {\r\n        cascadeInsert: true\r\n    })\r\n    @JoinTable()\r\n    public tags: Tag[];\r\n    \r\n}\r\n```\r\n\r\nCurrently, it doesn't seem to work: tags are created but relationship between Tag and Artwork / Artist is not saved in 'join' table . How could I manage to setup such a mechanism without having to implement 2 specific Tag classes (one for each class) ? \r\n\r\nBy the way I'm using @next version of typeorm with mysql-driver.\r\n\r\nThank you and keep up the good work !\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/461/comments",
    "author": "cclaim",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-05-10T05:18:53Z",
        "body": "In second argument of relation you should provide `inverse relation`, not `id column` as you do right now:\r\n\r\n\r\n```ts\r\nclass Tag {\r\n    @PrimaryGeneratedColumn()\r\n    id: number;\r\n\r\n    @ManyToMany(type => Artwork, artwork => artwork.tags)\r\n    artworks: Artwork[];\r\n\r\n    @ManyToMany(type => Artist, artist => artist.tags)\r\n    artists: Artist[];\r\n} \r\n```\r\n\r\n```ts\r\nclass Artwork {\r\n    @PrimaryGeneratedColumn()\r\n    id: number;\r\n   \r\n    @ManyToMany(type => Tag, tag => tag.artworks, {\r\n        cascadeInsert: true\r\n    })\r\n    @JoinTable()\r\n    public tags: Tag[];\r\n  \r\n}\r\n```\r\n```ts\r\nclass Artist {\r\n    @PrimaryGeneratedColumn()\r\n    id: number;\r\n   \r\n    @ManyToMany(type => Tag, tag => tag.artists, {\r\n        cascadeInsert: true\r\n    })\r\n    @JoinTable()\r\n    public tags: Tag[];\r\n    \r\n}\r\n```"
      },
      {
        "user": "cclaim",
        "created_at": "2017-05-10T10:28:33Z",
        "body": "Thank you !"
      }
    ]
  },
  {
    "number": 450,
    "title": "Saving a relationship",
    "created_at": "2017-05-02T22:14:30Z",
    "closed_at": "2017-05-04T18:37:31Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/450",
    "body": "I'm probably just doing this wrong. I'm trying to add related object to another object through a many2many relationship.\r\n\r\nHere's my scenario:\r\n\r\nUser->hasFriends [User] (many2many)\r\nUser->hasGroups [Group] (many2many)\r\n\r\nWhen i want to add a group to a user I\r\n1) fetch the respective user\r\n2) left join the groups\r\n3) fetch my respective group\r\n4) push my group, user.addGroup(group)\r\n5) persist my user object.\r\n\r\nThis works; but deletes all friend relationships. If I add a friend to my user; all group relationships get deleted.\r\n\r\nHere are my model definitions:\r\n\r\nUser:\r\n\r\n\trequire(\"reflect-metadata\");\r\n\timport {Entity, PrimaryColumn, Column, ManyToMany, JoinTable} from \"typeorm\";\r\n\timport Group from './Group';\r\n\t\r\n\t\r\n\t@Entity()\r\n\texport default class User {\r\n\t\r\n\t    @PrimaryColumn(\"int\", { generated: true })\r\n\t    id = undefined;\r\n\t\r\n\t    @Column(\"string\")\r\n\t    email = \"\";\r\n\t\r\n\t    @Column(\"string\")\r\n\t    firstname = \"\";\r\n\t\r\n\t    @Column(\"string\")\r\n\t    lastname = \"\";    \r\n\t    \r\n\t    @Column(\"string\")\r\n\t    middlename = \"\";\r\n\t    \r\n\t    @Column(\"string\")\r\n\t    password = \"\";\r\n\t    \r\n\t    @Column(\"string\")\r\n\t    salt = \"\";\r\n\t       \r\n\t    \r\n\t    setEmail(email) {\r\n\t\t    this.email = email;\r\n\t\t    return this;\r\n\t    }\r\n\t    \r\n\t    getEmail() {\r\n\t\t    return this.email;\t    \r\n\t    }\r\n\t    \r\n\t    setFirstname(firstname) {\r\n\t\t    this.firstname = firstname;\r\n\t\t    return this;\r\n\t    }\r\n\t    \r\n\t    getFirstname() {\r\n\t\t    return this.firstname;\r\n\t    }\r\n\t    \r\n\t    setLastname(lastname) {\r\n\t\t    this.lastname = lastname;\r\n\t\t    return this;\r\n\t    }\r\n\t    \r\n\t    getLastname() {\r\n\t\t    return this.lastname;\r\n\t    }\r\n\t    \r\n\t    setMiddlename(middlename) {\r\n\t\t    this.middlename = middlename;\r\n\t\t    return this;\r\n\t    }\r\n\t    \r\n\t    getMiddlename() {\r\n\t\t    return this.middlename;\r\n\t    }\r\n\t    \r\n\t    setPassword(password) {\r\n\t\t    this.password = password;\r\n\t\t    return this;\r\n\t    }\r\n\t    \r\n\t    getPassword() {\r\n\t\t    return this.password;\r\n\t    }\r\n\t    \r\n\t    setSalt(salt) {\r\n\t\t    this.salt = salt;\r\n\t\t    return this;\r\n\t    }\r\n\t    \r\n\t    getSalt() {\r\n\t\t    return this.salt;\r\n\t    }\r\n\t    \r\n\t    addFriend(friend) {\r\n\t\t    this.friends.push(friend);\r\n\t    }\r\n\t\r\n\t    getGroups() {\r\n\t\t    return this.groups;\r\n\t    }\r\n\t    \r\n\t    addGroup(group) {\r\n\t\t    this.groups.push(group);\r\n\t    }\r\n\t    \r\n\t    getFriends() {\r\n\t\t    return this.friends;\r\n\t    }\r\n\t    \r\n\t    getFriendsInverse() {\r\n\t\t    return this.friends;\r\n\t    }\r\n\t    \r\n\t\r\n\t\t@ManyToMany(type => User, user => user.friendsInverse, {\r\n\t\t\tcascadeInsert: false,\r\n\t\t\tcascadeUpdate: false,\r\n\t\t})\r\n\t\t@JoinTable()\r\n\t\tfriends = [];\r\n\t\r\n\t\t@ManyToMany(type => User, user => user.friends, {\r\n\t\t\tcascadeInsert: true,\r\n\t\t\tcascadeUpdate: true,\r\n\t\t\tcascadeRemove: false,\r\n\t\t})\r\n\t\tfriendsInverse = [];\r\n\t\t\r\n\t\t\r\n\t    @ManyToMany(type => Group, group => group.users, {\r\n\t        cascadeInsert: true,\r\n\t        cascadeUpdate: true,\r\n\t        cascadeRemove: false\r\n\t    })\r\n\t    groups = [];\r\n\t    \r\n\t    \r\n\t}\r\n\r\n\r\nGroup:\r\n\r\n\trequire(\"reflect-metadata\");\r\n\timport {Entity, PrimaryColumn, Column, ManyToMany, JoinTable} from \"typeorm\";\r\n\timport User from './User';\r\n\t\r\n\t@Entity()\r\n\texport default class Group {\r\n\t\r\n\t    @PrimaryColumn(\"int\", { generated: true })\r\n\t    id = undefined;\r\n\t\r\n\t    @Column(\"string\")\r\n\t    title = \"\";\r\n\t\r\n\t    @Column(\"string\")\r\n\t    description = \"\";\r\n\t\r\n\t    \r\n\t    setTitle(title) {\r\n\t\t    this.title = title;\r\n\t\t    return this;\r\n\t    }\r\n\t    \r\n\t    getTitle() {\r\n\t\t    return this.title;\t    \r\n\t    }\r\n\t    \r\n\t    setDescription(description) {\r\n\t\t    this.description = description;\r\n\t\t    return this;\r\n\t    }\r\n\t    \r\n\t    getDescription() {\r\n\t\t    return this.description;\r\n\t    }\r\n\t\r\n\t\t@ManyToMany(type => User, user => user.groups, {\r\n\t\t\tcascadeInsert: true,\r\n\t        cascadeUpdate: true,\r\n\t        cascadeRemove: true\r\n\t\t})\r\n\t\t@JoinTable()\r\n\t\tusers = [];\r\n\t    \r\n\t    \r\n\t}\r\n\r\n-------\r\n\r\nIs this the expected behaviour?\r\n\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/450/comments",
    "author": "Matt007",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-05-03T04:40:44Z",
        "body": "Remove initializations from your model ` = []`. When you load object without friends and there is initialization orm thinks that you have remove all friends from your object and removes them. There is no way it can understand is it just initialized empty array or its empty because all entities were removed."
      },
      {
        "user": "Matt007",
        "created_at": "2017-05-04T16:09:19Z",
        "body": "Oh, makes sense! Thanks a lot for your help!\r\n\r\nMaybe it would help to point this out in the example. I'm sure a lot of people might run into the same issue when they copy&paste the example from the docs.\r\n"
      },
      {
        "user": "pleerock",
        "created_at": "2017-05-04T18:37:31Z",
        "body": "you are right, thanks."
      }
    ]
  },
  {
    "number": 449,
    "title": "Event subscribers not affecting abstract entities",
    "created_at": "2017-05-02T20:34:13Z",
    "closed_at": "2017-05-10T05:58:20Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/449",
    "body": "Tried to create a new abstract entity with created_at and updated_at to be automatically update on change, it's not working, only if I put the columns in the entity itself.\r\n\r\nbtw, is there any built in soft deletes?",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/449/comments",
    "author": "ghost",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-05-03T04:42:43Z",
        "body": "> btw, is there any built in soft deletes?\r\n\r\nno\r\n\r\n> Tried to create a new abstract entity with created_at and updated_at to be automatically update on change, it's not working, only if I put the columns in the entity itself.\r\n\r\nthey should work. Did you include your abstract entity in the `entities` of the configuration?"
      },
      {
        "user": "ghost",
        "created_at": "2017-05-05T18:47:32Z",
        "body": "Thanks! that was the issue,\r\nis there any why I can put global condition on each entity so I can add for example\r\n\"deleted_at\" is null?"
      },
      {
        "user": "pleerock",
        "created_at": "2017-05-10T05:58:20Z",
        "body": "no there is no such way, put your queries always if you need this."
      }
    ]
  },
  {
    "number": 427,
    "title": "delete via join",
    "created_at": "2017-04-27T23:04:37Z",
    "closed_at": "2017-04-30T00:26:51Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/427",
    "body": "Hi,\r\n\r\nI'm trying to delete via join, though with postgres join doesn't work with delete.\r\n\r\nwith this query (assuming `Account` <-> `Project` as 1:many join):\r\n\r\n```\r\nconn.getRepository(Project)\r\n  .createQueryBuilder('p')\r\n  .innerJoin('p.account = account', 'account')\r\n  .where('account.accountId = :accountId', { accountId: 'test' })\r\n  .delete();\r\n```\r\nit generates the following SQL:\r\n\r\n```\r\nDELETE FROM \"projects\" INNER JOIN \"accounts\" \"account\" ON \"account\".\"account_id\"=\"p\".\"account_id\" WHERE \"account\".\"name\" = 'test';\r\n```\r\n\r\nWhich causes postgres to throw the following error:\r\n\r\n```\r\nLINE 1: DELETE FROM \"projects\" INNER JOIN \"accounts\" \"account\" ON \"a...\r\n```\r\n\r\nIt looks like the alias `p` isn't used in the query generation, also, the way to make inner join work for postgres is via `using <alias>`, as follows:\r\n\r\n```\r\nDELETE FROM \"projects\" *USING \"projects\" AS \"p\"* INNER JOIN \"accounts\" \"account\" ON \"account\".\"account_id\"=\"p\".\"account_id\" WHERE \"account\".\"name\" = 'test';\r\n```\r\n\r\nThis can certainly be me not knowing how to use the query builder correctly. Can anyone help verify if I need a different query or if this is not implemented at this time?\r\n\r\nThanks.\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/427/comments",
    "author": "yinso",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-04-28T05:04:10Z",
        "body": "No, deletion \"via join\" is not supported. Consider object deletion manually for each your relation."
      },
      {
        "user": "yinso",
        "created_at": "2017-04-28T18:02:56Z",
        "body": "If this isn't supported, it means that I'll need to retrieve the data first before I delete them right?\r\n\r\nSomething like below?\r\n\r\n```\r\nconn.getRepository(Project)\r\n  .createQueryBuilder('p')\r\n  .innerJoin('p.account = account', 'account')\r\n  .where('account.accountId = :accountId', { accountId: 'test' })\r\n  .getMany()\r\n  .then((projects) => {\r\n    return conn.getRepository(Project).remove(projects)\r\n  })\r\n```\r\n\r\n"
      },
      {
        "user": "pleerock",
        "created_at": "2017-04-29T05:12:06Z",
        "body": "right"
      },
      {
        "user": "yinso",
        "created_at": "2017-04-30T00:26:51Z",
        "body": "k thanks."
      },
      {
        "user": "jun9358",
        "created_at": "2019-02-13T08:20:56Z",
        "body": "Please support this feature..."
      },
      {
        "user": "Ezard",
        "created_at": "2020-01-04T16:26:12Z",
        "body": "@pleerock are you open to a PR to provide this functionality?"
      },
      {
        "user": "j1i-ian",
        "created_at": "2020-03-31T02:08:22Z",
        "body": "any progress ?"
      },
      {
        "user": "joaquinaraujo",
        "created_at": "2020-07-06T17:54:33Z",
        "body": "My solution, I hope it will soon be available in TypeORM\r\n\r\n```\r\nasync delete(id, { order, customer }): Promise<OrderItem> {\r\n    const [ orderItemErr, orderItem ] = await to(\r\n      this.orderItemsRepository.createQueryBuilder('order_item')\r\n        .select([\r\n          'order_item.id',\r\n          'order_item.quantity',\r\n          'order_item.price'\r\n        ])\r\n        .innerJoin('order_item.order', 'order')\r\n        .where({ id, order })\r\n        .andWhere('order.customer = :customer', { customer })\r\n        .getOne()\r\n    )\r\n    // track: console.log(orderItemErr)\r\n\r\n    if (orderItemErr || !Boolean(orderItem)) throw new Error('item-not-found')\r\n\r\n    const [ err, deletedOrderItem ]: [ Error, DeleteResult ] = await to(this.orderItemsRepository.delete({ id: orderItem.id }))\r\n    // track: console.log(err)\r\n\r\n    if (err || !Boolean(deletedOrderItem) || !Boolean(deletedOrderItem.affected)) throw new Error()\r\n\r\n    return orderItem\r\n  }\r\n```"
      },
      {
        "user": "dfenerski",
        "created_at": "2021-03-09T10:53:20Z",
        "body": "why is this closed?"
      },
      {
        "user": "MichaelSp",
        "created_at": "2021-03-19T11:35:47Z",
        "body": "that would be actually quite useful. "
      },
      {
        "user": "TheProgrammer21",
        "created_at": "2021-07-27T11:04:25Z",
        "body": "Extremely useful.. @pleerock could you please open the issue again? "
      },
      {
        "user": "imnotjames",
        "created_at": "2021-07-27T14:30:35Z",
        "body": "This was closed by the author.\r\n\r\nShould you want this feature please open a properly formatted feature request."
      }
    ]
  },
  {
    "number": 414,
    "title": "TypeScript target:es2015 not supporting OneToOne",
    "created_at": "2017-04-21T09:57:31Z",
    "closed_at": "2017-06-17T07:58:53Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/414",
    "body": "When using tsc with target es2015, the sample for OneToOne compiles but module load fails with: ```ReferenceError: PostMetadata is not defined``` or ```ReferenceError: Post is not defined``` depending which class is first to use the OneToOne relation. Same behavior with node 7.3.0 and 6.10;\r\n\r\nIt is strange that many other entities using a network of ManyToOne and OneToMany work fine with target es2015. \r\n\r\nPlease clarify if typeorm must be used with target es5 as in the tsconfig.json on this git repo. The code bellow works fine with es5. \r\n\r\n```\r\nimport {\r\n    Entity,\r\n    PrimaryGeneratedColumn,\r\n    Column,\r\n    OneToOne,\r\n    JoinColumn\r\n} from \"typeorm\";\r\n\r\n@Entity(\"sample2_post\")\r\nexport class Post {\r\n\r\n    @PrimaryGeneratedColumn()\r\n    id: number;\r\n\r\n    @Column()\r\n    title: string;\r\n\r\n    @Column()\r\n    text: string;\r\n\r\n    @OneToOne(type => PostMetadata, metadata => metadata.post, {\r\n        cascadeRemove: true\r\n    })\r\n    @JoinColumn()\r\n    metadata: PostMetadata;\r\n}\r\n\r\n@Entity(\"sample2_post_metadata\")\r\nexport class PostMetadata {\r\n\r\n    @PrimaryGeneratedColumn()\r\n    id: number;\r\n\r\n    @Column()\r\n    description: string;\r\n\r\n    @OneToOne(type => Post, post => post.metadata)\r\n    post: Post;\r\n\r\n}\r\n```",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/414/comments",
    "author": "kbajalc",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-04-21T09:59:32Z",
        "body": "what is your node.js version?"
      },
      {
        "user": "kbajalc",
        "created_at": "2017-04-21T10:02:08Z",
        "body": "node 7.3.0 and 6.10; checked with both - same behavior\r\nproduction will be on 6.10, AWS Lambda"
      },
      {
        "user": "pleerock",
        "created_at": "2017-04-22T05:09:55Z",
        "body": "wait I see your problem now. you cant first use class, then define it. Simply extract both your classes into separate files and import dependencies."
      },
      {
        "user": "pleerock",
        "created_at": "2017-06-17T07:58:53Z",
        "body": "let me know if you still have problems with it"
      }
    ]
  },
  {
    "number": 411,
    "title": "Can typeorm create partitions in oracle?",
    "created_at": "2017-04-20T08:44:49Z",
    "closed_at": "2017-04-20T12:41:44Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/411",
    "body": "",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/411/comments",
    "author": "slowkazak",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-04-20T09:06:35Z",
        "body": "No. Oracle support is experimental in typeorm yet (there are several problems with it at the moment) and I don't recommend to use it yet."
      },
      {
        "user": "slowkazak",
        "created_at": "2017-04-20T12:41:44Z",
        "body": "oh, ok, thanx("
      }
    ]
  },
  {
    "number": 394,
    "title": "Missing mongodb driver error in postgres project",
    "created_at": "2017-04-10T18:10:31Z",
    "closed_at": "2017-06-17T08:20:43Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/394",
    "body": "I've project running typeorm 0.0.11 with postgres, when I upgrade to 0.1.0-alpha, it errs with missing mongodb driver error.",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/394/comments",
    "author": "mkatrenik",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-04-10T18:46:58Z",
        "body": "right if you want to use `next` version you have to install mongodb driver for now `npm i mongodb --save`. There are few problems needs to be solved to fix this issue."
      },
      {
        "user": "pleerock",
        "created_at": "2017-06-17T08:20:43Z",
        "body": "this is already fixed in latest alpha versions."
      }
    ]
  },
  {
    "number": 378,
    "title": " db connection error : TypeError: optionsArray.filter is not a function",
    "created_at": "2017-03-30T18:39:46Z",
    "closed_at": "2017-03-30T20:09:35Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/378",
    "body": "getting this error when starting app:\r\n\r\n> db connection error : TypeError: optionsArray.filter is not a function\r\n\r\normconfig.json:\r\n```\r\n{\r\n    \"name\": \"default\",\r\n    \"driver\":{\r\n        \"type\":\"sqlite\",\r\n        \"database\":\"test\"\r\n    },\r\n    \"entities\":[\r\n        \"data/models/*.js\"\r\n    ],\r\n    \"autoSchemaSync\":true\r\n}\r\n```\r\n\r\nstacktrace:\r\n\r\n> \"TypeError: optionsArray.filter is not a function    at ConnectionManager.<anonymous> (c:\\projects\\typeorm-test\\node_modules\\typeorm\\connection\\ConnectionManager.js:309:55)    at step (c:\\projects\\typeorm-test\\node_modules\\typeorm\\connection\\ConnectionManager.js:32:23)    at Object.f [as next] (c:\\projects\\typeorm-test\\node_modules\\typeorm\\connection\\ConnectionManager.js:13:53)    at __awaiter (c:\\projects\\typeorm-test\\node_modules\\typeorm\\connection\\ConnectionManager.js:7:71)    at __awaiter (c:\\projects\\typeorm-test\\node_modules\\typeorm\\connection\\ConnectionManager.js:3:12)    at ConnectionManager.createFromConfigAndConnect (c:\\projects\\typeorm-test\\node_modules\\typeorm\\connection\\ConnectionManager.js:303:16)    at ConnectionManager.<anonymous> (c:\\projects\\typeorm-test\\node_modules\\typeorm\\connection\\ConnectionManager.js:151:48)    at step (c:\\projects\\typeorm-test\\node_modules\\typeorm\\connection\\ConnectionManager.js:32:23)    at Object.f [as next] (c:\\projects\\typeorm-test\\node_modules\\typeorm\\connection\\ConnectionManager.js:13:53)    at __awaiter (c:\\projects\\typeorm-test\\node_modules\\typeorm\\connection\\ConnectionManager.js:7:71)\"",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/378/comments",
    "author": "nadavten",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-03-30T19:23:01Z",
        "body": "ormconfig.json should contain an array with connections. So change it to \r\n\r\n```json\r\n[\r\n{\r\n    \"name\": \"default\",\r\n    \"driver\":{\r\n        \"type\":\"sqlite\",\r\n        \"database\":\"test\"\r\n    },\r\n    \"entities\":[\r\n        \"data/models/*.js\"\r\n    ],\r\n    \"autoSchemaSync\":true\r\n}\r\n]\r\n```\r\n\r\nAnd this will fix your issue."
      }
    ]
  },
  {
    "number": 357,
    "title": "bind message supplies 1 parameters, but prepared statement \"\" requires 0",
    "created_at": "2017-03-20T12:27:56Z",
    "closed_at": "2017-03-22T13:02:51Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/357",
    "body": "Typeorm v 0.0.9\r\n\r\n```typescript\r\nawait this.connection\r\n        .getRepository(Location)\r\n        .createQueryBuilder('l')\r\n        // .where(\"l.zip ILIKE ':zip%'\", { zip }) // fails\r\n        // .where('l.zip ILIKE \\':zip%\\'', { zip }) // fails\r\n        // .where(`l.zip ILIKE ':zip%'`, { zip }) // fails\r\n        .where(`l.zip ILIKE '${zip}%'`) // works, but this is bad practice\r\n        .getMany();\r\n```\r\nError:\r\n```\r\nquery failed: SELECT \"l\".\"zip\" AS \"l_zip\" FROM \"locations\" \"l\" WHERE \"l\".\"zip\" ILIKE '$1%' -- PARAMETERS: [\"123\"]\r\nerror during executing query:error: bind message supplies 1 parameters, but prepared statement \"\" requires 0\r\n\r\n```",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/357/comments",
    "author": "valVk",
    "comments": [
      {
        "user": "valVk",
        "created_at": "2017-03-20T13:48:51Z",
        "body": "This one works.\r\n```typescript\r\nawait this.connection\r\n        .getRepository(Location)\r\n        .createQueryBuilder('l')\r\n         .where('l.zip ILIKE :zip', { zip: `${ctx.params.zip}%` })\r\n        .getMany();\r\n```\r\n\r\n@pleerock, is that expected? If so than I'll close that issue.\r\n\r\nTHanks"
      },
      {
        "user": "pleerock",
        "created_at": "2017-03-22T13:02:43Z",
        "body": "yes, its expected because `%` part of your string."
      }
    ]
  },
  {
    "number": 355,
    "title": "InnerjoinAndSelect returns undefined",
    "created_at": "2017-03-19T15:15:33Z",
    "closed_at": "2017-03-23T21:34:03Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/355",
    "body": "Hello,\r\n\r\nI have a many to one relation. Every photo has one photoCollectionId and photoCollection and every PhotoCollection has an array of Photo. Now I want to load a collection with its photos:\r\n```typescript\r\n let collection = await this.collectionRepository.findOneById(id\r\n        , {\r\n          alias: \"collection\",\r\n          innerJoinAndSelect: {\r\n            \"photos\": \"collection.photos\"\r\n          }\r\n        });\r\n```\r\nWhen there is no photo related to the collection this returns undefined. However, if there is a related photo, it works as expected. \r\n\r\nFor now I have worked around the issue like this:\r\n```typescript\r\n@Get(\"/:id/photos\")\r\n  async getOne( @Param(\"id\") id: number) {\r\n    let photo = await this.photoRepository.findOne({ photoCollectionId: id });\r\n    if (photo) {\r\n      let collection = await this.collectionRepository.findOneById(id\r\n        , {\r\n          alias: \"collection\",\r\n          innerJoinAndSelect: {\r\n            \"photos\": \"collection.photos\"\r\n          }\r\n        });\r\n      console.log(collection);\r\n      return collection;\r\n    }\r\n    else {\r\n      let collection = await this.collectionRepository.findOneById(id);\r\n      console.log(collection);\r\n      return collection;\r\n    }\r\n  }\r\n```\r\n\r\nHowever, this is probably not how it should be I suppose. Is there a better/easier way to do this?",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/355/comments",
    "author": "Christian24",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-03-22T13:06:08Z",
        "body": "can you try `QueryBuilder` instead? Using \r\n\r\n```ts\r\n{\r\n          alias: \"collection\",\r\n          innerJoinAndSelect: {\r\n            \"photos\": \"collection.photos\"\r\n          }\r\n        }\r\n``` \r\n\r\nis deprecated and will be removed in next typeorm version. Use `QueryBuilder` instead:\r\n\r\n\r\n```ts\r\nrepository.createQueryBuilder(\"collection\")\r\n     .innerJoinAndSelect(\"collection.photos\", \"photos\")\r\n     .where(\"collection.id = :id\", { id })\r\n     .getOne();\r\n```"
      },
      {
        "user": "MichalLytek",
        "created_at": "2017-03-23T18:34:31Z",
        "body": "Could you paste here you entities classes?"
      },
      {
        "user": "Christian24",
        "created_at": "2017-03-23T21:31:09Z",
        "body": "@pleerock How do I know it is deprecated? Is there any way to know?\r\n\r\nUsing QueryBuilder works like a charm. Thanks a lot. \r\n\r\n"
      },
      {
        "user": "Christian24",
        "created_at": "2017-03-23T21:34:03Z",
        "body": "@19majkel94 \r\n\r\nPhotoCollection.ts:\r\n```typescript\r\n@Entity()\r\nexport class PhotoCollection extends BaseEntity {\r\n    @OneToMany(type => Photograph, photo => photo.photoCollection)\r\n    public photos:Array<Photograph> = new Array<Photograph>();\r\n     @Column(\"string\",{nullable:true})\r\n    public title:string;\r\n     @Column()\r\n    public showPhotoTitle:boolean = false;\r\n     @Column()\r\n    public showCollectionTitle:boolean = false;\r\n     @Column(\"string\",{nullable:true})\r\n\r\n    public titlePhotoUrl:string;\r\n     @Column()\r\n    public hidden:boolean = true;\r\n    @OneToMany(type => PhotoInfoSetting, infoSetting => infoSetting.photoCollection)\r\n    public infoSettings:Array<PhotoInfoSetting> = new Array<PhotoInfoSetting>();\r\n}\r\n```\r\nPhoto.ts:\r\n```typescript\r\n@Entity()\r\nexport class Photograph extends BaseEntity {\r\n     @Column(\"int\")\r\n   public photoCollectionId:number;\r\n   @ManyToOne(type => PhotoCollection, photoCollection => photoCollection.photos)\r\n   @JoinColumn({name:\"photoCollectionId\"})\r\n   public photoCollection:PhotoCollection;\r\n   @OneToMany(type => PhotoInfo, photoInfo => photoInfo.photo)\r\n   public photoInfos:Array<PhotoInfo> = new Array<PhotoInfo>();\r\n     @Column(\"string\",{nullable:true})\r\n   public title:string;\r\n     @Column(\"string\",{nullable:true})\r\n   public source:string;\r\n     @Column(\"string\",{nullable:true})\r\n   public preview:string;\r\n    @Column()\r\n   public hidden:boolean = false;\r\n}\r\n```\r\nThose are my entities. I will be offline for a week, so please expect a delay in response. "
      }
    ]
  },
  {
    "number": 351,
    "title": "execute migrations through code",
    "created_at": "2017-03-16T15:58:39Z",
    "closed_at": "2017-03-16T19:06:48Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/351",
    "body": "Is there a way to execute migrations through my code?",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/351/comments",
    "author": "natanielkdias",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-03-16T18:10:55Z",
        "body": "you can do that using `connection.runMigrations()` method"
      },
      {
        "user": "natanielkdias",
        "created_at": "2017-03-16T18:32:24Z",
        "body": "Thank you! I'm developing  a solution on electron and sqlite. It will be so helpful to my application updates. "
      },
      {
        "user": "pleerock",
        "created_at": "2017-03-16T19:06:48Z",
        "body": "good to help 👍 "
      }
    ]
  },
  {
    "number": 303,
    "title": "Connection pooling doesn't really pool connections",
    "created_at": "2017-02-22T00:41:50Z",
    "closed_at": "2017-02-23T17:25:22Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/303",
    "body": "It looks like when you create a connection and have connection pooling on type orm creates a \"pool of 1 connection\", and then when you close the connection type orm ends the pool.  Ideally what we want to do is create a pool of 50 connections in our web api that type orm re-uses across requests.  I'm new to type orm.  Hopefully I'm just missing some way to configure this.",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/303/comments",
    "author": "swilliams-a3digital",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-02-22T06:18:15Z",
        "body": "> when you close the connection type orm ends the pool\r\n\r\nyou should not close connection in the app lifecycle. You open connection once in application bootstrap and close only when application shut downs. Connection pools are handled in a single orm connection, and when you are closing connection - you are closing pool too. If you don't close connection - pool will work as you expect."
      },
      {
        "user": "swilliams-a3digital",
        "created_at": "2017-02-22T20:36:01Z",
        "body": "Thanks for the quick reply.  If I create the \"type orm connection\" in the app bootstrap, and I have a bunch of simultaneous requests that all use the one \"type orm connection\" will there be any issues?  \r\n\r\nMy concern is:\r\nrequest A comes in, type orm does a persist and while its waiting for the promise to resolve node handles request B that uses the same type orm connection and there is some problem because the connection is in use.\r\n\r\nI'm hoping the answer is the one \"type orm\" connection will open multiple my sql db connections if it needs to do multiple things at the same time\r\n\r\n"
      },
      {
        "user": "pleerock",
        "created_at": "2017-02-23T03:19:01Z",
        "body": "> If I create the \"type orm connection\" in the app bootstrap, and I have a bunch of simultaneous requests that all use the one \"type orm connection\" will there be any issues\r\n\r\nno, because its designed to work this way.\r\n\r\n> I'm hoping the answer is the one \"type orm\" connection will open multiple my sql db connections if it needs to do multiple things at the same time\r\n\r\nyes it is. Real database connection is used from pull per each `persist` / `remove`/ or any other `find` method call"
      },
      {
        "user": "swilliams-a3digital",
        "created_at": "2017-02-23T17:14:21Z",
        "body": "Thank you so much for the fast answer to my question.  You can close this issue.\r\n"
      },
      {
        "user": "zxr90",
        "created_at": "2017-04-22T06:48:05Z",
        "body": "> yes it is. Real database connection is used from pull per each persist / remove/ or any other find method call\r\n\r\nSorry to hijack this issue but i have a similar question while browsing the docs. Is there an option to control the max number of real database connection? If no, what is the default pool size?\r\n\r\nI'm coming off Activerecord and in Rails, they allow you to setup your own connection pool size when initializing the app."
      },
      {
        "user": "pleerock",
        "created_at": "2017-04-24T08:33:07Z",
        "body": "@zxr90 I have created separate issue for your issue. You can setup connection pool using \"extra\" option in connection driver options and pass there underlying driver options (for example if you are using mysql see mysql driver options on how to do this)"
      }
    ]
  },
  {
    "number": 294,
    "title": "Troubles with UglifyJS",
    "created_at": "2017-02-17T21:51:17Z",
    "closed_at": "2017-02-23T17:29:23Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/294",
    "body": "I use webpack and babel. I pass imported models to the connectionConfig. When I build the app for production with UglifyJsPlugin, an error occurs: `ER_NO_SUCH_TABLE: Table 'posts-app.e' doesn't exist`. How to avoid it without disabling the plugin? I found only one way: pass such options: ```  mangle: {\r\n    except: ['Post','User']\r\n  } ```",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/294/comments",
    "author": "SPAHI4",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-02-18T05:12:05Z",
        "body": "You have such error because table names are generated from class names, e.g. `Post` and `User`, but when you minify your code uglifier made your names `p` and `e` now. You have several choices: set explicit names for your tables, e.g. `@Entity(\"post\")` and `@Entity(\"user\")` or enable `mangle` (no need to specify entities, just mangle them all) or simply don't use uglify because its really pointless to use it and webpack on the backend."
      },
      {
        "user": "pleerock",
        "created_at": "2017-02-23T17:29:23Z",
        "body": "I guess I've answered your question and now this issue can be closed."
      },
      {
        "user": "SPAHI4",
        "created_at": "2017-02-23T18:25:05Z",
        "body": "@pleerock sure. Much thanks!"
      }
    ]
  },
  {
    "number": 238,
    "title": "How to save an int value to a foreign key ",
    "created_at": "2017-01-26T09:55:18Z",
    "closed_at": "2017-02-04T05:58:11Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/238",
    "body": "In the `Post` table, there is a one-to-one foreign key on `user_id` which links to the table `Members`, there is no problem with fetching the data like this:\r\n\r\n`[{ \"post_id\":1,\"user_id\":{\"user_name\":'Someone','user_id':4}, 'comment':'xxxxxx'}]`\r\n\r\nSuppose someone makes a comment, I get his comment and user id from express session, and want to save it to the `Post` table. Since `user_id` uses `Members` type, how can I save an int value to it? \r\nWould you please suggest a solution?\r\n\r\nHere's an example:\r\n\r\n````\r\n@Table()\r\nexport class Post {\r\n    @PrimaryGeneratedColumn()\r\n    post_id: number;\r\n\r\n    @OneToOne(type => Members,entity=>entity.user_id,{\r\n        cascadeRemove: true\r\n    })\r\n    @JoinColumn()\r\n    user_id: Members;\r\n\r\n    @Column()\r\n    comment:string;\r\n}\r\n\r\nexport class Members {\r\n    @PrimaryGeneratedColumn()\r\n    user_id: number;\r\n\r\n    @Column()\r\n    user_name:string;\r\n}\r\n````\r\n\r\n````\r\n    let post = new Post()\r\n    post.comment = \"sadsadsa\"\r\n    post.user_id = 44 <<=== type error!\r\n````\r\n\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/238/comments",
    "author": "laukaichung",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-01-26T10:52:26Z",
        "body": "you need to define both relation and id of the relation as a regular column. Example:\r\n\r\n```typescript\r\n@Table()\r\nexport class Post {\r\n    @PrimaryGeneratedColumn()\r\n    post_id: number;\r\n\r\n    @OneToOne(type => Members,entity=>entity.user_id)\r\n    @JoinColumn({ name: \"memberId\" })\r\n    member: Members;\r\n\r\n   @Column({  type: \"int\", nullable: true })\r\n   memberId: number;\r\n\r\n    @Column()\r\n    comment:string;\r\n}\r\n```\r\n"
      },
      {
        "user": "laukaichung",
        "created_at": "2017-01-26T16:00:23Z",
        "body": "@pleerock , I just did per your suggestion, I can save it to the table but \r\nit gives me this error/warning in the console: \r\n````\r\n(node:10665) UnhandledPromiseRejectionWarning: \r\nUnhandled promise rejection (rejection id: 1): \r\nError: Relation metadata for tag#user_id was not found.\r\n````\r\n````\r\n@Table()\r\nexport class Tag{\r\n\r\n    @OneToOne(type=>Members, entity=>entity.user_id,{onDelete:\"CASCADE\"})\r\n    @JoinColumn({name:'user_id'})\r\n    user_data:Members;\r\n\r\n    @Column({type:'int',nullable: true})\r\n    user_id:number;\r\n\r\n  \r\n}\r\n````\r\n\r\n"
      },
      {
        "user": "Tobias4872",
        "created_at": "2017-01-30T23:21:58Z",
        "body": "Not quite sure what you are trying to do. You have defined \"Post.user_id\" as type \"Members\" which obviously is not only an id. So, if you want to create a post, you will need to assign an instance of type \"Members\" to \"user_id\", so let's say you have two models like the following (please notice that I have changed the naming a bit.\r\n\r\n```\r\n@Table()\r\nexport class Member {\r\n    @PrimaryGeneratedColumn()\r\n    public userId: number;\r\n\r\n    @Column()\r\n    public userName: string;\r\n}\r\n\r\n@Table()\r\nexport class Post {\r\n    @PrimaryGeneratedColumn()\r\n    public postId: number;\r\n\r\n    @OneToOne(type => Member, (entity) => entity.userId,{\r\n        cascadeRemove: true,\r\n    })\r\n    @JoinColumn()\r\n    public user: Member;\r\n\r\n    @Column()\r\n    public comment: string;\r\n}\r\n```\r\n\r\nYou would then need to either create a new Member instance in advance or retrieve one from the db.\r\n\r\n```\r\n    const user = new Member();\r\n    user.userId = 1;\r\n    user.userName = \"Username\";\r\n\r\n    const memberRepo = connection.getRepository(Member);\r\n    await memberRepo.persist(user);\r\n\r\n    const post = new Post();\r\n    post.comment = \"Test\";\r\n    post.user = user;\r\n\r\n    const postRepo = connection.getRepository(Post);\r\n    await postRepo.persist(post);\r\n```\r\n\r\nLet me know if this helps.\r\n"
      },
      {
        "user": "vance",
        "created_at": "2017-09-20T17:13:43Z",
        "body": "If I use an existing `user:Member` entity, I get a violation of unique constraint when i update the 2nd post (since it uses the same `user` entity). How do a make a 2nd update to post?"
      },
      {
        "user": "Jood80",
        "created_at": "2021-05-12T17:32:21Z",
        "body": "These answers were absolutely helpful, thank you both @pleerock @Tobias4872 :pray: "
      }
    ]
  },
  {
    "number": 230,
    "title": "Error when create relation with concrete table inheritance",
    "created_at": "2017-01-24T04:37:52Z",
    "closed_at": "2017-06-10T17:20:12Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/230",
    "body": "It throws `Error: Entity metadata for ResourceOwner#tokens was not found.` with following entity definitions.\r\n\r\n```\r\n@AbstractTable()\r\nexport class OAuthToken {\r\n    ...\r\n\r\n    @ManyToOne(type => ResourceOwner, owner => owner.tokens)\r\n    owner: ResourceOwner;\r\n}\r\n\r\n@Table()\r\nexport class AccessToken extends OAuthToken {\r\n}\r\n\r\n// other subclass tokens...\r\n```\r\n\r\n```\r\n@Table()\r\nexport class ResourceOwner {\r\n    ...\r\n\r\n    @OneToMany(type => OAuthToken, token => token.owner)\r\n    tokens: OAuthToken[];\r\n}\r\n```",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/230/comments",
    "author": "exports",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-01-25T08:04:33Z",
        "body": "You can't point to abstract property on inverse side. \r\n\r\n```typescript\r\n@OneToMany(type => OAuthToken, token => token.owner)\r\n    tokens: OAuthToken[];\r\n```\r\n\r\nyou cant target only concrete entities like `AccessToken`, not abstract like `OAuthToken`"
      },
      {
        "user": "GeeWee",
        "created_at": "2017-06-10T12:57:12Z",
        "body": "Is there any plans for this feature @pleerock ?"
      },
      {
        "user": "pleerock",
        "created_at": "2017-06-10T17:20:12Z",
        "body": "its not possible to point to \"any inherited table\" from inverse side, referenced table should be a concrete table you want to reference, thats why you should use concrete entities in your base entities."
      }
    ]
  },
  {
    "number": 227,
    "title": "Persist: Insert but do not update",
    "created_at": "2017-01-22T23:12:57Z",
    "closed_at": "2017-06-30T14:26:03Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/227",
    "body": "How can i insert a new row without updating an existing row?\r\n\r\ncurrently i am using the Repository.persist method, but i would like to have the behaviour of SQLs INSERT IGNORE",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/227/comments",
    "author": "D4edalus",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-01-23T05:47:22Z",
        "body": "I guess right now its not possible. Are you using generated ids? If yes, then you can simply check if id exist then do not do anything, otherwise - insert."
      }
    ]
  },
  {
    "number": 201,
    "title": "@column should infer nullable property from variable declaration",
    "created_at": "2017-01-14T08:35:46Z",
    "closed_at": "2017-01-14T09:44:30Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/201",
    "body": "Can the @Column() decorator handle the following\r\n\r\n```\r\n@Column()\r\nua?: string\r\n```\r\n\r\nas equivalent to \r\n\r\n```\r\n@Column({nullable: true})\r\nua?: string\r\n```\r\n\r\n?",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/201/comments",
    "author": "dcworldwide",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-01-14T09:44:24Z",
        "body": "no you can't. btw answered your question on stackoverflow too."
      },
      {
        "user": "dcworldwide",
        "created_at": "2017-01-14T14:35:32Z",
        "body": "Thanks. Wishful thinking."
      }
    ]
  },
  {
    "number": 186,
    "title": "Single file @Table definition order is important",
    "created_at": "2017-01-10T05:24:30Z",
    "closed_at": "2017-01-10T10:08:48Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/186",
    "body": "It is worth nothing, that if you define all of your Entities (i.e. @Table classes) in a single file, that the order is important. If you reference a Entity as part of a relation (i.e. @OneToOne) before that referenced Entity is defined, you'll receive an error like below:\r\n\r\n```\r\n/Users/Danijel/projects/am/am-api/lib/model/model.js:175\r\n[1]     __metadata(\"design:type\", StoreBillingPlan)\r\n[1]                               ^\r\n[1]\r\n[1] ReferenceError: StoreBillingPlan is not defined\r\n[1]     at Object.<anonymous> (/Users/x/projects/am/am-api/lib/model/model.js:175:31)\r\n[1]     at Module._compile (module.js:571:32)\r\n[1]     at Object.Module._extensions..js (module.js:580:10)\r\n[1]     at Module.load (module.js:488:32)\r\n[1]     at tryModuleLoad (module.js:447:12)\r\n[1]     at Function.Module._load (module.js:439:3)\r\n[1]     at Module.require (module.js:498:17)\r\n[1]     at require (internal/module.js:20:19)\r\n[1]     at Object.<anonymous> (/Users/x/projects/am/am-api/lib/services/auth.js:10:17)\r\n[1]     at Module._compile (module.js:571:32)\r\n```\r\n\r\nIn my case, defining StoreBillingPlan before the above code was run solved my issue.  Is it possible to make order not important? \r\n\r\nNote: For those splitting Entities across files this shouldn't be an issue. ",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/186/comments",
    "author": "dcworldwide",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-01-10T10:08:48Z",
        "body": "No, its not possible. It is a language limitation and can't be avoided. Thats a dynamic nature of javascript. Its basically the same as:\r\n\r\n\r\n```typescript\r\nconsole.log(b); // will not work because b is not defined at this time\r\nlet a = 1;\r\nlet b = 2;\r\nconsole.log(a); // everything is fine because a is defined\r\n```\r\n\r\nSame rules applies to classes."
      },
      {
        "user": "dcworldwide",
        "created_at": "2017-01-10T10:59:00Z",
        "body": "Yeah I figured as much. Happy to modularise my code. "
      }
    ]
  },
  {
    "number": 153,
    "title": "ormconfig.json relative path?",
    "created_at": "2016-12-27T15:48:16Z",
    "closed_at": "2017-01-05T17:57:59Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/153",
    "body": "Can I put in ormconfig.json relative path? Absolute path is working fine, but relative - not :(\r\n```\r\n\"entities\" : [\r\n    \"../compiled/core/entities/*.js\"\r\n]\r\n```\r\nProject structure:\r\nproject\r\n```\r\n__complied\r\n____core\r\n______entities\r\n__app.js\r\n__src\r\n____core\r\n______entities\r\n__app.ts\r\ntsconfig.json\r\normconfig.json\r\n```\r\nI'm trying:\r\n```\r\n\"./compiled/core/entities/*.js\",\r\n\"./compiled/core/entities/*.js\",\r\n\"/compiled/core/entities/*.js\",\r\n\"compiled/core/entities/*.js\"\r\n```\r\nAnd many-many other))",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/153/comments",
    "author": "CocaColaBear",
    "comments": [
      {
        "user": "eduardoweiland",
        "created_at": "2016-12-27T16:48:02Z",
        "body": "I use relative paths and it works. I use:\r\n\r\n```\r\n\"entities\": [\"build/entity/*.js\"]\r\n```\r\n\r\nThis should be relative to the _current working directory_. So, you should `cd` into your project root before running it."
      },
      {
        "user": "CocaColaBear",
        "created_at": "2016-12-27T17:19:26Z",
        "body": "@eduardoweiland im run from project root:\r\nnpm ./compiled/app.js"
      }
    ]
  },
  {
    "number": 150,
    "title": "Column default value as function",
    "created_at": "2016-12-25T19:16:20Z",
    "closed_at": "2017-01-12T13:06:49Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/150",
    "body": "I have column Id:\r\n```\r\n@PrimaryColumn({\r\n    name: \"id\",\r\n    type: \"bigint\",\r\n    default: new_id() // new_id() is function in DB (postgresql)\r\n  })\r\n  Id: number;\r\n```\r\nIn database i have function: new_id() for generate ids. How i can implement this query?\r\n`id bigint NOT NULL DEFAULT new_id()`",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/150/comments",
    "author": "CocaColaBear",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2016-12-26T02:12:49Z",
        "body": "```typescript\r\n@PrimaryColumn({\r\n    name: \"id\",\r\n    type: \"bigint\",\r\n    default: \"new_id()\"\r\n  })\r\n  Id: number;\r\n```\r\n\r\nDoesnt it work?"
      },
      {
        "user": "CocaColaBear",
        "created_at": "2016-12-26T16:33:02Z",
        "body": "@pleerock  not work\r\nError:\r\n```\r\n{ error: invalid input syntax for integer: \"new_id()\"\r\n    at Connection.parseE (C:\\TS\\Test\\node_modules\\pg\\lib\\connection.js:554:11)\r\n    at Connection.parseMessage (C:\\TS\\Test\\node_modules\\pg\\lib\\connection.js:381:17)\r\n    at Socket.<anonymous> (C:\\TS\\Test\\node_modules\\pg\\lib\\connection.js:117:22)\r\n    at emitOne (events.js:96:13)\r\n    at Socket.emit (events.js:188:7)\r\n    at readableAddChunk (_stream_readable.js:176:18)\r\n    at Socket.Readable.push (_stream_readable.js:134:10)\r\n    at TCP.onread (net.js:551:20)\r\n  name: 'error',\r\n  length: 94,\r\n  severity: 'ERROR',\r\n  code: '22P02',\r\n  detail: undefined,\r\n  hint: undefined,\r\n  position: undefined,\r\n  internalPosition: undefined,\r\n  internalQuery: undefined,\r\n  where: undefined,\r\n  schema: undefined,\r\n  table: undefined,\r\n  column: undefined,\r\n  dataType: undefined,\r\n  constraint: undefined,\r\n  file: 'int8.c',\r\n  line: '99',\r\n  routine: 'scanint8' }\r\n```\r\n"
      },
      {
        "user": "pleerock",
        "created_at": "2016-12-26T17:40:11Z",
        "body": "mmm probably because of escaping... Probably we can add another option like `preventDefaultEscaping: boolean`, but I would like to hear better alternative @eduardoweiland @19majkel94 do you have any insights about this issue?"
      },
      {
        "user": "CocaColaBear",
        "created_at": "2016-12-26T17:58:30Z",
        "body": "@pleerock mb it is dirty, but we can check default value : function or not (regexp or another way).\r\nBut option 'preventDefaultEscaping' looks nice. I can make pull request with this option"
      },
      {
        "user": "pleerock",
        "created_at": "2016-12-26T18:22:19Z",
        "body": "> function or not (regexp or another way)\r\n\r\ncan we cover all cases with such regexp? \r\n\r\nI would like to hear something better then `preventDefaultEscaping`, maybe other guys have some opinions before you will make a PR with dirty `preventDefaultEscaping` option."
      },
      {
        "user": "eduardoweiland",
        "created_at": "2016-12-26T19:06:51Z",
        "body": "I have an idea, but maybe it's too much complex. Wrap the values that are sent to the database in some class, like `EscapedValue` and `RawSql`. These classes would hold the logic to convert the value to be sent to the database. I don't know how this would work with multiple drivers, but it's a starting point. What do you think?"
      },
      {
        "user": "MichalLytek",
        "created_at": "2016-12-26T20:58:47Z",
        "body": "5000 option and parameters makes the decorators code big and gross. I would preffer simple solutions like `&`, `@`, `=`, `<` in `AngularJS` or in template engines like `pug`.\r\n\r\nI don't know how about TypeORM v0.0.6 but the older version required quotes in string for default values:\r\n```typescript\r\n@Column(\"string\", { default: \"'normal'\" })\r\n```\r\nso we could also make this part of code more inteligent - if field is string, wrap argument in quotes in sql, if number no, etc.\r\n\r\nMy proposition are twos:\r\n1. Overloading decorator - you can pass function returning an unescaped string:\r\n```typescript\r\n@PrimaryColumn({ default: () => \"new_id()\" })\r\n```\r\nit could be even `default: unescaped => \"new_id()\"` or sth like this in intelisense.\r\n\r\n2. Parse string - if first char is '=' (or '!'), don't escape string. But it's like old JS style.\r\n\r\nIt could also be an alternative to `preventDefaultEscaping` option :wink:\r\n\r\n"
      },
      {
        "user": "pleerock",
        "created_at": "2016-12-27T05:56:06Z",
        "body": "Thank you guys for the feedback.\r\n\r\n`preventDefaultEscaping` really looks shitty beside your ideas.\r\n\r\n@eduardoweiland This is really cool idea, much better then `preventDefaultEscaping`.\r\n\r\n@19majkel94 I would like to prevent extra rules like \"!\" or \"&\" which aren't intuitive. But you bring a valueable point, what if value is lets say `TRUE` or `FALSE` or number, or string, or function.\r\n\r\nI think better if we won't do escaping at all, and those who want to use strings should put single quotes. It will solve all the problems and its intuitive enought (but still we need point this in docs)."
      },
      {
        "user": "pleerock",
        "created_at": "2017-01-12T13:07:37Z",
        "body": "Ive made a decision to use @19majkel94 suggested solution to use `function notation` for default values for now. It will work this way:\r\n\r\n```typescript\r\n@Column({ default: \"Umed\" })\r\nname: string;\r\n```\r\ngenerates `DEFAULT 'Umed'`\r\n\r\n```typescript\r\n@Column({ default: 1 })\r\ncount: number;\r\n```\r\ngenerates `DEFAULT 1`\r\n\r\n```typescript\r\n@Column({ default: true })\r\nisSomething: boolean;\r\n```\r\ngenerates `DEFAULT TRUE`\r\n\r\n```typescript\r\n@Column({ default: () => \"pow(5)\" })\r\ncount: number;\r\n```\r\ngenerates `DEFAULT pow(5)`\r\n\r\nThis fix released in `0.0.7-alpha.11`"
      }
    ]
  },
  {
    "number": 149,
    "title": "AbstractTable doesnt work in inherited classes",
    "created_at": "2016-12-25T16:21:16Z",
    "closed_at": "2016-12-25T18:59:23Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/149",
    "body": "Hi all!\r\nI have problem with AbstractTable decorator. Error:\r\n_MissingPrimaryColumnError: Entity \"Post\" does not have a primary column. Primary column is required to have in all your entities. Use @PrimaryColumn decorator to add a primary column to your entity._\r\nFiles:\r\n**BasePost.ts**:\r\n```\r\nimport {PrimaryGeneratedColumn, Column} from \"typeorm\";\r\nimport {AbstractTable} from \"typeorm\";\r\n\r\n@AbstractTable()\r\nexport class BasePost {\r\n    @PrimaryGeneratedColumn()\r\n    id: number;\r\n\r\n    @Column()\r\n    title: string;\r\n}\r\n```\r\n**Post.ts**:\r\n```\r\nimport {Column, Table} from \"typeorm\";\r\nimport {BasePost} from \"./BasePost\";\r\n\r\n@Table(\"post\")\r\nexport class Post extends BasePost {\r\n    @Column()\r\n    text: string;\r\n}\r\n```\r\n**app.ts**:\r\n```\r\nimport \"reflect-metadata\";\r\nimport { createConnection } from \"typeorm\";\r\nimport { Post } from \"./entities/Post\";\r\n\r\ncreateConnection({\r\n  driver: {\r\n    type: \"postgres\",\r\n    host: \"host\",\r\n    port: 7755,\r\n    username: \"postgres\",\r\n    password: \"pass\",\r\n    database: \"testdatabase\"\r\n  },\r\n  entities: [\r\n    Post\r\n  ],\r\n  autoSchemaSync: true\r\n  }).then(connection => {\r\n    console.log('Good!');\r\n  })\r\n  .catch(reason => {\r\n    console.log(reason);\r\n});\r\n```\r\nWhat is wrong?\r\nNodeJS version: 7.3.0\r\nTypescript version: 2.1.4\r\nTypeORM version: 0.0.5",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/149/comments",
    "author": "CocaColaBear",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2016-12-25T18:46:34Z",
        "body": "Please include `BasePost` in a list of your `entities: [Post, BasePost]`"
      },
      {
        "user": "CocaColaBear",
        "created_at": "2016-12-25T18:59:23Z",
        "body": "@pleerock thanks a lot! :)"
      },
      {
        "user": "pleerock",
        "created_at": "2016-12-25T19:00:10Z",
        "body": "one star from you ;)"
      }
    ]
  },
  {
    "number": 142,
    "title": "innerJoinAndSelect with no matching rows results in rejected promise",
    "created_at": "2016-12-22T22:40:54Z",
    "closed_at": "2016-12-23T18:28:29Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/142",
    "body": "Hi,\r\n\r\nThere's a OneToMany relation between \"ent\" (one) and \"some_stuff\" (many).\r\n\r\nI'm doing something similar to this:\r\n\r\n```\r\nentRepository.createQueryBuilder('ent')\r\n\t.innerJoinAndSelect('ent.some_stuff', 'some_stuff')\r\n\t.getOne();\r\n```\r\n\r\nWhenever some_stuff has corresponding rows for ent, it works.\r\nWhenever there're no corresponding rows for ent, the promise is rejected.\r\n\r\nHow can I simply have some_stuff set to an empty array in ent whenever there're no corresponding rows instead of having the promise rejected?",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/142/comments",
    "author": "royibernthal",
    "comments": [
      {
        "user": "eduardoweiland",
        "created_at": "2016-12-23T00:36:09Z",
        "body": "If you want to get the result for `ent` when it does not have any `some_stuff`, you should use a `LEFT JOIN`. When doing an `INNER JOIN`, the database will not return the `ent` row if it does not have corresponding rows in the joined table.\r\n\r\n@royibernthal can you try using `leftJoinAndSelect` and see if it works?\r\n\r\n```typescript\r\nentRepository.createQueryBuilder('ent')\r\n\t.leftJoinAndSelect('ent.some_stuff', 'some_stuff')\r\n\t.getOne();\r\n```"
      },
      {
        "user": "royibernthal",
        "created_at": "2016-12-23T09:15:05Z",
        "body": "True, works.\r\n\r\nIs that the only difference between innerJoinAndSelect and leftJoinAndSelect?\r\nIs there a reason not to always use leftJoinAndSelect?"
      },
      {
        "user": "pleerock",
        "created_at": "2016-12-23T13:01:38Z",
        "body": "yes. same applies for `INNER JOIN` vs `LEFT JOIN` in SQL."
      },
      {
        "user": "royibernthal",
        "created_at": "2016-12-24T00:48:41Z",
        "body": "Thanks"
      }
    ]
  },
  {
    "number": 2880,
    "title": "Firebird Support",
    "created_at": "2018-10-02T15:06:23Z",
    "closed_at": "2018-12-19T11:43:46Z",
    "labels": [
      "help wanted",
      "new feature",
      "accepting PRs",
      "community",
      "comp: drivers and platforms"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/2880",
    "body": "**Issue type:**\r\n\r\n[ ] question\r\n[ ] bug report\r\n[x] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n\r\n[x] 'firebird' - new\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n\r\nHi, I wanted to use the typeorm in a project that I use firebird, I even started to develop, if it could be useful I could add to the project.\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/2880/comments",
    "author": "edu-ricardo",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2018-12-19T11:43:46Z",
        "body": "As it was mentioned multiple times we don't have in plans to implement new drivers in a near future. If you want to contribute - please feel free! To keep issues cleaner lets close this one and continue discussion in #4"
      },
      {
        "user": "kerwynrg",
        "created_at": "2019-07-11T22:43:52Z",
        "body": "What is missing to integrate your changes to typeorm repo?"
      }
    ]
  },
  {
    "number": 2699,
    "title": "Support for IBM DB2 Database Server",
    "created_at": "2018-08-23T07:43:52Z",
    "closed_at": "2018-12-19T11:06:27Z",
    "labels": [
      "help wanted",
      "new feature",
      "accepting PRs",
      "community",
      "comp: drivers and platforms"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/2699",
    "body": "**Issue type:**\r\n\r\n[ ] question\r\n[ ] bug report\r\n[x] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `react-native`\r\n[ ] `expo`\r\n[x] `db2` (experimental)\r\n**TypeORM version:**\r\n\r\n[ ] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\n<!--\r\n    To answer those questions you need to put \"x\" inside the square brackets, for example:\r\n    [x] `mysql`\r\n    [ ] `postgres`\r\n\r\n    Also, please format your code properly (by taking code blocks into ```ts .... ```)\r\n!>\r\nAlso include support for IBM DB2 Server",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/2699/comments",
    "author": "shortthirdman",
    "comments": [
      {
        "user": "ghost",
        "created_at": "2018-11-23T09:33:18Z",
        "body": "+1 "
      },
      {
        "user": "pleerock",
        "created_at": "2018-12-19T11:06:27Z",
        "body": "As it was mentioned multiple times we don't have in plans to implement new drivers in a near future. If you want to contribute - please feel free! To keep issues cleaner lets close this one and continue discussion in #4"
      },
      {
        "user": "gabrielwillemann",
        "created_at": "2019-02-25T14:56:04Z",
        "body": "+1"
      },
      {
        "user": "paulodutra",
        "created_at": "2023-06-21T15:26:00Z",
        "body": "+1"
      },
      {
        "user": "luan-vieira-er",
        "created_at": "2023-09-06T14:43:59Z",
        "body": "+1\r\n"
      }
    ]
  },
  {
    "number": 2336,
    "title": "Extend entities in runtime",
    "created_at": "2018-06-13T21:02:11Z",
    "closed_at": "2022-12-29T15:43:40Z",
    "labels": [
      "help wanted",
      "new feature",
      "can be closed?",
      "discussion"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/2336",
    "body": "I would like to suggest an issue that has been discussed here before, but still not resolved yet.\r\n\r\nThe goal of my idea is to allow extensibility of the ORM entities using `@Entity` declaration.\r\n\r\nThe goal is to add naming to entities and then to separate it's declaration to smaller pieces.\r\n\r\nSuggested API:\r\n\r\n// Base entity\r\n```\r\n@Entity({ name: 'user' })\r\nclass BaseUser {\r\n    @Column()\r\n    name: String;\r\n}\r\n```\r\n\r\n// Extension A \r\n```\r\n@Entity({ name: 'user' })\r\nclass UserWithProfile {\r\n    @Column()\r\n    profile: Profile;\r\n}\r\n```\r\n\r\n// Extension AB\r\n```\r\n@Entity({ name: 'user' })\r\nclass UserWithAge {\r\n    @Column()\r\n    age: number;\r\n}\r\n```\r\n\r\nEach declaration should let the user to access the entire `User` object, and access all of the fields that has been declared before or after. The merge between the entities will occur during runtime (using `entities: [ ... ]`), and they will be merged by a unique specifier (for example, `name`).\r\nFor example, if a user tries to save using `BaseUser`, all of the validations and ORM rules that relevant to `BaseUser`+`UserWithProfile`+`UserWithAge` will be executed (just like one big entity).\r\nA fetch using the ORM will transform and return all of the fields. So a `find` execution using `getRepository(BaseUser)` will be the same as `getRepository(UserWithProfile)`.\r\n\r\nI belive that this feature will also let you in the future the ability to separate between the core ORM logic and the TypeScript decorators, because of the fact that entities will be identified by a name and not by a class with a decorator.\r\nIt will also allow user to extend entities without the need for inheritance, and without the need to couple between the classes.\r\n\r\n**Issue type:**\r\n\r\n[ ] question\r\n[ ] bug report\r\n[x] feature request\r\n[ ] documentation issue\r\n\r\n**TypeORM version:**\r\n\r\n[ ] `latest`\r\n[x] `@next`\r\n[ ] `0.x.x` (or put your version here)",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/2336/comments",
    "author": "dotansimha",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2018-06-14T05:17:18Z",
        "body": "I would like to point that this feature can be implemented only with entity schemas as we discussed earlier. "
      },
      {
        "user": "imnotjames",
        "created_at": "2021-07-05T19:00:03Z",
        "body": "This has seen little traction for several years.  I'd like to close it as I don't see it being implemented in the near future."
      }
    ]
  },
  {
    "number": 1792,
    "title": "Mongo return nothing with use id to query",
    "created_at": "2018-03-21T09:54:43Z",
    "closed_at": "2020-10-04T04:05:42Z",
    "labels": [
      "help wanted",
      "community",
      "driver: mongodb"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/1792",
    "body": "**Issue type:**\r\n\r\n[ ] question\r\n[x] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[x] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `websql`\r\n\r\n**TypeORM version:**\r\n\r\n[ ] `latest`\r\n[ ] `@next`\r\n[x] `0.1.12`\r\n\r\nwhen i use find function with the options which has id field it always return nothing;\r\n````node\r\nreturn this.userRepository.find({ // return []\r\n      where: {\r\n        id: {\r\n          $in: ids\r\n        }\r\n      }\r\n    });\r\n````\r\n\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/1792/comments",
    "author": "dapaer",
    "comments": [
      {
        "user": "Rhymmor",
        "created_at": "2018-03-29T16:38:08Z",
        "body": "@dapaer Actually, I was able to return objects by id field. Do you use ObjectID instance as id?"
      },
      {
        "user": "Rhymmor",
        "created_at": "2018-03-29T16:40:46Z",
        "body": "@pleerock how do you think, maybe finding by ids as strings should be the feature? The string can be wrapped to ObjectID instance inside."
      },
      {
        "user": "pleerock",
        "created_at": "2018-03-29T19:47:33Z",
        "body": "No, in query it can't be since query is mongodb-query and very dynamic, we can't manipulate it"
      },
      {
        "user": "Rhymmor",
        "created_at": "2018-03-30T07:21:03Z",
        "body": "I can add tests checking this behavior. If they will pass then I think issue can be closed (if @dapaer won't add anything)"
      }
    ]
  },
  {
    "number": 1740,
    "title": "Support the mongoDB change stream API",
    "created_at": "2018-03-11T17:27:19Z",
    "closed_at": "2019-03-10T05:42:06Z",
    "labels": [
      "help wanted",
      "accepting PRs",
      "community",
      "driver: mongodb"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/1740",
    "body": "**Issue type:**\r\n\r\n[ ] question\r\n[ ] bug report\r\n[ X ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ X ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `websql`\r\n\r\n**TypeORM version:**\r\n\r\n[ X ] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Demo with the native mongo driver:**\r\nSince mongo 3.6, the change stream API allow to watch changes on a collection.\r\n```ts\r\nlet mongoUrl: string = 'mongodb://192.168.1.3:27017';\r\nlet client: MongoClient = await MongoClient.connect(mongoUrl);\r\nlet db: Db = client.db('nsrp');\r\nlet accountsCollection: Collection = db.collection('accounts');\r\n\r\naccountsCollection.watch({ fullDocument: 'updateLookup' }).on('change', (change) => {\r\n\tswitch (change.operationType) {\r\n\t\tcase 'update':\r\n\t\t\tconsole.log('Someone change: ' + change.fullDocument.username);\r\n\t\t\tbreak;\r\n\r\n\t\tcase 'insert':\r\n\t\t\tconsole.log('New user created: ' + change.fullDocument.username);\r\n\t\t\tbreak;\r\n\r\n\t\tcase 'delete':\r\n\t\t\tconsole.log('A user were deleted: ' + change.documentKey._id);\r\n\t\t\tbreak;\r\n\t}\r\n});\r\n```\r\n\r\n**Possible implementations in typeorm:**\r\nI'm new in typeorm so I'm not very familiar with the architecture but this is what I think would be the best:\r\n\r\n- Exposing the mongo collection object could offer all futur features that the mongo driver offer before abstracting them on the typeorm ORM.\r\n- A watch() method could be added on the MongoRepository class or/and in the BaseEntity class\r\n\r\nI will explore the typeorm structur to find how I can add this feature but I think it could be a big advantage to offer a simple way to watch changes on the collection.",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/1740/comments",
    "author": "adam-lebon",
    "comments": [
      {
        "user": "adam-lebon",
        "created_at": "2018-03-11T18:00:08Z",
        "body": "Just seen that typeorm doesn't support mongodb driver >=3.0 and the watch api isn't available at 2.2.\r\nSo this feature will not be available since typeorm does not support mongo 3 driver."
      },
      {
        "user": "pleerock",
        "created_at": "2018-03-12T07:53:20Z",
        "body": "There is a PR for mongo 3 support, but author is still working on it.\r\n\r\nThis feature is opened for contributions, looks like simply need to add this method into MongoRepository and MongoEntityManager classes."
      },
      {
        "user": "jakubnavratil",
        "created_at": "2018-04-26T10:43:07Z",
        "body": "Looks like Mongo driver v 3 is already supported. This issue can now be fixed."
      },
      {
        "user": "rustamwin",
        "created_at": "2019-01-16T11:47:46Z",
        "body": ":+1: "
      },
      {
        "user": "rustamwin",
        "created_at": "2019-03-10T05:42:06Z",
        "body": "This issue fixed #3699 "
      }
    ]
  },
  {
    "number": 1680,
    "title": "Delete & Update applies to all entities in table if criteria is undefined or empty ",
    "created_at": "2018-02-28T21:51:42Z",
    "closed_at": "2018-03-03T17:58:17Z",
    "labels": [
      "help wanted",
      "accepting PRs"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/1680",
    "body": "**Issue type:**\r\n\r\n[x] question\r\n[x] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[x] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `websql`\r\n\r\n**TypeORM version:**\r\n\r\n[ ] `latest`\r\n[x] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n\r\nUsing the repository API and calling any of the following:\r\n\r\n`await repository.delete(null)`\r\n`await repository.delete(undefined)`\r\n`await repository.delete([])`\r\n\r\nWill drop the entire table.\r\n\r\nI don't think this is the intended functionality, or if it is, the documentation should make it very clear that it will delete everything. Also may be related to #1226.\r\n\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/1680/comments",
    "author": "alex-red",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2018-03-01T08:09:01Z",
        "body": "Correct. Since its easy to implement, do you want to contribute?"
      },
      {
        "user": "alex-red",
        "created_at": "2018-03-01T08:46:01Z",
        "body": "Sure, sounds good to me, I'll make a PR soon then :)\r\n"
      },
      {
        "user": "alex-red",
        "created_at": "2018-03-01T19:49:20Z",
        "body": "Hey @pleerock some questions for you:\r\n\r\n1) What should the return value look like in this case? Should I return an empty DeleteResult?\r\n\r\n2) I see that the same issue occurs with repository.update, ex: `repository.update(null, { someColumn: \"test\" }` will update the entire table, should I apply the same checks here?"
      },
      {
        "user": "pleerock",
        "created_at": "2018-03-02T07:21:17Z",
        "body": "> I see that the same issue occurs with repository.update, ex: repository.update(null, { someColumn: \"test\" } will update the entire table, should I apply the same checks here?\r\n\r\nyes, please\r\n\r\n> What should the return value look like in this case? Should I return an empty DeleteResult?\r\n\r\nProbably returning empty delete result is a bad idea. Maybe its better to throw an error?"
      },
      {
        "user": "MajidJafari",
        "created_at": "2020-09-25T10:38:08Z",
        "body": "How we can remove all entries of a table at once, now? Surely we can use `QueryBuilder`, but I'm sure `TypeORM` needs a simple way to do that, too."
      },
      {
        "user": "andreasblueher",
        "created_at": "2020-11-24T11:58:38Z",
        "body": "Hey @pleerock did you see this question? I can't find a way to delete all data for a specific entity either. Could you please help us?"
      },
      {
        "user": "nebkat",
        "created_at": "2020-11-24T13:48:19Z",
        "body": "> How we can remove all entries of a table at once, now? Surely we can use QueryBuilder, but I'm sure TypeORM needs a simple way to do that, too.\r\n\r\n`repository.delete(() => \"\")` should work, although it is a workaround.\r\n"
      },
      {
        "user": "NenadJovicic",
        "created_at": "2021-11-04T19:16:43Z",
        "body": "@MajidJafari @andreasblueher you can use `repository.clear()` it will delete everything from that table"
      },
      {
        "user": "vtgn",
        "created_at": "2022-10-13T18:45:13Z",
        "body": "> @MajidJafari @andreasblueher you can use `repository.clear()` it will delete everything from that table\r\n\r\nclear() uses TRUNCATE and delete() uses DELETE : these are absolutely not the same functionalities, and have not the same constraints. Plus TRUNCATE doesn't work correctly with the transactions, contrary to DELETE."
      },
      {
        "user": "vtgn",
        "created_at": "2022-10-13T18:58:01Z",
        "body": "> > How we can remove all entries of a table at once, now? Surely we can use QueryBuilder, but I'm sure TypeORM needs a simple way to do that, too.\r\n> \r\n> `repository.delete(() => \"\")` should work, although it is a workaround.\r\n\r\nThis workaround is not beautiful. :/\r\nWhy not simply allow to call the delete() function without argument to delete all entries in the table? This would be the same way the find() method get all the entries."
      },
      {
        "user": "forrestwilkins",
        "created_at": "2023-04-09T17:24:49Z",
        "body": "@vtgn Perhaps it's for safety?"
      },
      {
        "user": "vtgn",
        "created_at": "2023-04-09T17:44:09Z",
        "body": "> @vtgn Perhaps it's for safety?\r\n\r\nIt would be a huge error for the developer if no parameter is given by accident compared to:\r\n repository.delete(null)\r\n repository.delete(undefined)\r\n repository.delete([])\r\nwhich are most dangerous by far.\r\n\r\nOr else if you want even more safety, they can just create a specific method for that, for example: Repository.deleteAll()."
      }
    ]
  },
  {
    "number": 1624,
    "title": "CLI command entity:create overrides existing files",
    "created_at": "2018-02-21T16:10:34Z",
    "closed_at": "2018-02-28T08:04:21Z",
    "labels": [
      "enhancement",
      "help wanted",
      "accepting PRs"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/1624",
    "body": "**Issue type:**\r\n\r\n[ ] question\r\n[x] bug report\r\n[ ] feature request\r\n[ ] documentation issue\r\n\r\n**Database system/driver:**\r\n\r\n[ ] `cordova`\r\n[ ] `mongodb`\r\n[ ] `mssql`\r\n[ ] `mysql` / `mariadb`\r\n[ ] `oracle`\r\n[ ] `postgres`\r\n[ ] `sqlite`\r\n[ ] `sqljs`\r\n[ ] `websql`\r\n\r\n**TypeORM version:**\r\n\r\n[x] `latest`\r\n[ ] `@next`\r\n[ ] `0.x.x` (or put your version here)\r\n\r\n**Steps to reproduce or a small repository showing the problem:**\r\n* ```typeorm entity:create -n Test```\r\n* Edit the Test.ts entity file\r\n* ```typeorm entity:create -n Test```\r\n* Test.ts has been overriden with an empty entity\r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/1624/comments",
    "author": "Pedrock",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2018-02-22T04:56:43Z",
        "body": "It should probably throw an error that such file already exist."
      },
      {
        "user": "Rhymmor",
        "created_at": "2018-02-23T22:18:32Z",
        "body": "@pleerock, I've got this one but I'm not sure about the right way to test CLI. Should CLI be run with exec/spawn in the test?"
      },
      {
        "user": "pleerock",
        "created_at": "2018-02-26T05:40:20Z",
        "body": "We don't have CLI commands test covered yet, unfortunately. I think best is to extract logic inside CLI commands and test that classes separately probably. For now fix without test is acceptable."
      },
      {
        "user": "pleerock",
        "created_at": "2018-02-28T08:04:21Z",
        "body": "thanks @Rhymmor for the fix."
      }
    ]
  },
  {
    "number": 1414,
    "title": "Support enum for DB who don't support it",
    "created_at": "2018-01-06T11:07:43Z",
    "closed_at": "2020-10-09T20:55:22Z",
    "labels": [
      "help wanted",
      "new feature",
      "accepting PRs",
      "community",
      "comp: schema sync"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/1414",
    "body": "Currently SQLite doesn't have `ENUM` type, but TypeORM can use it's own validator before inserting a value into the DB and emit an error when the value is not in the enum.\r\n\r\n```typescript\r\nenum MyEnum { \r\n    zero = 0; \r\n    one = 1;\r\n}\r\n\r\n@Entity()\r\nexport class Test {\r\n    @Column({enum: MyEnum})\r\n    myVar: number; // Must be 0 or 1\r\n}\r\n```\r\n  ",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/1414/comments",
    "author": "antoine-pous",
    "comments": [
      {
        "user": "mhombach",
        "created_at": "2018-02-15T07:47:59Z",
        "body": "I'm a big fan of making ORM-Systems really universal or at least as much universal as it can get.\r\nIf i create my business-logic within it and i later need to change the database-engine, then there should not be a bunch of stuff i need to change. Sure, i can then optimize everything for the new engine, but it should \"work\" flawless without changing much stuff...\r\nSo i would vote for implementing this as universal type into the ORM and when a database doenst support that column-type, then internally it should just get converted to a string or an integer, which represents that ENUM values. And sure, then it should be validated exactly to match the declared ENUM-Object."
      },
      {
        "user": "pleerock",
        "created_at": "2018-02-15T07:59:42Z",
        "body": "@mhombach sorry to disappoint you, but Im biggest anti-fun of universal ORM-systems, simply because:\r\n\r\n* any abstraction come with cost, and cost of making everything universal is too high - you loose to much functionality that each database provides which values higher then having things \"universal\", because of...\r\n* being universal is mostly useless, because in practice it does not give anything except of \"i later need to change the database-engine\". But reality that you are not going to change your database engine almost never. And if you'll have such need ever it will be easier to you to change all places in your code to match new database rather then loosing benefits provided by point 1\r\n\r\nBut this particular feature request we can implement, because it does not restrict / limit us in anything, its just an addition."
      },
      {
        "user": "atheros",
        "created_at": "2018-03-05T19:22:04Z",
        "body": "I once wrote a full app using an orm(not typeorm) using linux + mysql for in-house usage, then my boss came and told me I have to deploy same app to one of our clients. The catch was it was supposed to run on windows with mssql. Obviously it took me some time to get the job done and I would have greatly appreciated if the orm I was using would allow me to abstract things more.\r\n\r\nIn any case since there is already simple-array and simple-json, why not add simple-enum? Also an option with \"useNativeTypeIfAvailable\" would be even better."
      },
      {
        "user": "pleerock",
        "created_at": "2018-03-09T10:18:37Z",
        "body": "This issue is opened for the community. Feel free to implement `simple-enum` type, its easy feature to implement. "
      },
      {
        "user": "davidmpaz",
        "created_at": "2018-04-24T12:48:43Z",
        "body": "My 5 cents...\r\n\r\n@antoine-pous  I came into this issue a couple of day before looking for the same kind of functionality. The outcome of it did not look well so i tried to solve it working around. I am working with `cordova` and `sqljs` drivers. So, what I did was this:\r\n```typescript\r\n// CostType.ts\r\nexport enum CostType {\r\n    TOTAL = 'total',\r\n    TAX_TOTAL = 'taxTotal',\r\n    GRANT_TOTAL = 'grantTotal'\r\n}\r\n\r\n// CostEntryOrmModel.ts\r\n@Entity('costEntry')\r\nexport class CostEntryOrmModel {\r\n\r\n    @PrimaryGeneratedColumn()\r\n    identifier: number;\r\n\r\n    // note here how the type is specified to be the type of value in enum\r\n    @Column({type: 'varchar'})\r\n    id: CostType;\r\n\r\n    // .....\r\n}\r\n```\r\nWould this work for you? Can you give it a try and report back your feedback?\r\n\r\nIf I find time this week I can make a pull request with some tests to make a PoC\r\n\r\nCheers\r\n"
      },
      {
        "user": "maxxims",
        "created_at": "2019-04-26T12:51:00Z",
        "body": "@borremosch could you please provide an example for this implementation?\r\n\r\nI am mostly interested for the MSSQL.\r\n\r\n`export enum CostType {\r\n    TOTAL = 0,\r\n    TAX_TOTAL = 1,\r\n    GRANT_TOTAL = 2\r\n}`\r\n\r\n```@Entity('costEntry')\r\nexport class CostEntryOrmModel {\r\n    @PrimaryGeneratedColumn()\r\n    id: number;\r\n    @Column({type: 'simple-enum'})\r\n    cost: CostType;\r\n}\r\n\r\nThis is saved as nvarchar and I don't see any CHECK Constraints being added."
      },
      {
        "user": "borremosch",
        "created_at": "2019-04-26T13:28:29Z",
        "body": "@maxxims you'll have to add the enum type to the column decorator as well, just like with a regular enum:\r\n\r\n```\r\n@Column({\r\n    type: 'simple-enum',\r\n    enum: CostType\r\n})\r\ncost: CostType;\r\n```\r\n\r\nHope this solves it"
      },
      {
        "user": "SYip",
        "created_at": "2020-01-20T07:20:03Z",
        "body": "Should this issue be closed as #3700 was already merged?"
      }
    ]
  },
  {
    "number": 926,
    "title": "[Feature Request] disable cache when redis is down",
    "created_at": "2017-09-22T08:39:15Z",
    "closed_at": "2021-05-08T08:12:38Z",
    "labels": [
      "help wanted",
      "discussion",
      "accepting PRs",
      "community"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/926",
    "body": "if I using a redis server to cache queries, when redis is down the typeorm will crash immediately.\r\n\r\n```\r\nError: Redis connection to 127.0.0.1:6379 failed - connect ECONNREFUSED 127.0.0.1:6379\r\n    at Object._errnoException (util.js:1026:11)\r\n    at _exceptionWithHostPort (util.js:1049:20)\r\n    at TCPConnectWrap.afterConnect [as oncomplete] (net.js:1174:14)\r\n```\r\n\r\nit should be auto disable cache and auto retry later",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/926/comments",
    "author": "Diluka",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-09-22T09:51:01Z",
        "body": "I don't think it should work this way. If you enabled cache and configure redis then your redis must be up and working. And I dont see real world scenarios when users redis will be \"sometimes enabled\" or \"sometimes disabled\""
      },
      {
        "user": "Diluka",
        "created_at": "2017-09-22T12:51:46Z",
        "body": "this is about server availability and crisis control.\r\nremote services could be unavailable sometimes. maybe network issue or service update. those foreseeable exceptions should be handled. for now, redis unavailable makes typeorm crashed further crashes the whole server. makes server unstable. \r\n\r\nthe cache is temporary storage. It allows the server to handle the business faster. But without it, the server should also be able to work properly, and not completely collapse.\r\nWhen use `spring-data-redis` to cache, we can override the serialization and deserialization methods to prevent redis errors caused by the problem.\r\n\r\n**At least, the cache options should export an API for developers to register there own implementations to handle cache server offline exception.**\r\nso that could increase the server's availability."
      },
      {
        "user": "pleerock",
        "created_at": "2017-09-22T15:15:25Z",
        "body": "This explanation makes sense, but we need to think how API for this shall look like"
      },
      {
        "user": "scvgoe",
        "created_at": "2019-01-31T00:58:47Z",
        "body": "I agree with @Diluka's opinion.\r\n\r\nI think we should be able to handle redis error."
      },
      {
        "user": "scvgoe",
        "created_at": "2019-01-31T01:15:45Z",
        "body": "Actually, I want to ignore all cache stuff errors.\r\n\r\n```typescript\r\n    /**\r\n     * Loads raw results from the database.\r\n     */\r\n    protected async loadRawResults(queryRunner: QueryRunner) {\r\n        const [sql, parameters] = this.getQueryAndParameters();\r\n        const queryId = sql + \" -- PARAMETERS: \" + JSON.stringify(parameters);\r\n        const cacheOptions = typeof this.connection.options.cache === \"object\" ? this.connection.options.cache : {};\r\n        let savedQueryResultCacheOptions: QueryResultCacheOptions | undefined = undefined;\r\n        if (this.connection.queryResultCache && (this.expressionMap.cache || cacheOptions.alwaysEnabled)) {\r\n            try {\r\n                savedQueryResultCacheOptions = await this.connection.queryResultCache.getFromCache({\r\n                    identifier: this.expressionMap.cacheId,\r\n                    query: queryId,\r\n                    duration: this.expressionMap.cacheDuration || cacheOptions.duration || 1000\r\n                }, queryRunner);\r\n                if (savedQueryResultCacheOptions && !this.connection.queryResultCache.isExpired(savedQueryResultCacheOptions))\r\n                    return JSON.parse(savedQueryResultCacheOptions.result);\r\n            } catch { }\r\n        }\r\n\r\n        const results = await queryRunner.query(sql, parameters);\r\n\r\n        if (this.connection.queryResultCache && (this.expressionMap.cache || cacheOptions.alwaysEnabled)) {\r\n            try {\r\n                await this.connection.queryResultCache.storeInCache({\r\n                    identifier: this.expressionMap.cacheId,\r\n                    query: queryId,\r\n                    time: new Date().getTime(),\r\n                    duration: this.expressionMap.cacheDuration || cacheOptions.duration || 1000,\r\n                    result: JSON.stringify(results)\r\n                }, savedQueryResultCacheOptions, queryRunner);\r\n            } catch { }\r\n        }\r\n\r\n        return results;\r\n    }    \r\n```"
      },
      {
        "user": "gouroujo",
        "created_at": "2019-09-26T10:11:41Z",
        "body": "Hello,\r\nThis issue is really a very nice improvement to the current behaviour.\r\nI'm facing the same problem with the option `enableOfflineQueue` set to false for a high velocity throughput.\r\nThe request I made to the database is very lightweight, but also very frequent (ETL system) so the cache is only here to reduce the number of request. If there is more miss than it should be (for example if there is a network failure with redis) I don't want to queue my request neither wait for the network neither I want to fail it due to the cache unavailability.\r\n\r\nIn my opinion, the actual behaviour should be the default (as it the most common use case) but you should provide an API option to ignore cache failure.\r\n\r\ncheers,\r\nJo"
      },
      {
        "user": "hunglee",
        "created_at": "2021-02-05T04:35:20Z",
        "body": "Any update about this issue? "
      }
    ]
  },
  {
    "number": 310,
    "title": "[Documentation] Default relationship handling in queries is very unclear.",
    "created_at": "2017-02-23T21:50:07Z",
    "closed_at": "2017-07-04T06:14:25Z",
    "labels": [
      "help wanted",
      "documentation"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/310",
    "body": "I'm very reluctant to use the relationship support in TypeORM because I'm totally in the dark about its impact on performance.  For example, I can't find doc or sample that indicates whether, in a one-to-many relation, the \"many\" side is fetched on a `find` of the \"one\".  I suspect (maybe!) that TypeORM emulates some other ORM that you're very familiar with, so \"of course it works that way\".  If so, can you say what it is? \r\n",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/310/comments",
    "author": "estaub",
    "comments": [
      {
        "user": "D4edalus",
        "created_at": "2017-02-23T22:34:49Z",
        "body": "if you are wondering about the generated sql statement you can always use getGeneratedQuery() on the query builder. \r\n\r\nbut more docs would be nice on it 👍 "
      },
      {
        "user": "estaub",
        "created_at": "2017-02-24T00:36:01Z",
        "body": "@D4edalus I'm asking about `Repository.find()`, which afaict has no `getGeneratedQuery`.  I'm fine with the querybuilder - it obviously only fetches what you tell it to, via `select`"
      },
      {
        "user": "pleerock",
        "created_at": "2017-02-24T04:00:14Z",
        "body": "`Repository.find()` uses query builder internally, so it just delegates params you send to query builder. I understand what you are asking for, however thats a small details of documentation which currently lack because of no priority on it (and because of lack of time and help from community). I'll return back to this once more priority features will be implemented and I'll go deeper with documentation. Feel free to jump deeper in typeorm code and write documentation on your own if you can!"
      }
    ]
  },
  {
    "number": 293,
    "title": "Camel cased property names produce quoted column names in DB but lower case do not",
    "created_at": "2017-02-17T01:43:16Z",
    "closed_at": "2017-07-27T10:46:46Z",
    "labels": [
      "help wanted",
      "discussion"
    ],
    "url": "https://github.com/typeorm/typeorm/issues/293",
    "body": "I got an error that threw me off for several minutes while using QueryBuilder.OrderBy when trying to reference a camel cased column name. I didn't realize it was quoted in the database and I had to actually put double quotes in the string passed to OrderBy. Without knowing the details of the code that handles that, it seems to me like there could be a better, more uniform way of avoiding that error. Maybe all property names passed into the DB could be automatically quoted? Again, not sure what the implications are, but it definitely doesn't feel right having several quoted column names while most are not and having to deal with them differently.",
    "comments_url": "https://api.github.com/repos/typeorm/typeorm/issues/293/comments",
    "author": "IRCraziestTaxi",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2017-02-17T03:53:00Z",
        "body": "Are you using postgres? Yeah right now quoting is an issue and we need to figure out how to handle that properly. The problem is that query builder just helps you to create an sql query. You can create almost any kind of sql query in query builder. And the question is that if its possible to always know what needs to be quoted in this sql query and whats not (can we parse it and always find whats needs to be quoted and whats not)."
      },
      {
        "user": "IRCraziestTaxi",
        "created_at": "2017-02-17T03:57:31Z",
        "body": "Sorry, I should have specified. Yes, I am using postgres."
      },
      {
        "user": "IRCraziestTaxi",
        "created_at": "2017-02-17T03:58:30Z",
        "body": "I did discover that quoting column names that are not quoted in the table definition did not affect the query, which is why the thought crossed my mind that quoting could always be automatic."
      },
      {
        "user": "rightisleft",
        "created_at": "2017-02-17T16:44:26Z",
        "body": "I've seen this behavior as well. "
      },
      {
        "user": "pleerock",
        "created_at": "2017-02-24T09:33:32Z",
        "body": "@IRCraziestTaxi can you provide a code example where I can reproduce your issue? Also whats your own opinion on how orm should handle quotes in custom sql expressions passed to query builder? I need somebody who knows all aspects of sql and is it possible to understand where alias or some column/table name is used to automatically replace it in any kind of sql query. But I guess that its not possible."
      },
      {
        "user": "IRCraziestTaxi",
        "created_at": "2017-02-27T16:46:41Z",
        "body": "@pleerock I will work on a code sample. Any recommendations on delivery method? You want me to just send you a zip somehow or put it up on some site?\r\n\r\nIt's pretty simple to reproduce, for anybody curious - just create a model with some all-lower-case properties and some camel-cased properties, sync schema (Postgres), try to use (for example) OrderBy in QueryBuilder, and observe that an error is thrown if camel-cased property names are not double-quoted. You can see the reason why by observing your DB schema - the column names for camel cased properties on table definitions are double quoted since Postgres apparently can't handle capital letters without quotes. I know your time is valuable, so I will still work on that code sample.\r\n\r\nHonestly, I'm not a SQL expert, which is the biggest reason I use ORMs and was so excited to find this awesome Node/TS one (kudos again, seriously). I'm not sure if auto-quoting strings going into OrderBy, etc. would cause issues elsewhere, and there's still the issue of backwards-compatibility with existing code that already double quotes property names to mitigate the error that is thrown - checking for double quotes before automatically adding them would make the code heavier for sure. There may not be an extremely elegant solution without investigating aliases or something, but I'm not enough of a SQL expert to speculate on that."
      },
      {
        "user": "pleerock",
        "created_at": "2017-06-30T13:16:47Z",
        "body": "I need smallest possible reproduction example you can post it right here in github"
      },
      {
        "user": "NoNameProvided",
        "created_at": "2017-07-27T09:06:25Z",
        "body": "Here is an example: \r\n\r\n```ts\r\n@Entity()\r\nexport class Recipe {\r\n  @PrimaryGeneratedColumn()\r\n  public id: number;\r\n\r\n  @Column({ default: 0 })\r\n  public likesCount: number;\r\n}\r\n\r\n// then run\r\nthis.recipeRepository.createQueryBuilder('recipe')\r\n      .update(Recipe)\r\n      .where('recipe.id = :id', { id: 1 })\r\n      .set({ likesCount: () => '\"likesCount\" + 1'})\r\n      .execute();\r\n```\r\n\r\nThis will generates the following sql: \r\n\r\n```sql\r\nUPDATE \"recipe\" SET likesCount = \"likesCount\" + 1 WHERE recipe.id = 1;\r\n```\r\n\r\nWhat will throw the following error:\r\n\r\n```\r\nERROR:  column \"likescount\" of relation \"recipe\" does not exist\r\nLINE 1: UPDATE \"recipe\" SET likesCount = \"likesCount\" + 1 WHERE reci...\r\n                            ^\r\n```\r\n\r\nThe generated query should be: \r\n\r\n```sql\r\nUPDATE \"recipe\" SET \"likesCount\" = \"likesCount\" + 1 WHERE recipe.id = 1;\r\n```\r\n\r\nThe problem is there is no way to tell TypeORM to tell that I want to quote the keys of the object used in the  `set()` function."
      },
      {
        "user": "pleerock",
        "created_at": "2017-07-27T10:47:46Z",
        "body": "@NoNameProvided your issue is fixed and will be released in next version. However if author still have some example how to reproduce his issue - please let me know."
      }
    ]
  }
]