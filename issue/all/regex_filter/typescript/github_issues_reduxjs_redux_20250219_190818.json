[
  {
    "number": 1714,
    "title": "Dispatch a redux action from an external javascript module",
    "created_at": "2016-05-11T09:17:36Z",
    "closed_at": "2016-05-11T13:00:04Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/reduxjs/redux/issues/1714",
    "body": "Hi guys,\nI'm working on a react/redux application, which makes use of an external module (written in plain javascript):\n\n``` javascript\nmodule.exports = {\n    ...\n    // Some functions here..\n    someFunction () {\n        dispatch(setSomething());\n    }\n    ...\n};\n```\n\nI need to dispatch an action on the existing store, previously built and linked to the React application. \nWhat's the best way?\n\nThank you\n",
    "comments_url": "https://api.github.com/repos/reduxjs/redux/issues/1714/comments",
    "author": "rpnna",
    "comments": [
      {
        "user": "gaearon",
        "created_at": "2016-05-11T13:00:03Z",
        "body": "This is just JavaScript, so the answer is the same as with any JavaScript code.\nIf you need a module to have access to a function, pass that function to that module.\n\n``` js\nmodule.exports = {\n  someFunction (dispatch) {\n    dispatch(setSomething());\n  }\n};\n```\n\nor\n\n``` js\nmodule.exports = function (dispatch) {\n  return {\n    someFunction () {\n      dispatch(setSomething());\n    }\n  }\n};\n```\n\nFinally, you can (if you really want) put a store in a separate module as a singleton, but this makes testing and universal apps considerably harder.\n"
      },
      {
        "user": "rpnna",
        "created_at": "2016-05-11T15:19:07Z",
        "body": "@gaearon thanks, I also have solved this way, it was a fake problem..I really appreciate your work and this project.\n"
      }
    ]
  },
  {
    "number": 1713,
    "title": "accessing a prop found in either reducer",
    "created_at": "2016-05-11T07:35:22Z",
    "closed_at": "2016-05-11T13:25:25Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/reduxjs/redux/issues/1713",
    "body": "Hello,\n\nsorry if this has already been asked earlier , but i have a prop which can be mutated by 2 reducers. I pull the isFetching variable in my component like the below\n\n```\nfunction mapStateToProps(state){\n  const {errorMessage,isFetching} = state.signUp\n  const {isAuthenticated,username} = state.login;\n  return {\n    isAuthenticated,\n    errorMessage,\n    isFetching,\n    username\n  }\n}\n```\n\ni have two reducers\n\n```\nexport const signUp = (state={},action) => {\n  switch(action.type){\n    case SIGNUP_REQUEST:\n      return Object.assign({},state,{\n        isFetching: true\n      })\n    case SIGNUP_FAILURE:\n      return Object.assign({},state,{\n        isFetching:false,\n        // isAuthenticated: false,\n        errorMessage: action.message\n      })\n    default:\n      return state\n  }\n}\n\nexport const login = (state={isAuthenticated:false},action) => {\n  switch(action.type){\n    case LOGIN_REQUEST:\n      return Object.assign({},state,{\n        isFetching: true,\n        isAuthenticated: false\n      })\n    case LOGIN_SUCCESS:\n      return Object.assign({},state,{\n        isFetching:false,\n        isAuthenticated:true,\n        username: action.username\n      })\n    case LOGIN_FAILURE:\n      return Object.assign({},state,{\n        isFetching: false,\n        isAuthenticated: false,\n        errorMessage: action.message\n      })\n    default:\n      return state\n  }\n}\n```\n\nwhen i dispatch a loginRequest - the reducer turns isFetching to true. but the component still doesnt update because its looking at the isFetching variable only from the signUp Reducer.\n\nis there a way i can have the component look at both reducers for the isFetching variable?\n\nStack overflow suggested that i do this\n\n```\nconst isFetching = {signUp.isFetching || login.isFetching}\n```\n\nbut is there a better way i can structure my reducers.\n",
    "comments_url": "https://api.github.com/repos/reduxjs/redux/issues/1713/comments",
    "author": "Kannaj",
    "comments": [
      {
        "user": "gaearon",
        "created_at": "2016-05-11T13:25:25Z",
        "body": "``` js\nconst isFetching = signUp.isFetching || login.isFetching\n```\n\nlooks perfectly reasonable to me.\n"
      }
    ]
  },
  {
    "number": 1710,
    "title": "Difference between use mapDispatchToProps and not use ?",
    "created_at": "2016-05-10T03:55:00Z",
    "closed_at": "2016-05-10T12:40:47Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/reduxjs/redux/issues/1710",
    "body": "@gaearon Would you mind helping me to be clear about mapDispatchToProps.\nI have a example code like this:\n\n```\n\n// ----------------------- not use mapDispatchToProps -----------------------------\n//var onSubmit = (event) => {\n//   event.preventDefault()\n//   var email = event.target.elements[0].value\n//   var password = event.target.elements[1].value\n//   // const path = `/repos/${userName}/${repo}`\n//   store.dispatch(action.requestLogin({username:email,password:password}))\n//   // store.dispatch(action.receiveLogin({user{username:email,password:password,objectId:1,sessionToken:\"asdfg\"}}))\n// }\n\n// ----------------------- use mapDispatchToProps -----------------------------\nconst mapDispatchToProps = (dispatch) => {\n  return {\n    onSubmit: (event) => {\n      event.preventDefault()\n      var email = event.target.elements[0].value\n      var password = event.target.elements[1].value\n      dispatch(action.requestLogin({username:email,password:password}))\n    }\n  }\n}\n\nconst mapStateToProps = state => ({\n  // onSubmit: onSubmit,\n  error: state.login.error\n});\n\nvar LoginPage = ({ onSubmit,error }) => {\n  return (\n`<div className=\"row\">\n      <div className=\"col-md-12\">\n        <LoginFormComponent className=\"account-form text-center\" title=\"Log in to Portal\" error={error !== null ? error : \"\"} onSubmit={onSubmit}/>\n      </div>\n    </div>`\n  )\n}\n\nexport default connect(mapStateToProps,mapDispatchToProps)(LoginPage)\n\n//-----------------------------and this is the reducer -------------------------------------\nexport default function login(state = {\n  logedAt: null,\n  isLogging: false,\n  error: null,\n  data: {},\n}, action) {\n  switch (action.type) {\n    case types.LOGIN_REQUEST:\n      return update(state, {\n        isLogging: { $set: true },\n        error: { $set: null }\n      });\n    case types.LOGIN_SUCCESS:\n      return update(state, {\n        data: { $set: action.body },\n        isLogging: { $set: false },\n        logedAt: { $set: action.logedAt },\n      });\n    case types.LOGIN_FAILURE:\n      return update(state, {\n        logedAt: { $set: null },\n        error: { $set: action.error },\n      });\n    default:\n      return state;\n  }\n}\n\n//-----------------------------and the middleware -------------------------------------\nexport function login({dispatch, getState}){\n  return next => action => {\n      return callLogin().then(\n        response => dispatch(Object.assign({},{\n            body: response,\n            logedAt: Date.now(),\n            type: LOGIN_SUCCESS,\n            isFetching: false,\n            isAuthenticated: true,\n            // callLogin: callLogin,\n          })),\n        error => dispatch(Object.assign({} ,{\n            error: error.response.text,\n            type: LOGIN_FAILURE,\n            isFetching: false,\n            isAuthenticated: false,\n            // callLogin: callLogin,\n        }))\n      );\n    }\n}\n\n```\n\nWhen I don't use the mapDispatchToProps, I just can dispatch the action for type:LOGIN_REQUEST but not the LOGIN_SUCCESS,LOGIN_FAILURE, when use mapDispatchToProps, it work. could you explain for me \nThanks a lot.\n",
    "comments_url": "https://api.github.com/repos/reduxjs/redux/issues/1710/comments",
    "author": "redkyo017",
    "comments": [
      {
        "user": "gaearon",
        "created_at": "2016-05-10T12:40:47Z",
        "body": "Hi! This is an issue tracker for Redux. StackOverflow is a more appropriate venue for usage questions because questions and answers are more easily searchable there. I’ll close this but please feel free to post a link to a StackOverflow question in this thread.\n"
      }
    ]
  },
  {
    "number": 1599,
    "title": "Please help me understand if / how I can use Redux",
    "created_at": "2016-04-11T08:27:20Z",
    "closed_at": "2016-07-10T17:52:01Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/reduxjs/redux/issues/1599",
    "body": "Hello All!\n\nI have recently discovered ReduxJS and am trying to understand,whether or not I can use it. \nI have an app where I would dispatch \"actions\" (invoke a function) that would use some logic to in a \"reducer\" (said function) to mutate some global \"state\" (plain JS object).\nSince Redux seems like a more mature and interesting implementation (sans the mutability) for the same issue, I thought I'd give it a try.\n\nHowever, in my case some of the logic in my \"reducer\" relies on the state of a DOM node, as far as I can see this violates the concept of a \"pure function\", since it relies on something outside the scope of the state. Even if I pass along that DOM node with my \"action\" it might violate the concept\nof \"replayability\" of said action, since every dispatch might have a different outcome depending on the state of that DOM node.\nI would be happy to know if this can somehow fit inside the Redux box.\n\nAnother thing is the issue of mutability. I fully understand the benefits of immutability in large async applications, where multiple sources might affect some global state.\nIn my case however, I have one synchronous source, changing one global state, which causes me to doubt the benefits of making my state immutable.\nCould anyone shed some light on this matter in the context of a synchronous stream of actions?\n\nI know Redux isn't for everyone and it might not even be a match for my case but I still would very much like to learn and expand my knowledge on these subjects and would love to hear the opinions of some of the more experienced developers here.\n\nThank you very much for any help you can offer.\n",
    "comments_url": "https://api.github.com/repos/reduxjs/redux/issues/1599/comments",
    "author": "dimitryvolkov",
    "comments": [
      {
        "user": "gaearon",
        "created_at": "2016-04-11T19:32:33Z",
        "body": "> However, in my case some of the logic in my \"reducer\" relies on the state of a DOM node\n\nCan I ask why this is the case?\n"
      },
      {
        "user": "dimitryvolkov",
        "created_at": "2016-04-12T07:23:54Z",
        "body": "Thank you for your prompt response!\nIt's is actually one of several edge cases I have.\n\nFor the most part, the state can be derived from the previous state without any external side effects, but in my case I have found that referring to the DOM state might short-circuit most of the logic of my reducer and save me some time.\n\nI have considered extracting that code into the action creator, passing along that dom state along with that action, that would cause the reducer to be indeed a \"pure function\" (according to my understanding) since the same input will always produce the same output state, but I am not sure if that is not cheating, since the action creator is now not entirely a pure function (not sure if that is even a must in Redux's world).\n\nAlso, though the reducer is now \"pure\" it still relies on some external information passed along with the action and not only the previous state, which I am not sure is the way to go.\n\nCan you shed some light?\n"
      },
      {
        "user": "adamdonahue",
        "created_at": "2016-04-12T15:55:00Z",
        "body": "> I have found that referring to the DOM state might short-circuit most of the logic of my reducer and save me some time.\n\nThis sounds suspiciously like premature optimization.  So are you saying you _can_ use Redux as is but that you want to somehow improve rendering by accessing or manipulating the DOM directly?\n"
      },
      {
        "user": "dimitryvolkov",
        "created_at": "2016-04-12T16:02:20Z",
        "body": "Thank you for your answer!\n\nIt might be a minor optimization, though it isn't premature since I have tested the effects of it and found it effective enough to use it.\n\nRegarding your second comment, I have no intention in manipulating the DOM (directly or indirectly), but some information found on the current state of the DOM might assist me in my logic so I chose to use it instead of spare it (that and the aforementioned minor performance boost).\n\nCould you perhaps assist me in understanding if the choice of moving said logic to the action creator fits better in the model? As far as I can see, my looking at the DOM is not different than retrieving some information asynchronously from some remote resource via fetch(), but still I am unsure if it violates some concept Redux is trying to preserve.\n"
      },
      {
        "user": "markerikson",
        "created_at": "2016-04-12T16:10:12Z",
        "body": "@dimitryvolkov : action creators absolutely _do not_ have to be pure, and in fact, are usually where most of an app's \"impurities\" live.  \n\nA typical Redux code flow would have a component handling any needed DOM interaction, extracting the necessary data from a DOM event or element, and calling an action creator with all that data.  The action creator usually uses something like `redux-thunk` to enable additional logic and dispatching, and would handle stuff like AJAX requests.  However, while an action creator is often not \"pure\" in the strict side effects sense, it usually does not deal with the DOM directly, instead relying on what raw data it needs to be passed in as parameters.\n\nCan you give some examples of what DOM state you actually are trying to refer to, and what the specific use cases are?  Might help use advise you better.\n"
      }
    ]
  },
  {
    "number": 1421,
    "title": "redux load local storage at first",
    "created_at": "2016-02-18T10:06:26Z",
    "closed_at": "2016-02-18T14:18:37Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/reduxjs/redux/issues/1421",
    "body": "I have a react app like where I have `App.js` which includes my `Headers` and `Footers` ..\n\nIn there I am storing my `state` to local storage.. After storing I can retrieve it .. \n\nBut I am having problem on loading it .. In my browser when I do `localstorage['key']` it gives me the data but I am unable to load after browser refresh.. \n\nWhere should I load it first ? \n\nI have `Root.js` :\n\n```\n`class Root extends Component {\n  render() {\n    const { store } = this.props\n    return (\n      <Provider store={store}>\n          <ReduxRouter />\n      </Provider>\n    )\n  }\n}\n\nRoot.propTypes = {\n  store: PropTypes.object.isRequired\n}\n\nexport default Root`\n```\n\nand `index.js` at outer level :\n\n```\n`const store = configureStore()\n\n\nrender(\n\n    <Root store={store} />,\n  document.getElementById('root')\n)`\n```\n\nWhere should I load my `localStorage` ?\n\nNeed help . I need to know what is called first in react so that I can make a call to load `localStorage` there .. If it is not bad idea\n",
    "comments_url": "https://api.github.com/repos/reduxjs/redux/issues/1421/comments",
    "author": "aaeronn",
    "comments": [
      {
        "user": "joncys",
        "created_at": "2016-02-18T13:19:11Z",
        "body": "Do you follow the pattern of allowing initial state to be set in the `configureStore` method?\n\nIf so, you could just pass it inside the method call as in\n`const store = configureStore(localStorage.getItem('key');`.\n\n`index.js` is being loaded first in your example and it bootstraps the whole app by rendering out the `Root` component contained within `Root.js`.\n"
      },
      {
        "user": "gaearon",
        "created_at": "2016-02-18T14:18:37Z",
        "body": "Hi, thanks for posting.\n\nThis is an issue tracker for Redux. Please ask usage questions on a dedicated Q&A site like StackOverflow. If we answer your question here, it will get lost (because GitHub search is not very well designed), and somebody is going to ask it again and again. On the other hand, on StackOverflow, you will get an answer that will serve as the definitive answers for everybody else in the future.\n\nFeel free to post a link to your StackOverflow question, and I’ll do my best to reply.\n"
      }
    ]
  },
  {
    "number": 1390,
    "title": "Component Loading",
    "created_at": "2016-02-11T18:33:07Z",
    "closed_at": "2016-02-11T20:23:53Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/reduxjs/redux/issues/1390",
    "body": "I'm curious about best practices for my use-case (which I believe is probably very common). It's combination of `react`, `redux`, `react-router` but I believe the discussion is best suited for `redux`\n\nDocumentation and guides are very vague when it comes to component-to-component communication (of a non parent-child nature). Imagine using `react-router` where the overall page is derived of nested layout components such as\n\n``` js\nReactDOM.render((\n    <Router>\n        <Route component={DefaultLayout}>\n            <Route path=\"foo\" component={FooLayout}>\n                <Route path=\"products\" component={Products}>\n                <Route path=\"users\" component={Users}>\n                <Route path=\"widgets\" component={Widgets}>\n            </Route>\n        </Route>\n    </Router>\n), document.getElementById('app'))\n```\n\n`DefaultLayout` looks like this:\n\n``` js\nexport default React.createClass({\n    render: function() {\n        return (\n            <div className=\"default-layout\">\n                <div class=\"receive-any-component\"></div>\n                <main>\n                    {this.props.children}\n                </main>\n            </div>\n        )\n    }\n})\n```\n\nFor the sake of this example, `FooLayout` (loaded into `this.props.children`) can be any sub layout you want to imagine. \n\nAll three routes: `/products`, `/users`, or `/widgets` have a button in their component. When clicked, it will load a whole new component into the `DefaultLayout`'s `<div class=\"receive-any-component\"></div>` section. For example\n\n`Products` component:\n\n``` js\nimport store from 'path/to/store'\n\nexport default React.createClass({\n    render: function() {\n        return (\n            <div className=\"product\">\n                Lorem ipsum...\n                <button onClick={this.onClick}>Click Me</button>\n            </div>\n        )\n    },\n    onClick: function() {\n        // There are several ways to have a component loaded DefaultLayout's\n        // div.receive-any-component\n    }\n})\n```\n\nThis whole example is over simplified. I'm using `react-redux` in the real thing. Official react docs only say one small bit on this type of use-case:\n\n> For communication between two components that don't have a parent-child relationship, you can set up your own global event system. Subscribe to events in componentDidMount(), unsubscribe in componentWillUnmount(), and call setState() when you receive an event. Flux pattern is one of the possible ways to arrange this.\n\nSo, I understand that I can use Redux to dispatch info whereby `DefaultLayout` is subscribed, but I need to load a whole component into `DefaultLayout`. It would seem to me there are two basic options, neither of which I feel are correct.\n## Option One\n\nHave our `Product` component dispatch the component we want to load:\n\n``` js\nimport store from 'path/to/store'\nconst componentToLoad = (\n    <Whatever />\n)\n\nexport default React.createClass({\n    render: function() {\n        return (\n            <div className=\"product\">\n                Lorem ipsum...\n                <button onClick={this.onClick}>Click Me</button>\n            </div>\n        )\n    },\n    onClick: function() {\n        store.dispatch({\n            type: 'LOAD',\n            component: componentToLoad\n        })\n    }\n})\n```\n\nUltimately, I'd like the `DefaultLayout` to be unaware of what components it's loading, so this solution works out in that regards. But sending a component into `redux` just seems so wrong, but it works.\n## Option Two\n\nInstead of dispatching a component, dispatch some state that indicates which component should be loaded. In this case, it would seem that `DefaultLayout` would have to `import` every possible component it might need to load (which in my real usecase is many), then subscribe to our state and use a switch statement to determine which one of our loaded components should be placed into `.receive-any-component`. This feels better from the `redux` end but feels crappy that `DefaultLayout` is aware of every possible component that it might need to load.\n\nI'm not new to JS, but somewhat new to React/Redux. What am I missing?\n\nAnd I apologize this question is so long. It's difficult for me to describe this any other way\n",
    "comments_url": "https://api.github.com/repos/reduxjs/redux/issues/1390/comments",
    "author": "bradwestfall",
    "comments": [
      {
        "user": "gaearon",
        "created_at": "2016-02-11T20:23:52Z",
        "body": "It is advisable that both actions and state are always serializable. Therefore putting a component into the action doesn’t seem like the correct way, and I would encourage you not to do that.\n\n> Instead of dispatching a component, dispatch some state that indicates which component should be loaded. In this case, it would seem that DefaultLayout would have to import every possible component it might need to load (which in my real usecase is many), then subscribe to our state and use a switch statement to determine which one of our loaded components should be placed into .receive-any-component. This feels better from the redux end but feels crappy that DefaultLayout is aware of every possible component that it might need to load.\n\nThis is exactly what I would suggest. I don’t think at all it is bad. You can have a separate module that does this.\n\n``` js\nimport Button from './Button'\nimport Checkbox from './Checkbox'\n\nfunction resolveComponent(componentId) {\n  switch (componentId) {\n  case 'BUTTON':\n    return Button\n  case 'CHECKBOX':\n    return Checkbox\n  }\n}\n```\n\nand in your component:\n\n``` js\nfunction mapStateToProps(state) {\n  let Type = resolveComponent(state.componentId)\n  let children = <Type />\n  return { children }\n}\n```\n\nIf your bundler supports code splitting, you can even make `resolveComponent` dynamically load components and return a promise so you can show some default view while component is being loaded.\n"
      },
      {
        "user": "bradwestfall",
        "created_at": "2016-02-11T21:16:32Z",
        "body": "Thanks, I can massage this into my real example\n"
      }
    ]
  },
  {
    "number": 1389,
    "title": "Clear all listeners",
    "created_at": "2016-02-11T15:54:51Z",
    "closed_at": "2016-02-11T15:56:01Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/reduxjs/redux/issues/1389",
    "body": "Hello, is it possible to remove all listeners from a store while keeping the state untouched?\n\nThat would be helpful within an Angular application: keeping the store as a separate module is useful to have the application state available everywhere. But everytime a controller that calls a subscription is istantiated, the listener stack grows with the same listener (e.g. after a logout/login)\n\nRight now the methods exposed by the Redux engines are getState, subscribe, dispatch and replaceReduce, IMHO it would be useful to have a method like clear\n\n```\nfunction clear() {\n    listeners = [];\n}\n\n...\n\nreturn {\n    ...\n    clear: clear\n}\n```\n\nThank you\nCheers \n",
    "comments_url": "https://api.github.com/repos/reduxjs/redux/issues/1389/comments",
    "author": "sickOscar",
    "comments": [
      {
        "user": "gaearon",
        "created_at": "2016-02-11T15:56:01Z",
        "body": "> But everytime a controller that calls a subscription is istantiated, the listener stack grows with the same listener (e.g. after a logout/login)\n\nWhatever piece of code is calling `subscribe()` is responsibly for unsubscribing later.\n\n``` js\nconst unsubscribe = store.subscribe(() => { ... })\n\n// later\nunsubscribe()\n```\n"
      }
    ]
  },
  {
    "number": 1381,
    "title": "react redux calling async method and dispatch on loop",
    "created_at": "2016-02-10T08:56:22Z",
    "closed_at": "2016-02-10T16:32:23Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/reduxjs/redux/issues/1381",
    "body": "Lets say I am calling a dispatch method in my actions :\n\n``` js\nreturn dispatch(add_data(data)).then(function(response){console.log(\"Done\")}\n```\n\nand my `add_data` method looks like:\n\n``` js\nexport function add_data(data){\n  return (dispatch, getState) => {\n    for(var i in data){\n      var data = {'url': data[i]}\n      return dispatch(myApi({url: \"some_url\", method: \"POST\", data: data,}\n        )).then(response => {\n        console.log(response)\n        return response.json()\n      }).then(response => {\n        console.log(response)\n        return dispatch({response, type: types.ADD_DATA})\n      })\n    }\n  }\n}\n```\n\nIt is working for only first data. Only first data is dispatched. It is inside loop and I expect it to dispatch for all the data from loop.\n\nIf I dont user `return` in my dispatch it does not wait for function to complete\n\nHow can I achieve this ?\n\nThank you\n",
    "comments_url": "https://api.github.com/repos/reduxjs/redux/issues/1381/comments",
    "author": "aaeronn",
    "comments": [
      {
        "user": "danielepolencic",
        "created_at": "2016-02-10T09:15:09Z",
        "body": "I guess you need to wait for all the promises to be resolved before calling the `return`. At the moment, once you're in the first iteration of the loop you hit `return` and immediately get out of the function.\n\nDispatch actions are supposed to be plain objects, but yours are promises. Is there something I'm missing out?\n"
      },
      {
        "user": "aaeronn",
        "created_at": "2016-02-10T09:27:05Z",
        "body": "Thank you I will try this out\n"
      },
      {
        "user": "aaeronn",
        "created_at": "2016-02-10T11:13:22Z",
        "body": "Thank you that was so much helpful\n"
      }
    ]
  },
  {
    "number": 1267,
    "title": "How to store streaming data ?",
    "created_at": "2016-01-24T23:09:15Z",
    "closed_at": "2016-01-25T02:30:55Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/reduxjs/redux/issues/1267",
    "body": "I writing an application which receives real time updates,the updates are received every second,  this data is displayed in multiple charts. \n\nShall It store the data in redux store (state) ?\n\nI was considering the option to just store the filters (state) in the the store, and use and external object to host the data.\n\nHow would you do it ?\n\nAny help is really appreciated :)\n",
    "comments_url": "https://api.github.com/repos/reduxjs/redux/issues/1267/comments",
    "author": "djleon2001",
    "comments": [
      {
        "user": "gaearon",
        "created_at": "2016-01-25T02:30:55Z",
        "body": "Storing data in the state should be fine.\n"
      }
    ]
  },
  {
    "number": 1260,
    "title": "Nested Entities Note on tutorial 3.1 Async Actions",
    "created_at": "2016-01-21T18:51:46Z",
    "closed_at": "2016-01-21T18:53:24Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/reduxjs/redux/issues/1260",
    "body": "Hi @gaearon (& others),\n\nI'm a bit confused about the Note on Nested Entities in the tutorial-> 3.1 Async Actions.\nYou mention to consider normalizing data as in:\n\nExample1:\n\n``` javascript\nentities: {\n    posts: {\n        42: {id: 42, title: 'A title'},\n        100: {id: 100, title: 'Other title'}}\n},\npostsByReddit: {\n    reactjs: {\n        items: [ 42, 100 ]\n    }\n}\n```\n\nvs.:\n\nExample2:\n\n``` javascript\npostsByReddit: {\n    reactjs: {\n    items: [ { id: 42, title: 'A title'}, { id: 100, 'Other title'} ]\n    }\n}\n```\n\nThis is fine. However, after I read it, I thought some of the magic was lost. From my limited understanding (newbie here) one of the nice aspects about Redux is how you can easily make a change in state to automatically update components that depend on it in React (using connect & select).\nAlso, updates are efficient for using an immutable state which boosts state change comparisons.\n\nSo, say I have a component that is connected to postsByReddit. Now imagine I update id:100 title to 'Yet another title'. If I do so in Example2, then a new object will be set on the second position of the items' array and the component will be rendered.\n\nHowever, I believe some extra stuff has to be done when using Example1. Say I change entities->posts->100. The second element in the array postsByReddit->reactjs->items is still a scalar (the id) which does not change.\n\nI guess the question is: what is the preferred method to inject entities's dependencies to different parts of the state?\n\nIs it part of the \"select\" to convert id's to object pointers?\n",
    "comments_url": "https://api.github.com/repos/reduxjs/redux/issues/1260/comments",
    "author": "landabaso",
    "comments": [
      {
        "user": "gaearon",
        "created_at": "2016-01-21T18:53:24Z",
        "body": "> Is it part of the \"select\" to convert id's to object pointers?\n\nYes, please check out `shopping-cart` in this repo for an example of that.\n\nThe reason we encourage you to normalize your data is to avoid duplication. When data is duplicated in several places of the state tree, it's no longer easy to edit it locally. How do you update a title of item that may be deeply nested in several places of the state graph?\n"
      }
    ]
  },
  {
    "number": 1245,
    "title": "Question: Return a promise from an action creator and use it in a component",
    "created_at": "2016-01-16T00:55:30Z",
    "closed_at": "2016-01-16T01:07:00Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/reduxjs/redux/issues/1245",
    "body": "I see that I can return anything from an action creator, and `dispatch` returns that value.\n\nDoes it make sense to use it in with a returned promise? Any gotchas here?\n\n``` js\n// action creator:\nexport function signIn(email, password) {\n  return dispatch => {\n    return client.signIn(email, password)\n      .then(user => dispatch({ type: 'USER_SIGN_IN_SUCCESS', user })\n      .catch(err => dispatch({ type: 'USER_SIGN_IN_ERROR', errorMessage: err.message }))\n  }\n}\n\n// component\n@connect(..., { signIn })\nclass SignInContainer extends Component {\n  // ...\n\n  onSubmit() {\n    this.props.signIn(e, p)\n     .then(() => this.dispach(routeActions.replace('/user-profile')))\n  }\n}\n```\n",
    "comments_url": "https://api.github.com/repos/reduxjs/redux/issues/1245/comments",
    "author": "elado",
    "comments": [
      {
        "user": "gaearon",
        "created_at": "2016-01-16T01:07:00Z",
        "body": "Sure, feel free to do that.\n"
      }
    ]
  },
  {
    "number": 1241,
    "title": "Patching connect function",
    "created_at": "2016-01-15T07:53:05Z",
    "closed_at": "2016-01-15T20:09:57Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/reduxjs/redux/issues/1241",
    "body": "I have certain set of mixins and other default props and dispatches that I want to map to all the dumb components via connect. Is there a way to do this with the framework other than monkey-patching the connect function? \n",
    "comments_url": "https://api.github.com/repos/reduxjs/redux/issues/1241/comments",
    "author": "udnisap",
    "comments": [
      {
        "user": "rossipedia",
        "created_at": "2016-01-15T16:30:06Z",
        "body": "What do you mean by \"monkey-patching the connect function\"? I'm not sure that's necessary. If I understand you correctly, you could just have a common connector function for your dumb components. The great thing about the design of react-redux is that it's just plain javascript, built on functional principles. \n\nSince `connect` returns a function that you apply to your components, you can just have a module called `dumbConnector.js` that just exports the result of a `connect` call, and you can apply that to whatever components you want.\n"
      },
      {
        "user": "gaearon",
        "created_at": "2016-01-15T20:09:57Z",
        "body": "This is a usage question. Please ask it on StackOverflow.\nThis is not a support forum—it's an issue tracker.\n\nThis question is also not about Redux—it's about React Redux library.\nIt's unrelated to this repo.\n\nWhen you ask it on StackOverflow please make sure to add more specifics because it's somewhat vague. Cheers!\n"
      }
    ]
  },
  {
    "number": 1222,
    "title": "How to store list/single element in Redux?",
    "created_at": "2016-01-09T22:45:48Z",
    "closed_at": "2016-01-12T22:03:16Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/reduxjs/redux/issues/1222",
    "body": "I'm using Redux for some time now but still I'm not sure how data in reducers should be stored.\n\nFor instance I would like to have list of users, from where I can choose one of them and get additional data.\n\nInformation needed for list is only id and name, and showing details of one user I need more info like city, phone number, etc.\n\nI begin with reducer that store list:\n\n``` javascript\n    UsersReducer:\n    [{id: 1, name: 'John'},\n    {id: 2, name: 'Will'},\n    {id: 5, name: 'George'}]\n```\n\nThen I load details for one of the users and here is my question: how and where should I put them?\n\nShould I expand UsersReducer, so it would look like:\n\n``` javascript\n    UsersReducer:\n    [{id: 1, name: 'John'},\n    {id: 2, name: 'Will', city: 'London', phone: 123456789},\n    {id: 5, name: 'George'}]\n```\n\nAnd in React extract from an array this one user?\n\nOr perhaps I should leave old reducer and create new one for storing single user:\n\n``` javascript\n    UsersReducer:\n    [{id: 1, name: 'John'},\n    {id: 2, name: 'Will'},\n    {id: 5, name: 'George'}]\n    UserReducer:\n    {id: 2, name: 'Will', city: 'London', phone: 123456789}\n```\n\nAnd in React extract data from UserReducer?\n\nOr both ways aren't correct and there is other idea to store data in Redux?\n",
    "comments_url": "https://api.github.com/repos/reduxjs/redux/issues/1222/comments",
    "author": "michalg42",
    "comments": [
      {
        "user": "seph-m",
        "created_at": "2016-01-10T01:30:03Z",
        "body": "You could make a userDetailsById reducer that handles the details.  Then just get the pieces of data you need in your smart component.\n\nSo usersById reducer would look like this:\n\n```\nUsersReducer:\n  usersById: {\n      1: { name: 'whatever'},\n      2: { name: 'whatever 2'}\n   }\n```\n\nand the userDetailsById reducer would look like this:\n\n```\nuserDetailsByIdReducer:\n{\n   1: {details stuff for user 1},\n   2: {details stuff for user 2}\n}\n```\n\nThen you'd have a selectedUserReducer that just stores the id of the selected user.  Then you'd compose all of these together to make one store.\n\nYou could always just make it all part of the same users reducer if you don't need or want the separation.\n\n```\nUsersReducer:\n{\n   usersById: {\n      1: { name: 'whatever'},\n      2: { name: 'whatever 2'}\n   },\n   userDetailsById: {\n     1: { user details 1},\n     2: { user details 2}\n   },\n   selectedUserId: 1\n}\n```\n\nNote that I'm using object hashes because it makes dealing with the entities simpler as you no longer have to do a lookup when you want to get at an entity by id.  In general I start with things as part of the same reducer and then break them into different reducers when it makes sense or when complexity dictates.\n"
      },
      {
        "user": "gaearon",
        "created_at": "2016-01-12T22:03:16Z",
        "body": "What @smastous described is the approach we suggest.\n"
      }
    ]
  },
  {
    "number": 1064,
    "title": "Namespacing action creators",
    "created_at": "2015-11-23T22:32:53Z",
    "closed_at": "2015-11-23T23:17:12Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/reduxjs/redux/issues/1064",
    "body": "I've been able to easily create namespaced bits of my store (e.g. to track the state of a single UI element) using `combineReducers`:\n\n```\nlet topLevelReducers = {\n    aTopLevelReducer: function() { /* Reducer Function */ },\n    namespacedReducers: Redux.combineReducers(objectOfReducersToNamespace)\n}\n```\n\nIt's not very easy to do this with action creators using the standard API, since `bindActionCreators` is expecting a flat object containing only functions.\n\nIt doesn't look like there's a way to get `bindActionCreators` to recursively bind any child objects it finds inside the object it's passed. Is there a way of doing this in the standard Redux API already?\n",
    "comments_url": "https://api.github.com/repos/reduxjs/redux/issues/1064/comments",
    "author": "Zacqary",
    "comments": [
      {
        "user": "gaearon",
        "created_at": "2015-11-23T23:17:12Z",
        "body": "There's no standard way to do this. It might look like this:\n\n``` js\nimport { bindActionCreators } from 'redux';\n\nexport default function bindActionCreatorsDeep(actionCreators, dispatch) {\n  return Object.keys(actionCreators).reduce((result, key) => {\n    if (!actionCreators[key]) {\n      return result;\n    }\n    switch (typeof actionCreators[key]) {\n    case 'object':\n      result[key] = bindActionCreatorsDeep(actionCreators[key], dispatch);\n      break;\n    case 'function':\n      result[key] = bindActionCreators(actionCreators[key], dispatch);\n      break;\n    default:\n      break;\n    }\n    return result;\n  }, {});\n}\n```\n\nWe won't include this in core, but if you decide to publish it as a module, let us know!\n"
      }
    ]
  },
  {
    "number": 1059,
    "title": "The case for e.g. immutable.js",
    "created_at": "2015-11-20T10:29:05Z",
    "closed_at": "2015-11-20T13:24:57Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/reduxjs/redux/issues/1059",
    "body": "I'm having trouble understanding pulling in something like immutable.js to turn your state tree immutable instead of just having some sort of middleware that clones the current state before dispatching the action. \n\nCan someone please enlighten me? =)\n",
    "comments_url": "https://api.github.com/repos/reduxjs/redux/issues/1059/comments",
    "author": "marreman",
    "comments": [
      {
        "user": "simplesmiler",
        "created_at": "2015-11-20T10:35:29Z",
        "body": "@marreman better asymptotic memory use and simpler equality checks, I guess.\n"
      },
      {
        "user": "gaearon",
        "created_at": "2015-11-20T13:24:57Z",
        "body": "You want to use ImmutableJS if you like its API and if your data is large and oft-changing. Re-creating large arrays and objects is costly, and Immutable solves this by structural sharing.\n\n> instead of just having some sort of middleware that clones the current state before dispatching the action\n\nThat would be terribly inefficient (assuming you want to do this in production too). If you don't do this in production, then you have different behavior in dev and prod, which is also problematic because it's hard to debug production issues.\n"
      }
    ]
  },
  {
    "number": 1047,
    "title": "Containers as Component's Children",
    "created_at": "2015-11-17T18:46:19Z",
    "closed_at": "2015-11-17T18:47:25Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/reduxjs/redux/issues/1047",
    "body": "Hello.\n\nIt's actually not a Redux question, sorry if I shouldn't ask it here.\n\nFor components that need to interact with the DOM I like to create it as containers.\nFor example, I have a `<Grid />` stateless function component and a `<ResponsiveGridContainer />` class component that does things like `$(window).on('resize')`.\n\nI want to know if it's a bad practice to use containers as component children, for example:\n\n``` jsx\nconst MyAwesomePanel = ({ title }) => (\n  <div className=\"panel\">\n    <h1>{title}</h1>\n    <div className=\"panel-body\">\n      <ResponsiveGridContainer>\n        <ColumnA />\n        <ColumnB />\n      </ResponsiveGridContainer>\n    </div>\n  </div>\n);\n```\n\nThank you.\n",
    "comments_url": "https://api.github.com/repos/reduxjs/redux/issues/1047/comments",
    "author": "hnordt",
    "comments": [
      {
        "user": "gaearon",
        "created_at": "2015-11-17T18:47:25Z",
        "body": "I don't see any problem with this.\nPlease, refrain from asking usage questions (not even Redux in this case) on the Redux issue tracker.\nThanks!\n"
      }
    ]
  },
  {
    "number": 1025,
    "title": "Which Action Should Be Processed by Which Middleware?",
    "created_at": "2015-11-12T15:18:08Z",
    "closed_at": "2015-11-12T15:21:47Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/reduxjs/redux/issues/1025",
    "body": "This is a very complicated question.\n\nI have two middleware, one is the thunkMiddleware, and one is like below:\n\n``` javascript\nexport default function clientMiddleware(client) {\n  return next => action => {\n    // This means that the action is a function and with one argument, which is of client's type.\n    if (typeof action === 'function' && action.length === 1) {\n      return next(action(client))\n    }\n    next(action)\n  }\n}\n```\n\nAnd the action dispatching is like this:\n\n``` javascript\n// action creator\nfunction loadUserInfo(userId) {\n  return (client) => {\n    return {\n      type: 'LOAD_USER_INFO',\n      promise: client.fetch(userId) // this method should return a Promise\n    }\n  }\n}\n\nstore.dispatch(loadUserInfo('tom'))\n```\n\nloadUserInfo('tom') returns a new function (It is the action here.) which carries one parameter, but my clientMiddleware and thunkMiddleware can both process this kind of action and cannot distinguish them. But the two middleware are mutually exclusive.\n\nThis is real an extreme case, my question is that, how can I have some graceful way to determine which middleware can process the action. Sometimes I may not have enough information.\n",
    "comments_url": "https://api.github.com/repos/reduxjs/redux/issues/1025/comments",
    "author": "tangrui",
    "comments": [
      {
        "user": "gaearon",
        "created_at": "2015-11-12T15:21:47Z",
        "body": "Indeed, these middleware are incompatible because they both attempt to “interpret” functions. Therefore you shouldn't mix them. It's probably wiser to embed the functionality of the thunk middleware into the client middleware. By this point you're customizing Redux pretty heavily so it's best to do this explicitly.\n"
      },
      {
        "user": "tangrui",
        "created_at": "2015-11-13T01:09:52Z",
        "body": "This means that if I have installed many middleware in my project, I should pay attention to the compatibility of them.\n\nBut if I import other's store enhancer (I'd like to treat it as a black box.) and inject my own middleware, it's really hard for me to design the middleware. I have to know all of the action patterns the store enhancer's middleware chain consumed, and design my own carefully to prevent incompatibility.\n\nThank you! I'll think about it again.\n"
      },
      {
        "user": "gaearon",
        "created_at": "2015-11-13T01:25:00Z",
        "body": "Third party store enhancers shouldn't inject their own middleware that changes behavior so significantly. It's the design problem with them—they are probably trying to do too much. \n\nBoth middleware and especially store enhancers are powerful extension mechanisms. They should be used sparingly and with caution. They add indirection, and we assume the user is cautious to not add too much indirection.\n"
      },
      {
        "user": "tangrui",
        "created_at": "2015-11-13T01:34:46Z",
        "body": "I see that, it's really a design problem.\n\nThank you!\n"
      }
    ]
  },
  {
    "number": 1000,
    "title": "Mocking nested smart components with mocha",
    "created_at": "2015-11-03T21:27:00Z",
    "closed_at": "2015-11-03T21:34:11Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/reduxjs/redux/issues/1000",
    "body": "Hi,\n\nI'm trying to test a \"smart\" connected component that has another connect'ed child inside.\nPreparing a store for the test and providing it directly\n\n``` js\nTestUtils.renderIntoDocument(\n    <SmartParent store={store} />\n);\n```\n\nand SmartParent has `<SmartChild />` in it that throws an exception like `Either wrap the root component in a <Provider>, or explicitly pass \"store\"...`\n\nI know there's `rewire`, but I couldn't manage babel\\webpack\\karma\\rewire setup easily, so I went with making the `SmartChild` dumb for now. But I really would like to figure testing thing out.\nAny hints on this? Maybe some working examples?\n\nThanks!\n",
    "comments_url": "https://api.github.com/repos/reduxjs/redux/issues/1000/comments",
    "author": "gothy",
    "comments": [
      {
        "user": "gaearon",
        "created_at": "2015-11-03T21:34:11Z",
        "body": "``` js\nTestUtils.renderIntoDocument(\n  <Provider store={store}>\n    <SmartParent />\n  </Provider>\n);\n```\n"
      },
      {
        "user": "gothy",
        "created_at": "2015-11-03T22:07:33Z",
        "body": "Thanks!\n\nps. That was easy... good sign I need to have some rest :)\n"
      },
      {
        "user": "markerikson",
        "created_at": "2016-02-24T04:01:26Z",
        "body": "Followup observation: the wrapper components generated by `connect()` do support taking `store` as a prop, which seems like it would be an alternate approach to passing it in to a smart component.  Also, it looks like the Enzyme library supports defining the context for a component being tested.\n"
      }
    ]
  },
  {
    "number": 967,
    "title": "Best way to design a Class which contains some isomorphic code ?",
    "created_at": "2015-10-28T18:56:15Z",
    "closed_at": "2015-10-28T19:00:23Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/reduxjs/redux/issues/967",
    "body": "I create a class \"Locale\" to manage i18n. I need it on the client and server side.\nSome methods must work everywhere whilst others are specific to a side.\nFor instance:\nOn server a \"load\" method to find a language resource locally.\nOn the client side, a \"fetch\" method to make HTTP req for new lang template or a \"translate\" method to handle pluralization case.\n\nWhat do you think is the best way to design it ?\n\n-> With 2 separeted Locale class files, one for each side.\n-> With an inheritance ? Where shared code base goes to the parent and specific code for each side on 2 children classes.\n-> With a more 'isomorphic' approach' like this:\n\n``` javascript\nexport default class Locale{\n  /* \n    shared code base \n  */\n}\n\nif(__SERVER__){\n   Locale.prototype.load = function(){};\n}else{\n //client\n Locale.prototype.fetch = function(){};\n Locale.prototype.translate = function(){};\n}\n```\n\nWhere static constants will be dead code eliminated on prod.\n\nWhat approach you advice ?\n\nThanks in advance.\n",
    "comments_url": "https://api.github.com/repos/reduxjs/redux/issues/967/comments",
    "author": "vieks",
    "comments": [
      {
        "user": "gaearon",
        "created_at": "2015-10-28T19:00:23Z",
        "body": "This does not appear Redux-specific.\nPlease ask usage and general questions on StackOverflow.\n"
      },
      {
        "user": "vieks",
        "created_at": "2015-10-29T10:19:00Z",
        "body": "Ok sorry but finally no need I found an elegant declarative solution with decorators.\n"
      }
    ]
  },
  {
    "number": 966,
    "title": "Connecting multiple components in a component ownership hierarchy, is it advisable?",
    "created_at": "2015-10-28T15:28:20Z",
    "closed_at": "2015-10-28T15:33:08Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/reduxjs/redux/issues/966",
    "body": "I'm just starting out with React and Redux and am questioning one of my first implementations in which I connect redux to a root component but for some high level components that sit right under the router I would rather make these smart components as well. Is it advisable or even intended to have multiple components within a single path in the component ownership hierarchy connected directly via a call to _connect_? Perhaps it is what is intended but for some reason it feels wrong to me like I'm overwriting some inherited context.\n",
    "comments_url": "https://api.github.com/repos/reduxjs/redux/issues/966/comments",
    "author": "jpierson",
    "comments": [
      {
        "user": "gaearon",
        "created_at": "2015-10-28T15:33:08Z",
        "body": "Yes, having multiple connected components is fine.\n#419\n"
      }
    ]
  },
  {
    "number": 954,
    "title": "Are there any major downsides to creating a redux store for testing?",
    "created_at": "2015-10-26T13:50:08Z",
    "closed_at": "2015-10-26T14:03:38Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/reduxjs/redux/issues/954",
    "body": "Let's say I've got a counter application, I could just create the \"fake\" store in one file. And import it to my tests.\n\n``` javascript\nFakeStore.js\nCounterTests.js\n\n// in CounterTests\n\nimport Store from './FakeStore'\n\nlet expected = {\ncount: 2\n}\nStore.dispatch(counterAdd())\nexpect(expected).to.eql(CounterSelector(Store.getState()))\n\n```\n\nTo me it seems that with this approach and a localhost server running you can test every part of your redux logic and the only untested part would be the components and containers.\n",
    "comments_url": "https://api.github.com/repos/reduxjs/redux/issues/954/comments",
    "author": "thomas-jeepe",
    "comments": [
      {
        "user": "gaearon",
        "created_at": "2015-10-26T14:03:38Z",
        "body": "Please ask usage questions on StackOverflow. The `counter` and `todomvc` examples in the `examples` folder show how to test different parts of Redux apps. I'm not sure what's being asked specifically here.\n"
      }
    ]
  },
  {
    "number": 940,
    "title": "How many containers and state should I have in a real world big application?",
    "created_at": "2015-10-23T07:26:18Z",
    "closed_at": "2015-10-23T10:55:03Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/reduxjs/redux/issues/940",
    "body": "I am new to the `redux`, but I like it very much. The single store is really awesome for SPA. But I have a question for a real world big application.\n\nFor example, if there is a membership management application. We have login page, member management page and accounting page. Should I have 3 `states` for each page? If I still have one single state, my concern is the `state` is going to huge.\nShould I have 3 containers for each page? If we need a new page, such as AddMember page. Should I add a new container?\n\nI have checked the examples provided in the source code. Most of them are only for a small SPA. Is there a big application scaffold?\n",
    "comments_url": "https://api.github.com/repos/reduxjs/redux/issues/940/comments",
    "author": "CrisLi",
    "comments": [
      {
        "user": "gaearon",
        "created_at": "2015-10-23T10:55:03Z",
        "body": "Please ask this on StackOverflow.\nRecently we've been trying to keep the issue tracker for issues and discussions, not questions.\n"
      }
    ]
  },
  {
    "number": 935,
    "title": "Redux version 3.0.3 and manually combining reducers doesn't trigger an update",
    "created_at": "2015-10-22T18:21:07Z",
    "closed_at": "2015-10-22T18:25:19Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/reduxjs/redux/issues/935",
    "body": "Version `3.0.2` works perfect with the following code, but breaks in version `3.0.3`. The following reducer is imported by another file and combined using `combineReducers()`. I'm assuming this has something to do with manually setting nested state properties instead of using `combineReducers()` in this file.\n\nThe specific issue comes from the `state.gallery` object not being represented with updated data.\n\nI'm assuming that it has todo with the reference check that redux does when determining if `combineReducers()` should return the same object. Would this be because we are mutating the object?\n\nIf it's helpful, I can open a PR with a failing test.\n\n``` js\nimport {remove} from 'lodash'\n\nimport gallery from './gallery'\nimport progressBar from './progress_bar'\nimport flash from './flash'\nimport newSubmission from './new_submission'\nimport loaded from './loaded'\n\nimport {\n  SET_CURRENT_PROJECT_ID,\n  LOADING_START,\n  LOADING_DONE,\n  ACTIVATE_PLACEMENT\n} from 'lw-actions/action_types'\n\nlet initialState = {\n  loading: []\n}\n\nexport default function ui (state = initialState, action) {\n\n  state.progressBar = progressBar(state.progressBar, action)\n  state.flash = flash(state.flash, action)\n  state.newSubmission = newSubmission(state.newSubmission, action)\n  state.gallery = gallery(state.gallery, action)\n  state.loaded = loaded(state.loaded, action)\n\n  switch (action.type) {\n\n    case SET_CURRENT_PROJECT_ID: {\n      return {\n        ...state,\n        currentProjectId: action.payload\n      }\n    }\n\n    case LOADING_START: {\n      return {\n        ...state,\n        loading: state.loading.concat(action.payload)\n      }\n    }\n\n    case LOADING_DONE: {\n      return {\n        ...state,\n        loading: remove(state.loading, action.payload)\n      }\n    }\n\n    case ACTIVATE_PLACEMENT: {\n      return {\n        ...state,\n        ...action.payload\n      }\n    }\n\n    default: {\n      return state\n    }\n  }\n}\n\n```\n",
    "comments_url": "https://api.github.com/repos/reduxjs/redux/issues/935/comments",
    "author": "scottcorgan",
    "comments": [
      {
        "user": "gaearon",
        "created_at": "2015-10-22T18:25:19Z",
        "body": "> Would this be because we are mutating the object?\n\nYes. We explicitly state in the documentation in many places that you should _never_ mutate the `state` or `action` the reducer receives. The fact that it worked was a lucky coincidence.\n\nThe correct way to write this kind of code:\n\n``` js\nexport default function ui (state = initialState, action) {\n  state = {\n    ...state,\n    progressBar: progressBar(state.progressBar, action),\n    flash = flash(state.flash, action),\n    newSubmission: newSubmission(state.newSubmission, action),\n    gallery: gallery(state.gallery, action),\n    loaded: loaded(state.loaded, action)\n  };\n\n  switch (action.type) {\n\n    case SET_CURRENT_PROJECT_ID: {\n      return {\n        ...state,\n        currentProjectId: action.payload\n      }\n    }\n\n    case LOADING_START: {\n      return {\n        ...state,\n        loading: state.loading.concat(action.payload)\n      }\n    }\n\n    case LOADING_DONE: {\n      return {\n        ...state,\n        loading: remove(state.loading, action.payload)\n      }\n    }\n\n    case ACTIVATE_PLACEMENT: {\n      return {\n        ...state,\n        ...action.payload\n      }\n    }\n\n    default: {\n      return state\n    }\n  }\n}\n```\n"
      }
    ]
  },
  {
    "number": 934,
    "title": "dispatch(action) calls reducer twice but this.props.function not",
    "created_at": "2015-10-22T18:15:07Z",
    "closed_at": "2015-10-22T18:21:31Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/reduxjs/redux/issues/934",
    "body": "Hello,\nI got a strange problem and I have no idea what causes this.\nThe approach that I am using is the mapStateToProps / mapDispatchToProps.\n\nThe strang thing is:\n- When I call the action through the function I am passing in through mapDispatchToProps, the reducer gets only called once.\n- When I am using the this.props.dispatch(action) the reducer gets called twice.\n\nThe logger shows that the state is changed to true but then the reducers gets called again and its set back to false again.\n\nFor better understanding, here's the code a code sample.\n\nAction creator:\n\n``` typescript\n//../actions/shellActions\nimport { TOGGLE_SIDEBAR } from '../constants/actionTypes';\nexport function toggleNavigation() {\n    return {\n        type: TOGGLE_SIDEBAR\n    }\n}\n```\n\nReducer\n\n``` typescript\n//../reducers/navigationReducer\nimport { TOGGLE_SIDEBAR } from '../constants/actionTypes';\n\nexport default function toggleSidebar(state:boolean=false, action:any) {\n    let hideSidebar = !state;\n    switch (action.type) {        \n        case TOGGLE_SIDEBAR:\n            return hideSidebar;\n        default:\n            return state;\n    }\n}\n\n//../reducers/rootReducer\nimport { default as toggleSidebar } from './navigationReducer';\n\nconst rootReducer: Redux.Reducer = combineReducers({\n    toggleSidebar: toggleSidebar\n});\n\nexport default rootReducer;\n```\n\nContainer\n\n``` typescript\nimport * as React from 'react';\nimport { connect } from 'react-redux';\nimport { toggleNavigation } from '../actions/shellActions';\n\nclass App extends React.Component<any, any> {\n    constructor(props) {\n        super(props);\n    }\n\n    onToggle() {\n        //this.props.toggleNavigation(); This gets called once\n        this.props.dispatch(toggleNavigation()); // This gets called twice\n    }\n\n    render() {\n        return (\n            <div className={ isSidebarVisible ? \"body-container\" : \"body-container sidebar-open\"}>\n                <button onClick={ this.onToggle.bind(this) }>Toggle</button>\n\n            </div>\n        );\n    }\n}\n\n\nfunction mapStateToProps(state: RootState):AppProp {\n    return {\n        isSidebarVisible: state.toggleSidebar\n    };\n}\n\nfunction mapDispatchToProps(dispatch) {\n    const actions: AppProp = {\n        dispatch: dispatch,\n        toggleNavigation: toggleNavigation\n    };\n\n    return bindActionCreators(actions, dispatch);\n}\n\nexport default connect(mapStateToProps, mapDispatchToProps)(App);\n```\n\nMaybe I did something wrong.\nThanks\n",
    "comments_url": "https://api.github.com/repos/reduxjs/redux/issues/934/comments",
    "author": "datoml",
    "comments": [
      {
        "user": "gaearon",
        "created_at": "2015-10-22T18:21:31Z",
        "body": "If you're using `bindActionCreators` and `mapDispatchToProps`, the action creators _are already bound_. There is no need to call `dispatch()` on their return values. The whole point of `bindActionCreators()` is _not_ to call `dispatch()`. You should either `bindActionCreators()` and call them as is, or not use it, and call `dispatch()`.\n"
      },
      {
        "user": "datoml",
        "created_at": "2015-10-22T18:49:56Z",
        "body": "Thank you for the explanation @gaearon.\n"
      }
    ]
  },
  {
    "number": 882,
    "title": "Redux iFrame",
    "created_at": "2015-10-12T08:27:31Z",
    "closed_at": "2015-10-12T12:58:30Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/reduxjs/redux/issues/882",
    "body": "I'm working on an `editor app` which works inside an iframe loaded in the dashboard. I'm want to use redux & react to build the editor. \n\n Is it possible to hot reload/auto-update views inside of an iframe?\n",
    "comments_url": "https://api.github.com/repos/reduxjs/redux/issues/882/comments",
    "author": "sathify",
    "comments": [
      {
        "user": "gaearon",
        "created_at": "2015-10-12T12:58:30Z",
        "body": "I don't see why not—but in any case this is unrelated to Redux.\nYou should ask in a repo related to the hot reloading solution you use.\n"
      }
    ]
  },
  {
    "number": 872,
    "title": "Why does this work?",
    "created_at": "2015-10-08T19:34:12Z",
    "closed_at": "2015-10-08T20:04:22Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/reduxjs/redux/issues/872",
    "body": "So, after literally hours of moving things around, trudging through docs, etc., I finally got this to work:\n\n``` js\nconst middleware = compose(\n  applyMiddleware(promise, thunk),\n  devTools(),\n  persistState(window.location.href.match(/[?&]debug_session=([^&]+)\\b/)),\n);\n\n// You may call this a finalCreateStore\nconst store = middleware(createStore)(reducer); // reducer is already combined up the chain\n...\n```\n\nSo...\n- What gets `compose`d vs. `applyMiddleware`d?\n- Why can't I `compose(promise, thunk, devTools(), persist(...))`?\n- Why can't I `applyMiddleware(promise, thunk, devTools())`\n- Why can't I do `compose(..., createStore, reducer)`?\n\nSorry if these are \"newbie\" questions, but my take was that things are either `actions`, `actionCreators`, `reducers`, or `middleware`, so I thought all of the above was middleware?\n",
    "comments_url": "https://api.github.com/repos/reduxjs/redux/issues/872/comments",
    "author": "ericclemmons",
    "comments": [
      {
        "user": "gaearon",
        "created_at": "2015-10-08T19:38:09Z",
        "body": "DevTools is not middleware.\npersistState is not middleware. \n\nBoth are \"store enhancers\".\nIncidentally applyMiddleware is also one.\nThat's why they're on the same level.\n\nIt's the opposite:\n- The basic concept is \"store enhancer\". It's createStore => createStore.\n- Store enhancers are too powerful, usually all you want is dispatch => dispatch (and have a reference to store for good measure).\n- There's a store enhancer called applyMiddleware().\n"
      },
      {
        "user": "gaearon",
        "created_at": "2015-10-08T19:41:34Z",
        "body": "Maybe it's easier to understand if you stop using compose(). It's just an inessential helper.\n\nWhat's really happening is this:\n\n```\nlet createStore = require('redux').createStore;\n\ncreateStore = applyMiddleware(thunk, promise)(createStore);\n\ncreateStore = devTools()(createStore);\n\ncreateStore = persistState(...)(createStore);\n\nlet store = createStore(reducer);\n```\n"
      },
      {
        "user": "ericclemmons",
        "created_at": "2015-10-08T19:42:14Z",
        "body": "Ok, so if I understand correctly...\n- middleware _can directly handle events from action creators_, which is why they get wrapped by the `applyMiddleware` \"store enhancer\".\n- Store enhancers aren't really part of the action dispatching process/changing/handing responsibility, but are there for adding features _using_ the store?\n"
      },
      {
        "user": "gaearon",
        "created_at": "2015-10-08T19:58:11Z",
        "body": "Store enhancers can do pretty much anything. For example they can wrap reducers, override any store method, or map state.\n\nThe only thing middleware does is wrap dispatch() method. It's less powerful but easier to write correctly.\n\nEverything that middleware can do, store enhancers can do. But they're more complicated to implement so we don't talk about them much in the docs.\n\nIf all you need is wrap dispatch, write middleware. If you need more exotic things write a store enhancer.\n\nAlso check out applyMiddleware() source.\n"
      },
      {
        "user": "ericclemmons",
        "created_at": "2015-10-08T20:04:22Z",
        "body": "This helps a lot.  Thanks!\n\nKnowing these are the pieces, I ended up with something up:\n\n``` js\nconst store = createStoreWith(middlewares, enhancers)(reducer, initialState);\n// Internally does the above, but now the terseness helps\n// the team understand what goes where.\n```\n"
      },
      {
        "user": "gaearon",
        "created_at": "2015-10-08T20:06:38Z",
        "body": "Yeah you could do that.\n\nOne side effect is that you might want to apply middleware twice.\n"
      },
      {
        "user": "gaearon",
        "created_at": "2015-10-08T20:09:45Z",
        "body": "What I meant to say is that there are cases where you want to apply some middleware, then some enhancer, and then some more middleware. For example if you want to put logger after some enhancer that generates actions you want to log.\n\nNot saying it's a common use case but it's something that gets lost with the signature above. That's the reason we don't include such createStoreWith in the core, too. \n"
      },
      {
        "user": "ericclemmons",
        "created_at": "2015-10-08T20:31:50Z",
        "body": "Ah, good explanation.  This reminds me much more of doing Koa-middleware where you `yield next` and create very special little sandwiches :)\n"
      },
      {
        "user": "ericclemmons",
        "created_at": "2015-10-08T20:53:34Z",
        "body": "Another question (last one!):  if \"middleware\" were all just store enhancers (but only concerned themselves with the dispatch part), would it then read:\n\n``` js\ncompose(\n  thunkEnhancer,\n  promiseEnhancer,\n  devTools(),\n  ...\n)(createStore)(reducer, initialState);\n```\n\nIf that's correct, then `applyMiddleware` is really _enhancing_ `thunk` and `promise` to be a \"store enhancer\" like the rest of the chain...\n"
      },
      {
        "user": "acdlite",
        "created_at": "2015-10-08T21:16:03Z",
        "body": "If we want to be precise about it, `applyMiddleware()` is a function whose arguments are middleware and which returns a store enhancer.\n"
      },
      {
        "user": "acdlite",
        "created_at": "2015-10-08T21:17:17Z",
        "body": "So you could make a `thunkEnhancer` or `promiseEnhancer` like so:\n\n``` js\nconst thunkEnhancer = applyMiddleware(thunk);\nconst promiseEnhancer = applyMiddleware(promise);\n```\n"
      },
      {
        "user": "ericclemmons",
        "created_at": "2015-10-08T22:31:28Z",
        "body": ":+1: \n"
      },
      {
        "user": "ericclemmons",
        "created_at": "2015-10-08T22:35:45Z",
        "body": "@acdlite I think that's clarification I (we) needed. Finally arrived to that conclusion, but   that distinction hasn't been clear.  Thanks guys!\n"
      }
    ]
  },
  {
    "number": 816,
    "title": "Sanity checks in production builds",
    "created_at": "2015-09-28T15:37:29Z",
    "closed_at": "2015-09-28T15:45:37Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/reduxjs/redux/issues/816",
    "body": "I was nosing around and I noticed that the sanity checks in `combineReducers` are invoking each reducer - not once, but twice upon boot! I figured this seems like an unnecessarily bottleneck during boot. It make sense in a development environment but is it really necessary in production? \n\nI was wondering if a \"santity checkless\" build is a common thing for libraries?\n",
    "comments_url": "https://api.github.com/repos/reduxjs/redux/issues/816/comments",
    "author": "jackcallister",
    "comments": [
      {
        "user": "gaearon",
        "created_at": "2015-09-28T15:45:37Z",
        "body": "It is not going to affect the boot time in any meaningful way. The reason we're keeping them in production is to avoid the situation where you have different stack traces in dev and prod. If those sanity checks fail, it means there _is_ a mistake in your code, and it _will_ blow up later. But you'll get a totally different stack trace in production, which will be mysterious because you won't be able to reproduce it in development.\n\nFor example, React also does certain assertions both in development and production because otherwise it would be very hard to trace something-has-gone-really-bad scenarios.\n\nWe don't plan to remove these checks. However, if you feel strongly about it, you can write a `combineReducers`-ly code by hand:\n\n``` js\nfunction app(state = {}, action) {\n  return {\n    something: something(state.something, action),\n    somethingElse: somethingElse(state.somethingElse, action)\n  };\n}\n```\n\nand have full control over it.\n"
      },
      {
        "user": "jackcallister",
        "created_at": "2015-09-28T15:59:42Z",
        "body": "@gaearon I thought you were on holiday with your pink crocs!? Cheers for the explanation though :crocodile:\n"
      }
    ]
  },
  {
    "number": 789,
    "title": "Stateful API middleware",
    "created_at": "2015-09-23T20:41:01Z",
    "closed_at": "2015-09-23T21:11:14Z",
    "labels": [
      "question",
      "feedback wanted"
    ],
    "url": "https://github.com/reduxjs/redux/issues/789",
    "body": "I'm working against a web socket api which means that my api middleware needs to keep an open web socket connection.\n\nI've come up with the following approach and I'm just wondering whether anyone have any suggestions or a better idea?\n\n``` javascript\nimport * as apiActions from './actions'\nimport connect from 'websocket-lib'\nimport Rx from 'rx'\n\nexport default store => {\n  const onClient = Rx.Observable\n    .create((o) => {\n      const client = connect(store.getState().api.url)\n      client.on('connect', () => o.onNext(client))\n      client.on('disconnect', () => o.onNext(null))\n      return () => client.close()\n    })\n    .publishValue(null)\n\n  onClient\n    .distinctUntilChanged()\n    .subscribe((client) => client\n      ? store.dispatch(apiActions.connected())\n      : store.dispatch(apiActions.disconnected()))\n\n  onClient.connect()\n\n  return next => action => {\n    const { type = null, payload } = action\n\n    const handler = {\n      [apiActions.API_FOO]: (payload) => onClient\n        .first(x => x)\n        .timeout(1000)\n        .flatMap(client => Rx.Observable\n          .create(o => {\n            // Do stuff...\n          }))\n    }[type]\n\n    if (!handler) {\n      return next(action)\n    }\n\n    return handler(payload)\n  }\n```\n\nUsed like this:\n\n```\n   apiActions.foo({id: 123}).subscribe((todo) => todoActions.addTodo(todo))\n```\n",
    "comments_url": "https://api.github.com/repos/reduxjs/redux/issues/789/comments",
    "author": "ronag",
    "comments": [
      {
        "user": "gaearon",
        "created_at": "2015-09-23T20:45:28Z",
        "body": "I'm not super well versed in Rx but this looks reasonable.\n"
      }
    ]
  },
  {
    "number": 781,
    "title": "Is middleware needed?",
    "created_at": "2015-09-23T09:45:39Z",
    "closed_at": "2015-09-23T09:50:29Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/reduxjs/redux/issues/781",
    "body": "If the same thing can be achieved using enhancers/higher order stores I don't see why we need to confuse people with two overlapping concepts?\n",
    "comments_url": "https://api.github.com/repos/reduxjs/redux/issues/781/comments",
    "author": "ronag",
    "comments": [
      {
        "user": "gaearon",
        "created_at": "2015-09-23T09:50:29Z",
        "body": "It's a simpler tool for 80% use cases. It also has a very specific action lifecycle: middleware can either pass it on (eventually) or restart the chain.\n\nThe behavior of restarting the chain can't be accomplished by store enhancers alone—you need something holding them together, at which point we arrive at middleware again.\n"
      }
    ]
  },
  {
    "number": 771,
    "title": "Production build",
    "created_at": "2015-09-21T23:47:42Z",
    "closed_at": "2015-09-22T11:27:32Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/reduxjs/redux/issues/771",
    "body": "Hi. Why in this project huge checks doesn't wrap into `if(process.env.NODE_ENV...)`? I understand, them are very helpful in the development stage but useless in production. I guess some of them can also slow down application, like:\n\n``` js\nObject.keys(finalReducers).forEach(key => {\n  var reducer = finalReducers[key];\n  if (typeof reducer(undefined, { type: ActionTypes.INIT }) === 'undefined') {\n    throw new Error(\n      `Reducer \"${key}\" returned undefined during initialization. ` +\n      `If the state passed to the reducer is undefined, you must ` +\n      `explicitly return the initial state. The initial state may ` +\n      `not be undefined.`\n    );\n  }\n\n  var type = Math.random().toString(36).substring(7).split('').join('.');\n  if (typeof reducer(undefined, { type }) === 'undefined') {\n    throw new Error(\n      `Reducer \"${key}\" returned undefined when probed with a random type. ` +\n      `Don't try to handle ${ActionTypes.INIT} or other actions in \"redux/*\" ` +\n      `namespace. They are considered private. Instead, you must return the ` +\n      `current state for any unknown actions, unless it is undefined, ` +\n      `in which case you must return the initial state, regardless of the ` +\n      `action type. The initial state may not be undefined.`\n    );\n  }\n});\n```\n",
    "comments_url": "https://api.github.com/repos/reduxjs/redux/issues/771/comments",
    "author": "nkt",
    "comments": [
      {
        "user": "ellbee",
        "created_at": "2015-09-22T08:25:56Z",
        "body": "I don't think these checks are going to significantly impact performance as they are only called in `combineReducers` during initialization, but I do think you are right that they could be put behind a dev flag. One benefit would be dead code elimination.\n"
      },
      {
        "user": "gaearon",
        "created_at": "2015-09-22T11:27:32Z",
        "body": "> I guess some of them can also slow down application, like:\n\nNot likely, because they execute just once.\nIf you are very concerned about them you can write your own `combineReducers` without checks:\n\n``` js\nexport default function combineReducers(reducers) {\n  return function combination(state = {}, action) {\n    return Object.keys(reducers).reduce((nextState, key) => {\n      nextState[key] = reducers[key](state[key], action);\n      return nextState;\n    }, {});\n  }\n}\n```\n\nWhen you use Redux you should understand that the functions provided to you are for convenience but you can totally customize them, and shouldn't feel awkward doing so. It's normal: you own your functions and code. Don't feel trapped in functions that ship with Redux.\n\n> Why in this project huge checks doesn't wrap into if(process.env.NODE_ENV...)\n\nThese checks actually _throw_ exceptions. They're not just warnings. If they were wrapped in `if (...)`, then production and development behavior would differ, which is bad. If developer misses a problem and the problem makes it into production, it will eventually throw (because sanity checks actually check for important mistakes that _will_ cause errors in production), but in a different place. You'll have weird stack traces that you can't possibly reproduce in development. For these reasons, if some behavior throws, it has to throw both in development and production.\n"
      }
    ]
  },
  {
    "number": 763,
    "title": "Displaying time?",
    "created_at": "2015-09-20T15:30:54Z",
    "closed_at": "2015-09-21T00:57:26Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/reduxjs/redux/issues/763",
    "body": "I have a lot of components that update every seconds based on `Date.now()`. However, performing these updates through the redux stores makes dev-tools and logging extremely slow, spammed and unusable.\n\nDoes anyone have any suggestions on how one can handle this in the best way?\n\nOne way I was thinking about was that the components themselves have a time subscription that calls `setState` with the current time, i.e. time updates are local to the component. The time has (mostly) no logical meaning only visual.\n",
    "comments_url": "https://api.github.com/repos/reduxjs/redux/issues/763/comments",
    "author": "ronag",
    "comments": [
      {
        "user": "timdorr",
        "created_at": "2015-09-21T00:45:25Z",
        "body": "How are you using time in your reducers? Since time is an external state, and introduces non-pure effects into store, it should probably be kept external. If you're using React, I would handle it internal to your components. \n\nSay, for example, you have a list of comments on a blog and you want to have the timestamp next to each comment update in real time (\"1 minute ago\" changes to \"2 minutes ago\", etc.). I wouldn't track that in my redux store, as that's a display concern. I would either have each comment component set up a `setInterval` and re-render as needed. Or I would set that up at the top level comment list container and pass down the current time as a prop to each comment component and have them re-render as needed. \n"
      },
      {
        "user": "ronag",
        "created_at": "2015-09-21T00:57:26Z",
        "body": "Sounds reasonable. Thank you for the feedback.\n"
      }
    ]
  },
  {
    "number": 738,
    "title": "Is nested combineReducers a bad or good idea?",
    "created_at": "2015-09-16T09:14:17Z",
    "closed_at": "2015-09-16T13:22:49Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/reduxjs/redux/issues/738",
    "body": "Can combineReducers be nested or it should be used once to combine all the reducers into one?\nIs that a bad approach to create a tree structure of store by combining reducers on each step?\n\nOr probably there is any other way to keep root store clean (want to avoid placing all tree leaves into root store)\nPseudocode structure example:\n\n```\nrootReducer = combineReducers({\n  router, // redux-react-router reducer\n    account: combineReducers({\n      profile: combineReducers({\n         info, // reducer function\n         credentials // reducer function\n      }),\n      billing // reducer function\n    }),\n    // ... other combineReducers\n  })\n});\n```\n",
    "comments_url": "https://api.github.com/repos/reduxjs/redux/issues/738/comments",
    "author": "dmitry-zaets",
    "comments": [
      {
        "user": "gaearon",
        "created_at": "2015-09-16T13:22:49Z",
        "body": "Sure, it's a fine idea.\n"
      },
      {
        "user": "justinlazaro-ubidy",
        "created_at": "2019-01-29T02:11:38Z",
        "body": "Hi im implementin a multiple combineReducer, \r\n\r\n\r\n// schoolReducer.js\r\n```\r\nexport default combineReducers({\r\n  company: companyReducer,\r\n  profile: profileReducer,\r\n});\r\n```\r\n\r\n// studentInfo.js\r\n```\r\nexport default combineReducers({\r\n  student: studentReducer,\r\n  course: courseReducer,\r\n});\r\n```\r\n\r\n//rootReducer.js\r\n```\r\nexport default combineReducers({\r\n  school: schoolReducer,\r\n  student: studentInfo,\r\n});\r\n\r\n```\r\nhaving an error\r\n```\r\nStore does not have a valid reducer. Make sure the argument passed to combineReducers is an object whose values are reducers.\r\n```"
      },
      {
        "user": "markerikson",
        "created_at": "2019-01-29T02:18:41Z",
        "body": "@justinlazaro-ubidy  : \r\nThis is a bug tracker, not a support system. For usage questions, please use Stack Overflow or Reactiflux where there are a lot more people ready to help you out - you'll probably get a better answer faster. Thanks!"
      }
    ]
  },
  {
    "number": 736,
    "title": "Remove many-level nested entities",
    "created_at": "2015-09-16T07:21:17Z",
    "closed_at": "2015-09-16T13:24:54Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/reduxjs/redux/issues/736",
    "body": "Hi,\n\nI have the next store normalized structure:\n\n``` javascript\n{\n  sports: {\n    1: {\n       id: 1,\n       name: 'Soccer',\n       leagues: [2,3,4]\n     },\n     ...\n  },\n  leagues: {\n    2: {\n       sportId: 1,\n       id: 2,\n       name: 'Some league',\n       matches: [5,6,7]\n     },\n     ...\n  },\n  matches: {\n    5: {\n       leagueId: 1,\n       id: 5,\n       name: 'Some match'\n     },\n    ...\n  }\n}\n```\n\nI have the next reducers composition: \n\n``` javascript\nrootReducer(state, action) {\n  return {\n    sports: sportsReducer(state.sports, action),\n    leagues: leaguesReducer(state.leagues, action),\n    matches: matchesReducer(state.matches, action)\n  }\n}\n```\n\nFor example I need to remove sport and all dependent entities (leagues and matches). I can remove leagues because a league entity has a sport's id, but match doesn't. So in this way I have to write a single reducer because sportsReducer actually have to change all three maps (sports, leagues and matches).\n\nIs there a more elegant way to deal with such situations?\n",
    "comments_url": "https://api.github.com/repos/reduxjs/redux/issues/736/comments",
    "author": "omeshechkov",
    "comments": [
      {
        "user": "gaearon",
        "created_at": "2015-09-16T13:24:54Z",
        "body": "Why do you need to _remove_ cached data? Keep all the state fields, but add a new field called `visibleSportIds: [1, 2, 3]`. Instead of _deleting_ a sport from `sports`, just remove its ID from this array. Make sure the app only displays sports that exist in `visibleSportIds`.\n"
      },
      {
        "user": "omeshechkov",
        "created_at": "2015-09-16T18:01:07Z",
        "body": "Because this is a cut of model what I have, the full mode is much bigger than it. Keeping all data in the store (without removing) will lead to the memory leaks and probably performance problems too, because there will be too much data soon. But the main requirement of our app is performance, so I can't afford it.\n\nActually, I've already found the solution. I'm going to expand low level entities with \"high-level\" keys. Hence, I'll be able to remove matches, scores, etc.\n\nSomething like this:\n\n``` javascript\nscores: {\n   sportId: 1,\n   leagueId: 2,\n   matchId: 3,\n   id: 4,\n   ...\n}\n\nscoreReducer(state, action) {\n  switch(action.type) {\n    case REMOVE_SPORT:\n      //get score IDs by leagueId\n      //remove from the state IDs I got\n      ...\n}\n```\n\nIt seems the most adequate solution in my case. The thing I most don't like in this case is iterating over map, but I think I'll reconcile with it.\n\nAnyway thanks for your reply, I'll keep in mind your solution.\n"
      },
      {
        "user": "gaearon",
        "created_at": "2015-09-16T18:03:59Z",
        "body": "> Keeping all data in the store (without removing) will lead to the memory leaks and probably performance problems too, because there will be too much data soon. But the main requirement of our app is performance, so I can't afford it.\n\nPlease profile it first (you can generate thousands of items to make sure). You might think keeping data in memory will be an issue, but if you use something like ImmutableJS to make sure mutations aren't that expensive, it may not be.\n"
      },
      {
        "user": "omeshechkov",
        "created_at": "2015-09-16T18:18:46Z",
        "body": "I have a batch of diffs (actions) every ~1 second, so it's likely will be a problem. The Immutable JS as I understood is only for elegant dealing with collections and  there are native objects and arrays under the hood. So there is no difference what I'm using Immutable JS or native objects regarding performance.\n\nBut I'll keep your solution in mind, thanks.\n"
      },
      {
        "user": "gaearon",
        "created_at": "2015-09-16T18:20:14Z",
        "body": "> So there is no difference what I'm using Immutable JS or native objects regarding performance.\n\nThere is: Immutable uses structural sharing. This means any time you're putting something in the entity cache or changing it, you're not creating giant object under the hood.\n"
      },
      {
        "user": "zatziky",
        "created_at": "2016-07-27T14:18:14Z",
        "body": "I stick with @omeshechkov . What if he needed to delete leagues from a sportReducer because they were leagues were modified and their modification was persisted to a db. Then you want to start with fresh leagues aka [].\n"
      }
    ]
  },
  {
    "number": 733,
    "title": "ES6 spread operator in ES5",
    "created_at": "2015-09-15T15:06:59Z",
    "closed_at": "2015-09-15T16:03:46Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/reduxjs/redux/issues/733",
    "body": "What's the best (and shortest) way to translate this to ES5:\n\n```\nreturn [...state, {\n  text: action.text,\n  completed: false\n}];\n```\n\nIt looks to me that a (deep?) copy of the state array should be created, with the new state at the end. I had a look what Babel would do, but it generates a big function that is probably not necessary for this little use case.\n",
    "comments_url": "https://api.github.com/repos/reduxjs/redux/issues/733/comments",
    "author": "kraftwer1",
    "comments": [
      {
        "user": "hunterc",
        "created_at": "2015-09-15T15:22:39Z",
        "body": "In this example, all the array spread syntax is doing is copying all the existing elements into the new array.\n\n```\nreturn state.slice().push({\n    text: action.text,\n    completed: false\n});\n```\n"
      },
      {
        "user": "heyimalex",
        "created_at": "2015-09-15T15:52:55Z",
        "body": "@hunterc `Array.prototype.push` returns the new length of the array. You need to split it up like this.\n\n``` js\nvar myNewValue = state.slice(); // Make a copy of the state array\nmyNewValue.push({ text: action.text, completed: false });\nreturn myNewValue;\n```\n"
      },
      {
        "user": "ghost",
        "created_at": "2015-09-15T15:57:43Z",
        "body": "```\nreturn state.concat( [ { text: action.text, completed: false } ] );\n```\n\nor even more concisely\n\n```\nreturn state.concat( { text: action.text, completed: false } );\n```\n"
      },
      {
        "user": "gaearon",
        "created_at": "2015-09-15T16:03:46Z",
        "body": "`state.concat(newStuff)` is right as @danmartinez101 said.\n\n`state.slice().push()` will work too because `slice()` copies the array, but it can be misleading to beginners who might think doing `push()`es is fine.\n"
      }
    ]
  },
  {
    "number": 654,
    "title": "Guidance on hooking lazily loaded actions+reducer into existing store",
    "created_at": "2015-08-29T21:34:18Z",
    "closed_at": "2015-08-30T22:28:06Z",
    "labels": [
      "question",
      "discussion"
    ],
    "url": "https://github.com/reduxjs/redux/issues/654",
    "body": "It may be out of the scope of the docs, but I haven't found any inspiration in the various middleware/scaffolding/example repos, either.\n\nIn my case, I've just switched `react-router` config to lazily-load sub-apps via `require.ensure`, and I'm trying to figure out how to bundle the sub-app's actions and reducers with the lazily loaded chunks rather than with the shared bundle.\n",
    "comments_url": "https://api.github.com/repos/reduxjs/redux/issues/654/comments",
    "author": "garborg",
    "comments": [
      {
        "user": "timdorr",
        "created_at": "2015-08-30T19:36:13Z",
        "body": "I'd keep an eye on #625. That will enable lazy/progressive loading of reducers.\n"
      },
      {
        "user": "garborg",
        "created_at": "2015-08-30T22:27:27Z",
        "body": "Thanks, @timdorr. I subscribed to #625 -- feel free to close this if it seems redundant.\n"
      },
      {
        "user": "gaearon",
        "created_at": "2015-09-01T11:07:36Z",
        "body": "@garborg In the meantime feel free to use `store.replaceReducer()`.\n"
      }
    ]
  },
  {
    "number": 622,
    "title": "API change proposal: listener() --> listener(action)",
    "created_at": "2015-08-25T15:24:29Z",
    "closed_at": "2015-08-25T17:42:57Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/reduxjs/redux/pull/622",
    "body": "Hi,\n\nAs our Redux project grows at our company, we have found useful to get the last dispatched action at the beginning of a `store.subscribe` like this:\n\n``` javascript\nstore.subscribe(() => {\n    const { records } = store.getState(); // a reducer that holds every action ever dispatched\n    const lastAction = records[records.length - 1];\n```\n\nBut that approach is not reliable every time: if we wait too long before accessing `records[records.length - 1]` we might end up with another action dispatched in the meanwhile.\n\nSo we thought, in `createStore.js`, what about calling `listener` with the dispatched action as argument ?\n\n``` javascript\nlisteners.slice().forEach(listener => listener(action));\n```\n\nThat would allow developers to use `store.subscribe()` as a way to create action-based side-effects, thus making Redux even more flexible.\n\nWould anyone else like this ?\n\nThanks for the lib.\n",
    "comments_url": "https://api.github.com/repos/reduxjs/redux/issues/622/comments",
    "author": "dherault",
    "comments": [
      {
        "user": "acdlite",
        "created_at": "2015-08-25T17:42:57Z",
        "body": "This seems to make Redux less flexible, not more. People often ask why we don't call listeners with the most recent _state_, not _action_. This is an example of why — different people have different opinions about how this stuff should work.\n\nThe beauty of Redux is that you can customize this type of behavior yourself. Using a store enhancer:\n\n``` js\nfunction subscribeWithAction(createStore) {\n  return (reducer, initialState) => {\n    const store = createStore(reducer, initialState);\n    let listeners = [];\n    let lastAction;\n    store.subscribe(() => listeners.forEach(l => l(lastAction));\n\n    return {\n      ...store,\n      dispatch: action => {\n        lastAction = action;\n        return store.dispatch(action);\n      },\n      subscribe: listener => {\n        listeners.push(listener);\n        return function unsubscribe() {\n          listeners = listeners.filter(l => l !== listener);\n        };\n      }\n    };\n  };\n}\n\n\n// Use it like this\nconst finalCreateStore = subscribeWithLastAction(createStore);\nconst store = finalCreateStore(reducer, initialState);\n\nstore.subscribe(lastAction => {\n  // Yay!\n});\n```\n"
      },
      {
        "user": "gaearon",
        "created_at": "2015-08-25T18:04:22Z",
        "body": "> But that approach is not reliable every time: if we wait too long before accessing `records[records.length - 1]` we might end up with another action dispatched in the meanwhile.\n\nCan you show with a failing test how this happens? I don't understand.\n"
      },
      {
        "user": "mikekidder",
        "created_at": "2015-08-26T02:06:06Z",
        "body": "@acdlite that example.  Hope it makes it's way into the documentation.\n"
      },
      {
        "user": "gaearon",
        "created_at": "2015-08-26T02:07:04Z",
        "body": "To be honest I wouldn't encourage people to write store enhancers when a reducer is enough :-).\nI'd rather want to understand what's wrong with just using `subscribe`—I couldn't reproduce the issue.\n"
      },
      {
        "user": "dherault",
        "created_at": "2015-08-26T09:16:58Z",
        "body": "@acdlite Thanks for the store enhancer that's something!\n\n@gaearon We can't seem to reproduce that issue either -_-, sorry for the inconvenience.\n"
      }
    ]
  },
  {
    "number": 621,
    "title": "Problem with componentWillMount on connected component",
    "created_at": "2015-08-25T13:21:41Z",
    "closed_at": "2015-08-25T13:32:51Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/reduxjs/redux/issues/621",
    "body": "I have a problem with server rendering when use `componentWillMount` method for request data. Some of my requests are pre-fetched on server-side and some of them not.\nExample:\n\n``` javascript\n// HomePage container\nclass HomePage extends Component {\n  static willRender = store => {\n    // I don't want fetch anything - let's client do this job\n  }\n\n  componentWillMount() {\n    this.props.fetchSongs();\n    this.props.fetchAlbums();\n    this.props.fetchBands();\n  }\n\n  ...\n}\n\nexport default connect(select, mapDispatchToProps)(HomePage);\n```\n\nWhen server render markup client can not use it, I see this error in console:\n\n```\nWarning: React attempted to reuse markup in a container but the checksum was invalid. This generally means that you are using server rendering and the markup generated on the server was not what the client was expecting. React injected new markup to compensate which works but you have lost many of the benefits of server rendering. Instead, figure out why the markup being generated is different on the client or server:\n (client) eoa8oo3k.1.$/\"><div class=\"loader-block\"\n (server) eoa8oo3k.1.$/\"><div data-reactid=\".meeoa\n```\n\nAs I understand it's because this method invoked on the client side before rendering and on server side \"after\".\n",
    "comments_url": "https://api.github.com/repos/reduxjs/redux/issues/621/comments",
    "author": "tadjik1",
    "comments": [
      {
        "user": "gaearon",
        "created_at": "2015-08-25T13:31:45Z",
        "body": "This is just how React works, isn't it? Either you generate identical markup, and then client is able to reuse it, or you generate a different markup, and client cannot reuse it.\n\nIn your example the server renders the data, but the client renders `<div class=\"loader-block\"` first. Unfortunately I can't help you further because I don't understand the problem from the issue description.\n"
      },
      {
        "user": "gaearon",
        "created_at": "2015-08-25T13:32:50Z",
        "body": "If you want to only fetch something on the client, put it into `componentDidMount` which executes only on the client:\n\n``` js\n  componentDidMount() {\n    this.props.fetchSongs();\n    this.props.fetchAlbums();\n    this.props.fetchBands();\n  }\n```\n"
      },
      {
        "user": "tadjik1",
        "created_at": "2015-08-25T13:34:27Z",
        "body": "yes, I want to make some requests only on client side. thanks for description\n"
      }
    ]
  },
  {
    "number": 612,
    "title": "Dispatching part of state in action creator as payload",
    "created_at": "2015-08-24T12:37:07Z",
    "closed_at": "2015-08-24T12:38:22Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/reduxjs/redux/issues/612",
    "body": "I'm wondering if this can be a good use case for the thunk middleware.\nBasically in my reducer I need to read some piece of data that's handled by another reducer.\nSo I was thinking to pass this after reading it with `getState` in a thunk.\n\nOpinions?\n",
    "comments_url": "https://api.github.com/repos/reduxjs/redux/issues/612/comments",
    "author": "nickdima",
    "comments": [
      {
        "user": "gaearon",
        "created_at": "2015-08-24T12:38:22Z",
        "body": "Yes, it's a valid use case for `redux-thunk`. Make sure you don't pass large portions of state there, as this seems more like an anti-pattern. Reading a few bits here and there is fine.\n"
      }
    ]
  },
  {
    "number": 596,
    "title": "store.dispatch() from Actions",
    "created_at": "2015-08-21T08:01:26Z",
    "closed_at": "2015-08-21T11:07:10Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/reduxjs/redux/issues/596",
    "body": "I'm working on an example that makes use of async state updates. In that app I'm trying to find the best place for dispatch (e.g. as in `redux-thunk`), and it just happens to make sense to use it from Actions. \n\nHere's a sample action just to illustrate. \n\n```\nimport { RECEIVE_LOCATION } from '../constants/Types';\nimport { defaultPosition } from '../constants/Geo';\nimport store from '../stores';\n\nfunction requestGeolocation() {\n  return function(dispatch) {\n    navigator.geolocation.getCurrentPosition(function(position) {\n      dispatch({\n        type: RECEIVE_LOCATION,\n        coords: {\n          latitude: position.coords.latitude,\n          longitude: position.coords.longitude,\n          inProgress: false,\n        },\n      });\n    });\n  };\n}\n\nexport function getGeolocation() {\n  if (!navigator.geolocation) {\n    return store.dispatch({\n      type: RECEIVE_LOCATION,\n      ...defaultPosition,\n    });\n  }\n  return store.dispatch(requestGeolocation());\n}\n```\n\nObviously `dispatch` didn't come from a view when firing `getGeolocation()`, which is why I'm looking to hear about your take on this approach. This kind of makes sense to me only for the agnostic components where I don't expect bound actions received through props (e.g. `<GeoButton />` that cares less about anything other than triggering that action)\n\nSo my question is, would this pattern break the basic Redux principles?\n",
    "comments_url": "https://api.github.com/repos/reduxjs/redux/issues/596/comments",
    "author": "grgur",
    "comments": [
      {
        "user": "gaearon",
        "created_at": "2015-08-21T11:07:10Z",
        "body": "> Obviously dispatch didn't come from a view\n\nIf you're grabbing `dispatch` from a singleton `store` by exporting it from some module, you're making it hard to change your app to be universal (i.e. render on the server) later. Whether you care about this or not, is up to you, but we don't encourage this pattern.\n\nWhy not just use thunk middleware to change\n\n``` js\nexport function getGeolocation() {\n  if (!navigator.geolocation) {\n    return store.dispatch({\n      type: RECEIVE_LOCATION,\n      ...defaultPosition,\n    });\n  }\n  return store.dispatch(requestGeolocation());\n}\n```\n\ninto thunk:\n\n``` js\nexport function getGeolocation() {\n  return function (dispatch) {\n    if (!navigator.geolocation) {\n      return dispatch({\n        type: RECEIVE_LOCATION,\n        ...defaultPosition,\n      });\n    }\n    return dispatch(requestGeolocation());\n  }\n}\n```\n\nThen you can dispatch it like this:\n\n``` js\nstore.dispatch(getGeolocation());\n```\n\nand import `store` from your view, if that's what you prefer.\n\nAt this point, though, you should probably put `connect()` without arguments onto your view. Then you'll only get `dispatch` injected as a prop, which is all you need:\n\n``` js\nclass GeoButton extends Component {\n  componentDidMount() {\n    this.props.dispatch(getGeolocation());\n  }\n}\n\nexport default connect()(GeoButton); // just gives it dispatch()\n```\n\nAnother option is to keep your `GeoButton` “dumb”, that is, unaware of Redux.\n\n``` js\nclass GeoButton extends Component {\n  componentDidMount() {\n    this.props.fetch();\n  }\n}\n```\n\nThen you can bind it somewhere else:\n\n``` js\nlet GeoButtonThatKnowsWhatToDo = connect(null, { fetch: getGeolocation })(GeoButton);\n```\n"
      },
      {
        "user": "grgur",
        "created_at": "2015-08-21T11:11:52Z",
        "body": "Fantastic! Thanks @gaearon 👌\n"
      }
    ]
  },
  {
    "number": 584,
    "title": "Best practise of handling normalised Entities?",
    "created_at": "2015-08-19T21:29:56Z",
    "closed_at": "2015-08-20T21:38:08Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/reduxjs/redux/issues/584",
    "body": "In my first App with Redux, I am trying to keep my collections normalised as recommended. This way you only have to change the Entities in one place. (this feels right to me)\n\nAt first i successfully normalised my Array of data to an Array-like-Object of Entities with the id's as key's\n\nThen i wanted to list the entities in a View, so i had to parse it back to an Array. Also if i want to filter my Entities, i need the real Array. <b>Is this really the right approach? </b>\n\nExample with re-select:\n\n``` javascript\n    // As \"id\" for my images i use \"uri\"\n\n    imageEntities = {\n     uri1: {image...},\n     uri2: {image...},\n    ....\n    }\n\n    // Selectors:\n    const imagesSelector = state => state.images;\n\n    // parse the Array-like-Object to an Array\n    const imagesArySelector = createSelector(\n      [imagesSelector],\n          images => {\n            let ary = [];\n            for (var key in images) {\n              if (images.hasOwnProperty(key)) {\n                ary.push(images[key]);\n              }\n             }\n            return ary;\n          }\n     );\n\n    // filter the Array to get only the new images\n    export const newImagesSelector = createSelector(\n      [imagesArySelector],\n        images => images.filter(image => image.isNew)\n     );\n```\n\n<b>Is this really the right approach? </b> (it is working fine, from what i see until now)\n",
    "comments_url": "https://api.github.com/repos/reduxjs/redux/issues/584/comments",
    "author": "ms88privat",
    "comments": [
      {
        "user": "itsmepetrov",
        "created_at": "2015-08-20T07:20:51Z",
        "body": "I think it can be done more elegantly.\nHow I do it:\n\n``` js\nimport { createSelector } from 'reselect';\n\nconst providersSelector = state => state.entities.providers;\nconst subscribersSelector = state => state.entities.subscribers;\n\nexport const providersArraySelector = createSelector(\n    [providersSelector],\n    providers => Object.keys(providers).map(id => providers[id])\n);\n\nexport const subscribersArraySelector = createSelector(\n    [subscribersSelector],\n    subscribers => Object.keys(subscribers).map(id => subscribers[id])\n);\n```\n"
      },
      {
        "user": "ms88privat",
        "created_at": "2015-08-20T12:28:38Z",
        "body": "@itsmepetrov looks a'lot better... thx. \n\nSo in principle I am on the right track. Anybody else? \n"
      },
      {
        "user": "gaearon",
        "created_at": "2015-08-20T21:38:08Z",
        "body": "> Then i wanted to list the entities in a View, so i had to parse it back to an Array.\n\nYou can keep an array of IDs when arrays are more convenient to work with. You'll _need_ to do this for things like pagination. The `real-world` example in `examples` folder does that.\n"
      }
    ]
  },
  {
    "number": 562,
    "title": "Clearing State Between Views",
    "created_at": "2015-08-17T20:03:54Z",
    "closed_at": "2015-08-17T20:40:31Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/reduxjs/redux/issues/562",
    "body": "Howdy.\n\nThis is more of a general Flux question, but being incredibly interested and impressed with Redux I wanted to see how all of you approached the situation, since I've been wavering on it for a while.\n\nFlux and Redux implementations are both incredibly clear to me when you have state that persists across your entire application - Facebook commonly cites the canonical Todo app or FB chat in their examples. But what do you do when you have disparate views that require entirely new sets of data? By that I mean: what is the best way to discard of the unused data that still lives inside of other stores/reducers.\n\nCreating a global \"reset\" action seems like a poor (albeit easy) way of doing this, but it severely hampers the ability to create reducers that reliably persist (or don't) between views. Or do you instead have the component/route responsible for triggering the initial load action also trigger an action to clear it? Thinking about it the latter option seems the most intuitive to me, but hopefully somebody more well-versed than me can speak on the issue. Maybe it's just that simple and I'm overthinking it.\n\nIf anybody has any recommendations or could point me to some documentation I'd greatly appreciate it. Almost all of the Flux examples I've found implement fairly trivial applications, so I'm still left wondering how reducers are managed in the context of a larger application.\n\nThanks :)\n",
    "comments_url": "https://api.github.com/repos/reduxjs/redux/issues/562/comments",
    "author": "dvdzkwsk",
    "comments": [
      {
        "user": "gaearon",
        "created_at": "2015-08-17T20:35:09Z",
        "body": "> Or do you instead have the component/route responsible for triggering the initial load action also trigger an action to clear it?\n\nThis is how I'd do it.\n"
      },
      {
        "user": "dvdzkwsk",
        "created_at": "2015-08-17T20:40:09Z",
        "body": "Good enough for me, thanks.\n"
      }
    ]
  },
  {
    "number": 479,
    "title": "How to dynamicaly pass middlewares into store?",
    "created_at": "2015-08-13T17:08:07Z",
    "closed_at": "2015-08-13T17:12:41Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/reduxjs/redux/issues/479",
    "body": "My application uses redux and works on server and client sides. So I need to create 2 different stores, one for server side and one for client. For example, I don't want log actions on server side but want to do it on client. But middlewares passes to store not like an array and I can't dynamicaly create it.\nIt looks like:\n\n``` javascript\n// createStore.js\nimport { createStore, combineReducers, applyMiddleware } from 'redux';\nimport thunk from 'redux-thunk';\nimport callAPIMiddleware from './utils/middlewares/call-api-middleware';\nimport logger from 'redux-logger';\n\nimport * as reducers from './reducers';\n\nexport default function(state = {}) {\n    const reducer = combineReducers(reducers);\n    const createStoreWithMiddleware = applyMiddleware(logger, callAPIMiddleware, thunk)(createStore);\n\n    return createStoreWithMiddleware(reducer, state);\n}\n```\n\nHow could I remove logger middleware on server side? If it will be array of middleware it will be very simple:\n\n``` javascript\n/* global __SERVER__ */\nconst middlewares = [].concat(\n  (__SERVER__ ? [] : [logger]),\n  [callAPIMiddleware, thunk]\n);\n```\n",
    "comments_url": "https://api.github.com/repos/reduxjs/redux/issues/479/comments",
    "author": "tadjik1",
    "comments": [
      {
        "user": "tadjik1",
        "created_at": "2015-08-13T17:12:41Z",
        "body": "ups, sorry. If anyone wants to get solution - you could simply use spread two times:\n\n``` javascript\n/* global __SERVER__ */\nconst middlewares = [].concat(\n  (__SERVER__ ? [] : [logger]),\n  [callAPIMiddleware, thunk]\n);\n\napplyMiddleware(...middlewares)(createStore);\n```\n"
      },
      {
        "user": "gaearon",
        "created_at": "2015-08-13T17:12:50Z",
        "body": ":+1: \n"
      }
    ]
  },
  {
    "number": 421,
    "title": "Showing notifications from reducers",
    "created_at": "2015-08-07T15:06:21Z",
    "closed_at": "2015-08-07T15:18:57Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/reduxjs/redux/issues/421",
    "body": "Hey, \nI'm still trying to wrap my head around redux.\n\nNow, I've created a store that would trigger notifications:\n\n``` javascript\nimport {\n   CRUD_SAVE_SUCCESS,\n} from '../actions/action-types';\n\nconst initialState = {\n};\n\nexport default function notification(state = initialState, action = {}) {\n   console.log(\"Trigger\", action.type);\n   switch (action.type) {\n      case CRUD_SAVE_SUCCESS:\n         window.addNotification({\n            message: \"Saved.\",\n            level: \"success\",\n            title: \"Status\"\n         });\n         return state;\n      default:\n         return state;\n   }\n}\n\n```\n\nProblem is, a new notification is created every time the state changes. The console log showed to me, that every time the state changes, all previous actions are re-triggered. This results in a new notification for each state-change for each time `CRUD_SAVE_SUCCESS` is called, so 2 calls result in 2 notifications the next time `SOME_ACTION` is triggered. \n\nIs that the normal behaviour? Or might I have a bug somewhere in my code? Any idea how I could solve that problem?\n\nThanks!\n",
    "comments_url": "https://api.github.com/repos/reduxjs/redux/issues/421/comments",
    "author": "bkniffler",
    "comments": [
      {
        "user": "gaearon",
        "created_at": "2015-08-07T15:09:07Z",
        "body": "Your reducers (using 1.0 terminology) should not contain any side effects. They should be pure functions, just like `render()` function in React.\n\nYou want to do side effects in action creators instead. Can you show your action creator for `CRUD_SAVE_SUCCESS`?\n"
      },
      {
        "user": "bkniffler",
        "created_at": "2015-08-07T15:18:56Z",
        "body": "Okay, got it, thanks for the hint. Here is the action creator:\n\n``` javascript\nexport function save(model, instance) {\n   return {\n      types: [CRUD_SAVE, CRUD_SAVE_SUCCESS, CRUD_SAVE_FAIL],\n      promise: (client) => client.put(\"/\" + model + \"/\" + instance.id, instance).then((result)=>{\n         window.addNotification({\n            message: \"Saved.\",\n            level: \"success\",\n            title: \"Status\"\n         });\n\n         return {\n            data: result,\n            model: model\n         }\n      }, (error)=>{... gotta show error})\n   };\n}\n```\n\nUsing @erikras middleware\n\n``` javascript\nexport default function clientMiddleware(client) {\n   return ({/* dispatch, getState */}) => {\n      return (next) => (action) => {\n         const { promise, types, ...rest } = action;\n         if (!promise) {\n            return next(action);\n         }\n\n         const [REQUEST, SUCCESS, FAILURE] = types;\n         next({...rest, type: REQUEST});\n         return promise(client).then(\n            (result) => next({...rest, result, type: SUCCESS}),\n            (error) => next({...rest, error, type: FAILURE})\n         );\n      };\n   };\n}\n```\n"
      },
      {
        "user": "gaearon",
        "created_at": "2015-08-07T15:19:25Z",
        "body": "This makes sense!\n"
      }
    ]
  },
  {
    "number": 408,
    "title": "Reducer handling action meta data",
    "created_at": "2015-08-06T11:10:53Z",
    "closed_at": "2015-08-06T11:12:11Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/reduxjs/redux/issues/408",
    "body": "Hey folks, I was wondering if the following is valid:\n- I've got a middleware that handles promises; If the payload is a promise, the middleware handles the promise and forwards the action with some meta information:\n\n``` javascript\n{\n  type: 'TASKS_FETCH',\n  meta: {\n    promise: true,\n    status: 'PENDING'\n  }\n}\n```\n\nWhen the promise is resolved or rejected a corresponding action is triggered which looks like this:\n\n``` javascript\n{\n  type: 'TASKS_FETCH_SUCCESS',\n  meta: {\n    promise: true,\n    status: 'SUCCESS'\n  }\n}\n```\n\nNow, I want a `loading` reducer to react to those actions and count how many promises are pending:\n\n``` javascript\nconst initialState = { count: 0 };\n\nexport default function loading(state = initialState, action) {\n    if (action.meta && action.meta.promise) {\n        switch (action.meta.status) {\n            case 'PENDING':\n                return {\n                    count: state.count + 1\n                };\n            case 'SUCCESS':\n            case 'ERROR':\n                return {\n                    count: state.count - 1\n                };\n            default:\n                return state;\n        }\n    }\n\n    return state;\n}\n```\n\nWhat do you think, is handling meta data inside a reducer valid, do you see any problems?\n",
    "comments_url": "https://api.github.com/repos/reduxjs/redux/issues/408/comments",
    "author": "malte-wessel",
    "comments": [
      {
        "user": "gaearon",
        "created_at": "2015-08-06T11:12:11Z",
        "body": "This looks totally sensible to me.\n"
      }
    ]
  },
  {
    "number": 391,
    "title": "Question: where this the place for keeping \"isLoading\" state?",
    "created_at": "2015-08-04T08:32:44Z",
    "closed_at": "2015-08-04T10:22:44Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/reduxjs/redux/issues/391",
    "body": "Hello. Thanks for a perfect work and very useful tool!\nWe are trying to use it in our project and meet a next difficult situation:\n\nwe have a movies collection in our project. movies could be recommendation, new releases, free, etc. How should we construct our store for keep all of this types and movies and how we detect that free movies are loading but new releases already loaded? All of this collections are paginated.\n\nfor example movies reducer:\n\n``` javascript\nconst initialState = {\n  allMovies: {}, // id => movie\n  free: [], // id\n  releases: [], // id\n  ...,\n  search: new Map() // {search query} => [id1, id2, ...]\n};\n\nexport default function movies(state = initialState, action) {\n  const movies = selectn('payload.entities.movies', action);\n  const ids = selectn('payload.result.movies', action);\n\n  switch (action.type) {\n  case RECEIVED_NEW_RELEASES:\n    // add movies and return new state\n\n  case RECEIVED_FREE_MOVIES:\n    // add movies and return new state\n  default:\n   // return state\n  }\n}\n```\n\nSo, how can I detect that my request for free movies is in process or finished? Where this state should be placed?\n",
    "comments_url": "https://api.github.com/repos/reduxjs/redux/issues/391/comments",
    "author": "tadjik1",
    "comments": [
      {
        "user": "gaearon",
        "created_at": "2015-08-04T10:22:44Z",
        "body": "It's sensible to store `isFetching` together with other pagination information. Your data structure most likely will look like this:\n\n``` js\nconst initialState = {\n  allMovies: {}, // id => movie\n  free: {\n    ids: [],\n    nextPageUrl: string, // empty on last page, parsed from server response\n    isFetching: bool\n  },\n  releases: {\n    ids: [],\n    nextPageUrl: string, // empty on last page, parsed from server response\n    isFetching: bool\n  },\n  ...,\n  search: new Map() // {search query} => [id1, id2, ...]\n};\n```\n\nIt's also sensible to make something like `createPaginationReducer(actionTypes)` so you don't need to write this logic more than once.\n"
      },
      {
        "user": "tadjik1",
        "created_at": "2015-08-04T11:58:34Z",
        "body": "@gaearon Thanks!\n"
      }
    ]
  },
  {
    "number": 309,
    "title": "Synchronous dispatchs ",
    "created_at": "2015-07-23T16:39:50Z",
    "closed_at": "2015-07-23T17:07:26Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/reduxjs/redux/issues/309",
    "body": "Is there a way to execute dispatchs synchronously ?\n\nIn the following example I would like wait for `SEGMENTS_RULES_SET_PROJECT` action to be traited before executing last 2 actions creators.\nInfo: `SEGMENTS_RULES_SET_PROJECT` will set `userSlug` and `projectSlug` on store.\n\n``` JAVASCRIPT\n//actions creator.js\n\nexport function setProject({ userSlug, projectSlug }) {\n  return (dispatch) => {\n    dispatch({\n      type: ActionTypes.SEGMENTS_RULES_SET_PROJECT,\n      userSlug,\n      projectSlug,\n    });\n    dispatch(fetchProjectAnalyses({userSlug, projectSlug}));\n    dispatch(fetchAllRules({userSlug, projectSlug}));\n  };\n}\n\nexport function fetchProjectAnalyses({ userSlug, projectSlug }) { ... }\nexport function fetchAllRules({ userSlug, projectSlug }) { ... }\n```\n\nWhy ? Because it would allow `fetchProjectAnalyses` and `fetchAllRules` to get `userSlug` and `projectSlug` from `getState` instead having to receive it from function arguments. like:\n\nBad\n\n``` JAVASCRIPT\nexport function fetchProjectAnalyses(({ userSlug, projectSlug }) {\n  return (dispatch, getState) => {\n    let { segmentsRules: { editingRule, project: currentProject } } = getState();\n    ...\n  };\n}\n```\n\nGood: because it ensure to fetch analyses of the current project (in store)  \n\n``` JAVASCRIPT\nexport function fetchProjectAnalyses() {\n  return (dispatch, getState) => {\n    let { segmentsRules: { project: { userSlug, projectSlug } } } = getState();\n    ...\n  };\n}\n```\n",
    "comments_url": "https://api.github.com/repos/reduxjs/redux/issues/309/comments",
    "author": "zallek",
    "comments": [
      {
        "user": "gaearon",
        "created_at": "2015-07-23T16:40:46Z",
        "body": "This is definitely possible. Do you have a problem?\n"
      },
      {
        "user": "zallek",
        "created_at": "2015-07-23T17:06:38Z",
        "body": "OK my bad, that's working exactly as I wanted >< Might be tired, 19h time to go home !\n\nBTW, at @Botify we are using redux in production (on a small first project for now) and it's really great. Simple and pretty compared to some other flux implementations :)\n"
      },
      {
        "user": "gaearon",
        "created_at": "2015-07-23T17:07:26Z",
        "body": "Glad to hear it!\n"
      },
      {
        "user": "shrugs",
        "created_at": "2017-04-23T20:38:20Z",
        "body": "Just in case anyone stumbles into this PR searching for `redux dispatch synchronous`:\r\n\r\nthe dispatch function _is_ synchronous. Your reducer will be called before the code following `dispatch` is called. If you're using async reducers (by loading them in when a module of your app is loaded (perhaps using redux-router's async features), make sure the reducers are injected into the store before you dispatch actions that depend on those reducers.\r\n\r\nOf course, if you're using some sort of async dispatch pattern (like thunk or saga) the effects of that function are async, so there's no guarantee that they'll be finished by the time the original `dispatch` returns.\r\n\r\n```js\r\n\r\n// reducer\r\nexport default (state = {}, action) => {\r\n  // 2\r\n  return state\r\n}\r\n\r\n// some file\r\n\r\nconst actionCreator = () => ({ type: MY_ACTION })\r\n\r\n//...\r\n// 1\r\n dispatch(actionCreator())\r\n// 3\r\n```\r\n\r\nIs the execution order"
      },
      {
        "user": "markerikson",
        "created_at": "2017-04-24T02:02:18Z",
        "body": "To clarify that last comment a bit: the term \"async reducers\" generally refers to \"slice reducers that are dynamically added after the application has started\" (as opposed to \"slice reducers that are known and passed to `combineReducers` when the store was created\").  Reducer functions themselves should indeed be 100% synchronous."
      }
    ]
  },
  {
    "number": 222,
    "title": "State that doesn't fit into memory",
    "created_at": "2015-07-06T11:55:26Z",
    "closed_at": "2015-07-06T13:08:00Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/reduxjs/redux/issues/222",
    "body": "First off, there are some great ideas in this library, and I very muched enjoyed your talk at React Europe!\n\nA lot of Flux or Flux-like libraries focus on use cases where all state fits in memory, and never mentions how you would tackle use cases where you use WebSQL or IndexedDB to store state and only fect a subset of it on demand. If your stores implement getters, it's simple to put the on-demand queries there. But where do you put it with Redux?\n\nLet's say you have a todo app, but the number of todos are too big to have in memory. How would you approach that with Redux?\n",
    "comments_url": "https://api.github.com/repos/reduxjs/redux/issues/222/comments",
    "author": "andersekdahl",
    "comments": [
      {
        "user": "johanneslumpe",
        "created_at": "2015-07-06T12:22:07Z",
        "body": "You could implement a simple pagination. Then to fetch more data you'd just call an action which in turns fetches the data from your database backend. The new data gets passed to your reducers and updates the state.\n\nIt's not different from a normal async request I'd say. Except that you don't use a REST api or something, but a local database.\n"
      },
      {
        "user": "andersekdahl",
        "created_at": "2015-07-06T12:37:39Z",
        "body": "I agree that it's conceptually the same as going over the wire to fetch data, but it's often assumed that you fetch everything once and have everything in memory after that.\n\nDo you have an example to point at for pagination? And perhaps filtering of finished todos where the filtering isn't done on an array but having the backend/database do it.\n"
      },
      {
        "user": "andersekdahl",
        "created_at": "2015-07-06T12:48:02Z",
        "body": "I'm not looking for a silver bullet here. Handicaping the client by not letting it know everything about state management puts some tough constraints on it. Was just looking to see what your take it on it was.\n"
      },
      {
        "user": "andersekdahl",
        "created_at": "2015-07-06T13:01:36Z",
        "body": "(That is, when the server keeps state the client doesn't have. Different story with a client database with all state.)\n"
      },
      {
        "user": "johanneslumpe",
        "created_at": "2015-07-06T13:03:00Z",
        "body": "Sorry, I currently have no example :/ But pagination would just be the same as with a web api. You only need to know the total count, the current page you're on and the amount of items per page. Then you can easily construct a working pagination. (Without having to store anything in memory, each page could just be fetched from the db).\n\nFiltering would work the same, maybe something like this:\n\n``` javascript\nconst action = {\n  filterItemsByKeyword: (keyword) => {\n    return (dispatch, getState) => {\n      // you could also just pass in the current page into the action\n      const { currentPage } = getState().todos.pagination;\n\n      // whether the db is local or remote really does not matter\n      api.retrieveItemsFilteredByKeyword(keyword, currentPage)\n        .then(results => dispatch({type: ITEMS_FETCHED, payload: results}));\n    };\n  }\n}\n```\n\nDoes that help you?\n"
      },
      {
        "user": "andersekdahl",
        "created_at": "2015-07-06T13:08:00Z",
        "body": "I think it does, thanks! I suspect that I'm approaching this with a different mindset than I should. I'll play with it, and reopen if I find something interesting.\n"
      },
      {
        "user": "johanneslumpe",
        "created_at": "2015-07-06T13:09:06Z",
        "body": ":+1: \n"
      }
    ]
  },
  {
    "number": 1743,
    "title": "Rename createStore() second argument from initialState to preloadedState",
    "created_at": "2016-05-18T02:22:42Z",
    "closed_at": "2016-05-27T20:02:35Z",
    "labels": [
      "help wanted",
      "docs"
    ],
    "url": "https://github.com/reduxjs/redux/issues/1743",
    "body": "It has caused enough confusion. This argument is only meant for providing persisted state, not for putting an object literal with all app’s initial state in one place. We should make it more clear by renaming the argument both in the source and everywhere in the docs.\n",
    "comments_url": "https://api.github.com/repos/reduxjs/redux/issues/1743/comments",
    "author": "gaearon",
    "comments": [
      {
        "user": "gaearon",
        "created_at": "2016-05-18T02:23:30Z",
        "body": "(Arguably it’s also used for server rendering. Alternative naming suggestions are welcome. I just want to make it clear that it’s supposed to be generated and not written by hand.)\n"
      },
      {
        "user": "markerikson",
        "created_at": "2016-05-18T02:27:36Z",
        "body": "`importedState`?  `preloadedState`?\n"
      },
      {
        "user": "gaearon",
        "created_at": "2016-05-18T02:43:58Z",
        "body": "`preloadedState` looks better. More ideas are welcome.\n"
      },
      {
        "user": "BerkeleyTrue",
        "created_at": "2016-05-18T04:18:57Z",
        "body": "defaultState\n"
      },
      {
        "user": "JisuPark",
        "created_at": "2016-05-18T05:02:06Z",
        "body": "`preloadedState` looks good. Then how about `stateToSync`?\n"
      },
      {
        "user": "danibrear",
        "created_at": "2016-05-19T12:42:51Z",
        "body": "My only argument to keep it as initialState is when referring to \"currentState\" it sounds more fluid to say \"initial\" -> \"current\" as opposed to \"preloaded\" -> \"current\". \n"
      },
      {
        "user": "markerikson",
        "created_at": "2016-05-27T19:53:44Z",
        "body": "W00t!  Actually rather amused that my offhand suggestion of \"preloadedState\" worked out :)\n"
      },
      {
        "user": "gaearon",
        "created_at": "2016-05-27T20:02:34Z",
        "body": ":-)\n"
      }
    ]
  },
  {
    "number": 1687,
    "title": "Replace es3ify with Babel ES3 transforms",
    "created_at": "2016-05-01T22:59:50Z",
    "closed_at": "2016-05-02T14:30:31Z",
    "labels": [
      "help wanted",
      "infrastructure"
    ],
    "url": "https://github.com/reduxjs/redux/issues/1687",
    "body": "The only reason it was added is because Babel ES3 transforms were broken.\nThey have since been fixed.\n\nNow that es3ify itself is broken (see Travis), I’d appreciate somebody just putting those plugins in and removing es3ify from our build process.\n",
    "comments_url": "https://api.github.com/repos/reduxjs/redux/issues/1687/comments",
    "author": "gaearon",
    "comments": [
      {
        "user": "chentsulin",
        "created_at": "2016-05-02T12:48:37Z",
        "body": "Submitted a PR at #1688 \n"
      },
      {
        "user": "gaearon",
        "created_at": "2016-05-02T14:30:32Z",
        "body": "Thank you!\n"
      }
    ]
  },
  {
    "number": 1397,
    "title": "Add Tests to `todos` Example",
    "created_at": "2016-02-14T02:09:36Z",
    "closed_at": "2016-03-08T13:40:11Z",
    "labels": [
      "help wanted",
      "examples"
    ],
    "url": "https://github.com/reduxjs/redux/issues/1397",
    "body": "I'm looking for somebody to pair with on adding tests to the `todos` example. I would like to add container and component tests. Mocha has been used to the other tests, but I am open to use Jasmine and/or Jest.\n",
    "comments_url": "https://api.github.com/repos/reduxjs/redux/issues/1397/comments",
    "author": "badnorseman",
    "comments": [
      {
        "user": "jontewks",
        "created_at": "2016-02-14T02:10:24Z",
        "body": "I'd love to pair with you on this!\n"
      },
      {
        "user": "gaearon",
        "created_at": "2016-02-14T02:14:38Z",
        "body": "Let’s use Mocha everywhere for consistency. You can look at `todomvc` examples for inspiration.\n"
      },
      {
        "user": "badnorseman",
        "created_at": "2016-02-14T02:15:15Z",
        "body": "Awesome.\n"
      },
      {
        "user": "badnorseman",
        "created_at": "2016-02-14T02:15:35Z",
        "body": "@gaearon Got it. Thanks.\n"
      },
      {
        "user": "gaearon",
        "created_at": "2016-02-14T02:16:06Z",
        "body": "Coordinating on GitHub would be better so everybody can keep track of what’s happening.\n"
      },
      {
        "user": "weicheng113",
        "created_at": "2016-02-29T01:26:20Z",
        "body": "How about the unit tests i did in #1458? I think organizing it to be easier unit testable is more important.\n\nCheers, Cheng\n"
      },
      {
        "user": "gaearon",
        "created_at": "2016-03-08T13:40:11Z",
        "body": "Superseded by #1471 and #1493.\n"
      }
    ]
  },
  {
    "number": 1318,
    "title": "replaceReducer() should throw if argument is not a function ",
    "created_at": "2016-01-30T09:01:40Z",
    "closed_at": "2016-01-30T09:35:54Z",
    "labels": [
      "enhancement",
      "help wanted"
    ],
    "url": "https://github.com/reduxjs/redux/issues/1318",
    "body": "This is an easy one, please feel free to send a PR.\nWe want to add a `typeof` check in `replaceReducer` just like we have when the store is created. \n",
    "comments_url": "https://api.github.com/repos/reduxjs/redux/issues/1318/comments",
    "author": "gaearon",
    "comments": [
      {
        "user": "Andersos",
        "created_at": "2016-01-30T09:25:02Z",
        "body": "Hello @gaearon, I tried making a pull request for this in #1320 . Do you want me to also try and make a test for the case?\n"
      },
      {
        "user": "gaearon",
        "created_at": "2016-01-30T09:27:50Z",
        "body": "Thank you! Yes, tests are necessary.\n"
      },
      {
        "user": "gaearon",
        "created_at": "2016-01-30T09:35:54Z",
        "body": "This is now fixed by #1321, thanks @dzhiriki!\n"
      }
    ]
  },
  {
    "number": 374,
    "title": "Add examples to Travis suite",
    "created_at": "2015-07-30T23:01:09Z",
    "closed_at": "2015-07-31T19:20:48Z",
    "labels": [
      "help wanted",
      "infrastructure"
    ],
    "url": "https://github.com/reduxjs/redux/issues/374",
    "body": "From #373, the example code should build and run any tests successfully.\n",
    "comments_url": "https://api.github.com/repos/reduxjs/redux/issues/374/comments",
    "author": "quicksnap",
    "comments": [
      {
        "user": "quicksnap",
        "created_at": "2015-07-30T23:01:34Z",
        "body": "I'm going to look into this now and see if it's easy. \n"
      },
      {
        "user": "gaearon",
        "created_at": "2015-07-30T23:34:32Z",
        "body": "BTW in case you didn't see, you can use tests from #278 \n"
      },
      {
        "user": "quicksnap",
        "created_at": "2015-07-31T19:20:48Z",
        "body": "Closed by #375 \n"
      }
    ]
  },
  {
    "number": 173,
    "title": "Reducers (ex-'stores') must have a default return value for state to be initialized properly?",
    "created_at": "2015-06-23T19:18:22Z",
    "closed_at": "2015-06-29T21:19:40Z",
    "labels": [
      "enhancement",
      "help wanted"
    ],
    "url": "https://github.com/reduxjs/redux/issues/173",
    "body": "Just spent some half an hour figuring this out.\nSay I only had one action type to process in my reducer, so, based on my experience with 'vanilla flux', I did it like this:\n\n``` js\nexport default function myReducer (state = initialState, action) {\n  switch (action.type) {\n   case THE_ONE_ACTION_I_LISTEN_TO:\n     return { ...state, ...someNewStuff };\n  }\n}\n```\n\nAnd (of course it's obvious to me now) I get an `undefined` state before the first action run, not the `initialState`. So I had to add the\n\n``` js\ndefault: return state;\n```\n\nto correctly process the '@@INIT' action type. AFAIK that's nowhere to be found in the docs currently, guess it's just implied, but maybe mentioning it somewhere could save someone else a bit of time.\n",
    "comments_url": "https://api.github.com/repos/reduxjs/redux/issues/173/comments",
    "author": "burmisov",
    "comments": [
      {
        "user": "gaearon",
        "created_at": "2015-06-23T19:24:49Z",
        "body": "Sorry for this.\n\nI'd accept a PR checking that the return value of every store function inside `composeStores` is not `undefined`. This should cover the most common use case. Folks not using `composeStores` are assumed to know what they're doing anyway.\n\nThis will also need a test in `composeStores.spec.js`.\n"
      },
      {
        "user": "gaearon",
        "created_at": "2015-06-23T19:29:12Z",
        "body": "(And they're going to be `composeReducers` in the next version... But we're not there yet ;-)\n"
      },
      {
        "user": "gaearon",
        "created_at": "2015-06-23T22:52:00Z",
        "body": "Work in progress on fixing this: #174\n"
      },
      {
        "user": "gaearon",
        "created_at": "2015-06-29T15:40:44Z",
        "body": "@burmisov Thoughts on #191?\n"
      },
      {
        "user": "gaearon",
        "created_at": "2015-06-29T21:19:40Z",
        "body": "Superseded by #191.\n"
      }
    ]
  },
  {
    "number": 88,
    "title": "Investigate the library size and dependencies",
    "created_at": "2015-06-13T21:56:26Z",
    "closed_at": "2015-06-19T14:50:19Z",
    "labels": [
      "enhancement",
      "help wanted"
    ],
    "url": "https://github.com/reduxjs/redux/issues/88",
    "body": "I haven't given much attention to library size or dependencies yet, as we're still figuring out the right API. However, as people start to depend on it, it's a good idea to check whether we're dragging unnecessary polyfills (babel-runtime?) when it's easily avoidable, and whether there's something we could do to reduce the library size (we can start by adding a UMD build and measuring it! ;-)\n\nI'm currently busy but I'd be happy to see somebody investigate this. If you decide to do it, please let us know in this issue!\n",
    "comments_url": "https://api.github.com/repos/reduxjs/redux/issues/88/comments",
    "author": "gaearon",
    "comments": [
      {
        "user": "dariocravero",
        "created_at": "2015-06-19T14:43:49Z",
        "body": "@gaearon I think we can close this now :)\n"
      }
    ]
  }
]