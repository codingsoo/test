[
  {
    "number": 60971,
    "title": "TypeScript server crashes with out of memory exception",
    "created_at": "2025-01-15T00:23:42Z",
    "closed_at": "2025-01-17T00:02:08Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/60971",
    "body": "### 🔎 Search Terms\n\n\"TypeScript server\", \"OOM\", \"memory\", \"out of memory exception\"\n\n### 🕗 Version Information\n\nTypeScript version: 5.7.2\nVS Code version: 1.96.3\n\n### 💻 Description\n\nI am working on a large platform that provides APIs for users to call. Since most of the implementation is not in JavaScript, we provide declaration (`d.ts`) files with classes and methods so that users programming in JavaScript can have IntelliSense & type inference. However, the platform has been steadily growing over the years and now for the `d.ts` files we provide, there are over 7000 classes, and each class on average has over 100 methods.\n\n### 🙁 Actual behavior\n\nWhen the user is using VS Code and relying on the TypeScrpt server shipped as part of VS Code for IntelliSense and type inference, the TypeScript server processes exits. I can reproduce this while in debug mode and can see the error is due to `Out of memory exception`.\n\n### 🙂 Expected behavior\n\nThe TypeScript server process should not have exceeded its total maximum heap memory.\n\n### Additional information about the issue\n\nOn my computer, I am able to increase the memory used by TypeScript server using these VS Code settings:\n```json\n    \"typescript.tsserver.maxTsServerMemory\": 8192,\n    \"typescript.tsserver.nodePath\": \"node\",\n```\nHowever, this cannot be done for specific customers who are using much weaker computers, such as computers with 8 GB RAM. The total size of all our `d.ts` files are 91 MB, but profiling the TypeScript server process shows that loading all the `d.ts` files (excluding node_modules and all other declaration files) results in ~ 4 GB of heap memory used. This seems odd because that is over 40:1 ratio of heap memory to file size, which seems very high.\n\nThe contents of the `d.ts` files are very primitive, they all have a `declare class` with no `extends` or inheritance structure and have only fields and methods:\n```ts\ndeclare class ApiName {\n  field1: string;\n  field2: string;\n  static function1(): string;\n  static function2(): string;\n  // etc.........\n}\n```\nAll our users are developing in JavaScript (not TypeScript) so they are using a `jsconfig.json` with the following contents\n```json\n{\n  \"compilerOptions\": {\n    \"target\": \"ES6\",\n    \"lib\": [\n      \"ES2015\"\n    ],\n    \"checkJs\": false,\n    \"strictNullChecks\": true\n  },\n  \"include\": [\n    \"./src/**/*.js\",\n    \"./path to our dts files\",\n  ]\n}\n```\nI understand that this use case is kind of a stress test of TypeScript server, but hopefully creating this issue would reveal some improvements in terms of memory and if there is anything I can configure on my end for optimizations.",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/60971/comments",
    "author": "c3danielxu",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2025-01-15T00:28:59Z",
        "body": "We've optimized our memory footprint to the highest extent possible; if you're only seeing memory consumption as a linear output of input source size, there isn't an actionable bug here. We could possibly advise on specific optimizations to be made in the .d.ts files if we can look at them."
      },
      {
        "user": "c3danielxu",
        "created_at": "2025-01-15T00:40:26Z",
        "body": "Hi @RyanCavanaugh thanks for the quick response! Yes, I am seeing the memory consumption as linear - as number of files increase, the memory increase is also linear. Similarly, as methods are deleted in the classes, the memory decrease is linear. While I cannot provide the full `d.ts` files, they all have similar structuring:\n```ts\ndeclare class ClassName {\n // up to 10 fields\n\n // 50 static functions such as:\n static function50(): string;\n\n // 50 member functions such as\n memberfunction50(): string;\n}\n```\nI am discussing internally to see if we can eliminate APIs that aren't used. Also the reason there is no inheritance structure is because the backend is using multiple inheritance and JavaScript is single inheritance, which means `class Foo extends A, B, C` is not supported. Thus all the methods are inlined in the class for the `d.ts` files.\n\nHowever, is 40:1 ratio of heap memory usage to file size expected? That still seems rather high."
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2025-01-15T00:47:45Z",
        "body": "> However, is 40:1 ratio of heap memory usage to file size expected? That still seems rather high.\n\nThis is the current best representation we have found\n\nFor a .d.ts file, even if the backend isn't using inheritance, you can still get gains in memory footprint by using common interfaces, e.g.\n```ts\ndeclare class SomeClass {\n  // SomeClass-specific fields\n  d: boolean;\n}\n// Add common members to SomeClass\ninterface SomeClass extends CommonMembers1, CommonMembers2 { }\n\n// ...\n\ninterface SomeOtherClass extends CommonMembers2, CommonMembers3 { }\n\ninterface CommonMembers1 {\n  a: string;\n  b: number;\n}\n```\nDecreasing the repetition like this can help quite a bit, and is usually possible"
      },
      {
        "user": "c3danielxu",
        "created_at": "2025-01-15T01:18:01Z",
        "body": "> This is the current best representation we have found\n\nThanks for clarifying. In that case, I'll look into if we can decrease some of the repetition for methods that were declared on 2+ classes.\n\nDo you know if it is possible to have lazy/incremental loading of some sort in TypeScript? For example, there are groups of users who use different sets of classes, but none of them end up using all 7000 classes in their codebase. And in a given development session, the user probably uses even less APIs for intellisense, although we don't know what the user may or may not use.\n\nIs it possible for something like, load methods of a class into memory once it has been determined that we need to know about the class?"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2025-01-16T21:53:23Z",
        "body": "There isn't any way to \"lazy\" load a file, since any file could potentially contain a declaration that affects something else.\n\nIf you only use `import` statements to bring files into scope, then only the files imported (and their transitive imports) will be loaded, but then it'd be required for users to explicitly import their API subset. There isn't a way to \"un-load\" a file after it's already been explicitly included through whatever mechanism but not used, though a file that is not actually referenced tends to have minimal impact on memory footprint (presuming there's a reasonable number of them, of course)."
      },
      {
        "user": "c3danielxu",
        "created_at": "2025-01-17T00:01:59Z",
        "body": "That makes sense, that would explain why nothing came up with \"lazy\" loading when searching through TypeScript docs. Unfortunately all our APIs are available to user on the global scope so we can't leverage `require`/`import` capabilities for limiting the files.\n\nUsually for optimizations there are large areas of improvement before diminishing returns occurs so I was hoping there might be something we could do in TypeScript server, but if as you said there isn't that much room for improvement, then we might be out of luck and need to resort to other measures within my organization's codebase.\n\nThanks @RyanCavanaugh for your responses, it is really appreciated!"
      }
    ]
  },
  {
    "number": 60772,
    "title": "Type inference performance issue",
    "created_at": "2024-12-16T11:43:24Z",
    "closed_at": "2024-12-19T01:33:17Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/60772",
    "body": "### Acknowledgement\n\n- [x] I acknowledge that issues using this template may be closed without further explanation at the maintainer's discretion.\n\n### Comment\n\nI have been trying to use type inference for a specific case.\n```ts\ninterface Model {\n    field1: Date;\n    field2: number;\n}\n\ninterface Column<T, K extends keyof T = keyof T> {\n    field: K;\n    transformation?: (value: T[K], data: Model) => string;\n}\n\nconst columns: Column<Model>[] =  [\n    {\n        field: 'field1',\n        transformation: (value) => value.getTime()\n    }\n];\n```\nIn 'transformation,' I would like 'value' to be of type Date instead of being number | Date.\n\nTo achieve this, I created two helper types to get the union of possible 'field' types and to correctly infer the type from 'field' in the callback.\n```ts\ninterface Column<\n    T,\n    K extends NestedKeyOf<T>,\n    V extends NestedValueOf<T, K>,\n> {\n    field: K & string;\n    transformation?: (value: V, data: Model) => string;\n}\n```\n\nfor NestedKeyOf\n```ts\ntype NestedKeyOf<Type> = Type extends string | number\n  ? never\n  : {\n      [Key in TraversableKeys<Type>]: NestedSingleKeyOf<Type, Key>;\n    }[TraversableKeys<Type>];\n\ntype TraversableKeys<Type> = Exclude<keyof Type & (string | number), 'prototype'>;\n\ntype NestedSingleKeyOf<Type, Key extends keyof Type> = Key extends string\n  ? IsArray<\n      Type[Key],\n      Key | `${Key}.${number}`,\n      IsComplexObject<Type[Key], Key | `${Key}.${NestedKeyOf<Type[Key]>}`, Key>\n    >\n  : never;\n\ntype IsArray<O, T, F> = O extends Array<unknown> ? T : F;\n\ntype IsComplexObject<O, T, F> = O extends Date | Array<unknown> | Blob\n  ? F\n  : IsObject<O, T, F>;\n\ntype IsObject<O, T, F> = O extends object ? T : F;\n```\n\nfor NestedValueOf\n```ts\ntype NestedValueOf<Type, Key extends string> = Key extends `${infer Head}.${infer Tail}`\n  ? Head extends keyof Type\n    ? IsNumberFromString<\n        Tail,\n        IsArrayValue<Type[Head], NestedValueOf<Type[Head], Tail>>,\n        NestedValueOf<Type[Head], Tail>\n      >\n    : never\n  : IsKeyOfType<Type, Key>;\n\ntype IsArrayValue<O, F> = O extends Array<infer U> ? U : F;\n\ntype IsNumberFromString<O, T, F> = O extends `${number}` ? T : F;\n\ntype IsKeyOfType<Type, Key> = Key extends keyof Type ? Type[Key] : never;\n```\n\nThis way, the type of 'value' is correctly inferred in the callback. I can even access different levels of nesting using dots, such as 'field1.field1-2.field1-2-1,' or even array positions, inferring the correct type like 'field1.6'.\n\n\nFrom this point, my problem is that in cases with multiple levels of nesting (3 or more) and types with many properties (20–30 or more), it takes a long time to compute the corresponding type. **Is there any way to optimize the typing or handle it differently?**",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/60772/comments",
    "author": "gumartinezedicom",
    "comments": [
      {
        "user": "typescript-bot",
        "created_at": "2024-12-19T01:33:16Z",
        "body": "This issue has been marked as \"Question\" and has seen no recent activity. It has been automatically closed for house-keeping purposes."
      }
    ]
  },
  {
    "number": 60535,
    "title": "language services: If tsconfig.json under the ConguredProject project ignores some files, such as d.ts, opening these d.ts will create a new InferredProject. Is it designed like this?",
    "created_at": "2024-11-19T06:35:16Z",
    "closed_at": "2024-12-04T06:06:21Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/60535",
    "body": "### 🔎 Search Terms\n\nIf tsconfig.json under the ConguredProject project ignores some files, such as d.ts, opening these d.ts will create a new InferredProject. Is it designed like this?\n\n### 🕗 Version & Regression Information\n\nversion: 5.6.3\n\n### ⏯ Playground Link\n\n_No response_\n\n### 💻 Code\n\n```ts\n// Your code here\n```\n\n\n### 🙁 Actual behavior\n\nThe two project paths are the same, but the ProjectKind is different\n\n### 🙂 Expected behavior\n\nExpect not to create a new project\n\n### Additional information about the issue\n\n_No response_",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/60535/comments",
    "author": "schizobulia",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2024-12-02T07:08:08Z",
        "body": "Yes - why wouldn't it?"
      },
      {
        "user": "schizobulia",
        "created_at": "2024-12-03T07:01:08Z",
        "body": "> Yes - why wouldn't it?\n\nCan I ask why it is designed this way? 😀  @RyanCavanaugh "
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2024-12-03T18:59:02Z",
        "body": "The most likely scenario of opening a `.d.ts` file that wasn't part of a configured project is that it's the *output* of that configured project, so merging it into the same project context as the tsconfig would result in many \"duplicate identifier\" errors"
      },
      {
        "user": "schizobulia",
        "created_at": "2024-12-04T06:06:21Z",
        "body": "Got it. Thank you @RyanCavanaugh "
      }
    ]
  },
  {
    "number": 60245,
    "title": "Type of a generic is not narrowed",
    "created_at": "2024-10-16T17:50:28Z",
    "closed_at": "2024-10-20T01:32:39Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/60245",
    "body": "### 🔎 Search Terms\n\ngeneric narrowed class instance enum\n\n### 🕗 Version & Regression Information\n\n- This is the behavior in every version I tried, and I reviewed the FAQ for entries about narrowed.\n\n\n### ⏯ Playground Link\n\n_No response_\n\n### 💻 Code\n\n```ts\nenum Tag {\n  A,\n  B,\n  C,\n}\n\ninterface InterfaceByTag {\n  [Tag.A]: {\n    type: string;\n  };\n  [Tag.B]: {\n    type: number;\n  };\n  [Tag.C]: {\n    type: boolean;\n  };\n}\n\nclass C<\n  T extends Tag = Tag,\n> {\n  tag: T;\n  type: InterfaceByTag[T][\"type\"];\n\n  constructor(tag: T, type: InterfaceByTag[T][\"type\"]) {\n    this.tag = tag;\n    this.type = type;\n  }\n}\n\nconst tagIsA = new C(Tag.A, \"string\");\nconst tagIsAError = new C(Tag.A, 123);\n\nfunction test(instance: C) {\n  switch (instance.tag) {\n    case Tag.A: {\n      const type = instance.type; // should get string, but get string | number | boolean.\n      break;\n    }\n    case Tag.B: {\n      const type = instance.type; // Same as above\n      break;\n    }\n    case Tag.C: {\n      const type = instance.type; // Same as above\n      break;\n    }\n  }\n}\n```\n\n\n### 🙁 Actual behavior\n\nIt is not narrowed in the switch statement. In all case, the type of `instance.type` is `string | number | boolean`.\n\n### 🙂 Expected behavior\n\nI think the specific type has been identified In the switch statement. What I expected:\n```ts\n  switch (instance.tag) {\n    case Tag.A: {\n      const type = instance.type; // string\n      break;\n    }\n    case Tag.B: {\n      const type = instance.type; // number\n      break;\n    }\n    case Tag.C: {\n      const type = instance.type; // boolean\n      break;\n    }\n  }\n```\n\n### Additional information about the issue\n\n_No response_",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/60245/comments",
    "author": "Nlicro",
    "comments": [
      {
        "user": "MartinJohns",
        "created_at": "2024-10-16T17:54:43Z",
        "body": "This is working as intended. You do not specify the type parameter for `C` in your `test` function, so it falls back to the default `Tag`. That means the type is `C<Tag>`, which results in the type `{ tag: Tag, type: string | number | boolean }`. This is not a union type that can be narrowed."
      },
      {
        "user": "Nlicro",
        "created_at": "2024-10-16T18:16:49Z",
        "body": "> This is working as intended. You do not specify the type parameter for `C` in your `test` function, so it falls back to the default `Tag`. That means the type is `C<Tag>`, which results in the type `{ tag: Tag, type: string | number | boolean }`. This is not a union type that can be narrowed.\n\nI'm sorry that my example is a little wrong and you misunderstood it. I have updated the code. \nI mean the type in the switch statement, not the return type of `test` function"
      },
      {
        "user": "MartinJohns",
        "created_at": "2024-10-16T18:34:46Z",
        "body": "> you misunderstood it.\n\nI did not. The type of `instance` is `C<Tag>`, which results in the type `{ tag: Tag, type: string | number | boolean }`. It's **not** the type `{ tag: Tag.A, type: string } | { tag: Tag.B, type: number } | { tag: Tag.C, type: boolean }`, so it can't be narrowed the way you expect it to. It's perfectly valid to have the value `{ tag: Tag.A, type: true }` assigned to `C<Tag>`."
      },
      {
        "user": "Nlicro",
        "created_at": "2024-10-17T04:09:10Z",
        "body": "> > you misunderstood it.\n> \n> I did not. The type of `instance` is `C<Tag>`, which results in the type `{ tag: Tag, type: string | number | boolean }`. It's **not** the type `{ tag: Tag.A, type: string } | { tag: Tag.A, type: number } | { tag: Tag.C, type: boolean }`, so it can't be narrowed the way you expect it to. It's perfectly valid to have the value `{ tag: Tag.A, type: true }` assigned to `C<Tag>`.\n\nI see. Thank you for your explanation.\nNow I'm using `is` to narrow it. But as the number of enumerations grows and each `is` function needs to be defined, the if expression looks unpretty:\n```ts\nfunction isTagA(instance: C): instance is C<Tag.A> {\n  return instance.tag === Tag.A;\n}\n\nfunction test(instance: C) {\n  if (isTagA(instance)) {\n    const type = instance.type; // string\n  } else if(isTagB(instance)) {}\n  // more...\n}\n```\nI tried to refactor it in other ways like using `switch`, and here's the problem. \nIs there any way to associate the type of `tag` with  the type of `type`? I have no idea because  the type of `C` is a class instance and cannot be turned into a union type. That's why I use generic here."
      },
      {
        "user": "MartinJohns",
        "created_at": "2024-10-17T06:22:11Z",
        "body": "This approach is unsafe, as it does not align with your types. Again, `{ tag: tag.A, type: true }` is a perfectly valid assignment to the type `C`, but using your `isTagA` type guard it would wrongly assume the type of `type` is `string`, when it's actually `boolean`.\n\nYou seem to wrongly assume that `InterfaceByTag[T][\"type\"]` is a type depending on what's assigned to `tag`, but that's not the case. The type depends on whatever `T` is, which can be a union type as well - and actually is a union type when your type argument defaults to `Tag`.\n\nYou need to use a union of the types you want:\n- `C<Tag.A> | C<Tag.B> | C<Tag.C>`, which results in `{ tag: Tag.A, type: string } | { tag: Tag.A, type: number } | { tag: Tag.C, type: boolean }`\n- **not** `C<Tag>` or `C` (they're the same), which results in `{ tag: Tag, type: string | number | boolean }`\n\nYou could use a helper type and make use of distributive conditional types to get a union based on your tags: `type AllTagC<T extends Tag> = T extends Tag ? C<T> : never`  \nThen use it: `function test(instance: AllTagC<Tag>) { ... }`\n\nIt's crucial to understand what structure your types actually look like."
      },
      {
        "user": "typescript-bot",
        "created_at": "2024-10-20T01:32:39Z",
        "body": "This issue has been marked as \"Question\" and has seen no recent activity. It has been automatically closed for house-keeping purposes."
      }
    ]
  },
  {
    "number": 59878,
    "title": "Understanding type checker cache",
    "created_at": "2024-09-06T10:31:16Z",
    "closed_at": "2024-09-09T01:32:26Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/59878",
    "body": "### Acknowledgement\n\n- [X] I acknowledge that issues using this template may be closed without further explanation at the maintainer's discretion.\n\n### Comment\n\nI've written a library that offers complex types, the in-editor performance used to be very poor (> 2sec to get autocompletion). While looking at the trace and the output of  `--extendedDiagnostics`, I noticed more than 4M+ instantiations. So I've started to dive deep down the performance of the lib and through many optimizations I managed to lower the instantiations to about 1.4M and autocompletion to something that feels ~200ms.\r\n\r\n1.4M instantiations still feels quite high though, compared to other lib I've written, admittedly less complex.\r\n\r\nSo my question focuses on in-editor performance more than type-checking during build.\r\n\r\n1. Is there a way to measure improvement made on cache usage ? I assume `--extendedDiagnostics` will show less instantiations, right ? The check time can vary quite a bit, making it difficult to know if we are moving in the right direction.\r\n\r\n2. Given the following :\r\n\r\n  ```ts\r\ntype Arg1 = { title: string };\r\ntype Arg2 = { title: string };\r\n\r\ntype AsArray<T> = T extends unknown ? [T] : never;\r\n\r\ntype Result1 = AsArray<Arg1>;\r\ntype Result1bis = AsArray<Arg1>;\r\ntype Result2 = AsArray<Arg2>;\r\n```\r\n\r\nWill the cache be used to evaluate `Result1bis` ? What about `Result2` ? It's a different alias but it's exactly the same type.\r\n  I've read a bit of the compiler cache source code and I think it uses the type alias id so I would guess cache is used for `Result1bis` because it's the same type alias, but cache would not be used for `Result2`.\r\n\r\n3. What about in a nested, conditional type ?\r\n\r\n```ts\r\ntype Describe<T> =\r\n  T extends string ? `string: ${T}` :\r\n    T extends number ? `number: ${T}` :\r\n    `unknown`\r\n;\r\n\r\ntype DescribeAll<T> = T extends readonly [infer A] ? Describe<A> : never;\r\n\r\ntype Result1 = DescribeAll<['hi']>;\r\ntype Result2 = DescribeAll<[3, 'hi']>;\r\n```\r\n\r\nIn this scenario, will the cache be used when evaluating `Result2` ? `Describe<'hi'>` has already been evaluated before for `Result1`, so that step uses cache, right ?\r\n\r\n4. Is there any particular condition that would prevent hitting the cache ?",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/59878/comments",
    "author": "JesusTheHun",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2024-09-06T16:25:09Z",
        "body": "> Is there a way to measure improvement made on cache usage ? I assume --extendedDiagnostics will show less instantiations, right ?\n\nCorrect; the counts here are a good proxy for how much work is being saved/not-saved\n\n> Will the cache be used to evaluate `Result1bis` ? What about `Result2` ? It's a different alias but it's exactly the same type.\n\nThere's no interning of \"identical\" object types, so computations on `Arg1` and `Arg2` will be independent (literal types *are* interned). Identical instantiations are cached, so `Result1` and `Result1bis` will point to the same type.\n\n> In this scenario, will the cache be used when evaluating Result2 ? `Describe<'hi'>` has already been evaluated before for Result1, so that step uses cache, right ?\n\nYes (because literal types are interned)\n\n> Is there any particular condition that would prevent hitting the cache ?\n\nThis is pretty vague; I don't know how to give a useful answer"
      },
      {
        "user": "JesusTheHun",
        "created_at": "2024-09-06T21:34:38Z",
        "body": "> Yes (because literal types are interned)\r\n\r\nSo the following wouldn't hit the cache because the type arguments are objects ?\r\n\r\n```ts\r\ntype Result3 = DescribeAll<[{ title: string }, { tags: string[] }]>;\r\n```\r\n\r\n> This is pretty vague; I don't know how to give a useful answer\r\n\r\nFor example, for tail recursive evaluation to take place, the following conditions need to be met :\r\n\r\n> We tail-recurse for generic conditional types that (a) have not already been evaluated and cached, and\r\n(b) are non distributive, have a check type that is unaffected by instantiation, or have a non-union check\r\ntype. Note that recursion is possible only through aliased conditional types, so we only increment the tail"
      },
      {
        "user": "typescript-bot",
        "created_at": "2024-09-09T01:32:25Z",
        "body": "This issue has been marked as \"Question\" and has seen no recent activity. It has been automatically closed for house-keeping purposes."
      },
      {
        "user": "JesusTheHun",
        "created_at": "2024-09-09T08:18:28Z",
        "body": "Come on @typescript-bot ! Unlike you, humans need to rest !\r\n\r\nFor the following code, the number of instantiation increases by 4 each type I compute `AsArray<Arg1>`. \r\n\r\n```ts\r\ntype Arg1 = { title: string };\r\n\r\ntype AsArray<T> = T extends unknown ? [T] : never;\r\n\r\ntype Result1 = AsArray<Arg1>; // Instantiations : 4\r\ntype Result2 = AsArray<Arg1>; // Instantiations : 8\r\ntype Result3 = AsArray<Arg1>; // Instantiations : 12\r\n```\r\n\r\nI expected the number of instantiation to stay exactly the same, but apparently the evaluation it's not skipped entirely.\r\nSo I ran the following :\r\n\r\n```ts\r\ntype Describe<T> = T extends string\r\n  ? `string: ${T}`\r\n  : T extends number\r\n    ? `number: ${T}`\r\n    : `unknown`;\r\n\r\ntype DescribeAll<T extends ReadonlyArray<unknown>> = T extends [infer A, ...infer Rest]\r\n  ? Describe<A> | DescribeAll<Rest>\r\n  : never;\r\n\r\n// 29 instantiations\r\n\r\ntype Result1 = DescribeAll<['hi']>; // + 42 (71)\r\ntype Result2 = DescribeAll<['hi']>; // + 13 (84)\r\ntype Result3 = DescribeAll<['hi']>; // + 13 (97)\r\ntype Result4 = DescribeAll<['John']>; // + 22 (119)\r\ntype Result5 = DescribeAll<['Doe']>; // + 22 (141)\r\n\r\ntype Obj = { title: string };\r\ntype Obj2 = { title: string };\r\n\r\ntype Result6 = DescribeAll<[Obj]>; // + 22 instantiations (163)\r\ntype Result7 = DescribeAll<[Obj]>; // + 15 instantiations (178)\r\ntype Result8 = DescribeAll<[Obj2]>; // + 22 instantiations (200)\r\n```\r\n\r\nSo it looks like some things are cached. The first call to `DescribeAll` triggers `42` instantiations while subsequent calls with the same parameter cost only `13`. Calls with a new string parameter cost `22` so I guess out of the `42` instantiations required to evaluate the type, 13 can't ever be cached, and 9 needs to be evaluate for each new parameter met.\r\n\r\n"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2024-09-09T15:47:12Z",
        "body": "> So the following wouldn't hit the cache because the type arguments are objects ?\n\nCorrect, type literals will get their own ID and thus be a cache miss.\n\nAt the level of analysis you're doing here, I'd recommend setting a few breakpoints in tsc and stepping through it. It'll be much more instructive (and accurate!) than my prose."
      }
    ]
  },
  {
    "number": 58517,
    "title": "ts.createSourceFile trims leading newlines, causing stored line numbers to mismatch",
    "created_at": "2024-05-13T11:58:21Z",
    "closed_at": "2024-05-17T01:28:53Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/58517",
    "body": "### 🔎 Search Terms\n\ncreateSourceFile newlines trim\n\n### 🕗 Version & Regression Information\n\n- This is the behavior in every version I tried, and I reviewed the FAQ for entries about createSourceFile\n\n### ⏯ Playground Link\n\n_No response_\n\n### 💻 Code\n\n```ts\r\n\r\n\r\n\r\nimport React from 'react';\r\n\r\nexport default function HelloWorldView() {\r\n  return <span>Hello</span>;\r\n}\r\n```\r\n\r\n\n\n### 🙁 Actual behavior\n\nGiven this TSX file, React tooling will store a source reference on the `<span>` element as e.g. \r\n```\r\n$0.__reactFiber$wzqrbgzp6o._debugSource\r\n```\r\n\r\nand it will contain\r\n\r\n```\r\n{\r\ncolumnNumber: 10,\r\nfileName: \".../something.tsx\",\r\nlineNumber: 7\r\n}\r\n```\r\n\r\nHowever, if you feed the TSX file into `ts.createSourceFile` and look for an element on line 7, you will not find anything because the file has been changed to\r\n```\r\nimport React from 'react';\r\n\r\nexport default function HelloWorldView() {\r\n  return <span>Hello</span>;\r\n}\r\n```\r\nand it only has 5 lines\r\n\n\n### 🙂 Expected behavior\n\nts.createSourceFile does no transformations whatsoever on the given input\n\n### Additional information about the issue\n\n_No response_",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/58517/comments",
    "author": "Artur-",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2024-05-13T16:48:28Z",
        "body": "TS obviously preserves the line information enough to e.g. give you correct line numbers on the commandline when showing errors. Can you clarify which API you're calling and how?"
      },
      {
        "user": "Artur-",
        "created_at": "2024-05-13T17:43:29Z",
        "body": "Not sure this is a meaningful test, reproducing what is shown in a larger case is always difficult. I will dig more into this tomorrow and ensure the problem is not elsewhere. Anyway, given `a.ts`\r\n```\r\n\r\n\r\n\r\n\r\nconst ts = require(\"typescript\");\r\nconst { readFileSync } = require(\"fs\");\r\n\r\nconst sourceText = readFileSync(\"a.ts\", {encoding: 'utf-8'});\r\nconst sourceFile = ts.createSourceFile('test.tsx', sourceText, ts.ScriptTarget.Latest, true);\r\nconsole.log(sourceFile.getText());\r\n\r\n\r\n\r\n\r\n\r\n```\r\n\r\nand `package.json` \r\n\r\n```\r\n{\r\n  \"name\": \"tstest\",\r\n  \"version\": \"1.0.0\",\r\n  \"description\": \"\",\r\n  \"main\": \"index.js\",\r\n  \"scripts\": {\r\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"\r\n  },\r\n  \"author\": \"\",\r\n  \"license\": \"ISC\",\r\n  \"devDependencies\": {\r\n    \"typescript\": \"^5.4.5\"\r\n  }\r\n}\r\n```\r\n\r\nthen running\r\n\r\n```\r\nnode_modules/.bin/tsc a.ts && node a\r\n```\r\n\r\noutputs\r\n```\r\nconst ts = require(\"typescript\");\r\nconst { readFileSync } = require(\"fs\");\r\n\r\nconst sourceText = readFileSync(\"a.ts\", {encoding: 'utf-8'});\r\nconst sourceFile = ts.createSourceFile('test.tsx', sourceText, ts.ScriptTarget.Latest, true);\r\nconsole.log(sourceFile.getText());\r\n\r\n\r\n\r\n\r\n```\r\n\r\nwhich includes trailing newlines but not leading ones."
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2024-05-13T18:42:45Z",
        "body": "Use `getFullText()` for that operation"
      },
      {
        "user": "Artur-",
        "created_at": "2024-05-14T06:04:31Z",
        "body": "Ok, so now that I am aware of `getFullText()` I am guessing that the main problem is the use of `getStart()` and `getEnd()` instead of `getFullStart()` and `getFullWidth()` in our code. Where should I have been able to find out about full vs non-full versions of the methods?"
      },
      {
        "user": "typescript-bot",
        "created_at": "2024-05-17T01:28:53Z",
        "body": "This issue has been marked as \"Question\" and has seen no recent activity. It has been automatically closed for house-keeping purposes."
      }
    ]
  },
  {
    "number": 58382,
    "title": "Type inference: is that a bug?",
    "created_at": "2024-05-01T01:51:32Z",
    "closed_at": "2024-05-02T01:16:20Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/58382",
    "body": "### Acknowledgement\n\n- [X] I acknowledge that issues using this template may be closed without further explanation at the maintainer's discretion.\n\n### Comment\n\nI'm not sure if the following is a bug or if it's working as intended.\r\n\r\n```ts\r\ninterface Entry<P, D> {\r\n  point: P\r\n  datum: D\r\n}\r\n\r\nclass X<P, D, E extends Entry<P, D>> {\r\n  readonly p: P\r\n  readonly d: D\r\n\r\n  constructor(entry: E) {\r\n    this.p = entry.point\r\n    this.d = entry.datum\r\n  }\r\n}\r\n\r\nconst a = new X({ point: 1, datum: 'a'})\r\n```\r\n\r\nHere, `a` is inferred to be of type `X<unknown, unknown, { point: number; datum: string; }>` (while `a.p` and `a.d` have the correct types).\r\n\r\nI expected it to be of type `X<number, string, { point: number; datum: string; }>`.\r\n\r\nCan anybody explain what's going on here? I'm using Typescript 5.4.3.",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/58382/comments",
    "author": "jcayzac",
    "comments": [
      {
        "user": "Andarist",
        "created_at": "2024-05-01T07:49:37Z",
        "body": "This is just not something that TS supports. Inference targets have to appear in parameter lists - the \"sources\" in constraints of other type parameters are ignored. An even simpler repro:\r\n```ts\r\ninterface Box<T> {\r\n  value: T;\r\n}\r\nfunction test<T, B extends Box<T>>(a: B) {}\r\ntest({ value: 10 });\r\n```\r\n\r\nArguably, you probably don't want this signature. In situations like this you probably don't want to allow such calls:\r\n```ts\r\nnew X<number, string, { point: 1, datum: 'a' }>({ point: 1, datum: 'a' })\r\n```\r\n\r\nI'd assume that your `E` should be strictly `{ point: number, datum: string }` here but your signature allows different subtypes of that.\r\n"
      },
      {
        "user": "jcalz",
        "created_at": "2024-05-01T16:44:52Z",
        "body": "see #7234 which was not implemented in favor of having people use intersections instead.  "
      },
      {
        "user": "jcayzac",
        "created_at": "2024-05-02T01:16:20Z",
        "body": "Thank you both, @Andarist @jcalz "
      }
    ]
  },
  {
    "number": 57789,
    "title": "TypeScript only find types",
    "created_at": "2024-03-15T10:37:46Z",
    "closed_at": "2024-03-15T17:45:00Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/57789",
    "body": "### 🔎 Search Terms\n\nTS18042, TS2693, import, exports, types\n\n### 🕗 Version & Regression Information\n\n- This is the behavior in every version I tried (_5.4.2_ and _5.0.2_), and I reviewed the FAQ for entries about _exports_.\n\n### ⏯ Playground Link\n\n_No response_\n\n### 💻 Code\n\n- `package.json`\r\n\r\n  ```JSON\r\n  {\r\n    \"name\": \"testcase\",\r\n    \"version\": \"1.0.0\",\r\n    \"type\": \"module\",\r\n    \"dependencies\": {\r\n      \"subproject\": \"./subproject/\",\r\n      \"typescript\": \"5.4.2\"\r\n    }\r\n  }\r\n  ```\r\n\r\n- `index.js`\r\n\r\n  ```JavaScript\r\n  import sub from \"subproject\";\r\n\r\n  console.log(sub.foo);\r\n  ```\r\n\r\n- `subproject/`\r\n  - `package.json`\r\n\r\n    ```JSON\r\n    {\r\n      \"name\": \"subproject\",\r\n      \"version\": \"1.0.0\",\r\n      \"type\": \"module\",\r\n      \"exports\": {\r\n        \".\": {\r\n          \"types\": \"./sub.d.ts\",\r\n          \"default\": \"./sub.js\"\r\n        }\r\n      }\r\n    }\r\n    ```\r\n\r\n  - `sub.js`\r\n\r\n    ```JavaScript\r\n    export default {\r\n      foo: \"bar\",\r\n      baz: 42,\r\n    };\r\n    ```\r\n\r\n  - `sub.d.ts`\r\n\r\n    ```TypeScript\r\n    declare type _default = {\r\n      foo: string;\r\n      baz: number;\r\n    };\r\n\r\n    export default _default;\r\n    ```\r\n\r\n1. `npm install`\r\n2. `npx tsc --noEmit --checkJs --module nodenext index.js`\r\n   or `npx tsc --noEmit --checkJs --module nodenext --moduleResolution nodenext index.js`\n\n### 🙁 Actual behavior\n\n```\r\nindex.js:1:8 - error TS18042: 'sub' is a type and cannot be imported in JavaScript files. Use 'import(\"subproject\").sub' in a JSDoc type annotation.\r\n\r\n1 import sub from \"subproject\";\r\n         ~~~\r\n\r\nindex.js:3:13 - error TS2693: 'sub' only refers to a type, but is being used as a value here.\r\n\r\n3 console.log(sub.foo);\r\n              ~~~\r\n\r\n\r\nFound 2 errors in the same file, starting at: index.js:1\r\n```\n\n### 🙂 Expected behavior\n\nNo error.\n\n### Additional information about the issue\n\nI also reproduce the bug with `npm pack` and:\r\n\r\n```JSON\r\n{\r\n  \"dependencies\": {\r\n    \"subproject\": \"./subproject/subproject-1.0.0.tgz\",\r\n  }\r\n}\r\n```",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/57789/comments",
    "author": "regseb",
    "comments": [
      {
        "user": "regseb",
        "created_at": "2024-03-15T10:58:23Z",
        "body": "I'm having the same problem with a TypeScript file:\r\n\r\n```TypeScript\r\n// index.ts\r\nimport type subType from \"subproject\";\r\nimport sub from \"subproject\";\r\n\r\nconst a: subType = {\r\n    foo: \"bar\",\r\n    baz: \"Not a Number\",\r\n};\r\nconst b: sub = {\r\n    foo: \"bar\",\r\n    baz: \"Not a Number\",\r\n};\r\n\r\nconsole.log(sub.foo);\r\n```\r\n\r\n`npx tsc --noEmit --module nodenext index.ts`\r\n\r\n```\r\nindex.ts:7:5 - error TS2322: Type 'string' is not assignable to type 'number'.\r\n\r\n7     baz: \"Not a Number\",\r\n      ~~~\r\n\r\n  node_modules/subproject/sub.d.ts:3:5\r\n    3     baz: number;\r\n          ~~~\r\n    The expected type comes from property 'baz' which is declared here on type '_default'\r\n\r\nindex.ts:11:5 - error TS2322: Type 'string' is not assignable to type 'number'.\r\n\r\n11     baz: \"Not a Number\",\r\n       ~~~\r\n\r\n  node_modules/subproject/sub.d.ts:3:5\r\n    3     baz: number;\r\n          ~~~\r\n    The expected type comes from property 'baz' which is declared here on type '_default'\r\n\r\nindex.ts:14:13 - error TS2693: 'sub' only refers to a type, but is being used as a value here.\r\n\r\n14 console.log(sub.foo);\r\n               ~~~\r\n\r\n\r\nFound 3 errors in the same file, starting at: index.ts:7\r\n```"
      },
      {
        "user": "IllusionMH",
        "created_at": "2024-03-15T11:59:37Z",
        "body": "`types` in `exports` section override/shadow `import`/`require` and in your declarations you only export type.\n\nTo export value you need to declare const and export it as default IIRC"
      },
      {
        "user": "jakebailey",
        "created_at": "2024-03-15T14:43:44Z",
        "body": "```ts\r\ndeclare const _default: {\r\n  foo: string;\r\n  baz: number;\r\n};\r\n\r\nexport default _default;\r\n```"
      },
      {
        "user": "jakebailey",
        "created_at": "2024-03-15T14:45:32Z",
        "body": "If you're already using TypeScript, you'd be better of using it to produce your declaration files instead of doing it by hand; it would have done the right thing."
      },
      {
        "user": "regseb",
        "created_at": "2024-03-15T17:45:01Z",
        "body": "Thank you for your feedback. I understood the association between _.js_ and _.d.ts_ files. The _.d.ts_ file:\r\n\r\n- must **not** export the type of JavaScript objects.\r\n- must export typed JavaScript objects.\r\n\r\n---\r\n\r\nI want to add typing to a JavaScript project. That's why I'm writing the declaration file by hand. And then I use TypeScript and JSDoc to validate the types in the JavaScript files."
      }
    ]
  },
  {
    "number": 57576,
    "title": "How to stop emitting declaration files for tests ",
    "created_at": "2024-02-28T18:03:03Z",
    "closed_at": "2024-03-02T01:23:38Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/57576",
    "body": "### Acknowledgement\r\n\r\n- [x] I acknowledge that issues using this template may be closed without further explanation at the maintainer's discretion.\r\n\r\n### Comment\r\n\r\nHi Team,\r\n\r\nI have a src dir, inside which there are certain files/dirs for which I do not want to generate declaration types for. If i mention these files in exclude, these files miss on typescript compilation, which is needed for my case. Is there a way to achieve this? Am I missing something obvious here?\r\n\r\nI don't want to generate types for my tests. I am authoring a package\n```[tasklist]\n### Tasks\n```\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/57576/comments",
    "author": "truedrug",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2024-02-28T22:18:45Z",
        "body": "Project references - set up a `test` project with declaration off and reference the non-test project"
      },
      {
        "user": "typescript-bot",
        "created_at": "2024-03-02T01:23:38Z",
        "body": "This issue has been marked as \"Question\" and has seen no recent activity. It has been automatically closed for house-keeping purposes."
      },
      {
        "user": "truedrug",
        "created_at": "2024-03-02T01:26:14Z",
        "body": "Got it, so i will either use this or may be run a script to delete these unnecessary d.ts files post build. Thanks. Will update here, so it helps the community "
      },
      {
        "user": "jakebailey",
        "created_at": "2024-03-02T01:27:54Z",
        "body": "I personally put my tests in `__tests__` and then npmignore them, which also works (if you don't care about purity)."
      },
      {
        "user": "truedrug",
        "created_at": "2024-03-03T07:24:31Z",
        "body": "\r\n@jakebailey thanks. I learned something new today :)\r\n\r\n"
      },
      {
        "user": "truedrug",
        "created_at": "2024-03-03T09:34:56Z",
        "body": "For now, I have fixed this by running a script post webpack build. For someone interested:\r\n\r\n`index.js`\r\n\r\n```\"use strict\";\r\n\r\nconst deleteFilesAndDirectories = require(\"./delete-files-and-dirs\");\r\n\r\nclass DeleteSelectiveDeclarationFiles {\r\n  constructor(paths) {\r\n    this.paths = paths;\r\n  }\r\n\r\n  apply(compiler) {\r\n    compiler.hooks.afterEmit.tap(\"DeleteSelectiveDeclarationFiles\", () => {\r\n      deleteFilesAndDirectories(\"lib\", this.paths);\r\n    });\r\n  }\r\n}\r\n\r\nmodule.exports = DeleteSelectiveDeclarationFiles;\r\n```\r\n\r\n`delete-files-and-dirs.js`:\r\n```\r\nconst fs = require(\"fs\").promises;\r\nconst path = require(\"path\");\r\nconst glob = require(\"glob\");\r\n\r\nasync function deleteFilesAndDirectories(directoryPath, patterns) {\r\n  directoryPath = path.resolve(directoryPath);\r\n\r\n  for (const pattern of patterns) {\r\n    const filesAndDirectories = glob.sync(pattern, {\r\n      cwd: directoryPath,\r\n      dot: true,\r\n    });\r\n\r\n    for (const fileOrDir of filesAndDirectories) {\r\n      const fullPath = path.join(directoryPath, fileOrDir);\r\n      try {\r\n        if ((await fs.lstat(fullPath)).isDirectory()) {\r\n          await fs.rm(fullPath, { recursive: true });\r\n        } else {\r\n          await fs.unlink(fullPath);\r\n        }\r\n      } catch (error) {\r\n        console.error(`Error deleting ${fullPath}: ${error.message}`);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nmodule.exports = deleteFilesAndDirectories;\r\n```\r\n\r\n`Usage inside webpack`\r\n```\r\n// Delete unwanted declaration files\r\nconst files = [\"__tests__\", \"test-utils.d.ts\", \"theme\", \"**/*.stories.d.ts\"];\r\nconst plugins = [\r\n  ......,\r\n  new DeleteSelectiveDeclarationFiles(files),\r\n];\r\n```"
      }
    ]
  },
  {
    "number": 57278,
    "title": "where is TypeScript Language Specification pdf file ?",
    "created_at": "2024-02-03T05:59:06Z",
    "closed_at": "2024-02-05T16:24:07Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/57278",
    "body": "### Acknowledgement\n\n- [X] I acknowledge that issues using this template may be closed without further explanation at the maintainer's discretion.\n\n### Comment\n\nwhere is TypeScript Language Specification pdf file ?",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/57278/comments",
    "author": "ghyaoutlook",
    "comments": [
      {
        "user": "MartinJohns",
        "created_at": "2024-02-03T06:10:22Z",
        "body": "There is no specification."
      },
      {
        "user": "fatcerberus",
        "created_at": "2024-02-03T06:25:49Z",
        "body": "TypeScript as it exists today has no specification.  Git history is public so you can find the old version if you go back far enough, but that document is *very* old and outdated, and likely isn't useful for anything except historical curiosity."
      }
    ]
  },
  {
    "number": 57178,
    "title": "TS 5.4 beta release tag not available",
    "created_at": "2024-01-25T22:41:25Z",
    "closed_at": "2024-01-29T01:25:33Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/57178",
    "body": "### Acknowledgement\n\n- [X] I acknowledge that issues using this template may be closed without further explanation at the maintainer's discretion.\n\n### Comment\n\nHas TS 5.4 beta been released? When I do `git tag`, I don't see a `v5.4-beta` branch. \r\n\r\nCan you guys create a branch so we can bring TS 5.4 into Google and report feedback to you.",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/57178/comments",
    "author": "rahul-kamat",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2024-01-25T22:55:48Z",
        "body": "5.4 beta isn't out yet. Ping here again if you don't see the release tag in github once the 5.4-beta release is on npm (these should happen basically simultaneously)"
      },
      {
        "user": "rahul-kamat",
        "created_at": "2024-01-25T22:59:42Z",
        "body": "Ok sounds good thank you :)"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2024-01-26T18:06:44Z",
        "body": "Just as a heads up, we will probably go out with the 5.4 beta next Monday, since we're having some issues with the NuGet side of the build pipeline."
      },
      {
        "user": "typescript-bot",
        "created_at": "2024-01-29T01:25:33Z",
        "body": "This issue has been marked as \"Question\" and has seen no recent activity. It has been automatically closed for house-keeping purposes."
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2024-01-29T23:59:36Z",
        "body": "FYI, 5.4 beta is now available"
      }
    ]
  },
  {
    "number": 57169,
    "title": "ts.ImportDeclaration.moduleSpecifier can`t run  getText(), because node don`t have parent.",
    "created_at": "2024-01-25T09:37:54Z",
    "closed_at": "2024-01-28T01:28:02Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/57169",
    "body": "### 🔎 Search Terms\n\nImportDeclaration.moduleSpecifier.getText()\n\n### 🕗 Version & Regression Information\n\n- This is a crash\r\n- This changed between versions ______ and _______\r\n- This changed in commit or PR _______\r\n- This is the behavior in every version I tried, and I reviewed the FAQ for entries about _________\r\n- I was unable to test this on prior versions because _______\r\n\n\n### ⏯ Playground Link\n\n_No response_\n\n### 💻 Code\n\n```ts\r\n// Your code here\r\nfunction main (){\r\n    const sourceFile = ts.createSourceFile(\"test.ts\",\r\n    `\r\n    import ts from \"typescript\"\r\n    `\r\n    ,ts.ScriptTarget.ES2022)\r\n    \r\n    const imports: { packageName: string, importedObjects: string[] }[] = [];\r\n\r\n    function visit(node: ts.Node) {\r\n        if (ts.isImportDeclaration(node)) {\r\n            // console.log((node.moduleSpecifier as any).text )\r\n        const packageName = node.moduleSpecifier.getText().slice(1, -1); // Remove quotes from package name\r\n        const importedObjects: string[] = [];\r\n\r\n        if (node.importClause && node.importClause.namedBindings && ts.isNamedImports(node.importClause.namedBindings)) {\r\n            node.importClause.namedBindings.elements.forEach((element) => {\r\n            importedObjects.push(element.name.getText());\r\n            });\r\n        }\r\n\r\n        imports.push({ packageName, importedObjects });\r\n        }\r\n\r\n        ts.forEachChild(node, visit);\r\n    }\r\n    visit(sourceFile)\r\n}\r\nmain();\r\n\r\n\r\n```\r\n\n\n### 🙁 Actual behavior\n\n```\r\nTypeError: Cannot read properties of undefined (reading 'text')\r\n    at NodeObject.getText (D:\\project\\2\\ts\\node_modules\\typescript\\lib\\typescript.js:134343:29)\r\n    at visit (D:\\project\\2\\ts\\dist\\SdkScript\\index.js:56:58)\r\n    at visitNodes (D:\\project\\2\\ts\\node_modules\\typescript\\lib\\typescript.js:27591:24)\r\n    at forEachChildInSourceFile (D:\\project\\2\\ts\\node_modules\\typescript\\lib\\typescript.js:28211:18)\r\n    at Object.forEachChild (D:\\project\\2\\ts\\node_modules\\typescript\\lib\\typescript.js:27676:37)\r\n    at visit (D:\\project\\2\\ts\\dist\\SdkScript\\index.js:65:34)\r\n    at D:\\project\\2\\ts\\dist\\SdkScript\\index.js:67:9\r\n    at Generator.next (<anonymous>)\r\n    at D:\\project\\2\\ts\\dist\\SdkScript\\index.js:11:71\r\n    at new Promise (<anonymous>)\r\n    \r\n```\r\n\r\n```ts\r\n\r\n        function getSourceFileOfNode(node) {\r\n          while (node && node.kind !== 308 /* SourceFile */) {\r\n          \r\n          //error\r\n          \r\n            node = node.parent;\r\n          }\r\n          return node;\r\n        }\r\n        \r\n         getSourceFile() {\r\n          return getSourceFileOfNode(this);\r\n        }\r\n        \r\n         getText(sourceFile) {\r\n          this.assertHasRealPosition();\r\n          if (!sourceFile) {\r\n          // error\r\n            sourceFile = this.getSourceFile();\r\n          }\r\n          return sourceFile.text.substring(this.getStart(sourceFile), this.getEnd());\r\n        }\r\n\r\n\r\n```\n\n### 🙂 Expected behavior\n\nreturn 'typescript'\n\n### Additional information about the issue\n\n_No response_",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/57169/comments",
    "author": "ouyangxuxiang",
    "comments": [
      {
        "user": "Andarist",
        "created_at": "2024-01-25T10:42:44Z",
        "body": "You can just call `element.name.getText(sourceFile);` to work around your problem. TS doesn't always set up `.parent` references on the parsed nodes - it usually happens in the binder."
      },
      {
        "user": "jakebailey",
        "created_at": "2024-01-25T16:25:19Z",
        "body": "Yeah, you either need to pass the flag to the parser to set parents, or pass in the source file. Both of these are performance related things (many transformers don't need parents, and walking up the parents every single time is slow)."
      },
      {
        "user": "typescript-bot",
        "created_at": "2024-01-28T01:28:01Z",
        "body": "This issue has been marked as \"Question\" and has seen no recent activity. It has been automatically closed for house-keeping purposes."
      }
    ]
  },
  {
    "number": 57168,
    "title": "(Is it possible to | please provide a way to) specify the main module in a System-JS \"outFile\" bundle?",
    "created_at": "2024-01-25T08:24:15Z",
    "closed_at": "2024-01-26T19:02:54Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/57168",
    "body": "### Acknowledgement\n\n- [X] I acknowledge that issues using this template may be closed without further explanation at the maintainer's discretion.\n\n### Comment\n\nWhen loading a bundle of several modules in a browser, System-JS only \"executes\" the first one, unless there a call to System.import later, e.g. in the page itself. By executing, I mean running the global statements in the source .ts file.\r\n\r\nThe trouble is that - unless I'm mistaken - it doesn't seem possible to specify which module will be bundled first in the file specified with an \"outFile\" option. I tried to change the \"main\" property in the corresponding package.json but it has no effect.",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/57168/comments",
    "author": "JX75",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2024-01-25T16:31:44Z",
        "body": "We nearly cut SystemJS `outFile` support in 5.0. I'd recommend switching to a more-configurable bundler if you need functionality beyond what's already available."
      },
      {
        "user": "JX75",
        "created_at": "2024-01-25T23:59:23Z",
        "body": "Thank you for the information. "
      }
    ]
  },
  {
    "number": 56224,
    "title": "Types not generated/working with AMD module",
    "created_at": "2023-10-26T10:08:53Z",
    "closed_at": "2023-10-27T18:26:56Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/56224",
    "body": "### Acknowledgement\n\n- [X] I acknowledge that issues using this template may be closed without further explanation at the maintainer's discretion.\n\n### Comment\n\nWhen using AMD modules and working in VSCode, type declarations are not being picked up for modules that load dependencies using an array passed to the define function, but they are working for modules that load dependencies using `require('./module-path')`\r\n\r\nIn a simple project structured like this:\r\n\r\n```\r\napp\r\n    |app.js\r\n    |lib.js\r\n    |lib.d.ts\r\n```\r\nThe file `lib.js` contains this:\r\n\r\n```\r\ndefine('lib', function() {\r\n    return {\r\n        libTest: (msg) => {\r\n            console.log('lib is working!', msg);\r\n            return true;\r\n        },\r\n    }\r\n});\r\n```\r\nThe file `lib.d.ts` looks like this:\r\n\r\n```\r\n/** @name declaration test */\r\nexport module './lib';\r\n/** @name libTest */\r\nexport function libTest(msg: string): boolean;\r\n```\r\nThe declarations from `lib.d.ts` are correctly picked up in `app.js` with this and Intellisense works as expected, pulling info from `lib.d.ts`:\r\n\r\n```\r\nconst lib = require('./lib');\r\nlib.libTest(); // hovering pointer on 'libTest' shows \"function libTest(msg: string): boolean \\n @name -- libTest\" and hovering on 'lib' shows \"@name -- declaration test\"\r\n```\r\nThe declarations also work as expected if `app.js` looks like this instead:\r\n\r\n```\r\ndefine(function() {\r\n    const lib = require('./lib');\r\n    lib.libTest(); // hovering pointer on 'libTest' shows \"function libTest(msg: string): boolean \\n @name -- libTest\" and hovering on 'lib' shows \"@name -- declaration test\"\r\n});\r\n```\r\nHowever, the declarations **do not work** at all when the code in `app.js` looks like this:\r\n\r\n```\r\ndefine(['lib'], function(lib) {\r\n    lib.libTest(); // hovering pointer on either 'lib' or 'libTest' just shows \"any\"\r\n});\r\n```\r\nWhy are the declarations from the `lib.d.ts` file working as expected for the first two variations of `app.js`, but not the third variation which uses an array of dependencies?\r\n\r\nAdditionally, if I delete the `lib.d.ts` file and try to have the compiler generate the declarations automatically (using `\"declaration\": true, \"emitDeclarationOnly\": true` in tsconfig) the tsc command completes successfully, but the generated d.ts file is completely empty",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/56224/comments",
    "author": "ts-lover",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2023-10-26T16:31:23Z",
        "body": "JS module inference only works for calls to the `require` function; it doesn't support AMD `define` calls."
      },
      {
        "user": "ts-lover",
        "created_at": "2023-10-27T10:08:56Z",
        "body": "Ok, thanks for the quick response Ryan :)\r\n\r\nWhat about if the app file was a TypeScript file instead of a JS file, would that make any difference?"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2023-10-27T16:53:19Z",
        "body": "You'd have to write it with \"normal\" TS syntax and transpile to AMD format for it to be recognized"
      },
      {
        "user": "ts-lover",
        "created_at": "2023-10-27T18:26:56Z",
        "body": "Got it, thanks so much!"
      }
    ]
  },
  {
    "number": 56160,
    "title": "tsc target did not work expectedly when compile ES2022 to ES2015",
    "created_at": "2023-10-20T07:59:04Z",
    "closed_at": "2023-10-23T01:26:29Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/56160",
    "body": "### 🔎 Search Terms\n\ntarget  ES2022  ES2015\n\n### 🕗 Version & Regression Information\n\nTS 4.5\r\n\n\n### ⏯ Playground Link\n\n_No response_\n\n### 💻 Code\n\nnpx tsc --target es5 index.ts --outFile indexout.js\r\n\r\n\r\nindex.ts:\r\nconst arr = [1, 2, 3, 4, 5];\r\narr.at(1); // 2\n\n### 🙁 Actual behavior\n\nindexout.js:\r\n\r\nconst arr = [1, 2, 3, 4, 5];\r\narr.at(1); // 2\n\n### 🙂 Expected behavior\n\nArray.at is a new feature in ES2022\r\nThe target is ES5, the output js should not include Array.at\r\nso the indexout.js can not work on the old browser.\n\n### Additional information about the issue\n\n_No response_",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/56160/comments",
    "author": "turtleinspace1",
    "comments": [
      {
        "user": "MartinJohns",
        "created_at": "2023-10-20T08:07:34Z",
        "body": "TypeScript will only downlevel newer syntax. If the function you're trying to call does not exist at your runtime it's your responsibility to polyfill it."
      },
      {
        "user": "turtleinspace1",
        "created_at": "2023-10-20T09:05:00Z",
        "body": "Thanks I understand"
      },
      {
        "user": "typescript-bot",
        "created_at": "2023-10-23T01:26:29Z",
        "body": "This issue has been marked as \"Question\" and has seen no recent activity. It has been automatically closed for house-keeping purposes."
      }
    ]
  },
  {
    "number": 55684,
    "title": "Cannot find module - changing to suggested option doesn't resolve the problem",
    "created_at": "2023-09-08T15:47:11Z",
    "closed_at": "2023-09-14T01:24:37Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/55684",
    "body": "### 🔎 Search Terms\n\n#TS2792\r\n#did you mean to set the  moduleResolution  option to  nodenext \n\n### 🕗 Version & Regression Information\n\n- This is a crash\r\n- This changed between versions ______ and _______\r\n- This is the behavior in every version I tried, and I reviewed the FAQ for entries about _________\r\n- I was unable to test this on prior versions because _______\r\n\n\n### ⏯ Playground Link\n\n_No response_\n\n### 💻 Code\n\nroot\r\n```\r\n\r\n{\r\n  \"compilerOptions\": {\r\n    \"emitDecoratorMetadata\": true,\r\n    \"esModuleInterop\": true,\r\n    \"experimentalDecorators\": true,\r\n    \"forceConsistentCasingInFileNames\": true,\r\n    \"noFallthroughCasesInSwitch\": true,\r\n    \"noUnusedLocals\": true,\r\n    \"noUnusedParameters\": true,\r\n    \"skipLibCheck\": true,\r\n    \"strict\": true,\r\n    \"target\": \"ES2022\"\r\n  }\r\n}\r\n```\r\n\r\nclient\r\n```\r\n{\r\n  \"extends\": \"../tsconfig\",\r\n  \"compilerOptions\": {\r\n    \"useDefineForClassFields\": true,\r\n    \"types\": [\"vitest/globals\"],\r\n    \"lib\": [\"ES2022\", \"DOM\", \"DOM.Iterable\"],\r\n    \"module\": \"ESNext\",\r\n\r\n    /* Bundler mode */\r\n    \"moduleResolution\": \"bundler\",\r\n    \"allowImportingTsExtensions\": true,\r\n    \"resolveJsonModule\": true,\r\n    \"isolatedModules\": true,\r\n    \"noEmit\": true,\r\n    \"jsx\": \"react-jsx\"\r\n  },\r\n  \"include\": [\"src\", \"./tests/setup.ts\"],\r\n  \"references\": [{ \"path\": \"./tsconfig.node.json\" }]\r\n}\r\n```\r\n\r\n\n\n### 🙁 Actual behavior\n\n`TS2792: Cannot find module  vitest . Did you mean to set the  moduleResolution  option to  nodenext , or to add aliases to the  paths  option?\r\n`\r\n\r\nI started getting these errors on all external imports, they don't go away when following the suggestion and changing moduleResolution from 'bundle' to 'nodenext' (or 'node'). \r\n\r\nhow do I resolve that issue? it shows up in every file.\n\n### 🙂 Expected behavior\n\nno error at the exports\n\n### Additional information about the issue\n\nI have a new react project created with vite",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/55684/comments",
    "author": "dbie999",
    "comments": [
      {
        "user": "typescript-bot",
        "created_at": "2023-09-14T01:24:36Z",
        "body": "This issue has been marked as \"Question\" and has seen no recent activity. It has been automatically closed for house-keeping purposes."
      }
    ]
  },
  {
    "number": 55559,
    "title": "How to fix ts(2635) error ",
    "created_at": "2023-08-29T10:14:57Z",
    "closed_at": "2023-09-01T01:28:06Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/55559",
    "body": "### 🔎 Search Terms\n\nI am using TS together for the Next.js project. \r\n\r\nThe custom hook is set to receive multiple types of data types as generic, and ts2635 errors are output during this process. \r\n\r\nBuild is fine, but I can't find a workaround for it even if I google it, so I leave an inquiry on Github issues.\r\n\r\nI've looked up a lot of posts so far, but I don't see a clear solution regarding the ts2635 bug, so I'm vague about how to solve it. \r\n\r\n\r\n\n\n### 🕗 Version & Regression Information\n\nTypescript version: \"5.0.4\"\r\n\r\ntsconfig.json\r\n\r\n```\r\n{\r\n  \"compilerOptions\": {\r\n    \"target\": \"es5\",\r\n    \"lib\": [\"dom\", \"dom.iterable\", \"esnext\"],\r\n    \"allowJs\": true,\r\n    \"skipLibCheck\": true,\r\n    \"strict\": true,\r\n    \"forceConsistentCasingInFileNames\": true,\r\n    \"noEmit\": true,\r\n    \"esModuleInterop\": true,\r\n    \"module\": \"esnext\",\r\n    \"moduleResolution\": \"node\",\r\n    \"resolveJsonModule\": true,\r\n    \"isolatedModules\": true,\r\n    \"jsx\": \"preserve\",\r\n    \"incremental\": true,\r\n    \"plugins\": [\r\n      {\r\n        \"name\": \"next\"\r\n      }\r\n    ],\r\n    \"paths\": {\r\n      \"@/*\": [\"./*\"]\r\n    }\r\n  },\r\n  \"include\": [\"next-env.d.ts\", \"**/*.ts\", \"**/*.tsx\", \".next/types/**/*.ts\"],\r\n  \"exclude\": [\"node_modules\"]\r\n}\r\n\r\n```\n\n### ⏯ Playground Link\n\n_No response_\n\n### 💻 Code\n\n```ts\r\n// Your code here\r\n```\r\n\n\n### 🙁 Actual behavior\n\nerror msg is\r\n\r\n**\"Type 'FetchProps<TournamentProps>' has no signatures for which the type argument list is applicable. ts(2635)\"**\r\n\r\nerror occurs **<TournamentProps>** in below code.\r\n\r\n```\r\nconst TournamentColumn = () => {\r\n  const { contents, setContents } = useFetchDataWithLastVisible({\r\n    fetch: getTounamentsWithLastVisible,\r\n  })<TournamentProps>;\r\n```\r\n\r\nand my FetchProps looks like this\r\n\r\n```\r\ntype FetchProps<T extends TournamentProps | PostProps | OooProps> = {\r\n  contents: T[];\r\n  isMore: boolean;\r\n  getItems: () => Promise<void>;\r\n  setContents: React.Dispatch<React.SetStateAction<T[]>>;\r\n  user: UserProps | undefined;\r\n};\r\n```\r\n\r\nand useFetchDataWithLastVisiable function code is this\r\n\r\n```\r\nconst useFetchDataWithLastVisible = <\r\n  T extends TournamentProps | PostProps | OooProps\r\n>({\r\n  initContent,\r\n  fetch,\r\n}: {\r\n  initContent?: T;\r\n  fetch: ({\r\n    channel,\r\n    lastVisible,\r\n    currentUser,\r\n  }: {\r\n    channel?: ChannelProps;\r\n    lastVisible?: DocumentData;\r\n    currentUser?: UserProps;\r\n  }) => Promise<{\r\n    items: T[];\r\n    lastVisible: DocumentData | undefined;\r\n  }>;\r\n}): FetchProps<T> => {\r\n  // do something\r\n};\r\n\r\n```\n\n### 🙂 Expected behavior\n\nPersonally, I think you can set up an argument list.\n\n### Additional information about the issue\n\n_No response_",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/55559/comments",
    "author": "joshephan",
    "comments": [
      {
        "user": "typescript-bot",
        "created_at": "2023-09-01T01:28:05Z",
        "body": "This issue has been marked as \"Question\" and has seen no recent activity. It has been automatically closed for house-keeping purposes."
      }
    ]
  },
  {
    "number": 55501,
    "title": "Can I  Auto refer generic type?",
    "created_at": "2023-08-24T16:56:51Z",
    "closed_at": "2023-08-27T01:26:46Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/55501",
    "body": "### Acknowledgement\r\n\r\n- [X] I acknowledge that issues using this template may be closed without further explanation at the maintainer's discretion.\r\n\r\n### Comment\r\n\r\n```ts\r\ntype CardProps<T> = {\r\n  updatedData: T extends readAllUpdatedDataGetType[0]\r\n    ? readAllUpdatedDataGetType[0]\r\n    : T extends readAllArchiveDataGetType[0]\r\n    ? readAllArchiveDataGetType[0]\r\n    : never;\r\n};\r\n\r\nexport default function Card<T>({ updatedData}: CardProps<T>) .....\r\n\r\n```\r\nI want when I give updatedData inside give any data, typescript will understand which generic type of data it is.\r\n\r\nIf it happens like that, I do not need to every card component to give a generic type.\r\n\r\n\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/55501/comments",
    "author": "myagizmaktav",
    "comments": [
      {
        "user": "typescript-bot",
        "created_at": "2023-08-27T01:26:46Z",
        "body": "This issue has been marked as \"Question\" and has seen no recent activity. It has been automatically closed for house-keeping purposes."
      }
    ]
  },
  {
    "number": 54189,
    "title": "Uncaught SyntaxError \":\" in recursive function signature",
    "created_at": "2023-05-08T23:45:10Z",
    "closed_at": "2023-05-09T16:47:56Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/54189",
    "body": "Uncaught SyntaxError C:\\Users\\Owner\\Documents\\TS\\HelloWorlds\\HelloHanoi\\hanoi.ts:19\r\n  height: number,\r\n        ^\r\n\r\nfunction moveTower(\r\n  height: number,\r\n  fromPole: string,\r\n  toPole: string,\r\n  withPole: string\r\n): void {\r\n  if (height >= 1) {\r\n    // Move tower of height-1 to an intermediate pole, using the destination pole.\r\n    moveTower(height - 1, fromPole, withPole, toPole);\r\n\r\n    // Move the remaining disk to the destination pole.\r\n    console.log(`Move disk from ${fromPole} to ${toPole}`);\r\n\r\n    // Move the tower of height-1 from the intermediate pole to the destination pole using the source pole.\r\n    moveTower(height - 1, withPole, toPole, fromPole);\r\n  }\r\n}\r\n\r\n// Call the function with the initial parameters.\r\nmoveTower(3, \"A\", \"C\", \"B\");",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/54189/comments",
    "author": "peternroth",
    "comments": [
      {
        "user": "jakebailey",
        "created_at": "2023-05-09T04:13:14Z",
        "body": "You are attemping to execute TypeScript without compiling it to JavaScript, hence the error on the `:` token. You'll need to run `tsc` and then execute its output, or use a tool such as `ts-node` or `tsx` to run your script directly."
      },
      {
        "user": "peternroth",
        "created_at": "2023-05-09T16:47:56Z",
        "body": "Thanks, jakebailey! "
      }
    ]
  },
  {
    "number": 50564,
    "title": "Allow to use value as type in some cases",
    "created_at": "2022-08-31T12:13:10Z",
    "closed_at": "2022-09-02T04:35:24Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/50564",
    "body": "## 🔍 Search Terms\r\nts2747, Allow to use value as type\r\n\r\n## ⭐ Suggestion\r\n\r\nAllow to use value as type in some cases\r\n\r\n## 💻 Use Cases\r\n\r\nSometimes it would be nice to have ability to use value as type:\r\n```\r\nclass A {\r\n    public static classname = 'A';\r\n    public a: number = 2;\r\n    classname = 'A';\r\n    constructor (v: number) {\r\n        this.a = v;\r\n    }\r\n}\r\n\r\nclass B {\r\n    public static classname = 'B';\r\n    public b: number = 2;\r\n    classname = 'B';\r\n    constructor (v: number) {\r\n        this.b = v;\r\n    }\r\n}\r\n\r\nconst list = [new A(1), new A(2), new B(3), new A(4), new B(5)];\r\n\r\n// first case\r\nfunction findByType<T> (source: T[], type: Function): type { // 'type' refers to a value, but is being used as a type here.\r\n    return source.find(e => e instanceof type);\r\n}\r\nconsole.log(findByType(list, A).a + findByType(list, B).b);\r\n\r\n\r\n// second case\r\nfunction isTypeOf<T> (source: T, type: Function): source is type { // 'type' refers to a value, but is being used as a type here.\r\n    return (source as any).classname === (type as any).classname;\r\n}\r\nif (isTypeOf(list[0], A)) console.log(list[0].a);\r\n```\r\nThis is a highly simplified example, but it shows how this feature can be used in real application.\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/50564/comments",
    "author": "buryndin",
    "comments": [
      {
        "user": "IllusionMH",
        "created_at": "2022-08-31T13:13:00Z",
        "body": "You should follow issue template.\r\n\r\nThere may be intersection between identifiers in types \"scope\" and values \"scope\", therefore it's not easier to get problems when values are used as types and vice versa.\r\n\r\nError message suggests correct fix - just write `typeof type` instead of plain `type`. Why it's problem to add explicit `typeof`?\r\n\r\nTS would then report proper errors in your code In your code (after adding requested `typeof`)."
      },
      {
        "user": "buryndin",
        "created_at": "2022-08-31T13:31:35Z",
        "body": "I need not a 'typeof'. I pass type as parameter and I want to use this type.\r\ntypeof A === 'function' - it is useless.\r\nI understand that we cannot use type as value, because some kind of types ('type' or 'interface') does not exist in runtime(compiled js-code). But It seems using value as type is quite possible."
      },
      {
        "user": "IllusionMH",
        "created_at": "2022-08-31T13:52:37Z",
        "body": "Because you have explicit type `Function`. You should make that type generic (with constraint).\r\n\r\nAlso type of `type` is constructor type as you expect function and pass class constructor.\r\nYou should use `InstanceType<typeof type>` to get type you are looking for."
      },
      {
        "user": "fatcerberus",
        "created_at": "2022-08-31T13:53:33Z",
        "body": "> typeof A === 'function' - it is useless.\r\n\r\nWe're not talking about runtime `typeof`, we're talking about type-level `typeof`, which means \"get the compile-time type of this variable\":\r\n\r\n```ts\r\nlet x: number = 42;\r\nlet y: typeof x = 812;\r\n//  ^?\r\n//  (number)\r\n```"
      },
      {
        "user": "fatcerberus",
        "created_at": "2022-08-31T13:55:53Z",
        "body": "```ts\r\nfunction isTypeOf<T extends Function>(source: Function, type: T): source is typeof type {\r\n    return (source as any).classname === (type as any).classname;\r\n}\r\n```\r\n\r\nThis works.  But of course at this point you might as well just write `source is T`."
      },
      {
        "user": "buryndin",
        "created_at": "2022-08-31T14:29:51Z",
        "body": "> You should use `InstanceType<typeof type>`\r\nIt is not working:\r\n```ts\r\nfunction findByType<T> (source: T[], type: Function): InstanceType<typeof type> { // error Type 'Function' does not satisfy the constraint ...\r\n    return source.find(e => e instanceof type);\r\n}\r\n```\r\n> ```ts\r\n> function isTypeOf<T extends Function>(source: Function, type: T): source is typeof type {\r\n>     return (source as any).classname === (type as any).classname;\r\n> }\r\n> ```\r\n\r\nThis is does not work also\r\n```ts\r\nfunction isTypeOf<T extends {}>(source: {}, type: T): source is typeof type {\r\n    return (source as any).classname === (type as any).classname;\r\n}\r\nif (isTypeOf(list[0], A)) console.log(list[0].a); // Property 'a' does not exist on type 'B & typeof A'.\r\n```\r\n\r\nPlease see my suggestion carefully: if predicate isTypeOf is true I expect that on the line \r\n```\r\nif (isTypeOf(list[0], A)) console.log(list[0].a); \r\n```\r\ntypeof list[0]  = A"
      },
      {
        "user": "MartinJohns",
        "created_at": "2022-08-31T14:34:27Z",
        "body": "```typescript\r\nfunction isTypeOf<T extends new (...args: any) => any>(source: {}, type: T): source is InstanceType<T> {\r\n    return (source as any).classname === (type as any).classname;\r\n}\r\n```"
      },
      {
        "user": "IllusionMH",
        "created_at": "2022-08-31T14:35:50Z",
        "body": "> You should use InstanceType<typeof type>\r\n> It is not working:\r\n\r\nYou've skipped first part where it should be generic, but as **wisecerberus** mentioned, in that case you can just use generic `T` type instead of `typeof type`. Or as posted above by **MartinJohns**"
      },
      {
        "user": "fatcerberus",
        "created_at": "2022-08-31T14:38:54Z",
        "body": "> if predicate isTypeOf is true I expect that ... typeof list[0] = A\r\n\r\nThat's literally just `list[0] instanceof A`.  Martin's version is the correct way to implement your custom version."
      },
      {
        "user": "buryndin",
        "created_at": "2022-09-02T04:35:24Z",
        "body": "Sorry guys, I forgot about generic. Thank's a lot for your help. Issue can be closed."
      }
    ]
  },
  {
    "number": 50033,
    "title": "typescript ast",
    "created_at": "2022-07-25T09:01:23Z",
    "closed_at": "2022-07-27T22:16:10Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/50033",
    "body": "how can i parse typescript code and get it's ast in java?",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/50033/comments",
    "author": "1014661165",
    "comments": [
      {
        "user": "DanielRosenwasser",
        "created_at": "2022-07-25T23:17:04Z",
        "body": "We don't provide Java APIs for TypeScript. At best, I think you could use the TypeScript API and find a way to serialize to/deserialize from JSON. These sorts of questions might be better off at StackOverflow for future reference."
      }
    ]
  },
  {
    "number": 48404,
    "title": "Update from 4.6.0-Beta to 4.6.1-RC introduced bug with Electron 12",
    "created_at": "2022-03-24T18:50:48Z",
    "closed_at": "2022-03-24T19:39:23Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/48404",
    "body": "# Bug Report\r\n\r\nAfter updating and compiling the project, the Electron-App (Runniing on Electron v12.0.2) does not load the resulting javascript file but reports an error just a view lines into the code.\r\n`Uncaught SyntaxError: Unexpected token '{'`\r\n\r\n### 🔎 Search Terms\r\n\r\n`Uncaught SyntaxError: Unexpected token '{'` Electron 4.6.1-RC\r\n\r\n### 🕗 Version & Regression Information\r\n\r\nAfter update from 4.5.0-Beta to 4.6.2, did some research to find it was introduced with 4.6.1-RC\r\n\r\n- This is a crash\r\n- This changed between versions 4.6.0-Beta and 4.6.1-RC\r\n\r\n\r\n### 💻 Code\r\n\r\n<!-- Please post the relevant code sample here as well-->\r\n```ts\r\n    class DebugConsole extends FudgeCore.DebugTarget {\r\n        static { this.delegates = {                                                    // error thrown from this line\r\n            [FudgeCore.DEBUG_FILTER.INFO]: console.info,\r\n            [FudgeCore.DEBUG_FILTER.LOG]: console.log,\r\n            [FudgeCore.DEBUG_FILTER.WARN]: console.warn,\r\n            [FudgeCore.DEBUG_FILTER.ERROR]: console.error,\r\n            [FudgeCore.DEBUG_FILTER.FUDGE]: DebugConsole.fudge,\r\n            [FudgeCore.DEBUG_FILTER.CLEAR]: console.clear,\r\n            [FudgeCore.DEBUG_FILTER.GROUP]: console.group,\r\n            [FudgeCore.DEBUG_FILTER.GROUPCOLLAPSED]: console.groupCollapsed,\r\n            [FudgeCore.DEBUG_FILTER.GROUPEND]: console.groupEnd,\r\n            [FudgeCore.DEBUG_FILTER.SOURCE]: DebugConsole.source\r\n        }; }\r\n```\r\n\r\nPrevious output, which Electron12 was able to run, was\r\n```ts\r\n    class DebugConsole extends FudgeCore.DebugTarget {\r\n          ....\r\n    }\r\n    DebugConsole.delegates = {\r\n            [FudgeCore.DEBUG_FILTER.INFO]: console.info,\r\n             ....\r\n```\r\n\r\n### 🙁 Actual behavior\r\n\r\nElectron aborts loading the compiled Javascript file and throws the error \r\n\r\n### 🙂 Expected behavior\r\n\r\nLoad the compiled file and run it\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/48404/comments",
    "author": "JirkaDellOro",
    "comments": [
      {
        "user": "DanielRosenwasser",
        "created_at": "2022-03-24T19:17:20Z",
        "body": "Hmm, are you using `--target esnext`? If so, that isn't a stable output target across different versions of TypeScript, and will emit syntax that may be newer than what your engine expects. In this case, I would expect `--target es2020` would be good enough. Otherwise, we need more info about what went wrong (e.g. compiler options and new output)."
      },
      {
        "user": "JirkaDellOro",
        "created_at": "2022-03-24T19:39:22Z",
        "body": "Wow, didn't expect that quick of an answer. Correct, I used `esnext` to target whatever the newest is, but until I find the time to port the project to a newer Electron version, I just figured I can even use `es2021` with typescript@next. It's better this way round.\r\n\r\nThanks a lot!"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2022-03-24T21:12:55Z",
        "body": "No problem, glad the workaround was simple!"
      }
    ]
  },
  {
    "number": 48382,
    "title": "Property 'dataMenu' does not exist on type 'HTMLAttributes<HTMLDivElement>'.ts(2322)",
    "created_at": "2022-03-23T06:52:16Z",
    "closed_at": "2022-03-24T23:55:10Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/48382",
    "body": "\r\nIn Vue3, I am having some property that does not exist in the HtmlElement error. please help me solve this issue.\r\n\r\nError :\r\n\r\n```\r\n(property) dataMenu: string\r\n\r\n(property) data-menu: string\r\n```\r\n\r\n```\r\nType '{ class: string; dataMenu: string; \"data-menu\": string; }' is not assignable to type 'HTMLAttributes'.\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/48382/comments",
    "author": "RahelSiddiqi",
    "comments": [
      {
        "user": "DanielRosenwasser",
        "created_at": "2022-03-24T23:55:10Z",
        "body": "Hey there, this issue tracker isn't meant to work as a support forum. These questions tend to be better suited for StackOverflow. You may want to open a question up there instead. Thanks!"
      }
    ]
  },
  {
    "number": 47084,
    "title": "warning: Experimental support for decorators is a feature that is subject to change in a future release",
    "created_at": "2021-12-09T09:29:46Z",
    "closed_at": "2021-12-10T08:45:57Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/47084",
    "body": "# Bug Report\r\n\r\n<!--\r\n  Please fill in each section completely. Thank you!\r\n-->\r\n\r\n### 🔎 Search Terms\r\n\r\nExperimental  decorators\r\n\r\n### 🕗 Version & Regression Information\r\n\r\nmonaco: v0.30.1\r\ntypescript: 3.2.4\r\n\r\n\r\n### 💻 Code\r\nplaygroud code:\r\nmonaco.languages.typescript.javascriptDefaults.setDiagnosticsOptions({\r\n\tnoSemanticValidation: true,\r\n\tnoSyntaxValidation: false\r\n});\r\n\r\n// compiler options\r\nmonaco.languages.typescript.javascriptDefaults.setCompilerOptions({\r\n\ttarget: monaco.languages.typescript.ScriptTarget.ES2015,\r\n        experimentalDecorators: true,\r\n\tallowNonTsExtensions: true\r\n});\r\n\r\n\r\nvar jsCode = [\r\n    'import { Injectable } from \\'@angular/core\\';',\r\n    'import { ApplicationParamService } from \\'@farris/command-services\\';',\r\n    'import { HttpClient, HttpHeaders } from \\'@angular/common/http\\';',\r\n    '@Injectable()',\r\n    'export class List1FrmWebcmpService {',\r\n        'constructor(private obj: ApplicationParamService, private http:HttpClient) {',\r\n            'this.obj.parseParams;',\r\n        '}',\r\n        'private get() { }',\r\n        'set() { }',\r\n    '}'\r\n].join('\\n');\r\n\r\nmonaco.editor.create(document.getElementById('container'), {\r\n\tvalue: jsCode,\r\n\tlanguage: 'typescript'\r\n});\r\n\r\n### 🙁 Actual behavior\r\n\r\n'List1FrmWebcmpService' has underline&warning ' Experimental support for decorators is a feature that is subject to change in a future release. Set the 'experimentalDecorators' option in your 'tsconfig' or 'jsconfig' to remove this warning '\r\n\r\n### 🙂 Expected behavior\r\n'experimentalDecorators: true' option not wok,how to remove this warning?\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/47084/comments",
    "author": "chenqiangkobe",
    "comments": [
      {
        "user": "MartinJohns",
        "created_at": "2021-12-09T09:57:20Z",
        "body": "Did you mean to set `typescriptDefaults` instead of `javascriptDefaults`? Regardless, this doesn't seem to be an issue with TypeScript itself.\r\n\r\n> typescript: 3.2.4\r\n\r\nAre you really using a version released on 3. January **2019**? The latest version is 4.5.2."
      },
      {
        "user": "chenqiangkobe",
        "created_at": "2021-12-10T08:45:57Z",
        "body": "@MartinJohns  I use **typescriptDefaults** instead of **javascriptDefaults**, the option **experimentalDecorators: true** works. Thanks a lot. "
      }
    ]
  },
  {
    "number": 46341,
    "title": "how to tell typescript that this variable can not be null?",
    "created_at": "2021-10-13T13:01:58Z",
    "closed_at": "2021-10-13T17:04:31Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/46341",
    "body": "//actual behaviour:\r\nlet numbers :number[] = [9,-1,-13];\r\nnumbers = null; // typescript accept this no errors \r\n// expected  behaviour: \r\nlet numbers :number[] = [9,-1,-13];\r\nnumbers = null; //A value of type 'null' can't be assigned to a variable of type 'number'.\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/46341/comments",
    "author": "sanba-anass",
    "comments": [
      {
        "user": "fatcerberus",
        "created_at": "2021-10-13T13:37:45Z",
        "body": "Uh… you should probably enable `strictNullChecks`?"
      }
    ]
  },
  {
    "number": 45246,
    "title": "module is cjs and esModuleInterop is set to true, the \"default\" is still output",
    "created_at": "2021-07-30T09:53:46Z",
    "closed_at": "2021-08-02T02:44:16Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/45246",
    "body": "# Bug Report\r\n\r\n### 🔎 Search Terms\r\n\r\nallowSyntheticDefaultImports\r\ncommonjs\r\ncjs\r\ndefault\r\n\r\n### 🕗 Version & Regression Information\r\n\r\ntypescript 3.8.2\r\nnode 12.18.0\r\n\r\n### ⏯ Playground Link\r\n\r\n### 💻 Code\r\n\r\n```\r\n// source code\r\nimport React from 'react'\r\n\r\nexport default function Circle (props) {\r\n    const { ...other } = props;\r\n    return (\r\n        <div\r\n            {...other}\r\n        >\r\n            {props.children || ''}\r\n        </div>\r\n    )\r\n}\r\n\r\n// tsconfig\r\n{\r\n      \"compilerOptions\": {\r\n        \"outDir\": \"./lib/\",\r\n        \"module\": \"commonjs\",\r\n        \"target\": \"es5\",\r\n        \"declaration\": true,\r\n        \"jsx\": \"react\",\r\n        \"moduleResolution\": \"Node\",\r\n        \"keyofStringsOnly\": true,\r\n        \"esModuleInterop\": true,\r\n        \"experimentalDecorators\": true\r\n      },\r\n      \"include\": [\r\n        \"src/components\"\r\n      ],\r\n      \"exclude\": [\r\n        \"node_modules\",\r\n        \"build\",\r\n        \"scripts\",\r\n        \"**/__tests__/*.test.tsx\",\r\n      ]\r\n}\r\n```\r\n\r\n### 🙁 Actual behavior\r\n\r\n```\r\nfunction Circle(props) {\r\n   // Some non-critical output\r\n    return (react_1.default.createElement(\"div\", __assign({}, other, { className: classes }), props.children || ''));\r\n}\r\n```\r\n\r\n### 🙂 Expected behavior\r\n\r\nThe output at this time should point to React.createElement, **but if the output target is es module, this problem will not occur**\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/45246/comments",
    "author": "ProfBramble",
    "comments": [
      {
        "user": "andrewbranch",
        "created_at": "2021-07-30T21:26:40Z",
        "body": "You want `esModuleInterop`, not `allowSyntheticDefaultImports`."
      },
      {
        "user": "ProfBramble",
        "created_at": "2021-07-31T05:52:31Z",
        "body": "I tested it before raising the issue, but it still outputs `react_1.default.createElement`\r\n\r\n> You want `esModuleInterop`, not `allowSyntheticDefaultImports`.\r\n\r\n"
      },
      {
        "user": "ProfBramble",
        "created_at": "2021-08-02T02:44:13Z",
        "body": "It's a bit embarrassing. I didn't know that the help function __importDefault has already mounted the entire package on default, although the display still carries default. But it's working"
      }
    ]
  },
  {
    "number": 44839,
    "title": "[question]update typescript to 4.2.x, An import path cannot end with '.ts' ?",
    "created_at": "2021-07-01T04:04:32Z",
    "closed_at": "2021-07-03T18:00:01Z",
    "labels": [
      "Duplicate",
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/44839",
    "body": "when i upgrade typescript from 4.1.5 to 4.3.2, my progrom cannot build.\r\n > the error info：  An import path cannot end with a '.ts' extension. Consider importing '@/api/common.js' instead.\r\n\r\nversion 4.1.5 is ok。Is it not allowed to use .ts extention after 4.2.x?\r\n\r\nmy tsconfig.json:\r\n```json\r\n{\r\n  \"compilerOptions\": {\r\n    \"target\": \"es2019\",\r\n    \"module\": \"esnext\",\r\n    \"moduleResolution\": \"node\",\r\n    \"forceConsistentCasingInFileNames\": true,\r\n    \"jsx\": \"preserve\",\r\n    \"incremental\": true,\r\n    \"isolatedModules\": true,\r\n    \"strict\": true,\r\n    \"resolveJsonModule\": true,\r\n    \"importHelpers\": true,\r\n    \"esModuleInterop\": true,\r\n    \"allowSyntheticDefaultImports\": true,\r\n    \"sourceMap\": true,\r\n    \"skipLibCheck\": true,\r\n    \"noUnusedLocals\": false,\r\n    \"types\": [\r\n      \"webpack-env\",\r\n      \"jest\"\r\n    ],\r\n    \"lib\": [\r\n      \"esnext\",\r\n      \"dom\",\r\n      \"dom.iterable\",\r\n      \"scripthost\"\r\n    ]\r\n  },\r\n  \"includes\": [\"../shared/**/**\"],\r\n  \"exclude\": [\r\n    \"node_modules\"\r\n  ]\r\n}\r\n\r\n```\r\n\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/44839/comments",
    "author": "1gehunzi",
    "comments": [
      {
        "user": "MartinJohns",
        "created_at": "2021-07-01T06:42:01Z",
        "body": "See #38149, and note that this repository is not suited for questions. You should ask on StackOverflow instead."
      },
      {
        "user": "typescript-bot",
        "created_at": "2021-07-03T18:00:02Z",
        "body": "This issue has been marked as a 'Duplicate' and has seen no recent activity. It has been automatically closed for house-keeping purposes."
      }
    ]
  },
  {
    "number": 43235,
    "title": "This condition will always return 'false' since the types have no overlap.",
    "created_at": "2021-03-14T06:24:15Z",
    "closed_at": "2021-03-15T17:45:33Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/43235",
    "body": "Hi, I post a \"duplicate\" of #25642 which does \"work as intended\". Sorry, I'm not trying to spam you, but i simply disagree. Here is a simplified version of the error i'm getting:\r\n\r\n`\r\nconst UPDATABLE_OPTION_FLAG : \"FLAG1\" | \"FLAG2\" | \"FLAG3\" = \"FLAG2\"; // I change this whenever i want\r\n\r\nswitch (UPDATABLE_OPTION_FLAG) {\r\n    case \"FLAG1\":\r\n        console.log(\"Do job 1.\");\r\n        break;\r\n    case \"FLAG2\":\r\n        console.log(\"Do job 2.\");\r\n        break;\r\n    case \"FLAG3\":\r\n        console.log(\"Do job 3.\");\r\n        break;\r\n}\r\n\r\nif (UPDATABLE_OPTION_FLAG == \"FLAG1\") {\r\n    console.log(\"Do job 1.\");\r\n} else if (UPDATABLE_OPTION_FLAG == \"FLAG2\") {\r\n    console.log(\"Do job 2.\");\r\n} else {\r\n    console.log(\"Do job 3.\");\r\n}\r\n`\r\n\r\nI get a bunch of errors equivalent to \"This condition will always return 'false' since the types have no overlap.\". To silence them i need either 1) to move the constant, which is making my code harder to read because sometimes i want the flag switch near the code to switch; 2) to comment out some code, which makes refactoring fail and is error-prone; 3) or to use tricks to make the compiler lose it, which will make me lose it too.\r\nIMHO I didn't make any programming mistake here and the compiler is wrong. \r\n\r\nRegards.\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/43235/comments",
    "author": "bonjourjoel",
    "comments": [
      {
        "user": "MartinJohns",
        "created_at": "2021-03-14T06:39:59Z",
        "body": "This is working as intended, whether you agree or not. TypeScript provides types to prevent common mistakes. A condition that is verifiable **never** true is such a common mistake that the compiler reports about. Why would you want this safety check removed?\r\n\r\nYou can/should just use `\"FLAG2\" as \"FLAG1\" | \"FLAG2\" | \"FLAG3\"`. That way the compiler won't narrow the type of your variable to `\"FLAG2\"`.\r\n\r\nAlternatively you can wrap your value in a function:\r\n\r\n    function getFlag(): \"FLAG1\" | \"FLAG2\" | \"FLAG3\" {\r\n        return \"FLAG1\";\r\n    }\r\n\r\n    const UPDATABLE_OPTION_FLAG = getFlag();"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2021-03-15T17:45:33Z",
        "body": "> Sorry, I'm not trying to spam you, but i simply disagree.\r\n\r\nPlease consider what this place would look like if everyone who disagreed with any of the thousands of decisions we've made filed a new issue."
      }
    ]
  },
  {
    "number": 42326,
    "title": "Question: where can one find all possible TSC errors?",
    "created_at": "2021-01-14T02:37:42Z",
    "closed_at": "2021-01-14T18:58:58Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/42326",
    "body": "# Question #\r\n\r\nFirst, my apologies for not asking on SO, I doubt that questions like this are relevant to their platform.\r\n\r\nAre any TSC errors documented (outside of the source code)?\r\nDoes an exhaustive list containing every possible error exist?\r\nIs there a documented rationale behind why a compiler error is introduced?\r\n\r\nIf so, where might I find this documentation?\r\nIf not, why isn't there? Could this be introduced?",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/42326/comments",
    "author": "ghost",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2021-01-14T18:44:39Z",
        "body": "We don't have specific documentation for each error, no.\r\n\r\nOur experience has been that it's very, very difficult to write meaningful per-error documentation (plus there are literally thousands of them); we prefer to document the system more holistically."
      },
      {
        "user": "ghost",
        "created_at": "2021-01-14T18:52:07Z",
        "body": "@RyanCavanaugh I can understand, documenting ~20k different compiler errors wouldn't be easy, but is there anywhere that I can easily find the errors and their associated messages, maybe in the source code? Or are they scattered across the codebase?"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2021-01-14T18:53:27Z",
        "body": "See `src/compiler/diagnosticMessages.json`"
      },
      {
        "user": "ghost",
        "created_at": "2021-01-14T18:58:58Z",
        "body": "Thanks, that'll help!"
      }
    ]
  },
  {
    "number": 41859,
    "title": "Values of array passed as parameter can't be used to infer the return type",
    "created_at": "2020-12-07T19:44:49Z",
    "closed_at": "2020-12-07T21:34:48Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/41859",
    "body": "Not sure if this is a bug or an expected behavior so please forgive me if this does not belong here.\r\n\r\nI'm trying to create a factory that guarantees that the object it returns have certain properties, whose names are passed as parameters:\r\n\r\n```ts\r\nconst foo = fooFactory(['id', 'name']); // returned object is guaranteed by the type checker to implement the interface {id: string, name: string}\r\n```\r\n\r\nIt's possible with the latest flavors of TypeScript by using something like this:\r\n\r\n```ts\r\nconst fooFactory1 = <P extends string>(keys: ReadonlyArray<string>): Record<P, string> => {\r\n    return; // noop for the sake of example\r\n}\r\n\r\nconst keys= <const>['id', 'name'];\r\n\r\nconst foo1 = fooFactory1<typeof keys[number]>(keys); // inferred type of foo1 is Record<\"id\" | \"name\", string>, as expected\r\n```\r\nBut it seems like trying to infer the return type from the type of the parameter passed to the function instead of explicitely, like above doesn't work:\r\n\r\n```ts\r\nconst fooFactory2 = (keys: ReadonlyArray<string>): Record<typeof keys[number], string> => {\r\n    return;  // noop for the sake of example\r\n}\r\n\r\nconst foo2 = fooFactory2(<const>['id', 'name']); // inferred type of foo2 is Record<string, string>\r\n```\r\n\r\nFrom my understanding, the two approachs should be analoguous: in the first case, the return type is inferred from the values of the `keys` array _passed_ as parameter, in the second case it should be inferred from the values of the `keys` array _received_ as parameter.\r\n\r\nObviously the second approach is less verbose and doesn't require that the `keys` array is instanciated before being passed as parameter, so I hoped it would work.\r\n\r\nAm I doing anything wrong? Is it simply not supported? Or is it a bug?\r\n\r\nThanks by advance. ",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/41859/comments",
    "author": "ericmorand",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2020-12-07T21:06:18Z",
        "body": "Reasonable question; the difference you've outlined here is exactly the difference between a generic and a non-generic function. In `fooFactory2`, the type `typeof keys[number]` refers only to the *parameter declaration*'s type, whereas in `fooFactory1`, `P` refers to the type of the argument as passed during the call. That's what makes a generic function generic: resolution of types is deferred to each call site, rather than being statically resolved."
      },
      {
        "user": "ericmorand",
        "created_at": "2020-12-07T21:34:48Z",
        "body": "Make a lot of sense. Thanks for the clarification."
      },
      {
        "user": "ericmorand",
        "created_at": "2020-12-08T16:39:57Z",
        "body": "@RyanCavanaugh , actually writing the factory like this gets the job perfectly done:\r\n\r\n```ts\r\nconst fooFactory = <P>(keys: Array<keyof P>): Record<keyof P, string> => {\r\n    return;  // noop for the sake of example\r\n}\r\n\r\nconst foo = fooFactory(['id', 'name']); // inferred type of foo is Record<\"id\" | \"name\", string>\r\n```\r\n\r\nLooks like `P` is inferred by the fact that `keys` are known to be an array containing only the keys of `P`. I have to say that my mind is blown by how smart type inferring is."
      }
    ]
  },
  {
    "number": 40824,
    "title": "What is `project.addMissingFileRoot` actually do?",
    "created_at": "2020-09-29T02:04:57Z",
    "closed_at": "2020-09-30T02:33:45Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/40824",
    "body": "What is `project.addMissingFileRoot` actually do? can I use it to add d.ts file to the project?\r\nIf I can, how to remove d.ts from the project?  I tried `project.removeFile`\r\nAnd I keep getting this error, what does it mean? how can I fix it?\r\n```\r\n    Debug Failure. False expression.\r\n\r\n    Error: Debug Failure. False expression.\r\n        at ProjectService.forEachConfigFileLocation (c:\\Users\\mjaso\\AppData\\Local\\Programs\\Microsoft VS Code Insiders\\resources\\app\\extensions\\node_modules\\typescript\\lib\\tsserver.js:150617:26)\r\n        at ProjectService.stopWatchingConfigFilesForInferredProjectRoot (c:\\Users\\mjaso\\AppData\\Local\\Programs\\Microsoft VS Code Insiders\\resources\\app\\extensions\\node_modules\\typescript\\lib\\tsserver.js:150592:22)\r\n        at InferredProject.removeRoot (c:\\Users\\mjaso\\AppData\\Local\\Programs\\Microsoft VS Code Insiders\\resources\\app\\extensions\\node_modules\\typescript\\lib\\tsserver.js:148914:37)\r\n        at InferredProject.Project.removeFile (c:\\Users\\mjaso\\AppData\\Local\\Programs\\Microsoft VS Code Insiders\\resources\\app\\extensions\\node_modules\\typescript\\lib\\tsserver.js:148159:26)\r\n        at Timeout._onTimeout (Z:\\contrib\\vscode_deno\\typescript-deno-plugin\\out\\typescript-deno-plugin\\src\\plugin.js:25:26)\r\n        at listOnTimeout (internal/timers.js:531:17)\r\n        at processTimers (internal/timers.js:475:7\r\n```\r\n\r\n```ts\r\nthis.project.getScriptInfo(getDenoDts(true))?.detachAllProjects();\r\n```\r\n```\r\n    Debug Failure. False expression.\r\n\r\n    Error: Debug Failure. False expression.\r\n        at ProjectService.forEachConfigFileLocation (c:\\Users\\mjaso\\AppData\\Local\\Programs\\Microsoft VS Code Insiders\\resources\\app\\extensions\\node_modules\\typescript\\lib\\tsserver.js:150617:26)\r\n        at ProjectService.stopWatchingConfigFilesForInferredProjectRoot (c:\\Users\\mjaso\\AppData\\Local\\Programs\\Microsoft VS Code Insiders\\resources\\app\\extensions\\node_modules\\typescript\\lib\\tsserver.js:150592:22)\r\n        at InferredProject.removeRoot (c:\\Users\\mjaso\\AppData\\Local\\Programs\\Microsoft VS Code Insiders\\resources\\app\\extensions\\node_modules\\typescript\\lib\\tsserver.js:148914:37)\r\n        at InferredProject.Project.removeFile (c:\\Users\\mjaso\\AppData\\Local\\Programs\\Microsoft VS Code Insiders\\resources\\app\\extensions\\node_modules\\typescript\\lib\\tsserver.js:148159:26)\r\n        at ScriptInfo.detachAllProjects (c:\\Users\\mjaso\\AppData\\Local\\Programs\\Microsoft VS Code Insiders\\resources\\app\\extensions\\node_modules\\typescript\\lib\\tsserver.js:147141:23)\r\n        at Timeout._onTimeout (Z:\\contrib\\vscode_deno\\typescript-deno-plugin\\out\\typescript-deno-plugin\\src\\plugin.js:26:112)\r\n        at listOnTimeout (internal/timers.js:531:17)\r\n        at processTimers (internal/timers.js:475:7)\r\n```",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/40824/comments",
    "author": "CGQAQ",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2020-09-29T13:36:45Z",
        "body": "@sheetalkamat any advice?"
      },
      {
        "user": "sheetalkamat",
        "created_at": "2020-09-29T17:49:54Z",
        "body": "addRoot and addMissingRoot are suppose to be internal but must have missed.. They will not help you with adding roots to the project. The roots of projects are managed by configurations internally and you cannot change them. External projects specify way to create project with known set of roots and compiler options or plugins can add external files as root through `getExternalFiles` though."
      },
      {
        "user": "alfredsgenkins",
        "created_at": "2022-08-17T09:07:38Z",
        "body": "@sheetalkamat I have had a need to add more source files to the project recently. When working with plugin system, plugin targets had to be manually included. I tried using `getExternalFiles` in plugin, specifying the array of all files I intend to include, but `program.getSourceFile(fileName)` resulted in `undefined`.\r\n\r\nI ended up using following function to add file to project dynamically:\r\n```ts\r\n getSourceFileByPath(fileName: string, tryCount = 0): ts.SourceFile | undefined {\r\n      // TODO: optimize this function (it is very slow)\r\n\r\n      const program = this.ctx.info.project.getLanguageService().getProgram();\r\n\r\n      if (!program || tryCount > 1) {\r\n          // ^^^ Allow only 2 tries to get the source file\r\n          return;\r\n      }\r\n\r\n      const sourceFile = program.getSourceFile(fileName);\r\n\r\n      if (sourceFile) {\r\n          return sourceFile;\r\n      }\r\n\r\n      // vvv Add file as new source file\r\n      this.ctx.info.project.addMissingFileRoot(fileName as ts.server.NormalizedPath);\r\n\r\n      return this.getSourceFileByPath(fileName, tryCount + 1);\r\n  }\r\n```\r\n\r\nAny suggestion for me here?"
      },
      {
        "user": "sheetalkamat",
        "created_at": "2022-08-18T21:11:05Z",
        "body": "Did you look into why `getExternalFiles` didnt work? It seems like that should work.. Did you try checking if its contents are queried.. Did you check result of `program.getSourceFiles().map(f => f.fileName)`"
      },
      {
        "user": "alfredsgenkins",
        "created_at": "2022-08-22T06:39:24Z",
        "body": "@sheetalkamat I have retried the approach with `getExternalFiles`, and it now works as expected. Sorry for false alarm! :)"
      }
    ]
  },
  {
    "number": 40326,
    "title": "[Question or Bug]: is the way of using ParsingContext intended in Parser.ts?",
    "created_at": "2020-08-31T08:48:31Z",
    "closed_at": "2020-09-01T02:06:14Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/40326",
    "body": "> these happens in typescript repository itself.\r\n\r\nHi, I found an enum `ParsingContext` which is not defined as flags. Here are the code copy:\r\n``` ts\r\n        const enum ParsingContext {\r\n            SourceElements,            // Elements in source file\r\n            BlockStatements,           // Statements in block\r\n            SwitchClauses,             // Clauses in switch statement\r\n            SwitchClauseStatements,    // Statements in switch clause\r\n            TypeMembers,               // Members in interface or type literal\r\n            ClassMembers,              // Members in class declaration\r\n            EnumMembers,               // Members in enum declaration\r\n            HeritageClauseElement,     // Elements in a heritage clause\r\n            VariableDeclarations,      // Variable declarations in variable statement\r\n            ObjectBindingElements,     // Binding elements in object binding list\r\n            ArrayBindingElements,      // Binding elements in array binding list\r\n            ArgumentExpressions,       // Expressions in argument list\r\n            ObjectLiteralMembers,      // Members in object literal\r\n            JsxAttributes,             // Attributes in jsx element\r\n            JsxChildren,               // Things between opening and closing JSX tags\r\n            ArrayLiteralMembers,       // Members in array literal\r\n            Parameters,                // Parameters in parameter list\r\n            JSDocParameters,           // JSDoc parameters in parameter list of JSDoc function type\r\n            RestProperties,            // Property names in a rest type list\r\n            TypeParameters,            // Type parameters in type parameter list\r\n            TypeArguments,             // Type arguments in type argument list\r\n            TupleElementTypes,         // Element types in tuple element type list\r\n            HeritageClauses,           // Heritage clauses for a class or interface declaration.\r\n            ImportOrExportSpecifiers,  // Named import clause's import specifier list\r\n            Count                      // Number of parsing contexts\r\n        }\r\n```\r\n`as flags` means something like\r\n```ts\r\nenum Example{\r\nA = 1<<0;\r\nB = 1<<1;\r\n}\r\n```\r\n\r\nBut I see a strange use of it, which makes me feel they are used like flags.\r\n\r\n```ts\r\n            const saveParsingContext = parsingContext;\r\n            parsingContext |= 1 << kind;   // `Line 1`\r\n```\r\n```ts\r\n            switch (parsingContext) {\r\n                case ParsingContext.ClassMembers:\r\n                case ParsingContext.SwitchClauses:\r\n                case ParsingContext.SourceElements:\r\n                case ParsingContext.BlockStatements:\r\n                case ParsingContext.SwitchClauseStatements:\r\n                case ParsingContext.EnumMembers:\r\n                case ParsingContext.TypeMembers:\r\n                case ParsingContext.VariableDeclarations:\r\n                case ParsingContext.JSDocParameters:\r\n                case ParsingContext.Parameters:\r\n                    return true;\r\n            }\r\n            return false;\r\n```\r\n```ts\r\n        function isInSomeParsingContext(): boolean {\r\n            for (let kind = 0; kind < ParsingContext.Count; kind++) {\r\n                if (parsingContext & (1 << kind)) {    // `Line 2`\r\n                    if (isListElement(kind, /*inErrorRecovery*/ true) || isListTerminator(kind)) {\r\n                        return true;\r\n                    }\r\n                }\r\n            }\r\n            return false;\r\n        }\r\n```\r\nFrom the for-loop, it seems the enum is not used as flag, but `Line 1` would make most condition out of range, and let switch clause loss of use.\r\n`Line 2` is also strange, it seems some enum kind are very special in the condition and only take them as parameter (I means 1，2,4,8,16). \r\n\r\nI feel someone confused the types, sometimes he treats the enum as flags and sometimes not.\r\n\r\nFeel free to close this if it is intended. And it would be sweet to give a simple reason.\r\n\r\nIf it is really a bug, I would be glad to fix it. (or maybe it is more proper to be fixed by core team?)",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/40326/comments",
    "author": "ShuiRuTian",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2020-08-31T15:21:47Z",
        "body": "The enum gets used both ways. The `switch` there refers to the `parsingContext` parameter that takes a plain `ParsingContext` value, whereas `isInSomeParsingContext` operates on a bitfield. I'm not entirely sure why we didn't just define this as a flags from the get-go, but it's not a bug."
      },
      {
        "user": "ShuiRuTian",
        "created_at": "2020-09-01T02:06:14Z",
        "body": "Thanks for the detailed reason, glad to know how it works!"
      }
    ]
  },
  {
    "number": 40258,
    "title": "TypeScript 4.0 AST > string | null produces Union(StringKeyword, LiteralType) instead of Union(StringKeyword, NullKeyword) ",
    "created_at": "2020-08-26T09:27:08Z",
    "closed_at": "2020-08-26T19:17:06Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/40258",
    "body": "For the following type:\r\n\r\n```ts\r\ntype Category = {\r\n    name: string | null\r\n}\r\n```\r\n\r\nTypeScript 4.0 produces a following AST:\r\n\r\n```ts\r\nname > UnionType\r\n                  > StringKeyword\r\n                  > LiteralType\r\n                       > NullKeyword\r\n```\r\n\r\nBefore 4.0 it was:\r\n\r\n```ts\r\nname > UnionType\r\n                  > StringKeyword\r\n                  > NullKeyword\r\n```\r\n\r\nJust want to make sure new AST is correct before applying changes in my code.",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/40258/comments",
    "author": "pleerock",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2020-08-26T16:04:21Z",
        "body": "This is the intended categorization since `null` is a literal value at runtime (where as `string` is only a reserved keyword)"
      }
    ]
  },
  {
    "number": 39420,
    "title": "TypeScript package is transpiled to ES5 on npm",
    "created_at": "2020-07-04T08:56:44Z",
    "closed_at": "2020-07-07T22:34:45Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/39420",
    "body": "## Search Terms\r\nnpm, compiler\r\n<!-- List of keywords you searched for before creating this issue. Write them down here so that others can find this suggestion more easily -->\r\n\r\n## Suggestion\r\nIs there any reason the TypeScript package itself is transpiled down to ES5 on npm? The last version of Node.js without ES2015 support was released five years ago. Right now the `typescript` package is sitting at around 50MB on npm. I imagine that switching to an ES2015 build or above would also slightly improve the performance.",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/39420/comments",
    "author": "alex-kinokon",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2020-07-07T21:59:45Z",
        "body": "The TS package gets rolled in to other environments like the Visual Studio Online editor that functions in older runtimes. People are also running TS in some strange-ish environments where ES2015 isn't available.\r\n\r\nWe've tested these things and in general perf/size wins from not downleveling are either very small or even negative; there's not really any downside to targeting older runtimes."
      },
      {
        "user": "alex-kinokon",
        "created_at": "2020-07-07T22:34:45Z",
        "body": "@RyanCavanaugh Thanks for the answer!"
      }
    ]
  },
  {
    "number": 38326,
    "title": "identifier 'IteratorResult'. 75 interface IteratorResult<T> { }",
    "created_at": "2020-05-04T18:45:47Z",
    "closed_at": "2020-05-05T00:09:01Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/38326",
    "body": "I'm getting this error on build using tsc\r\n```\r\n\r\nnode_modules/@types/node/index.d.ts:75:11 - error TS2300: Duplicate identifier 'IteratorResult'.\r\n\r\n75 interface IteratorResult<T> { }\r\n             ~~~~~~~~~~~~~~\r\n```\r\n\r\n\r\nMy package json\r\n\r\n```\r\n\"dependencies\": {\r\n    \"bcrypt\": \"^3.0.2\",\r\n    \"bluebird\": \"^3.5.1\",\r\n    \"body-parser\": \"^1.18.2\",\r\n    \"dotenv\": \"^6.2.0\",\r\n    \"express\": \"^4.16.2\",\r\n    \"express-statsd\": \"^0.3.0\",\r\n    \"express-validator\": \"^5.3.0\",\r\n    \"hashids\": \"^1.2.2\",\r\n    \"jsonwebtoken\": \"^8.4.0\",\r\n    \"mailgun-js\": \"^0.22.0\",\r\n    \"mysql2\": \"^1.5.1\",\r\n    \"nyc\": \"^13.1.0\",\r\n    \"reflect-metadata\": \"^0.1.10\",\r\n    \"sequelize\": \"^5.21.7\",\r\n    \"sequelize-typescript\": \"^1.1.0\",\r\n    \"strong-error-handler\": \"^2.3.0\",\r\n    \"supertest\": \"^3.3.0\",\r\n    \"uuid\": \"^3.3.2\"\r\n  },\r\n  \"devDependencies\": {\r\n    \"@types/express\": \"^4.0.39\",\r\n    \"@types/mocha\": \"2.2.41\",\r\n    \"@types/node\": \"12.12.31\",\r\n    \"mocha\": \"^5.2.0\",\r\n    \"ts-node\": \"^8.4.1\",\r\n    \"tslint\": \"^5.8.0\",\r\n    \"typescript\": \"^3.8.3\"\r\n  }\r\n```\r\n\r\nmy tsconfig.json\r\n\r\n\r\n```\r\n{\r\n  \"compileOnSave\": false,\r\n  \"compilerOptions\": {\r\n    \"target\": \"es6\",\r\n    \"module\": \"commonjs\",\r\n    \"moduleResolution\": \"node\",\r\n    \"experimentalDecorators\": true,\r\n    \"emitDecoratorMetadata\": true,\r\n    \"noUnusedLocals\": true,\r\n    \"sourceMap\": true,\r\n    \"declaration\": false,\r\n    \"pretty\": true,\r\n    \"strictNullChecks\": true,\r\n    \"typeRoots\": [ \"node_modules/@types\" ]\r\n  },\r\n  \"include\": [\r\n    \"src/**/*.ts\",\r\n    \"index.ts\"\r\n  ],\r\n  \"files\": [\r\n    \"./node_modules/@types/mocha/index.d.ts\",\r\n    \"./node_modules/@types/node/index.d.ts\"\r\n  ],\r\n  \"exclude\": [\r\n    \"node_modules\"\r\n  ]\r\n}\r\n\r\n```\r\nsomeone can help?\r\nThanks in advance...",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/38326/comments",
    "author": "ShintaroNippon",
    "comments": [
      {
        "user": "DanielRosenwasser",
        "created_at": "2020-05-05T00:08:52Z",
        "body": "Hey there, this issue tracker isn't meant to work as a support forum. These questions tend to be better suited for StackOverflow. You may want to open a question up there instead. Thanks!\r\n\r\nYou likely do need to upgrade your types for Node though."
      }
    ]
  },
  {
    "number": 37795,
    "title": "Better type inference for Frozen const arrays ",
    "created_at": "2020-04-05T01:01:08Z",
    "closed_at": "2020-04-23T22:02:26Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/37795",
    "body": "Search Terms: Object.freeze, Readonly\r\n\r\nI think typescript should have better type inference when object freeze is used on arrays and The type used is readonly array of the given type, instead the type should be readonly tuple that has the types used in the array.\r\n\r\nExample:\r\n``` javaScript\r\n// The type of the array is: \r\n// readonly Array<string | number>\r\n\r\n// What the type should be:\r\n// readonly [\"Abra\", \"Isma\", 0]\r\nconst b = Object.freeze([\"Abra\", \"Isma\", 0]);\r\n```",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/37795/comments",
    "author": "joseDaKing",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2020-04-17T20:59:07Z",
        "body": "You can use `as const` if this is your intent"
      },
      {
        "user": "joseDaKing",
        "created_at": "2020-04-19T21:12:31Z",
        "body": "what do you mean exactly? "
      },
      {
        "user": "RyanLamansky",
        "created_at": "2020-04-23T20:42:30Z",
        "body": "He means this:\r\n```TS\r\nconst b = Object.freeze([\"Abra\", \"Isma\", 0] as const);\r\n```"
      },
      {
        "user": "joseDaKing",
        "created_at": "2020-04-23T22:02:22Z",
        "body": "Aha did not that existed thanks"
      }
    ]
  },
  {
    "number": 36545,
    "title": "[loc][Query][TypeScript] Localizability of 0; \"TypesInstallerInitializationErrorMessage\"",
    "created_at": "2020-01-31T13:14:22Z",
    "closed_at": "2020-02-26T17:58:02Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/36545",
    "body": "Hi,\r\nplease help localization team to answer question from translator.\r\nIn case translator is not sure about context/meaning/localizability of string we raise a question to Core team.\r\nThanks in advance for the reply\r\n\r\nSource:\r\nFailed to initialize Automatic Type Acquisition. This might cause poor IntelliSense in your JavaScript/TypeScript files. See {0} for more information. Error: {1}\r\n\r\nFile Name:\r\nLanguageService\\TypeScriptLanguageService\\Windows\\bin\\Release\\localize\\ENU\\Microsoft.CodeAnalysis.TypeScript.EditorFeatures.dll\r\n\r\nResource ID:\r\n0; \"TypesInstallerInitializationErrorMessage\"\r\n\r\nQuery:\r\nPlease clarify the meaning of \"poor IntelliSense\". Does \"poor\" mean \"incorrect\"?\r\n\r\n0; \"TypesInstallerInitializationErrorMessage\"\r\n0; \"TypingsInstallErrorMessage\"",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/36545/comments",
    "author": "PDostalek",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2020-02-26T17:57:57Z",
        "body": "\"poor\" here means \"of low quality\" or \"worse than is usual or expected\""
      }
    ]
  },
  {
    "number": 35495,
    "title": "Export control (ECCN)",
    "created_at": "2019-12-04T11:10:08Z",
    "closed_at": "2019-12-18T21:56:07Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/35495",
    "body": "Hi, is there ECCN for typescript or email address I can contact regarding US export compliance for this project?",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/35495/comments",
    "author": "antAirbus",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2019-12-05T18:03:13Z",
        "body": "I'm following up with our internal contact on the matter and will let you know what I find out"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2019-12-18T21:56:07Z",
        "body": "TypeScript doesn't have an ECCN and we aren't able to assist further in this matter."
      }
    ]
  },
  {
    "number": 34963,
    "title": "No longer able to get mixined class' base class type when not including lib files",
    "created_at": "2019-11-07T02:12:04Z",
    "closed_at": "2019-11-14T18:33:35Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/34963",
    "body": "**TypeScript Version:**  3.8.0-dev.20191105\r\n\r\n**Search Terms:** mixin base type\r\n\r\n**Code**\r\n\r\n```ts\r\nimport * as ts from \"typescript\";\r\n\r\nconsole.log(ts.version);\r\n\r\nconst testFilePath = \"/file.ts\";\r\nconst testFileText = `\r\ntype Constructor<T> = new (...args: any[]) => T;\r\nclass Base { prop!: string; }\r\n\r\ninterface Mixin {\r\n    getResult(): number;\r\n}\r\n\r\nfunction Mixin<T extends Constructor<{}>>(Base: T): Constructor<Mixin> & T {\r\n    return class extends Base implements Mixin {\r\n        constructor(...args: any[]) {\r\n            super(args);\r\n        }\r\n\r\n        getResult() {\r\n            return 5;\r\n        }\r\n    }\r\n}\r\n\r\nclass Child extends Mixin(Base) {\r\n}\r\n`;\r\nconst testSourceFile = ts.createSourceFile(testFilePath, testFileText, ts.ScriptTarget.Latest, true);\r\nconst program = getProgram();\r\nconst typeChecker = program.getTypeChecker();\r\n\r\nconst classDec = testSourceFile.statements[testSourceFile.statements.length - 1] as ts.ClassDeclaration;\r\nconst classDecType = typeChecker.getTypeAtLocation(classDec.name!);\r\n\r\nconsole.log(classDecType.getBaseTypes()!.map(t => typeChecker.typeToString(t)));\r\n\r\nconsole.log(\"---------\");\r\nconsole.log(ts.formatDiagnosticsWithColorAndContext(ts.getPreEmitDiagnostics(program, testSourceFile), {\r\n    getCanonicalFileName: name => name,\r\n    getCurrentDirectory: () => \"/\",\r\n    getNewLine: () => \"\\n\"\r\n}));\r\n\r\nfunction getProgram() {\r\n    const options: ts.CompilerOptions = { target: ts.ScriptTarget.ES5 };\r\n    const host: ts.CompilerHost = {\r\n        fileExists: filePath => filePath === testFilePath,\r\n        directoryExists: dirPath => dirPath === \"/\",\r\n        getCurrentDirectory: () => \"/\",\r\n        getDirectories: () => [],\r\n        getCanonicalFileName: fileName => fileName,\r\n        getNewLine: () => \"\\n\",\r\n        getDefaultLibFileName: () => \"\",\r\n        getSourceFile: filePath => filePath === testFilePath ? testSourceFile : undefined,\r\n        readFile: filePath => filePath === testFilePath ? testFileText : undefined,\r\n        useCaseSensitiveFileNames: () => true,\r\n        writeFile: () => {}\r\n    };\r\n    return ts.createProgram({\r\n        options,\r\n        rootNames: [testFilePath],\r\n        host\r\n    });\r\n}\r\n```\r\n\r\n**Expected output (pre TS 3.7):**\r\n\r\n```\r\n3.6.3\r\n[ 'Mixin & Base' ]\r\n---------\r\nerror TS2318: Cannot find global type 'Array'.\r\nerror TS2318: Cannot find global type 'Boolean'.\r\nerror TS2318: Cannot find global type 'Function'.\r\nerror TS2318: Cannot find global type 'IArguments'.\r\nerror TS2318: Cannot find global type 'Number'.\r\nerror TS2318: Cannot find global type 'Object'.\r\nerror TS2318: Cannot find global type 'RegExp'.\r\nerror TS2318: Cannot find global type 'String'.\r\n```\r\n\r\n**Actual behavior (TS 3.7 and greater):**\r\n\r\n```\r\n3.8.0-dev.20191105\r\n[ 'Mixin' ]\r\n---------\r\nerror TS2318: Cannot find global type 'Array'.\r\nerror TS2318: Cannot find global type 'Boolean'.\r\nerror TS2318: Cannot find global type 'Function'.\r\nerror TS2318: Cannot find global type 'IArguments'.\r\nerror TS2318: Cannot find global type 'Number'.\r\nerror TS2318: Cannot find global type 'Object'.\r\nerror TS2318: Cannot find global type 'RegExp'.\r\nerror TS2318: Cannot find global type 'String'.\r\nfile.ts:10:12 - error TS2545: A mixin class must have a constructor with a single rest parameter of type 'any[]'.\r\n\r\n10     return class extends Base implements Mixin {\r\n              ~~~~~\r\nfile.ts:21:21 - error TS2510: Base constructors must all have the same return type.\r\n\r\n21 class Child extends Mixin(Base) {\r\n                       ~~~~~~~~~~~\r\n```\r\n\r\nNOTE: This works fine when including the lib.d.ts-like files.\r\n\r\n**Question**\r\n\r\nOk, maybe this is all bets off because of the compile errors caused by no lib files. I thought I would report it anyway though to ask why it would now need the lib files?",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/34963/comments",
    "author": "dsherret",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2019-11-14T18:29:44Z",
        "body": "The checker is really, really bad at doing anything without definitions of the built-in types. This may have worked by accident before, but these types need to be present for any behavior to be well-defined"
      },
      {
        "user": "dsherret",
        "created_at": "2019-11-14T18:33:35Z",
        "body": "@RyanCavanaugh yeah, that's not surprising. I'm just going to work on making it easier to load in lib files when using an in-memory file system.\r\n\r\nThanks for answering my question!"
      }
    ]
  },
  {
    "number": 33303,
    "title": "Does Typescript support circularly reference type?",
    "created_at": "2019-09-08T02:40:44Z",
    "closed_at": "2019-09-11T20:56:01Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/33303",
    "body": "```ts\r\n// Yes\r\ninterface A {\r\n  self: A;\r\n}\r\n\r\n// No\r\ntype A = [A?];\r\n// or\r\ntype B = [string | B];\r\n```",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/33303/comments",
    "author": "Coooooooola",
    "comments": [
      {
        "user": "austincummings",
        "created_at": "2019-09-08T02:44:21Z",
        "body": "~Not at the moment.~ I believe it is being expanded on in #33050 though. "
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2019-09-11T20:56:01Z",
        "body": "Sometimes it does!"
      }
    ]
  },
  {
    "number": 33203,
    "title": "Compiler API: getConstantValue() can't get a real value from enum's PropertyAccessExpression",
    "created_at": "2019-09-03T03:48:37Z",
    "closed_at": "2019-09-04T01:43:49Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/33203",
    "body": "<!-- Please try to reproduce the issue with `typescript@next`. It may have already been fixed. -->\r\n**TypeScript Version:**  3.5.3\r\n\r\n<!-- Search terms you tried before logging this (so others can find this issue more easily) -->\r\n**Search Terms:**\r\n\r\nCompiler API, getConstantValue, PropertyAccessExpression\r\n\r\n**Code**\r\n\r\n```ts\r\nimport * as ts from \"typescript\";\r\n\r\n\r\nlet program = ts.createProgram(['/src/sandbox/test.ts'], {});\r\nlet checker = program.getTypeChecker();\r\n\r\nlet source = program.getSourceFile('/src/sandbox/test.ts')!;\r\n\r\nsource.forEachChild(node => {\r\n  switch (node.kind) {\r\n    case ts.SyntaxKind.EnumDeclaration:\r\n      (() => {\r\n        const real = node as ts.EnumDeclaration;\r\n        real.members.forEach(item => {\r\n          console.log(item.name.getText(), checker.getConstantValue(item))\r\n        })\r\n      })()\r\n      break;\r\n    case ts.SyntaxKind.ExpressionStatement:\r\n      (() => {\r\n        const a = node as ts.ExpressionStatement;\r\n        const real = a.expression as ts.PropertyAccessExpression;\r\n        console.log(checker.getConstantValue(real)) // ------------------------> Undefined\r\n      })()\r\n      break\r\n  }\r\n});\r\n```\r\n\r\nThe '/src/sandbox/test.ts':\r\n```ts\r\nenum Test {\r\n    A = 100,\r\n    B,\r\n}\r\n\r\nTest.A;\r\n```\r\n\r\n**Expected behavior:**\r\n\r\nTell me `100`\r\n\r\n**Actual behavior:**\r\n\r\nReturns `undefined`\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/33203/comments",
    "author": "mohanson",
    "comments": [
      {
        "user": "sandersn",
        "created_at": "2019-09-03T23:08:50Z",
        "body": "getConstantValue doesn't follow references back to their declaration. You have to do that yourself by looking at the symbol's declaration. Something like\r\n\r\n`checker.getConstantValue(checker.getSymbolAtLocation(real))`"
      },
      {
        "user": "mohanson",
        "created_at": "2019-09-04T01:43:49Z",
        "body": "Got it!"
      }
    ]
  },
  {
    "number": 33166,
    "title": "Declaration dts files cannot represent enums nested in interfaces",
    "created_at": "2019-08-30T17:30:40Z",
    "closed_at": "2019-09-03T19:52:57Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/33166",
    "body": "**TypeScript Version:**  3.5.0\r\n\r\n**Search Terms:** enum in interface declaration\r\n\r\n**Code**\r\n\r\nFor JavaScript code being edited with Monaco, DTS libraries are used to inform Monaco of the symbols which can be autocompleted.\r\n\r\nIn our case, our library permits code like the following:\r\n\r\n```js\r\nLib.setEnum(Lib.MyEnum.ONE);\r\nLib.chain().setEnum(Lib.MyEnum.ONE);\r\n```\r\n\r\nThe expected way to represent this would be something along the lines of:\r\n\r\n```ts\r\n// lib.d.ts\r\ninterface Lib {\r\n    chain(): Lib;\r\n    setEnum(val: Lib.MyEnum);\r\n}\r\nconst Lib: Lib;\r\nmodule Lib {\r\n    enum MyEnum { ONE }\r\n}\r\n```\r\n\r\n**Expected behavior:**\r\n\r\nTypeScript is aware of the symbols `Lib.chain`, `Lib.setEnum`, `Lib.MyEnum`.\r\n\r\n**Actual behavior:**\r\n\r\nAs written, with `module Lib` at the end of `lib.d.ts`, only `Lib.chain` and `Lib.setEnum` autocomplete.  `Lib.setEnum` takes an `any` though instead of `Lib.MyEnum`.\r\n\r\nIf you move `module Lib` to the top of `lib.d.ts`, only `Lib.MyEnum` autocompletes.",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/33166/comments",
    "author": "trevorade",
    "comments": [
      {
        "user": "sandersn",
        "created_at": "2019-09-03T19:52:57Z",
        "body": "This one is tricky. enums define both a type and a value, so the containing namespace `Lib` defines a value too. That means it can't merge with any other values, like `const Lib`. But in order for references like `Lib.setEnum` to resolve, the *value* `Lib` needs to contain `setEnum`. So you need to declare the functions on the namespace instead of the interface.\r\n\r\nThis leaves you with a problem of referencing the type that `Lib` defines in `chain`. Confusingly, it's not `Lib` since the namespace `Lib` is a value, not a type. It's `typeof Lib`.\r\n\r\n```ts\r\ndeclare namespace Lib {\r\n    export function chain(): typeof Lib\r\n    export function setEnum(val: Lib.MyEnum): any;\r\n    enum MyEnum { ONE }\r\n}\r\n\r\nLib.setEnum(Lib.MyEnum.ONE);\r\nLib.chain().setEnum('hi'); // expect error here\r\n```\r\n\r\n"
      }
    ]
  },
  {
    "number": 32733,
    "title": "MsBuild.TypeScript uses Node 32bit by default",
    "created_at": "2019-08-06T14:21:52Z",
    "closed_at": "2019-08-07T17:06:35Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/32733",
    "body": "I tried to use MSBuild.Typescript and discover that it uses only 32bit version of Node.\r\nThis is written in  Microsoft.TypeScript.targets\r\n`    <NodePath Condition=\"'$(OS)' == 'Windows_NT' AND Exists('$(MSBuildExtensionsPath)\\Microsoft\\VisualStudio\\NodeJs\\\\node.exe')\">$(MSBuildExtensionsPath)\\Microsoft\\VisualStudio\\NodeJs</NodePath>\r\n`\r\nBut in this path we have win-x64 directory with 64bit version node.exe.\r\nIs it correct?  When I use node from cmd I use 64bit Node",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/32733/comments",
    "author": "SlavkaOnline",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2019-08-06T15:44:53Z",
        "body": "Correct. 32-bit Node tends to be faster than 64-bit."
      },
      {
        "user": "SlavkaOnline",
        "created_at": "2019-08-07T01:24:42Z",
        "body": "> Correct. 32-bit Node tends to be faster than 64-bit.\r\n\r\nSo could you help to resolve my problem?\r\nI can build my project on the local environment (my PC) but when I try to build my project on the build server (with windows server 2008) I have a problem with memory for node. After use google, I discovered that if I set NODE_OPTIONS=--max_old_space_size=4096 and use 64bit Node it resolve my problem. But it all seems very strange to me."
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2019-08-07T15:43:35Z",
        "body": "It sounds like you were able to find the solution. Is there anything else we can help clarify?"
      },
      {
        "user": "SlavkaOnline",
        "created_at": "2019-08-07T17:06:35Z",
        "body": "> It sounds like you were able to find the solution. Is there anything else we can help clarify?\r\n\r\nI think in the future I will use NPM package for tsc.js. That's all, thank."
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2019-08-07T17:18:39Z",
        "body": "That's a good plan. Thanks!"
      }
    ]
  },
  {
    "number": 32052,
    "title": "how do i get previous number in types?",
    "created_at": "2019-06-23T21:23:43Z",
    "closed_at": "2019-07-13T00:00:10Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/32052",
    "body": "here is a pattern that gets the next number in types domain\r\n```\r\ntype Nums = [1, 2, 3, 4, 5, 6, 7, 8, 9];\r\ntype Num = Nums[number];\r\ntype Next<N extends Num> = Nums[N] extends number ? Nums[N] : never;\r\ntype N2 = Next<1>; // 2\r\n```\r\nis there a way to get a previous number?",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/32052/comments",
    "author": "zpdDG4gta8XKpMCd",
    "comments": [
      {
        "user": "nattthebear",
        "created_at": "2019-06-23T21:54:12Z",
        "body": "Not sure why you'd want this, but isn't it obvious?\r\n```ts\r\ntype Nums = [-1, 0, 1, 2, 3, 4, 5, 6, 7];\r\ntype Num = Nums[number];\r\ntype Prev<N extends Num> = Nums[N] extends number ? Nums[N] : never;\r\ntype N2 = Prev<1>; // 0\r\n```\r\n"
      },
      {
        "user": "zpdDG4gta8XKpMCd",
        "created_at": "2019-06-23T22:11:34Z",
        "body": "can you use the original sequence?"
      },
      {
        "user": "jcalz",
        "created_at": "2019-06-24T00:34:16Z",
        "body": "Shouldn't this be on Stack Overflow?  \r\n\r\n```ts\r\ntype Prev<N extends Num> = { [K in Num]: N extends Next<K> ? K : never }[Num];\r\n// Prev<1> is never, just like Next<9> is never. 🤷‍♂️\r\n```\r\n\r\n"
      }
    ]
  },
  {
    "number": 32043,
    "title": "Support 'as const' together with type restriction",
    "created_at": "2019-06-22T19:32:41Z",
    "closed_at": "2019-07-13T00:00:10Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/32043",
    "body": "Would be nice to be able to apply type checking to 'as const' types, currently I have to use the silly trick of using type checks when writing them, then switch to 'as const' afterwards.\r\n\r\n```\r\ntype MyType = {name: string};\r\n\r\nconst x:MyType = {\r\n    name: 'test' // Autocompleted, typesafe. But Type is {name: string}, not \r\n                 // what I want, I want {readonly name: 'test'}\r\n} as const;\r\n\r\nconst x = { name: 'test' } as const; // Gives correct type, but no type check for MyType...\r\n```",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/32043/comments",
    "author": "KnutRyagerInmeta",
    "comments": [
      {
        "user": "MartinJohns",
        "created_at": "2019-06-22T22:24:35Z",
        "body": "Your type `MyType` clearly says that `name` is a mutable property. If you want it read-only, then you can just use `Readonly<MyType>`."
      },
      {
        "user": "jcalz",
        "created_at": "2019-06-23T00:59:09Z",
        "body": "Helper function to the rescue!\r\n\r\n```ts\r\ntype MyType = { name: string };\r\nconst asMyType = <T extends MyType>(x: T) => x; // helper function\r\nconst x = asMyType({ name: \"test\" } as const); // 😃\r\n```"
      },
      {
        "user": "KnutRyagerInmeta",
        "created_at": "2019-06-23T15:56:16Z",
        "body": "@jcalz this does the trick.\r\n\r\n@MartinJohns readonly was not originally of my concern, but emerged with 'as const'. Seems with jcalz's solution readony does not emerge. Now a single string literal type should be readonly by implication though... well you are allowed to overwrite with the same string I guess."
      },
      {
        "user": "MartinJohns",
        "created_at": "2019-06-23T16:15:47Z",
        "body": "@KnutRyagerInmeta You mean a string literal type, e.g. `'fixed'` instead of `string`. In that case the same logic applies: Your type `MyType` explicitly says the property `name` can be of **any** string.\r\n\r\nWith jcalz solution you will have the same issue when you use the wrong type:\r\n\r\n    const x: MyType = asMyType({ name: \"test\" } as const); // x.name is of type string again\r\n\r\nBut I likely misunderstand you, and you want something like \"make sure this object matches SomeType, then make it a const context\", in which case jcalz solution is probably the best."
      }
    ]
  },
  {
    "number": 31998,
    "title": "Please include that typeRoots is used only for resolving <reference path=\"\"/> tags",
    "created_at": "2019-06-20T11:04:51Z",
    "closed_at": "2019-07-13T00:00:13Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/31998",
    "body": "I've wasted tons of time and was so frustrated because the typeRoots option wasn't working as I expected. The type definition file could not be found so I looked up the documentation multiple times, googled around, and finally managed to find an answer on github issues stating that it is only for resolving the `/// <reference path=\"\"/>` tag and that I should use the `include` option instead.\r\n\r\nThe current description for the `typeRoots` option is \"List of folders to include type definitions from.\" and this description is sloppy and misleading. I've seen multiple other users confused and asking the same questions I did. If this description can be updated to be more precise, it would really save a lot of users' time and frustrations.",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/31998/comments",
    "author": "hwkd",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2019-06-25T17:31:42Z",
        "body": "Huh? This isn't true. Do you mean `<reference types` ?"
      },
      {
        "user": "hwkd",
        "created_at": "2019-06-26T15:17:53Z",
        "body": "@RyanCavanaugh Okay perhaps it was `/// <reference types=\"...\"/>` but you get my point."
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2019-06-26T15:41:36Z",
        "body": "We'll be writing up better docs on this as part of the new handbook effort"
      }
    ]
  },
  {
    "number": 31944,
    "title": "Why Typescript does not have @types?",
    "created_at": "2019-06-17T20:21:38Z",
    "closed_at": "2019-06-17T20:34:41Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/31944",
    "body": "\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/31944/comments",
    "author": "lksilva",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2019-06-17T20:27:25Z",
        "body": "Packages which ship their own `.d.ts` files don't need `@types` packages"
      }
    ]
  },
  {
    "number": 31479,
    "title": "How to include files like txt, csv, docx and xlsx in Typescript compilation output?",
    "created_at": "2019-05-20T18:56:29Z",
    "closed_at": "2019-05-20T20:34:05Z",
    "labels": [
      "Duplicate",
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/31479",
    "body": "",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/31479/comments",
    "author": "GianfrancoMS",
    "comments": [
      {
        "user": "DanielRosenwasser",
        "created_at": "2019-05-20T20:34:05Z",
        "body": "Duplicate of #15222\r\nDuplicate of #30835"
      }
    ]
  },
  {
    "number": 31433,
    "title": "Incorrect error (TS2367) that a variable will always have a certain value, and thus a condition will always be false",
    "created_at": "2019-05-16T19:12:01Z",
    "closed_at": "2019-07-13T00:00:29Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/31433",
    "body": "I'm using TS 3.4.3.  The code looks like the following:\r\n\r\npackage.json has:\r\n\r\n```\r\n    \"dependencies\": {\r\n        \"deasync\": \"^0.1.15\"\r\n    },\r\n    \"devDependencies\": {\r\n        \"@types/deasync\": \"^0.1.0\",\r\n    }\r\n```\r\n\r\ntsconfig is:\r\n\r\n```json\r\n    \"compilerOptions\": {\r\n        \"outDir\": \"bin\",\r\n        \"target\": \"es6\",\r\n        \"module\": \"commonjs\",\r\n        \"moduleResolution\": \"node\",\r\n        \"declaration\": true,\r\n        \"sourceMap\": true,\r\n        \"stripInternal\": true,\r\n        \"experimentalDecorators\": true,\r\n        \"noFallthroughCasesInSwitch\": true,\r\n        \"forceConsistentCasingInFileNames\": true,\r\n        \"strict\": true\r\n    },\r\n```\r\n\r\n```ts\r\nimport * as deasync from \"deasync\";\r\n\r\nexport function promiseResult<T>(promise: Promise<T>): T {\r\n    enum State {\r\n        running,\r\n        finishedSuccessfully,\r\n        finishedWithError,\r\n    }\r\n\r\n    let result: T;\r\n    let error = undefined;\r\n    let state = State.running;\r\n\r\n    promise.then(\r\n        val => {\r\n            result = val;\r\n            state = State.finishedSuccessfully;\r\n        },\r\n        err => {\r\n            error = err;\r\n            state = State.finishedWithError;\r\n        });\r\n\r\n    deasync.loopWhile(() => state === State.running);\r\n    if (state === State.finishedWithError) {\r\n        throw error;\r\n    }\r\n\r\n    return result!;\r\n}\r\n```\r\n\r\nThis reports:\r\n\r\n```\r\nThis condition will always return 'false' since the types 'State.running' and 'State.finishedWithError' have no overlap.\r\n```\r\n\r\nOn this line:\r\n\r\n```ts\r\n    if (state === State.finishedWithError) {\r\n```\r\n\r\nThis error seems specious (and doesn't match confirmed runtime behavior) since `state` can be and is assigned other values in both the callbacks to `promise.then(..., ...)`.  For some reason TS seems to not be considering these.  \r\n\r\nI can 'fix' this by writing `let state = <State>State.running;`, but it's not clear why i should have to.\r\n\r\nIs this a bug in the compiler?\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/31433/comments",
    "author": "CyrusNajmabadi",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2019-05-16T20:50:36Z",
        "body": "Duplicate #9998"
      }
    ]
  },
  {
    "number": 31176,
    "title": "Type checking of extended mapped type",
    "created_at": "2019-04-30T18:49:06Z",
    "closed_at": "2019-05-01T12:14:48Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/31176",
    "body": "**Typescript version:** 3.4.5.\r\n\r\nI'm writing the boilerplate code for type-safe Express routes in my projects, possibly even create a npm library, if it works as expected.\r\nThe idea is to make sure all the API responses have the shape\r\n```ts\r\n{result: T, error?: any}\r\n```\r\nwhere T is the Response type of the route, or\r\n```ts\r\n{error: any}\r\n```\r\nif there is an error and declare the type of each routes' request and response types in a declarative way.\r\n\r\nThe API is routed under the `/api` route. I'm accomplishing this with `app.use('/api', indexRouter.router)`, where `indexRouter` is an instance of `WrappedRouter` (which is defined at the end of this bug report) which is imported from the file `routes/index.ts`.\r\n\r\n**Contents of `routes/index.ts`**:\r\n```ts\r\nimport authRouter from './auth';\r\nimport makeRouter from \"../utils/RestRoute\";\r\n\r\nconst router = makeRouter();\r\n\r\nrouter.makeSubRoute('/auth',authRouter);\r\n\r\nexport default router;\r\n```\r\n\r\n**Contents of `routes/auth/types.ts`**:\r\n```ts\r\nimport {ITypes} from '../../utils/RestRoute';\r\n\r\nexport interface Types extends ITypes {\r\n    '/sayHello': {\r\n        request: void,\r\n        response: string\r\n    }\r\n}\r\n```\r\n\r\nThe idea is that I can now write this:\r\n**Contents of `routes/auth/index.ts`**:\r\n```ts\r\nimport makeRouter from '../../utils/RestRoute';\r\nimport {Types} from \"./types\";\r\n\r\nconst router = makeRouter<Types>();\r\n\r\nrouter.route('/sayHello',args => ({\r\n    result: 'Hello World!'\r\n}));\r\n\r\nexport default router.router;\r\n```\r\n____________________________________________________________\r\n\r\n**Contents of `RestRoute.ts`** (which contains the wrapper around Express.JS's Route and most of the boilerplate logic):\r\n\r\n```ts\r\nimport express from 'express';\r\n\r\nexport interface ITypes {\r\n    [key: string]: {\r\n        request: any,\r\n        response: any\r\n    }\r\n}\r\n\r\ninterface HandlerFuncionArgs<Req> {\r\n    cookies: express.Request[\"cookies\"],\r\n    hostname: express.Request[\"hostname\"],\r\n    ip: express.Request[\"ip\"],\r\n    clearCookie: express.Response[\"clearCookie\"],\r\n    cookie: express.Response[\"cookie\"],\r\n    secure: express.Request[\"secure\"],\r\n    body: Req,\r\n    params: express.Request[\"params\"]\r\n}\r\n\r\nexport type APIResultType<T> = {result: T, error?: any} | {error: any};\r\n\r\nexport type HandlerFunction<Req,Res> = (args: HandlerFuncionArgs<Req>)=>APIResultType<Res> & {status?: number};\r\n\r\nclass WrappedRouter<Types extends ITypes> {\r\n    public constructor(public readonly router: express.Router) {}\r\n\r\n    private static proxyFunction<Req,Res>(handlerFunction: HandlerFunction<Req,Res>): express.RequestHandler {\r\n        return (req, res, next) => {\r\n            res.type('application/json');\r\n            try {\r\n                const ret = handlerFunction({\r\n                    cookies: req.cookies,\r\n                    hostname: req.hostname,\r\n                    ip: req.ip,\r\n                    clearCookie: res.clearCookie,\r\n                    cookie: res.cookie,\r\n                    secure: req.secure,\r\n                    body: req.body,\r\n                    params: req.params\r\n                });\r\n                res.status(ret.status || 200);\r\n                delete ret.status;\r\n                res.json(ret as APIResultType<Res>);\r\n            } catch(e) {\r\n                res.status(500);\r\n                res.json({error: e} as APIResultType<Res>);\r\n            } finally {\r\n                res.end();\r\n            }\r\n        };\r\n    }\r\n\r\n    public route<Path extends keyof Types>(path: Path, handlerFunction: HandlerFunction<Types[Path][\"request\"],Types[Path][\"response\"]>):void {\r\n        this.router.post(path as string,WrappedRouter.proxyFunction(handlerFunction));\r\n    }\r\n\r\n    public makeSubRoute(path: string, subRouter: express.Router): void;\r\n\r\n    public makeSubRoute<SubRouterTypes extends ITypes>(path: string, subRouter: WrappedRouter<SubRouterTypes>): void;\r\n\r\n    public makeSubRoute<SubRouterTypes extends ITypes>(path: string, subRouter: express.Router|WrappedRouter<SubRouterTypes>) {\r\n        if(subRouter instanceof WrappedRouter) {\r\n            this.router.use(path,subRouter.router);\r\n        } else {\r\n            this.router.use(path,subRouter);\r\n        }\r\n    }\r\n}\r\n\r\nexport function wrapRouter<Types extends ITypes>(router: express.Router) {\r\n    return new WrappedRouter<Types>(router);\r\n}\r\n\r\nexport function makeRouter<Types extends ITypes>() {\r\n    return new WrappedRouter<Types>(express.Router({caseSensitive: true, mergeParams: true}));\r\n}\r\n\r\nexport default makeRouter;\r\n```\r\n(`ITypes` is supposed to be the generic shape of every route's type: each key, representing a route, should contain an object with \"response\" and \"request\" as its only keys. `ITypes` isn't supposed to be instantiated, only extended by other types)\r\n\r\n**Expected behavior:**\r\nCorrectly checks the types of the request and response of each route **AND** doesn't allow routes which aren't defined in that sub-route's `Type`.\r\n\r\n**Actual behaviour:**\r\nIt works well in checking the types of the route: ie. if I try to return `result: 1` in the `/api/auth/sayHello` route, the compiler fails and says that number isn't compatible with string.\r\nThe problem is when I mistype `/sayHello` for, say, `/sayHelo`. There is no error reported from the compiler _even though_ `WrappedRouter.route`'s first argument is of type `Path extends keyof Types`. It just simply accepts any type in the request and any type in the response... It should be an error because `/sayHelo` __**is not**__ in `keyof Type`, which is equal to `/sayHelo`.\r\n\r\nI'm guessing the problem is in extending the interface because it is first declared as having string keys but doesn't specify the keys' type when it is extended. I think `keyof Types` computes to `\"/sayHello\" | string`.\r\n\r\nI've tried to change the generic type of the `route` function to `<Path extends Exclude<keyof Types, string>>` but it doesn't work because it also deletes `\"/sayHello\"` from the union type. Then the `router.route('/sayHello' (...)` line in the `auth/index.ts` file reports the error `TS2345: Argument of type '\"/sayHello\"' is not assignable to parameter of type 'number'`.\r\n\r\nIs there any workaround or a hacky way of accomplishing this while this isn't fix this in a future version of TS?",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/31176/comments",
    "author": "TheDSCPL",
    "comments": [
      {
        "user": "dragomirtitian",
        "created_at": "2019-04-30T21:29:50Z",
        "body": "That is one long question, might I suggest in the future: \r\n\r\n1. Isolating a smaller code snippet illustrating your issue.\r\n2. Trying stackoverflow first. This forum is generally reserved for bugs, or questions that SO didn't or can't answer (you will probably get answers there just as fast here and by the same people)\r\n\r\nThat being said, your root cause is that you force `Types` to have an index signature. If `Types` has an index signature, `keyof Types` will be `string` allowing any string in path.\r\n\r\nYou can change the definitions a bit, you actually want to constrain `ITypes` to have only properties of type `{ request: any, response: any }` regardless of if they have an index signature.\r\n\r\nA solution that seems to work (although I have not tested it a lot) would be: \r\n\r\n```ts\r\n//RestRoute.ts\r\nimport express from 'express';\r\n\r\nexport type ITypes<K extends PropertyKey> = Record<K, { request: any, response: any }>\r\n\r\ninterface HandlerFuncionArgs<Req> {\r\n    cookies: express.Request[\"cookies\"],\r\n    hostname: express.Request[\"hostname\"],\r\n    ip: express.Request[\"ip\"],\r\n    clearCookie: express.Response[\"clearCookie\"],\r\n    cookie: express.Response[\"cookie\"],\r\n    secure: express.Request[\"secure\"],\r\n    body: Req,\r\n    params: express.Request[\"params\"]\r\n}\r\n\r\nexport type APIResultType<T> = {result: T, error?: any} | {error: any};\r\n\r\nexport type HandlerFunction<Req,Res> = (args: HandlerFuncionArgs<Req>)=>APIResultType<Res> & {status?: number};\r\n\r\nclass WrappedRouter<Types extends ITypes<keyof Types>> {\r\n    public constructor(public readonly router: express.Router) {}\r\n\r\n    private static proxyFunction<Req,Res>(handlerFunction: HandlerFunction<Req,Res>): express.RequestHandler {\r\n        return (req, res, next) => {\r\n            res.type('application/json');\r\n            try {\r\n                const ret = handlerFunction({\r\n                    cookies: req.cookies,\r\n                    hostname: req.hostname,\r\n                    ip: req.ip,\r\n                    clearCookie: res.clearCookie,\r\n                    cookie: res.cookie,\r\n                    secure: req.secure,\r\n                    body: req.body,\r\n                    params: req.params\r\n                });\r\n                res.status(ret.status || 200);\r\n                delete ret.status;\r\n                res.json(ret as APIResultType<Res>);\r\n            } catch(e) {\r\n                res.status(500);\r\n                res.json({error: e} as APIResultType<Res>);\r\n            } finally {\r\n                res.end();\r\n            }\r\n        };\r\n    }\r\n\r\n    public route<Path extends keyof Types>(path: Path, handlerFunction: HandlerFunction<Types[Path][\"request\"],Types[Path][\"response\"]>):void {\r\n        this.router.post(path as string,WrappedRouter.proxyFunction(handlerFunction));\r\n    }\r\n\r\n    public makeSubRoute(path: string, subRouter: express.Router): void;\r\n\r\n    public makeSubRoute<SubRouterTypes extends ITypes<keyof SubRouterTypes>>(path: string, subRouter: WrappedRouter<SubRouterTypes>): void;\r\n\r\n    public makeSubRoute<SubRouterTypes extends ITypes<keyof SubRouterTypes>>(path: string, subRouter: express.Router|WrappedRouter<SubRouterTypes>) {\r\n        if(subRouter instanceof WrappedRouter) {\r\n            this.router.use(path,subRouter.router);\r\n        } else {\r\n            this.router.use(path,subRouter);\r\n        }\r\n    }\r\n}\r\n\r\nexport function wrapRouter<Types extends ITypes<keyof Types>>(router: express.Router) {\r\n    return new WrappedRouter<Types>(router);\r\n}\r\n\r\nexport function makeRouter<Types extends ITypes<keyof Types>>() {\r\n    return new WrappedRouter<Types>(express.Router({caseSensitive: true, mergeParams: true}));\r\n}\r\n\r\nexport default makeRouter;\r\n\r\n// types.ts\r\n\r\nimport {ITypes} from '../../utils/RestRoute';\r\n\r\nexport interface Types extends ITypes<keyof Types> { // ensures all properties have the correct shape\r\n    '/sayHello': {\r\n        request: void,\r\n        response: string\r\n    }\r\n}\r\n\r\n//auth/index.ts\r\nimport makeRouter from '../../utils/RestRoute';\r\n\r\nimport {Types} from \"./types\";\r\n\r\nconst router = makeRouter<Types>();\r\n\r\n//ok\r\nrouter.route('/sayHello',args => ({\r\n    result: 'Hello World!'\r\n}));\r\n\r\n//err\r\nrouter.route('/sayHelloo',args => ({\r\n    result: 'Hello World!'\r\n}));\r\n\r\nexport default router.router;"
      },
      {
        "user": "TheDSCPL",
        "created_at": "2019-05-01T12:14:48Z",
        "body": "Uhm, ok! I didn't know you could do this kind of recursive operations in the types definition!\r\nI thought this was a bug because I dind't know `<Types extends ITypes<keyof Types>>` was valid syntax.\r\nThank you very much!"
      }
    ]
  },
  {
    "number": 30990,
    "title": "'export' fails in declaration files",
    "created_at": "2019-04-17T12:07:34Z",
    "closed_at": "2019-07-13T00:00:36Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/30990",
    "body": "test.d.ts\r\n`/*export*/ declare type typeA = number; //uncomment 'export' will cause an issue in test.ts as shown below, and cannot be removed (see test2.d.ts to know why)`\r\n\r\ntest2.d.ts\r\n```\r\n//trying to import declarations from another file\r\n//faild to load them via ///<reference>\r\nexport declare type typeB=number; //'export' here is mandatory for importing\r\n\r\n```\r\ntest.ts\r\n```\r\n///<reference types=\"./test2\" /> //not work\r\n///<reference path=\"./test2.d.ts\" /> //not work\r\ntype typeB3 = import(\"./test2\").typeB ; //works\r\nimport { typeB as typeB4 } from \"./ts2\"; //works\r\n\r\nlet x1:typeA=1,//works only if 'export' removed\r\n     x2:typeB=1, //not work, i.e didn't imported via  ///<reference>\r\n     x3:typeB3=1, //works \r\n     x4:typeB4=1, //works \r\n```\r\n     \r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/30990/comments",
    "author": "xxyyzz2050",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2019-04-17T21:20:33Z",
        "body": "Not a bug. `reference` does not cause module exports to become in scope. StackOverflow can explain more"
      },
      {
        "user": "xxyyzz2050",
        "created_at": "2019-05-01T08:53:55Z",
        "body": "thanks @RyanCavanaugh "
      }
    ]
  },
  {
    "number": 30865,
    "title": "how can i get a contextual type of a function result?",
    "created_at": "2019-04-11T15:45:54Z",
    "closed_at": "2019-07-13T00:00:38Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/30865",
    "body": "```ts\r\nfunction thusMyClass() {\r\n    return class {\r\n    };\r\n}\r\n```\r\n\r\nnow, using typescript api, i am given `declaration: ts.FunctionDeclaration` node of the `thusMyClass` function with `declaration.type` being undefined, how can i get the contextual type of a function declaration?",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/30865/comments",
    "author": "zpdDG4gta8XKpMCd",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2019-04-11T16:07:39Z",
        "body": "`getContextualType` would be the function to call, but function declarations aren't subject to contextual typing. The expression of the return statement would be contextually typed by a return type annotation if one existed, though."
      },
      {
        "user": "zpdDG4gta8XKpMCd",
        "created_at": "2019-04-11T16:17:32Z",
        "body": "...bad day"
      },
      {
        "user": "zpdDG4gta8XKpMCd",
        "created_at": "2019-04-11T16:18:45Z",
        "body": "what if i have 10 return statements, how do i get the resulting type combining them all?"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2019-04-11T17:27:52Z",
        "body": "Call `getTypeAtLocation` either on each return statement expression (and combine them using whatever \"combine\" means to you), or call it on the declaration to and inspect the return type (to get the compiler's view of the world)"
      }
    ]
  },
  {
    "number": 30707,
    "title": "weird type relationship",
    "created_at": "2019-04-02T16:07:01Z",
    "closed_at": "2019-04-02T17:13:42Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/30707",
    "body": "problem:\r\n\r\n```ts\r\ndeclare function sureNever<_T extends never>(): void;\r\ntype NeverDifferent<L, R> = L extends R ? R extends L ? never : 'right does not extend left' : 'left does not extend right';\r\nsureNever<NeverDifferent<'a', 'a'>>(); // works\r\nsureNever<NeverDifferent<{}, {}>>(); // works\r\nsureNever<NeverDifferent<'a' | 'b', 'a' | 'b'>>(); // breaks: Type '\"right does not extend left\"' does not satisfy the constraint 'never'\r\n```\r\n\r\nnasty workaround:\r\n\r\n```ts\r\ndeclare function sureIdentical<L, R>(\r\n    asRight: (left: L) => R,\r\n    asLeft: (right: R) => L,\r\n): void;\r\nsureIdentical<'a' | 'b', 'a'>(x => x, x => x); // breaks as expected\r\nsureIdentical<'a', 'a' | 'b'>(x => x, x => x); // breaks as expected\r\nsureIdentical<'a' | 'b', 'a' | 'b'>(x => x, x => x); // works as expected\r\n```",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/30707/comments",
    "author": "zpdDG4gta8XKpMCd",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2019-04-02T17:07:49Z",
        "body": "Conditional type distributivity (yr fav) is what's causing this. This produces the behavior desired by the example:\r\n```ts\r\ntype NeverDifferent<L, R> = [L] extends [R] ? R extends L ? never : 'right does not extend left' : 'left does not extend right';\r\n```"
      },
      {
        "user": "zpdDG4gta8XKpMCd",
        "created_at": "2019-04-02T17:13:40Z",
        "body": "that pesky distributivity again, ok, noted"
      }
    ]
  },
  {
    "number": 30643,
    "title": "How to get intellisense for already initialized Function Constructor ",
    "created_at": "2019-03-29T16:40:06Z",
    "closed_at": "2019-03-29T17:34:26Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/30643",
    "body": "Hi team,\r\nFirst, thanks for open sourcing this amazing compiler.\r\n\r\nWe are using (fully) customized internal javascript engine running in our cloud environment.\r\nWe have below pattern for all of our javascript ( nearly 5000 files).  \r\n\r\n```\r\n//@ts-check\r\n/**\r\n@type {FunctionConstructor}\r\n*/\r\nvar Point = createPlainFnType() // returns plain javascript function constructor after initializing  internal scopes, GC stuff and some internal c++ objects\r\n// function Point() {}  // This statement gives full intellisense and no errors but we can't use it.\r\nPoint.staticMethod = function() {\r\n}\r\nPoint.prototype.memberMethod = function() {\r\n}\r\n\r\nPoint.staticMethod(); // error here\r\nnew Point().memberMethod() // error here\r\n```\r\n Now the problem is, how do we get intellisense just like normal FunctionConstructor?. or at least is it possible by using out of the box typescript compiler?\r\n\r\nThanks",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/30643/comments",
    "author": "yln99517",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2019-03-29T17:19:12Z",
        "body": "We only support tacking on additional properties if the initializer was a function expression. I don't think it's possible for JS inference to handle this properly without allowing *all* arbitrary writes, which isn't something we want to do."
      },
      {
        "user": "yln99517",
        "created_at": "2019-03-29T17:34:26Z",
        "body": "Thank you @RyanCavanaugh."
      }
    ]
  },
  {
    "number": 30641,
    "title": "defaultProps in HOC when use React.ComponentType<M>",
    "created_at": "2019-03-29T07:59:37Z",
    "closed_at": "2019-07-13T00:00:45Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/30641",
    "body": "I have a problem of HOC .  when pass a component with a defaultProps to HOC, the props of component exposed to user become optional as the defaultProps is Partial. see example below\r\n\r\nthe property df1 and df2 is not optional after wrapper by HOC!\r\n\r\nbecause \r\n\r\n```js\r\nconst TabRCT = Tab as React.ComponentType<Props & WithProps>\r\ntype DpProps = typeof TabRCT.defaultProps\r\ntype DpProps1 = typeof Tab.defaultProps\r\n```\r\nDpProps is Partial<Props & WithProps> | undefined\r\nDpProps1 is DefaultTabProps\r\n\r\n\r\nthe complete example\r\n \r\n```js\r\nimport * as React from 'react'\r\n\r\ninterface DefaultTabProps {\r\n  df1: number,\r\n  df2: string\r\n}\r\n\r\ninterface Props extends DefaultTabProps {\r\n  pp1?: number\r\n  pp2: number\r\n}\r\n\r\ninterface WithProps {\r\n  wp: string\r\n}\r\n\r\ninterface InjectProps {\r\n  ij: number\r\n}\r\n\r\nclass Tab extends React.Component<Props & WithProps, any> {\r\n  static defaultProps: DefaultTabProps = {\r\n    df1: 11,\r\n    df2: '12'\r\n  }\r\n  render() {\r\n    return <div />\r\n  }\r\n}\r\n\r\n\r\ntype Merge<M, T> = Pick<M, Exclude<keyof M, keyof T>> & T\r\n\r\n\r\n// 希望M是处理后的 ，即最初M是Props，最后组件暴露出来的props是{...Props, ...DefaultProps }，而WithProps后暴露出来的还是Props，希望加上WithProps\r\nfunction WithTest<M>(Cp: React.ComponentType<M & WithProps>) {\r\n  return (props: Merge<M, typeof Cp.defaultProps> & InjectProps) => {\r\n    let params = omit(props, ['ij']) as M\r\n    let wp = (props.ij * 100) + '%'\r\n    return <Cp {...params} wp={wp}/>\r\n  }\r\n}\r\n\r\nconst TabWith = WithTest(Tab)\r\n\r\n\r\nfunction omit<T, K extends keyof T>(obj: T, keys: K[]) {\r\n  const newObj: { [key in keyof OmitType<T, K>]?: T[key] } = {}\r\n\r\n  return (Object.keys(obj) as (keyof OmitType<T, K>)[])\r\n    .filter((curr: any) => !keys.includes(curr))\r\n    .reduce((acc: { [key in keyof OmitType<T, K>]?: T[key] }, curr: (keyof OmitType<T, K>)) => (\r\n      acc[curr] = obj[curr],\r\n      acc\r\n    ), newObj)\r\n}\r\n \r\n\r\nconst obj = {\r\n  A: <TabWith ij={12} pp2={1} /> \r\n}\r\n\r\n```\r\n\r\n\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/30641/comments",
    "author": "luckhpy",
    "comments": [
      {
        "user": "dragomirtitian",
        "created_at": "2019-03-29T08:23:44Z",
        "body": "Might I suggest asking this sort of question on SO first. There is a dedicated comunity there just wating to help. GitHub is for bugs or questions that SO can't answer or need an official position (IMO)\r\n\r\nThere is no magic reason for the default props to be preserved in the wrapped component. The returned function does not have a defaultProps. If you want to preserve default props you need to add them to the returned function type. This will work as you expect it: \r\n\r\n```ts\r\nfunction WithTest<M, DF>(Cp: React.ComponentType<M & WithProps> & { defaultProps : DF}) : { // Explicit return annotation not required, just for clarity \r\n  (props: Merge<M, typeof Cp.defaultProps> & InjectProps) : JSX.Element\r\n  defaultProps : DF\r\n} {\r\n  function wrapped (props: Merge<M, typeof Cp.defaultProps> & InjectProps) {\r\n    let params = omit(props, ['ij']) as M\r\n    let wp = (props.ij * 100) + '%'\r\n    return <Cp {...params as any} wp={wp}/> // The conditional types that handle the defaults make this assertion necessary unfortunately \r\n  }\r\n  wrapped.defaultProps = Cp.defaultProps\r\n  return wrapped\r\n}\r\n```"
      },
      {
        "user": "luckhpy",
        "created_at": "2019-03-31T02:24:04Z",
        "body": "thank you very much! you've saved me a lot of time! and thank you for your kind remind and i will asking this sort of question in SO in the future"
      }
    ]
  },
  {
    "number": 30601,
    "title": "allow type morphing",
    "created_at": "2019-03-26T17:21:00Z",
    "closed_at": "2019-07-13T00:00:46Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/30601",
    "body": "considering a certain (better constrained generic) type in current TS, there is no easy way to:\r\n\r\n- add/replace/remove a property\r\n- add/replace/remove a parameter\r\n\r\nit makes it extremely hard to get the resulting types out of builders\r\n\r\n```ts\r\n// what is the type of result?\r\nconst result = building<A>().addProp<string>('x').replaceProp<number>('y').removeProp('z');\r\n```\r\n\r\nsure you can do:\r\n```ts\r\ntype Result = typeof result;\r\n```\r\n\r\nbut only if there are **no functions** and **no generics involved**\r\n\r\n```ts\r\nfunction make<X, Y>() {\r\n     const result = building<A>().addProp<X>('x').replaceProp<Y>('y').removeProp('z');\r\n     return result;\r\n}\r\ntype Result<X, Y> = typeof make<X, Y>; // <-- dang! now what?\r\n```\r\n\r\nwithout types you **cannot pass stuff around**, so the results of the builders are **not transferable**, so it limits the composability of the code and overall design of the application\r\n\r\nit's a super major headache with higher order components in React:\r\n\r\n-  they are easy to build, but very hard to type\r\n\r\n**so i wish there was something as convenient as builders, but for the _type domain_**\r\n\r\nplease consider these use cases:\r\n\r\n```ts\r\ninterface A {\r\n    x: number;\r\n    y: { z: string; };\r\n}\r\ntype B = /* some magic here */ A;\r\n```\r\n-------------------\r\n1. type `B` same as `A` but without property `y`\r\n```ts\r\ntype B = { x: number; };\r\n```\r\ncurrent answer: \r\n```ts\r\ntype B = Omit<A, 'y'>;\r\n```\r\n-------------------\r\n2. type `B` same as `A` but with property `x` of type `string`\r\n```ts\r\ntype B = { x: string; y: string; };\r\n```\r\ncurrent answer: \r\n```ts\r\ntype B = Omit<A, 'x'> | { x: string };\r\n```\r\n-------------------\r\n3. type `B` same as `A` but with property `y.z` removed:\r\n```ts\r\ntype B = { x: string; y: {}; };\r\n```\r\ncurrent answer: \r\n```ts\r\ntype B = Omit<A, 'y'> & { y: Omit<A['y'], 'z'> };\r\n```\r\n-------------------\r\n4. type `B` same as `A` but with property `y.z` of type `boolean`\r\n```ts\r\ntype B = { x: string; y: { z: boolean; }; };\r\n```\r\ncurrent answer\r\n```ts\r\ntype B = Omit<A, 'y'> & { y: Omit<A['y'], 'z'> & { z: boolean; }; };\r\n```\r\n-------------------\r\n... see where i am going?\r\n\r\nnow...\r\n```ts\r\ninterface A {\r\n    m(x: string, y: number): void;\r\n}\r\ntype B = /* some magic here */ A;\r\n```\r\n-------------------\r\n5. type `B` same as `A` but with first parameter removed\r\n```ts\r\ntype B = { m(y: number): void; };\r\n```\r\ncurrent answer\r\n```\r\n// NOT SURE IF IT IS DOABLE, SOME VERY UGLY CODE\r\n```\r\n-------------------\r\n6. type `B` same as `A` but with first parameter of type `boolean`\r\n```ts\r\ntype B = { m(x: boolean, y: number): void; };\r\n```\r\ncurrent answer\r\n```\r\n// SOME VERY UGLY CODE\r\n```\r\n-------------------\r\n7. type `B` same as `A` but with with extra parameter of type `boolean`\r\n```ts\r\ntype B = { m(x: string, y: number, z: boolean): void; };\r\n```\r\ncurrent answer\r\n```\r\n// NOT SURE IF IT IS DOABLE, IF IT IS IT WILL BE VERY UGLY\r\n```\r\n\r\n-------------------\r\n7. type `B` same as `A` but with with extra parameter of type `boolean` after 1st one\r\n```ts\r\ntype B = { m(x: string, z: boolean, y: number): void; };\r\n```\r\ncurrent answer\r\n```\r\n// NOT SURE IF IT IS DOABLE, IF IT IS IT WILL BE VERY UGLY\r\n```\r\n-------------------\r\n...etc",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/30601/comments",
    "author": "zpdDG4gta8XKpMCd",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2019-03-26T17:52:22Z",
        "body": "For properties\r\n```ts\r\ntype Omit<T, K> = Pick<T, Exclude<keyof T, K>>;\r\ntype Change<T, K, P> = { [S in keyof T]: S extends K ? P : T[S] };\r\n\r\ninterface A {\r\n    x: number;\r\n    y: { z: string; };\r\n}\r\ntype B1 = Omit<A, \"y\">;\r\nconst b1: B1 = { x: 10 };\r\n\r\ntype B2 = Change<A, \"y\", string>;\r\nconst b2: B2 = { x: 10, y: \"\" };\r\n\r\ntype B3 = Change<A, \"y\", Omit<A[\"y\"], \"z\">>;\r\nconst b3 = { x: \"\", y: {} };\r\n\r\ntype B4 = Change<A, \"y\", Change<A[\"y\"], \"z\", boolean>>;\r\nconst b4 = { x: \"\", y: { z: true } };\r\n```\r\n\r\nParameters work roughly the same but with tuples"
      },
      {
        "user": "zpdDG4gta8XKpMCd",
        "created_at": "2019-03-26T17:55:08Z",
        "body": "ok, i need to add `w: string, v: boolean` inside `x.y.z` and remove `u` from `x.y`\r\ni am not picking on you, it's a real problem, the solution you are suggesting is hideous when it is taken to the real life situations extent"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2019-03-26T18:02:50Z",
        "body": "I'm not sure what you're proposing, then. The primitives are there, and any highly complex operation expressed in terms of smaller primitives is going to look kind of ugly regardless of what order the operands go in. What kind of sugar would be understandable and also meaningfully better?"
      },
      {
        "user": "zpdDG4gta8XKpMCd",
        "created_at": "2019-03-26T18:11:48Z",
        "body": "i am not sure, but\r\n\r\n1. being able to get the type of a generic function result:\r\n```ts\r\nfunction make<X, Y, Z>(...) {}\r\ntype W = {}\r\ntype V = {}\r\ntype Result<T> = typeof make<T, W, V>;\r\n```\r\n\r\n2. some sort of first class support for this from this language:\r\n```\r\ntype B = remove A.x, remove A.y, add A.x: number, replace A.z: string, change: A.w: T => Promise<T>;\r\n```\r\n3. macros (to generate all this mess of primitive operations behind the scene)\r\n\r\n4. type functions/calculations:\r\n```\r\ntypefunction ToResult<X> {\r\n    type NoZ = Omit<X, 'z'>\r\n    type NoZX = Omit<NoZ, 'x'>;\r\n    type R = NoZX & { w: { t: sting; }; };\r\n    return R;\r\n}\r\ntype MyType<T> = ToResult<T>;\r\n```"
      },
      {
        "user": "krryan",
        "created_at": "2019-03-26T18:49:31Z",
        "body": "I agree that this is a problem. Particularly in the deeper cases, it’s pretty painful to omit or replace things. What to do about it, though, is less clear to me...\r\n\r\nI’d comment also that `Omit` isn’t very smart. We have at least one place in our code where we have, effectively,\r\n\r\n```ts\r\nfunction foobar<Foo extends { bar: string; }>(\r\n    fooBarless: Omit<Foo, 'bar'>,\r\n    bar: Foo['bar'],\r\n): Foo {\r\n    const foo = { ...fooBarless, bar };\r\n    return foo;\r\n}\r\n```\r\n\r\nand of course that doesn’t work. I have no idea if Aleksey’s proposal would allow something about that to be done or if it’s the same problem either way, but it seems like it might be related. I could imagine an interface being unable to make the same guarantees that this would."
      }
    ]
  },
  {
    "number": 30450,
    "title": "Language Service(?) is abbreviating types too aggressively",
    "created_at": "2019-03-17T15:09:56Z",
    "closed_at": "2019-07-13T00:00:50Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/30450",
    "body": "I have a project with some pretty complicated types - generics with function signatures as type parameters, themselves returning generic types of all sorts.  I've noticed in using 3.3.3333 with vscode 1.32.3 that my tooltips types are abbreviated in a new way with ellipses throughout.  I understand the intent but these abbreviations are too aggressive.  I'm trying to debug my types and I can't tell whether/where some of the nested type inferences are getting dropped (to `{}` or `any`, for example).\r\n\r\nI don't know how to repro this issue because it is specifically related to the size and complexity of the types involved.  Maybe others can contribute anecdotes of this happening with popular libraries?  Or maybe someone with knowledge of the code can call out the culprit more actionably.\r\n\r\nI guess that there's some algorithm that assigns weights to the various parts of the type tree and adds ellipses to keep the rendered length under some limit.  Is there a way to tinker with this limit as a user to allow me to see longer or even complete signatures, even if they're a mile long?  Or maybe there's a usability nuance that the weightings aren't accounting for.  All I know is that I'm unable to see the inferred types that I need to see to debug my types.",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/30450/comments",
    "author": "JasonKleban",
    "comments": [
      {
        "user": "ajafff",
        "created_at": "2019-03-17T16:40:03Z",
        "body": "You can try the `noErrorTruncation` compiler option. Despite the name it seems to also work for quickinfo.\r\n\r\nThere's a proposal (here or in the VSCode repo) to make quickinfo tooltips interactive, so you can click on the ellipsis to expand it. Unfortunately I cannot find it right now."
      },
      {
        "user": "AnyhowStep",
        "created_at": "2019-03-17T19:56:24Z",
        "body": "`noErrorTruncation` doesn't help. It'll still show the ellipsis."
      },
      {
        "user": "weswigham",
        "created_at": "2019-03-18T05:45:33Z",
        "body": "The `...` is also used for reverse mapped types where we used to incorrectly print `any` (we actually still have strong types for the thing all the way down, the structure just expands potentially forever)."
      }
    ]
  },
  {
    "number": 30296,
    "title": "API: how to get TypeParameters of inferred higher order function",
    "created_at": "2019-03-09T16:56:25Z",
    "closed_at": "2019-05-24T20:31:14Z",
    "labels": [
      "Question",
      "API"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/30296",
    "body": "<!-- Please try to reproduce the issue with `typescript@next`. It may have already been fixed. -->\r\n**TypeScript Version:**  3.4.0-dev.20190309\r\n\r\n**Code**\r\n\r\n```ts\r\n// from #30215\r\ndeclare function pipe<A extends any[], B, C>(ab: (...args: A) => B, bc: (b: B) => C): (...args: A) => C;\r\n\r\ndeclare function list<T>(a: T): T[];\r\ndeclare function box<V>(x: V): { value: V };\r\n\r\nconst listBox = pipe(list, box);  // <T>(a: T) => { value: T[] }\r\n\r\nlistBox(1); // <-- want to get TypeParameters here\r\n```\r\n\r\nGiven a CallExpression, I want to get all type parameters of the resolved signature.\r\nBefore higher order function type inference, I could simply use `ts.getEffectiveTypeParameterDeclarations(checker.getResolvedSignature(node).declaration)`.\r\n\r\nThis doesn't work in the example above, because `signature.declaration` is `(...args: A) => C` which obviously has no declared type parameters.\r\n\r\nI noticed there's `signature.typeParameters`, but that seems to always be `undefined` on instantiated signatures.\r\nUsing the debugger I could see that `signature.target.typeParameters` contains what I need, but `target` is internal.\r\n\r\nCurrently I'm trying to work around this by getting the type of `listBox` first and using the uninstantiated signature iff there's only one call signature. Otherwise I fall back to my previous solution because inferred higher order functions currently only work with a single call signature.\r\nIs that the recommended way to solve my problem?",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/30296/comments",
    "author": "ajafff",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2019-03-19T18:04:00Z",
        "body": "Doesn't look like there's a way to do it with the available public API. To really get the right answer you'd also need the `.mapper` and then instantiate the type with the provided the mapper.\r\n\r\nMore details on your use case would be useful if you'd like to see changes in the public API to accommodate some scenario."
      }
    ]
  },
  {
    "number": 30293,
    "title": "Index Signatures break Mapped type key picking.",
    "created_at": "2019-03-09T16:05:37Z",
    "closed_at": "2019-07-13T00:00:53Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/30293",
    "body": "***Update***:  Please see the second comment, titled \"**simple repro**\" \r\n\r\n\r\n***Summary***\r\n\r\nI'm trying to create type definitions for a mixin object.  when doing so I found the following error if one of the mixed types has an index signature.\r\n\r\nremoving the index signature \"fixes\" the problem.\r\n\r\n\r\n**TypeScript Version:**  3.3.3333\r\n\r\n**Code**\r\n\r\n```ts\r\n/** helper that returns prop names except those to filter.  This helper type is needed to actually remove the prop, as otherwise the prop still exists in the type just as \"never\".  */\r\ntype PropsRemove_Name<TTarget, TPropToRemove> = { [ K in keyof TTarget ]: TTarget[ K ] extends TPropToRemove ? never : K }[ keyof TTarget ];\r\n/** remove props of the given type.   always removes ```never``` type props.  if no ```TPropToRemove``` is provided, removes just ```never``` type props. */\r\ntype PropsRemove<TTarget,TPropToRemove=never> = Pick<TTarget, PropsRemove_Name<TTarget,TPropToRemove>>;\r\n\r\n/** type used to demonstrate the bug */\r\ntype TestType = {\r\n\ta: number;\r\n} & {\t\r\n\tb: boolean;\r\n\t[ key: string ]: boolean; //THE OFFENDING LINE\r\n}\r\n\r\nlet testRemoval: PropsRemove<TestType,number>;\r\n\r\n\r\n```\r\n\r\n**Expected behavior:**\r\n```ts\r\n//expect typescript to provide the proper definition. \r\ntestRemoval.b; //boolean\r\n```\r\n**Actual behavior:**\r\n```ts\r\n//with the index signature, typescript provides no properties in the dropdown\r\ntestRemoval; //no properties\r\n\r\n//when the index signature is removed, typescript provides the proper definition. \r\ntestRemoval.b; //boolean\r\n```\r\n\r\n**Related Issues:** didn't really see any :(\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/30293/comments",
    "author": "jasonswearingen",
    "comments": [
      {
        "user": "jasonswearingen",
        "created_at": "2019-03-09T17:26:00Z",
        "body": "## simple repro:\r\n\r\n```ts\r\n\r\n/** type used to demonstrate the bug */\r\ntype TestType ={\r\n\tb: boolean;\r\n\t[ key: string ]: boolean;\r\n}\r\n\r\nlet testSimple: Pick<TestType, keyof TestType>;\r\ntestSimple; //no properties in vscode intellisense dropdown, nor available in type propagation (unioning, etc).  comment the index signature to get properties.\r\n"
      },
      {
        "user": "jack-williams",
        "created_at": "2019-03-10T19:07:40Z",
        "body": "This is related to: #17867"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2019-03-19T16:56:19Z",
        "body": "`keyof TestType` is `string | number`\r\n\r\n`Pick<TestType, string | number>` is `{ [k: string]: boolean }`\r\n\r\nI think both of those are fairly inarguable given the definition of both operations. `Pick<T, keyof T>` is not guaranteed to produce `T` for this reason."
      },
      {
        "user": "jasonswearingen",
        "created_at": "2019-06-29T00:16:22Z",
        "body": "sorry @RyanCavanaugh, not following you, I don't spend enough time with type definitions I guess :/\r\n\r\nMaybe my \"simple\" repro muddys the issue.   I want to do as shown in the initial post:  remove a property, but can not when an index signature is in the type."
      }
    ]
  },
  {
    "number": 30202,
    "title": "Get type of variable over the course of lifetime from TypeChecker",
    "created_at": "2019-03-03T15:17:29Z",
    "closed_at": "2019-07-13T00:00:56Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/30202",
    "body": "Calling `getTypeAtLocation().getFlags()` on  the identifier `b` at its declaration in the following example returns `ts.TypeFlags.Number` however the type (to me) should be `ts.TypeFlags.Number` or `ts.TypeFlags.Any` since it is later reassigned to a variable of unknown type.\r\n\r\n```\r\nfunction a(c) { // c is implicit any\r\n  let b = 1; // getTypeAtLocation(b).getFlags() is ts.TypeFlags.Number\r\n  b = c; // getTypeAtLocation(b = c).getFlags() is no longer ts.TypeFlags.Number\r\n}\r\n```\r\n\r\nIs it possible to get this information at the declaration of `b` or do I need to accumulate this type information myself?",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/30202/comments",
    "author": "eatonphil",
    "comments": [
      {
        "user": "DanielRosenwasser",
        "created_at": "2019-03-04T03:04:08Z",
        "body": "I'm not totally clear on the intent but if you're asking about the type of `b = c`, that's because the `=` operator always returns the right-hand side."
      },
      {
        "user": "eatonphil",
        "created_at": "2019-03-04T13:25:22Z",
        "body": "I'm going to change the example slightly but the intent is still the same. The inferred type of `b` in this example should be `number | string` (or `any`, I guess):\r\n\r\n```javascript\r\nfunction a(c: string) {\r\n  let b = 1;\r\n  b = c;\r\n}\r\n```\r\n\r\nBecause the following would be right:\r\n\r\n```javascript\r\nfunction a(c: string) {\r\n  let b: number | string = 1;\r\n  b = c;\r\n}\r\n```\r\n\r\nAnd the following would be wrong:\r\n\r\n```javascript\r\nfunction a(c: string) {\r\n  let b: number = 1;\r\n  b = c;\r\n}\r\n```\r\n\r\nBut whether I explicitly annotate the type of `b` as `b: string | number` at the declaration or not, I cannot seem to get that information from the TypeChecker via `getTypeAtLocation()`. Around the declaration of `b`, all the nodes just seem to be ts.TypeFlags.Number.\r\n\r\nDoes that make sense?"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2019-03-04T17:35:11Z",
        "body": "There isn't an API that's going to give you answer you want there, because TypeScript's inference algorithm doesn't work like that. You'd have to accumulate the RHSes of all assignments yourself to get the `number | string` result."
      },
      {
        "user": "eatonphil",
        "created_at": "2019-03-04T17:42:28Z",
        "body": "Got it, thank you!"
      }
    ]
  },
  {
    "number": 30189,
    "title": "Why getCombinedModifierFlags() requires Declaration instead of just Node",
    "created_at": "2019-03-02T14:27:58Z",
    "closed_at": "2019-07-13T00:00:57Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/30189",
    "body": "\r\nHello.\r\n\r\nI noticed, that `getCombinedModifierFlags(node: Declaration)` can perfectly work with just `node: Node`. Why it requires `Declaration` instead?\r\n\r\nAs per use case, I'm building a small code generator which analyses some interface definitions and generates boilerplate code and I'd like to check whether definition is exported or not. ",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/30189/comments",
    "author": "eldargab",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2019-03-05T00:21:02Z",
        "body": "My reading is that this function only makes sense on declarations - only declarations are affected by their outer declarations' modifiers in the first place."
      }
    ]
  },
  {
    "number": 30143,
    "title": "Compiler hangs with no output - how to debug?",
    "created_at": "2019-02-28T09:26:45Z",
    "closed_at": "2019-03-06T13:17:39Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/30143",
    "body": "**TypeScript Version:**  3.4.0-dev.20190228\r\n\r\nI have a project that contains references to sub-projects. For some reason, the compiler hangs with no output, and finally crashes with FATAL ERROR: CALL_AND_RETRY_LAST Allocation failed - JavaScript heap out of memory.\r\n\r\nI haven't been able to isolate the problem. It is somehow related to importing monocle-ts in sub-project, but it seems very random.\r\n\r\nMy question is: is there a way to find out what causes the compiler to crash? Can I enable debug output in tsc, or something else?\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/30143/comments",
    "author": "lvanhala",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2019-02-28T17:37:57Z",
        "body": "There isn't meaningful debug output generated during phases which typically cause these kinds of crashes.\r\n\r\nThe best thing to do is to run `node --inspect tsc.js [your commandline]`, attach a debugger, wait until you think it's close to crashing, then break the debugger and capture the call stack along with values of relevant locals. Usually there will be a `node` somewhere in the stack trace that will point you to which line of source is the root cause."
      }
    ]
  },
  {
    "number": 30127,
    "title": "Is it possible to define a universal default generic type parameter so that a bottom object like `new None()`, can type check any type of None, such as None<number>, None< ()=>any >?",
    "created_at": "2019-02-27T14:33:11Z",
    "closed_at": "2019-07-13T00:01:00Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/30127",
    "body": "**In short, TypeScripts uses type {} for default generic type parameter, when T is not provided for `new ClassA<T>(...)`** so Applicative data structure would require developers more concious with types, which is a barrier for more advanced data structure.\r\n\r\nIs it possible to define an universal default generic type so that a bottom datastructure like `new None()`, can type check any type of None, such as `None<number>`, `None< ()=>any >`?\r\n\r\n**Details:**\r\n\r\nI was trying to implement an Applicative data structure in TS as the Applicative of Haskell:\r\n\r\n```\r\n(Some f) <*> (Some x) = Some (f x)\r\n(None) <*>(Some x) = None\r\n```\r\n\r\nFirst try is to implement functor/applicative  on Option and subclass Some and None.\r\nBelow is the type and class definition:\r\n\r\n\r\n```\r\nexport const id = (a: any) => a\r\n\r\nexport interface Functor<T> {\r\n  fmap(f: (a: T) => any): Functor<any>\r\n}\r\n\r\nexport interface Applicative<T> extends Functor<T> {\r\n  ffmap(af: Applicative<(a: T) => any>): Applicative<any>\r\n}\r\n\r\nexport abstract class Option<T> implements Functor<T> {\r\n  abstract _a: T | undefined\r\n\r\n  abstract fmap(f: (a: T) => any): Functor<any>\r\n\r\n  *[Symbol.iterator]() {\r\n    yield this._a\r\n  }\r\n}\r\n\r\nexport class Some<T> extends Option<T> {\r\n  _a: T\r\n\r\n  constructor(a: T) {\r\n    super()\r\n    this._a = a\r\n  }\r\n\r\n  fmap(f: (a: T) => any): Option<any> {\r\n    return new Some(f(this._a))\r\n  }\r\n\r\n  ffmap(a: Option<(a: T) => any>): Option<any> {\r\n    if (a instanceof None) return new None()\r\n\r\n    const f = a._a\r\n\r\n    if (f === undefined || f === null) return new None()\r\n    else return new Some(f!(this._a))\r\n  }\r\n}\r\n\r\nexport class None<T> extends Option<T> {\r\n  _a: T | undefined\r\n  constructor() {\r\n    super()\r\n    this._a = undefined\r\n  }\r\n\r\n  fmap(f: (a: T) => any): Option<any> {\r\n    return new None()\r\n  }\r\n\r\n  ffmap(a: Option<(a: T) => any>): Option<any> {\r\n    return new None()\r\n  }\r\n}\r\n\r\n```\r\nI have written some test cases and most work. However when test the case :\r\n\r\n```\r\n  test(' Some.ffmap(None) === None', () => {\r\n    const a = new Some(33)\r\n\r\n    const af = new None()\r\n\r\n    expect(a.ffmap(af)).toEqual(new None())\r\n  })\r\n```\r\n\r\nFollowing error is reported:\r\n```\r\n    src/index.test.ts:116:20 - error TS2345: Argument of type 'None<{}>' is not assignable to parameter of type 'Option<(a: number) => any>'.\r\n      Types of property '_a' are incompatible.\r\n        Type '{} | undefined' is not assignable to type '((a: number) => any) | undefined'.\r\n          Type '{}' is not assignable to type '(a: number) => any'.\r\n            Type '{}' provides no match for the signature '(a: number): any'.\r\n\r\n    116     expect(a.ffmap(af)).toEqual(new None())\r\n```\r\n\r\nSpcifically, TS consider new None() has the type of new None<{}>(), which is no match with applicative parameter, new None< ()=>any>()\r\n\r\nWhen I change the test case to the following, it works:\r\n\r\n```\r\n  test(' Some.fmap(None) = None', () => {\r\n    const a = new None<number>()\r\n\r\n    const f = (a: number) => a + 2\r\n\r\n    expect(a.fmap(f)).toEqual(a)\r\n  })\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/30127/comments",
    "author": "reactma",
    "comments": [
      {
        "user": "jack-williams",
        "created_at": "2019-02-27T14:39:57Z",
        "body": "Did you try:\r\n```ts\r\nexport class None extends Option<never> {\r\n    …\r\n}\r\n```"
      },
      {
        "user": "j-oliveras",
        "created_at": "2019-02-27T14:42:07Z",
        "body": "You can defined a default type parameter as:\r\n```ts\r\n// Change any with the type you want to be the default.\r\nexport interface Functor<T = any> {\r\n  fmap(f: (a: T) => any): Functor<any>\r\n}\r\n```"
      },
      {
        "user": "reactma",
        "created_at": "2019-02-27T14:47:33Z",
        "body": "@jack-williams It doesn't work for my case as I need a type parameter.\r\n@j-oliveras Your solution type checks. I didn't know generic type parameter could have default type as well. Thanks."
      }
    ]
  },
  {
    "number": 30116,
    "title": "The type definition read by ts does not match the types",
    "created_at": "2019-02-27T04:00:16Z",
    "closed_at": "2019-03-01T18:21:01Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/30116",
    "body": "My code\r\n\r\n```ts\r\nexport default function (name: string, defaultValue = {}, adapter = 'memory', extractSetStateFunc: Function) {\r\n  const Context = React.createContext(name);\r\n  const { Provider } = Context;\r\n\r\n  class ContextHoc extends React.Component {\r\n    constructor(props: any) {\r\n      super(props);\r\n\r\n      if (!adapters[adapter]) {\r\n        throw new Error(`KV Store:\\n Uncaught ReferenceError: ${adapter} Adapter is not defined.`);\r\n      }\r\n\r\n      this.state = {\r\n        ...defaultValue,\r\n        ...adapters[adapter].get(name),\r\n      };\r\n\r\n      extractSetStateFunc(name, (store: any, callback: Function) => {\r\n        this.setState(store, () => {\r\n          adapters[adapter].set(name, this.state);\r\n          if (typeof callback === 'function') {\r\n            callback();\r\n          }\r\n        });\r\n      });\r\n    }\r\n\r\n    render() {\r\n      return (\r\n        <Provider value={this.state}>\r\n          { this.props.children }\r\n        </Provider>\r\n      );\r\n    }\r\n  }\r\n\r\n  class Factory {\r\n    get ctx() {\r\n      return Context;\r\n    }\r\n\r\n    get component() {\r\n      return ContextHoc;\r\n    }\r\n  }\r\n\r\n  return new Factory();\r\n}\r\n```\r\n\r\nBut i get a error: Can't assign type \"ReadOnly<{}>\" to type \"string\" of .ts (2322) \r\nfor this line:\r\n```ts\r\n<Provider value={this.state}>\r\n```\r\n\r\nConfusingly, when I looked at @types/react, I found that the definition of ProviderProps is generic:\r\n\r\nProviderProps<T>{ value: T }\r\ninstead of ProviderProps<string>{ value: string }",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/30116/comments",
    "author": "NanWu5522",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2019-02-27T20:21:40Z",
        "body": "You created a context with default value `name` (a string), then tried to provide a different value via the `Provider` with something that wasn't a string."
      },
      {
        "user": "NanWu5522",
        "created_at": "2019-03-01T09:56:57Z",
        "body": "> You created a context with default value `name` (a string), then tried to provide a different value via the `Provider` with something that wasn't a string.\r\n\r\nThank you for your answer, I have solved this problem."
      }
    ]
  },
  {
    "number": 29986,
    "title": "allow class fields overload",
    "created_at": "2019-02-20T03:33:30Z",
    "closed_at": "2019-07-13T00:01:02Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/29986",
    "body": "This is what we can do in current ts version:\r\n\r\n```ts\r\nclass Foo {\r\n    public bar(a: number): void;\r\n    public bar(a: string, b: number, c: boolean): void;\r\n\r\n    public bar(a, b?, c?) {\r\n        console.log(this);\r\n        console.log(a, b, c);\r\n    }\r\n}\r\n```\r\n\r\nHowever, we want to use arrow functions to avoid `this` problem, so we have to write some code like this:\r\n\r\n```ts\r\nclass Foo {\r\n    public bar: (a: number) => void;\r\n    public bar: (a: string, b: number, c: boolean) => void;\r\n\r\n    public bar = (a, b?, c?) => {\r\n        console.log(this);\r\n        console.log(a, b, c);\r\n    }\r\n}\r\n```\r\n\r\nBut currently typescript don't allow us to do that, so I hope typescript can overload class fields (arrow functions) in the future.",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/29986/comments",
    "author": "hronro",
    "comments": [
      {
        "user": "dragomirtitian",
        "created_at": "2019-02-20T06:10:33Z",
        "body": "Thre isn't dedicated syntax for this, but you can easily declare a function field with overloads, and the syntax is not overly verbose IMO:\r\n\r\n```ts\r\nclass Foo {\r\n    public bar: {\r\n        (a: number): void;\r\n        (a: string, b: number, c: boolean): void;\r\n    } = (a: number | string, b?: number, c?: boolean) => {\r\n        console.log(this);\r\n        console.log(a, b, c);\r\n    }\r\n}\r\n```"
      }
    ]
  },
  {
    "number": 29934,
    "title": "Ask a question",
    "created_at": "2019-02-15T15:32:21Z",
    "closed_at": "2019-02-15T17:45:06Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/29934",
    "body": "Because my language organization ability is limited, so I directly give a piece of code\r\n\r\n\r\n```typescript\r\n\r\n    type Action = { payload: { name: string }; meta?: { loading?: boolean } };\r\n\r\n    const onChangeName = function(state: IState, action: Action) {\r\n      return { ...state, ...action.payload };\r\n    };\r\n\r\n    type FnType = typeof onChangeName;\r\n\r\n    type ParamType = Parameters<FnType>[1];\r\n\r\n    type DY = (args: Pick<ParamType, \"payload\" | \"meta\">) => void;\r\n\r\n    let s: DY;\r\n\r\n    // actual results\r\n    s({ payload: { name: \"张三\" } });\r\n\r\n\r\n    // what should I do to improve the result I hope\r\n    s( {name:\"张三\"} , { loading:true} )\r\n\r\n```",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/29934/comments",
    "author": "ityuany",
    "comments": [
      {
        "user": "nmain",
        "created_at": "2019-02-15T15:57:58Z",
        "body": "I'm not sure if I fully understood your example, but the following type declaration will behave the way you want it to:\r\n\r\n```ts\r\ntype Example = (payload: ParamType[\"payload\"], meta: ParamType[\"meta\"]) => void;\r\n\r\nlet e: Example;\r\n\r\ne({ name: \"张三\" }, { loading: true });\r\n```\r\n"
      },
      {
        "user": "ityuany",
        "created_at": "2019-02-15T15:59:47Z",
        "body": "@nmain  \r\nMeta may or may not be an optional type. This is an indeterminate message, including payload"
      },
      {
        "user": "nmain",
        "created_at": "2019-02-15T16:01:28Z",
        "body": "Should be easy to fix that:\r\n\r\n```ts\r\ntype Example = (payload: ParamType[\"payload\"], meta?: ParamType[\"meta\"]) => void;\r\n```\r\n"
      },
      {
        "user": "ityuany",
        "created_at": "2019-02-15T16:01:51Z",
        "body": "@nmain \r\n\r\n```typescript\r\n\r\n/**\r\n     * Part of the input from the user (the parameter list has certain deformation, mainly including payload and meta)\r\n     */\r\n    type Action = { payload: { name: string }; meta: { loading?: boolean } };\r\n\r\n    const onChangeName = function(state: IState, action: Action) {\r\n      return { ...state, ...action.payload };\r\n    };\r\n\r\n\r\n    /**\r\n     * What you want the framework to accomplish with ts\r\n     */\r\n    type FnType = typeof onChangeName;\r\n\r\n    type ParamType = Parameters<FnType>[1];\r\n\r\n    type i = Pick<ParamType, \"payload\" | \"meta\">\r\n\r\n\r\n\r\n    type DY = (...args:  [ i[\"payload\"] , i[\"meta\"] ? ]) => void;\r\n\r\n    let s: DY;\r\n\r\n    // result\r\n\r\n    // actual results\r\n    s({ payload: { name: \"张三\" } });\r\n\r\n\r\n    // what should I do to improve the result I hope\r\n    s( {name:\"张三\"}  )\r\n\r\n```"
      },
      {
        "user": "ityuany",
        "created_at": "2019-02-15T16:03:14Z",
        "body": "@nmain  I wonder if you can understand what I mean"
      },
      {
        "user": "ityuany",
        "created_at": "2019-02-15T16:15:27Z",
        "body": "@nmain \r\n```typescript\r\n //or\r\n    type Action1 = { payload: { name: string }; meta: { loading?: boolean } };\r\n\r\n    //or\r\n    type Action2 = { payload: { name: string }; meta?: { loading: boolean } };\r\n\r\n    //or\r\n    type Action3 = { payload: { name?: string }; meta: { loading: boolean } };\r\n\r\n    //or\r\n    type Action4 = { payload: { name?: string }; meta: { loading?: boolean } };\r\n\r\n```"
      },
      {
        "user": "nmain",
        "created_at": "2019-02-15T16:30:20Z",
        "body": "I suspect you want something that you can generalize easily?\r\n\r\n```ts\r\ntype ActionWithMeta<P, M> = { payload: P, meta: M };\r\ntype ActionWithOptionalMeta<P, M> = { payload: P, meta?: M };\r\ntype Action<P, M> = ActionWithMeta<P, M> | ActionWithOptionalMeta<P, M>;\r\n\r\ntype FuncType<T> =\r\n  T extends ActionWithMeta<infer P, infer M> ? (payload: T[\"payload\"], meta: T[\"meta\"]) => void :\r\n  T extends ActionWithOptionalMeta<infer P, infer M> ? (payload: T[\"payload\"], meta?: T[\"meta\"]) => void :\r\n  never;\r\n\r\ndeclare var f1: FuncType<{ payload: { name: string }; meta: { loading?: boolean } }>\r\nf1({ name: \"foo\" }, { loading: false });\r\n\r\ndeclare var f2: FuncType<{ payload: { name: string }; meta?: { loading?: boolean } }>\r\nf2({ name: \"foo\" });\r\n```"
      }
    ]
  },
  {
    "number": 29911,
    "title": "transpileModule cannot transform JSON properly",
    "created_at": "2019-02-14T08:26:59Z",
    "closed_at": "2019-07-13T00:01:03Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/29911",
    "body": "**TypeScript Version:**  `3.4.0-dev.20190214`\r\n\r\n**Search Terms:** transpileModule JSON\r\n\r\n**Code**\r\n\r\n```ts\r\nimport {\r\n  transpileModule,\r\n  ScriptTarget,\r\n  ModuleKind,\r\n  TransformationContext,\r\n  SourceFile,\r\n  visitEachChild,\r\n  isStringLiteral,\r\n  VisitResult,\r\n  Node,\r\n  createStringLiteral\r\n} from \"typescript\";\r\n\r\nconst transpileOutput = transpileModule(`{ \"hello\": \"world\" }`, {\r\n  compilerOptions: {\r\n    target: ScriptTarget.JSON,\r\n    module: ModuleKind.None,\r\n    removeComments: true\r\n  },\r\n  transformers: {\r\n    after: [\r\n      (ctx: TransformationContext) => {\r\n        return (sourceFile: SourceFile) => {\r\n          function visitor(node: Node): VisitResult<Node> {\r\n            if (isStringLiteral(node)) {\r\n              if (node.text === \"world\") {\r\n                return createStringLiteral(\"JSON!\");\r\n              }\r\n              return node;\r\n            }\r\n            return visitEachChild(node, visitor, ctx);\r\n          }\r\n\r\n          const sourceFile2 = visitEachChild(sourceFile, visitor, ctx);\r\n\r\n          return sourceFile2;\r\n        };\r\n      }\r\n    ]\r\n  }\r\n});\r\n\r\nconsole.log(transpileOutput.outputText);\r\n```\r\n\r\n**Expected behavior:**\r\n\r\n```json\r\n{ \"hello\": \"JSON!\" }\r\n```\r\n\r\n**Actual behavior:**\r\n\r\n```js\r\n({ \"hello\": \"JSON!\" })\r\n```\r\n\r\n**Workaround:**\r\n\r\nI've tracked this issue down to the fact that TypeScript internally wraps the `ObjectLiteralExpression` with a `ParenthesizedExpression` even though it produces illegal JSON in the end.\r\n\r\nI use the TypeScript compiler to process JSON because it can strip comments and I'm familiar with its interface. It struck me as a surprise that it would NOT allow me to use custom transformers without going through additional steps.\r\n\r\nI currently use this utility function to *fix* the problem but I don't think TypeScript should make me **have** do this.\r\n\r\nI could have missed something here but I spent a good chunk of time analysing the problem and this was the only way I could make it work for me in the end.\r\n\r\n```ts\r\nfunction deParenthesize(sourceFile: SourceFile) {\r\n  const statements = sourceFile.statements\r\n  if (statements.length === 1) {\r\n    const statement = statements[0]\r\n    if (isExpressionStatement(statement)) {\r\n      const expression = statement.expression\r\n      if (isParenthesizedExpression(expression)) {\r\n        // we cannot use the \"createExpressionStatement\" helper\r\n        // it would just reintroduce the ParenthesizedExpression\r\n\r\n        const replacement = createNode(\r\n          SyntaxKind.ExpressionStatement,\r\n          -1,\r\n          -1\r\n        ) as ExpressionStatement\r\n        replacement.flags |= NodeFlags.Synthesized\r\n        replacement.expression = expression.expression\r\n\r\n        sourceFile.statements = createNodeArray([replacement])\r\n      }\r\n    }\r\n  }\r\n}\r\n```\r\nAdditionally, if I include `fileName: \"module.json\"` in the transpilation options, I get, `Error: Debug Failure. Output generation failed` and this wasn't the case before. This behavior changed between TypeScript 3.1 and 3.3 but I'm not sure of which version exactly.\r\n\r\nIf I dump the `sourceFile.languageVersion` it will show up as `ES2015` despite using the `compilerOptions` `target: ScriptTarget.JSON`.",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/29911/comments",
    "author": "leidegre",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2019-02-14T21:06:36Z",
        "body": "`target: ScriptTarget.JSON` is not a valid value (you can't specify this in a tsconfig file or on the commandline); emitting to JSON files isn't a supported scenario."
      },
      {
        "user": "leidegre",
        "created_at": "2019-02-14T21:37:31Z",
        "body": "@RyanCavanaugh it would be good to know if there was some manner in which I could depend on TypeScript for JSON processing. I don't fully understand why the `ScriptTarget.JSON` exist if it cannot be used. I would also probably have wished for a more meaningful error message.\r\n\r\nI know you guys are super busy but any kind of insight would be greatly appreciated.\r\n\r\n\r\n"
      }
    ]
  },
  {
    "number": 29848,
    "title": "[Compiler API] transform import when module is set to commonjs",
    "created_at": "2019-02-11T01:42:46Z",
    "closed_at": "2019-02-19T20:29:10Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/29848",
    "body": "Hi there,\r\n\r\nI'm writing a TS transformer that inline some `import` depending on certain file type. For example:\r\n\r\n```\r\nimport {foo, bar} from 'static-file'\r\nconst baz = foo + bar\r\n// Transform into\r\nconst foo = 1, bar = 2\r\nconst baz = foo + bar\r\n```\r\n\r\nWhen I set `tsconfig`'s module to `ESNext`, the example above works. However, when the `module` config is `CommonJS`, import `namedBindings` seem to get aliased.\r\n\r\n```\r\nimport {foo, bar} from 'static-file'\r\nconst baz = foo + bar\r\n// Transform into\r\nconst foo = 1, bar = 2\r\nconst baz = static_file_1.foo + static_file_1.bar\r\n```\r\n\r\nI'd love to learn more about the context of why it behaves that way and potentially how to solve my issue.\r\n\r\nThank you so much!\r\n\r\nLH",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/29848/comments",
    "author": "longlho",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2019-02-19T17:32:26Z",
        "body": "ES6 module bindings are \"live\" - they always observe the value of the property as it exists in the imported module, not just grab the value once at file startup time and then not change again."
      },
      {
        "user": "longlho",
        "created_at": "2019-02-19T20:29:10Z",
        "body": "gotcha thanks!"
      }
    ]
  },
  {
    "number": 29525,
    "title": "Typing specification on compile",
    "created_at": "2019-01-22T10:17:11Z",
    "closed_at": "2019-01-23T18:23:00Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/29525",
    "body": "",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/29525/comments",
    "author": "dorin182",
    "comments": [
      {
        "user": "DanielRosenwasser",
        "created_at": "2019-01-23T05:14:16Z",
        "body": "This is not a self-contained repro of the issue. What are you calling this on?"
      }
    ]
  },
  {
    "number": 29436,
    "title": "Doc bug in function section.",
    "created_at": "2019-01-16T00:33:17Z",
    "closed_at": "2019-02-14T18:38:44Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/29436",
    "body": "In the docs, it says\r\n\r\n> In playing with the example, you may notice that the TypeScript compiler can figure out the type if you have types on one side of the equation **but not the other**:\r\n> ```\r\n> // myAdd has the full function type\r\n> let myAdd = function(x: number, y: number): number { return  x + y; };\r\n> \r\n> // The parameters 'x' and 'y' have the type number\r\n> let myAdd: (baseValue: number, increment: number) => number =\r\n>     function(x, y) { return x + y; };\r\n> \r\n> ```\r\n\r\nIt seems to me that *\"not the other\"* is incorrect. I think what is meant to be said is *\"not both\"*. It seems from the documentation that typescript can infer the type of `myAdd` from the function, or infer the type of the arguments in the function from the type of `myAdd`, but not infer the types of `x` and `y` in isolation of any type declaration.\r\n\r\nIt may be worth mentioning the reason here too: why it can't infer the types of both -- presumably because the `+` operator is polymorphic.",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/29436/comments",
    "author": "EvanCarroll",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2019-01-16T17:52:36Z",
        "body": "If types are present on both sides, then there's nothing left to figure out.\r\n\r\nIt's like saying in a room full of a dozen people, I can figure out the last name if given a first name, or the first name if given a last name, ... but not both? It's not even clear what that means."
      },
      {
        "user": "EvanCarroll",
        "created_at": "2019-01-16T18:20:51Z",
        "body": "Interesting and compelling example. Perhaps that's the oversight -- I don't read \"but not the other\" to mean that TypeScript just accepts explicit typing on both sides. For me the wording is just awkward and causes confusion. Consider,\r\n\r\n> It's like saying in a room full of a dozen people, I can figure out the name if you provide the first name, or last name **but not the other**.\r\n\r\nThat's how I read it currently. Perhaps though we could skirt the whole issue by rewording entirely,\r\n\r\n> In playing with the example, you may notice that the TypeScript compiler can figure out the types absent from either side, with the types present on the other."
      },
      {
        "user": "fatcerberus",
        "created_at": "2019-01-17T02:36:03Z",
        "body": "This is a pretty common turn of phrase, I thought.  \"There's something on side of the fence, but not the other\".  The general meaning is that there are two pigeonholes, but only one has something in it--without specifying which one that is (because it's not relevant)."
      },
      {
        "user": "fatcerberus",
        "created_at": "2019-01-17T02:38:20Z",
        "body": "I'll agree the wording in this case is awkward, though.  This would probably be clearer:\r\n> In playing with the example, you may notice that the TypeScript compiler can figure out the type **even if you only have types on one side of the equation:**"
      }
    ]
  },
  {
    "number": 29411,
    "title": "Function return value types not inferred in some cases",
    "created_at": "2019-01-14T20:52:32Z",
    "closed_at": "2019-01-15T17:54:18Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/29411",
    "body": "**TypeScript Version:**  3.3.0-dev.20190112\r\n\r\n**Search Terms:** function return type\r\n\r\n**Code**\r\n See code below which has a function returning a Promise<HelloInterface | undefined>\r\nThe calling code only infers the type to be HelloInterface.\r\n\r\n```ts\r\nclass Example1 {\r\n  public testFunction1(): void {\r\n    this.getResponse().then((value: HelloInterface) => {  // Expected tsc to infer this to be value: HelloInterface | undefined \r\n\r\n      console.log(value.property1);  // Potential runtime error as value can be undefined.\r\n    });\r\n  }\r\n\r\n  private getResponse(): Promise<HelloInterface | undefined> {\r\n    return Promise.resolve({ \"property1\": \"value1\" });\r\n  }\r\n}\r\n\r\ninterface HelloInterface {\r\n  \"property1\": string;\r\n}\r\n\r\n```\r\n\r\n**Expected behavior:**\r\n1) value should have inferred type as HelloInterface | undefined. \r\nThis will force me to handle the case where it is undefined in the caller.\r\n\r\n**Actual behavior:**\r\nvalue has type HelloInterface\r\nThere will be a runtime error when we access say value.property1 when value is undefined.\r\n\r\n**Playground Link:** \r\nPaste above code in vscode editor. \r\nI would expect vscode editor to indicate an error for value possibly being undefined.\r\n\r\n** Other Observations **\r\n The same works if the function return type is say Promise<HelloInterface | string>\r\n It appears this is seen when we have 'undefined' as one of the return value types.\r\n\r\n**Related Issues:**\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/29411/comments",
    "author": "psavur",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2019-01-14T21:53:26Z",
        "body": "Sounds like you have `strictNullChecks` off - enable this option to have TS check for `null` / `undefined` values"
      },
      {
        "user": "psavur",
        "created_at": "2019-01-14T23:26:34Z",
        "body": "@RyanCavanaugh  strictNullChecks are on.\r\nI updated the code example above to be more clear.\r\n\r\n"
      },
      {
        "user": "ajafff",
        "created_at": "2019-01-15T07:42:24Z",
        "body": "And do you have `strictFunctionTypes` enabled?"
      },
      {
        "user": "psavur",
        "created_at": "2019-01-15T17:54:18Z",
        "body": "@ajafff  Yes, it was `strictFunctionTypes`. Thanks, closing this."
      }
    ]
  },
  {
    "number": 29295,
    "title": "Extract<keyof T, string> is not assignable to K extends Extract<keyof T, string> when used as K[]",
    "created_at": "2019-01-07T20:06:40Z",
    "closed_at": "2019-01-08T00:11:45Z",
    "labels": [
      "Question",
      "Domain: lib.d.ts"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/29295",
    "body": "**TypeScript Version:**  3.3.0-dev.20190105\r\n\r\n<!-- Search terms you tried before logging this (so others can find this issue more easily) -->\r\n**Search Terms:** keyof string array, K extends Extract<keyof T, string>\r\n\r\n**Code**\r\n\r\nUsing a generic `K extends Extract<keyof T, string>` generic definition does not work:\r\n\r\n```ts\r\nfunction copyAllExcept<T, K extends Extract<keyof T, string>>(target: any, source: T, skip: K[]) {\r\n    for (const key in source) {\r\n        if (source[key] != null && !skip.includes(key)) {\r\n            target[key] = source[key];\r\n        }\r\n    }\r\n}\r\n```\r\nError at the `!skip.includes(key)` part:\r\n\r\nArgument of type 'Extract<keyof T, string>' is not assignable to parameter of type 'K'.\r\n  Type 'string & keyof T' is not assignable to type 'K'.\r\n    Type 'string' is not assignable to type 'K'.\r\n      Type 'string' is not assignable to type 'K'.\r\n\r\n\r\nUsing `Array<Extract<keyof T, string>>` directly as the argument definition does work though:\r\n\r\n```ts\r\nfunction copyAllExcept<T>(target: any, source: T, skip: Array<Extract<keyof T, string>>) {\r\n    for (const key in source) {\r\n        if (source[key] != null && !skip.includes(key)) {\r\n            target[key] = source[key];\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/29295/comments",
    "author": "manigandham",
    "comments": [
      {
        "user": "weswigham",
        "created_at": "2019-01-07T23:56:18Z",
        "body": "You don't need the `K` type parameter - you're overconstraining your input a bit:\r\n```ts\r\nfunction copyAllExcept<T>(target: any, source: T, skip: (Extract<keyof T, string>)[]) {\r\n  for (const key in source) {\r\n      if (source[key] != null && !skip.includes(key)) {\r\n          target[key] = source[key];\r\n      }\r\n  }\r\n}\r\n```\r\nand that seems to work fine.\r\n\r\nNow, the type parameter doesn't work because you're saying that you're searching through a `K[]` for a `Extract<keyof T, string>` - while `K extends Extract<keyof T, string>`, `Extract<keyof T, string>` is a less specific type and so doesn't satisfy the argument type. `includes` is going to be OK with this at runtime anyway - the parameter type is actually meaningless, you define its type as `unknown` and be fine, which is what's unfortunate here - the `lib` definition of `Array.prototype.includes` constrains its argument to the type of only things in the array - meaning you can't pass less specific types that might still be the same as things in the array."
      },
      {
        "user": "manigandham",
        "created_at": "2019-01-08T00:11:45Z",
        "body": "Ah ok, didn't realize that the `extends` keyword made it more specific. Seems like it would fit since they are both from a limited set of strings coming from `keyof` but the direct argument definition works.\r\n\r\nThanks for the info."
      }
    ]
  },
  {
    "number": 29210,
    "title": "Dependency questions ",
    "created_at": "2018-12-31T04:30:34Z",
    "closed_at": "2018-12-31T04:32:34Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/29210",
    "body": "I have a few questions. \r\nWhich dependencies are needed for:\r\nBuilding? Excluding linting, testing, minifying \r\nTesting?\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/29210/comments",
    "author": "swedebugia",
    "comments": [
      {
        "user": "DanielRosenwasser",
        "created_at": "2018-12-31T04:32:32Z",
        "body": "Hey there, this issue tracker isn't meant to work as a support forum. These questions tend to be better suited for other venues like our Gitter channel, or can be searched up separately. Thanks!"
      }
    ]
  },
  {
    "number": 29097,
    "title": "error TS2304: Cannot find name 'EventListenerOrEventListenerObject' (and others)",
    "created_at": "2018-12-19T14:32:15Z",
    "closed_at": "2018-12-19T19:47:08Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/29097",
    "body": "This is a duplicate of #21922, but that one has been fixed in 2.8. Maybe the DT entry for electron needs updating. In this case this issue would be obsolete.\r\n\r\n**TypeScript Version:**  3.3.0-dev.20181219\r\n\r\n**Search Terms:**\r\n\r\n**Code**\r\n\r\n```ts\r\n// any code using electron, both with obsolete @types/electron or types included in electron.\r\n```\r\n\r\n**Expected behavior:**\r\n\r\nNo errors\r\n\r\n**Actual behavior:**\r\n\r\n```\r\ntsc --noEmit\r\n\r\nnode_modules/electron/electron.d.ts:3675:116 - error TS2304: Cannot find name 'ReadableStream'.\r\n\r\n3675     interceptStreamProtocol(scheme: string, handler: (request: InterceptStreamProtocolRequest, callback: (stream?: ReadableStream | StreamProtocolResponse) => void) => void, completion?: (error: Error) => void): void;\r\n                                                                                                                        ~~~~~~~~~~~~~~\r\n\r\nnode_modules/electron/electron.d.ts:3744:114 - error TS2304: Cannot find name 'ReadableStream'.\r\n\r\n3744     registerStreamProtocol(scheme: string, handler: (request: RegisterStreamProtocolRequest, callback: (stream?: ReadableStream | StreamProtocolResponse) => void) => void, completion?: (error: Error) => void): void;\r\n                                                                                                                      ~~~~~~~~~~~~~~\r\n\r\nnode_modules/electron/electron.d.ts:4200:11 - error TS2304: Cannot find name 'ReadableStream'.\r\n\r\n4200     data: ReadableStream;\r\n               ~~~~~~~~~~~~~~\r\n\r\nnode_modules/electron/electron.d.ts:6535:38 - error TS2304: Cannot find name 'HTMLElementEventMap'.\r\n\r\n6535     addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, useCapture?: boolean): void;\r\n                                          ~~~~~~~~~~~~~~~~~~~\r\n\r\nnode_modules/electron/electron.d.ts:6535:102 - error TS2304: Cannot find name 'HTMLElementEventMap'.\r\n\r\n6535     addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, useCapture?: boolean): void;\r\n                                                                                                          ~~~~~~~~~~~~~~~~~~~\r\n\r\nnode_modules/electron/electron.d.ts:6536:46 - error TS2304: Cannot find name 'EventListenerOrEventListenerObject'.\r\n\r\n6536     addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\r\n                                                  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n\r\nnode_modules/electron/electron.d.ts:6537:41 - error TS2304: Cannot find name 'HTMLElementEventMap'.\r\n\r\n6537     removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, useCapture?: boolean): void;\r\n                                             ~~~~~~~~~~~~~~~~~~~\r\n\r\nnode_modules/electron/electron.d.ts:6537:105 - error TS2304: Cannot find name 'HTMLElementEventMap'.\r\n\r\n6537     removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, useCapture?: boolean): void;\r\n                                                                                                             ~~~~~~~~~~~~~~~~~~~\r\n\r\nnode_modules/electron/electron.d.ts:6538:49 - error TS2304: Cannot find name 'EventListenerOrEventListenerObject'.\r\n\r\n6538     removeEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\r\n                                                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n\r\n[EDIT: removed irrelevant errors]\r\n```\r\n**Playground Link:** <!-- A link to a TypeScript Playground \"Share\" link which demonstrates this behavior -->\r\n\r\n**Related Issues:** #21922",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/29097/comments",
    "author": "mutech",
    "comments": [
      {
        "user": "weswigham",
        "created_at": "2018-12-19T18:17:09Z",
        "body": "`EventListenerOrEventListenerObject` is definitely still used in the `DOM` lib file - are you compiling with `noLib` or without the dom lib?"
      },
      {
        "user": "weswigham",
        "created_at": "2018-12-19T18:58:23Z",
        "body": "Yeah, I can only repro these errors if the `dom` lib isn't in the build. Does your `lib` compiler option include `dom`?"
      },
      {
        "user": "mutech",
        "created_at": "2018-12-19T19:47:08Z",
        "body": "You're right, `dom` was missing. I split the compilation for main and renderer parts and removed `dom` for the main part. Didn't realize tha the d.ts is the same for node/chrome. Sorry for the noise."
      }
    ]
  },
  {
    "number": 29092,
    "title": "Can tsc emit namespace with explicit reference to window?",
    "created_at": "2018-12-19T08:53:01Z",
    "closed_at": "2018-12-24T14:40:56Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/29092",
    "body": "Not sure if I have missed something, but I've found nothing on the web... So, suppose I have the following file `test.ts`\r\n```typescript\r\nnamespace MyNamespace.SubNamespace\r\n{\r\n\r\n    export function test()\r\n    {\r\n        window.alert(\"Test!\");\r\n    }\r\n\r\n}\r\n```\r\n\r\nWhen compiling it with `tsc --strict`, the generated file, `test.js`, is\r\n```javascript\r\n\"use strict\";\r\nvar MyNamespace;       // <---- (A)\r\n(function (MyNamespace) {\r\n    var SubNamespace;\r\n    (function (SubNamespace) {\r\n        function test() {\r\n            window.alert(\"Test!\");\r\n        }\r\n        SubNamespace.test = test;\r\n    })(SubNamespace = MyNamespace.SubNamespace || (MyNamespace.SubNamespace = {}));\r\n})(MyNamespace || (MyNamespace = {}));\r\n```\r\n\r\nWhen the script get loaded with `<script>` tag, I have access to `window.MyNamespace`, and everything works out just fine.\r\n\r\nThe problem comes when I'm trying to use `window.eval()` and put the content of `test.js` into it. Due to the nature of a mixture of Strict Mode and global `eval` function, when you declare a variable at position `(A)`, it isn't really the same as `window.MyNamespace`, and after the script execution, `window.MyNamespace` is still undefined.\r\n\r\nI understand there exist scripts executed not in browsers, but would it be better if the compiler can provide us a way to specify the global container for the namespaces explicitly, so we can have the compiled js look like this?\r\n```javascript\r\n\"use strict\";\r\n(function (MyNamespace) {\r\n    var SubNamespace;\r\n    (function (SubNamespace) {\r\n        function test() {\r\n            window.alert(\"Test!\");\r\n        }\r\n        SubNamespace.test = test;\r\n    })(SubNamespace = MyNamespace.SubNamespace || (MyNamespace.SubNamespace = {}));\r\n})(window.MyNamespace || (window.MyNamespace = {}));\r\n```",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/29092/comments",
    "author": "CXuesong",
    "comments": [
      {
        "user": "weswigham",
        "created_at": "2018-12-19T18:24:48Z",
        "body": "I don't think we will, no. We don't make any assumptions on environment in our emit. If you want your namespace attached to `window`, then just do so. Add a `(window as any).MyNamespace = MyNamespace` to the bottom of your file."
      },
      {
        "user": "CXuesong",
        "created_at": "2018-12-20T03:48:17Z",
        "body": "I see. But this may introduce some complexity when there is a namespace spanning over multiple files, though we may probably solve the problem with something like this\r\n```typescript\r\n(<any>window).MyNamespace = {...((<any>window).MyNamespace || {}), ...MyNamespace};\r\n```\r\n\r\nAnyway I see the the current decision of tsc now, and will try to work on top of that. Thank you!"
      }
    ]
  },
  {
    "number": 28937,
    "title": "LS-Plugin: what to use for filesystem IO",
    "created_at": "2018-12-10T12:03:36Z",
    "closed_at": "2018-12-18T15:08:24Z",
    "labels": [
      "Question",
      "API"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/28937",
    "body": "I'm currently writing a LanguageService plugin.\r\nI need read access to the file system and probably a bit of file watching in this plugin. I don't want to use Node's `fs` module directly to allow execution in other environments.\r\nSo I looked for existing abstractions to do FileSystem IO. Here's what I found out so far:\r\n\r\n`PluginCreateInfo.serverHost`: the host of all hosts, accesses the file system directly\r\n`PluginCreateInfo.project`: uses a CachedDirectoryStructureHost to allow file system reads, doesn't support watching\r\n`PluginCreateInfo.languageServiceHost`: the same as `PluginCreateInfo.project` in the default implementation? with a lot of optional methods so not really pleasant to use\r\n\r\nWhen using `ServerHost` for file watching I need to clean up after myself when my plugin is disposed?\r\n\r\nAre the assumptions above correct? Is there some kind of documentation how this all works together (other than looking at the code)?",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/28937/comments",
    "author": "ajafff",
    "comments": [
      {
        "user": "weswigham",
        "created_at": "2018-12-10T22:49:49Z",
        "body": "@sheetalkamat do you know if we have a doc page on how the `host`s for the plugin/server APIs are related?"
      },
      {
        "user": "sheetalkamat",
        "created_at": "2018-12-12T18:10:42Z",
        "body": "I dont know if there is documentation around it but `ts.sys` is our FS abstraction. Other hosts like language service or project arent file system implementers. Eg. Project implements languageServiceHost so it doesn't need watch implementation. it internally does watch depending on what kind of languageServiceHost commands take place. (eg. from program watching missing files etc)\r\n"
      },
      {
        "user": "ajafff",
        "created_at": "2018-12-18T15:08:24Z",
        "body": "Thank you for the insights. I think I'll try to avoid `ts.sys` as the `ServerHost` might use a different means for filesystem access.\r\nMy current approach is using `Project` where possible and falling back to `ServerHost` for watching."
      }
    ]
  },
  {
    "number": 28593,
    "title": "Classes cannot satisfy Constructor<Itself> bound",
    "created_at": "2018-11-18T21:28:08Z",
    "closed_at": "2018-11-19T18:41:55Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/28593",
    "body": "<!-- Please try to reproduce the issue with `typescript@next`. It may have already been fixed. -->\r\n**TypeScript Version:**  3.2.0-dev.201xxxxx\r\n\r\n<!-- Search terms you tried before logging this (so others can find this issue more easily) -->\r\n**Search Terms:** generics mixin classes interfaces constructor\r\n\r\n**Code**\r\n\r\n```ts\r\ntype Constructor<T> = new(...args: any[]) => T;\r\n\r\ninterface XInterface {}\r\nfunction make<T extends Constructor<XInterface>>(Base: T) {\r\n    return class extends Base implements XInterface {}\r\n}\r\n\r\n// This is ok.\r\nclass X extends make(Function) { }\r\n\r\n// But this fails.\r\nclass X2 extends make(Function) implements Constructor<XInterface> { }\r\n```\r\n\r\n**Expected behavior:** \r\nCode should compile\r\n\r\n**Actual behavior:**\r\nCompiler error: X2 provides no match for signature `new(...args: any[]) => XInterface`\r\n\r\n\r\n--- \r\n\r\n**Edit 1:**\r\nLooks like even something more basic like \r\n\r\n```ts\r\nclass Y implements XInterface, Constructor<XInterface> {}\r\n```\r\n\r\nfails to compile. This makes it difficult to chain together a set of mixin extending through another mixin function. \r\n\r\n**Edit 2**\r\n\r\nLooks like even the simplest case of\r\n\r\n```ts\r\nclass Y implements Constructor<Y>\r\n```\r\n\r\nfails.",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/28593/comments",
    "author": "prasannavl",
    "comments": [
      {
        "user": "weswigham",
        "created_at": "2018-11-19T18:29:30Z",
        "body": "@prasannavl the `implements` clause constrains the instance shape of a class - the constructor signature of a class is associate with its static side (it returns the instance), therefore isn't constrainable via `implements`.\r\n\r\n```ts\r\nclass X2 extends make(Function) implements Constructor<XInterface> { }\r\n```\r\nis saying the class X2 extends a `Constructor<XInterface>` and its instance is a `Constructor<XInterface>` - meaning that when you say `new X2()`, the result is something you can use `new` on and get an `XInterface`, which is, ofc, not the case here."
      },
      {
        "user": "prasannavl",
        "created_at": "2018-11-19T18:41:55Z",
        "body": "Thank you @weswigham  -- That makes a lot of sense. I feel rather silly now after reading the reply. Thanks again for taking the time to explain this! :) "
      }
    ]
  },
  {
    "number": 28543,
    "title": "TypeScript call AMD module",
    "created_at": "2018-11-15T05:58:54Z",
    "closed_at": "2018-11-15T06:30:13Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/28543",
    "body": "i have a library use AMD，i want call this library in typeScript，\r\ni use “const VertexArray = require('src/assets/thirdParty/cesium/Source/Renderer/VertexArray.js')”，\r\nbut in AMD module i use “require('https')”，when i compile typeScript，\r\nERROR：Module not found: Error: Can't resolve 'https'",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/28543/comments",
    "author": "z3214965",
    "comments": [
      {
        "user": "DanielRosenwasser",
        "created_at": "2018-11-15T06:30:13Z",
        "body": "Hey there, this issue tracker isn't meant to work as a support forum. These questions tend to be better suited for StackOverflow. You may want to open a question up there instead. Thanks!"
      },
      {
        "user": "z3214965",
        "created_at": "2018-11-15T07:02:06Z",
        "body": "@DanielRosenwasser \r\nin StackOverflow，I didn't find a solution，Can you help me out? Thank you"
      }
    ]
  },
  {
    "number": 28191,
    "title": "Spread operator with one union-typed key gives type error?",
    "created_at": "2018-10-28T18:43:19Z",
    "closed_at": "2018-10-29T19:27:03Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/28191",
    "body": "I'm not sure if the following code should be filed as a bug, or it's just me not completely understanding the Typescript type-system.\r\n\r\nIn the following code (testing the playground V3.1), the function `fails` gives a type error, complaining that `Type 'Tag.BAR' is not assignable to type 'Tag.FOO'`.\r\n\r\nHowever, this function just returns the `x` object again, it's just that the `id` key is copied explicitly.\r\n\r\nCan someone explain why this doesn't work, and/or if this is a bug or by design?\r\n\r\n```ts\r\n// Dummy _tag_ key to avoid passing identifiers as plain numbers\r\ntype Identifier<TAG> = number & { readonly _tag_: TAG };\r\n\r\ninterface Entity<TAG> {\r\n  readonly tag: TAG;\r\n  readonly id: Identifier<TAG>;\r\n}\r\n\r\nenum Tag {\r\n  FOO = 0,\r\n  BAR = 1\r\n}\r\n\r\ninterface Foo extends Entity<Tag.FOO> {\r\n    foo: string;\r\n}\r\n\r\ninterface Bar extends Entity<Tag.BAR> {\r\n    bar: boolean;\r\n}\r\n\r\nfunction works(x: Foo | Bar): Foo | Bar {\r\n    return { ...x };\r\n}\r\n\r\nfunction fails(x: Foo | Bar): Foo | Bar {\r\n    return { ...x, id: x.id };\r\n}\r\n```\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/28191/comments",
    "author": "ziriax",
    "comments": [
      {
        "user": "weswigham",
        "created_at": "2018-10-29T18:22:04Z",
        "body": "When you say `x.id`, you get the type of the `id` field on both `Foo` and `Bar` - so `Identifier<Tag.FOO> | Identifier<Tag.BAR>`. The assignment doesn't retain a dependency relationship on `x`'s type, so what happens is in both of the union elements you spread over, you assign this combined type to both members, causing the problem."
      },
      {
        "user": "ziriax",
        "created_at": "2018-10-29T19:27:03Z",
        "body": "Thanks for clarifying. Coming from C# and C++, this is very peculiar :-) But it does make perfect sense if you look at it this way. \r\n\r\nThanks, closing this then, since it is by design.\r\n\r\n\r\n"
      }
    ]
  },
  {
    "number": 27762,
    "title": "Import module type definition without importing it for async imports.",
    "created_at": "2018-10-11T19:09:29Z",
    "closed_at": "2018-10-11T21:16:38Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/27762",
    "body": "## Suggestion\r\n\r\nI want to asynchronously import a module and assign it to a variable without losing its type definition.\r\n\r\n```ts\r\nclass NewRelicService {\r\n    private newrelic: X\r\n    public async init() {\r\n        this.newrelic = await import(\"newrelic\")\r\n    }\r\n}\r\n```\r\n\r\nHowever, its not possible for me to get the type definition of the module without importing it.\r\n\r\n`@types/newrelic/index.ts` looks like this.\r\n\r\n```ts\r\ndeclare namespace newrelic {\r\n    interface NewRelicAPI {}\r\n}\r\ndeclare const api: newrelic.NewRelicAPI;\r\nexport = api;\r\n```\r\n\r\nSo the question is how can I get that type definition without importing the newrelic module. This doesn't work, and I've tried a number of different things.\r\n\r\n```ts\r\nimport {NewRelicAPI} from \"@types/newrelic/index\"\r\nimport {newrelic} from \"@types/newrelic/index\"\r\nimport {api} from \"@types/newrelic/index\"\r\nimport {NewRelicAPI} from \"newrelic\"\r\nimport {newrelic} from \"newrelic\"\r\nimport {api} from \"newrelic\"\r\n```\r\n\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/27762/comments",
    "author": "ccorcos",
    "comments": [
      {
        "user": "ghost",
        "created_at": "2018-10-11T19:17:28Z",
        "body": "You can use `private newrelic: typeof import(\"newrelic\");`.\r\n(Current definitions of `@types/newrelic` are overly complicated, fixed this in DefinitelyTyped/DefinitelyTyped#29662. But that won't affect your situation.)"
      },
      {
        "user": "ccorcos",
        "created_at": "2018-10-11T21:15:17Z",
        "body": "That's not going to import newrelic?"
      },
      {
        "user": "ghost",
        "created_at": "2018-10-11T21:20:44Z",
        "body": "It's just a type annotation, it doesn't have any runtime effect."
      }
    ]
  },
  {
    "number": 27678,
    "title": "Why promise will be unwrapped by dynamic import?",
    "created_at": "2018-10-10T06:45:37Z",
    "closed_at": "2018-10-10T19:02:08Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/27678",
    "body": "I got mysterious inferred type with dynamic import.In `dynamic import` with `typeof`,Promise will be unwrapped.\r\n\r\n```json\r\n{\r\n  \"foo\": \"FOO\"\r\n}\r\n```\r\n\r\n```typescript\r\nconst json = import('./sample.json')\r\ntype ImportedJsonType = typeof json\r\ntype DynamicImportedJsonType = typeof import('./sample.json')\r\n```\r\n\r\n```typescript\r\n// result of infer\r\ntype ImportedJsonType = Promise<{ \"foo\": string }>\r\ntype DynamicImportedJsonType = { \"foo\": string }\r\n```\r\nI would like to know the reasons for this behavior. Best reguards.\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/27678/comments",
    "author": "takefumi-yoshii",
    "comments": [
      {
        "user": "ajafff",
        "created_at": "2018-10-10T06:59:20Z",
        "body": "`import('./sample.json')` as expression returns a Promise because it executes asynchronously.\r\n`import('./sample.json')` as type is not intended to be the same as the expression counterpart. It's meant to reference a type of another module inline. Since it has no runtime behavior, it doesn't need to result in a Promise-type."
      },
      {
        "user": "takefumi-yoshii",
        "created_at": "2018-10-10T07:54:06Z",
        "body": "@ajafff Thanks for reply.If there has some discussion at past time,I'd like to know related issues.I would like to still open this one day.\r\n"
      }
    ]
  },
  {
    "number": 27540,
    "title": "Weak inference of String Literal Types by const",
    "created_at": "2018-10-04T07:25:45Z",
    "closed_at": "2018-10-05T02:16:22Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/27540",
    "body": "Needless to say, below code infferd as String Literal Types.\r\n```typescript\r\nexport const INCREMENT = \"INCREMENT\"\r\nexport const SET_COUNT = \"SET_COUNT\" as \"SET_COUNT\"\r\n```\r\n```typescript\r\n// result of infer\r\nconst INCREMENT: \"INCREMENT\"\r\nconst SET_COUNT: \"SET_COUNT\"\r\n```\r\nWhen put them in the object, It is no longer as String Literal Types without assertion.\r\nIs it correct to be interpreted as weak inference?\r\n\r\n```typescript\r\nconst object = {\r\n  INCREMENT,\r\n  SET_COUNT\r\n}\r\n```\r\n```typescript\r\n// result of infer\r\nconst object: {\r\n  INCREMENT: string;\r\n  SET_COUNT: \"SET_COUNT\";\r\n}\r\n```\r\n\r\nAnd this problem can avoid below code.\r\n\r\n```typescript\r\nconst object = {\r\n  INCREMENT: INCREMENT as (typeof INCREMENT),\r\n  SET_COUNT\r\n}\r\n```\r\n```typescript\r\n// result of infer\r\nconst object: {\r\n  INCREMENT: \"INCREMENT\";\r\n  SET_COUNT: \"SET_COUNT\";\r\n}\r\n```\r\nI am waiting for reply. Best reguards.",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/27540/comments",
    "author": "takefumi-yoshii",
    "comments": [
      {
        "user": "jack-williams",
        "created_at": "2018-10-04T08:56:17Z",
        "body": "I think the solution to this is covered by #10195"
      },
      {
        "user": "takefumi-yoshii",
        "created_at": "2018-10-04T09:15:03Z",
        "body": "@jack-williams thanks! I'll track them."
      },
      {
        "user": "takefumi-yoshii",
        "created_at": "2018-10-04T12:48:28Z",
        "body": "umm...Is the pointer reference strength different depending on whether assertion is present or not？"
      },
      {
        "user": "ahejlsberg",
        "created_at": "2018-10-04T13:46:03Z",
        "body": "See #11126 for a description of this behavior."
      },
      {
        "user": "takefumi-yoshii",
        "created_at": "2018-10-05T02:16:21Z",
        "body": "@ahejlsberg thanks for reply. I understood about `Widening and non-widening`. I'll write some localized post about them."
      }
    ]
  },
  {
    "number": 27374,
    "title": "Property 'value' does not exist on type 'IDBCursor'",
    "created_at": "2018-09-26T20:13:17Z",
    "closed_at": "2018-10-01T21:55:08Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/27374",
    "body": "typescript complains about `value` property on `IDBCursor` interface.\r\n\r\n    let cursor: IDBCursor;\r\n    cursor.value\r\n\r\n\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/27374/comments",
    "author": "P0oOOOo0YA",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2018-10-01T21:55:08Z",
        "body": "`let cursor: IDBCursorWithValue`"
      }
    ]
  },
  {
    "number": 27185,
    "title": "Preserve variable names when converting commonjs",
    "created_at": "2018-09-18T13:42:49Z",
    "closed_at": "2018-09-18T21:54:23Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/27185",
    "body": "Example file:\r\n\r\n```\r\nimport { Bar as test } from \"./Bar\";\r\nimport { Foo as test2 } from \"./Foo\";\r\n\r\nlet bar = new test()\r\nlet foo = new test2();\r\n```\r\n\r\nWhen output using commonjs, looks like this:\r\n\r\n```\r\n\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst Bar_1 = require(\"./Bar\");\r\nconst Foo_1 = require(\"./Foo\");\r\nlet bar = new Bar_1.Bar();\r\nlet foo = new Foo_1.Foo();\r\n```\r\n\r\n```test``` and ```test2``` are nowhere to be seen.\r\n\r\nThis renders inline variable previewing and easy autocomplete in debugging impossible for those variables.\r\n\r\nIt becomes a guessing game of what import variable names are instead of preserving the original names, I don't see why this would clash or be an issue.\r\n\r\nWhy transform the names?\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/27185/comments",
    "author": "jpike88",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2018-09-18T21:54:23Z",
        "body": "ES6 module bindings are \"live\", even if bound to a single local identifier through destructuring. IOW\r\n```\r\n// a.js\r\nexport let x = 0;\r\nexport function increment() { x++ }\r\n\r\n// b.js\r\nimport { x, increment } from './a';\r\nincrement();\r\nconsole.log(x.toString()); // Prints 1, not 0\r\n```"
      }
    ]
  },
  {
    "number": 27174,
    "title": "API: how to work with fresh type literal or literal type?",
    "created_at": "2018-09-18T07:14:38Z",
    "closed_at": "2019-06-01T12:32:00Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/27174",
    "body": "With all the type freshness recently added, is there a way to actually use it through the public API?\r\n`ts.TypeFlags.FreshLiteral` is internal, so that's not an option.\r\n\r\nLast time I checked none of the `TypeChecker.getType*` methods returned a type with the freshness flag set, even though is should definitely be there.\r\n\r\nIs freshness a concept that is not intended for API users to know and care about?",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/27174/comments",
    "author": "ajafff",
    "comments": [
      {
        "user": "DanielRosenwasser",
        "created_at": "2018-09-18T16:14:26Z",
        "body": "> Is freshness a concept that is not intended for API users to know and care about?\r\n\r\nI want to say this is the answer, however I'll defer to @RyanCavanaugh and @weswigham. Is there any reason you need to know about freshness?"
      },
      {
        "user": "weswigham",
        "created_at": "2018-09-18T16:34:16Z",
        "body": "It's intended to be internal. Consumers should just be aware that there can be multiple variants of a literal type with different triple-equals assignability that are still essentially identical types, so generally speaking, using triple equals to check for the presence of a specific type is a bad idea. A relationship like isIdenticalTo or isAssignableTo is almost always more correct."
      },
      {
        "user": "ajafff",
        "created_at": "2018-09-18T20:17:40Z",
        "body": "> Is there any reason you need to know about freshness?\r\n\r\nAdmittedly there are not many use cases and the one I'm presenting here may not be too useful either:\r\nI have a lint rule to detect useless assertions. Currently I have to ignore assertions with literal types as they are used to prevent widening (remove freshness).\r\n\r\n```ts\r\ndeclare function identity<T>(p: T): T;\r\nidentity('foo' as 'foo'); // assertion is not necessary because identity functions make fresh literal type non-widening\r\nconst wideningFoo = 'foo';\r\nconst nonWideningFoo = wideningFoo as 'foo'; // assertion is necessary to remove freshness\r\n\r\n'foo' as 'foo'; // assertion is necessary to remove freshness\r\nnonWideningFoo as 'foo'; // assertion is not necessary on a non-widening type\r\n```\r\n\r\nThe last case in the above example cannot be detected right now.\r\n\r\n> A relationship like isIdenticalTo or isAssignableTo is almost always more correct.\r\n\r\nI wish one of these functions was exposed as part of the public API. Currently I can only compare type identity using triple equals or compare the output of `typeToString`"
      },
      {
        "user": "ajafff",
        "created_at": "2018-10-19T14:16:49Z",
        "body": "I have another use case: I have a rule to detect useless initializers (in ObjectBindingPattern).\r\nIt works by looking at the initializer of the VariableLikeDeclaration and check if the destructured property is optional or allows `undefined`.\r\nUnfortunately the type checker adds `SymbolFlags.Optional` to properties of fresh object literals if the destructuring has a default initializer:\r\n\r\n```ts\r\nlet {a = '', b = ''} = {a: 1, b: Boolean() ? 'foo' : undefined};\r\n```\r\n\r\nIn the above example properties `a` and `b` are both marked as optional (even though they will always be present). I could simply ignore that flag if I knew that I'm dealing with a fresh object literal. But there's no way for me to find out that the containing type is a fresh object literal (besides looking at the AST)."
      }
    ]
  },
  {
    "number": 26934,
    "title": "Can i declare an Object properties must contain a or b ?",
    "created_at": "2018-09-06T06:36:10Z",
    "closed_at": "2018-09-06T22:53:40Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/26934",
    "body": "when i declare an Object like this:\r\n`interface obj {\r\n a?:string,\r\n b?string\r\n}\r\n`\r\nbut i want the attribute a not to exist, the attribute b must exist.\r\n`let obj:obj={}`  It is allowed ,i want it is not allowed\r\n`let obj:obj={a:'a'}` or `let obj:obj={b:'b'}`  if i want It is allowed. what should I do?\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/26934/comments",
    "author": "Zane0816",
    "comments": [
      {
        "user": "markusjohnsson",
        "created_at": "2018-09-06T12:48:26Z",
        "body": "Yes, but not using an interface. Instead, use `type`:\r\n\r\n```ts\r\ntype obj = { a: string } | { b: string };\r\n```\r\n\r\nif you want both properties:\r\n\r\n```ts\r\ntype obj = { a: string } | { b: string } | { a: string; b: string; };\r\n```"
      },
      {
        "user": "Zane0816",
        "created_at": "2018-09-06T13:42:44Z",
        "body": "thanks! I think it should be simple @markusjohnsson "
      }
    ]
  },
  {
    "number": 26757,
    "title": "Infer Interfaces from types",
    "created_at": "2018-08-30T00:34:00Z",
    "closed_at": "2018-08-30T00:51:28Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/26757",
    "body": "<!-- 🚨 STOP 🚨 𝗦𝗧𝗢𝗣 🚨 𝑺𝑻𝑶𝑷 🚨\r\n\r\nHalf of all issues filed here are duplicates, answered in the FAQ, or not appropriate for the bug tracker. Please read the FAQ first, especially the \"Common Feature Requests\" section.\r\n\r\n-->\r\n\r\n## Search Terms\r\n\r\ninfer interfaces types automatic generate mock\r\n\r\n## Suggestion\r\n\r\nInfer interfaces from public members of types.\r\n`<TypeName>.Interface` would be understood as an interface which requires all public members of **TypeName** to be implemented.\r\n\r\n## Use Cases\r\n\r\nThe majority of interfaces I have in my projects are for testing purpose, to allow mocking out related modules. Any signature change needs to happen always in 3 places (interface, real implementation and mock) what is bothersome.\r\n\r\nThat would remove the need of writing explicitly this kind of interface.\r\n\r\n## Examples\r\n\r\n```ts\r\n// Given a type:\r\nclass Foo {\r\n     public foo(): string {\r\n        return \"I am foo\";\r\n    }\r\n}\r\n\r\n// This would be a mock implementation:\r\nclass MockFoo1 implements Foo.Interface {\r\n     public foo(): string {\r\n        return \"mockresult\";\r\n    }\r\n}\r\n\r\n// This would complain of missing foo function:\r\nclass MockFoo2 implements Foo.Interface {\r\n     public bar(): string {\r\n        return \"I am foo\";\r\n    }\r\n}\r\n\r\n// Happy Assignments:\r\nconst foo: Foo.interface = new Foo();\r\nconst mockFoo1: Foo.interface = new MockFoo1();\r\n```\r\n\r\n## Checklist\r\n\r\nMy suggestion meets these guidelines:\r\n* [X] This wouldn't be a breaking change in existing TypeScript / JavaScript code\r\n* [X] This wouldn't change the runtime behavior of existing JavaScript code\r\n* [X] This could be implemented without emitting different JS based on the types of the expressions\r\n* [X] This isn't a runtime feature (e.g. new expression-level syntax)\r\n\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/26757/comments",
    "author": "renatomariscal",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2018-08-30T00:36:47Z",
        "body": "You can already write\r\n```ts\r\nclass MockFoo1 implements Foo {\r\n```\r\nand get the behavior you've described. No new syntax needed"
      },
      {
        "user": "renatomariscal",
        "created_at": "2018-08-30T00:38:55Z",
        "body": "This is awesome, is that mentioned somewhere in the documentation?"
      },
      {
        "user": "renatomariscal",
        "created_at": "2018-08-30T00:51:28Z",
        "body": "Closing as the feature already exists."
      }
    ]
  },
  {
    "number": 26466,
    "title": "FileReader, e.target.result (result - indefined)",
    "created_at": "2018-08-15T07:05:11Z",
    "closed_at": "2018-08-15T15:43:41Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/26466",
    "body": "**\r\nvar reader = new FileReader();\r\n        reader.onload = e => {\r\n          var content = e.target.result;\r\n          var base64 = content.split(\",\")[1];\r\n          file.base64Data = base64;\r\n          input.remove();\r\n          deferred.resolve(file);\r\n        }\r\n**\r\n\r\ne.target.result \r\nresult - indefined",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/26466/comments",
    "author": "yuriy-bezrukov",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2018-08-15T15:43:41Z",
        "body": "That is indeed code.\r\n\r\nPlease follow the template."
      }
    ]
  },
  {
    "number": 26351,
    "title": "Why did I restore the traditional mode?",
    "created_at": "2018-08-10T01:45:45Z",
    "closed_at": "2018-08-10T18:28:13Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/26351",
    "body": "Why did I restore the traditional mode, the next time I open VS 2017, it opens to me by default, I don't want this new mode, because it will cause the JS file written by my own local project to not prompt, which is annoying, or you can use the new The language service, also prompt me the function of the JS file in the local project? Is there such a solution?",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/26351/comments",
    "author": "JHeLiu",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2018-08-10T18:28:13Z",
        "body": "To expedite the triage process, we need everyone to follow the issue template and instructions.\r\n\r\nWhen you clicked \"Create New Issue\", the issue form was pre-populated with a template and some instructions. We need you to read those instructions *completely*, follow them, and then fill in *all* the fields in that template.\r\n\r\nWe are not able to assist with issues that don't follow the template instructions as they represent a significantly larger amount of work compared to issues which are correctly specified. Thank you for understanding."
      }
    ]
  },
  {
    "number": 26212,
    "title": "Support typeguards for class members",
    "created_at": "2018-08-05T11:19:10Z",
    "closed_at": "2018-08-06T17:52:04Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/26212",
    "body": "## Search Terms\r\n\r\n- type guards\r\n- member type guards\r\n- class member type guard\r\n\r\n## Suggestion\r\n\r\nAdd an expression that makes type guard functions to check the class instance members instead of\r\nthe function's parameters, in place of `value is X` something like `this.value is X`.\r\n\r\n## Use Cases\r\n\r\nThis would be handy when checking if an instance field is of one type or another, in join types or\r\nin optional types.\r\n\r\nCurrently this can be achieved with parameter checking, like:\r\n\r\n```ts\r\nclass Foo {\r\n  value: string | null;\r\n  hasValue(value: string | null): value is string {\r\n    return value !== null;\r\n  }\r\n}\r\nconst foo = new Foo();\r\nif (foo.hasValue(foo.value)) {\r\n  // Do something with foo that involves value not being null.\r\n}\r\n```\r\n\r\nThe problem of this approach is that if you want to maintain the `member` field _private_, you can't\r\ntake this approach, or this approach can only be used inside the class (Therefore `hasValue` should\r\nbe also private).\r\n\r\n## Examples\r\n\r\nThe latter can be solved telling Typescript to check the instance's member instead of the function\r\nparameter:\r\n\r\n```ts\r\nclass Foo {\r\n  private value: string | null;\r\n  public hasValue(): this.value is string {\r\n    return this.value !== null;\r\n  }\r\n}\r\nconst foo = new Foo();\r\nif (foo.hasValue()) {\r\n  // Do something with foo that involves value not being null.\r\n}\r\n```\r\n\r\n## Checklist\r\n\r\nMy suggestion meets these guidelines:\r\n* [x] This wouldn't be a breaking change in existing TypeScript / JavaScript code\r\n* [x] This wouldn't change the runtime behavior of existing JavaScript code\r\n* [x] This could be implemented without emitting different JS based on the types of the expressions\r\n* [x] This isn't a runtime feature (e.g. new expression-level syntax)\r\n\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/26212/comments",
    "author": "sigmasoldi3r",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2018-08-05T17:59:07Z",
        "body": "You can already do this:\r\n```ts\r\nclass Foo {\r\n  public value: string | null;\r\n  public hasValue(): this is { value: string } {\r\n    return this.value !== null;\r\n  }\r\n}\r\nconst foo = new Foo();\r\nfoo.value.toString(); // Error, may be null\r\nif (foo.hasValue()) {\r\n  // OK\r\n  foo.value.toString();\r\n}\r\n```"
      },
      {
        "user": "sigmasoldi3r",
        "created_at": "2018-08-06T14:26:46Z",
        "body": "Yes, it can be used as a solution and works fine (Thanks for the answer).\r\n\r\nHowever, the field cannot be private:\r\n```\r\nTS2546: Property 'value' has conflicting declarations and is inaccessible in type 'Optional & { value: any; }'.\r\n```\r\n\r\n(But with public field works, which is better than passing it again)"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2018-08-06T16:16:35Z",
        "body": "There's no point to provide a public type guard on a private member, though - if you're inside the class, you can already directly test against it; if you're outside the class, the fact that the private field isn't null doesn't change what you can do with the class instance."
      },
      {
        "user": "sigmasoldi3r",
        "created_at": "2018-08-06T17:52:04Z",
        "body": "So we can say that is a good pattern to check it internally using a static type guard, like:\r\n\r\n```ts\r\nclass Foo<T> {\r\n  private static check<T>(value: T | null): type is T {\r\n    return value !== null;\r\n  }\r\n  private bar: T | null = null;\r\n  public operation() {\r\n    // or: if (this.bar !== null) {...}\r\n    if (Foo.check<T>(this.bar)) {\r\n      // Do things.\r\n    }\r\n  }\r\n}\r\n```\r\n\r\nIn which case, this can replace the explicit member guard.\r\n\r\nThe original intention was to provide a boolean-style method, like `hasValue()` that could let the compiler\r\nknow if what a getter returns is valid, but can be replaced with the other way round approach: Get the value, then checking if it was valid. I'll close this as it can be achieved with other approaches. Thanks for your time!"
      },
      {
        "user": "davidgomes",
        "created_at": "2019-08-13T10:05:02Z",
        "body": "> You can already do this:\r\n> \r\n> ```ts\r\n> class Foo {\r\n>   public value: string | null;\r\n>   public hasValue(): this is { value: string } {\r\n>     return this.value !== null;\r\n>   }\r\n> }\r\n> const foo = new Foo();\r\n> foo.value.toString(); // Error, may be null\r\n> if (foo.hasValue()) {\r\n>   // OK\r\n>   foo.value.toString();\r\n> }\r\n> ```\r\n\r\nThis doesn't actually work as expected if we use an `else` clause after the last `if`:\r\n\r\n```\r\n...\r\nif (foo.hasValue()) {\r\n  // OK\r\n  foo.value.toString();\r\n} else {\r\n  (foo.value); // Should be null, but is actually string | null\r\n}\r\n```\r\n\r\nIn the last `else` clause, TypeScript cannot figure out that `foo.value` can only be `null` there. Any ways around this?"
      }
    ]
  },
  {
    "number": 25918,
    "title": "Can't use default parameter value if its type a generic",
    "created_at": "2018-07-25T07:34:47Z",
    "closed_at": "2018-07-25T15:10:18Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/25918",
    "body": "Following works fine:\r\n\r\n```ts\r\nfunction a<T extends Object>(p: T) { // good\r\n}\r\na(Object); // good\r\n```\r\n\r\nhowever this does not work:\r\n\r\n```ts\r\nfunction a<T extends Object>(p: T = Object) { // error\r\n}\r\na(Object); // good\r\n```\r\n\r\nsame happens with other types:\r\n\r\n```ts\r\nfunction a<T extends number>(p: T = 1) { // error\r\n}\r\na(1); // good\r\n```\r\n\r\nResults into `Type 'ObjectConstructor' is not assignable to type 'T'` error.\r\n\r\nI came into this issue from a different scenario where I tried to use Object in a following way:\r\n\r\n```ts\r\nexport type Constructor<T = {}> = new (...args: any[]) => T;\r\nexport const Taggable = <T extends Constructor>(base: T = Object) => class extends base {\r\n    tags: any[] = [];\r\n}\r\n```",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/25918/comments",
    "author": "pleerock",
    "comments": [
      {
        "user": "mattmccutchen",
        "created_at": "2018-07-25T14:11:10Z",
        "body": "This is working as intended.  The problem is that if someone calls your function with `T` set to a subclass of `Object`, such as `string`, then the default parameter value would not be a valid value of type `T`.  It's probably cleanest to define a separate function for the case where you pass no arguments and want to use `Object`.  If you really want to use a single function, you could overload it like this:\r\n```ts\r\nexport function Taggable();\r\nexport function Taggable<T extends Constructor>(base: T);\r\nexport function Taggable<T extends Constructor>(base?: T) {\r\n  if (base === undefined) base = <T><{}>Object;\r\n  return class extends base {\r\n    tags: any[] = [];\r\n  };\r\n}\r\n```"
      },
      {
        "user": "pleerock",
        "created_at": "2018-07-25T15:10:18Z",
        "body": "Actually I want as simple as possible function signature to make it easiest as possible to create mixins.\r\n\r\nThank you for the answer though 👍 "
      }
    ]
  },
  {
    "number": 25768,
    "title": "Stringify like in \"c\" ",
    "created_at": "2018-07-18T14:12:27Z",
    "closed_at": "2018-07-19T05:56:50Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/25768",
    "body": "Hi ,\r\nHow do we convert object dot walking into string signature.\r\n``` typescript\r\nlet person = {\r\n\tcompany: {\r\n\t\tdepartment: {\r\n\t\t\tmsging: {\r\n\t\t\t\tphone: \"xyz\",\r\n\t\t\t\tfax: \"abc\"\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\tage: 34\r\n}\r\n\r\nfunction evaluateObject(val: string) {\r\n // some logic to evalute\r\n}\r\nevaluateObject(`${person.company.department.msging.phone}`);\r\n```\r\nthis will emit \r\n``` javascript\r\nevaluateObject('xyz');\r\n```\r\nbut I want to emit something like this.\r\n``` javascript\r\nevaluateObject('person.company.department.msging.phone');\r\n```\r\nIs there anyway to achieve this? Any Custom syntax like in \"C\" macros\r\n```typescript\r\nevaluateObject(`#{person.company.department.msging.phone}`);\r\n```\r\n\r\nIs it possible to achieve with any plugin kind of thing?.\r\n-thanks",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/25768/comments",
    "author": "yln99517",
    "comments": [
      {
        "user": "ghost",
        "created_at": "2018-07-18T15:07:10Z",
        "body": "I think this is possible like so:\r\n```ts\r\nfunction path<K0 extends string>(obj: Record<K0, unknown>, k0: K0): string;\r\nfunction path<K0 extends string, K1 extends string>(obj: Record<K0, Record<K1, unknown>>, k0: K0, k1: K1): string;\r\nfunction path<K0 extends string, K1 extends string, K2 extends string>(obj: Record<K0, Record<K1, Record<K2, unknown>>>, k0: K0, k1: K1, k2: K2): string;\r\nfunction path(_: any, ...keys: string[]): string {\r\n    return keys.join(\".\");\r\n}\r\n\r\nconst obj = {\r\n    a: {\r\n        b: {\r\n            c: 0,\r\n        },\r\n    },\r\n};\r\n\r\nconsole.log(path(obj, \"a\")); // \"a\"\r\nconsole.log(path(obj, \"a\", \"b\")); // \"a.b\"\r\nconsole.log(path(obj, \"a\", \"b\", \"c\")); // \"a.b.c\"\r\npath(obj, \"a\", \"b\", \"x\"); // Compile error\r\n```\r\n\r\nSee also #1579."
      },
      {
        "user": "ghost",
        "created_at": "2018-07-18T15:32:40Z",
        "body": "@sandersn Pointed out that this can be done without overloads:\r\n\r\n```ts\r\nfunction dive<T>(obj: T): Diver<T> {\r\n    return new Diver(obj, \"\");\r\n}\r\nclass Diver<T> {\r\n    constructor(readonly obj: T, readonly str: string) {}\r\n\r\n    p<K extends string, TT extends Record<K, unknown>>(this: Diver<TT>, k: K): Diver<TT[K]> {\r\n        return new Diver(this.obj[k], this.str === \"\" ? k : this.str + \".\" + k);\r\n    }\r\n}\r\n\r\nconst obj = {\r\n    a: {\r\n        b: {\r\n            c: 0,\r\n        },\r\n    },\r\n};\r\n\r\nconsole.log(dive(obj).p(\"a\").p(\"b\").p(\"c\").str);\r\n```"
      },
      {
        "user": "yln99517",
        "created_at": "2018-07-19T05:56:50Z",
        "body": "Thank you very much."
      }
    ]
  },
  {
    "number": 25753,
    "title": "readonly key signature on interfaces etc",
    "created_at": "2018-07-18T07:05:09Z",
    "closed_at": "2018-08-01T00:26:22Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/25753",
    "body": "I want to be able to create an object where all properties are readonly, yet where properties may be added in the future, something like this:\r\n\r\n```js\r\nexport interface RO {\r\n  [readonly key: string]: any\r\n}\r\n\r\nconst o = {} as RO\r\n\r\no.foo = 5;  // compiles\r\no.foo = 6   // compile error\r\n```\r\n\r\nmight be stupid/crazy, not sure. Perhaps the type checker wouldn't be perfect, but could catch some bugs that were in the same file/scope.",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/25753/comments",
    "author": "ORESoftware",
    "comments": [
      {
        "user": "ghost",
        "created_at": "2018-07-18T15:47:22Z",
        "body": "Since all there is is an index signature, the type checker can't track anything about individual properties. But you could add runtime checking.\r\n\r\n```ts\r\nconst obj: { [key: string]: number } = {};\r\nconst proxy = new Proxy(obj, {\r\n    set(obj, prop, value) {\r\n        if (prop in obj) throw new Error(`Already set '${String(prop)}'`);\r\n        return Reflect.set(obj, prop, value);\r\n    },\r\n    //...others...\r\n});\r\n\r\nproxy.one = 1;\r\nproxy.one = 2; // fails\r\n```"
      },
      {
        "user": "ORESoftware",
        "created_at": "2018-07-18T20:25:50Z",
        "body": "Yeah I am actually already using a proxy like that, I just wanted type-checking to give the user a warning about soon-to-come runtime error."
      },
      {
        "user": "ORESoftware",
        "created_at": "2018-07-21T19:11:15Z",
        "body": "is there really no way to declare constant properties/methods on an object?"
      },
      {
        "user": "ghost",
        "created_at": "2018-07-22T03:34:15Z",
        "body": "You could declare in the interface up-front all the properties that you plan to initialize, and use an index signature for the rest:\r\n```ts\r\ninterface I {\r\n\treadonly x: number;\r\n\treadonly y: number;\r\n\t[other: string]: number;\r\n}\r\n\r\nconst i: I = { x: 0, y: 0 };\r\ni.z = 4; // succeeds\r\ni.z = 5; // succeeds\r\n```\r\nOf course this means `z` will be mutable."
      },
      {
        "user": "JakeTunaley",
        "created_at": "2018-07-22T07:31:27Z",
        "body": "Something like this would be useful for gradually building up an object.\r\n\r\n```ts\r\ninterface SomeObject {\r\n    readonly n: number;\r\n    readonly isPositive: boolean;\r\n}\r\n\r\ninterface SomeEnhancedObject extends SomeObject {\r\n    readonly isNotPositive: boolean;\r\n}\r\n\r\ntype Mutable<T> = {\r\n    -readonly [P in keyof T]: T[P];\r\n};\r\n\r\nconst obj: SomeObject = {\r\n    n: Math.random() - 0.5,\r\n    isPositive: false\r\n};\r\n// We can't access object properties inside the object literal, so we have to do stuff like this\r\n(obj as Mutable<SomeObject>).isPositive = obj.n > 0;\r\n// But the initial value of isPositive: false was just there to get the compiler to be happy\r\n// What if we forgot to set it to the actual value?\r\n\r\n// The other way to do this is something like this:\r\nlet n = Math.random() - 0.5;\r\nconst obj2: SomeObject = {\r\n    n: n,\r\n    isPositive: n > 0\r\n};\r\n\r\n// The above is fine here, but it gets clunky with large interfaces, especially if\r\n// multiple properties depend on each other\r\nn = Math.random() - 0.5;\r\nconst isPositive = n > 0;\r\nconst obj3: SomeEnhancedObject = {\r\n    n: n,\r\n    isPositive: isPositive,\r\n    isNotPositive: !isPositive\r\n};\r\n\r\n// You can see how this doesn't scale well, because we're writing approx. twice the amount of\r\n// code we'd need to if objects could be built up over time\r\nconst obj4: Buildable<SomeEnhancedObject> = {\r\n    // \"Buildable\" is a hypothetical type that allows build-over-time behaviour\r\n    n: Math.random() - 0.5\r\n};\r\nobj4.isPositive = obj4.n > 0;\r\nobj4.isNotPositive = !obj4.isPositive;\r\nlet result: SomeEnhancedObject = obj4 as SomeEnhancedObject;\r\n\r\n// Currently the best approximation of this building pattern is something like this:\r\nconst obj5: Partial<Mutable<SomeEnhancedObject>> = {\r\n    n: Math.random() - 0.5\r\n};\r\nobj5.isPositive = obj5.n > 0;\r\nobj5.isNotPositive = !obj5.isPositive;\r\nresult = obj5 as SomeEnhancedObject;\r\n// But this doesn't give us type safety because this statement doesn't generate an error if it's\r\n// put before the built properties are set\r\n```"
      },
      {
        "user": "ORESoftware",
        "created_at": "2018-07-22T20:05:11Z",
        "body": "@andy-ms yeah in your example I want z to be immutable too. hence the question title - immutable/read-only index signature."
      },
      {
        "user": "typescript-bot",
        "created_at": "2018-08-01T00:26:22Z",
        "body": "Automatically closing this issue for housekeeping purposes. The issue labels indicate that it is unactionable at the moment or has already been addressed."
      }
    ]
  },
  {
    "number": 25599,
    "title": "Import a side-effects only module and generate ES6 style module importing syntax.",
    "created_at": "2018-07-12T07:51:20Z",
    "closed_at": "2018-07-13T01:46:56Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/25599",
    "body": "<!-- 🚨 STOP 🚨 𝗦𝗧𝗢𝗣 🚨 𝑺𝑻𝑶𝑷 🚨\r\n\r\nHalf of all issues filed here are duplicates, answered in the FAQ, or not appropriate for the bug tracker. Please read the FAQ first, especially the \"Common Feature Requests\" section.\r\n\r\n-->\r\n\r\n## Search Terms\r\n\r\nmodule; import; side-effects; es6 module\r\n\r\n## Suggestion\r\n\r\nBy now, tsc keeps the importing statement unchanged when compiling ts file to ES6 js.\r\nGiven a module, named ModuleA, its contents seem like:\r\n```js\r\n(function(){\r\n  var ModuleA = {\r\n    /* members */\r\n  };\r\n})();\r\n```\r\nIt also has a .d.ts file defined well.\r\nNext, in a ts file, we want to import it:\r\n```ts\r\n  import * as ModuleA from \"./Module\";\r\n\r\n  let v = new ModuleA.ClassFoo();\r\n```\r\nIn the meantime, the intelligense(of Visual studio code) works well when coding.\r\nBut when I compile it(target ES6, module-style ES6) and run. The browser hints that \"ClassFoo is not a constructor.\"\r\n\r\nTo fix it, I change the importing statement in *ts* file as:\r\n```ts\r\n  import \"./Module\"\r\n```\r\nIt got compile errors(and the intelligense didn't work anymore) but it can work in browser.\r\n\r\n## Use Cases\r\n\r\n* Want generating ES6 codes;\r\n* Use a non-ES6 style library, no export, but have corresponding .d.ts definitions.\r\n\r\n## Examples\r\n\r\nI met this problem when use library **konva** for 2D painting.\r\n\r\nReference codes:\r\n\r\nindex.html\r\n``` html\r\n<script type=\"module\">\r\n  import \"./main.js\";\r\n  main();\r\n</script>\r\n```\r\n\r\nmain.ts\r\n```ts\r\nimport \"./node_modules/konva/konva.js\";\r\nfunction main()\r\n{\r\n  let stage = new Konva.Stage();\r\n}\r\n```\r\n\r\nThe konva library is install from npm.\r\n\r\n## Checklist\r\n\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/25599/comments",
    "author": "shrinktofit",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2018-07-12T17:25:50Z",
        "body": "You might have better luck sharing this on StackOverflow. This is not a support forum, it is one for reporting compiler/language bugs and suggestions. \r\nIf you believe you are running into a compiler bug, please share a minimal repro project that demonstrates the issue you are running into and why you believe this is a compiler bug and not a declaration file issue or library usage problem."
      }
    ]
  },
  {
    "number": 25365,
    "title": "Are `Array.from()` and `Array.of()` typed correctly?",
    "created_at": "2018-07-02T15:32:26Z",
    "closed_at": "2018-07-17T21:15:42Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/25365",
    "body": "The following type signature looks wrong:\r\n\r\n```ts\r\ninterface ArrayConstructor {\r\n  from<T>(arrayLike: ArrayLike<T>): T[];\r\n}\r\n```\r\n\r\nIn plain JS, the class determines the type of the result:\r\n\r\n```text\r\n> SubclassOfArray.from(someIterable) instanceof SubclassOfArray\r\ntrue\r\n```\r\n\r\nSo maybe it should be typed like this?\r\n\r\n```ts\r\ninterface ArrayConstructor<T> {\r\n  from(arrayLike: ArrayLike<T>): T[];\r\n}\r\n```\r\n\r\nSimilar: `Array.of()`",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/25365/comments",
    "author": "rauschma",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2018-07-02T16:38:39Z",
        "body": "`ArrayConstructor` is the type of the global value `Array`, which certainly does produce an `Array` when calling `.from`. If someone else is using `ArrayConstructor` to represent some other type, they'd need to modify it appropriately"
      },
      {
        "user": "rauschma",
        "created_at": "2018-07-02T16:57:51Z",
        "body": "Ah, my bad. I wasn’t thinking clearly: I thought the constructor would pass on its type parameter to static members, too. Not true.\r\n\r\nBut this is still an issue:\r\n\r\n```ts\r\nclass Sub<T> extends Array<T> {\r\n}\r\nconst s = Sub.from([1, 2]);\r\n// Inferred:  s: number[]\r\n// Should be: s: Sub<number>\r\n```\r\n\r\nBut I don’t think it can be solved with the current type system. You’d need:\r\n\r\n```ts\r\nfrom<T>(arrayLike: ArrayLike<T>): this<T>;\r\n```"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2018-07-02T17:58:22Z",
        "body": "Yep, see #5863"
      },
      {
        "user": "typescript-bot",
        "created_at": "2018-07-17T21:15:42Z",
        "body": "Automatically closing this issue for housekeeping purposes. The issue labels indicate that it is unactionable at the moment or has already been addressed."
      }
    ]
  },
  {
    "number": 25272,
    "title": "Define an enum as the cartesian product of two enums. Is it possible?",
    "created_at": "2018-06-27T15:13:28Z",
    "closed_at": "2018-07-12T18:46:24Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/25272",
    "body": "Hi,\r\nI was wondering if the type system allows to achieve the following.\r\n\r\nSay I have two enums, `ReportType` and `AggregateBy`:\r\n\r\n```\r\nenum ReportType = {\r\n  ContentSummary,\r\n  VideoUsage\r\n}\r\n\r\nenum AggregateBy {\r\n   Day,\r\n   Month\r\n}\r\n```\r\nI'd like to be able to create a third enum obtained as the cartesian product of those two.\r\nThe result would be:\r\n\r\n```\r\n{\r\n   ContentSummaryDay\r\n   ContentSummaryMonth,\r\n   VideoUsageDay,\r\n   VideoUsageMonth\r\n}\r\n```\r\n\r\n\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/25272/comments",
    "author": "alexandro81",
    "comments": [
      {
        "user": "ghost",
        "created_at": "2018-06-27T15:20:51Z",
        "body": "Not automatically, but you could use `interface ReportAndAggregate { report: ReportType; aggregate: AggregateBy; }`, which is sometimes called a \"product type\" and whose set of possible values is the cartesian product of those two enums."
      },
      {
        "user": "alexandro81",
        "created_at": "2018-06-27T15:27:05Z",
        "body": "Yeah, I was thinking about something more generic, maybe using mapped types to define a `Product` type alias that takes 2 type parameters and builds a new type that is indeed the cartesian product of the values of the input types."
      },
      {
        "user": "ghost",
        "created_at": "2018-06-27T15:29:15Z",
        "body": "`interface Product<T, U> { first: T, second: U }`, or just `[T, U]`, would work for that, but I think it's less readable than using a named interface."
      },
      {
        "user": "typescript-bot",
        "created_at": "2018-07-12T18:46:23Z",
        "body": "Automatically closing this issue for housekeeping purposes. The issue labels indicate that it is unactionable at the moment or has already been addressed."
      }
    ]
  },
  {
    "number": 24951,
    "title": "keyof - conditional readonly | optional",
    "created_at": "2018-06-14T10:28:12Z",
    "closed_at": "2018-06-15T01:48:14Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/24951",
    "body": "Hi, I have a question with regards to `keyof` and if its possible to conditionally change the `readonly` and `optional` qualifiers on a property if the properties type `extends` that of another type. As an example, below I am attempting to map the boolean property `Foo.b` either `readonly` or `optional` leveraging type queries + `keyof`, along with a few attempts with the syntax to help illustrate the intent.\r\n\r\n```typescript\r\ntype Foo = {\r\n    a: number\r\n    b: boolean // wish to map as b?: boolean\r\n}\r\n\r\n// Bar<Foo> = { a: number, b: boolean }\r\ntype Bar <T> = { [K in keyof T]: T[K] }\r\n\r\n\r\n//  Bar<Foo> = { a?: number, b?: boolean }\r\ntype Bar <T> = { [K in keyof T]?: T[K] }\r\n\r\n\r\n// (SYNTAX ERROR) Bar<Foo> = { a: number, b?: boolean }\r\ntype Bar <T> = { [K in keyof T]   : T[K] extends boolean ? (T[K] ? ) : T[K] }\r\n//                              ^                                |\r\n//                              |                                |\r\n//                              +-------- move '?' here ---------+\r\n\r\n// (SYNTAX ERROR) Bar<Foo> = { a: number, readonly b: boolean }\r\ntype Bar <T> = {   [K in keyof T] : T[K] extends boolean ? (readonly T[K]) : T[K] }\r\n//               ^                                             |\r\n//               |                                             |\r\n//               +---------- move 'readonly' here -------------+\r\n```\r\n\r\nIs it possible to change the `readonly` and `optional` qualifiers from the results given from a type query?",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/24951/comments",
    "author": "sinclairzx81",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2018-06-14T17:34:10Z",
        "body": "You will need to filter the keys of the type first to extract the non-boolean members, then mark these as readonly.\r\n\r\n```ts\r\ntype BooleanPropertyKeys<T> = { [P in keyof T]: T[P] extends boolean ? P : never }[keyof T];\r\ntype ReadonlyBoolean<T> = Readonly<Pick<T, Extract<keyof T, BooleanPropertyKeys<T>>>> & Pick<T, Exclude<keyof T, BooleanPropertyKeys<T>>>;\r\n```\r\n"
      },
      {
        "user": "sinclairzx81",
        "created_at": "2018-06-15T05:35:22Z",
        "body": "**Solution**\r\n\r\nThe following is the full solution to this issue/question that seems to work well if anyone finds it helpful in future.\r\n\r\n```typescript\r\n/** Include property keys from T where the property is assignable to U */\r\ntype IncludePropertyKeys<T, U>  = { [P in keyof T]: T[P] extends U ? P : never}[keyof T]\r\n/** Excludes property keys from T where the property is assignable to U */\r\ntype ExcludePropertyKeys<T, U>  = { [P in keyof T]: T[P] extends U ? never: P}[keyof T]\r\n\r\n/** Includes properties from T where the property is assignable to U */\r\ntype IncludePropertyTypes<T, U> = { [K in IncludePropertyKeys<T, U>]: T[K] }\r\n/** Excludes properties from T where the property is assignable to U */\r\ntype ExcludePropertyTypes<T, U> = { [K in ExcludePropertyKeys<T, U>]: T[K] }\r\n\r\n/** Makes properties of type T optional where the property is assignable to U */\r\ntype OptionalPropertyType<T, U> = ExcludePropertyTypes<T, U> & Partial<IncludePropertyTypes<T, U>>\r\n/** Makes properties of type T readonly where the property is assignable to U */\r\ntype ReadonlyPropertyType<T, U> = ExcludePropertyTypes<T, U> & Readonly<IncludePropertyTypes<T, U>>\r\n\r\ninterface Foo {\r\n  a: boolean, // make optional\r\n  b: number, // make readonly\r\n  c: string\r\n}\r\n\r\n// type Bar = { a?: boolean, readonly b: number, c: string }\r\ntype Bar = ExcludePropertyTypes<ExcludePropertyTypes<Foo, number>, boolean> & // exclude numbers and booleans\r\n           Partial<IncludePropertyTypes<Foo, boolean>> &                      // re add booleans as partials\r\n           Readonly<IncludePropertyTypes<Foo, number>>                        // re add numbers as readonly\r\n           \r\n\r\n```"
      }
    ]
  },
  {
    "number": 24898,
    "title": "Types of property 'render' are incompatible.",
    "created_at": "2018-06-12T07:53:39Z",
    "closed_at": "2018-06-28T23:04:43Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/24898",
    "body": "Hey, so I am using ReactQuill as a component, but I am facing this error while using Typescript. Any suggestions for mitigation \r\n\r\nJSX element type 'ReactQuill' is not a constructor function for JSX elements.\r\n  Types of property 'render' are incompatible.\r\n    Type '() => ReactNode' is not assignable to type '{ (): false | Element | null; (): ReactNode; }'.\r\n      Type 'ReactNode' is not assignable to type 'false | Element | null'.\r\n        Type 'undefined' is not assignable to type 'false | Element | null'.",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/24898/comments",
    "author": "cutoz",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2018-06-12T15:56:25Z",
        "body": "You might have better luck sharing this on StackOverflow. This is not a support forum, it is one for reporting compiler/language bugs and suggestions. \r\nIf you believe you are running into a compiler bug, please share a minimal repro project that demonstrates the issue you are running into and why you believe this is a compiler bug and not a declaration file issue or library usage problem."
      },
      {
        "user": "typescript-bot",
        "created_at": "2018-06-28T23:04:43Z",
        "body": "Automatically closing this issue for housekeeping purposes. The issue labels indicate that it is unactionable at the moment or has already been addressed."
      }
    ]
  },
  {
    "number": 24478,
    "title": "type incorrectly resolves when used recursively",
    "created_at": "2018-05-29T23:04:55Z",
    "closed_at": "2018-06-13T00:49:51Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/24478",
    "body": "\r\n```\r\nexport type RCssSelector<Selecotor extends string, Property> = {\r\n    [name in Selecotor]?: Property & RCssSelector<Selecotor, Property>;\r\n};\r\nexport type RCss<Selecotor extends string, Property> = Property & RCssSelector<Selecotor, Property>;\r\nexport type t2 = RCss<'hover', { color?: string }>;\r\n/**\r\n * check error\r\n */\r\nexport const a1: t2 = { hover: { f: 1 } };\r\n/**\r\n * check correct\r\n */\r\nexport const a2: t2 = { hover: { color: 'red', f: 1 } };\r\n```\r\nMy question is why a2 is correct\r\n```\r\nexport const a2: t2 = { hover: { color: 'red', f: 1 } };\r\n```",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/24478/comments",
    "author": "fastspeeed",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2018-05-29T23:52:28Z",
        "body": "As the error message indicates:\r\n> Type '{ hover: { f: number; }; }' is not assignable to type 'RCss<\"hover\", { color?: string; }>'.\r\n>  Type '{ hover: { f: number; }; }' is not assignable to type 'RCssSelector<\"hover\", { color?: string; }>'.\r\n>    Types of property 'hover' are incompatible.\r\n>      Type '{ f: number; }' has no properties in common with type 'RCss<\"hover\", { color?: string; }>'."
      },
      {
        "user": "mhegazy",
        "created_at": "2018-05-29T23:52:36Z",
        "body": "You might have better luck sharing this on StackOverflow. This is not a support forum, it is one for reporting compiler/language bugs and suggestions. \r\nIf you believe you are running into a compiler bug, please share a minimal repro project that demonstrates the issue you are running into and why you believe this is a compiler bug and not a declaration file issue or library usage problem."
      },
      {
        "user": "typescript-bot",
        "created_at": "2018-06-13T00:49:51Z",
        "body": "Automatically closing this issue for housekeeping purposes. The issue labels indicate that it is unactionable at the moment or has already been addressed."
      }
    ]
  },
  {
    "number": 24401,
    "title": "Attach type parameter to (non-method) function-valued property in object type",
    "created_at": "2018-05-25T05:36:29Z",
    "closed_at": "2018-06-08T15:57:32Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/24401",
    "body": "## Search Terms\r\ngeneric in object key type alias parameter\r\n\r\n## Suggestion\r\n\r\nMy apologies if this has been suggested before or if there's already a way to do it that I'm not aware of... I wasn't exactly sure how to search for this issue. But, basically, here's the situation:\r\n\r\nSuppose I have an interface/object type like:\r\n\r\n```ts\r\ninterface X {\r\n  applyPreMiddleware<T extends SomeType = SomeType>(it: T, opts: B): Promise<T | undefined>\r\n  applyPostMiddleware<T extends SomeTypePostProcessing = SomeTypePostProcessing>(it: T, opts: B): Promise<T | undefined>\r\n}\r\n\r\n// Note: SomeTypePostProcessing extends SomeType\r\n```\r\n\r\nThe `applyPreMiddleware` and `applyPostMiddleware` accept an object and apply registered middleware functions for objects of that type. Now, suppose I want to pull out the common signature, say, to use for an underlying function. Something like: \r\n\r\n```ts\r\ntype applyMiddleware<T extends SomeType = SomeType> = \r\n  (it: T, opts: B) => Promise<T | undefined>\r\n```\r\n\r\nWhat I'd like is a way to use this common type to define the `interface X` above, so I don't have to repeat the common bits. Something like:\r\n\r\n```ts\r\ninterface X {\r\n  applyPreMiddleware<T extends SomeType = SomeType>: applyMiddleware<T>;\r\n  applyPostMiddleware<T extends SomeTypePostProcessing = SomeTypePostProcessing>: applyMiddleware<T>;\r\n}\r\n```\r\n\r\nBasically, I'm trying to reference the type alias instead of putting the function signature inline. When I try the above, though, I get a syntax error.\r\n\r\nNote: the generic parameter has to be on the methods, not the interface, because the value for `T` can be different each time each method is called.\r\n\r\n## Checklist\r\n\r\nMy suggestion meets these guidelines:\r\n* [x] This wouldn't be a breaking change in existing TypeScript / JavaScript code\r\n* [x] This wouldn't change the runtime behavior of existing JavaScript code\r\n* [x] This could be implemented without emitting different JS based on the types of the expressions\r\n* [x] This isn't a runtime feature (e.g. new expression-level syntax)\r\n\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/24401/comments",
    "author": "ethanresnick",
    "comments": [
      {
        "user": "DanielRosenwasser",
        "created_at": "2018-05-25T07:42:29Z",
        "body": "Keep in mind that the generic method signature\r\n\r\n```ts\r\n{\r\n  applyPreMiddleware<T extends SomeType = SomeType>(it: T, opts: B): Promise<T | undefined>\r\n}\r\n```\r\n\r\nis mostly just syntactic sugar for the following property declaration:\r\n\r\n```ts\r\n{\r\n  applyPreMiddleware: <T extends SomeType = SomeType>(it: T, opts: B) => Promise<T | undefined>\r\n}\r\n```\r\n\r\nSo I think you want this:\r\n\r\n```ts\r\ntype ApplyMiddleware<Constraint> = \r\n  <T extends Constraint = Constraint>(it: T, opts: B) => Promise<T | undefined>\r\n\r\ninterface X {\r\n  applyPreMiddleware: ApplyMiddleware<SomeType>;\r\n  applyPostMiddleware: ApplyMiddleware<SomeTypePostProcessing>;\r\n}\r\n```"
      },
      {
        "user": "ethanresnick",
        "created_at": "2018-05-25T07:57:05Z",
        "body": "```ts\r\n\r\ninterface X {\r\n  applyPreMiddleware: ApplyMiddleware<SomeType>;\r\n  applyPostMiddleware: ApplyMiddleware<SomeTypePostProcessing>;\r\n}\r\n```\r\n\r\nThanks @DanielRosenwasser.\r\n\r\nIf I'm understanding correctly, though, I don't think your suggestion is exactly what I'm asking for. In particular, I want to allow the user of the `X` to set the parameter at each call site of one of the `applyMiddleware` methods (e.g., so they get a more specific Promise out); in your version, though, the value for the parameters seems to be set once and forever in the definition of `X`."
      },
      {
        "user": "typescript-bot",
        "created_at": "2018-06-08T15:57:31Z",
        "body": "Automatically closing this issue for housekeeping purposes. The issue labels indicate that it is unactionable at the moment or has already been addressed."
      },
      {
        "user": "ethanresnick",
        "created_at": "2018-06-09T01:08:26Z",
        "body": "@DanielRosenwasser Should this be relabeled/reopened? I'm pretty sure your suggestion doesn't work exactly for my use case."
      }
    ]
  },
  {
    "number": 24318,
    "title": "Recursive mapped type inference not working as expected",
    "created_at": "2018-05-22T14:26:41Z",
    "closed_at": "2018-05-22T16:24:12Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/24318",
    "body": "**TypeScript Version:**  2.9.1-insiders.20180521\r\n\r\n<!-- Search terms you tried before logging this (so others can find this issue more easily) -->\r\n**Search Terms:** \r\nrecursive inference\r\n\r\n**Code**\r\n\r\n```ts\r\ntype Entity<T> = T & { _: \"Entity\" };\r\n\r\ntype MyNestedType = {\r\n  something0: number;\r\n  level1?: {\r\n    something1: number;\r\n    level2?: {\r\n      something2: number;\r\n      level3?: {\r\n        something3: number;\r\n        property: string;\r\n      };\r\n    };\r\n  };\r\n  level1Array?: Entity<\r\n    {\r\n      something1: number;\r\n      level2Array?: Entity<\r\n        {\r\n          something2: number;\r\n          level3Array?: Entity<\r\n            {\r\n              something3: number;\r\n              property: string;\r\n            }[]\r\n          >;\r\n        }[]\r\n      >;\r\n    }[]\r\n  >;\r\n};\r\n\r\ntype EverythingPresent<T> = { [P in keyof T]-?: EverythingPresent<T[P]> };\r\ndeclare var everythingPresent: EverythingPresent<MyNestedType>;\r\neverythingPresent.level1;\r\neverythingPresent.level1.level2;\r\neverythingPresent.level1.level2.level3;\r\neverythingPresent.level1Array[0].something1;\r\neverythingPresent.level1Array[0].level2Array[0].something2;\r\neverythingPresent.level1Array[0].level2Array[0].level3Array[0].something3;\r\n\r\ntype OnlyEntitiesPresent<T> = {\r\n  [P in keyof T]-?: T[P] extends Entity<infer U> | undefined\r\n    ? Entity<\r\n        U extends Array<infer R>\r\n          ? Array<OnlyEntitiesPresent<R>>\r\n          : OnlyEntitiesPresent<U>\r\n      >\r\n    : T[P]\r\n};\r\ndeclare var onlyArraysPresent: OnlyEntitiesPresent<MyNestedType>;\r\nonlyArraysPresent.level1;\r\nonlyArraysPresent.level1.level2;\r\nonlyArraysPresent.level1.level2.level3; // This errors as expected\r\nonlyArraysPresent.level1Array[0].something1;\r\nonlyArraysPresent.level1Array[0].level2Array[0].something2; // This should not error\r\nonlyArraysPresent.level1Array[0].level2Array[0].level3Array[0].something3; // This should not error\r\n\r\n```\r\n\r\n**Expected behavior:**\r\nI should only get an error where expected (1 line)\r\n\r\n**Actual behavior:**\r\nI get errors on the last 2 lines as well\r\n\r\nJust to note - in 2.8.3 I also get errors for the last 3 lines of everythingPresent - so some improvements have been made but it's still not as expected",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/24318/comments",
    "author": "massimonewsuk",
    "comments": [
      {
        "user": "massimonewsuk",
        "created_at": "2018-05-22T14:56:26Z",
        "body": "Here are some examples where it works as expected\r\n```ts\r\n// Normal nested stuff\r\ntype Node = {\r\n    always: {\r\n        property: string;\r\n    }\r\n    maybe?: {\r\n        property: string;\r\n    }\r\n    leaf?: Node;\r\n};\r\n\r\ntype EverythingPresent<T> = { [P in keyof T]-?: EverythingPresent<T[P]> };\r\ndeclare var everythingPresent: EverythingPresent<Node>;\r\neverythingPresent.maybe.property;\r\neverythingPresent.leaf.maybe.property;\r\neverythingPresent.leaf.leaf.maybe.property;\r\neverythingPresent.leaf.leaf.leaf.maybe.property;\r\n\r\ntype OnlyLeafsPresent<T> = {\r\n  [P in keyof T]-?: T[P] extends Node\r\n    ? OnlyLeafsPresent<Node>\r\n    : T[P]\r\n};\r\ndeclare var onlyLeafsPresent: OnlyLeafsPresent<Node>;\r\n// These examples work fine\r\nonlyLeafsPresent.maybe.property;\r\nonlyLeafsPresent.leaf.maybe.property;\r\nonlyLeafsPresent.leaf.leaf.maybe.property;\r\nonlyLeafsPresent.leaf.leaf.leaf.maybe.property;\r\n\r\n// Generic nested stuff\r\ntype GenericNode<T> = {\r\n    always: {\r\n        property: string;\r\n    }\r\n    maybe?: {\r\n        property: T;\r\n    }\r\n    leaf?: GenericNode<T>;\r\n};\r\ndeclare var everythingPresent2: EverythingPresent<GenericNode<string>>;\r\neverythingPresent2.maybe.property;\r\neverythingPresent2.leaf.maybe.property;\r\neverythingPresent2.leaf.leaf.maybe.property;\r\neverythingPresent2.leaf.leaf.leaf.maybe.property;\r\n\r\ntype OnlyLeafsPresentGeneric<T> = {\r\n    [P in keyof T]-?: T[P] extends GenericNode<infer U>\r\n      ? OnlyLeafsPresentGeneric<GenericNode<U>>\r\n      : T[P]\r\n  };\r\ndeclare var onlyLeafsPresent2: OnlyLeafsPresentGeneric<GenericNode<string>>;\r\n// These examples work fine\r\nonlyLeafsPresent2.maybe.property;\r\nonlyLeafsPresent2.leaf.maybe.property;\r\nonlyLeafsPresent2.leaf.leaf.maybe.property;\r\nonlyLeafsPresent2.leaf.leaf.leaf.maybe.property;\r\n\r\n```"
      },
      {
        "user": "ghost",
        "created_at": "2018-05-22T15:26:04Z",
        "body": "Note: since `Node` has all-optional properties, everything extends it, so the conditional types will always use the true branch. Could you update your example to avoid that pitfall?"
      },
      {
        "user": "massimonewsuk",
        "created_at": "2018-05-22T16:10:34Z",
        "body": "@andy-ms Thanks, that's cleared things up a bit... it seems that the `Array` is a special case where things aren't quite working as expected... the examples with `Node` all work fine now"
      },
      {
        "user": "ghost",
        "created_at": "2018-05-22T16:14:49Z",
        "body": "It looks like you can fix that by changing `T[P] extends Array<infer U>` to `T[P] extends Array<infer U> | undefined` -- since `T[P]` still contains `undefined` even though you removed optionality from the property."
      },
      {
        "user": "massimonewsuk",
        "created_at": "2018-05-22T16:24:12Z",
        "body": "You're right - I could have sworn I tried that and it never helped.\r\n\r\nI've updated my original code example to what I actually wanted to achieve.\r\n\r\nIt seems to work fine in 2.9.1 so I'm closing the issue. Sorry for taking your time!"
      },
      {
        "user": "massimonewsuk",
        "created_at": "2018-05-22T16:59:15Z",
        "body": "@andy-ms so I've basically replicated the issue I was originally facing. If you had a moment to take a look, here's the code example that I'm having issues with.\r\n\r\n```ts\r\n// Entities\r\ntype Order = {\r\n    id: number;\r\n    customer?: Entity<Customer>;\r\n    lineItems?: Entity<OrderLineItem[]>;\r\n};\r\n\r\ntype Customer = {\r\n    name: string;\r\n    bestFriend?: Entity<Customer>;\r\n    legacyData?: {\r\n        registered: boolean;\r\n    };\r\n};\r\n\r\ntype OrderLineItem = {\r\n    quantity: number;\r\n    options?: Entity<OrderLineItemOption[]>;\r\n    item?: Entity<Item>;\r\n};\r\n\r\ntype OrderLineItemOption = {\r\n    colour: string;\r\n};\r\n\r\ntype Item = {\r\n    description: string;\r\n};\r\n\r\n// Type helpers\r\ntype PropertiesWithoutNevers<T, U> = {\r\n    [P in keyof T]: T[P] extends U ? never : P\r\n}[keyof T];\r\n\r\ntype Mandatory<T> = { [P in keyof T]-?: T[P] };\r\n\r\ntype Entity<T> = T & { _: \"Entity\" };\r\n\r\ntype EagerLoadedRelations<TEntity> = Pick<\r\n  Mandatory<TEntity>,\r\n  PropertiesWithoutNevers<\r\n    {\r\n      [P in keyof TEntity]-?: TEntity[P] extends Entity<infer TRelation> | undefined\r\n        ? Entity<TRelation extends Array<infer TOneToMany> ? Array<Eager<TOneToMany>> : Eager<TRelation>>\r\n        : never\r\n    },\r\n    TEntity\r\n  >\r\n>;\r\n\r\ntype NormalFields<TEntity> = Pick<\r\n  TEntity,\r\n  PropertiesWithoutNevers<\r\n    { [P in keyof TEntity]-?: TEntity[P] extends Entity<infer U> | undefined ? never : TEntity[P] },\r\n    TEntity\r\n  >\r\n>;\r\n\r\ntype Eager<T> = EagerLoadedRelations<T> & NormalFields<T>;\r\n\r\n\r\n// Without Eager<T> - everything works as expected\r\ndeclare var order: Order;\r\norder.id; // works as expected\r\norder.customer.name; // error as expected\r\norder.lineItems[0].quantity; // error as expected\r\n\r\n// With Eager<T> - Eager<T> doesn't seem to apply deeper than 1 level\r\ndeclare var eagerOrder: Eager<Order>;\r\neagerOrder.id; // works as expected\r\neagerOrder.customer.name; // works as expected\r\neagerOrder.customer.bestFriend.name; // ERROR - doesn't work - bestFriend should be eager loaded\r\neagerOrder.customer.legacyData.registered; // errors as expected\r\neagerOrder.lineItems[0].quantity; // works as expected\r\neagerOrder.lineItems[0].item.description; // ERROR - doesn't work - items should be eager loaded\r\neagerOrder.lineItems[0].options[0].colour; // ERROR - doesn't work - options should be eager loaded\r\n\r\n```"
      },
      {
        "user": "ghost",
        "created_at": "2018-05-22T17:17:53Z",
        "body": "Some things I noticed:\r\n* In the above example, it looks like `NormalFields` can be removed without affecting the erroring examples.\r\n* `EagerLoadedRelations` is a `Pick`. `Pick` doesn't have any deep effects, it just picks certain fails. `Mandatory` also doesn't work deeply, so it will only have an effect on first-level fields, not `eagerOrder.customer.bestFriend`.\r\n* The type of values in the first argument to `PropertiesWithoutNevers` only matters to the extent that it extends `TEntity` or not. You can even see when hovering over `eagerOrder` (after removing `NormalFields`) that it's just `var eagerOrder: Pick<Mandatory<Order>, \"customer\" | \"lineItems\">`."
      }
    ]
  },
  {
    "number": 24216,
    "title": "Strict keys in HashMap",
    "created_at": "2018-05-17T19:45:02Z",
    "closed_at": "2018-06-02T19:56:07Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/24216",
    "body": "It's very powerful feature in typescript by strict value type in HashMap declaration. However looks like the same feature is missing for key values. I tried defined as type of string or enums but getting errors.\r\n\r\n\r\n```\r\ntype Keys1 = \"key1\" | \"key2\";\r\nenum Keys2 {key1, key2}\r\nconst map1: {[key: string]: Keys1 | null} = {\r\n    \"key1\": \"key1\",\r\n    \"key2\": \"key2\",\r\n    \"key3\": \"key3\"  //That is working!!!\r\n                    // Property '\"key3\"' is incompatible with index signature.\r\n                    // Type '\"key3\"' is not assignable to type '\"key1\" | \"key2\" | null'.\r\n};\r\n\r\nconst map2: {[key: string]: Keys1 | null} = {\r\n    \"key1\": \"key1\",\r\n    \"key2\": \"key2\",\r\n    \"key3\": null //I would like to strct and get error\r\n};\r\n\r\nconst map3: {[key: Keys1]: boolean} = {  //[ts] An index signature parameter type cannot be a union type. \r\n                                        //Consider using a mapped object type instead.\r\n                                        //(parameter) key: \"key1\" | \"key2\"\r\n    \"key3\": true\r\n};\r\n\r\nconst map4: {[key: Keys2]: boolean} = {  //[ts] An index signature parameter type must be 'string' or 'number'.\r\n                                        //(parameter) key: Keys2\r\n    \"key3\": true\r\n};\r\n```",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/24216/comments",
    "author": "dgofman-equinix",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2018-05-17T19:51:22Z",
        "body": "Use mapped types:\r\n\r\n```ts\r\nconst map3: { [key in Keys1]: boolean } = {\r\n    \"key3\": true\r\n};\r\n\r\nconst map4: { [key in Keys2]?: boolean } = {  \r\n    [Keys2.key1]: true\r\n};\r\n```"
      },
      {
        "user": "dgofman-equinix",
        "created_at": "2018-05-17T23:56:06Z",
        "body": "Thank you! I didn't know we can use \"in\" as data type declaration."
      },
      {
        "user": "typescript-bot",
        "created_at": "2018-06-02T19:56:07Z",
        "body": "Automatically closing this issue for housekeeping purposes. The issue labels indicate that it is unactionable at the moment or has already been addressed."
      }
    ]
  },
  {
    "number": 24092,
    "title": "input file override crazytown",
    "created_at": "2018-05-14T02:46:07Z",
    "closed_at": "2018-05-14T16:49:58Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/24092",
    "body": "I have this config:\r\n\r\n```json\r\n{\r\n  \"compilerOptions\": {\r\n    \"outDir\":\"dist\",\r\n    \"allowJs\": false,\r\n    \"pretty\": true,\r\n    \"skipLibCheck\": true,\r\n    \"declaration\": true,\r\n    \"baseUrl\": \".\",\r\n    \"target\": \"es6\",\r\n    \"module\": \"commonjs\",\r\n    \"noImplicitAny\": true,\r\n    \"removeComments\": true,\r\n    \"allowUnreachableCode\": true,\r\n    \"lib\": [\r\n      \"es2015\",\r\n      \"es2016\",\r\n      \"es2017\"\r\n    ]\r\n  },\r\n  \"compileOnSave\": false,\r\n  \"include\": [\r\n    \"src\"\r\n  ]\r\n}\r\n```\r\n\r\nI keep getting this error:\r\n\r\n> error TS5055: Cannot write file '/Users/alexamil/WebstormProjects/oresoftware/fly/dist/fly.d.ts' because it would overwrite input file.\r\n\r\n\r\nIt's driving me batty lol. `tsc` should know that the `dist` dir is the destination, so no input files should come from there, right? not only that, but the `include` is set to `src` in the config.\r\n\r\n\r\nhere are my versions:\r\n```bash\r\nnodejs version: v9.11.1\r\nnpm version: 5.6.0\r\ntypescript version: Version 2.8.3\r\n```\r\n\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/24092/comments",
    "author": "ORESoftware",
    "comments": [
      {
        "user": "ghost",
        "created_at": "2018-05-14T15:32:58Z",
        "body": "You probably imported from `dist` at some point. Include doesn't specify the files to be included (Microsoft/TypeScript-Handbook#692), it specifies the *root* files."
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2018-05-14T16:49:58Z",
        "body": "To expedite the triage process, we need everyone to follow the issue template and instructions.\r\n\r\nWhen you clicked \"Create New Issue\", the issue form was pre-populated with a template and some instructions. We need you to read those instructions *completely*, follow them, and then fill in *all* the fields in that template.\r\n\r\nWe are not able to assist with issues that don't follow the template instructions as they represent a significantly larger amount of work compared to issues which are correctly specified. Thank you for understanding."
      },
      {
        "user": "ORESoftware",
        "created_at": "2018-05-14T17:18:24Z",
        "body": "@andy-ms thanks for info, yeah, I think in my tests, I imported from `dist`. damn."
      }
    ]
  },
  {
    "number": 24088,
    "title": "how to annotation function's input arguments?",
    "created_at": "2018-05-13T12:08:39Z",
    "closed_at": "2018-05-14T01:17:23Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/24088",
    "body": "```typescript\r\nimport * as R from \"ramda\";\r\nimport * as _ from \"lodash\";\r\n\r\nlet functionalLib = function () {\r\n    // Given data:\r\n    let students = ['Rosser', 'Turing', 'Kleene', 'Church'];\r\n    let grades = [80, 100, 90, 99];\r\n\r\n    const smartestStudent: (k: string[], v: number[]) => string =\r\n        R.compose</**/any/**/, any, any[], any[], string[], string>(\r\n            R.head,\r\n            R.pluck(0),\r\n            R.reverse,\r\n            R.sortBy(R.last),\r\n            R.zip);\r\n\r\n    let result = smartestStudent(students, grades); //-> 'Turing'\r\n    console.log(result, 'Turing');\r\n}\r\n```\r\nthe `/**/any/**/` should be function's input arguments annotation ` (k: string[], v: number[]) `, but it seem have no way to do this?",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/24088/comments",
    "author": "xp44mm",
    "comments": [
      {
        "user": "bcherny",
        "created_at": "2018-05-13T18:45:56Z",
        "body": "@xp44mm This looks like a support question, and so belongs on Stack Overflow. I suggest closing this issue and posting your question there. That said, this looks like an issue with Ramda's typings, or the way you're using them, and not with TypeScript itself."
      },
      {
        "user": "xp44mm",
        "created_at": "2018-05-14T01:17:13Z",
        "body": "typescript no way to express **parameters list**?"
      }
    ]
  },
  {
    "number": 23859,
    "title": "Language Service API should allow to remove newline before interface declaration opening curly bracket",
    "created_at": "2018-05-03T12:03:47Z",
    "closed_at": "2018-05-04T07:48:07Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/23859",
    "body": "I'm using `typescript-formatter`, which says that any issues regarding TS formatting should be opened here.\r\n\r\nIt should be possible to convert\r\n```\r\nexport interface AdminForDetails\r\n{\r\n  UserID: number;\r\n  AdminFor: number;\r\n  Hash: string;\r\n}\r\n```\r\nto:\r\n```\r\nexport interface AdminForDetails {\r\n  UserID: number;\r\n  AdminFor: number;\r\n  Hash: string;\r\n}\r\n```",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/23859/comments",
    "author": "Maximaximum",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2018-05-03T16:08:30Z",
        "body": "Do you have `placeOpenBraceOnNewLineForFunctions` option set to `true`? if so set it to `false`."
      },
      {
        "user": "Maximaximum",
        "created_at": "2018-05-04T06:38:48Z",
        "body": "I've set it to false, but nothing changes"
      },
      {
        "user": "Maximaximum",
        "created_at": "2018-05-04T07:48:07Z",
        "body": "I'm sorry, It seems like the formatter was never actually run. Everything works now the way it's expected"
      }
    ]
  },
  {
    "number": 23853,
    "title": "[questions] is there any easy way to case a union type?",
    "created_at": "2018-05-03T06:11:42Z",
    "closed_at": "2018-05-03T06:46:13Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/23853",
    "body": "Hello, I had several situations that the variable is a type like `string | string[]` or `customerType | customerType[]`. \r\n\r\nWhen I have this type and want to pass it to a string or string[] value, I always get an error `Type 'string | string[]' is not assignable to type 'string[]'.\r\n        Type 'string' is not assignable to type 'string[]'.`\r\n\r\nI know this is because `string | string[]` is not compatible with `string[]`, but is there any easy way to cast `string | string[]` to `string[]`?",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/23853/comments",
    "author": "leozhao0709",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2018-05-03T06:46:07Z",
        "body": "It looks like this is a question rather than a bug report. This issue tracker is for tracking bugs and active work on TypeScript *itself*, rather than a general forum for programmers using TypeScript to get help or ask questions."
      }
    ]
  },
  {
    "number": 23773,
    "title": "Inline cast in function parameter",
    "created_at": "2018-04-30T05:47:10Z",
    "closed_at": "2018-05-14T16:09:50Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/23773",
    "body": "I am using D3 library  and prefer using strong type in the callback function. In case JSON parameters is changing I can refactor my code.\r\n\r\nIn the D3 one of the overload function \"attr\" defined as:\r\n\r\n```\r\n/**\r\n     * Sets the value of the attribute with the specified name for the selected elements and returns this selection.\r\n     * The value for the individual selected elements is determined by the value function.\r\n     *\r\n     * @param name Name of the attribute\r\n     * @param value A value function which is evaluated for each selected element, in order, being passed the current datum (d),\r\n     * the current index (i), and the current group (nodes), with this as the current DOM element (nodes[i]).  A null value will clear the attribute.\r\n     */\r\nattr(name: string, value: ValueFn<GElement, Datum, string | number | boolean | null>): this;\r\n```\r\n\r\nSo, function parameter may accept:\r\n\"ValueFn<BaseType, {}, string\" //is JSON Object\r\nor \"number\" or \"boolean\" or \"null\"\r\n\r\nFor a JSON argument I defined a custom type\r\n\r\ntype **DefaultState** = {\r\n                **source**: {x: 10, y: 100},\r\n                **target**: {x: 20, y: 300}\r\n            };\r\n\r\nNow I would like to cast this argument in my callback function. Currently my workaround using two lines.\r\n\r\nd3.select(\"body\").attr(\"path\", (val:**any**):string => {\r\n                    let d = val as **DefaultState**;\r\n                    return \"M2\" + d.**source**.x + \",\" + d.**source**.y + \"L\" + d.**target**.x + \",\" + d.**target**.y;\r\n                })\r\n\r\nBut I would prefer using inline casting:\r\nd3.select(\"body\").attr(\"path\", (d:**DefaultState**):string => {\r\n                    return \"M2\" + d.source.x + \",\" + d.source.y + \"L\" + d.target.x + \",\" + d.target.y;\r\n                })\r\n\r\nor\r\n\r\nd3.select(\"body\").attr(\"path\", (d:**any** as **DefaultState**):string => {\r\n                    return \"M2\" + d.source.x + \",\" + d.source.y + \"L\" + d.target.x + \",\" + d.target.y;\r\n                })\r\n\r\nUnfortunately I am getting an error:\r\n\r\n[ts]\r\nArgument of type '(d: DefaultState) => string' is not assignable to parameter of type 'ValueFn<BaseType, {}, string | number | boolean | null>'.\r\n  Types of parameters 'd' and 'datum' are incompatible.\r\n    Type '{}' is not assignable to type 'DefaultState'.\r\n      Property 'source' is missing in type '{}'.\r\n\r\n\r\nCan someone give me a solution. Thanks!",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/23773/comments",
    "author": "dgofman-equinix",
    "comments": [
      {
        "user": "j-oliveras",
        "created_at": "2018-04-30T06:29:29Z",
        "body": "Most likely, this is the effect of strictFunctionTypes (#18654). You can try disabling it."
      },
      {
        "user": "dgofman-equinix",
        "created_at": "2018-04-30T15:15:10Z",
        "body": "This issue in Visual Studio Code. And looks like an IDE is not reading setting from tsconfig.json"
      },
      {
        "user": "typescript-bot",
        "created_at": "2018-05-14T16:09:49Z",
        "body": "Automatically closing this issue for housekeeping purposes. The issue labels indicate that it is unactionable at the moment or has already been addressed."
      }
    ]
  },
  {
    "number": 23710,
    "title": "nested namespace issue in different files",
    "created_at": "2018-04-26T16:04:49Z",
    "closed_at": "2018-05-11T15:48:21Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/23710",
    "body": "**TypeScript Version:**  2.8.3\r\n\r\n**Code**\r\n\r\na.ts\r\n```ts\r\nnamespace N{\r\n    import C = N.N2.C;\r\n}\r\n```\r\n\r\nb.ts\r\n```ts\r\nnamespace N.N2{\r\n    export class C{}\r\n}\r\n```\r\nIt's will be ok, no error happens.\r\n\r\nBUT!!!!!!!!!!!!!\r\n\r\na.ts add some importing code  out of namespace N, like this: \r\n```ts\r\nimport * as path from 'path';\r\nnamespace N{\r\n    import C = N.N2.C;\r\n}\r\n```\r\nit will report  TS2694: Namespace 'N' has no exported member 'N2'\r\n\r\nwhen I try to moving import statement into namespace 'N', like this: \r\n```ts\r\nnamespace N{\r\n    import * as path from 'path';\r\n    import C = N.N2.C;\r\n}\r\n```\r\n\r\nthe TS2694: Namespace 'N' has no exported member 'N2' gone, and another like \"TS1147: Import declarations in a namespace cannot reference a module.\" happen",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/23710/comments",
    "author": "CGQAQ",
    "comments": [
      {
        "user": "ghost",
        "created_at": "2018-04-26T16:09:16Z",
        "body": "When a file is a module (contains imports/exports), everything inside that file is in a module scope. So the `namespace N` appearing after an import is a local variable and unrelated to the global `N`."
      },
      {
        "user": "CGQAQ",
        "created_at": "2018-04-26T16:16:54Z",
        "body": "So  how do I use class C inside of file a.ts,  import from  seems not gonna work"
      },
      {
        "user": "ghost",
        "created_at": "2018-04-26T16:18:33Z",
        "body": "You can still access the global `N` as long as you don't shadow it with a local `N`."
      },
      {
        "user": "CGQAQ",
        "created_at": "2018-04-26T16:28:19Z",
        "body": "but I couldn't access global N,  I tried to \r\n```ts\r\nimport * as path from 'path';\r\nimport GN = N;\r\nnamespace N{\r\n    import C = GN.N2.C;\r\n}\r\n```\r\nsitll had the same issue  TS2694: Namespace 'N' has no exported member 'N2'\r\n\r\naliasing seems not work.\r\n\r\n\r\nand \r\n```ts\r\nimport * as path from 'path';\r\nconst/let GN = N;\r\nnamespace N{\r\n    import C = GN.N2.C;\r\n}\r\n```\r\nit said TS2503:  Cannot find Namespace 'GN'"
      },
      {
        "user": "CGQAQ",
        "created_at": "2018-04-26T16:38:45Z",
        "body": "How can I use class 'c' in namespace 'N' of a.ts anyhow? or it's no way to do it?"
      },
      {
        "user": "ghost",
        "created_at": "2018-04-26T16:47:15Z",
        "body": "The problem is that you declared a local `N` in `a.ts` that shadows the global `N`. Just avoid declaring `namespace N` in a local scope."
      },
      {
        "user": "CGQAQ",
        "created_at": "2018-04-26T16:53:13Z",
        "body": "But it's just nesting relation like c#, avoid this, I don't think we need namespace in the ts.\r\n\r\nthank you for answering me, have a good day!"
      },
      {
        "user": "typescript-bot",
        "created_at": "2018-05-11T15:48:21Z",
        "body": "Automatically closing this issue for housekeeping purposes. The issue labels indicate that it is unactionable at the moment or has already been addressed."
      }
    ]
  },
  {
    "number": 23670,
    "title": "static return might fail with switch statement",
    "created_at": "2018-04-24T22:42:15Z",
    "closed_at": "2018-04-25T18:39:50Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/23670",
    "body": "I have this:\r\n\r\n```js\r\nconst onUpdate = function (v: string, o: any) : Promise<any> {\r\n  \r\n  const finalName = String(v || '').split('.')[1]; // collection name\r\n  const _id = o && o.o2 && o.o2._id;\r\n  let key;\r\n  \r\n  switch (finalName) {\r\n    \r\n    case 'categories':      \r\n      return Category.findOne({_id}).exec().then(function (cat: any) {\r\n         // ....\r\n      });\r\n    \r\n    case 'acquisitions':\r\n        return Acquisition.findOne({_id}).exec().then(function (acq: any) {\r\n         // ...\r\n      });\r\n    \r\n    case 'functionalTeams':\r\n      return FunctionalGroup.findOne({_id}).exec().then(function (ft: any) {\r\n           // ...\r\n      });\r\n    \r\n    default:\r\n      log.error('document collection did not match a pre-defined name');\r\n      // nothing is returned here, but can TS check to see if it does/doesn't\r\n  }\r\n  \r\n};\r\n```\r\n\r\ncan TypeScript check to see if a Promise fails to be returned in the default or after the switch statement? Right now it's compiling even though a Promise is not returned in all cases.",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/23670/comments",
    "author": "ORESoftware",
    "comments": [
      {
        "user": "ghost",
        "created_at": "2018-04-24T23:26:57Z",
        "body": "You probably just need `--strictNullChecks` enabled."
      },
      {
        "user": "MartinJohns",
        "created_at": "2018-04-25T07:07:54Z",
        "body": "Or alternatively `--noImplicitReturns`. Enabling `--strictNullChecks` is often very difficult to add in old code bases, but `--noImplicitReturns` is a no-brainer."
      },
      {
        "user": "ORESoftware",
        "created_at": "2018-04-25T07:17:58Z",
        "body": "@andy-ms yeah that's fine, I guess I would expect the default behavior to always catch this one tho?"
      },
      {
        "user": "MartinJohns",
        "created_at": "2018-04-25T07:21:07Z",
        "body": "The default behaviour is to align with JavaScript. If a function returns \"nothing\", it implicitly returns `undefined`. That is what is happening here. And with `strictNullChecks` disabled, the value of `undefined` is compatible with the type `Promise<any>`, the value is compatible with **any** type.\r\n\r\n`strictNullChecks` will change the semantics of `undefined` from a mere *value* to a *type*, so the value `undefined` will be of the type `undefined`, which is not compatible with `Promise<any>` anymore. You will get an error.\r\n\r\n`noImplicitReturns` will enforce what the name implies: A method may not have an implicit return value. That means you have to explicitly write `return undefined;`."
      },
      {
        "user": "ORESoftware",
        "created_at": "2018-04-25T07:28:16Z",
        "body": "ok understood, to move this in a more productive direction, is there a way to never allow null/undefined in the place of a defined value? In Java, all those NullPointerException's are caused by allowing null to exist in far too many places.\r\n\r\nReturning null from a function/method instead of an array or Promise, or anything, it's just crazy imo.\r\n\r\n"
      },
      {
        "user": "MartinJohns",
        "created_at": "2018-04-25T09:10:26Z",
        "body": "Yes... That is pretty much what `strictNullChecks` is for. And related to that the `strictPropertyInitialization` feature (works only together with `strictNullChecks`."
      },
      {
        "user": "ORESoftware",
        "created_at": "2018-04-25T18:39:44Z",
        "body": "@MartinJohns  thanks for the info...I still think `strictNullChecks` should be the default behavior, and that users should have to specifically set it to false, but nbd I guess"
      }
    ]
  },
  {
    "number": 23665,
    "title": "Allow narrowing generic parameters in conditional types",
    "created_at": "2018-04-24T19:58:06Z",
    "closed_at": "2018-05-01T10:25:42Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/23665",
    "body": "```TypeScript\r\n    type Lambda1 = () => number;\r\n    type Lambda2 = <T>() => Array<T>;\r\n\r\n    type Test1<T> = T extends <U>() => infer V ? V : never;\r\n\r\n    type T1 = Test1<Lambda1>; // 'number'\r\n    type T2 = Test1<Lambda2>; // '{}[]'\r\n\r\n    type Test2<T, R> = T extends <U = R>() => infer V ? V : never;\r\n\r\n    type T3 = Test2<Lambda1, string>; // 'number'\r\n    type T4 = Test2<Lambda2, string>; // '{}[]'\r\n\r\n    type Test3<T, R> = T extends <U extends R>() => infer V ? V : never;\r\n\r\n    type T5 = Test3<Lambda1, string>; // 'number'\r\n    type T6 = Test3<Lambda2, string>; // '{}[]'\r\n```\r\n\r\nI'd expect either or both T4 or T6 to be `string[]`. As it is, there seems to be no way to specify the generic type inside of a conditional. I think this is a proposal, but if there's an existing way to turn T4 or T6 into `string[]`, this can be closed, I don't think there is.",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/23665/comments",
    "author": "SimonMeskens",
    "comments": [
      {
        "user": "krryan",
        "created_at": "2018-04-24T21:21:24Z",
        "body": "So in `Test2`, you set `U` to default to `R`, but there are no constraints on it saying it *must* be `R`. The `=` basically offers no assistance here.\r\n\r\nI'm less sure what's going on with `Test3`. It seems like that should be looking at `Lambda2<string>` which is `() => string` so `V` should be `string`.\r\n\r\nBut in both `Test2` and `Test3` we see `() => number` matching with `<U>() => infer V`, which means that conditional types are _not_ picky about generic parameters in the `extends` clauses of function types.\r\n\r\nUltimately, this seems like it should be implemented with higher-kinded types, which is a **very** long-time request: #1213 \r\n\r\n...which I see you are fully aware of, being the author of a step forward on that... nevermind me."
      },
      {
        "user": "SimonMeskens",
        "created_at": "2018-04-24T21:48:08Z",
        "body": "Yeah, this issue came out of experiments with HKTs. If I could get either Test2 or Test3 into the language, we would get proper type level pattern matching, which allows us to do lots of cool things, one of which is improving inference for HKTs, but also generic function application, abstract type constructors, etc."
      },
      {
        "user": "SimonMeskens",
        "created_at": "2018-04-24T21:50:00Z",
        "body": "@ahejlsberg I think this one is in your domain?"
      },
      {
        "user": "SimonMeskens",
        "created_at": "2018-04-28T00:53:52Z",
        "body": "@mhegazy This isn't a question but a suggestion"
      },
      {
        "user": "mhegazy",
        "created_at": "2018-04-30T17:03:54Z",
        "body": "The typescript type system is structural. so type parameters need to have a manifestation to be picked up by inference. i.e. used in a parameter type or in a return type for a function. if inference could not find any candidates, the upper bound is returned, which is `{}`.\r\n\r\nIn the case of `T4`, the compiler is trying to infer for `V` from `Lambda2`, it looks at the param list, to find any candidates for `T` and none are found, so `T` goes to `{}`, then instantiating `Lambda2` with `T = {}` gets us a return type of `{}[]` that is then used to as the inference for `V`.  same process happens in `T6`."
      },
      {
        "user": "SimonMeskens",
        "created_at": "2018-04-30T21:40:41Z",
        "body": "Okay, so here are some really odd behaviors to prove that it's not at all intuitive:\r\n```ts\r\ntype Lambda1 = <U>(a: U) => U;\r\ntype Lambda2 = <U extends string>(a: U) => U;\r\n\r\ntype Test<T> = T extends <U extends \"test\">(a: U) => infer S\r\n    ? S\r\n    : string;\r\n\r\n// OK\r\nlet a: Test<Lambda1> = \"test\"; // a: {}\r\nlet b: Test<Lambda1> = \"some\"; // b: {}\r\n\r\n// Error: Type '\"test\"' is not assignable to type 'Test<Lambda2>'.\r\nlet c: Test<Lambda2> = \"test\"; // c: Test<Lambda2>\r\n// Error: Type '\"some\"' is not assignable to type 'Test<Lambda2>'.\r\nlet d: Test<Lambda2> = \"some\"; // d: Test<Lambda2>\r\n```\r\n\r\nExpected behavior:\r\na, b, c and d are all of type `\"test\"` and b and d give an error that I can't assign '\"some\"' to type '\"test\"'\r\n\r\nActual behavior:\r\na and b are of type `{}` and allow me to assign \"some\"\r\nc and d are of type `Test<Lambda2>` (whatever that means) and don't even allow me to pass in any string\r\n\r\nSo as it stands, I can't narrow type constraints, and I get really odd behavior when I try to."
      },
      {
        "user": "SimonMeskens",
        "created_at": "2018-04-30T22:24:53Z",
        "body": "I think I understand now why my suggestion is naive. The example above is just a bug.\r\n\r\nConditionals actually do something like this:\r\n```ts\r\ntype Conditional<T extends <U extends \"test\">(a: U) => S, S = ReturnType<T>> = S;\r\n\r\ntype T = Conditional<Lambda2>;\r\n```\r\n\r\nExcept they infer what S is above. So what would be necessary instead is for a proposal orthogonal to conditional types, like type level function application."
      }
    ]
  },
  {
    "number": 23582,
    "title": "Suggestion: Expose internals of File Watching beyond simple notification",
    "created_at": "2018-04-20T20:28:57Z",
    "closed_at": "2018-05-07T18:40:38Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/23582",
    "body": "I am building a framework that tightly couples with Typescript, and it would be useful to be able to tap into the File watcher API.\r\n\r\nCurrently that functionality culminates in the public API of \r\n\r\n`ts.sys.watchDirectory(directory, callback?:(file:string)=>void, recursive?: boolean):FileWatcher`\r\n`ts.sys.watchFile(file, callback?:(file:string)=>void, pollingInterval?: number):FileWatcher`, \r\n\r\nwhere `FileWatcher` is \r\n```\r\ninterface FileWatcher {\r\n   close():void;\r\n}\r\n```\r\nThe API is very limited compared to the actual underlying functionality, especially given that `watchDirectory` does not indicate if the change is an add, remove or delete.\r\n\r\nThere are other libraries that do this, with `chokidar` being the forerunner with flexibility and configuration.  Unfortunately `chokidar` weighs in at a very heavy footprint (235 dependencies) due to all the various use cases that they support. \r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/23582/comments",
    "author": "arciisine",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2018-04-21T00:41:51Z",
        "body": "The file watcher APIs are mainly for our watch scenarios in --watch and in tsserver. they are not intended to be general watch APIs really, and we have no plans to support them as such. \r\nCan elaborate on what options/additions you need and how/if they tie into the TS main scenarios? "
      },
      {
        "user": "arciisine",
        "created_at": "2018-04-22T15:53:14Z",
        "body": "My primary motivator for reaching out, is that it seems like what is currently internal, might work just as well, if not better, for quite a few people. This would be true regardless of whether or not they are using TypeScript.\r\n\r\nWith respect to the internal nature of the APIs, I think we are in agreement.  Exposing them as is, really doesn't fit in line with the project's goals apart form providing additional tooling.  Though I would say that I somewhat feel the same way about the existing `ts.sys.watchDirectory`.  \r\n\r\nUltimately, I'm thinking what may be best is for me to just repackage the current set of internal APIs (or some approximation there of) as a separate lib and use that.  \r\n\r\n"
      },
      {
        "user": "typescript-bot",
        "created_at": "2018-05-07T18:40:37Z",
        "body": "Automatically closing this issue for housekeeping purposes. The issue labels indicate that it is unactionable at the moment or has already been addressed."
      }
    ]
  },
  {
    "number": 23504,
    "title": "Potentially incorrect return type inference for enum types",
    "created_at": "2018-04-18T11:36:10Z",
    "closed_at": "2018-05-02T22:53:38Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/23504",
    "body": "Hi,\r\n\r\nIn the following case, why is type of `z` inferred as `Bar` instead of `Bar.Baz`?\r\n\r\n```ts\r\nenum Bar {\r\n    Baz = \"Baz\",\r\n    Abc = \"Abc\"\r\n}\r\n\r\nfunction foo() {\r\n    return Bar.Baz;\r\n}\r\n\r\nconst z = foo();\r\n```",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/23504/comments",
    "author": "michaelgeorgeattard",
    "comments": [
      {
        "user": "michaelgeorgeattard",
        "created_at": "2018-04-18T12:45:21Z",
        "body": "`Bar.Baz` should be a type too.\r\n\r\nAlso the below works:\r\n\r\n```ts\r\nenum Bar {\r\n    Baz = \"Baz\",\r\n    Abc = \"Abc\"\r\n}\r\n\r\nfunction foo(): Bar.Baz {\r\n    return Bar.Baz;\r\n}\r\n\r\nconst z = foo();\r\n```\r\n\r\nThough I think I know what is happening, the below return type is inferred as `boolean` instead of `true`:\r\n\r\n```ts\r\nfunction foo(): {\r\n    return true;\r\n}\r\n```\r\n\r\nI think return type inference is not very restrictive."
      },
      {
        "user": "ghost",
        "created_at": "2018-04-18T14:48:29Z",
        "body": "Duplicate of  #241"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2018-04-18T14:48:57Z",
        "body": "@andy-ms these are function declarations, not expressions"
      },
      {
        "user": "typescript-bot",
        "created_at": "2018-05-02T22:53:37Z",
        "body": "Automatically closing this issue for housekeeping purposes. The issue labels indicate that it is unactionable at the moment or has already been addressed."
      }
    ]
  },
  {
    "number": 23482,
    "title": "New Logo Proposal",
    "created_at": "2018-04-17T19:32:11Z",
    "closed_at": "2018-05-18T20:50:56Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/23482",
    "body": "Hello! I would like to collaborate with this project by providing a _free_ new logo that suits with the project! Let me know if interested so we can get in touch! Cheers.",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/23482/comments",
    "author": "LuigiBaute",
    "comments": [
      {
        "user": "DanielRosenwasser",
        "created_at": "2018-04-18T02:07:32Z",
        "body": "Thank you! We actually would be interested to hear about your ideas, though I don't think we can necessarily commit ourselves to anything. If you want to reach out and discuss it privately, my email address just uses my name in the format `FirstName.LastName [at] microsoft <dot> com`"
      },
      {
        "user": "LuigiBaute",
        "created_at": "2018-05-01T09:19:51Z",
        "body": "Hello, I am the graphic designer who wants to present the logo for your TypeScrip project, I would like to know more about your project so that the logo is as accurate as possible and you can use it as soon as possible. @DanielRosenwasser  I couldn't reach to you by the email you gave me, mine is \r\nabelsakimerlib [at] gmail [dot] com"
      }
    ]
  },
  {
    "number": 23427,
    "title": "Returning a Proxy from a class does not infer and can’t be typed",
    "created_at": "2018-04-16T15:03:51Z",
    "closed_at": "2018-04-30T16:56:11Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/23427",
    "body": "It seems that typescript does not allow for a class constructor to return a proxy that resolved to anything except what the class itself contains.\r\n\r\nExpected:\r\n```\r\nclass Foo<ProxiedThing> {\r\n  adapter: any;\r\n  constructor(adapter) {\r\n    this.adapter = adapter;\r\n\r\n    return <ProxiedThing> new Proxy(this, {\r\n        get(target, name) {\r\n           return this.adapter[name keyof ProxiedThing]\r\n        }\r\n     })\r\n  }\r\n}\r\nvar test = new Foo(\r\n    new SomeOtherClass()\r\n);\r\ntest.methodOnSomeOtberClass();\r\n```\r\n\r\nThe desired effect here is pseudo composable enharatence on classes. This can be done of course in JS but I can only seem to make this work in TS by defining `[key: string]: any` on the `Foo` class to get things compiled but then lackes typechecking and hinting.\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/23427/comments",
    "author": "mattapperson",
    "comments": [
      {
        "user": "ghost",
        "created_at": "2018-04-16T15:51:04Z",
        "body": "First: Try turning on `--noImplicitAny` -- `constructor(adapter)` implicitly makes `adapter: any`, so there's no way to perform type inference on `new Foo`.\r\n\r\nSecond, we don't support returning a different type from a constructor, that is, `new Foo()` must return a `Foo`. It seems like you want `new Foo(new SomeOtherClass())` to return an object with the interface of `SomeOtherClass`. It might be better to write this as a `function createProxy<T>(value: T): T` instead of as a class."
      },
      {
        "user": "typescript-bot",
        "created_at": "2018-04-30T16:56:11Z",
        "body": "Automatically closing this issue for housekeeping purposes. The issue labels indicate that it is unactionable at the moment or has already been addressed."
      }
    ]
  },
  {
    "number": 23398,
    "title": "PathIn<T> type just like Partial<T> type for deep field path in a object.",
    "created_at": "2018-04-13T14:47:46Z",
    "closed_at": "2018-04-27T17:27:43Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/23398",
    "body": "I love typescript wanted to ask if this can be a feature. I searched some issues related to this but could not find any help. \r\n\r\n__Sorry for  my noobness.__\r\n\r\n### For model Car\r\n```typescript\r\ninterface Car {\r\n    engine: {\r\n        name: string;\r\n        modelNumber: string;\r\n    },\r\n    body:{\r\n        color:string;\r\n        shape:{\r\n        }\r\n    },\r\n}\r\n```\r\n\r\n## Current problem\r\nDescribing nested or deep typings needs to be improved. Below code is taken from ngrx/store \r\n\r\n```typescript\r\nclass Store<T>{\r\n    // ...\r\n    select<a extends keyof T>(key: a): Store<T[a]>;\r\n    select<a extends keyof T, b extends keyof T[a]>(key1: a, key2: b): Store<T[a][b]>;\r\n    select<a extends keyof T, b extends keyof T[a], c extends keyof T[a][b]>(key1: a, key2: b, key3: c): Store<T[a][b][c]>;\r\n    select<a extends keyof T, b extends keyof T[a], c extends keyof T[a][b], d extends keyof T[a][b][c]>(key1: a, key2: b, key3: c, key4: d): Store<T[a][b][c][d]>;\r\n    select<a extends keyof T, b extends keyof T[a], c extends keyof T[a][b], d extends keyof T[a][b][c], e extends keyof T[a][b][c][d]>(key1: a, key2: b, key3: c, key4: d, key5: e): Store<T[a][b][c][d][e]>;\r\n    select<a extends keyof T, b extends keyof T[a], c extends keyof T[a][b], d extends keyof T[a][b][c], e extends keyof T[a][b][c][d], f extends keyof T[a][b][c][d][e]>(key1: a, key2: b, key3: c, key4: d, key5: e, key6: f): Store<T[a][b][c][d][e][f]>;\r\n    // ...\r\n}\r\n```\r\n\r\nSo `select` method can be used like this\r\n```typescript\r\nlet store :  Store<Car>;\r\nstore.select('engine','name');\r\n```\r\n\r\n1. Lot of boilerplate and still do not cover all cases, only upto 6 keys. Not productive.\r\n2. Javascript object is multi level object and `keyof` restricts us to only one level.\r\n\r\n## My Suggestion\r\nThere should be a way to address deep field or nested path in the language itself.  I will be discussing  `PathIn<T>` type like `Partial<T>`, but it can any other thing like `pathin` as `keyof` etc. (this is beyond my knowledge)\r\n`let path: PathIn<Car>;`\r\nSo `path` should be limited to `['engine']`, `['engine', 'name']`, `['engine', 'modelNumber']`, `['body']`, `['body', 'color']` and `['body', 'shape']`.\r\n\r\nFor single level it may be `'engine'` or `'body'` i.e. without array notation. This is just a sugar syntax, not required.\r\n\r\n```typescript\r\nlet path1 :PathIn<Car> = ['engine']; //Okay\r\nlet path2 :PathIn<Car> = ['abc']; //Error\r\n```\r\nSince `PathIn` only means multilevel path so for\r\n```typescript\r\nlet pathToBodyColor : PathIn<Car> = ['body','color'];\r\n```\r\n1. `type` of `Car[pathToBodyColor]` should be `string`.\r\n2. For `let car:Car`, one of these should return value at `car.body.color`\r\n    * `car[pathToBodyColor] === car.body.color`\r\n    * `pathToBodyColor[car] === car.body.color`\r\n    * `pathToBodyColor.from(car) === car.body.color`\r\n3. `let emptyPath: Path<T> = [];`  is not clear.\r\n   * If valid, then it can be valid for every `T` in `number`, `undefined`, `null` , `{}`etc. and as discussed in point `2` `emptyPath.from(\"abc\")` should return `\"abc\"` itself.\r\n   * If invalid, then `Path<T>` where `T` is in `number`, `undefined`, `null` , `{}` etc. should not be possible.\r\n4. For `let path : PathIn<any>` , the path array can be anything which is a possible valid path.\r\n\r\nAnd now the above code for `Store.select()` can be\r\n```typescript\r\nclass Store<T>{\r\n    // ...\r\n    select<a extends PathIn<T>>(key: a): Store<T[a]>;\r\n    // ...\r\n}\r\n```\r\n\r\n### Extra\r\nDealing with object like \r\n```typescript\r\ninterface Car2 {\r\n    name:string;\r\n    bodyColor:string;\r\n    bodyShape:Polygon;\r\n    bodyWeight:number;\r\n    bodyDimension: Box;\r\n    engineModel:string;\r\n    engineManufacturedOn:string,\r\n}\r\n```\r\n\r\nthen there is no problem, but we know in real world objects are not like that and `keyof` is very limited.\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/23398/comments",
    "author": "AmitDigga",
    "comments": [
      {
        "user": "krryan",
        "created_at": "2018-04-13T16:39:12Z",
        "body": "`Partial` is built-in for convenience, but it's trivial to implement yourself. It doesn't have any special or hard-coded rules. So you could, in theory, produce your `PathIn` type yourself.\r\n\r\nHowever, there isn't currently any way to modify tuples as types. So you can write a type that finds `['engine']`, and notices that `Car['engine']` is an object, and then recurses and finds `['name']` (well, at least an interface that does that; see below), but no way to join `['engine']` and `['name']` to be `['engine', 'name']`.\r\n\r\nBut if you were willing to accept other structures for representing this path, that wouldn't be a problem. For example, a linked list would be easy enough to do.\r\n\r\nThe problem then is that Typescript does not support types that circularly reference themselves. Classes and interfaces can do it, and that's the recommended workaround, but a single interface cannot somehow be a union of anything. Types support distribution across a union, which you need for this.\r\n\r\nGiven the advent of conditional types, perhaps the eager resolution of types, and therefore their inability to handle circular references, should be revisited."
      },
      {
        "user": "jack-williams",
        "created_at": "2018-04-13T16:55:12Z",
        "body": "I think things like `Car[pathToBodyColor]` where `pathToBodyColor` is a tuple is abusing index syntax too much IMO. Anyway, here is a `PathIn<T>` type I had a go at.\r\n\r\nThe best I can do; expect this to blow up:\r\n\r\n```ts\r\ntype Append<X, T extends any[]> =\r\n    T extends [infer A0, infer A1, infer A2, infer A3, infer A4, infer A5, infer A6, infer A7, infer A8, infer A9] ?\r\n    [A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, X] :\r\n\r\n    T extends [infer A0, infer A1, infer A2, infer A3, infer A4, infer A5, infer A6, infer A7, infer A8] ?\r\n    [A0, A1, A2, A3, A4, A5, A6, A7, A8, X] :\r\n\r\n    T extends [infer A0, infer A1, infer A2, infer A3, infer A4, infer A5, infer A6, infer A7] ?\r\n    [A0, A1, A2, A3, A4, A5, A6, A7, X] :\r\n\r\n    T extends [infer A0, infer A1, infer A2, infer A3, infer A4, infer A5, infer A6] ?\r\n    [A0, A1, A2, A3, A4, A5, A6, X] :\r\n\r\n    T extends [infer A0, infer A1, infer A2, infer A3, infer A4, infer A5] ?\r\n    [A0, A1, A2, A3, A4, A5, X] :\r\n\r\n    T extends [infer A0, infer A1, infer A2, infer A3, infer A4] ?\r\n    [A0, A1, A2, A3, A4, X] :\r\n\r\n    T extends [infer A0, infer A1, infer A2, infer A3] ?\r\n    [A0, A1, A2, A3, X] :\r\n\r\n    T extends [infer A0, infer A1, infer A2] ?\r\n    [A0, A1, A2, X] :\r\n\r\n    T extends [infer A0, infer A1] ?\r\n    [A0, A1, X] :\r\n\r\n    T extends [infer A0] ?\r\n    [A0, X] : never\r\n\r\n\r\ntype TraverseTop<T> =\r\n    T extends object ?\r\n    { [K in keyof T]: [K] | Traverse<[K],T[K]> }\r\n    : never\r\n\r\ntype Traverse<P extends any[],T> =\r\n    T extends object ?\r\n    keyof T extends never ? P : \r\n    { [K in keyof T]: P | Traverse<Append<K,P>,T[K]> }\r\n    : P\r\n\r\n\r\ntype Flatten10<T> = T extends any[] ? T : T extends object ? Flatten9<T[keyof T]> : T;\r\ntype Flatten9<T> = T extends any[] ? T : T extends object ? Flatten8<T[keyof T]> : T;\r\ntype Flatten8<T> = T extends any[] ? T : T extends object ? Flatten7<T[keyof T]> : T;\r\ntype Flatten7<T> = T extends any[] ? T : T extends object ? Flatten6<T[keyof T]> : T;\r\ntype Flatten6<T> = T extends any[] ? T : T extends object ? Flatten5<T[keyof T]> : T;\r\ntype Flatten5<T> = T extends any[] ? T : T extends object ? Flatten4<T[keyof T]> : T;\r\ntype Flatten4<T> = T extends any[] ? T : T extends object ? Flatten3<T[keyof T]> : T;\r\ntype Flatten3<T> = T extends any[] ? T : T extends object ? Flatten2<T[keyof T]> : T;\r\ntype Flatten2<T> = T extends any[] ? T : T extends object ? Flatten1<T[keyof T]> : T;\r\ntype Flatten1<T> = T extends any[] ? T : T extends object ? Flatten0<T[keyof T]> : T;\r\ntype Flatten0<T> = T\r\n\r\ninterface Car {\r\n    engine: {\r\n        name: string;\r\n        modelNumber: string;\r\n    },\r\n    body:{\r\n        color:string;\r\n        shape:{\r\n        }\r\n    },\r\n}\r\n\r\ntype PathIn<T> = Flatten10<TraverseTop<T>>;\r\nlet path1:PathIn<Car> = ['engine']; //Okay\r\nlet path2:PathIn<Car> = ['abc']; //Error\r\nlet pathToBodyColor: PathIn<Car> = ['body','color'];\r\n```"
      },
      {
        "user": "typescript-bot",
        "created_at": "2018-04-27T17:27:43Z",
        "body": "Automatically closing this issue for housekeeping purposes. The issue labels indicate that it is unactionable at the moment or has already been addressed."
      }
    ]
  },
  {
    "number": 23394,
    "title": "Incorrect behaviour for class methods redefenition",
    "created_at": "2018-04-13T08:54:11Z",
    "closed_at": "2018-04-13T19:37:16Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/23394",
    "body": "**Search Terms:**\r\nclass, methods\r\n\r\n**Code**\r\n\r\nFirstly, u can see this problem if you use a pattern of redefinition methods in children class which has a declared type of returning value.\r\n\r\n```ts\r\nclass Base {\r\n  method(): string {\r\n    return 'mystring'\r\n  }\r\n}\r\n\r\nclass Children extends Base {\r\n  method(): number {\r\n    return 1;\r\n  }\r\n}\r\n```\r\n\r\n**Expected behavior:**\r\nNo errors, it's fully redefinition.\r\n\r\n**Actual behavior:**\r\nError: Type 'number' is not assignable to type 'string'.\r\n\r\nSecondly, u can see the same problem with the methods args.\r\n\r\n```ts\r\nclass Base {\r\n  method(arg: string) {\r\n    return arg\r\n  }\r\n}\r\n\r\nclass Children extends Base {\r\n  method(arg: number ) {\r\n    return arg;\r\n  }\r\n}\r\n\r\n// BUT\r\n\r\nclass Children2 extends Base {\r\n  method(arg) { // <--- any\r\n    return arg;\r\n  }\r\n}\r\n```\r\n\r\n**Expected behavior:**\r\nNo errors, it's fully redefinition.\r\n\r\n**Actual behavior:**\r\nError: \r\nTypes of parameters 'arg' and 'arg' are incompatible.\r\nType 'string' is not assignable to type 'number'.",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/23394/comments",
    "author": "awinogradov",
    "comments": [
      {
        "user": "MartinJohns",
        "created_at": "2018-04-13T16:53:01Z",
        "body": "```\r\nconst instance: Base = new Children();\r\ninstance.method(????);\r\n```\r\n\r\nWhat would you pass? The type `Base` clearly states it accepts a `string`, but the actual instance overwrote the method accepting a `number`.\r\n\r\nThe behavior works as intended."
      },
      {
        "user": "awinogradov",
        "created_at": "2018-04-13T16:58:38Z",
        "body": "Thanks for the answer!\r\n\r\n@MartinJohns I can agree with the first case of methods value because it can be called in different places of the base class. But I don't agree with the second case of arguments types. In the children class, all arguments of a redefined method have any type. But I can't declare another one type them. If I can't change it why it's not inherited by default?"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2018-04-13T19:37:16Z",
        "body": "Derived classes can accept wider types than their base types, as is described by substitutability. Please read the FAQ and/or ask questions on StackOverflow."
      }
    ]
  },
  {
    "number": 23336,
    "title": "One type signature overrides another when undesirable ",
    "created_at": "2018-04-11T10:16:18Z",
    "closed_at": "2018-04-27T17:27:46Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/23336",
    "body": "The following works fine:\r\n\r\n```ts\r\nexport function ReduxComponent<PROPS>(options: {\r\n    props: { [P in keyof PROPS]?: string },\r\n    actions: { [P in keyof PROPS]?: string },\r\n}) {\r\n    return function(target: Function) {\r\n    };\r\n}\r\n\r\n@ReduxComponent<PostListPageProps>({\r\n    props: {\r\n        posts: \"posts\",\r\n        postsArgs: \"postsArgs\"\r\n    },\r\n    actions: {\r\n        setPosts: \"POSTS_LOADED\",\r\n        removePosts: \"POSTS_REMOVE\",\r\n    }\r\n})\r\nexport class PostListPage extends Component<PostListPageProps>\r\n```\r\n\r\nHowever this code:\r\n\r\n```ts\r\nexport function ReduxComponent<PROPS>(options: {\r\n    props: { [P in keyof PROPS]?: string },\r\n    actions: { [P in keyof PROPS]?: string },\r\n}) {\r\n    return function(target: { new(...args: any[]): Component<PROPS> }) {\r\n    };\r\n}\r\n\r\n@ReduxComponent({\r\n    props: {\r\n        posts: \"posts\",\r\n        postsArgs: \"postsArgs\"\r\n    },\r\n    actions: {\r\n        setPosts: \"POSTS_LOADED\",\r\n        removePosts: \"POSTS_REMOVE\",\r\n    }\r\n})\r\nexport class PostListPage extends Component<PostListPageProps> {\r\n```\r\n\r\nGives me following error:\r\n\r\n```\r\nError:(25, 9) TS2345: Argument of type '{ props: { posts: string; postsArgs: string; }; actions: { setPosts: string; removePosts: string;...' is not assignable to parameter of type '{ props: { posts?: string; postsArgs?: string; }; actions: { posts?: string; postsArgs?: string; ...'.\r\n  Types of property 'actions' are incompatible.\r\n    Type '{ setPosts: string; removePosts: string; }' is not assignable to type '{ posts?: string; postsArgs?: string; }'.\r\n      Object literal may only specify known properties, and 'setPosts' does not exist in type '{ posts?: string; postsArgs?: string; }'.\r\n```\r\n\r\nLooks like when I define `props` it thinks `actions` will have the same signature, however its not.\r\nI'm using latest `2.8.1`.\r\nSorry wasn't sure how to title this issue.",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/23336/comments",
    "author": "pleerock",
    "comments": [
      {
        "user": "ghost",
        "created_at": "2018-04-11T15:18:38Z",
        "body": "If you don't want them to have the same keys, why did you write `actions: { [P in keyof PROPS]?: string },`? `actions: object` would fix the compile error."
      },
      {
        "user": "pleerock",
        "created_at": "2018-04-11T18:28:33Z",
        "body": "but it does not provide a type-safety, right? I want first to be some properties of T and second to be some other (or same) properties of T. Just like in first working example, looks like the second is a bit complexier and it does not work."
      },
      {
        "user": "ghost",
        "created_at": "2018-04-11T20:46:35Z",
        "body": "Well, a bigger problem is that we can't properly infer the type `PROPS` if all we have are its keys. The best you could do is something like this:\r\n```ts\r\ndeclare function f<PropKeys extends string, ActionKeys extends string>(\r\n    props: { [P in PropKeys]: string },\r\n    actions: { [P in ActionKeys]: string },\r\n): { [K in PropKeys | ActionKeys]: {} };\r\nconst o = f({ a: \"\" }, { m: \"\" }); // Type is `{ a: {}, m: {} }`\r\n```"
      },
      {
        "user": "pleerock",
        "created_at": "2018-04-12T04:42:39Z",
        "body": "Can you please help me with my particular example?:\r\n\r\n```ts\r\nexport function ReduxComponent<PROPS>(options: {\r\n    props: { [P in keyof PROPS]?: string },\r\n    actions: { [P in keyof PROPS]?: string },\r\n}) {\r\n    return function(target: { new(...args: any[]): Component<PROPS> }) {\r\n    };\r\n}\r\n```\r\n\r\n(PROPS) must be inferred from the class on which decorator is applied."
      },
      {
        "user": "ghost",
        "created_at": "2018-04-12T14:52:25Z",
        "body": "It's not possible to infer `PROPS` if the parameters only use its keys. You'll need explicit type arguments in that case."
      },
      {
        "user": "pleerock",
        "created_at": "2018-04-12T16:24:36Z",
        "body": "Can you please explain why its not a bug? When working with this code user feels it like a bug even if you prove that its not a bug, btw."
      },
      {
        "user": "ghost",
        "created_at": "2018-04-12T16:58:50Z",
        "body": "Type inference can only do so much. If you only use the keys of a type, how is it supposed to infer what that type is? If you have `function f<T>(keys: ReadonlyArray<keyof T>): T` and call `f([\"x\", \"y\"])`, what should the return type be?"
      },
      {
        "user": "pleerock",
        "created_at": "2018-04-12T18:49:59Z",
        "body": "I understand what you mean, when you are talking about return type do you mean a `: Component<PROPS>` part in my example?"
      },
      {
        "user": "ghost",
        "created_at": "2018-04-12T18:54:31Z",
        "body": "Well, type inference doesn't usually look at the return type, but I am pointing out that the parameter is:\r\n```ts\r\noptions: {\r\n    props: { [P in keyof PROPS]?: string },\r\n    actions: { [P in keyof PROPS]?: string },\r\n})\r\n```\r\nThe only time `PROPS` appears is in `keyof PROPS`, so there's no way to infer the *values* of `PROPS` by looking at the arguments to a function call."
      },
      {
        "user": "typescript-bot",
        "created_at": "2018-04-27T17:27:46Z",
        "body": "Automatically closing this issue for housekeeping purposes. The issue labels indicate that it is unactionable at the moment or has already been addressed."
      }
    ]
  },
  {
    "number": 23222,
    "title": "Difficulties with building a library for distributing",
    "created_at": "2018-04-06T18:42:06Z",
    "closed_at": "2018-04-25T20:28:19Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/23222",
    "body": "I'm trying to compile a lib for distributing. I want my npm package with the library has the following structure:\r\n```\r\n├───dist\r\n│     ├───lib/*.js + *.d.ts + *.js.map\r\n│     └───modules/*.js + *.d.ts\r\n├───src\r\n│     ├───lib/*.ts\r\n│     └───modules/*.ts\r\n├───tsconfig.json\r\n└───package.json\r\n```\r\nInside `dist` I want runtime (*.js) script, declaration files for compiling user apps (*.d.ts) and source maps (*.js.map) for debugging that point to sources inside *.ts.\r\nIt seems legit structure, nothing fancy. \r\n\r\nI staged all source files into `dist/src` folder. The folder `dist` contains `package.json`, `tsconfig.json` - it's root for npm package that will be published.   \r\n\r\nThere're two strategies:\r\n1. compile with `-d` inside `dist/src` then rename it to `dist/dist` and move *.ts from it into `dist/src`\r\n2. compile with `-d` and `--outDir dist/dist` options\r\n\r\nIt turns out that both approaches have problems and don't allow to create a working package.\r\n\r\n1. If I compile with `-d` inside `dist/src` then source maps (*.js.map) will have local links (`\"file\":\"file.js\", \"sourceRoot\":\"\",\"sources\":[\"file.ts\"]`). That means that if I move `*.ts` later from that folder it'll break source mapping for the lib in runtime. It seems that `sourceRoot` option could solve that issue - but it doesn't work as expected - see #23180 (TL;DR: I I set it that tsc put local absolute file paths inside *.js.map).\r\n2. If I compile with `-d` and redirecting into other folder via `--outDir` then another issue arises: if a ts-file has a reference to a declaration besides it (`.d.ts`) then that reference will be changed in output folder.\r\nFor example, in `dist/src` I have `file.ts` with a reference to `.stud.d.ts`:\r\n```ts\r\n/// <reference path=\"./.stubs.d.ts\" />\r\n```\r\nafter compilation with `-d --outDir ./dist/dist` we'll have `dist/dist/file.d.ts` with the following reference:\r\n```ts\r\n/// <reference path=\"../src/lib/.stubs.d.ts\" />\r\n```\r\nOh my. This is a problem as I can't copy all *.d.ts from `dist/src` to `dist/dist` because such references become invalid. You may ask me why should I copy `*.d.ts` from `src` to `dist`. Well `dist/dist` should complete distributive and it should work without `dist/src` (which is optional and can be even removed in some cases)\r\n\r\nSo I can't understand how it suppose to work. How is it meant libraries should be built for distributing?\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/23222/comments",
    "author": "evil-shrike",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2018-04-06T22:36:11Z",
        "body": "I do not think the first approach is ideal. as you said it messes up your source maps, though you should know about `--sourceRoot` for these cases.\r\n\r\nThe second is what i would recommend. to have a recommendation on the .d.ts issue, i need to know what are these .d.ts files represent? are they your code? external dependencies? are they from npm?\r\nalso why are you using `/// <references` to start with?\r\n"
      },
      {
        "user": "evil-shrike",
        "created_at": "2018-04-06T23:00:37Z",
        "body": "> though you should know about --sourceRoot for these cases.\r\n\r\nyes, but as I noted `--sourceRoot` puts local absolute path into js.map that make then useless\r\n\r\n>i need to know what are these .d.ts files represent? are they your code? \r\n\r\nit's my code usually with `declare module` like\r\n```ts\r\ndeclare module \"xhtmpl!*\" {\r\n\tconst m: HandlebarsTemplateDelegate;\r\n\texport = m;\r\n}\r\n```\r\nor\r\n```ts\r\ndeclare module \"core.ui\" {\r\n\texport * from \"ui/.ui\";\r\n\texport import Dialog = require(\"lib/ui/Dialog\");\r\n}\r\n```\r\nthat for example allows me to put Dialog class into `core.ui.Dialog`-\r\n`lib/ui/Dialog.ts`:\r\n```ts\r\n...\r\ncore.ui.Dialog = Dialog;\r\nexport = Dialog;\r\n```\r\n\r\n>also why are you using /// <references to start with?\r\n\r\nif I don't add `/// <references ` then client app will have to include all *.d.ts explicitly from the lib. \r\n\r\n>external dependencies? are they from npm?\r\n\r\nthere're references to vendor's typings as well which distributed inside libraries (not from `@types`) like:\r\n```ts\r\n/// <reference path=\"../../../vendor/fancytree/jquery.fancytree.dnd.d.ts\" />\r\n```"
      },
      {
        "user": "mhegazy",
        "created_at": "2018-04-06T23:08:45Z",
        "body": "> yes, but as I noted --sourceRoot puts local absolute path into js.map that make then useless\r\n\r\nthat seems like a bug in tsconfig.json parsing. we should fix that. on the command-line it should be used verbatim, you can also use `file:///./src` to avoid it being resolved."
      },
      {
        "user": "mhegazy",
        "created_at": "2018-04-06T23:14:17Z",
        "body": "seems like the .d.ts file is something you are adding manually. then i would just not use `///<references` at all. have a static file in your output call it `entrypoint.d.ts` this file all it has is:\r\n\r\n```ts\r\n/// <reference path=\"./mygloabls.d.ts\" />\r\nexport * from \"./index\";\r\n```\r\n\r\nthe other option is to have that .d.ts file in your dist folder directly, and add the `/// <reference` to it in the dist folder."
      },
      {
        "user": "evil-shrike",
        "created_at": "2018-04-06T23:57:33Z",
        "body": "Do I understand correctly that you are suggesting remove all `/// <reference>` imports from all my *.ts/*.d.ts and put all of them into a single d.ts file, right?\r\nIt's far from ideal solution for me. As the lib is modular and every module contains its own references.\r\nAnd anyway that \"entrypoint\" should be imported somewhere and at that place its path in reference will be changed on compiling.\r\n\r\nIt's not clear why tsc can't copy referenced .d.ts into outDir with other created d.ts. If a script imports d.ts via `///<reference>` that means it's needed, so why not to copy it along?"
      },
      {
        "user": "mhegazy",
        "created_at": "2018-04-07T00:13:30Z",
        "body": "So .d.ts files are not considered sources. the compiler does not generate output for them. think of all your `@types` packages for instance.. \r\nThe compiler does not copy references either.. again think of all your `@types\\node` package, you do not want its contents copied to your dist folder just cause you used `require`.\r\nTriple-slash -reference tags are pointers to existing files to include in your compilation, that is all.. we had them before `tsconfig.json` was introduced. it is similar to adding the .d.ts file in the `include` section of your tsconfig.json..\r\nThe only difference is that the compiler traffics it to the output, and thus it ensures that it writes your triple-slash-reference tags correctly to output.., consider use case where you have multiple components with a shared folder with .d.ts files. you want the output to still point to the correct shared folder after it is moved.\r\nLooks to me that the best option here is to have your .d.ts files in your dist folder.. e.g. `dist\\globals\\fileA.d.ts` and reference this in your sources, the compiler will rewrite them in the output to have the correct paths.\r\n"
      },
      {
        "user": "evil-shrike",
        "created_at": "2018-04-09T11:24:15Z",
        "body": "> The compiler does not copy references either.. again think of all your @types\\node package, you do not want its contents copied to your dist folder just cause you used require.\r\n\r\nthat's the problem.\r\nThere're two kinds of `/// <reference>`: with `types` and `path`:\r\n```ts\r\n/// <reference types=\"jquery\" />\r\n/// <reference path=\"../vendor/underscore.d.ts\" />\r\n```\r\nSo for `types` obviously I do not want its contents copied to my dist. \r\nBut for `/// <reference path` yes, I want them to be copied. \r\nLet me show one more example.\r\n\r\nIn my lib I have `modules` folder. It contains so called app-modules. Idea of them is that a module is imported in one place (think main.js) and no one references it or its components directly any more. It's kind a plugin. \r\nLet look at module-reporting.\r\n`module-reporting.ts`:\r\n```ts\r\nimport core = require(\"core\");\r\nimport ReportPagePart = require(\"./ui/ReportPagePart\");\r\nimport ReportPart = require(\"./ui/ReportPart\");\r\n\r\nlet reporting = {\r\n\tReportPart: ReportPart,\r\n\tReportPagePart: ReportPagePart\r\n};\r\ncore.reporting = reporting;\r\n\r\nexport = reporting;\r\n```\r\nThis `module-reporting.ts` is the app-module entry point, it loads all module' components and puts the module object (namespace) into `core.reporting` field.  `core` module is kind a root module for an app.  So somewhere in user code there could be:\r\n```ts\r\nvar core = require(\"core\");\r\nif (core.reporting != null) {\r\n  // reporting supported\r\n  var report = new core.reporting.ReportPart({});\r\n}\r\n```\r\nIdea here is that user code isn't bound to app-module implementation.\r\n\r\nHow does tsc know about that `core.reporting`? It's because `module-reporting.ts` contains a reference to declaration file with augmentation for `core`:\r\n`module-reporting.ts`:\r\n```\r\n/// <reference path=\"./core.all.d.ts\" />\r\n```\r\n`core.all.d.ts`:\r\n```ts\r\n// Extend module `core`\r\ndeclare module \"core\" {\r\n\texport import reporting = require(\"modules/reporting/module-reporting\");\r\n}\r\n```\r\nI'd happy to put this code inside `module-reporting.ts` but that's impossible - I'll get \r\nError:(13, 2) TS2667: Imports are not permitted in module augmentations. Consider moving them to the enclosing external module.\r\n\r\nSo I have to use d.ts and `///<reference` here.  Also I don't want to force users to include that `core.all.d.ts` explicitly via tsconfig, I want they write one import and it just works.\r\nIn this case the declaration file definitely is \"sources\" and the method it's included isn't much my choice, basically it's dictated by the compiler.\r\n\r\nNow I hope you understand how this advice looks like:\r\n>Looks to me that the best option here is to have your .d.ts files in your dist folder.. e.g. dist\\globals\\fileA.d.ts and reference this in your sources, the compiler will rewrite them in the output to have the correct paths.\r\n\r\nI'll have to move all my *.d.ts from modules they belong to to some higher folder (from sources root). That breaks composability and modules encapsulation. And very inconvenient from source organization's point of view as well.\r\n"
      },
      {
        "user": "evil-shrike",
        "created_at": "2018-04-11T10:46:57Z",
        "body": "For the record.\r\nI abandoned both approaches (`--sourceRoot` and `--outDir`). In the end I just compile everything in-place (in staged folder /dist/dist) where I get *.js, *.ts, *.d.ts, *.js.map then just move *.ts and *.js.map into sibling folder structure /dist/src. So the release package contains:\r\n```\r\n├───dist\r\n│     ├───lib/*.js + *.d.ts\r\n│     └───modules/*.js + *.d.ts\r\n├───src\r\n│     ├───lib/*.ts + *.d.ts + *.js.map\r\n│     └───modules/*.ts + *.d.ts + *.js.map\r\n├───tsconfig.json\r\n└───package.json\r\n```\r\n\r\nInside *.js I have local sourcemap references (like `//# sourceMappingURL=file1.js.map`). So if the lib's users want to debug TS they'll need to copy *.ts and *.js.map from `/src` subtree into server's \"wwwroot\".\r\n"
      },
      {
        "user": "typescript-bot",
        "created_at": "2018-04-25T20:28:18Z",
        "body": "Automatically closing this issue for housekeeping purposes. The issue labels indicate that it is unactionable at the moment or has already been addressed."
      }
    ]
  },
  {
    "number": 23195,
    "title": "getSourceFile().moduleName is undefined",
    "created_at": "2018-04-06T05:25:58Z",
    "closed_at": "2018-04-06T18:25:14Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/23195",
    "body": "**TypeScript Version:**  2.8.1\r\n\r\n\r\n**Code**\r\n\r\n**index.ts**\r\n```ts\r\nit('should', () => \"\");\r\n```\r\n\r\n**checker.ts**\r\n```ts\r\nimport * as ts from \"typescript\"\r\n\r\nconst program = ts.createProgram([\"./index.ts\"], { types: [\"jasmine\"] });\r\nconst sourceFile = program.getSourceFile(\"./index.ts\");\r\nconst checker = program.getTypeChecker();\r\n\r\nts.forEachChild(sourceFile, checkNested);\r\n\r\nfunction checkNested(node: ts.Node) {\r\n  if (ts.isCallExpression(node)) {\r\n    const signature = checker.getResolvedSignature(node);\r\n    const file = signature.getDeclaration().getSourceFile();\r\n\r\n    // file.fileName -> ​​​​​c:/git/testing-typescript/node_modules/@types/jasmine/index.d.ts​​​​​\r\n    // file.moduleName -> ​​​​​undefined​​​​​\r\n  }\r\n\r\n  ts.forEachChild(node, checkNested);\r\n}\r\n```\r\n\r\n**Expected behavior:**\r\nI expected that the moduleName returned is not undefined but the moduleName of the source file.\r\n\r\nMy end goal here is that I want to know in which module the expression that I am using is defined in that case the Jasmine `it`. \r\n\r\n**Actual behavior:**\r\nWhen I run checker.ts The filename is resolved and the moduleName is always undefined.",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/23195/comments",
    "author": "alan-agius4",
    "comments": [
      {
        "user": "ajafff",
        "created_at": "2018-04-06T06:17:34Z",
        "body": "You actually want to use `file.fileName`.\r\n\r\n`moduleName` is something related to AMD modules. But that comment is not present in the generated declaration files."
      },
      {
        "user": "alan-agius4",
        "created_at": "2018-04-06T06:57:16Z",
        "body": "Is there anyway to get the moduleName ie: 'jasmine' in any other way?"
      },
      {
        "user": "ghost",
        "created_at": "2018-04-06T15:52:16Z",
        "body": "@alan-agius4 That's not really easy since it requires going backwards from a module path to the way it was imported. You could construct a reverse mapping yourself by looping over the imports of each module and getting what they resolved to:\r\n```ts\r\nfunction add<K, V>(map: Map<K, V[]>, key: K, value: V): void {\r\n    const values = map.get(key);\r\n    if (values) values.push(value); else map.set(key, [value]);\r\n}\r\n\r\nfunction createReverseMap(program: ts.Program): Map<ts.SourceFile, string[]> {\r\n    const checker = program.getTypeChecker();\r\n    const map = new Map<ts.SourceFile, string[]>();\r\n    for (const importer of program.getSourceFiles()) {\r\n        for (const statement of importer.statements) {\r\n            if (!ts.isImportDeclaration(statement) || !ts.isStringLiteral(statement.moduleSpecifier)) continue;\r\n            const importedSym = checker.getSymbolAtLocation(statement.moduleSpecifier)!;\r\n            for (const decl of importedSym.declarations!) {\r\n                if (ts.isSourceFile(decl)) {\r\n                    add(map, decl, statement.moduleSpecifier.text);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return map;\r\n}\r\n```\r\n\r\nIf you're wondering how we synthesize imports for completions, see `function getNewImportInfos` in `importFixes.ts` in this repository, but that method's pretty complicated."
      },
      {
        "user": "alan-agius4",
        "created_at": "2018-04-06T16:15:56Z",
        "body": "Thanks @andy-ms for your response and help. I'll have a look at the mentioned implementations. Though my biggest problem was that I don't have `import` declarations as the module I am interested in is an ambient module.\r\n\r\nI ended up doing something  along these lines;\r\n\r\n```ts\r\nfunction isJasmineExpression(checker: Checker, node: ts.CallExpression): boolean {\r\n  // get the `jasmine` module file path\r\n  const jasmineNode = checker.typeChecker\r\n    .getAmbientModules()\r\n    .find(x => x.name.replace(/\"/g, '') === 'jasmine');\r\n\r\n  if (!jasmineModule) {\r\n    return false;\r\n  }\r\n  const declarations = jasmineModule.getDeclarations();\r\n  let jasmineModulePath = '';\r\n  if (declarations && declarations.length) {\r\n    jasmineModulePath = declarations[0].getSourceFile().fileName;\r\n  }\r\n\r\n  const signature = checker.typeChecker.getResolvedSignature(node);\r\n  const file = signature.getDeclaration().getSourceFile();\r\n\r\n  // math the file path of the `it` with that of `jasmine`\r\n  return jasmineModulePath === file.fileName;\r\n}\r\n```"
      }
    ]
  },
  {
    "number": 23174,
    "title": "Missing typings for URLSearchParams",
    "created_at": "2018-04-05T18:03:57Z",
    "closed_at": "2018-04-19T21:30:09Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/23174",
    "body": "**Search Terms:** \r\n\r\nURLSearchParams\r\n\r\n**Code**\r\n\r\nconst params = new URLSearchParams('?q=hello');\r\nconst keys = [...params.keys()]\r\n\r\n**Expected behavior:**\r\n\r\n(no error)\r\n\r\n**Actual behavior:**\r\n\r\n[ts] Property 'keys' does not exist on type 'URLSearchParams'\r\n\r\n**Playground Link:** <!-- A link to a TypeScript Playground \"Share\" link which demonstrates this behavior --> \r\n\r\n**Related Issues:**\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/23174/comments",
    "author": "philnova",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2018-04-05T19:08:08Z",
        "body": "Make sure you compiler with either:\r\n`tsc --target es6`\r\nor\r\n`tsc --target es5 --lib es6,dom,dom.iterable --downlevelIteration`\r\n"
      },
      {
        "user": "typescript-bot",
        "created_at": "2018-04-19T21:30:09Z",
        "body": "Automatically closing this issue for housekeeping purposes. The issue labels indicate that it is unactionable at the moment or has already been addressed."
      }
    ]
  },
  {
    "number": 22889,
    "title": "Autocompletion for Generic Mapped Types in Typescript (Conditional: Based on First Parameter ,Second Parameter should get Valid Suggestions)",
    "created_at": "2018-03-26T20:47:13Z",
    "closed_at": "2018-04-10T20:50:05Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/22889",
    "body": "_From @sarathkrrish on March 24, 2018 13:21_\n\n```ts\r\n interface rc {}\r\n\r\ninterface rc {\r\n  parent1: {\r\n    children: {\r\n      child1: {\r\n        props: {\r\n          child1prop1: any;\r\n          child1prop2: any;\r\n        };\r\n      },\r\n      child2:{\r\n        props: {\r\n          child2prop1: any\r\n        }\r\n      }\r\n    };\r\n  };\r\n}\r\n\r\n//@ts-ignore\r\ntype ChildProp<T,S> = keyof rc[T][\"children\"][S]['props'];\r\n\r\ndeclare interface sample<T extends keyof rc> {\r\n   //@ts-ignore\r\n  check<S extends keyof rc[T][\"children\"],F extends ChildProp<T,S>>(childid:S,propid:F);\r\n}\r\n```\r\n\r\nAbove one is declarations I am having. I am not sure issue or it is the feature, based on the first parameter in check method, I need to get valid autocomplete suggestions for the second parameter.\r\n\r\n```ts\r\n// Here I will get only child1 props as suggestions but not child2 props .\r\n   var sample = sample<'parent1'>\r\n      sample.check('child1','child1prop1')\r\n```\r\n\r\nVSCode is able to validate the code of first and second parameters of the check method.But it is unable to give autocompletion for the second parameter. Is it possible to provide that? \r\n\r\n\n\n_Copied from original issue: Microsoft/vscode#46464_",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/22889/comments",
    "author": "mjbvz",
    "comments": [
      {
        "user": "mjbvz",
        "created_at": "2018-03-26T20:50:04Z",
        "body": "The first `@ts-ignore` is suppressing errors that likely explain why you don't get proper intellisense. TypeScript cannot infer the keys of `props` from the expression as written. Someone in the TS community may know the correct way to write this"
      },
      {
        "user": "typescript-bot",
        "created_at": "2018-04-10T20:50:04Z",
        "body": "Automatically closing this issue for housekeeping purposes. The issue labels indicate that it is unactionable at the moment or has already been addressed."
      }
    ]
  },
  {
    "number": 22857,
    "title": "Union type in JSX IntrinsicElements seems like a bug",
    "created_at": "2018-03-24T14:14:24Z",
    "closed_at": "2018-03-24T15:30:53Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/22857",
    "body": "```typescript\r\ndeclare namespace JSX {\r\n  interface IntrinsicElements {\r\n    foo: { bar: boolean } | { baz: boolean };\r\n  }\r\n}\r\n\r\nconst one = <foo bar baz />; // ok\r\n```\r\n\r\nHi. Is this a bug? I was expecting this to not compile but it does. \r\n\r\nIn the IntrinsicElements interface the type for `foo` is defined as having a boolean attribute of `foo` **or** `baz` but it compiles when both are set.\r\n\r\nI'm new to typescript so apologies if the issue is just my understanding of the type system.",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/22857/comments",
    "author": "mikelnrd",
    "comments": [
      {
        "user": "MartinJohns",
        "created_at": "2018-03-24T14:57:39Z",
        "body": "Union types are **or**, but not **xor**. **or** means **any** of the types is provided. If all are provided it's fine. **xor** means **one** of the types is provided, not more. Currently it's not directly supported to have a **xor** union type beyond having a discriminated union. See also #14094."
      },
      {
        "user": "mikelnrd",
        "created_at": "2018-03-24T15:30:53Z",
        "body": "Makes sense, thanks for the quick reply."
      }
    ]
  },
  {
    "number": 22856,
    "title": "how to assign values to object with dynamic keys",
    "created_at": "2018-03-24T11:03:51Z",
    "closed_at": "2018-03-26T18:16:14Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/22856",
    "body": "Hi i don't know the key name , it can be anything and it can be any number each time so how to assign values to dynamic keys of object\r\nfor example \r\n\r\nobj[\"anything\"] = anything;\r\n\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/22856/comments",
    "author": "sivahanuman",
    "comments": [
      {
        "user": "DanielRosenwasser",
        "created_at": "2018-03-24T13:59:41Z",
        "body": "Hey there, this issue tracker isn't meant to work as a support forum. These questions tend to be better suited for StackOverflow. You may want to open a question up there instead. Thanks!"
      }
    ]
  },
  {
    "number": 22771,
    "title": "Method dispatching based on this polymorphism",
    "created_at": "2018-03-21T21:08:03Z",
    "closed_at": "2018-04-07T00:16:41Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/22771",
    "body": "**TypeScript Version:**  2.7.2 or 2.8 dev\r\n\r\n**Code**\r\n\r\n```ts\r\ntype ObjectLiteral = object & {\r\n    reduceRight?: 'nope';\r\n}\r\n\r\ninterface Dispatcher<T> {\r\n    at(this: Dispatcher<ObjectLiteral>): string\r\n    at<A>(this: Dispatcher<A[]>): Date\r\n}\r\n\r\n\r\nconst objDispatcher = {} as any as Dispatcher<{}>\r\n// That's fine we got a string back\r\nobjDispatcher.at().toLowerCase()\r\n\r\nconst arrDispatcher = {} as any as Dispatcher<number[]>\r\n// The correct overload should have picked the Array form and returned a Date, but it did not: This does not compile\r\narrDispatcher.at().getTime()\r\n```\r\n\r\nNote that it used to work with TS 2.6.2. In the more recent versions, it simply always choose the first method signature.\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/22771/comments",
    "author": "AlexGalays",
    "comments": [
      {
        "user": "ghost",
        "created_at": "2018-03-23T16:22:54Z",
        "body": "Since `Dispatcher` doesn't use `T` anywhere, every dispatcher is a `Dispatcher<ObjectLiteral>`. If you add `value: T;` to the interface it will work as expected. Not sure why it behaved different in 2.6 but the current behavior of choosing the first matching overload seems correct."
      },
      {
        "user": "AlexGalays",
        "created_at": "2018-03-23T16:32:11Z",
        "body": "Good catch, but in my real code I had a T somewhere in the interface to simulate a nominal type. Looks like this example is too simple; let me get back to you :)"
      },
      {
        "user": "typescript-bot",
        "created_at": "2018-04-07T00:16:40Z",
        "body": "Automatically closing this issue for housekeeping purposes. The issue labels indicate that it is unactionable at the moment or has already been addressed."
      }
    ]
  },
  {
    "number": 22734,
    "title": "convert map/set into array using spread operator does not work in TS Playground",
    "created_at": "2018-03-20T21:16:14Z",
    "closed_at": "2018-04-11T18:50:13Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/22734",
    "body": "This works for the compiler (V 2.7.2) but not in the Playground...\r\n\r\n```\r\nconst testMap = new Map<String, String>();\r\nconst arrayFromMap = [...testMap];\r\n```\r\n\r\n`Array.from(testMap)` works fine in the Playground...\r\n\r\nIt is the same issue for sets.",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/22734/comments",
    "author": "marcelh-gh",
    "comments": [
      {
        "user": "ghost",
        "created_at": "2018-03-20T22:19:41Z",
        "body": "That's because it has a low `--target` setting. We could consider adding that as an option in the UI."
      },
      {
        "user": "marcelh-gh",
        "created_at": "2018-03-22T10:34:54Z",
        "body": "adding target selection as an option in the UI would be awesome :-)\r\n\r\nAnd while at it, maybe also display the currently used TS version in the UI..."
      },
      {
        "user": "typescript-bot",
        "created_at": "2018-04-11T18:50:13Z",
        "body": "Automatically closing this issue for housekeeping purposes. The issue labels indicate that it is unactionable at the moment or has already been addressed."
      }
    ]
  },
  {
    "number": 22666,
    "title": "can get this to work",
    "created_at": "2018-03-16T23:19:16Z",
    "closed_at": "2018-03-19T10:09:15Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/22666",
    "body": "code in question:\r\n```\r\napp.set(\"permission\", {\r\n    after: (res, next, authorizedStatus) => {\r\n        if (authorizedStatus !== \"authorized\") {\r\n            res.redirect(\"/login\" || {});\r\n        } else {\r\n            next();\r\n        }\r\n    }\r\n});\r\n```\r\n\r\nThis is giving this errors when I build\r\n`src/app.ts(52,13): error TS7006: Parameter 'res' implicitly has an 'any' type.`\r\n`src/app.ts(52,18): error TS7006: Parameter 'next' implicitly has an 'any' type.`\r\n`src/app.ts(52,24): error TS7006: Parameter 'authorizedStatus' implicitly has an 'any' type.`\r\n\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/22666/comments",
    "author": "mylastore",
    "comments": [
      {
        "user": "DanielRosenwasser",
        "created_at": "2018-03-19T05:51:39Z",
        "body": "Hey there, this issue tracker isn't meant to work as a support forum. These questions tend to be better suited for StackOverflow. You may want to open a question up there instead. Thanks!"
      }
    ]
  },
  {
    "number": 22611,
    "title": "map return type",
    "created_at": "2018-03-15T20:29:33Z",
    "closed_at": "2018-03-30T20:06:19Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/22611",
    "body": "I am trying to change the return type of a function using a new `infer` syntax.\r\n\r\nExample:\r\n```ts\r\n\r\ntype Convert<T> = T extends (\r\n  arg1: infer A1,\r\n  arg2: infer A2,\r\n) => infer R\r\n  ? (arg1: A1, arg2: A2) => { payload: R }\r\n  : never;\r\n\r\ntype A = (a: number, b: number) => { a: number; b: number };\r\ntype B = Convert<A>\r\n\r\n```\r\n\r\nArgument names (`a`, `b`) cannot be inferred and type B has the signature:\r\n\r\n```ts\r\ntype B = (arg1: number, arg2: number) => {\r\n    payload: {\r\n        a: number;\r\n        b: number;\r\n    };\r\n}\r\n```\r\n\r\nIs it possible to use the same argument names? Or we must wait for variadic types #5453?\r\n\r\n\r\n**TypeScript Version:**  2.80-dev.20180315\r\n\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/22611/comments",
    "author": "lstkz",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2018-03-15T20:35:51Z",
        "body": "What's the desired behavior? Just for the parameter names to match?"
      },
      {
        "user": "lstkz",
        "created_at": "2018-03-15T20:45:49Z",
        "body": "Correct.\r\nIf the autocomplete shows `arg1`, `arg2` etc. then it's hard to use such function."
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2018-03-15T20:52:36Z",
        "body": "You'd need variadic types or something isomorphic to it to maintain the argument names."
      },
      {
        "user": "typescript-bot",
        "created_at": "2018-03-30T20:06:19Z",
        "body": "Automatically closing this issue for housekeeping purposes. The issue labels indicate that it is unactionable at the moment or has already been addressed."
      },
      {
        "user": "lstkz",
        "created_at": "2018-07-03T07:14:17Z",
        "body": "@RyanCavanaugh \r\nAny chance to reopen it?\r\nKeeping the same argument names would be very useful when creating functions like `curry`."
      }
    ]
  },
  {
    "number": 22482,
    "title": "How to dynamically import componenents dynamically using import statements ",
    "created_at": "2018-03-12T08:34:32Z",
    "closed_at": "2018-03-28T21:11:08Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/22482",
    "body": " I have to load a component which has the same name called \"MyComponent\" but located in different folders physically(and the name of the component is \"MyComponent) which has different behavior in each folder) and MyComponent component has to load based on the options which user selects in his previous screens ....\r\n\r\n\r\n\r\nSuppose MyComponent is located in following folders \r\n\r\nOPTION ONE \r\n\r\n`..path1/path2/path3/my-component/my-component.component  `  and this component have to refer to my routing module import statement as shown below and path1,path2, and path2 are some dynamic values which user will select in his previous screens.\r\n\r\n`import {MyComponent } from \"..path1/path2/path3/my-component/my-component.component\" `\r\n\r\n\r\n\r\nNOTE: I am keeping the options which user select in his configuration screens as the same name to the folder name to ease my import statements.\r\n\r\n\r\n\r\nOPTION TWO \r\n\r\n`..path4/path5/path6/my-component/my-component.component  `  and this component have to refer to my routing module import statement as shown below and path4,path5, and path6 are some dynamic values which user will select in his previous screens.\r\n\r\nand import statement will look like below \r\n\r\n`import {MyComponent } from \"..path4/path5/path5/my-component/my-component.component\"`\r\n\r\nsince MyComponent is referred in my declaration array of RoutinModule but if you import above two components in one short compiler will throw an error that MyComponent is already imported,  so I have to import those import statement very dynamically based on user's selections.\r\n\r\n\r\n\r\nHope you understand my problem statement ...\r\n\r\n\r\n\r\nLet me summarise the issue below like, I have to generate import statement dynamically ....",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/22482/comments",
    "author": "vittal288",
    "comments": [
      {
        "user": "ghost",
        "created_at": "2018-03-14T15:58:59Z",
        "body": "Importing dynamically can be tricky -- if performance is not a concern you could import both components up front and choose one later?\r\n```ts\r\nimport { MyComponent as MyComponentA } from \"./a\";\r\nimport { MyComponent as MyComponentB } from \"./b\";\r\n...\r\nconst MyComponent = condition ? MyComponentA : MyComponentB;\r\n```"
      },
      {
        "user": "typescript-bot",
        "created_at": "2018-03-28T21:11:07Z",
        "body": "Automatically closing this issue for housekeeping purposes. The issue labels indicate that it is unactionable at the moment or has already been addressed."
      }
    ]
  },
  {
    "number": 22372,
    "title": "Using createVariableStatement in a compiler transformer breaks the compiler",
    "created_at": "2018-03-07T11:15:49Z",
    "closed_at": "2018-03-07T19:16:36Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/22372",
    "body": "**TypeScript Version:**  2.8.0-dev.20180307\r\n\r\n**Search Terms:** createVariableStatement const\r\n\r\n**Code (compiler)**\r\n\r\n```ts\r\n// A *self-contained* demonstration of the problem follows...\r\nimport * as ts from 'typescript';\r\n\r\nfunction transformer(program: ts.Program): ts.TransformerFactory<ts.SourceFile> {\r\n    return (context: ts.TransformationContext) => (file: ts.SourceFile) => transformFile(program, context, file);\r\n}\r\n\r\nfunction transformFile(program: ts.Program, context: ts.TransformationContext, file: ts.SourceFile): ts.SourceFile {\r\n    const transformedFile = ts.visitEachChild(file, child => visit(child, context, file), context);\r\n    return transformedFile;\r\n}\r\nfunction visit(node: ts.Node, context: ts.TransformationContext, file: ts.SourceFile): ts.Node {\r\n    if (ts.isMethodDeclaration(node)) {\r\n        const newNode = ts.createMethod(\r\n            [ts.createToken(ts.SyntaxKind.StaticKeyword)], \r\n            [], \r\n            null, \r\n            node.name, \r\n            null, \r\n            [], \r\n            node.parameters, \r\n            node.type, \r\n            ts.createBlock([ \r\n                ts.createVariableStatement(\r\n                    [ts.createToken(ts.SyntaxKind.ConstKeyword)], \r\n                    [ts.createVariableDeclaration('myConst', null, ts.createLiteral('value'))]\r\n                ),\r\n                ...(node.body ? node.body.statements : [])\r\n            ])\r\n        );\r\n        console.log(ts.createPrinter().printNode(ts.EmitHint.Unspecified, newNode, file));\r\n        return newNode;\r\n    }\r\n    return ts.visitEachChild(node, child => visit(child, context, file), context);\r\n}\r\n\r\nconst program = ts.createProgram([\r\n  '../transformer-issue-src/src/A.ts'\r\n], {\r\n    target: ts.ScriptTarget.ES5,\r\n    module: ts.ModuleKind.CommonJS,\r\n    moduleResolution: ts.ModuleResolutionKind.NodeJs,\r\n    importHelpers: true,\r\n    alwaysStrict: true,\r\n    noImplicitAny: true,\r\n    noImplicitThis: true,\r\n    removeComments: true,\r\n    sourceMap: true,\r\n    outDir: \"../transformer-issue-src/lib\",\r\n    declaration: true,\r\n    declarationDir: \"../transformer-issue-src/lib\",\r\n    lib: [\r\n      \"lib.es2017.d.ts\",\r\n    ],\r\n    experimentalDecorators: true,\r\n    noEmitOnError: true,\r\n});\r\n\r\nconst transformers = {\r\n  before: [\r\n    transformer(program),\r\n  ]\r\n}\r\nconst result = program.emit(undefined, undefined, undefined, false, transformers);\r\n```\r\n\r\n**Code (test program, ../transformer-issue-src/src/A.ts)**\r\n\r\n```ts\r\nexport class A {\r\n    static myMethod() {\r\n        return 'value';\r\n    }\r\n}\r\n```\r\n\r\n**Expected behavior:**\r\nThe .js file should be emitted.\r\nThe `console.log` statement should print the following:\r\n\r\n```ts\r\nstatic myMethod() { const myConst = \"value\"; return 'value'; }\r\n```\r\n\r\n**Actual behavior:**\r\nThe .js file is not emitted due to a compiler exception. Message and stack trace:\r\n\r\n```\r\nTypeError: Cannot read property 'transformFlags' of null\r\n    at aggregateTransformFlagsForNode (d:\\solutions\\transformer-issue-compiler\\node_modules\\typescript\\lib\\typescript.js:54626:18)\r\n    at Object.aggregateTransformFlags (d:\\solutions\\transformer-issue-compiler\\node_modules\\typescript\\lib\\typescript.js:54611:9)\r\n    at visitNode (d:\\solutions\\transformer-issue-compiler\\node_modules\\typescript\\lib\\typescript.js:53754:12)\r\n    at Object.visitEachChild (d:\\solutions\\transformer-issue-compiler\\node_modules\\typescript\\lib\\typescript.js:54053:108)\r\n    at visitVariableDeclaration (d:\\solutions\\transformer-issue-compiler\\node_modules\\typescript\\lib\\typescript.js:61625:30)\r\n    at Object.flatMap (d:\\solutions\\transformer-issue-compiler\\node_modules\\typescript\\lib\\typescript.js:2047:25)\r\n    at visitVariableDeclarationList (d:\\solutions\\transformer-issue-compiler\\node_modules\\typescript\\lib\\typescript.js:61510:39)\r\n    at visitJavaScript (d:\\solutions\\transformer-issue-compiler\\node_modules\\typescript\\lib\\typescript.js:60282:28)\r\n    at visitor (d:\\solutions\\transformer-issue-compiler\\node_modules\\typescript\\lib\\typescript.js:60243:24)\r\n    at visitNode (d:\\solutions\\transformer-issue-compiler\\node_modules\\typescript\\lib\\typescript.js:53755:23)\r\n```\r\n\r\nEven if I remove the `ts.createToken(ts.SyntaxKind.ConstKeyword)` token, this exception is still thrown.\r\n\r\nAlso, the `console.log` statement prints the following (the var keyword is left there):\r\n\r\n```ts\r\nstatic myMethod() { const var myConst = \"value\"; return 'value'; }\r\n```",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/22372/comments",
    "author": "pedro-pedrosa",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2018-03-07T17:43:02Z",
        "body": "80% sure the problem is that you're passing `null` instead of `undefined` for some of those parameters. The TS API basically never uses `null` and will behave badly if given it because it's only ever checking for ` === undefined`"
      },
      {
        "user": "pedro-pedrosa",
        "created_at": "2018-03-07T18:33:44Z",
        "body": "Replacing the `null` in `createVariableDeclaration` with `undefined` made the exception go away (wasn't needed on createMethod), however it still prints `const var`."
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2018-03-07T18:56:58Z",
        "body": "Pass `NodeFlags.Const` to `createVariableDeclarationList` rather than trying to push in a `const` keyword in the array.\r\n\r\nThere are lots of examples in the TypeScript codebase that show calling this function correctly."
      },
      {
        "user": "pedro-pedrosa",
        "created_at": "2018-03-07T19:16:36Z",
        "body": "That worked, I have a correct output now.\r\n\r\nThank you."
      }
    ]
  },
  {
    "number": 22045,
    "title": "Ambient declarations of mixins",
    "created_at": "2018-02-20T09:53:40Z",
    "closed_at": "2018-07-30T16:23:45Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/22045",
    "body": "Declarations of mixins are not handled as expected by TypeScript compiler, I can't find a way to make it work manually either.\r\n\r\n**Search Terms:**\r\n- ambient mixin declaration\r\n- type 'T & Constructor<T>' is not a constructor function type\r\n- mixin type annotations\r\n\r\n**Code**\r\n\r\nOne of the solutions I've tried (out of tens):\r\n\r\nDeclaration:\r\n```ts\r\ntype Constructor<T = {}> = new (...args: any[]) => T;\r\nfunction mixin<T extends Constructor<SomeClass>>(\r\n  superClass: T,\r\n): Constructor<T> & T;\r\n```\r\n\r\nUsage:\r\n```ts\r\nconst anotherMixin = <T extends Constructor<SomeClass>>(\r\n  superClass: T,\r\n) =>\r\n  class extends mixin(superClass) {}\r\n```\r\n**Expected behavior:**\r\nI'd expect it to be possible to make ambient type declarations for mixins.\r\n\r\n**Actual behavior:**\r\nTypeScript compiler emits these declarations by copying all of the fields from parent classes.\r\n\r\nThere's no way to make a type declarations manually.\r\n\r\n**Playground Link:**\r\nPlayground does not support emitting type declarations.",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/22045/comments",
    "author": "merlinnot",
    "comments": [
      {
        "user": "DanielRosenwasser",
        "created_at": "2018-02-20T20:39:39Z",
        "body": "> ```ts\r\n> type Constructor<T = {}> = new (...args: any[]) => T;\r\n> function mixin<T extends Constructor<SomeClass>>(\r\n>   superClass: T,\r\n> ): Constructor<T> & T;\r\n> ```\r\n> \r\n\r\nhere `T` is the original constructor type - I'm pretty sure you want to write something like `Constructor<MixedInstanceType> & T`\r\n\r\n```ts\r\ninterface MixedInstance {\r\n  yay: any;\r\n}\r\n\r\ndeclare function mixin<T extends Constructor<SomeClass>>(\r\n    superClass: T,\r\n): Constructor<MixedInstance> & T;\r\n```"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2018-02-20T20:43:11Z",
        "body": "You can then write something like\r\n\r\n```ts\r\ninterface AnotherMixinInstance {\r\n  // ...\r\n}\r\n\r\ndeclare const anotherMixin:\r\n    <T extends Constructor<SomeClass>>(ctor: T) =>\r\n        Constructor<AnotherMixinInstance> & Constructor<MixedInstance> & T;\r\n```"
      },
      {
        "user": "merlinnot",
        "created_at": "2018-02-26T20:11:44Z",
        "body": "Let me be more specific here, maybe I'm missing something:\r\n\r\nI'm using a library which provides a mixin for classes extending `HTMLElement`, but there are no type declarations for this library. This mixin does not introduce any new props/methods, it's declaration could be empty.\r\n\r\nI want to create another mixin which overrides some of the functionalities of the one from the library, it does not define any new props/methods neither.\r\n\r\nSo basically I have something like this:\r\n`mixinFromLibrary.d.ts`\r\n```ts\r\ntype Constructor<T = {}> = new (...args: any[]) => T;\r\nfunction mixinFromLibrary<T extends Constructor<HTMLElement>>(\r\n  superClass: T,\r\n): Constructor<T> & T;\r\n```\r\n\r\nand my implementation, which is built on top of the one from the library:\r\n```ts\r\nconst myMixin = <T extends Constructor<HTMLElement>>(superClass: T) =>\r\n  class extends mixinFromLibrary(superClass) {}\r\n```\r\n\r\nBy doing so I get `Type ... is not a constructor function type`. I'd like `class extends mixinFromLibrary(superClass)` to be equal (in terms of type) to class extends superClass."
      },
      {
        "user": "merlinnot",
        "created_at": "2018-04-07T08:40:18Z",
        "body": "Works in the latest version."
      },
      {
        "user": "merlinnot",
        "created_at": "2018-04-22T13:02:29Z",
        "body": "Actually it doesn't :("
      },
      {
        "user": "typescript-bot",
        "created_at": "2018-07-30T16:23:44Z",
        "body": "Automatically closing this issue for housekeeping purposes. The issue labels indicate that it is unactionable at the moment or has already been addressed."
      }
    ]
  },
  {
    "number": 21935,
    "title": "String Based Enum - Reverse Mapping Problem",
    "created_at": "2018-02-14T09:55:08Z",
    "closed_at": "2018-02-14T16:25:26Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/21935",
    "body": "My TypeScript Version is 2.7.1\r\n\r\n1. enum Country{\r\n2.     India = \"INR\",\r\n3.     France = \"EUR\",\r\n4.     USA = \"USD\",\r\n5.     Germany = France\r\n6. }\r\n7. let vx : Country = Country.India;\r\n8. console.log(\"vx is \"+vx);\r\n9. console.log(\"enum name is \"+Country[vx]);\r\n\r\nThe output are as follows\r\n\r\nvx is INR\r\nenum name is undefined\r\n\r\nIn Line 9, the reverse mapping is not working for string based enum.\r\n\r\nThanks\r\n\r\nKannan Wisen",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/21935/comments",
    "author": "kannanwisen",
    "comments": [
      {
        "user": "j-oliveras",
        "created_at": "2018-02-14T10:35:31Z",
        "body": "String enums has no reverse mapping. Is by design.\r\n\r\nSee last part of entry post of #15486."
      },
      {
        "user": "kannanwisen",
        "created_at": "2018-02-14T11:01:46Z",
        "body": "Thanks for your information"
      },
      {
        "user": "marcelh-gh",
        "created_at": "2018-03-08T18:37:15Z",
        "body": "@RyanCavanaugh Hi! Could you please explain, why the TS team insists on string enums not having reverse mapping functionality? I have found lots of discussions about it but did not find the rationale behind the decision. Thanks a lot! Cheers, Marcel"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2018-03-08T18:44:34Z",
        "body": "If we provided the reverse map automatically (which, by the way, is not necessarily non-ambiguous!), then you'd have no way to distinguish keys from values unless there was a completely separate object created at runtime. It is trivial to write a function that constructs the reverse map if you want it; our goal is to emit as little code as possible so it makes sense to just emit the data you *need* (to keep code size down) and let you construct the reverse map on an as-needed basis."
      },
      {
        "user": "marcelh-gh",
        "created_at": "2018-03-08T20:20:51Z",
        "body": "@RyanCavanaugh That makes sense. Thanks a lot for the explanation! :-)"
      }
    ]
  },
  {
    "number": 21877,
    "title": "Salsa Intellisense for parameters of closures with javascript",
    "created_at": "2018-02-12T07:14:55Z",
    "closed_at": "2018-02-13T07:53:23Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/21877",
    "body": "**Version:**  VS2017\r\n\r\nMy TypeScript project produces a `.d.ts` file. Which is perfect for TS projects:\r\n\r\n```ts\r\ndeclare function myGlobal(param: string): string;\r\ndeclare module myHmi {\r\n    class foo {\r\n        static myStatic(bar: string): string;\r\n    }\r\n}\r\n```\r\n\r\nBut other teams are on JS and wants to use our nice typings. They have the .d.ts file inside the project. VS2017 detects it in the new JS Language Service (Salsa).\r\n\r\n```js\r\nvar myHmi;\r\n(function (myHmi) {\r\n    // Here VS2017 knows myGlobal()\r\n    // Here VS2017 detected myHmi as {}. So it has no knowledge of myHmi.foo.myStatic()\r\n\r\n    main code...\r\n})(myHmi || (myHmi = {}));\r\n\r\n// Here VS2017 knows myGlobal()\r\n// Here VS2017 knows myHmi.foo.myStatic()\r\n\r\n```\r\nCan we use a hint (jsdoc magic?) to tell VS that the inner myHmi is an extension of the outer myHmi?\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/21877/comments",
    "author": "HolgerJeromin",
    "comments": [
      {
        "user": "ghost",
        "created_at": "2018-02-12T15:23:13Z",
        "body": "The JS developers should *also* be able to use the `.d.ts` file instead of the compiled `.js`. Just give it the same name and put it next to the `.js` file. So I don't see why it would be important to have accurate typings inside of the compiled code?"
      },
      {
        "user": "HolgerJeromin",
        "created_at": "2018-02-12T17:05:55Z",
        "body": "The JS developers are including their code into `myHmi` TS module infrastructure (as an extension). \r\nThey do not code in compiled code but their JS code looks the same as TS transpiled output."
      },
      {
        "user": "ghost",
        "created_at": "2018-02-12T17:15:34Z",
        "body": "So your JS developers are manually writing code that looks like TS transpiled output?\r\nIf you omit `var myHmi` it will work...\r\n```js\r\n(function (myHmi) {\r\n    myHmi.foo; // works\r\n\r\n// @ts-ignore (cannot assign to myHmi because it is not a variable)\r\n})(myHmi || (myHmi = {}));\r\n```"
      },
      {
        "user": "HolgerJeromin",
        "created_at": "2018-02-13T07:53:23Z",
        "body": "> So your JS developers are manually writing code that looks like TS transpiled output?\r\n\r\nYes. We want to elevate them eventually to Typescript. \r\n\r\n`})(myHmi || (myHmi = {}));`\r\n\r\nThis does not work in my complex code in VS 15.5.4, JS language service 2.0, TS Tools 15.5.11025.1\r\nI need to have:\r\n`})(myHmi);`\r\n\r\nBut this is working pretty good. \r\nThanks for your help."
      }
    ]
  },
  {
    "number": 21723,
    "title": "Export `with` as a property within declaration file",
    "created_at": "2018-02-07T16:28:41Z",
    "closed_at": "2018-02-08T16:39:59Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/21723",
    "body": "I got a CommonJS module that exports a function by default. The function has a property named `with`, which is a reserved word in JavaScript. JavaScript allows this kind of usage (`with` as a property name), but unfortunately, I can't get it working in TS declaration file.\r\n\r\n## Code\r\n**a.js**\r\n```javascript\r\nmodule.exports = () => 1;\r\nmodule.exports.with = (n: number) => 1 + n;\r\n```\r\n\r\n**a.d.ts**\r\n```ts\r\nexport = GetNumber;\r\n\r\ndeclare function GetNumber(): number;\r\n\r\ndeclare namespace GetNumber {\r\n\texport function with(n: number): number;\r\n}\r\n```\r\n\r\n**b.ts**\r\n```ts\r\nimport * as getNumber from './a';\r\n\r\nconsole.log(getNumber()); // => 1\r\nconsole.log(getNumber.with(2)); // => 3\r\n```\r\n\r\n## Expected behavior:\r\n\r\nDeclaration should be valid for both `getNumber` and `getNumber.with`.\r\n\r\n## Actual behavior:\r\n\r\nGetting an error in compilation:\r\n```\r\n$ tsc a.d.ts\r\na.d.ts(6,19): error TS1003: Identifier expected.\r\na.d.ts(6,25): error TS1005: ')' expected.\r\na.d.ts(6,33): error TS1005: ';' expected.\r\na.d.ts(6,34): error TS1128: Declaration or statement expected.\r\n```",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/21723/comments",
    "author": "yardnsm",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2018-02-07T17:44:56Z",
        "body": "use `export { ... as with }` instead:\r\n\r\n```ts\r\nexport = GetNumber;\r\n\r\ndeclare function GetNumber(): number;\r\n\r\ndeclare namespace GetNumber {\r\n    function _with(n: number): number;\r\n    export { _with as with}\r\n}\r\n```"
      },
      {
        "user": "yardnsm",
        "created_at": "2018-02-08T16:39:59Z",
        "body": "Awesome, it works!\r\nThanks :)"
      }
    ]
  },
  {
    "number": 21428,
    "title": "Variable resolution in abstract classes",
    "created_at": "2018-01-26T22:31:45Z",
    "closed_at": "2018-01-29T18:24:11Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/21428",
    "body": "Hi,\r\n\r\nWhile setting up a Linked List pattern, I've noticed that, when it comes to abstract classes, I can use a `as this['opt']` trick to resolve a variable with its actual type:\r\n\r\n```\r\nabstract class oAbstract {\r\n    public opt: any;\r\n\r\n    test() {\r\n        // without the 'as this[\"opt\"]', the opt at the bottom of the code would be type \"any\"\r\n        return this.opt as this[\"opt\"];    \r\n    }\r\n}\r\n\r\nclass oConcrete extends oAbstract {\r\n    opt = { 'concreteOpt': true }\r\n}\r\n\r\nlet opt = (new oConcrete).test();   // type: {'concreteOpt': boolean;}\r\n```\r\n\r\nIt also seems to preserve the generics:\r\n\r\n```\r\nclass Option<T> {\r\n    constructor(public opt: T) {}\r\n\r\n    getValue() {\r\n        return this.opt;\r\n    }\r\n}\r\n\r\nabstract class oAbstract2 {\r\n    public opt: any;\r\n\r\n    test() {\r\n        return this.opt as this[\"opt\"];\r\n    }\r\n}\r\n\r\nclass oConcrete2 extends oAbstract2 {\r\n    opt = new Option(\"hop\");\r\n}\r\n\r\nlet o2 = new oConcrete2;\r\nlet opt2 = o2.test();  // Type: Option<string>\r\n```\r\n\r\nIt's powerful, and actually saving my life, when I need accurate typings over classical OOP patterns such as linked lists, abstract factories, decorators and so on...\r\n\r\nI why just wondering, since TS keeps the current type, why such a behavior is not the default. I can't think of a case when a developer would want a method from an object inheritance chain not to return the typings corresponding to the current variable. Are there side-effects to that?",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/21428/comments",
    "author": "degardinn",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2018-01-29T18:24:11Z",
        "body": "`this`-bound types have fairly heavy performance implications as far as things go; this was briefly the default when we were writing `this` types and it was found that many real-world codebases became unbearably slow to typecheck."
      },
      {
        "user": "degardinn",
        "created_at": "2018-01-29T20:04:41Z",
        "body": "It makes perfect sense. Thanks for the explanation."
      }
    ]
  },
  {
    "number": 21421,
    "title": "Mapped type should take a function form as well",
    "created_at": "2018-01-26T06:02:30Z",
    "closed_at": "2018-01-30T04:32:28Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/21421",
    "body": "According to #12114 mapped types currently support following forms:\r\n\r\n```ts\r\n{ [ P in K ] : T }\r\n{ [ P in K ] ? : T }\r\n{ readonly [ P in K ] : T }\r\n{ readonly [ P in K ] ? : T }\r\n```\r\n\r\nI think it shall also at least support a function form:\r\n\r\n```ts\r\n{ ([ P in K ]) : T }\r\n{ ([ P in K ]) ? : T }\r\n{ ([ P in K])(entities: P[], someBoolean: boolean) ? : T }\r\n```\r\n\r\nCurrently Im trying to implement a `Functionize<T>` interface which forces implementors to implement any property of the T, but make it a function with maybe additional arguments. Example:\r\n\r\n```ts\r\ninterface User {\r\n     name: string;\r\n     age: number\r\n}\r\n```\r\n\r\nI want to do Functionize<User> which I want to give me:\r\n\r\n```ts\r\n{\r\n       name(names: string[]): string;\r\n       age(ages: number[]): number;\r\n}\r\n```\r\n\r\nAnd I'm asking about following method signature:\r\n\r\n```ts\r\ntype Functionize<T> = {\r\n   [P in keyof T](values: T[])?: T[P];\r\n};\r\n```",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/21421/comments",
    "author": "pleerock",
    "comments": [
      {
        "user": "pleerock",
        "created_at": "2018-01-26T06:04:57Z",
        "body": "Someone suggested to do:\r\n\r\n```ts\r\ntype Functionize <T> = {\r\n   [P in keyof T]: () => T[P];\r\n};\r\n```\r\n\r\nhowever it does not work with extra function parameters, e.g.\r\n\r\n```ts\r\ntype Functionize <T> = {\r\n   [P in keyof T]: (values: T[]) => T[P];\r\n};\r\n```\r\n\r\ncompiler have no errors when values argument is not defined in the implementor of Functionize interface.\r\n\r\nEDIT: it appears to work partially, if I define lets say `name(names: boolean[])` instead of `name(names: string[])` it will give me a compiler error, however if I do simply `name()` its not telling me that names is required parameter."
      },
      {
        "user": "jack-williams",
        "created_at": "2018-01-26T14:14:10Z",
        "body": "> however if I do simply name() its not telling me that names is required parameter.\r\n\r\nI believe the issue is that a signature that accepts fewer inputs is assignable to one that accepts more (provided they agree on matching parameters and output). So the following is acceptable:\r\n\r\n```typescript\r\nlet f: () => number = () => 42;\r\nlet g: (x: number[]) => number = f;\r\n```\r\n\r\nIn your specific example, the type `{ name: () => string }` is assignable to the type `{ name: (names: string[]) => string }`.\r\n\r\nYou get a compiler error when using `boolean[]` because they disagree on a shared parameter.\r\n\r\nAlso, from your requirements I think the definition of `Functionize` should be: \r\n```typescript\r\ntype Functionize <T> = {\r\n   [P in keyof T]: (values: (T[P])[]) => T[P]; // or [P in keyof T]?: (values: (T[P])[]) => T[P] if you want optional properties \r\n};\r\n```\r\n(added a lookup on the type of `values`."
      },
      {
        "user": "pleerock",
        "created_at": "2018-01-29T09:16:02Z",
        "body": "> Also, from your requirements I think the definition of Functionize should be:\r\n\r\ncorrect, sorry Im using a bit different code, I just wanted to provide an example and make this mistake.\r\n\r\n> In your specific example, the type { name: () => string } is assignable to the type { name: (names: string[]) => string }.\r\n\r\ncorrect, that's exactly issue I have. Is it tracked, or is it by design? "
      },
      {
        "user": "jack-williams",
        "created_at": "2018-01-29T10:21:52Z",
        "body": "I believe it's by design. From the spec:\r\n\r\n> M has a rest parameter or the number of non-optional parameters in N is less than or equal to the total number of parameters in M.\r\n\r\nwhen defining whether call-signature N is a subtype of call-signature M.\r\n\r\nIntuitively if a user writes a function of type `() => number`, then it can always ignore extra arguments given and still return a number. So it also works when used as the type `(x: boolean) => number` or `(names: number[]) => number`.\r\n\r\nThe only way I could see this being something you *don't* want is if the output of the function *must* come from the input of the function. So in the type:\r\n```\r\n{\r\n       name(names: string[]): string;\r\n       age(ages: number[]): number;\r\n}\r\n```\r\n\r\nthe output of `name` always comes from an element in `names`, and the output of `age` always comes from an element in `ages`. If this is something you want, then I think the most likely solution will be parametricity and generics. Instead, would the follow types for you work?\r\n```\r\n{\r\n       name<X>(names: X[]): X;\r\n       age<X>(ages: X[]): X;\r\n}\r\n```\r\nThe rules about adding extra inputs to a function signature still apply, but in this case it's impossible to create something of type `X` out of nothing (unless you cheat and use `any`). An implementor of the function will not be able to write a function with the type: `<X>() => X`; the only way to return an `X` is to use one that is given to you from the input."
      },
      {
        "user": "mhegazy",
        "created_at": "2018-01-30T00:33:10Z",
        "body": "here is the syntax for definitnon a mapped type with function typed properties:\r\n\r\n```ts\r\ntype Funcs<T> = {[P in keyof T]?: (entities: P[], someBoolean: boolean) => T };\r\n```"
      },
      {
        "user": "pleerock",
        "created_at": "2018-01-30T04:32:28Z",
        "body": "okay thank you guys, I think this issue can be closed."
      }
    ]
  },
  {
    "number": 21229,
    "title": "how to user typescript genericity  like the C#",
    "created_at": "2018-01-17T14:24:07Z",
    "closed_at": "2018-02-01T20:48:23Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/21229",
    "body": "public class Singleton<T> where T: class,new()  \r\n{  \r\n\tprivate static T _instance;  \r\n\tprivate static readonly object syslock=new object();  \r\n\t\r\n\tpublic static T getInstance()   \r\n\t{  \r\n\t\tif (_instance == null)  \r\n\t\t{  \r\n\t\t\tlock (syslock) {  \r\n\t\t\t\tif (_instance == null)  \r\n\t\t\t\t{  \r\n\t\t\t\t\t_instance = new T();  \r\n\t\t\t\t}  \r\n\t\t\t}  \r\n\t\t}  \r\n\t\treturn _instance;  \r\n\t}  \r\n}  \r\n\r\nhow to user typescript to write this?\r\n\r\n\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/21229/comments",
    "author": "gkjolin",
    "comments": [
      {
        "user": "gkjolin",
        "created_at": "2018-01-17T15:20:46Z",
        "body": "In typescript. there is no new T(). how could I do this? "
      },
      {
        "user": "ghost",
        "created_at": "2018-01-17T15:51:45Z",
        "body": "JavaScript has a different execution model than C#. In particular, there are no threads. So patterns you used in C# may not be applicable any more. You may want to study up on the JavaScript language to learn the different ways things are done.\r\nIn this case, instead of using the singleton pattern to expose a value, you can just export it as a value like so:\r\n\r\n**definition.ts**\r\n```ts\r\nexport const myValue = { /*...object contents here...*/ };\r\n```\r\n**user.ts**\r\n```ts\r\nimport { myObject } from \"./definition\";\r\n```"
      },
      {
        "user": "ghost",
        "created_at": "2018-01-17T15:55:25Z",
        "body": "Not that I think this is a good idea, but just for reference, a more direct translation of what you're trying might look like this:\r\n```ts\r\nfunction lazyInstanceGetter<T>(cls: new () => T): () => T {\r\n    let value: T | undefined;\r\n    return () => {\r\n        if (value === undefined) {\r\n            value = new cls();\r\n        }\r\n        return value;\r\n    };\r\n}\r\n\r\nclass C {}\r\nconst cGetter = lazyInstanceGetter(C);\r\nconst theC = cGetter();\r\n```\r\n\r\nBut you probably don't actually need lazy initialization, so I would recommend just `export const theC = new C();` (or forget the class and just use an object literal) instead."
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2018-01-17T19:41:43Z",
        "body": "Please do not use our issue tracker for questions in the future, as StackOveflow is a more well-suited venue."
      },
      {
        "user": "typescript-bot",
        "created_at": "2018-02-01T20:48:23Z",
        "body": "Automatically closing this issue for housekeeping purposes. The issue labels indicate that it is unactionable at the moment or has already been addressed."
      }
    ]
  },
  {
    "number": 21186,
    "title": "Javascript Maps are treated as arrays under spread operation",
    "created_at": "2018-01-15T07:14:46Z",
    "closed_at": "2018-01-15T18:27:54Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/21186",
    "body": "<!-- Please try to reproduce the issue with `typescript@next`. It may have already been fixed. -->\r\n**TypeScript Version:**\r\n\r\nTested with version typescript@2.7.0-dev.20180113 and latest 2.6.2:\r\n\r\n```typescript\r\nconst a = new Map<number, number>();\r\na.set(0, 0);\r\na.set(1, 1);\r\n\r\nconst b = new Map<number, number>();\r\nb.set(2, 2);\r\nb.set(3, 3);\r\n\r\nconst c = [...a, ...b]; // Type 'Map<number, number>' is not an array type.\r\n```\r\n\r\nRunning `tsc` on the above code also produces:\r\n\r\n```javascript\r\nvar a = new Map();\r\na.set(0, 0);\r\na.set(1, 1);\r\nvar b = new Map();\r\nb.set(2, 2);\r\nb.set(3, 3);\r\nvar c = a.concat(b);\r\n```\r\n\r\n**Expected behavior:**\r\n\r\nMaps under spread operator are treated like Maps.\r\n\r\n**Actual behavior:**\r\n\r\nMaps are treated as arrays.\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/21186/comments",
    "author": "alexluecke",
    "comments": [
      {
        "user": "ajafff",
        "created_at": "2018-01-15T08:26:59Z",
        "body": "Since you get a type error (`Type 'Map<number, number>' is not an array type.`) you cannot expect valid transpiled code.\r\nAlso note that you cannot spread Maps without `target` >= ES6 or `--downlevelIteration` enabled."
      },
      {
        "user": "alexluecke",
        "created_at": "2018-01-15T16:58:56Z",
        "body": "My tsconfig:\r\n\r\n```\r\n{\r\n  \"compilerOptions\": {\r\n    \"target\": \"es6\",\r\n    \"module\": \"commonjs\",\r\n    \"lib\": [\"es6\", \"dom\"],\r\n    \"strict\": true\r\n  }\r\n}\r\n```\r\n\r\nStill get `'Map<number, number>' is not an array type.` when running `tsc`. When running with `--downlevelIteration` (with either `es5` or `es6` as target) it produces the error:\r\n\r\n` Type 'Map<number, number>' is not an array type or does not have a '[Symbol.iterator]()' method that returns an iterator.`"
      },
      {
        "user": "alexluecke",
        "created_at": "2018-01-15T18:27:54Z",
        "body": "`tsc file.ts --lib es2015 --downlevelIteration` and `tsc file.ts --lib es6 --downlevelIteration` produces correct output. Closing."
      }
    ]
  },
  {
    "number": 21179,
    "title": "Index which's key's type is number can accept string keys",
    "created_at": "2018-01-14T11:46:36Z",
    "closed_at": "2018-01-17T20:19:25Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/21179",
    "body": "When I declare an index like this:\r\nlet index: {[index: number]: string} = {};\r\nThen I can add a member to the index like this:\r\nindex['3s'] = 3;\r\nThe type of the key '3s' is string. But this works. Is this a bug? ",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/21179/comments",
    "author": "Lcng",
    "comments": [
      {
        "user": "yortus",
        "created_at": "2018-01-15T01:46:40Z",
        "body": "JavaScript objects coerce numeric indices to strings behind the scenes, leading to some modeling challenges for TypeScript. See some of the related issues for further explanation: #17191, #13715, #12425.\r\n"
      }
    ]
  },
  {
    "number": 21161,
    "title": "why we use import { Component, OnInit } '@angular/core';",
    "created_at": "2018-01-12T08:48:56Z",
    "closed_at": "2018-01-12T15:44:52Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/21161",
    "body": "import { Component, OnInit } from '@angular/core';\r\nimport { Hero } from '../hero';\r\nimport { HeroService } from '../hero.service';\r\n\r\n\r\n<!--why we use this in the ts file when we insert new ts file all this is not available but why do we need to import-->\r\n//can someone explain please.... ",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/21161/comments",
    "author": "nithintel",
    "comments": [
      {
        "user": "ghost",
        "created_at": "2018-01-12T15:44:52Z",
        "body": "You might want to ask someplace where you could get help with angular. This is an issue tracker for the TypeScript language itself and we're not knowledgeable about angular."
      }
    ]
  },
  {
    "number": 21096,
    "title": "Issue with generic extension of object with index signature that returns functions",
    "created_at": "2018-01-09T17:19:58Z",
    "closed_at": "2018-01-09T21:03:58Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/21096",
    "body": "**TypeScript Version:**  2.7.0-dev.20180109\r\n\r\nHi. I ran into this issue trying to assign a class to a generic type that takes in T which extends an index signature type [s:string]:Function. The same issue happens with index sig [s:string]:new(..._)=>any\r\n\r\n**Code**\r\n\r\n```ts\r\nclass C {\r\n}\r\n\r\ntype Test<T extends {[s:string]:Function}> = {};\r\n\r\nconst t:Test<{c:C}> = { //error\r\n\tc:C,\r\n};\r\n\r\ntype Test2 = {\r\n\t[s:string]:Function\r\n}\r\n\r\nconst f:Test2 = {c:C}; //fine\r\n```\r\n\r\n**Expected behavior:**\r\nI should be able to assign {c:C} to the generic type\r\n\r\n**Actual behavior:**\r\n\r\nerror: \r\n\r\nError:(6, 14) TS2344: Type '{ c: C; }' does not satisfy the constraint '{ [s: string]: Function; }'.\r\n  Property 'c' is incompatible with index signature.\r\n    Type 'C' is not assignable to type 'Function'.\r\n      Property 'apply' is missing in type 'C'.\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/21096/comments",
    "author": "dontsave",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2018-01-09T18:26:10Z",
        "body": "i think you meant `Test<{c:typeof C}>` there. `C` refers to the instance type of `C`, `typeof C` refers to the type of the constructor function for `C`."
      },
      {
        "user": "dontsave",
        "created_at": "2018-01-09T18:45:01Z",
        "body": "that makes sense now thanks. Took a minute to wrap my head around. "
      }
    ]
  },
  {
    "number": 20960,
    "title": "Use Latitude and Longitude",
    "created_at": "2018-01-02T14:59:11Z",
    "closed_at": "2018-01-02T16:17:38Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/20960",
    "body": "I need to do calculations from my current location.\r\nI use the following code:\r\n\r\ngetLocation() {\r\n  if (navigator.geolocation) {\r\n    navigator.geolocation.getCurrentPosition(\r\n      function(position) {\r\n        alert(position.coords.latitude + ' ' + position.coords.longitude);\r\n        this.lat = position.coords.latitude;\r\n        this.lon = position.coords.longitude;\r\n        alert(this.lat + ' ' + this.lon);\r\n      },\r\n      function errorCallback(error) {\r\n        console.log('Geolocation error : code ' + error.code + ' - ' + error.message);\r\n        alert('Une erreur est survenue durant la géolocalisation. Veuillez réessayer plus tard ou contacter le support.');\r\n      },\r\n      {\r\n          maximumAge: Infinity,\r\n          timeout: 5000\r\n      }\r\n  );\r\n}\r\n}\r\n\r\nthe first alert is ok. But...\r\n\r\nThe second alert produces the following error:\r\nERROR TypeError: Cannot set property 'lat' of null\r\n\r\nlat and lon are global variables\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/20960/comments",
    "author": "karmen1974",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2018-01-02T16:17:38Z",
        "body": "This is an issue tracker, not a support forum. Please do not ask for help debugging your code here."
      },
      {
        "user": "karmen1974",
        "created_at": "2018-01-02T16:27:54Z",
        "body": "Y le parece poco el problema que tienen, que las variables globales no le funcionen???? "
      },
      {
        "user": "j-oliveras",
        "created_at": "2018-01-03T07:52:30Z",
        "body": "This fails at runtime, so you have a bug. Most likely, this is null."
      }
    ]
  },
  {
    "number": 20923,
    "title": "Direct use await whitout async function",
    "created_at": "2017-12-28T21:12:23Z",
    "closed_at": "2018-01-12T19:50:40Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/20923",
    "body": "Hi, what possibilities exist to be able to use the await operator without the use of async?,\r\nas it is currently done in javascript.\r\n\r\nExample in actual javascript\r\n\r\nconst prom = new Promise((r)=> {r('Running whitout without async 🏄   \r\n')});\r\nawait prom // Running whitout without async 🏄\r\n\r\nRegards!",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/20923/comments",
    "author": "11ume",
    "comments": [
      {
        "user": "ajafff",
        "created_at": "2017-12-28T21:37:14Z",
        "body": "> as it is currently done in javascript.\r\n\r\n@Hume83 do you mean what the node repl or chrome console does? There is some special treatment for top level await.\r\nIn regular JavaScript and TypeScript this is not valid. You can try it yourself by saving the code snippet to a file and execute that file with node."
      },
      {
        "user": "11ume",
        "created_at": "2017-12-28T21:49:39Z",
        "body": "You are right, excuse my ignorance, I have tried it fast in the console, it would be a really great feature, to avoid the unnecessary use of async function in some cases. Could this feature be available in the future of Javascript?\r\nThanks for your answer mate."
      },
      {
        "user": "typescript-bot",
        "created_at": "2018-01-12T19:50:40Z",
        "body": "Automatically closing this issue for housekeeping purposes. The issue labels indicate that it is unactionable at the moment or has already been addressed."
      }
    ]
  },
  {
    "number": 20747,
    "title": "TS doesn't merge members for Window interface",
    "created_at": "2017-12-18T08:26:09Z",
    "closed_at": "2018-01-02T18:40:08Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/20747",
    "body": "I've tried to add a new property `counter` to the `Window` interface like this in the `main.ts` file:\r\n\r\n```\r\n// main.ts\r\n\r\ninterface Window {\r\n    counter;\r\n}\r\n```\r\n\r\n**Expected behavior:**\r\n\r\nI expected the property to be available on the `window` object:\r\n\r\n```\r\nwindow.counter;\r\n```\r\n\r\n**Actual behavior:**\r\n\r\nHowever, I got the error:\r\n\r\n```\r\nError:(19, 16) TS2339: Property 'counter' does not exist on type 'Window'.\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/20747/comments",
    "author": "maxkoretskyi",
    "comments": [
      {
        "user": "yortus",
        "created_at": "2017-12-18T14:39:51Z",
        "body": "Try this:\r\n\r\n```ts\r\n// main.ts\r\n\r\ndeclare global {\r\n    interface Window {\r\n        counter;\r\n    }\r\n}\r\n```\r\n"
      },
      {
        "user": "maxkoretskyi",
        "created_at": "2017-12-18T16:19:44Z",
        "body": "@yortus, thanks a lot, works this way. Can you elaborate a bit, why is `declare global` required?"
      },
      {
        "user": "kitsonk",
        "created_at": "2017-12-18T16:39:50Z",
        "body": "Because TypeScript is assuming you are in a module, likely because of the way you have your `tsconfig.json` configured (or the way you are compiling via `tsc`).  It therefore interfaces by default are scoped locally, instead of globally.  `declare global` indicates you are a module attempting to modify the global interfaces."
      },
      {
        "user": "maxkoretskyi",
        "created_at": "2017-12-19T16:41:26Z",
        "body": "@kitsonk , got it, thanks a lot!"
      },
      {
        "user": "typescript-bot",
        "created_at": "2018-01-02T18:40:07Z",
        "body": "Automatically closing this issue for housekeeping purposes. The issue labels indicate that it is unactionable at the moment or has already been addressed."
      }
    ]
  },
  {
    "number": 20692,
    "title": "unknown compiler option lib ",
    "created_at": "2017-12-14T08:19:21Z",
    "closed_at": "2018-01-02T18:40:14Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/20692",
    "body": "i am getting error when i build my project :unknown compiler option lib \r\nmy ts config file is:\r\n{\r\n  \"compilerOptions\": {\r\n    \"emitDecoratorMetadata\": true,\r\n    \"experimentalDecorators\": true,\r\n    \"module\": \"commonjs\",\r\n    \"moduleResolution\": \"node\",\r\n    \"lib\": [ \"es2015\", \"dom\" ],\r\n    \"noImplicitAny\": true,\r\n    \"sourceMap\": true,\r\n    \"suppressImplicitAnyIndexErrors\": true,\r\n    \"target\": \"es5\"\r\n  }\r\n}\r\nand m using typescript 2.0.0\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/20692/comments",
    "author": "nat124",
    "comments": [
      {
        "user": "ghost",
        "created_at": "2017-12-14T14:46:37Z",
        "body": "First I would recommend using a newer version of TypeScript -- but even with `typescript@2.0.0` installed I get no error when compiling an empty file with that `tsconfig.json`. Could you try running `npm install typescript` and then `tsc` from the command line?"
      },
      {
        "user": "typescript-bot",
        "created_at": "2018-01-02T18:40:14Z",
        "body": "Automatically closing this issue for housekeeping purposes. The issue labels indicate that it is unactionable at the moment or has already been addressed."
      }
    ]
  },
  {
    "number": 20668,
    "title": "tsc copy filed not included it's parent dir after compiled with setting other dir exclued in tsconfig.json",
    "created_at": "2017-12-13T08:35:54Z",
    "closed_at": "2017-12-14T13:11:02Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/20668",
    "body": "`tsc 2.6.2`. there is source dir tree:\r\n\r\n```\r\nsrc/\r\n├── client\r\n│   └── client.tsx\r\n├── server\r\n│   ├── actions\r\n│   ├── app.ts\r\n├── shared\r\n```\r\n\r\nwhere `tsconfig.json` settings:\r\n```json\r\n{\r\n...,\r\n\"outDir\": \"dist\",\r\n\"exclude\": [\r\n    \"./src/shared/**/*\",\r\n    \"./src/client/**/*\",\r\n    \"./src/server/*.tsx\",\r\n    \"./src/server/**/*.tsx\",\r\n],\r\n\"include\": [\r\n    \"./src/**/*\"\r\n  ]\r\n}\r\n```\r\n\r\nexec `tsc -p tsconfig.json`, expected `dist dir tree`:\r\n```\r\nsrc/\r\n├── server\r\n│   ├── actions\r\n│   ├── app.ts\r\n```\r\n\r\nin fact，it output:\r\n```\r\ndist\r\n├── app.js\r\n├── app.js.map\r\n├── actions\r\n```\r\n\r\nbut,  this's `tsconfig.json` is okay:\r\n```json \r\n{\r\n...,\r\n\"outDir\": \"dist\",\r\n\"exclude\": [\r\n    \"./src/shared/**/*\",\r\n],\r\n\"include\": [\r\n    \"./src/**/*\"\r\n  ]\r\n}\r\n```\r\n\r\nthe output `dist dir  tree`:\r\n```\r\ndist\r\n├── client\r\n└── server\r\n```\r\n\r\nso, i am confused. that is a bug ?😷😷😷\r\n\r\nThanks.",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/20668/comments",
    "author": "Phinome",
    "comments": [
      {
        "user": "ghost",
        "created_at": "2017-12-13T15:18:22Z",
        "body": "Seems like a duplicate of #16563.\r\nNormally we will find the common root directory of all the files that were included -- so if you only include files in `src/server` and compile to `dist`, we'll compile from `src/server` to `dist` and not add a `server` directory.\r\nAs mentioned in that issue, you can override this behavior by setting an explicit `\"rootDir\": \"src\"` in your `\"compilerOptions\"` in `tsconfig.json`."
      },
      {
        "user": "Phinome",
        "created_at": "2017-12-14T13:11:02Z",
        "body": "Thanks."
      }
    ]
  },
  {
    "number": 20659,
    "title": "escapedText property missing on LeftHandSideExpression interface!",
    "created_at": "2017-12-12T22:55:07Z",
    "closed_at": "2018-01-02T18:40:15Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/20659",
    "body": "**Source :** \r\n\r\n```typescript\r\nfunction add(a: number, b: number): number {\r\n  return a + b;\r\n}\r\nconst sum = add(1, 2);\r\n\r\n```\r\n\r\n**Parsed AST :** \r\n\r\n```json \r\n{\"pos\":1470,\"end\":1493,\"flags\":0,\"kind\":209,\"declarationList\":{\"pos\":1470,\"end\":1492,\"flags\":2,\"kind\":228,\"declarations\":[{\"pos\":1476,\"end\":1492,\"flags\":0,\"kind\":227,\"name\":{\"pos\":1476,\"end\":1480,\"flags\":0,\"escapedText\":\"sum\"},\"initializer\":{\"pos\":1482,\"end\":1492,\"flags\":0,\"kind\":182,\"expression\":{\"pos\":1482,\"end\":1486,\"flags\":0,\"escapedText\":\"add\"},\"arguments\":[{\"pos\":1487,\"end\":1488,\"flags\":0,\"kind\":8,\"text\":\"1\",\"numericLiteralFlags\":0},{\"pos\":1489,\"end\":1491,\"flags\":0,\"kind\":8,\"text\":\"2\",\"numericLiteralFlags\":0}]}}]}\r\n```\r\n**Initialiser bits :** \r\n\r\n```json \r\n\"initializer\":{\"pos\":1482,\r\n\"end\":1492,\r\n\"flags\":0,\r\n\"kind\":182, // CallExpression\r\n\"expression\":{\"pos\":1482,\"end\":1486,\"flags\":0,\"escapedText\":\"add\"} //LeftHandSideExpression\r\n```\r\n```typescript\r\n  interface CallExpression extends LeftHandSideExpression, Declaration {\r\n        kind: SyntaxKind.CallExpression;\r\n        expression: LeftHandSideExpression;\r\n        typeArguments?: NodeArray<TypeNode>;\r\n        arguments: NodeArray<Expression>;\r\n    }\r\n```\r\n\r\n**Typescript Version : 2.7.0-dev.20171209**",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/20659/comments",
    "author": "chandu0101",
    "comments": [
      {
        "user": "ghost",
        "created_at": "2017-12-13T15:23:41Z",
        "body": "Not all `LeftHandSideExpression`s have `escapedText` -- only `Identifier`s do. `adder.add(1, 2)` wouldn't have `escapedText` in its `expression`, because it's a `PropertyAccessExpression`.\r\nBesides, `escapedText` is internal and public users should use `text` instead."
      },
      {
        "user": "typescript-bot",
        "created_at": "2018-01-02T18:40:15Z",
        "body": "Automatically closing this issue for housekeeping purposes. The issue labels indicate that it is unactionable at the moment or has already been addressed."
      }
    ]
  },
  {
    "number": 20637,
    "title": "Cannot use index signature of default export from wildcard module",
    "created_at": "2017-12-11T22:43:11Z",
    "closed_at": "2017-12-13T05:53:07Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/20637",
    "body": "**TypeScript Version:**  2.6.2\r\n\r\n**Code**\r\n\r\n***json-module.d.ts***\r\n```ts\r\n// Allows json files to be imported as a module\r\ndeclare module \"*.json\" {\r\n    import {JSONObject} from \"src/json\";\r\n    const value: JSONObject;\r\n    export default value;\r\n}\r\n```\r\n\r\n***json.ts***\r\n```ts\r\n/**\r\n * Type declarations and utilities for working with JSON-compatible data structures.\r\n * @module\r\n */\r\n\r\n/**\r\n * Any primitive data type that is allowed in JSON.\r\n */\r\nexport type JSONPrimitive = string | number | boolean | null;\r\n\r\n/**\r\n * Any value data type allowed in JSON (primitives, arrays, and objects).\r\n */\r\nexport type JSONValue = JSONPrimitive | JSONArray | JSONObject;\r\n\r\n/**\r\n * An array of data types allowed in JSON.\r\n */\r\nexport interface JSONArray extends Array<JSONValue> {\r\n}\r\n\r\n/**\r\n * An object whose properties are of types allowed in JSON.\r\n */\r\nexport interface JSONObject {\r\n    [name: string]: JSONValue;\r\n}\r\n```\r\n\r\nExample usage:\r\n```ts\r\nimport * as jsonData from \"someFile.json\";\r\n\r\n// compiler error on the following line\r\nconst someValue = jsonData[\"aPropertyName\"]; \r\n```\r\n\r\n**Expected behavior:**\r\nI should be able to use the imported value from my JSON file as a `JSONObject`, indexing into its properties without compiler errors.\r\n\r\n**Actual behavior:**\r\nCompiler error where I attempt to index into the properties of my JSONObject:\r\n`error TS7017: Element implicitly has an 'any' type because type 'typeof \"*.json\"' has no index signature.`",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/20637/comments",
    "author": "UselessPickles",
    "comments": [
      {
        "user": "UselessPickles",
        "created_at": "2017-12-11T22:47:27Z",
        "body": "The following hack allows me to use the imported JSON as desired:\r\n\r\n```ts\r\nimport * as jsonData_ from \"someFile.json\";\r\n\r\n// Assigning the import to an explicitly typed const is fine; so the compiler understands\r\n// here that the import value is of type JSONData.\r\nconst jsonData: JSONObject = jsonData_;\r\n\r\n// Now this works without compiler errors.\r\nconst someValue = jsonData[\"aPropertyName\"]; \r\n```"
      },
      {
        "user": "Jessidhia",
        "created_at": "2017-12-12T01:18:48Z",
        "body": "That is because, on your declaration, you were very specific that the only export is a `default` export. There is no index signature on ES Module exports.\r\n\r\nYou need to change your import from `import * as jsonData from` into `import jsonData from`."
      },
      {
        "user": "ghost",
        "created_at": "2017-12-12T01:39:27Z",
        "body": "Alternatively, use `export =` instead of `export default`, and `import jsonData = require(\"someFile.json\")`."
      },
      {
        "user": "UselessPickles",
        "created_at": "2017-12-12T02:38:24Z",
        "body": "Thanks for the responses. It seems so obvious now that the way I'm importing `*`, but exporting a single default, is inconsistent.\r\n\r\nBut can anyone explain why my `jsonData` import in my example seems to have an identity crisis? Why does the compiler believe it *is* of type JSONObject (which has an index signature), but that it also does *not* have an index signature because of the way it was imported? In every other way that I use `jsonData`, it works as type JSONObject... as long as I don't try to use the index operator.\r\n\r\nRegardless of the fact that I was doing it wrong, it still seems like there's an inconsistency in the behavior of my example."
      },
      {
        "user": "ghost",
        "created_at": "2017-12-12T15:46:11Z",
        "body": "The compiler doesn't actually believe that `jsonData` is of type `JSONObject`. If you write `const x = jsonData;` and hover over `x` you'll see it says `typeof jsonData`. If you try writing `jsonData.` you'll only get completions for `default`.\r\nIt is *assignable* to a `JSONObject` variable though, because the type `{ default: JSONObject }` is assignable to `JSONObject`, since every property value in that type is a `JSONValue`."
      },
      {
        "user": "UselessPickles",
        "created_at": "2017-12-12T21:41:17Z",
        "body": "I figured it out!\r\n\r\nThe key was to start by looking at how webpack (what I'm using for module loading, etc.) generates modules for JSON files, declare my \"*.json\" module to match, and use an import style that matches. \r\n\r\nThe built-in JSON loader for webpack creates a module in the form of:\r\n```js\r\nmodule.exports = {/* the JSON object from the file */};\r\n```\r\n\r\nTo match the way the webpack loader generates the module, I declare my \"*.json\" module as:\r\n\r\n```ts\r\ndeclare module \"*.json\" {\r\n    import {JSONObject} from \"src/json\";\r\n    const value: JSONObject;\r\n    export = value;\r\n}\r\n```\r\n\r\nAnd then import JSON like this:\r\n```ts\r\nimport * as jsonData from \"someFile.json\";\r\n```\r\n\r\nI guess this is a good lesson that the structure of an external non-typescript module is what dictates how corresponding TS declarations must be defined, and therefore dictates how the module must be imported."
      },
      {
        "user": "UselessPickles",
        "created_at": "2017-12-12T21:43:03Z",
        "body": "@andy-ms \r\n> It is assignable to a JSONObject variable though, because the type { default: JSONObject } is assignable to JSONObject, since every property value in that type is a JSONValue.\r\n\r\nThanks for the clarification. I see now where I got confused :)\r\n"
      },
      {
        "user": "UselessPickles",
        "created_at": "2017-12-12T21:59:05Z",
        "body": "Part of my confusion was that my initial setup was working correctly at runtime. Now I understand that it's because the style of my import matched the structure of the actual module that was being generated by webpack. It was only my TS declaration that didn't match, and was causing compile-time confusion under certain conditions. \r\n\r\nThe fact that the incorrect TS declaration of the module combined with my import style to produce something that was *assignable* to JSONObject (unfortunate coincidence) was an additional red herring. The end result was that it seemed to \"mostly work\", unless I tried to directly use the import as a JSONObject."
      }
    ]
  },
  {
    "number": 20612,
    "title": "Visual Studio 2017 TypeScript Compiler Version",
    "created_at": "2017-12-11T08:59:04Z",
    "closed_at": "2018-01-02T18:40:17Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/20612",
    "body": "**Expected behavior:**\r\nVS 2017.15.5.1 TypeScript Compiler OK in use typescript's version 1.8.10 project.\r\n\r\nI want to use 1.8.10 TypeScript Compiler... in VS 2017.15.5.1\r\n\r\n**Actual behavior:**\r\nVS 2017.15.5.1 use default typescript tools compiler, maybe version is 2.5, comilper some error in my project.\r\nbut my gulp-typescript@2.13.6 is working well~it's dependency ts 1.8.10",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/20612/comments",
    "author": "fegg",
    "comments": [
      {
        "user": "typescript-bot",
        "created_at": "2018-01-02T18:40:17Z",
        "body": "Automatically closing this issue for housekeeping purposes. The issue labels indicate that it is unactionable at the moment or has already been addressed."
      }
    ]
  },
  {
    "number": 20530,
    "title": "Shouldn't `this` type annotation be disallowed for input parameters (contravariant position)?",
    "created_at": "2017-12-07T07:48:01Z",
    "closed_at": "2018-01-02T18:40:27Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/20530",
    "body": "```ts\r\nclass Base  {\r\n    foo(item: this) { }\r\n}\r\n\r\nclass Derived extends Base {\r\n\r\n    foo(item: this) {\r\n        item.bar();\r\n    }\r\n\r\n    bar() {}\r\n}\r\n\r\nfunction useFoo(base: Base) {\r\n    base.foo(new Base());\r\n}\r\n\r\nconst d = new Derived();\r\nuseFoo(d); // runtime error\r\n```\r\n\r\n**Expected behavior:**\r\nCompile time error on `foo(item: this) `\r\n\r\n**Actual behavior:**\r\nRuntime error on `useFoo(d);`",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/20530/comments",
    "author": "levenleven",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2017-12-07T16:16:44Z",
        "body": "Things written in method syntax are still checked bivariantly due to people being broadly bad at writing class hierarchies that actually achieve substitutability (e.g. the DOM).\r\n\r\nIf you use property syntax and turn on strictFunctionTypes, this is an error:\r\n```ts\r\nclass Base  {\r\n    foo = (item: this) => { }\r\n}\r\n\r\nclass Derived extends Base {\r\n    foo = (item: this) => {\r\n        item.bar();\r\n    }\r\n\r\n    bar() {}\r\n}\r\n\r\nfunction useFoo(base: Base) {\r\n    base.foo(new Base());\r\n}\r\n\r\nconst d = new Derived();\r\nuseFoo(d); // type error\r\n```"
      },
      {
        "user": "typescript-bot",
        "created_at": "2018-01-02T18:40:26Z",
        "body": "Automatically closing this issue for housekeeping purposes. The issue labels indicate that it is unactionable at the moment or has already been addressed."
      }
    ]
  },
  {
    "number": 20280,
    "title": "Wrong type inferred for nested union",
    "created_at": "2017-11-27T18:11:05Z",
    "closed_at": "2018-10-05T19:06:52Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/20280",
    "body": "**TypeScript Version:**  2.7.0-dev.20171126\r\n\r\nContext: a method for ember.js which extracts the value from some path, e.g.\r\n```ts\r\nget({ foo: { bar: { baz: 'hello' }}}, 'foo', 'bar', 'baz') // returns \"hello\"\r\n```\r\n\r\nEach value in the path might be some plain object `T` or a `Wrapped<T>` (in which case we return the underlying `T`)\r\n\r\n**Code**\r\n\r\nTypescript can infer the returned type using a union:\r\n\r\n```ts\r\n// working example\r\ninterface Wrapped<T> { value: T }\r\n\r\ntype Props1<T> = {\r\n    [K in keyof T]: Wrapped<T[K]> | T[K];\r\n}\r\n\r\ndeclare function get1<T, K1 extends keyof T>(obj: Props1<T>, k1: K1): T[K1];\r\n\r\ndeclare const obj1: { a: string };\r\nconst v1: string = get1(obj1, 'a'); // works\r\n\r\ndeclare const obj2: { a: Wrapped<string> };\r\nconst v2: string = get1(obj2, 'a'); // works\r\n```\r\n\r\nHowever, it no longer works when the union types are nested:\r\n\r\n```ts\r\n// non-working example\r\ntype Props2<T> = {\r\n    [K in keyof T]: Wrapped<Props1<T[K]>> | Props1<T[K]>\r\n};\r\n\r\ndeclare function get2<T, K1 extends keyof T, K2 extends keyof T[K1]>(obj: Props2<T>, k1: K1, k2: K2): T[K1][K2];\r\n\r\ndeclare const obj3: { a: { b: string } };\r\nconst v3: string = get2(obj3, 'a', 'b'); // works\r\n\r\ndeclare const obj4: { a: Wrapped<{ b: Wrapped<string> }> };\r\nconst v4: string = get2(obj4, 'a', 'b'); // TS2345:Argument of type '\"b\"' is not assignable to parameter of type 'never'.\r\n```\r\n\r\nIf I eliminate the _right side_ of the union from `Props2`, then the `obj4` example works\r\n```ts\r\ntype Props2<T> = {\r\n    [K in keyof T]: Wrapped<Props1<T[K]>> //| Props1<T[K]>\r\n};\r\n```\r\nThe `obj4` example should pick the left side of the union to begin with",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/20280/comments",
    "author": "dwickern",
    "comments": [
      {
        "user": "chriskrycho",
        "created_at": "2017-11-27T19:01:09Z",
        "body": "To add a bit, the motivation is providing a type-safe wrapper around `Ember.get(someObj, 'a.b')`. We want to be able to do a `safeGet(someObj, 'a', 'b')` which simply dispatches internally to the relevant path, but which does type-checking on the supplied keys – for an API that's *slightly* less ergonomic than the built-in Ember API, but which is much nicer than doing it the way we are presently.\r\n\r\n```ts\r\n// current way to do it to get type inference\r\nconst a = get(someObj, 'a');\r\nconst b = get(a, 'b');\r\n\r\n// desired API\r\nconst b = safeGet(someObj, 'a', 'b');\r\n```\r\n"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2018-08-07T22:03:42Z",
        "body": "@dwickern @chriskrycho I wrote a version using conditional types that works:\r\n```ts\r\ntype Unwrap<T> = T extends Wrapped<infer U> ? U : T;\r\n\r\n// working example\r\ninterface Wrapped<T> {\r\n  value: T\r\n}\r\n\r\ntype Props1<T> = {\r\n    [K in keyof T]: T[K];\r\n}\r\n\r\ndeclare function get1<T, K1 extends keyof T>(obj: Props1<T>, k1: K1): Unwrap<T[K1]>;\r\n\r\ndeclare const obj1: { a: string };\r\nconst v1: string = get1(obj1, 'a'); // works\r\n\r\ndeclare const obj2: { a: Wrapped<string> };\r\nconst v2: string = get1(obj2, 'a'); // works\r\n\r\ntype Props2<T> = {\r\n    [K in keyof T]: Unwrap<Props1<T[K]>>\r\n};\r\n\r\ndeclare function get2<T, K1 extends keyof T, K2 extends keyof Unwrap<T[K1]>>(obj: Props2<T>, k1: K1, k2: K2): Unwrap<Unwrap<T[K1]>[K2]>;\r\n\r\ndeclare const obj3: { a: { b: string } };\r\nconst v3: string = get2(obj3, 'a', 'b'); // works\r\n\r\ndeclare const obj4: { a: Wrapped<{ b: Wrapped<string> }> };\r\nconst v4: string = get2(obj4, 'a', 'b'); // now works\r\n```\r\nI don't think this is solvable otherwise because we don't preferentially go down one path or the other when inferring a key type for the union."
      },
      {
        "user": "chriskrycho",
        "created_at": "2018-08-08T01:50:26Z",
        "body": "Ah, this is genuinely great. Thank you, @RyanCavanaugh. I don’t have time to experiment tonight; it looks like it should be possible to extend this using overloads but probably not tuple/argument types, if I’m tracking correctly?\r\n\r\nAt a minimum, it’ll give us a tool we can build on for this. Thanks for circling back around to it!"
      },
      {
        "user": "dwickern",
        "created_at": "2018-10-05T19:06:52Z",
        "body": "This is possible now with conditional types 🎉 "
      }
    ]
  },
  {
    "number": 20245,
    "title": "Unable to use loop indexers with union index signatures in strict mode",
    "created_at": "2017-11-23T18:53:10Z",
    "closed_at": "2017-12-12T18:21:16Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/20245",
    "body": "<!-- BUGS: Please use this template. -->\r\n\r\n<!-- Please try to reproduce the issue with `typescript@next`. It may have already been fixed. -->\r\n**TypeScript Version:**  2.7.0-dev.20171123\r\n\r\n**Code**\r\n\r\n```ts\r\ntype Union = 'A' | 'B';\r\nconst test: {[key in Union]: string} = {A: 'a', B: 'b'};\r\nfor(const key in test) {\r\n\ttest[key] = test[key] + 'a';\r\n}\r\n```\r\n\r\n**Expected behavior:**\r\nNo error.\r\n\r\n**Actual behavior:**\r\n```\r\n>tsc test.ts --strict\r\ntest.ts(4,2): error TS7017: Element implicitly has an 'any' type because type '{ A: string; B: string; }' has no index signature.\r\ntest.ts(4,14): error TS7017: Element implicitly has an 'any' type because type '{ A: string; B: string; }' has no index signature.\r\n```\r\n\r\nSorry if this is an issue already; I couldn't find anything quite like this using the issue search or Google.\r\nBasically I'd expect this to work without an error, as the entire point of using an index signature with a string union is to enforce type constraints, not lose them completely.\r\nI get that this is likely because of the whole \"keys are always strings at runtime\" thing, but it effectively makes any object with a `[key in T]: V` constraint un-indexable in strict mode, and indexing is a big part of why you'd use a constraint like that in the first place.",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/20245/comments",
    "author": "code-elf",
    "comments": [
      {
        "user": "emcastro",
        "created_at": "2017-11-25T14:42:29Z",
        "body": "`{[key in Union]: string}` means “something which, for its keys in `Union`, contains strings”. It may have other keys, with different types. So `key in test` does not necessarily yield `Union` values.\r\n\r\nAdding a type guard might be a solution to your problem:\r\n```\r\ntype Union = 'A' | 'B';\r\n\r\nfunction isUnion(key: string): key is Union {\r\n  return key === 'A' || key === 'B'\r\n}\r\n\r\nconst funkyData = {A: 'a', B: 'b', C: 42}\r\nconst test: {[key in Union]: string} = funkyData;\r\nfor(const key in test) {\r\n  if (isUnion(key)) {\r\n    test[key] = test[key] + 'a'; // does not apply to 'C'\r\n  }\r\n}\r\n```\r\n"
      },
      {
        "user": "code-elf",
        "created_at": "2017-11-27T01:39:54Z",
        "body": "If it's not intended to be an index signature, then why does it have the same syntax? That's not only confusing, it also makes it impossible to _also_ define an index signature for the type.\r\nNot to mention that the `[key in T]: V` feature was somewhat 'advertised' as making more narrow index signatures possible, but considering what you just said, something like `[key: StringUnion]: V` seems to still be a missing feature, and one that would be insanely useful in a lot of places, like iterations."
      },
      {
        "user": "typescript-bot",
        "created_at": "2017-12-12T18:21:15Z",
        "body": "Automatically closing this issue for housekeeping purposes. The issue labels indicate that it is unactionable at the moment or has already been addressed."
      },
      {
        "user": "code-elf",
        "created_at": "2017-12-12T19:43:11Z",
        "body": "@mhegazy I'd request reopening this since it's not actually a question but an issue with how the `in` \"index signature\" works and/or is portrayed."
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2017-12-13T17:54:30Z",
        "body": "@MayaWolf we're not going to change the syntax at this point, and it's not a bug that the syntax doesn't do what you intuit it should do. I don't see anything actionable here"
      }
    ]
  },
  {
    "number": 20148,
    "title": "tsc and yarn/npm run tsc difference ",
    "created_at": "2017-11-20T09:20:38Z",
    "closed_at": "2017-12-05T18:27:21Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/20148",
    "body": "I had a project on using typescript, I found the difference was when I used `tsc` it will be fine, but has a lot of errors when I used `yarn run tsc` or `npm run tsc`\r\nThe script in my package.json:\r\n`\r\n\"tsc\": \"tsc -w\"\r\n`\r\n\r\nErrors:\r\n```\r\nNicholas in ~/code/project on master √\r\n± tsc                                                                                                                                                                                  16:59\r\n\r\nNicholas in ~/code/project on master √\r\n± yarn run tsc                                                                                                                                                                         17:13\r\nyarn run v1.3.2\r\n$ tsc -w\r\ntypings/globals/node/index.d.ts(40,5): error TS1131: Property or signature expected.\r\ntypings/globals/node/index.d.ts(40,14): error TS1005: ';' expected.\r\ntypings/globals/node/index.d.ts(41,1): error TS1128: Declaration or statement expected.\r\ntypings/globals/node/index.d.ts(82,26): error TS1110: Type expected.\r\ntypings/globals/node/index.d.ts(285,40): error TS1110: Type expected.\r\ntypings/globals/node/index.d.ts(1846,37): error TS1110: Type expected.\r\ntypings/globals/node/index.d.ts(1863,18): error TS1005: '=' expected.\r\ntypings/globals/node/index.d.ts(1863,24): error TS1005: ';' expected.\r\ntypings/globals/node/index.d.ts(1869,18): error TS1005: '=' expected.\r\ntypings/globals/node/index.d.ts(1869,30): error TS1005: ';' expected.\r\ntypings/globals/node/index.d.ts(4052,33): error TS1110: Type expected.\r\n5:13:25 PM - Compilation complete. Watching for file changes.\r\n```\r\n\r\nI don't understand what is the difference of executions way, Why when I use npm or yarn it will be catch the errors",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/20148/comments",
    "author": "lizhongit",
    "comments": [
      {
        "user": "aluanhaddad",
        "created_at": "2017-11-20T12:24:07Z",
        "body": "When you run `$ tsc -w` it is not going through yarn or npm.\r\nUnless you have some kind of alias set up it will hit your global installation.\r\nRun `$ yarn add typescript`"
      },
      {
        "user": "typescript-bot",
        "created_at": "2017-12-05T18:27:21Z",
        "body": "Automatically closing this issue for housekeeping purposes. The issue labels indicate that it is unactionable at the moment or has already been addressed."
      }
    ]
  },
  {
    "number": 20055,
    "title": "Weird behavior scanning recursive template strings",
    "created_at": "2017-11-15T22:26:46Z",
    "closed_at": "2017-11-15T22:33:58Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/20055",
    "body": "**TypeScript Version:**  2.7.0-dev.20171115\r\n\r\n**Code**\r\n\r\n```ts\r\nimport * as tsc from \"typescript\";\r\n\r\nconst scanner = tsc.createScanner(tsc.ScriptTarget.ES2016, true, tsc.LanguageVariant.Standard);\r\nconst str = \"`a${`c` + `d${'e'}f`}g`\";\r\nscanner.setText(str);\r\n\r\nwhile( scanner.getTextPos() < str.length ) {\r\n    scanner.scan();\r\n    console.log(`${scanner.getTokenText()}\\t=> ${scanner.getToken()}`);\r\n}\r\n```\r\n\r\n**Expected behavior:**\r\n```diff\r\n    `a${    => 14 //TemplateHead\r\n    `c`     => 13 //NoSubstitutionTemplateLiteral\r\n    +       => 37\r\n    `d${    => 14 //TemplateHead\r\n    'e'     => 9\r\n+   }f`     => 16 //TemplateTail\r\n+   }g`     => 16 //TemplateTail\r\n```\r\n\r\n**Actual behavior:**\r\n```diff\r\n    `a${    => 14 //TemplateHead\r\n    `c`     => 13 //NoSubstitutionTemplateLiteral\r\n    +       => 37\r\n    `d${    => 14 //TemplateHead\r\n    'e'     => 9\r\n-   }       => 18 //CloseBraceToken\r\n-   f       => 71 //Identifier\r\n-   `}g`    => 13 //NoSubstitutionTemplateLiteral\r\n```",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/20055/comments",
    "author": "lmcarreiro",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2017-11-15T22:31:45Z",
        "body": "You can't just blindly call `scan`. See the function `parseTemplateSpan` in `parser.ts` - when encountering a `CloseBraceToken` you need to `reScanTemplateToken`"
      },
      {
        "user": "lmcarreiro",
        "created_at": "2017-11-15T22:33:58Z",
        "body": "I thought that the scanner was a state machine that knows its state.\r\n\r\nThanks."
      }
    ]
  },
  {
    "number": 19936,
    "title": "No way to createProgram from files with extensions other than typescript extensions (such as .vue).",
    "created_at": "2017-11-11T00:46:12Z",
    "closed_at": "2017-11-13T20:20:18Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/19936",
    "body": "**TypeScript Version:**  latest\r\n\r\n**Expected behavior:**\r\nAbility to call `ts.createProgram` for typechecking on a file without a `.ts` extension. For example, a `.vue` file (the **vue** file would have been stripped down through webpack loader chain and contains only valid TypeScript in it by the time **createProgram** is called on it).\r\n\r\n**Actual behavior:**\r\nDoesn't work with .vue files. For example, `program.getSourceFile(fileName)` will return undefined on anything other than valid typescript extensions.\r\n\r\nUltimately my goal is to do my own linting on .vue files.",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/19936/comments",
    "author": "prograhammer",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2017-11-13T18:34:04Z",
        "body": "The compiler makes assumptions about file extensions in module resolution and in output generation.. this is why `createProgram` validates the extensions of input files.\r\n\r\nif all you want is to lint, then you do not realy need a `Program`, all you need is a `SourceFile`, so consider using `createSourceFile` instead."
      },
      {
        "user": "prograhammer",
        "created_at": "2017-11-13T18:46:23Z",
        "body": "Some linting requires the typechecker so I can't go the route of just using createSourceFile. For single file components (.vue) is my only solution to pull out the TypeScript and put it into it's own file (.ts) and just import it into the .vue file then? This is unfortunate."
      },
      {
        "user": "sheetalkamat",
        "created_at": "2017-11-13T20:03:19Z",
        "body": "But ```createProgram``` does take ```CompilerHost``` as optional argument and you could specify that host to  with your specific ```getSourceFile``` and ```resolveModuleName``` to handle this. Would that not work?"
      },
      {
        "user": "prograhammer",
        "created_at": "2017-11-13T20:20:09Z",
        "body": "Hmmm... ok @sheetalkamat maybe there is a solution there. Let me try that! I'll close this issue and report a new issue if I find TypeScript blocking me further. Thank you!"
      }
    ]
  },
  {
    "number": 19828,
    "title": "Typescript Index Signature extension methods",
    "created_at": "2017-11-08T08:15:52Z",
    "closed_at": "2017-11-29T16:44:11Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/19828",
    "body": "I`m trying to create my own Typescript dictionary like class, but with some custom methods to use in my code.\r\n\r\nI can create the basic dictionary like this:\r\n\r\n```\r\nexport interface IDictionary<T> {\r\n [property: string]: T;\r\n};\r\n\r\nexport class Dictionary<T> implements IDictionary<T> {\r\n [property: string]: T;\r\n constructor() {}\r\n}\r\n```\r\nand this works great...but... if i try to create a extension method, such as\r\n\r\n```\r\nexport class Dictionary<T> implements IDictionary<T> {\r\n [property: string]: T;\r\n constructor() {}\r\n}    \r\npublic getValues(): T[] {\r\n    return Object.values(this);\r\n}\r\n```\r\nI get this error: Property 'getValues' of type '() => T[]' is not assignable to string index type 'T'.\r\n\r\nIs this even possible? If it is, how can do I create extension methods for my this?",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/19828/comments",
    "author": "WayneBarnard",
    "comments": [
      {
        "user": "rozzzly",
        "created_at": "2017-11-08T11:59:05Z",
        "body": "It is possible. It's a bit ugly. I'll show you how after I take a nap lmao"
      },
      {
        "user": "WayneBarnard",
        "created_at": "2017-11-10T05:31:33Z",
        "body": "mmm, thats a long nap :D"
      },
      {
        "user": "rozzzly",
        "created_at": "2017-11-11T14:25:44Z",
        "body": "```typescript\r\nexport interface MyBaseDictionary<T> {\r\n    [key: string]: T;\r\n}\r\n\r\nexport interface MyDictionaryInstance<T> {\r\n    ‎getValues(): T[];\r\n    ‎// ...\r\n}\r\n\r\nexport type MyDictonary<T> = (\r\n    ‎& MyBaseDictionary<T>\r\n    ‎& MyDictionaryInstance<T>\r\n);\r\n\r\nexport function MakeDictonary<T>(): MyDictonary<T> {\r\n    // Create empty dict, keep reference so instance methods can reference that data--because we are not using this.\r\n    const dict: MyDictonary<T> = {} as any;\r\n    ‎// Add dict's instance methods to the empty dict via `Object.defineProperty` so they're not enumerable via `Object.values`\r\n    ‎Object.defineProperty(dict, 'getValued', { \r\n        enumerable: false,\r\n        ‎configurable: false,\r\n        ‎writable: false,\r\n        ‎value: () => {\r\n    ‎.      return Object.getValues (dict);\r\n        }\r\n    });\r\n    ‎return dict;\r\n}\r\n```"
      },
      {
        "user": "rozzzly",
        "created_at": "2017-11-11T14:43:48Z",
        "body": "Okay, so super rough and untested ( typed this up on my phone ) but hopefully it gives you an idea what I was getting at. It's not an es2105 class, but it's instances are quite similar to what it looks like what you are trying to achieve. Lemme know if you have questions.\r\n\r\nPS: personally, I'd suggest redoing your API. I'm assuming you posted a somewhat contrived example and that end result you're invisioning is a lot like something I have toyed arround with in the past. I ended up ditching the pattern shown above, having the values nested in a property at a depth equal to those instance methods. Just wasn't worth the hassle.\r\n\r\nBut that was for my usecase, you'll have to weigh  the pros/cons of such a pattern for yourself."
      },
      {
        "user": "typescript-bot",
        "created_at": "2017-11-29T16:44:11Z",
        "body": "Automatically closing this issue for housekeeping purposes. The issue labels indicate that it is unactionable at the moment or has already been addressed."
      }
    ]
  },
  {
    "number": 19561,
    "title": "Cann't reference generic type in function implementation.",
    "created_at": "2017-10-29T15:10:06Z",
    "closed_at": "2017-11-13T18:06:37Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/19561",
    "body": "**TypeScript Version:**  2.5.2\r\n\r\n**Code**\r\n\r\n```ts\r\nconst identity: <P>(id: P) => P = id => id\r\n\r\nconst fn: <T>(p: T) => [T, T] = p => {\r\n    // Work: tmp and tmp2 are of type T. Via implicit inference.\r\n    const tmp = p\r\n    const tmp2 = identity(p)\r\n    \r\n    return [tmp, tmp2]\r\n}\r\n\r\nconst fn2: <T>(p: T) => [T, T] = p => {\r\n    // Error: Cannot find name 'T'\r\n    const tmp: T = p\r\n    const tmp2 = identity<T>(p)\r\n    const tmp3 = identity<T>('string') // I guess this is the key point that TS can't check whether 'string' match generic type T.\r\n\r\n    return [tmp, tmp2]\r\n}\r\n```\r\n\r\n**Expected behavior:**\r\nWe can use generic type T in the function body. In some complex implementations, we may need union/intersection types with the generic type. Such as:\r\n\r\n```ts\r\nconst fn: <T>(p: T) => T = p => {\r\n    let tmp: T | null = null\r\n    // ...later\r\n    tmp = p\r\n\r\n    return tmp\r\n}\r\n```\r\n\r\n**Actual behavior:**\r\nThrow errors as code comments.",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/19561/comments",
    "author": "zheeeng",
    "comments": [
      {
        "user": "gcnew",
        "created_at": "2017-10-29T16:52:50Z",
        "body": "You have two options:\r\n\r\nEither annotate the value, not the variable\r\n```ts\r\nconst fn = <T>(p: T): [T, T] => {\r\n    // Work: tmp and tmp2 are of type T. Via implicit inference.\r\n    const tmp = p\r\n    const tmp2 = identity(p)\r\n    const tmp3 = identity<T>('string') // error\r\n\r\n    return [tmp, tmp2]\r\n}\r\n```\r\nOr to create a type alias:\r\n```ts\r\nconst fn2: <T>(p: T) => [T, T] = p => {\r\n    type T = typeof p\r\n\r\n    const tmp: T = p\r\n    const tmp2 = identity<T>(p)\r\n    const tmp3 = identity<T>('string') // error\r\n\r\n    return [tmp, tmp2]\r\n}\r\n```\r\n\r\nBasically, variable declaration annotations don't share their scope with a possible literal implementation."
      },
      {
        "user": "typescript-bot",
        "created_at": "2017-11-13T18:06:37Z",
        "body": "Automatically closing this issue for housekeeping purposes. The issue labels indicate that it is unactionable at the moment or has already been addressed."
      }
    ]
  },
  {
    "number": 19529,
    "title": "Can TypeScript refer to an instance type over a namespace type?",
    "created_at": "2017-10-27T13:19:56Z",
    "closed_at": "2017-10-27T14:41:46Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/19529",
    "body": "I have a library whose `.d.ts` file defined something like:\r\n\r\n```\r\ndeclare class Logger extends EventEmitter {\r\n    constructor();\r\n    info(message: string);\r\n    error(message: string);\r\n}\r\n\r\ndeclare namespace Logger {\r\n    const INFO: number;\r\n    const ERROR: number;\r\n}\r\n\r\nexport = Logger;\r\n```\r\n\r\nI'm accessing it with `require()` and loading it in at runtime:\r\n\r\n```\r\nimport LoggerType = require(\"mylogger\");\r\n\r\n...\r\n\r\nlet logger: typeof LoggerType;\r\ntry {\r\n    logger = require(\"mylogger\").createLogger(...);\r\n}\r\ncatch (err) {\r\n    ...\r\n}\r\n\r\nif (logger) {\r\n    logger.info(\"hello world\");\r\n}\r\n```\r\n\r\nBut this doesn't work because TypeScript doesn't see `logger` as an instance of `Logger` but as the namespace `Logger`.  Can it instead refer to the instance of `Logger` so `logger.info()` will not be a type violation?",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/19529/comments",
    "author": "jez9999",
    "comments": [
      {
        "user": "ghost",
        "created_at": "2017-10-27T14:27:59Z",
        "body": "`let logger: LoggerType;`\r\n`typeof LoggerType` gives you the type of the module's export, which is a *class*. `LoggerType` gives you the type exported by the module, which is the type of *instances* of `Logger`."
      },
      {
        "user": "jez9999",
        "created_at": "2017-10-27T14:41:46Z",
        "body": "Thanks."
      }
    ]
  },
  {
    "number": 19382,
    "title": "Referenced type variable incorrectly inferred as \"{}\" in function calls",
    "created_at": "2017-10-20T19:39:19Z",
    "closed_at": "2017-11-07T16:55:28Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/19382",
    "body": "**TypeScript Version:**  2.6.0-dev.201xxxxx\r\n\r\n**Code**\r\n\r\n```ts\r\n// Fails:  error TS2339: Property 'a' does not exist on type '{}'.\r\ninfer({ thing: { a: 10 } }).a; \r\n\r\n// With explicit type parameters, it works\r\ninfer<{a:number}, Holder<{a: number}>>({ thing: { a: 10 } }).a; \r\n\r\ninterface Holder<T> {\r\n\tthing: T;\r\n}\r\nfunction infer<T, H extends Holder<T>>(holder: H): T {\r\n\treturn holder.thing;\r\n}\r\n```\r\n\r\n**Expected behavior:**\r\n\r\nThe type parameter `T` should be inferred to be the type of `thing` in the instance of `Holder` passed to the function `infer()`.\r\n\r\nPerhaps there is another way to get this type of inference to work? I'm building a builder-pattern class and really need this to correctly return the right types.\r\n\r\n**Actual behavior:**\r\n\r\nThe type parameter, `T`, is inferred to be `{}` when calling `infer()`\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/19382/comments",
    "author": "Yona-Appletree",
    "comments": [
      {
        "user": "ghost",
        "created_at": "2017-10-20T20:11:44Z",
        "body": "You don't actually need `H` here.\r\n```ts\r\nfunction infer<T>(holder: Holder<T>): T {\r\n\treturn holder.thing;\r\n}\r\n```"
      },
      {
        "user": "Yona-Appletree",
        "created_at": "2017-10-20T20:17:49Z",
        "body": "Fair, though in my actual code I do need it. Slightly contrived, but closer to my actual use case:\r\n\r\n```ts\r\nconst result = infer({ thing: { a: 10 } });\r\nresult.holder.thing += result.value.thing;\r\n\r\ninterface Holder<T> {\r\n\tthing: T;\r\n}\r\nfunction infer<T, H extends Holder<T>>(holder: H): { holder: H, value: T} {\r\n\treturn { holder, value: holder.thing };\r\n}\r\n```\r\n\r\n"
      },
      {
        "user": "ghost",
        "created_at": "2017-10-20T20:41:27Z",
        "body": "How about `function infer<T, H extends Holder<T>>(holder: H & Holder<T>): { holder: H, value: T} {`?"
      },
      {
        "user": "Yona-Appletree",
        "created_at": "2017-10-20T21:00:34Z",
        "body": "@andy-ms Yeah, that's perfect, actually. Thanks. It seems to me that it shouldn't be necessary, but this is a great work around."
      },
      {
        "user": "ghost",
        "created_at": "2017-10-20T21:02:46Z",
        "body": "@sandersn Could we infer a more specific `T` in the original example? It seems silly to add `& Holder<T>` when `H` already extends that."
      },
      {
        "user": "gcanti",
        "created_at": "2017-10-21T03:07:17Z",
        "body": "Another option\r\n\r\n```ts\r\nfunction infer<H extends Holder<any>>(holder: H): { holder: H; value: H['thing'] } {\r\n  return { holder, value: holder.thing }\r\n}\r\n```"
      },
      {
        "user": "mhegazy",
        "created_at": "2017-10-23T20:23:11Z",
        "body": "you can define your function as: \r\n```ts\r\nfunction infer<T, H extends Holder<T>>(holder: Holder<T> & H): T \r\n```"
      },
      {
        "user": "mhegazy",
        "created_at": "2017-11-07T00:20:59Z",
        "body": "Automatically closing this issue for housekeeping purposes. The issue labels indicate that it is unactionable at the moment or has already been addressed."
      },
      {
        "user": "ghost",
        "created_at": "2017-11-07T15:50:09Z",
        "body": "@sandersn Could we infer a more specific `T` in the original example? It seems silly to add `& Holder<T>` when `H` already extends that."
      },
      {
        "user": "mhegazy",
        "created_at": "2017-11-07T16:55:28Z",
        "body": "constraints are not inference positions.. they are merely for checking constraints after an inference has occurred. \r\n\r\nNow, the general question is i want to capture a container type \"and\" the type it contains.. this is doable through one of two ways.. either, you infer the container type, and you access the element type using indexed access type, e.g.:\r\n```ts\r\nfunction infer<H extends Holder<any>>(holder: H): H['thing'];\r\n```\r\nor through making two inferences using intersection types, e.g.:\r\n\r\n```ts\r\nfunction infer<T, H extends Holder<T>>(holder: Holder<T> & H): T;\r\n```"
      }
    ]
  },
  {
    "number": 19333,
    "title": "Test Case Issue",
    "created_at": "2017-10-19T09:40:28Z",
    "closed_at": "2017-11-02T20:04:10Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/19333",
    "body": "I have the following test case in my project which is failling:\r\n\t\r\n\r\nit('should have redux store in \"ref\"', () => {\r\n\tconst App =BR.boot({renderApp:false});\r\n\r\n\t\t\tconst component =TestUtils.renderIntoDocument (\r\n\t\t\t\t<App/>   //error at this point\r\n\t\t\t);\r\n\t\t expect(BR.refs.store).toBeTruthy();\r\n\t });\r\n\r\n\r\nI am getting an error:\r\n Unterminated regular expression  >\r\n\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/19333/comments",
    "author": "adnan1naeem",
    "comments": [
      {
        "user": "ghost",
        "created_at": "2017-10-19T15:52:19Z",
        "body": "Is it possible that you don't have JSX parsing enabled? (Try renaming the file to have a `.tsx` extension.)\r\nCould you try to get a standalone repro of this error?"
      },
      {
        "user": "mhegazy",
        "created_at": "2017-11-02T20:04:09Z",
        "body": "Automatically closing this issue for housekeeping purposes. The issue labels indicate that it is unactionable at the moment or has already been addressed."
      }
    ]
  },
  {
    "number": 19323,
    "title": "recursive reference occured and I don't know how to describe this....",
    "created_at": "2017-10-19T03:16:38Z",
    "closed_at": "2017-11-02T20:04:13Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/19323",
    "body": "```ts\r\n\r\n\r\nconst XXX1 = <T>(obj: { a: T, b: (v: any) => any }) => 1\r\n\r\nclass Test1 {\r\n\r\n    // td is any <--------------------------  why ????????????????\r\n    td = XXX1<string>(\r\n        { a: 'aaa', b: v => this.state.x + 123 } //as any   <----------\r\n    )\r\n\r\n    // state is any <-------------------------- why ????????????????\r\n    state = {\r\n        td: this.td,\r\n        x: 1,\r\n        y: 2\r\n    }\r\n}\r\n\r\n\r\n\r\nconst XXX2 = (obj: { a: string, b: (v: any) => any }) => 1\r\n\r\nclass Test2 {\r\n\r\n    //ok\r\n    td = XXX2(\r\n        { a: 'aaa', b: v => this.state.x + 123 }\r\n    )\r\n\r\n    //ok\r\n    state = {\r\n        td: this.td,\r\n        x: 1,\r\n        y: 2\r\n    }\r\n}\r\n```",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/19323/comments",
    "author": "fc01",
    "comments": [
      {
        "user": "DanielRosenwasser",
        "created_at": "2017-10-19T07:54:08Z",
        "body": "You can reduce this slightly.\r\n\r\n```ts\r\nfunction f<T>(obj: (v: any) => any) {\r\n  return 100;\r\n}\r\n\r\nclass Test1 {\r\n    foo = f(v => this.bar.x + 123)\r\n\r\n    bar = {\r\n        foo: this.foo,\r\n        x: 100\r\n    }\r\n}\r\n```\r\n\r\nI believe what is happening here is that you when we try to get the type of `td`, we need to check the call for `XXX2`. In that process, we need to make sure that the function `v => this.bar.x + 123` is assignable to `(v: any) => any`. This requires figuring out the type of `this.bar.x`, which requires us type-checking `this.bar`.\r\n\r\nHowever, `this.bar` references `this.foo` in that object literal. TypeScript detects a circularity and by default we just give you the type `any`. Under `noImplicitAny`, TypeScript will detect the circularity and give you an error.\r\n\r\nThe only thing you can really do here is add a type annotation."
      },
      {
        "user": "mhegazy",
        "created_at": "2017-11-02T20:04:13Z",
        "body": "Automatically closing this issue for housekeeping purposes. The issue labels indicate that it is unactionable at the moment or has already been addressed."
      }
    ]
  },
  {
    "number": 19207,
    "title": "Allow narrowing of discriminated unions at type level",
    "created_at": "2017-10-16T09:36:00Z",
    "closed_at": "2017-10-16T20:05:34Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/19207",
    "body": "Typescript currently supports narrowing of discriminated unions at value level.\r\n\r\nFor example,\r\n```ts\r\ntype Action = {\r\n    kind: \"CASE_1\";\r\n    payload: number;\r\n} | {\r\n    kind: \"CASE_2\";\r\n    payload: string;\r\n}\r\n...\r\n```\r\nSo, if we have a value of type `Action`, we can\r\ndetermine the type of the `payload` parameter based on the `kind` property.\r\n```ts\r\nconst action: Action = ...;\r\nif (action.kind === \"CASE_1\") {\r\n    action.payload; // type inferred as number\r\n} else if (action.kind === \"CASE_2\") {\r\n    action.payload; // type inferred as string;\r\n}\r\n```\r\nNow, since the compiler already has this information, it would be nice if we\r\ncould do this \"narrowing\" at the type level.\r\n\r\nSo, we should be able to have something like.\r\n```ts\r\n// not currently valid\r\ntype PayloadOf<Kind extends Action[\"kind\"]> =\r\n   Action[\"payload\"] where { Action[\"kind\"] is Kind }\r\n```\r\nHere, the where clause is adding a constraint to the `Action` type\r\nthat it's `kind` property is known to be the generic parameter `Kind`.\r\n\r\nHence,\r\n```ts\r\ntype PayloadOfCase1 = PayloadOf<\"CASE_1\">;\r\n```\r\nwill alias `PayloadOfCase1` to `number`.\r\n\r\n**Use cases**\r\nOne specific use case I can think of is in redux, where \"reducers\" are\r\njust functions that perform certain actions based on the `kind` of the action\r\nreceived. They're essentially giant switch statements on `action.kind`.\r\n\r\nIf implemented, something like this\r\n```ts\r\nfunction reducer(state: State, action: Action): State {\r\n    switch(action.type) {\r\n    case \"CASE_1\": return case1Handler(state, action.payload);\r\n    case \"CASE_2\": return case2Handler(state, action.payload);\r\n    ...\r\n    default: return state;\r\n    }\r\n}\r\n```\r\nCould be converted to this\r\n```ts\r\nconst reducer = createReducer({\r\n   \"CASE_1\": case1Handler,\r\n   \"CASE_2\": case2Handler,\r\n   ...\r\n});\r\ntype Cases {\r\n    [Kind in Action[\"kind\"]]: PayloadOf<Kind>\r\n}\r\nfunction createReducer(cases: Partial<Cases>): Reducer {\r\n    ...\r\n}\r\n```\r\nwithout losing type safety.",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/19207/comments",
    "author": "dhruvrajvanshi",
    "comments": [
      {
        "user": "ahejlsberg",
        "created_at": "2017-10-16T17:11:14Z",
        "body": "You can actually do this without any new features:\r\n\r\n```ts\r\ntype ActionMap = {\r\n    \"CASE_1\": number;\r\n    \"CASE_2\": string;\r\n}\r\n\r\ntype ActionKind = keyof ActionMap;\r\ntype ActionPayload<K extends ActionKind> = ActionMap[K];\r\ntype ActionObject<K extends ActionKind> = { kind: K, payload: ActionPayload<K> };\r\ntype Action = { [P in ActionKind]: ActionObject<P> }[ActionKind];\r\n```\r\n"
      },
      {
        "user": "dhruvrajvanshi",
        "created_at": "2017-10-16T20:05:34Z",
        "body": "Yes that works! Thanks."
      }
    ]
  },
  {
    "number": 19186,
    "title": "TS2339: Property 'tooltip' does not exist on type '{ label: string; } | { label: string; tooltip: string; }'.",
    "created_at": "2017-10-14T19:27:31Z",
    "closed_at": "2017-10-30T18:31:36Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/19186",
    "body": "**TypeScript Version:**  typescript@2.6.0-dev.20171014\r\n\r\n**Code**\r\n\r\n```ts\r\nconst cells = [\r\n  { label: '1' },\r\n  { label: '2', tooltip: '2' },\r\n  { label: '3', tooltip: '3' },\r\n  { label: '4' },\r\n  { label: '5' },\r\n  { label: '6' },\r\n]\r\nfor (const cell of cells) {\r\n  if (cell.tooltip) console.log(cell.tooltip)\r\n}\r\n```\r\n\r\n**Expected behavior:**\r\nThat this compiles without error; the error message seems to indicate TS sees a call to cell.tooltip as valid but then forbids it in the second part of the error message.\r\n\r\n**Actual behavior:**\r\n```\r\ntt.ts(10,12): error TS2339: Property 'tooltip' does not exist on type '{ label: string; } | { label: string; tooltip: string; }'.\r\n  Property 'tooltip' does not exist on type '{ label: string; }'.\r\ntt.ts(10,38): error TS2339: Property 'tooltip' does not exist on type '{ label: string; } | { label: string; tooltip: string; }'.\r\n  Property 'tooltip' does not exist on type '{ label: string; }'.\r\n```",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/19186/comments",
    "author": "retorquere",
    "comments": [
      {
        "user": "DanielRosenwasser",
        "created_at": "2017-10-14T21:20:28Z",
        "body": "Looks like a duplicate of #1260. You can get around this with a user-defined type guard or a type-assertion."
      },
      {
        "user": "retorquere",
        "created_at": "2017-10-14T21:53:16Z",
        "body": "I eyed that issue but couldn't make out whether it was the same problem; If it's a dup feel free to close. The suggestions in #1260 do allow compilation, but is this issue planned for a fix in a 2.x release? #1260 has been open for a while."
      },
      {
        "user": "ajafff",
        "created_at": "2017-10-14T22:22:10Z",
        "body": "The easy fix for your problem is a type annotation:\r\n```ts\r\nconst cells: {label: string, tooltip?: string} = [\r\n  { label: '1' },\r\n  { label: '2', tooltip: '2' },\r\n  { label: '3', tooltip: '3' },\r\n  { label: '4' },\r\n  { label: '5' },\r\n  { label: '6' },\r\n]\r\n```"
      },
      {
        "user": "retorquere",
        "created_at": "2017-10-14T22:27:10Z",
        "body": "Yeah, that's what I settled on in the end."
      },
      {
        "user": "mhegazy",
        "created_at": "2017-10-30T18:31:36Z",
        "body": "Automatically closing this issue for housekeeping purposes. The issue labels indicate that it is unactionable at the moment or has already been addressed."
      }
    ]
  },
  {
    "number": 19017,
    "title": "Type inference by property comparison",
    "created_at": "2017-10-08T12:59:55Z",
    "closed_at": "2017-10-08T16:00:32Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/19017",
    "body": "**TypeScript Version:**  2.5.3\r\n\r\n**Code**\r\n\r\n```ts\r\ninterface Symbol\r\n{\r\n    kind: \"namespace\"|\"class\"|\"interface\"|\"enum\";\r\n    basename: string;\r\n}\r\n\r\ninterface SymbolClass extends Symbol\r\n{\r\n    kind: \"class\";\r\n    extends: string;\r\n}\r\n\r\nfunction (symbol: Symbol)\r\n{\r\n    if (symbol.kind === \"class\")\r\n    {\r\n        //infer symbol as SymbolClass, is it possible?\r\n        console.log(symbol.extends);\r\n    }\r\n}\r\n```\r\n\r\n**Expected behavior:**\r\nNo error\r\n\r\n**Actual behavior:**\r\nProperty 'extends' does not exist on type 'Symbol'.",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/19017/comments",
    "author": "lmcarreiro",
    "comments": [
      {
        "user": "j-oliveras",
        "created_at": "2017-10-08T13:57:12Z",
        "body": "Something like:\r\n```ts\r\ninterface SymbolBase {\r\n    basename: string;\r\n}\r\n\r\ninterface SymbolClass extends SymbolBase {\r\n    kind: \"class\";\r\n    extends: string;\r\n}\r\n\r\ninterface SymbolNamespace extends SymbolBase {\r\n    kind: \"namespace\";\r\n}\r\n\r\ninterface SymbolInterface extends SymbolBase {\r\n    kind: \"interface\";\r\n}\r\n\r\ninterface SymbolEnum extends SymbolBase {\r\n    kind: \"enum\";\r\n}\r\n\r\ntype SymbolType = SymbolClass | SymbolNamespace | SymbolInterface | SymbolEnum;\r\n\r\nfunction func(sym: SymbolType) {\r\n    if (sym.kind === \"class\") {\r\n        console.log(sym.extends);\r\n    }\r\n}\r\n```"
      },
      {
        "user": "lmcarreiro",
        "created_at": "2017-10-08T16:00:32Z",
        "body": "It works, thanks!"
      }
    ]
  },
  {
    "number": 18973,
    "title": "compiler hide errors in tsx files, if there is \"import\"",
    "created_at": "2017-10-05T20:02:24Z",
    "closed_at": "2017-10-06T08:32:57Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/18973",
    "body": "**TypeScript Version:**  2.5.3\r\n\r\n**Code**\r\n\r\n1.tsx\r\n```ts\r\nimport Test from \"./2\"\r\n\r\ndeclare namespace JSX {\r\n  interface IntrinsicElements {\r\n    foo: { requiredProp: string; optionalProp?: number }\r\n  }\r\n}\r\nclass React {  static Render(a?: any, b?: any, c?: any) {} }\r\n\r\nfunction xxxxx() {\r\n  <foo />;\r\n}\r\n```\r\n2.ts\r\n```ts\r\nexport default class Test {}\r\n```\r\ncommand line\r\n``` tsc 1.tsx --jsx react```\r\n\r\n**Expected behavior:**\r\n```error TS2322: Type '{}' is not assignable to type '{ requiredProp: string; optionalProp?: number; }'.\r\n  Property 'requiredProp' is missing in type '{}'\r\n```\r\n\r\n**Actual behavior:**\r\ncompilation is success\r\n\r\n**Note:**  \r\nif I comment line 'import Test from \"./2\"', I get error as expected.",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/18973/comments",
    "author": "jack128",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2017-10-05T20:18:49Z",
        "body": "once a file has a top-level `import` or `export` it becomes a module. modules have their own scope. declarations within this module do not merge with declarations in the global scope.\r\n\r\nUse `declare global` instead:\r\n\r\n```ts\r\ndeclare global {\r\n  namespace JSX {\r\n    interface IntrinsicElements {\r\n      foo: { requiredProp: string; optionalProp?: number }\r\n    }\r\n  }\r\n}\r\n```"
      },
      {
        "user": "jack128",
        "created_at": "2017-10-06T08:32:57Z",
        "body": "Oh, I see. Thanks."
      }
    ]
  },
  {
    "number": 18870,
    "title": "Suggestion: Type predicates + union types (| false)",
    "created_at": "2017-09-30T21:38:49Z",
    "closed_at": "2017-10-01T02:32:22Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/18870",
    "body": "It would be nice to be able to write\r\n```typescript\r\nfunction filter<X, Y extends X>(list: X[], pred: (x: X) => (x is Y | false)): Y[] {\r\n  let out = [];\r\n  for (const k of list) {\r\n    if (pred(k)) {out.push(k)}\r\n  }\r\n  return out\r\n}\r\n```\r\n\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/18870/comments",
    "author": "acertain",
    "comments": [
      {
        "user": "DanielRosenwasser",
        "created_at": "2017-09-30T22:04:04Z",
        "body": "Sorry, I'm not understanding the notation and how it differs from type predicates today. Can you elaborate on what that would mean?"
      },
      {
        "user": "acertain",
        "created_at": "2017-10-01T02:32:22Z",
        "body": "Nevermind, it looks like this is possible today. You can't do `let test: ((x: string) => x is \"foo\") = (x) => false;` which made me think that type predicates couldn't return false if the value might have the type, but `function test(x: string): x is \"foo\" { return false;}` works. Still, it might be nice to have `(x is Y | false)` parse (and be equal to `x is Y`)"
      }
    ]
  },
  {
    "number": 18869,
    "title": "Suggestion: a better way to handle enums in generic functions",
    "created_at": "2017-09-30T19:45:18Z",
    "closed_at": "2017-10-01T01:15:29Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/18869",
    "body": "Currently, there's no \"easy\" way to write a generic function that takes an enum as input/generic parameter and returns one of its constants. Consider the following example, which shows a way to almost accomplish it:\r\n\r\n```ts\r\nenum Color {\r\n    RED = \"#FF0000\",\r\n    GREEN = \"#00FF00\",\r\n    BLUE = \"#0000FF\"\r\n}\r\n\r\ndeclare function randomKey<T>(object: T): keyof T;\r\n\r\n// One overload for numeric enums and one for string enums\r\nfunction randomEnumValue<E extends {[P in keyof E]: number}>(enumObject: E): number;\r\nfunction randomEnumValue<E extends {[P in keyof E]: string}>(enumObject: E): string;\r\n\r\nfunction randomEnumValue(enumObject: any): any {\r\n    return enumObject[randomKey(enumObject)];\r\n}\r\n\r\ndeclare function doSomethingWithColor(color: Color);\r\n\r\nlet color = <Color> randomEnumValue(Color);\r\ndoSomethingWithColor(color);\r\n```\r\n\r\nThe problem with this approach is that every call to `randomEnumValue` requires a cast to the enum type (the code would compile if `Color` was a numeric enum but `color` would still be a `number`, not a `Color`). Also note that two overloads were required and the generic restriction `E extends {[P in keyof E]: number}` allows a lot of undesired types (i.e non-enums).\r\n\r\nI suggest the following version:\r\n```ts\r\nfunction randomEnumValue<T, E extends enum<T>>(enumObject: typeof E): E {\r\n    return enumObject[randomKey(enumObject)];\r\n}\r\n```\r\n\r\nHere, `T` is the underlying type of the enum (currently, that means either `number` or `string`). `enum<T>` is a special type used to restrict a generic parameter to an enum of underlying type `T`. Also note that the parameter `enumObject` has type `typeof E`, which I think is currently not allowed and therefore is also part of my suggestion. That example would make it unnecessary to put a cast when calling that function, e.g\r\n\r\n```ts\r\n// calls randomEnumValue<string, Color>(enumObject: typeof Color): Color\r\nlet color = randomEnumValue(Color);\r\n// color has type Color\r\n```\r\n\r\nAnother possibility that crossed my mind is something like this:\r\n```ts\r\nfunction randomEnumValue<T, E extends enum<T>>(enumObject: E): EnumMember<E> {\r\n    return enumObject[randomKey(enumObject)];\r\n}\r\n```\r\n\r\nThis might be easier to implement and I'm not sure which way would be preferable, but I feel like the overall idea of this suggestion would make enums better to manipulate.\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/18869/comments",
    "author": "Ghabriel",
    "comments": [
      {
        "user": "ahejlsberg",
        "created_at": "2017-09-30T22:24:48Z",
        "body": "It already works without any overloads:\r\n\r\n```ts\r\nenum Color {\r\n    RED = \"#FF0000\",\r\n    GREEN = \"#00FF00\",\r\n    BLUE = \"#0000FF\"\r\n}\r\n\r\ndeclare function randomKey<T>(object: T): keyof T;\r\n\r\nfunction randomEnumValue<T>(enumObject: T) {  // Inferred return type is T[keyof T]\r\n    return enumObject[randomKey(enumObject)];\r\n}\r\n\r\nlet color = randomEnumValue(Color);  // Inferred type is Color\r\n```\r\n\r\nThe inferred return type for `randomEnumValue` is `T[keyof T]` which for an enum object is the enum type, i.e. precisely what you want. Of course it also works if you add a type annotation:\r\n\r\n```ts\r\nfunction randomEnumValue<T>(enumObject: T): T[keyof T] {\r\n    return enumObject[randomKey(enumObject)];\r\n}\r\n```\r\n"
      },
      {
        "user": "Ghabriel",
        "created_at": "2017-10-01T01:15:28Z",
        "body": "Thanks, totally forgot about T[keyof T]... I still think that it would be useful to restrict a function to only accept enums, but considering that your example works I can't really think of a good use case right now. If anyone can think of a good use case, feel free to reopen this issue (if that's possible) or reference it in a new one."
      }
    ]
  },
  {
    "number": 18763,
    "title": "Decorator should support hoisting",
    "created_at": "2017-09-26T10:06:59Z",
    "closed_at": "2017-09-26T17:18:18Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/18763",
    "body": "Decorator used before declaration does not decorate anything. When combining many files, we don't know in which order files will be merged.\r\n\r\nWorkaround is to change filename containing decorators should be prefixed with \"_\".\r\n\r\n**TypeScript Version:**  2.4.0 / nightly (2.5.0-dev.201xxxxx)\r\n\r\n**Code**\r\n\r\n```ts\r\n\r\nnamespace App {\r\n\r\n    // never called...\r\n    @injectGlobal\r\n    export class BrowserService{\r\n    }\r\n\r\n\r\n    // decorator...\r\n    export function injectGlobal(){\r\n    }\r\n\r\n}\r\n```\r\n\r\n\r\n**Expected behavior:**\r\nDecorator declared even after use should work correctly.\r\n\r\n\r\n**Actual behavior:**\r\nDecorator never gets called.\r\n\r\n**Workaround**\r\n\r\nRename files and prefix with \"_\", works on windows, haven't tried it on other platforms.",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/18763/comments",
    "author": "neurospeech",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2017-09-26T17:18:18Z",
        "body": "This is not a support forum; please use Stack Overflow or other question forums if you're having trouble with ordering your output file."
      },
      {
        "user": "neurospeech",
        "created_at": "2017-09-26T19:27:52Z",
        "body": "@RyanCavanaugh I have already posted a workaround so I am not looking for any support. Decorators are simple functions, just like other function hoisting why can't it support hoisting instead of ordering them? I haven't found any ECMA script specifications which says otherwise, but I believe it should be consistent with normal functions. Except decorators, you don't really need to order anything."
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2017-09-26T19:37:58Z",
        "body": "```\r\nC:\\Throwaway\\dectest>tsc a.ts --experimentalDecorators\r\n\r\nC:\\Throwaway\\dectest>type a.ts\r\nnamespace App {\r\n    @injectGlobal\r\n    export class BrowserService{\r\n    }\r\n\r\n    // decorator...\r\n    export function injectGlobal(cls: any) {\r\n        console.log(\"Hello!\");\r\n    }\r\n}\r\n\r\nC:\\Throwaway\\dectest>node a.js\r\nHello!\r\n```"
      },
      {
        "user": "neurospeech",
        "created_at": "2017-09-26T19:48:43Z",
        "body": "@RyanCavanaugh try this... try to put two namespaces of same name in different namespace.\r\n\r\n\r\n```typescript\r\n\r\nC:\\Throwaway\\dectest>tsc a.ts --experimentalDecorators\r\n\r\nC:\\Throwaway\\dectest>type a.ts\r\nnamespace App {\r\n    @injectGlobal\r\n    export class BrowserService{\r\n    }\r\n}\r\nnamespace App {\r\n    // decorator...\r\n    export function injectGlobal(cls: any) {\r\n        console.log(\"Hello!\");\r\n    }\r\n}\r\nconsole.log(\"Done\");\r\n\r\nC:\\Throwaway\\dectest>node a.js\r\nDone\r\n```\r\n\r\n"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2017-09-26T20:15:52Z",
        "body": "Hoisting does not occur across namespaces"
      }
    ]
  },
  {
    "number": 18761,
    "title": "Cannot find types in sub-project",
    "created_at": "2017-09-26T07:23:08Z",
    "closed_at": "2017-09-27T03:23:02Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/18761",
    "body": "**TypeScript Version:**  2.5.2\r\n\r\n**Code**\r\n```js\r\n// [1]\r\n// tsconfig.json\r\n{\r\n    \"compilerOptions\": {\r\n      \"allowJs\": true,\r\n      \"sourceMap\": true,\r\n      \"declaration\": false,\r\n      \"skipLibCheck\": true,\r\n      \"noImplicitAny\": false,\r\n      \"strictNullChecks\": false,\r\n      \"module\": \"es2015\",\r\n      \"moduleResolution\": \"node\",\r\n      \"target\": \"es5\",\r\n      \"typeRoots\": [\r\n        \"node_modules/@types\"\r\n      ],\r\n      \"lib\": [\r\n        \"dom\",\r\n        \"es5\",\r\n        \"scripthost\",\r\n        \"es2015\"\r\n      ]\r\n    },\r\n    \"include\": [\r\n      \"types/**/*.d.ts\",\r\n      \"src/**/*.ts\"\r\n    ],\r\n    \"exclude\": [\r\n      \"node_modules\"\r\n    ]\r\n  }\r\n```\r\n\r\n```ts\r\n// git-submodule/src/index.ts\r\nDate.prototype.format = function () {\r\n    return 90; // Just for demo\r\n};\r\nconst date = new Date();\r\nconst format = date.format();\r\nexport default format;\r\n\r\n// git-submodule/types/custom.d.ts\r\ninterface Date {\r\n    format(): number;\r\n}\r\n\r\n// git-submodule/tsconfig.json // see above [1]\r\n\r\n// src/index.ts\r\nimport Sub from '../git-submodule/src/index';\r\n\r\n// src/tsconfig.json // see above [1]\r\n```\r\n\r\nthen, run `tsc` in root directory.\r\n\r\n**Expected behavior:**\r\nNo errors.\r\n\r\n**Actual behavior:**\r\n```\r\n// errors\r\ngit-submodule/src/index.ts(1,16): error TS2339: Property 'format' does not exist on type 'Date'.\r\ngit-submodule/src/index.ts(6,21): error TS2339: Property 'format' does not exist on type 'Date'.\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/18761/comments",
    "author": "Aqours",
    "comments": [
      {
        "user": "ghost",
        "created_at": "2017-09-26T14:38:43Z",
        "body": "TypeScript won't look at the `tsconfig.json` for imported modules. So it won't know that in `git-submodule` you had a `tsconfig.json` that included the types.\r\nIf you need to expose types from a package, you should reference them from its `index` in some way, such as with `/// <reference path=\"./types/custom.d.ts\" />.`\r\nIn this case, you could also not bother with putting types in a separate file and just do:\r\n```ts\r\ndeclare global {\r\n    interface Date {\r\n        format(): number;\r\n    }\r\n}\r\n```"
      },
      {
        "user": "Aqours",
        "created_at": "2017-09-27T03:23:02Z",
        "body": "@andy-ms \r\nIt works great.\r\n\r\nFurthermore, defined types of root project(e.g: `/// <reference path=\"./root-project.d.ts\" />`) will expose to sub-project which can use those types in `root-project.d.ts` file even if sub-project does not define those types. And compiling code will not throw type error, it's unreasonable.\r\n\r\n"
      }
    ]
  },
  {
    "number": 18676,
    "title": "Cannot find module 'vue' when 'module' is set to 'umd'",
    "created_at": "2017-09-22T02:08:27Z",
    "closed_at": "2017-09-22T05:08:51Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/18676",
    "body": "**TypeScript Version:**  2.5.2\r\n\r\nwhen tsc complie `d:/elecapp/one/comp/test.ts`\r\n\r\n**Code**\r\n\r\n```javascript\r\n======== Resolving module 'vue' from 'd:/elecapp/one/comp/test.ts'. ========\r\nModule resolution kind is not specified, using 'Classic'.\r\nFile 'd:/elecapp/one/comp/vue.ts' does not exist.\r\nFile 'd:/elecapp/one/comp/vue.tsx' does not exist.\r\nFile 'd:/elecapp/one/comp/vue.d.ts' does not exist.\r\nFile 'd:/elecapp/one/vue.ts' does not exist.\r\nFile 'd:/elecapp/one/vue.tsx' does not exist.\r\nFile 'd:/elecapp/one/vue.d.ts' does not exist.\r\nFile 'd:/elecapp/vue.ts' does not exist.\r\nFile 'd:/elecapp/vue.tsx' does not exist.\r\nFile 'd:/elecapp/vue.d.ts' does not exist.\r\nFile 'd:/vue.ts' does not exist.\r\nFile 'd:/vue.tsx' does not exist.\r\nFile 'd:/vue.d.ts' does not exist.\r\nDirectory 'd:/elecapp/one/comp/node_modules' does not exist, skipping all lookups in it.\r\nDirectory 'd:/elecapp/one/node_modules' does not exist, skipping all lookups in it.\r\nFile 'd:/elecapp/node_modules/@types/vue.d.ts' does not exist.\r\nDirectory 'd:/node_modules' does not exist, skipping all lookups in it.\r\nFile 'd:/elecapp/one/comp/vue.js' does not exist.\r\nFile 'd:/elecapp/one/comp/vue.jsx' does not exist.\r\nFile 'd:/elecapp/one/vue.js' does not exist.\r\nFile 'd:/elecapp/one/vue.jsx' does not exist.\r\nFile 'd:/elecapp/vue.js' does not exist.\r\nFile 'd:/elecapp/vue.jsx' does not exist.\r\nFile 'd:/vue.js' does not exist.\r\nFile 'd:/vue.jsx' does not exist.\r\n======== Module name 'vue' was not resolved. ========\r\n```\r\n\r\n**Expected behavior:**\r\n\r\n```javascript\r\nFile 'd:/elecapp/node_modules/@types/vue.d.ts' does not exist.\r\nFile 'd:/elecapp/node_modules/vue/types/index.d.ts' exist.\r\n```\r\n\r\n**Actual behavior:**\r\n\r\n```javascript\r\nFile 'd:/elecapp/node_modules/@types/vue.d.ts' does not exist.\r\n```\r\n\r\nIt's only find `@types/vue.d.ts` does not exist , but it didn't find there is `vue/types/index.d.ts` already exists.\r\n\r\ninside /vue/package.json(there is typings):\r\n\r\n```javascript\r\n  \"typings\": \"types/index.d.ts\",\r\n  \"unpkg\": \"dist/vue.js\",\r\n  \"version\": \"2.4.4\"\r\n```\r\n\r\n\r\nps tsconfig.json:\r\n```javascript\r\n{\r\n  \"compilerOptions\": {\r\n    \"target\": \"es5\",\r\n    \"module\": \"umd\",\r\n    \"declaration\": false,\r\n    \"traceResolution\": true,\r\n    \"noImplicitAny\": false, \r\n    \"skipLibCheck\": true, \r\n    \"allowJs\": false,\r\n    \"checkJs\": false,\r\n    \"lib\": [\r\n      \"dom\",\r\n      \"scripthost\",\r\n      \"webworker\",\r\n      \"es5\",\r\n      \"es2015\",\r\n      \"es2016\",\r\n      \"es2017\",\r\n      \"esnext\"\r\n    ]\r\n  },\r\n  \"include\": [\r\n    \"one/*/*.tsx\",\r\n    \"one/*/*.ts\"\r\n  ],\r\n  \"exclude\": []\r\n}\r\n```",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/18676/comments",
    "author": "yolio2003",
    "comments": [
      {
        "user": "DanielRosenwasser",
        "created_at": "2017-09-22T03:18:42Z",
        "body": "Try setting your `\"moduleResolution\"` strategy to `\"node\"` which isn't the default on `\"module\": \"umd\"`"
      },
      {
        "user": "yolio2003",
        "created_at": "2017-09-22T05:08:51Z",
        "body": "ok, thx, it works pretty well"
      }
    ]
  },
  {
    "number": 18573,
    "title": "React with Typescript error",
    "created_at": "2017-09-19T13:02:15Z",
    "closed_at": "2017-09-19T17:18:11Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/18573",
    "body": "I continue to get this error when I try to add props on a component. I cannot find the solution anf or work around. Is this a bug?\r\n\r\n[ts] Property 'title' does not exist on type 'IntrinsicAttributes & IntrinsicClassAttributes<AppHeader> & Readonly<{ children?: ReactNode; }> &...'.\r\n\r\n**TypeScript Version:**  2.5.7 \r\n\r\n**Code**\r\n```ts\r\nimport * as React from 'react';\r\nimport AppFooter from './Footer';\r\nimport AppHeader from './Header';\r\n\r\nexport default class Layout extends React.Component {\r\n  render() {\r\n    const title = 'Welcome Mark';\r\n    return (\r\n      <div>\r\n        <AppHeader title={title}/>\r\n        <AppFooter />\r\n      </div>\r\n    )\r\n  }\r\n}\r\n```",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/18573/comments",
    "author": "Suka1215",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2017-09-19T17:18:11Z",
        "body": "This is not a support forum. If you think you've found a bug, please include a way to reproduce the bug. We don't have the definition of `AppHeader` so we have no way of knowing what might be going wrong with your code."
      }
    ]
  },
  {
    "number": 18468,
    "title": "'type definition only import' transpiled to js",
    "created_at": "2017-09-14T14:59:32Z",
    "closed_at": "2017-10-02T22:51:19Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/18468",
    "body": "**TypeScript Version:**  2.4.2\r\n\r\n**Code**\r\n\r\n```ts\r\nimport * as tsp from \"typescript/lib/protocol\";\r\n\r\nexport function foo() : string {\r\n    return tsp.CommandTypes.Brace;\r\n}\r\n```\r\n\r\n**Expected behavior:**\r\nThe resulting JS should not contain \r\n```js\r\nconst tsp = require(\"typescript/lib/protocol\");\r\n```\r\n\r\n**Actual behavior:**\r\nbut it does.\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/18468/comments",
    "author": "svenefftinge",
    "comments": [
      {
        "user": "kitsonk",
        "created_at": "2017-09-14T15:06:09Z",
        "body": "You are not using `tsp` in a value position, so it does not get erased.  Those definitions are not UMD definitions, they are global definitions.  They should not be imported into a module.  If you need to use them, it should just be in the scope of the compiler, so in your `tsconfig.json` `\"include\"` or as a triple slash ref."
      },
      {
        "user": "svenefftinge",
        "created_at": "2017-09-14T15:56:57Z",
        "body": "Yes, it is a value position but there are no references in the generated js, as the string values from the enum are inlined. Shouldn't that be detected by the compiler?"
      },
      {
        "user": "kitsonk",
        "created_at": "2017-09-14T16:05:01Z",
        "body": "```\r\n$ cat test.ts\r\nimport * as tsp from \"typescript/lib/protocol\";\r\n\r\nexport function foo() : string {\r\n    return tsp.CommandTypes.Brace;\r\n}\r\n\r\n$ tsc test.ts\r\ntest.ts(4,12): error TS2708: Cannot use namespace 'tsp' as a value.\r\n$ tsc --version\r\nVersion 2.4.2\r\n```\r\n\r\nIt is even telling you, you got a problem.\r\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2017-10-02T22:51:19Z",
        "body": "Automatically closing this issue for housekeeping purposes. The issue labels indicate that it is unactionable at the moment or has already been addressed."
      }
    ]
  },
  {
    "number": 18463,
    "title": "The operand of an increment or decrement operator must be a variable or a property access.",
    "created_at": "2017-09-14T09:57:22Z",
    "closed_at": "2017-09-14T12:55:00Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/18463",
    "body": "```\r\nclass Test {\r\n    a(i: number): number {\r\n        return i;\r\n    }\r\n    b(i: number): number {\r\n        return this.a( i ) ++; // Error. Bug?\r\n    }\r\n}\r\n```",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/18463/comments",
    "author": "acopalipsis",
    "comments": [
      {
        "user": "kitsonk",
        "created_at": "2017-09-14T10:30:14Z",
        "body": "TypeScript is protecting you from doing something that is non-sensical, because the increment operator is intended to increment a value of a variable or property.  In this case it isn't.  While it is valid runtime syntax, a big part of the operators behaviour is missing, trying to point out you are making a logic error.  Because if you are not trying to increment a variable or property, it would be much clear to just write:\r\n\r\n```ts\r\nclass Test {\r\n    a(i: number): number {\r\n        return i;\r\n    }\r\n    b(i: number): number {\r\n        return this.a( i ) + 1;\r\n    }\r\n}\r\n```\r\n"
      }
    ]
  },
  {
    "number": 18432,
    "title": "Inconsistent type-check with enum",
    "created_at": "2017-09-13T10:16:49Z",
    "closed_at": "2017-09-13T17:37:38Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/18432",
    "body": "**TypeScript Version:** 2.5.2\r\n\r\nWhen I use numerical references in my enum I lose the ability to properly type-check with the enum in a class property\r\n\r\n**code**\r\nExample 1 passes type-checking, but produces run-time 404\r\n```ts\r\nexport class Item {\r\n  id: number;\r\n  name: string;\r\n  badge: ITEMBADGE; \r\n}\r\n\r\nexport enum ITEMBADGE {\r\n  'item1.svg' = 1,\r\n  'item2.svg' = 2\r\n}\r\n\r\nexport const ITEMS: Item[] = [\r\n  {id: 1, name: 'item1', badge: 1}, // runtime 404 error \r\n  {id: 2, name: 'item2', badge: 2}\r\n]\r\n```\r\nExample 2 Does not pass type-check, but seems to me that it should\r\ngiven: `ITEMBADGE[1] === 'item1.svg' // true` \r\n\r\n```ts\r\nexport class Item {\r\n  id: number;\r\n  name: string;\r\n  badge: ITEMBADGE;  // changing this to type 'string' or type 'any' gets rid if the error, but I lose the type reference to enum ITEMBADGE therefore any string will suffice at run-time\r\n}\r\n\r\nexport enum ITEMBADGE {\r\n  'item1.svg' = 1,\r\n  'item2.svg' = 2\r\n}\r\n\r\n// [ts] Type '{ id: number; name: string; badge: string; }[]' is not assignable to type 'Item[]'.\r\n//   Type '{ id: number; name: string; badge: string; }' is not assignable to type 'Item'.\r\n//   Types of property 'badge' are incompatible.\r\n//     Type 'string' is not assignable to type 'ITEMBADGE'.\r\n// const ITEMS: Item[]\r\nexport const ITEMS: Item[] = [\r\n  {id: 1, name: 'item1', badge: ITEMBADGE[1]}, \r\n  {id: 2, name: 'item2', badge: ITEMBADGE[2]}\r\n]\r\n```\r\n\r\n**Expected behavior:**\r\nexpected ts to see that the number reference to the enum is a string, since the class property `badge` can be set to type `string` then `ITEMBADGE[1]` produces the desired result\r\n\r\n**Actual behavior:**\r\nAlthough `ITEMBADGE[1]` is a `string` in this case, using `ITEMBADGE` as a type-check for `badge` in the class causes an error.  Assigning `badge: string;` type allows compilation\r\n\r\n**further notes:**\r\nIt seems the issue is specific to number references with enum.  When I changed the enum to non-numerical references it works and I can use ITEMBADGE as a type-check in my class:\r\n\r\n```ts\r\nexport class Item {\r\n  id: number;\r\n  name: string;\r\n  badge: ITEMBADGE;\r\n}\r\n\r\nexport enum ITEMBADGE {\r\n  ITEM1 = 'item1.svg',\r\n  ITEM2 = 'item2.svg'\r\n}\r\n\r\nexport const ITEMS: Item[] = [\r\n  {id: 1, name: 'item1', badge: ITEMBADGE.ITEM1},\r\n  {id: 2, name: 'item2', badge: ITEMBADGE.ITEM2}\r\n]\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/18432/comments",
    "author": "Hachero",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2017-09-13T17:37:38Z",
        "body": "The reverse map (from number to string) isn't intended for regular use because it's not guaranteed that any particular *value* has only one *key*, e.g. this is legal:\r\n```ts\r\nenum Foo {\r\n  bar = 1,\r\n  baz = 1\r\n}\r\nFoo[1] // 'baz', not 'bar'\r\n```\r\nFor your case I'd recommend using string enums; in general the reverse map for numeric enums should only be used for debugging / error message purposes."
      }
    ]
  },
  {
    "number": 18401,
    "title": "No way to type-constrain a value as object-but-not-a-function",
    "created_at": "2017-09-12T03:43:58Z",
    "closed_at": "2017-09-27T22:40:00Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/18401",
    "body": "**TypeScript Version:**  2.5.2\r\n\r\nJust as `typeof someFunction === 'function'`, how do I type-constrain a generic parameter to only those types which would satisfy that same expression?\r\n\r\n**Code**\r\n\r\n```ts\r\nfunction isObject<T extends object>(value: T | string | number | boolean | symbol | Function | null | undefined): value is T {\r\n  return typeof value === 'object' && value !== null;\r\n}\r\n\r\nconst fn = function () { return 'foo'; };\r\n!isObject(fn) && fn.name; // fn.name is never\r\n```\r\n\r\n**Expected:**\r\n\r\nAfter failing the type guard check, `fn.name` should have a compile time type of `string`, seeing as `fn` is a function primitive, not a standard object primitive.\r\n\r\n**Actual:**\r\n\r\nAfter failing the type guard check, `fn.name` has a compile time type of `never`.\r\n\r\nThis issue does not occur if the function is a local function declared via a `function` statement, rather than as a variable assignment.\r\n\r\nThe `object` type seems to match variables assigned a function value, and there appears to be no primitive type keyword that TypeScript understands as meaning a value having the `function` type, rather than just an object (`Function`) that has functional characteristics. I have also tried `((...args: any[]) => any)`, though I suspect the compiler treats that the same way as `Function`. I know that in JavaScript, functions are technically objects and can have arbitrary properties attached, but they're also special in that they're callable, and are first class primitives in JavaScript in that respect, and so I would expect TypeScript would be able to help me identify objects that are *not* functions, especially seeing as functions are such an integral and fundamental type in JavaScript.\r\n\r\n**Update:**\r\n\r\nFunction overloads appear to solve the problem:\r\n\r\n```ts\r\nexport type Primitive = string | number | boolean | symbol | null | undefined;\r\n\r\nexport function isObject<T extends Function>(value: T): false;\r\nexport function isObject<T extends object>(value: T | Primitive): value is T;\r\nexport function isObject<T extends object>(value: T | Primitive): value is T {\r\n  return typeof value === 'object' && value !== null;\r\n}\r\n\r\n// compilation tests:\r\nfunction c () { return 'foo'; }\r\nconst d = function () { return 'foo'; };\r\nconst a = 'foo', b = { foo: 'bar' };\r\nisObject(a) && a.length; // good; compiles fine\r\n!isObject(a) && a.length; // good; compiles fine\r\nisObject(b) && b.foo; // good; compiles fine\r\n!isObject(b) && b.foo; // good; error as expected\r\nisObject(c) && c.name; // good; compiles fine\r\n!isObject(c) && c.name; // good; compiles fine\r\nisObject(d) && d.name; // good; compiles fine\r\n!isObject(d) && d.name; // good; compiles fine\r\n```\r\n\r\nI'll leave the issue open pending confirmation that I'm not missing any relevant caveats. Devs, feel free to close it if so.",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/18401/comments",
    "author": "axefrog",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2017-09-12T19:57:46Z",
        "body": "Not a bug; functions are a subtype of objects. There isn't a way to express `isObjectButNotFunction` (same as there isn't a way to express `isAnimalButNotDog`)"
      },
      {
        "user": "axefrog",
        "created_at": "2017-09-27T22:40:00Z",
        "body": "Ok, thanks."
      }
    ]
  },
  {
    "number": 18389,
    "title": "Overloading function with literal argument doesn't work",
    "created_at": "2017-09-11T15:56:31Z",
    "closed_at": "2017-09-11T16:04:52Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/18389",
    "body": "**TypeScript Version:**  2.5.2\r\n\r\n**Code**\r\n```ts\r\nfunction test(p: 'a'): 'a';\r\nfunction test(p: string): string {\r\n    return p;\r\n}\r\n\r\ntest('b');\r\n```\r\n\r\n**Expected behavior:**\r\nno errors\r\n\r\n**Actual behavior:**\r\nArgument of type '\"b\"' is not assignable to parameter of type '\"a\"'.\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/18389/comments",
    "author": "dfilatov",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2017-09-11T15:59:21Z",
        "body": "The function has one signature. the other one is called an \"implementation\" signature, is only visible within the body of the function. so if you want your function to be called with a `string`, add a new overload.\r\n\r\n```ts\r\nfunction test(p: 'a'): 'a';\r\nfunction test(p: string): string;\r\nfunction test(p: string): string {\r\n    return p;\r\n}\r\n```"
      },
      {
        "user": "dfilatov",
        "created_at": "2017-09-11T16:04:52Z",
        "body": "@mhegazy Thank you for explanation!"
      }
    ]
  },
  {
    "number": 18041,
    "title": "keyof strange type casting",
    "created_at": "2017-08-25T12:53:09Z",
    "closed_at": "2017-08-29T14:17:37Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/18041",
    "body": "TSC 2.4.2\r\n\r\n```ts\r\nfunction foo1<T>(e: T, k: string) {\r\n    let\r\n        v = e[k];   // v: any\r\n}\r\n\r\nfunction foo2<T>(e: T, k: keyof T) {\r\n    let\r\n        v = e[k];   // v: T[keyof T]\r\n}\r\n```\r\n\r\nI would expect that for `foo2` type of `v` should also be `any`",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/18041/comments",
    "author": "pankleks",
    "comments": [
      {
        "user": "ikatyang",
        "created_at": "2017-08-25T13:49:24Z",
        "body": "`v` in `foo2` must be something in `e`, `T[keyof T]` did describe its relationship well."
      },
      {
        "user": "pankleks",
        "created_at": "2017-08-29T12:18:42Z",
        "body": "@ikatyang not sure I understand your answer - could you please elaborate a bit more - thanks:)"
      },
      {
        "user": "ikatyang",
        "created_at": "2017-08-29T12:50:50Z",
        "body": "Not sure how to elaborate, lets take an example. Imagine passing `MyObject` as `T` into that function:\r\n\r\n```ts\r\ninterface MyObject {\r\n  a: boolean;\r\n  b: number;\r\n  c: string;\r\n}\r\n\r\ntype MyKeys = keyof MyObject; //=> 'a' | 'b' | 'c'\r\ntype MyValues = MyObject[MyKeys]; //=> boolean | number | string\r\n\r\nfunction foo1<T>(e: T, k: string) {\r\n    //           ^     ^ string\r\n    //           MyObject\r\n    let\r\n        v = e[k];\r\n    //  ^ MyObject[string] = ??? = any\r\n    //    (string is not one of its keys, so TS think it can be anything.)\r\n    //    (keys are string, but string is not key, since key is more specific.)\r\n}\r\n\r\nfunction foo2<T>(e: T, k: keyof T) {\r\n    //           ^     ^ MyKeys\r\n    //           MyObject\r\n    let\r\n        v = e[k];\r\n    //  ^ MyObject[MyKeys] = MyValues = boolean | number | string\r\n    //    (MyKeys is one of its keys, so TS knows how to get its type)\r\n}\r\n```"
      },
      {
        "user": "pankleks",
        "created_at": "2017-08-29T14:17:37Z",
        "body": "It's smarter than I assumed - just notation `T[keyof T]` is a little confusing :)\r\n\r\nThanks!"
      }
    ]
  },
  {
    "number": 18002,
    "title": "Signature test with overloading not working",
    "created_at": "2017-08-24T09:19:41Z",
    "closed_at": "2017-08-24T10:49:24Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/18002",
    "body": "**TypeScript Version:**  2.4.1\r\n\r\n**Code**\r\n\r\n```ts\r\nexport class api {\r\n    public static works();\r\n    public static works(propertyName: string);\r\n    public static works(propertyNames: string[]);\r\n\r\n    public static works(propertyName?: string | string[]) {\r\n        return system.testing(propertyName as string); // No idea why the type assertion is needed\r\n    }\r\n    public static worksNot();\r\n    public static worksNot(propertyName: string);\r\n    public static worksNot(propertyNames: string[]);\r\n\r\n    public static worksNot(propertyName?: string | string[]) {\r\n        return system.testing(propertyName); // compile error!\r\n    }\r\n}     \r\n\r\nexport class system {\r\n    public static testing();\r\n    public static testing(propertyName: string);\r\n    public static testing(propertyNames: string[]);\r\n    // [Edit] needs\r\n    //public static testing(propertyName?: string | string[])\r\n\r\n    public static testing(propertyName?: string | string[]) {\r\n        // Do some stuff with string or string[]\r\n        return;\r\n    }\r\n}\r\n```\r\n\r\n**Expected behavior:**\r\nShould compile without a problem\r\n**Actual behavior:**\r\n error TS2345: Build:Argument of type 'string | string[]' is not assignable to parameter of type 'string[]'.",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/18002/comments",
    "author": "HolgerJeromin",
    "comments": [
      {
        "user": "ikatyang",
        "created_at": "2017-08-24T09:44:43Z",
        "body": "Duplicate of #17508."
      },
      {
        "user": "HolgerJeromin",
        "created_at": "2017-08-24T10:15:55Z",
        "body": "Thanks for the link. \r\nBut IMO this is still a bug."
      },
      {
        "user": "kitsonk",
        "created_at": "2017-08-24T10:23:02Z",
        "body": "It maybe your opinion, but this has been discussed quite a lot before.  #17508 is just one example.\r\n\r\nThe reason it doesn't work is because of the need for co-variant types, which at the moment is problematic with TypeScript.  That being said, it also is totally redundant now that we have union types.  We used to have to expand overloads because we didn't have the union types, now we don't."
      },
      {
        "user": "HolgerJeromin",
        "created_at": "2017-08-24T10:49:24Z",
        "body": "Ok, thanks a lot both of you. My usecase is solvable. \r\nAnd you are right. It is better to leave it like that for the big picture."
      }
    ]
  },
  {
    "number": 17927,
    "title": "number data type implements or not a Number type?",
    "created_at": "2017-08-19T14:12:11Z",
    "closed_at": "2017-09-05T17:05:36Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/17927",
    "body": "For its language segment I'm writing a detailed tutorial for TypeScript.\r\nBut there is one thing that I cannot understand. The data type t implements the data type T?\r\nOr the data type of t compatible with the data type T?\r\n(t === number, string, boolean, symbol, object)\r\n(T === Number, String, Boolean, Symbol, Object)\r\n\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/17927/comments",
    "author": "isoftninja",
    "comments": [
      {
        "user": "aluanhaddad",
        "created_at": "2017-08-19T15:12:17Z",
        "body": "The types `number`, `string`, `boolean`, and `symbol` are the types of values of literals of each of their respective types as well as operators on those types and various conversions.\r\nFor example:\r\n```ts\r\n\"hello world\" // literal -> type of expression is string\r\nvar s = \"hello world\"; // -> type of s is string\r\n```\r\nThese types also arise from operations that perform conversions\r\nFor example:\r\n```ts\r\n+\"12\" //  literal (type string) converted via `+`-> expression has type number\r\n```\r\nAnother way to write the above is to invoke the JavaScript built in function object `Number`\r\n```ts\r\nNumer(\"12\") // literal (type string) converted by calling `Number`-> expression has type number\r\n```\r\nAll of these uses are fine and all produce values of types corresponding to the lowercase variants.\r\n\r\nHowever, where the uppercase variants come into play is when certain JavaScript built in function objects such as the above `Number`, are invoked with `new`.\r\nFor example:\r\n```ts\r\nnew Number(\"12\") // literal (type string) as ctor arg of `Number`-> expression has type Number\r\n```\r\nThese create wrapper objects that have reference identity. They are different types than their literal counterparts.\r\nFor example:\r\n```ts\r\n1 === 1\r\nnew Number(1) !== 1\r\nnew Number(1) !== new Number(1)\r\n```\r\nIn typescript, the name of the type of a value created by \"newing\" a function or class is the name of that function or class.\r\n\r\nThe uppercase `Number` type exists to represent the objects created by invoking `Number` as a constructor. These objects have different, and in general highly undesirable behavior such as the equality relation shown above.\r\n\r\nIn practice, the uppercase types should _never_ be used because they represent the values produced by by invoking objects like `Number` as constructors and this should not be done.\r\n\r\nNotice how invoking `Number` without `new` results in a `number`, but invoking it with `new` results in a `Number`.\r\n\r\nA `Number` is never what you want.\r\n\r\nWhile some might wish to postrationalize this behavior of the JavaScript builtin `Number` by claiming that enabling subclassing was the goal (something still not viable), I personally think that the behavior may be bad legacy that JavaScript inherited from Java.\r\n\r\nThe same holds for `String`, `Boolean`.\r\n\r\nWhile JavaScript has a built in `Symbol` function object as well, it does not suffer from these problems because it cannot be invoked with `new`. It refers to the `prototype` of all symbol values. These values are of type `symbol`.\r\n\r\n`Object` is different in that it refers to the type created by an object literal expression, calling the JavaScript builtin `Object`, and invoking that builtin with `new`. In this case `new` does not change the effect, and produces the same result as normal invocation.\r\n\r\nTypeScript introduced the `object` type, to represent the super type or shape, of objects that are _not_ primitives (`string`s, `number`s, `boolean`s, etc) but are not known to have any properties beyond those inherited via `Object.prototype`."
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2017-08-19T16:04:40Z",
        "body": "Thanks for the awesome explanation @aluanhaddad.\r\n\r\nTo add to this, these are also called \"wrapper objects\", and are used to provide the methods and properties on each primitive.\r\n\r\nSo for instance, to evaluate `\"Hello!\".toLowerCase()`, ECMAScript will first try to convert `\"Hello!\"` to an object (`String`) before fetching a property named `toLowerCase`.\r\n\r\nThat's why in TypeScript, we use these types to know what methods `string`, `number`, and `boolean` have."
      },
      {
        "user": "mhegazy",
        "created_at": "2017-09-05T17:05:36Z",
        "body": "Automatically closing this issue for housekeeping purposes. The issue labels indicate that it is unactionable at the moment or has already been addressed."
      }
    ]
  },
  {
    "number": 17854,
    "title": "deconstruction of the object ",
    "created_at": "2017-08-17T02:44:22Z",
    "closed_at": "2017-08-17T03:16:22Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/17854",
    "body": "let obj = {\r\n    p: [\r\n      'Hello',\r\n      { y: 'World' }\r\n    ]\r\n  };\r\n  \r\n  let { p, p: [x, { y }] } = obj;\r\n \r\n\r\nwhy \r\nerror TS2459: Type 'string | {\r\ny: string; }' has no property 'y' and no strin\r\ng index signature.???????????",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/17854/comments",
    "author": "JLBear",
    "comments": [
      {
        "user": "aluanhaddad",
        "created_at": "2017-08-17T02:57:23Z",
        "body": "Can you please format your code examples using GitHub flavored markdown?\r\n```markdown\r\n```ts\r\nTypeScript code here\r\n```\r\n```"
      },
      {
        "user": "ikatyang",
        "created_at": "2017-08-17T03:01:31Z",
        "body": "The type for property will always be widened (no tuple, no literal type) unless place it in the place contextual type inference is available, e.g.\r\n\r\n(original)\r\n\r\n```ts\r\nlet obj = {\r\n  p: ['Hello', { y: 'World' }],\r\n}; //=> { p: (string | { y: string })[] }\r\n\r\nlet { p, p: [x, { y }] } = obj;\r\n//                ^ [ts] Type 'string | { y: string; }' has no property 'y' and no string index signature.\r\n```\r\n\r\n(solution 1)\r\n\r\n```ts\r\nlet { p, p: [x, { y }] } = {\r\n  p: ['Hello', { y: 'World' }],\r\n}; // works fine\r\n```\r\n\r\n(solution 2)\r\n\r\n```ts\r\nfunction deconstruction({ p, p: [x, { y }] }) {\r\n  // do something\r\n}\r\n\r\ndeconstruction({\r\n  p: ['Hello', { y: 'World' }],\r\n}); // works fine\r\n```"
      },
      {
        "user": "JLBear",
        "created_at": "2017-08-17T03:16:34Z",
        "body": "thanks"
      }
    ]
  },
  {
    "number": 17826,
    "title": "Why Record is not obvious behavior? Bug?",
    "created_at": "2017-08-16T09:55:17Z",
    "closed_at": "2017-08-27T10:46:04Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/17826",
    "body": "```\r\nfunction record<K extends string, T>(object: Record<K, T>): Record<K, T> {\r\n    return;\r\n}\r\n\r\ninterface IPerson {\r\n    name: string;\r\n    age: 0;\r\n}\r\n\r\nlet person1: Record<'name', IPerson>; // person1: {name: IPerson}\r\nlet pesros2 = record({name: '', age: 1}); // pesros2: {name: strign|number, age: string|number}\r\n```\r\n\r\nWhy in the first case, the output types of the fields specifies the type IPerson, and the second string | number? How the compiler understands that the type T belongs to all the available types? Obviously the same is not specified anywhere... Why not -  `{name: IPerson, age: IPerson}`, \r\n``` \r\nlet person3: Record<'name' | 'age', IPerson>; // person1: {name: IPerson, age: IPerson}\r\n``` \r\n\r\n```\r\n // why T strign|number?? why not {name: IPerson, age: IPerson}?\r\nfunction record<K extends string, T>(object: Record<K, T>): Record<K, T> {\r\n  \r\n return;\r\n}\r\n``` \r\n\r\n\r\n\r\nThis is a bug? This is the only source of non-Boolean type inference throughout the TypeScript.",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/17826/comments",
    "author": "acopalipsis",
    "comments": [
      {
        "user": "jcalz",
        "created_at": "2017-08-16T15:35:47Z",
        "body": "I think you might be confused about what `Record<K,T>` is.  It is not an object of type `T`, but an object whose property keys are of type `K` and whose *property values* are of type `T`.  \r\n\r\nThe object `{name: '', age: 1}` is just an `IPerson`.   It is not a `Record<'name'|'age',IPerson>`.  An actual `Record<'name'|'age',IPerson>` would be an object whose keys `name` and `age`, and whose values are `IPerson`, like: `{name: {name: 'a', age:0}, age: {name: 'b', age:1}}`.\r\n\r\nThe object `{name: '', age: 1`} *is*, however, a `Record<'name'|'age', string|number>`, since its keys are of type `'name'|'age'` and its values are of type `string|number`.  \r\n\r\nDoes this clear things up for you?\r\n"
      },
      {
        "user": "acopalipsis",
        "created_at": "2017-08-16T15:58:25Z",
        "body": "> Does this clear things up for you?\r\n\r\n@jcalz No, because you described what is obvious. But this behavior is not clean, with obvious to the output of types. Why type inference, for the function parameter, prints Record <'name' | 'Age', string | Number>?\r\n\r\n```\r\n// K === 'name' | 'age', T !== T[K], T === T === IPerson\r\nfunction record<K extends string, T>(object: Record<K, T>): Record<K, T> {\r\n   return;\r\n}\r\n\r\n// K === 'name' | 'age', T !== T[K], T === T === IPerson\r\nlet person: Record<'name'|'age', IPerosn>\r\n\r\n// Rules for type inference, in both cases, are the same, and the results are different.\r\n// And I'll note again, this behavior is only with the Record. Why?\r\n```"
      },
      {
        "user": "jcalz",
        "created_at": "2017-08-16T16:36:39Z",
        "body": "When you call `record({name: '', age: 1})`, the compiler is trying to match `{name:'', age: 1}` to `Record<K, T>` for some `K` and `T`.  You have written `T === IPerson` above your declaration of `record()`, but that is not possible.  You have passed in an `IPerson`, which is *not* a `Record<K,IPerson>` for any `K`.  It *is* a `Record<'name'|'age', string|number>`, which is what the compiler infers.  \r\n\r\nYou seem to think that a `Record<K,T>` is itself a `T`, but it is not.   I don't know if I can explain it further without repeating myself.  Rest assured that this is not a bug, but a misunderstanding on your part.  Good luck!"
      },
      {
        "user": "acopalipsis",
        "created_at": "2017-08-16T17:24:13Z",
        "body": "> Rest assured that this is not a bug, but a misunderstanding on your part. Good luck!\r\n\r\n@jcalz I read a thousand articles and help on the .ts, but none of the authors did not say a word about the REPORT ONLY. \r\n\r\nProbably, if you understand, then you can not explain...\r\n"
      }
    ]
  },
  {
    "number": 17821,
    "title": "about typecript's type assertion",
    "created_at": "2017-08-16T03:25:28Z",
    "closed_at": "2017-08-16T04:19:57Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/17821",
    "body": "var someValue :any = false;\r\nvar strLength   :  number =(<string>someValue).length;\r\nconsole.log(strLength);//undefined\r\n\r\nvar someValue :any = 12324;\r\nvar strLength   :  number =(<string>someValue).length;\r\nconsole.log(strLength);//undefined\r\n\r\n\r\nvar a:number = 12345;\r\nvar b:string = <string>a;\r\n//error\r\n\r\nvar a:number = 12345;\r\nvar b:string = <string><any>a;\r\nconsole.log(b.length) //undefined\r\n\r\n\r\nwhy？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/17821/comments",
    "author": "JLBear",
    "comments": [
      {
        "user": "aluanhaddad",
        "created_at": "2017-08-16T03:40:32Z",
        "body": "Type annotations and type assertions do not change the emitted JavaScript. They are solely for conveying information to the compiler. That means that `b` is a `number`on the second to last line of the example above.\r\n\r\nInstead of annotating `b` with the _type_ `string`, use the JavaScript runtime global function `String` to convert `a` to a `string` like so\r\n```ts\r\nvar a = 12345;\r\nvar b = String(a);\r\nconsole.log(b.length); // 5\r\n```\r\nNote that in the code above, the compiler knows that `a` is of type `number` and that `b` is of type `string` by inferring the types from the initializers `=`. Specifically, it knows the types because `12345` is a value of type `number` and that the `String` function always returns a `string`. Therefore, it is rarely necessary to specify the types of local variables."
      }
    ]
  },
  {
    "number": 17817,
    "title": "\"return;\" should return void",
    "created_at": "2017-08-15T20:15:05Z",
    "closed_at": "2017-08-15T21:50:27Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/17817",
    "body": "Consider this code.  There is no useful way to make it compile without coercions.\r\n\r\n```ts\r\n// a function that returns Promise<void>\r\nasync function doSomething() {\r\n  // do some async work, without producing a value\r\n}\r\n\r\nfunction foo(): Promise<void> {\r\n  if (1 == 1) return doSomething();\r\n  // 1) If you leave out a 'return' statement, you fail due to missing return.\r\n  // 2) If you add a 'return;' statement, you fail due to\r\n  // Type 'undefined' is not assignable to type 'Promise<void>'\r\n  ???;\r\n}\r\n```",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/17817/comments",
    "author": "evmar",
    "comments": [
      {
        "user": "ghost",
        "created_at": "2017-08-15T20:23:39Z",
        "body": "The error is that you are returning `void` but not `Promise<void>`.\r\nYou could change the return type to `function foo(): Promise<void> | void`.\r\nOr, leave the return type as it is and `return Promise.resolve()`."
      },
      {
        "user": "evmar",
        "created_at": "2017-08-15T21:50:26Z",
        "body": "Aaargh I am sorry for the wasted time, I failed to reduce my larger test case to the underlying issue."
      }
    ]
  },
  {
    "number": 17802,
    "title": "\"TS6143 --allowJs is not set\" error but only on one setup",
    "created_at": "2017-08-15T11:06:33Z",
    "closed_at": "2017-08-22T08:47:59Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/17802",
    "body": "**TypeScript Version:**  2.2\r\n\r\nWe have several machines with the same Angular 2 + ASP.NET Core 1.6 project on them. All of the setups are similar as far as we can say and one of those VS.NET setups is having this error on build and we couldn't figure out what's different/missing:\r\n\r\n```\r\nError\tTS6143\tBuild:Module './src/common' was resolved to 'D:/MyProject/node_modules/@angular/common/src/common.js', but '--allowJs' is not set.\r\nD:\\MyProject\\node_modules\\@angular\\common\\index.d.ts\t13\t\r\n```\r\n\r\nThe same project builds and runs fine on other setups. Here's what they all have common:\r\n\r\n- VS.NET 2017 15.2\r\n- TypeScript 2.2\r\n- .NET SDK 1.0.4\r\n\r\n`tsconfig.json` is in the root folder of the project.\r\n\r\n**tsconfig.json:**\r\n\r\n```\r\n{\r\n  \"compilerOptions\": {\r\n    \"target\": \"es5\",\r\n    \"module\": \"commonjs\",\r\n    \"moduleResolution\": \"node\",\r\n    \"sourceMap\": true,\r\n    \"emitDecoratorMetadata\": true,\r\n    \"experimentalDecorators\": true,\r\n    \"lib\": [ \"es2015\", \"dom\" ],\r\n    \"suppressImplicitAnyIndexErrors\": true\r\n  },\r\n  \"exclude\": [\r\n    \"node_modules\",\r\n    \"wwwroot/Application/Models/Custom/**/*\",\r\n    \"wwwroot/Application/Models/Generator/**/*\",\r\n    \"wwwroot/Application/**/*.js\",\r\n    \"wwwroot/Application/**/*.js.map\"\r\n  ]\r\n}\r\n```\r\n\r\nWhat could be wrong with this problematic machine?",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/17802/comments",
    "author": "deastr",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2017-08-16T18:42:36Z",
        "body": "Seems like you must have different node_modules folder contents. Try setting up a package-lock.json and making sure you have identical NPM modules installed"
      },
      {
        "user": "deastr",
        "created_at": "2017-08-22T08:47:59Z",
        "body": "Yes the problem was incomplete node_modules folder. We cleared cache, node_modules and restore clean and it works now."
      }
    ]
  },
  {
    "number": 17795,
    "title": "Type loss when using generic decorators",
    "created_at": "2017-08-15T04:50:06Z",
    "closed_at": "2017-09-06T19:01:22Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/17795",
    "body": "**TypeScript Version:**  2.4.1\r\n\r\nThe following code aims to restrict the decorator `decorate` to members of a class inheriting from `Base`. However, it seems that `K` ends up only including members in `Base`, not in the inherited class. (This is a minimal reproducible example for other cases, e.g., restricting the decorator to methods within subclasses of `Base` of a certain return type.)\r\n\r\n**Code**\r\n\r\n```ts\r\nabstract class Base {\r\n  base() { return 1; };\r\n}\r\n\r\ntype ProtoOf<T> = Pick<T, keyof T>;\r\n\r\nfunction decorate<T extends Base, K extends keyof ProtoOf<T>, F extends T[K]>() {\r\n  return (proto: ProtoOf<T>, propertyKey: K, descriptor: TypedPropertyDescriptor<F>) => {\r\n    // Do stuff.\r\n  };\r\n}\r\n\r\nclass Test extends Base {\r\n  @decorate()\r\n  bar(): boolean {\r\n    return false;\r\n  }\r\n}\r\n```\r\n\r\n**Expected behavior:**\r\nNo errors when applying `@decorate()` to `bar()`.\r\n\r\n**Actual behavior:**\r\nError: `[ts] Argument of type '\"bar\"' is not assignable to parameter of type '\"base\"'.`",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/17795/comments",
    "author": "oleg-codaio",
    "comments": [
      {
        "user": "aluanhaddad",
        "created_at": "2017-08-16T03:15:11Z",
        "body": "You can work around it by returning a generic decorator from your decorator factory.\r\n```ts\r\nfunction decorate() {\r\n  return <T extends Base, K extends keyof T, F extends T[K]>\r\n    (proto: ProtoOf<T>, propertyKey: K, descriptor: TypedPropertyDescriptor<F>) => {\r\n    // Do stuff.\r\n  };\r\n}\r\n\r\nclass Test extends Base {\r\n  @decorate() bar(): boolean {\r\n    return false;\r\n  }\r\n}\r\n```\r\nI think this behavior is correct since it is equivalent to writing\r\n```ts\r\n\r\nfunction decorate<T extends Base, K extends keyof ProtoOf<T>, F extends T[K]>() {\r\n  return (proto: ProtoOf<T>, propertyKey: K, descriptor: TypedPropertyDescriptor<F>) => {\r\n    // Do stuff.\r\n  };\r\n}\r\n\r\nconst decorator = decorate();\r\n\r\nclass Test extends Base {\r\n  @decorator bar(): boolean {\r\n    return false;\r\n  }\r\n}\r\n```"
      },
      {
        "user": "oleg-codaio",
        "created_at": "2017-08-16T18:37:48Z",
        "body": "@aluanhaddad thanks for the update! Your solution does address the issue in my earlier example, though I guess the actual problem I was having had to do with decorator arguments:\r\n\r\n```\r\nfunction decorate<T extends Base>(property: keyof T) {\r\n  return <U extends T, K extends keyof U, F extends U[K]>\r\n    (proto: ProtoOf<U>, propertyKey: K, descriptor: TypedPropertyDescriptor<F>) => {\r\n    // Do stuff.\r\n  };\r\n}\r\n\r\nclass Test extends Base {\r\n  @decorate('foo') bar(): boolean {\r\n    return false;\r\n  }\r\n\r\n  foo(): boolean { return false; }\r\n}\r\n```\r\n\r\nSo the decorator works on `bar()` fine now, but is failing with this error: `[ts] Argument of type '\"foo\"' is not assignable to parameter of type '\"base\"'.` Basically, is there a good way of having the decorator parameters be generic w.r.t. the decorated class?"
      },
      {
        "user": "oleg-codaio",
        "created_at": "2017-08-16T19:11:41Z",
        "body": "On another note, if `bar()` is marked private, then the original error returns - it seems that in this case, the decorator is only able to access public properties? My gut feeling is this is a limitation we'd have to deal with."
      },
      {
        "user": "mhegazy",
        "created_at": "2017-08-22T22:24:53Z",
        "body": "Just nothing that this `function decorate<T extends Base>(property: keyof T)`  does not have any place to infer `T`, you can not infer a type from a name of one of its properties. and remember decorate is a factory that returns a function that will be used to decorate. so it is equivalent to `decorate(property: keyof Base)`, which means you can only decorate properties that have the same name as ones in `Base`.\r\n\r\nSo @aluanhaddad's suggestion seems like the correct solution here.\r\n"
      },
      {
        "user": "oleg-codaio",
        "created_at": "2017-08-22T22:40:04Z",
        "body": "Your explanation makes sense. Though the issue still stands that it doesn't seem currently possible to have decorate properties work off the decorated class. It would be great if there was a way to give \"context\" to decorator properties as to what exact object they're decorating."
      },
      {
        "user": "aluanhaddad",
        "created_at": "2017-08-23T15:15:04Z",
        "body": "@vaskevich I'm not sure if I understand what you are trying to achieve correctly, but you can capture a string literal type parameter when the decorator factory is applied and then subsequently validate that this property exists on the class with the decorated method.\r\n\r\nSo, going back to your example, you can validate that a `foo` member exists on the decorated class and we can even place constraints on its type. For example, in the following, `Test` must have a callable member `foo` that has the same return type as the decorated member.\r\n\r\n(Warning these types are pretty hard to read and I experienced several language service crashes in VS code due to recursion while working them out.)\r\n\r\n```ts\r\ntype ProtoOf<T> = Pick<T, keyof T>;\r\n\r\nfunction decorate<CK extends string>(property: CK) {\r\n\r\n  return <\r\n    T extends Base & {[P in CK]: G},\r\n    K extends keyof T,\r\n    F extends T[K] & G,\r\n    G extends  ((...args: {}[]) => R),\r\n    R>(\r\n      proto: ProtoOf<T> & {[P in CK]: (...args: {}[]) => R},\r\n      propertyKey: K,\r\n      descriptor: TypedPropertyDescriptor<F>) => {\r\n    // Do stuff.\r\n  };\r\n}\r\n\r\nclass Test extends Base {\r\n  @decorate('foo') bar(): boolean {\r\n    return false;\r\n  }\r\n\r\n  foo(): boolean {return false;}\r\n}\r\n````\r\nThe way this works is by capturing a type for the argument to the factory and using that argument to define the expected shape of the object that will be decorated. The declaration of `G` and the intersection type used to describe the target of the decorator was an experiment that seemed to work. The intent was that if we change `foo` to return a type not assignable to the return type of `bar`, we will get an error at the decorator application site.\r\n\r\nNote that the the declaration of T is provided, as in my previous example, by the decorator and not the decorator factory."
      },
      {
        "user": "mhegazy",
        "created_at": "2017-09-06T19:01:21Z",
        "body": "Automatically closing this issue for housekeeping purposes. The issue labels indicate that it is unactionable at the moment or has already been addressed."
      },
      {
        "user": "oleg-codaio",
        "created_at": "2017-09-06T19:12:48Z",
        "body": "Thanks for the replies - I haven't been able to take a look at this again yet, but will open a new issue if there's a specific defect here (which doesn't seem to be the case)."
      }
    ]
  },
  {
    "number": 17775,
    "title": "Enum Error after Using tsc --target a.ts. ",
    "created_at": "2017-08-14T12:46:07Z",
    "closed_at": "2017-08-15T01:15:18Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/17775",
    "body": "enum DoorState\r\n{\r\nOpen, Closed, Ajar\r\n}\r\nsave as 2_a.ts\r\nCompile using tsc --target es6 2_a.ts\r\nRun using node 2_a.js\r\nResult::\r\nUnexpected reserved word.\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/17775/comments",
    "author": "ybchoo",
    "comments": [
      {
        "user": "ikatyang",
        "created_at": "2017-08-14T13:34:12Z",
        "body": "I guess you might execute the wrong file, e.g. `node 2_a.ts`, otherwise can you share your TS/Node version and generated `2_a.js`?"
      },
      {
        "user": "ybchoo",
        "created_at": "2017-08-15T01:15:18Z",
        "body": "Yes u r right ikat. I make a mistake. Please kindly delete this post. Thanks."
      }
    ]
  },
  {
    "number": 17773,
    "title": "Mapped Type bug?",
    "created_at": "2017-08-14T10:27:40Z",
    "closed_at": "2017-08-14T11:24:21Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/17773",
    "body": "```\r\nclass Model<T, U extends keyof T = keyof T> {\r\n    constructor( private entity: T ) {}\r\n\r\n    public value( key: U ): T[ U ] {\r\n        return this.entity[ key ];\r\n    }\r\n}\r\n\r\ninterface IUserModel {\r\n    id: string;\r\n    age: number;\r\n}\r\n\r\nlet userModel: Model<IUserModel> = new Model({id: 'user', age: 0});\r\n\r\nlet age = userModel.value( 'age' ); // age: string | number ???\r\n```\r\n\r\nWhy is age not a number? Bug?",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/17773/comments",
    "author": "acopalipsis",
    "comments": [
      {
        "user": "gcnew",
        "created_at": "2017-08-14T11:17:30Z",
        "body": "Well, you have `U extends keyof T = keyof T`, so for `T = IUserModel` `U = 'id' | 'age'` hence `T[U] = string | number`.\r\n\r\nA possible fix is:\r\n```ts\r\nlet userModel: Model<IUserModel, 'age'> = new Model({id: 'user', age: 0});\r\nlet age = userModel.value( 'age' ); // age: number\r\n```\r\n\r\nHowever, I think you are looking for:\r\n```ts\r\nclass Model<T> {\r\n    constructor( private entity: T ) {}\r\n\r\n    public value<U extends keyof T>( key: U ): T[ U ] {\r\n        return this.entity[ key ];\r\n    }\r\n}\r\n\r\ninterface IUserModel {\r\n    id: string;\r\n    age: number;\r\n}\r\n\r\nlet userModel: Model<IUserModel> = new Model({id: 'user', age: 0});\r\nlet age = userModel.value( 'age' ); // number\r\nlet id = userModel.value( 'id' ); // string\r\n```\r\n"
      }
    ]
  },
  {
    "number": 17647,
    "title": "about Union Types demo",
    "created_at": "2017-08-07T05:57:44Z",
    "closed_at": "2017-09-05T17:05:52Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/17647",
    "body": "interface Bird {\r\n    fly();\r\n    layEggs();\r\n}\r\n\r\ninterface Fish {\r\n    swim();\r\n    layEggs();\r\n}\r\n\r\nfunction getSmallPet(): Fish | Bird {\r\n    // ...\r\n\r\n}\r\n\r\nlet pet = getSmallPet();\r\npet.layEggs(); // okay\r\n\r\ntest.ts(11,25): error TS2355: A function whose declared type is neither 'void' nor 'any' must return a value.\r\n\r\n{\r\n    \"compilerOptions\": {\r\n        \"target\": \"es5\",\r\n        \"experimentalDecorators\": true,\r\n         \"lib\": [\r\n      \"dom\",\r\n      \"es5\",\r\n       \"es6\"\r\n    ]\r\n    }\r\n}\r\n\r\ntsc -v\r\n2.4.2\r\n\r\n\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/17647/comments",
    "author": "JLBear",
    "comments": [
      {
        "user": "HerringtonDarkholme",
        "created_at": "2017-08-07T07:24:51Z",
        "body": "Hi\r\n\r\nThe error reports `getSmallPet` does not return a value. This is just a demo to illustrate union type,\r\nso implementation part is missing here.\r\n\r\n You can change it to `declare function getSmallPet(): Fish | Bird;` to skip implementation, or adding a dummy implementation is also fine."
      },
      {
        "user": "mhegazy",
        "created_at": "2017-09-05T17:05:51Z",
        "body": "Automatically closing this issue for housekeeping purposes. The issue labels indicate that it is unactionable at the moment or has already been addressed."
      }
    ]
  },
  {
    "number": 17645,
    "title": "async  can use it at Typescript?",
    "created_at": "2017-08-07T02:24:13Z",
    "closed_at": "2017-08-07T03:05:53Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/17645",
    "body": "async function getStockPriceByName(name) {\r\n  return name;\r\n}\r\n\r\n\r\nerror TS2468: Cannot find global value 'Promise'.\r\ntest.ts(1,16): error TS2705: An async function or method in ES5/\r\nES3 requires the 'Promise' constructor.  Make sure you have a de\r\nclaration for the 'Promise' constructor or include 'ES2015' in y\r\nour `--lib` option.\r\n\r\n\r\n{\r\n    \"compilerOptions\": {\r\n        \"target\": \"es5\",\r\n        \"experimentalDecorators\": true,\r\n         \"lib\": [\r\n      \"dom\",\r\n      \"es5\",\r\n       \"es6\"\r\n    ]\r\n    }\r\n}",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/17645/comments",
    "author": "JLBear",
    "comments": [
      {
        "user": "ikatyang",
        "created_at": "2017-08-07T02:46:40Z",
        "body": "You have to specify your `tsconfig.json` for `tsc` so that TS can pick up your configs.\r\n\r\n```sh\r\ntsc -p path/to/your/tsconfig.json\r\n```\r\n\r\n`tsc test.ts` is considered using default settings."
      },
      {
        "user": "JLBear",
        "created_at": "2017-08-07T02:56:02Z",
        "body": "solved \r\n\r\ntsc \r\ncan't tsc test.ts"
      }
    ]
  },
  {
    "number": 17603,
    "title": "Type inference works outside of a function, but not inside of it",
    "created_at": "2017-08-03T23:29:38Z",
    "closed_at": "2017-12-05T18:27:45Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/17603",
    "body": "**TypeScript Version:**  2.4.2\r\n\r\n**Code**\r\n```ts\r\nconst data = {\r\n    hello: { param: 10 },\r\n    bye: {param: \"x\"}\r\n}\r\n\r\n//Extract param types:\r\nfunction paramTypes<TP>(rpc: {[K in keyof TP]: { param: TP[K] }}): TP  {\r\n    return null as any;\r\n}\r\n\r\n//Correctly infered, type of \"types\" is {hello: number, bye: string}\r\nlet types = paramTypes(data);\r\n\r\nfunction inferTypes<T>(data: T) {\r\n    return paramTypes(data);\r\n}\r\n\r\n//Type of \"types2\" is {}\r\nlet types2 = inferTypes(data);\r\n\r\n//error\r\ntypes = types2;\r\n```\r\n\r\n**Expected behavior:**\r\nVariable `types2` should have the same type as `types`\r\n\r\n**Actual behavior:**\r\nVariable `types2` is typed as `{}` even when the generic argument of `interTypes` is correctly inferred\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/17603/comments",
    "author": "RafaelSalguero",
    "comments": [
      {
        "user": "HerringtonDarkholme",
        "created_at": "2017-08-04T03:03:32Z",
        "body": "TypeScript determines function return type at declaration site. That means, `inferTypes` is typed by abstract type variable `T`, not by `typeof data`. An unbound type variable `T` is reduced to `{}`, naturally.\r\n\r\nYou can just call `paramTypes`, or annotate `inferTypes` in the same way as `paramTypes`."
      },
      {
        "user": "typescript-bot",
        "created_at": "2017-12-05T18:27:45Z",
        "body": "Automatically closing this issue for housekeeping purposes. The issue labels indicate that it is unactionable at the moment or has already been addressed."
      }
    ]
  },
  {
    "number": 17515,
    "title": "tsc is transpiling multiple files, when I just want 1 file transpiled",
    "created_at": "2017-07-30T03:32:41Z",
    "closed_at": "2017-08-17T17:13:32Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/17515",
    "body": "Not sure if this is a bug or not.\r\n\r\nI have a file like so:\r\n\r\n```typescript\r\n//foo.ts\r\nimport {Client} from \"../../client\";\r\nconsole.log('foo');\r\n```\r\n\r\nI transpile this .ts file like so:\r\n\r\n `tsc ${foo} --outDir \"${OUT_DIR}\"`\r\n\r\nwhat happens, however, is that tsc will transpile multiple files including `../../client`, and write them out to the filesystem.\r\n\r\nI would expect only `${foo}` to get transpiled.\r\n\r\n`${foo}` represents just one file, I double checked.\r\n\r\nAny idea if this is a bug or expected behavior? It's causing problems for me, as is.\r\n\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/17515/comments",
    "author": "ORESoftware",
    "comments": [
      {
        "user": "aluanhaddad",
        "created_at": "2017-07-30T03:56:42Z",
        "body": "@ORESoftware \r\n```bash\r\n> tsc ${foo} --noResolve --outDir \"${OUT_DIR}\"\r\n```\r\nAlso, why not ask on Stack Overflow?"
      },
      {
        "user": "ORESoftware",
        "created_at": "2017-07-30T04:30:45Z",
        "body": "thanks, because I thought it might be a bug, next time will ask SO first"
      },
      {
        "user": "mhegazy",
        "created_at": "2017-08-17T17:13:32Z",
        "body": "Automatically closing this issue for housekeeping purposes. The issue labels indicate that it is unactionable at the moment or has already been addressed."
      }
    ]
  },
  {
    "number": 17419,
    "title": "Longer Type descriptions?",
    "created_at": "2017-07-25T22:59:11Z",
    "closed_at": "2017-08-17T17:13:36Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/17419",
    "body": "How do I get longer typescript type descriptions in the error messages?\r\n\r\nRight now I get error messages like:\r\n```\r\nTS2345: Argument of type '(action: TAction<TPayloadPanelIdTitle>, undoHandler: \"utx-handler-standard\" | \"utx-handler-crop\" ...' is not assignable to parameter of type 'CallEffectNamedFn<{ [x: string]: Func1<any>; }, string>'.\r\n  Type '(action: TAction<TPayloadPanelIdTitle>, undoHandler: \"utx-handler-standard\" | \"utx-handler-crop\" ...' is not assignable to type '[{ [x: string]: Func1<any>; }, string]'.\r\n    Property '0' is missing in type '(action: TAction<TPayloadPanelIdTitle>, undoHandler: \"utx-handler-standard\" | \"utx-handler-crop\" ...'.\r\n```\r\nand the ellipses gulp away a lot of information. Frustrating!\r\n\r\n**TypeScript Version:**  2.4.1 \r\n\r\n**Expected behavior:**\r\nAn option in tsconfig to have longer type descriptions\r\n\r\n**Actual behavior:**\r\nShort type descriptions.",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/17419/comments",
    "author": "pconerly",
    "comments": [
      {
        "user": "DanielRosenwasser",
        "created_at": "2017-07-26T00:49:34Z",
        "body": "Unfortunately it's not obvious, but we have a flag called `--noErrorTruncation`."
      },
      {
        "user": "mhegazy",
        "created_at": "2017-08-17T17:13:36Z",
        "body": "Automatically closing this issue for housekeeping purposes. The issue labels indicate that it is unactionable at the moment or has already been addressed."
      }
    ]
  },
  {
    "number": 17343,
    "title": "Tsc uses wrong type when infer deterministic code",
    "created_at": "2017-07-21T14:03:09Z",
    "closed_at": "2017-08-17T17:13:43Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/17343",
    "body": "<!-- BUGS: Please use this template. -->\r\n**TypeScript Version:**  2.4.2\r\n\r\n**Code**\r\n\r\n```ts\r\nconst A = (true) ? { b: 1 } : { c: 3 };\r\n\r\nif (A.b === undefined) {\r\n    const c = A.c;\r\n}\r\n```\r\n(The condition should be replaceable by any other expression)\r\n\r\n**Expected behavior:**\r\n\r\nNo compiler errors.\r\n\r\n**Actual behavior:**\r\n\r\nThe following compiler errors:\r\n\r\n> src/index.ts(3,7): error TS2339: Property 'b' does not exist on type '{ b: number; } | { c: number; }'.\r\n  Property 'b' does not exist on type '{ c: number; }'.  \r\n> src/index.ts(4,17): error TS2339: Property 'c' does not exist on type '{ b: number; } | { c: number; }'.\r\n  Property 'c' does not exist on type '{ b: number; }'.",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/17343/comments",
    "author": "lochbrunner",
    "comments": [
      {
        "user": "ghost",
        "created_at": "2017-07-21T15:49:10Z",
        "body": "TypeScript won't let you access a property that might not exist.\r\nYou could try this:\r\n```ts\r\nconst A: { kind: \"b\", b: number } | { kind: \"c\", c: number } = true ? { kind: \"b\", b: 1 } : { kind: \"c\", c: 3 };\r\nif (A.kind === \"c\") {\r\n    const c = A.c;\r\n}\r\n```"
      },
      {
        "user": "jcalz",
        "created_at": "2017-07-21T16:52:36Z",
        "body": "Or, using type guards instead of discriminated unions:\r\n\r\n```ts\r\nfunction hasKey<K extends string>(x: any, k: K): x is { [_ in K]: any } {\r\n  return k in x;  // or some other key check\r\n}\r\n\r\nconst A = (Math.random()>0.5) ? { b: 1 } : { c: 3 };\r\n\r\nif (!hasKey(A,'b')) {\r\n  const c = A.c;\r\n} else {\r\n  const c = A.b;\r\n}\r\n```"
      },
      {
        "user": "lochbrunner",
        "created_at": "2017-07-21T17:13:39Z",
        "body": "Is there a reason for that behavior?\r\nOr is this not implemented yet?"
      },
      {
        "user": "ghost",
        "created_at": "2017-07-21T17:50:30Z",
        "body": "The compiler logic is simpler if we only support access to properties that definitely exist.\r\nAlso, without exact types (#12936), it would be unsound to take the existence or non-existence of a property as proof that a value is of a certain type."
      },
      {
        "user": "mhegazy",
        "created_at": "2017-08-17T17:13:43Z",
        "body": "Automatically closing this issue for housekeeping purposes. The issue labels indicate that it is unactionable at the moment or has already been addressed."
      }
    ]
  },
  {
    "number": 17333,
    "title": "Relax rule about `super` followed by member access",
    "created_at": "2017-07-20T22:33:00Z",
    "closed_at": "2017-07-22T01:07:59Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/17333",
    "body": "I have a method that takes a class type. I can pass an explicit class name to it `Foo`, or I can pass `this`, but I cannot pass `super` because of the ts error:\r\n\r\n> 'super' must be followed by an argument list of member access.\r\n\r\nIs there a specific design goal behind disabling this?\r\n\r\n**TypeScript Version:**  2.4.1\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/17333/comments",
    "author": "yebrahim",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2017-07-20T23:40:32Z",
        "body": "> Is there a specific design goal behind disabling this?\r\n\r\nIt's not in any sense \"disabled\" as much as simply not existing in the first place - it's not legal ES6 code to nakedly reference `super`, and there's not an immediately obvious ES5 transpilation."
      },
      {
        "user": "yebrahim",
        "created_at": "2017-07-22T01:07:59Z",
        "body": "I see, I'll close this then. Thanks for the quick reply!"
      }
    ]
  },
  {
    "number": 17328,
    "title": "tsc compiler command switch to override variable value",
    "created_at": "2017-07-20T18:48:28Z",
    "closed_at": "2017-08-17T17:13:44Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/17328",
    "body": "I want to pass command line switch to tsc compiler like enviornment.production = true to override value in .js file. \r\n\r\ndo we have support for this ?\r\n```\r\nexport const enviornment = {\r\n  production:false\r\n}\r\nif(this.enviornment.production){\r\nenableProdMode();\r\n}\r\nplatformBrowserDynamic().bootstrapMOdule(AppModule);\r\n\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/17328/comments",
    "author": "faisalloe",
    "comments": [
      {
        "user": "ghost",
        "created_at": "2017-07-20T19:53:43Z",
        "body": "No, TypeScript will not change the behavior of your code.\r\nIf you want your code to have different behavior depending on how you build it, you would have to add a build step to do something like generate code, or write a value somewhere that the program could read it."
      },
      {
        "user": "mhegazy",
        "created_at": "2017-08-17T17:13:44Z",
        "body": "Automatically closing this issue for housekeeping purposes. The issue labels indicate that it is unactionable at the moment or has already been addressed."
      }
    ]
  },
  {
    "number": 17292,
    "title": "importHelpers by default?",
    "created_at": "2017-07-19T12:52:56Z",
    "closed_at": "2017-08-17T17:25:48Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/17292",
    "body": "I was wondering why `importHelpers` is not activated by default when in project mode. Or at least activated in the default `tsc --init` config. I've been using typescript for a little while now and I just discovered this compilation flag.\r\nI guess most users don't use `importHelpers` and end-up having a lot of duplication in there bundles.\r\n\r\nBut maybe I'm missing something?",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/17292/comments",
    "author": "testerez",
    "comments": [
      {
        "user": "aluanhaddad",
        "created_at": "2017-07-26T13:46:59Z",
        "body": "It requires the use of a module system and also takes a dependency on an additional package, `npm:tslib`. Given the added complexity and that it is an optimization it makes sense for it to be off by default. Perhaps it should be better highlighted in the documentation as it is indeed a very useful feature.\r\n\r\nFor reference, Babel has a similar option which if also off by default."
      },
      {
        "user": "testerez",
        "created_at": "2017-07-26T14:34:34Z",
        "body": "Ok makes sense. Thanks for the answer."
      },
      {
        "user": "mhegazy",
        "created_at": "2017-08-17T17:25:48Z",
        "body": "Automatically closing this issue for housekeeping purposes. The issue labels indicate that it is unactionable at the moment or has already been addressed."
      }
    ]
  },
  {
    "number": 17289,
    "title": "undefined for class property",
    "created_at": "2017-07-19T10:47:24Z",
    "closed_at": "2017-07-21T04:45:09Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/17289",
    "body": "\r\n**TypeScript Version:**  2.4.1\r\n\r\n**Code**\r\n\r\n      public async loginUser(mobile: string, password: string): Promise<number> {\r\n        debugger\r\n        logger.info(\"Preparing to login user\");\r\n        let user: User = await this.getUser({ mobile: mobile });\r\n        if (!user) {\r\n            throw new BizError(ErrorInfo.USER_NOT_EXIST);\r\n        }\r\n        let pwdResult = user.password;\r\n        if (!pwdResult) {\r\n            throw new Error(\"fail\");\r\n        }\r\n        logger.info(\"Successfully login user\");\r\n        return user.id;\r\n    }\r\n\r\nI write class User，and want to get user data from database， actually，i get real user data from database，but ，I want to give user.password property data to pwdResult, however, this is undefined  for user.password. How it happend? \r\n\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/17289/comments",
    "author": "chaoxihailing",
    "comments": [
      {
        "user": "ikatyang",
        "created_at": "2017-07-19T12:30:53Z",
        "body": "Can you share a self-contained demo? There is no enough information to understand what's going on."
      },
      {
        "user": "chaoxihailing",
        "created_at": "2017-07-21T04:16:54Z",
        "body": "This is my error， I in db sequelize exclude password，so it can’t get password value"
      }
    ]
  },
  {
    "number": 17259,
    "title": "Type inference misses type of this?",
    "created_at": "2017-07-18T07:34:13Z",
    "closed_at": "2017-12-05T18:27:47Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/17259",
    "body": "**TypeScript Version:**  2.4.1\r\n\r\n**Code**\r\n\r\n```ts\r\ninterface Compare {\r\n    compare<T>(v: T): number;\r\n}\r\n\r\nclass Unquote implements Compare {\r\n    str: string;\r\n\r\n    constructor(str: string) {\r\n        this.str = str;\r\n    }\r\n\r\n    compare(u: Unquote): number {\r\n        return this.str === u.str? 0: this.str < u.str? -1: 1;\r\n    }\r\n}\r\n```\r\n\r\n**Expected behavior:**\r\n\r\nThis compiled under 2.2.2\r\n\r\n**Actual behavior:**\r\n\r\nGives an error message\r\n\r\n```\r\nerr.ts(5,7): error TS2420: Class 'Unquote' incorrectly implements interface 'Compare'.\r\n  Types of property 'compare' are incompatible.\r\n    Type '(u: Unquote) => number' is not assignable to type '<T>(v: T) => number'.\r\n      Types of parameters 'u' and 'v' are incompatible.\r\n        Type 'T' is not assignable to type 'Unquote'.\r\n```\r\n\r\nWhen replacing the declaration of compare(u: Unquote) with compare<Unquote>(u: Unquote): number, the error message gets even weirder:\r\n\r\n```\r\nerr.ts(13,31): error TS2339: Property 'str' does not exist on type 'Unquote'.\r\nerr.ts(13,52): error TS2339: Property 'str' does not exist on type 'Unquote'.\r\n```",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/17259/comments",
    "author": "theovosse",
    "comments": [
      {
        "user": "ikatyang",
        "created_at": "2017-07-18T07:48:44Z",
        "body": "This is caused by stricter generic checks (#16368), you should write this way:\r\n\r\n```ts\r\ninterface Compare<T> {\r\n    compare(v: T): number;\r\n}\r\n\r\nclass Unquote implements Compare<Unquote> { // passed\r\n    str: string;\r\n\r\n    constructor(str: string) {\r\n        this.str = str;\r\n    }\r\n\r\n    compare(u: Unquote): number { \r\n        return this.str === u.str? 0: this.str < u.str? -1: 1;\r\n    }\r\n}\r\n```\r\n\r\nor just enable `--noStrictGenericChecks` option."
      },
      {
        "user": "typescript-bot",
        "created_at": "2017-12-05T18:27:47Z",
        "body": "Automatically closing this issue for housekeeping purposes. The issue labels indicate that it is unactionable at the moment or has already been addressed."
      }
    ]
  },
  {
    "number": 17199,
    "title": "type object implements global interface Object?",
    "created_at": "2017-07-14T17:02:42Z",
    "closed_at": "2017-07-14T17:08:00Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/17199",
    "body": "Couldn't find the info, so I ask the question here.\r\nThe `object` type implements a global interface `Object`?\r\n```\r\nvar o: object = {};\r\no.notexistsMethod; // Error\r\no.hasOwnProperty(''); // Ok\r\no.constructor; // Ok\r\n```",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/17199/comments",
    "author": "acopalipsis",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2017-07-14T17:08:00Z",
        "body": "Again, this is for bugs, not questions."
      }
    ]
  },
  {
    "number": 17155,
    "title": "error TS18003: No inputs were found in config file 'tsconfig.json'. Specified 'include' paths were '[\"src/**/*\"]' and 'exclude' paths were '[\"node_modules\"]'.",
    "created_at": "2017-07-13T05:47:05Z",
    "closed_at": "2017-08-21T17:09:12Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/17155",
    "body": "can't parsing tsconfig.json\r\n\r\nerror TS18003: No inputs were found in config file 'tsconfig.json'. Specified 'include' paths were '[\"src/**/*\"]' and 'exclude' paths were '[\"node_modules\"]'.\r\n\r\ntsconfig.json:\r\n\r\n> {\r\n  \"compileOnSave\": true,\r\n  \"compilerOptions\": {\r\n    \"experimentalDecorators\": true,\r\n    \"sourceMap\": true,\r\n    \"strict\": true,\r\n    \"module\": \"es2015\",\r\n    \"moduleResolution\": \"node\",\r\n    \"target\": \"es5\"\r\n  },\r\n  \"include\": [\r\n    \"src/**/*\"\r\n  ],\r\n  \"exclude\": [\r\n    \"node_modules\"\r\n  ]\r\n}\r\n\r\n\r\nwebpack config:\r\n\r\n>   {\r\n        test: /\\.tsx?$/,\r\n        loader: 'ts-loader',\r\n        include: [resolve('src')],\r\n        options: {\r\n          appendTsSuffixTo: [/\\.vue$/],\r\n        }\r\n      },\r\n\r\nuse:\r\nvue2, webpack2, typescript2.4.1\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/17155/comments",
    "author": "hms181231",
    "comments": [
      {
        "user": "ghost",
        "created_at": "2017-07-13T14:57:01Z",
        "body": "Are you using `tsc` to compile your project?\r\nIs there a `src` directory next to your `tsconfig.json` that contains `.ts` files?"
      },
      {
        "user": "hms181231",
        "created_at": "2017-07-17T02:27:29Z",
        "body": "this ok now, thank. `.ts` files write wrong."
      },
      {
        "user": "ghost",
        "created_at": "2017-08-04T22:32:28Z",
        "body": "I am getting the same error I also have `.ts` files in src folder. My `package.json` is like this \r\n```\r\n\r\n{\r\n  \"compilerOptions\": {\r\n    \"rootDir\": \".\",\r\n    \"experimentalDecorators\": true,\r\n    \"module\": \"es2015\",\r\n    \"moduleResolution\": \"node\",\r\n    \"noUnusedParameters\": true,\r\n    \"strictNullChecks\": true,\r\n    \"skipLibCheck\": true,\r\n    \"outDir\": \"./dist/packages/all\",\r\n    \"target\": \"es2015\",\r\n    \"lib\": [\"es5\", \"es2015\", \"dom\"],\r\n    \"types\": [\"jasmine\"],\r\n    \"baseUrl\": \".\",\r\n    \"paths\": {\r\n      \"@angular/material\": [\"./src/lib/public_api.ts\"],\r\n      \"@angular/cdk/*\": [\"./src/cdk/*\"],\r\n      \"@angular/material-examples\": [\"./src/material-examples\"],\r\n      \"material2-build-tools\": [\"./tools/package-tools\"]\r\n    }\r\n  },\r\n  \"include\": [\r\n \"/\"\r\n  ],\r\n  \"exclude\": [\r\n    \"/\"\r\n  ]\r\n}\r\n```"
      },
      {
        "user": "mhegazy",
        "created_at": "2017-08-21T17:09:12Z",
        "body": "Automatically closing this issue for housekeeping purposes. The issue labels indicate that it is unactionable at the moment or has already been addressed."
      },
      {
        "user": "ghost",
        "created_at": "2017-08-21T17:13:18Z",
        "body": "@saishbhende24 Maybe remove the `\"exclude\"`?"
      }
    ]
  },
  {
    "number": 17116,
    "title": "Structural type compatibility",
    "created_at": "2017-07-12T09:56:24Z",
    "closed_at": "2017-07-12T10:41:02Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/17116",
    "body": "```\r\nclass Bird { name; }\r\nclass Fish { name; fins; }\r\n\r\nvar animal: Bird = new Fish(); // Ok\r\nvar animal: Fish = new Bird(); // Error\r\n```\r\n\r\n```\r\nclass Bird { name; wings; }\r\nclass Fish { name; }\r\n\r\nvar animal: Bird = new Fish(); // Error\r\nvar animal: Fish = new Bird(); // Error\r\n```\r\n\r\nThis is a bug?",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/17116/comments",
    "author": "acopalipsis",
    "comments": [
      {
        "user": "olegdunkan",
        "created_at": "2017-07-12T10:11:41Z",
        "body": "`var animal: Bird = new Fish(); // Error` is error as expected \r\n`var animal: Fish = new Bird(); // Error` is error because you redeclare `var` `animal` with other type.\r\nstackoverflow.com is the best place to ask questions. "
      }
    ]
  },
  {
    "number": 17045,
    "title": "Is it possible to define generator function that has different yield and return type?",
    "created_at": "2017-07-09T18:35:27Z",
    "closed_at": "2017-07-09T23:20:09Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/17045",
    "body": "eg. Let's imagine generator function that yields only numbers, but returns only booleans\r\n\r\n```\r\nfunction* myGenerator() {\r\n  yield 1;\r\n  yield 2;\r\n  yield 3;\r\n\r\n  return true;\r\n}\r\n```\r\n\r\nFor now it's type is just `number | boolean` so it'd allow me to yield bool and return number without errors.\r\n\r\nI wonder if is it possible to create type that distinguishes it.",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/17045/comments",
    "author": "pie6k",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2017-07-09T23:20:09Z",
        "body": "This is a bug tracker, not a support forum. Please ask questions on e.g. StackOverflow."
      }
    ]
  },
  {
    "number": 17034,
    "title": "how to disable 'this' tranform to '_this'，I want to add linq extension metthod for Array",
    "created_at": "2017-07-08T16:49:51Z",
    "closed_at": "2017-07-08T17:47:22Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/17034",
    "body": "I want to add linq extension metthod for Array, like c# static Extension method。\r\n\r\nhere is the code\r\n\r\ndeclare interface Array<T> {\r\n    where(predicate: (value?: T, index?: number, list?: T[]) => boolean): T[];\r\n}\r\nArray.prototype.where = (predicate?: (value?: T, index?: number, list?: T[]) => boolean) => {\r\n return this.filter(predicate);\r\n};\r\n\r\nbut the tsc compiled 'this 'into '_this',and code work incorrect.",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/17034/comments",
    "author": "mokeyish",
    "comments": [
      {
        "user": "ikatyang",
        "created_at": "2017-07-08T16:55:50Z",
        "body": "You should use `function () { /* ... */ }`(function) instead of `() => { /* ... */ }`(arrow-function), arrow-function is a function that does not have its own `this`."
      },
      {
        "user": "mokeyish",
        "created_at": "2017-07-08T17:08:39Z",
        "body": "@ikatyang Thank you for your answer.The problem's been solved."
      }
    ]
  },
  {
    "number": 16935,
    "title": "Compiler API transpile type cast code wrong.",
    "created_at": "2017-07-05T03:12:16Z",
    "closed_at": "2017-07-05T06:35:49Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/16935",
    "body": "**TypeScript Version:**  2.3.4 \r\n\r\n**Code**\r\n- compiler api invoke\r\n```ts\r\nimport * as ts from \"typescript\";                                                                                                                                                       \r\nfunction _go_transpileModule(script: string): string {\r\n    let result = ts.transpileModule(script, {compilerOptions: {module: ts.ModuleKind.CommonJS, target: ts.ScriptTarget.ES5}}); \r\n    return result.outputText;\r\n}  \r\n```\r\nI call _go_transpileModule method in myself embed v8 engine application, not node.js.\r\n\r\n- ts source code\r\n```ts\r\nfunction sqlDemo() {                                           \r\n                                                               \r\n    try {                                                      \r\n        let s = db.sql();                                      \r\n        let records = <Object[]>s.exec('select * from script');\r\n                                                               \r\n        records.forEach((r) => printRecord(r));                \r\n                                                               \r\n        for (let i = 0; i < records.length; i++) {             \r\n            printRecord(records[i]);                           \r\n        }                                                      \r\n                                                               \r\n        s.exec(\"update script set id = 1111 where id = 1;\");   \r\n    } catch (error) {                                          \r\n        console.log(error.name, error.message);                \r\n    }                                                          \r\n}                       \r\n\r\n```\r\n\r\n- the javascript code after transpiled\r\n```js\r\nfunction sqlDemo() {\r\n    try {\r\n        var s = db.sql();\r\n        var records = <Object />, _a =  > s.exec('select * from script');\r\n        records.forEach(function (r) { return printRecord(r); });\r\n        for (var i = 0; i < records.length; i++) {\r\n            printRecord(records[i]);\r\n        }\r\n        s.exec(\"update script set id = 1111 where id = 1;\");\r\n    }\r\n    catch (error) {\r\n        console.log(error.name, error.message);\r\n    }\r\n}\r\n```\r\n\r\n**Expected behavior:**\r\n\r\neverything is ok.\r\n\r\n**Actual behavior:**\r\n\r\nbut the follow code:\r\n```ts\r\n<Object[]>\r\n```\r\n has been translated to \r\n```js\r\n<Object />, _a =  >\r\n```\r\n\r\nHow can I solve this problem?\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/16935/comments",
    "author": "saibing",
    "comments": [
      {
        "user": "ikatyang",
        "created_at": "2017-07-05T03:44:05Z",
        "body": "It seems something might be wrong with your `jsx` config, can you give a try with\r\n\r\n```js\r\ntranspileOptions = {compilerOptions: {jsx: ts.JsxEmit.None, /* ... */}, /* ... */}\r\n``` \r\n\r\nor \r\n\r\n```js\r\ntranspileOptions = {fileName: 'something.ts', /* ... */}\r\n```"
      },
      {
        "user": "saibing",
        "created_at": "2017-07-05T06:35:34Z",
        "body": "@ikatyang \r\n\r\nThank you very much. it works well."
      }
    ]
  },
  {
    "number": 16929,
    "title": "Improve Error for Invalid Augmentation on Multiple Declarations",
    "created_at": "2017-07-04T17:32:52Z",
    "closed_at": "2017-09-05T17:06:14Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/16929",
    "body": "**TypeScript Version:**  2.4.0\r\n\r\nI spent the last four hours trying to add a TypeScript declaration for an untyped module, and died a little inside when I realized this error message betrayed me:\r\n\r\n    [ts] Invalid module name in augmentation. Module 'ephori' resolves to an untyped module at '/Users/faraz/Workspace/app/node_modules/ephori/dist/index.js', which cannot be augmented.\r\n\r\nI interpret this to mean that I can't augment an untyped module, as in there was no way to add types to an existing untyped module, but as I learned through misery and luck, the message was trying to tell me I can't have two declarations like this in the same file:\r\n\r\n```\r\ndeclare global {\r\n  const apples: string\r\n}\r\n\r\ndeclare module 'bananas' {\r\n  export function throwBanana(): void\r\n}\r\n```\r\n\r\nCan we pretty please improve this error message so I shan't have suffer in vain? 😇 ",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/16929/comments",
    "author": "fny",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2017-08-17T23:55:23Z",
        "body": "that is not true. you can have a module augmentation and global augmentation in the same module. \r\n\r\nwhat you can not have, is augmentation to a module that was not defined initially. you need to define the module first.\r\nThe compiler tries to look for types for `ephori` every where and could not find any. it first looks in `ephori`'s package.json for `types` property (a la `main`), then it looks for `@types/ephori` to be there and did not find that either. it also looks under your `\"paths\"` in your tsconfig.json if you have a redirect to `\"ephori\"` definition, and none was found.\r\n\r\nthe simplest way to do this is to create a new .d.ts file, e.g. `addtional.d.ts` and add:\r\n```ts\r\ndeclare module \"ephori\" { \r\n    ...\r\n}\r\n```"
      },
      {
        "user": "fny",
        "created_at": "2017-08-21T09:34:52Z",
        "body": "Ah, makes much more sense now. Thanks for the clarification! But I still think the error message in no way explains the issue.\r\n\r\nThe error message \"[ts] Invalid module name in augmentation. Module 'ephori' resolves to an untyped module which cannot be augmented.\" Mentions nothing about a module not being found, and caused my misunderstanding of what was really happening, which you just corrected."
      },
      {
        "user": "mhegazy",
        "created_at": "2017-08-21T22:51:47Z",
        "body": "open to suggestions for a better error message."
      },
      {
        "user": "mhegazy",
        "created_at": "2017-09-05T17:06:13Z",
        "body": "Automatically closing this issue for housekeeping purposes. The issue labels indicate that it is unactionable at the moment or has already been addressed."
      },
      {
        "user": "jwalton",
        "created_at": "2018-04-12T20:01:20Z",
        "body": "Can we reopen this?  I just spent 20 minutes banging my head against a wall because I created a file called `/src/@types/json-schema-traverse.d.ts`, and inside I put:\r\n\r\n```ts\r\nimport { JSONSchema4, JSONSchema6 } from \"json-schema\";\r\ndeclare module 'json-schema-traverse' {\r\n}\r\n```\r\n\r\nwhich caused this error, and it was only when I found this issue that I realized I should try:\r\n\r\n```ts\r\ndeclare module 'json-schema-traverse' {\r\n    import { JSONSchema4, JSONSchema6 } from \"json-schema\";\r\n}\r\n```\r\n\r\nAnd to be honest I still don't know why the first one complains that \"json-schema-traverse\" can't be augmented, but the second one works.  -_-"
      }
    ]
  },
  {
    "number": 16927,
    "title": "Failed to launch external program tsc -p ts spawn tsc ENOENT",
    "created_at": "2017-07-04T16:06:56Z",
    "closed_at": "2017-08-17T17:25:56Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/16927",
    "body": "**TypeScript Version:**  2.4.1\r\n**VSCode Version:** 1.3.1\r\n**OS Version:** Linux Mint 18.1\r\n**node:** 6.11.0\r\n**npm:** 5.0.3\r\n\r\nSteps to Reproduce:\r\n\r\nOpen VSCode insider from Nemo or from terminal\r\nTry to run build task **Ctrl+Shift+B** (using tsc -p in task.json 'args')\r\n\r\ntasks.json\r\n```javascript\r\n{\r\n    \"version\": \"0.1.0\",\r\n    \"command\": \"tsc\",\r\n    \"isShellCommand\": true,\r\n    \"args\": [\"-p\", \"ts\"],\r\n    \"showOutput\": \"silent\",\r\n    \"problemMatcher\": \"$tsc\"\r\n}\r\n```\r\n\r\nhelloworld.ts in **ts** folder\r\n```typescript\r\nclass HelloWorld {\r\n    \r\n}\r\n```\r\ntsconfig.json\r\n```javascript\r\n{\r\n    \"compilerOptions\": {\r\n        \"target\": \"es5\",\r\n        \"outFile\": \"../js/app.js\",\r\n        \"sourceMap\": true\r\n    }\r\n}\r\n```\r\n\r\nEmpty folder **js**\r\n\r\n**Expected behavior:**\r\nI believe that this setup should compile the typescrpt files in my project to js files and put them in my js folder.\r\n\r\n**Actual behavior:**\r\nWhen I hit **Ctrl+Shift+B** i get: \r\n**Failed to launch external program tsc -p ts.**\r\n**spawn tsc ENOENT**\r\nin the output window\r\n\r\nIts worth noting that if I run the **tsc** command with args in the VSCode terminal window in my projects root directory (tsc -p ts) it **DOES** seem to work fine(I get the expected behavior). \r\n\r\nThis issues is similar to #8434 \r\nI do have custom code in my .profile and .bashrc, but in my case it does not matter if I open from the terminal or from the file explorer\r\n\r\nrunning process.env.PATH in VScode dev tools console outputs the same path as running echo $PATH from my command line. ",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/16927/comments",
    "author": "kylerdanielster",
    "comments": [
      {
        "user": "leonadler",
        "created_at": "2017-07-05T13:00:43Z",
        "body": "This is normally caused by `tsc` not being in your $PATH. Double-check if your global node_modules/.bin is reachable outside of bash, e.g. via running `which tsc` in `sh`/`zsh`.\r\n\r\nWhile not a fix for your issue per se, consider running the local `tsc` in your project:\r\n```json\r\n{\r\n    \"version\": \"0.1.0\",\r\n    \"command\": \"node\",\r\n    \"isShellCommand\": true,\r\n    \"args\": [\"${workSpaceRoot}/node_modules/typescript/bin/tsc\", \"-p\", \"ts\"],\r\n    \"showOutput\": \"silent\",\r\n    \"problemMatcher\": \"$tsc\"\r\n}\r\n```\r\n\r\nThis allows you to track the version of the TypeScript compiler you want to use in your package.json independent of the globally installed one (`npm i -g typescript`)."
      },
      {
        "user": "kylerdanielster",
        "created_at": "2017-07-09T02:00:22Z",
        "body": "This worked.\r\n\r\nInstalled typescript locally with `npm i typescript` and changed tasks.json to \r\n```\r\n{\r\n    \"version\": \"0.1.0\",\r\n    \"command\": \"node\",\r\n    \"isShellCommand\": true,\r\n    \"args\": [\"{pathToWorkSpaceRoot}/node_modules/typescript/bin/tsc\", \"-p\", \"ts\"],\r\n    \"showOutput\": \"silent\",\r\n    \"problemMatcher\": \"$tsc\"\r\n}\r\n```\r\nWhich as you say \"allows you to track the version of the TypeScript compiler you want to use in your package.json independent of the globally installed one\". Seems like a good idea. \r\n\r\nI think it is worth noting that: ~/.npm-global/bin is in my path which contains the tsc package. This should be equivalent to node_modules/.bin I believe. \r\n\r\nRegardless, running 'sh' and 'tcs' I get 'tsc: not found'."
      },
      {
        "user": "leonadler",
        "created_at": "2017-07-10T09:36:25Z",
        "body": "@kylerdanielster glad it solves your issue!\r\nJust a little addendum, since you wrote \"{pathToWorkSpaceRoot}\", I assume you hard-coded the path - you can use the actual string `${workSpaceRoot}` so it works regardless of where you checkout the project."
      },
      {
        "user": "kylerdanielster",
        "created_at": "2017-07-11T00:14:53Z",
        "body": "@leonadler \"${workSpaceRoot}/node_modules/typescript/bin/tsc\" did not work for me, that is why I hard coded it. \r\n\r\nI played around with the path some more and \"node_modules/typescript/bin/tsc\" this did the trick as well.\r\n\r\nCurrent task.json (in .vscode folder)\r\n```\r\n{\r\n    \"version\": \"0.1.0\",\r\n    \"command\": \"node\",\r\n    \"isShellCommand\": true,\r\n    \"args\": [\"node_modules/typescript/bin/tsc\", \"-p\", \"ts\"],\r\n    \"showOutput\": \"silent\",\r\n    \"problemMatcher\": \"$tsc\"\r\n}\r\n```"
      },
      {
        "user": "mhegazy",
        "created_at": "2017-08-17T17:25:56Z",
        "body": "Automatically closing this issue for housekeeping purposes. The issue labels indicate that it is unactionable at the moment or has already been addressed."
      }
    ]
  },
  {
    "number": 16876,
    "title": "Support question - Webstorm, NPM symlinks, static type checking",
    "created_at": "2017-07-01T00:29:08Z",
    "closed_at": "2017-08-17T17:25:57Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/16876",
    "body": "Sorry on mobile right now. I am curious as to the state of following symlinks so that you can get static type checking across local symlinked NPM projects. Is this currently possible? If it is, are there instructions somewhere on how to accomplish this? AFAICT right now, it seems like type checking is not working when projects are symlinked with NPM link.\r\n\r\nOne related question - if I want to import types from a project X but project X is not a dependency of my project (nor do I want it to be), is there any other avenue besides making `@types/X` a devDependency of project? What I am afraid of is that @types/X will be out-of-sync with X itself.\r\n\r\nIf I can solve the out-of-sync problem, then I would fine with publishing types to `@types/X`, and sharing that type information. But that does not solve the original symlinking issue above, which remains a problem.",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/16876/comments",
    "author": "ORESoftware",
    "comments": [
      {
        "user": "DanielRosenwasser",
        "created_at": "2017-07-01T00:52:36Z",
        "body": "This really seems like something that is a better fit for StackOverflow. We don't have a set of instructions for setting this up, though investigating project-to-project references is something we're investigating, which may be related to what you're trying to accomplish."
      },
      {
        "user": "ORESoftware",
        "created_at": "2017-07-01T00:58:52Z",
        "body": "I might drop it on programmers.stackexchange.com -> probably a better place for this than SO.\r\n\r\nbut can you confirm that tsc doesn't work with NPM symlinks? It might be a Webstorm issue, less so tsc itself. "
      },
      {
        "user": "mhegazy",
        "created_at": "2017-08-17T17:25:57Z",
        "body": "Automatically closing this issue for housekeeping purposes. The issue labels indicate that it is unactionable at the moment or has already been addressed."
      }
    ]
  },
  {
    "number": 16812,
    "title": "Add an \"argument is not type\" operator",
    "created_at": "2017-06-28T21:04:10Z",
    "closed_at": "2017-08-17T17:26:01Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/16812",
    "body": "We already have:\r\n```ts\r\nfunction isNotUndefined(obj:any): obj is string | number | boolean | MyCustomType | null | MyOtherCustomType {\r\n    return typeof obj !== \"undefined\";\r\n}\r\n```\r\n\r\nNow we just need:\r\n\r\n```ts\r\nfunction isNotUndefined(obj:any): obj is not undefined { // or isnot\r\n    return typeof obj !== \"undefined\";\r\n}",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/16812/comments",
    "author": "Arlen22",
    "comments": [
      {
        "user": "kitsonk",
        "created_at": "2017-06-28T21:09:00Z",
        "body": "Dupe (or heavily related to) #4183"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2017-06-28T21:16:53Z",
        "body": "```ts\r\nfunction isNotUndefined<T>(obj: T | undefined): obj is T {\r\n    return typeof obj !== \"undefined\";\r\n}\r\nvar x = Math.random() > 0.5 ? undefined : 32;\r\nif (isNotUndefined(x)) {\r\n    console.log(x.toFixed());\r\n}\r\n```"
      },
      {
        "user": "Arlen22",
        "created_at": "2017-06-28T23:25:52Z",
        "body": "```ts\r\nconst test: (string | undefined)[] = []\r\ntest.filter(<T>(a: T): a is T | undefined => { \r\n    return !!a; \r\n}).map(t => {\r\n    // t is string | undefined\r\n})\r\n```"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2017-06-28T23:43:48Z",
        "body": "@Arlen22 why did you write the predicate wrong? This works in 2.4:\r\n```ts\r\nconst test: (string | undefined)[] = []\r\ntest.filter(<T>(a: T | undefined): a is T => { \r\n    return !!a; \r\n}).map(t => {\r\n    t;\r\n    // t is string\r\n})\r\n```"
      },
      {
        "user": "Arlen22",
        "created_at": "2017-06-29T00:09:04Z",
        "body": "~~Strange. In 2.4.1:~~\r\n```ts\r\nconst test: (string | undefined)[] = []\r\ntest.filter(<T>(a: T | undefined): a is T => { \r\n    return !!a; \r\n}).map(t => {\r\n    let r: string = t; //Error: Type 'string | undefined' is not assignable to type 'string'\r\n})\r\n```"
      },
      {
        "user": "Arlen22",
        "created_at": "2017-06-29T00:19:23Z",
        "body": "Nevermind, I forgot to update my global tsc. Now I'm seeing the new feature. Nice :)"
      },
      {
        "user": "Arlen22",
        "created_at": "2017-06-29T00:23:47Z",
        "body": "Any idea what PR brought this in?"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2017-06-29T00:24:28Z",
        "body": "#11858"
      },
      {
        "user": "mhegazy",
        "created_at": "2017-08-17T17:26:00Z",
        "body": "Automatically closing this issue for housekeeping purposes. The issue labels indicate that it is unactionable at the moment or has already been addressed."
      }
    ]
  },
  {
    "number": 16794,
    "title": "Modify behavior of generics extending string literal union? ",
    "created_at": "2017-06-28T08:50:32Z",
    "closed_at": "2017-09-11T16:00:15Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/16794",
    "body": "Consider the following code:\r\n\r\n```typescript\r\ntype Color = 'red' | 'green' | 'blue';\r\n\r\nfunction setBackgroundColor(color: Color) {\r\n    // ...\r\n}\r\n```\r\n\r\nThis snippet gives us handy type completions at the `?` in `setBackgroundColor('?')`. This is super useful; prevents errors, saves time, etc. But what if you wanted to support lots of colors.... like say every shade the hardware store sells? Well, currently you have two options:\r\n\r\n  1. Add the list of all conceivable colors to the `Color` union **BUT, that's a prohibitive pain.**\r\n\r\n  2. Get rid of `Color` and just use `string` **BUT, you loose completions.**\r\n\r\n\r\nThere are often times I wish I could offer \"hints\" to a consuming developer. Or give a few default values, but allow devs to supply their own. Unfortunately, `string | 'Red' | 'Blue'` widens to `string` and the suggestions are lost! So it'd be great if either those completions could be maintained or perhaps if something akin  to the following were possible:\r\n```typescript\r\ntype Color = 'red' | 'green' | 'blue';\r\n\r\nfunction setBackgroundColor<C extends Color>(color: C) {\r\n    // ...\r\n}\r\n\r\nsetBackgroundColor('r?');\r\n// completion:   red ^\r\nsetBackgroundColor('orange');\r\n// no completions:   ^\r\n// but no error thrown either\r\n\r\n```\r\n\r\n\r\nI just came up against shortfall for like the 3rd time, and figured I ought to open an issue, see how receptive the TS team was to something like this.\r\n\r\n\r\n### Thanks for all the great work! keep it up!\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/16794/comments",
    "author": "rozzzly",
    "comments": [
      {
        "user": "rozzzly",
        "created_at": "2017-06-28T09:48:37Z",
        "body": "Okay so I just noticed:\r\n\r\nfrom <kbd>lib.dom.d.ts</kbd>\r\n```typescript\r\naddEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, useCapture?: boolean): void;\r\naddEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;\r\n````\r\n\r\nallows both\r\n\r\n```typescript\r\ndocument.addEventListener('scroll', undefined);\r\ndocument.addEventListener('foo', undefined);\r\n```\r\n\r\n`foo` obviously isn't a DOM event, just some made up value. **But it passes!** When I copy the type definition to create my own function, \r\n\r\n\r\n```typescript\r\nfunction foo<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, useCapture?: boolean): void;\r\nfunction foo(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void { };\r\n\r\nfoo('abort', undefined); // works as expected\r\nfoo('bar', undefined); // doesn't work\r\n```\r\n\r\nI've tested this in `2.5.0-dev.20170628` and whatever the typescript playground is running\r\n\r\nSo it looks like there's some voodoo magic going on behind the scenes to silence the type checker and preserve completions for this special case.  **But that just proves my point!** This is a common concern and would nicely complement many APIs. Wouldn't it be a lot less hacky to remove that hidden logic and change the behavior of extending string literal unions?"
      },
      {
        "user": "mhegazy",
        "created_at": "2017-08-26T00:40:33Z",
        "body": "We get a lot of savings in memory and performance by flatting types, and dropping literal types if they are unioned with string. so somehting like `string | 'red' | 'blue'` just for completions would be worth it.\r\nchanging the meaning of extends is not a possiblity. it is a breaking change, and does not make fit the rest of the language.\r\n\r\nYou can however use overloads to achieve what you want. and that is what we use for addeventListener and the like, e.g.:\r\n\r\n```ts\r\nfunction setBackgroundColor(color: Color);\r\nfunction setBackgroundColor(color: string); \r\nfunction setBackgroundColor(color: string) { \r\n...\r\n}\r\n```\r\n\r\njust make sure your `string` overload is last."
      },
      {
        "user": "mhegazy",
        "created_at": "2017-09-11T16:00:15Z",
        "body": "Automatically closing this issue for housekeeping purposes. The issue labels indicate that it is unactionable at the moment or has already been addressed."
      }
    ]
  },
  {
    "number": 16731,
    "title": "Suggestion: syntax for overloading function expressions",
    "created_at": "2017-06-24T21:40:41Z",
    "closed_at": "2017-06-25T14:58:30Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/16731",
    "body": "Currently it is only possible to define function overloads for function declarations.\r\n\r\nSometimes it is desirable to use function expressions instead of function declarations. It would be nice if the function overload feature was applicable to function expressions as well.\r\n\r\nBy function expression, I mean something like this:\r\n\r\n``` ts\r\nconst identity = <X>(x: X) => x;\r\n```",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/16731/comments",
    "author": "OliverJAsh",
    "comments": [
      {
        "user": "ikatyang",
        "created_at": "2017-06-25T12:39:14Z",
        "body": "You can use call signature to do such things:\r\n\r\n```ts\r\nconst identity: {\r\n  <X extends string>(x: X): X;\r\n  <X extends number>(x: X): X;\r\n} = <X>(x: X) => x;\r\n```\r\n\r\n```ts\r\nfunction identity<X extends string>(x: X): X;\r\nfunction identity<X extends number>(x: X): X;\r\nfunction identity<X>(x: X): X {\r\n  return x;\r\n}\r\n```"
      },
      {
        "user": "OliverJAsh",
        "created_at": "2017-06-25T14:58:30Z",
        "body": "Of course, thank you! "
      },
      {
        "user": "OliverJAsh",
        "created_at": "2017-06-25T23:05:01Z",
        "body": "I notice that when I only specify the call signature on the interface with no inline function parameter/return types, I get an error:\r\n\r\n``` ts\r\n{\r\n    type identity = {\r\n        (x: string): string;\r\n        (x: number): number;\r\n    }\r\n    \r\n    // error: Parameter 'x' implicitly has an 'any' type\r\n    const identity: identity = (x) => x;\r\n}\r\n```\r\n\r\nI would expect the `x` param to be inferred as `string | number`. Is this a bug I should open a separate issue for?"
      },
      {
        "user": "ikatyang",
        "created_at": "2017-06-26T03:31:03Z",
        "body": "`x` should never be inferred as `string | number`, since it will cause `(A | B) -> (A | B)` instead of `(A -> A) | (B -> B)`, so I think it is correct to be inferred as `any`.\r\n\r\n```ts\r\nconst identity: identity = (x: string | number) => x;\r\n//    ^^^^^^^^ [ts]\r\n// Type '(x: string | number) => string | number' is not assignable to type 'identity'.\r\n//   Type 'string | number' is not assignable to type 'string'.\r\n//     Type 'number' is not assignable to type 'string'.\r\n```\r\n---\r\n\r\nI think using generic is the correct way but it seems something wrong with it.\r\n\r\n```ts\r\ntype identity = {\r\n  (x: string): string;\r\n  (x: number): number;\r\n}\r\n    \r\n// no error as expected\r\nconst identity: identity = <T>(x: T) => x;\r\n```\r\n\r\n```ts\r\ntype test = {\r\n  (x: string): string;\r\n  (x: number): number;\r\n  (x: boolean): object;\r\n}\r\n    \r\n// expected error but passed\r\nconst test: test = <T>(x: T) => x;\r\n```"
      }
    ]
  },
  {
    "number": 16669,
    "title": "Unable to use boolean valued promise as thenable construct in Typescript",
    "created_at": "2017-06-21T04:12:04Z",
    "closed_at": "2017-06-21T07:05:13Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/16669",
    "body": "For some reason, I am unable to use a boolean valued promise as a thenable construct and I can't figure out why. The error message is _**TS2345value Argument of type '(value: boolean) => Promise<{}> | undefined' is not assignable to parameter of type '((value: boolean) => {} | IThenable<{}> | undefined'**_.\r\n\r\nThe source code is below with comment showing where the compile error occurs.\r\n\r\nI have used this sort of mechanism in the pure JavaScript version of the framework I'm converting to Typescript without issues. It's only in Typescript that I have this problem.\r\n \r\n```\r\npublic static refreshUntilElementIsPresent(element: ElementFinder, numberOfSeconds: number = 30000,\r\n        refreshInterval: number = 5000): void {\r\n    this.refreshElement(element, numberOfSeconds, refreshInterval);\r\n}\r\n\r\nprotected static refreshElement(element: ElementFinder, numberOfSeconds: number = 30000, refreshInterval:\r\n        number = 5000) {\r\n\r\n\r\n    //This line throws the compile error\r\n    element.isPresent().then(value => {\r\n        if (!value) {\r\n            if (numberOfSeconds <= 0) {\r\n                return new wd.promise.Promise(function (resolve, reject) {\r\n                    reject('Element cannot be found after expected retry numbers');\r\n                })\r\n            }\r\n            browser.sleep(refreshInterval).then(() => {\r\n                browser.refresh().then(() => this.refreshUntilElementIsPresent(element, numberOfSeconds -\r\n                    (refreshInterval / 1000)));\r\n            });\r\n        }\r\n    });\r\n}\r\n```",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/16669/comments",
    "author": "adityagautam",
    "comments": [
      {
        "user": "DanielRosenwasser",
        "created_at": "2017-06-21T07:05:13Z",
        "body": "I don't know what the fix is because I don't have an isolated repro for the issue, and I don't know where you're getting the error, but I can guess.\r\n\r\nBecause TypeScript can't immediately figure out the type of the `Promise` you're constructing from its arguments, you'll need to add an explicit type argument to `new wd.promise.Promise`. Alternatively in 2.4 you'll be able to explicitly annotate the return type of `refreshElement`.\r\n\r\nAs a heads up, please use StackOverflow for \"why isn't this working?\" questions in the future."
      }
    ]
  },
  {
    "number": 16629,
    "title": "Change return type by type guard",
    "created_at": "2017-06-19T20:54:04Z",
    "closed_at": "2017-06-19T21:07:57Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/16629",
    "body": "```\r\nclass Foo {\r\n  foo = 123;\r\n}\r\nclass Bar {\r\n  bar = 123;\r\n}\r\nfunction distinguish(arg: Foo | Bar): Foo | Bar {\r\n  if(arg instanceof Foo) {\r\n    return arg\r\n  }\r\n  else {\r\n    return arg\r\n  }\r\n}\r\nlet result: Foo = distinguish(new Foo())\r\n// Type 'Foo | Bar' is not assignable to type 'Foo'\r\n```",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/16629/comments",
    "author": "pravdomil",
    "comments": [
      {
        "user": "DanielRosenwasser",
        "created_at": "2017-06-19T21:04:40Z",
        "body": "I'm not sure what you're asking or what the motivating scenario is, but would this fix it?\r\n\r\n```ts\r\nfunction distinguish<T extends Foo | Bar>(arg: T): T {\r\n  if (arg instanceof Foo) {\r\n    return arg\r\n  }\r\n  else {\r\n    return arg\r\n  }\r\n}\r\n```\r\n"
      },
      {
        "user": "pravdomil",
        "created_at": "2017-06-19T21:07:57Z",
        "body": "yea!"
      }
    ]
  },
  {
    "number": 16614,
    "title": "Mapped Types Not working correctly with arrays",
    "created_at": "2017-06-19T12:27:49Z",
    "closed_at": "2017-08-17T18:07:16Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/16614",
    "body": "<!-- BUGS: Please use this template. -->\r\n\r\n\r\n**TypeScript Version:**  2.3.4\r\n**Code**\r\n\r\n```ts\r\ninterface BaseType {\r\n    \"foo\":string;\r\n    \"bar\":number;\r\n}\r\ntype MappedType = {\r\n    [P in keyof BaseType]:BaseType[P][]\r\n}\r\nfunction addToMappedType<P extends keyof BaseType>(mapped:MappedType, key:P, value:BaseType[P]) {\r\n    let array = mapped[key];\r\n    array.push(value);\r\n}\r\n```\r\n**Expected behavior:**\r\narray.push should have type signature ```ts (...items:BaseType[P][])=>number``` \r\n**Actual behavior:**\r\narray.push has the type signature ```ts ((...items:string[])=>number) |((...items:number[])=>number)```\r\nAnd because it lacks a unique call signature it is not able to be invoked. \r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/16614/comments",
    "author": "thomasd16",
    "comments": [
      {
        "user": "jcalz",
        "created_at": "2017-06-19T15:58:48Z",
        "body": "I don't think this has much to do with arrays, but rather with the types in the mapping being evaluated eagerly or something.  This gives the same problem:\r\n\r\n```ts\r\ninterface BaseType {\r\n    \"foo\":string;\r\n    \"bar\":number;\r\n}\r\ntype WrappedType = {\r\n    [P in keyof BaseType]: { contents: BaseType[P] }; \r\n}\r\nfunction openPresent<P extends keyof BaseType>(present: WrappedType, key: P) {\r\n    var v = present[key].contents;\r\n    // next line is an error because the type of v\r\n    // is inferred as string | number instead of BaseType[P]\r\n    var v: BaseType[P]; \r\n} \r\n```\r\n\r\nI'm guessing this is a design limitation?  Anyway this workaround might help:\r\n```ts\r\nfunction addToMappedType<P extends keyof BaseType>(mapped:MappedType, key:P, value:BaseType[P]) {\r\n    let array = mapped[key] as BaseType[P][]; // explicit cast\r\n    array.push(value); // no error now\r\n}\r\n```\r\n\r\n\r\n"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2017-06-19T16:48:03Z",
        "body": "Try this\r\n\r\n```ts\r\ninterface BaseType {\r\n    \"foo\":string;\r\n    \"bar\":number;\r\n}\r\n\r\ntype Arrayify<T> = {\r\n    [P in keyof T]: T[P][]\r\n}\r\n\r\nfunction addToMappedType<T extends BaseType, P extends keyof T>(mapped: Arrayify<T>, key: P, value: T[P]) {\r\n    let array = mapped[key];\r\n    array.push(value);\r\n}\r\n```\r\n\r\nhere I've\r\n\r\n1. Rewritten `MappedType` as a homomorphic mapped type called `Arrayify`.\r\n2. Created a new type for `T` that is constrained to `BaseType`.\r\n3. Used the keys of `T` as the constraint of `P` so that you can re-index into `T` correctly.\r\n     * You can also index into `Arrayify<T>` with `P` because it's a homomorphic mapped type so the keys are well-known. That's where things start to come together."
      },
      {
        "user": "jcalz",
        "created_at": "2017-06-20T17:22:52Z",
        "body": "I don't think it's clear to a developer when the type checker discards the information about the mapping it would need for the code in OP to work.\r\n\r\nGiven\r\n- a type function `R<>`\r\n- a homomorphic mapped type `M<>`\r\n```ts\r\ntype M<T> = {\r\n    [K in keyof T] : R<T[K]>\r\n}\r\n```\r\n- a type `A`\r\n- and a generic type `K extends keyof A`,\r\n\r\nit seems like the type `M<A>[K]` should always resolve to `R<A[K]>`, *whether `A` is generic or concrete*.  But today, this only works for generic `A` and not concrete `A`.  Is this a bug, a design limitation, or working as intended?  If it's not a bug then maybe we need some documentation to explain what's going on.\r\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2017-08-17T18:07:16Z",
        "body": "Automatically closing this issue for housekeeping purposes. The issue labels indicate that it is unactionable at the moment or has already been addressed."
      }
    ]
  },
  {
    "number": 16477,
    "title": "Generators and Iteration for ES5/ES3,  error TS2318: Cannot find global type 'IterableIterator'.",
    "created_at": "2017-06-13T10:56:40Z",
    "closed_at": "2017-08-17T18:36:47Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/16477",
    "body": "   set  \r\n```json\r\n{\r\n   \"compilerOptions\": {\r\n        \"sourceMap\": false,\r\n        \"noImplicitAny\": false,\r\n        \"module\": \"amd\",\r\n        \"target\": \"es5\",\r\n        \"jsx\": \"react\",\r\n        \"traceResolution\":true,\r\n        \"declaration\": true,\r\n        \"noEmitOnError\":true,\r\n       \"downlevelIteration\": true\r\n    },\r\n    \"include\": [\r\n        \"./01core/**/*\",\"./index.tsx\"\r\n    ],\r\n    \"exclude\": [\r\n        \"node_modules\"\r\n    ]\r\n}\r\n```\r\n but it errors : \r\n\r\nerror TS2318: Cannot find global type 'IterableIterator'.\r\n\r\n\r\nbuild \r\n\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/16477/comments",
    "author": "lusess123",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2017-06-13T21:15:18Z",
        "body": "set `\"lib\": [\"es6\"]` or `\"lib: [\"es6\" , \"dom\"]` if you are using the DOM APIs."
      },
      {
        "user": "mhegazy",
        "created_at": "2017-08-17T18:36:47Z",
        "body": "Automatically closing this issue for housekeeping purposes. The issue labels indicate that it is unactionable at the moment or has already been addressed."
      }
    ]
  },
  {
    "number": 16432,
    "title": "how defined symbol class property?",
    "created_at": "2017-06-10T04:06:32Z",
    "closed_at": "2017-08-17T18:07:33Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/16432",
    "body": "\r\n**TypeScript Version:**  2.3.4 \r\n\r\n**Code**\r\n\r\n```ts\r\n\r\nconst key = Symbol.for(\"key\");\r\n\r\nclass C{\r\n     [key]:number = 1;  // error!  A computed property name in a class property declaration must directly refer to a built-in symbol.\r\n}\r\n\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/16432/comments",
    "author": "izengliang",
    "comments": [
      {
        "user": "DanielRosenwasser",
        "created_at": "2017-06-10T07:24:02Z",
        "body": "See #15473 for progress on making this potentially work."
      },
      {
        "user": "mhegazy",
        "created_at": "2017-08-17T18:07:32Z",
        "body": "Automatically closing this issue for housekeeping purposes. The issue labels indicate that it is unactionable at the moment or has already been addressed."
      }
    ]
  },
  {
    "number": 16295,
    "title": "Type guard via `if` does not make value compatible as argument",
    "created_at": "2017-06-06T12:25:32Z",
    "closed_at": "2017-09-07T17:44:27Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/16295",
    "body": "**TypeScript Version:**  2.3.3 (with --strictNullChecks)\r\n\r\nThe condition `test.a` ensures that `a` can not be `undefined`, thus `test` should be suitable to be passed as `A`. Note that `test.a` is already narrowed down to `string`.\r\n\r\nThe reason I declare the fields `a` and `b` in `Base` is so that the `if` below does not type error on `test.a`.\r\n\r\n**Code**\r\n\r\n```ts\r\ninterface Base {\r\n    a?: string;\r\n    b?: string;\r\n}\r\n\r\ninterface A extends Base {\r\n    a: string;\r\n}\r\n\r\ninterface B extends Base {\r\n    b: string;\r\n}\r\n\r\ntype Any = A | B;\r\n\r\nfunction source(): Any {\r\n    return {a: ''};\r\n}\r\n\r\nfunction sink(a: A) {\r\n\r\n}\r\n\r\nlet test: Any = source();\r\nif (test.a) {\r\n    const a: string = test.a;\r\n    sink(test);\r\n}\r\n```\r\n\r\n**Expected behavior:** It compiles.\r\n\r\n**Actual behavior:** error at `sink(test)`:\r\n\r\n```\r\nError:(27, 10) TS2345:Argument of type 'Any' is not assignable to parameter of type 'A'.\r\n  Type 'B' is not assignable to type 'A'.\r\n    Types of property 'a' are incompatible.\r\n      Type 'string | undefined' is not assignable to type 'string'.\r\n        Type 'undefined' is not assignable to type 'string'.\r\n```",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/16295/comments",
    "author": "Yogu",
    "comments": [
      {
        "user": "ikatyang",
        "created_at": "2017-06-06T14:13:09Z",
        "body": "Based on my experience, `if (test.a)` will just narrow the type of `test.a` instead of `test`, so that `if` will do nothing for `test`, you have to use some assertion to narrow the type, for example:\r\n\r\n```ts\r\ndeclare function hasA(v: any): v is {a: any};\r\n\r\nif (hasA(test)) {\r\n  sink(test);\r\n}\r\n``` "
      },
      {
        "user": "Yogu",
        "created_at": "2017-06-06T15:20:20Z",
        "body": "@ikatyang Thanks, that would be an explanation. I guess implementing the suggested feature would add a substantial amount of complexity, then."
      },
      {
        "user": "mhegazy",
        "created_at": "2017-09-07T17:44:26Z",
        "body": "Automatically closing this issue for housekeeping purposes. The issue labels indicate that it is unactionable at the moment or has already been addressed."
      }
    ]
  },
  {
    "number": 16192,
    "title": "can any one tell me how to implement extension method for Array in Typescript (Let's suppose i want to write functionality for sorting the array )",
    "created_at": "2017-06-01T11:29:42Z",
    "closed_at": "2017-06-05T22:05:12Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/16192",
    "body": "",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/16192/comments",
    "author": "Prashant3108",
    "comments": [
      {
        "user": "ikatyang",
        "created_at": "2017-06-01T11:39:56Z",
        "body": "(./extend.ts)\r\n\r\n```ts\r\ndeclare global {\r\n  interface Array<T> {\r\n    some_method(): this;\r\n  }\r\n}\r\n\r\nArray.prototype.some_method = function () {\r\n  return this.sort().reverse();\r\n};\r\n\r\nexport {};\r\n```\r\n\r\n(./test.ts)\r\n\r\n```ts\r\nimport './extend';\r\n\r\nconst a = ['abc', 'def'].some_method();\r\n```\r\n\r\nIs this what you want?\r\n\r\n"
      },
      {
        "user": "Prashant3108",
        "created_at": "2017-06-01T14:14:51Z",
        "body": "yes, thanks"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2017-06-05T22:05:12Z",
        "body": "This is an issue tracker, not a support forum. Please use an appropriate venue for questions as indicated in the template."
      }
    ]
  },
  {
    "number": 16013,
    "title": "'convertFunctionToEs6Class' is not a syntactic check",
    "created_at": "2017-05-23T04:01:02Z",
    "closed_at": "2017-06-07T16:31:08Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/16013",
    "body": "From the declaration:\r\n\r\n```ts\r\n        /** A fast syntactic check to see if the refactor is applicable at given position. */\r\n        isApplicable(context: RefactorContext): boolean;\r\n```\r\n\r\nHowever, in `convertFunctionToEs6Class`, the implementation is semantic - it uses the type-checker. So I guess my question is, is that okay? Or should the checking logic be moved into `getCodeActions`?",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/16013/comments",
    "author": "DanielRosenwasser",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2017-05-23T16:39:09Z",
        "body": "> However, in convertFunctionToEs6Class, the implementation is semantic - it uses the type-checker. So I guess my question is, is that okay? \r\n\r\nyes. the intention for the check to be quick, and not block. syntactic is the fastest category, but pulling on the checker for one symbol should be close too.\r\n\r\n>  Or should the checking logic be moved into getCodeActions?\r\n\r\nit is too late at this point. you want to know if this is something you should show to the user or not.\r\n"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2017-05-23T20:31:27Z",
        "body": "Comment needs to be updated"
      },
      {
        "user": "mhegazy",
        "created_at": "2017-06-07T16:31:08Z",
        "body": "Automatically closing this issue for housekeeping purposes. The issue labels indicate that it is unactionable at the moment or has already been addressed."
      }
    ]
  },
  {
    "number": 15994,
    "title": "Control flow type narrowing doesn't work",
    "created_at": "2017-05-22T15:24:34Z",
    "closed_at": "2017-05-22T16:00:06Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/15994",
    "body": "**TypeScript Version:**  2.3.2\r\n\r\n**Code**\r\n\r\n```ts\r\ntype JoinModels<A, K extends string, B> = A & {\r\n    [k in K]: B;\r\n};\r\n\r\ninterface User {\r\n    username: string;\r\n}\r\n\r\ninterface Post {\r\n    title: string;\r\n}\r\n\r\ntype UserWithPosts = JoinModels<User, \"posts\", Post[]> | null;\r\n\r\nlet userWithPosts: UserWithPosts = null;\r\nif (userWithPosts == null) {\r\n    console.log(userWithPosts.posts[0].title);\r\n}\r\n```\r\n\r\n**Expected behavior:**\r\n`userWithPosts` should be narrowed to null;\r\n\r\n**Actual behavior:**\r\nNo error occurs",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/15994/comments",
    "author": "CurlerRoo",
    "comments": [
      {
        "user": "blakeembrey",
        "created_at": "2017-05-22T15:32:21Z",
        "body": "@pc-lover If you enable `strictNullChecks`, this should work as expected. Without it, there is no `null` or `undefined` types used. Do you have an expected behaviour without `strictNullChecks` enabled?"
      },
      {
        "user": "CurlerRoo",
        "created_at": "2017-05-22T16:00:03Z",
        "body": "@blakeembrey I'm sorry, my mistake"
      }
    ]
  },
  {
    "number": 15976,
    "title": "Compiler API: How to get the \"type\" of an interface?",
    "created_at": "2017-05-21T07:27:45Z",
    "closed_at": "2017-05-22T18:26:23Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/15976",
    "body": "**TypeScript Version:**  2.3.2\r\n\r\n**Code**\r\n\r\nGiven an interface like this:\r\n\r\n```ts\r\n/**\r\n * The props which can be passed to `<Foo/>`.\r\n */\r\nexport interface FooProps {\r\n  /**\r\n   * Use a date formatted as RFC 3339/ISO 8601 (e.g. `'2017-02-22T10:36:24Z'`).\r\n   */\r\n  date: string;\r\n}\r\n```\r\n\r\nI'd like to get the documentation of the interface. Currently I do something like this:\r\n\r\n```ts\r\nconst exports = checker.getExportsOfModule(checker.getSymbolAtLocation(sourceFile));\r\nconst docs: Array<DocumentedExport> = exports.map(exportedSymbol => {\r\n    const symbol = getOriginalSymbol(exportedSymbol, checker);  // returns exportedSymbol or the aliased symbol if it is a re-export\r\n    const documentation = displayPartsToString(symbol.getDocumentationComment());\r\n\r\n    const declaration = symbol.declarations![0];\r\n    const sourceFile = declaration.getSourceFile();\r\n    const { fileName } = sourceFile;\r\n    const { line, character } = sourceFile.getLineAndCharacterOfPosition(declaration.getStart());\r\n    const type = checker.typeToString(checker.getTypeOfSymbolAtLocation(symbol, declaration));\r\n\r\n    if (declaration.kind === SyntaxKind.InterfaceDeclaration) {\r\n      console.log('Found FooProps!');\r\n    }\r\n\r\n    return {\r\n      name: symbol.getName(),\r\n      kind: declaration.kind,\r\n      fileName,\r\n      line,\r\n      character,\r\n      documentation,\r\n      type  // this is `'any'`\r\n    }\r\n  });\r\n```\r\n\r\nMy `type` is `'any'`. Shouldn't it be something like `{ date: string; }`? And how would I get the documentation for `date` (the `Use a date formatted as...'` line).`? \r\n\r\nThank you :)",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/15976/comments",
    "author": "donaldpipowitch",
    "comments": [
      {
        "user": "donaldpipowitch",
        "created_at": "2017-05-21T18:34:17Z",
        "body": "Is this the correct way? :)\r\n\r\n```ts\r\nconst exports = checker.getExportsOfModule(checker.getSymbolAtLocation(sourceFile));\r\nconst docs: Array<DocumentedExport> = exports.map(exportedSymbol => {\r\n  const symbol = getOriginalSymbol(exportedSymbol, checker);  // returns exportedSymbol or the aliased symbol if it is a re-export\r\n  const documentation = displayPartsToString(symbol.getDocumentationComment());\r\n\r\n  const declaration = symbol.declarations![0];\r\n  const sourceFile = declaration.getSourceFile();\r\n  const { fileName } = sourceFile;\r\n  const { line, character } = sourceFile.getLineAndCharacterOfPosition(declaration.getStart());\r\n  let type = checker.typeToString(checker.getTypeOfSymbolAtLocation(symbol, declaration));\r\n\r\n  if (declaration.kind === SyntaxKind.InterfaceDeclaration) {\r\n    type = checker.typeToString(checker.getTypeAtLocation(declaration));\r\n  }\r\n\r\n  return {\r\n    name: symbol.getName(),\r\n    kind: declaration.kind,\r\n    fileName,\r\n    line,\r\n    character,\r\n    documentation,\r\n    type  // this is `'FooProps'` now \\o/\r\n  }\r\n});\r\n```\r\n\r\nCan someone explain me when `getTypeOfSymbolAtLocation` and when `getTypeAtLocation` should be used?\r\n"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2017-05-22T17:35:16Z",
        "body": "There are two functions, `getDeclaredTypeOfSymbol` and `getTypeOfSymbol`. The former is for getting the types of *types*, the latter is for getting the types of *values*. So `getTypeOfSymbol(/*the FooProps symbol*/)` tries to get the type of the *value identifier* (variable) named `FooProps`. `getDeclaredTypeOfSymbol` will do the right thing here.\r\n\r\nI cannot coherently explain the naming convention in a way that would let anyone intuit this behavior."
      },
      {
        "user": "donaldpipowitch",
        "created_at": "2017-05-22T18:26:23Z",
        "body": "Cool, thank you again. ❤"
      },
      {
        "user": "donaldpipowitch",
        "created_at": "2017-05-23T07:10:22Z",
        "body": "> There are two functions, getDeclaredTypeOfSymbol and getTypeOfSymbol.\r\n\r\n@RyanCavanaugh  There is a `getTypeOfSymbol` function in the `checker.ts`, but it is not public. Should it be public? Or is `getTypeOfSymbolAtLocation` (which is public) basically for similar use cases like `getTypeOfSymbol`?\r\n\r\n(`getDeclaredTypeOfSymbol` is on the public `interface TypeChecker`.)"
      },
      {
        "user": "donaldpipowitch",
        "created_at": "2017-05-23T11:40:05Z",
        "body": "> The former is for getting the types of types\r\n\r\nTypes of types are... `interface` and `type`? So basically TypeScript keywords/primitives which aren't included in your compiled JS code?"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2017-05-23T19:07:04Z",
        "body": "Not sure on the first question.\r\n\r\nFor the second, there are also classes and imports to consider. The identifier for a class resolves to both a value (which is the constructor function) and a type (the instance type); similarly an `import`ed identifier *may* have both type and value meanings (or possibly neither, if it's a namespace)."
      }
    ]
  },
  {
    "number": 15858,
    "title": "React Props validation does not work for extended classes",
    "created_at": "2017-05-15T22:08:29Z",
    "closed_at": "2017-05-15T22:31:26Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/15858",
    "body": "We have a generic BaseComponent that does some autobinding and transition blocking. \r\n\r\nIf I have a component that extends BaseComponent<Props, State>, the compiler does not recognize error in props validation.\r\n\r\nThe following component does not throw compiler errors.\r\n```jsx\r\ninterface Props {\r\n  notMyField: string,\r\n}\r\n\r\nclass MyComponent extends BaseComponent<Props, any> {\r\n   render() {\r\n      return <div>{this.props.myField}</div>;\r\n   } \r\n}\r\n```\r\n\r\n```jsx\r\nimport * as PropTypes from 'prop-types';\r\nimport * as React from 'react';\r\n\r\n/**\r\n * The base component that autobinds all the methods to this.\r\n */\r\nclass BaseComponent<Props, State> extends React.Component<Props, State> {\r\n  static propTypes;\r\n  static contextTypes = {\r\n    router: PropTypes.object,\r\n  };\r\n\r\n  props;\r\n  unblock;\r\n\r\n  constructor(props: Props) {\r\n    super(props);\r\n    Object.getOwnPropertyNames(Object.getPrototypeOf(this)).forEach((method) => {\r\n      if (typeof this[method] !== 'function') {\r\n        return;\r\n      }\r\n      this[method] = this[method].bind(this);\r\n    });\r\n  }\r\n\r\n  componentDidMount() {\r\n    const {\r\n      props: {\r\n        history\r\n      },\r\n      willTransition\r\n    } = this as any;\r\n    // TODO: Figure out why react/prop-types is warning here.\r\n    /* eslint-disable react/prop-types */\r\n    if (history && willTransition) {\r\n      this.unblock = history.block(willTransition);\r\n    }\r\n    /* eslint-enable react/prop-types */\r\n  }\r\n\r\n  componentWillUnmount() {\r\n    if (this.unblock) {\r\n      this.unblock();\r\n    }\r\n  }\r\n}\r\n\r\nexport default BaseComponent;\r\n```",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/15858/comments",
    "author": "robin-anil",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2017-05-15T22:24:13Z",
        "body": "`BaseComponent` has a declaration for `props` with no type, and hence it gets a type `any`. remove the declaration of `props`. \r\n```ts\r\nclass BaseComponent<Props, State> extends React.Component<Props, State> {\r\n    ...\r\n    // props;\r\n   ...\r\n```\r\n\r\nalso worth nothing that using `--noImplicitAny` would have flagged these properties as `any` for you."
      },
      {
        "user": "robin-anil",
        "created_at": "2017-05-15T22:31:26Z",
        "body": "Makes sense."
      }
    ]
  },
  {
    "number": 15801,
    "title": "--allowJs Unexpected behavior",
    "created_at": "2017-05-12T16:54:18Z",
    "closed_at": "2017-05-30T18:59:14Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/15801",
    "body": "Hello mates, \r\nI have a problem, when enable option \"allowJs\" , The ts compiler goes crazy \r\ntrying to compile again and again the same files 👎 \r\n\r\nThey could tell me why, Thanks for your time greetings!\r\n\r\nTypescript 2.3.2 \r\nvscode 1.12.1",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/15801/comments",
    "author": "11ume",
    "comments": [
      {
        "user": "aaronbeall",
        "created_at": "2017-05-12T18:04:24Z",
        "body": "Are you outputting the JS in the same folder you are compiling?"
      },
      {
        "user": "mhegazy",
        "created_at": "2017-05-12T18:35:55Z",
        "body": "make sure you have your output folder in your `exclude` property."
      },
      {
        "user": "11ume",
        "created_at": "2017-05-12T19:22:06Z",
        "body": "I have included the output folder in my exclude property and now works perfectly thank you for your time\r\nregards!!"
      },
      {
        "user": "mhegazy",
        "created_at": "2017-05-30T18:59:14Z",
        "body": "Automatically closing this issue for housekeeping purposes. The issue labels indicate that it is unactionable at the moment or has already been addressed."
      }
    ]
  },
  {
    "number": 15793,
    "title": "Object types (Specification)",
    "created_at": "2017-05-12T08:21:38Z",
    "closed_at": "2017-05-12T13:19:26Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/15793",
    "body": "From specification:\r\n````\r\n3.3 Object Types\r\n\r\nObject types are composed from properties, call signatures, construct signatures, \r\nand index signatures, collectively called members.\r\n3.8.3 Object Type Literals\r\n  ...\r\n  TypeMember:\r\n   PropertySignature\r\n   CallSignature\r\n   ConstructSignature\r\n   IndexSignature\r\n   MethodSignature\r\n  ...\r\n  Object type members are described in section 3.9.\r\n\r\n3.9 Specifying Members\r\n3.9.5 Method Signatures\r\n\r\n  A method signature is shorthand for declaring a property of a function type.\r\n\r\n````\r\nWhy there is no **method signatures** in the first sentence?\r\n_Object types are composed from properties, call signatures, construct signatures, \r\nand index signatures, collectively called members._\r\n\r\nDoes `properties` mean `method and property signatures` together?\r\nIf so it is not evidently.\r\nMay be it is better to split `properties` into `property and method signatures`,\r\nbecause we will enumerate entities from one domain (signatures).  \r\n\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/15793/comments",
    "author": "olegdunkan",
    "comments": [
      {
        "user": "DanielRosenwasser",
        "created_at": "2017-05-12T09:18:19Z",
        "body": "A method signature is really just a property signature whose type is an object type which contains a call signature.\r\n\r\nIn other words\r\n\r\n```ts\r\ninterface Foo {\r\n  bar(): string;\r\n}\r\n```\r\n\r\nis the same as\r\n\r\n```ts\r\ninterface Foo {\r\n  bar: {\r\n    (): string;\r\n  }\r\n}\r\n```"
      },
      {
        "user": "olegdunkan",
        "created_at": "2017-05-12T13:19:18Z",
        "body": "@DanielRosenwasser thanks, I expected that they are the same entity but in the context of object literal they are apart.\r\n\r\n\r\n"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2017-05-12T16:12:24Z",
        "body": "No prob! It's more a difference between the syntax and the type itself"
      }
    ]
  },
  {
    "number": 15649,
    "title": "extension authoring:need some api",
    "created_at": "2017-05-08T03:40:28Z",
    "closed_at": "2018-02-22T20:41:39Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/15649",
    "body": "I'd like to witre an extension : \"when rename a file ,auto repalce the reference in other files\" for ts project and nodejs project.\r\n\r\nI looked for the doc but can't find the rename event or move file event or delete file event (\r\nMaybe it's my carelessness ). So , can support the apis?\r\n\r\n\r\nand by the way ,\r\n\r\n\r\nfind string api (the doc show it has the find file api)\r\n\r\nreplace string api\r\n\r\nis not exist ,and it's useful too. eg: the TODO Parser Extension .the exist TODO Parser Extension is not good and fast.\r\n\r\n\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/15649/comments",
    "author": "Midqiu",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2018-02-08T20:08:12Z",
        "body": "The server does not have such events, you want to get that from the editor. "
      },
      {
        "user": "typescript-bot",
        "created_at": "2018-02-22T20:41:38Z",
        "body": "Automatically closing this issue for housekeeping purposes. The issue labels indicate that it is unactionable at the moment or has already been addressed."
      }
    ]
  },
  {
    "number": 15646,
    "title": "[2339] Property ... does not exist on type 'typeof (Anonymous class)'",
    "created_at": "2017-05-08T00:34:59Z",
    "closed_at": "2017-05-08T19:46:41Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/15646",
    "body": "**TypeScript Version:**  2.2.1 stable\r\n\r\n**Code**\r\n\r\n```ts\r\nclass skrolr {\r\n    private static _Array = class extends Array {\r\n        from( obj: HTMLCollection ) {\r\n            let arr = [];\r\n            for( let i=0, len=obj.length; i<len; i++ ) {\r\n                arr[i] = obj[i];\r\n            }\r\n        }\r\n    }\r\n    \r\n    // in another class\r\n    skrolr._Array.from( [HTMLCollection object] );\r\n}\r\n```\r\n\r\n**Expected behavior:**\r\nSuccessful transpiling to ES3\r\n\r\n**Actual behavior:**\r\nError 2339\r\n\r\nBasically just trying to have a simplified polyfill for Array.from(), but I don't want this to be global, so I'm doing it in a subclass. It works as expected in ES6, and the subclass transpiles correctly to ES3, it's just the parser for some reason isn't seeing it.",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/15646/comments",
    "author": "jhpratt",
    "comments": [
      {
        "user": "hediet",
        "created_at": "2017-05-08T09:01:30Z",
        "body": "You are not instantiating your class `_Array`, so either you want to make `from` static or put it in an object rather than a class:\r\n```\r\n... \r\nprivate static _array = { from: function() {...}} ;\r\n... \r\n```"
      },
      {
        "user": "mhegazy",
        "created_at": "2017-05-08T16:21:07Z",
        "body": "` skrolr._Array` is a class, whose instances have a function called `from`. \r\n\r\nso either defined `from` as `static`, or call `(new skrolr._Array()).from`"
      },
      {
        "user": "jhpratt",
        "created_at": "2017-05-08T19:42:37Z",
        "body": "Ok, yes, that was the issue. However, why does it transpile to ES6 but not ES3 without declaring `static`?"
      },
      {
        "user": "mhegazy",
        "created_at": "2017-05-08T19:46:37Z",
        "body": "not sure what you mean by `transpile`..\r\n\r\nthe generated code is the same semantically, it just happens that on ES6 engine, your class has a static `from` method that it got from the base `Array`, on an ES3 engine, that is not the same..\r\n\r\nin both cases, your new function goes not get to execute."
      }
    ]
  },
  {
    "number": 15561,
    "title": "Generic hash base type (Suggestion)",
    "created_at": "2017-05-03T17:21:16Z",
    "closed_at": "2017-05-03T23:38:05Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/15561",
    "body": "In Typescript and javascript  all variables are hashes.  There isn't necessarily a specific hash object.  But the hash is a non generic type that returns type any and there is no way of have a typed hash without creating your own object which of course then adds overhead.  It would be nice to have a base type in typescript that can be used generically that would cast the return of a [] statement on a variable with the type specific in the generic declaration of the variable.  \r\nAn example would be the following.\r\n`var hash: Hash<string> = {};\r\nvar value = hash['somekey'];\r\n`\r\n\r\nThe value would have the implicit type of string based on the declaration of the hash and wouldn't require additional casting of the value coming back from the object.",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/15561/comments",
    "author": "cwunderly",
    "comments": [
      {
        "user": "kitsonk",
        "created_at": "2017-05-03T17:26:26Z",
        "body": "How would this differ from:\r\n\r\n```ts\r\ninterface Hash<T> {\r\n  [key: string]: T;\r\n}\r\n\r\nconst hash: Hash<string> = {};\r\nhash['somekey'] = 'foo';\r\n```\r\n"
      },
      {
        "user": "cwunderly",
        "created_at": "2017-05-03T17:29:06Z",
        "body": "Didn't realize you could declare that in an interface.  Would still be nice to have it as a base type i guess but i could very easily make that myself."
      },
      {
        "user": "cwunderly",
        "created_at": "2017-05-03T17:35:41Z",
        "body": "Trying that out this does bring up a slight irregularity in the error reporting behavior.  I would have declared\r\nthe hash to be this instead. `interface Hash<T> {\r\n  [key: string|number]: T;\r\n}\r\n`\r\nthe hash to be this instead. `interface Hash<T> {\r\n  [key: string|number]: T;\r\n}\r\n`\r\nBut the compiler tells me it has to be a string or number but it can't be a string \"or\" number in the syntactical sense.  I see that you can still get the the interface this way by doing this:\r\n`interface Hash<T> {\r\n  [key: number]: T;\r\n[key: string]: T;\r\n}\r\n`\r\nso its really not a big deal but just seemed a little strange.\r\n\r\n"
      },
      {
        "user": "kitsonk",
        "created_at": "2017-05-03T17:43:07Z",
        "body": "> But the compiler tells me it has to be a string or number but it can't be a string \"or\" number in the syntactical sense.\r\n\r\nBecause you can't... indexes have to be `string` or `number` not the intersection of the two.  At runtime they are technically always `string`, but `number` is allowed to make it easier to model `Array` and its related types."
      },
      {
        "user": "cwunderly",
        "created_at": "2017-05-03T17:53:39Z",
        "body": "OK I read up on the union symbol.  I had seen it and used in other code and assumed that | meant or.  I realize now that it isn't the same thing.  That makes sense.  Thanks for the clarification."
      }
    ]
  },
  {
    "number": 15440,
    "title": "Suggestion : a way to share method implementations",
    "created_at": "2017-04-28T12:15:40Z",
    "closed_at": "2017-04-28T17:22:39Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/15440",
    "body": "Class inheritance and mixins are not always the best way to share methods when your model is not hierarchical.\r\nI'm looking for a way to share implementations in classes.\r\nIn Typesrcipt, it could looks like:\r\n```typescript\r\nfunction m1() {...}\r\nfunction m2(this:A) {...}\r\n\r\nclass A {\r\n  m :: m1\r\n}\r\nclass B extends A {\r\n  m :: m2\r\n}\r\nclass C {\r\n  m :: m1\r\n}\r\n```\r\nTranspilation in javascript should looks like:\r\n```javascript\r\nfunction m1() {...}\r\nfunction m2() {...}\r\n\r\nA = class A {}\r\nA.prototype.m = m1\r\n\t\t\t\r\nB = class B extends A {}\r\nB.prototype.m = m2\r\n\r\nC = class C {}\r\nC.prototype.m = m1\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/15440/comments",
    "author": "sspi",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2017-04-28T17:22:39Z",
        "body": "```ts\r\nclass A {\r\n  // regular stuff\r\n}\r\ninterface A {\r\n  m: typeof m1;\r\n}\r\nA.prototype.m = m1;\r\n```"
      }
    ]
  },
  {
    "number": 15394,
    "title": "Confusing Types: Element, Node, HTMLElement, EventTarget",
    "created_at": "2017-04-26T17:58:35Z",
    "closed_at": "2017-05-22T22:34:58Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/15394",
    "body": "**TypeScript Version:**  2.2.1\r\n\r\n**Code**\r\n\r\n```ts\r\ndocument.activeElement.isContentEditable // type error\r\n(document.activeElement as HTMLElement).isContentEditable\r\n\r\ndocument.querySelector('[contenteditable=\"true\"]').addEventListener(\"mousedown\", (e) => {\r\n\te.target.getBoundingClientRect() // type error\r\n\t(e.target as Node).getBoundingClientRect()\r\n\t(e.target as Element).getBoundingClientRect()\r\n\t(e.target as HTMLElement).getBoundingClientRect()\r\n})\r\n```\r\n\r\n**Expected behavior:**\r\n\r\nI would expect there to be no type-errors here because they all work in the browser...\r\n\r\n**Actual behavior:**\r\n\r\nI get random unexpected type-errors and keep having to cast types.\r\n\r\n---\r\n\r\nI apologize if I don't know what I'm talking about and this is actually a question, but it seems like a bug to me. If not, I'd love to see some clarification in the docs about the subtleties of these types.",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/15394/comments",
    "author": "ccorcos",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2017-04-26T18:11:56Z",
        "body": "Basically EventTarget is the most general type, of which Element is a subtype, and HTMLElement is a subtype of that. If you get back a *thing* from the DOM, we generally have no idea which it is, and you should add a type assertion to \"add in\" the specific external knowledge that you have about the structure of your particular DOM layout.\r\n\r\nIt's possible, for example, that the `.target` of an event is *not* an Element (you can add event listeners to XMLHttpRequest, for example, and XMLHttpRequest does not have a getBoundingClientRect method)."
      },
      {
        "user": "ccorcos",
        "created_at": "2017-04-26T20:51:09Z",
        "body": "hmm, well in the event listener above, it seems like the target should always be HTMLElement based on the type that I'm adding the event listener to. Is it possible that we just need some stricter type annotations? Or is this just the way it is?"
      },
      {
        "user": "mhegazy",
        "created_at": "2017-05-22T22:34:58Z",
        "body": "Automatically closing this issue for housekeeping purposes. The issue labels indicate that it is unactionable at the moment or has already been addressed."
      }
    ]
  },
  {
    "number": 15317,
    "title": "Custom transformers does not work with tsx and jsx: 'react' compiler option",
    "created_at": "2017-04-22T12:39:08Z",
    "closed_at": "2017-04-22T12:42:57Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/15317",
    "body": "**TypeScript Version:**  2.3.0-dev.20170422\r\n\r\n**Code**\r\n\r\n* test.tsx\r\n```ts\r\nimport * as React from 'react';\r\n\r\nclass Test extends React.Component<{}, {}> {\r\n  render() {\r\n    return <div></div>;\r\n  }\r\n}\r\n```\r\n\r\n* compile.js\r\n\r\n```js\r\nconst ts = require('typescript');\r\n\r\nconst program = ts.createProgram(['./test.tsx'], {\r\n  strict: true,\r\n  noEmitOnError: true,\r\n  target: ts.ScriptTarget.ES5,\r\n  jsx: 'react'\r\n});\r\n\r\nconst transformers = {\r\n  before: [context => file => file], // use a custom transformer that does nothing\r\n  after: []\r\n};\r\nprogram.emit(undefined, undefined, undefined, false, transformers);\r\n```\r\n\r\nAnd then run\r\n\r\n```sh\r\n$ node compile.js\r\n```\r\n\r\n**Expected behavior:**\r\n`return <div></div>;` is converted to `return React.createElement(\"div\", null);`\r\n\r\n**Actual behavior:**\r\n`return <div></div>;` remains in the emitted JavaScript file.",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/15317/comments",
    "author": "kimamula",
    "comments": [
      {
        "user": "kimamula",
        "created_at": "2017-04-22T12:42:57Z",
        "body": "Sorry, this was my fault.\r\n`jsx: 'react'` should be `jsx: ts.JsxEmit.React`."
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2017-04-24T18:28:18Z",
        "body": "Someone should write a typechecker to catch those kinds of problems 🤔 😉 "
      }
    ]
  },
  {
    "number": 15264,
    "title": "No --target es2016 support on VS2017?",
    "created_at": "2017-04-19T05:31:15Z",
    "closed_at": "2017-04-19T08:41:20Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/15264",
    "body": "**TypeScript Version:**  2.1.5.0 (VS2017)\r\n\r\n**Code**\r\n\r\n```xml\r\n  <PropertyGroup Label=\"Configuration\" Condition=\"'$(Configuration)|$(Platform)'=='Release|AnyCPU'\">\r\n    <TypeScriptTarget>ES2016</TypeScriptTarget>\r\n    <TypeScriptNoImplicitAny>true</TypeScriptNoImplicitAny>\r\n    <TypeScriptOutFile>js/app.js</TypeScriptOutFile>\r\n  </PropertyGroup>\r\n```\r\n\r\n**Expected behavior:**\r\n\r\nIt should compile\r\n\r\n**Actual behavior:**\r\n\r\n`Build:Cannot find name '(every type in lib.d.ts e.g. Document)'`",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/15264/comments",
    "author": "saschanaz",
    "comments": [
      {
        "user": "DanielRosenwasser",
        "created_at": "2017-04-19T07:45:51Z",
        "body": "I think this is related to #14401. Can you try adding `\"lib\": [\"es2016\", \"dom\"]`?"
      },
      {
        "user": "saschanaz",
        "created_at": "2017-04-19T08:41:20Z",
        "body": "Seems it does the work. Thanks!\r\n\r\n```xml\r\n<TypeScriptLib>es2016,dom</TypeScriptLib>\r\n```"
      }
    ]
  },
  {
    "number": 15263,
    "title": "Typing static class",
    "created_at": "2017-04-19T02:11:56Z",
    "closed_at": "2017-04-19T03:31:02Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/15263",
    "body": "**TypeScript Version:**  2.2.1\r\n\r\n**Code**\r\n\r\n```ts\r\nimport { Component, DebugElement, Type } from '@angular/core';\r\nimport { ComponentFixture, TestBed } from '@angular/core/testing';\r\n\r\ninterface TestFixture<T> {\r\n  component: T;\r\n  debugElement: DebugElement;\r\n  element: any;\r\n  fixture: ComponentFixture<T>;\r\n}\r\n\r\nexport function createComponent<T>(TestBed: Static<TestBed>, cmpt: Type<T>): TestFixture<T> {\r\n  const fixture = TestBed.createComponent(cmpt);\r\n  const component = fixture.componentInstance;\r\n  const debugElement = fixture.debugElement;\r\n  const element = fixture.nativeElement;\r\n\r\n  return { component, debugElement, element, fixture };\r\n}\r\n```\r\n\r\n**Expected behavior:**\r\n\r\nI propose that we have a good way of typing a static class value in a function argument - in this example, this prevents me from accurately typing `fixture`, `component`, `debugElement`, and `element` without force casting since TypeScript does not appear to support typing static instances.\r\n\r\nIn my example, I am proposing that a syntax such as `Static<TestBed>` represent the static class `TestBed`, which is not meant to be newed.\r\n\r\n**Actual behavior:**\r\n\r\nI get errors such as\r\n```\r\nTS2345: Argument of type 'typeof TestBed' is not assignable to parameter of type 'TestBed'\r\n```",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/15263/comments",
    "author": "wesleycho",
    "comments": [
      {
        "user": "aluanhaddad",
        "created_at": "2017-04-19T02:32:05Z",
        "body": "> In my example, I am proposing that a syntax such as Static<TestBed> represent the static class TestBed, which is not meant to be newed.\r\n\r\nThere is such syntax already:\r\n```ts\r\ninterface TestBed {\r\n  createComponent<T extends new (...args:{}[]) => {})>(Component: T): Fixture;\r\n}\r\ninterface Fixture {...}\r\n```\r\n> TypeScript does not appear to support typing static instances.\r\n\r\nMaybe I misunderstand, but what is a static instance? Everything is just an object, even a class which is why the interface declaration above will work."
      },
      {
        "user": "wesleycho",
        "created_at": "2017-04-19T03:31:02Z",
        "body": "TestBed is not something I own - it is something that the Angular team provides with static methods on the class itself.\r\n\r\nLooks like the answer was to use `typeof TestBed` in this instance though.\r\n\r\nClosing as this appears to have a good enough solution for my case."
      },
      {
        "user": "aluanhaddad",
        "created_at": "2017-04-19T07:01:41Z",
        "body": "@wesleycho that doesn't mean you can't declare a type for it. Just use another name.\r\n\r\nThat said, I think using `typeof` is the right solution here but I wanted to explain how the specific feature requested is already provided so that you could employ it whenever you might need to. I feel like there's a fair amount of confusion around classes."
      }
    ]
  },
  {
    "number": 15215,
    "title": "Performance request/question: direct use of \"arguments\" variable inside a function ",
    "created_at": "2017-04-17T06:24:03Z",
    "closed_at": "2017-04-17T06:57:53Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/15215",
    "body": "**TypeScript Version:**  2.2.2, Linux Ubuntu 16.04 x86_64.\r\n\r\nI find it depressing that I cannot use the arguments variable somehow directly, that I have to see TypeScript creating a horrible duplication of memory, and waste of time. I think/wish/dream we should be able to use \"...arguments\" so that the generated javascript can just use \"arguments\" directly.\r\n\r\nI think I want something like:\r\n\r\n```ts\r\nfunction foo(...arguments) {\r\n   console.log( arguments[0] ); // TS2396\r\n}\r\n```\r\n\r\nso I have to do something like:\r\n\r\n```ts\r\nfunction foo(...args) {\r\n   console.log( args[0] ); // ok\r\n}\r\n```\r\n\r\nbut it generates depressing overhead in the final js:\r\n\r\n```js\r\n// the generated js \r\n    var args = [];\r\n    for (var _i = 0; _i < arguments.length; _i++) {\r\n        args[_i] = arguments[_i];\r\n    }\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/15215/comments",
    "author": "raould",
    "comments": [
      {
        "user": "ikatyang",
        "created_at": "2017-04-17T06:51:26Z",
        "body": "Default target is `es5` which cannot use `...`, you have to set `es6` or above\r\n\r\nCLI\r\n\r\n```sh\r\ntsc test.ts --target es6\r\n```\r\n\r\nor using `tsconfig.json`:\r\n\r\n```json\r\n{\r\n    \"compilerOptions\": {\r\n        \"target\": \"es6\"\r\n    }\r\n}\r\n\r\n```\r\ntest.ts\r\n```ts\r\nfunction foo(...args) {\r\n   console.log( args[0] ); // ok\r\n}\r\n```\r\n\r\ntest.js\r\n```js\r\nfunction foo(...args) {\r\n    console.log(args[0]); // ok\r\n}\r\n```"
      },
      {
        "user": "raould",
        "created_at": "2017-04-17T06:57:53Z",
        "body": "thank you, will try!"
      }
    ]
  },
  {
    "number": 15161,
    "title": "Type params constrained to Record<string, ...> require type args to have index signatures",
    "created_at": "2017-04-12T20:51:25Z",
    "closed_at": "2021-06-24T22:48:13Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/15161",
    "body": "```ts\r\ninterface Foo {\r\n    a: \"hello\" | \"world\";\r\n    b: boolean\r\n}\r\n\r\ndeclare function takeFoo<T extends Record<string, string | boolean>>(x: T): T;\r\n\r\ntakeFoo<Foo>({\r\n    a: \"hello\",\r\n    b: true,\r\n});\r\n```\r\n\r\nExpected: no error\r\nActual: \r\n\r\n```\r\nType 'Foo' does not satisfy the constraint 'Record<string, number | boolean>'.\r\n  Index signature is missing in type 'Foo'.\r\n```",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/15161/comments",
    "author": "DanielRosenwasser",
    "comments": [
      {
        "user": "dmikis",
        "created_at": "2018-03-23T13:35:50Z",
        "body": "~~It's not immediately obvious why it's not a bug. Right now this breaks our project on 2.7.2 (worked perfectly on 2.5).~~\r\n\r\n~~After giving it some thought it's understandable. However, we still need a way to constraint types of members of a passed type parameter.~~\r\n\r\nAfter giving it more thought and asking around for possible solutions, it seems we can't solve out problem without redundant index signatures. Here's what we've got. We have out own implementation of event emitter:\r\n\r\n```typescript\r\ninterface IEvent<TPropMap extends {}> {\r\n    get<TKey extends keyof TPropMap>(key: TKey): TPropMap[TKey];\r\n}\r\n\r\ninterface IEventCallback<TEvent extends IEvent<{}>> {\r\n    (event: TEvent): void;\r\n}\r\n\r\ninterface IEventManager<TEventMap extends Record<strign, IEvent<{}>> {\r\n    add<TEventName extends keyof TEventMap>(\r\n        name: TEventName,\r\n        callback: IEventCallback<TEventMap[TEventName]>\r\n    ): void;\r\n}\r\n```\r\n\r\nThe `extends Record<string, IEvent<{}>>` part causing us problems due to reasons described in this task. We ended up with redundant inheritance from a `Record<string, IEvent<{}>>` for all types used as `TEventMap`.\r\n\r\nGenerally speaking, I think an interface should be assignable to a `Record<string, T>` where `T` is a type every property of the interface is assignable to."
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2021-06-24T22:48:13Z",
        "body": "We're good enough at circular constraints now that this isn't needed. You can write\r\n```ts\r\ndeclare function takeFoo<T extends Record<keyof T, string | boolean>>(x: T): T;\r\n```"
      }
    ]
  },
  {
    "number": 15065,
    "title": "Unable to assign compatible value to generic typed property using `extends` in generic definition.",
    "created_at": "2017-04-07T03:55:17Z",
    "closed_at": "2017-04-07T04:27:05Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/15065",
    "body": "**TypeScript Version:**  2.2.2\r\n\r\nI might just be misunderstanding how generics work (if so please point me in the right direction), but this seem like a bug.\r\n\r\n**Code**\r\n\r\n```ts\r\n// A *self-contained* demonstration of the problem follows...\r\n\r\ninterface BaseState {\r\n    on: boolean;\r\n};\r\n\r\nclass Component {\r\n    state: BaseState;\r\n\r\n    setState(state: BaseState) {\r\n        this.state = state;\r\n    }\r\n\r\n    onInput({ value }: { value: number }) {\r\n        this.setState({ on: value > 0 });  // no error\r\n    }\r\n}\r\n\r\nclass GenericComponent<State extends BaseState> {\r\n    state: State;\r\n\r\n    setState(state: State) {\r\n        this.state = state\r\n    }\r\n\r\n    onInput({ value }: { value: number }) {\r\n        this.setState({ on: value > 0 });  // error Argument of type '{ on: boolean; }' is not assignable to parameter of type 'State'.\r\n    }\r\n}\r\n\r\n```\r\n\r\n**Expected behavior:**\r\nIn the `Component` class in the example above causes no errors when using the `BaseState` interface directly. I expect the same behavior from the `GenericComponent` class since the `State` generic explicitly extends `BaseState`.\r\n\r\n**Actual behavior:**\r\nInstead I get the following error related to `this.setState({ on: value > 0 });`: \"Argument of type '{ on: boolean; }' is not assignable to parameter of type 'State'.\"\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/15065/comments",
    "author": "joslarson",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2017-04-07T04:27:05Z",
        "body": "Consider what happens if you write this\r\n```ts\r\nvar t = new GenericComponent<{on: boolean, thing: string}>();\r\nt.onInput({ value: 30 });\r\nt.state.thing.substr(0); // 'thing' property should exist, but doesn't\r\n```"
      },
      {
        "user": "aluanhaddad",
        "created_at": "2017-04-07T04:36:28Z",
        "body": "Here is a simplified example:\r\n```ts\r\nclass Stateful<State extends { on: boolean }> {\r\n  state: State = {\r\n    on: true\r\n  }; // error\r\n}\r\n```\r\nThe reason this doesn't work is that it is only ever going to be valid when `Stateful` is instantiated with a type argument precisely equivalent to `{ on: boolean }`.\r\n\r\nBasically, _there exists_ a type `T`, satisfying the constraints of `Stateful`'s type argument such that the instantiation is valid but this does not hold _for all_ types `T` where `T` satisfies the constraint of `Stateful`'s type argument.\r\n\r\nSo the errant code above asserts that, for all types `T<T>` where `T, `Stateful<T>`.\r\n\r\nLogically, we can look at it as follows\r\n\r\nAssertion\r\n\r\n1. Let `P` be the type `{ on: boolean }`\r\n2. For all types `T` such that `T` is assignable to `P`, the definition of `Stateful<T>` above is valid\r\n\r\nDisproof by counter example\r\n1. Let `U` be the type `{ on: boolean, value: number }`\r\n2. `U` is assignable to `P` -> by definition\r\n3. `Stateful<U>` is invalid -> by substitution\r\n4. Therefore there exists a type `T` such that `T` is assignable to `P` and `Stateful<T>` is an invalid instantiation -> by implication"
      },
      {
        "user": "joslarson",
        "created_at": "2017-04-07T04:40:52Z",
        "body": "@RyanCavanaugh @aluanhaddad  Shoot, I knew that. I just got confused while trying to distill the problem down to something simpler. So let try that again. What about in this case using a Partial? I still get a similar error.\r\n\r\n```ts\r\ninterface BaseState {\r\n    on: boolean;\r\n};\r\n\r\nclass Component {\r\n    state: BaseState;\r\n\r\n    setState(partialState: Partial<BaseState>) {\r\n        this.state = { ...this.state, ...partialState };\r\n    }\r\n\r\n    onInput({ value }: { value: number }) {\r\n        this.setState({ on: value > 0 });  // no error\r\n    }\r\n}\r\n\r\nclass GenericComponent<State extends BaseState> {\r\n    state: State;\r\n\r\n    setState(partialState: Partial<State>) {\r\n        this.state = { ...this.state, ...partialState };\r\n    }\r\n\r\n    onInput({ value }: { value: number }) {\r\n        this.setState({ on: value > 0 });  // error: Argument of type '{ on: boolean; }' is not assignable to parameter of type 'Partial<State>'\r\n    }\r\n}\r\n```"
      }
    ]
  },
  {
    "number": 15025,
    "title": "Inexplicable behavior",
    "created_at": "2017-04-05T14:54:28Z",
    "closed_at": "2017-04-05T15:32:08Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/15025",
    "body": "**Example 1**\r\n\r\n```ts\r\nclass foo {\r\n  readonly 1 // the same with private and static\r\n}\r\n```\r\n\r\n**Error**\r\n\r\nNo\r\n\r\n**Result**:\r\n\r\n```js\r\nvar foo = (function () {\r\n    function foo() {\r\n    }\r\n    return foo;\r\n}());\r\n\r\n```\r\n\r\n**Example 2**\r\n\r\n```ts\r\nclass foo {\r\n  const a () {} \r\n}\r\n```\r\n\r\n**Error**\r\n\r\n```\r\nError:(2, 9) TS1248:A class member cannot have the 'const' keyword.\r\n```\r\n\r\n**Result**:\r\n\r\n```js\r\nvar foo = (function () {\r\n    function foo() {\r\n    }\r\n    foo.prototype.a = function () { };\r\n    return foo;\r\n}());\r\n```\r\n\r\nIs it ok?\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/15025/comments",
    "author": "monolithed",
    "comments": [
      {
        "user": "ghost",
        "created_at": "2017-04-05T15:04:07Z",
        "body": "**Example 1**:\r\nIt might help clarify to turn on `\"noImplicitAny\": true,` in your tsconfig. `1` is the *key* of the property there, and the type is omitted.\r\nProperty declarations have no effect on emit (unless they have an initializer).\r\nFYI `readonly 1 = 2;` is totally valid code. Then `new foo()[1]` will be `2`.\r\n\r\n**Example 2**:\r\n`const` isn't allowed on a method (this ain't C++), so TypeScript correctly gave you an error here.\r\nTS will still have a best-guess emit even after an error; in this case it simply ignores `const`."
      },
      {
        "user": "monolithed",
        "created_at": "2017-04-05T15:32:08Z",
        "body": "Got it, thanks"
      }
    ]
  },
  {
    "number": 14978,
    "title": "Inference of generic type",
    "created_at": "2017-04-03T03:11:57Z",
    "closed_at": "2017-04-19T18:54:30Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/14978",
    "body": "Currently a generic class such as\r\n```ts\r\nclass A<B extends C<D>, D>\r\n```\r\nMust have both B and D passed when instantiated, but it would be nice if the type system could infer the type D from type B. Because if I pass in type B which extends type C<D>, then type D is known from C<D>. Why do I have to pass type D separately as well?\r\n\r\nOr am I approaching this the wrong way? I'm just trying to avoid us having to unnecessarily import interfaces all over the place!",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/14978/comments",
    "author": "Roam-Cooper",
    "comments": [
      {
        "user": "Roam-Cooper",
        "created_at": "2017-04-03T04:11:29Z",
        "body": "Say that I define a generic class as such\r\n```ts\r\nclass A<B<C>>\r\n```\r\nIs it therefore possible in any form or fashion to be able to extract type C from generic type B? Or is this impossible?\r\n\r\nIt would be incredibly, immensely useful to be able to extract the type of a generic type, especially when type mapping (another issue that I have opened)."
      },
      {
        "user": "aluanhaddad",
        "created_at": "2017-04-03T05:05:07Z",
        "body": "In the nightly build there is some nice new syntactic sugar around default type arguments that allows you to omit type them from consumption sites in a number of places as well as pass down defaults which can, optionally, be themselves derived from other type arguments.\r\n\r\nThat said, I think you are after higher-kinded types, or perhaps existential types."
      }
    ]
  },
  {
    "number": 14939,
    "title": "potential bug when transpiling to System.js",
    "created_at": "2017-03-30T21:44:02Z",
    "closed_at": "2017-05-19T16:47:52Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/14939",
    "body": "TypeScript Version:  2.2.1 \r\n\r\nI have this tsconfig.json file:\r\n\r\n```js\r\n{\r\n  \"compilerOptions\": {\r\n    \"outFile\": \"dist/suman.js\",\r\n    \"declaration\": true,\r\n    \"baseUrl\": \".\",\r\n    \"paths\": {\r\n    },\r\n    \"types\": [\r\n      \"node\",\r\n      \"async\",\r\n      \"lodash\"\r\n    ],\r\n    \"typeRoots\": [\r\n      \"node_modules/@types\"\r\n    ],\r\n    \"target\": \"es5\",\r\n    \"module\": \"system\",\r\n    \"moduleResolution\": \"node\",\r\n    \"noImplicitAny\": true,\r\n    \"removeComments\": true,\r\n    \"allowUnreachableCode\": true,\r\n    \"lib\": [\r\n      \"es2015\",\r\n      \"es2016\",\r\n      \"es2017\",\r\n      \"dom\"\r\n    ]\r\n  },\r\n  \"allowJs\": true,\r\n  \"compileOnSave\": false,\r\n  \"include\": [\r\n    \"./**/*.ts\",\r\n    \"./**/*.js\"\r\n  ],\r\n  \"exclude\": [\r\n    \"test\",\r\n    \"node_modules\",\r\n    \"dist\"\r\n  ]\r\n}\r\n```\r\n\r\n\r\na file called freeze-existing.ts, looks like:\r\n\r\n```ts\r\n'use strict';\r\n\r\nexport = function freezeExistingProps(obj: any) {\r\n\r\n    try {\r\n        Object.keys(obj).forEach(function (key) {\r\n            Object.defineProperty(obj, key, {\r\n                writable: false\r\n            });\r\n        });\r\n    }\r\n\r\n    catch(err){\r\n\r\n    }\r\n\r\n    return obj;\r\n\r\n};\r\n```\r\n\r\nand it gets compiled to:\r\n\r\n```js\r\nSystem.register(\"freeze-existing\", [], function (exports_1, context_1) {\r\n    'use strict';\r\n    var __moduleName = context_1 && context_1.id;\r\n    return {\r\n        setters: [],\r\n        execute: function () {\r\n        }\r\n    };\r\n});\r\n\r\n```\r\n\r\nPerhaps this is because Object.defineProperty is not available in the browser?\r\n\r\nI would expect that the module would be basically transpiled verbatim but that's clearly not what happened.\r\n\r\n\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/14939/comments",
    "author": "ORESoftware",
    "comments": [
      {
        "user": "aluanhaddad",
        "created_at": "2017-04-01T00:19:09Z",
        "body": "> Perhaps this is because Object.defineProperty is not available in the browser?\r\n\r\n`Object.defineProperty` most definitely is available in browsers.\r\n\r\nYour code is invalid. The `system` format is not defined in terms of assignments to `module.exports` and does not provide any of `module`, `exports`, or `require`.\r\n\r\nTypeScript throws an error on this code and the error is very specific:\r\n> Export assignment is not supported when '--module' flag is 'system'.\r\n\r\nUse \r\n```ts\r\nexport default function freezeExistingProps(obj: {}) { ... }\r\n```\r\ninstead\r\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2017-05-19T16:47:52Z",
        "body": "Automatically closing this issue for housekeeping purposes. The issue labels indicate that it is unactionable at the moment or has already been addressed."
      }
    ]
  },
  {
    "number": 14866,
    "title": "Type inference is not casting inheritance interfaces",
    "created_at": "2017-03-27T06:55:26Z",
    "closed_at": "2017-05-18T16:23:26Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/14866",
    "body": "**TypeScript Version:**  2.2.1\r\n\r\n**Code**\r\n```ts\r\nexport function sample<T, P extends base<T>, R extends base<T>>(originalFunc: OriginalFunction<T, P, R>) {\r\n}\r\n\r\n\r\ninterface base<T>{\r\n    Misc?: {[keyName: string]: keyof T};  // this will just make evident the cast error and cause the compilation error, without it will compile successfully but if you check the typings will be casted to <any>\r\n}\r\ninterface child<T> extends base<T> {\r\n\tItems: Array<T>;\r\n}\r\n\r\ninterface OriginalFunction <T, P, R> {\r\n    <T>(params: P, callback: OriginalCallbacFunc<R>): any;\r\n}\r\n\r\ninterface OriginalCallbacFunc<R> {\r\n    (err: Error, data: R): any;\r\n}\r\n\r\n\r\n\r\nfunction functionWithCallback<T>(params: child<T>, callback: (err: Error, data: child<T>) => void) {\r\n}\r\n\r\nsample(functionWithCallback); // wrong type inference causes error\r\n```\r\n\r\n**Expected behavior:**\r\nCorrect typing inference instead of the compilation error.\r\n**Actual behavior:**\r\nThe Generic typings are not correctly inferred, so it generates a compilation error.",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/14866/comments",
    "author": "HefloRicardo",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2017-05-18T16:16:57Z",
        "body": "Just as a comment. the `T` in `OriginalFunction` is never used. `    <T>(params: P ...)` declares a new type parameter `T` that shadows the `T` from the interface. my guess is you do not need either.\r\n```ts\r\ninterface OriginalFunction <T, P, R> {\r\n    <T>(params: P, callback: OriginalCallbacFunc<R>): any;\r\n}\r\n```"
      },
      {
        "user": "mhegazy",
        "created_at": "2017-05-18T16:23:19Z",
        "body": "By using that `T` in a place where it can not be infered, you are getting a `{}`, this then does not satisfy the constraint. removing it should address the error you are seeing.\r\n"
      }
    ]
  },
  {
    "number": 14831,
    "title": "How could I solve duplicated identifiers in global libraries?",
    "created_at": "2017-03-24T02:14:57Z",
    "closed_at": "2017-04-27T19:55:46Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/14831",
    "body": "let's say I have a project use both `jest` & `jasmine` for test purpose.when I install them the tsc compiler report duplicate identifiers.I try to find issues to solve my problem,but never success.for examples:\r\n-  in spec directory I want to use jasmine\r\n\r\n```ts\r\n///<reference types=\"jasmine\"/>\r\ndescribe(\"jasmine tests\",...);\r\n```\r\n\r\n-  in test directory I want to use jest\r\n\r\n```ts\r\n///<reference types=\"jest\"/>\r\ndescribe(\"jest tests\",...);\r\n```",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/14831/comments",
    "author": "holi-java",
    "comments": [
      {
        "user": "ghost",
        "created_at": "2017-03-24T14:38:40Z",
        "body": "You could use separate tsconfigs for spec/test."
      }
    ]
  },
  {
    "number": 14763,
    "title": "Readonly tuple function",
    "created_at": "2017-03-21T13:24:08Z",
    "closed_at": "2017-03-21T15:34:18Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/14763",
    "body": "I want to create a function that returns a tuple with literal types.\r\n\r\nHere is what I got with TS 2.2:\r\n\r\n``` ts\r\nconst tuple2 = <A, B>(tuple: Readonly<[A, B]>): Readonly<[A, B]> => tuple\r\ntuple2(['foo', 'bar']) // actual Readonly<[string, string]>, expected Readonly<['foo', 'bar']>\r\n```\r\n\r\nIs there any way to make this return literal types?",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/14763/comments",
    "author": "OliverJAsh",
    "comments": [
      {
        "user": "zpdDG4gta8XKpMCd",
        "created_at": "2017-03-21T13:49:58Z",
        "body": "```typescript\r\nconst tuple2 = <A extends string, B extends string>(tuple: Readonly<[A, B]>): Readonly<[A, B]> => tuple\r\ntuple2(['foo', 'bar']) // Readonly<['foo', 'bar']>\r\n```"
      },
      {
        "user": "gcnew",
        "created_at": "2017-03-21T15:23:58Z",
        "body": "I've defined a `Literal` type alias. This way the function can accept all literal values and treat them as such.\r\n\r\n```ts\r\ntype Literal = boolean | string | number | null | undefined | object;\r\n\r\nfunction pair<L extends Literal, R extends Literal>(l: L, r: R): [L, R] {\r\n    return [l, r]\r\n}\r\n\r\npair(1, 'hello');            // [1, 'hello']\r\npair(true, false);           // [true, false]\r\npair([1, 2, 3], { a: 'a' })  // [number[], { a: string }]\r\npair(/test/, 'value')        // [RegExp, 'value']\r\npair(null, undefined)        // [null, undefined]\r\n```\r\n"
      },
      {
        "user": "OliverJAsh",
        "created_at": "2017-03-21T15:34:18Z",
        "body": "Thanks all!"
      }
    ]
  },
  {
    "number": 14705,
    "title": "static types checking not working properly when retrieving values from the array",
    "created_at": "2017-03-17T14:08:35Z",
    "closed_at": "2017-04-19T18:54:34Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/14705",
    "body": "**TypeScript Version:**  2.2.1 \r\n\r\n**Code**\r\n\r\n```ts\r\nvar values :any[] =[\"a\", \"b\", 1 ,2, true, false];\r\n\r\nvar fname :number =values[0];\r\n\r\nconsole.log(typeof(fname));\r\n```\r\n\r\n**Expected behavior:**\r\n\r\nfname reports compile error as value[0] is a string and variable fname should has only numbers\r\n\r\n**Actual behavior:**\r\nfname set string value to number variable\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/14705/comments",
    "author": "abdooay",
    "comments": [
      {
        "user": "aluanhaddad",
        "created_at": "2017-03-17T15:06:53Z",
        "body": "> values[0] is a string\r\n\r\nNo it is not, it is `any` because you said it was.\r\n\r\nSo firstly, avoid writing `any`, secondly don't annotate everything, and lastly the Angular 2 tutorials/examples are not a good way to learn TypeScript.\r\n\r\nI mention the Angular 2 tutorials/examples because I don't see this kind of code coming from anywhere else, but I do so see it used there and hence on every stack overflow question about Angular 2. It is awful.\r\n\r\nI just don't understand why someone would write\r\n```ts\r\nvar values :any[] =[\"a\", \"b\", 1 ,2, true, false];\r\n```\r\nIt is basically like writing the following C# (in terms of static type checking)\r\n```c#\r\ndynamic[] numbers = { 1, 2, 3 };\r\n```"
      }
    ]
  },
  {
    "number": 14687,
    "title": "TS2300: Duplicate identifier",
    "created_at": "2017-03-16T13:22:43Z",
    "closed_at": "2017-04-21T16:30:50Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/14687",
    "body": "**TypeScript Version:**  2.2.1\r\n\r\n```\r\n{\r\n\t\"compilerOptions\": {\r\n\t\t\"typeRoots\": [\r\n\t\t\t\"./node_modules/@types\",\r\n\t\t\t\"./types\"\r\n\t\t],\r\n\r\n\t\t\"outDir\": \"cache/\",\r\n\r\n\t\t\"types\": [\r\n\t\t\t\"debug\",\r\n\t\t\t\"deepmerge\",\r\n\t\t\t\"imap\",\r\n\t\t\t\"faker\",\r\n\t\t\t\"minimist\",\r\n\t\t\t\"mocha\",\r\n\t\t\t\"nodemailer\",\r\n\t\t\t\"node\",\r\n\t\t\t\"request\",\r\n\t\t\t\"webdriverio\"\r\n\t\t],\r\n\r\n\t\t\"lib\": [\r\n\t\t\t\"es2017\",\r\n\t\t\t\"scripthost\",\r\n\t\t\t\"webworker\",\r\n\t\t\t\"dom\"\r\n\t\t],\r\n\r\n\t\t\"target\": \"es2017\",\r\n\t\t\"module\": \"commonjs\",\r\n\t\t\"moduleResolution\": \"node\",\r\n\t\t\"noImplicitAny\": false,\r\n\r\n\t\t\"declaration\": false,\r\n\t\t\"allowJs\": true,\r\n\r\n\t\t\"emitDecoratorMetadata\": true,\r\n\t\t\"experimentalDecorators\": true,\r\n\t\t\"sourceMap\": true\r\n\t},\r\n\r\n\t\"exclude\": [\r\n\t\t\"./config.js\",\r\n\t\t\"./config.local.js\",\r\n\t\t\"./node_modules\",\r\n\t\t\"./utils\",\r\n\t\t\"./tasks\",\r\n\t\t\"./files\",\r\n\t\t\"./cache\"\r\n\t]\r\n}\r\n```\r\n\r\n```\r\n➜ tsc\r\n/usr/local/lib/node_modules/typescript/lib/lib.dom.d.ts(14171,14): error TS2300: Duplicate identifier 'EventListenerOrEventListenerObject'.\r\n/usr/local/lib/node_modules/typescript/lib/lib.dom.d.ts(14897,6): error TS2300: Duplicate identifier 'AlgorithmIdentifier'.\r\n/usr/local/lib/node_modules/typescript/lib/lib.dom.d.ts(14898,6): error TS2300: Duplicate identifier 'BodyInit'.\r\n/usr/local/lib/node_modules/typescript/lib/lib.dom.d.ts(14920,6): error TS2300: Duplicate identifier 'IDBKeyPath'.\r\n/usr/local/lib/node_modules/typescript/lib/lib.dom.d.ts(14929,6): error TS2300: Duplicate identifier 'RequestInfo'.\r\n/usr/local/lib/node_modules/typescript/lib/lib.dom.d.ts(14930,6): error TS2300: Duplicate identifier 'USVString'.\r\n/usr/local/lib/node_modules/typescript/lib/lib.dom.d.ts(14934,6): error TS2300: Duplicate identifier 'IDBValidKey'.\r\n/usr/local/lib/node_modules/typescript/lib/lib.dom.d.ts(14935,6): error TS2300: Duplicate identifier 'BufferSource'.\r\n/usr/local/lib/node_modules/typescript/lib/lib.webworker.d.ts(72,5): error TS2403: Subsequent variable declarations must have the same type.  Variable 'source' must be of type 'Window', but here has type 'any'.\r\n/usr/local/lib/node_modules/typescript/lib/lib.webworker.d.ts(367,5): error TS2375: Duplicate number index signature.\r\n/usr/local/lib/node_modules/typescript/lib/lib.webworker.d.ts(398,14): error TS2403: Subsequent variable declarations must have the same type.  Variable 'srcElement' must be of type 'Element', but here has type 'any'.\r\n/usr/local/lib/node_modules/typescript/lib/lib.webworker.d.ts(446,5): error TS2375: Duplicate number index signature.\r\n/usr/local/lib/node_modules/typescript/lib/lib.webworker.d.ts(715,14): error TS2403: Subsequent variable declarations must have the same type.  Variable 'source' must be of type 'Window', but here has type 'any'.\r\n/usr/local/lib/node_modules/typescript/lib/lib.webworker.d.ts(1096,14): error TS2403: Subsequent variable declarations must have the same type.  Variable 'responseXML' must be of type 'Document', but here has type 'any'.\r\n/usr/local/lib/node_modules/typescript/lib/lib.webworker.d.ts(1684,14): error TS2300: Duplicate identifier 'EventListenerOrEventListenerObject'.\r\n/usr/local/lib/node_modules/typescript/lib/lib.webworker.d.ts(1710,13): error TS2403: Subsequent variable declarations must have the same type.  Variable 'onmessage' must be of type '(this: Window, ev: MessageEvent) => any', but here has type '(this: DedicatedWorkerGlobalScope, ev: MessageEvent) => any'.\r\n/usr/local/lib/node_modules/typescript/lib/lib.webworker.d.ts(1715,13): error TS2403: Subsequent variable declarations must have the same type.  Variable 'location' must be of type 'Location', but here has type 'WorkerLocation'.\r\n/usr/local/lib/node_modules/typescript/lib/lib.webworker.d.ts(1716,13): error TS2403: Subsequent variable declarations must have the same type.  Variable 'onerror' must be of type 'ErrorEventHandler', but here has type '(this: DedicatedWorkerGlobalScope, ev: ErrorEvent) => any'.\r\n/usr/local/lib/node_modules/typescript/lib/lib.webworker.d.ts(1718,13): error TS2403: Subsequent variable declarations must have the same type.  Variable 'self' must be of type 'Window', but here has type 'WorkerGlobalScope'.\r\n/usr/local/lib/node_modules/typescript/lib/lib.webworker.d.ts(1724,13): error TS2403: Subsequent variable declarations must have the same type.  Variable 'navigator' must be of type 'Navigator', but here has type 'WorkerNavigator'.\r\n/usr/local/lib/node_modules/typescript/lib/lib.webworker.d.ts(1743,6): error TS2300: Duplicate identifier 'AlgorithmIdentifier'.\r\n/usr/local/lib/node_modules/typescript/lib/lib.webworker.d.ts(1744,6): error TS2300: Duplicate identifier 'BodyInit'.\r\n/usr/local/lib/node_modules/typescript/lib/lib.webworker.d.ts(1745,6): error TS2300: Duplicate identifier 'IDBKeyPath'.\r\n/usr/local/lib/node_modules/typescript/lib/lib.webworker.d.ts(1746,6): error TS2300: Duplicate identifier 'RequestInfo'.\r\n/usr/local/lib/node_modules/typescript/lib/lib.webworker.d.ts(1747,6): error TS2300: Duplicate identifier 'USVString'.\r\n/usr/local/lib/node_modules/typescript/lib/lib.webworker.d.ts(1748,6): error TS2300: Duplicate identifier 'IDBValidKey'.\r\n/usr/local/lib/node_modules/typescript/lib/lib.webworker.d.ts(1749,6): error TS2300: Duplicate identifier 'BufferSource'.\r\n```\r\n\r\nI see these errors with `lib.webworker`",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/14687/comments",
    "author": "monolithed",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2017-03-16T15:26:10Z",
        "body": "You can't target `webworker` and `dom` at the same time -- these are mutually exclusive, and have different types for certain global variables. You'll need two separate compilations, one for the code which runs in your webworker threads, and one for code which runs in the DOM"
      },
      {
        "user": "monolithed",
        "created_at": "2017-03-16T18:58:54Z",
        "body": "@RyanCavanaugh, I got it, thanks! Could you show such errors not like a stack trace?"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2017-03-16T19:40:29Z",
        "body": "Not sure what you mean?"
      },
      {
        "user": "monolithed",
        "created_at": "2017-03-16T20:14:59Z",
        "body": "```\r\n/usr/local/lib/node_modules/typescript/lib/lib.dom.d.ts(14171,14): error TS2300: Duplicate identifier 'EventListenerOrEventListenerObject'.\r\n```\r\n\r\nUsually such error messages are not informative. It would be nice to print something like:\r\n\r\n> You can't target webworker and dom at the same time -- these are mutually exclusive, and have different types for certain global variables. You'll need two separate compilations, one for the code which runs in your webworker threads, and one for code which runs in the DOM\r\n\r\n😉"
      }
    ]
  },
  {
    "number": 14651,
    "title": "Path resolution after build",
    "created_at": "2017-03-14T15:36:55Z",
    "closed_at": "2017-03-15T22:45:54Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/14651",
    "body": "Hi there,\r\n\r\nThis is my problem : I use Path resolution in my TypeScript app like this => \r\n\r\n```\r\n{\r\n  \"compilerOptions\": {\r\n    \"module\": \"commonjs\",\r\n    \"target\": \"es5\",\r\n    \"pretty\": true,\r\n    \"outDir\": \"./build\",\r\n    \"baseUrl\": \".\",\r\n    \"paths\": {\r\n      \"Internal/*\": [\"./src/*\"]\r\n    }\r\n  }\r\n}\r\n```\r\n\r\nAnd when i import my module i write that => \r\n\r\n```\r\nimport * as Interfaces from 'Internal/Interfaces';\r\n```\r\n\r\nMy problem is, when i build my project with the tsc command, i can execute my js native file because import path are the same ! So, i have forgot something or ???\r\n\r\nThanks!",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/14651/comments",
    "author": "jonathanroze",
    "comments": [
      {
        "user": "vladima",
        "created_at": "2017-03-14T18:19:31Z",
        "body": "not sure that  I understand the problem correctly. Path mappings were introduced to address the issue with flexible module loading in runtime when loader can map module id from the source code to a physical file using some additional configuration (i.e. via `paths` section in SystemJS or RequireJs). Module imports are never altered by the compiler - it assumes that whatever was written by user is correct and will apply`baseUrl`, `paths` and `rootDirs` to map this module id to a file to be used as type infor for module in design time."
      },
      {
        "user": "jonathanroze",
        "created_at": "2017-03-14T18:29:30Z",
        "body": "@vladima  Mhhh ok i understand but, when i compile my code how can i change this path by absolute path ? :/ ! "
      },
      {
        "user": "mhegazy",
        "created_at": "2017-03-14T19:05:53Z",
        "body": "Presumablly you have a babel-plugin or some post-build script that updates the reference. the setting here is just to \"tell\" the compiler what happens at build time."
      },
      {
        "user": "jonathanroze",
        "created_at": "2017-03-14T20:20:46Z",
        "body": "Ok great ! Thanks for your help :-)"
      }
    ]
  },
  {
    "number": 14650,
    "title": "When using the native method 'defineProperty ' to define a 'Getter' for a class, the compiler error!",
    "created_at": "2017-03-14T11:31:17Z",
    "closed_at": "2017-04-21T16:40:50Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/14650",
    "body": "**TypeScript Version:**  1.8.0\r\n\r\n**Code:**\r\n\r\n```ts\r\n// a function used to define targetObject's descriptor from SourceObject's properties\r\n\r\nfunction defineGetter(SourceObject, targetObject) {\r\n    \r\n    Object.keys(SourceObject).forEach(function (key) {\r\n        Object.defineProperty(targetObject.prototype, key, {\r\n            get: function () {\r\n                return SourceObject[key]\r\n            },\r\n            enumerable: true,\r\n            configurable: true\r\n        })\r\n    })\r\n}\r\n\r\ninterface IForm {\r\n    name: string;\r\n    label: string;\r\n    value: any;\r\n    sequence: number;\r\n    width: number;\r\n    type: number;\r\n}\r\n\r\n\r\nclass Form {\r\n    constructor(form: IForm) {\r\n        defineGetter(form, Form);\r\n    }\r\n    get info() {\r\n        return `name is ${this.name}, label is ${this.label}`;\r\n    }\r\n}\r\n\r\nlet form = new Form({\r\n       name: '1',\r\n       label: '2',\r\n       value: 3,\r\n       sequence: 4,\r\n       width: 5,\r\n       type: 6\r\n})\r\n```\r\n\r\n\r\n\r\n**Expected behavior & Actual behavior:**\r\nI want to complete my definition of **Getter** with metadata(a Singleton Object) through a **defineGetter ()** method, It seems to be successful. but, When I manually define another Getter (info), the compiler prompts：\r\n\r\n> “ error TS2339: Property 'name' does not exist on type 'Form'”\r\n> “  error TS2339: Property 'type' does not exist on type 'Form'. ”\r\n\r\nI just want to use a function to solve my burden of writing the getter repeatedly，How can I solve this problem?\r\n\r\n\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/14650/comments",
    "author": "ulivz",
    "comments": [
      {
        "user": "ulivz",
        "created_at": "2017-03-14T12:05:39Z",
        "body": "How can I only write a class in this way 😐:\r\n```ts\r\nclass Form{\r\n\r\n    private _form: IForm;\r\n\r\n    constructor(form: IForm) {\r\n        this._form = form;\r\n    }\r\n\r\n    get name() {\r\n        return this._form.name;\r\n    }\r\n\r\n    get label() {\r\n        return this._form.name;\r\n    }\r\n\r\n    get value() {\r\n        return this._form.value;\r\n    }\r\n    \r\n    get width() {\r\n        return this._form.width;\r\n    }\r\n    \r\n    get type() {\r\n        return this._form.type;\r\n    }\r\n    \r\n    get sequence() {\r\n        return this._form.sequence;\r\n    }\r\n\r\n    // extra getter\r\n    get info() {\r\n        return this.width + this.type;\r\n    }\r\n\r\n}\r\n```"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2017-03-14T18:13:57Z",
        "body": "Write this:\r\n```ts\r\nclass Form {\r\n    constructor(form: IForm) {\r\n        defineGetter(form, Form);\r\n    }\r\n    get info() {\r\n        return `name is ${this.name}, label is ${this.label}`;\r\n    }\r\n}\r\ninterface Form extends IForm { }\r\n```"
      },
      {
        "user": "ulivz",
        "created_at": "2017-03-15T06:33:05Z",
        "body": "Can the name of interface and class be the same name? well, I didn‘t write it before. Just wrote a simple `interface inheritance`"
      },
      {
        "user": "kitsonk",
        "created_at": "2017-03-15T10:07:21Z",
        "body": "> Can the name of interface and class be the same name?\r\n\r\nIt takes advantage of what TypeScript calls \"interface merging\".  When an interface and a class have the same name, it automatically merges the two.  This is in part why it is often recommended not to name your interfaces with an `I...` which is a convention in many other languages, since there some \"automagic\" that can happen when the names are the same.\r\n\r\nIt is best to think as the type system in TypeScript as an \"overlay\" on top of the underlying JavaScript.\r\n\r\nAlso to properly type your interface, you should be marking properties that only have a getter as `readonly` in the interface, which will disallow assignment to the properties within the type system, which would more accurately reflect your runtime intent."
      }
    ]
  },
  {
    "number": 14647,
    "title": "lib/lib.d.ts error  Cannot find name 'object'.",
    "created_at": "2017-03-14T09:38:33Z",
    "closed_at": "2017-03-15T06:17:39Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/14647",
    "body": "**TypeScript Version:**  2.2.1 \r\n\r\nusing gulp typescript with latest version 2.2.1 of typescript throws errors:\r\n\r\n```\r\ntypescript/lib/lib.d.ts(163,15): error TS2304: Cannot find name 'object'.\r\ntypescript/lib/lib.d.ts(170,15): error TS2304: Cannot find name 'object'.\r\n```\r\n\r\n**Expected behavior:**\r\nCompile without errors\r\n\r\n**Actual behavior:**\r\n```\r\ntypescript/lib/lib.d.ts(163,15): error TS2304: Cannot find name 'object'.\r\ntypescript/lib/lib.d.ts(170,15): error TS2304: Cannot find name 'object'.\r\n```\r\n\r\n-> renaming the lines to the following (just changed object to Object) solves the compile error\r\n\r\n```\r\ncreate(o: Object | null): any;\r\n\r\n    /**\r\n      * Creates an object that has the specified prototype, and that optionally contains specified properties.\r\n      * @param o Object to use as a prototype. May be null\r\n      * @param properties JavaScript object that contains one or more property descriptors.\r\n      */\r\n    create(o: Object | null, properties: PropertyDescriptorMap): any;\r\n```",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/14647/comments",
    "author": "Skuriles",
    "comments": [
      {
        "user": "ghost",
        "created_at": "2017-03-14T15:48:52Z",
        "body": "`object` is a keyword in TS2.2. Is it possible you're compiling with a different version than the version you get `lib` from?"
      },
      {
        "user": "Skuriles",
        "created_at": "2017-03-15T06:17:39Z",
        "body": "I found some errors in my package,json (double entries in dev and \"normal\" dependencies) -> fixed it and re-installed all packages -> seems to work now.\r\nThanks for the hint"
      },
      {
        "user": "DenisCarriere",
        "created_at": "2017-05-01T19:40:04Z",
        "body": "👍 Thanks @andy-ms "
      }
    ]
  },
  {
    "number": 14643,
    "title": "bugs:strange primitive types",
    "created_at": "2017-03-14T03:29:56Z",
    "closed_at": "2017-05-19T16:47:55Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/14643",
    "body": "Hi,when I use `reflect-metadata` module the primitive is horrifying.if compile the .ts into .js,that every thing run fine and fetch the variable types correctly except Foo,but I runs tests in typescript with different result.they are `Object` instead.I could use `string`,`boolean`,`number`,but there is not a `Date` primitive type.\r\n\r\n\r\n```ts\r\nfunction Test(matcher: Matcher<any>) {\r\n    return function (target: any, key: string): void {\r\n        let type = Reflect.getOwnMetadata('design:type', target, key);\r\n\r\n        test(`${target.constructor.name} ${key}'s type should ${matcher.description}!`, () => {\r\n            expect(matcher.test(type)).toBe(true);\r\n        });\r\n    }\r\n}\r\n\r\nclass ReflectMetadataTest {\r\n    // this test always false even if you compile .ts it into .js file\r\n    @Test(DeclaredType.not.is(Foo/*ref function*/)) foo: Foo/*ref interface*/;\r\n\r\n    //this test is true when you c om pile .ts it into .js file\r\n    @Test(DeclaredType.not.is(Date)) Date: Date;\r\n    @Test(DeclaredType.not.is(String)) String: String;\r\n    @Test(DeclaredType.not.is(Number)) Number: Number;\r\n    @Test(DeclaredType.not.is(Boolean)) Boolean: Boolean;\r\n\r\n    //this test is always true both in .ts & .js\r\n    @Test(DeclaredType.is(String)) string: string;\r\n    @Test(DeclaredType.is(Number)) number: number;\r\n    @Test(DeclaredType.is(Boolean)) boolean: boolean;\r\n    @Test(DeclaredType.is(MyDate)) myDate: MyDate;\r\n    @Test(DeclaredType.is(ReflectMetadataTest)) test: ReflectMetadataTest;\r\n}\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/14643/comments",
    "author": "holi-java",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2017-04-27T17:09:03Z",
        "body": "The reflect metadata tries to represent types at design time at runtime. This is a lossy processes by definition, since there are types that only exist in design time (e.g. interfaces, type aliases, etc..).\r\n\r\nThe way this works is for primitives, the boxed values are uses to serialize them:\r\n* `number` => `Number`\r\n* `string` => `String`\r\n* `boolean` => `Boolean`\r\n* `object` => `Object`\r\n* Arrays are always serialized to `Array`\r\n* Classes will be serialized as themselves, since they do exist at run time\r\n* function types will be serialized as `Function`\r\n* Everything else will be serialized as `Object`\r\n\r\nHope this answers your question."
      },
      {
        "user": "mhegazy",
        "created_at": "2017-05-19T16:47:54Z",
        "body": "Automatically closing this issue for housekeeping purposes. The issue labels indicate that it is unactionable at the moment or has already been addressed."
      }
    ]
  },
  {
    "number": 14627,
    "title": "how can i type-annotate a function that creates an object literal out of a literal key and a value?",
    "created_at": "2017-03-13T11:38:44Z",
    "closed_at": "2017-03-13T15:56:49Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/14627",
    "body": "i have\r\n```typescript\r\nconst key: 'name' = 'name';\r\nconst value: number = 1;\r\n```\r\n\r\ni need a function that turns these key/value into an object with a property, in JavaScript it would look like:\r\n```javascript\r\n// javascript\r\nfunction(key, value) {\r\n    return { [key]: value };\r\n}\r\n```\r\n\r\nso that:\r\n```typescript\r\nconst data = fn(key, value);\r\n// data is expected to be of type: { name: number; }\r\n```\r\n\r\nis there a way to type-annotate `fn` so that it returns an object of type `{ name: number; }`? if so, how?\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/14627/comments",
    "author": "zpdDG4gta8XKpMCd",
    "comments": [
      {
        "user": "gcanti",
        "created_at": "2017-03-13T14:07:50Z",
        "body": "```ts\r\nfunction fn<K extends string, V>(key: K, value: V): { [k in K]: V } {\r\n  return { [key as any]: value } as any\r\n}\r\n```"
      },
      {
        "user": "zpdDG4gta8XKpMCd",
        "created_at": "2017-03-13T15:56:49Z",
        "body": "thanks, just what i needed"
      }
    ]
  },
  {
    "number": 14611,
    "title": "Suggestion: infer type based on first non-null-or-undefined assignment",
    "created_at": "2017-03-12T20:07:17Z",
    "closed_at": "2017-03-14T08:41:42Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/14611",
    "body": "It would be very convenient if types for variables were inferred based on the first non-null-or-undefined assignment to that variable rather than always based on initialisation. For example, it must be very common to write the following code.\r\n\r\n```ts\r\nlet result = null; //Or just let result;\r\ntry{\r\nresult = doSomethingThatMightFail();\r\n}catch(ex){}\r\nif(!result){\r\ndoOneThing(result);\r\n}else{\r\ndoAnother(result);\r\n}\r\n```\r\nCurrently the inferred type of result is any. However, it would be useful if it was the return type of doSomethingThatMightFail (which is often quite a complicated type in operations such as querying a database, so awkward to declare manually).\r\n\r\nThis would also apply to inference of function return types. For example the following must be an extremely common pattern.\r\n\r\n```ts\r\nfunction myFunc(input: MyClass){\r\n  if(!input){\r\n    return null;\r\n  }\r\n  //do some stuff which ends up declaring a variable called result \r\n  return result;\r\n}\r\n```\r\nIn this case it would be useful if the inferred return type of myFunc was the type of result, not any.\r\n\r\nI suppose when I say 'first' assignment here, the 'first' might be a bit unclear. It could just be the first non-null-or-undefined assignment that could possibly happen. If this it too difficult or not well-defined in general then it could apply only to a few simple cases to start with, such as the ones above.\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/14611/comments",
    "author": "benstevens48",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2017-03-13T00:59:06Z",
        "body": "This already works pretty well if you use `strictNullChecks`:\r\n```ts\r\ndeclare function doSomethingThatMightFail(): HTMLElement | undefined;\r\ndeclare function doOneThing(s: undefined): void;\r\ndeclare function doAnother(s: HTMLElement): void;\r\n\r\nlet result;\r\ntry {\r\n\tresult = doSomethingThatMightFail();\r\n} catch (ex) {\r\n}\r\nif (!result) {\r\n\tdoOneThing(result);\r\n} else {\r\n\tdoAnother(result);\r\n}\r\n```"
      },
      {
        "user": "benstevens48",
        "created_at": "2017-03-13T09:53:00Z",
        "body": "Hi @RyanCavanaugh ,\r\nThanks for the reply. I think maybe my example wasn't written very well. The functions doOneThing and doAnother were meant to be placeholders for that block's body rather than actual functions. A more complete example would be something like\r\n\r\n```ts\r\ndeclare function doSomethingThatMightFail(): HTMLElement;\r\n\r\nlet result = null; //or perhaps also just let result;\r\ntry {\r\n\tresult = doSomethingThatMightFail();\r\n} catch (ex) {\r\n}\r\nif (!result) {\r\n  console.log('something failed');\r\n} else {\r\n  result.innerHTML = 'test';\r\n}\r\n```\r\n\r\nThe point is I want to avoid having to manually write out the type of result anywhere. I'd also like my second example to work. I realise that this is in conflict with how you've defined null initialisation to work in strictNullChecks mode. \r\n\r\nI suppose what I'm asking for is some sort of type widening based on control flow analysis. Initially I said it should be based on the first non-null assignment, but maybe it could continue to widen the type based on possible assignments. I think it should only widen the type if one is a subtype of the other, or null or undefined, else you would lose any type checking.\r\n\r\nIt would also be useful if this worked for empty arrays `[]` as well as null and undefined.\r\n\r\nI actually use the `if(!input) return null` pattern as given in my second example in almost all my functions, which means I get no type inference for any of my function return types. I suppose maybe in the long run it's better to explicitly declare the return type, but often with client side code that changes a lot based on changing requirements putting in explicit types doesn't seem worth it, however it would still be really useful to have type checking.\r\n"
      },
      {
        "user": "aluanhaddad",
        "created_at": "2017-03-14T06:21:08Z",
        "body": "@benstevens48 You need to specify `--noImplicitAny` and `--strictNullChecks`. Under these settings, all of your examples work fine. Also, arrays work as you suggest."
      },
      {
        "user": "benstevens48",
        "created_at": "2017-03-14T08:41:42Z",
        "body": "Hi @aluanhaddad ,\r\nOh, Ok thanks. I hadn't been using noImplicityAny. Also, I think I might have been wrong about the second example anyway. It seems to work even without these settings in simple cases. \r\n\r\nThe problem I have with noImplicitAny is that I would end up typing a lot of stuff as any just to get it to work initially, then when I came back to look at it, it would look like I'd already typed it even though it was meant to be a quick fix. It might be useful if the above worked under less strict conditions, or I have another suggestion that would be pretty simple to implement. \r\n\r\nPerhaps add another type that has the same effect as any, but is meant to be used by the developer as a temporary measure before going back and putting a better type in. Then there could be a flag which would highlight any instances of this type as an error if turned on. Maybe I will add this as a separate suggestion."
      },
      {
        "user": "benstevens48",
        "created_at": "2017-03-17T19:41:55Z",
        "body": "Hi @aluanhaddad , @RyanCavanaugh ,\r\nI would like to make a small addendum to this issue.\r\n\r\nIn my second example above, about inferring the return type of a function, TypeScript correctly infers the type even without any flags. However, the reason why I got confused was a lot of my functions have the async modifier, and  if you add the async modifier then this is no longer the case. For example, given this code\r\n```ts\r\nasync function removeStart(input: string) {\r\n  if (!input) {\r\n    return null;\r\n  }\r\n  return input.substr(1);\r\n}\r\n```\r\nthe return type is inferred as `Promise<any>`, unless strictNullChecks is enabled in which case it correctly gives `Promise<string | null>`. \r\n\r\nSince the non-async version works even without strictNullChecks, would it be possible to make the async version work even without strictNullChecks as well?"
      }
    ]
  },
  {
    "number": 14609,
    "title": "Typescript Error No best common type exists among return expressions.",
    "created_at": "2017-03-12T13:48:38Z",
    "closed_at": "2017-04-21T16:40:51Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/14609",
    "body": "Hello, I feel like there is a bug here. please let me know :).\r\nA bit of class inception.\r\n\r\nThe principals:\r\nthe class Number is a CalcNode;\r\npush requires a CalcNode return;\r\npush local variable is a CalcNode;\r\n\r\nI have a multiple \"if\" condition with \"else\" at the end. It seems like a \"no condition\" return is attended.\r\n\r\n```\r\nTypescript Error\r\nNo best common type exists among return expressions.\r\nsrc/pages/calculator/engine/number.class.ts\r\n  push(new_value: CalcNode){\r\n    if(new_value.get_priority() === Priority.THREE){\r\n```\r\n\r\n```\r\nexport class Number implements CalcNode {\r\n  value: string = \"\";\r\n  priority: Priority = Priority.THREE;\r\n\r\n  constructor(new_value: string){\r\n    this.value = new_value;\r\n  }\r\n\r\n  get_priority(){\r\n    return this.priority;\r\n  }\r\n\r\n  push(new_value: CalcNode){\r\n    if(new_value.get_priority() === Priority.THREE){\r\n      this.value += \"\"+new_value.evaluate();\r\n      return this;\r\n    }\r\n    else if (new_value.get_priority() === Priority.ZERO){\r\n      var temp: CalcNode =  new Multiply();\r\n      temp.push(this);\r\n      temp.push(new Parenthese());\r\n      return temp;\r\n    }\r\n    else {\r\n      return new_value.push(this);\r\n    }\r\n  }\r\n```",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/14609/comments",
    "author": "ShouldIPressTheButton",
    "comments": [
      {
        "user": "kitsonk",
        "created_at": "2017-03-12T16:33:22Z",
        "body": "Try annotating your return of the method `push()`, because it will help highlight where the compiler is getting confused.  I suspect it is the circular logic in trying to identify the return type of `push()` that is causing it to be confused."
      },
      {
        "user": "ahejlsberg",
        "created_at": "2017-03-12T17:18:23Z",
        "body": "If you post a complete example we can take a look, however I don't think there is a bug here."
      },
      {
        "user": "halaproliu",
        "created_at": "2018-01-24T06:58:52Z",
        "body": "Hey, guys!I have the same problem when I use the following code!Please tell me how to fix this!Thx!`export default class Chain {\r\n    fn: any;\r\n    successor: any;\r\n    constructor (fn: any) {\r\n        this.fn = fn;\r\n        this.successor = null;\r\n    }\r\n\r\n    setNextSuccessor (successor: any) : any {\r\n        this.successor = successor;\r\n        return this.successor;\r\n    }\r\n\r\n    passRequest ():any {\r\n        let ret = this.fn.apply(this, arguments);\r\n        if (ret === 'nextSuccessor') {\r\n            return this.successor && this.successor.passRequest.apply(this.successor, arguments);\r\n        }\r\n    }\r\n}`"
      }
    ]
  },
  {
    "number": 14608,
    "title": "Unable to parameterize keyof (in function) to access object's fields",
    "created_at": "2017-03-12T13:05:47Z",
    "closed_at": "2017-03-12T17:17:39Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/14608",
    "body": "I'm having problems understanding how to parameterize **keyof**. I have extracted a simple code that describes the issue I'm facing.\r\n\r\n```ts\r\ninterface INested3 {\r\n    id: number;\r\n    name: string;\r\n}\r\n\r\ninterface INested2a {\r\n    id: number;\r\n    name: string;\r\n    nested3: INested3;\r\n}\r\n\r\ninterface INested2b {\r\n    id: number;\r\n    name: string;\r\n    nested3: INested3;\r\n}\r\n\r\ninterface INested1 {\r\n    id: number;\r\n    name: string;\r\n    nested2a: INested2a;\r\n    nested2b: INested2b;\r\n}\r\n\r\ninterface IFoo {\r\n    id: number;\r\n    name: string;\r\n    nested1: INested1;\r\n}\r\n\r\nfunction get<T, K1 extends keyof T, K2 extends keyof T[K1], K3 extends keyof T[K1][K2]>(obj: T, key1: K1, key2: K2, key3: K3): T[K1][K2][K3] {\r\n    return obj[key1][key2][key3];\r\n}\r\n\r\n// Fine\r\nfunction foo1a(f: IFoo): void {\r\n    console.log(\r\n        get(f, \"nested1\", \"nested2a\", \"nested3\")\r\n    );\r\n}\r\n\r\nfunction foo1b(f: IFoo): void {\r\n    console.log(\r\n        get(f, \"nested1\", \"nested2b\", \"nested3\")\r\n    );\r\n}\r\n\r\n// Not fine - why?\r\n// Argument of type '\"nested3\"' is not assignable to parameter of type '\"toString\" | \"valueOf\"'.\r\nfunction foo1param(f: IFoo, nested2key: keyof INested1): void {\r\n    console.log(\r\n        get(f, \"nested1\", nested2key, \"nested3\")\r\n    )\r\n}\r\n\r\nvar f: IFoo = {\r\n    id: 1,\r\n    name: \"Foo\",\r\n    nested1: {\r\n        id: 1,\r\n        name: \"Nested 1\",\r\n        nested2a: {\r\n            id: 1,\r\n            name: \"Nested 2A\",\r\n            nested3: {\r\n                id: 1,\r\n                name: \"Nested 3\",\r\n            }\r\n        },\r\n        nested2b: {\r\n            id: 1,\r\n            name: \"Nested 2B\",\r\n            nested3: {\r\n                id: 2,\r\n                name: \"Nested 3\",\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// Would like to use it like this\r\nfoo1param(f, \"nested2a\");\r\nfoo1param(f, \"nested2b\");\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/14608/comments",
    "author": "vladimir-djokic",
    "comments": [
      {
        "user": "ahejlsberg",
        "created_at": "2017-03-12T17:11:54Z",
        "body": "In your example, `keyof INested1` is equivalent to `\"id\" | \"name\" | \"nested2a\" | \"nested2b\"` (the full set of property names for `INested1`). You need to restrict it to just `\"nested2a\" | \"nested2b\"`:\r\n\r\n```ts\r\nfunction foo1param(f: IFoo, nested2key: \"nested2a\" | \"nested2b\"): void { ... }\r\n```\r\n\r\nOnce you do that your example works."
      },
      {
        "user": "vladimir-djokic",
        "created_at": "2017-03-12T17:17:39Z",
        "body": "I understand now, thank you! I guess this was a classic case of _\"can't see the forest for the trees\"_."
      }
    ]
  },
  {
    "number": 14352,
    "title": "String not assignable to string enum even when value is known at compile time and is part of the enum.",
    "created_at": "2017-02-28T03:27:45Z",
    "closed_at": "2017-03-01T04:02:00Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/14352",
    "body": "Typescript@2.1.6\r\n\r\nHere's an example:\r\n\r\n```\r\ninterface Test {\r\n    fun(opts: {foo: 'enum1' | 'enum2'}): void\r\n}\r\n\r\nconst bar: Test = {\r\n    fun: (opts) => { }\r\n}\r\n\r\nconst defaults = {\r\n    foo: 'enum1'\r\n};\r\n\r\nbar.fun(defaults) // Error: Type 'string' is not assignable to type '\"enum1\" | \"enum2\"'\r\n```\r\n\r\nShouldn't `defaults.foo` be inferred to be a subset of the string enum?",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/14352/comments",
    "author": "realyze",
    "comments": [
      {
        "user": "realyze",
        "created_at": "2017-02-28T03:28:35Z",
        "body": "FWIW, `bar.fun({foo: 'enum1'})` compiles OK."
      },
      {
        "user": "realyze",
        "created_at": "2017-02-28T03:30:34Z",
        "body": "I would suggest `defaults` type to be inferred as `{ foo: string & 'enum1' }` rather than `string`."
      },
      {
        "user": "Jessidhia",
        "created_at": "2017-02-28T04:39:12Z",
        "body": "Note that `defaults.foo` is mutable, so the inferred type has to be `string`; otherwise it would prevent you from ever mutating it. Using `&` is even more dangerous as, if you _did_ mutate it, the `& 'enum1'` part of the type would make its type be `'enum1'` even if it was any other value.\r\n\r\nYou probably want something similar to this, probably with an `interface` or `type` alias to avoid repetition:\r\n\r\n```ts\r\nconst defaults: { foo: 'enum1' | 'enum2' } = {\r\n  foo: 'enum1'\r\n}\r\n```"
      },
      {
        "user": "realyze",
        "created_at": "2017-03-01T04:01:59Z",
        "body": "@Kovensky Right, hmm, yeah that does make sense. I'll close this. Thanks!"
      },
      {
        "user": "ubershmekel",
        "created_at": "2017-08-14T23:48:36Z",
        "body": "Going to leave the answer to my case here because google brought me to this issue:\r\n\r\n    import * as isomorphicFetch from \"isomorphic-fetch\";\r\n    const fetchOptions: isomorphicFetch.RequestInit = {\r\n        method: \"POST\",\r\n        body: JSON.stringify(body),\r\n        headers: headers,\r\n        // required for cookies in ajax\r\n        \"credentials\": \"include\",\r\n    };\r\n    let response = await isomorphicFetch(url, fetchOptions);\r\n\r\nCaused this error:\r\n\r\n```\r\nfile: 'file:///Users/backend/packages/nuxt-typescript/lib/api.ts'\r\nseverity: 'Error'\r\nmessage: 'Argument of type '{ method: string; headers: { \"Content-Type\": string; }; \"credentials\": string; }' is not assignable to parameter of type 'RequestInit | undefined'.\r\n  Type '{ method: string; headers: { \"Content-Type\": string; }; \"credentials\": string; }' is not assignable to type 'RequestInit'.\r\n    Types of property 'credentials' are incompatible.\r\n      Type 'string' is not assignable to type '\"include\" | \"omit\" | \"same-origin\" | undefined'.'\r\nat: '120,51'\r\nsource: 'ts'\r\n```\r\n\r\nSolved by:\r\n\r\n    let fetchOptions: RequestInit = {\r\n\r\n"
      },
      {
        "user": "ZelphirKaltstahl",
        "created_at": "2017-12-22T10:58:21Z",
        "body": "It seems like `tsc` does not consider `string`s like `\"cors\"` or `\"default\"` to be of the types `RequestMode` or `RequestCache`, unless one adds the type declaration as @ubershmekel did in their answer."
      }
    ]
  },
  {
    "number": 14321,
    "title": "locally modifying+testing published definitions is a pain (bug/rant/perhaps-question)",
    "created_at": "2017-02-26T19:56:07Z",
    "closed_at": "2017-04-21T13:50:25Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/14321",
    "body": "the ```@types``` process is pretty great for consuming .d.ts files (much better than the previous typings or tsd workflows)   \r\n\r\nhowever, I seem to have a big problem as a creator of ```.d.ts``` for publication.    I don't see any way of creating a .d.ts file for local use and testing, and then be able to then publish the file as-is.   \r\n\r\nFor example, if this is a definition I publish to DT:  \r\n\r\n```foo/index.d.ts```:\r\n`\r\ndeclare namespace Foo{ export function foo():void; }\r\nexport = Foo;\r\nexport as namespace Foo;\r\n`\r\n\r\nand usage:\r\n`\r\nimport foo = require(\"foo\");\r\n`\r\n\r\n\r\nHow would I consume my own definitions for ```foo``` locally?  I don't see how to do this with the normal import style.  instead I need to modify my d.ts and consumption usage like:\r\n\r\n```myProject/_dts/foo.ts```\r\n`\r\nexport declare namespace _foo{ export function foo():void; }\r\nexport const Foo: typeof _foo = require(\"foo\");\r\n`\r\nand usage:\r\n`\r\nimport foo = require(\"./_dts/foo\");\r\n`\r\n\r\nBasically this means that I can't easily test and/or modify a definition that I want to share publically, which adds a lot of friction for re-contributing to the community.   Am I doing something wrong?  Is there an easy way to modify and locally reference a published type?\r\n\r\n\r\n\r\n**Note**: I don't know if i'm doing it wrong these days, so please correct my understanding if you see problems with my logic above.\r\n\r\n\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/14321/comments",
    "author": "jasonswearingen",
    "comments": [
      {
        "user": "jasonswearingen",
        "created_at": "2017-02-27T19:42:50Z",
        "body": "by the way, pre ```@types``` I published perhaps 10 ```d.ts``` on DefinitelyTyped, but based on the issues described in my above rant the friction to publish+maintain typings is too great, so I just write definitions for private use.   \r\n\r\nbasically from a consumption standpoint, ```@types``` is great, but from a producer's perspective it is worse than the previous DT ```tsd``` model."
      },
      {
        "user": "mhegazy",
        "created_at": "2017-02-27T21:49:02Z",
        "body": "> How would I consume my own definitions for foo locally? I don't see how to do this with the normal import style. instead I need to modify my d.ts and consumption usage like:\r\n\r\nLet's say you want to write defintions for `foo`, which is a module:\r\n- under your app: `src\\extra-types\\foo`, create `index.d.ts` that has your declaration as noted above (along with tsconfig.json, tslint.json, and tests for DT if you want). \r\n- in your `tsconfig.json` add a path mapping rule: \r\n ```js\r\n{\r\n     ...\r\n    \"paths\": {\r\n       \"foo\" : [\"src/extra-types/foo\"]\r\n    }\r\n}\r\n  ```\r\n  or if you have multiple:\r\n  ```js\r\n{\r\n     ...\r\n    \"paths\": {\r\n       \"*\" : [ \"*\", \"src/extra-types/*\"]\r\n    }\r\n}\r\n  ```\r\n- once you have published to DT, delete `src\\extra-types\\foo` and add `@types/foo`, no other changes should be required.\r\n"
      },
      {
        "user": "jasonswearingen",
        "created_at": "2017-04-21T13:50:25Z",
        "body": "ok thank you for those details.  I finally got around to writing a new definition and see that your info works.\r\n\r\nare those in the docs somewhere?\r\n"
      }
    ]
  },
  {
    "number": 14220,
    "title": "tsc -m system: a module with no exports doesn't generate a system module",
    "created_at": "2017-02-22T00:59:22Z",
    "closed_at": "2017-04-21T16:55:43Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/14220",
    "body": "Given these files:\r\n\r\n```ts\r\n// a.ts: \r\nconst a = 1\r\n\r\n// b.ts:\r\nexport const b = 1\r\n```\r\n\r\nIf you run `tsc -m system a.ts` and `tsc -m system b.ts` you get:\r\n\r\n```js\r\n// a.js:\r\nvar a = 1;\r\n\r\n// b.js:\r\nSystem.register([], function (exports_1, context_1) {\r\n    \"use strict\";\r\n    var __moduleName = context_1 && context_1.id;\r\n    var b;\r\n    return {\r\n        setters: [],\r\n        execute: function () {\r\n            exports_1(\"b\", b = 1);\r\n        }\r\n    };\r\n});\r\n```\r\n\r\nSo, a file with no exports (or imports) doesn't generate a system module. I don't think this is right, but if this is not a bug but the expected behavior, what's the rationale?\r\n\r\n**TypeScript Version:**  Version 2.3.0-dev.20170221\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/14220/comments",
    "author": "nahuel",
    "comments": [
      {
        "user": "DanielRosenwasser",
        "created_at": "2017-02-22T01:05:59Z",
        "body": "This is working as intended, though I agree that it is extremely frustrating - the idea is that there are some cases where you'd like to have global code along with your modules (for instance, any calls to `System.config`.\r\n\r\nYou can get around this with an `export {};`"
      }
    ]
  },
  {
    "number": 14206,
    "title": "Ternary results consider both branches even when boolean literal values make one impossible",
    "created_at": "2017-02-21T16:18:38Z",
    "closed_at": "2017-04-24T20:38:28Z",
    "labels": [
      "Question",
      "Working as Intended"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/14206",
    "body": "**TypeScript Version:**  2.3.0-dev.20170217\r\n\r\n**Code**\r\n\r\n```ts\r\nconst aOrB = true ? 'a' : 'B';\r\nconst a: 'a' = aOrB;\r\n```\r\n\r\n**Expected behavior:**\r\nCompiles without error.\r\n\r\n**Actual behavior:**\r\n>Type '\"a\" | \"B\"' is not assignable to type '\"a\"'.\r\n>  Type '\"B\"' is not assignable to type '\"a\"'.",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/14206/comments",
    "author": "krryan",
    "comments": [
      {
        "user": "vladima",
        "created_at": "2017-02-21T16:34:17Z",
        "body": "Currently reachability analysis in compiler works on the statement level which has a good rationale: it is pretty common to have code like `while(true) <block>` where control flow inside the loop can be abrupted via `return`, `break`, `continue` or `throw` statements. However having it on the expression level add a very little value to the real world use-cases, i.e. what is the purpose of writing  code like `true ? <do-something> : <do-something-else>` other than making synthetic example?"
      },
      {
        "user": "krryan",
        "created_at": "2017-02-21T16:45:54Z",
        "body": "I generally feel like the compiler should be as aware of types as possible. This is obvious using `true` itself, but when using a function that returns `true`, or particularly an overload the returns `true` with a particular input, would be less obvious, and thus something like this could result in improved error-checking in the face of refactoring.\r\n\r\nFor example:\r\n\r\n```ts\r\nconst foobar = passesSomePredicate(foo) ? new Foo() : new Bar();\r\nif (isFoo(foobar)) {\r\n    doSomethingWithFoo(foobar);\r\n}\r\nelse {\r\n    doSomethingWithBar(foobar);\r\n}\r\n```\r\n\r\nWhen originally written, presumably this code was meaningful. But suppose some refactoring happened that caused `bar` to be narrower, or an overload for `passesSomePredicate` was written, and either way, now we have `passesSomePredicate(typeof foo): true`. This means that `foobar` must be a `Foo` (and not a `Bar`), which means `isFoo` (a typeguard) is redundant and the `else` block is unreachable. If the compiler knew that `foobar` had to be a `Foo` and that `else` block is unreachable and the value of `foobar` in `doSomethingWithBar(foo)` is `never`. It improves the compile-time understanding of the system, and can help find redundant or unreachable code."
      }
    ]
  },
  {
    "number": 14032,
    "title": "String Literal Type can't be used as index",
    "created_at": "2017-02-13T13:27:31Z",
    "closed_at": "2017-12-05T18:28:06Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/14032",
    "body": "<!-- BUGS: Please use this template. -->\r\n**TypeScript Version:**  2.1.3 \r\n\r\n**Code**\r\n```ts\r\ntype X = \"a\" | \"b\";\r\n\r\nconst x: { [key: X]: string } = {\r\n    \"a\":\"value\"\r\n}\r\n```\r\n\r\n**Expected behavior:**\r\nShould compile as X is actually a string. \r\n\r\n**Actual behavior:**\r\nCompile-time error:\r\n```\r\nAn index signature parameter type must be 'string' or 'number'.\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/14032/comments",
    "author": "olostan",
    "comments": [
      {
        "user": "gcnew",
        "created_at": "2017-02-13T14:39:41Z",
        "body": "Use the `in` operator. E.g.\r\n\r\n```ts\r\ntype X = \"a\" | \"b\";\r\n\r\nconst x: { [key in X]: string } = {\r\n    \"a\": \"value\",\r\n    \"b\": \"value 2\"     // b is required\r\n}\r\n\r\n// to make property `b` optional make the keys optional\r\nconst y: { [key in X]?: string } = {\r\n    \"a\": \"value\",\r\n}\r\n```"
      },
      {
        "user": "masaeedu",
        "created_at": "2017-07-24T23:22:47Z",
        "body": "@gcnew Neither of those is quite the same as requiring a single key from the union."
      },
      {
        "user": "gcnew",
        "created_at": "2017-07-25T00:46:31Z",
        "body": "@masaeedu Yes, that's true. Unfortunately picking a single key is not currently possible, AFAIK :(\r\n\r\n**Edit:** On a second thought, I'm not sure it makes much sense to name a property based on a type. The problem is that for unions (as is the case at hand) such a key cannot be determined without a runtime check. My presumption is that we are looking for provable logic at compile time."
      },
      {
        "user": "masaeedu",
        "created_at": "2017-07-25T18:00:26Z",
        "body": "@gcnew I am looking to construct the type `type A = { foo: 10 } | { bar: 10 }`, using the literal types `type B = \"foo\" | \"bar\"` and `type C = 10`. I feel like this should be the result of `type A = { [idx: B]: C }`. I feebly remember recognizing some general distributive property of unions over other types in a discussion about invoking unions of functions, but I can't quite figure it out for key-value map types.\r\n\r\nAt the moment there is no value-level computation involved, this is purely type-level juggling of expressions, so I don't understand what you're saying in the edit. Could you provide an example of what you mean?"
      },
      {
        "user": "masaeedu",
        "created_at": "2017-07-28T22:09:05Z",
        "body": "@olostan It turns out this is possible, you just need to introduce a type variable:\r\n\r\n```ts\r\ntype X = \"a\" | \"b\";\r\nfunction acceptX<T extends X>(x: {[K in T]: string }) {\r\n    return x\r\n}\r\nconst x = acceptX({ \"b\": \"value\" })\r\n// x is inferred as { \"b\": string }\r\n```\r\n\r\nPassing `{ \"c\": \"value\" }` or `{ \"a\": 10 }` is a type error, as expected."
      },
      {
        "user": "typescript-bot",
        "created_at": "2017-12-05T18:28:06Z",
        "body": "Automatically closing this issue for housekeeping purposes. The issue labels indicate that it is unactionable at the moment or has already been addressed."
      }
    ]
  },
  {
    "number": 13956,
    "title": "Emit/Copy JSDoc comments to declaration files",
    "created_at": "2017-02-08T19:54:36Z",
    "closed_at": "2017-04-19T20:44:38Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/13956",
    "body": "Hi,\r\n\r\nIs possible to emit or copy over jsdoc comments to the d.ts files? \r\n\r\nThanks",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/13956/comments",
    "author": "blendsdk",
    "comments": [
      {
        "user": "donaldpipowitch",
        "created_at": "2017-02-09T06:50:38Z",
        "body": "This should be the case already?\r\n\r\nSay I have this `add.ts` file:\r\n\r\n```typescript\r\n/**\r\n * This function adds two summands.\r\n * @param a The first summand.\r\n * @param b The second summand.\r\n * @returns The sum.\r\n */\r\nexport function add(a: number, b: number): number {\r\n  return a + b;\r\n}\r\n```\r\n\r\nMy `add.d.ts` file looks like this:\r\n\r\n```typescript\r\n/**\r\n * This function adds two summands.\r\n * @param a The first summand.\r\n * @param b The second summand.\r\n * @returns The sum.\r\n */\r\nexport declare function add(a: number, b: number): number;\r\n```"
      },
      {
        "user": "mhegazy",
        "created_at": "2017-04-19T20:44:38Z",
        "body": "Make sure `--removeComments` is not set."
      }
    ]
  },
  {
    "number": 13952,
    "title": "Local @types",
    "created_at": "2017-02-08T12:49:49Z",
    "closed_at": "2017-02-09T08:33:44Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/13952",
    "body": "Hi all,\r\n\r\nI'm developing 2 libraries `A` and `B` in different folders where `A` is exported as target es5 and module commonjs.\r\n\r\nIn `B` I'd like to use `index.d.ts` from `A` among other @types libraries which are in node_modules folder. And then use some classes from `A` via in import like this: `import {MyClass} from \"a\";`.\r\nUnfortunately this doesn't work: a not found in `node_modules/@types/a` etc.\r\nI tried without success with:\r\n \r\n```typescript\r\n\"baseUrl\": \".\",\r\n    \"paths\": {\r\n      \"a\": [\r\n        \"lib/a\"\r\n      ]\r\n    },\r\n```\r\n\r\nHow to setup typescript to find lib/a/index.d.ts without modifying my import with relative path (e.g. `import {MyClass} from \"../lib/a/index\";`)?\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/13952/comments",
    "author": "sternbel",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2017-02-08T18:55:57Z",
        "body": "The target in the \"paths\" list is relative to `\"baseUrl\"`. so your \"paths\" here says `\"a\" => \"./lib/a\"` so you either want to set the `\"baseUrl\"` to `\"../\"` or set the target to `\"../lib/a\"`.\r\n\r\n```ts\r\n{\r\n    \"compilerOptions\": {\r\n        \"module\": \"commonjs\",\r\n        \"target\": \"es5\",\r\n        \"baseUrl\": \"./\",\r\n        \"paths\": {\r\n            \"a\" : [\"../lib/a/index.d.ts\"]\r\n        }\r\n    }\r\n}\r\n```"
      },
      {
        "user": "sternbel",
        "created_at": "2017-02-09T08:33:42Z",
        "body": "Hi @mhegazy,\r\n\r\nThanks a lot, it's working now!"
      }
    ]
  },
  {
    "number": 13907,
    "title": "Avoid \"cannot assign an abstract constructor ...\" through union type",
    "created_at": "2017-02-06T20:28:23Z",
    "closed_at": "2017-04-21T16:55:52Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/13907",
    "body": "I have this code in TS 2.1:\r\n```ts\r\nabstract class Test { _brand: string; }\r\n\r\nfunction test1<T>(arg: { new(): T }): T { return null!; }\r\nfunction test2<T>(arg: { new(): T } | Function): T { return null!; }\r\n\r\nconst a = test1(Test);\r\nconst b = test2(Test);\r\n```\r\nAs discussed in #5843, `test1` is not supposed to typecheck. However, surprisingly, `test2` does.\r\nTypeScript infers `T` for `a` and `Test` for `b`.\r\nI don't know whether this is intended - can I build upon that behavior?",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/13907/comments",
    "author": "hediet",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2017-02-06T22:06:05Z",
        "body": "The type `{ new(): T } | Function` is equivalent to `Function` because `{ new(): T }` is assignable to `Function` (the same way the type `Dog | Animal` is equivalent to `Animal`). We call this \"subtype reduction\" and in general it's really bad to write down a type that undergoes immediate reduction (we probably should have made this an error when we made union types, but too late now).\r\n\r\nMost of the time when people write `Function` the actual type they want is `(...args: any[]) => any)`:\r\n```ts\r\n`function test2<T>(arg: { new(): T } | ((...args: any[]) => any) ): T { return null!; }\r\n\r\nconst b = test2(Test); // Error\r\n```"
      },
      {
        "user": "hediet",
        "created_at": "2017-02-06T22:34:02Z",
        "body": "Thanks for your answer!\r\nBut still, the type of the expression `test2(Test)` infers to `Test`. If `{ new():T } | Function` is actually equivalent to `Function`, TypeScript should have inferred `any`, as it does for `test3(Test)` in\r\n```ts\r\nfunction test3<T>(arg: Function): T { return null!; }\r\n```\r\nHowever, I like TypeScripts current inference behavior as it solves #5843. I need this for my remoting library that instantiates abstract classes (which need to be classes so they can be decorated with metadata)."
      }
    ]
  },
  {
    "number": 13892,
    "title": "semver guidelines for libraries with typings",
    "created_at": "2017-02-05T23:04:41Z",
    "closed_at": "2017-04-21T16:55:53Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/13892",
    "body": "This is a discussion tailor to JavaScript libraries distributing their own typings.\r\n\r\nChanging typings can easily break builds, even if the underlying JavaScript code doesn't change.\r\n\r\nWe should have a guideline to describe when should it be considered a minor/major version bump.\r\n\r\nOn the other hand, since the JavaScript code doesn't change (or only worth a patch version bump), if we recommend to bump minor/major version when the typings changes, the consumer who consumes the library in JavaScript project could be confused by these version changes because there are no code changes to them.",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/13892/comments",
    "author": "unional",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2017-02-06T18:49:08Z",
        "body": "If you own the package, and you include the declaration files with your package, then you should follow semver for your .d.ts files just like you do for your .js files. \r\n\r\nif the declaration file change is breaking, then it should be under a major version, otherwise use a minor version. \r\n\r\nThis means that you can be shipping new versions the package that differ only in .d.ts content, but that is no different from any other non-js resources that your package can carry, e.g. package.json or .css files."
      },
      {
        "user": "unional",
        "created_at": "2017-02-25T02:52:20Z",
        "body": "Agree to what you say, but may not fly for the package authors because they may think typings (and flow definitions) are additional and have a different point of view.\r\n\r\nIs education the only option?"
      },
      {
        "user": "mhegazy",
        "created_at": "2017-02-27T22:08:43Z",
        "body": "The other option is to build a while different system for getting definitions. we believe npm is a good system to use, it saves the users from learning about a new system altogether."
      }
    ]
  },
  {
    "number": 13861,
    "title": "Unsafe coercion from \"any type\" to {}",
    "created_at": "2017-02-03T10:32:00Z",
    "closed_at": "2017-02-03T18:57:18Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/13861",
    "body": "**TypeScript Version:**  2.1.5 and 2.2.0-dev.20170201\r\nUsing --noImplicitAny and --strictNullChecks\r\n\r\n**Code**\r\n\r\n```ts\r\nfunction doItWithAnObject<A extends {}>(a: A) {\r\n  a.toString()\r\n}\r\n\r\nfunction doItWithAnything<B>(b: B) {\r\n  doItWithAnObject(b)\r\n}\r\n\r\ndoItWithAnything(null)\r\ndoItWithAnything(undefined)\r\n```\r\n\r\n**Expected behavior:**\r\n`doItWithAnything` should not compile because it calls `doItWithAnObject` with something that is potentially not an object.\r\n\r\n**Actual behavior:**\r\nNo compilation error. Runtime errors.\r\n\r\nPerhaps related: If I have an abstract type A, and I narrow it down to A minus null minus undefined, it isn't considered as an object.\r\n\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/13861/comments",
    "author": "AlexGalays",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2017-02-03T18:15:05Z",
        "body": "if you want to exclude `null` and `undefined`, give the generic type parameter a constraint for `{}`. if you want to further exclude primitives, give it a constraint `object`. otherwise, it goes to the top type, i.e. `{} | null | undefined`"
      },
      {
        "user": "AlexGalays",
        "created_at": "2017-02-03T18:57:18Z",
        "body": "Oh, I see. Thanks."
      },
      {
        "user": "ikokostya",
        "created_at": "2017-02-03T19:25:24Z",
        "body": "> if you want to exclude null and undefined, give the generic type parameter a constraint for {}\r\n\r\nBut it already done for `doItWithAnObject` function:\r\n\r\n```ts\r\nfunction doItWithAnObject<A extends {}>(a: A) {\r\n  a.toString();\r\n}\r\ndoItWithAnObject(null); // Error: Argument of type 'null' is not assignable to parameter of type '{}'\r\n```\r\n\r\nWhy compiler doesn't check this inside `doItWithAnything` function?\r\n\r\n```ts\r\nfunction doItWithAnything<B>(b: B) {\r\n  doItWithAnObject(b); // No errors, but argument \"b\" has \"null\" type here\r\n}\r\ndoItWithAnything(null);\r\n```"
      }
    ]
  },
  {
    "number": 13809,
    "title": "[request] allow namespaces to become types",
    "created_at": "2017-02-01T06:21:10Z",
    "closed_at": "2017-02-01T11:10:18Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/13809",
    "body": "How about allowing namespaces to become types?\r\n\r\ne.g.)\r\n\r\n```typescript\r\n// some declaration file I can't touch\r\ndeclare module monaco {   //this is monaco, not 'monaco'. so it's a namespace.\r\n   ...\r\n}\r\n\r\ntype _MonacoNamespaceType = ::monaco; // or any other syntax is fine.\r\n```\r\n--------------------------------\r\nbackground: I'm having problems trying to write d.ts file for react-monaco-editor.\r\n\r\nmonaco-editor's typescript definition has everything in ts namespaces, so I'm stuck trying to get 'monaco' as a type.\r\n\r\nhere's the definition file I'm working on:\r\n```typescript\r\n/// <reference path=\"../../node_modules/monaco-editor/monaco.d.ts\" />\r\n\r\n\r\ndeclare module 'react-monaco-editor' {\r\n  import { Component } from 'react';\r\n  export type ReactMonacoEditorProps = {\r\n    width: string,\r\n    height: string,\r\n    language: string,\r\n    options: monaco.editor.IEditorOptions,\r\n    editorDidMount?: (editor: monaco.editor.ICodeEditor, monaco: any) => any,\r\n  };\r\n  import test = monaco;\r\n  export type ICodeEditor = monaco.editor.ICodeEditor;\r\n  export default class ReactMonacoEditor\r\n      extends Component<ReactMonacoEditorProps, void> { }\r\n}\r\n```\r\nAs you can see on **editorDidMount?: (editor: monaco.editor.ICodeEditor, monaco: any) => any,**\r\nI couldn't give the 'monaco' type on monaco as 'monaco' namespace cannot be a type.",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/13809/comments",
    "author": "devdoomari",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2017-02-01T06:32:21Z",
        "body": "`typeof monaco` ?"
      },
      {
        "user": "devdoomari",
        "created_at": "2017-02-01T11:09:11Z",
        "body": "@mhegazy oh so there was already a way! Thanks : )"
      },
      {
        "user": "devdoomari",
        "created_at": "2017-02-01T11:10:18Z",
        "body": "."
      }
    ]
  },
  {
    "number": 13725,
    "title": "Readonly option dose not have correct operation",
    "created_at": "2017-01-27T15:49:34Z",
    "closed_at": "2017-01-27T17:48:37Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/13725",
    "body": "in ReadOnly property  it seems has a Ambiguity.\r\n\r\n```\r\nlet a: number[] = [1, 2, 3, 4];\r\nlet b: number[] = [1, 2, 3, 4, 6];\r\nlet ro: ReadonlyArray<number> = a;\r\nro[10] = 12; // error!\r\n\r\nro = b; // is ok; not error\r\nro = a; // is ok; not error\r\n```",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/13725/comments",
    "author": "captainhamid",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2017-01-27T17:47:52Z",
        "body": "`ReadonlyArray` talks about the content of the array. `ro` is a reference. if you want `ro` to be constant, declare it as:\r\n\r\n```ts\r\nconst ro:  ReadonlyArray<number> = a;\r\n```"
      },
      {
        "user": "mhegazy",
        "created_at": "2017-01-27T17:48:34Z",
        "body": "In general StackOverflow is the right place for such questions. this issue tracker is for compiler/language bugs and suggestions."
      }
    ]
  },
  {
    "number": 13581,
    "title": "tsc doesn't resolve module specified in the typeRoots",
    "created_at": "2017-01-19T18:17:36Z",
    "closed_at": "2017-04-21T16:56:05Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/13581",
    "body": "**TypeScript Version:**  2.1.5\r\n\r\nI have the following directory structure:\r\n```\r\ntsconfig.json\r\na.ts\r\nnode_modules\r\n|--- custom\r\n     |--- rembo\r\n           |---index.d.ts\r\n```\r\n\r\nThe content of `index.d.ts` is the following:\r\n```\r\nexport declare class Rembo {\r\n    name: string;\r\n}\r\n```\r\n\r\nI reference this module in `a.ts`:\r\n`import {Rembo} from 'rembo';`\r\n\r\nThe `package.json` is the following:\r\n```\r\n{\r\n  \"compilerOptions\": {\r\n    \"moduleResolution\": \"node\",\r\n    \"module\": \"es6\",\r\n    \"target\": \"es6\",\r\n    \"typeRoots\": [\r\n      \"node_modules/custom\"\r\n    ]\r\n  }\r\n}\r\n```\r\nThe problem is that `rembo` module can't be resolved. When compiled, I get the following result:\r\n\r\n`$ tsc --traceResolution`\r\n\r\n```\r\n======== Resolving type reference directive 'rembo', containing file 'D:/Projects/typescript/__inferred type names__.ts', root directory 'D:/Projects/typescript/node_modules/custom'. ========\r\nResolving with primary search path 'D:/Projects/typescript/node_modules/custom'\r\nFile 'D:/Projects/typescript/node_modules/custom/rembo/package.json' does not exist.\r\nFile 'D:/Projects/typescript/node_modules/custom/rembo/index.d.ts' exist - use it as a name resolution result.\r\nResolving real path for 'D:/Projects/typescript/node_modules/custom/rembo/index.d.ts', result 'D:/Projects/typescript/node_modules/custom/rembo/index.d.ts'\r\n======== Type reference directive 'rembo' was successfully resolved to 'D:/Projects/typescript/node_modules/custom/rembo/index.d.ts', primary: true. ========\r\na.ts(3,21): error TS2307: Cannot find module 'rembo'.\r\n```\r\n\r\nI don't understand why the error, since it reports then:\r\n\r\n> Type reference directive 'rembo' was **successfully** resolved to 'D:/Projects/typescript/node_modules/custom/rembo/index.d.ts', primary: true.\r\n\r\n\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/13581/comments",
    "author": "maxkoretskyi",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2017-01-19T22:49:50Z",
        "body": "TypeRoots is useful for global declarations, things that you do not `import`, e.g. node definition file. when the compiler starts it loads all files under `typeRoots` and adds them in the global scope.\r\n\r\nSeems like this is not what you are looking for, what you need is [Path mapping](www.typescriptlang.org/docs/handbook/module-resolution.html#path-mapping):\r\n\r\n```ts\r\n{\r\n  \"compilerOptions\": {\r\n    \"moduleResolution\": \"node\",\r\n    \"module\": \"es6\",\r\n    \"target\": \"es6\",\r\n    \"baseUrl\": \"./\",\r\n    \"paths\": {\r\n      \"*\" : [\"node_modules/custom/*\"]\r\n    }\r\n  }\r\n}\r\n```\r\n\r\nThis tells the compiler to look under `<baseUrl>/node_modules/custom` for any import it sees."
      },
      {
        "user": "maxkoretskyi",
        "created_at": "2017-01-20T06:37:09Z",
        "body": "Thanks a lot for you quick reply. As I understand, the `node_modules` and `node_modules/@types` are automatically added to \"paths\", correct? I have imports of one module residing inside `node_modules` and the other in `node_modules/@types` and don't \"paths\" configured, but both modules are still successfully resolved.\r\n\r\nAnd is my understanding correct that both \"typeRoots\" and \"types\" is used for global modules resolve?"
      },
      {
        "user": "mhegazy",
        "created_at": "2017-01-21T22:13:42Z",
        "body": "that is correct. I would not think about `typeRoots` unless you are using something global, e.g. `node`. otherwise, just think about modules."
      },
      {
        "user": "maxkoretskyi",
        "created_at": "2017-01-26T18:37:00Z",
        "body": "Got it, thanks. Where can I read about all supported patterns for `paths`? For example, can I match part of the module name and provide mappings for that part? Or only `*` pattern is supported?"
      },
      {
        "user": "gdamjan",
        "created_at": "2017-02-10T00:27:35Z",
        "body": "What if the node_modules including node_modules/@types are outside the source directory alltogether?\r\n\r\n```\r\nSRC=$HOME/Pojects/demo\r\nDEST=/tmp/build\r\n\r\nln -s $SRC/package.json $DEST/package.json\r\ncd $DEST\r\nnpm install\r\n\r\ncd $SRC\r\ntsc --outDir $DEST/build --typeRoots $DEST/???\r\n```\r\nthis doesn't work\r\n\r\n\r\n\r\n\r\n(ts 2.1.6)"
      },
      {
        "user": "mhegazy",
        "created_at": "2017-02-10T00:47:46Z",
        "body": "`paths` is relative to the `baseUrl` and not the `projectRoot`. so you can make the `baseUrl` whatever you want."
      }
    ]
  },
  {
    "number": 13530,
    "title": "Invoking methods from object iteration",
    "created_at": "2017-01-17T12:05:32Z",
    "closed_at": "2017-01-17T20:01:49Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/13530",
    "body": "**TypeScript Version:**  2.1.5\r\n\r\n**Code**\r\n\r\n```ts\r\nclass Params {\r\n\tpublic paramsInit () {\r\n\t\tfor ( let prop in this ) {\r\n\t\t\tif ( typeof this[ prop ] === 'function' ) {\r\n\t\t\t\tlet res = this[ prop ]();\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\nclass Test extends Params {\r\n\tconstructor () {\r\n\t\tsuper();\r\n\t\tthis.paramsInit();\r\n\t}\r\n\r\n\tpublic param1 (): void {\r\n\t\tconsole.log( 'param1' );\r\n\t}\r\n}\r\n```\r\n\r\n**Expected behavior:**\r\n\r\nIn TypeScript 2.0 the above compiles without any errors.\r\n\r\n**Actual behavior:**\r\n\r\nIn TypeScript 2.1.5 I get:\r\n\r\n> test.ts(5,15): error TS2349: Cannot invoke an expression whose type lacks a call signature. Type 'Params[keyof this]' has no compatible call signatures.\r\n\r\nI can see why tsc might not like invooking `this[ prop ]`, but I can't see any way to tell it that it is a valid function. I've tried using `as` in various combinations, but with no luck.\r\n\r\nIs there a way to get this to compile in 2.1 without errors?",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/13530/comments",
    "author": "DataTables",
    "comments": [
      {
        "user": "ahejlsberg",
        "created_at": "2017-01-17T14:33:46Z",
        "body": "This works:\r\n\r\n```ts\r\nclass Params {\r\n    public paramsInit () {\r\n        for ( let prop in this ) {\r\n            if ( typeof this[ prop ] === 'function' ) {\r\n                let res = (this[ prop ] as any)();\r\n            }\r\n        }\r\n    }\r\n}\r\n```"
      },
      {
        "user": "DataTables",
        "created_at": "2017-01-17T14:42:48Z",
        "body": "Thanks! Yes, that allows a clean compile with tsc 2.1.5.\r\n\r\nSo I guess the question becomes, is the 2.0 or 2.1 behaviour correct?"
      },
      {
        "user": "ahejlsberg",
        "created_at": "2017-01-17T18:40:13Z",
        "body": "The current behavior is correct. The call without a type assertion is clearly not type safe, but previously we were not equipped to track the type of a computed property access so we would give an implicit `any` type to `this[prop]` (and you'd get an error with `--noImplicitAny`). Now, because of indexed access types (a.k.a. \"lookup types\") we can do a better job."
      },
      {
        "user": "DataTables",
        "created_at": "2017-01-17T20:01:49Z",
        "body": "Awesome - thanks very much.\r\n\r\nOthers have said it many times, and I as well, but going to say it again - TypeScript is excellent and a credit to all involved!"
      }
    ]
  },
  {
    "number": 13412,
    "title": "Cannot augment an UMD module declaration from global scope",
    "created_at": "2017-01-11T14:48:14Z",
    "closed_at": "2017-05-22T22:35:18Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/13412",
    "body": "**TypeScript Version:**  2.1.4\r\n\r\n**Code**\r\n\r\n```ts\r\n\r\n// test.d.ts\r\n\r\ndeclare namespace MyNamesapce {\r\n  export interface MyInterface {\r\n    DoSomething();\r\n  }\r\n  export var Var: MyInterface;\r\n}\r\nexport = MyNamesapce;\r\nexport as namespace MyUMDGlobal;\r\n```\r\n\r\n```ts\r\n// main.ts\r\n\r\ndeclare module \"test\" {\r\n  interface MyInterface {\r\n    DoAnotherThing();\r\n  }\r\n}\r\n\r\nvar a = MyUMDGlobal.Var.DoSomething();\r\nvar b = MyUMDGlobal.Var.DoAnotherThing();\r\n```\r\n\r\n**Expected behavior:**\r\n\r\nIt should compile fine, because I've augmented the module `test` and it's interface `MyInterface` with the method `DoAnotherThing`.\r\n\r\n**Actual behavior:**\r\n\r\nIt gives a compile error that it doesn't find the symbol `DoAnotherThing`. Visual Studio intellisense doesn't resolve it either.",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/13412/comments",
    "author": "cervengoc",
    "comments": [
      {
        "user": "cervengoc",
        "created_at": "2017-01-31T10:46:34Z",
        "body": "@mhegazy Could you please have a look at this? This one currently breaks my work on updating some library typings to be TS2 friendly."
      },
      {
        "user": "mhegazy",
        "created_at": "2017-04-27T22:44:48Z",
        "body": "you need a top-level import or export in this file.  in other words you need to import the module first to be able to augment it."
      },
      {
        "user": "mhegazy",
        "created_at": "2017-05-22T22:35:18Z",
        "body": "Automatically closing this issue for housekeeping purposes. The issue labels indicate that it is unactionable at the moment or has already been addressed."
      }
    ]
  },
  {
    "number": 13399,
    "title": "files/dirs that start with a dot (.) do not get copied or transpiled by default",
    "created_at": "2017-01-10T20:04:48Z",
    "closed_at": "2017-04-21T16:31:16Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/13399",
    "body": "**TypeScript Version:**  2.1.4\r\n\r\n**Code**\r\n\r\n```\r\n/lib\r\n/test\r\n    /.suman\r\n    /test-src\r\n```\r\n\r\nif I build this project with `tsc` and use the outDir option, the .suman directory **won't** get moved/transpiled, presumably because it starts with a dot .\r\n\r\nbased on the above project structure, the resulting _incorrect_ build would look like:\r\n\r\n```\r\n/dist\r\n   /lib\r\n   /test\r\n       /test-src  \r\n```\r\nabove we can see that the .suman dir is missing from the test dir\r\n\r\nif I rename the .suman directory to suman like so:\r\n\r\n```\r\n/lib\r\n/test\r\n    /suman    // renamed from .suman to suman\r\n    /test-src\r\n```\r\n\r\nthen it will get moved to the outDir, because it no longer starts with a dot .\r\n\r\nso the expected result actually happens, which is of course:\r\n\r\n```\r\n/dist\r\n   /lib\r\n   /test\r\n       /suman\r\n       /test-src\r\n```\r\n\r\n\r\n\r\n\r\nhere is my config, which shows that I want to `include` my test dir, in the build.\r\n\r\n```json\r\n{\r\n  \"compilerOptions\": {\r\n    \"compileOnSave\": true,\r\n    \"target\": \"es5\",\r\n    \"noImplicitAny\": false,\r\n    \"removeComments\": true,\r\n    \"preserveConstEnums\": true,\r\n    \"outDir\": \"dist\",\r\n    \"allowJs\": true,\r\n    \"allowUnreachableCode\": true,\r\n    \"lib\": [\"es2015\", \"dom\"]\r\n  },\r\n  \"include\": [\r\n    \"./**/*\"\r\n  ],\r\n  \"exclude\": [\r\n    \"node_modules\"\r\n  ]\r\n}\r\n\r\n```\r\n\r\n**Expected behavior:**\r\n\r\nI would expect it would include files/directories that start with a dot, unless you exclude files/dirs that start with a dot\r\n\r\n**Actual behavior:**\r\n\r\nTS/tsc seems to exclude files/dirs that start with a dot by default, which seems very strange, since users could easily specify with a regex to ignore dirs/files that start with a dot!\r\n\r\n**My question is then, is there a tsconfig.json setting I can use to include the .suman directory with my build?**\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/13399/comments",
    "author": "ORESoftware",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2017-01-11T17:49:38Z",
        "body": "files and folders starting with a `.` are ignored by the glob patterns. this to accomodate for hidden folders that tools like git rely on. You need to add the folder starting with a `.` explcitlly in your include patter:\r\n\r\n```json\r\n  \"include\": [\r\n    \"./**/*\",\r\n    \"./test/.suman/**/*\"\r\n  ],\r\n```\r\n\r\nalso one note, you need to exclude your outDir, or you will be consuming the output again, given that you have `--allowJs` set. so your exclude patterns should be:\r\n```json\r\n  \"exclude\": [\r\n    \"node_modules\",\r\n    \"./dist\"\r\n  ]\r\n```"
      },
      {
        "user": "ORESoftware",
        "created_at": "2017-01-11T23:18:18Z",
        "body": "ahh thanks so much that helps a ton!"
      }
    ]
  },
  {
    "number": 13398,
    "title": " An index signature parameter type must be 'string' or 'number' - why not string | number?",
    "created_at": "2017-01-10T20:04:10Z",
    "closed_at": "2017-04-21T16:56:11Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/13398",
    "body": "This:\r\n\r\n```ts\r\ninterface A {\r\n    [key: string | number]: boolean;\r\n}\r\n```\r\n\r\nspecifies that the key must be either a string or a number, but produces an error saying that the key must be either string or number! But I guess this helps with clarity, ensuring that a value inserted with a string key `\"123\"` is not read with a number key `123` and vice versa.\r\n\r\nBut in the generic case:\r\n\r\n```ts\r\ninterface A<K extends string|number> {\r\n    [key: K]: boolean;\r\n}\r\n```\r\n\r\nI *could* instantiate this with `K = string|number`, but more likely the intent is to pass one or the other, in which case this seems totally reasonable, but we currently can't do it.",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/13398/comments",
    "author": "danielearwicker",
    "comments": [
      {
        "user": "aluanhaddad",
        "created_at": "2017-01-11T03:33:33Z",
        "body": ">But I guess this helps with clarity, ensuring that a value inserted with a string key \"123\" is not read with a number key 123 and vice versa.\r\n\r\nActually you can get a value inserted with a string key \"123\" by using the number key 123, but the reverse will result in an `any`.\r\nConsider\r\n```ts\r\ninterface Keyed {\r\n  [key: string]: {};\r\n}\r\ninterface Numbered { // This is just named \"Numbered\" for fun ;)\r\n  [key: number]: {};\r\n}\r\n\r\nconst x: Keyed = {};\r\nconst y: Numbered = {};\r\n\r\nconst a = x[1]; // {}\r\nconst b = y['1']; // any\r\n```"
      },
      {
        "user": "danielearwicker",
        "created_at": "2017-01-11T09:49:03Z",
        "body": "Yes. `number` is convertible to `string`, so really (in the first example) `string | number` would effectively be equivalent to `string`, so in truth the existing behaviour doesn't help that much in the simple case, though with `--noImplicitAny` the reverse is properly caught.\r\n\r\nThis looseness extends to access via union key type:\r\n\r\n```ts\r\ndeclare const m: { [key: string ]: boolean};\r\ndeclare const k: string | number;\r\n\r\nm[k] = true;\r\n```\r\n\r\nHowever, the generic case (which is what I'm actually interested in) is a bit tighter:\r\n\r\n```ts\r\nfunction foo<K extends string | number>(k: K) {\r\n\r\n    var m: { [key: string ]: boolean}; // try using string as workaround\r\n\r\n    m[k] = true; // type K cannot be used to index...\r\n}\r\n```\r\n\r\nSo the indexer key type is `string`, and K is one of `(string|number)`, `string`, `number`, all of which are fine outside generics. But instead it errors.\r\n\r\nSo the complete workaround is to use `string` as the key type *and* stick in a type assertion `m[k as string]` everywhere you use the indexer. Or equivalently, use `number` and use `m[k as number]` everywhere. It doesn't matter which one you pick, as in the generic case the convertibility of `number` to `string` does not appear to be relevant.\r\n\r\nMy guess is that if an indexer could be declare with a generic key type, as long as that key type was one of `(string|number)`, `string`, `number`, then no workaround would be needed."
      },
      {
        "user": "neolivz",
        "created_at": "2017-05-05T02:00:56Z",
        "body": "I am not sure why this was closed? \r\n\r\n```\r\ninterface MyMap<T extends string> {\r\n    [key: T]: any\r\n}\r\n```\r\nI should be able to do something like this to restrict. I know this won't make any sense what I wanted  to do is something like this\r\n\r\n```\r\ninterface MyMap<T> {\r\n    [key: K]: MyType<K, T>\r\n}\r\n```\r\nwhich basically every key would have the same key type.\r\nThis is allowed in functional interface \r\n```\r\ninterface MyMapFn<T> {\r\n    <K>(k:K): MyType<K,T>\r\n}\r\n```\r\nWhy can't i do something like this ?"
      },
      {
        "user": "thinkingmedia",
        "created_at": "2018-02-05T14:18:54Z",
        "body": "I don't understand why this was closed too, but I did figure out how to work around the problem.\r\n\r\nYou basically can not use the OR `|` operator for types on a key, but you can define overloaded accessors of different types.\r\n\r\n```\r\ninterface A<T extends string | number> {\r\n    [key: string]: any;\r\n    [key: number]: any;\r\n}\r\n```\r\n\r\nIf you are using the generics type to define the accessor for a function parameter. You have to define both types as `string` or `number` like this:\r\n\r\n```\r\ninterface A<T extends string | number> {\r\n    get(data: {[key:string]:any} | {[key :number]:any})\r\n}\r\n```\r\n\r\nI see this as just a work around. If anyone has a better approach please share it."
      }
    ]
  },
  {
    "number": 13311,
    "title": "Performance Query - Large String Union Types",
    "created_at": "2017-01-06T03:35:44Z",
    "closed_at": "2017-05-08T08:00:20Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/13311",
    "body": "## Background \r\n\r\nWe have a 2000 line localization file, and a localize function in our code which pulls out the translation at run-time.\r\n\r\nI am investigating the possibility of auto-generating a large string union type, writing it out to a file, and using it as a type parameter for the localize function.\r\n\r\n## Code\r\n\r\n**TypeScript Version:**  2.1.4\r\n\r\n**Before**\r\n\r\n```ts\r\nfunction localize(id: string) {\r\n   // ...\r\n}\r\n\r\nlocalize('not a real key'); // OK\r\n```\r\n\r\n**After**\r\n\r\n```ts\r\nfunction localize(id: LocalizationKey) {\r\n   // ...\r\n}\r\n\r\nlocalize('not a real key'); // NOT OK\r\n\r\n// auto-generated\r\ntype LocalizationKey =\r\n    \"foo\"\r\n  | \"bar\"\r\n  | ... // 2000+ items.\r\n```\r\n\r\nThis works fine.\r\n\r\n## Question\r\n\r\nWe are concerned about type-checking performance, both at compile time, and in TypeScript language services in our IDEs (VS Code and Visual Studio).\r\n\r\nIs this a valid concern, or will these types be cached in an efficient manner?\r\n\r\nThanks.",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/13311/comments",
    "author": "azz",
    "comments": [
      {
        "user": "azz",
        "created_at": "2017-05-08T08:00:20Z",
        "body": "Closing this as it doesn't seem to be an issue."
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2017-05-08T17:15:25Z",
        "body": "FYI - Large unions of literal types are highly optimized because that's the internal representation of an enum value. We have an enum in the compiler with ~350 members and it doesn't cause any problems (that I'm aware of). 2,000 might be pushing it but I suspect you'll be OK."
      }
    ]
  },
  {
    "number": 13305,
    "title": "Multiple recommendations / Issues related to TS development under Visual Studio",
    "created_at": "2017-01-05T22:41:31Z",
    "closed_at": "2017-04-27T22:46:05Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/13305",
    "body": "Hello, I have multiple recommendations to typescript (and ts for visual studio). I am using it in the similar way as the C# so I split classes to separate files and compiling each project to the single library file (or \"executable\"), referencing projects in the solution as libraries and so on. I have found few things I don't like so much, but in the worst case I can live with them :) On the other hand it would be great if these can be fixed. All are related to web development, not to dev for Node, but its not probably important.\r\n\r\nVisual Studio\r\n\r\na) Multiple VS projects in single solution\r\n   If there are multiple projects in the solution and one project is used as a library (js+.d.ts) in the second it is not possible to navigate directly to source code of the library (by pressing F12) but navigation to the .d.ts file is performed instead. It would be great if there can be some internal mapping mechanism and the right the source file / type is openned directly.\r\n\r\nb) Debugging\r\n   If the \"dynamic script\" (in meaning it was evaled or loaded dynamically by injecting a script tag) is about to be debugged and the source is not located directly in the main project (the js library with a map file is loaded) it is not possible to see the content of variables using a mouse over method. Breakpoints works well, watches too, but it would be great if mouse over can work too in such case. It is strange that when I switch from the dynamic code to the source I can hover, but I can't debug, because stepping forward switches me back to the dynamic of course.\r\n\r\nTypeScript\r\n\r\na) Namespaces\r\n   If there is a same namespace splited over multiple files and the transpilation target is single file it is necessary to use export keyword in order to make definitions in a one file available through other files but with the same namespace. This is strange behavior, but I get it is related to modules loaded separately.\r\n\r\nb) Namespaces transpillation\r\n   If the namespace with the same name is used and splitted over multiple files and the single transpillation target is used it would be great to join all the same namespaces together to the single literal. Currently, there are as many namespaces as files defining them.\r\n\r\nIf you will find any of my recommendations \"fixable\" I can create separate issues for them.\r\n\r\nRegards,\r\nFrantisek Novak",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/13305/comments",
    "author": "atomsoftwarestudios",
    "comments": [
      {
        "user": "atomsoftwarestudios",
        "created_at": "2017-01-10T06:36:45Z",
        "body": "Regarding Visual Studio b)\r\nI have recreated the solution and now everything works as expected. But at this time I was not able to identify where the problem was. I'll keep you updated if I'll identify it."
      },
      {
        "user": "aluanhaddad",
        "created_at": "2017-01-10T07:53:31Z",
        "body": "👍 for item a) it's badly needed but it has nothing to do with Visual Studio. It has to do with the concept of package level references that mean more than simply files on disk."
      },
      {
        "user": "atomsoftwarestudios",
        "created_at": "2017-01-10T08:13:33Z",
        "body": "I can imagine this will be hard as if the source will not be available in the solution this can bring problems. I can live with it, its not that big deal, find feature works well too ;)"
      }
    ]
  },
  {
    "number": 13290,
    "title": "Enum type guard",
    "created_at": "2017-01-04T23:13:24Z",
    "closed_at": "2017-01-05T19:45:47Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/13290",
    "body": "Is there a way to guard type only to enum types?\r\n\r\nThanks!",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/13290/comments",
    "author": "pankleks",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2017-01-05T19:45:47Z",
        "body": "This is an issue tracker, not a help forum. Please ask questions on your favorite Q+A site, e.g. Stack Overflow."
      },
      {
        "user": "pankleks",
        "created_at": "2017-01-06T14:07:45Z",
        "body": "I'm asking as I could not find a way - so it's more like feature request I guess.\r\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2017-01-06T21:52:34Z",
        "body": "there is not a general `Enum` type. Enums all are subtypes of `number`, but obviously this includes numbers as well.\r\n\r\nIn general, if this is a suggestion, it would be helpful to include an explanation of the scenario you are trying to address with this change, a code snippet demonstrating the original problem as well as some description of the proposed solution."
      }
    ]
  },
  {
    "number": 13221,
    "title": "Checkbox selected value",
    "created_at": "2016-12-29T21:08:02Z",
    "closed_at": "2016-12-29T21:43:16Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/13221",
    "body": "I am making a small static demo in angular 2\r\nI have 3 checkboxes and the user will make the selection as required.\r\nI wish to save the selected checkbox values on button click  in table, in horizontal manner, separated by comma.\r\ne.g\r\nhere is my table with only one column :\r\nSkills \r\nAngular2,Typescript,HTML5\r\n\r\nSo far i have done this :\r\n----------------------------\r\n### subject.ts\r\n\r\nexport interface ISkills\r\n{\r\n     _skillID:number,\r\n     _skillName:string\r\n}\r\n-----------------------------------------\r\n### subject.component.ts\r\n\r\nimport { Component, OnInit } from '@angular/core';\r\nimport {ISkills} from './../Student/subject';\r\n@Component({\r\n     selector: 'stud',\r\n     templateUrl: 'app/Student/subject-list.component.html'\r\n})\r\nexport class StudentComponent implements OnInit {\r\n     checked = false;\r\n\r\n    sk:ISkills[]=[{\r\n         _skillID:1,\r\n         _skillName:'Angular 2'\r\n    },\r\n    {\r\n          _skillID:2,\r\n         _skillName:'Typescript'\r\n    },\r\n    {\r\n          _skillID:3,\r\n         _skillName:'HTML 5'\r\n    }]\r\n     constructor() { }\r\n\r\n     ngOnInit() {\r\n          this.checked=!this.checked;\r\n      }\r\n}\r\n------------------------------------------------\r\n**subject.component.html**\r\n\r\n         <md-card>\r\n    <md-card-content>\r\n        <section class=\"example-section\">\r\n            <md-checkbox class=\"example-margin\" *ngFor=\"let item of sk\">{{item._skillName}}</md-checkbox>\r\n        </section>\r\n        <!--on click of submit button i will show selected checkbox values on my table-->\r\n        <button type=\"button\">Submit</button><br/><br/>\r\n\r\n        <h4>My Table below :</h4>\r\n        <table>\r\n            <thead>\r\n                <tr>\r\n                    <th>Skills</th>\r\n                </tr>\r\n            </thead>\r\n            <tbody>\r\n                <tr>\r\n                    <td></td>\r\n                </tr>\r\n            </tbody>\r\n        </table>\r\n    </md-card-content>\r\n</md-card>\r\n---------------------------------------------------------------\r\ncan anybody tell me how do i get the value separated with comma on my table.\r\nAny help would be much appreciated\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/13221/comments",
    "author": "Ashwani44",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2016-12-29T21:43:16Z",
        "body": "This is a bug tracker, not a general support forum. **Read the issue template**."
      }
    ]
  },
  {
    "number": 13207,
    "title": "λ return object",
    "created_at": "2016-12-29T05:43:13Z",
    "closed_at": "2016-12-29T07:11:36Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/13207",
    "body": "let func=(val:number)=>{x:val};//error\r\nlet func=(val:number)=>{return {x:val};};//ok",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/13207/comments",
    "author": "kgtkr",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2016-12-29T05:47:06Z",
        "body": "The first line is, unfortunately , a valid JS grammar production. the `{}` represent the body of the function, the `x` is a label, the `val` is an expression, the function as a whole implicitly returns `undefined`.\r\n\r\nyou can wrap it in parans to avoid this. e.g. \r\n```ts\r\nlet func1 = (val: number) => ({ x: val });\r\n```"
      },
      {
        "user": "kgtkr",
        "created_at": "2016-12-29T12:13:06Z",
        "body": "thank you"
      }
    ]
  },
  {
    "number": 13200,
    "title": " Conflict between  Intersection types and keyof",
    "created_at": "2016-12-28T13:36:15Z",
    "closed_at": "2016-12-28T16:44:23Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/13200",
    "body": "**TypeScript Version:**  2.1.4 / nightly (2.2.0-dev.20161228)\r\n\r\n**Code**\r\n\r\n```ts\r\nclass Tween<T>{\r\n\r\n    static get<T>(target: T): Tween<T> {\r\n        return new Tween(target);\r\n    }\r\n\r\n    constructor(private target: T) {\r\n\r\n    }\r\n\r\n    /** \r\n     * modify the value of target from a old number value to new number value;\r\n     * there are two rules props should be followed : \r\n     * 1. key of props must be the key of target \r\n     * 2. every value of props should be number\r\n     */\r\n    public to(props: Partial<T> & { [index: string]: number }) {\r\n\r\n    }\r\n}\r\n\r\n\r\nvar textField = { x: 0, y: 0, text: \"helloworld\" };\r\nvar tween = Tween.get(textField);\r\ntween.to({ \"x\": 100 })\r\ntween.to({ \"xx\": 100 });\r\ntween.to({ \"text\": \"hello,typescript\" });\r\ntween.to({ \"text\": 1 });\r\n\r\n```\r\n\r\n\r\n**Expected behavior:**\r\n```\r\ntween.to({ \"x\": 100 }) // right\r\ntween.to({ \"xx\": 100 });  // report error because 'xx' is not existed in typeof textfield\r\ntween.to({ \"text\": \"hello,typescript\" }); // report error because 'hello,typescript' is not number\r\ntween.to({ \"text\": 1 });// report error because 'text' in typeof textfield should be string\r\n```\r\n\r\n\r\n**Actual behavior:**\r\n\r\n```\r\ntween.to({ \"x\": 100 }) // right\r\ntween.to({ \"xx\": 100 });  // right , why ???????\r\ntween.to({ \"text\": \"hello,typescript\" }); // report error because 'hello,typescript' is not number\r\ntween.to({ \"text\": 1 });// report error because 'text' in typeof textfield should be string\r\n```",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/13200/comments",
    "author": "WanderWang",
    "comments": [
      {
        "user": "blakeembrey",
        "created_at": "2016-12-28T16:00:51Z",
        "body": "This looks correct to me. Your signature is saying `{ [key: string]: number }` is valid, so any key not in `T` must be a number (and anything in `T` intersects with `number` so makes some `never` types when `string & number`. Perhaps you want a signature more like `Partial<{ [X in keyof T]: number }>`? If `{ text: 1 }` is definitely meant to be an error, try the signature `Partial<T & { [X in keyof T]: number }>`, I couldn't really tell if the error there was intentional."
      },
      {
        "user": "WanderWang",
        "created_at": "2016-12-28T16:44:23Z",
        "body": "Thanks !!!\r\n``` Partial<T & { [X in keyof T]: number }> ``` it worked well !!!! I think this issue should be closed"
      }
    ]
  },
  {
    "number": 13197,
    "title": "support of native async/await is missing ",
    "created_at": "2016-12-28T10:29:16Z",
    "closed_at": "2016-12-30T18:08:40Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/13197",
    "body": "\r\n**TypeScript Version:**  2.1.1 / nightly (2.2.0-dev.201xxxxx)\r\n\r\n**Code**\r\n\r\n```ts\r\n\r\nasync function f() {\r\n let value = await anotherAsyncFunction()\r\n  ....\r\n}\r\n```\r\n\r\n**Expected behavior:**\r\nIf target type is set to ES7 (which it currently doesn't even support) it should leave the above code _as is_, since the current versions of Node already support it (and it is much easier to debug, too).\r\n\r\n**Actual behavior:**\r\n1. Currently it generates the __awaiter code and uses yield, etc.\r\n1. There's no support for target type es7\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/13197/comments",
    "author": "dharmax",
    "comments": [
      {
        "user": "alitaheri",
        "created_at": "2016-12-28T10:42:09Z",
        "body": "@dharmax es doesn't follow that versioning semantic anymore. use `es2017`."
      },
      {
        "user": "aluanhaddad",
        "created_at": "2016-12-28T12:18:57Z",
        "body": "`--target esnext` should disable all transformations that are not module format related.\r\n@alitaheri did they ever?😝 "
      },
      {
        "user": "dharmax",
        "created_at": "2016-12-28T15:21:04Z",
        "body": ":+1: \r\n@alitaheri oh, i see. I gave it a try and indeed it outputs the right code now. However, seems like my node doesn't understand async, although it's version 7.3.... "
      },
      {
        "user": "blakeembrey",
        "created_at": "2016-12-28T15:53:35Z",
        "body": "@dharmax it's still behind a flag, try `node --harmony-async-await`."
      }
    ]
  },
  {
    "number": 13149,
    "title": "Argument of type 'typeof Cat' is not assignable to parameter of type 'new () => Cat'.",
    "created_at": "2016-12-23T18:13:58Z",
    "closed_at": "2016-12-23T23:17:20Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/13149",
    "body": "**TypeScript Version:**  2.1.4\r\n\r\n**Code**\r\n```ts\r\nclass Animal {\r\n    // constructor() {} // (This constructor works)\r\n    constructor(public p: string) {} // (This constructor errors)\r\n}\r\nclass Cat extends Animal {}\r\n\r\ndeclare function DecorateAnimal<T extends Animal>(original: { new(): T }): { \r\n    new(): T; \r\n};\r\n\r\nlet DecoratedCat = DecorateAnimal(Cat);\r\n```\r\n\r\n**Expected behavior:**\r\nI expect to be able to pass `typeof Cat` to a function that takes a `new(): Cat`.  I _can_  do that unless Animal has a property, then I can't. I would at the least expect it to work in both cases or in neither case. \r\n\r\n**Actual behavior:**\r\nErrors out with `Argument of type 'typeof Cat' is not assignable to parameter of type 'new () => Cat'.`\r\n\r\n\r\nAs motivation, this came up in the context of declaring the types of a decorator function. A JS library I'm using decorates classes, returning a new class which makes changes to both the static and instance side of a class type. Something like this:\r\n\r\n```ts\r\nclass Animal<P> {\r\n    constructor(public p: P) {}\r\n}\r\nclass Cat extends Animal<string> {\r\n    meow() {}\r\n}\r\ninterface StaticDecorations<T> {\r\n    originalClass: { new(): T };\r\n}\r\ninterface InstanceDecorations<T> {\r\n    originalInstance: T;\r\n    makeTracks(): void;\r\n}\r\ndeclare function DecorateAnimal<T extends Animal<P>, P>(original: { new(): T }): { \r\n    new(): T & InstanceDecorations<T>; \r\n    prototype: { originalClass: { new(): T } }\r\n};\r\n\r\nlet DecoratedCat = DecorateAnimal(Cat);\r\n```",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/13149/comments",
    "author": "masonk",
    "comments": [
      {
        "user": "masonk",
        "created_at": "2016-12-23T23:17:20Z",
        "body": "I think I found the issue"
      },
      {
        "user": "bgever",
        "created_at": "2017-05-24T03:13:58Z",
        "body": "I had a similar error. The reason was that I didn't set default values for the properties in the constructor, hence the parameterless `new(): T` won't match.\r\n\r\nTo fix the original example:\r\n\r\n```ts\r\nclass Animal {\r\n    // constructor() {} // (This constructor works)\r\n    // constructor(public p: string) {} // (This constructor errors)\r\n    constructor(public p = '') {} // (This constructor works)\r\n}\r\nclass Cat extends Animal {}\r\n\r\ndeclare function DecorateAnimal<T extends Animal>(original: { new(): T }): { \r\n    new(): T; \r\n};\r\n\r\nlet DecoratedCat = DecorateAnimal(Cat);\r\n```"
      }
    ]
  },
  {
    "number": 13054,
    "title": "How to create an API module in Typescript?",
    "created_at": "2016-12-20T14:34:40Z",
    "closed_at": "2016-12-21T21:22:27Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/13054",
    "body": "I have a few methods and models that i want to share across several Typescript projects.\r\n\r\nWhat are the best practices to create dependency that would allow me to use the same model and methods definition across several projects?\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/13054/comments",
    "author": "bertolo1988",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2016-12-21T21:22:27Z",
        "body": "Please only log issues on the issue tracker. There are many websites available for general discussion / questions / etc."
      }
    ]
  },
  {
    "number": 12998,
    "title": "Implementing interface is not required for class children?",
    "created_at": "2016-12-17T15:38:10Z",
    "closed_at": "2017-02-28T00:28:06Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/12998",
    "body": "Lets say I have some interface:\r\n\r\n```\r\ninterface BaseInterface {\r\n  test: boolean;\r\n}\r\n```\r\n\r\nAnd then I have some class that implements it (note this class is extending another class)\r\n\r\n```\r\nclass BaseModel extends Util.Object implements BaseInterface {\r\n    // expected error as I dont have 'test' variable here.\r\n}\r\n```\r\n\r\nNow I have another class that extend `BaseModel`:\r\n```\r\nclass ChildClass extends BaseModel {\r\n    // even if I dont have 'test' variable here, I'm not getting error\r\n    // I should get it as I'm extending class that require it\r\n}\r\n```\r\n\r\nIs it bug or am I doing something wrong?",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/12998/comments",
    "author": "pie6k",
    "comments": [
      {
        "user": "aluanhaddad",
        "created_at": "2016-12-17T16:51:28Z",
        "body": "The implementation is provided by the base class. Child classes inherit it automatically. "
      },
      {
        "user": "pie6k",
        "created_at": "2016-12-17T16:58:22Z",
        "body": "What if I want parent class to be `abstract` and require child classes to implement interface, or in case they override parent class, to keep overrides following parent interface?"
      },
      {
        "user": "aluanhaddad",
        "created_at": "2016-12-17T17:29:51Z",
        "body": "Then you would decorate each method in the base class with the `abstract` modifier. Alternatively you could declare that the child class implements the base class as supposed to be deriving from it, or both.\r\n\r\n**EDIT** fixed insane typo (hunting -> deriving) due to speech to text engine 😆 "
      },
      {
        "user": "mhegazy",
        "created_at": "2016-12-19T20:20:56Z",
        "body": "TypeScript has a structural type system. at every location where a type is expected, the value is checked it it matches the expected type. the check depends on the structure, and not if type has an `implements` clause. \r\n\r\nThe only use of an `implement` clause, is to ask the compiler to give you an error if your class does not implement the interface. the class does not get any additional properties by implementing an interface."
      }
    ]
  },
  {
    "number": 12912,
    "title": "instanceof doesn't work as expected for derived class",
    "created_at": "2016-12-14T13:04:02Z",
    "closed_at": "2016-12-14T17:34:05Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/12912",
    "body": "**TypeScript Version:**  2.1.4\r\n\r\n**Code**\r\n\r\nI am seeing a very strange problem where instanceof doesn't seem to work properly for a derived class in TypeScript. The structure of my classes is as follows (I tried to make a self-contained example that shows the problem, but I couldn't reproduce the error in that simple example...):\r\n\r\n```ts\r\ninterface Serializing \r\n{\r\n    serialize(): string \r\n}\r\n\r\nclass Storage implements Serializing\r\n{\r\n    // constructor, methods, serialize, ...\r\n}\r\n\r\nclass StorageContainer\r\n{\r\n    // constructor, methods, various methods that act on storage_, ...\r\n\r\n    protected storage_: Storage;\r\n}\r\n\r\nclass Derived extends StorageContainer\r\n{\r\n    constructor()\r\n    {\r\n        super();\r\n\r\n        let test1 = this instanceof Derived; // succeeds\r\n        let test2 = this instanceof StorageContainer; // succeeds\r\n    }\r\n\r\n    // ... constructor, methods, ...\r\n}\r\n```\r\n\r\nand I then run this method using these classes:\r\n\r\n```ts\r\ntestInstanceofOnDerivedClasses()\r\n{\r\n    let derived = new Derived();\r\n\r\n    let test1 = derived instanceof Derived; // succeeds\r\n    let test2 = derived instanceof StorageContainer; // fails?\r\n}\r\n```\r\n\r\n**Expected behavior:**\r\n\r\nAll test variables should be true.\r\n\r\n**Actual behavior:**\r\n\r\nThe test2 variable in testInstanceofOnDerivedClasses (testing if derived class is an instance of the base class) fails. \r\n\r\nI also did tests with other simpler derived classes, and there instanceof does work as expected. Only in this particular case I have, it doesn't...\r\n\r\nAlso remarkable: when I do the 2 tests inside the constructor of Derived, they both succeed...\r\nBut then once outside of the constructor, the second test fails...\r\n\r\nI have already asked on SO, but I am posting this here, as I think this might be TypeScript bug that only occurs in very specific circumstances somehow:\r\n\r\n- I couldn't reproduce this in a simple self-contained example\r\n- especially the fact that the tests are OK inside the constructor, but not any longer once returned from the constructor worries me\r\n\r\nI would be glad to check out a few things if people have advice as to what to look for.\r\n\r\nI have to apologize: normally, I would provide a simple self-contained example, but in this case, I can't reproduce it that way... Since the codebase I'm working on is closed-source, I can't just post the project online, but perhaps I could ask here if I can share it privately with the Microsoft team if needed.\r\n\r\nBut if there are things I need to check first, please let me know!\r\n\r\nAdditional note: this also occurred with TypeScript 1.7.6.0. Switching to the latest version 2.1.4 didn't make a change.",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/12912/comments",
    "author": "KoenT-X",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2016-12-14T17:34:05Z",
        "body": "TypeScript doesn't do anything that could possibly cause the behavior you're describing. Once TS emits the .js code, it has no ability to change how the `instanceof` operator works depending on where the code is being run.\r\n\r\nYou'll need to narrow this down yourself - we cannot provide support for general programming problems where TypeScript happens to be involved."
      },
      {
        "user": "KoenT-X",
        "created_at": "2016-12-16T08:13:12Z",
        "body": "OK, understood. At least that gives me a direction.\r\n\r\nShould anyone else read this, and have ideas how to go about finding out where this could be coming from, I'd be interested to get some advice."
      }
    ]
  },
  {
    "number": 12877,
    "title": "How to convert enum type to Array<Object>",
    "created_at": "2016-12-13T11:47:34Z",
    "closed_at": "2016-12-13T19:04:27Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/12877",
    "body": "I want convert enum type to Array<Object>.\r\n\r\nexample : \r\n\r\nenum A {\r\n  dog = 1,\r\n  cat = 2,\r\n  ant = 3\r\n}\r\n\r\nconvert to: [{id: 1, name: 'dog'}, {id: 2, name: 'cat'}, {id: 3, name: 'ant'}]\r\n\r\n\r\nthank you.",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/12877/comments",
    "author": "attachai-b",
    "comments": [
      {
        "user": "dead-claudia",
        "created_at": "2016-12-13T14:36:37Z",
        "body": "@narutomxc \r\n\r\nThis is an issue tracker, not a standard help forum. But anyways, here's how you'd do it:\r\n\r\n```ts\r\n// This requires TypeScript 2.1.\r\n// If you need older versions, use `string` instead of `keyof E`.\r\ninterface EnumItem<E> { id: E; name: keyof E; }\r\n\r\nfunction enumToArray<E>(Enum: {[keyof E]: E}): EnumItem<E>[] {\r\n    return Object.keys(Enum).map(key => ({id: Enum[key], name: key} as EnumItem<E>))\r\n}\r\n```"
      },
      {
        "user": "attachai-b",
        "created_at": "2016-12-14T02:46:40Z",
        "body": "OK, thx"
      },
      {
        "user": "xmeng1",
        "created_at": "2017-11-01T12:57:37Z",
        "body": "I found `{[keyof E]: E}` cannot be recognise in Webstorm. so replace it with any..."
      }
    ]
  },
  {
    "number": 12833,
    "title": "Question/Idea :  Iterate over primitive values of a custom type ",
    "created_at": "2016-12-11T10:26:13Z",
    "closed_at": "2017-04-20T23:40:04Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/12833",
    "body": "**TypeScript Version:**  2.1.4\r\n\r\n**Code**\r\nThe following code used to work in TS 2.0\r\n\r\n```ts\r\ntype Digit = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9;\r\n\r\nfunction iExpectDigit(d:Digit)\r\n{ }\r\n\r\nfor (let k: Digit = 1; k < 10; k++) {\r\n  iExpectDigit(k); //Error, because K is number\r\n}\r\n\r\n```\r\nI think the new behaviour is correct.\r\nSince `k++` is an operation between a digit and a number, it does make sense that `k`becomes a number.\r\n\r\nThe only work around I've come with is \r\n\r\n```ts\r\nfor (let k: Digit = 1; k < 10; k = <Digit>(k + 1)) {\r\n    // k is digit\r\n}\r\n```\r\nor \r\n\r\n```ts\r\n// in some module\r\nexport let digits: Digit[] = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\r\n\r\nfor (let k of digits)\r\n{\r\n    // k is digit\r\n}\r\n```\r\nThe second approach is less expressive, but cleaner.\r\n\r\n**Question**\r\nIs there a better way to iterate over primitive values of a custom type ?",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/12833/comments",
    "author": "akarzazi",
    "comments": [
      {
        "user": "aluanhaddad",
        "created_at": "2016-12-11T11:06:56Z",
        "body": "I'm not sure what the use case is, but to simultaneously retain the desired type and maintain correctness, I think the following would be appropriate\r\n```ts\r\ntype Digit = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9;\r\n\r\nfunction iExpectDigit(d: Digit) { }\r\n\r\nfunction isDigit(n: number): n is Digit {\r\n    return n > -1 && n < 10 && n === Math.trunc(n);\r\n}\r\n\r\nfor (let k = 0; isDigit(k); k++) {\r\n    iExpectDigit(k);\r\n}\r\n```\r\nI say maintain correctness because in order to exit the loop in your example, `k` must take the value `10` which is not a `Digit`."
      }
    ]
  },
  {
    "number": 12821,
    "title": "Is it safe to access private members by using an element access expression?",
    "created_at": "2016-12-10T10:36:12Z",
    "closed_at": "2016-12-11T00:20:58Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/12821",
    "body": "**TypeScript Version:**  2.1 / nightly (2.2.0-dev.20161127)\r\n\r\n**Code**\r\n```ts\r\ninterface SomeType { }\r\n\r\nclass A { private m: SomeType; }\r\n\r\nclass B {\r\n\tfoo(a: A) {\r\n\t\tconst n1 = a.m; // (1)\r\n\t\tconst n2 = a[\"m\"]; // (2)\r\n\t}\r\n}\r\n```\r\nAs expected, the property access expression (1) produces a compile error. However, the element access expression (2) does not, even though typescript recognizes that (2) refers to member \"A.m\" as it infers the type \"SomeType\" for n2.\r\n\r\nCan I expect (2) to not produce any compile errors in future typescript versions?",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/12821/comments",
    "author": "hediet",
    "comments": [
      {
        "user": "ahejlsberg",
        "created_at": "2016-12-10T23:27:57Z",
        "body": "It's been that way since forever and several code bases depend on it so I don't imagine us changing it. If we did, we would minimally put it under a compiler switch."
      },
      {
        "user": "hediet",
        "created_at": "2016-12-11T00:20:58Z",
        "body": "Thank you for clarifying this!"
      }
    ]
  },
  {
    "number": 12812,
    "title": "This typing not honored",
    "created_at": "2016-12-09T21:31:47Z",
    "closed_at": "2016-12-12T07:58:37Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/12812",
    "body": "**TypeScript Version:**  2.0.3\r\n\r\n**Code**\r\n```ts\r\ninterface UIElement {\r\n    addClickListener(onclick: (this: UIElement, e: Event) => void): void;\r\n    prop: number;\r\n}\r\n\r\nlet uiElement: UIElement;\r\nuiElement.addClickListener(() => {\r\n    var k = this.prop;\r\n});\r\n```\r\n\r\n**Expected behavior:**\r\n\r\nNo error\r\n\r\n**Actual behavior:**\r\ntsc.exe --noImplicitThis blah.ts\r\nblah.ts(8,10): error TS2683: 'this' implicitly has type 'any' because it does not have a type annotation.",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/12812/comments",
    "author": "wimoy",
    "comments": [
      {
        "user": "jthomaschewski",
        "created_at": "2016-12-09T22:44:24Z",
        "body": "In your example you are using an arrow function - so the `this` available inside of this function is the same as the `this` outside - which has no type information (any)\r\n\r\nUse `function` and you get your typed this:\r\n\r\n```ts\r\ninterface UIElement {\r\n    addClickListener(onclick: (this: UIElement, e: Event) => void): void;\r\n    prop: number;\r\n}\r\n\r\nlet uiElement: UIElement;\r\nuiElement.addClickListener(function() {\r\n    var k = this.prop;\r\n});\r\n```\r\n\r\nThe behavior looks good to me. It does catch errors related to misuse of arrow functions."
      }
    ]
  },
  {
    "number": 12683,
    "title": "Missing type-awareness within scope",
    "created_at": "2016-12-06T01:37:02Z",
    "closed_at": "2016-12-06T07:19:07Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/12683",
    "body": "**TypeScript Version:**  `Version 2.1.1`\r\n\r\n**Code**\r\n\r\n```ts\r\n// Interface:\r\ninterface IRPC {\r\n    type: 'request' | 'response';\r\n    uuid: string;\r\n}\r\ninterface IRPCRequest extends IRPC {\r\n    type: 'request';\r\n    name: string;\r\n    args?: any[];\r\n}\r\ninterface IRPCResponse extends IRPC {\r\n    type: 'response';\r\n    isError?: boolean;\r\n    data: any;\r\n}\r\n// Example:\r\n// data = instance of IPRC\r\nswitch (data.type) {\r\n  case 'request':\r\n      // Because we know it can only be 'request' or 'response' we should not need\r\n      // the cast within this scope.\r\n      // Also there is no further interface/implementation where type is 'request'.\r\n      result = await this.functions[(data as IRPCRequest).name](\r\n        ...(data as IRPCRequest).args\r\n      );\r\n    break;\r\n  case 'response':\r\n    // This works fine as uuid is a field in IRPC\r\n    await this.callbacks[data.uuid](data);\r\n    return null;\r\n  default:\r\n    return null;\r\n}\r\n```\r\n\r\n**Expected behavior:**\r\ntsc should not need an explicit cast to a sub-interface.\r\n\r\n**Actual behavior:**\r\ntsc requires an explicit cast to a sub-interface to be happy.",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/12683/comments",
    "author": "T4cC0re",
    "comments": [
      {
        "user": "aluanhaddad",
        "created_at": "2016-12-06T01:45:18Z",
        "body": "> there is no further interface/implementation where type is 'request'.\r\n\r\nBut there could be such a value and it would by definition be an `IRPC`.\r\nWhat you want something like this\r\n```ts\r\ninterface ProtocolMessage {\r\n    uuid: string;\r\n}\r\ninterface IRPCRequest extends ProtocolMessage {\r\n    type: 'request';\r\n    name: string;\r\n    args?: any[];\r\n}\r\ninterface IRPCResponse extends ProtocolMessage {\r\n    type: 'response';\r\n    isError?: boolean;\r\n    data: any;\r\n}\r\n\r\ntype IRPC = IRPCRequest | IRPCResponse;\r\n```"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2016-12-06T07:19:07Z",
        "body": "Thanks for answering @aluanhaddad - the correct answer is to use a closed union so that TypeScript can analyze the cases."
      }
    ]
  },
  {
    "number": 12650,
    "title": "Bug or feature?",
    "created_at": "2016-12-04T13:38:05Z",
    "closed_at": "2016-12-04T17:53:25Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/12650",
    "body": "TypeScript Version:  2.0.10\r\n\r\nThe following code does _not_ produce a syntax error (and I am really hoping this is a feature and not a bug):\r\n```ts\r\nclass MyClass {\r\n    test: { (): number; (_: number): MyClass }\r\n}\r\nlet tmp = new MyClass();\r\ntmp\r\n    .test(22)\r\n    .test()\r\n;\r\n```\r\n\r\n**Expected behavior:**\r\nSyntax error at compilation time on MyClass declaration\r\n\r\n**Actual behavior:**\r\nRuntime error on call to ```tmp.test```\r\n\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/12650/comments",
    "author": "GordonSmith",
    "comments": [
      {
        "user": "aluanhaddad",
        "created_at": "2016-12-04T15:08:36Z",
        "body": "Definitely not a bug. It is a valid type annotation. Initializing is a bit of a pain.\\\r\n```ts\r\nclass MyClass {\r\n  test: { (): number; (_: number): MyClass } = ((_?: number) => {\r\n    if (_ || _ === 0) {\r\n      return new MyClass();\r\n    }\r\n    return 10;\r\n  }) as any;\r\n}\r\nlet tmp = new MyClass();\r\n```\r\nNo runtime errors"
      },
      {
        "user": "GordonSmith",
        "created_at": "2016-12-04T17:53:25Z",
        "body": "@aluanhaddad Interesting and I think your may well be correct since \"test\" is just a property and not a method (which happens to be an instance of an interface declared inline).\r\n\r\nWhat I wrote is effectively a more declarative version of this:\r\n```\r\nclass MyClass {\r\n    test2: (_?) => number | MyClass;\r\n}\r\n```\r\nWhich also produces no compile time error - thx.\r\n "
      }
    ]
  },
  {
    "number": 12569,
    "title": "how can I use jquery method like this $(\"#id\")?",
    "created_at": "2016-11-30T03:41:41Z",
    "closed_at": "2016-12-05T05:52:17Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/12569",
    "body": "while i use the typescript 2\r\n\r\n\r\n`import $ from 'jquery'`\r\n`{`\r\n`    $.getJSON(...)//works`\r\n`    $(...)//error; tip is $ is an Object`\r\n`}`\r\n\r\n\r\ni found the document described that it is unable to use the module as a function.\r\nbut i do want it works\r\n\r\ni also try the usage ` const $ = require('jquery')`, and it does work, but it has no tips at all.\r\n\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/12569/comments",
    "author": "renyaoxiang",
    "comments": [
      {
        "user": "aluanhaddad",
        "created_at": "2016-11-30T03:49:27Z",
        "body": "This is going to depend on your loader and module format. What are they?\r\n\r\nBy the way,\r\n```ts\r\nconst $ = require('jquery');\r\n```\r\nnever provides intellisense.\r\nit needs to be \r\n```ts\r\nimport $ = require('jquery');\r\n```"
      },
      {
        "user": "aluanhaddad",
        "created_at": "2016-11-30T03:51:28Z",
        "body": "Also, is this a runtime issue or is the code working but you are getting a compile time error?"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2016-11-30T18:10:25Z",
        "body": "Please ask questions on e.g. Stack Overflow. This is not a general support forum."
      },
      {
        "user": "aluanhaddad",
        "created_at": "2016-12-01T06:24:07Z",
        "body": "@RyanCavanaugh Sorry, I didn't mean to indulge this."
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2016-12-01T06:25:16Z",
        "body": "No worries @aluanhaddad!"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2016-12-01T07:36:22Z",
        "body": "Yeah no trouble, if people want to ask questions and other people want to answer them that's cool, we just need to set expectations that TS members don't have resources to help out with everyday stuff. We can't seem to stop people from asking anyway :smile:"
      },
      {
        "user": "renyaoxiang",
        "created_at": "2016-12-05T05:51:01Z",
        "body": "any how , i fixed the question\r\n$ can be used like a normal way like in javascript"
      }
    ]
  },
  {
    "number": 12549,
    "title": "bug: type predicates (`V is T`) fails on expressions (`V[K] is T`)",
    "created_at": "2016-11-29T04:37:52Z",
    "closed_at": "2016-11-29T07:13:38Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/12549",
    "body": "**TypeScript Version:** nightly (2.2.0-dev.20161128)\r\n\r\n**Code**\r\n\r\n```ts\r\npropIs<T, V, K extends keyof V>(type: T, name: K, obj: V): V[K] is T;\r\n```\r\n\r\n**Expected behavior:**\r\nTS being totally cool with `V[K] is T`.\r\n\r\n**Actual behavior:**\r\nNope, many syntax errors.\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/12549/comments",
    "author": "KiaraGrouwstra",
    "comments": [
      {
        "user": "DanielRosenwasser",
        "created_at": "2016-11-29T04:42:19Z",
        "body": "The type predicate syntax has always taken a parameter name on the left side of the `is` keyword. So it sounds like what you want is better parser recovery here."
      },
      {
        "user": "KiaraGrouwstra",
        "created_at": "2016-11-29T04:50:16Z",
        "body": "Oh, yeah, `V is T` itself works fine, this seems to be specifically about adding the `[K]` there. It does seem like storing (`extends`) `V[K]` in a new generic may form a solution here...\r\nBut apparently `propIs<T, V, K extends keyof V, R extends V[K]>(type: T, name: K, obj: V): R is T;` yields `Cannot find parameter 'R'`. I must be doing something wrong...\r\n"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2016-11-29T06:07:13Z",
        "body": "Well it's only the *parameter* that a type predicate can operate on - in other words, you write\r\n\r\n```ts\r\nfunction foo(x: any): x is string {\r\n    // ....\r\n}\r\n```\r\n\r\nAs opposed to the following:\r\n\r\n```ts\r\nfunction foo(x: any): any is string {\r\n    // ....\r\n}\r\n```"
      },
      {
        "user": "KiaraGrouwstra",
        "created_at": "2016-11-29T06:34:59Z",
        "body": "I'm sorry, that would be my misinterpretation then.\r\nIn that event I would be inclined to try the following for this specific case:\r\n```ts\r\npropIs<T, V, K extends keyof V, R extends V[K]>(type: T, name: K, obj: V): obj[name] is T;\r\n```\r\nStill not okay though. I suppose it'd help if I had the ability to save this result to a new variable first, but I'm not confident I can do this in the type language...\r\n"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2016-11-29T07:08:10Z",
        "body": "You could do something like this:\r\n\r\n```ts\r\npropIs<T, V, K extends keyof V, R extends V[K]>(type: T, name: K, obj: V): obj is (V & Record<K, T>)\r\n```"
      },
      {
        "user": "KiaraGrouwstra",
        "created_at": "2016-11-29T07:13:38Z",
        "body": "Whoa, some out of the box thinking there, wouldn't have come up with that myself. Thanks for thinking along. :)"
      }
    ]
  },
  {
    "number": 12509,
    "title": "T[keyof T] types as constraints",
    "created_at": "2016-11-26T00:51:48Z",
    "closed_at": "2016-12-15T18:53:28Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/12509",
    "body": "**TypeScript Version:**  2.2.0-dev.20161125\r\n\r\n**Code**\r\n\r\n```ts\r\ntype MapOf<T> { [ x: string ]: T | never } // values only of type T\r\ntype Box<T> { value: T }\r\n\r\n// Here we show that the above type constrains valid types for values of MapOf<T> to T\r\nconst t: MapOf<number> = { foo: 1 } // compiles\r\nconst tbad: MapOf<number> = { foo: 'foo' } // does not compile\r\n\r\n// assign every value of MapOf<T> to some T\r\nfunction forMapsOf <T> ( m: MapOf<T>, t: T ) {\r\n  for ( var k in m ) { \r\n    m[k] = t\r\n  }\r\n} // Compiles and works as expected\r\n\r\n// now let's transform the definition of the above function slightly\r\nfunction forMapsOf <T, M extends MapOf<T>> ( m: M, t: T ) {\r\n  for ( var k in m ) { \r\n    m[k] = t\r\n  }\r\n} // DOES NOT COMPILE - Says \"Type T is not assignable to type M[keyof M]\r\n\r\n// The above is crucial for this function below which would take a map of \r\n// Boxed values and update them from a map of unboxed values\r\nfunction updateBoxed \r\n<T, \r\n U extends Only<T>, \r\n B extends { [ K in keyof U ]: Box<U[K]> }> \r\n( b: B, u: U ) {\r\n  for ( var k in u ) { \r\n    b[k].value = u[k]\r\n  }\r\n} // DOES NOT COMPILE - Says \"Type U[keyof U] is not assignable to type T\"\r\n```\r\n\r\n**Expected behavior:**\r\nI would expect the value of a type indexing itself to in-fact be all the types of its values.  This should be knowable at compile-time and especially so if the type is constrained as ```T | never```\r\n\r\n**Actual behavior:**\r\nCompiler does not recognize that U[keyof U] is the same as T. \r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/12509/comments",
    "author": "stevekane",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2016-11-26T22:13:09Z",
        "body": "I am not not sure i understand the issue. so bear with me..\r\nI do not see how the maps is related tot he boxed version. `Mapof<T>` forgets all the properties by vertue of the indexer. so it does not fit with the `updateBoxed` function. i would expect this to be typed as:\r\n\r\n```ts\r\ntype Boxed<T> = {\r\n    [P in keyof T]: { value: T[P] }\r\n}\r\nfunction updateBoxed<U> (b: Boxed<U>, u: U) {\r\n    for (var k in u) {\r\n        b[k].value = u[k]\r\n    }\r\n}\r\n\r\n// usage\r\n\r\nvar obj = { a: 1, b: \"string\" };\r\n\r\nvar boxed = boxify(obj);\r\n\r\nupdateBoxed(boxed, { a: 2 });// OK\r\nupdateBoxed(boxed, { a: 2, b: \"anotherString\" });// OK\r\nupdateBoxed(boxed, { a: false });// Error\r\n```"
      },
      {
        "user": "ahejlsberg",
        "created_at": "2016-11-28T07:07:27Z",
        "body": "@stevekane Check out #12528 for an example of how to implement this."
      }
    ]
  },
  {
    "number": 12394,
    "title": "Passing Html element id in typescript",
    "created_at": "2016-11-20T15:22:56Z",
    "closed_at": "2017-04-21T16:56:30Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/12394",
    "body": "I have a HTML file with 2 textbox and i want to calculate length and breadth on button click and based on the value entered in textbox and bind it on label : here is my code\r\nindex.html\r\n<body> <br/><br/>\r\n    <div class=\"row\">\r\n        <div class=\"col-md-2\"></div>\r\n        <div class=\"col-md-4\">\r\n            <div class=\"form-group\">\r\n                <label for=\"length\">Length:</label>\r\n                <input type=\"number\" class=\"form-control\" id=\"length\" />\r\n            </div>\r\n            <div class=\"form-group\">\r\n                <label for=\"breadth\">Breadth:</label>\r\n                <input class=\"form-control\" id=\"breadth\" />\r\n            </div>\r\n           \r\n            <div class=\"form-group\">\r\n              <button type=\"button\" class=\"btn btn-primary\" onclick=\"\">Submit</button>\r\n            </div>\r\n\r\n            <div class=\"form-group\">\r\n                <label for=\"calc\">Area of Rectangle is : </label>\r\n                <label id=\"label_to_bind\" ></label>\r\n                \r\n            </div>\r\n            \r\n        </div>\r\n        <div class=\"col-md-6\"></div>\r\n    </div>\r\n\r\napp.ts\r\n\r\nnamespace example\r\n{\r\n   interface CalculateArea\r\n    {\r\n        Recatngle: ( l: number, b: number ) => number;\r\n    }\r\n\r\n   \r\n    var area: CalculateArea = {\r\n        Recatngle: function ( l: number, b: number )\r\n        {\r\n            return l * b;\r\n        }\r\n    }\r\n    //Get Element id from UI\r\n    var a = document.getElementById( \"Length\" ).innerHTML;\r\n    var b = document.getElementById( \"Breadth\" ).innerHTML;\r\n    var z = area.query( a,b ); // showing me error here \"string is not assignable to parameter type  number\r\n}\r\nCan any body tell me where i am making mistake and also please tell me how do i  make a call on button click and bind result on label\r\n\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/12394/comments",
    "author": "Ashwani44",
    "comments": [
      {
        "user": "saschanaz",
        "created_at": "2016-11-20T16:43:17Z",
        "body": "This is not an answer but you can insert triple backticks to prevent incorrect document format.\n\n<pre>\n```html\n&lt;div&gt;\nCode in the backtick shell\n&lt;/div&gt;\n```\n</pre>\n"
      },
      {
        "user": "aluanhaddad",
        "created_at": "2016-11-20T19:21:27Z",
        "body": "InnerHTML is a string but the API expects a number.\nIf it requires a number and what you have is a string you should convert it appropriately.\nYou can use the `Number` or `parseInt` or `parseFloat` global functions. Remember to pass a radix when calling `parseInt`.\n"
      }
    ]
  },
  {
    "number": 12385,
    "title": "error TS2304: Cannot find name 'UriMapHandlerArray'.",
    "created_at": "2016-11-19T21:03:42Z",
    "closed_at": "2016-11-19T23:52:05Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/12385",
    "body": "UriMapHandlerArray is defined in the same file, TS cannot find it.\r\n\r\nts v2.0.10\r\n**Code**\r\n\r\n```js\r\ninterface UriMapHandlerArray {\r\n  [index: string]: IUriMapHandler;\r\n}\r\n\r\nexport class Furi {\r\n\r\n  private _get:    IUriMap = { uri_map: UriMapHandlerArray };\r\n```\r\n\r\n```ts\r\n// A *self-contained* demonstration of the problem follows...\r\n\r\n```\r\n\r\n**Expected behavior:**\r\n\r\n**Actual behavior:**\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/12385/comments",
    "author": "rajinder-yadav",
    "comments": [
      {
        "user": "j-oliveras",
        "created_at": "2016-11-19T21:20:02Z",
        "body": "You uses UriMapHandlerArray as a value of uri_map property not as a type.\n\nIf you want to define IUriMap type as { uri_map: UriMapHandlerArray } you can do:\n`type IUriMap = { uri_map: UriMapHandlerArray }`\nor:\n`interface IUriMap { uri_map: UriMapHandlerArray }`\nand then use it as \n\n```\nexport class Furi {\n  private _get: IUriMap = { uri_map: {} };\n}\n```\n"
      },
      {
        "user": "rajinder-yadav",
        "created_at": "2016-11-19T23:52:05Z",
        "body": "OK I see my mistake, thanks!\n"
      }
    ]
  },
  {
    "number": 12204,
    "title": "async/await with arrow functions compiles to invalid javascript with SyntaxError",
    "created_at": "2016-11-12T23:10:52Z",
    "closed_at": "2016-11-13T00:43:16Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/12204",
    "body": "<!-- BUGS: Please use this template. -->\r\n**TypeScript Version:**  2.0.9\r\n\r\n**Code**\r\n```ts\r\ntest('smoke', async t => {\r\n\tawait Promise.resolve();\r\n});\r\n```\r\n\r\n**Expected behavior:**\r\nNo SyntaxError.\r\n\r\n**Actual behavior:** \r\n```js\r\ntest('smoke', function (t) __awaiter(this, void 0, void 0, function* () {\r\n    yield Promise.resolve();\r\n}));\r\n```\r\n```\r\n  SyntaxError: test.js: Unexpected token, expected { (47:27)\r\n  45 |     t.pass();\r\n  46 | });\r\n> 47 | test('smoke', function (t) __awaiter(this, void 0, void 0, function* () {\r\n     |                            ^\r\n  48 |     yield Promise.resolve();\r\n  49 | }));\r\n  50 | test('save', function (t) {\r\n```\r\n\r\nBut general function (non-async) compiles to valid javascript.\r\n```\r\ntest('smoke', async function (t) {\r\n\tawait Promise.resolve();\r\n});\r\n```\r\n```\r\ntest('smoke', function (t) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n        yield Promise.resolve();\r\n    });\r\n});\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/12204/comments",
    "author": "unlight",
    "comments": [
      {
        "user": "DanielRosenwasser",
        "created_at": "2016-11-13T00:42:39Z",
        "body": "You should be getting an error message that TypeScript 2.0 can't target ES5 when using async functions, so the incorrect emit is expected.\n\nIn 2.1, this will be fixed. You can use the 2.1 release candidate by running\n\n```\nnpm install -g typescript@rc\n```\n\nor use our nightlies by running\n\n```\nnpm install -g typescript@next\n```\n"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2016-11-13T00:43:00Z",
        "body": "Also check out #7706.\n"
      }
    ]
  },
  {
    "number": 12167,
    "title": "importHelpers does not emit import unless at least one other import is present",
    "created_at": "2016-11-11T01:30:37Z",
    "closed_at": "2017-02-28T00:28:15Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/12167",
    "body": "Noticed on a webpack project with typescript@2.1.1, using either commonjs or es2015 modules:\r\n\r\n```ts\r\n// index.ts\r\n\r\nimport './empty'\r\n\r\nasync function x () {}\r\n```\r\n\r\n```ts\r\n// empty.ts\r\n```\r\n\r\nThis emits an import for `tslib` following by the import for `empty`. However, commenting the `import 'empty'` line out also omits the import for `tslib`, and the emitted code attempts to use a global `__awaiter`.\r\n\r\nI thought this might have been fixed by #12151, but it's still present in current `master` (built with `gulp LKG`).",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/12167/comments",
    "author": "Jessidhia",
    "comments": [
      {
        "user": "Jessidhia",
        "created_at": "2016-11-11T01:41:02Z",
        "body": "Using `isolatedModules` gives a clue: the \"Cannot compile namespaces\" error hints that tsc doesn't/can't treat files without `import`/`export` as a module.\n\nWith `isolatedModules` enabled, putting an `export {}` is enough to pass the `isolatedModules` condition, and the code is emitted with the `tslib` import.\n"
      },
      {
        "user": "Checksum",
        "created_at": "2017-01-10T10:59:41Z",
        "body": "Just wasted two hours on this! With an empty import statement, it works as intended. Tested on version `2.2.0-dev.20170110`"
      },
      {
        "user": "mhegazy",
        "created_at": "2017-01-21T22:35:22Z",
        "body": "If the file does not have a toplevel import/export is it is not considered a module, and it is treated as script/global.\r\n\r\nuse `--isolatedModules` to flag these files as errors."
      }
    ]
  },
  {
    "number": 12122,
    "title": " TypeScriptLanguageService:For literals, typeToString() returned an incorrect value",
    "created_at": "2016-11-09T08:22:47Z",
    "closed_at": "2017-04-21T16:31:29Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/12122",
    "body": "<!-- BUGS: Please use this template. -->\r\n**TypeScript Version:**  2.0.8\r\n\r\n**Code**\r\n(1) data for  TypeScriptLanguageService:\r\nvar numVar: number = 1;\r\nvar boolBar: boolean = false;\r\nvar undefVar=undefined;\r\nvar nullStr:string = null;\r\n\r\n**Expected behavior:**\r\ntypeToString() same as  runtime's typeof() .\r\n!! value=1,fullyQualifiedType=number,simple type=number\r\n!! value=false,fullyQualifiedType=boolean,simple type=boolean\r\n!! value=null,fullyQualifiedType=object,simple type=object\r\n\r\n**Actual behavior:** \r\ntypeToString()  returns value.\r\n!! value=1,fullyQualifiedType=number,simple type=number\r\n!! value=false,fullyQualifiedType=false,simple type=false\r\n!! value=null,fullyQualifiedType=null,simple type=null\r\n\r\n**Code(2)**\r\n(2) Reproduced code:\r\n```ts\r\nimport fs = require(\"fs\");\r\nimport * as ts from \"typescript\";\r\nvar curTypeChecker: ts.TypeChecker;\r\nvar idList:any = {};\r\nfunction report(node: ts.Node, message: string) {\r\n    let { line, character } = node.getSourceFile().getLineAndCharacterOfPosition(node.getStart());\r\n    let kind: string = \"un known\";\r\n    switch (node.kind) {\r\n        case ts.SyntaxKind.Identifier:\r\n            kind = (curTypeChecker.typeToString(curTypeChecker.getTypeAtLocation(node)));\r\n            idList[node.getText()] = kind;\r\n            console.log(`id=${node.getText()} = ${idList[node.getText()]},type=${typeof(idList[node.getText()])}`)\r\n            break;\r\n        case ts.SyntaxKind.VariableDeclaration:\r\n        case ts.SyntaxKind.PropertyDeclaration:\r\n        kind = ts.SyntaxKind[node.kind];\r\n            if ((<ts.VariableDeclaration>node).initializer) {\r\n                console.log(\"initializer exist\");\r\n                kind += \"==\" + curTypeChecker.typeToString(curTypeChecker.getTypeAtLocation(((<ts.VariableDeclaration>node).initializer)), undefined, ts.TypeFormatFlags.UseFullyQualifiedType);\r\n            }\r\n            break;\r\n        case ts.SyntaxKind.NullKeyword:\r\n        case ts.SyntaxKind.UndefinedKeyword:\r\n        case ts.SyntaxKind.NumericLiteral:\r\n        case ts.SyntaxKind.TrueKeyword:\r\n        case ts.SyntaxKind.FalseKeyword:\r\n            var fullyQualifiedType: string = curTypeChecker.typeToString(curTypeChecker.getTypeAtLocation(node), undefined, ts.TypeFormatFlags.UseFullyQualifiedType);\r\n            var simpleType = curTypeChecker.typeToString(curTypeChecker.getTypeAtLocation(node));\r\n            console.log(`!! value=${node.getText()},fullyQualifiedType=${fullyQualifiedType},simple type=${simpleType}`)\r\n            kind = ts.SyntaxKind[node.kind] + \"==\" + fullyQualifiedType\r\n            break;\r\n        case ts.SyntaxKind.IfStatement:\r\n            if (ts.SyntaxKind.IfStatement === node.kind){\r\n                console.log(`IfStatement, text=${node.getText()}}`);\r\n            } else if (ts.SyntaxKind.IfStatement === node.kind || 1+1 !== 2){\r\n            }\r\n        default:\r\n            kind = ts.SyntaxKind[node.kind];\r\n    }\r\n    console.log(`${node.getSourceFile().fileName} (${line + 1},${character + 1})::kind=${kind}:: ${message}`);\r\n}\r\nfunction doNode(node: ts.Node) {\r\n    report(node, node.getText());\r\n    ts.forEachChild(node, doNode);\r\n}\r\nfunction compile(fileNames: string[], options: ts.CompilerOptions): void {\r\n    let program = ts.createProgram(fileNames, options);\r\n    curTypeChecker = program.getTypeChecker();\r\n    let emitResult = program.emit();\r\n    let allDiagnostics = ts.getPreEmitDiagnostics(program).concat(emitResult.diagnostics);\r\n    allDiagnostics.forEach(diagnostic => {\r\n        if (diagnostic.file) {\r\n\r\n            let { line, character } = diagnostic.file.getLineAndCharacterOfPosition(diagnostic.start);\r\n            let message = ts.flattenDiagnosticMessageText(diagnostic.messageText, '\\n');\r\n            console.log(`--diagnostic--${diagnostic.file.fileName} (${line + 1},${character + 1}): ${message}`);\r\n        } else {\r\n            console.log(`--diagnostic.code=${diagnostic.code}`);\r\n        }\r\n    });\r\n    var curSource: ts.SourceFile = program.getSourceFile(fileNames[0]);\r\n     doNode(curSource);\r\n    console.log(`Diagnostics count= '${allDiagnostics.length}'.`);\r\n    let exitCode = emitResult.emitSkipped ? 1 : 0;\r\n    console.log(`Process exiting with code '${exitCode}'.`);\r\n    process.exit(exitCode);\r\n}\r\n\r\nconsole.log(\"begin\")\r\nprocess.argv.forEach((v,i,a)=>{\r\n    console.log(v);\r\n})\r\ncompile(process.argv.slice(2), {\r\n    noEmitOnError: true, noImplicitAny: true,\r\n    target: ts.ScriptTarget.ES5, module: ts.ModuleKind.CommonJS\r\n});\r\nconsole.log(\"normal end\")\r\n\r\n```\r\n\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/12122/comments",
    "author": "reversi-fun",
    "comments": [
      {
        "user": "nchen63",
        "created_at": "2016-12-08T23:59:40Z",
        "body": "I see `tc.typeToString(tc.getTypeAtLocation(node.left)` evaluate to the string \"1\" if node.left is the number `1` in v2.1.4"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2016-12-12T23:59:43Z",
        "body": "You're seeing the literal types, which is expected in this case. It's straightforward to detect these and convert to their base primitive types if so desired (see the implementation of getBaseTypeOfLiteralType in checker.ts)."
      },
      {
        "user": "reversi-fun",
        "created_at": "2016-12-15T09:18:13Z",
        "body": "I was dissatisfied with incompatibility.\r\nI implemented it.\r\nbut insufficent result.\r\n` !! value=null,fullyQualifiedType=null,simple type=null`\r\n\r\nMy Expected behavior:\r\n`!! value=null,fullyQualifiedType=object,simple type=object`\r\n>>\r\n```\r\nfunction getFullBaseTypeStringAtNode(node:ts.Node) : string{\r\n   var type =curTypeChecker.getTypeAtLocation(node);\r\n   if(type.flags & ts.TypeFlags.StringLiteral ){return \"string\";}\r\n   else if(type.flags & ts.TypeFlags.NumberLiteral) { return \"number\" ;}\r\n   else if(type.flags & ts.TypeFlags.BooleanLiteral) { return \"boolean\";}\r\n   else if(type.flags & ts.TypeFlags.Null) {return \"null\";}\r\n   else if(type.flags & ts.TypeFlags.EnumLiteral) {type=(<ts.EnumLiteralType>type).baseType;}\r\n   return curTypeChecker.typeToString(type, undefined, ts.TypeFormatFlags.UseFullyQualifiedType);\r\n}\r\n```\r\n<<"
      },
      {
        "user": "reversi-fun",
        "created_at": "2016-12-15T09:20:57Z",
        "body": "anybody, please tell me a better solution."
      }
    ]
  },
  {
    "number": 12078,
    "title": "typescript change number when cast from json",
    "created_at": "2016-11-07T09:09:19Z",
    "closed_at": "2016-11-07T19:31:53Z",
    "labels": [
      "Question",
      "External",
      "Working as Intended"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/12078",
    "body": "i am geting json data from a web api as the following  :\r\n{\"name\":\"johan\",\"packageNo\":[100000498827944537]}\r\nbut when i use it in typeScript project the packageNo change to number : 100000498827944540\r\nWhyyyyyyyyyyyyyyyyyyyyyyyyyyyy?",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/12078/comments",
    "author": "itsurge",
    "comments": [
      {
        "user": "alitaheri",
        "created_at": "2016-11-07T09:25:18Z",
        "body": "It's not related to typescript. it's simply how javascript handles number.\nThe maximum safely representable integer in javascript is 9007199254740991 which is a couple of zeroes smaller than your number. no wonder it gets messy. don't cast this to number, you can't represent it. use `string` instead.\n\n``` js\n9007199254740991    // max safe\n100000498827944540  // your number :O\n```\n"
      },
      {
        "user": "aluanhaddad",
        "created_at": "2016-11-07T14:37:11Z",
        "body": "Just to clarify TypeScript does not perform typecasting at all. What you think of as casting is actually type assertion. It is purely a design time feature and has no impact on the code that is either emitted or executed.\n"
      }
    ]
  },
  {
    "number": 12005,
    "title": "TS is incorrectly disallowing a variable assignment.",
    "created_at": "2016-11-02T20:25:10Z",
    "closed_at": "2016-11-03T16:14:46Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/12005",
    "body": "**TypeScript Version:**  2.0.3 \r\n\r\n**Code**\r\n\r\nAll of the code in this issue can be run in the playground.\r\n\r\nThe following gives this compile error: **\"Type 'EntityInstance' is not assignable to type 'EntityInstance'.\"**\r\n\r\n```ts\r\nexport class EntityInstance {\r\n    public deleted = false;\r\n    private children = new EntityArray<EntityInstance>();\r\n\r\n    getChildren(): EntityArray<EntityInstance> {\r\n        return this.children;\r\n    }\r\n}\r\n\r\nexport class ExtendedInstance extends EntityInstance {\r\n    public anotherProperty = true;\r\n\r\n    getChildren(): EntityArray<ExtendedInstance> {\r\n        return super.getChildren() as EntityArray<ExtendedInstance>;\r\n    }\r\n}\r\n\r\nlet ei = new ExtendedInstance();\r\nei.getChildren()[0].anotherProperty = false;\r\n\r\nexport class EntityArray<EntityInstance> extends Array<EntityInstance> {\r\n\r\n    delete(index?: number) {\r\n        let ei = new EntityInstance();\r\n        ei = this.splice( index, 1 )[0];\r\n        ei.deleted = true;\r\n    }\r\n}\r\n\r\n```\r\n\r\n**Expected behavior:**\r\n\r\nThis should be allowed.  It appears that TS thinks that EntityInstance as specified in \"EntityArray<EntityInstance>\" is a different type from EntityInstance.  The former EntityInstance doesn't appear to have type information.  For example, if I rewrite the delete() as follows there is an error because TS doesn't know about the 'deleted' property:\r\n\r\n```ts\r\n    delete(index?: number) {\r\n        let ei = this.splice( index, 1 )[0];\r\n        ei.deleted = true;\r\n    }\r\n```\r\n\r\n**Actual behavior:** \r\n\r\nTS raises compile error.\r\n\r\n**More notes:**\r\n\r\nI could define EntityArray without the <> (which then correctly determines the types in delete) but then I lose type information when I call ExtendedInstance.getChildren().  For example, the above code fails when rewitten as:\r\n\r\n```ts\r\nexport class EntityInstance {\r\n    public deleted = false;\r\n    private children = new EntityArray();\r\n\r\n    getChildren(): EntityArray {\r\n        return this.children;\r\n    }\r\n}\r\n\r\nexport class ExtendedInstance extends EntityInstance {\r\n    public anotherProperty = true;\r\n\r\n    getChildren(): EntityArray {\r\n        return super.getChildren();\r\n    }\r\n}\r\n\r\nlet ei = new ExtendedInstance();\r\nei.getChildren()[0].anotherProperty = false;\r\n\r\nexport class EntityArray extends Array<EntityInstance> {\r\n\r\n    delete(index?: number) {\r\n        let ei = new EntityInstance();\r\n        ei = this.splice( index, 1 )[0];\r\n        ei.deleted = true;\r\n    }\r\n}\r\n```\r\n\r\nI can get by the original error by casting to <any> in the delete method but who wants to do that in Typescript?\r\n\r\n```ts\r\ndelete(index?: number) { \r\n    let ei = this.splice( index, 1 )[0] as any; \r\n    ei.deleted = true; \r\n}\r\n```",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/12005/comments",
    "author": "DeegC",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2016-11-02T21:53:33Z",
        "body": ">  It appears that TS thinks that EntityInstance as specified in \"EntityArray<EntityInstance>\" is a different type from EntityInstance\n\nIt is. You declared a type parameter that shadowed the name:\n\n``` ts\nclass EntityArray<EntityInstance> extends Array<EntityInstance> {\n```\n\nYou probably meant to write\n\n``` ts\nclass EntityArray extends Array<EntityInstance> {\n```\n"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2016-11-02T21:54:42Z",
        "body": "Or perhaps this:\n\n``` ts\nclass EntityArray<T extends EntityInstance> extends Array<T> {\n```\n"
      },
      {
        "user": "DeegC",
        "created_at": "2016-11-03T15:32:26Z",
        "body": "Thanks Ryan, that solved my problem.  It does seem like a confusing error message; would it be possible to flag the original `EntityArray<EntityInstance>` as an error for attempting to create a type with an already-existing name?\n\nEither way, I appreciate the help.\n"
      },
      {
        "user": "aluanhaddad",
        "created_at": "2016-11-03T15:59:48Z",
        "body": "Shadowing is, for better or worse, a part of JavaScript that is fairly ubiquitous. Of course these are types, not Java Script values but it makes sense that the same naming rules would apply. Maybe just displaying that it's a type parameter in the error message would be helpful.\n"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2016-11-03T16:14:46Z",
        "body": "It's kind of necessary to allow type name shadowing, otherwise we wouldn't be able to safely add things to the global namespace without the risk of a breaking change.\n\nThere's perhaps a suggestion lurking here which is that our error messages should do something (I don't know what) if we ever issue a message like \"Cannot assign X to X\" where both X's have identical spelling. I mean ideally you'd see something like \"Cannot assign X (Type Parameter) to X (Interface)\", but it's hard to guess if even that would cover all the cases.\n"
      },
      {
        "user": "aluanhaddad",
        "created_at": "2016-11-04T11:17:05Z",
        "body": "> There's perhaps a suggestion lurking here which is that our error messages should do something (I don't know what) if we ever issue a message like \"Cannot assign X to X\" where both X's have identical spelling. I mean ideally you'd see something like \"Cannot assign X (Type Parameter) to X (Interface)\", but it's hard to guess if even that would cover all the cases.\n\n@RyanCavanaugh I was going to suggest this at first but there are a lot of lenses via which to look at a type so it could become ambiguous, or a just a best guess, in a lot of cases. \n\nMaybe a simpler, higher value option would be to do something like\n\n``` scala\ngiven Types A and B over assignment\nwhere not A assignable to B\nreport IncompatableAssignementOfIdenticallyNamedTypesDiagnostic\nwhen A name is B name\notherwise report IncompatibleTypesDiagnostic\n```\n\nSo it would say something like **\"Type 'B' is not assignable to type 'A'. (note that they are _not_ same Declaration)\"**\n"
      },
      {
        "user": "DeegC",
        "created_at": "2016-11-05T20:17:36Z",
        "body": "Would it be possible to make it illegal for the name of a generic type to shadow a previously defined type?  I'm obviously no TS expert (yet!) but I can't think of a reason one would need to shadow a currently existing type.  The error message could be something like \"Generic type name 'EntityInstance' not allowed because it would shadow an existing type.'\n\nThat would potentially break some current client code; if that's forbidden maybe make it a warning?\n"
      }
    ]
  },
  {
    "number": 11887,
    "title": "Typescript error TS5055",
    "created_at": "2016-10-27T12:49:27Z",
    "closed_at": "2016-10-27T18:34:15Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/11887",
    "body": "**TypeScript Version:**  nightly (2.1.0-dev.20161027)\n\n**Simulation**\n\nCreate a project with the following configuration:\n\n``` json\n{\n  \"compilerOptions\": {\n    \"module\": \"commonjs\",\n    \"target\": \"es5\",\n    \"experimentalDecorators\": true,\n    \"emitDecoratorMetadata\": true,\n    \"noImplicitAny\": true,\n    \"noUnusedParameters\": true,\n    \"noUnusedLocals\": true,\n    \"noEmitOnError\": true,\n    \"skipLibCheck\": true,\n    \"declaration\": true,\n    \"sourceMap\": true,\n    \"outDir\": \"out/\",\n    \"rootDir\": \"src\",\n    \"baseUrl\": \"src\",\n    \"moduleResolution\": \"node\",\n    \"lib\": [\n      \"es5\",\n      \"es2015\",\n      \"dom\"\n    ]\n  },\n  \"exclude\": [\n    \"node_modules\"\n  ]\n}\n```\n\nThe directory structure should be:\n- project\n  - src\n    - index.ts\n    - hello.ts\n  - out\n\nThe content of the `hello.ts` could be:\n\n``` typescript\nexport function hello(name: string) {\n  return `Hello, ${name}`;\n}\n```\n\nThe `index.ts` should re-export the hello module contents:\n\n``` typescript\nexport * from \"./hello\";\n```\n\nAfter that, compile twice using the vscode or the tsc:\n- `tsc -p .`\n- `tsc -p .`\n\n**Expected behavior:**\n\nCompile and produce again the js and the definitions.\n\n**Actual behavior:** \n\nIn the first compilation, it will compile normally. But at the second one, it will file with a message like `error TS5055: Cannot write file '.../hello.d.ts' because it would overwrite input file.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/11887/comments",
    "author": "danfma",
    "comments": [
      {
        "user": "danfma",
        "created_at": "2016-10-27T12:55:40Z",
        "body": "Just to point out, it works with the current production release version.\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2016-10-27T18:34:14Z",
        "body": "add your  `\"outDir\"` to your exclude list. i.e.:   `\"exclude\": [\"node_modules\", \"out\"]`\n"
      },
      {
        "user": "danfma",
        "created_at": "2016-11-04T15:56:46Z",
        "body": "Ohhh man, what a mistake! Thanks! ;)\n"
      }
    ]
  },
  {
    "number": 11876,
    "title": "QUESTION: Advanced intersection type",
    "created_at": "2016-10-27T01:37:51Z",
    "closed_at": "2017-05-22T22:35:28Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/11876",
    "body": "Hi, we are preparing typings fro the amazing semantic-ui-react project.\n\nOne of the properties of the library is the possibility to define how the element will be rendered.\nFor example:\n\n``` js\n<Button>Text</Button>\n```\n\nis rendered as\n\n``` js\n<button class=\"ui button\">Text</button>\n```\n\nBut, if I want to make a link button I can do (note the **as** param)\n\n``` js\n<Button as=\"a\" href=\"/\">Text</Button>\n```\n\nis rendered as\n\n``` js\n<a class=\"ui button\" href=\"/\">Text</button>\n```\n\nNow, the problem is, that I do not know how to merge the typings based on the property specified in the \"as\" element.\n\nWhat we have is this:\n\n``` js\ninterface ButtonProps {\n...\n}\n\ninterface ButtonStatic extends React.StatelessComponent<IButtonProps> {\n}\n\nexport const Button: ButtonStatic;\n```\n\nThe idea is do do following, but the T needs to come from attribute \"as\":\n\n``` js\ninterface ButtonStatic<T> extends React.StatelessComponent<IButtonProps & T> {\n}\n\nexport const Button: ButtonStatic;\n```\n\nI pretty much know it won't be possible this way, but do you have any idea on how can I tell the element that it needs to merge props with another interface?\n\nThanks\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/11876/comments",
    "author": "tomitrescak",
    "comments": [
      {
        "user": "aluanhaddad",
        "created_at": "2016-11-01T01:56:13Z",
        "body": "I believe you _can_ accomplish this, but I don't know enough react to get it working. Basically, you want to use intersection and union types in a manner like\n\n``` ts\ntype AsProps = { as: 'a' } & typeof React.DOM.a | { as: 'input' } & typeof React.DOM.input;\n```\n\nAgain I don't know react, but this should be possible. It is possible for arbitrary functions.\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2017-05-22T22:35:28Z",
        "body": "Automatically closing this issue for housekeeping purposes. The issue labels indicate that it is unactionable at the moment or has already been addressed."
      }
    ]
  },
  {
    "number": 11792,
    "title": "Question: Why are some of the CompilerOptions Internal?",
    "created_at": "2016-10-22T00:45:52Z",
    "closed_at": "2016-10-22T21:39:50Z",
    "labels": [
      "Question",
      "API"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/11792",
    "body": "I am upgrading my bundling Typescript compiler to use Typescript 2.x and noticed that a number of CompilerOptions ares now internal ( Diagnostics, ListFiles, Watch, etc ). Is there a reason for this?\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/11792/comments",
    "author": "ToddThomson",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2016-10-22T00:48:04Z",
        "body": "These are options that are used only by commandline compiler driver (tsc.js), no other parts of the system use them, so specifying them would be not be useful. e.g. `help`. setting this on the API does not do any thing. \n"
      },
      {
        "user": "ToddThomson",
        "created_at": "2016-10-22T17:50:52Z",
        "body": "I use them. For example when doing white space elimination I use the Diagnostics flag to output white space reduction statistics. I also need to know if the user has the Watch flag set as I have compile and bundling and minification functions that result when a source file changes.\nI agree that these settings are most likely only used by those of us writing features on top of the transpiler, but they are needed. \n"
      },
      {
        "user": "mhegazy",
        "created_at": "2016-10-22T20:52:35Z",
        "body": "Nothing stops you from defining a new property on the option bag. Your diagnostics flag means something to you, so that is fine, but it is not the same meaning the one in types has. So my recomedation is to add your declarations on top of the exisitng compileroptions as needed.\n"
      },
      {
        "user": "ToddThomson",
        "created_at": "2016-10-22T21:39:50Z",
        "body": "Yes, I see your point, I am just piggybacking my use of a few of the \"internal\" compiler options.\nIn any event, as you say, it is simple enough to get those properties back for my use. Cheers, @mhegazy \n"
      }
    ]
  },
  {
    "number": 11784,
    "title": "Suggestion: Provide tagged union discriminator as compile-time constant",
    "created_at": "2016-10-21T15:01:44Z",
    "closed_at": "2017-02-28T00:28:19Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/11784",
    "body": "Currently, when using tagged unions, describing the discriminator member has to be done with a string/number/boolean constant type and can't be done by a constant. This means that the value has to be manually duplicated when a check is made, and the two has to be kept in sync.\n\nMy suggestion is to make the discriminator syntactically available as a static property on the type. For example:\n\n``` ts\ntype Fruit = IApple | IBanana;\n\nconst appleType = \"apple\";\n\ninterface IApple {\n    type: \"apple\"; // this can't be `appleType`, it has to be a literal\n    numberOfSeeds: number;\n}\n\ninterface IBanana {\n    type: \"banana\";\n    ripeness: number;\n    bendInRadians: number;\n}\n\nconst fruit: Fruit;\n\nswitch (fruit.type) {\n    // only possible current option\n    case \"apple\":\n        // fruit is implicitly IApple here\n        break;\n\n    // proposed option, would be functionally identical\n    case IApple.type:\n        // fruit is implicitly IApple here too\n        // because of type being equal to \"apple\"\n        // just as before\n        break;\n}\n```\n\nThe generated code would be the discriminator value as defined in the interface's property declaration (`\"apple\"` for `IApple` above). The declaration files would need no new information and this would work with existing declaration files..\n\nOf course, no such shortcut can be used for anonymous interfaces in a tagged union, like:\n\n``` ts\nconst oneOrTheOther: { type: \"a\"; x: number; } | IApple;\n// can't say `[anything].type` to get \"a\"\n```\n\nI think that's fine. This is an extra feature for named types - if this is desired, just name the interface.\n\nHowever, which code should be generated when the type declaration is missing is unclear to me. If TypeScript has no idea what `IApple.type` is, generating anything could result in JavaScript with garbage logic.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/11784/comments",
    "author": "JesperTreetop",
    "comments": [
      {
        "user": "ahejlsberg",
        "created_at": "2016-10-21T20:39:15Z",
        "body": "If the desired effect is to have a single declaration of each discriminant value you could write your code this way:\n\n``` ts\ntype Fruit = IApple | IBanana;\n\nconst APPLE = \"apple\";\nconst BANANA = \"banana\";\n\ninterface IApple {\n    type: typeof APPLE;\n    numberOfSeeds: number;\n}\n\ninterface IBanana {\n    type: typeof BANANA;\n    ripeness: number;\n    bendInRadians: number;\n}\n\ndeclare var fruit: Fruit;\n\nswitch (fruit.type) {\n    case APPLE:\n        // Handle apples\n        break;\n    case BANANA:\n        // Handle bananas\n        break;\n}\n```\n\nThe above works with the nightly build. With 2.0.x you'll need to declare the `const` constants with a type annotation:\n\n``` ts\nconst APPLE: \"apple\" = \"apple\";\nconst BANANA: \"banana\" = \"banana\";\n```\n"
      },
      {
        "user": "JesperTreetop",
        "created_at": "2016-10-21T23:20:02Z",
        "body": "@ahejlsberg That's great! Before I posted this, I tried simply:\n\n``` ts\nconst APPLE = \"apple\";\n\ninterface IApple {\n    type: APPLE;\n}\n```\n\n...it didn't occur to me that `typeof APPLE` would be a compile-time constant in a way that getting the value of it isn't, because it would get the type `\"apple\"` and not the string value `\"apple\"`. I think that's a good enough replacement for the same idea, even though it's a bit counterintuitive - then again, so's my suggested method. I guess my method could still be helpful to allow external consumers to do the same discrimination - it would make the bond between the constant and the discriminant known.\n"
      }
    ]
  },
  {
    "number": 11740,
    "title": "Union type guards are not conferred via the ternary operator",
    "created_at": "2016-10-20T02:37:41Z",
    "closed_at": "2016-10-20T14:10:18Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/11740",
    "body": "**TypeScript Version:**  2.0.3\n\n**Code**\n\n``` ts\n// A *self-contained* demonstration of the problem follows...\nclass A {\n  constructor(public a:string) {\n  }\n}\nclass B {\n  constructor(public b:string) {\n  }\n}\nfunction test(p:A | B):string {\n  return (p instanceof A) ? p.a) : p.b;\n}\n\nlet q = new A('hello');\nconsole.log(test(q));\n```\n\n**Expected behavior:**\nThe type inference conferred by the instanceof type guard should also work within the functions that use the same scope of the ternary operator.\n\n**Actual behavior:** \nThe type is not remembered any more, and p must be re-cast as A or B.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/11740/comments",
    "author": "wwoods",
    "comments": [
      {
        "user": "jesseschalken",
        "created_at": "2016-10-20T04:16:48Z",
        "body": "The provided code compiles fine on 2.0.3, after fixing the typo in the ternary.\n"
      },
      {
        "user": "wwoods",
        "created_at": "2016-10-20T14:10:18Z",
        "body": "Ah, I see, I had the code formatted differently:\n\n``` ts\nclass A...\nclass B...\nfunction test(p:A | B):string {\n  return\n    (p instanceof A) ? p.a\n    p.b\n    ;\n}\n```\n\nI didn't figure that the return being on a separate line made a difference, but I see now that the compiler interprets the return statement as a completed statement and then does something very weird with the ternary.  Fix (workaround?  I guess this is valid javascript) by putting a parenthesis on the same line as the return, and enclosing the ternary.\n"
      }
    ]
  },
  {
    "number": 11689,
    "title": "C:\\Program Files (x86)\\Microsoft SDKs\\TypeScript\\1.8\\lib.d.ts has many errors with SVGElement",
    "created_at": "2016-10-17T22:06:21Z",
    "closed_at": "2017-04-24T20:38:44Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/11689",
    "body": "**TypeScript Version:**  1.8.36 \n**Code**\nNo TS code we could find related to the issue in our project (we never touch the SVGElement interface)\n\n**Expected behavior:**\nApplication compiles without errors from the lib.d.ts file \n\n**Actual behavior:** \n1>C:\\Program Files (x86)\\Microsoft SDKs\\TypeScript\\1.8\\lib.d.ts(12844,11): error TS2320: Build:Interface 'SVGFEBlendElement' cannot simultaneously extend types 'SVGElement' and 'SVGFilterPrimitiveStandardAttributes'.\n1>C:\\Program Files (x86)\\Microsoft SDKs\\TypeScript\\1.8\\lib.d.ts(12890,11): error TS2320: Build:Interface 'SVGFEColorMatrixElement' cannot simultaneously extend types 'SVGElement' and 'SVGFilterPrimitiveStandardAttributes'.\n1>C:\\Program Files (x86)\\Microsoft SDKs\\TypeScript\\1.8\\lib.d.ts(12912,11): error TS2320: Build:Interface 'SVGFEComponentTransferElement' cannot simultaneously extend types 'SVGElement' and 'SVGFilterPrimitiveStandardAttributes'.\n1>C:\\Program Files (x86)\\Microsoft SDKs\\TypeScript\\1.8\\lib.d.ts(12922,11): error TS2320: Build:Interface 'SVGFECompositeElement' cannot simultaneously extend types 'SVGElement' and 'SVGFilterPrimitiveStandardAttributes'.\n1>C:\\Program Files (x86)\\Microsoft SDKs\\TypeScript\\1.8\\lib.d.ts(12952,11): error TS2320: Build:Interface 'SVGFEConvolveMatrixElement' cannot simultaneously extend types 'SVGElement' and 'SVGFilterPrimitiveStandardAttributes'.\n1>C:\\Program Files (x86)\\Microsoft SDKs\\TypeScript\\1.8\\lib.d.ts(12981,11): error TS2320: Build:Interface 'SVGFEDiffuseLightingElement' cannot simultaneously extend types 'SVGElement' and 'SVGFilterPrimitiveStandardAttributes'.\n1>C:\\Program Files (x86)\\Microsoft SDKs\\TypeScript\\1.8\\lib.d.ts(12995,11): error TS2320: Build:Interface 'SVGFEDisplacementMapElement' cannot simultaneously extend types 'SVGElement' and 'SVGFilterPrimitiveStandardAttributes'.\n1>C:\\Program Files (x86)\\Microsoft SDKs\\TypeScript\\1.8\\lib.d.ts(13029,11): error TS2320: Build:Interface 'SVGFEFloodElement' cannot simultaneously extend types 'SVGElement' and 'SVGFilterPrimitiveStandardAttributes'.\n1>C:\\Program Files (x86)\\Microsoft SDKs\\TypeScript\\1.8\\lib.d.ts(13070,11): error TS2320: Build:Interface 'SVGFEGaussianBlurElement' cannot simultaneously extend types 'SVGElement' and 'SVGFilterPrimitiveStandardAttributes'.\n1>C:\\Program Files (x86)\\Microsoft SDKs\\TypeScript\\1.8\\lib.d.ts(13083,11): error TS2320: Build:Interface 'SVGFEImageElement' cannot simultaneously extend types 'SVGElement' and 'SVGFilterPrimitiveStandardAttributes'.\n1>C:\\Program Files (x86)\\Microsoft SDKs\\TypeScript\\1.8\\lib.d.ts(13093,11): error TS2320: Build:Interface 'SVGFEMergeElement' cannot simultaneously extend types 'SVGElement' and 'SVGFilterPrimitiveStandardAttributes'.\n1>C:\\Program Files (x86)\\Microsoft SDKs\\TypeScript\\1.8\\lib.d.ts(13111,11): error TS2320: Build:Interface 'SVGFEMorphologyElement' cannot simultaneously extend types 'SVGElement' and 'SVGFilterPrimitiveStandardAttributes'.\n1>C:\\Program Files (x86)\\Microsoft SDKs\\TypeScript\\1.8\\lib.d.ts(13130,11): error TS2320: Build:Interface 'SVGFEOffsetElement' cannot simultaneously extend types 'SVGElement' and 'SVGFilterPrimitiveStandardAttributes'.\n1>C:\\Program Files (x86)\\Microsoft SDKs\\TypeScript\\1.8\\lib.d.ts(13153,11): error TS2320: Build:Interface 'SVGFESpecularLightingElement' cannot simultaneously extend types 'SVGElement' and 'SVGFilterPrimitiveStandardAttributes'.\n1>C:\\Program Files (x86)\\Microsoft SDKs\\TypeScript\\1.8\\lib.d.ts(13184,11): error TS2320: Build:Interface 'SVGFETileElement' cannot simultaneously extend types 'SVGElement' and 'SVGFilterPrimitiveStandardAttributes'.\n1>C:\\Program Files (x86)\\Microsoft SDKs\\TypeScript\\1.8\\lib.d.ts(13194,11): error TS2320: Build:Interface 'SVGFETurbulenceElement' cannot simultaneously extend types 'SVGElement' and 'SVGFilterPrimitiveStandardAttributes'.\n\nAgain, none of our code (declarations or actual code) go anywhere near the SVGElement... \n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/11689/comments",
    "author": "jhandel",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2016-10-17T22:37:28Z",
        "body": "This means that in your application you have reopened `Element` or other definitions that `SVGElement` depends on, and thus breaking the inheritance rules listed above. \n"
      }
    ]
  },
  {
    "number": 11472,
    "title": "Define array of non-nullables",
    "created_at": "2016-10-09T19:20:31Z",
    "closed_at": "2016-10-09T19:38:50Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/11472",
    "body": "I need to define array of any non-nullable values. Is it possible?\nExample:\n\n``` ts\ndeclare type NonNullable; // this is placeholder for type, which I am looking for\nlet a: NonNullable[] = [];\nlet b: string | null;\na.push(b); // expected compile error;\n```\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/11472/comments",
    "author": "Strate",
    "comments": [
      {
        "user": "DanielRosenwasser",
        "created_at": "2016-10-09T19:30:18Z",
        "body": "`{}` is the empty object type, which every type is structurally compatible with, except for `null`, `undefined`, and `void`.\n\nThis should work with `--strictNullChecks` mode.\n\n``` ts\ntype NonNullable = {};\n\nlet a: NonNullable[] = [];\nlet b: string | null;\n\na.push(b); // expected compile error;\n```\n"
      },
      {
        "user": "Strate",
        "created_at": "2016-10-09T19:38:49Z",
        "body": "@DanielRosenwasser nice, it works, thank you!\n"
      }
    ]
  },
  {
    "number": 11402,
    "title": "Unification overly simplifies types resulting in the swallowing of 'undefined'",
    "created_at": "2016-10-05T21:33:16Z",
    "closed_at": "2016-10-06T08:50:12Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/11402",
    "body": "**TypeScript Version:**  2.0.3\n\nThis is very problematic as it weakens undefined safety _a lot_.\n\n**Code**\n\n``` ts\nfunction bar<A>(c:boolean, a:A, au:A | undefined) { // foo return type is inferred to A instead of A | undefined\n    return c ? a : au;\n}\n```\n\n**Expected behavior:**\n\nbar return type is inferred to A | undefined (valid simplification of A | A | undefined)\n\n**Actual behavior:** \n\nbar return type is inferred to A\n\nNote: similar problem with 'null' instead of 'undefined'\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/11402/comments",
    "author": "sledorze",
    "comments": [
      {
        "user": "yortus",
        "created_at": "2016-10-06T00:26:32Z",
        "body": "If you set `strictNullChecks: true` in your `tsconfig.json`, then `bar` does return `A | undefined` as you expect.\n"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2016-10-06T03:55:57Z",
        "body": "@sledorze does that fix things for you?\n"
      },
      {
        "user": "sledorze",
        "created_at": "2016-10-06T08:50:12Z",
        "body": "Oh dear, yes of course, wonderful! :)\n"
      }
    ]
  },
  {
    "number": 11393,
    "title": "Incorrect propagation of boolean property value",
    "created_at": "2016-10-05T20:30:33Z",
    "closed_at": "2016-10-05T21:57:56Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/11393",
    "body": "**TypeScript Version:** 2.0.3\n\n**Code**\n\n``` ts\nfunction foo(x: boolean, arg: any) {\n    if (x) arg.val = true;\n}\n\nfunction bar(x: boolean) {\n    var arg = {\n        val: false,\n    };\n    arg.val = false;\n    foo(x, arg);\n    if (arg.val === true) console.log('test is true!');\n}\n\nbar(true);\n```\n\n**Expected behavior:**\n\nCode should compile without errors.\n\n**Actual behavior:** \n\n```\nbug.ts(11,9): error TS2365: Operator '===' cannot be applied to types 'false' and 'true'.\n```\n\ncompiler infers that `arg.val` is always`false` in the `if` test. This is wrong because `foo(x, arg)` modifies `arg.val`.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/11393/comments",
    "author": "bjouhier",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2016-10-05T20:32:49Z",
        "body": "See #9998\n"
      },
      {
        "user": "bjouhier",
        "created_at": "2016-10-05T21:57:56Z",
        "body": "Got it.\n\nI only hit that problem once in 43 klocs, and the fix was really easy. I just removed the `=== true` part from the test. Testing booleans with  `x === true` is a bad habit anyway.\n\nI like the _optimistic_ approach descrbed in #9998. I see it as a tacit encouragement to reduce side-effects in code. When this kind of problem happens (when type inference is misled), it is probably a good idea to review the code and eliminate the nasty side-effects. If the TS compiler missed the mutation, it's likely that a developper will also miss it when reading the code.\n"
      }
    ]
  },
  {
    "number": 11275,
    "title": "Error setting method on a function",
    "created_at": "2016-09-30T08:23:09Z",
    "closed_at": "2016-09-30T09:28:59Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/11275",
    "body": "**TypeScript Version:**  2.0.3\n\n**Code**\n\n``` ts\nfunction createMessageBox() {\n\n  addLine.editLine = editLine;\n  return addLine;\n\n  function addLine (text: string, id?: number) {\n    // stuff..\n  }\n\n  function editLine (text: string, id: number) {\n     // stuff..\n  }\n}\n\n```\n\n**Expected behavior:**\nNo errors. Method added to the function successfully.\n\nAccessible by\n\n``` ts\nlet test = createMessageBox();\ntest.editLine(\"test\", 0);\n```\n\nOutputs on node\n\n``` text\n> test.editLine\n[Function: editLine]\n```\n\n**Actual behavior:** \nConsole error when compiling\n\n``` ts\ncommandLine.ts(10,11): error TS2339: Property 'editLine' does not exist on type '(text: string, id?: number) => number'.\n```\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/11275/comments",
    "author": "vectrixdevelops",
    "comments": [
      {
        "user": "kitsonk",
        "created_at": "2016-09-30T09:24:18Z",
        "body": "You are using implicit typing in that `addLine` is simply declared as a function, and not declared as an interface which has a property `editLine`.  TypeScript is keeping you from doing something you have implied you don't want to do.  One of the _many_ ways to deal with this would be:\n\n``` typescript\ninterface AddLine {\n    (text: string, id?: number): void;\n    editLine(text: string, id: number): void;\n}\n\nfunction createMessageBox() {\n\n  (<AddLine> addLine).editLine = editLine;\n  return <AddLine> addLine;\n\n  function addLine (text: string, id?: number) {\n    // stuff..\n  }\n\n  function editLine (text: string, id: number) {\n     // stuff..\n  }\n}\n\nconst msgBox = createMessageBox();\nmsgBox.editLine; // No Error\n```\n\nThis is very basic TypeScript though and this is an issue tracking forum for defects and enhancements of TypeScript.  It would be better to seek this sort of general support from StackOverflow, Gitter or IRC.\n"
      }
    ]
  },
  {
    "number": 11146,
    "title": "Tagged unions not inferred when returning objects implementing interfaces ",
    "created_at": "2016-09-26T13:22:02Z",
    "closed_at": "2016-09-26T19:11:23Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/11146",
    "body": "**TypeScript Version:**  2.0.0\n\n``` ts\ninterface Category \n{\n    id: string;\n    description: string;\n}\n\ninterface TreeNodeBase \n{\n  readonly children: TreeNode[];\n  title() : string;\n  id(): string;\n}\n\ninterface CategoryTreeNode extends TreeNodeBase\n{\n  readonly kind: \"category\";\n  readonly item: Category;\n}\n\ninterface EmptyTreeNode extends TreeNodeBase\n{\n  readonly kind: \"empty\";\n}\n\ntype TreeNode = EmptyTreeNode | CategoryTreeNode; // More variants in actual case.\n\nfunction createCategoryNode(category : Category, children : TreeNode[]) : CategoryTreeNode\n{\n    return {\n      kind: \"category\",\n      item: category,\n      children: children,\n      title() { return (<Category>this.item).description; }, // Why is type of this.item not inferred ?\n      id() { return (<Category>this.item).id; } // Why is type of this.item not inferred ?\n    };\n}\n```\n\n**Expected behavior:**\n\nThe factory method **createCategoryNode** should be able to return an object that is a CategoryTreeNode in a type safe manner without having to specify the type as done above when implementing the title and id functions.\n\n**Actual behavior:** \n\nRight now, unless the type of this.item is explicitly given, typescript will regard the type of item as **any** instead of Category. Thus, the type of this.item is not inferred correctly.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/11146/comments",
    "author": "mmc41",
    "comments": [
      {
        "user": "Arnavion",
        "created_at": "2016-09-26T18:44:19Z",
        "body": "Nothing to do with union types. `this` itself is `any` in methods in object literals. See #10835\n\nEdit: i.e. in your case you would need to write\n\n``` ts\n    title(this: CategoryTreeNode) { return this.item.description; }\n    id(this: CategoryTreeNode) { return this.item.id; }\n```\n"
      }
    ]
  },
  {
    "number": 11053,
    "title": "Redundant rest parameter should be omitted from compiled output",
    "created_at": "2016-09-22T01:45:26Z",
    "closed_at": "2016-09-22T04:33:49Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/11053",
    "body": "**TypeScript Version:**  2.0.2 (rc)\n\nIn some cases I am iterating through arguments using the arguments object, and don't actually need to reference the paremeters. In these sorts of cases, the only reason to include the rest parameter in the original source is to tell TypeScript that the function may be called with any number of arguments. If the parameter is never actually referenced (particularly if you then access the arguments object), it should be able to infer that the parameter is redundant and drop it from the compiled output.\n\nHaving an intermediate array built, or even just a redundant rest parameter when targeting ES2015, is not ideal when your code is performance-critical. Optimizing compilers might be smart enough to skip an unused rest parameter, but it still feels sloppy, and ES5 output will be worse, of course.\n\nThe example below is contrived of course, but it serves to illustrate the redundant output:\n\n``` ts\nfunction run(...args: any[]) {\n  const values = arguments;\n  for(var i = 0; i < values.length; i++) {\n    console.log(values[i]);\n  }\n}\n```\n\nES5 output:\n\n``` js\nfunction run() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i - 0] = arguments[_i];\n    }\n    var values = arguments;\n    for (var i = 0; i < values.length; i++) {\n        console.log(values[i]);\n    }\n}\n```\n\nand ES2015 output:\n\n``` js\nfunction run(...args) {\n    const values = arguments;\n    for (var i = 0; i < values.length; i++) {\n        console.log(values[i]);\n    }\n}\n```\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/11053/comments",
    "author": "axefrog",
    "comments": [
      {
        "user": "yortus",
        "created_at": "2016-09-22T02:29:15Z",
        "body": "@axefrog since the prime concern here seems to be performance, what is the performance difference if you actually use the `args` rest parameter instead of `arguments` in your implementation? E.g. is `run1` slower than `run2` in the code below? I'm genuinely curious.\n\n``` ts\nfunction run1(...args: any[]) {\n  for(var i = 0; i < args.length; i++) {\n    console.log(args[i]);\n  }\n}\n\nfunction run2() {\n  const values = arguments;\n  for(var i = 0; i < values.length; i++) {\n    console.log(values[i]);\n  }\n}\n```\n"
      },
      {
        "user": "axefrog",
        "created_at": "2016-09-22T02:44:07Z",
        "body": "@yortus it's not quite as specific as this (yes I do have one function in mind right now, but I don't want to focus on that); rather than optimizing for one specific case I'm experiencing, and then changing my code to try and cater to TypeScript idiosyncracies, I'm just observing that, because JavaScript offers an arguments object and that sometimes it will be used directly, and that sometimes doing so will be in an area of code where redundancy creates a question mark as to expected performance characteristics on different runtime compilers, it seems logical that I should be able to take advantage of this language feature of JavaScript without paying the cost of redundant compiler output. Also, generating redundant syntax seems sloppy.\n"
      },
      {
        "user": "yortus",
        "created_at": "2016-09-22T03:00:01Z",
        "body": "Would the following meet your needs? It has both the compile-time (variadic) and runtime (no redundant var) characteristics you mentioned.\n\n``` ts\nconst foo: (...args) => void = function () {\n    const values = arguments;\n    for (var i = 0; i < values.length; i++) {\n        console.log(values[i]);\n    }\n}\n```\n\n**EDIT:** @RyanCavanaugh's solution below is more idiomatic TS and preserves hoisting, so use that.\n"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2016-09-22T03:00:55Z",
        "body": "The solution is simple, though undiscoverable:\n\n``` ts\nfunction run(...args: any[]): void;\nfunction run() {\n  const values = arguments;\n  for(var i = 0; i < values.length; i++) {\n    console.log(values[i]);\n  }\n}\n```\n"
      },
      {
        "user": "axefrog",
        "created_at": "2016-09-22T05:59:30Z",
        "body": "@RyanCavanaugh Ah, thanks! May I suggest a ticket to clarify this in the documentation?\n"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2016-09-22T06:57:05Z",
        "body": "We try to keep the documentation to common-ish cases and this seems to be fairly rare. You can also see #498 which we're accepting PRs for.\n"
      }
    ]
  },
  {
    "number": 10957,
    "title": "Improper type inferred in presence of overloads",
    "created_at": "2016-09-16T20:59:01Z",
    "closed_at": "2019-08-23T21:25:34Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/10957",
    "body": "**TypeScript Version:**  2.1.0-dev.20160916\n\n**Code**\n\n``` ts\ninterface Editor {\n  on(e: string, h: (x: Editor) => void): void;\n  on(e: string, h: (x: string, e: any) => void): void;\n  on(e: 'foo', h: (x: Editor, e: any) => void): void;\n}\n\nlet cm: Editor = null as any;\ncm.on('bar', (x, y) => {});\n```\n\n**Expected behavior:**\n\n`cm.on()` infers some type for its second param that is accepted by the compiler, given that the param has no types specified.\n\n**Actual behavior:** \n\n```\nerr.ts(8,14): error TS2345: Argument of type '(x: Editor, y: any) => void' is not assignable to parameter of type '(x: string, e: any) => void'.\n  Types of parameters 'x' and 'x' are incompatible.\n    Type 'string' is not assignable to type 'Editor'.\n```\n\nIt appears to infer that its param should have the third overload's expected type, but then typechecks it against the second overload.\n\nIt appears to also be sensitive to the order in which the overloads are declared.\n\n(This is reduced from a larger example that involves the CodeMirror d.ts files.)\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/10957/comments",
    "author": "evmar",
    "comments": [
      {
        "user": "evmar",
        "created_at": "2016-09-20T21:43:49Z",
        "body": "This example from @rkirov is a bit smaller and has maybe the same error.\n\n``` js\ninterface Editor {\n  on(h: (x: boolean) => void): void;\n  on(h: (x: string, e: string) => void): void;\n}\n\nlet cm: Editor = null as any;\ncm.on((x, y) => {});\n```\n\n```\nArgument of type '(x: boolean, y: any) => void' is not assignable to parameter of type '(x: string, e: string) => void'.\n  Types of parameters 'x' and 'x' are incompatible.\n    Type 'string' is not assignable to type 'boolean'.\n```\n"
      },
      {
        "user": "Erikvv",
        "created_at": "2018-08-17T00:11:53Z",
        "body": "I ran into this and I found out that if you replace the overload by an equivalent Union type it works! Though an overloaded function seems to me an intersection type but that doesn't work.\r\n\r\nThis is maybe not so hard to fix so I hope the typescript team can give this some prio.\r\n\r\nFaulty behavior in the case of overloads:\r\n```ts\r\ninterface MyFunction1 {\r\n  (): string\r\n  (): number\r\n}\r\n\r\n// should be string|number but actually is number\r\ntype StringOrNumber1 = ReturnType<MyFunction1> \r\n```\r\nCorrect behaviour in the case of Union types:\r\n```ts\r\ntype MyFunction2 = \r\n    (() => string) \r\n    | \r\n    (() => number)\r\n\r\n// is string|number\r\ntype StringOrNumber2 = ReturnType<MyFunction2>\r\n```\r\n"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2019-08-23T21:25:33Z",
        "body": "The definition in the OP has signatures in the wrong order - callbacks with more parameters should go first:\r\n```ts\r\ninterface Editor {\r\n  on(e: string, h: (x: string, e: any) => void): void;\r\n  on(e: string, h: (x: Editor) => void): void;\r\n  on(e: 'foo', h: (x: Editor, e: any) => void): void;\r\n}\r\n```\r\n"
      }
    ]
  },
  {
    "number": 10854,
    "title": "Simultaneous use of export equals and export default in a module",
    "created_at": "2016-09-11T12:35:00Z",
    "closed_at": "2016-09-11T14:52:16Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/10854",
    "body": "I have some NPM modules written that uses the old default export syntax:\n\n``` ts\ndeclare module 'my-module' {\n    function test(): string;\n    export = test;\n}\n```\n\nTo promote ES import syntax but still keep the old one, I wanted to add both the new and old default export syntax:\n\n``` ts\ndeclare module 'my-module' {\n    function test(): string;\n    export default test;\n    export = test; // An export assignment cannot be used in a module with other exported element\n}\n```\n\nThough it complains that it cannot use an export assignment with other export statements.\n\nI think it is reasonable to support both syntax simultaneously in a module. Because choosing between both syntax. I would choose `export =` before `export default`, simply because of no API breakage.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/10854/comments",
    "author": "tinganho",
    "comments": [
      {
        "user": "kitsonk",
        "created_at": "2016-09-11T13:21:19Z",
        "body": "No it isn't really practical at all, because it isn't \"magic\" that produces the default export.  It is added as a property on the export of the module.  What is provided above is trying to export something as `my-module.default` and then overwriting it with a function named `test` and TypeScript is preventing you from describing something that contradicts itself.\n\nI think what you might want to consider the solution to #5285 (`--allowSyntheticDefaultImports`), which allows you to import a module as if it were the shape you denoted.\n"
      },
      {
        "user": "tinganho",
        "created_at": "2016-09-11T13:31:53Z",
        "body": "> I think what you might want to consider the solution to #5285 (--allowSyntheticDefaultImports), which allows you to import a module as if it were the shape you denoted.\n\n@kitsonk thanks that was what I wanted.\n"
      },
      {
        "user": "tinganho",
        "created_at": "2016-09-11T13:42:13Z",
        "body": "There could be a problem. I'm currently doing the magic on the module itself and not relying on any module loader doing the magic for me. There could possibly be people that are not using `--allowSyntheticDefaultImports` so they cannot use one of my modules, unless they want to use the old import syntax. Telling all users that they need to add a flag just to use a module is little bit harsh also.\n\nFYI. This is the magic I do:\n\n``` ts\ndeclare var module: any;\nmodule.exports = myModule;\nmodule.exports.default = myModule;\n```\n"
      },
      {
        "user": "kitsonk",
        "created_at": "2016-09-11T14:37:01Z",
        "body": "``` typescript\ndeclare module 'my-module' {\n    const test: () => string & { default: () => string };\n    export = test;\n}\n```\n"
      },
      {
        "user": "tinganho",
        "created_at": "2016-09-11T14:52:16Z",
        "body": "Very neat trick!\n"
      }
    ]
  },
  {
    "number": 10852,
    "title": "Reuse files between different module models",
    "created_at": "2016-09-11T08:12:06Z",
    "closed_at": "2016-09-20T22:58:15Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/10852",
    "body": "Hi - it's more a question rather than issue.\nI have front-end (web-app) and backend (nodejs).\nI would like to reuse some TS files between both. However my front-end is compiled without modules (using `outFile` to compile all into single file) and node use `commonjs`.\nBoth `es6` target.\n\nTried different options but I can't find a way to structure the file so it compiles on both.\nI really wish to avoid introducing modules on front-end side.\n\nMy backend file looks like this:\n\n``` ts\nexport class ShareMePlease {\n}\n```\n\nTo use it at front-end I need to wrap it with namespace:\n\n``` ts\nnamespace Shares {\n  export class ShareMePlease {\n  }\n}\n```\n\nHowever, to use it then on backend side, I would need to add `export` before namespace, but then it won't compile anymore in front-end.\n\nI even tried to compile all shared files as separate project - to generate JS and D.TS - which I would then include into both solutions - but really same problem remains. Either node won't see it as module I can include or front-end requires modules.\n\nAny solutions without moving front-end to modules?\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/10852/comments",
    "author": "pankleks",
    "comments": [
      {
        "user": "pankleks",
        "created_at": "2016-09-12T07:38:40Z",
        "body": "Guys any help on this?\nI really don't think it's so uncommon scenario. \n\nmaybe if module=\"none\" in tsconfig, we should ignore `external` and `import` statements?\n"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2016-09-12T19:14:50Z",
        "body": "FYI Saturday and Sunday are not working days for most salaried employees in the United States.\n\nOur general recommendation here would be to write your front-end with modules and use a bundler like webpack or rollup (rather than `--outFile`) to produce a single .js file that would run natively in the browser. This is what most people seem to be doing.\n"
      },
      {
        "user": "basarat",
        "created_at": "2016-09-13T01:27:42Z",
        "body": "> I really wish to avoid introducing modules on front-end side.\n\nChange your wishes please. The whole JS ecosystem is now pro npm + module all things :rose:\n"
      }
    ]
  },
  {
    "number": 10836,
    "title": "2 variables of type number are concatenated instead of added",
    "created_at": "2016-09-10T09:34:53Z",
    "closed_at": "2016-09-10T20:25:58Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/10836",
    "body": "<!-- BUGS: Please use this template. -->\n\nHi,\n\nI am having an issue to add 2 numbers. They are both of number type. I tried to force with parseInt, but the compiler says \"argument of type 'number' is not assignable to parameter of type 'string'.\", which is normal. However how I add my 2 numbers!!\n\n```\n public myfunction(posX: number, posY: number): string {\n\n        var sequencereturned:string=\"\";\n\n        while(sequencereturned.length!=2){\n        var nextX:number=0;\n        var nextY:number=0;\n        while (nextX==0 && nextY==0) {\n            var result = this.AssignXY(posX, posY)\n            nextX = result[0];\n            nextY = result[1];\n           let myvar=posX+nextX;\n           console.log(myvar);\n           sequencereturned=sequencereturned+this.grid[posX+nextX][posY+nextY];\n        }}\n\n\n\nreturn sequencereturned;\n        //selectionner une ligne adjascente\n\n    }\n\n  private AssignXY(posX: number, posY: number): Array<number> {\nreturn [1,2];\n}\n```\n\n let myvar=posX+nextX; if posX is 2 and nextX is 1=>\nmyvar got \"21\" instead of \"3\".\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/10836/comments",
    "author": "stefdelec",
    "comments": [
      {
        "user": "stefdelec",
        "created_at": "2016-09-10T09:38:59Z",
        "body": "Hum, it is coming from the parameter posX which is a string, so it is coming from Javascript not Typescript.\n"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2016-09-10T20:25:58Z",
        "body": "Please post questions on Stack Overflow. This is not a general coding support forum.\n\nWhoever is invoking `myfunction`, which you haven't shown us, is actually passing in a string. Use a debugger and fix that problem and everything should just work.\n"
      }
    ]
  },
  {
    "number": 10835,
    "title": "can’t use 'this' in object literals with --noImplicitThis",
    "created_at": "2016-09-10T09:09:57Z",
    "closed_at": "2016-09-10T20:26:25Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/10835",
    "body": "**TypeScript Version:**  2.1.0-dev.20160910\n\n**Code**\n\n``` ts\nlet literal = {\n  a: 1,\n  getA() {\n    return this.a\n   // error: 'this' implicitly has type 'any' because it does not have a type annotation\n  },\n}\n\n```\n\n**Expected behavior:** there is a way to use `this` in an object literal while `noImplicitThis` enabled\n\n**Actual behavior:** an error is shown, even with `getA: function(this: this)` notation\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/10835/comments",
    "author": "msklvsk",
    "comments": [
      {
        "user": "yortus",
        "created_at": "2016-09-10T11:39:51Z",
        "body": "This was tried before (see PR #8382) and then reverted after the discussion in #8191.\n"
      },
      {
        "user": "msklvsk",
        "created_at": "2016-09-10T11:50:58Z",
        "body": "Thanks. I gave up searching duplicates on page 2 of 50.\nThen maybe we make this issue about error\n\n> this' implicitly has type 'any' because it does not have a type annotation\n\nwhen `--noImplicitThis` enabled?\n"
      },
      {
        "user": "kitsonk",
        "created_at": "2016-09-10T13:42:46Z",
        "body": "Well, if you have `noImplicitThis` enabled, you have opted into ensuring that `this` is typed, even in object literals.  This works around the error:\n\n``` typescript\nlet literal = {\n  a: 1,\n  getA(this: any) {\n    return this.a\n  },\n}\n```\n"
      }
    ]
  },
  {
    "number": 10779,
    "title": "Generics not inferred from union type",
    "created_at": "2016-09-08T14:08:19Z",
    "closed_at": "2016-09-08T14:37:18Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/10779",
    "body": "Latest 2 beta\n\n``` ts\nconst y = <S, E>(z: S | E) => 1;\ny(5 || 'foo') // generics should be number and string, but are {} and {}\n```\n\nI expect the generics `S` and `E` to be inferred correctly as `number` and `string`, but it seems like TypeScript infers them both as `{}` instead.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/10779/comments",
    "author": "OliverJAsh",
    "comments": [
      {
        "user": "kitsonk",
        "created_at": "2016-09-08T14:24:23Z",
        "body": "TypeScript cannot infer generics in that way.  A simple example:\n\n``` typescript\nconst y = <S, E>(z: S | E) => 1;\ny(5 || 'foo' || true) // What should be inferred here?\n```\n\nWhere as:\n\n``` typescript\nconst y = <S>(z: S) => 1;\ny(5 || 'foo') // inferred as `string | number`\n```\n\nIn order to infer generics contextually, TypeScript needs to be in a position to actually resolve to a single type (which a union type is a single type).  For example:\n\n``` typescript\nconst y = <S, E>(z: S | E, a: S, b: E) => 1;\ny(5 || 'foo', 6, 'bar') // inferred as number, string\ny(5 || true, 6, 'bar') // an Error\n```\n"
      },
      {
        "user": "OliverJAsh",
        "created_at": "2016-09-08T14:37:09Z",
        "body": "That makes sense, thank you!\n"
      }
    ]
  },
  {
    "number": 10748,
    "title": "error TS7017. But why?",
    "created_at": "2016-09-07T13:50:25Z",
    "closed_at": "2016-09-07T15:20:42Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/10748",
    "body": "**TypeScript Version:**  1.8.10  \n\n**Code**\n\n``` ts\n// const ready: angular.IDeferred<{}>\n// (parameter) isAuth: boolean\nready[ isAuth ? 'resolve' : 'reject' ]();\n```\n\n**Expected behavior:**\nI expect that there should be no errors\n**Actual behavior:** \nBut in the end compiler reports:\n`error TS7017: Index signature of object type implicitly has an 'any' type.`\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/10748/comments",
    "author": "cawa-93",
    "comments": [
      {
        "user": "kitsonk",
        "created_at": "2016-09-07T14:47:36Z",
        "body": "It means what it says...\n\n`angular.IDeferred` does not have an index signature and you have `noImplicitAny` enabled.  In TypeScript, when you access a property via the index, TypeScript doesn't introspect the strings and try to match literal properties on the interface, it looks to an indexer property to see what the type is.  Therefore you may want re-write your code to not need to access properties via their index:\n\n``` typescript\n(isAuth ? ready.resolve : ready.reject)();\n```\n\nThese sorts of general questions are better asked in Gitter, Stack Overflow or IRC.\n"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2016-09-07T15:43:38Z",
        "body": "Thanks as usual @kitsonk !\n"
      }
    ]
  },
  {
    "number": 10744,
    "title": "Object properties introspection",
    "created_at": "2016-09-07T09:36:30Z",
    "closed_at": "2016-09-15T19:49:28Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/10744",
    "body": "Supposed to have an object like\n\n``` typescript\nexport class User implements UserInterface, BaseObject {\n    user_id: string\n    id: string\n    name: string\n    location: Location\n```\n\nunless for the object instance `var u = new User()` all properties are not assigned, there is no way to do introspection via\n\n``` javascript\nObject.keys(u).forEach(k=> {\n            console.log(k);\n        });\n```\n\nor `hasOwnProperty` like in a possibile object fill function:\n\n``` javascript\npublic fill(properties:Object) {\n        var self=this;\n        for (var i in properties) {\n            if (self.hasOwnProperty(i)) {\n                self[i]=properties[i];\n            }\n        }\n    }\n```\n\nThe only option I see is to assign with the default constructor i.e.\n\n``` typescript\nconstructor() {\n        this.user_id=\"\";\n        this.id=\"\";\n        this.name=\"\";\n        this.location=null;\n    }\n```\n\nAt this point I will get properties on compiled javascript object.\nAny plan to support object introspection for undefined properties?\n\nA ugly way would be\n\n``` typescript\nclass A {\n  A: string = undefined\n}\n```\n\nso that the both thee `Object.keys` and `this.hasOwnProperty` will introspect all object properties.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/10744/comments",
    "author": "loretoparisi",
    "comments": [
      {
        "user": "aluanhaddad",
        "created_at": "2016-09-11T09:56:02Z",
        "body": "Try \n\n``` TypeScript\nexport class User implements UserInterface, BaseObject {\n    user_id = \"\";\n    id =\"\";\n    name = \"\";\n    location: Location = undefined;\n}\n```\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2016-09-12T17:09:33Z",
        "body": "The declaration is meant to tell the compiler at compile time that the property exists, but it is meant to be completely erasable. if you want to have runtime artifacts you will need to initialize them explicitly as @aluanhaddad mentioned.\n"
      },
      {
        "user": "loretoparisi",
        "created_at": "2016-09-13T09:15:51Z",
        "body": "@mhegazy what about `prototype` class variables?\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2016-09-15T19:49:26Z",
        "body": "> @mhegazy what about prototype class variables?\n\n``` ts\nclass C {\n     static p = undefined;\n}\n```\n"
      }
    ]
  },
  {
    "number": 10718,
    "title": "Code paths not type checked when one path returns any",
    "created_at": "2016-09-06T08:53:52Z",
    "closed_at": "2016-09-06T17:27:29Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/10718",
    "body": "Version: latest 2 beta\n\nGiven:\n\n``` ts\n    type Fn = (n: number) => number;\n    const fn: Fn = (n: number) => {\n        if (n === 1) {\n            return 'foo' as any;\n            // return 'foo';\n        } else {\n            return 'bar'; // expected to error\n        }\n    };\n```\n\nI expect this to error because one of the code paths is known to be `string` which doesn't comply with the specified `number`.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/10718/comments",
    "author": "OliverJAsh",
    "comments": [
      {
        "user": "gcnew",
        "created_at": "2016-09-06T17:21:18Z",
        "body": "The function return type is inferred to be the most speciffic type, covering all branch return types. In your case one of the branches returns `any`, which encompasses `string`, thus the return type of the lambda is inferred as `any`. As well as everything being assignable to `any`, it is also assignable to everything. Thus your `any` returning lambda is assignable to the `number` returning `Fn`.\n\nPS: add a manual return type annotation and the error will show up\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2016-09-06T17:27:19Z",
        "body": "You can add a return type annotation to stop inferring the return type.\n\n``` ts\nconst fn: Fn = (n: number): number => { ... }\n```\n"
      }
    ]
  },
  {
    "number": 10655,
    "title": "Async map iteration does not work as expected",
    "created_at": "2016-08-31T22:37:21Z",
    "closed_at": "2016-09-02T22:07:17Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/10655",
    "body": "**TypeScript Version:**  1.8.10\n\n**Code**\n\n``` ts\nvar map = new Map<string, any>();\nmap.set('abc', 123);\nmap.forEach(async (value)=>{\nawait DoSomethingAsyncWithValue(val);\n});\n```\n\n**Expected behavior:**\nShould asynchronously iterate over the map.\n\n**Actual behavior:** \nSynchronously iterates over the map.\n\nThere are no compilation errors from this code, so a developer would assume it'd work the same as an Array forEach.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/10655/comments",
    "author": "Roam-Cooper",
    "comments": [
      {
        "user": "Arnavion",
        "created_at": "2016-09-01T01:13:42Z",
        "body": "> Expected behavior:\n> Should asynchronously iterate over the map.\n\nThat would be a violation of the ES6 spec, and is outside of TS's control at any rate.\n\n> There are no compilation errors from this code, so a developer would assume it'd work the same as an Array forEach.\n\nThat is technically legal from both runtime perspective and compiler perspective.\n\nFrom runtime's point of view, the callback given to `forEach` is returning a `Promise` that `forEach` ignores and throws away.\n\nFrom TS compiler's point of view, `forEach` excepts a callback that returns `void`, whereas the actual callback is returning a `Promise`. But it is legal to assign callbacks that return non-`void` to callbacks that return `void`. (This is useful for writing single-expression lambdas where one just wants the result of the expression to be ignored.) So there is nothing to raise a compiler error about.\n\nPerhaps you could create a tslint rule for this, something like \"Async lambda used with Array#forEach may not work as expected.\"\n"
      },
      {
        "user": "yortus",
        "created_at": "2016-09-01T07:20:23Z",
        "body": "@Roam-Cooper you could try something like this:\n\n``` ts\nasync function foo() {\n    var map = new Map<string, any>();\n    map.set('abc', 123);\n\n    for (let [key, val] of map) {\n        await doSomethingAsyncWithValue(val);\n    }\n}\n```\n"
      },
      {
        "user": "Roam-Cooper",
        "created_at": "2016-09-01T07:26:52Z",
        "body": "I've already solved it with a for..of loop of course, just didn't know es6\nspec doesn't include asynchronous map iteration. :)\n"
      }
    ]
  },
  {
    "number": 10551,
    "title": "Generic type constraint for abstract class.",
    "created_at": "2016-08-26T02:10:03Z",
    "closed_at": "2016-08-26T04:11:27Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/10551",
    "body": "Too constraint a generic type that is a class, we can write `{new():T}`, however it doesn't match an abstract class.\n\n``` typescript\nclass X{};\nabstract class Y{};\nfunction f<T>(x: {new():T});\nf(X);// OK\nf(Y);// Faild\n```\n\nIs there any way overcome this?\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/10551/comments",
    "author": "thynson",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2016-08-26T03:32:14Z",
        "body": "Why would you want to? It's illegal to `new Y`.\n\nYou could also write `function f<T>(x: {prototype: T})`\n"
      },
      {
        "user": "thynson",
        "created_at": "2016-08-26T04:11:27Z",
        "body": "I'm writing an IoC container, use abstract class itself as indentifier to register its implementation.\nAnd `function f<T>(x: {prototype: T})` works, thank you!\n"
      }
    ]
  },
  {
    "number": 10389,
    "title": "tsc: Accept multiple .ts source files at once",
    "created_at": "2016-08-17T16:03:03Z",
    "closed_at": "2016-08-17T16:50:17Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/10389",
    "body": "For larger projects, please add the ability for `tsc` to compile multiple `.ts` source files at once, like other compilers.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/10389/comments",
    "author": "mcandre",
    "comments": [
      {
        "user": "kitsonk",
        "created_at": "2016-08-17T16:16:29Z",
        "body": "`tsc file1.ts file2.ts`\n"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2016-08-17T16:54:04Z",
        "body": "Out of curiosity, _what did you try_? It'd be good to improve our commandline help or something if there's something you tried and it didn't work.\n"
      }
    ]
  },
  {
    "number": 10363,
    "title": "\"A class must be declared after its base class\" on classes in different directories",
    "created_at": "2016-08-16T07:02:48Z",
    "closed_at": "2016-08-16T07:08:25Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/10363",
    "body": "**TypeScript Version:**  master branch\n\n**Repro**\n1. Create a new JavaScript->Windows->Universal->Blank App project\n2. Add directories and empty files as following:\n   \n   ```\n   (App name)\n   |>sources\n   |    |>cats\n   |    |    |>elephants\n   |    |    | foo.ts\n   |    | bar.ts\n   \n   sources/cats/elephants/foo.ts\n   sources/cats/bar.ts\n   ```\n3. Write codes as following:\n   \n   ``` ts\n   // In sources/cats/elephants/foo.ts:\n   class Foo extends Bar {\n   }\n   \n   // In sources/cats/bar.ts:\n   class Bar {\n   }\n   ```\n4. Open project properties and set \"Combine JavaScript output into file\" to \"js/app.js\"\n5. Unload project\n6. Reload project\n\n**Expected behavior:**\n\nCompiler should automatically make a proper order for the classes\n\n**Actual behavior:** \n\n``` ts\nclass Foo extends Bar {\n//                ~~~\n//                A class must be declared after its base class.\n}\n```\n\n**Workaround:**\n\nRename \"foo.ts\" to \"a.ts\".\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/10363/comments",
    "author": "saschanaz",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2016-08-16T07:05:55Z",
        "body": "The compiler doesn't figure out what the \"right\" order of files is based on class dependencies or anything else. The usual methods are available: have a `_reference.ts`, use `/// <reference` directives, or use a module loader (if applicable)\n"
      },
      {
        "user": "saschanaz",
        "created_at": "2016-08-16T07:08:25Z",
        "body": "Thanks! I would be happier if the error message told me the tip.\n"
      }
    ]
  },
  {
    "number": 10329,
    "title": "typings error in lib.d.ts",
    "created_at": "2016-08-14T16:06:15Z",
    "closed_at": "2016-08-17T20:37:16Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/10329",
    "body": "I've encounter this error\n\n```\n../node_modules/typescript/lib/lib.d.ts(12844,11): error TS2320: Interface 'SVGFEBlendElement' cannot simultaneously extend types 'SVGElement' and 'SVGFilterPrimitiveStandardAttributes'.\n  Named property 'result' of types 'SVGElement' and 'SVGFilterPrimitiveStandardAttributes' are not identical.\n\n```\n\n**SVGFilterPrimitiveStandardAttributes** has _result: SVGAnimatedString;_\n\nwhereas \n\n**SVGElement** has _result:any_  I guess, because it has very nesty extensions, as I've grep 'result'\n\n```\n# grep 'result:' ../node_modules/typescript/lib/lib.d.ts\n    evaluate(expression: string, contextNode: Node, resolver: XPathNSResolver, type: number, result: XPathResult): XPathResult;\n    result: any;\n    result: any;\n    result: any;\n    evaluate(expression: string, contextNode: Node, resolver: XPathNSResolver, type: number, result: XPathResult): XPathResult;\n    evaluate(contextNode: Node, type: number, result: XPathResult): XPathExpression;\n    result: any;\n    result: SVGAnimatedString;\n```\n\n**Note:** I've also change the type to _result: any_ for **SVGFilterPrimitiveStandardAttributes** and no compilation warnings.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/10329/comments",
    "author": "maclarensg",
    "comments": [
      {
        "user": "yuit",
        "created_at": "2016-08-16T16:15:13Z",
        "body": "@maclarensg what TypeScript version you are using?\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2016-08-17T20:37:09Z",
        "body": "this would be caused by another declaration in your compilation that changes the shape of one of the SVG interfaces. Interfaces in TypeScript can be augmented by re-declaring them. one of your files would include a declaration that changes the shape of one of the involved interfaces causing this issue.\n"
      },
      {
        "user": "maclarensg",
        "created_at": "2016-08-18T17:03:33Z",
        "body": "Hi, \n\nApologies on my late reply. The version is as follows:\n\n# tsc -v\n\nVersion 1.8.10\n"
      }
    ]
  },
  {
    "number": 10305,
    "title": "Unable to declare global variable as alias to existing type",
    "created_at": "2016-08-12T16:15:25Z",
    "closed_at": "2016-08-12T16:33:21Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/10305",
    "body": "Hi, I have a small issue when trying to declare a global variable as an alias to an existing type.\n\nTypeScript 1.8.7\n\nGiven the following declaration file:\n\n``` ts\n// typings.d.ts\nimport { Assert } from 'chai/lib/Assert';\n\ndeclare const assert: Assert;\ndeclare const helper: any;\n```\n\nIf I reference this declaration file in my project, both `assert` and `helper` cannot be found. I expect them both to be found.\n\n``` ts\n// main.ts\nassert; // unexpected error\nhelper; // unexpected error\n```\n\nIf I comment out lines 1 and 3, helper can be found as expected.\n\n``` ts\n// main.ts\nassert; // error as expected\nhelper;\n```\n\nWhat is wrong with my declaration file and why do I not get any feedback in my declaration file about this?\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/10305/comments",
    "author": "OliverJAsh",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2016-08-12T16:21:02Z",
        "body": "A file that `import`s or `export`s things is a _module_ and only contributes names to its own namespace, not the global namespace. You can put these things in a `declare global {` block if you want to put them into the global namespace instead.\n"
      },
      {
        "user": "OliverJAsh",
        "created_at": "2016-08-12T16:22:39Z",
        "body": "Fantastic, that makes perfect sense. Thanks for the speedy reply. Not sure whether to post these questions here or on IRC, what would you advise?\n\nIs this `declare global` documented anywhere?\n"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2016-08-12T16:25:26Z",
        "body": "StackOverflow would be preferred.\n\nI think we're behind on docs in this area.\n"
      },
      {
        "user": "OliverJAsh",
        "created_at": "2016-08-12T16:26:14Z",
        "body": "``` ts\nimport { Assert } from 'chai/lib/Assert';\n\ndeclare global {\n    const assert: Assert;\n    const helper: any;\n}\n```\n\nI get the error:\n\n```\nserver/manual-typings.d.ts(4,8): error TS2665: Module augmentation cannot introduce new names in the top level scope.\n```\n"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2016-08-12T16:32:54Z",
        "body": "That error will be removed after TS 1.8. If you're able to try the 2.0 beta or the latest bits (`npm install typescript@next`) you can see how it works.\n"
      }
    ]
  },
  {
    "number": 10192,
    "title": "short-hand module declaration not working in application files (only in d.ts files)",
    "created_at": "2016-08-07T10:30:49Z",
    "closed_at": "2017-04-19T18:55:21Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/10192",
    "body": "**TypeScript Version:**   2.1.0-dev.2016080\n\nWhen declaring global variables it is possible to do something like this:\n\n``` ts\ndeclare var _: any;\n...\n_.every(...)\n```\n\ndirectly in the source code-file \n\ntrying to do the same for module leads to an exception in the TypeScript-Compiler:\n\n``` ts\ndeclare module 'lodash';\nimport * as lo from 'lodash';\n```\n\n```\n TS2664: Invalid module name in augmentation, module 'lodash' cannot be found.\n```\n\nadding the `declare module 'lodash'` in a `d.ts` file make the compiler happy again\n\n**Expected behavior:**\n\nIt should be possible to declare modules \"on the fly\" in source-code without the need to create a d.ts file for that.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/10192/comments",
    "author": "choeller",
    "comments": [
      {
        "user": "hriss95",
        "created_at": "2016-08-08T09:54:51Z",
        "body": "I think that using the string literal notation for the name is meant for external modules so you cannot really do that, unless you use namespaces. I could be wrong, I am learning TypeScript in the moment :)\n"
      },
      {
        "user": "blakeembrey",
        "created_at": "2017-02-13T23:33:22Z",
        "body": "This is because of the difference of the `import` or `export` keywords. Those keywords at the top-level change the definition/file to a module and change `declare module` from the global `module` declaration to an augmentation."
      }
    ]
  },
  {
    "number": 10156,
    "title": "On static method Error TS2339: Property 'then' does not exist on type '() => Promise'",
    "created_at": "2016-08-04T22:26:53Z",
    "closed_at": "2016-08-04T23:29:43Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/10156",
    "body": "<!-- BUGS: Please use this template. -->\n\n**TypeScript Version:**  1.8.10 and nightly (2.1.0-dev.20160804)\n\n**Code**\n\n``` ts\n/// <reference path=\"typings/globals/core-js/index.d.ts\" />\n\nexport class CryptoService\n{\n  static getToken()\n  {\n    return Promise.resolve('123');\n  }\n\n  static setXsrf()\n  {\n    return this.getToken.then( token  => {} );\n  }\n}\n```\n\n**Not expected error:**\n\n> error TS2339: Property 'then' does not exist on type '() => Promise<string>'.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/10156/comments",
    "author": "KostyaTretyak",
    "comments": [
      {
        "user": "DickvdBrink",
        "created_at": "2016-08-04T22:30:47Z",
        "body": "You wanted to write `this.getToken()` (notice the `()`) right?\n"
      },
      {
        "user": "KostyaTretyak",
        "created_at": "2016-08-04T22:38:57Z",
        "body": "@DickvdBrink, you say that I can not get a token?\n"
      },
      {
        "user": "normalser",
        "created_at": "2016-08-04T23:26:09Z",
        "body": "Change:\n`return this.getToken.then( token  => {} );`\nto\n`return this.getToken().then( token  => {} );`\n"
      },
      {
        "user": "KostyaTretyak",
        "created_at": "2016-08-04T23:30:58Z",
        "body": "Thank you guys! I am ashamed =)\n"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2016-08-05T01:04:28Z",
        "body": "Unless you have reason to believe there's actually a compiler bug, please use Stack Overflow for questions or log an issue with the definition file. Thanks!\n"
      }
    ]
  },
  {
    "number": 10146,
    "title": "type alias cannot work with class now?",
    "created_at": "2016-08-04T15:06:29Z",
    "closed_at": "2016-08-04T21:38:35Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/10146",
    "body": "**TypeScript Version:**  2.0.0 beta or playground\n\n**Code**\n\n``` ts\nclass A {}\ntype B = A;\n\nnew A();\nnew B();\n```\n\n**Expected behavior:**\nno error.\n**Actual behavior:** \nerror, cannot find name 'B'\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/10146/comments",
    "author": "plantain-00",
    "comments": [
      {
        "user": "evmar",
        "created_at": "2016-08-04T17:04:29Z",
        "body": "B is a type, not a function.  You can use it like `let x: B = ...` but not in any non-type position.\nTry `const B = A`.\n"
      }
    ]
  },
  {
    "number": 10135,
    "title": "Cannot rebuild declarations with declarationDir",
    "created_at": "2016-08-04T13:03:51Z",
    "closed_at": "2016-08-31T14:54:47Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/10135",
    "body": "**TypeScript Version:**  2.0.0-beta\n\n**Configuration**\n\n``` json\n{\n    \"compilerOptions\": {\n        \"declaration\": true,\n        \"declarationDir\": \"declarations\"\n    }\n}\n```\n\n**Expected behavior:**\nIn the first run, compiler generate declarations. When start second build `.d.ts` files should be updated.\n\n**Actual behavior:** \nAfter second run, I get this error:\n\n``` cmd\nerror TS5055: Cannot write file 'declarations/*.d.ts' because it would overwrite input file.\n```\n\nAnd declarations files not updated.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/10135/comments",
    "author": "GiedriusGrabauskas",
    "comments": [
      {
        "user": "lostfields",
        "created_at": "2016-08-31T07:39:44Z",
        "body": "add the following to your tsconfig.json to avoid making declarations of declarations or something :-)\n\n```\n\"exclude\": [\"./declarations\"]\n```\n"
      },
      {
        "user": "GiedriusGrabauskas",
        "created_at": "2016-08-31T08:53:20Z",
        "body": "Yep, it's working and that make sense. Thanks :+1: \n"
      }
    ]
  },
  {
    "number": 10105,
    "title": "Use lib/lib.*.d.ts as regular program files",
    "created_at": "2016-08-03T00:20:32Z",
    "closed_at": "2016-08-03T05:56:12Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/10105",
    "body": "We use the same `tsconfig.json` `compilerOptions` for all code in our monorepo.\nEach target gets to specify only the `files` list.\n\nWe'd like some targets to be able to opt-in for typings like collections. In the past, we did that by including the DefinitelyTyped es6-collections.d.ts in the files.\n\nIf I include one of the `///<reference no-default-lib=true/>` files, though, I get an error:\n\n```\nalexeagle@alexeagle:~/Projects/repro$ cat tsconfig.json \n{\n    \"compilerOptions\": {\n        \"module\": \"commonjs\",\n        \"target\": \"es5\"\n    },\n    \"files\": [\"node_modules/typescript/lib/lib.es2015.collection.d.ts\"]\n}\nalexeagle@alexeagle:~/Projects/repro$ $(npm bin)/tsc\nerror TS2318: Cannot find global type 'Array'.\nerror TS2318: Cannot find global type 'Boolean'.\nerror TS2318: Cannot find global type 'Function'.\nerror TS2318: Cannot find global type 'IArguments'.\nerror TS2318: Cannot find global type 'Number'.\nerror TS2318: Cannot find global type 'Object'.\nerror TS2318: Cannot find global type 'RegExp'.\nerror TS2318: Cannot find global type 'String'.\n```\n\nThis is the case even if other files are included in the compilation. I can solve it by removing the `///ref` but this means we have local modifications to Typescript. Is there another way to defeat the error?\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/10105/comments",
    "author": "alexeagle",
    "comments": [
      {
        "user": "DanielRosenwasser",
        "created_at": "2016-08-03T03:13:14Z",
        "body": "Those errors only come up because you didn't include `lib.es5.d.ts` , so you didn't have the global core types available.\n\nDoes this using this `tsconfig.json` fix the issue?\n\n``` json\n{\n    \"compilerOptions\": {\n        \"module\": \"commonjs\",\n        \"target\": \"es5\"\n    },\n    \"files\": [\n        \"node_modules/typescript/lib/lib.es5.d.ts\",\n        \"node_modules/typescript/lib/lib.es2015.collection.d.ts\"\n    ]\n}\n```\n"
      },
      {
        "user": "alexeagle",
        "created_at": "2016-08-03T05:56:12Z",
        "body": "Thanks Daniel, that does work.\n\nI had tried\n\n```\n{\n    \"compilerOptions\": {\n        \"module\": \"commonjs\",\n        \"target\": \"es5\",\n        \"noImplicitAny\": false,\n        \"sourceMap\": false,\n        \"lib\": [\"es5\"]\n    },\n    \"files\": [\n        \"app.ts\",\n        //\"node_modules/typescript/lib/lib.es5.d.ts\",\n        \"node_modules/typescript/lib/lib.es2015.collection.d.ts\"\n    ]\n}\n```\n\nthinking that the `--lib` flag would bring in the standard types (and this is what we have today). I imagine that `no-default-lib` actually means don't use any default libs, and the `--lib` flag just chooses a different set of \"default\" libs?\n\nBut it will probably make our setup easier to just use `--noLib` and pass all files together, rather than a mix of `--lib` and `files`\n"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2016-08-03T06:27:23Z",
        "body": "Sounds good, keep us posted on how that works out.\n"
      },
      {
        "user": "alexeagle",
        "created_at": "2016-08-04T04:35:38Z",
        "body": "Submitted it today, works great and solves our problem 👍 \n"
      },
      {
        "user": "alexeagle",
        "created_at": "2016-08-08T21:27:49Z",
        "body": "I take that back, we are investigating a 2x performance regression for compiles.\nWe now include v1_9_0_dev_20160526/lib/lib.es5.d.ts in the `files[]` of tsconfig. Even though we have a cache that prevents re-reading from disk, and we don't ask to type-check that file, I suspect we now hit some parse time when creating a `ts.Program` containing that.\nPreviously, it was in `--lib` and we `skipDefaultLibCheck` - I am guessing we also skipped parsing?\n\ncc @evmar who is profiling it.\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2016-09-08T23:10:21Z",
        "body": "@alexeagle is this still an issue?\n"
      },
      {
        "user": "alexeagle",
        "created_at": "2016-09-09T13:11:40Z",
        "body": "thanks for following up. We did track down our performance regression. @evmar could confirm, looking at the history we were not certain what introduced it. removing `--noEmitOnError` helped, as that was triggering an extra type-check.\n"
      }
    ]
  },
  {
    "number": 10093,
    "title": "How get only public properties?",
    "created_at": "2016-08-02T13:37:41Z",
    "closed_at": "2016-09-20T22:53:07Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/10093",
    "body": "How get only `public` properties, without `private`?\n\n```\nclass A {\n private _a:string = \"111\";\n public b: string = \"222\"\n}\nconsole.log(new A());\n/*\n_a: \"111\",b: \"222\"\n*/\n```\n\nThank you in advance.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/10093/comments",
    "author": "maranqz",
    "comments": [
      {
        "user": "arlee12",
        "created_at": "2016-08-02T14:07:51Z",
        "body": "Public and private properties look the same in compiled Javascript, so there is no way to distinguish them.\n"
      },
      {
        "user": "kitsonk",
        "created_at": "2016-08-02T14:08:17Z",
        "body": "The only way is to enumerate over the properties and use some sort of convention to sort them out, since private properties are added by default assignment, which creates them as enumerable own properties.\n\nSee #9769 for a discussion on a possible solution to this.\n"
      }
    ]
  },
  {
    "number": 10056,
    "title": "Mystique Screen interface",
    "created_at": "2016-07-31T19:16:24Z",
    "closed_at": "2016-07-31T21:47:35Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/10056",
    "body": "Go to playground and type\n\n``` ts\ninterface Screen<T> {}\n```\n\nyou will see error: all declarations of an interface must have identical type parameters.\n\nI have tried it in Chrome and Mozila, OS -windows 8\n\nIt seems to me that some code inside playground in global scope.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/10056/comments",
    "author": "olegdunkan",
    "comments": [
      {
        "user": "olegdunkan",
        "created_at": "2016-07-31T19:49:53Z",
        "body": "I found out that Screen is the global object in browser environment, then I saw the same issue about 'name' variable. For novice it is not obvious that code in playground is executed in global scope.  The questions like this will appear more and more. Maybe it will better to limit scope or make some attention to this for users.  \n\nIn my case typescript generates nothing, there is no any variable named Screen. How can I suppose that nothing interferes with global Screen object? \n"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2016-07-31T21:47:35Z",
        "body": "If you use modules, you'll get a \"fresh\" scope inside the global scope where you can shadow existing names as you like.\n\nIn real life, conflict with global variables when code executes at the global scope is actually a very large concern and it's desirable to be warned of this. It'd be very bad, for example, to assign to `Screen` or some other mutable variable and break some downstream code.\n"
      },
      {
        "user": "olegdunkan",
        "created_at": "2016-08-01T08:26:29Z",
        "body": "Yes, in real life it is. But we are in a pure playground as I thought. \nThank you)\n"
      }
    ]
  },
  {
    "number": 9955,
    "title": "Auto emit types ",
    "created_at": "2016-07-26T16:28:16Z",
    "closed_at": "2017-04-27T16:17:28Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/9955",
    "body": "Is it planned to emit the type metadata for every attribute on class level. Especially when defining a data model this would be very helpful. It would be great to be able to add something like a decorator @emitAllMetadata to the class and then the metadata for every attribute will be emitted.\n\n``` js\n@emitAllMetadata\nclass Myclass {\n  public color: string;\n}\n\nlet test = new Myclass();\n\nconsole.log(Reflect.getMetatdata('design:type', test,'color'));\n// output: string\n```\n\nI know it will create a lot of overhead when doing this for every class but especially in the backend where its's needed to verify data before storing in the database it could be very helpful.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/9955/comments",
    "author": "DominicBoettger",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2017-04-27T16:17:24Z",
        "body": "We have no plans in changing or increasing the scope of the metadata emit feature."
      }
    ]
  },
  {
    "number": 9811,
    "title": "Cannot define declared variable with the same property",
    "created_at": "2016-07-19T07:46:15Z",
    "closed_at": "2016-07-25T06:14:32Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/9811",
    "body": "**TypeScript Version:**  1.8.0 / nightly (2.0.0-dev.201xxxxx)\n\n**Code**\n\n``` ts\ninterface A {   \n}\n\ndeclare var A: {\n    x: number;\n}\n\nclass AShim implements A {\n    x: number;\n}\n\nvar A: {\n     x: number;\n} = AShim;\n```\n\n**Expected behavior:**\nI expect this to compile successfully.\n\n**Actual behavior:** \n\n```\na.ts(12,5): error TS2322: Type 'typeof AShim' is not assignable to type '{ x: number; }'.\n  Property 'x' is missing in type 'typeof AShim'.\n```\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/9811/comments",
    "author": "NN---",
    "comments": [
      {
        "user": "kitsonk",
        "created_at": "2016-07-19T10:41:56Z",
        "body": "Classes have two interfaces, the instance interface and the static interface of the constructor function.  You are trying to assign something that is a class to something that is a simple object interface.  The static interface can be referenced as `typeof AShim` and `new AShim()` would produce something that is assignable to `A`.\n\nTo describe an interface that `AShim` could be assigned to, it would look like this:\n\n``` typescript\ninterface AConstructor {\n    new (): A;\n    prototype: A;\n}\n\nvar A: AConstructor = AShim;\n```\n"
      },
      {
        "user": "NN---",
        "created_at": "2016-07-19T18:25:03Z",
        "body": "Why it works for other cases like this:\n\n``` ts\n\ninterface Blob {\n    size: number;\n    type: string;\n    msClose(): void;\n    msDetachStream(): any;\n    slice(start?: number, end?: number, contentType?: string): Blob;\n}\n\ndeclare var Blob: {\n    prototype: Blob;\n    new (blobParts?: any[], options?: BlobPropertyBag): Blob;\n}\n\nclass BlobShim implements Blob {\n    constructor(blobParts?: any[], options?: BlobPropertyBag) { }\n    msDetachStream(): any {}\n    slice(start?: number, end?: number, contentType?: string): Blob {\n        return null;\n    }\n    msClose(): void {}\n    type: string;\n    size: number;\n}\n\n// OK\nvar Blob: {\n    prototype: Blob;\n    new(blobParts?: any[], options?: BlobPropertyBag): Blob;\n} = BlobShim;\n```\n"
      },
      {
        "user": "kitsonk",
        "created_at": "2016-07-19T21:39:17Z",
        "body": "Because BlobShim's interface matches the interface for `var Blob`.  Above, you were trying to put assign a constructor function/class to an instance interface, as I explained.  Here, you are assigning `BlobShim` to a constructor interface, which works.\n"
      },
      {
        "user": "NN---",
        "created_at": "2016-07-20T06:20:49Z",
        "body": "@kitsonk Your example doesn't compile.\n\n``` ts\ninterface A {   \n}\n\ndeclare var A: {\n    x: number;\n}\n\nclass AShim implements A {\n    x: number;\n}\n\ninterface AInterface {\n    x: number;\n}\n\nvar A: AInterface = AShim;\n```\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2016-07-20T06:25:54Z",
        "body": "@NN--- can you explain what is the original issue behind the OP? \n"
      },
      {
        "user": "NN---",
        "created_at": "2016-07-20T09:40:56Z",
        "body": "@mhegazy I am writing tests with PhantomJS runner.\nIt doesn't have window.URL object, so I want to create my own.\nThe code worked well in TS 1.8 and stopped working in TS 2.0.\nAfter some investigations I got to this minimal code sample.\n\nI don't understand why it doesn't work while having the exact same types on both sides.\n"
      },
      {
        "user": "normalser",
        "created_at": "2016-07-21T03:03:47Z",
        "body": "@NN---  \n\nSeems like you did not understand @kitsonk explanation\n\nHere is your last full example adjusted to compile\n\n``` ts\ninterface A {   \n}\n\ndeclare var A: {\n    x: number;\n}\n\nclass AShim implements A {\n    x: number;\n}\n\ninterface AInterface {\n    x: number;\n}\n\nvar A: AInterface = AShim.prototype;\nvar A: AInterface = new AShim();\n\ninterface AInterface2 {\n    new (): AInterface;\n    prototype: AInterface;\n}\n\nvar A2: AInterface2 = AShim;\n```\n"
      },
      {
        "user": "NN---",
        "created_at": "2016-07-21T20:38:27Z",
        "body": "@wallverb The only problem that I want to it without A2.\n\nI want to define a variable of URL with my implementation.\nHow I do it ?\nThank you.\n\n``` ts\ninterface URL {\n    hash: string;\n    host: string;\n    hostname: string;\n    href: string;\n    readonly origin: string;\n    password: string;\n    pathname: string;\n    port: string;\n    protocol: string;\n    search: string;\n    username: string;\n    toString(): string;\n}\n\ndeclare var URL: {\n    prototype: URL;\n    new(url: string, base?: string): URL;\n    createObjectURL(object: any, options?: ObjectURLOptions): string;\n    revokeObjectURL(url: string): void;\n}\n```\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2016-07-21T23:27:17Z",
        "body": "all you need is somehting that has the shape of the the URL constructor, i.e. the type of the `var` `URL`.\n\nso:\n\n``` ts\nclass URLShim {\n    // instace side, i.e. interface URL\n    hash: string;\n    host: string;\n    hostname: string;\n    href: string;\n    readonly origin: string;\n    password: string;\n    pathname: string;\n    port: string;\n    protocol: string;\n    search: string;\n    username: string;\n\n    // Static side, i,e. typeof var URL\n    constructor(url: string, base?: string) { }\n    static createObjectURL(object: any, options?: ObjectURLOptions): string { }\n    static revokeObjectURL(url: string): void { }\n}\n\nURL = URLShim;\n\n```\n"
      },
      {
        "user": "NN---",
        "created_at": "2016-07-25T06:14:32Z",
        "body": "@mhegazy **static createObjectURL** \nThis does the trick :+1: \n\nDidn't think that 'static' affects on type matching, while it is logical though.\n"
      }
    ]
  },
  {
    "number": 9706,
    "title": "Compiler error in MSBuild using Typescript",
    "created_at": "2016-07-13T22:46:29Z",
    "closed_at": "2016-07-14T00:06:22Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/9706",
    "body": "**TypeScript Version:**  1.8.31.0\n**Code**\n\n``` ts\nif (document.fullscreenEnabled || document.webkitFullscreenEnabled)\n{\n    if (document.exitFullscreen !== undefined)\n    {\n        document.exitFullscreen();\n    }\n    else if (document.webkitCancelFullScreen !== undefined)\n    {\n        document.webkitCancelFullScreen();\n    }\n    else\n    {\n        document.webkitExitFullscreen();\n    }\n}\n```\n\n// A _self-contained_ demonstration of the problem follows...\nType script compiler issue.\n1>d:\\snr_git\\snrcode\\private\\frontend\\answers\\services\\maps\\src\\content/script/plugins/internalcontrols/taskbar/viewmodel/taskbarviewmodel.ts(526,35) : error TS2339: Property 'webkitCancelFullScreen' does not exist on type 'Document'. [d:\\snr_git\\snrcode\\private\\frontend\\answers\\services\\maps\\src\\maps.csproj]\nThis also occurs for exitFullscreen and webkitExitFullscreen. ```\n\n**Expected behavior:**\nAs these are supported in JavaScript I would expect type script to also support them. \n\n**Actual behavior:** \nCompiler errors for this and any full screen methods on elements or the document.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/9706/comments",
    "author": "dwloup69",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2016-07-14T00:06:17Z",
        "body": "We have been trying to remove vendor specific definitions from the library to make it as standard complaint as possible.\n\nThe declarations in lib.d.ts are just normal interfaces, and you can augment them to add your specific declarations, so include this in one of your files, and you should not see this error again.\n\n``` ts\ninterface Document {\n    webkitCancelFullScreen?(): void;\n}\n```\n"
      }
    ]
  },
  {
    "number": 9604,
    "title": "Overriding addEventListener to augment event objects",
    "created_at": "2016-07-11T00:25:45Z",
    "closed_at": "2016-07-11T21:33:53Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/9604",
    "body": "Ultimately, what I want to do is to describe the following trick:\n\n``` js\nconst element = document.createElement(\"div\");\n\nelement.addEventListener(\"click\", event => {\n  event.foo = 123;\n});\n```\n\nAs you see, my `<div>` element intercepts all \"click\" events and adds a new property to them, so whoever attaches a \"click\" listener later will see this new property.\n\nA practical example would be a custom UI element that represents, for instance, a chess board, and adds `row` and `col` properties to every mouse event, as the consumers of the UI element shouldn't need to convert the plain `x` and `y` coordinates to the cell coordinates.\n\nMy attempt to describe this failed:\n\n``` ts\ninterface MyMouseEvent {\n  foo?: number;\n}\n\ninterface MyElement extends HTMLElement {\n  addEventListener(type: \"click\", listener: (ev: MyMouseEvent) => any, capture?: boolean): void;\n}\n```\n\ntsc complains that the HTMLElement interface is incorrectly extended:\n\n```\nTS2430  Interface 'MyElement' incorrectly extends interface 'HTMLElement'.\n  Types of property 'addEventListener' are incompatible.\n    Type '(type: \"click\", listener: (ev: MyMouseEvent) => any, useCapture?: boolean) => void' is not assignable to type '{ (type: \"MSContentZoom\", listener: (ev: UIEvent) => any, useCapture?: boolean): void; (type: \"MS...'.\n      Type '(type: \"click\", listener: (ev: MyMouseEvent) => any, useCapture?: boolean) => void' provides no match for the signature '(type: string, listener: EventListener | EventListenerObject, useCapture?: boolean): void'\n```\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/9604/comments",
    "author": "d180cf",
    "comments": [
      {
        "user": "kitsonk",
        "created_at": "2016-07-11T07:19:31Z",
        "body": "When you have overrides that is also an overload, you have to provide at least one overload that matches the overridden function.  This is fairly clearly implied by the error:\n\n``` typescript\ninterface MyElement extends HTMLElement {\n  addEventListener(type: \"click\", listener: (ev: MyMouseEvent) => any, capture?: boolean): void;\n  addEventListener(type: string, listener: EventListener | EventListenerObject, useCapture?: boolean): void;\n}\n```\n"
      },
      {
        "user": "d180cf",
        "created_at": "2016-07-12T01:49:58Z",
        "body": "This works nicely, indeed. Thanks!\n"
      }
    ]
  },
  {
    "number": 9584,
    "title": "How to write a definition file for a commonjs module without typings.",
    "created_at": "2016-07-09T04:22:20Z",
    "closed_at": "2016-07-09T04:42:32Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/9584",
    "body": "```\n//./SpinnerDialog.js\n'use strict'\n\nconst exec = require('cordova/exec')\n\nmodule.exports = {\n  show: function (title, message, cancelCallback) {\n    if (cancelCallback === true && typeof cancelCallback !== 'function') {\n      cancelCallback = function () {}\n    }\n    exec(cancelCallback, null, 'SpinnerDialog', 'show', [ title, message, !!cancelCallback ])\n  },\n  hide: function (success, fail) {\n    exec(success, fail, 'SpinnerDialog', 'hide', [ '', '' ])\n  }\n}\n```\n\nSo I can use relative path to import this moudle\n\nimport \\* as SpinnerDialog from '../../../plugins/com.filfatstudios.spinnerdialog/www/SpinnerDialog';\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/9584/comments",
    "author": "lygstate",
    "comments": [
      {
        "user": "DanielRosenwasser",
        "created_at": "2016-07-09T04:42:30Z",
        "body": "Hi @lygstate Please ask questions on StackOveflow in the future. This is not a help forum.\n\nBecause I'm already answering:\n\n``` ts\ndeclare namespace SpinnerDialog {\n    export function show(title: string, message: string, cancelCallback: boolean | (() => void): void;\n    export function hide(success: () => void, fail: () => void): void;\n}\nexport = SpinnerDialog;\n```\n\nThough if this is a local file, why not just convert it to TypeScript as it stands?\n"
      },
      {
        "user": "lygstate",
        "created_at": "2016-07-09T06:07:50Z",
        "body": "declare it is not a problem. but how to import the js file properly.?\n"
      }
    ]
  },
  {
    "number": 9575,
    "title": "Debugging Cordova App with Webpack sourcemaps",
    "created_at": "2016-07-08T17:19:32Z",
    "closed_at": "2016-09-20T22:49:20Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/9575",
    "body": "Angular2 + TypeScript + Webpack Cordova app - I want to be able to debug original TypeScript files on my Android phone when debugging app using Chrome.\n\nWhat is additionally needed to configure in order for the sourcemap to also work in a remote mobile device running cordova app bundled by Webpack?\n\nWill add current configurations on demand.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/9575/comments",
    "author": "justme1",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2016-07-08T18:06:14Z",
        "body": "What version of VS are you using? what version of TS? \n"
      },
      {
        "user": "justme1",
        "created_at": "2016-07-08T18:11:58Z",
        "body": "TypeScript 1.8\nNot using VS (Webstorm instead)\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2016-07-08T18:15:23Z",
        "body": "Your debugger needs to support webpack source maps. most do. we have done work in VS 2015 Update3 to support this scenario specifically. i am not familiar with what webstorm does for debugging to be frank so can not comment on this.\n\n@sheetalkamat is the expert, she can give some guidance here as well.\n"
      },
      {
        "user": "justme1",
        "created_at": "2016-07-08T18:20:43Z",
        "body": "The debugging is being done inside of Chrome - not Webstorm (it's only the IDE, not used for debugging).\n\nI'm describing here the most basic workflow using Webpack + Typescript debugging Cordova app - should be pretty straightforward to set it up. Unfortunately, I couldn't find exact config online to support this.\n"
      },
      {
        "user": "sheetalkamat",
        "created_at": "2016-07-08T18:22:46Z",
        "body": "@justme1 Webpack puts the sources inline, so chrome might be able to show you typescript files when debugging. You would need to try it out. We did some work so that the inline files can be mapped to the actual disk files in VS but irrespective of that work there is possibility that it would just work, given chrome can find the sourcemap file.\n"
      },
      {
        "user": "justme1",
        "created_at": "2016-07-08T18:25:49Z",
        "body": "@sheetalkamat Unfortunately I've opened an issue here because I couldn't find the files in Chorme when debugging the Cordova app.  However, when I debug using webpack-dev-server as a website I'd see the files in Chrome when debugging.\n\nI think the problem is that the TypeScript files aren't accessible to the Android phone as they are located on my computer, opposed to the case when debugging as a website from my machine where the files are accessible.\n\nI could write here the webpakc config if you want.\n"
      },
      {
        "user": "justme1",
        "created_at": "2016-07-10T14:22:03Z",
        "body": "any news on this?\n"
      },
      {
        "user": "sheetalkamat",
        "created_at": "2016-07-11T18:54:42Z",
        "body": "@justme1 , Can you check if your app that you compiled with webpack has inline sources? That is in the source map file of the .js file has contents for the typescript file it is compiled from.\n"
      },
      {
        "user": "justme1",
        "created_at": "2016-07-11T19:03:04Z",
        "body": "@sheetalkamat you want to check the sourcemap files and see if the sourcemap files contains the TypeScript file in it, am I right?\n"
      },
      {
        "user": "sheetalkamat",
        "created_at": "2016-07-11T19:15:14Z",
        "body": "@justme1  yes that's right.\n"
      },
      {
        "user": "justme1",
        "created_at": "2016-07-11T19:25:40Z",
        "body": "@sheetalkamat from the check I've made I'm pretty sure that yes, it does contain the actual TypeScript files in the sourcemaps.\n\nI'm using:\n\nmodule.exports = {\n\n  devtool: 'source-map',\n  watchOptions: {\n    poll: true\n  },\n\n  entry: {\n    \"vendor\": [\n      path.resolve(__dirname, 'app', 'vendor')\n    ],\n    \"app\": [\n      path.resolve(__dirname, 'app', 'boot')\n    ]\n  },\n\n...\n"
      },
      {
        "user": "justme1",
        "created_at": "2016-07-11T19:34:36Z",
        "body": "Seems like it is now working:\n\nAll I needed to do was to use \n\n  devtool: 'inline-source-map',\n\ninstead of \n\ndevtool: 'source-map',\n\nDoes that makes sense? Now everything is working (breakpoints, I see all TS files - this rocks!)\n"
      },
      {
        "user": "justme1",
        "created_at": "2016-07-11T19:49:53Z",
        "body": "@sheetalkamat, do you have any experience in regards to sourcemaps & TypeScript using Safari in Mac?\n\nEverything is working perfectly on Chrome both on Web & Cordova - but I'm unable to see the TypeScript files using same configurations in Safari.\n\nIt's important for me due to the fact the debugging iOS Cordova app is only possible using Safari :-(\n"
      },
      {
        "user": "sheetalkamat",
        "created_at": "2016-07-11T20:53:40Z",
        "body": "@justme1  glad that worked. I haven't used source map debugging with safari so I don't have much idea if and what they support. Sorry.\n"
      },
      {
        "user": "justme1",
        "created_at": "2016-07-11T21:10:12Z",
        "body": "@sheetalkamat  thanks a lot for your great help - it was extremely important for me to be able debug TypeScript on Chrome.\n\nIt would be great if you could point out someone you are familiar who has experience with Safari + TypeScript debugging as this one will be needed by the entire iOS Cordova developers with Angular2 as they must debug their apps _only_ on Safari.\n\nThanks again\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2016-09-20T22:49:20Z",
        "body": "I do not think we have a safari expert around. SO might provide more help.\n"
      }
    ]
  },
  {
    "number": 9463,
    "title": "TypeScript setting type of new JSX.Element",
    "created_at": "2016-07-01T02:11:53Z",
    "closed_at": "2016-07-25T16:26:28Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/9463",
    "body": "After importing React-Router, when I type the following\n`let test = <Route /> as Route;`\nI get the following error: `error TS2352: Neither type 'Element' nor type 'Route' is assignable to the other.\n  Property 'setState' is missing in type 'Element'.`\n\nThis should work; why does it not?\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/9463/comments",
    "author": "ozyman42",
    "comments": [
      {
        "user": "krasevych",
        "created_at": "2016-07-25T15:17:17Z",
        "body": "the same problem\n"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2016-07-25T16:26:28Z",
        "body": "`<Route />` isn't an instance of `Route`. It's not even close -- it's an expression that will be passed to `render` and eventually turned into a wrapped data structure that will be processed by React to produce something that is _backed_ by an instance of `Route`.\n\nPlease take questions to Stack Overflow with a better description of what you're trying to do.\n"
      }
    ]
  },
  {
    "number": 9462,
    "title": "Interface lost when re-exported",
    "created_at": "2016-07-01T02:01:40Z",
    "closed_at": "2016-07-02T06:21:46Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/9462",
    "body": "**TypeScript Version:**  1.8.10 & nightly (2.0.0-dev.20160630)\n\n**Code**\n\n`one.ts`:\n\n``` ts\ninterface One {\n  type:One.Type;\n}\nmodule One {\n  export enum Type { FOO, BAR }\n}\nexport default One;\n```\n\n`two.ts`:\n\n``` ts\nimport One from './one';\ninterface Two {\n  aOne:One;\n}\nmodule Two {\n  export const Oneone = One;\n}\nexport default Two;\n```\n\n`three.ts`:\n\n``` ts\nimport One from './one';\nimport Two from './two';\nlet aOne:One;\nlet bOne:Two.Oneone;\n```\n\n**Expected behavior:**\n\nNo compile errors (I should be able to refer to `Two.Oneone` as an alias to the `One` interface from `one.ts`, right?)\n\n**Actual behavior:** \n\n```\n4 let bOne:Two.Oneone;\n               ~~~~~~\n\nthree.ts(4,14): error TS2305: Module 'Two' has no exported member 'Oneone'.\n```\n\nNote that the generated JS code _does_ alias and export `Oneone`:\n\n`two.js`:\n\n``` js\n\"use strict\";\nvar one_1 = require('./one');\nvar Two;\n(function (Two) {\n    Two.Oneone = one_1.default;\n})(Two || (Two = {}));\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = Two;\n```\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/9462/comments",
    "author": "nevir",
    "comments": [
      {
        "user": "nevir",
        "created_at": "2016-07-01T18:14:22Z",
        "body": "If I _also_ export the type, I can get a bit further\n\n`one.ts` (no change)\n`two.ts`:\n\n``` ts\nimport One from './one';\ninterface Two {\n  aOne:One;\n}\nmodule Two {\n  export const Oneone = One;\n  export type Oneone = One;\n}\nexport default Two;\n```\n\n`three.ts`:\n\n``` ts\nimport Two from './two';\nlet foo:Two.Oneone = {type:Two.Oneone.Type.BAR};\nlet type:Two.Oneone.Type = Two.Oneone.Type.BAR;\n```\n\n```\n3 let type:Two.Oneone.Type = Two.Oneone.Type.BAR;\n               ~~~~~~\n\nthree.ts(3,14): error TS2305: Module 'Two' has no exported member 'Oneone'.\n```\n"
      },
      {
        "user": "nevir",
        "created_at": "2016-07-01T21:02:59Z",
        "body": "Ok, so I found an approach that does what I want, but I'm supremely confused about the syntax, and whether this is being used appropriately (e.g. `export import` o.O):\n\n`one.ts`:\n\n``` ts\ninterface One {\n  type:One.Type;\n}\nmodule One {\n  export enum Type { FOO, BAR }\n}\nexport default One;\n```\n\n`two.ts`:\n\n``` ts\nimport One from './one';\ninterface Two {\n  aOne:One;\n}\nmodule Two {\n  export import Oneone = One;\n}\nexport default Two;\n```\n\n`three.ts`:\n\n``` ts\nimport One from './one';\nimport Two from './two';\nlet aOne:One;\nlet bOne:Two.Oneone;\n```\n"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2016-07-02T06:21:46Z",
        "body": "Yup, that's an import alias. IIRC, it creates an alias of every meaning of an identifier/qualified name. Sorry you had to jump through hoops.\n"
      }
    ]
  },
  {
    "number": 9456,
    "title": "Dont require declaration files after compile",
    "created_at": "2016-06-30T22:09:18Z",
    "closed_at": "2016-07-06T23:31:30Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/9456",
    "body": "I use `import` instead of `<reference ..` to import my `d.ts` files. But after I'd compiled this:\n\n``` ts\nimport 'tests/interfaces/mocha.d.ts';\n```\n\nI've got:\n\n``` js\n\"use strict\";\nrequire('tests/interfaces/mocha.d.ts');\n```\n\nMy config file:\n\n``` json\n{\n    \"compilerOptions\": {\n        \"emitDecoratorMetadata\": true,\n        \"experimentalDecorators\": true,\n        \"module\": \"commonjs\",\n        \"moduleResolution\": \"classic\",\n        \"noImplicitAny\": false,\n        \"outDir\": \"dist\",\n        \"rootDir\": \".\",\n        \"sourceMap\": true,\n        \"target\": \"es5\"\n    }\n}\n```\n\nCan i change this behaviour by config?\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/9456/comments",
    "author": "lasekio",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2016-06-30T22:27:30Z",
        "body": "do not put the file extension in the require statement. use the module name. so:\n\n``` ts\nimport 'tests/interfaces/mocha';\n```\n\nor  if you are using TS 2.0: \n\n``` ts\nimport 'tests/interfaces/mocha.js';\n```\n"
      },
      {
        "user": "lasekio",
        "created_at": "2016-06-30T22:33:33Z",
        "body": "@mhegazy I use version `1.8.10`\n\n``` ts\nimport 'tests/interfaces/mocha';\n```\n\nworks same.\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2016-06-30T22:38:25Z",
        "body": "> Can i change this behavior by config?\n\nno. module names are resource identifiers, they are written in the output the same way they are read. the compiler will not change the import name or extension.\n"
      }
    ]
  },
  {
    "number": 9438,
    "title": "How to judge class type?",
    "created_at": "2016-06-30T09:44:28Z",
    "closed_at": "2016-06-30T19:35:41Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/9438",
    "body": "Hi all,I have a question that how to  judge the class type in typescript? pseudo-code as below:\n\n```\nfunction isComponent(ipt:any){\n     if(ipt==Component) return true;\n     return false;\n}\nfunction isAaComponent(ipt:any){\n     if(ipt==AaComponent) return true;\n     return false;\n}\n```\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/9438/comments",
    "author": "keyiis",
    "comments": [
      {
        "user": "kitsonk",
        "created_at": "2016-06-30T12:54:42Z",
        "body": "General questions should be filed on StackOverflow or discussed on Gitter or IRC.  The TypeScript issues are for issues (potential bugs) for TypeScript.\n\nThis is basic JavaScript and little to nothing to do with TypeScript, if you want to know if an instance is an instance of a class, you use the `instanceof` operator.  For example:\n\n``` typescript\nfunction isComponent(ipt: any) {\n  return ipt instanceof Component;\n}\n```\n\nAt a technical level it determines if the prototype of `Component` is contained in the prototype chain of the subject of the operator.\n"
      }
    ]
  },
  {
    "number": 9370,
    "title": "Allow empty return statements on setters",
    "created_at": "2016-06-27T11:06:27Z",
    "closed_at": "2016-06-27T16:32:09Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/9370",
    "body": "**TypeScript Version:** \n1.8.10\n\n**Code**\n\n``` ts\nclass Foo {\n  private _value: string = '';\n  set value(newV: string): void {\n    if (newV === this._value) {\n      return;\n    }\n\n    // ...\n  }\n}\n```\n\n**Expected behavior:**\n\nNo errors.\n\n**Actual behavior:** \n\n`A 'set' accessor cannot have a return type annotation.`.\n\nThanks :)\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/9370/comments",
    "author": "gjuchault",
    "comments": [
      {
        "user": "aluanhaddad",
        "created_at": "2016-06-27T11:51:42Z",
        "body": "Is the issue of the Void annotation, or the return statement I believe it's the former.\n"
      },
      {
        "user": "gjuchault",
        "created_at": "2016-06-27T11:58:30Z",
        "body": "The error is that TypeScript puts an error when there is a return statement on a setter; when it can makes sense to stop the setter becasue of validation or whatever\n"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2016-06-27T16:32:09Z",
        "body": "The issue is the return type annotation, not the return statement. Expressionless return statements are legal. Return type annotations are not.\n"
      },
      {
        "user": "gjuchault",
        "created_at": "2016-06-28T07:36:09Z",
        "body": "@RyanCavanaugh Ok I'm not really sure what's the difference between the two. Is the `: void` non-sense on a setter ?\n"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2016-06-28T15:25:40Z",
        "body": "Yes. The returned value of a setter is unobservable, so it doesn't make any sense to talk about its return type.\n"
      }
    ]
  },
  {
    "number": 9368,
    "title": "should ts avoid to use the this keyworld in class ?",
    "created_at": "2016-06-27T06:16:31Z",
    "closed_at": "2016-06-27T07:10:27Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/9368",
    "body": "**version**\n1.8.31\n\n``` ts\nclass A {\n    public count: number = 10;\n    public AddOne(): void{\n        this.count += 1;\n    }\n}\n```\n\nand will generate those js\n\n``` js\nvar A = (function () {\n    function A() {\n        this.count = 10;\n    }\n    A.prototype.AddOne = function () {\n        this.count += 1;\n    };\n    return A;\n}());\n\n```\n\nthis is ok when you `let a = new A()`  and `a.AddOne()`  , \nbut when  `let myadd = a.AddOne`  and   `myadd()`\nthe result will be different . because  `this`  became something else.\n\nshould  the output js like this ?\n\n``` js\nvar A = (function () {\n    var _this;\n    function A() {\n        this.count = 10;\n        _this = this;\n    }\n    A.prototype.AddOne = function () {\n        _this.count += 1;  // not use this\n    };\n    return A;\n}());\n```\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/9368/comments",
    "author": "John0King",
    "comments": [
      {
        "user": "kitsonk",
        "created_at": "2016-06-27T06:27:46Z",
        "body": "This is just the behaviour of JavaScript.  When using `class` in a ES6 compatible environment, you get an error when you called an improperly bound method:\n\n``` javascript\nclass A {\n    constructor() {\n        this.count = 10;\n    }\n    AddOne() {\n        this.count += 1;\n    }\n}\n\nconst a = new A();\nconst myaddone = a.AddOne;\n\nmyaddone();  // Uncaught TypeError: Cannot read property 'count' of undefined\n```\n\nTherefore if your suggestion would break compatibility with ES6 classes.\n\nIf you need a reference of a method bound to an instance, just bind it:\n\n``` typescript\nconst myaddone = a.AddOne.bind(a);\n```\n"
      },
      {
        "user": "John0King",
        "created_at": "2016-06-27T06:43:31Z",
        "body": "@kitsonk  How to use it in  jquery's  `click`  or  `change` method ?\n"
      },
      {
        "user": "kitsonk",
        "created_at": "2016-06-27T06:51:23Z",
        "body": "I am afraid this isn't a general support forum, but without some example of how you want to use something and what is not working, it is really difficult to even answer that question.  The problem could be solved any number of ways, which are patterns used with construction functions with prototypes since the early days of JavaScript.  Most libraries like jQuery have mechanisms for being context when it can be lost as well as ES6 offer lexical `this` binding when using arrow/lambda functions.\n\nBut all of this is probably not for discussion in a issue tracker for bugs with TypeScript.  StackOverflow, Gitter and IRC are better places to discuss \"how do I use\" something.\n"
      },
      {
        "user": "John0King",
        "created_at": "2016-06-27T07:10:27Z",
        "body": "@kitsonk   you are right , my suggestion can fix in es 5 and lower but can not fix in es6.\n"
      }
    ]
  },
  {
    "number": 9347,
    "title": "Pattern for define type of class extends an abstract class.",
    "created_at": "2016-06-24T12:22:33Z",
    "closed_at": "2016-08-27T00:25:43Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/9347",
    "body": "Hi,\n\nI am looking for a pattern that allows me to create a command pattern object from an classes that extends from an abstract class. The abstract class have some helper method and implement the default values for the properties defined in an interface. \nThis type of ATest (see below) should the base element, because the getValue method will declared in the classes that extends ATest.\nSo the question is if there is a proper sollution or a way to define an interface, contain a bunch of classes, that extends an abstract?\n\n``` TypeScript\n// a base interface that spec the properties\ninterface ITest {\n    value: string;\n    getValue(): string;\n}\n\n// abstract class that implements helper methods\nabstract class ATest implements ITest {\n    value: string = 'new String';\n    abstract getValue(): string;\n    constructor() {\n        // create default value pattern\n    }\n\n    protected helper(num: number): string {\n        return String(num);\n    }\n}\n\n// implementing class\nclass Test extends ATest {\n    constructor() {\n        super();\n    }\n\n    getValue(): string {\n        return this.value;\n    }\n\n    getNumVal(num: number) {\n        return this.helper(num);\n    }\n}\n\n// this should implement the command pattern\n// how can this a class that extends from the abstract class ATest?\ninterface ICommandTest {\n    [name: string]: typeof ATest;\n}\n\n\n\nvar commandObject: ICommandTest = {};\ncommandObject['test'] = Test;\n// Does not work\n//let Cmd: typeof Test = commandObject['test'];\nlet Cmd = commandObject['test'];\nlet test = new Cmd();\n```\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/9347/comments",
    "author": "Thomas-P",
    "comments": [
      {
        "user": "aluanhaddad",
        "created_at": "2016-06-24T15:21:36Z",
        "body": "I think you are looking for \n\n``` TypeScript\ninterface ICommandTest {\n    [name: string]: ATest;\n}\n```\n\nwhen you write `typeof ATest`, you are getting the class from whence an instance was created (more or less).\n"
      },
      {
        "user": "aluanhaddad",
        "created_at": "2016-06-24T15:24:37Z",
        "body": "Consider\n\n``` TypeScript\ntype T = typeof Date;\n```\n\nT is the type `DateConstructor`.\n"
      },
      {
        "user": "Thomas-P",
        "created_at": "2016-06-24T17:02:11Z",
        "body": "Hi, \nI want to get the class explicitly passed and call the constructor in the method. Otherwise I head to use the factory way.\n"
      },
      {
        "user": "aluanhaddad",
        "created_at": "2016-06-24T18:20:03Z",
        "body": "@Thomas-P I missed that requirement. This can still be done by declaring the type returned by the index signature to be a constructor function which returns a type derived from `ATest` \n\n``` TypeScript\n    [name: string]: new () => ATest;\n```\n\nEdit: Why avoid a factory though?\n"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2016-08-18T17:12:39Z",
        "body": "`[name: string]: new () => ATest;` indeed looks like the right declaration here.\n"
      }
    ]
  },
  {
    "number": 9311,
    "title": "Should syntax like `+someVariable` be allowed by itself?",
    "created_at": "2016-06-22T13:19:02Z",
    "closed_at": "2016-06-22T14:22:29Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/9311",
    "body": "**TypeScript Version:**  1.8.10\n\nI've seen some developers at my organization do something like the following _(usually a typo)_\n\n``` ts\nvar num = 4;\nvar demo = +num;\nconsole.log(demo); //4\n```\n\nWriting `+num` seems like it should not be valid syntax by itself, although it is allowed in plain JavaScript.  Either way it really does nothing except look strange as far as I can tell.\n\nI can't really think of a valid reason why syntax like this should be allowed, but I'd be curious to hear if anyone knows reasons why it should.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/9311/comments",
    "author": "ChrisMBarr",
    "comments": [
      {
        "user": "kitsonk",
        "created_at": "2016-06-22T13:43:41Z",
        "body": "It is a form of _valid_ implicit coercion:\n\n``` javascript\nconst four = 4;\nconst a = +four;\nconst b = +false;\nconst c = +'4';\nconsole.log(a, b, c); // 4, 0, 4\nconsole.log(typeof a, typeof b, typeof c); // number, number, number\n```\n\nSo not in all cases would it be an error.  This sort of thing is usually addressed best by a linter (e.g. `tslint`) instead of \"breaking\" the JavaScript compatibility in TypeScript.\n"
      },
      {
        "user": "ChrisMBarr",
        "created_at": "2016-06-22T13:53:46Z",
        "body": "ah ok, I was not aware of that. I suppose I've only seen it used \"improperly\" then\n"
      }
    ]
  },
  {
    "number": 9302,
    "title": "Typing is clumsy when instancing using class objects derived from an abstract class",
    "created_at": "2016-06-21T20:04:57Z",
    "closed_at": "2016-09-20T22:48:19Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/9302",
    "body": "Suppose you have an abstract class `A` and two concrete clases `B`, `C` derived from `A`, and you want to store `B` and `C` as first-class values to make instances from these values: \n\n``` ts\nabstract class A  { a: any}\nclass B extends A { b: any}\nclass C extends A { c: any}\n\nlet classes  = [B, C]            // inferred type = (typeof B | typeof C)[]\nlet instance = new classes[1]()  // inferred type = (B | C)\ninstance.a                       // ok, because .a is in B and C\n```\n\nIt will be nice if the previous example inferred the `instance` type as `A` instead of `(B | C)`. But it works. \nThe problem comes when TS can't infer the `classes` type, like when using a `Map` instead of an array:\n\n``` ts\nlet classes2 = new Map([[\"b\", B], [\"c\", C]]) // error TS2453: The type argument for type parameter 'V' cannot be inferred from the usage.\nlet classes3 = new Map<string, typeof A>([[\"b\",B], [\"c\", C]])\nlet classes4 = new Map<string, typeof B | typeof C>([[\"b\",B], [\"c\", C]])\n\nvar instance3 = new (classes3.get(\"c\"))()   // TS2511: Cannot create an instance of the abstract class 'A'.\nvar instance4 = new (classes4.get(\"c\"))()   // inferred type = (B | C)\n```\n\n`classes2` doesn't work because TS can't infer the type. \n`classes3` doesn't work because you can't use it for instancing.\n`classes4` example worked but is very clumsy for a large number of classes, you need to type `(typeof B | typeof C | ...)` for all the classes involved. Maybe this is acceptable but I think there is a need to be able of defining (and inferring) a type like \"all concrete classes derived from A\".\n\nBelow is the same example but using a concrete base class. Note in this case you can use `<typeof A>` as the type of the array / map values:\n\n``` ts\nclass A  {a : any}    // now concrete\nclass B extends A { b: any}\nclass C extends A { c: any}\n\nlet classes0 = [B, C]  // inferred type = (typeof B | typeof C)[]\nlet classes1 = <typeof A[]>[B,C]\n\nlet instance1 = new classes0[1]()  // inferred type = (B | C)\ninstance1.a                        // ok, because .a is in B and C\nlet instance2 = new classes1[1]()  // inferred type = A\ninstance2.a                        // ok, because .a is in A\n\nlet classes2 = new Map([[\"b\", B], [\"c\", C]]) // error TS2453: The type argument for type parameter 'V' cannot be inferred from the usage.\nlet classes3 = new Map<string, typeof A>([[\"b\",B], [\"c\", C]])\nlet classes4 = new Map<string, typeof B | typeof C>([[\"b\",B], [\"c\", C]])\n\nvar instance3 = new (classes3.get(\"c\"))()   // inferred type = A\nvar instance4 = new (classes4.get(\"c\"))()   // inferred type = (B | C)\n```\n\n**TypeScript Version:** \n\n1.9.0-dev.20160616-1.0\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/9302/comments",
    "author": "nahuel",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2016-06-21T20:13:35Z",
        "body": "I think what you want is this?\n\n``` ts\nlet classes5 = new Map<string, new() => A>([[\"b\",B], [\"c\", C]]); // OK\n\nvar instance5 = new (classes5.get(\"c\"))(); // OK, instance5: A\n```\n"
      },
      {
        "user": "nahuel",
        "created_at": "2016-06-22T14:27:38Z",
        "body": "@RyanCavanaugh thanks, your example solves this problem! Just a detail, there is a way to reference the `A` constructor signature to avoid repeating it on the `Map` one? I mean:\n\n``` ts\nabstract class A  { a: any\n                    constructor (x: number, y: number) {}}\nclass B extends A { b: any}\nclass C extends A { c: any}\n\nlet classes5 = new Map<string, new(x : number, y : number) => A>([[\"b\",B], [\"c\", C]]); // OK\n     // must repeat args signature ^^^^^^^^^^^^^^^^^^^^^^\nvar instance5 = new (classes5.get(\"c\"))(1,2); // OK, instance5: A\n\n// Is possible to reference the A constructor signature? something like this:\nlet classes6 = new Map<string, typeof A.new>([[\"b\",B], [\"c\", C]]); \n```\n\nThanks for your reply.\n"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2016-06-22T15:45:15Z",
        "body": "Unfortunately there isn't\n"
      },
      {
        "user": "aluanhaddad",
        "created_at": "2016-06-22T19:53:00Z",
        "body": "It's interesting to note that using an object literal might be more typesafe and refactoring friendly than using a `Map`.\n\n``` TypeScript\nabstract class A  { a: any}\nclass B extends A { b: any}\nclass C extends A { c: any}\n\nlet classes  = { B, C };\nlet instance = new classes.B()  // inferred type = B\ninstance.a                       // ok, because .a is in B\n```\n"
      },
      {
        "user": "nahuel",
        "created_at": "2016-06-25T20:28:02Z",
        "body": "@aluanhaddad that works, but not when you use an string based key (eg. one taken from a config file). In your example `var a = 'B' ; classes[a]` will be inferred as `any`.\n"
      },
      {
        "user": "aluanhaddad",
        "created_at": "2016-06-25T21:01:13Z",
        "body": "The keys are strings, I'm simply using concise object literal notation for brevity and in order to leverage refactoring. It's true that if you're using an index signature with a string literal, it becomes more difficult, but I don't see how it is any worse than an array, and at least it makes any necessary casting more intuitive. But you could add an index signature like\n\n``` typescript\n[key: string]: B | C;\n```\n\nor\n\n``` typescript\n[key: string]: new () => A;\n```\n\nThen again that kind of defeats the thing you were trying to achieve in the first place. When the keys are not constants, it's easy to run into this sort of thing.\nWould it be possible for the config file to be a TypeScript file containing exported constants? I found that to be quite useful in certain cases. Also it looks like there will be support for typed JSON Imports at some point in the future.\n"
      },
      {
        "user": "nahuel",
        "created_at": "2016-06-25T21:18:17Z",
        "body": "@aluanhaddad: let me check if I get you, given this:\n\n``` ts\nlet classes1 = new Map<string, new() => A>([[\"B\", B], [\"C\", C]]); \nlet classes2 : {[k : string] : new() => A } = { B, C };\n```\n\n`classes2` is more concise, and his initialization is more refactorizable when you change `B` or `C` names. But there are no other advantages over `classes1` in the later usage when you need to access it using string keys.\n"
      },
      {
        "user": "aluanhaddad",
        "created_at": "2016-06-25T21:45:11Z",
        "body": "Actually, I think this works better,\n(TypeScript 1.9.0-dev.20160624-1.0)\n\n``` TypeScript\nlet classes = { B, C };\n\nlet CPrime = classes[\"C\"]; // CPrime has the same type as C\nlet instance = new C(); // instance is an instance of C\nconsole.log(instance.c);\n```\n\nThe problem is the config file. The constant value does not seem to propagate across module boundaries. Forgot my idea of about using a _.ts_ configuration file. It only seems to work within one file.\n\nI had a thought that you could do \n\n``` TypeScript\nimport { classKey } from \"./config\"; // classKey is defined as \"export const classKey = 'C';\"\nlet CPrime = classes[classKey]; // Unfortunately has type any\n```\n\nEdit: It's not related to modules, it has to do with string literal type inference. Even if I give a variable an explicit string literal type, it does not flow from the variable to the index signature. There are a lot of issues related to this.\n"
      },
      {
        "user": "nahuel",
        "created_at": "2016-06-25T22:37:51Z",
        "body": "@aluanhaddad when I said \"a config file\" I meant an arbitrary JSON document loaded at runtime, not an imported \"config\" module. But yes, I think you are pointing to another valid issue.\n"
      },
      {
        "user": "aluanhaddad",
        "created_at": "2016-06-26T00:14:06Z",
        "body": "@nahuel that probably should have been obvious to me because otherwise they wouldn't have been much of a point to the scenario you described. Sorry if I got the issue off track. I don't see how TypeScript could provide this however, without compile time constants. A run-time scenario like you mention, where the type is decided based on dynamically imported configuration is going to have to do type assertions. There is an issue tracking type providers which may be closer to what you're looking for #3136\n"
      }
    ]
  },
  {
    "number": 9262,
    "title": "About design patterns(typescript)",
    "created_at": "2016-06-20T04:15:27Z",
    "closed_at": "2016-06-20T06:44:09Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/9262",
    "body": "Scene:\n**init.js**\n\n```\n//because connectionPool should singleton,so i save it in nodejs global.\nif(!global.connectionPool) global.connectionPool=createPool();\n```\n\n**module(A...X).js**(multiple)\n\n```\nreruire(./init.js);\nglobal.connectionPool.execSQL('select * from tableA');\n```\n\nIf use java,i could define 'abstract parent class' then initial 'connectionPool' in constructor,the next all module(A...X) extend 'abstract parent class',but in typescript.what Is Best Practice?\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/9262/comments",
    "author": "keyiis",
    "comments": [
      {
        "user": "kitsonk",
        "created_at": "2016-06-20T06:36:25Z",
        "body": "StockOverflow, Gitter or IRC are better places to discuss best practices and design questions...\n"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2016-06-20T06:44:09Z",
        "body": "Agreed with @kitsonk - though you should be able to do something similar with abstract classes in TypeScript anyhow.\n"
      }
    ]
  },
  {
    "number": 9247,
    "title": "Cannot set property 'xyz' of undefined",
    "created_at": "2016-06-18T11:38:15Z",
    "closed_at": "2016-06-18T18:13:46Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/9247",
    "body": "It would seem like this is a (common?) bug that the compiler could catch for us.\n\nGiven this example class:\n\n``` javascript\nclass Foo {\n    bar: number;\n}\nlet a: Foo;\na.bar = 1;\n```\n\nAt runtime I will get an error 'Cannot set property 'bar' of undefined because I never actually initialized the object. (i.e. `let a: Foo = new Foo();` or `let a = new Foo();`)\nThis seems to me like it could probably be a pretty common developer mistake given the ability to provide types (: Foo), especially since editors will give you full Intellisense on the object just by naming the type of it without initialization.  I'm curious if it's something that the Compiler could catch?  (variable a is undefined; declared, but never initialized)\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/9247/comments",
    "author": "benjaminmillhouse",
    "comments": [
      {
        "user": "yortus",
        "created_at": "2016-06-18T13:25:50Z",
        "body": "If you use the `--strictNullChecks` compiler option, you'll get a compiler error stating `Variable 'a' is used before being assigned`. Is that what you are after?\n"
      },
      {
        "user": "benjaminmillhouse",
        "created_at": "2016-06-18T17:57:14Z",
        "body": "That probably would do it. Sorry, didn't see that in the tsconfig options. I'll give it a try. \n"
      },
      {
        "user": "yortus",
        "created_at": "2016-06-18T20:47:14Z",
        "body": "@benmillhouse it's only in the nightly version, so might not be documented yet. See #7140. \n"
      }
    ]
  },
  {
    "number": 9243,
    "title": "a class cannot extend events node module",
    "created_at": "2016-06-18T06:11:48Z",
    "closed_at": "2016-06-18T18:17:01Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/9243",
    "body": "**TypeScript Version:** \n\n1.8.10\n\n**Code**\n\n``` ts\n/// <reference path=\"./../../../typings/index.d.ts\" />\nimport {EventEmitter} from \"events\";\nclass _req extends EventEmitter {\n    constructor() {\n        super();\n    }\n    emit() {\n        super.emit(\"test\")\n    }\n}\nconst a = new _req();\na.on(\"test\", _ => {\n    console.log(\"test was called\");\n})\na.emit();\n```\n\n**Expected behavior:**\ncompile with no errors \n**Actual behavior:** \ni got the error telling me \n\n```\nts/core/request/index.ts(3,7): error TS2415: Class '_req' incorrectly extends base class 'EventEmitter'.\n  Types of property 'emit' are incompatible.\n    Type '() => void' is not assignable to type '(event: string, ...args: any[]) => boolean'.\n      Type 'void' is not assignable to type 'boolean'.\n```\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/9243/comments",
    "author": "ta3pks",
    "comments": [
      {
        "user": "kitsonk",
        "created_at": "2016-06-18T06:56:05Z",
        "body": "This isn't an issue with TypeScript.  This is basic stuff.  You should read the error and fix it.\n\nThe method you are extending does not match the contract of the underlying class.  As the error says, your extended `emit` is of type `() => void`, but the method you are extending is of type `(event: string, ...args: any[]) => boolean` and the need to be compatible, so at the very least `emit` need to return a boolean value.\n\nFor basic questions like these, StackOverflow, Gitter or IRC are better places to ask.\n"
      },
      {
        "user": "ta3pks",
        "created_at": "2016-06-18T18:17:01Z",
        "body": "ah now it makes sense i am sorry for opening this i just didnt pay attention to my own emit method \n"
      }
    ]
  },
  {
    "number": 9227,
    "title": "unexpected TS2342",
    "created_at": "2016-06-17T12:29:29Z",
    "closed_at": "2016-06-17T16:32:53Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/9227",
    "body": "i have 3 static function\n\n``` ts\nUtil.isString(value:any):boolean{\nreturn typeof value === 'string'\n}\n\nUtil.isFunction(value:any):boolean{\nreturn typeof value === 'function'\n}\n\nUtil.noop():void{}\n```\n\nThan\n\n``` ts\nfoo(fn:Function|string, context:Object){\n    fn = Utils.isFunction(fn) ? fn : (Util.isString(fn) && Util.isFunction(context[fn]) ? context[fn] : Util.noop);\n    fn.apply(this);\n}\n```\n\nThis produce an unexpected TS2342 An index expression argument must be of type 'string', 'number', 'symbol', or 'any'\nBut Util.isString(fn) ====> typeof fn === 'string'\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/9227/comments",
    "author": "lucap86",
    "comments": [
      {
        "user": "yortus",
        "created_at": "2016-06-17T12:53:17Z",
        "body": "Try annotating your `isString` and `isFunction` return types as follows:\n\n``` ts\nfunction isString(value:any): value is string {\n    return typeof value === 'string'\n}\n\nfunction isFunction(value:any): value is Function {\n    return typeof value === 'function'\n}\n```\n\nThen the `TS2342` error should go away.\n\nType guard functions need these special `x is Type` return type annotations for the compiler to recognise them as type guards and use them to narrow types. They still return a boolean value of course.\n"
      }
    ]
  },
  {
    "number": 9211,
    "title": "Type inference bug with Union Types",
    "created_at": "2016-06-16T09:01:02Z",
    "closed_at": "2016-06-16T23:27:38Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/9211",
    "body": "**TypeScript Version:** \n\n1.8.10\n\n**Code**\n\n``` ts\nclass Item1Stuff {}\ninterface Item1 {\n    stuff: Item1Stuff;\n}\n\nclass Item2Stuff {}\ninterface Item2 {\n    stuff: Item2Stuff;\n}\n\ntype Item = Item1 | Item2;\n\nfunction handler(item: Item) {\n    return item.stuff;\n}\n```\n\n**Expected behavior:**\nThe inferred return type of the `handler` function should be `Item1Stuff | Item2Stuff` no matter how they're implemented since they are completely unrelated classes.\n\n**Actual behavior:** \nThe return type is inferred to be `Item1Stuff`. This only changes if `Item1Stuff` implements any property/method (doesn't need to be public) that does not exist in `Item2Stuff` or only exists with another signature.\n\nNote that this only works this way around -- if `Item2Stuff` implements something not contained in `Item1Stuff` it doesn't change anything.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/9211/comments",
    "author": "loilo",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2016-06-16T18:54:09Z",
        "body": "TS has a structural type system. `Item1Stuff` and `Item2Stuff` are identical types from a structural view point. \n\nThere is a sub-type reduction process that happens when looking up union type members. the result is picking the type which is more general.\n\nif the two types are disjoint, then both will be in the result. if they are not, the one that is a super type of the other will be picked.\n"
      },
      {
        "user": "loilo",
        "created_at": "2016-06-16T19:23:04Z",
        "body": "Oh okay. Didn't know that structural system thing. Thanks for the information. :)\n"
      },
      {
        "user": "zbjornson",
        "created_at": "2016-07-13T02:50:16Z",
        "body": "This seems like wrong behavior regardless of the type system. At the very least it's confusing to see the wrong return type. In @Loilo's example, given the call `handler(myItem2)`, TS will report that it has returned an instance of `Item1Stuff`, which is incorrect; only the instance members are the same.\n\nAnother example:\n\n``` ts\nfunction doStuff(input: Float32ArrayConstructor|Float64ArrayConstructor) {\n    return new input(2);\n} // inferred output type is \"Float32Array\"\ndoStuff(Float64Array) // claims this is a Float32Array\n```\n\nWe can override the inferred return type with the same union type as the params, but then the result of `doStuff` remains a union type as well.\n"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2016-07-13T03:04:41Z",
        "body": "It's just :turtle: s all the way down in that example, though, because `Float32Array` and `Float64Array` are _also_ identical, so there's no reason (from a type system perspective) to prefer one of them over the other. The real fix is that `Float32Array` and `Float64Array` should be made different by some means or another and there are already a bunch of issues discussing how to make that happen.\n"
      },
      {
        "user": "zbjornson",
        "created_at": "2016-07-13T03:08:04Z",
        "body": "Haha :)\n\nLooks like you're referring to #5388. Thanks for pointing that out.\n"
      }
    ]
  },
  {
    "number": 9203,
    "title": "Typecheck bug?",
    "created_at": "2016-06-16T00:28:55Z",
    "closed_at": "2016-09-20T22:45:40Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/9203",
    "body": "**TypeScript Version:** \n\n1.9.0-dev.20160615-1.0\n\n**Code**\n\n``` ts\n// A self-contained demonstration of the problem follows...\nexport class SortedMap extends Map<string, ASTNode | ASTNode[]> {\n\n  set(key: string, value?: ASTNode | ASTNode[]): Map<string, ASTNode | ASTNode[]> {\n    return super.set(key, value);\n  }\n}\n```\n\n**Expected behavior:**\nNot sure, but no error?\n\n**Actual behavior:** \n\n```\nError:(3, 14) TS2415: Class 'SortedMap' incorrectly extends base class 'Map<string, ASTNode | ASTNode[]>'.\n Types of property 'set' are incompatible.\n Type '(key: string, value?: ASTNode | ASTNode[]) => Map<string, ASTNode | ASTNode[]>' is not assignable to type '(key: string, value?: ASTNode | ASTNode[]) => this'.\n Type 'Map<string, ASTNode | ASTNode[]>' is not assignable to type 'this'.\n```\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/9203/comments",
    "author": "bartosz-k",
    "comments": [
      {
        "user": "Arnavion",
        "created_at": "2016-06-16T00:52:59Z",
        "body": "Simpler repro:\n\n``` typescript\ndeclare class Base {\n    foo(): this;\n}\n\nclass Derived extends Base {\n    foo() {\n        return super.foo();\n    }\n}\n```\n\n`super.foo()` is inferred as returning `Base` instead of `this`.\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2016-06-16T00:57:06Z",
        "body": "@Arnavion this works for me on latest.\n\nthe probelm in the orginal example is the type annotation.\n\n``` ts\n set(...): Map<string, ASTNode | ASTNode[]>\n```\n\nis a lesser a contract  than:\n\n``` ts\n set(...): this\n```\n\nthe first always returns a `Map`, the second returns a Map or any decedent class it was invoked on.\n\nso to fix this, define your class as:\n\n``` ts\nexport class SortedMap extends Map<string, ASTNode | ASTNode[]> {\n  set(key: string, value?: ASTNode | ASTNode[]) : this {\n    return super.set(key, value);\n  }\n}\n```\n\nor just\n\n``` ts\nexport class SortedMap extends Map<string, ASTNode | ASTNode[]> {\n  set(key: string, value?: ASTNode | ASTNode[]) {\n    return super.set(key, value);\n  }\n}\n```\n"
      },
      {
        "user": "Arnavion",
        "created_at": "2016-06-16T00:57:35Z",
        "body": "Oh yes, my bad.\n"
      }
    ]
  },
  {
    "number": 9137,
    "title": "Allow to discard code when generating code.",
    "created_at": "2016-06-13T18:15:15Z",
    "closed_at": "2016-06-13T18:48:43Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/9137",
    "body": "I have JavaScript library , where I have multiple inheritance done with my own functions to extend.\n\nBut for intellisense purpose we have add some interface to allow lookup for function withing the classes and implemented dummy functions for completeness. But when generating the code, I would like to take that out.\n\nCan we added that feature take out some code when generating JS code.\nJust one switch let us say, #NOT_A_CODE #END_NOT_A_CODE ... and ignore the code in between.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/9137/comments",
    "author": "mubbasher16",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2016-06-13T18:22:41Z",
        "body": "Interfaces don't generate code; if you need to have a class that doesn't generate code, you can use the `declare` keyword to create an ambient class. There shouldn't be anything you need to do for intellisense / type information purposes that requires a construct that generates code.\n"
      },
      {
        "user": "mubbasher16",
        "created_at": "2016-06-13T19:10:31Z",
        "body": "It's not ambient class.\nit is actual class.  I get this error.\n[ts] 'declare' modifier cannot appear on a class element.\n\nSome stuff needs to be added to the class for intellisense. But It would be only added at runtime.\nby some other JS library say for instance.\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2016-06-13T19:43:05Z",
        "body": "not the class member, the whole class.\n\n``` ts\ndeclare class C {\n    property: number;\n    method(a: string): C;    \n}\n\n\nvar x = new C();\nx.method(\"string\");\n```\n"
      },
      {
        "user": "mubbasher16",
        "created_at": "2016-06-13T22:17:33Z",
        "body": "Got it that would work in fact.\n\nBut if someone ends up in a situation like me...\n\nI just created a small quick code in C# to post process my final javascript and remove the code between the comments, //##NOT_A_CODE //##END_NOT_A_CODE.\nMy situation is slightly different.\n\nAnd if someone interested in how to do multiple inheritance using JavaScript or even using the TypeScript which apparently doesn't support it ... give me a ping. :) as I did achieved :+1: \n"
      }
    ]
  },
  {
    "number": 9114,
    "title": "Sourcemap debugging in Safari",
    "created_at": "2016-06-13T06:04:56Z",
    "closed_at": "2016-06-13T21:21:16Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/9114",
    "body": "TypeScript Version: 1.8.0\n\n**Expected behavior:**\n\nWhen debugging my application (Angular2) I'm able to see the source map and debug the TypeScript files only in Google Chrome. However, I'm unable to debug the TypeScript files in Safari(Version 9.1.1 Mac OS).\n\nIs it possible to debug the original TypeScript files in Safari? I need this to debug my iOS Cordova  apps  only from Safari, and I couldn't find an answer on the Web.\n\nActual behaivour:\n\nI can only see the bundled javascript files - not the TypeScript files.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/9114/comments",
    "author": "galsch",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2016-06-13T19:54:46Z",
        "body": "If the source maps work in Chrome then presumably they were generated correctly. What points to this being a TypeScript issue rather than a Safari issue?\n"
      },
      {
        "user": "justme1",
        "created_at": "2016-06-13T20:15:05Z",
        "body": "Hi Ryan,\n\nI'm not suggesting this is TypeScript issue; I'm intersted to know if there is support for this in Safari.\nI'm assuming this is basic feature that is used by anyone who has to debug their apps on Safari(e.g. iOS apps).\n"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2016-06-13T21:21:16Z",
        "body": "Please only log TypeScript issues on the TypeScript issue tracker. This isn't a general discussion forum.\n"
      }
    ]
  },
  {
    "number": 9106,
    "title": "can i use import module in nodejs ,and avoid reltive path",
    "created_at": "2016-06-12T15:58:55Z",
    "closed_at": "2016-06-13T20:10:59Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/9106",
    "body": "I don't wan't import a module write a lot reltive path such as \n\n`\nimport {myFunction} from '../../../../../myModule'; \n`\n\nis any solution?\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/9106/comments",
    "author": "lcultx",
    "comments": [
      {
        "user": "aluanhaddad",
        "created_at": "2016-06-13T02:58:39Z",
        "body": "Try importing it relative to the root directory of your application. You shouldn't need that many `../`s unless the desired module is actually located 4 levels above your app folder. If that's the case, you may want to create a local package.json, restructure your app, or maybe even use npm link.\n\nGenerally I find myself rarely writing parent relative imports, and when I do they're usually just one level up. \n\nThat said, I mainly right client-side TypeScript, but that kind of import pattern may indicate an overall structuring inneficiency. \n\nOn the other hand if it's a helper library that you use all over the place, consider installing or locating it at the top level of your application directory and then simply importing it directly.\n\nAlso consider using the re-export pattern.\n"
      }
    ]
  },
  {
    "number": 8940,
    "title": "Why \"Use undefined, do not use null.\"?",
    "created_at": "2016-06-02T12:47:00Z",
    "closed_at": "2016-06-02T16:22:55Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/8940",
    "body": "Can someone explain this prescription?\n\nUndefined is a type, used heavily by the JS engine, while null is a value that only the developer can control. I would rather go for null than undefined, because I'm managing it.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/8940/comments",
    "author": "lnaie",
    "comments": [
      {
        "user": "kitsonk",
        "created_at": "2016-06-02T13:09:08Z",
        "body": "That guide is for those developing the TypeScript compiler, not a general statement about using `null` with TypeScript.  Projects should adopt usage rules around usage of `undefined` and `null` and be consistent in their usage.\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2016-06-02T16:22:53Z",
        "body": "the rational is JavaScript has two concepts to refer to the empty sentinel value, most other programming languages just have one. Moreover, `undefined` is always present, as all uninitialized values have the value `undefined` at run time. `null` on the other hand is avoidable, specially if you are not using any APIs that produce it, e.g. DOM, which the TypeScript compiler does not use.\n"
      }
    ]
  },
  {
    "number": 8891,
    "title": "Question: Disallow toString / cast to String",
    "created_at": "2016-05-31T08:06:59Z",
    "closed_at": "2016-05-31T15:21:12Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/8891",
    "body": "Hi,\n\nI like to disallow (=compiler error) the toString / cast to string for a object. Is this possible? \n\n**TypeScript Version:** \n\n1.8\n\n**Code**\n\nI have the following class:\n\n``` ts\nclass Person\n{\n   private toString(): string {\n            return \"not allowed\";\n    }\n}\nvar person1 = new Person();\n\n```\n\nThis is now disallowed\n\n``` ts\nperson1.toString();\n```\n\nBut can I also disallow this?\n\n``` ts\nvar text = person1 + \"\";\n```\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/8891/comments",
    "author": "304NotModified",
    "comments": [
      {
        "user": "basarat",
        "created_at": "2016-05-31T08:29:20Z",
        "body": "> Is this possible\n\nJust quick info : Not at the moment :rose: \n"
      },
      {
        "user": "kitsonk",
        "created_at": "2016-05-31T09:22:27Z",
        "body": "You could throw in the `toString()` method if you are really that desperate to keep people from using implicit coercion on your instances.\n"
      },
      {
        "user": "304NotModified",
        "created_at": "2016-05-31T15:21:12Z",
        "body": "> You could throw in the toString() method if you are really that desperate to keep people from using implicit coercion on your instances.\n\nYes, we're doing it now, but I was hoping for a better solution. \n\nThanks for the replies! \n"
      }
    ]
  },
  {
    "number": 8890,
    "title": "Unable to run Array.map on an Array",
    "created_at": "2016-05-31T07:45:40Z",
    "closed_at": "2016-05-31T09:48:34Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/8890",
    "body": "**TypeScript Version:** \n\n1.8\n\n**Code**\n\n``` ts\nfunction getARPTable() {\n    return new Promise((resolve, reject) => {\n        arp.table((error, devices) => {\n            if (error) reject(error);\n            else resolve(devices);\n        });\n    });\n}\n\nasync function scanPorts() {\n    let devices = await getARPTable();\n    console.log(Array.isArray(devices)); // true\n    devices = devices.map((device) => device); // error\n                      ^\n    return true;\n}\n\nscanPorts();\n```\n\n**Expected behavior:**\n\nNo error output\n\n**Actual behavior:** \n\n`error TS2339: Property 'map' does not exist on type '{}'.`\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/8890/comments",
    "author": "xeoneux",
    "comments": [
      {
        "user": "kitsonk",
        "created_at": "2016-05-31T09:31:33Z",
        "body": "TypeScript cannot contextually determine what the `Promise` resolves to (see: #5254) therefore you have to assert it.\n\nSomething like:\n\n``` typescript\nfunction getARPTable() {\n    return new Promise<any[]>((resolve, reject) => {\n        arp.table((error, devices) => {\n            if (error) reject(error);\n            else resolve(devices);\n        });\n    });\n}\n```\n"
      },
      {
        "user": "xeoneux",
        "created_at": "2016-05-31T09:37:51Z",
        "body": "@kitsonk Thanks! I created a similar interface to fix it. However, I am still not sure why does the error occur even after successful compilation to JavaScript and running under node?\n"
      },
      {
        "user": "kitsonk",
        "created_at": "2016-05-31T09:44:02Z",
        "body": "Because, instead of inferring type `any` for the `Promise` resolution, TypeScript infers `{}` which is an object with no properties, therefore doesn't have a `.map` method.  IIRC there was a lot of discussion in the ticket I linked to as to why `{}` instead of `any` makes sense when filling a generic that cannot be contextually determined.  By default, TypeScript will still emit the code, even if it has errors.  So while the run-time behaviour works, TypeScript couldn't be sure it would be when it emitted the code.\n"
      },
      {
        "user": "xeoneux",
        "created_at": "2016-05-31T09:48:34Z",
        "body": "@kitsonk I didn't realise that the error was during compilation and not during runtime. Thanks for the clarification! 😄 \n"
      }
    ]
  },
  {
    "number": 8867,
    "title": "Bad inference when using void and &&",
    "created_at": "2016-05-27T22:02:23Z",
    "closed_at": "2016-06-07T21:48:11Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/8867",
    "body": "``` javascript\nconst a: void = undefined;\nconst b: number = 33;\n\nconst z = a && b;\n```\n\nz is always inferred to be of the same type as b, even though a is undefined.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/8867/comments",
    "author": "AlexGalays",
    "comments": [
      {
        "user": "Arnavion",
        "created_at": "2016-05-29T19:00:27Z",
        "body": "Without `--strictNullChecks` there is nothing wrong. `&&` is allowed when the left expression is of type `void` to maintain compatibility with JS, and `undefined` is a valid value for `number`.\n\nWith `--strictNullChecks` it should probably be inferred as `number | undefined | null`, but it's still inferred as `number`. That looks like a bug.\n"
      },
      {
        "user": "Arnavion",
        "created_at": "2016-06-07T23:08:37Z",
        "body": "For future reference, the bug I noted above doesn't happen if `a` is of type `undefined` instead of `void`. I imagine it's probably best to never use `void` as a holder for `undefined` values to reap the benefits of `--strictNullChecks`\n"
      },
      {
        "user": "AlexGalays",
        "created_at": "2016-06-08T06:31:10Z",
        "body": "Not sure what you mean, undefined is not a type?  Are you saying void should never be used at all in type annotations and we should just rely on type inference?\n\nAnyway, I'm not sure why this got closed without much explanation :(\n"
      },
      {
        "user": "kitsonk",
        "created_at": "2016-06-08T06:52:06Z",
        "body": "I think @Arnavion assumed TypeScript@next usage (as you didn't specify a version of TypeScript in the issue, though the issue template requests one).  In TypeScript 2.0, `undefined` and `null` are types that are removed from all other types (except `any`) and can be dealt with better.\n\nSo, if you feel like you need to be neurotic in your type annotations:\n\n``` typescript\nconst a: undefined = undefined;\n```\n\nIs a better way of representing `undefined`, but of course it being a `const`, therefore disallowing reassignment, the type annotation it entirely superfluous.\n\nTypeScript 2.0 introduces the compiler flag `--strictNullChecks` and @Arnavion noted that with `--strictNullChecks` the `void` type appears to not be handled properly, which he states is likely a bug, though I think @mhegazy might have not have noticed that, trying to quickly triage the name issues that are opened here.  On the other hand, the new types of `undefined` and `null` are handled properly, so it might not be a bug.\n\nIn 1.8, there is no `undefined` type, but the compiler is still working correctly, since `number` could be expressed as `number | undefined | null` in TypeScript 2.0 terms as all types are inclusive of those values, because JavaScript is a crazy language.  There is no concept of a hard \"bottom\" type in TypeScript 1.8.  `void` is only used to imply that no value is likely to be returned from an operation, but upon assignment, it doesn't \"hold\".\n\nSo in summary, there is an improvement of this in TypeScript 2.0 that lets you better model this, but technically TypeScript 1.8 isn't broken either.\n"
      },
      {
        "user": "AlexGalays",
        "created_at": "2016-09-01T15:15:38Z",
        "body": "I'm now happily using TS 2.0 and use the undefined type whenever it applies, however I still struggle to see what's the difference between undefined and void. Is that documented somewhere ?\n"
      },
      {
        "user": "kitsonk",
        "created_at": "2016-09-01T15:45:50Z",
        "body": "Like Cher, I suspect that if the TypeScript team could rollback time, `void` would not exist and `undefined` and `null` would have been distinct types from the start.\n\n`void` is intended to denote a return from a function where from an interface perspective, no one should depend upon any return.  It wasn't really a type, in the way `undefined` is.  Because of the significant breaking change of `strictNullChecks` this was introduced under a flag to avoid breaking all the stuff people already had (and make transition from JavaScript to TypeScript easy and potentially incremental).\n\nI am not sure it documented anywhere specifically yet.\n"
      }
    ]
  },
  {
    "number": 8747,
    "title": "Async/await wont work properly with nodejs",
    "created_at": "2016-05-23T07:54:21Z",
    "closed_at": "2016-06-07T22:08:43Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/8747",
    "body": "**TypeScript Version:** \n\n1.8.10\n\n**Code**\n\n``` ts\n// A self-contained demonstration of the problem follows...\nasync function dbsave(connect: Promise<Db>, col: string, where: string, obj: update): Promise<void> {\n    const db = await connect;\n    const coll = db.collection(col);\n    const total = db.collection(\"total\");\n    const date: Date = new Date();\n    total.update({ date: new Date(date.getFullYear(), date.getMonth(), date.getDate()) },\n        {\n            $inc: {\n                count: 1\n            }\n        }, {\n            upsert: true\n        });\n    /*\n    **experimental\n    */\n    coll.update({}, {\n        $pull: {\n            pages: {\n                date: {\n                    $lte: new Date(date.getTime() - (1000 * 60 * 60 * 24))\n                }\n            }\n        }\n    }, {\n            multi: true\n        });\n    /*\n    ***experimental\n    */\n    console.log(await coll.update({ _id: where }, obj, { upsert: true }));\n    return db.close();\n}\n\n```\n\nand at the bottom of page i call the function \n\n``` ts\ndbsave(mongodb.connect(options.db), options.collection, addr, doc)\n        .catch(e => {\n            console.error(e);\n        })\n```\n\ni have no error during compilation . And after compilation the program is actually running but after first await program newer re-enters the function. and as expected no db operation is done.\n**Expected behavior:**\nupdate db and log the object returned from db operation\n**Actual behavior:** \nnothing happens res.end() method works but the save db function wont work and no error or log .\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/8747/comments",
    "author": "ta3pks",
    "comments": [
      {
        "user": "yortus",
        "created_at": "2016-05-23T13:12:42Z",
        "body": "Are those `.update(...)` method calls returning promises? If so you need to `await` them too. They may be throwing an error, which you'll not see at all with the above code because they are neither `await`ed nor have any catch handers attached to them.\n"
      },
      {
        "user": "aluanhaddad",
        "created_at": "2016-05-23T18:56:58Z",
        "body": "@NikosEfthias I think @yortus is right. In one place you await coll.update and in another you do not. You can await something that isn't a promise but this looks suspect.\n"
      },
      {
        "user": "ta3pks",
        "created_at": "2016-05-23T19:02:41Z",
        "body": "i figured the issue out @aluanhaddad  @yortus  when the async function definition is in the scope of its caller  it works but when its defined in global it wont enter back but still it makes no sense to me i guess its something to do with yield in es6\n"
      }
    ]
  },
  {
    "number": 8695,
    "title": "CommonJS vs UMD vs moduleResolution..",
    "created_at": "2016-05-19T18:30:26Z",
    "closed_at": "2016-05-21T00:15:18Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/8695",
    "body": "```\n    \"module\": \"commonjs\",\n    \"target\": \"es5\"\n```\n\nor\n\n```\n    \"module\": \"umd\",\n    \"target\": \"es5\",\n    \"moduleResolution\": \"node\"\n```\n\nWorks perfectly to resolve my `/node_modules/typscript-dotnet` library.\nBut ...\n\n```\n    \"module\": \"umd\",\n    \"target\": \"es5\",\n```\n\nDoes not... :(  (TS2307 for everything including relative references) Can someone explain why?  I'm fine with using commonjs as a module type for subsequent projects.  Just curious why this is.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/8695/comments",
    "author": "electricessence",
    "comments": [
      {
        "user": "vladima",
        "created_at": "2016-05-20T20:39:40Z",
        "body": "by default if value of `moduleResolution` is not specified we use `node` module resolution if module is `commonjs` and `classic` otherwise. `classic` module resolution does not look into `node_modules` folder\n"
      }
    ]
  },
  {
    "number": 8671,
    "title": "tsconfig chaining",
    "created_at": "2016-05-18T18:40:59Z",
    "closed_at": "2016-05-18T22:11:41Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/8671",
    "body": "Hi,\n\nI was looking for ability to chain tsconfig files in different sources but couldn't find any. Also in the compiler option part of handbook there is a `--project` aka `-p` option that is not included to the tsconfig schema.\n\nIt will be great to add this property to the schema as an array of source directories that each has their own tsconfig files and chaining them up. This can potentially lead to a directory structure that deprecates `files` property and will come in handy in big code bases.\n\nCheers\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/8671/comments",
    "author": "khooz",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2016-05-18T22:11:41Z",
        "body": "tsconfig.json is just a way to pass configurations to the compiler instead of passing them on the command line. A single tsconfig.json represents a single invocation to the compiler (i.e. one call to tsc.exe or tsc.js).\n\nFor dependency checking, and building multiple projects, please use a build orchestration tool like gulp, grunt, MSBuild, Broccoli etc...\n\nthe `--project` is what you pass to `tsc` to tell it to use a specific `tsconfig.json`. if none was passed the compiler tries to find one automatically by looking for one in any enclosing directory starting by the current directory. \n\nThus the property does not make much sense in the tsconfig.json itself, as its importance is to locate the file.\n"
      }
    ]
  },
  {
    "number": 8642,
    "title": "Using interface of an enumeration and module merged type as generics type parameter",
    "created_at": "2016-05-17T09:45:41Z",
    "closed_at": "2016-05-18T09:31:49Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/8642",
    "body": "I found a strange behaviour of enumeration and module merging when using generics. Take a look at the following example:\n\n``` typescript\ninterface IEnumerationType {\n     getNames(): string[];\n}\n\nenum RoleType {\n    ApplicationRole,\n    CompanyRole,\n}\n\nmodule RoleType {\n    export function getNames(): string[] {\n        return [\"ApplicationRole\", \"CompanyRole\"];\n    }\n}\n\nvar r : IEnumerationType = RoleType;\n```\n\nIt compiles without error. The RoleType implements the IEnumerationType, it has a getNames method because of the enum+module merging.\n\nIf I want to use IEnumerationType and RoleType as a generic type parameter, it fails:\n\n``` typescript\ninterface MyInterface<TEnumeration extends IEnumerationType> {\n    enumerationType: TEnumeration;\n}\n\nvar x : MyInterface<RoleType>; // error, why? RoleType implements IEnumerationType\n```\n\nIs this a bug or is it a documented behaviour?\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/8642/comments",
    "author": "laszlojakab",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2016-05-17T19:18:14Z",
        "body": "The type name `RoleType` refers to a value of the enum type. Remember that you would normally write:\n\n``` ts\nlet x: RoleType = RoleType.CompanyRole;\n```\n\nThe type `RoleType` doesn't implement `IEnumerationType` because it's just a specialized subtype of `number`.\n\nThe type of the value `RoleType` itself is actually anonymous; you can refer to it using the `typeof` operator:\n\n``` ts\nvar x : MyInterface<typeof RoleType>; // OK\n```\n"
      },
      {
        "user": "laszlojakab",
        "created_at": "2016-05-18T09:31:49Z",
        "body": "Thanks for the help I could solve the problem. \n"
      }
    ]
  },
  {
    "number": 8498,
    "title": "interface optional methods not showing ",
    "created_at": "2016-05-06T12:25:37Z",
    "closed_at": "2016-05-09T08:37:15Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/8498",
    "body": "**TypeScript Version:** \n\n1.8.30\n\n**Code**\n\n``` ts\ninterface ITest {\n  init?();\n}\n\nclass Test implements ITest {\n  print() {\n    if (typeof this.init == \"function\")\n      this.init();\n  }\n}\n\nclass MyOwnTest extends Test {\n  init() {\n    // boo!  \n  }\n}\n```\n\n**Expected behavior:**\ncompiles without error\n\n**Actual behavior:** \nProperty 'init' does not exist in 'Test'\n\nWhy such construction? \nI would like to provide optional implementation of `init` in user derived type, and check in base class if it was really implemented.\n\ntoday I have to use `this[\"init\"]` - which is not strong type.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/8498/comments",
    "author": "pankleks",
    "comments": [
      {
        "user": "malibuzios",
        "created_at": "2016-05-06T12:58:21Z",
        "body": "_(tested on `1.9.0-dev.20160506`)_\n\nI believe it is possible to work around this by declaring an uninitialized property having a a function type in the base class:\n\n``` ts\ninterface ITest {\n    init?(): void;\n}\n\nclass Test implements ITest {\n    init: () => void; // when strict null checking is enabled,\n                      // '() => void | undefined' is possible here as well\n\n    print() {\n        if (typeof this.init == \"function\")\n            this.init();\n    }\n}\n\nclass MyOwnTest extends Test {\n    init = () => {\n        // boo!  \n    }\n}\n```\n"
      },
      {
        "user": "pankleks",
        "created_at": "2016-05-06T13:17:27Z",
        "body": "You right - thanks!\n\nHowever for me it's workaround only as in derived class you MUST use arrow function to define method - can't use \"regular\" method syntax anymore.\n\nSo still, IMO my original syntax should be possible.\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2016-05-06T16:40:59Z",
        "body": "you can use a class/interface pair to define optional properties on a class, so \n\n``` ts\ninterface Test {\n    init?();\n}\n\nclass Test {\n    print() {\n        if (typeof this.init == \"function\")\n            this.init();  // OK\n    }\n}\n```\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2016-05-06T16:42:33Z",
        "body": "the other option is to use abstract classes/methods. not sure if this fits your requirements though,\n"
      },
      {
        "user": "pankleks",
        "created_at": "2016-05-09T08:37:14Z",
        "body": "Not obvious but works. \nThanks - closing item.\n"
      }
    ]
  },
  {
    "number": 8475,
    "title": "is there a way to declare an interface with a method returning an anonymous class?",
    "created_at": "2016-05-05T16:37:36Z",
    "closed_at": "2016-05-05T17:31:17Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/8475",
    "body": "``` typescript\nfunction toClass() {\n    return class {}\n}\n\ninterface I {\n    toClass: () => { /* what goes here? */ }\n}\n\nconst i : I = {\n    toClass: toClass\n};\n\n// need the following to work:\nclass MyClass extends i.toClass() {\n\n}\n```\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/8475/comments",
    "author": "zpdDG4gta8XKpMCd",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2016-05-05T16:44:25Z",
        "body": "there is not a way to keep the class construct, but you should be able to declare it as a consttructor and instance type pair:\n\n``` ts\ninterface Base {\n ....\n}\n\ninterface I {\n    toClass: () => { new (...args: any[]) : Base }\n}\n```\n"
      },
      {
        "user": "zpdDG4gta8XKpMCd",
        "created_at": "2016-05-05T17:31:20Z",
        "body": "thanks\n"
      }
    ]
  },
  {
    "number": 8330,
    "title": "Typechecking for non-intrinsic elements in TSX",
    "created_at": "2016-04-27T09:52:32Z",
    "closed_at": "2016-04-27T21:19:20Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/8330",
    "body": "I'm using TSX without React. I'm just wondering how do I get type checking for a non-intrinsic element?\n\n``` ts\n<ScrollableContent class='CommentsListContainer' type='vertical' maxHeight={300}/>\n```\n\nthe attributes `class`, `type` and `maxHeight` is of type any. I have tried numerous ways to get type checking, but failed. I have also looked at `react.d.ts` to try to get the solution, but also failed.\n\nThe `ScrollableContent` class is an extension of a generic class:\n\n``` ts\ninterface Props {\n    class: string;\n    maxLength: number;\n    type: 'vertical' | 'horizontal';\n}\n\nexport class ScrollableContent extends Component<Props> {\n```\n\nAnd I guess just the right interfaces need to be defined in the JSX namespace in order for everything to kick in?\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/8330/comments",
    "author": "tinganho",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2016-04-27T16:38:44Z",
        "body": "#3203 outlines how this works\n"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2016-04-27T16:39:28Z",
        "body": "#5478 as well\n"
      },
      {
        "user": "tinganho",
        "created_at": "2016-04-28T06:39:54Z",
        "body": "Thanks!\n"
      }
    ]
  },
  {
    "number": 8260,
    "title": "Can't minus two Date object",
    "created_at": "2016-04-23T06:31:58Z",
    "closed_at": "2016-04-23T10:21:50Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/8260",
    "body": "**TypeScript Version:** \n\n1.8.9\n\n**Code**\n\n``` ts\n\"use strict\";\n\nlet start = new Date()\nlet end = new Date()\nconsole.log(start - end)\n```\n\n**Expected behavior:**\nprint the difference between two date\n**Actual behavior:** \ndon't compile when compile option  `noEmitOnError` is enabled. \nHere is the error message:\n\n``` bash\napp.ts(5,13): error TS2362: The left-hand side of an arithmetic operation must be of type 'any', 'number' or an enum type.\napp.ts(5,21): error TS2363: The right-hand side of an arithmetic operation must be of type 'any', 'number' or an enum type.\n```\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/8260/comments",
    "author": "bennyyip",
    "comments": [
      {
        "user": "Arnavion",
        "created_at": "2016-04-23T08:14:49Z",
        "body": "TS doesn't understand `valueOf`, so it doesn't consider `Date` to be intrinsically convertible to `number` for arithmetic operations. You have to be explicit with `end.getTime() - start.getTime()`\n"
      },
      {
        "user": "weswigham",
        "created_at": "2016-04-23T09:23:57Z",
        "body": "Explicitly coercing to a number with `+` also works.\n\n``` ts\n\"use strict\";\n\nlet start = new Date()\nlet end = new Date()\nconsole.log(+start - +end)\n```\n"
      },
      {
        "user": "bennyyip",
        "created_at": "2016-04-23T10:21:50Z",
        "body": "@Arnavion @weswigham  thanks\n"
      },
      {
        "user": "mikemaccana",
        "created_at": "2017-10-18T14:45:13Z",
        "body": "A more explicit way to coerce to a Number is to use Number:\r\n\r\n    Number(new Date())"
      }
    ]
  },
  {
    "number": 8032,
    "title": "Empty object or type (`{} | Type`) doesn't work as expected",
    "created_at": "2016-04-12T19:19:44Z",
    "closed_at": "2016-04-12T20:06:31Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/8032",
    "body": "**TypeScript Version:** \n\n1.8.9\n\n**Code**\n\n``` ts\ninterface IAnimal {\n  legs: Number;\n}\n\ninterface IHouse {\n  cat: {} | IAnimal;\n}\n\nconst obj: IHouse = {\n  cat: {\n    legs: 2,\n  },\n};\n\nobj.cat.legs = 5;   // Property 'legs' does not exist on type '{} | IAnimal'.\nobj.cat = {};\n```\n\n**Expected behavior:**\n\nShould be able to assign `cat.legs` or `{}` interchangeably.\n\n**Actual behavior:** \n\nUnable to assign `legs` of `{} | IAnimal`.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/8032/comments",
    "author": "alexgorbatchev",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2016-04-12T19:22:25Z",
        "body": "You can't assign the `legs` property to `{}` (it has no members), and the `cat` property might be `{}`.\n\nWhat was your intent in writing `{} | IAnimal` ? This is a somewhat unusual thing to write and it's probably not doing what you think it does.\n"
      },
      {
        "user": "alexgorbatchev",
        "created_at": "2016-04-12T19:24:07Z",
        "body": "You are most likely correct. I'm trying to have a property where it could be a predefined type or an empty object `{}`. \n\n`{} | IAnimal` seemed like an intuitive thing to do, I couldn't find an existing example.\n"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2016-04-12T19:33:52Z",
        "body": ">  I'm trying to have a property where it could be a predefined type or an empty object `{}`.\n\nIn that case, what you wrote is correct (usually people use `null` or `undefined` as a placeholder, hence my question).\n\nFor this example, the best solution would be a type assertion, since the compiler doesn't know whether or not the `cat` property is `{}` or not:\n\n``` ts\ninterface IAnimal {\n  legs: Number;\n}\n\ninterface IHouse {\n  cat: {} | IAnimal;\n}\n\nconst obj: IHouse = {\n  cat: {\n    legs: 2,\n  },\n};\n\n(obj.cat as IAnimal).legs = 5;   // OK\nobj.cat = {};\n```\n\nThere are other solutions you could play with (writing a type predicate, making `legs` optional, etc) but it really depends on the situation.\n\nAs an aside, you _definitely_ want to use `number` instead of `Number`. `Number` refers to the boxed object you get from e.g. `new Number(5)`; `number` refers to actual numbers you'd commonly see in JS.\n"
      },
      {
        "user": "alexgorbatchev",
        "created_at": "2016-04-12T20:06:31Z",
        "body": "Interesting, thanks for clearing that up. I believe I see how it works now. Because there's no clear way to discern between `{}` and `IAnimal` compiler just choses the first one from `{} | IAnimal`, is that right?\n\nI got it work with making `legs` optional, which isn't ideal, because it's either all properties or an empty object (the actual code is more involved).\n\nThanks for the `number` correction, I haven't realized that.\n"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2016-04-12T20:53:10Z",
        "body": ">  Because there's no clear way to discern between {} and IAnimal compiler just choses the first one from {} | IAnimal, is that right?\n\nBasically. The rule for union types is that we only allow an operation if it would be legal to do on _each_ member of the union. Since `{}` doesn't have `legs`, the property assignment isn't allowed.\n\nDepending on context we can sometimes tell which you happen to have and will \"narrow\" to one member of the union (e.g. if there's an `instanceof` or `typeof` check), but this situation isn't one of them.\n"
      },
      {
        "user": "tonyxiao",
        "created_at": "2018-03-03T20:03:03Z",
        "body": "@RyanCavanaugh what if I actually want to define an empty object that may not have any properties? (such that the only acceptable value for that object is `{}`)? How would I define the type for that in TypeScript?"
      },
      {
        "user": "mhegazy",
        "created_at": "2018-03-03T20:16:57Z",
        "body": "use `object` instead."
      },
      {
        "user": "evenfrost",
        "created_at": "2018-05-16T16:13:47Z",
        "body": "`object` throws same error. I'm using this to define Vuex default state structure. Any way to define `empty object | Type`  without making all properties of `Type` optional?"
      }
    ]
  },
  {
    "number": 7990,
    "title": "Duplicate identifier 'Node', how to let Typescript know my file is a module",
    "created_at": "2016-04-10T03:57:13Z",
    "closed_at": "2016-04-10T04:03:05Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/7990",
    "body": "I'm building a module and I want to name a class 'Node'. Looks like 'Node' already exists in the global scope. A module file has an isolated scope, so it will not replace the global 'Node' class. How can I tell typescript that a file is a module so it does not complain about duplicates?\n\nmodels.ts:\n`class Node {}`\n\nIf I add export to the Node class, the warning is gone.\n\ntsc --version\n`Version 1.8.9`\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/7990/comments",
    "author": "carlosdubus",
    "comments": [
      {
        "user": "carlosdubus",
        "created_at": "2016-04-10T04:03:26Z",
        "body": "I just realized Typescript needs at least one export to know that a file is a module. My bad.\n"
      },
      {
        "user": "jesseschalken",
        "created_at": "2016-04-10T05:08:52Z",
        "body": "(at least one export or import)\n"
      }
    ]
  },
  {
    "number": 7790,
    "title": "[Question] - Is it possible to cast a type to an entire block?",
    "created_at": "2016-04-02T22:30:32Z",
    "closed_at": "2016-04-02T23:07:03Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/7790",
    "body": "Hi there,\n\nQuick question (or suggestion if this isn't possible):\n\nWhat I'm interested in doing is casting a type to an entire block (or to the rest of the current block). I do pretty explicit error handling, and I've found that I have to do this overly verbose `as <type>` statement each time. \n\nHere's a very pointless, but descriptive example:\n\n``` ts\ninterface Person {\n  firstname: string\n  lastname: string\n  age: number\n}\n\nfunction myFunc(x: boolean): Person|Error {\n  if (!x) {\n     return new Error('My error message');\n  }\n  return {\n    firstname: 'John',\n    lastname: 'Doe',\n    age: 45,\n  }\n}\n\nlet output = myFunc(true);\n\n// Handle the error\nif ((output as Error).name === 'Error') {\n  throw output;\n} \n\nconsole.log(\n  (output as Person).firstname + ' ' + (output as Person).lastname\n);\n\n```\n\nI'd like to assume that the `output` variable is of type Person after the if block that checks for an error. Is there any way to re-declare that it is type `Person` so that I don't have to do `(output as Person)` for everything thereafter?\n\nI hope that makes sense. Thanks a lot for the clarification! :smile: \n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/7790/comments",
    "author": "dsifford",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2016-04-02T23:01:31Z",
        "body": "This will be possible once type guards are rewritten to use flow control analysis (this work is currently in progress), assuming you add one helper function that creates an explicit type predicate.\n\nThe working version of the code (simplified) would look like this:\n\n``` ts\nfunction isError(p: any): p is Error {\n  return (p as Error).name === 'Error';\n}\n\nlet x: Person | Error = /* ... */;\n\nif (isError(x)) {\n  throw x;\n}\n\n// Because we know we can't get here if 'x' is 'Error',\n// all future uses of 'x' in this block are seen as type 'Person'\nlet n = x.firstname; // OK\n```\n"
      },
      {
        "user": "dsifford",
        "created_at": "2016-04-02T23:07:03Z",
        "body": "Excellent! Thanks for the clarification.\n"
      }
    ]
  },
  {
    "number": 7764,
    "title": "Unable to use \"Factory\" pattern",
    "created_at": "2016-04-01T12:58:10Z",
    "closed_at": "2016-04-01T16:38:33Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/7764",
    "body": "**TypeScript Version:** \n\n1.8.9\n\n**Code**\n\n_file A.ts_\n\n``` ts\nimport B from \"./B\";\nimport C from \"./C\";\n\nabstract class A {\n    static create(param: string) {\n        switch (param) {\n            case \"B\":\n                return new B();\n            case \"C\":\n                return new C();\n            default:\n                break;\n        }\n    }\n\n    abstract show(): void;\n}\n\nexport default A;\n```\n\n_file B.ts_\n\n``` ts\nimport A from \"./A\";\n\nexport default class B extends A {\n    show() {\n        console.log(\"B\");\n    }\n}\n```\n\n_file C.ts_\n\n``` ts\nimport A from \"./A\";\n\nexport default class C extends A {\n    show() {\n        console.log(\"C\");\n    }\n}\n```\n\n_file index.ts_\n\n``` ts\nimport A from \"./A\";\n\nA.create(\"C\").show();\n```\n\n**Actual behavior:** \n\nUncaught TypeError: Cannot read property 'prototype' of undefined\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/7764/comments",
    "author": "solodii",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2016-04-01T16:38:33Z",
        "body": "It's generally never safe to have circular module dependencies that require immediate execution. You need to re-order your file:\n\n``` ts\nabstract class A {\n    static create(param: string) {\n        switch (param) {\n            case \"B\":\n                return new B();\n            case \"C\":\n                return new C();\n            default:\n                break;\n        }\n    }\n\n    abstract show(): void;\n}\n\nexport default A;\n\nimport B from \"./B\";\nimport C from \"./C\";\n```\n\nThe problem is that when `B` and `C` are loaded from the `import` in `A`, they execute _before_ the `A` class has been created or exported.\n"
      }
    ]
  },
  {
    "number": 7733,
    "title": "Request: Optional strict typing on bracket access to properties",
    "created_at": "2016-03-30T14:20:13Z",
    "closed_at": "2016-05-20T06:13:42Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/7733",
    "body": "_Tested with TypeScript 1.8.7_\n\nI have a situation where I need to access a property on an object with bracket notation because the property name contains dots. Unfortunately, TypeScript is less strict with the bracket notation:\n\n``` ts\ninterface IFoo {\n  n: number;\n  s: string;\n}\n\nfunction testNumber(x : number) {\n  return x;\n}\n\nfunction (foo : IFoo) {\n  testNumber(foo.n);  // pass\n  testNumber(foo.s);  // fail\n  testNumber(foo.asd);  // fail\n\n  testNumber(foo['n']);  // pass\n  testNumber(foo['s']);  // fail\n  testNumber(foo['asd']);  // pass\n}\n```\n\n`foo.asd` in this case fails because `asd` is not a valid property of `IFoo`. But `foo['asd']` is assumed to be of type `any`.\n\nI read somewhere that this behavior is intentional to offer some kind of backdoor. I am pretty sure I do not need that backdoor in my project, but I need `foo['asd']` to fail. So it would be great if this behavior could be optionally turned on.\n\nI guess the `--noImplicitAny` option would have some effect, but unfortunately turning it on would require major changes in the rest of my codebase, so that is not an option. \n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/7733/comments",
    "author": "xi",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2016-03-30T21:38:38Z",
        "body": "JavaScript allows to index into any object. TypeScript compiler can not statically know type checked all these, e.g. `var name = getName(); x[name];`. so it gives it the type `any`.\n\nObviously this is not type-safe, for this you have index signatures on types, e.g.\n\n``` ts\ninterface IFoo {\n  n: number;\n  s: string;\n  [x:string] : number | string;\n}\n\ntestNumber(foo['asd']);  // now fails\n```\n\n`--noImplicitAny` enforces that you can not access into anything without either 1. using known property names (e.g. `foo[\"n\"]` above), or 2. having an index signature on the type as outlined above.\n"
      },
      {
        "user": "xi",
        "created_at": "2016-05-20T16:02:16Z",
        "body": "My report was not a question but a feature request. I will take your answer as a no to that request.\n"
      },
      {
        "user": "Psvensso",
        "created_at": "2017-04-03T07:40:56Z",
        "body": "However when the index type is a number you loose some more typing. \r\n\r\nThe compiler seems to be lost when doing:\r\n```\r\ninterface IFoo {\r\n        [x: number]: number | string;\r\n}\r\nvar t = foo['a']; // t = any\r\n```\r\n\r\nThe equivalent, but using string as index key, works as expected even with \"wrong\" accessor type:\r\n```\r\ninterface IFoo {\r\n        [x: string]: number | string;\r\n}\r\nvar t = foo[0]; // t = number | string;\r\n``` \r\n\r\nThis is perhaps a silly example but becomes odd when using enums as keys.\r\nAnd in 2.1.5 you can't use enums as accessors yet so you have to use key:number.  \r\n\r\n@mhegazy any recommendations of usage here? (e.g. not getting back type:any when using key:number)\r\n\r\n\r\nUsing 2.1.5 in examples"
      }
    ]
  },
  {
    "number": 7727,
    "title": "Extra casting not necessary",
    "created_at": "2016-03-29T18:02:17Z",
    "closed_at": "2016-03-29T18:03:37Z",
    "labels": [
      "By Design",
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/7727",
    "body": "Hello,\n\nActual:\n`interface ITest{test:string}; let test:ITest=<ITest>{}`\nExpected\n`interface ITest{test:string}; let test:ITest={}`\n\nI think `{}` should be considered as `ITest` by default instead of any.\n\nThanks in advance for your feedback.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/7727/comments",
    "author": "Alphapage",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2016-03-29T18:03:37Z",
        "body": "``` ts\ninterface ITest{test?:string}; let test:ITest={}\n```\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2016-03-29T18:04:50Z",
        "body": "Sorry hit comment too soon.\n\n`ITest` requires one member `test`. the empty object does not have that. they are not assignable.\n\nyou can make `test` optional in `ITest`:\n\n``` ts\ninterface ITest{test?:string}; let test:ITest={}\n```\n"
      }
    ]
  },
  {
    "number": 7706,
    "title": "Async arrow functions generate broken code when targeting es5",
    "created_at": "2016-03-27T23:34:23Z",
    "closed_at": "2016-03-28T19:28:12Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/7706",
    "body": "**TypeScript Version:** Tested on 1.8.9 and Version 1.9.0-dev.20160327\n\n**Code**\n\n``` ts\nlet foo = async (_arg) => {};\n```\n\nCompiles to the following (when `{\"target\": \"es5\"}`):\n\n``` js\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator.throw(value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments)).next());\n    });\n};\nvar foo = function (_arg) __awaiter(this, void 0, void 0, function* () { });\n```\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/7706/comments",
    "author": "nevir",
    "comments": [
      {
        "user": "Arnavion",
        "created_at": "2016-03-28T02:47:37Z",
        "body": "The compiler also gives an error:\n\n`foo.ts(1,11): error TS1057: An async function or method must have a valid awaitable return type.`\n\nIt's by design that the compiler may emit some output (which may be garbage) even if there's an error. If you don't want the compiler to emit on error then use `noEmitOnError: true`\n\nEdit: And note that the error is somewhat misleading since the real reason is that async functions aren't supported when targeting ES5.\n"
      },
      {
        "user": "yortus",
        "created_at": "2016-03-28T03:55:29Z",
        "body": "I also reported this a month ago (#7334).\n\nIt's not specific to async arrow functions, it's when the async function is an expression (e.g. RHS of assignment) rather than a declaration.\n\n@Arnavion that error `TS1057` is due to an internal check that relies on the existence of `Promise` (which is not in ES5 by default). #7334 defines `Promise`, which unmasks the real problem - that no compiler errors are raised for async function expressions in ES5 even though the generated code is unusable.\n"
      }
    ]
  },
  {
    "number": 7673,
    "title": "Call static method without repeating the class name",
    "created_at": "2016-03-24T18:59:05Z",
    "closed_at": "2016-03-25T19:34:24Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/7673",
    "body": "When I create a static method, the only way to call it seems to be through the actual class name: `MyClass.staticMethod`. It would be great if there was a way to call the static method without repeating the class name, it would be less error prone when you later decide to rename the class.\n\nA few suggestions:\n`self.class.staticMethod` or\n`self.type.staticMethod` or\n`Self.staticMethod`\n\nIn other languages you can do it like this:\n- PHP: `$this->staticMethod();` or `$this::staticMethod();`\n- Python: `self.__class__.staticMethod()`\n- Ruby: `self.class.staticMethod`\n- Objective-C: `[[self class] staticMethod]`\n- Swift: `self.dynamicType.staticMethod()`\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/7673/comments",
    "author": "yvbeek",
    "comments": [
      {
        "user": "jpleclerc",
        "created_at": "2016-03-25T18:23:23Z",
        "body": "A good IDE should be able to rename/refactor your class without any problem, especially if the refactor is in the same class.\n"
      },
      {
        "user": "yvbeek",
        "created_at": "2016-03-25T18:28:13Z",
        "body": "You can walk to most places instead of driving there, that is not really a reason for not using a car.\n"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2016-03-25T19:34:24Z",
        "body": "You should be able to write `this.staticMethod` in a static context of the same class.\n"
      },
      {
        "user": "SBD580",
        "created_at": "2016-12-22T10:02:06Z",
        "body": "+1\r\n\r\nNot to mention Java where you can call a static method just by it's name (from within the same class of course).\r\n\r\nThis will make the code much more readable.\r\n"
      },
      {
        "user": "bloadvenro",
        "created_at": "2017-03-28T22:16:55Z",
        "body": "@DanielRosenwasser it is usual for me to call static methods/props from instance methods, but `this` points to the instance side.  `this.constructor._property` says _\"Property '\\_property' does not exist on type 'Function'.\"_ Is it difficult to implement reference to static side of the class? "
      },
      {
        "user": "invasioncredible",
        "created_at": "2017-11-27T18:25:16Z",
        "body": "@bloadvenro +1\r\nHad a problem with this today. "
      },
      {
        "user": "eugenecherkassky",
        "created_at": "2018-02-25T12:10:30Z",
        "body": "+1"
      },
      {
        "user": "PrasannaaSanthanam",
        "created_at": "2018-03-02T03:39:32Z",
        "body": "+1\r\nThis would be a really nice to have feature when you are dealing with really long classNames and does not have the option of changing the class name, especially when you are in a ternary  along with x max-line-length"
      },
      {
        "user": "negora",
        "created_at": "2018-05-08T08:06:47Z",
        "body": "In my opinion, this feature is really important **to improve the readability of the code.** Although the ability to refactor the code more easily is also welcomed, of course.\r\n\r\nWhen you have to add a class name before a method call, a statement that usually takes 1 line, takes 2 (or even more). Specially if the names of your class, method or arguments (or all them) are not trivial, and you've to restrict the line length to 80 characters.\r\n\r\nWith regard to the implementation of this feature, **I would love to be able to omit the class name entirely, as in Java.** But I guess that it could lead to confusion in JavaScript; because one wouldn't know if the code is calling a static method or an independent function.\r\n\r\nBut that already may happen with instance methods, if you set the option `noImplicitThis` to `false`. Doesn't it? For that cases, I guess that editors and IDEs should allow to use a different colour for the calls to functions.\r\n\r\nI also like the idea of the `self` keyword. But I wonder if it would cause problems with code that already uses that word. I guess that the TS developers could create an option, called `referencesToSelfStatic` or `refsToSelfStatic`, with the following possible values:\r\n\r\n* `explicit`: only allows the use of the class name.\r\n* `self`: allows the use of the class name or the `self` keyword (for a given statement).\r\n* `implicit`: allows the use of the class name or the `self` keyword, or their omission (for a given statement).\r\n\r\nThese values could also be named as: `className`,  `className+self`, `className+self+implicit`.\r\n\r\nThis way, we all could choose the option that better suited our needs.\r\n"
      }
    ]
  },
  {
    "number": 7670,
    "title": "Issue with inferring types when using derived interfaces",
    "created_at": "2016-03-24T16:10:48Z",
    "closed_at": "2016-03-29T05:11:17Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/7670",
    "body": "**TypeScript Version:** \n\nCurrent playground version and 1.7.5\n\n**Code**\n\n```\ninterface Promise<T> { }\ninterface MyPromise<T> extends Promise<T> { }\n\nfunction eventually<T>(func: () => Promise<T>, test: (result: T) => boolean, retries: number) {\n}\n\nfunction getMyPromise<T>(): MyPromise<T> {\n    return {};\n}\n\neventually(() => getMyPromise<any[]>(), x => x.length > 0, 10);\n```\n\n**Expected behavior:**\nShould compile without errors\n\n**Actual behavior:** \nGive an error (still emits though)\n\nOn the playground I get \"Property length does not exist on type {}\"\nOn v1.7.5 I get the same error\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/7670/comments",
    "author": "massimocode",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2016-03-24T16:34:10Z",
        "body": "the problem is that `T` is never manifested in the type `Promise` or `MyPromise`; TS has a structural type system, so trying to infer `T` from `MyPromise<T>` will only work, if the structure of `MyPromise` has some representation of T.\n\nfor instance, changing your definition to:\n\n``` ts\ninterface Promise<T> { a: T}\n```\n\nwould harness the expected result.\n"
      },
      {
        "user": "massimocode",
        "created_at": "2016-03-24T16:39:09Z",
        "body": "I see what you mean. The real reason I raised this is because we have an issue with a custom form of promise. I will have to isolate a proper example for you.\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2016-03-24T16:43:04Z",
        "body": "the root cause boils down to, if the structure does not \"manifest\" the type parameter, there is no way to infer to it. that is not the case in a nominal type system.\n"
      },
      {
        "user": "massimocode",
        "created_at": "2016-03-24T17:25:14Z",
        "body": "Ok so we have a Promise that extends the ES6 promise by using species etc. It's called Promish. I have written a type definition as follows:\n\n```\n// Basic type definitions for Promise. Needs updating as and when needed.\n\ninterface Promish<T> extends Promise<T> {\n    /**\n    * Attaches callbacks for the resolution and/or rejection of the Promise.\n    * @param onfulfilled The callback to execute when the Promise is resolved.\n    * @param onrejected The callback to execute when the Promise is rejected.\n    * @returns A Promise for the completion of which ever callback is executed.\n    */\n    then<TResult>(onfulfilled?: (value: T) => TResult | PromiseLike<TResult>, onrejected?: (reason: any) => TResult | PromiseLike<TResult>): Promish<TResult>;\n    then<TResult>(onfulfilled?: (value: T) => TResult | PromiseLike<TResult>, onrejected?: (reason: any) => void): Promish<TResult>;\n\n    /**\n     * Attaches a callback for only the rejection of the Promise.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of the callback.\n     */\n    catch(onrejected?: (reason: any) => T | PromiseLike<T>): Promish<T>;\n    catch(onrejected?: (reason: any) => void): Promish<T>;\n\n    /**\n     * Attaches a callback for the settlement of the Promise but does not allow you to transform the settled value.\n     * @param onsettled The callback to execute when the Promise is settled.\n     * @returns A Promise for the completion of the callback.\n     */\n    finally(onsettled?: (reason: any) => T | PromiseLike<T>): Promish<T>;\n    finally(onsettled?: (reason: any) => void): Promish<T>;\n\n    delay(value: number): Promish<T>;\n\n\n}\n\ndeclare module \"promish\" {\n  interface PromishConstructor {\n    /**\n      * A reference to the prototype.\n      */\n    prototype: Promish<any>;\n\n    /**\n     * Creates a new Promise.\n     * @param executor A callback used to initialize the promise. This callback is passed two arguments:\n     * a resolve callback used resolve the promise with a value or the result of another promise,\n     * and a reject callback used to reject the promise with a provided reason or error.\n     */\n    new <T>(executor: (resolve: (value?: T | PromiseLike<T>) => void, reject: (reason?: any) => void) => void): Promish<T>;\n\n    /**\n     * Creates a Promise that is resolved with an array of results when all of the provided Promises\n     * resolve, or rejected when any Promise is rejected.\n     * @param values An array of Promises.\n     * @returns A new Promise.\n     */\n    all<T>(values: Iterable<T | PromiseLike<T>>): Promish<T[]>;\n\n    /**\n     * Creates a Promise that is resolved or rejected when any of the provided Promises are resolved\n     * or rejected.\n     * @param values An array of Promises.\n     * @returns A new Promise.\n     */\n    race<T>(values: Iterable<T | PromiseLike<T>>): Promish<T>;\n\n    /**\n     * Creates a new rejected promise for the provided reason.\n     * @param reason The reason the promise was rejected.\n     * @returns A new rejected Promise.\n     */\n    reject(reason: any): Promish<void>;\n\n    /**\n     * Creates a new rejected promise for the provided reason.\n     * @param reason The reason the promise was rejected.\n     * @returns A new rejected Promise.\n     */\n    reject<T>(reason: any): Promish<T>;\n\n    /**\n      * Creates a new resolved promise for the provided value.\n      * @param value A promise.\n      * @returns A promise whose internal state matches the provided promise.\n      */\n    resolve<T>(value: T | PromiseLike<T>): Promish<T>;\n\n    /**\n     * Creates a new resolved promise .\n     * @returns A resolved promise.\n     */\n    resolve(): Promish<void>;\n\n\n    [Symbol.species]: Function;\n  }\n\n  var promish: PromishConstructor;\n  export = promish;\n}\n```\n\nThe type definition is basically a copy/paste of the ES6 Promise type definition, except that I have replaced references of Promise with Promish. The problem is that when we pass a Promish to a method that expects a Promise, there are sometimes issues detecting the generic type parameter, leading to the following error:\nerror TS2453: The type argument for type parameter 'T' cannot be inferred from the usage. Consider specifying the type arguments explicitly.\n  Type argument candidate 'any[]' is not a valid type argument because it is not a supertype of candidate 'void'.\n\nDo you have any ideas on this?\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2016-03-24T19:38:02Z",
        "body": "add a new member `\"_tag\" : T`.\n"
      },
      {
        "user": "massimocode",
        "created_at": "2016-03-29T08:57:58Z",
        "body": "Hi @mhegazy. I just tried adding this member to the Promish<T> interface but it did not solve the error. Any ideas?\n"
      },
      {
        "user": "massimocode",
        "created_at": "2016-03-29T09:39:09Z",
        "body": "Further update: This seems to be fixed in the Typescript@next build. I have put in a workaround in the meantime by using PromiseLike<T> instead of Promise<T> in my eventually function. Thanks\n"
      }
    ]
  },
  {
    "number": 7669,
    "title": "Typescript not merging interfaces from lib.d.ts",
    "created_at": "2016-03-24T15:16:09Z",
    "closed_at": "2016-03-24T16:19:06Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/7669",
    "body": "**TypeScript Version:** \n\n1.8.9\n**Code**\n\n``` ts\ninterface Window {\n    URL;\n}\n```\n\n**Actual behavior:** \n\nWhen upgrading typescript versions, new definitions were added to lib.d.ts, and these new definitions cause conflicts with definitions we had in our project.\n\nThis makes it annoying to upgrade typescript since we have to introduce a change to the code that breaks anyone using an old compiler.\n\n**Expected behavior:** \nTypescript would merge the types in my project definitions with lib.d.ts without complaint.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/7669/comments",
    "author": "kuza55",
    "comments": [
      {
        "user": "oising",
        "created_at": "2016-03-24T15:37:54Z",
        "body": "TypeScript _does_ merge interfaces without complaint, but you have a merge _conflict_ for identically named members. I'm not sure I would want typescript to automatically choose a side for a merge conflict. What if it's got the same member name and different parameters? Which definition should win? And what is the logic behind it?\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2016-03-24T16:19:05Z",
        "body": "As @oising explained, a duplicate definition is not something that will be merged, it is assumed to be an error.\n\none thing to note, using `--noLib`, you can specify your own version of the library, be it an older version of lib.d.ts or a custom one.\n"
      }
    ]
  },
  {
    "number": 7659,
    "title": "[Question] - Is there a syntax for defining interface properties of the same type on the same line?",
    "created_at": "2016-03-23T20:29:52Z",
    "closed_at": "2016-03-23T20:39:50Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/7659",
    "body": "Hello, \n\nSorry if this has been asked before. The issue history is massive and I couldn't locate it if it has. I also checked SO but didn't find anything.\n\nI'm coming from Golang and one thing that I like from there is the ability to declare properties of the same type on the same line (It reads cleaner IMO). \n\nIs this possible with Typescript?\n\nHere's how I'd define an interface (struct type) in Go\n\n``` go\ntype person struct {\n        firstName, lastName string\n        age int\n}\n```\n\nHere's how I do the same thing currently in TypeScript\n\n``` ts\ninterface person {\n  firstName : string\n  lastName : string\n  age : number\n}\n```\n\nHere's how I'd like to do it\n\n``` ts\ninterface person {\n  firstName, lastName : string\n  age : number\n}\n```\n\nThanks for the clarification! :smile: \n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/7659/comments",
    "author": "dsifford",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2016-03-23T20:37:15Z",
        "body": "It is not allowed to define multiple member declarations in the same declaration statements for interfaces, or classes. nor is it allowed for variable declarations.\n\nto get this behavior you will need to specify the type for each member. If no type is specified, the type is `any`.\n\nthis also applies for variable declarations.\n\n``` ts\nvar x, y : number;  // x : any, y: number\n```\n"
      },
      {
        "user": "dsifford",
        "created_at": "2016-03-23T20:39:50Z",
        "body": "Understood! Thanks for the quick reply! :+1: \n"
      }
    ]
  },
  {
    "number": 7644,
    "title": "super() with an options object (possibly a FAQ)",
    "created_at": "2016-03-22T21:14:29Z",
    "closed_at": "2016-03-23T18:22:08Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/7644",
    "body": "(Apologies if this is known, but I search a bunch of places and didn't find anything.)\n\nIs there a good way to deal with a constructor of a derived class that is getting an options kind of value that needs to be merged with a defaults value?  I started with something like this:\n\n```\nexport class Foo extends Bar {\n    ...\n    private options: any = {};\n    ...\n    constructor(x: Something, y: SomethingElse, options: any = {}) {\n        this.options = $.extend({}, defaults, options);\n        super(this.options.blah);\n        ...\n    }\n}\n```\n\nThis failed and I eventually resorted to:\n\n```\n    constructor(x: Something, y: SomethingElse, options: any = {}) {\n        super(options.blah || defaults.blah);\n        this.options = $.extend({}, defaults, options);\n        ...\n    }\n```\n\nwhich is duplicating functionality (and sloppy).\n\nHopefully I'm not the only one who ran into this problem and there's good way to do that?\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/7644/comments",
    "author": "elibarzilay",
    "comments": [
      {
        "user": "Arnavion",
        "created_at": "2016-03-22T22:10:51Z",
        "body": "The assignment to `this.options` before calling `super()` is illegal per ES6 semantics, so that can't be done anyway.\n\nYou could assign to a temporary (eg back to `options`), do the `super()` call, then assign `options` to `this.options`\n\n``` typescript\nconstructor(x: Something, y: SomethingElse, options: any = {}) {\n    options = $.extend({}, defaults, options);\n    super(options.blah);\n    this.options = options;\n}\n```\n\n... but that still hits the error that the `super()` call needs to be first.\n\nI've worked around a similar issue (needed to swap derived class constructor parameters before calling base class constructor to maintain backward compatibility) by abusing an IIFE as the `super()` parameter.\n\n``` typescript\nconstructor(x: Something, y: SomethingElse, options: any = {}) {\n    super((() => {\n        options = $.extend({}, defaults, options);\n        return options.blah;\n    })());\n    this.options = options;\n}\n```\n\n---\n\nEdit: Since you're always assigning to `this.options` in the constructor, you can remove the initialiazer for the class member `options`. Then the first alternative I gave will also compile.\n"
      },
      {
        "user": "elibarzilay",
        "created_at": "2016-03-23T17:57:32Z",
        "body": "The problem is that all of these are ugly hacks, and it looks very strange that the usual facility for keyword arguments thing cannot work in such constructors.\n\nBTW, I couldn't get your hack to work, perhaps the TS version I'm using is too old.  But if we're talking about such workarounds, then here's another ugly hack that works around it (based on an old Lisp hack of abusing optional arguments similarly):\n\n```\nconstructor(x: Something, y: SomethingElse, _options: any = {},\n            options: any = $.extend({}, Constants, _options)) {\n    super(options.blah);\n    this.options = options;\n    ...\n}\n```\n\nIn any case, I find it surprising that there is no proper way to do this, given that it's a common enough JS pattern that it's been embraced as the proper way to do keyword arguments.\n"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2016-03-23T18:22:08Z",
        "body": "Not 100% sure what the best approach is, but since this is really an ES6 thing (must invoke `super` before using `this`) you might find some good answers on Stack Overflow by just posting under the [javascript] tag\n"
      },
      {
        "user": "elibarzilay",
        "created_at": "2016-03-23T19:25:20Z",
        "body": "@RyanCavanaugh, so I looked at it more, and I still think that there's a specific TS issue here.  I can understand where the ES6 restriction is coming from, but trying it via TS still seem weird.\n\nI dug some more, and it looks like usually initialized properties are handled _after_ the `super()` call, **except** when there is some expression before the `super`, and even when that expression doesn't try to access `this`.  Here's an example that shows this:\n\n```\nclass Bar { private x; constructor(x: any) { this.x = x; }}\n\nclass Foo extends Bar {\n    private mu = 9999;\n    private options;\n    constructor(x: string, y: number, options: any = {}) {\n        // options = [123, options];\n        super(options.blah);\n        this.options = options;\n    }\n}\n```\n\nThis works fine, and the output has `this.mu = 9999;` after the `super` call.  Now uncomment the `options` setting line, and for some reason the `mu` initialization moves up to _before_ the the `super` call.  Is that intentional?\n\nAs a side note, I also think that it'll be good to add it to your FAQ since people will probably do what I did, and look for the error message.  So a quick entry saying that it's an ES6 issue would be better than nothing...\n"
      },
      {
        "user": "Arnavion",
        "created_at": "2016-03-24T00:04:35Z",
        "body": "@elibarzilay I did say\n\n> Since you're always assigning to `this.options` in the constructor, you can remove the initialiazer for the class member `options`. Then the first alternative I gave will also compile.\n"
      },
      {
        "user": "elibarzilay",
        "created_at": "2016-03-24T03:30:19Z",
        "body": "@Arnavion, see the example in my reply to @RyanCavanaugh above: the problem is that if there is _any_ initialized member TS does the assignment before the `super` call.  In my case it's obviously ok to drop the initialization of `options`, but there are other members that are initialized.\n"
      }
    ]
  },
  {
    "number": 7641,
    "title": "Possible to add a static method on a union type?",
    "created_at": "2016-03-22T19:40:35Z",
    "closed_at": "2016-03-22T20:55:53Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/7641",
    "body": "I'm using C like a companion object in Scala:\n\n``` ts\ninterface A {\n  a: number\n}\ninterface B {\n  b: number\n}\nclass C {\n  a: number\n  b: number\n  static c(d: number): number {...}\n}\n```\n\nHow do I express that `C = A|B`? I can do\n\n``` ts\ninterface A {...}\ninterface B {...}\ntype C = A|B\n```\n\nBut then I lose the static method\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/7641/comments",
    "author": "bcherny",
    "comments": [
      {
        "user": "jeffreymorlan",
        "created_at": "2016-03-22T20:33:50Z",
        "body": "Just use a variable, not a class:\n\n``` ts\ntype C = A|B;\nvar C = {\n    c(d: number): number {...}\n};\n```\n"
      },
      {
        "user": "bcherny",
        "created_at": "2016-03-22T20:55:53Z",
        "body": "Fantastic, that works great! Thanks @jeffreymorlan!\nAlso, will move these sorts of questions to stackoverflow from now on.\n"
      }
    ]
  },
  {
    "number": 7633,
    "title": "Index signature not inherited from interface to class",
    "created_at": "2016-03-22T09:31:25Z",
    "closed_at": "2016-03-29T00:06:57Z",
    "labels": [
      "Question",
      "Canonical"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/7633",
    "body": "``` ts\ninterface Foo {\n    [key:string]:any;\n}\n\ninterface Bar extends Foo {\n}\n\nclass Baz implements Foo {\n    [key:string]:any;\n}\n\nclass Qux implements Foo {\n}\n\nconsole.log((<Foo>{})['x']);\nconsole.log((<Bar>{})['x']);\nconsole.log((<Baz>{})['x']);\nconsole.log((<Qux>{})['x']);\n```\n\nOn `(<Qux>{})['x']` compiler fails with `Index signature of object type implicitly has an 'any' type.` message. When it's explicitly added to a class, like with `Baz`, everything works ok. With interfaces it seems to work fine, for example, `Bar` interface behaves as expected.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/7633/comments",
    "author": "iby",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2016-03-29T00:06:56Z",
        "body": "There is a distinction between `extends` and `implements` clauses for classes. `extends` means the current class inherits the shape of the parent; this includes index signatures, properties, and methods. `implements` on the other hand, is just a constraint. it says to the compiler, \"please check that this class incorrectly implements this interface\". there is nothing that is \"inherited\" by implementing the interface.\n\nTypeScript's type system is a structural one. so the implements clause is not required for an instance of this class to be assignable to an instance of the interface it implements. the only requirements, is that their structures match. As a matter of fact, removing the implement clause, should not change the semantics of your program.\n"
      },
      {
        "user": "iby",
        "created_at": "2016-03-29T06:24:37Z",
        "body": "Very well then. Thanks for the detailed explain.\n"
      }
    ]
  },
  {
    "number": 7620,
    "title": "A syntax for returning \"this\" for method call chaining would be great",
    "created_at": "2016-03-21T20:55:50Z",
    "closed_at": "2016-03-21T21:13:30Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/7620",
    "body": "When you've got a bit of inheritance going on, there can be limits to what you can do with method chaining.  Say you've got these two classes:\n\n```\nclass Animal {\n    public sleep() : Animal {\n        return this;\n    }\n}\n\nclass Elephant extends Animal {\n    public squirtWithTrunk(): Elephant {\n        return this;\n    }\n}\n```\n\nGiven an instance of Elephant, you could do this:\nmyElephant.squirtWithTrunk().sleep()\n\nbut you couldn't do this:\nmyElephant.sleep().squirtWithTrunk()\n\nBecause Animal doen't have a \"squirtWithTrunk\" method.\n\nSeems fair enough, but given how much code space method chaining can save, and how much that can matter in JavaScript, it's a shame.  And obviously in raw JavaScript this sort of thing just works.\n\nIf the following syntax were allowed, and \"this\" could be passed through a method chain without its type being narrowed to ancestor types, I think that might be quite nice:\n\n```\nclass Animal {\n    public sleep() : this {\n    }\n}\n\nclass Elephant extends Animal {\n    public squirtWithTrunk(): this {\n    }\n}\n```\n\nI don't know how feasible that would be from a compiler point of view, but as a user of the language I'd find it very useful.  In the last code snippet I imagine that the return statement would be disallowed, and that the returned value would always be the current object.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/7620/comments",
    "author": "philthy256",
    "comments": [
      {
        "user": "sandersn",
        "created_at": "2016-03-21T21:12:42Z",
        "body": "TypeScript already works this way. You do have to `return this` at the end of each method though.\n"
      },
      {
        "user": "sandersn",
        "created_at": "2016-03-21T21:14:13Z",
        "body": "See #4910\n"
      },
      {
        "user": "philthy256",
        "created_at": "2016-03-21T22:18:49Z",
        "body": "@sandersn That's awesome, thank you!\n\nThe following works a treat - great stuff:\n\nclass Animal {\n    public sleep() {\n        return this;\n    }\n}\n\nclass Elephant extends Animal {\n    public squirtWithTrunk() {\n        return this;\n    }\n}\n"
      }
    ]
  },
  {
    "number": 7531,
    "title": "Unable to assert(implicit down cast) narrow types from intersection types with partial object types",
    "created_at": "2016-03-16T02:05:19Z",
    "closed_at": "2016-03-16T06:25:03Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/7531",
    "body": "**TypeScript Version:** \n\nmaster\n\n**Code**\n\n``` ts\n<{a: number, b: number}>{a: <number&string>0, b: 0}; // ok\n<{a: number, b: number}>{a: <number>0}; // ok\n<{a: number, b: number}>{a: <number&string>0}; // error, should be able to assert\n```\n\n**Expected behavior:**\n\n```\n$ node built/local/tsc.js index.ts\n```\n\n**Actual behavior:** \n\n```\n$ node built/local/tsc.js index.ts\nindex.ts(3,1): error TS2352: Neither type '{ a: number & string; }' nor type '{ a: number; b: number; }' is assignable to the other.\n  Property 'b' is missing in type '{ a: number & string; }'.\n```\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/7531/comments",
    "author": "falsandtru",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2016-03-16T02:58:52Z",
        "body": "Do not really know how better to explain it than the error message does :)\n\n>  Neither type '{ a: number & string; }' nor type '{ a: number; b: number; }' is assignable to the other.\n"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2016-03-16T03:10:03Z",
        "body": "We have the rule in type assertions that your assertion has to be plausibly correct.\n\nIn other words, you can't write this code\n\n``` ts\nvar x = 'hello';\nvar y = <number>x; // Nope\n```\n\nbecause there's really no way that's true unless you've been telling some big lies about the type of something.\n\nSo in this case, if you want this to be legal (as a suggested change, not a bug), we'd need to see some rule which a) makes this legal, b) has some compelling justification as for why it should be legal, and c) doesn't allow any random type to be asserted to any other random type.\n"
      },
      {
        "user": "falsandtru",
        "created_at": "2016-03-16T03:22:12Z",
        "body": "TypeScript implicitly destructs intersection types in declarations.\n\n``` ts\nvar x: number & string;\nvar y: number = x;\n```\n\nWhy TypeScript does not have the same rule in partial object?\n"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2016-03-16T06:12:46Z",
        "body": "There's no implicit destructuring there, just a simple rule of assignability.\n\nA simpler case to think about would be something like\n\n``` ts\ninterface Farm1 {\n  x: Horse;\n  y: Animal;\n}\ninterface Farm2 {\n  x: Animal;\n  y: Dog;\n}\n\nvar f1: Farm1;\nvar f2: Farm2;\n\nf1 = <Farm1>f2;\n```\n\nThis assertion isn't allowed because neither `Farm1` nor `Farm2` is assignable to the other. You can't have one property go \"up\" while the other goes \"down\" -- either all the properties are being asserted to a supertype, or all the properties are asserted to a subtype. There's no mixing and matching allowed.\n\n#5300 is closely related.\n"
      },
      {
        "user": "falsandtru",
        "created_at": "2016-03-16T06:25:03Z",
        "body": "I understood that. Thanks @RyanCavanaugh .\n"
      }
    ]
  },
  {
    "number": 7527,
    "title": "Uninstalling 1.8 tools does not remove some its \"features\"",
    "created_at": "2016-03-15T21:52:27Z",
    "closed_at": "2016-03-16T01:04:01Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/7527",
    "body": "I did a fresh build of my machine yesterday (from base OS).\n\nI Installed Visual Studio 2015 Update 1.  Got my project from source and got it compiling great.\n\nToday I installed the Typescript 1.8 tools (Said 1.8.4 I think).  I got this from the Visual Studio 2015 link on the Typescript 1.8 blog post.\n\nOnce I loaded my project it asked me if I wanted to upgrade my tools.  I said yes.\n\nI then build again, and got a ton of errors.  I could not see any reason for them, so I decided to downgrade back to 1.7 tools.\n\nI uninstalled Typescript 1.8 tools and reverted my project back.\n\nWhen I started up visual studio again my project loaded fine but gave me a build error.  The error was complaining about \"compilerOptions\":being null or undefined. (Which was odd, because it was defined in my tsconfig file.)\n\n**Error:**  \nI went and looked in my project properties and it told me that because I had a tsconfig file, the properties were disabled.\n\n**Expected:**  \nBecause I had uninstalled the 1.8 tools, my project would go back to ignoring the tsconfig file.\n\n**Workaround**  \nI was able to get around this by removing my tsconfig file from my project.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/7527/comments",
    "author": "Vaccano",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2016-03-15T22:24:30Z",
        "body": "> I then build again, and got a ton of errors.\n\nwhat kind of errors did you get?\n"
      },
      {
        "user": "Vaccano",
        "created_at": "2016-03-15T22:45:22Z",
        "body": "I got a whole bunch of \"Cannot find name ....\" errors.\n\nEverything from $ to aurelia-framework.\n\nI get a lot of Intellisense red squiggles too.\n\nIt works fine with the older version (1.7)\n"
      },
      {
        "user": "Vaccano",
        "created_at": "2016-03-15T22:50:14Z",
        "body": "@mhegazy So I tried it again, to see if I could get you a list of errors.  I noticed that (at least this time) all the errors only show when I have \"Build + Intellisense\" selected in the dropdown in the \"Error List\".\n\nIf I just pick \"Build\" then there are no errors.\n\nBut the red squiglies on all my imports will drive me nuts.   Plus it has killed my typescript intellisense completion.\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2016-03-15T23:06:21Z",
        "body": "I think i know what is going on. in TS 1.7 the project file was used to build your project, so the tsconfig.json was ignored. in TS 1.8 the tsconfig.json is now honored. looks like your tsconfig.json does not match what you had in your project file. try looking in the build log (or output window after build), what arguments does `tsc.exe` takes, and make sure your tsconfig.json has these set as well.\n"
      },
      {
        "user": "Vaccano",
        "created_at": "2016-03-15T23:10:51Z",
        "body": "@mhegazy But I uninstalled the TS 1.8 tools.  And I changed my project file to use the 1.7 tools again.\n\nI guess I thought that would revert me back to TS 1.7.  Is there more that I need to uninstall to revert back to TS 1.7?\n\nI will check the build output and see if I can make my tsconfig match it.  I would rather be on 1.8.  But if there is another dependency besides the visual studio Type Script tools that controls what version of typescript is compiled with I would like to know it.\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2016-03-15T23:18:24Z",
        "body": "When uninstalling a version, there are some shared tools that are left behind. namelly the SDK.\nuninstalling TS 1.7 removes the VS support. but your build tools stay around untill VS is uninstalled.\n\nthe targets and tasks has that support. \n\nso with that setup your MSBuild tasks know about tsconfig. removing the tsconfig.json from the project does the trick as you explained.\n\nif you want to remove it completely from your system:\n1. uninstall all TS versions you have, from Add/Remove Programs\n2. delete the folder `C:\\Program Files (x86)\\MSBuild\\Microsoft\\VisualStudio\\v14.0\\TypeScript`\n3. install the version you intend, be it 1.7.6 or another.\n"
      },
      {
        "user": "Vaccano",
        "created_at": "2016-03-15T23:37:07Z",
        "body": "My build had the following options (when running TS 1.7):\n\n `--module System --sourcemap --target ES5 --emitDecoratorMetadata --experimentalDecorators --noEmitOnError --locale en-US`\n\nI updated my tsconfig to look like this:\n\n```\n{\n  \"compilerOptions\": {\n    \"emitDecoratorMetadata\": true,\n    \"experimentalDecorators\": true,\n    \"locale\": \"en-US\",\n    \"module\": \"system\",\n    \"noEmitOnError\": true,\n    \"sourceMap\": true,\n    \"target\": \"es5\"\n  }\n}\n```\n\nAnd I still get the errors.  Here is a list of a few of them in case it matters (I shortened the paths):\n\n```\nError   TS2304  Cannot find name 'Promise'. TypeScript Virtual Projects     C:\\src\\entities\\box\\box-callback-interfaces.ts\nError   TS2503  Cannot find namespace 'breeze'. TypeScript Virtual Projects C:\\src\\entities\\box\\box-type-interface.ts   \nError   TS2503  Cannot find namespace 'breeze'. TypeScript Virtual Projects C:\\src\\entities\\box\\box-type.ts \nError   TS2503  Cannot find namespace 'breeze'. TypeScript Virtual Projects C:\\src\\entities\\box\\box-type.ts \nError   TS2307  Cannot find module 'aurelia-framework'. TypeScript Virtual Projects C:\\src\\entities\\box\\box.ts  \nError   TS1219  Experimental support for decorators is a feature that is subject to change in a future release. Set the 'experimentalDecorators' option to remove this warning. TypeScript Virtual Projects C:\\src\\entities\\box\\box.ts\nError   TS2307  Cannot find module 'aurelia-framework'. TypeScript Virtual Projects C:\\src\\entities\\entity-factory.ts\n```\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2016-03-16T00:47:48Z",
        "body": "Can you share the project?\n"
      },
      {
        "user": "Vaccano",
        "created_at": "2016-03-16T00:54:11Z",
        "body": "@mhegazy Alas, no.  But I think I may have gotten it working.\n\nWhat was messing me up is that with TS 1.7 it would only compile what was in my project.  With TS 1.8 it looks at the disk, not the project to see what to compile.  I had to add some excludes and remove an erroneous exclude that I had in my tsconfig to get it looking at the right stuff..  \n\nOnce I got that all figured, it started working correctly again.\n\nThank you for your help!\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2016-03-16T01:04:01Z",
        "body": "glad that worked. sorry for your trouble. let us know if you run into other issues.\n"
      }
    ]
  },
  {
    "number": 7490,
    "title": "Type guards do not understand unions of array types",
    "created_at": "2016-03-12T16:07:28Z",
    "closed_at": "2016-03-29T04:39:12Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/7490",
    "body": "Try the following:\n\n```\nfunction workWithXArray(array: x[]) { }\nfunction workWithYArray(array: y[]) { }\n\nfunction workWithArray(array: (x|y)[]) {\n    if (array.length > 0) {\n        let value = array[0];\n\n        if (value instanceof x) {\n            workWithXArray(array);\n        } else if (value instanceof y) {\n            workWithYArray(array);\n        }\n    }\n}\n```\n\nIt will throw error TS2345: Argument of type '(x| y)[]' is not assignable to parameter of type 'x[]'\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/7490/comments",
    "author": "matthiasferch",
    "comments": [
      {
        "user": "FranklinWhale",
        "created_at": "2016-03-12T18:02:49Z",
        "body": "I am not sure if (X|Y)[] is the intended type of the \"array\" parameter. I think it should be X[]|Y[]. The former one appears to be an array of the union type of X and Y while the latter one means either an array of X or an array of Y.\n\nThe following code appears to work:\n\n``` ts\nclass X {\n    public x;\n}\nclass Y {\n    public y;\n}\n\nfunction workWithXArray(array: X[]) { }\nfunction workWithYArray(array: Y[]) { }\n\nfunction workWithArray(array: X[] | Y[]) {\n    if (array.length > 0) {\n        let value = array[0];\n\n        if (value instanceof X) {\n            workWithXArray(array as X[]);\n        } else if (value instanceof Y) {\n            workWithYArray(array as Y[]);\n        }\n    }\n}\n```\n"
      }
    ]
  },
  {
    "number": 7430,
    "title": "Augmenting re-exported names from ambient module",
    "created_at": "2016-03-08T15:06:04Z",
    "closed_at": "2016-03-08T20:56:47Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/7430",
    "body": "**TypeScript Version:** \n\nnightly (1.9.0-dev.20160308)\n\n**Code**\n\n``` ts\n// test1.d.ts\ndeclare module 'test1/lib' {\n    export interface Test {\n        a: number;\n    } \n}\n\ndeclare module 'test1' {\n    export * from 'test1/lib';\n}\n\n// augment.d.ts\n\n/// <reference path=\"test1.d.ts\" />\nimport 'test1';\ndeclare module 'test1' {\n    interface Test { // Module augmentation cannot introduce new names in the top level scope. (2665)\n        b: string;\n    }\n}\n```\n\nShouldn't it be allowed?\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/7430/comments",
    "author": "asvetliakov",
    "comments": [
      {
        "user": "vladima",
        "created_at": "2016-03-08T20:47:59Z",
        "body": "re-exports does not add exported names into the local scope of the module - here module `test1` won't have local entry for `interface Test` so compiler error is correct.\n"
      },
      {
        "user": "asvetliakov",
        "created_at": "2016-03-08T20:56:47Z",
        "body": "Ok, thanks\n"
      }
    ]
  },
  {
    "number": 7414,
    "title": "Anyway to force arrow functions as type annotations?",
    "created_at": "2016-03-07T12:17:33Z",
    "closed_at": "2016-03-07T18:25:17Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/7414",
    "body": "**TypeScript Version:** \n\n1.8.2\n\n**Code**\n\nUsing arrow functions we can invoke them without passing context (if it is neccesary por us). It it useful to write libraries. Other way we need to ask context:\n\nExample:\n\n``` ts\ninterface Request{\n    callBack: (data) => void;\n    context: any;\n}\n\nclass Command{\n// ...\n    constructor(private request: Request) { }\n    protected executeCallBack(result) {\n//...\n       this.request.callBack.call(this.request.context,  result); /* Not sure if it is an arrow function so invoke call or apply */\n    };\n//...\n}\n```\n\nI think code below is better:\n\n``` ts\ninterface Request{\n    callBack: (data) => void;\n}\n\nclass Command{\n// ...\n    constructor(private request: Request) { }\n    protected executeCallBack(result) {\n//...\n       this.request.callBack(result); \n    };\n//...\n}\n```\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/7414/comments",
    "author": "xLama",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2016-03-07T15:43:35Z",
        "body": "This will be handled by #6739\n"
      }
    ]
  },
  {
    "number": 7357,
    "title": "Overloaded array type",
    "created_at": "2016-03-03T01:27:45Z",
    "closed_at": "2016-03-03T05:53:14Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/7357",
    "body": "I was unable to find this in the documentation or among the existing issues.\n\nIs there any way to have overloaded array types? Something that would look like:\n\n```\ninterface I {\n    [s: string]<T extends Bar>: T;\n    method<T extends Bar>(): T;   // this is allowed\n}\n```\n\nI guess it would also need a syntax at call-sites, which would look weird:\n\n```\ndeclare var array: I\n\n// and in client code:\nclass Foo extends Bar { foo(); }\narray[\"field\"]<Foo>.foo();\n```\n\n(As an aside, I'm not sure how to use the array type syntax)\n\nMy apologies if this is already do-able, I couldn't find a way...\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/7357/comments",
    "author": "Ptival",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2016-03-03T05:19:23Z",
        "body": "There isn't a direct way to do this, but really all you're doing is writing a type assertion at the indexing site. You could equivalently write:\n\n``` ts\ndeclare var array: { [s: string]: Bar; };\n(<Foo>array[\"field\"]).foo();\n```\n"
      },
      {
        "user": "Ptival",
        "created_at": "2016-03-03T05:42:50Z",
        "body": "It would indeed defer type assertions to the indexing site, but it could at least guarantee the subtyping condition.\n\nMy use case is for a JS library which registers multiple kinds of objects into an array.\nIf I just make it:\n\n```\ninterface W2UI {\n    [s: string]: any;\n}\ndeclare var w2ui : W2UI\n```\n\nThen I don't get any documentation/type-checking out of what comes out of the array.\nSince the main mode of interaction with the library is with:\n\n```\nw2ui[\"layout\"].layoutMethod();\nw2ui[\"tab\"].tabMethod();\n```\n\nIt becomes pretty much useless to even give type to anything.\n\nIs there a way to describe a type that is one of 7 classes, but is allowed to be any of them? (even when they are not compatible)\n"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2016-03-03T05:49:24Z",
        "body": "You could use a union type:\n\n``` ts\ninterface W2UI {\n  [s: string]: TabControl | InputControl | LabelControl;\n}\nvar arr: W2UI;\n// Just type assert\n(<InputControl>arr[\"input\"]).setValue();\n// N.B. still typesafeish\n(<HTMLDivElement>arr[\"nope\"]).blur(); // Error, can't convert HTMLDivElement to ...\n\n// Use some actual sanity checking\nconst x = arr['layout'];\nif(x instanceof TabControl) {\n  x.tabMethod();\n}\n```\n"
      },
      {
        "user": "Ptival",
        "created_at": "2016-03-03T05:53:14Z",
        "body": "Ok, that's what I though of initially but was annoyed to have to cast every time. I can't think of a better way to do it though. Thanks for the quick feedback!\n"
      }
    ]
  },
  {
    "number": 7314,
    "title": "Feature request: TypedClassDescriptor",
    "created_at": "2016-03-01T12:15:53Z",
    "closed_at": "2016-03-29T05:01:12Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/7314",
    "body": "Could it be possible to implement TypedClassDescriptor which works similar to TypedPropertyDescriptor, which could give access to e.g. class type name?\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/7314/comments",
    "author": "sondreb",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2016-03-01T20:34:40Z",
        "body": "I would be interested to know how you will be using the instance type in the decorator.. but this should give you access to the type:\n\n``` ts\ndeclare type Class<T> = {\n    new (...args: any[]): T;\n    prototype: T;\n};\n\nfunction dec<T>(target: Class<T>) {\n    var instance: T;\n    return target\n}\n\n@dec\nclass C {\n}\n```\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2016-03-29T05:01:12Z",
        "body": "please reopen if the issue has not been addressed.\n"
      }
    ]
  },
  {
    "number": 7273,
    "title": "Any plans to refactor typescript to modular structure ?",
    "created_at": "2016-02-27T09:02:58Z",
    "closed_at": "2016-02-29T01:21:11Z",
    "labels": [
      "Question",
      "Infrastructure"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/7273",
    "body": "Guys do you have any plans to refactor TypeScript to modular structure ? \n\nCurrently very hard to review and contribute the files with 15K lines. \n\nPS: thanks for such a great tool. \n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/7273/comments",
    "author": "casser",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2016-02-27T20:30:32Z",
        "body": "Well.. these are two different things. refactoring to modules does not necessary mean that checker.ts will be smaller :).\n\nfor the modular side, yes, we would like to do that at some point; if we were to start writing TS today we would definitely have everything as a module. @weswigham did an experiment to split up the code base into modules and there were a couple of pieces we need in place to make the change happen, namely declaration flattening.\n\nfor the size, this is something we talk about a lot. there are pieces that we can split up from the checker to make it smaller, and we have plans to do that, but id not think it is going to shrink much in the long run.\n"
      },
      {
        "user": "casser",
        "created_at": "2016-02-28T11:45:41Z",
        "body": "So this will not come in near Roadmap :) \n\nThanks for answer\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2016-02-29T01:21:11Z",
        "body": "Both issues are on our minds, but no concrete plans at the time being.\n"
      }
    ]
  },
  {
    "number": 7242,
    "title": "Duplicate identifier when using `export import ... = ...` with interfaces only",
    "created_at": "2016-02-25T20:33:00Z",
    "closed_at": "2016-05-20T06:10:30Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/7242",
    "body": "In a `.d.ts` file, I have the following:\n\n``` ts\nimport * as interfaces from './interfaces';\n\ndeclare module sequelize {\n  export import Promise = interfaces.Promise;\n}\ndeclare var sequelize: interfaces.Static;\n\nexport = sequelize;\n```\n\nI'm getting an error saying \"duplicate identifier 'sequelize'\". \nI think this might not be the best way of doing things, but I couldn't find any other way.\nWhat I want to achieve is exporting the `sequelize` variable using `export =` syntax while also exporting some interfaces using `declare module`.\n\nIf I do this instead it works fine:\n\n``` ts\nimport * as interfaces from './interfaces';\n\ndeclare module sequelize {\n  type Promise<T> = interfaces.Promise<T>;\n}\ndeclare var sequelize: interfaces.Static;\n\nexport = sequelize;\n```\n\nbut I don't want to use types because you cannot extend a type. another option is:\n\n``` ts\nimport * as interfaces from './interfaces';\n\ndeclare module sequelize {\n  interface Promise<T> extends interfaces.Promise<T> {}\n}\ndeclare var sequelize: interfaces.Static;\n\nexport = sequelize;\n```\n\nwhich works fine but is very confusing. Is there a better way to achieve this?\nOn a side note, it's very confusing to me how there are two types of modules. The one with `export`s and the one that's a namespace.\nA better title for this issue is probably _cannot re-export interfaces in `declare module` without switching its type to object_\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/7242/comments",
    "author": "louy",
    "comments": [
      {
        "user": "louy",
        "created_at": "2016-02-25T20:47:45Z",
        "body": "Also this works fine, which means the issue only affects using `export import ...`, not `export ...` by itself.\n\n``` ts\nimport * as interfaces from './interfaces';\n\ndeclare module sequelize {\n  export type Promise<R> = interfaces.Promise<R>;\n  // or\n  // export interface Promise<R> extends interfaces.Promise<R> {}\n}\ndeclare var sequelize: interfaces.Static;\n\nexport = sequelize;\n```\n"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2016-02-25T20:50:34Z",
        "body": "What is the content of the `./interfaces` module?\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2016-02-25T20:51:00Z",
        "body": "imports make a module instantiated. this is why it conflicts with your var.\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2016-02-25T20:52:17Z",
        "body": "This is done in a binding phase early on. and at that time we have no idea what the import will resolve to. \n"
      },
      {
        "user": "louy",
        "created_at": "2016-02-26T00:36:41Z",
        "body": "**interfaces.d.ts** has something like this:\n\n``` ts\nexport interface Promise<T> {/*...*/}\nexport interface Static {/*...*/}\n```\n"
      },
      {
        "user": "louy",
        "created_at": "2016-02-26T00:43:19Z",
        "body": "so this behaviour of instantiated vs non-instantiated modules is really confusing. I also don't think it's documented, but anyway...\nin my opinion there should be a way to re-export interfaces/types easily. something like this:\n\n``` ts\nimport Promise = interfaces.Promise;\ndeclare module sequelize {\n  export {Promise}; // can be a type or an interface\n}\n```\n\nmy problem with using `export import ...` vs `export interface Promise extends interfaces.Promise {}` is that I always have to specify type params in both places when using the latter, and that it's much longer and isn't clear that I'm only re-exporting, not creating something new.\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2016-02-26T01:10:57Z",
        "body": "My only comment is i think the use of `export=` is what is complicating things.. if all what you want to do is reexport, then `export { Promise } from './interfaces';` should do the trick. \n"
      }
    ]
  },
  {
    "number": 7214,
    "title": "Async/Await generated code doesn't rethorw the error caught",
    "created_at": "2016-02-24T12:39:15Z",
    "closed_at": "2016-02-24T18:28:49Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/7214",
    "body": "I am using async/await functionality in my nodejs app, when i see the the _awaiter generated code its like\n\n``` js\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator.throw(value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments)).next());\n    });\n}\n```\n\nthe problem arises when i throw an error from inside an async function then according to the genreated code the fulfilled and rejected function catches and the same and doesn't rethrows it back ,so my application could catch the required error which i had thrown from the particular async function, is this being made by design ??\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/7214/comments",
    "author": "pranaydutta89",
    "comments": [
      {
        "user": "Arnavion",
        "created_at": "2016-02-24T18:17:46Z",
        "body": "The exception thrown from the async function is used to reject the Promise returned by the async function (as you already noticed). That's how async functions work - they return a Promise that will be resolved to the final value or rejected with any error that happened.\n\nIf your calling code uses `await func()` then `await` will either return the final value or rethrow the exception. If your calling code uses `then()` with callbacks then you would have something like `func().then(result => /* result is the final value */, err => /* err is the exception */)`\n"
      }
    ]
  },
  {
    "number": 7105,
    "title": "Type inference on ternary-selected promises fails",
    "created_at": "2016-02-17T00:23:27Z",
    "closed_at": "2016-02-17T20:01:57Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/7105",
    "body": "Example:\n\n``` typescript\nlet x = {then(cb: (x: string)=>any) { cb('x'); }};\nlet y = {then(cb: (x: Object)=>any) { cb({}); }};\n\n(Math.random() < .5 ? x : y).then((z) => z); // z is string\n(Math.random() < .5 ? y : x).then((z) => z); // z is Object\n```\n\n`z` should probably be `string | Object` in both cases.\n\nMight be related, but if I have x: number in the second function above, the last lines fail with \"Cannot invoke an expression whose type lacks a call signature\", which is weird.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/7105/comments",
    "author": "calebegg",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2016-02-17T00:56:40Z",
        "body": "In general you should never declare things as `Object`, it rarely does what you want (for example, `string` is assignable to `Object`). See #1809.\n\nThe primary issue is that `Object` is a supertype of `string`, and function parameters are bivariant (see the entry in the FAQ), so the type of `x` is assignable to `y` and the type of `y` is assignable to `x`, so we're basically just picking the first one here when resolving the type of `expr ? x: y`.\n\nThe related issue is because call signatures don't appear on union types unless the signatures are identical. See #5640\n"
      }
    ]
  },
  {
    "number": 7095,
    "title": "Occurrence typing for array element",
    "created_at": "2016-02-16T15:43:26Z",
    "closed_at": "2016-02-19T23:11:12Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/7095",
    "body": "[Sorry about the title, \"occurrence typing\" is the Typed Racket term for this feature, and I haven't seen a name for it in the TypeScript docs.]\n\nThis doesn't work:\n\n```\nfunction foo(...xs: (number | (()=>number))[]): number {\n    if (typeof xs[0] === \"number\") return xs[0];\n    else return xs[0]();\n}\n```\n\nbut this does:\n\n```\nfunction foo(...xs: (number | (()=>number))[]): number {\n    var x = xs[0];\n    if (typeof x === \"number\") return x;\n    else return x();\n}\n```\n\nThis might be intentional if it's because `xs[0]` might return different value for things that are kind of like arrays but aren't, though it still surprised me since a rest argument should always be a plain array, so `xs[0]` should always be the same...?\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/7095/comments",
    "author": "elbarzil",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2016-02-16T16:15:22Z",
        "body": "Combination of intentional and simply not implemented (see issues mentioning type guards for property access).\n\nIn general we can't make very many safe assumptions about the content of a reference type. For example, this is basically equivalent, but we have no idea what `somethingSpecialHappens` might be doing to the array.\n\n``` ts\nfunction foo(...xs: (number | (()=>number))[]): number {\n    if (typeof xs[0] === \"number\") {\n      somethingSpecialHappens(xs);\n      return xs[0];\n    } else {\n      return xs[0]();\n    }\n}\n```\n"
      },
      {
        "user": "elbarzil",
        "created_at": "2016-02-16T16:37:42Z",
        "body": "Yeah, obviously handing out `xs` to someone else between the type testing and the use could break it; it's just that IME that happens much less frequently than referencing lists, so I was hoping that TS would check for such things and will work if there aren't any...\n"
      }
    ]
  },
  {
    "number": 7090,
    "title": "Union type of string literals",
    "created_at": "2016-02-16T09:28:30Z",
    "closed_at": "2016-02-16T10:47:29Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/7090",
    "body": "With TypeScript 1.8, this code fails:\n\n```\ntype SomeString = ('string1' | 'string2') & ('string3' | 'string4');\nconst x: SomeString = 'string1';\n```\n\nWith the following error: `Type 'string' is not assignable to type '(\"string1\" | \"string2\") & (\"string3\" | \"string4\")'. Type 'string' is not assignable to type '\"string1\" | \"string2\"'. Type 'string' is not assignable to type '\"string2\"'`.\n\nIs this by design? Should it not be possible to use unions for string literal types?\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/7090/comments",
    "author": "andersekdahl",
    "comments": [
      {
        "user": "yortus",
        "created_at": "2016-02-16T10:36:42Z",
        "body": "The following _does_ work:\n\n``` typescript\ntype SomeString = 'string1' | 'string2' | 'string3' | 'string4';\nconst x: SomeString = 'string1';\n```\n\nSo it is possible to use unions for string literal types. Your example is an intersection, which `'string1'` cannot possibly satisfy, because it must simultaneously satisfy `'string3'|'string4'`, which it clearly can't.\n\nThe error message you are getting from tsc is not very helpful in this case.\n"
      },
      {
        "user": "andersekdahl",
        "created_at": "2016-02-16T10:47:29Z",
        "body": "Ah, completely mixed up union and intersection types, sorry!\nClosing this because brain fart.\n"
      }
    ]
  },
  {
    "number": 7085,
    "title": "Strict object literal check fails when infered to type containing string literal type",
    "created_at": "2016-02-15T12:35:20Z",
    "closed_at": "2016-02-16T04:15:49Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/7085",
    "body": "Hi,\nThis issue might be linked to #6167 ( particularly widening i guess) or #6554,  but i did not find any details the bellow case: \n\n``` typescript\n\ninterface Test {\n    value: string;\n    comparator:\"equals\"|\"isGreater\";\n}\n\nfunction applyTest(value: string, testval:Test) {\n    return \"ok\";\n}\n\nlet tt = {value: \"test\", comparator:\"equals\"};\napplyTest(\"ko\",tt);\n\n```\n\nwhen i compile using tsc (typescript@1.9.0-dev.20160215) i get a warning\n\n```\ntest.ts(11,16): error TS2345: Argument of type '{ value: string; comparator: string; }' is not assignable to parameter of type 'Test'.\n  Types of property 'comparator' are incompatible.\n    Type 'string' is not assignable to type '\"equals\" | \"isGreater\"'.\n      Type 'string' is not assignable to type '\"isGreater\"'.\n```\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/7085/comments",
    "author": "erichillah",
    "comments": [
      {
        "user": "weswigham",
        "created_at": "2016-02-15T21:06:57Z",
        "body": "Apply a type annotation such as `let tt: Test = { ... }`. TS only infers string literal types in type positions and when contextually appropriate based on type information. Since TS doesn't do use-site analysis, `tt` gets typed soled by its definition, which is `{value: string, comparator: string}`, as there's no casts/annotations indicating it should use a literal type.\n"
      }
    ]
  },
  {
    "number": 7084,
    "title": "Suggestion: Typing module values",
    "created_at": "2016-02-15T11:49:29Z",
    "closed_at": "2016-02-15T12:08:53Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/7084",
    "body": "I don't know if this was considered yet but since we can pass around modules as values why not offer the ability to specify module types in variables/function signatures?\n\n``` typescript\nmodule Foo {    \n    export function bar(a: number, b: number): number {\n        return a + b;\n    }\n}\n\nfunction foo2(moduleFoo: <ModuleType>) {\n    ...\n}\n```\n\nKind regards.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/7084/comments",
    "author": "pdhborges",
    "comments": [
      {
        "user": "ivogabe",
        "created_at": "2016-02-15T11:57:50Z",
        "body": "You can already use `typeof Foo`. Is that what you're looking for?\n"
      },
      {
        "user": "pdhborges",
        "created_at": "2016-02-15T12:08:53Z",
        "body": " @ivogabe Ah! That's enough to cover my use cases.\n\nThanks!\n"
      }
    ]
  },
  {
    "number": 7023,
    "title": "\"Go to Definition\" can't run when method declarations",
    "created_at": "2016-02-11T11:19:35Z",
    "closed_at": "2016-02-12T18:31:48Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/7023",
    "body": "_From @lv7777 on February 9, 2016 13:47_\n\n``` javascript\nlet foo= function(){\n}\nfoo;\n```\n\nabove code can right,but\n\n``` javascript\nlet obj;\nobj.foo= function(){\n}\nfoo;\n```\n\ncan't f12\n\n_Copied from original issue: Microsoft/vscode#2842_\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/7023/comments",
    "author": "dbaeumer",
    "comments": [
      {
        "user": "dbaeumer",
        "created_at": "2016-02-11T11:19:36Z",
        "body": "IMO foo can't be f12 since foo is unknown in the second example. foo only exists as a property of obj. Moving to TS repository for final closing.\n"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2016-02-12T18:31:47Z",
        "body": "Go To Definition doesn't work on string matching (nor should it IMO)\n"
      }
    ]
  },
  {
    "number": 7018,
    "title": "Suggestion regarding --noCustomAsyncPromise",
    "created_at": "2016-02-11T08:48:13Z",
    "closed_at": "2016-02-11T09:39:37Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/7018",
    "body": "The `--noCustomAsyncPromise` switch was just introduced #6967.\n\nES7 async functions cannot return custom promises, but their TypeScript counterparts can. This switch makes it so that TypeScript's non-compliant async function behaviour is the default, and anyone wanting to maintain ES-compliant code has to provide this switch.\n\nWhy not have an `--allowCustomAsyncPromise` instead? Then anybody can opt in to TypeScript's custom async function behaviour, but is made more aware they are doing something special/non-standard because they need to provide the flag.\n\nThe current polarity of the flag may encourage a great deal more inadvertent use of this non-standard behaviour, causing greater pain down the line when async functions gain better runtime support and adoption. I think it would be prudent to put the non-standard behaviour behind a flag, and make standard behaviour the default.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/7018/comments",
    "author": "yortus",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2016-02-11T09:39:37Z",
        "body": "Please note this is a 1.8-only flag, and will not exist after that. it is not documented. you are welcome to use it for now if you would like your project to be checked more stricktelly.\nThe change was a breaking change that broke multiple customers. there is no easy way now to use it async/await with ES5 nor to redefine Promise if you are using ES6. we are working on these for the next release. once that is done the breaking change should be easily avoided by either switching to ES5 or redefining the Promise value.\n"
      },
      {
        "user": "yortus",
        "created_at": "2016-02-11T09:42:14Z",
        "body": "Cool, thanks for clarifying.\n"
      }
    ]
  },
  {
    "number": 6965,
    "title": "Language services debug assertion when switching compiler options",
    "created_at": "2016-02-08T19:26:09Z",
    "closed_at": "2016-02-19T20:14:15Z",
    "labels": [
      "Question",
      "API"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/6965",
    "body": "Suppose you are writing a client of the LanguageService that provides a LanguageServiceHost that implements getCompilationSettings to return CompilerOptions that target ScriptTarget.ES5.\n\nIf you compile once, then change getCompilationSettings to instead target ScriptTarget.ES6 -- that is, if you dynamically switch the targeted language -- you'll eventually fall into the below code path and hit the debug assertion seen in the snippet.\n\nHowever, it appears the below code after the debug assertion is attempting to correctly handle the case where the settings have changed.  So I think that the debug assertion is unnecessary and should be removed.\n\nThis issue can also be worked around by recreating the whole stack of LanguageServiceHost from scratch when the compilation target changes, but that seems like it might be slow.  It's potentially the case that clients should expect to recreate this object in that scenario, but then it's not clear why the below code handles the missing entry.\n\nFeel free to tell me I'm using the API wrong, or whether a reproduction test case would be useful (I pulled this out of a much larger program so reducing it will be a bit painful).\n\n``` javascript\n        function acquireOrUpdateDocument(fileName, compilationSettings, scriptSnapshot, version, acquiring) {\n            var bucket = getBucketForCompilationSettings(compilationSettings, /*createIfMissing*/ true);\n            var path = ts.toPath(fileName, currentDirectory, getCanonicalFileName);\n            var entry = bucket.get(path);\n            if (!entry) {\n                ts.Debug.assert(acquiring, \"How could we be trying to update a document that the registry doesn't have?\");\n                // Have never seen this file with these settings.  Create a new source file for it.\n                var sourceFile = createLanguageServiceSourceFile(fileName, scriptSnapshot, compilationSettings.target, version, /*setNodeParents*/ false);\n                entry = {\n                    sourceFile: sourceFile,\n                    languageServiceRefCount: 0,\n                    owners: []\n                };\n                bucket.set(path, entry);\n            }\n```\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/6965/comments",
    "author": "evmar",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2016-02-19T20:14:14Z",
        "body": "The system assumes that files and compilation settings are not mutable. there are places that are built on this assumption. creating a new LS object is the correct way to go. the system is wired to make this a cheap operation, by caching SourceFile objects, and reusing them.\n"
      }
    ]
  },
  {
    "number": 6919,
    "title": "Issue with \"as\" keyword when target type uses union types for properties",
    "created_at": "2016-02-05T10:59:59Z",
    "closed_at": "2016-02-19T23:29:21Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/6919",
    "body": "From what I understand, the as keyword allows you to omit properties... but it doesn't seem to work when union types are involved...\n\n```\ninterface Foo {\n  foo: string;\n  bar: Bar;\n  baz: Baz;\n  union: Bar | Baz;\n}\ninterface Bar {\n  bar: string;\n}\ninterface Baz {\n  baz: string;\n}\n\nlet this_works = {\n  foo: 'hello'\n} as Foo;\n\nlet this_also_works1 = {\n  bar: { bar: 'hello' }\n} as Foo;\n\nlet this_also_works2 = {\n  baz: { baz: 'hello' }\n} as Foo;\n\nlet union_cant_be_assigned_unless_all_other_properties_assigned = {\n  union: { bar: 'hello' }\n} as Foo;\n```\n\nI've tested on TypeScript 1.7.5 (current release) and typescript@next (Version 1.9.0-dev.20160205)\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/6919/comments",
    "author": "massimocode",
    "comments": [
      {
        "user": "ahejlsberg",
        "created_at": "2016-02-05T14:36:02Z",
        "body": "This is a known issue. We have a fix in #5517 but we haven't decided if we really want to introduce a third kind of type relation.\n\nIn last example the issue is that neither `{ union: { bar: string } }` nor `Foo` is assignable to the other. You can work around the problem by adding another `as`:\n\n``` typescript\nlet union_cant_be_assigned_unless_all_other_properties_assigned = {\n  union: { bar: 'hello' } as Bar | Baz\n} as Foo;\n```\n"
      },
      {
        "user": "massimocode",
        "created_at": "2016-02-05T15:01:21Z",
        "body": "Hi Anders, thanks for your reply and also for all the hard work on C#/TypeScript!\n\nWhen I raised this I was basically thinking to myself \"ok so I have defined the 'union' property with a valid value of a type that it allows (Bar or Baz)... just as if I were to define only the foo property with a valid value of a type that it allows (string)\"... i.e. I feel like the logic for the \"as\" keyword doesn't check if the value I'd given to the \"union\" property was a valid Bar or a valid Baz... instead it seems to be looking for something of type \"Bar | Baz\" (as you stated) which isn't really going to exist in an object literal without some kind of manual coercion\n\nI'm not really sure if it needs a new kind of type relation or if it's just an issue with the existing type relations, but just wanted to state my thought trail in case it was of any help\n"
      }
    ]
  },
  {
    "number": 6897,
    "title": "Type casting seems impossible in a React TSX file",
    "created_at": "2016-02-04T07:45:36Z",
    "closed_at": "2016-02-04T07:56:25Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/6897",
    "body": "It appears I can't use type casting in React TSX files.\n\nSay I have this expression in some method of the React TSX component:\n\n`var editTitle = <EditableField>this.refs['editTitle'];`\n\nThis line is supposed to be: fetch the child component ref'd as \"editTitle\" and cast it to the type EditableField, so that I can then access methods of EditableField in a strongly-typed manner.\n\nBut the typescript compiler appears to be treat that cast expression as a React element creation expression instead, being inside a TSX file and all.\n\nIs it even possible to cast objects inside a React TSX component?\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/6897/comments",
    "author": "jumpinjackie",
    "comments": [
      {
        "user": "jumpinjackie",
        "created_at": "2016-02-04T07:49:13Z",
        "body": "Ok, it appears I can use the `as` operator to do this. If direct casting via `<>` is not possible, then feel free to close.\n"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2016-02-04T07:56:23Z",
        "body": "Yup, we introduced the `as` operator for this. It's usable in both `.ts` and `.tsx` files.\n"
      },
      {
        "user": "beclamide",
        "created_at": "2018-05-03T09:59:45Z",
        "body": "For completeness in case anyone stumbles across this page. This is the correct way to inline cast in TSX.\r\n\r\n```typescript\r\n(myObject as ObjectType).myProperty = 'foo';\r\n```"
      }
    ]
  },
  {
    "number": 6830,
    "title": "qualified types in function header only with named parameter",
    "created_at": "2016-02-02T10:21:00Z",
    "closed_at": "2016-02-02T11:44:29Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/6830",
    "body": "This gives a compile error:\n\n```\n\nmodule b {\n  interface t {}\n}\n\nabstract class A {\n  abstract f(b.t) : void;\n}\n\n```\n\nThis compiles:\n\n```\n\nmodule b {\n  interface t {}\n}\n\nabstract class A {\n  abstract f(x : b.t) : void;\n}\n\n```\n\nQualifying the type t makes it necessary to name the parameter of the function although this should not be necessary.\n\nThis again works:\n\n```\n\nmodule b {\n  interface t {}\n}\n\nabstract class A {\n  type t = b.t;\n  abstract f(t) : void;\n}\n\n```\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/6830/comments",
    "author": "fphh",
    "comments": [
      {
        "user": "fphh",
        "created_at": "2016-02-02T10:30:27Z",
        "body": "I use compiler version 1.7.5.\n"
      },
      {
        "user": "Arnavion",
        "created_at": "2016-02-02T10:57:46Z",
        "body": "That last example doesn't do what you think it does. `abstract f(t) : void` doesn't define a method which takes one parameter of type `t`, it defines a method which takes one parameter of type `any`.\n\nIn general, signatures in TS (function signatures, indexer signatures, etc.) have parameter name required and type optional. So reversing this for abstract method signatures will just cause confusion.\n\nAlso having parameter names is descriptive. And if you want to attach JSDoc you need to have a parameter name.\n"
      },
      {
        "user": "fphh",
        "created_at": "2016-02-02T11:44:29Z",
        "body": "Yes, I see my mistake. However it is strange that parameter names are mandatory and parameter types are optional. Note that we define already the arity of the function, and, thus, a partial type for it. Why not defining the whole type and making the parameter names optional? I think, that's a design question and I consider this issue closed.\n"
      },
      {
        "user": "Arnavion",
        "created_at": "2016-02-02T18:23:40Z",
        "body": "As I said, everywhere else parameter names are required and types optional.\n\nDefining a function - `function foo(a, b) { }` or `function foo(a: number, b: string) { }`\nDefining a method - `class Foo { bar(a, b) { } }` or `class Foo { bar(a: number, b: string) { } }`\n\nSo as I said it would be confusing to change the rules only for abstract methods and make it that `abstract bar(a, b)` means a and b are types.\n"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2016-02-02T18:40:37Z",
        "body": "Please read the FAQ.\n"
      }
    ]
  },
  {
    "number": 6809,
    "title": "Disallow export-assignment modules to be imported with `import * as from` ?",
    "created_at": "2016-02-02T00:26:46Z",
    "closed_at": "2016-02-20T04:46:39Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/6809",
    "body": "While `import * as foo from \"foo\";` compiles to `var foo = require(\"foo\");` (and equivalent for AMD) and thus works as a way to use export-assignment modules, the ES6 spec does not define this behavior. Instead the spec requires that `foo` be an immutable namespace object that only contains the exports of the module as properties.\n\nDo you think it's worth disallowing the use of `import * as Foo from \"./foo\"` for export-assignment modules?\n\nFor example, if foo.d.ts is\n\n``` typescript\ndeclare module \"foo\" {\n    function foo();\n    export = foo;\n}\n```\n\nOption 1: The compiler only allows it to be imported with `import foo = require(\"foo\");` and errors otherwise. The error message could also suggest using `import foo from \"foo\";` with `--allowSyntheticDefaultImports` and a suitable loader.\n\nOption 2: The compiler allows the ES6-style import but strips the `()` member, so the imported `foo` cannot be used as a function but other properties on it are still available. This is closer to the ES6 spec but will probably cause more user confusion. It also doesn't prevent the case where the export is of `any` type.\n\nIt is a breaking change, but there is precedent with the other recent breaking change to make ES6 imports immutable - that one was also based on an ES6 spec interpretation of not-necessarily-ES6 modules.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/6809/comments",
    "author": "Arnavion",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2016-02-02T01:04:35Z",
        "body": "We actually did 1. initially. but the issue is most of the definitions on definitely typed are written with an `export=` (for reasons other than returning a class or a function for a module). and that made the ES6 module syntax unusable. so we relaxed the rule.\n\n2 is currently in place, so your example above is actually an error today?;\n\n``` cmd\n error TS2497: Module '\"foo\"' resolves to a non-module entity and cannot be imported using this construct.\n```\n\nthere is a caveat though. to allow for using the destructuring import pattern on modules written with `export=` (again for reasons other than returning a class or a function for a module),  this is allowed:\n\n``` ts\ndeclare module \"bar\" {\n    namespace B {\n         var a;\n    }\n    export = B;\n}\nimport {a} from \"bar\";\n```\n\nand as a side effect, the function call is also allowed. so:\n\n``` ts\ndeclare module \"foo\" {\n    function foo();\n   namespace foo {} // just add a namespace\n    export = foo;\n}\n\nimport * as n from \"foo\";\nn(); // OK\n```\n\nIdeally, we would want `export=` and `import .. =require` syntax to go away. it is not clear if and when they would though. so we are not investing in them, per se, but we can not disallow them outright as that will break a lot of code out there.\n"
      },
      {
        "user": "Arnavion",
        "created_at": "2016-02-02T01:28:44Z",
        "body": "> 2 is currently in place, so your example above is actually an error today?\n\nSorry, yes you're right my example is an error without the `namespace foo { }` hack that you said. It's fine to be able to do `import * as n from \"foo\";` with that hack, but `n()` is against ES6 spec.\n\n> Ideally, we would want `export=` and `import .. =require` syntax to go away. it is not clear if and when they would though. so we are not investing in them, per se, but we can not disallow them outright as that will break a lot of code out there.\n\nI wasn't asking to disallow the `import = require` syntax, so that's fine.\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2016-02-02T01:40:28Z",
        "body": "> with that hack, but n() is against ES6 spec.\n\nWe have talked about possibly flagging a the call expression as an error in ES6. but the feeling was it is not common, as modules move their exports to ES6, it will be harder to run into this issue.\n"
      },
      {
        "user": "Arnavion",
        "created_at": "2016-02-02T02:08:56Z",
        "body": "Are you sure it's not common? A lot of existing node libraries assign functions or classes to module.exports. I'm not sure if they will all change to ES6 exports.\n\nThere is #6656 just from last week with the same issue (export-assignment of a React element). The same hack was suggested to make it work with `import * as` _and_ it was tagged as a bug, instead of suggesting the correct way to use either `import = require` or default import + allowSyntheticDefaultImports.\n\nEven if you don't want to make it an error, atleast don't suggest the hack instead of the correct way?\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2016-02-02T07:45:46Z",
        "body": "default import + allowSyntheticDefaultImports only works if your loader does the trick. e.g. SystemJS. the emitted code does not change. so i do not think it works in the #6656, unless the user is using SystemJS. which does not seem to be the case.\n\nI think the main issue is we need to make commonJS emit/existing modules work with ES6 module syntax. i think things will become clearer when node have an ES6 module implementation along with some back-compat story.\n\nA true complaint ES6 module implementation would not have this issue anyways. so again it is only the interop issue, which is not clear yet, as there is no ES6 implementation yet.\n"
      },
      {
        "user": "Arnavion",
        "created_at": "2016-02-20T05:38:49Z",
        "body": "@mhegazy Why did you close this?\n"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2016-02-22T20:39:37Z",
        "body": "@Arnavion seems like you had a question that was answered. I think the best path forward would be a separate issue if you think there's something concrete that should happen.\n"
      },
      {
        "user": "Arnavion",
        "created_at": "2016-02-22T21:47:59Z",
        "body": "@RyanCavanaugh It was not a question. I asked for a change in the OP.\n"
      },
      {
        "user": "Arnavion",
        "created_at": "2016-02-22T21:57:56Z",
        "body": "To clarify, @mhegazy said that it's pending a real-life implementation of ES6 + ES5 modules interop to decide whether `import * as foo from \"foo\"` is legal where foo is an ES5 module. I can understand that, so it's okay that `foo.bar()` is legal.\n\nHowever it's still certain that `foo()` is an error, since the ES6 spec is unambiguous on the fact that `foo` is a ModuleNamespaceObject. So that should be disallowed to prevent users from writing ES6 code that's invalid ES6.\n"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2016-02-22T22:00:35Z",
        "body": "I think Mohamed addressed why we didn't do that\n"
      },
      {
        "user": "Arnavion",
        "created_at": "2016-02-22T22:05:47Z",
        "body": "So just to confirm, you're saying that it's okay that TS allows users to write ES6 code that's invalid ES6 ?\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2016-02-22T22:08:45Z",
        "body": "We should file an issue to issue an error for calling a namespace import.\n"
      }
    ]
  },
  {
    "number": 6806,
    "title": "Question: Interface with _at least one_ defined member?",
    "created_at": "2016-02-02T00:02:48Z",
    "closed_at": "2016-02-02T00:48:21Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/6806",
    "body": "In RxJS, we have a need for an interface that is basically this:\n\n``` TypeScript\ninterface Observer<T> {\n  next?: (value: T) => void;\n  error?: (err: any) => void;\n  complete?: () => void;\n}\n```\n\nbut you'll notice that it matches `{}` in that case, which isn't what we want. What we _really_ want is _at least one_ of those members.\n\nIt seems like I'd be able to do something with `PartialObserver<T> = NextObserver<T>|ErrorObserver|CompleteObserver`, but I'm honestly not sure how to accomplish this.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/6806/comments",
    "author": "benlesh",
    "comments": [
      {
        "user": "weswigham",
        "created_at": "2016-02-02T00:12:30Z",
        "body": "``` ts\ninterface NextObserver<T> {\n  next: (value: T) => void;\n}\ninterface ErrorObserver {\n  error: (err: any) => void;\n}\ninterface CompleteObserver {\n  complete: () => void;\n}\ntype Observer<T> = NextObserver<T> | ErrorObserver | CompleteObserver | (NextObserver<T> & ErrorObserver & CompleteObserver) | (ErrorObserver & CompleteObserver) | (NextObserver<T> & ErrorObserver) | (NextObserver<T> & CompleteObserver);\n```\n\nYou can enumerate the power set of interface combinations by hand, though I'll admit the definition is a little dense (and possibly more verbose than need be).\n"
      },
      {
        "user": "ahejlsberg",
        "created_at": "2016-02-02T00:26:34Z",
        "body": "Perhaps this?\n\n``` typescript\ninterface NextObserver<T> {\n  next: (value: T) => void;\n  error?: (err: any) => void;\n  complete?: () => void;\n}\ninterface ErrorObserver<T> {\n  next?: (value: T) => void;\n  error: (err: any) => void;\n  complete?: () => void;\n}\ninterface CompleteObserver<T> {\n  next?: (value: T) => void;\n  error?: (err: any) => void;\n  complete: () => void;\n}\ntype Observer<T> = NextObserver<T> | ErrorObserver<T> | CompleteObserver<T>;\n```\n"
      },
      {
        "user": "benlesh",
        "created_at": "2016-02-02T00:48:21Z",
        "body": "@ahejlsberg  ... that did it. Thank you!\n"
      },
      {
        "user": "benlesh",
        "created_at": "2016-02-02T00:49:49Z",
        "body": "Also, @weswigham I tried the same thing you recommended, and (just for informational purposes) it caused compilation errors on the consumption side.  `observer.next()` would say `\"next\" does not exist on  NextObserver<T> | ErrorObserver | CompleteObserver | (NextObserver<T> & ErrorObserver & CompleteObserver) | (ErrorObserver & CompleteObserver) | (NextObserver<T> & ErrorObserver) | (NextObserver<T> & CompleteObserver);` unless I cast it first.\n"
      },
      {
        "user": "weswigham",
        "created_at": "2016-02-10T09:55:23Z",
        "body": "Just realized I never came back to this - the intention of my definitions would be for a strongly typed observer which _requires_ checks for members before calls are allowed. Pair the definitions in my prior post with type guards like so:\n\n``` ts\nfunction hasNext<T, U extends Observer<T>>(o: U): o is NextObserver<T> {\n  return !!(o as NextObserver<T>).next;\n}\n\nfunction hasComplete<T, U extends Observer<T>>(o: U): o is CompleteObserver<T> {\n  return !!(o as any).complete;\n}\n\nfunction hasError<T, U extends Observer<T>>(o: U): o is ErrorObserver<T> {\n  return !!(o as any).error;\n}\n```\n\nAnd use like so:\n\n``` ts\nconst obs: Observer<Observee> = fetchObs();\nfor (i=1, i<3, i++) {\n  if (hasNext(obs)) {\n    try {\n      thing = doThing()\n    }\n    catch (e) {\n      if (hasError(obs)) {\n        return obs.error(e);\n      }\n    }\n    obs.next(thing);\n  }\n}\nif (hasComplete(obs)) {\n  obs.complete()\n}\n```\n\nI _think_ I've got the types right for that, but I can't claim to have tested it, as it makes use of TS 1.8's F-Bounded Polymorphism, so I can't just drop it into the playground to test it yet (and I'm away from my PC at the moment).\n"
      }
    ]
  },
  {
    "number": 6641,
    "title": "Generics in indexers",
    "created_at": "2016-01-27T13:55:22Z",
    "closed_at": "2016-01-27T16:30:36Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/6641",
    "body": "Hi,\n\nI was wondering why something like that is not possible:\n\n``` javascript\ninterface IDictionary<TKey, TValue> {\n  [index: TKey]: TValue;\n}\n```\n\nit tells me: index signature parameter must be string or number\n\nI agree, but why I could not get this error when trying to use something else than string or number as TKey? Generics are analyzed at build time right? if so, this should be easy to find.\n\n``` javascript\n  temp: IDictionary<number, ...>;\n```\n\nshould work.\n\nI could even do something like this, to be more precise:\n\n``` javascript\ninterface IDictionary<TKey extends string | number, TValue>\n```\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/6641/comments",
    "author": "pankleks",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2016-01-27T16:30:36Z",
        "body": "String indexers and number indexers have very different effects on the types they're contained in. They're not really interchangeable in any meaningful way, so it's pointless to make them able to be based on generic type parameters.\n\nPractically speaking, you really have two types: `IDictionaryString<T> { [s: string]: T }` and `IDictionaryNumber<T> { [n: number]: T }`. There's nothing gained by making them generic.\n"
      },
      {
        "user": "pankleks",
        "created_at": "2016-01-27T16:36:30Z",
        "body": "ok thanks.\n"
      }
    ]
  },
  {
    "number": 6622,
    "title": "export types not found",
    "created_at": "2016-01-26T13:19:47Z",
    "closed_at": "2016-01-29T22:46:40Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/6622",
    "body": "This might be a tad 'anti-typescript' but figured I throw it out anyway. I have a function that reads a array and dynamically creates exports like so:\n\n```\nconst methods = ['head', 'options', 'get', 'post', 'put', 'patch', 'del', 'delete', 'all']\nmethods.forEach(method => {\n  let methName = method.charAt(0).toUpperCase() + method.slice(1);\n  exports[`http${methName}`] = route.bind(null, method);\n});\n```\n\nFor obvs reasons, TypeScripts complains on compiling about this:\n\n```\n\u001b[100;30m\nsrc/api/ApplicationController.ts(1,22): error TS2305: Module '\"src/common/routing\"' has no exported member 'httpGet'.\n```\n\nIs there anything on the roadmap to do this type of dynamic / functional exports?\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/6622/comments",
    "author": "amcdnl",
    "comments": [
      {
        "user": "WreckedAvent",
        "created_at": "2016-01-26T14:13:50Z",
        "body": "You could do something like this:\n\n``` typescript\nconst methods = ['head', 'options', 'get', 'post', 'put', 'patch', 'del', 'delete', 'all'];\nconst toExport: {[action: string]: () => void} = {};\n\nmethods.forEach(method => {\n  let methName = method.charAt(0).toUpperCase() + method.slice(1);\n  toExport[`http${methName}`] = route.bind(null, method);\n});\n\nexport = toExport;\n```\n\nWhatever you type `toExport` to be should be what other files get from their `import`. \n"
      },
      {
        "user": "amcdnl",
        "created_at": "2016-01-29T15:18:36Z",
        "body": "@WreckedAvent  - I do other exports in the module, so I get a error saying like `export assignment can not be used with other export assignments...`\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2016-01-29T22:46:37Z",
        "body": "The shape of the module needs to be statically known. anything that is dynamic will not work. This is also the same semantics as ES6 modules. you are better of defining each as an export:\n\n``` ts\nexport const httpHead = route.bind(undefined, \"head\"); \n```\n\nthe other alternative, is you put these one level deeper inside the module:\n\n``` ts\nexport var exportedMethods: IMethods = {}\n\nmethods.forEach(method => {\n  let methName = method.charAt(0).toUpperCase() + method.slice(1);\n  exportedMethods[`http${methName}`] = route.bind(null, method);\n});\n```\n"
      },
      {
        "user": "amcdnl",
        "created_at": "2016-01-29T23:26:50Z",
        "body": "@mhegazy thanks!\n"
      }
    ]
  },
  {
    "number": 6612,
    "title": "Need eval() for Typescript.transpile()",
    "created_at": "2016-01-25T18:55:18Z",
    "closed_at": "2016-01-25T19:04:30Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/6612",
    "body": "In order to execute loaded code that is being transpiled using the api, would this be an appropriate use of eval()? transpile returns a string and in order to run the code I can't see any way around that. Just wanted to make sure :)\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/6612/comments",
    "author": "hydrotik",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2016-01-25T19:04:30Z",
        "body": "You could use `eval` or `new Function(\"code goes here\")`.\n\nBut anyway please use Stack Overflow for JS runtime questions.\n"
      }
    ]
  },
  {
    "number": 6543,
    "title": "Can't get to the instance type of a wrapped class across modules",
    "created_at": "2016-01-19T22:58:31Z",
    "closed_at": "2016-01-19T23:09:21Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/6543",
    "body": "Ran into this trying to leverage higher-order React components but it doesn't take much to reproduce:\n\nThing.ts\n\n``` typescript\nclass Thing { }\n\nfunction wrap<T>(classType: T): T {\n    return classType;\n}\n\nexport default wrap(Thing);\n```\n\nThingImporter.ts\n\n``` typescript\nimport Thing from \"./Thing\";\n\nlet thingInstance: Thing; //error: Cannot find name 'Thing'\nlet thingConstructor: typeof Thing; //ok\n```\n\nEven though the wrap function returns exactly what it takes in, the type gets changed from `class Thing` to `typeof Thing` and it seems this causes it to lose the class-reference-equals-instance-type magic in other modules.\n\nTS versions: 1.7.5 and 1.8.0-dev.20160119\ntsconfig:\n\n``` json\n{\n  \"compilerOptions\": {\n    \"module\": \"commonjs\",\n    \"target\": \"es5\"\n  }\n}\n```\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/6543/comments",
    "author": "jwbay",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2016-01-19T23:09:21Z",
        "body": "Thanks for reducing the repro.\n\nWhen we see an `export default` declaration, we expose \"all meanings\" of the expression on the right. The expression on the right, in this case, does not have any types, so there is no type meaning to expose.\n\nDoing a general purpose expansion of the right-hand side here is generally not tractable.\n\nIf you wanted to create a default export that had a type meaning, you could write something like this:\n\n``` ts\nclass _Thing { }\n\nfunction wrap<T>(classType: T): T {\n    return classType;\n}\n\nconst Thing: typeof _Thing = wrap(_Thing);\ntype Thing = _Thing;\nexport default Thing;\n```\n"
      },
      {
        "user": "jwbay",
        "created_at": "2016-01-19T23:29:38Z",
        "body": "Thanks for the quick reply! That works like a charm. I never would have thought to make an alias/local type with the same name as the actual export.\n\nFor anyone else who runs across this -- the root cause seems to be the wrap function and not so much the export. The same problem and fix applies within a single file.\n\n``` typescript\nfunction wrap<T>(classType: T): T {\n    return classType;\n}\n\nclass Thing { }\n\nconst ThingTwo = wrap(Thing);\nconst ThingThree = wrap(Thing);\ntype ThingThree = Thing;\n\nlet thingTwo: ThingTwo; //error: Cannot find name \"ThingTwo\"\nlet thingThree: ThingThree; //ok \n```\n"
      }
    ]
  },
  {
    "number": 6519,
    "title": "Discussion: Type casting and typing = position ambiguity",
    "created_at": "2016-01-17T11:10:47Z",
    "closed_at": "2016-01-17T17:19:40Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/6519",
    "body": "Hello,\n\nHere is my code example:\n\n```\nlet value : any;                   // ok javascript like \n(<string[]>value).length     // why not (value<string[]>).length\n```\n\n< string[] > value is more c# like : (string[])value in c#\n\nWhy not using a javascript style for typing and type casting: always put typing at the end of the expression ? (I mean \"javascript style\" because :any signature seems to be adopted)\n\nThanks in advance for your answers.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/6519/comments",
    "author": "Alphapage",
    "comments": [
      {
        "user": "ahejlsberg",
        "created_at": "2016-01-17T17:18:20Z",
        "body": "We already support postfix type assertions using the `as` operator, so if you prefer that you can simply write `(value as string[]).length`.\n"
      },
      {
        "user": "Alphapage",
        "created_at": "2016-01-17T18:29:58Z",
        "body": "Thank you. You learn me something. +1\n"
      }
    ]
  },
  {
    "number": 6473,
    "title": "XMLHttpRequest declaration",
    "created_at": "2016-01-14T02:01:31Z",
    "closed_at": "2016-01-14T03:19:19Z",
    "labels": [
      "Question",
      "Domain: lib.d.ts"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/6473",
    "body": "Hi.\n\nI was wondring if there is a reason to why the declaration of XMLHttpRequest in lib.d.ts is not declared like this:\n\n``` typescript\ninterface XMLHttpRequestConstructor {\n    prototype: XMLHttpRequest;\n    new(): XMLHttpRequest;\n    DONE: number;\n    HEADERS_RECEIVED: number;\n    LOADING: number;\n    OPENED: number;\n    UNSENT: number;\n    create(): XMLHttpRequest;\n}\ndeclare var XMLHttpRequest: XMLHttpConstructor\n```\n\nbut instead the declaration in lib.d.ts is:\n\n``` typescript\ndeclare var XMLHttpRequest: {\n    prototype: XMLHttpRequest;\n    new(): XMLHttpRequest;\n    DONE: number;\n    HEADERS_RECEIVED: number;\n    LOADING: number;\n    OPENED: number;\n    UNSENT: number;\n    create(): XMLHttpRequest;\n}\n```\n\nIs this by design and if so why?\n\n/Mikkel Snitker\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/6473/comments",
    "author": "MikkelSnitker",
    "comments": [
      {
        "user": "DanielRosenwasser",
        "created_at": "2016-01-14T03:19:19Z",
        "body": "By declaring an interface, a user can augment the type if they feel it is appropriate to do so.\n\n``` ts\ninterface XMLHttpConstructor {\n    // augment with overloads and fields here\n}\n```\n"
      }
    ]
  },
  {
    "number": 6463,
    "title": "Cannot define type while destructuring in a $q.all ",
    "created_at": "2016-01-13T13:43:49Z",
    "closed_at": "2016-01-13T22:49:17Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/6463",
    "body": "<pre>\n$q.all([\n  IPromise&lt;type does not work here&gt;promise1,\n  promise2\n])\n.then([result1: &lt;can't define type here as well&gt;, result2] => { }`\n</pre>\n\n\nI have tried to type cast promise and tried to define type in `.then` as well and it still gives error. I have tried with simple function as well and it does not work for simple functions as well.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/6463/comments",
    "author": "khagesh",
    "comments": [
      {
        "user": "kitsonk",
        "created_at": "2016-01-13T18:57:11Z",
        "body": "These are best for other forums, like StackOverflow or gitter.im.\n\nYou need to understand tuple types in TypeScript better.\n\n``` typescript\n$q.all([ promise1, promise2 ])\n    .then(( [ result1, result2 ]: [ string, string ] ) => { });\n```\n"
      },
      {
        "user": "khagesh",
        "created_at": "2016-01-14T10:17:16Z",
        "body": "@kitsonk Sorry, I did not know we could do something like this and thought it might be a bug. Thanks for reply.\n"
      }
    ]
  },
  {
    "number": 6397,
    "title": "signature overloading breaking change?",
    "created_at": "2016-01-08T10:19:20Z",
    "closed_at": "2016-01-08T16:56:19Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/6397",
    "body": "Looks like that in 1.7.5 overloading order became significant in some cases\n\n1) specific first\n\n``` TypeScript\ndeclare class A {\n    f(x:string): any;\n    f(x:{[key: string]: any}): A;\n}\n\nvar a: A;\nvar x = a.f(\"A\") + 1;  // OK in both TS 1.7.5 and TS 1.5.3\n```\n\n2) specific second\n\n``` TypeScript\ndeclare class A {\n    f(x:{[key: string]: any}): A;\n    f(x:string): any;\n}\n\nvar a: A;\nvar x = a.f(\"A\") + 1; // Fails on TS 1.7.5 (Worked on 1.5.3). Inferred f result as A\n```\n\nIs it by design?\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/6397/comments",
    "author": "Artazor",
    "comments": [
      {
        "user": "ahejlsberg",
        "created_at": "2016-01-08T14:59:12Z",
        "body": "Yes, it is by design. Specifically, it is an effect of the change in #4074.\n"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2016-01-08T16:56:19Z",
        "body": "Overloading has always been order-sensitive -- the first signature that matches is the one that's selected.\n\nRecommended fix would be to replace `[key: string]: any` with `[key: string]: {}`\n"
      },
      {
        "user": "Artazor",
        "created_at": "2016-01-08T23:01:58Z",
        "body": "@ahejlsberg, @RyanCavanaugh - thank you for explanation\n"
      }
    ]
  },
  {
    "number": 6380,
    "title": "UMD output option for single file",
    "created_at": "2016-01-06T22:20:24Z",
    "closed_at": "2016-02-20T01:12:03Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/6380",
    "body": "It seems like TypeScript 1.8 will support a single file option for AMD and SystemJS. Adding UMD support as well would be great.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/6380/comments",
    "author": "pspeter3",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2016-01-07T00:05:04Z",
        "body": "A single file output does not really make much sense for node/CommonJS. UMD is just a wrapper around AMD/CommonJS. commonJS require implementation can not load a module from the same file anyways. so you have to use a custom loader, if so, just use AMD/SystemJS to do the trick.\n"
      },
      {
        "user": "chge",
        "created_at": "2016-10-01T09:04:47Z",
        "body": "TypeScript is so useful tool due to its cross-platform abilities out-of-the box.\n\nIf you want to create a lib for browsers, it's a sign of good taste to use UMD wrapper around your code to support any user's toolchain. But currently you have to connect TypeScript with other tools and then mess around trying to fix `mkdir -p` or glob issues in Windows shell with additional plugins or forks of popular bundlers. Why to increase dependencies with heavyweight build systems and runners, instead of using one-line npm script `tsc --module umd --watch --outFile ...`?\n\nThis is a very useful feature, please implement it.\n"
      },
      {
        "user": "aluanhaddad",
        "created_at": "2016-10-02T09:47:55Z",
        "body": "@chge CommonJS means that is not viable option as @mhegazy explained. \n"
      }
    ]
  },
  {
    "number": 6360,
    "title": "Cannot use type that is re-exported by another module",
    "created_at": "2016-01-05T16:29:34Z",
    "closed_at": "2016-01-05T17:49:45Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/6360",
    "body": "I'm trying to re-export a class from a module `bar.ts` that has been imported from `foo.ts`. The class itself is usable but its type cannot be used for declaring variables. I'm using latest typescript 1.8.0-dev.20160105 from npm:\n\nfoo.ts (type definition):\n\n```\nexport class Foo {\n}\n```\n\nbar.ts (type re-export):\n\n```\nexport = {\n  Foo: require('./foo')\n};\n```\n\nqux.ts (type usage):\n\n```\nimport Bar = require('./bar');\nvar foo: Bar.Foo;\n```\n\ntsconfig.json:\n\n```\n{\n  \"compilerOptions\": {\n    \"target\": \"es6\",\n    \"module\": \"commonjs\"\n  }\n}\n```\n\nThe actual error:\n\n```\n$ tsc\nqux.ts(2,10): error TS2503: Cannot find namespace 'Bar'.\n```\n\nI haven't found a way to re-export a type. It's useful for me to split up several database models in multiple files, and then aggregate all of them in a single file. However actually I'm losing the types.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/6360/comments",
    "author": "lucabrunox",
    "comments": [
      {
        "user": "DanielRosenwasser",
        "created_at": "2016-01-05T17:00:12Z",
        "body": "With `bar.ts`:\n\n``` ts\nexport = {\n  Foo: require('./foo')\n};\n```\n\nWe don't recognize that as `require` as an import form, so there's no type/namespace side that we know of.\n\nInstead, I'd suggest you use an ES2015 style export:\n- New `bar.ts`\n  \n  ``` ts\n  export { Foo } from \"./foo\";\n  ```\n\nWhile you're at it, you might as well use a new import form in `qux.ts` as well:\n\n``` ts\nimport * as Bar from \"./bar\";\nlet foo: Bar.Foo;\n```\n"
      },
      {
        "user": "lucabrunox",
        "created_at": "2016-01-05T17:07:35Z",
        "body": "Yeah I understand the problem, thanks for the answer.\n\nUsing `import * as Bar from \"./bar\"` gives `qux.ts(1,22): error TS2497: Module '\"bar\"' resolves to a non-module entity and cannot be imported using this construct.`.\n\nWhile for `export { Foo } from \"./foo\";`, I don't have a `Foo` inside `foo.ts`, it's an `export =`.\n"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2016-01-05T17:39:15Z",
        "body": "If you really need to keep it as an `export =`, you'll need to use the old-style imports like so:\n\n``` ts\nexport import Foo = require(\"./foo\");\n```\n\nfor `foo.ts`.\n\nIf you use a module loader that automatically fixes up `export =` forms to `default` exports, you can use the `--allowSyntheticDefaultImports` which is available in the nightly.\n"
      },
      {
        "user": "lucabrunox",
        "created_at": "2016-01-05T17:42:13Z",
        "body": "I think I will simplify and do it this way: `export class Foo` + `export { Foo} from './foo'`. It's quite ok, thanks :)\n"
      },
      {
        "user": "lucabrunox",
        "created_at": "2016-01-05T17:44:46Z",
        "body": "Also `export import Foo = require('./foo');` + `export = Foo;` works very well.\n"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2016-01-05T17:49:44Z",
        "body": "Sounds good - I think we an close this up then.\n"
      }
    ]
  },
  {
    "number": 6316,
    "title": "`Promise<number>` is `Promise<string>`",
    "created_at": "2016-01-02T01:51:56Z",
    "closed_at": "2016-01-08T06:10:16Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/6316",
    "body": "Is there any way to resolve the following weak typings?\n\n``` ts\ntype A = boolean;\ntype AB = boolean|number;\nclass C<T> {\n    g: T;\n}\n\nvar c: C<A> = <C<AB>>null; // error\nvar p: PromiseLike<A> = <PromiseLike<AB>>null; // should be an error\n```\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/6316/comments",
    "author": "falsandtru",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2016-01-07T18:17:20Z",
        "body": "not that i can think of.\n"
      },
      {
        "user": "falsandtru",
        "created_at": "2016-01-08T05:53:25Z",
        "body": "TypeScript said, `Promise<number>` is `Promise<string>`.\n\n``` ts\nvar s: PromiseLike<number | string> = <PromiseLike<string>>null;\nvar n: PromiseLike<number> = <PromiseLike<number | string>>s; // should be an error\n```\n"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2016-01-08T06:10:16Z",
        "body": "Title is not accurate:\n\n``` ts\nlet x: PromiseLike<string>;\nlet y: PromiseLike<number>;\nx = y; // Error\n```\n\nThe behavior around `string|number` happens because of function parameter bivariance; see any number of issues around this already, e.g. #222\n"
      }
    ]
  },
  {
    "number": 6310,
    "title": "Tuple type not inferred when calling generic function",
    "created_at": "2016-01-01T02:38:23Z",
    "closed_at": "2016-02-20T01:19:35Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/6310",
    "body": "Tuple types aren't always inferred when calling generic functions. For example:\n\n```\nfunction identity<A>(value: A): A {\n    return value\n}\n\n// works\nconst [a1, b1]: [number, string] = [1, 'a']\n\n// works\nconst [a2, b2]: [number, string] = identity<[number, string]>([1, 'a'])\n\n// breaks\nconst [a3, b3]: [number, string] = identity([1, 'a'])\n```\n\nOutput:\n\n```\nfoo.ts(12,7): error TS2322: Type '(number | string)[]' is not assignable to type '[number, string]'.\n  Property '0' is missing in type '(number | string)[]'.\n```\n\nSee also #2189, #4136, #6037.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/6310/comments",
    "author": "andy-hanson",
    "comments": [
      {
        "user": "DanielRosenwasser",
        "created_at": "2016-01-02T05:29:54Z",
        "body": "This is because the array expression needs to be contextually typed by a tuple-like type so that we can infer your type argument as a tuple. You've enforced that when you explicitly gave a type argument, but not in the last example.\n\nOne way you could achieve what you want is to add a tuple-like constraint for your type parameter:\n\n``` ts\nfunction identity<A extends [void] | {}>(value: A): A {\n    return value\n}\n```\n"
      },
      {
        "user": "zpdDG4gta8XKpMCd",
        "created_at": "2016-01-04T15:56:32Z",
        "body": "that's the most interesting `identify` function I've seen so far\n"
      }
    ]
  },
  {
    "number": 6261,
    "title": "Building as library",
    "created_at": "2015-12-27T09:08:23Z",
    "closed_at": "2016-01-07T00:25:48Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/6261",
    "body": "Hello, I'm trying to create a small librery using TypeScript.\n\nI want to compile all of my files to a single file and allow the users to import any or all of the classes included in that file in an easy why.\n\nWhat would be the recomanded way to achive this ?\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/6261/comments",
    "author": "gotenxds",
    "comments": [
      {
        "user": "DanielRosenwasser",
        "created_at": "2015-12-27T16:15:09Z",
        "body": "Hi @gotenxds, in our nightly builds of TypeScript, we support module bundling by using the `--module` and `--outFile` flags. You'll need to install the nightlies by running `npm install -g typescript@next`.\n"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2015-12-27T16:16:57Z",
        "body": "I'm not sure if we support putting together a single `.d.ts` file though. @weswigham and @vladima should know what the situation is on that.\n"
      },
      {
        "user": "weswigham",
        "created_at": "2015-12-27T16:24:57Z",
        "body": "We do - we generate an ambient declaration file.\n"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2015-12-27T16:36:50Z",
        "body": "Then give it a shot @gotenxds :smile: \n"
      }
    ]
  },
  {
    "number": 6251,
    "title": "Use string literal types to get rid of redundant overload definitions",
    "created_at": "2015-12-26T05:57:01Z",
    "closed_at": "2016-02-20T01:11:34Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/6251",
    "body": "Inspired by #1003 and #6028.\nIsn't it possible to use string literal types for sharing specialized signatures among several methods?\n\ni.e., I would like to write:\n\n``` ts\ntype TodoEvent = {\n  name: 'create';\n  payload: string;\n} | {\n  name: 'updateText';\n  payload: {\n    id: string;\n    text: string;\n  };\n};\n\ninterface TodoEventEmitter {\n  emit(name: TodoEvent.name, payload: TodoEvent.payload): boolean;\n  on(name: TodoEvent.name, listener: (payload: TodoEvent.payload) => any): this;\n  // ...etc\n}\n\nconst eventEmitter: TodoEventEmitter = new EventEmitter();\n```\n\ninstead of:\n\n``` ts\ninterface TodoEventEmitter {\n  emit(name: 'create', payload: string): boolean;\n  emit(name: 'updateText', payload: { id: string; text: string; }): boolean;\n  emit(name: string, payload: any): boolean;\n\n  on(name: 'craete', listener: (payload: string) => any): this; // typo 'craete', but no error\n  on(name: 'updateText', listener: (payload: { id: number; text: string; }) => any): this; // id type incorrect, but no error\n  on(name: string, listener: (payload: any) => any): this;\n\n  // similar definitions for other methods again and again and again\n}\n\nconst eventEmitter: TodoEventEmitter = new EventEmitter();\n```\n\nOverload definitions would be further reusable when used in combination with generic types.\n\n``` ts\ninterface EventEmitterBase<T extends {name: string, payload: any}> {\n  // ...\n}\n\nconst myEventEmitter: EventEmitterBase<MyEvent> = new EventEmitter();\nconst anotherEventEmitter: EventEmitterBase<AnotherEvent> = new EventEmitter();\n```\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/6251/comments",
    "author": "kimamula",
    "comments": [
      {
        "user": "DanielRosenwasser",
        "created_at": "2015-12-27T03:10:07Z",
        "body": "What you typed out isn't valid in its semantics, but you can do something like this:\n\n``` ts\nnamespace TodoEvent {\n    export type Name = \"create\" | \"updateText\";\n    export type Payload = string | { id: string; text: string };\n}\n\ninterface TodoEventEmitter {\n  emit(name: TodoEvent.Name, payload: TodoEvent.Payload): boolean;\n  on(name: TodoEvent.Name, listener: (payload: TodoEvent.Payload) => any): this;\n  // ...etc\n}\n```\n\nThough that won't do a ton for you.\n\nWhy don't you give string literal types a try by installing our nightlies? Run `npm install -g typescript@next`.\n"
      },
      {
        "user": "kimamula",
        "created_at": "2015-12-27T13:45:34Z",
        "body": "Thanks for a reply, @DanielRosenwasser.\n\nWell, this is a suggestion.\nIt's common that multiple methods should share the definition of the specialized signatures, such as the methods of EventEmitter as I described above, as well as addEventListener/removeEventListener of HTMLElement, and createElement/getElementsByTagName of Document.\nUnfortunately however, currently we have to repeat the same definition for each method in such situations (AFAIK).\n\nI think it'd be really nice if the functionality of string literal types could be extended to resolve this.\n\nIn your example, the event \"create\" is not linked to the specific type of payload.\nSo one can emit the \"create\" event with a payload of either `string` or `{ id: string; text: string }`, which is not safe.\n"
      },
      {
        "user": "saschanaz",
        "created_at": "2015-12-27T18:44:45Z",
        "body": "This would be able to be expressed with extended #1295 proposal as:\n\n``` typescript\ninterface TodoEventTypes {\n    'create':  { payload: string; };\n    'updateText': {\n        payload: {\n            id: string;\n            text: string;\n        }\n    }\n}\n\ninterface TodoEventEmitter {\n  emit(name: string, payload: TodoEventTypes[name][\"payload\"]): boolean;\n  on(name: string, listener: (payload: TodoEventTypes[name][\"payload\"]) => any): this;\n  // ...etc\n}\n```\n\n... though the original proposal won't allow this.\n"
      }
    ]
  },
  {
    "number": 6228,
    "title": "AMD module with `--outFile` option emits declaration file references",
    "created_at": "2015-12-23T19:37:12Z",
    "closed_at": "2015-12-24T00:29:33Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/6228",
    "body": "Referenced file does not exist.\n\n``` ts\n// index.ts\nimport './types';\n\n// types.d.ts\nexport default function f()\n```\n\n```\n$ node built/local/tsc.js -t es5 -m amd --outFile bundle.js index\n```\n\n``` js\n// bundle.js\ndefine(\"index\", [\"require\", \"exports\", './types'], function (require, exports) {\n    \"use strict\";\n});\n```\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/6228/comments",
    "author": "falsandtru",
    "comments": [
      {
        "user": "DanielRosenwasser",
        "created_at": "2015-12-23T19:44:38Z",
        "body": "For the most part `--module` and `--outFile` have nonsensical behavior when used together. You'd be better served by a module bundler.\n"
      },
      {
        "user": "vladima",
        "created_at": "2015-12-23T19:51:16Z",
        "body": "just to clarify, what should be expected output from your perespective?\n"
      },
      {
        "user": "falsandtru",
        "created_at": "2015-12-23T19:53:49Z",
        "body": "expected:\n\n``` js\n// bundle.js\ndefine(\"index\", [\"require\", \"exports\"], function (require, exports) {\n    \"use strict\";\n});\n```\n\nactual:\n\n``` js\n// bundle.js\ndefine(\"index\", [\"require\", \"exports\", './types'], function (require, exports) {\n    \"use strict\";\n});\n```\n"
      },
      {
        "user": "vladima",
        "created_at": "2015-12-23T21:09:34Z",
        "body": "Compiler never elides import statements that lack import clause because they are usually used only for side-effect that happen during module loading and removing them will be incorrect.\n"
      },
      {
        "user": "falsandtru",
        "created_at": "2015-12-23T21:25:09Z",
        "body": "Certainly, TypeScript compiler needs side-effect. But runtime is not. Declaration files have no actual behavior. This emit has unnecessary references. It seems emits will be not incorrect.\n"
      },
      {
        "user": "vladima",
        "created_at": "2015-12-23T21:33:55Z",
        "body": "declaration file just describes the public surface but does not tell if loading of the module will trigger any effects. Compiler has to be conservative here especially given that the main reason why people use import declaration without import clause is side-effects.\n"
      },
      {
        "user": "falsandtru",
        "created_at": "2015-12-23T22:08:30Z",
        "body": "Excuse me, a following case causes an error. Why is it correct?\n\n``` ts\n// index.ts\nimport './types.d';\n```\n\n```\n$ node built/local/tsc.js -t es5 -m commonjs index\n```\n\n``` js\n// index.js\n\"use strict\";\nrequire('./types.d');\n```\n\n```\n$ node index.js\nmodule.js:328\n    throw err;\n    ^\n\nError: Cannot find module './types.d'\n```\n"
      },
      {
        "user": "vladima",
        "created_at": "2015-12-23T23:16:53Z",
        "body": "import / export declaration is ES6 constructions with semantic described by ES6 spec. TypeScript follows it and the only extra thing it does - removes imports that were not used in value positions (imports that were used only to bring types into the scope). If import is not removed it will fail in runtime since there are no actual exported value. Imports without import clause and imports that were used as values are never elided even if module cannot be found.\n\n``` ts\nimport {X} from \"./a\"\nlet a = new X();\n```\n\n```\nvladima@vladima-W520:~/sources/git/TypeScript$ node built/local/tsc.js -m commonjs t.ts\nt.ts(1,17): error TS2307: Cannot find module './a'.\nvladima@vladima-W520:~/sources/git/TypeScript$ cat t.js\n\"use strict\";\nvar a_1 = require(\"./a\");\nvar a = new a_1.X();\n```\n\nAnswering your question: I can easily imagine this situation somewhere in the middle of transition of some codebase from JavaScript to TypeScript: when `index.ts` is already converted to TypeScript but `./types.d.js` - not. The fact that TypeScript compiler cannot find module does not mean that it should remove its import.\n"
      },
      {
        "user": "falsandtru",
        "created_at": "2015-12-23T23:29:55Z",
        "body": "Thanks for your kindness!\n\n> TypeScript compiler cannot find module\n\nCompile was succeeded because there is:\n\n``` ts\n// types.d.ts\nexport default function f()\n```\n\ncompletely:\n\n``` ts\n// index.ts\nimport './types';\n\n// types.d.ts\nexport default function f()\n```\n\nsame as:\n\n``` ts\n// index.ts\nimport './types.d';\n\n// types.d.ts\nexport default function f()\n```\n\nMy specified error is a runtime error, not a compile error.\n"
      },
      {
        "user": "vladima",
        "created_at": "2015-12-23T23:40:16Z",
        "body": "Ambient declarations describe shape of things whose code is not accessible to the compiler. In your example the assumption is that `types.d.ts` define the public surface the API for some module 'types' that will exist in runtime. This is similar to:\n\n``` ts\ndeclare function someFunction(a: string): number;\nsomeFunction(\"123\").toFixed();\n```\n\ncompiler does not have the code for 'someFunction' so it have to trust that declaration provided by the user is correct and hope that it runtime this function will be defined.\n"
      },
      {
        "user": "falsandtru",
        "created_at": "2015-12-24T00:29:33Z",
        "body": "I understood your explained concept. Thank you very much!\n\nNote: Then I think, compiler is probably better to emit(expected):\n\n``` js\n\"use strict\";\nrequire('./types');\n```\n\nactual:\n\n``` js\n\"use strict\";\nrequire('./types.d');\n```\n\nin this directory structure:\n\n```\n./\n- index.ts\n- types.d.ts\n- types.js or types/\n```\n\nfor code semantics. Thanks.\n"
      }
    ]
  },
  {
    "number": 6226,
    "title": "Lookup index in tuple",
    "created_at": "2015-12-23T17:31:26Z",
    "closed_at": "2015-12-23T19:18:11Z",
    "labels": [
      "Duplicate",
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/6226",
    "body": "``` ts\nconst x: [number, string] = [1, 'foo'];\nconst y = x[1]\ny\n```\n\nTypeScript knows `y` is a `string`. However, if I ask for `x[2]`, TypeScript tells me it is `string | number`. Why is this? I expected it not to compile.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/6226/comments",
    "author": "OliverJAsh",
    "comments": [
      {
        "user": "saschanaz",
        "created_at": "2015-12-23T17:59:35Z",
        "body": "It seems it needs more discussion. See also #5203.\n"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2015-12-23T19:18:06Z",
        "body": "This is because a tuple of length `n` is an anonymous type that has properties `0`, ... `n - 1`, and which effectively extends an array of the union of all element types. Since it's a subtype of `Array`, it gets an index signature, whose output type is the union of all element types.\n"
      }
    ]
  },
  {
    "number": 6208,
    "title": "JSX expression type inferencing.",
    "created_at": "2015-12-22T19:06:09Z",
    "closed_at": "2015-12-22T21:34:20Z",
    "labels": [
      "Question",
      "Domain: JSX/TSX"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/6208",
    "body": "I am working on a jsx library for using CustomElements, and I would like to be able to use the element instance type directly from a JSX expression. Reading through #3203 it seems that `JSX.Element` is the final return type of all JSX expressions.\n\nCould the JSX expression type not be inferred by evaluating the return type of `React.createElement`? i.e. run the type-inferencing as if the code has been de-sugared.\n\nConsider:\n\n``` Typescript\nnamespace React {\n  interface ElementConstructor<T> {\n      new(): T\n  }\n\n  // i.e. the element instance type created is of the passed in constructor.\n  function createElement<T>(cls: ElementConstructor<T>, props: any, ...children: any[]): T {\n  }\n}\n\nclass ExampleTag {\n  exampleFunction() { }\n}\n\n// The next line fails type checking\n(<ExampleTag />).exampleFunction(); // The type of the JSX expression is specific.\n```\n\nNotice the inconsistency of the type inferencing between JSX and it's de-sugared equivalent.\n\n``` Typescript\n(<ExampleTag />).exampleFunction();  // Fails type check\n(React.createElement(ExampleTag)).exampleFunction();  // Passes\n```\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/6208/comments",
    "author": "jameskeane",
    "comments": [
      {
        "user": "ivogabe",
        "created_at": "2015-12-22T20:28:09Z",
        "body": "+1, would also be very useful for usage without React.\n"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2015-12-22T21:34:20Z",
        "body": "This is a common misunderstanding of how React works.\n\n`<ExampleTag />` is not a class instance of `ExampleTag`. Your definition of `createElement` is also incorrect - `createElement` does not instantiate the class. `(<ExampleTag />).exampleFunction()` doesn't typecheck because it doesn't work at runtime either.\n\nIf you have code like this:\n\n``` ts\nclass MyElement {\n  constructor() {\n    console.log('ctor invoked');\n  }\n  render() {\n    return <div>Hello world</div>;\n  }\n}\n\nconsole.log('Creating an element');\nlet x = <MyElement />;\nconsole.log('Rendering it');\nReactDOM.render(x, document.getElementById('target'));\n```\n\nYou'll see that the output is:\n\n``` ts\nCreating an element\nRendering it\nctor invoked\n```\n\nNote that the class is not instantiated at the point where we wrote `<MyExample />` -- it's only when the component is rendered that React instantiates your class.\n"
      },
      {
        "user": "jameskeane",
        "created_at": "2015-12-22T21:57:44Z",
        "body": "I think you are misunderstanding, I am _implementing_ `React.createElement` so that our internal library can use JSX. This issue has nothing to do with how React works, it is about how typescript fundamentally supports JSX implementations.\n"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2015-12-22T22:27:28Z",
        "body": "It's very confusing to call your library React as well :smile:\n\nOne of our decision points when implementing JSX support was what non-React consumers of JSX were doing. We can't support every possible library (for example, we don't know how they determine what the set of valid attributes are), so we chose to implement a conservative set that didn't have to provide per-object data. This was also an issue for allowing React itself because things like `<div>` don't route through an actual `div` value identifier to use for resolution.\n\nIf your library (or one with identical behavior) becomes popular and has well-defined semantics, we can look into how to support it more fully.\n"
      },
      {
        "user": "jameskeane",
        "created_at": "2015-12-22T22:57:19Z",
        "body": "You are right, it is confusing to have to define `React` to use typescript's built-in JSX support :wink:.\n\nI guess what I really want is `--jsx generic`, so I can define `JSX.createElement`. I'll open another ticket soon with more details.\n\nBut before doing that, I would like to know if it is even possible to infer a JSX expression type from the `createElement` method signature or if there is some structural or other reason for using the `JSX.Element` type.\n"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2015-12-22T23:08:29Z",
        "body": "TypeScript doesn't look at `React` when resolving JSX elements -- everything goes through the `JSX` namespace. The emitter cares if you're using `--jsx react`, but presumably a non-React library would use `--jsx preserve`, in which case `React` never enters the picture.\n\nIt's certainly possible to support this pattern (can I call it \"XAML-like\" ?). I'd like to understand more what its rules are and what other libraries are doing this. Function call resolution might be the right pattern, or maybe something else, depending on exactly how it works.\n"
      }
    ]
  },
  {
    "number": 6170,
    "title": "Unassignable type error when trying to access a class's static method from iVar reference.",
    "created_at": "2015-12-19T22:03:39Z",
    "closed_at": "2016-02-20T01:11:52Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/6170",
    "body": "The below example attempts to access a public static method on a class whose type is held in an ivar;\n\nIf i compare this._type with MyClass, the objects are identical and the method DOES exist and can be called. It's only TSC that's saying it doesn't exist. Am i doing something wrong or is there a workaround for this situation?\n\n```\ninterface ClassOf<T> { new(...args: any[]): T; }\n\nclass MyClass {\n    public static aStaticMethod(): void {/*... blah ...*/ }\n}\n\nclass GenericClass<T extends MyClass> extends Array<T> {\n    private _type: ClassOf<T>;\n    public get type(): ClassOf<T> { return this._type; };\n\n    public instanceMethod(): void {\n        let theClass = this._type;\n        let tmp: MyClass = <MyClass>theClass.aStaticMethod();\n        // Causes Error ----------------------- ^^^^^^^^\n        // Error:(400, 27) TS2339: Property 'aStaticMethod' does not exist on type 'ClassOf<T>'.\n\n        MyClass.aStaticMethod();\n        // ^^^ Works Great!\n    }\n\n    constructor(aClass: ClassOf<T>) {\n        super();\n        this._type = aClass;\n    }\n}\n```\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/6170/comments",
    "author": "Think7",
    "comments": [
      {
        "user": "DanielRosenwasser",
        "created_at": "2015-12-20T02:08:13Z",
        "body": "First off I'm going to assume you meant to write `(<MyClass>theClass).aStaticMethod();`\n\nA class introduces two separate types: the instance side and the static side. The static side holds any static properties and is also a constructor function. The instance side is the type created by the constructor function.\n\nThe instance side always gets the same name as the class itself. So in this case, the type name of the instance is `MyClass`. The static side actually gets an anonymous type, however, you can always refer to that type using `typeof MyClass` (because `MyClass` is the name of the constructor function as well).\n\nSo what you probably wanted to write is\n\n``` ts\nlet tmp: MyClass = (<typeof MyClass>theClass).aStaticMethod();\n```\n"
      },
      {
        "user": "Think7",
        "created_at": "2015-12-20T10:22:21Z",
        "body": "Wow, Thank You!\n- Yes! Forgot the parentheses. This example was semi copied from production code about 45 seconds before going to bed. Shame on me!\n- Completely missed how / when / why to use typeof for this case. Looking over your example now it makes perfect sense. Will have another read through the handbook.\n\nI've changed the title of this issue to better reflect it being a \"why doesn't this work\" question instead of a bug.\n\nIf in the future i am in a situation like this and am unable to work out why or how to do something strictly TS related, May i create a new question-issue?\n\nEDIT:\nHmm, I don't think this works after all. I now get the following error:\n\n```\nError:(404, 26) TS2352: \n- Neither type 'ClassOf<T>' nor type 'typeof MyClass' is assignable to the other.\n- Property 'aStaticMethod' is missing in type 'ClassOf<T>'.\n```\n"
      },
      {
        "user": "Think7",
        "created_at": "2015-12-20T13:34:01Z",
        "body": "Below is a clearer example of what i'm trying to do:\n\n```\ninterface ClassOf<T> { new(...args: any[]): T; }\n\nclass Model {\n    public static fromData(data: Object): Model {\n        let inst = new Model();\n        // ... Populate the model ... //\n        return inst;\n    }\n}\n\nclass RefArray<T extends Model> extends Array<ObjectID> {\n    private _type: ClassOf<T>;\n    public get type(): ClassOf<T> { return this._type; };\n\n    public resolve(): Array<T> {\n        let ModelClass = <typeof Model>this._type;\n        //               ^^^ This throws error\n        // Error:(404, 26) TS2352: \n        // - Neither type 'ClassOf<T>' nor type 'typeof Model' is assignable to the other.\n        // - Property 'fromData' is missing in type 'ClassOf<T>'.\n        return this.map((cData: Object): T => {\n            return <T>ModelClass.fromData(cData);\n        });\n    }\n\n    constructor(aClass: ClassOf<T>) {\n        super();\n        this._type = aClass;\n    }\n}\n```\n"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2015-12-20T21:04:53Z",
        "body": "In general, these questions are better fit for StackOverflow, but since you're already here it's not a problem. :smile: \n\nThis is an annoying subtlety. Basically type assertions check assignability in both directions. `this._type` can't be assigned to `ClassOf<T>`, because `T` might be a more derived type when you instantiate it. The other way around, `ClassOf<T>` can't be assigned to `this._type` because it's missing the static method.\n\nYou could perform an assertion to `any` and then to `ClassOf<T>` but I don't necessarily recommend that.\n\nWhat about moving `typeof Model` to your type parameter?\n\n``` ts\nclass RefArray<TModel extends typeof Model> extends Array<ObjectID> {\n    private _type: TModel;\n    public get type(): TModel { return this._type; };\n\n    public resolve(): Array<TModel> {\n        let ModelClass = <TModel>this._type;\n        return this.map((cData: Object): TModel => {\n            return <TModel>ModelClass.fromData(cData);\n        });\n    }\n\n    constructor(aClass: TModel) {\n        super();\n        this._type = aClass;\n    }\n}\n```\n"
      }
    ]
  },
  {
    "number": 6148,
    "title": "Working with async/await and bluebird",
    "created_at": "2015-12-18T12:18:14Z",
    "closed_at": "2015-12-19T12:15:40Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/6148",
    "body": "I know TypeScript recently adds `async/await` keyword, which is of great use to program async codes. And I use `Bluebird` instead of the built-in `Promise` object since it has useful utilities like `.promisifyAll()`, `.spread()` and so on. However, I found it unable to use `Bluebird` instead of the built-in `Promise` with async functions.\n\nI have ignored the errors created related to bluebird definitions, and the js emit was successfully updated, but it cannot execute properly in runtime.\n\nMy source code is:\n\n``` ts\n/// <reference path=\"../references.d.ts\" />\n\nimport userModel = require('../models/user');\n\nexport var reg = async (username: String, password: String): Promise<[userModel.IUser, number]> => {\n  var user: userModel.IUser = new userModel.User({\n    username: username\n  });\n  user.setPassword(password);\n  var result = await user.saveAsync<userModel.IUser>();\n  return result;\n}\n```\n\nNote that `user.saveAsync()` returns a `bluebird Promise`.\n\nWhen targeting either `ES5` or `ES6`, it throws in runtime:\n\n```\nTypeError: cUser.reg(...).spread is not a function\n```\n\nEven if I add `import Promise = require('bluebird');` does not work.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/6148/comments",
    "author": "xfoxfu",
    "comments": [
      {
        "user": "xfoxfu",
        "created_at": "2015-12-19T12:15:40Z",
        "body": "Sorry, I have found a solution now: manually set\n\n``` ts\nglobal.Promise = require(\"bluebird\");\n```\n\nsince bluebird won't set it when Promise already exists. Then I can make all the Promises into bluebird version.\n\nIssue closed.\n"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2015-12-20T05:10:36Z",
        "body": "For the record, you can also specifically annotate your function with the type of Bluebird's promise type, and the emit will adjust for this.\n"
      }
    ]
  },
  {
    "number": 6134,
    "title": "Is there a defined order for AMD modules in a single file?",
    "created_at": "2015-12-17T16:53:51Z",
    "closed_at": "2016-01-07T00:28:21Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/6134",
    "body": "For example, is it guaranteed that all dependencies will appear before a file?\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/6134/comments",
    "author": "pspeter3",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2016-01-07T00:28:21Z",
        "body": "Your AMD loader implementation should be able to handle that. no ordering is required.\n"
      }
    ]
  },
  {
    "number": 6133,
    "title": "Question about type parameter assignment error with inheritance",
    "created_at": "2015-12-17T16:08:15Z",
    "closed_at": "2015-12-17T17:22:59Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/6133",
    "body": "I have something like this:\n\n```\ninterface Foo {\n  state(): any;\n}\nclass GenericTable<A> implements Foo {\n  public state() { ... }\n}\nclass MyTable extends GenericTable<A> { ... }\nstatic function DoStuff(foo: Foo) { ... }\n\nDoStuff(MyTable);\n```\n\nI get these errors in VS 2015:\n\n```\nArgument of type 'typeof MyTable' is not assignable to parameter of type 'Foo'.\nArgument of type 'typeof MyTable' is not assignable to parameter of type 'Foo'.\n  Property 'state' is missing in type 'MyTable'.\n```\n\nThis is using TSX in VS with `tsc` 1.7.5. Using the `as` operator doesn't help. It would seem that this should work but it isn't realizing that Table ultimately does implement Foo and should be able to be cast to that, or maybe my assumption is invalid, or maybe the generic piece in the middle is causing a problem. Is it possible to do this?\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/6133/comments",
    "author": "josh-endries",
    "comments": [
      {
        "user": "ahejlsberg",
        "created_at": "2015-12-17T17:22:44Z",
        "body": "You're passing the `MyTable` _constructor function_ to a function that expects a `Foo` _instance_. You need to write:\n\n``` typescript\nstatic function DoStuff(foo: Foo) { ... }\n\nDoStuff(new MyTable());\n```\n\nOr, if you actually intend to pass the constructor function, you need to write something like:\n\n``` typescript\nstatic function DoStuff(foo: new () => Foo) { ... }\n\nDoStuff(MyTable);\n```\n"
      }
    ]
  },
  {
    "number": 6131,
    "title": "Implicit conversion of number to const enum",
    "created_at": "2015-12-17T12:41:30Z",
    "closed_at": "2016-01-05T20:18:58Z",
    "labels": [
      "By Design",
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/6131",
    "body": "The following code compiles, even though variable `n` obviously is assigned value that is incompatible with its type.\n\n``` ts\nconst enum BinaryDigit {\n    zero = 0,\n    one = 1\n}\n\nlet n: BinaryDigit = 2;\n```\n\nIs there any reason why the compiler allows an implicit conversion of numbers to const enums?\n\nAn instance of a base class cannot be implicitly converted to an instance of a derived class. I would have expected the same for const enums and numbers (all const enum values \"are\" numbers, but not all numbers \"are\" const enum values). If you do not consider numbers and const enum values equialent types, that would be even more reason to disallow implicit conversion.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/6131/comments",
    "author": "crobi",
    "comments": [
      {
        "user": "ahejlsberg",
        "created_at": "2015-12-17T15:06:06Z",
        "body": "It's to allow patterns such as `n = n + 1`. We actually take the view that all numbers _are_ enum values, but that one enum value is not assignable to another enum value. In other words, numbers and enums implicitly convert to each other, but different enums do not.\n\nIt is obviously possible to construct stricter views of enum types, but those stricter views also often force you to write type assertions. It's all about which compromises you prefer.\n"
      }
    ]
  },
  {
    "number": 5966,
    "title": "How can i define an interface for method only available to specific other methos",
    "created_at": "2015-12-07T07:51:21Z",
    "closed_at": "2015-12-07T18:24:43Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/5966",
    "body": "On pouchdb.d.ts projet i'm stuck on writing for the emit method that is accessible only for reduce method.\n\nExemple\n\n```\nfunction reduce(doc) {\n   emit(xx, yy)\n}\n```\n\nthe emit method can only by called by reduce function.\n\nHow can i write this on Definitely type?\nThanks for your help.\n\nAGBrown/pouchdb.d.ts#36\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/5966/comments",
    "author": "sebglon",
    "comments": [
      {
        "user": "jesseschalken",
        "created_at": "2015-12-07T08:36:05Z",
        "body": "If a method on an `interface` is only accessible to one or more other methods on that interface, then what use is it have it in the interface, since you can't use it from the outside?\n\nIf you want to write a method in a class (eg `emit`) that can only be called by a specific other method in the same class (eg `reduce`), then you can just define it locally inside method you want to use it in.\n\n``` ts\nfunction reduce(doc) {\n    var emit = (x, y) => {\n        // ...\n    };\n    // ...\n    emit(xx, yy);\n    // ...\n}\n```\n"
      },
      {
        "user": "sebglon",
        "created_at": "2015-12-07T08:45:02Z",
        "body": "Sorry I have not been clear.\n\nthe emit function can only be called by callback mapFun.\n\nExemple:\n\n``` javascript\nfunction mapReduce(doc) {\n    var emit = (x,y) => {\n         // ...\n    }\n var mapFun = z.callback\n}\n\nvar mapFun = (doc) => {\n      emit(doc.x,doc.y);  // emit can only be called from callback function\n}\n```\n"
      },
      {
        "user": "jesseschalken",
        "created_at": "2015-12-07T08:52:27Z",
        "body": "So pass `emit` into `mapFun`?\n"
      },
      {
        "user": "sebglon",
        "created_at": "2015-12-07T10:34:59Z",
        "body": "My project is to create definitelytyped for existing javascript PouchDB.\nI can't change PouchDB implementation.\nI just want to create d.ts interface for compatibility.\n"
      },
      {
        "user": "jesseschalken",
        "created_at": "2015-12-07T11:29:21Z",
        "body": "So if I understand correctly, a JavaScript library provides an object with an `emit` method which, although it is technically accessible anywhere, is only _expected_ to be called from within a callback called `reduce`. I don't think there is a way to express this in TypeScript, and it seems like a strange API. I would expect the `emit` method to be passed _to_ your callback if it is only expected to be called from it.\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2015-12-07T18:24:43Z",
        "body": "I agree with @jesseschalken; I would say JSDoc comments would be a good place to document this restriction.\n"
      },
      {
        "user": "fredgalvao",
        "created_at": "2015-12-07T19:19:37Z",
        "body": "I think @sebglon wasn't quite able to express what we need on this one.\nThis is not a javascript per se issue, as in \"browser or node issue\". This happens because CouchDB makes a global function `emit` available for any `map` function, but only in that scope.\n\nWe cannot declare the `emit` for every `map` function as in\n\n``` typescript\nfunction mapThis(doc){\n    var emit: () => {};\n    emit(...);\n}\n```\n\nbecause we have no controll over the user's code. We can only define what type the `mapThis` is expected to be.\n\nWe wanted to know if there's anything in typescript that would allow us to say that for that function type, and for it only, an `emit` function would be available. Similar to reserved words, like the way `export` is handled at the moment, but with limited scope like modules.\n\n### **tl,dr;**\n\nWe want to know if there's anything that makes this possible:\n\n``` typescript\ninterface ExistingDoc {}\n\ntype MapFunction = (doc: ExistingDoc) => void;\n\ninterface MapReduce {\n    map: MapFunction;\n}\n\nemit(); // this should not compile\nvar ordinaryFn = function () {\n    emit(); // this should not compile either\n}\n\nvar mapFunction: MapFunction = (doc) => {\n    emit(); // this should compile\n}\n\nvar queryObject = {\n    map: (doc) => {\n        emit(); // this should also compile\n    }\n}\n```\n\nOtherwise, we would need to advise the user that we can't do that, and tell them to define it themselves (which is the last resort).\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2015-12-07T19:24:30Z",
        "body": "if the function is visible in the scope, i do not think there is much we can do to restrict its use.\n"
      }
    ]
  },
  {
    "number": 5964,
    "title": "ReducerFunction Example Error",
    "created_at": "2015-12-07T04:51:10Z",
    "closed_at": "2015-12-07T19:12:56Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/5964",
    "body": "I'm trying to write a reactivex/rxjs based redux like library for angular2. And this is what I ran into.\n\nI want the ReducerFunction interface to be able to accommodate both the simple reducer functions, as well as an object that is a tree of reducers. This way, my redux store constructor can intelligently combine the reducers depending on the structure of the object that is passed in.\n\nThe following does not work:\n\n``` typescript\n\n/** Created by ge on 12/6/15. */\nexport interface Action {\n    type: string;\n    [key:string]: any;\n}\nexport interface ReducerFunction<TState> {\n    (state:TState, action:Action):TState;\n    [key:string]:ReducerFunction;\n}\n\ninterface State {\n    counter:number;\n}\nvar reducer:ReducerFunction<State> = function (state:State, action:Action):State {\n      return state;\n};\n\n```\n\nThe following works:\n\n``` typescript\n\n/** Created by ge on 12/6/15. */\nexport interface Action {\n    type: string;\n    [key:string]: any;\n}\nexport interface ReducerFunction<TState> {\n    (state:TState, action:Action):TState;\n    [key:string]:any;\n}\n\ninterface State {\n    counter:number;\n}\nvar reducer:ReducerFunction<State> = function (state:State, action:Action):State {\n      return state;\n};\n\n```\n\nuhm is this a feature, bug, or why?\n\nThanks! \n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/5964/comments",
    "author": "geyang",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2015-12-07T05:58:43Z",
        "body": "You can not reference a generic type without specifying its type arguments. the reference to `ReducerFunction` in `[key:string]:ReducerFunction` should have some type for `TState`, possibly `ReducerFunction<TState>` or `ReducerFunction<any>`.\n\nI am not sure i understand the intention, but looks like the interface should not be generic but rather the function, so consider something like:\n\n``` ts\ninterface ReducerFunction {\n    <TState extends State>(state: TState, action: Action): TState;\n    [key: string]: ReducerFunction;\n}\n```\n\nFrom the explanation above, looks like you want them to be either a function or an object, but not both. if this is true, consider re-defining the `ReducerFunction` as a union type:\n\n``` ts\ntype ReducerFunction = {\n        <TState extends State>(state: TState, action: Action): TState;\n    } | {\n        [key: string]: ReducerFunction;\n    };\n```\n"
      },
      {
        "user": "geyang",
        "created_at": "2015-12-07T06:39:42Z",
        "body": "Hi @mhegazy \n\nSo I want this module to be used in the following way. the problem is that I want the State interface to be defined by the code that imports the library (\"./index\" in this case). I'm new to type script so not sure what to do in this case ;-/ (and thanks for your help!)\n\nLet's assume that the ReducerFunction is either a function or an object. (I originally wanted other wise, but this might be simpler.)\n\nThe  tricky thing is that I also don't know how to write the `combineReducers` function. It needs to return a function where the state has the type `State`, but State is not available in the library, it is going to be defined by the script that calls the library. So the following implementation of the combineReducers is also not working because the State interface is not available in this scope:\n\n``` typescript\nimport {Action, ReducerFunction} from \"../interfaces\";\n// helper function\nfunction pickReducer(reducers: ReducerFunction) {\n    return Object.keys(reducers).reduce((result, key):ReducerFunction => {\n        if (typeof reducers[key] === 'function') {\n            result[key] = reducers[key];\n        }\n        return result;\n    }, {});\n}\n\n\n// mixed reducer type is not supported, but I want to add them later on.\nexport function combineReducers(reducers:ReducerFunction):ReducerFunction {\n    const finalReducers:ReducerFunction = pickReducer(reducers);\n    const keys = Object.keys(finalReducers);\n\n    function newReducer <TSate>(state:TSate, action:Action):TSate => {\n        return keys.reduce((result, key) => {\n            result[key] = finalReducers[key](state[key], action);\n            return result;\n        }, {});\n    };\n    return newReducer\n};\n```\n\n``` typescript\n/** Created by ge on 12/6/15. */\nexport interface Action {\n    type: string;\n    [key:string]: any;\n}\nexport type ReducerFunction = {\n    <TState>(state:TState, action:Action):TState;\n}|{\n    [key:string]:ReducerFunction;\n}\n\n```\n\n``` typescript\nimport {Action, ReducerFunction} from \"./index\";\ninterface State {\n    counter:number;\n}\n\nvar reducer:ReducerFunction = function <State>(state:State, action:Action):State {\n    if (action.type === \"INC\") {\n        state.counter += 1;\n        return state\n    } else if (action.type === \"DEC\") {\n        state.counter -= 1;\n        return state\n    } else {\n        return state;\n    }\n};\n\ndescribe(\"interfaces\", function () {\n    it(\"Reducer can be a function\", function () {\n        var state:State = {counter: 0};\n        expect(state.counter).toBe(0);\n        state = reducer(state, {type: \"INC\"});\n        expect(state.counter).toBe(1);\n        state = reducer(state, {type: \"DEC\"});\n        expect(state.counter).toBe(0);\n    });\n});\n\n//import {combineReducers} from \"./index\";\n//describe(\"combineReducers\", function () {\n//    it(\"should return same reducer\", function(){\n//\n//    })\n//})\n```\n"
      },
      {
        "user": "geyang",
        "created_at": "2015-12-07T06:47:42Z",
        "body": "Okay so right now if I just do the following, I'm getting the following error message:\n\n``` error\n/components/luna/src/index.spec.ts.ktp.ts(10,15): error TS2339: Property 'counter' does not exist on type 'State'.\n```\n\n``` typescript\n// interface.js\n\n/** Created by ge on 12/6/15. */\nexport interface Action {\n    type: string;\n    [key:string]: any;\n}\nexport type ReducerFunction = {\n    <TState>(state:TState, action:Action):TState;\n}|{\n    [key:string]:ReducerFunction;\n}\n\n```\n\n``` typescript\n/// index.spec.ts file\n\n///<reference path=\"../typings/jasmine/jasmine.d.ts\"/>\n/** Created by ge on 12/6/15. */\nimport {Action, ReducerFunction} from \"./index\";\ninterface State {\n    counter:number;\n}\n\nvar reducer:ReducerFunction = function<State> (state:State, action:Action):State {\n    if (action.type === \"INC\") {\n        state.counter += 1;\n        return state\n    } else if (action.type === \"DEC\") {\n        state.counter -= 1;\n        return state\n    } else {\n        return state;\n    }\n};\n\ndescribe(\"interfaces\", function () {\n    it(\"Reducer can be a function\", function () {\n        var state:State = {counter: 0};\n        expect(state.counter).toBe(0);\n        state = reducer(state, {type: \"INC\"});\n        expect(state.counter).toBe(1);\n        state = reducer(state, {type: \"DEC\"});\n        expect(state.counter).toBe(0);\n    });\n    it(\"create store\", function () {\n        var state:State = {counter: 0};\n        expect(state.counter).toBe(0);\n        state = reducer(state, {type: \"INC\"});\n        expect(state.counter).toBe(1);\n        state = reducer(state, {type: \"DEC\"});\n        expect(state.counter).toBe(0);\n    });\n});\n\n//import {combineReducers} from \"./index\";\n//describe(\"combineReducers\", function () {\n//    it(\"should return same reducer\", function(){\n//\n//    })\n//})\n```\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2015-12-07T06:50:34Z",
        "body": "`State` is not a name of the type State, it is a gneric type argument.\n\n``` ts\nfunction<State> (state:State, action:Action):State { }\n```\n\nthis should probably be:\n\n``` ts\nfunction<T extends State> (state:T, action:Action):T { }\n```\n\nor just loose the generic type parameter altogether:\n\n``` ts\nfunction (state:State, action:Action):State { }\n```\n"
      },
      {
        "user": "geyang",
        "created_at": "2015-12-07T18:47:32Z",
        "body": "Thanks @mhegazy , so I can just have a typescript file like this?\n\n``` typescript\n\nexport type function ReducerFunction (state:State, action:Action):State {\n}\n```\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2015-12-07T19:12:55Z",
        "body": "well, you need to define `State` in this file, or import it. so something like:\n\n``` ts\n\nimport {Action} from \"./index\";\n\ninterface State {\n    counter:number;\n}\n\nexport function ReducerFunction (state:State, action:Action):State {\n    if (action.type === \"INC\") {\n        state.counter += 1;\n        return state\n    } else if (action.type === \"DEC\") {\n        state.counter -= 1;\n        return state\n    } else {\n        return state;\n    }\n};\n```\n"
      },
      {
        "user": "geyang",
        "created_at": "2015-12-07T19:15:42Z",
        "body": "Thanks! I think Im going to move this discussion to gitter.\n"
      }
    ]
  },
  {
    "number": 5963,
    "title": "Error when using \"Legacy\" external modules + SystemJS",
    "created_at": "2015-12-07T01:13:13Z",
    "closed_at": "2015-12-07T03:38:34Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/5963",
    "body": "Hi, I get the following error:\n\n```\nerror TS1218: Export assignment is not supported when '--module' flag is 'system'.\n```\n\nWhen I try to compile an external module (not ES6 module):\n\n```\nexport = arrays;\n// and\nimport arrays = require(\"./arrays.ts\");\n```\n\nI'm using TypeScript `1.8.0-dev.20151204` and a class like the following:\n\n```\nclass Arrays {\n\n  // ...\n\n}\n\nvar arrays = new Arrays();\nexport = arrays;\n```\n\nIs it possible to compile using `--module`  `system` and \"legacy\" external modules?\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/5963/comments",
    "author": "remojansen",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2015-12-07T03:38:34Z",
        "body": "No. SystemJS does not have a parallel to `export =` like in other module loaders e.g. commonJs and AMD. \n\nuse `export default arrays` instead.\n"
      },
      {
        "user": "remojansen",
        "created_at": "2015-12-07T08:55:04Z",
        "body": "@mhegazy thanks for the answer, can I use?\n\n```\nimport arrays = require(\"./arrays.ts\")\n```\n\nIf I use `export =` ? or system can only be used with the ES6 module syntax?\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2015-12-07T17:40:16Z",
        "body": "You can use `import arrays = require(\"./arrays\")` which will be equivalent to import \\* as arrays from \"./arrays\";`but you can not use`export=`.\n"
      },
      {
        "user": "wejsi",
        "created_at": "2016-10-14T14:50:18Z",
        "body": "PT-BR -- Configure o seu tsconfig.json desta maneira.\n\n{\n  \"compilerOptions\": {\n    \"target\": \"ES5\",\n    \"module\": \"commonjs\",\n    \"sourceMap\": true,\n    \"emitDecoratorMetadata\": true,\n    \"experimentalDecorators\": true,\n    \"removeComments\": false,\n    \"noImplicitAny\": false\n  },\n  \"exclude\": [\n    \"typings\"\n  ]\n}\n"
      }
    ]
  },
  {
    "number": 5930,
    "title": "User defined type guard function and type any",
    "created_at": "2015-12-04T13:45:27Z",
    "closed_at": "2016-01-15T00:05:37Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/5930",
    "body": "Hi all!\n\n``` typescript\ninterface A {\n    prop: string\n}\n\nfunction isA(arg: any): arg is A {\n    return \"prop\" in arg;\n}\n\nfunction handle(arg: any) {\n    if (isA(arg)) {\n        let b = arg.nonExistsProp; // no compile error here\n    }\n}\n```\n\nWhy there is no compile error while acessing `nonExistsProp`? Is it by design and guard function only works with union types? Can't find some sort of specs, please, help me.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/5930/comments",
    "author": "Strate",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2015-12-05T03:20:07Z",
        "body": "Type guards do not narrow `any`. The reasoning for this is that we want type guards to allow you to do _more_, not _less_. `any` can already do everything, so it doesn't \"help\" you in that regard.\n\nMore specifically, we actually did try it the other way. The initial version of type guards _did_ narrow on `any`; what we found is that a lot people had code like this:\n\n``` ts\n// By contract, this function accepts only a Dog or a House\nfunction fn(x: any) {\n  // For whatever reason, user is checking against a base class rather\n  // than the most-specific class. Happens a lot with e.g. HTMLElement\n  if (x instanceof Animal) {\n    x.woof(); // Disallowed if x: Animal\n  } else {\n    // handle House case\n  }\n}\n```\n"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2015-12-05T04:51:44Z",
        "body": "At the expense of being pedantic, this isn't entirely true. `instanceof` and user-defined type guards do not perform narrowing. `typeof` type guards _do_ because we know _exactly_ what type a value has. \n\n``` ts\nlet x: any;\n\nif (typeof x === \"number\") {\n    // 'x' has type 'number' here.\n    let y = x * x;\n}\n```\n"
      },
      {
        "user": "zpdDG4gta8XKpMCd",
        "created_at": "2015-12-05T20:30:14Z",
        "body": "@RyanCavanaugh what bothers me is that the design team is up for encouraging bad habits, this is wrong, please stop, you cannot follow the flow even if everyone flows with it, you should make what's right, not what's everyone is accustomed to be doing for their lives, i mean an average member of javascript community doesn't have a PhD in computer science, why the hell we choose to follow his bad habits?\n\ntype guard should narrow things, this is what they do, narrowing `any` makes perfect sense\n"
      },
      {
        "user": "fongandrew",
        "created_at": "2015-12-10T23:13:11Z",
        "body": "+1 on changing the behavior to narrowing the type.\n\nWith respect to prior user behavior, I don't think it's something to be encouraged, but if it is widespread, it's because `instanceof` existed prior to typeguards being introduced. For user-defined typeguards however, that's not the case. If I define a function with the signature `(arg: any) => arg is A`, there's zero ambiguity that the user intends for `any` type to be narrowed to `A`.\n\nAlternatively, maybe there could be some sort of syntax where the user can explicitly indicate intent to narrow? E.g. `isA(arg: any) => arg isOnly A`?\n"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2015-12-11T02:29:24Z",
        "body": "I'm serious about the number of breakages we found in real-world code. It was very large, and feedback from people trying early builds said they didn't want this.\n\nIt's so far been basically impossible to get a type error on a value of type `any` and there would need to be a stronger justification other than \"You should be stricter on people\" when the entire point of the `any` type is to be as unstrict as possible.\n\nOn the one hand, listen to users, and on the other hand, listen to users...\n"
      },
      {
        "user": "zpdDG4gta8XKpMCd",
        "created_at": "2015-12-11T02:36:09Z",
        "body": "Don't see a contradiction. Let `any` be the most unrestricted thing in the world. No problem. But when someone does `if (anything is Potato) { eatSteak(anything); }` they expect a compiler error, `any` won't give it to them, so they don't want `any`, they want a shaped value. So the strictness is welcome here, it's a good thing, why would anyone be pissed by it.\n"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2015-12-11T02:41:11Z",
        "body": "What you've written there is runtime-invalid code. The point is that there's lots of runtime-_valid_ code that also issues a type error if we narrow `any`\n"
      },
      {
        "user": "zpdDG4gta8XKpMCd",
        "created_at": "2015-12-11T02:55:57Z",
        "body": "Let's not use word strictness or narrowing for a second. Type guard is a predicate that asserts at runtime that a given value is of certain type. Ultimately one can put anything in it and it would say yes or no. Once it said yes you get a guarantee (up to the implementation of the type guard) that a value is of that type. Am I right so far? If so, then your example with the `woof` method must break. We asserted that a value is of type `Animal`. Animals don't woof, dogs do. It's not a runtime valid code, because if I put a cat in that function it will crash regardless of what the author thought the contract is. There is no such thing as a contract in JavaScript, there are only our best assumptions and hopefully a test that verifies them. So I am not sure why we are into giving the developers an illusion that they know what they are doing. I see your point that there are a lot of naive people who already written tons of crappy code, well this is TypeScript for goodness sake, time to grow up.\n"
      },
      {
        "user": "zpdDG4gta8XKpMCd",
        "created_at": "2015-12-11T03:13:27Z",
        "body": "I am not trying to convince you. Just ranting. I get it that the design goal is to make a mainstream language that fits the least competent developer. It is indeed very frustrating that correctness isn't the goal. I get that too. There is already quite a number of features that I wish didn't exist at all, we one more one less doesn't make a difference. Hopefully the niche for a correct/sound counterpart of TypeScript will be filled soon. As soon as we have it we will get a natural partitioning between the skilled developers and beginners.\n"
      }
    ]
  },
  {
    "number": 5877,
    "title": "Incorrect function return type: expected it to match generic type parameter",
    "created_at": "2015-12-02T00:33:12Z",
    "closed_at": "2015-12-02T00:45:29Z",
    "labels": [
      "By Design",
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/5877",
    "body": "I may just be abusing the type system here, but there's no warnings or errors, so I have to assume it should work. I'm trying to dispatch a command to a registered handler and return the result, which should be of the type specified by the command.\n\nQuestion is, why is the result always of type object, when the type parameter is clearly a string? Is this a bug or known limitation, and if so, is it a bug that there is no error or warning here?\n\n``` typescript\ninterface Command<T>\n{\n}\n\nclass TestCommand implements Command<string>\n{\n}\n\nfunction dispatch<T>(command: Command<T>): T\n{\n    let result: any = \"Result of executing the command handler\";\n\n    return result as T;\n}\n\nlet result = dispatch(new TestCommand());\n// Why is result of type object? I expected it to be a string.\n```\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/5877/comments",
    "author": "thomas-darling",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2015-12-02T00:45:29Z",
        "body": "The problem is that `T` is never manifested in the object, and since it is a structural type system, setting `T` to a string without using it has no impact on the inference. if you add a property `p: T` to your interface, your result should be of type `T`, in this case, `string` as you would expect.\n"
      },
      {
        "user": "thomas-darling",
        "created_at": "2015-12-02T01:04:28Z",
        "body": "Ahhh, that makes sense, although it would likely have been a while before I figured that one out on my own - looking at the code it kinda feels like it should just work. But thanks for the quick response, the workaround solved my problem :-)\n"
      }
    ]
  },
  {
    "number": 5820,
    "title": "Class as parameter?",
    "created_at": "2015-11-28T18:08:50Z",
    "closed_at": "2015-11-30T06:13:01Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/5820",
    "body": "Can we do something like \n\n```\nclass Serializable {\n   public toString() {} \n}\nclass Test extends Serializable {\n    public key:string\n}\n\ntest(Test);\nfunction test(klass: Class<? extends Serializable>) {\n    var obj = new klass();\n    obj.toString()\n}\n```\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/5820/comments",
    "author": "joesonw",
    "comments": [
      {
        "user": "DanielRosenwasser",
        "created_at": "2015-11-28T20:04:27Z",
        "body": "You might want something like\n\n```\nfunction tests<T extends Serializable>(constructorFn: new () => T) {\n    var obj = new constructorFn()\n    obj.toString()\n}\n```\n\nWhere the type `new () => T` means that you can call a value of that type and get a `T` out of it.\n"
      },
      {
        "user": "joesonw",
        "created_at": "2015-11-30T02:43:10Z",
        "body": "But it also allows to pass anything to it (like some class did not extend from serializable) .\n"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2015-11-30T04:59:34Z",
        "body": "That's because your implementation of `Serializable` just requires `toString(): string`, which every type has by default anyway. That means every constructor function is structurally compatible with `Serializable`. If the method's name was something else, or you added an extra property on `Serializable` (like `__serializable: any`), then you'd get an error.\n"
      },
      {
        "user": "joesonw",
        "created_at": "2015-12-25T09:57:00Z",
        "body": "It does not seem work with generics.\n"
      }
    ]
  },
  {
    "number": 5778,
    "title": "Declaring a named module with call signature?",
    "created_at": "2015-11-24T21:05:51Z",
    "closed_at": "2015-11-25T21:55:15Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/5778",
    "body": "I'm having trouble typing the following scenario.\n\ndefs.d.ts\n\n```\ndeclare module \"my/module\" {\n  export = (arg: string) => any;\n}\n```\n\nmain.ts\n\n```\nimport myModule = require(\"my/module\");\nmyModule(\"hello\");\n```\n\nLine 2 in `main.ts` compiles fine, VS even shows the correct call signature, however, `defs.d.ts` does not compile correctly:\n`error TS2304: Cannot find name 'any'`\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/5778/comments",
    "author": "jseanxu",
    "comments": [
      {
        "user": "vladima",
        "created_at": "2015-11-24T21:43:09Z",
        "body": "can you define \"my/module\" like this?\n\n``` ts\ndeclare module \"my/module\" {\n    function f(arg: string) => any;\n    export = f;\n}\n```\n"
      },
      {
        "user": "jseanxu",
        "created_at": "2015-11-25T21:55:15Z",
        "body": "That works, thanks!\n"
      }
    ]
  },
  {
    "number": 5685,
    "title": "Index signature of object type, not supported by implementing class",
    "created_at": "2015-11-16T14:56:05Z",
    "closed_at": "2016-02-20T04:46:17Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/5685",
    "body": "With the following code, and the `noImplicitAny` flag on, I get the error `TS7017: Index signature of object type implicitly has an 'any' type.`\n\n``` js\ninterface ICurrency {\n  [key: string]: any;\n\n  currencyId:number;\n  // ...\n}\n\nclass Currency implements ICurrency {\n  public currencyId:number;\n  // ...\n}\n\nlet currency = new Currency();\n\nlet x = 'currencyId';\nconsole.log(currency[x]);  // error\n\nconsole.log(currency['currencyId']);  // ok\n```\n\nSurely that's a bug?\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/5685/comments",
    "author": "Merott",
    "comments": [
      {
        "user": "ahejlsberg",
        "created_at": "2015-11-16T19:03:56Z",
        "body": "Can't seem to reproduce this. Which version of the compiler are you using?\n"
      },
      {
        "user": "Merott",
        "created_at": "2015-11-16T21:22:27Z",
        "body": "It looks like I went one step too far in simplifying the problem, and accidentally erased the problem itself :smile: \n\nThe issue occurs when using a variable as the key to a property:\n\n``` js\nlet x = 'currencyId';\nconsole.log(currency[x]);  // error\n```\n\nI've corrected the original description to reflect that.\n\nI'm using 1.6.2 by the way.\n"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2015-11-16T22:32:34Z",
        "body": "This is an unfortunate inconsistency on our assignability rules vs substitutability in practice.\n\nThe index signature `[key: string]: any;` is somewhat meaningless - it says that you can index this object by a `string` to get back a value of type `any`. That is true of _any_ object, it's just a question of whether that `any` is \"implicit\" (an error under `noImplicitAny`), or if it's explicit (because the type has an index signature). So when we test the assignability of a type, the `[key: string]: any;` declaration is ignored in the target type because it's universally true(ish), which means that the class's `implements` clause is satisfied even though the class has no explicit (non-implicit-`any`) index signature.\n\nDepending on your scenario, it might be better to define the index signature as `[key: string]: {};`, or to add an explicit index signature to `Currency` (by adding `[key: string]: number;` to its body).\n"
      },
      {
        "user": "Merott",
        "created_at": "2015-11-17T09:39:36Z",
        "body": "So, an explicit index signature on an interface becomes an implicit signature in the implementing class. I think I get that. (right?)\n\nI'm fairly new to TypeScript and therefore my thinking is very much from a user's point of view, without knowledge of the internals. And what I don't understand about this issue is the difference it makes when using a string variable as key vs an explicit string value, to access a property. I expect the behaviour to be the same because in both cases the type of key in use is known to be a `string`. As far as the types are concerned there is no difference in the compiler's knowledge.\n"
      },
      {
        "user": "amritk",
        "created_at": "2016-01-27T20:04:11Z",
        "body": "The issue does not have to do with the any return value, even if you set a type there it still will not work. Typescript doesn't seem to allow you to access properties via a variable:\n\n```\ninterface ICurrency {\n  [key: string]: string;\n\n  currencyId:number;\n  // ...\n}\n\nclass Currency implements ICurrency {\n  public currencyId:number;\n  // ...\n}\n\nlet currency = new Currency();\n\nlet x = 'currencyId';\nconsole.log(currency[x]);  // error\n\nconsole.log(currency['currencyId']);  // ok\n```\n"
      },
      {
        "user": "bgrieder",
        "created_at": "2016-01-29T06:00:31Z",
        "body": "@amritk setting the `suppressImplicitAnyIndexErrors` flag on the compile \"fixes\" the issue even in the presence of the `noImplicitAny` flag.\n\n(this begs the question of why this is not always the case when `noImplicitAny` is set)\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2016-02-20T04:46:17Z",
        "body": "An index signature can be defined on the class to constraint the access of properties with string names. i.e:\n\n``` ts\nclass Currency implements ICurrency {\n    public currencyId: string;\n\n    [key: string]: string;\n}\n\nlet currency = new Currency();\n\nlet x = \"currencyId\";\nvar y = currency[x];// stinrg;\nvar z = currency[\"currencyId\"];// stinrg;\n\n```\n\nthe index signature on the interface is just not inherited by the class. this is a general distinction between implements and extends. extending a class gives you all its properties and signatures, but implementing an interface, is just a check to make sure the class has a compatible shape, but nothing more.\n"
      },
      {
        "user": "zakdances",
        "created_at": "2016-11-23T08:54:16Z",
        "body": "But `[key: string]: string;` makes the class lose it's shape by claiming any string as a key. There doesn't seem to be any way to allow a class or interface to *retain it's shape* while also allowing it's properties to be accessed with a variable EVEN IF that variable is properly typed as the names of the class's properties, like \r\n\r\n```\r\ntype word = 'firstName'; \r\nconst myVar: word = 'firstName';\r\n\r\nmyInstance[myVar] // (Assuming myInstance has a 'firstName' property) This causes an \"implicit 'any'\" error :(\r\n```"
      }
    ]
  },
  {
    "number": 5672,
    "title": "Can I keep generators (async/await) only and compile other features to ES5?",
    "created_at": "2015-11-15T06:59:19Z",
    "closed_at": "2015-11-15T08:39:52Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/5672",
    "body": "Did try babel for second compilation but can we make it directly through TypeScript?\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/5672/comments",
    "author": "vilicvane",
    "comments": [
      {
        "user": "DanielRosenwasser",
        "created_at": "2015-11-15T08:28:30Z",
        "body": "Sounds like you want #4692. We are working on downlevel async functions though, and as part of the effort, we're hoping to enable more granular control over transformations.\n"
      },
      {
        "user": "vilicvane",
        "created_at": "2015-11-15T08:39:52Z",
        "body": "@DanielRosenwasser great to know, I had read that issue but didn't know you are already working on it. Thanks!\n"
      }
    ]
  },
  {
    "number": 5652,
    "title": "Infer type for generic.",
    "created_at": "2015-11-13T14:46:56Z",
    "closed_at": "2016-02-20T00:45:30Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/5652",
    "body": "Hi!\n\nSeems that some cases of inferring types does not work:\n\n```\ninterface Blabla<T> {\n    (): T\n}\n\nfunction some(): Blabla {\n    return () => {\n        return 123;\n    }\n}\n```\n\nI got compilation error:\n\n```\nerror TS2314: Generic type 'Blabla<T>' requires 1 type argument(s).\n```\n\nIs it possible to infer `number` type for `T`?\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/5652/comments",
    "author": "Strate",
    "comments": [
      {
        "user": "ahejlsberg",
        "created_at": "2015-11-13T17:19:19Z",
        "body": "No, but you can just omit the type annotation and TypeScript will infer the return type of `some` to be `() => number`. That type is structurally compatible with `Blabla<number>` so you get the same effect:\n\n``` typescript\ninterface Blabla<T> {\n    (): T\n}\n\nfunction some() {\n    return () => {\n        return 123;\n    }\n}\n\nvar f: Blabla<number> = some();\n```\n"
      },
      {
        "user": "Strate",
        "created_at": "2015-11-13T19:30:57Z",
        "body": "It would be very great if typescript infer type in this case.\nIn real life I have a bit more complex example:\n\n```\ninterface Action {\n  // some properties here\n}\ninterface Dispatch {\n    (action: Action): void\n}\ninterface State {\n  // some properties here\n}\ninterface Thunk<R> {\n    (dispatch: Dispatch, getState?: () => State): R\n}\n\nfunction doAction(): Thunk {\n    return (dispatch, getState) => { // dispatch and getState arguments proper typed here\n        return 123;\n    }\n}\n```\n\nwithout return type annotation I should annotate arguments for returning closure (I use ts with `noImplicitAny` compiler option). And now I should explicitly write `Thunk<number>`, but compiler really can infer that type.\n"
      },
      {
        "user": "bedorlan",
        "created_at": "2017-06-09T20:59:26Z",
        "body": "I had the exact same problem. I solved it like this:\r\n\r\n```typescript\r\ninterface Action {\r\n  // some properties here\r\n}\r\ninterface Dispatch {\r\n    (action: Action): void\r\n}\r\ninterface State {\r\n  // some properties here\r\n}\r\ninterface Thunk<R> {\r\n    (dispatch: Dispatch, getState?: () => State): R\r\n}\r\n\r\nfunction doAction() {\r\n    return createThunk((dispatch, getState) => {\r\n        return 123;\r\n    })\r\n}\r\n\r\nfunction createThunk<T>(f: Thunk<T>): Thunk<T> {\r\n    return f\r\n}\r\n```\r\n\r\nHave you found a better way?\r\n"
      }
    ]
  },
  {
    "number": 5629,
    "title": "Tests: no way ensuring that super has been called.",
    "created_at": "2015-11-12T01:39:36Z",
    "closed_at": "2015-11-13T06:37:04Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/5629",
    "body": "When writing tests (using Jasmine in my case), how can one ensure that the super of a class is called?\n\nFor instance, in the following code:\n\n```\nclass Snake extends Animal {\n    constructor(name: string) { super(name); }\n    move(meters = 5) {\n        alert(\"Slithering...\");\n        super.move(meters);\n    }\n}\n```\n\nHow can one write a test ensuring `super.move()` is called when `Snake.move()` is called?\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/5629/comments",
    "author": "Izhaki",
    "comments": [
      {
        "user": "bmayen",
        "created_at": "2015-11-12T02:54:51Z",
        "body": "Should be able to spy on it and then check if it was called with `toHaveBeenCalled`\n"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2015-11-12T05:20:55Z",
        "body": "For the record, StackOverflow/StackExchange/our Gitter room/our IRC room is probably a better venue for these sorts of questions.\n"
      },
      {
        "user": "Izhaki",
        "created_at": "2015-11-12T10:58:10Z",
        "body": "@bmayen how?\n\nI can't see `super` anywhere on the prototype.\n\n@DanielRosenwasser, might be phrased as a question, but I'm really arguing this cannot be done and thus an issue.\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2015-11-13T06:37:04Z",
        "body": "there is no entity called `super` super is just an alias to the class you are extending. in this case, `Animal`. so as @bmayen mentioned, `Animal.move` is what you want to check to have been called.\n"
      },
      {
        "user": "Izhaki",
        "created_at": "2015-11-13T16:24:55Z",
        "body": "@mhegazy Still not sure I understand. `Animal` is a class, not an instance.\n\nJust to make it more concrete, given this code:\n\n```\nclass Painter extends Transformer {\n\n    //.... \n\n    translate( aTranslation: Point ) {\n        this.context.translate( aTranslation.x , aTranslation.y );\n        super.translate( aTranslation );\n    }\n\n}\n```\n\nThe test:\n\n```\ndescribe( 'translate()', function() {\n\n    beforeAll( function () {\n        spyOn( iPainter.context, 'translate' );\n        iPainter.translate( new Point( 10, 20 ) );\n    });\n\n    it( 'Should translate the context', function() {\n        expect( iPainter.context.translate ).toHaveBeenCalledWith( 10, 20 );\n    });\n\n    it( 'Should call translate on its super', function() {\n        // What's here???\n    });        \n\n});\n```\n\nWhat would be the line to replace `What's here???`\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2015-11-13T17:18:14Z",
        "body": "``` ts\nvar originalTransformenrTranslate = Transformer. prototype.translate;\nTransformer. prototype.translate = function (...args) {\n    console.log(\"Transformer.translate is called!\");\n    originalTransformenrTranslate.apply(this, args);\n}\n\nvar originalPainterTranslate = Painter. prototype.translate;\nPainter. prototype.translate = function (...args) {\n    console.log(\"Painter.translate is called!\");\n    originalPainterTranslate.apply(this, args);\n}\n\n```\n"
      },
      {
        "user": "Izhaki",
        "created_at": "2015-11-13T17:48:11Z",
        "body": "Or alternatively:\n\n```\nbeforeAll( function () {\n    spyOn( Transformer.prototype, 'translate' );\n\n    iTranslation = new Point( 10, 20 );\n    iPainter.translate( iTranslation );\n});\n\nit( 'Should call translate on its super', function() {\n    expect( Transformer.prototype.translate ).toHaveBeenCalledWith( iTranslation );\n});\n```\n\nGot it, thanks!\n"
      }
    ]
  },
  {
    "number": 5624,
    "title": "Is v1.7 going to be available on npm?",
    "created_at": "2015-11-11T22:45:18Z",
    "closed_at": "2015-11-11T23:14:56Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/5624",
    "body": "I noticed a 1.7.2 tag a while ago, but there is no corresponding package on npm.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/5624/comments",
    "author": "g162h3",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2015-11-11T23:14:51Z",
        "body": "I think 1.7.3 will be the one available. the release in a the final stabilization phase, and should be available soon.\n"
      },
      {
        "user": "reflectivecode",
        "created_at": "2015-11-23T16:45:04Z",
        "body": "I'm also waiting for the 1.7.x release.\n"
      }
    ]
  },
  {
    "number": 5612,
    "title": "Publish 1.7.x to npm",
    "created_at": "2015-11-11T14:45:06Z",
    "closed_at": "2015-11-11T17:45:58Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/5612",
    "body": "In this repo package.json already points to 1.8, however, npm version still reports 1.6.2.\nThe question is: where is 1.7 and will it be published to npm?\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/5612/comments",
    "author": "Artazor",
    "comments": [
      {
        "user": "shadeglare",
        "created_at": "2015-11-11T15:10:42Z",
        "body": ":thumbsup:\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2015-11-11T17:45:58Z",
        "body": "We like to stabilize releases for a couple of weeks before publishing them to npm. the release is in the final stabilization phases, so should be out shortly.\n"
      }
    ]
  },
  {
    "number": 5609,
    "title": "Destructuring and function properties",
    "created_at": "2015-11-11T09:59:00Z",
    "closed_at": "2015-11-11T10:56:12Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/5609",
    "body": "Hi,\n\nwe are using Visual Studio 2013 with TS 1.6\n\ni don't get why this is valid:\n\n``` typescript\nfunction foo({bar: string}) {}\n```\n\nbut this leads to a compile error:\n\n``` typescript\nfunction foo({bar: () => string}) {}\n```\n\nCompile error message is \"Cannon find name string\".\n\nFor me this is a defect behavior. What do you guys think?\n\nKind regards,\nTimo\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/5609/comments",
    "author": "Kinchkun",
    "comments": [
      {
        "user": "falsandtru",
        "created_at": "2015-11-11T10:24:11Z",
        "body": "Correct code example:\n\n``` ts\nfunction foo1({bar}: {bar: () => string}) {}\nfunction foo2({bar = () => ''}: {bar?: () => string}) {}\n```\n"
      },
      {
        "user": "Kinchkun",
        "created_at": "2015-11-11T10:56:12Z",
        "body": "I see, thank you!\n\nKind regards,\nTimo\n"
      }
    ]
  },
  {
    "number": 5570,
    "title": "Unable to define async function type",
    "created_at": "2015-11-09T10:08:09Z",
    "closed_at": "2015-11-10T01:24:16Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/5570",
    "body": "I'm just wondering if I could define an async function type. I want to create an interface where one of the properties of the interface is an async method.\n\n``` typescript\ninterface Setup {\n     asyncMethod: async () => Promise<any>; // cannot find name 'async'.\n}\n```\n\nThe reason I want to await, is so I can await on a function that returns a promise from a JS library. Also await on any type isn't working either.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/5570/comments",
    "author": "tinganho",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2015-11-09T17:44:57Z",
        "body": "`async` is only allowed in implementation. use `Promise`\n\n``` ts\ninterface Setup {\n    asyncMethod: () => Promise<number>;\n}\n\nasync function asyncMethodImplementation() {\n    return 0;\n}\n\nvar s: Setup;\n\ns.asyncMethod = asyncMethodImplementation;\n```\n"
      },
      {
        "user": "tinganho",
        "created_at": "2015-11-10T01:24:16Z",
        "body": "Ok thanks\n"
      }
    ]
  },
  {
    "number": 5568,
    "title": "Definition file: unable refernce top namespace",
    "created_at": "2015-11-09T09:11:24Z",
    "closed_at": "2015-11-10T04:33:32Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/5568",
    "body": "This code (.ts) compiles fine\n\n```\nnamespace A {\n    export enum TestEnum { One };\n}\n\nnamespace A {\n    namespace B {\n        namespace A {\n            class Test {\n                main(): TestEnum {\n                    return TestEnum.One;\n                }\n            }\n        }\n    }\n}\n```\n\nThis code (.d.ts) \n\n```\ndeclare namespace A {\n    export enum TestEnum { One }\n}\n\ndeclare namespace A {\n    namespace B {\n        namespace A {\n            class Test {\n                main(): A.TestEnum.One;\n            }\n        }\n    }\n}\n```\n\ncompiles with error `error TS2305: Build: Module 'A.B.A' has no exported member 'TestEnum'.`\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/5568/comments",
    "author": "MarenkovIgor",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2015-11-09T17:59:36Z",
        "body": "what version of typescript are you using? \n\nI can not seem to get a repro for this on latest:\n\n``` ts\nnamespace A {\n    export enum TestEnum { One };\n}\n\nnamespace A {\n    export namespace B {\n        export namespace A {\n            export class Test {\n                main(): TestEnum {\n                    return TestEnum.One;\n                }\n            }\n        }\n    }\n}\n```\n\ncompiling using:\n\n``` shell\n> tsc --v\nmessage TS6029: Version 1.8.0-dev.20151105\n\n> tsc C:\\test\\file1.ts --d\n```\n\nproduces:\n\n``` ts\ndeclare namespace A {\n    enum TestEnum {\n        One = 0,\n    }\n}\ndeclare namespace A {\n    namespace B {\n        namespace A {\n            class Test {\n                main(): TestEnum;\n            }\n        }\n    }\n}\n```\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2015-11-09T18:06:00Z",
        "body": "maybe i miss understood. is this .d.ts generated by the compiler or hand authored?\n\nif it is hand authored, then a few comments:\n- using the enum value `A.TestEnum.One` in a type location is not allowed, I am guessing you actually mean `TestEnum`\n- your inner namespace `A` shadows the outer `A`, so when you refer to `A` here it always means the inner one, which does not have a `TestEnum` on it.\n- options: \n  1. do not qualify it, and let the compiler find it in any enclosing scope, \n     2.if this is not possible e.g. there is another TestEnum in the path and you really want the outer one use aliasing to get the correct qualification.\n\ne.g.:\n\n``` ts\ndeclare namespace A {\n    import outerA = A;\n    namespace B {\n        namespace A {\n            class Test {\n                main(): outerA.TestEnum;\n            }\n        }\n    }\n}\n```\n"
      },
      {
        "user": "MarenkovIgor",
        "created_at": "2015-11-10T04:33:32Z",
        "body": "Ok, it`s not a bug. --d flag helped me.\n\nThank you and sorry for inconvenience.\n"
      }
    ]
  },
  {
    "number": 5542,
    "title": "Module resolution walks all parent directories to / with system module type",
    "created_at": "2015-11-05T19:59:23Z",
    "closed_at": "2015-11-06T08:45:32Z",
    "labels": [
      "Question",
      "API"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/5542",
    "body": "This 'issue' may be behaviour by design, but I couldn't find a suitable reference to this logic anywhere. So apologies if that is the case. \n\n```\n$ tsc --version\nmessage TS6029: Version 1.8.0-dev.20151105\n```\n\nSteps to repro:\n- Create empty TypeScript project in `/tmp/path/to/my/project/`\n- Create a `tsconfig.json` as follows:\n\n```\n{\n    \"compilerOptions\": {\n        \"module\": \"system\",\n        \"target\": \"es5\",\n        \"noImplicitAny\": false,\n        \"sourceMap\": false\n    },\n    \"exclude\": [\n        \"node_modules\"\n    ]\n}\n```\n- Create a single TypeScript file `/tmp/path/to/my/project/test.ts`:\n\n``` typescript\nimport * as React from \"react\";\n```\n- Compile with `tsc`. Observe the following output as expected (because we haven't installed the type definition file anywhere):\n\n```\ntest.ts(1,24): error TS2307: Cannot find module 'react'.\n```\n\nWhat's interesting however is the output of `strace`:\n\n```\n$ strace tsc 2>&1 | grep react\nread(9, \"import * as React from \\\"react\\\";\\n\", 32) = 32\nstat(\"/tmp/path/to/my/project/react.ts\", 0x7ffd985dbb00) = -1 ENOENT (No such file or directory)\nstat(\"/tmp/path/to/my/project/react.d.ts\", 0x7ffd985dbb00) = -1 ENOENT (No such file or directory)\nstat(\"/tmp/path/to/my/react.ts\", 0x7ffd985dbb00) = -1 ENOENT (No such file or directory)\nstat(\"/tmp/path/to/my/react.d.ts\", 0x7ffd985dbb00) = -1 ENOENT (No such file or directory)\nstat(\"/tmp/path/to/react.ts\", 0x7ffd985dbb00) = -1 ENOENT (No such file or directory)\nstat(\"/tmp/path/to/react.d.ts\", 0x7ffd985dbb00) = -1 ENOENT (No such file or directory)\nstat(\"/tmp/path/react.ts\", 0x7ffd985dbb00) = -1 ENOENT (No such file or directory)\nstat(\"/tmp/path/react.d.ts\", 0x7ffd985dbb00) = -1 ENOENT (No such file or directory)\nstat(\"/tmp/react.ts\", 0x7ffd985dbb00)   = -1 ENOENT (No such file or directory)\nstat(\"/tmp/react.d.ts\", 0x7ffd985dbb00) = -1 ENOENT (No such file or directory)\nstat(\"/react.ts\", 0x7ffd985dbb00)       = -1 ENOENT (No such file or directory)\nstat(\"/react.d.ts\", 0x7ffd985dbb00)     = -1 ENOENT (No such file or directory)\n```\n\ni.e. in trying to resolve the non-relative `import` of `\"react\"`, every parent directory up to and including `/` is considered as a potential location for either `react.ts` or `react.d.ts`. \n\nWe got bitten by this the other day because I happened to have a copy of `react.d.ts` kicking around in a parent directory (two directories higher) of our project. The compiler also picked up the intended version within our project, installed via `tsd` in a `typings` subdirectory. This threw a number of 'duplicate definition' errors (which in the circumstances, i.e. loading two copies of the same file, is expected behaviour).\n\nSo the unexpected behaviour here was:\n- walking all the way to '/'\n- but also the non-relative import trying to load a file in the first place given the `\"system\"` module setting (but again I could be missing something here)\n\nPlease can someone confirm whether this is by design on both counts?\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/5542/comments",
    "author": "myitcv",
    "comments": [
      {
        "user": "vladima",
        "created_at": "2015-11-05T23:15:55Z",
        "body": "Currently this is by design. TypeScript has two strategies to resolve module names:\n- node - mimics the way how module names are resolved in Nod\n- classic - original strategy that involves folder walk and does not make distinctions between relative and non-relative names.\n  Strategy can be specified via `moduleResolution` compiler option. If this option is omitted compiler will use `node` when target module kind is `commonjs` and `classic` otherwise. In #5039 we plan to add path-mapping based way to do module resolution that I think will do what you need\n"
      },
      {
        "user": "myitcv",
        "created_at": "2015-11-06T08:45:32Z",
        "body": "@vladima - thanks for confirming. I'll pick up the thread of #5039 and close this issue.\n"
      }
    ]
  },
  {
    "number": 5529,
    "title": "union with type parameters.",
    "created_at": "2015-11-04T18:45:03Z",
    "closed_at": "2015-11-04T22:39:36Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/5529",
    "body": "I noticed that union with type parameters resolved type variable too agressively.\n\n```\nvar csv: Dsv;\ntype Dict<T> = { [key: string]: T };\ntype S= Dict<string>;\ntype DsvAccessor<T> = (rows: S[], index?: number)=> T ;\ninterface DsvCallback<T>{\n    (rows: T[]): void;\n    (error: any, rows: T[]): void;\n}\ninterface Dsv {\n       (url: string, accessor?: DsvAccessor<S|void>, callback?: DsvCallback<S>): DsvXhr<S>;\n    <T>(url: string, accessor?: DsvAccessor<T|void>, callback?: DsvCallback<T>): DsvXhr<T>;\n\n}\n\ninterface DsvXhr<T> {\n}\n\ninterface Data{\n    a: number;\n}\nfunction f1(d, i){ }\nfunction f2(d, i){ return {a:'a'} }\n\ncsv('', f1, function(a){})\ncsv('', f2, function(a){})\n\nfunction f3(d: S[]){}\nfunction f4(d: S[]){ return {a: 0}}\ncsv('', f3, function(a:S[]){})\ncsv('', f4, function(a:S[]){})\n```\n\nThe non generic version types fine, while the generic version gives the following error:\n\n```\ntest.tsx(31,13): error TS2345: Argument of type '(a: { [key: string]: string; }[]) => void' is not assignable to parameter of type 'DsvCallback<{ a: number; }>'.\n  Types of parameters 'a' and 'rows' are incompatible.\n    Type '{ [key: string]: string; }[]' is not assignable to type '{ a: number; }[]'.\n      Type '{ [key: string]: string; }' is not assignable to type '{ a: number; }'.\n        Property 'a' is missing in type '{ [key: string]: string; }'.\nmessage TS6042: Compilation complete. Watching for file changes.\n```\n\nand I have to change to overload to make it pass\n\n```\n   <T>(url: string, accessor?: DsvAccessor<void>, callback?: DsvCallback<T>): DsvXhr<T>;\n   <T>(url: string, accessor?: DsvAccessor<T>,    callback?: DsvCallback<T>): DsvXhr<T>;\n```\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/5529/comments",
    "author": "co-dh",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2015-11-04T22:18:58Z",
        "body": "Could you make your sample self-contained so it's easier to understand what's going on here?\n"
      },
      {
        "user": "co-dh",
        "created_at": "2015-11-04T22:32:31Z",
        "body": "It's should be self-contained now. I have some copy & paste error.\n"
      },
      {
        "user": "co-dh",
        "created_at": "2015-11-04T22:38:26Z",
        "body": "sorry, please close this ticket.\nI made a mistake in the last line, it should be:\ncsv('', f4, function(a:Data[]){})\n"
      }
    ]
  },
  {
    "number": 5528,
    "title": "tsc with watch does not attempt to reuse oldProgram structure",
    "created_at": "2015-11-04T17:51:05Z",
    "closed_at": "2015-11-09T23:32:56Z",
    "labels": [
      "Question",
      "API"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/5528",
    "body": "When tsc is run with watch enabled, the recompile timeout handler eventually calls compile(). In compile() the call to createProgram() does not provide an oldProgram so the old program structure is never tested to see if it can be reused. Why is this?\nPerhaps related is when the watched project config file changes the cached program is set to undefined thus also never giving the chance for the call to createProgram to use oldProgram. If a project config changes it is not necessarily a reason to throw away the oldProgram.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/5528/comments",
    "author": "ToddThomson",
    "comments": [
      {
        "user": "DanielRosenwasser",
        "created_at": "2015-11-04T18:23:58Z",
        "body": ">  In compile() the call to createProgram() does not provide an oldProgram so the old program structure is never tested to see if it can be reused. Why is this?\n\nAre you sure that the program structure isn't reused? Maybe you mean in certain contexts? `recompile` calls `performCompilation` which creates a new compiler host whose `getSourceFile` uses `cachedProgram` if it is available and not invalidated.\n\n> If a project config changes it is not necessarily a reason to throw away the oldProgram.\n\nI agree; we could always just keep the intersection of the listed files and the old files in cache. I think the current behavior was adopted because it was simpler (and thus less prone to a surprise memory leak).\n"
      },
      {
        "user": "ToddThomson",
        "created_at": "2015-11-04T19:03:54Z",
        "body": "Yes, I saw that the host getSourceFile() is overridden to utilize the cachedProgram if it exists. Perhaps, I need a better understanding of what that exactly accomplishes ( other than handling file watch operations ). However, I am not sure how that effects the actual call to createProgram() from within compile(). Without actually passing in the cachedProgram to createProgram() the oldProgram structure is not tested to see if it can be used in the incremental compilation. It seems that source files from the oldProgram ( even if read by the overridden getSourceFile() ) need to be tested ( by the call to tryReuseStructureFromOldProgram() ) to see if they can be reused. If oldProgram is not provided in a call to createProgram() the old program structure is not used.\n"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2015-11-04T20:23:51Z",
        "body": "`createProgram` uses the given host object's `getSourceFile` whenever it needs a SourceFile object for a given path. `getSourceFile` will check the cache before actually doing all the hard work (i.e. dependency resolution, scanning, parsing, etc.)\n\nAfter going over it with @mhegazy, the reason we don't reuse programs when a `tsconfig.json` is modified is that the project options might have changed (e.g. `moduleResolution`, `module`) which affect the way in which dependency resolution is run. This means that when `getSourceFile` gets called again, it might give wrong results because the module resolution strategy might differ.\n\nStill this is not a stopper; my understanding is that @vladima has done some work in the language service so that we can reuse the program despite project settings changing.\n\nBy the way, if you don't mind me asking, what's your interest in the current code?\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2015-11-04T20:34:23Z",
        "body": "> When tsc is run with watch enabled, the recompile timeout handler eventually calls compile(). In compile() the call to createProgram() does not provide an oldProgram so the old program structure is never tested to see if it can be reused. Why is this?\n\nWe added this optimization for the Language Service, but never enabled it for watch scenarios. we could, not sure if there is much value there though, the LS operations are more frequent and re-resolving the whole project every request is a usage blocker.\n\nOne thing to note, the program structure is not the AST, reusing the AST is done in getSourceFile. this is about module resolution results.\n\n> Perhaps related is when the watched project config file changes the cached program is set to undefined thus also never giving the chance for the call to createProgram to use oldProgram. If a project config changes it is not necessarily a reason to throw away the oldProgram.\n\nit is simpler. changing tsconfig (as well as adding a new file/removing a file) is rather an infrequent event in the lifetime of a watch session. so we can just simplify the logic by throwing away everything. again we can always optimize it.\n"
      },
      {
        "user": "ToddThomson",
        "created_at": "2015-11-04T20:53:12Z",
        "body": "@DanielRosenwasser I use Typescript for all my javascript projects. The one thing that I need is the ability to output a single file bundle from sources that use ES6 imports. Earlier in the year I wrote a node base gulp vinyl adapter that takes as input the typescript configuration file and compiles the individual files and also looks a the file dependencies and generates bundles if the tsconfig.json file has a \"bundles\" property ( my addition to the schema ). It works perfectly for my needs ( I also use it to compile itself - producing a single file commonjs node module ).\nAlthough not the mainstream gulp typescript compiler, a number of people need the bundling capabilities so I've been adding features as I have time ( file globs, etc ). I try to stay current with the whatever the new tsconfig.json schema provides so when I saw the watch compilerOption I thought I'd add that too.\n"
      },
      {
        "user": "ToddThomson",
        "created_at": "2015-11-04T21:08:59Z",
        "body": "@mhegazy Thank-you. I guess I still need to get a better understanding of the AST. I cannot wrap my head around how your getSourceFile() from the cachedProgram is useful if a watched source file change results in a dependency change. No worries, I'll figure it out.\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2015-11-04T22:44:12Z",
        "body": "The SourceFile (AST) is used for incremental parsing. so if you have a file, and make an edit in one line, the majority of the nodes in the AST are reused, and we only re-parse the area around the change. this saves both memory and time.\n\nnow the change itself, after incremental parsing is done, could affect module resolution. e.g. you added new `import * as ns from \"module\"`, now this program should include `module.ts` in it. so we need to re-resolve the program.\n\nthe logic to reuse program structure, tries to reuse as much as it can, i.e. if non of your import changed, no need to re run the resolution (find what file `\"module\"` should resolve to) as it needs to do fileExists and folder search operations that can be expensive.\n\nagain watch implementation does not do that today. so it is possible to go update it to do that, and would give you some perf gains.\n"
      },
      {
        "user": "ToddThomson",
        "created_at": "2015-11-05T18:33:51Z",
        "body": "@mhegazy Thank-you. I get it now. My incorrect assumption was that with the watch implementation and passing oldProgram to createProgram()  and if retaining program structure that program.emits would be incremental too ( along with incremental parsing ).\nFor bundles I don't need the intermediate js, map a d.ts files, but if compiled output is needed in some cases, it would be nice to have just the set of modified file(s) and the files that are dependent on the modified file(s) emitted.\n"
      },
      {
        "user": "ToddThomson",
        "created_at": "2015-11-09T20:09:28Z",
        "body": "@mhegazy Thank-you. I've gone over the differences in the watch implementation in tsc vs the incremental change processing in services.ts.\nI've seen that the most significant perf gains come by holding onto the AST between compilations. I'll take advantage of that when building bundled external modules. I'll leave incremental parsing for now.\nFor source file changes that affect module resolution have you looked at partial reuse of the program - keeping sourceFiles that are not affected at all by the change?\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2015-11-09T23:15:02Z",
        "body": "> For source file changes that affect module resolution have you looked at partial reuse of the program - keeping sourceFiles that are not affected at all by the change?\n\nboth implementations do this already. as you mentioned, keeping the sourceFiles (AST) that have not changed between compilations is a big perf gain. \n"
      }
    ]
  },
  {
    "number": 5346,
    "title": "Stop global type leaks across commonJS modules",
    "created_at": "2015-10-21T02:43:31Z",
    "closed_at": "2015-10-21T07:00:17Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/5346",
    "body": "A lot of type definitions in DefinatelyType export CommonJS module types and a global type definition for popular libraries. I.E Jquery can be used directly from the window object but also using the require syntax. \n\nBut this causes Typescript to accept faulty code as correct. E.g using $ or jQuery directly in a commonjs module without requiring the module itself is compiled correctly, when in the first place it was a bug not to require the module. \n\nSo can there be a flag where if commonjs modules is enabled then global types are not supported, and only types exported through a module name?\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/5346/comments",
    "author": "ziahamza",
    "comments": [
      {
        "user": "weswigham",
        "created_at": "2015-10-21T05:03:39Z",
        "body": "#4913 has been proposed as a possible solution to this, but we have a number of competing proposals around the node package typing space. (You can find some of them linked in that PR)\n"
      },
      {
        "user": "ziahamza",
        "created_at": "2015-10-21T07:00:17Z",
        "body": "Awesome, then I guess we can close the issue. will keep track of them. Thanks!\n"
      }
    ]
  },
  {
    "number": 5327,
    "title": "reset tsc compiler state for external module",
    "created_at": "2015-10-19T15:41:42Z",
    "closed_at": "2015-11-13T06:46:54Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/5327",
    "body": "I noticed that we don't need reference path for some require statement if the .t.ds has been referenced in another ts file.\n\nfor example:\nIf I have A.tsx WITHOUT reference path, and:\n\nimport React = require('react')\n\nit WILL compile if another tsx file (B.tsx) have  /// <reference path=\"react.d.ts\"> \n\nThis behaviour is undesirable because it create a dependency of A.tsx on B.tsx, and if B is removed in future, A will not compile any more.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/5327/comments",
    "author": "co-dh",
    "comments": [
      {
        "user": "ahejlsberg",
        "created_at": "2015-10-19T15:50:32Z",
        "body": "You can use the `-noResolve` command line option to suppress dependency resolution and include only files that are listed on the command line or in tsconfig.json.\n"
      },
      {
        "user": "co-dh",
        "created_at": "2015-10-19T17:13:22Z",
        "body": "Glad to here your answer. But Dependency Resolution do not have to accumulate included files.\nEach file should be compiled correctly independently, And also Dependency Resolution is a nice feature that I don't want to turn off.\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2015-11-13T06:46:54Z",
        "body": "My recommendation is to not use `/// <reference >` tags.\n"
      }
    ]
  },
  {
    "number": 5303,
    "title": "Duck typing on anonymous object literals and class objects",
    "created_at": "2015-10-17T06:29:13Z",
    "closed_at": "2015-10-18T22:57:44Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/5303",
    "body": "Based on new duck typing concept fresh objects can not have access property.\nLike this\n\n``` javascript\nlet a = { name:\"Bill\"};\nlet b = {name:\"Bill\", age:20};\n\na = {name: \"James\", age:30 }; // Error - excess property not allowed\na = b; // No error - works fine\n```\n\nNow the questions is does this concept also applies to class objects\nLike this:\n\n``` javascript\nclass Human {    \n    name: string;    \n    constructor(name: string){\n        this.name = name;\n    }\n}\n\nclass Animal {\n    name: string;\n    age: number;    \n    constructor(name: string, age: number){\n        this.name = name;\n        this.age = age;\n    }\n    eat(){\n        console.log(this.name + \" is a Human and is eating\");\n    }\n}\n\nlet h1 = new Human(\"James\");\nlet a1 = new Animal(\"Dog\", 2);\nh1 = new Animal(\"Cat\", 1); //this is working -- But based on duck typing concept it should not because it has excess property and its fresh object\n```\n\nThe error is same if I remove constructor.\n\nIs there any difference in duck typing concept for anonymous objects and class objects OR may be I'm missing something?\nOr is it really considered as fresh object?\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/5303/comments",
    "author": "zeeshanhanif",
    "comments": [
      {
        "user": "ziaukhan",
        "created_at": "2015-10-17T06:33:33Z",
        "body": "I have the same question?\n"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2015-10-17T08:08:49Z",
        "body": "_Object literals_ have an associated freshness before they're bound to a variable. The same doesn't apply for any other expressions.\n\nThe idea is that object literals are often used for option bags (where the user has to manually type out each property name at each use-site), and this behavior catches typos.\n\nIf you'd like to prevent `Animal` from being assigned to a `Human`, you can add a `private` property to `Animal`, since `private` and `protected` properties need to originate from the same declaration to be compatible.\n"
      },
      {
        "user": "zeeshanhanif",
        "created_at": "2015-10-17T13:47:15Z",
        "body": "Thanks its clear now\n"
      }
    ]
  },
  {
    "number": 5282,
    "title": "Which is the max size that typescript.js support?",
    "created_at": "2015-10-16T08:56:28Z",
    "closed_at": "2015-10-17T09:03:56Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/5282",
    "body": "I have tried system.js + typescript.js + angular2 with a file with more than 720 KB aprox and it doesn't works well. It works until 700 KB aprox.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/5282/comments",
    "author": "danicomas",
    "comments": [
      {
        "user": "vladima",
        "created_at": "2015-10-16T16:04:48Z",
        "body": "can you please tell what exactly does not work? Right now it is a little bit vague.\n"
      },
      {
        "user": "danicomas",
        "created_at": "2015-10-16T16:24:07Z",
        "body": "Sorry. If you add system.js, typescript.js, angular2.js and app.ts in a HTML and you copy paste the code from app.ts inside the same file N times you will see when the file size > 710KB aprox the page scripting is executed in 700ms but with 700KB was in 3 seconds. Something wrong with >710KB. The console doesn't show errors.\n"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2015-10-16T23:19:12Z",
        "body": "Still not clear what you mean. The TypeScript compiler itself is around 4.5 MB of source and we compile in a few seconds. How are you invoking the compiler? Can you share a direct repro?\n"
      },
      {
        "user": "danicomas",
        "created_at": "2015-10-17T09:03:56Z",
        "body": "@RyanCavanaugh I am in other computer and the results are very different I will check it out on Monday in the same computer. However I don't think that it is a typescript.js issue.\n"
      }
    ]
  },
  {
    "number": 5239,
    "title": "Is it possible to import modules through absolute paths? or is something like that planned?",
    "created_at": "2015-10-13T13:45:42Z",
    "closed_at": "2015-10-21T05:21:03Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/5239",
    "body": "Currently when referring to modules I _think_ that you must use relative paths.\nFor complex structures it's not convenient for example, say we have the following project structure.\n\n```\nR\n|-- A\n|   |\n|   `-- a.ts\n|-- B\n|   |\n|   `-- b.ts\n|\n|-- c.ts\n|\n`-- tsconfig.json\n```\n\nNow let's say that module B depends on A so currently we would have to use relative paths like so:\n\n```\n// b.ts\nimport {A} from \"../A/a.ts\"\n\nexport class B {\n}\n```\n\n_I gave simplistic example but it can easily turn into more complex structure if I was nesting it a bit more._\n\nWhat I would like to do instead is as follow:\n\n```\n// b.ts\nimport {A} from \"./A/a.ts\"\n\nexport class B {\n}\n```\n\nBasically what I'm suggesting is to resolve the dependency from the root where the root can either be specified to the compiler or otherwise starts from the tsconfig.json file.\n\nMaybe you can borrow the symbol from ASP.NET where they use tilde to refer to the application root like so:\n\n```\n// b.ts\nimport {A} from \"~/A/a.ts\"\n\nexport class B {\n}\n```\n\nResolving the dependencies from the root feels more robust and reads a lot better when dealing with nested dependencies.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/5239/comments",
    "author": "iam3yal",
    "comments": [
      {
        "user": "jbrantly",
        "created_at": "2015-10-13T16:00:53Z",
        "body": "Related: #5039\n"
      },
      {
        "user": "iam3yal",
        "created_at": "2015-10-13T17:50:00Z",
        "body": "@jbrantly thanks mate! \n"
      }
    ]
  },
  {
    "number": 5180,
    "title": "sourceRoot should support relative paths and respect folder hirearchy",
    "created_at": "2015-10-08T19:12:20Z",
    "closed_at": "2015-10-09T02:10:59Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/5180",
    "body": "When supplying sourceRoot, it is just directly copied into the source map file as is. This doesn't work correctly with rootDir and outDir options. For example, if I have the following structure:\n\nrepo/src/www/foo.ts\nrepo/src/bar.ts\n\nand I want to output the files into repo/out/, I tried using sourceRoot: '../src' and that works okay for bar.js, but not www/foo.js. I hope this explanation makes sense.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/5180/comments",
    "author": "seanzer",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2015-10-08T22:14:40Z",
        "body": "`sourceRoot` represents the root to use by the debug to locate the sources relative to. if you just want a relative path, do not set sourceRoot and the right thing should happen..\n\nso here is my setup:\n\ntsconfig.json\n\n``` json\n{\n    \"compilerOptions\": {\n        \"rootDir\": \"./\",\n        \"outDir\": \"./out\",\n        \"sourceMap\": true\n    }\n}\n```\n\ncompiling, i get:\n\n``` cmd\nC:\\test\\5180>type out\\bar.js.map\n{\"version\":3,\"file\":\"bar.js\",\"sourceRoot\":\"\",\"sources\":[\"../src/bar.ts\"],\"names\":[],\"mappings\":\"AAAA,IAAI,CAAC,GAAE,CAAC,CAAC\"}\nC:\\test\\5180>type out\\www\\foo.js.map\n{\"version\":3,\"file\":\"foo.js\",\"sourceRoot\":\"\",\"sources\":[\"../../src/www/foo.ts\"],\"names\":[],\"mappings\":\"AAAA,IAAI,CAAC,GAAG,CAAC,CAAC\"}\n```\n"
      },
      {
        "user": "seanzer",
        "created_at": "2015-10-09T02:10:59Z",
        "body": "My mistake, it looks like it works when I use tsc. It looks to be an issue with gulp integration. Thanks.\n"
      },
      {
        "user": "pleerock",
        "created_at": "2016-07-14T04:31:06Z",
        "body": "@mhegazy @sheetalkamat  I have following tsconfig.json:\n\n``` json\n{\n    \"compilerOptions\": {\n        \"rootDir\": \"./\",\n        \"outDir\": \"./out\",\n        \"sourceMap\": true\n    }\n}\n```\n\nmy sources are in **./src**\nAnd in source maps I have `\"sources\":[\"../../src/index.ts\"]`\nThis is correct for development, but what I want to do for production build is `\"sources\":[\"src/index.ts\"]` (because I emit source maps with source code, and want in production build to have ts near its js). Is there way to do it?\n"
      }
    ]
  },
  {
    "number": 5142,
    "title": "VSCode shows me  \"Type must have a [Symbol.iterator]() method (...) \"  but Type has it.",
    "created_at": "2015-10-06T22:17:03Z",
    "closed_at": "2015-11-13T06:31:19Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/5142",
    "body": "I can see that error with this code:\n\n```\nfunction* numIterator(num: number) {\n    var n = parseInt(num.toString()).toString();\n    var length = n.length;\n    for (var i = length - 1; i >= 0 ; --i){\n        yield n.charAt(i);\n    }   \n}\n\nNumber.prototype[Symbol.iterator] = function() {\n    return  numIterator(this.valueOf());\n}\nvar num = 2387;\nfor (var n of num){ // Error in VSCode but It works fine in Chrome\n    console.log(n) // 7, 8, 3, 2\n}   \n\n```\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/5142/comments",
    "author": "xLama",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2015-10-06T22:29:00Z",
        "body": "You are augmenting the `Number` interface without telling the type system about it, so it does not know that a number now has an iterator. you need to augment the declaration of interface `Number` to add the iterator declaration, so adding something like this to your file should get rid of the error:\n\n``` ts\ninterface Number {\n    [Symbol.iterator](): IterableIterator<string>;\n}\n\n```\n"
      }
    ]
  },
  {
    "number": 5112,
    "title": "after compile .d.ts files  will not be included in build (outDir) folder",
    "created_at": "2015-10-05T13:20:06Z",
    "closed_at": "2015-10-08T10:52:35Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/5112",
    "body": "Hello.\ni have typescript project.\nit contains autogenerated from .net interfaces.\nfile has .d.ts extension and contains in tsconfig.json\nafter compile in outDir i have js, d.ts for my source but i havnt autogenerated.d.ts\nWhy d.ts is not included in compilation result? \n\nI think, each d.ts files should be included in outDir according project sources tree\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/5112/comments",
    "author": "stepancar",
    "comments": [
      {
        "user": "danquirk",
        "created_at": "2015-10-05T19:06:13Z",
        "body": "The .d.ts files you use are an input to the build system but not an output. It's perfectly reasonable to consume some types from a .d.ts but have your output not use those types, so there'd be no reason to distribute the input .d.ts with your build results. It sounds like you'll want a post-build step in your build tool to copy the relevant .d.ts files wherever you need them.\n"
      },
      {
        "user": "stepancar",
        "created_at": "2015-10-05T22:08:22Z",
        "body": "@danquirk , thank you for your answer! I have in serverModels.d.ts declarations of server models. In my projects i use this declarations for checking translation from client models to server models. \nd.ts  participates in project type checking. Imagine that project which i described is npm module, which contains api-services. In another typescript code i will import this one apiservice from package described before.\napi service returns server models, described in serverModels.d.ts, but after compile d.ts has not was copyed to putput of package, and it not available. Yep, i can use grunt, gulp for copy, but i think that its compile problem. exported d.ts can relates to serverModels.d.ts, which is not in output dir, it means out tree of d.ts is not correct\n"
      },
      {
        "user": "stepancar",
        "created_at": "2015-10-07T09:34:36Z",
        "body": "@danquirk, @RyanCavanaugh, @basarat, Can you help me to solve my problem? Or maybe I should provide you repo with example?\nThank you!\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2015-10-07T17:19:59Z",
        "body": "The .d.ts files are considered \"references\" the compiler will not touch them, not move them, or recreate them. the only thing it will do, if you have a `/// <reference >` to an input.d.ts, the generated output will have the reference rewritten to point to the source location.\nAn easy way to think of the .d.ts files is that they go along with your .js files. if you are copying the .js files, you should copy the matching .d.ts.\n"
      },
      {
        "user": "basarat",
        "created_at": "2015-10-07T23:27:00Z",
        "body": "what he said ^ `.d.ts` are not moved around -> by design :rose: \n\nThere are reasons why I feel this is good ... e.g. one would not want `node.d.ts` to be moved around ... its just an ambient ref, that any module consumer should include themselves if they need it.\n"
      },
      {
        "user": "stepancar",
        "created_at": "2015-10-08T10:52:35Z",
        "body": "Thank you!\n"
      },
      {
        "user": "vsarunov",
        "created_at": "2017-03-10T15:21:06Z",
        "body": "Is there a workaround to include custom typings files? For instance I have a custom main.d.ts file with interfaces:\r\n\r\n```\r\ninterface s1 {\r\n  ...\r\n}\r\n\r\ninterface s2 {\r\n....\r\n}\r\n\r\ninterface s3 {\r\n...\r\n}\r\n```\r\n\r\nI have a main file index.ts which is refered in the package.json file:\r\n\r\n```\r\nimport t1=require('...');\r\nimport t2=require('..');\r\n\r\nexport{\r\nt1,\r\nt2\r\n}\r\n```\r\n\r\nif I add to it tripple slash references the generated d.ts file for it will change it references to refer to the source. How can I include the custom d.ts files and still have the correct references (without manually changing the generated files and without manually dragging and dropping custom d.ts files."
      },
      {
        "user": "mhegazy",
        "created_at": "2017-03-10T17:08:49Z",
        "body": "Add the file in your tsconfig.json in the \"include\" section."
      },
      {
        "user": "vsarunov",
        "created_at": "2017-03-13T09:12:06Z",
        "body": "No, it is not being included. I have read the documentation and read all the responses on github and stackoverflow concerning this topic, if I specify only the d.ts file nothing gets compiled, if I specify both files (the main entry point file and the d.ts file) it compiles, but still the d.ts file is not included.\r\n\r\nUpdate: Found a way around."
      },
      {
        "user": "JonWallsten",
        "created_at": "2017-09-13T10:30:05Z",
        "body": "@vsarunov If you found a way around please  publish it here for others to find."
      },
      {
        "user": "motss",
        "created_at": "2018-03-29T04:00:21Z",
        "body": "When `include` does not include in the compilation, it sounds very ironic to me."
      }
    ]
  },
  {
    "number": 5093,
    "title": "accidental duplicate",
    "created_at": "2015-10-03T11:18:03Z",
    "closed_at": "2015-10-06T00:29:10Z",
    "labels": [
      "Duplicate",
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/5093",
    "body": "I have a general question about project structures / modules.\nIt's a project with 3 types of code:\n- client: classes used for the client web-app, built into a single js file (with --out).\n- server: code running on node\n- shared: classes used by both client and server, typically model classes with functions like validation, etc\n\nMy aim is this:\n- use 1 file per 1 class at the source level\n- deploy the client app into a single output file (for performance reasons: better start up time), the server can be deployed as many files (or if possible and makes sense from a perf. point of view it can be a single file too). These can be 2 separate compilations, the client with --out and the server with commonjs.\n- reuse the shared model classes (without duplication) in the client and the server\n- be able to use circular dependencies (although shared code will not depend on client/node code, only the other way around, circular dependencies can only occur in within the client code)\n\nI can't seem to achieve these goals. The problem is this:\n- if I structure the shared code so that I only use the ///<reference.../> tags (like I do in the client) that won't be usable when compiling the server with common.js\n- if I use common.js style requires in the shared code then that won't work for the client's single file --out compilation\n\nThese are the options I think I have:\n- switch to using require js (amd) in the client as opposed to references and the single file output, and maybe use some post compile script to concatenate the modules to a single file. However circular dependencies may occur sometimes and that's a big issue I have with require.js\n- switch to using es6 style module syntax and use it on the client and in node with some polyfills/loaders until natively supported\n- switch to using commonjs style modules and load them with browserify on the client\n- do a pre-compilation step and transform the shared code to be eligible once for the client side single output compilation and once for the node.js side common.js compilation. However this can have many caveats and sounds like a hack.\n\nWhat I think I'm really looking for is a way for each TypeScript class/file to be able to \"say\" what is the class it exports, but not specify how it will be consumed, ie. via commonjs or as a single file output. Probably that's not possible though in a simple way?\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/5093/comments",
    "author": "andrewvarga",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2015-10-06T00:29:10Z",
        "body": "duplicate of #5094?\n"
      }
    ]
  },
  {
    "number": 5078,
    "title": "ES6 Promise definition has non-optional property [Symbol.toStringTag]",
    "created_at": "2015-10-02T15:01:14Z",
    "closed_at": "2016-02-20T00:43:24Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/5078",
    "body": "I am using TypeScript with AngularJs I am trying to cast Angular's ng.IPromise to an ES6 Promise, but I am getting the following error:\n\nType 'Promise<any>' has non-optional property '__@toStringTag' which is not present in the type 'IPromise<any>'\n\nCan the [Symbol.toStringTag] property be made optional so that this Promise definition can interface with other definitions?\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/5078/comments",
    "author": "bgoerdt",
    "comments": [
      {
        "user": "rbuckton",
        "created_at": "2015-10-02T22:25:49Z",
        "body": "The `Promise` interface in lib.es6.d.ts matches the API for the specification for ES6. There is also a `PromiseLike` interface in both lib.d.ts and lib.es6.d.ts:\n\n``` ts\ninterface PromiseLike<T> {\n    /**\n    * Attaches callbacks for the resolution and/or rejection of the Promise.\n    * @param onfulfilled The callback to execute when the Promise is resolved.\n    * @param onrejected The callback to execute when the Promise is rejected.\n    * @returns A Promise for the completion of which ever callback is executed.\n    */\n    then<TResult>(onfulfilled?: (value: T) => TResult | PromiseLike<TResult>, onrejected?: (reason: any) => TResult | PromiseLike<TResult>): PromiseLike<TResult>;\n    then<TResult>(onfulfilled?: (value: T) => TResult | PromiseLike<TResult>, onrejected?: (reason: any) => void): PromiseLike<TResult>;\n}\n```\n\nAre you targeting ES6? \n"
      }
    ]
  },
  {
    "number": 5068,
    "title": "Generic type inference broken when using | anywhere in a class",
    "created_at": "2015-10-02T02:17:34Z",
    "closed_at": "2016-02-20T00:45:01Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/5068",
    "body": "NOTE: This is a different issue to #5052, which was a spurious example based on stripping down the example code too much.\n\nThe below code fails to compile because the Schema type is not correctly inferred. The root cause is this declaration in the BaseData<schema> class.\n\n``` Typescript\n    data(in_newData: Schema[] | Array<{}>): void;\n```\n\nIf I remove that method, or change it to only take Schema[], then everything compiles OK.\n\nExample Code:\n\n``` Typescript\ndeclare class BaseData<Schema> {\n    default(): Schema;\n    data(in_newData: Schema[] | Array<{}>): void;\n}\n\ndeclare class Widget<Schema> {\n    constructor(data: BaseData<Schema>);\n    default(): Schema;\n}\n\ndeclare interface DataSchema {\n    name: string;\n}\ndeclare class ExtendedData extends BaseData<DataSchema> { }\n\nfunction test() {\n    let widgetWithExtendedData = new Widget(new ExtendedData());\n    // Compile error. Intellisense shows widgetWithExtendedData as type Widget<{}>\n    console.log(widgetWithExtendedData.default().name);\n}\n```\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/5068/comments",
    "author": "rwyborn",
    "comments": [
      {
        "user": "rwyborn",
        "created_at": "2015-10-02T02:20:13Z",
        "body": "Follow up. I can also fix the compile error by changing the BaseData declaration to the following:\n\n``` Typescript\ndeclare class BaseData<Schema> {\n    default(): Schema;\n    data(in_newData: Schema[]): void;\n    data(in_newData: Array<{}>): void;\n}\n```\n"
      },
      {
        "user": "ahejlsberg",
        "created_at": "2015-10-02T13:58:13Z",
        "body": "The issue arises when trying to infer from the type `DataSchema[] | {}[]` to the type `Schema[] | {}[]`. Union type inference relates each source type to each target type, so we end up inferring that `Schema` _might_ be `{}`, which indeed is true given the way you're written the types.\n\nI'm wondering why you're writing `Schema[] | {}[]` in the first place? You might as well just write `{}[]` since any array type is assignable to `{}[]`. That should solve the problem.\n"
      },
      {
        "user": "rwyborn",
        "created_at": "2015-10-06T23:07:07Z",
        "body": "Hi @ahejlsberg, here is a more complete example. Apologies for the slow response, I have been extracting this example code from a large code base... it was tricky to isolate exactly what real world combination was triggering the issue.\n\n``` Typescript\ndeclare interface Event {\n}\n\ndeclare class EventCollection {\n    push(...events: Event[]): number;\n}\n\ndeclare class ModelArray<Schema> extends EventCollection {\n    toJSON(): Schema[];\n}\n\ndeclare class BaseData<Schema> {\n    default(): Schema;\n    data(in_newData: Schema[] | ModelArray<Schema>): void;\n}\n\ndeclare class Widget<Schema> {\n    constructor(data: BaseData<Schema>);\n    default(): Schema;\n}\n\ndeclare interface DataSchema {\n    name: string;\n}\ndeclare class ExtendedData extends BaseData<DataSchema> { }\n\nfunction test() {\n    let widgetWithExtendedData = new Widget(new ExtendedData());\n    // Compile error. Intellisense shows widgetWithExtendedData as type Widget<Event>\n    console.log(widgetWithExtendedData.default().name);\n}\n```\n\nI think the problem is that the structural typing is inferring that EventCollection is an Array<T>, and therefore has generic type Event, which is then inferred to be the generic type of BaseData (where it should be Schema).\n\nThinking about this there are probably any number of complex cases where there is an ambiguous choice for a generic type based on structural typing alone. In the case above (which at least in our codebase is very common) there is a simple solution... walk the class hierarchy first to see if that yields a match for generic type, and only if no match is found go to structural typing. You mentioned that already if there is an exact type match you infer the generic type directly rather than going to structural typing... so this is just an extension of that. For example if I had\n\n``` Typescript\ndeclare class Base<Schema> {}\ndeclare class Derived<Schema> extends Base<Schema> {}\ndeclare class Concrete extends Derived<MyCustomSchema> {}\n\nfunction Process<Schema>(data:Base<Schema>) {\n}\n\nProcess(new Concrete());\n```\n\nWe would walk the hierarchy based on the known type of the data param for Process\n\n```\n- Concrete matches Base<Schema>? No, go to parent\n- Derived<MyCustomSchema> matches Base<Schema>? No, go to parent\n- Base<MyCustomSchema> matches Base<Schema>? Yes, generic type is MyCustomSchema\n```\n\nOf course you would have to traverse the interface hierarchy as well, but I think all up this would result in much more robust generic type inference compared to relying on structural typing alone.\n"
      }
    ]
  },
  {
    "number": 5057,
    "title": "jake local fails",
    "created_at": "2015-10-01T18:55:28Z",
    "closed_at": "2015-11-13T06:28:38Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/5057",
    "body": "Hi,\n  since I have a few issues with tsx inside vs, I would like to use the latest language service instead of the packaged one to see if something is different.\n  I updated my typescript clone and launched **jake local** (I have already done this in the last months) but this time fails:\n  if I run from a command shell I obtain this error message\n\n> jake aborted.\n> Error: Cannot find module 'tslint'\n>    at Function.Module._resolveFilename (module.js:336:15)\n>    at Function.Module._load (module.js:278:25)\n> (See full trace by running task with --trace)\n\nif I run from powershell\n\n> module.js:338\n>    throw err;\n>          ^\n> Error: Cannot find module 'lru-cache'\n>    at Function.Module._resolveFilename (module.js:336:15)\n>    at Function.Module._load (module.js:278:25)\n>    at Module.require (module.js:365:17)\n>    at require (module.js:384:17)\n>    at D:\\GitHub\\typescript\\node_modules\\jake\\node_modules\\filelist\\node_modules\\minimatch\\minimatch.js:35:11\n>    at Object.<anonymous> (D:\\GitHub\\typescript\\node_modules\\jake\\node_modules\\filelist\\node_modules\\minimatch\\minimatch.js:1057:3)\n>    at Module._compile (module.js:460:26)\n>    at Object.Module._extensions..js (module.js:478:10)\n>    at Module.load (module.js:355:32)\n>    at Function.Module._load (module.js:310:12)\n\nThis is the first time I see something similar. Am I missing something?\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/5057/comments",
    "author": "lucamorelli",
    "comments": [
      {
        "user": "danquirk",
        "created_at": "2015-10-01T19:15:51Z",
        "body": "Run 'npm install' to update the necessary dependencies.\n"
      },
      {
        "user": "lucamorelli",
        "created_at": "2015-10-01T19:54:53Z",
        "body": "looks like it solved, but I don't understand why works fine from a powershell admin console and not from a cmd admin console\n"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2015-10-01T21:29:30Z",
        "body": "@weswigham does `&&` execute conditionally in PowerShell?\n"
      },
      {
        "user": "weswigham",
        "created_at": "2015-10-01T22:07:35Z",
        "body": "`&&` was removed from powershell as a valid deliminator recently, I think. You have to use `;` instead.\n"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2015-10-01T22:15:52Z",
        "body": "Awesome. Is there anything we can do to keep the two consistent?\n"
      },
      {
        "user": "weswigham",
        "created_at": "2015-10-01T22:23:05Z",
        "body": "Cross-shell compatibility has never been easy... ahh... `|` I believe is supported on most shells, which could work if everything that needs to be run doesn't care about the output of the prior process...\n"
      },
      {
        "user": "weswigham",
        "created_at": "2015-10-01T22:26:30Z",
        "body": "@DanielRosenwasser But his question why why it worked in powershell but not in cmd, so I'm not sure it's important.\n"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2015-10-01T22:29:04Z",
        "body": "This means that PowerShell wasn't explicitly failing even though `tslint` wasn't present.\n"
      },
      {
        "user": "weswigham",
        "created_at": "2015-10-01T22:54:07Z",
        "body": "Looking at his stack traces, the different is that in powershell he was never even able to load `jake` from the local node_modules dir whereas in `cmd` he had at least gotten `jake` installed and started to read the jakefile before it got to the missing tslint dependency.\n"
      },
      {
        "user": "weswigham",
        "created_at": "2015-10-01T22:54:45Z",
        "body": "I don't see anything there that would have anything to do with a `&&` at all.\n"
      },
      {
        "user": "weswigham",
        "created_at": "2015-10-01T23:01:18Z",
        "body": "@DanielRosenwasser Also, TIL `;` is a valid separator in bash. I've always used `&&`.\n"
      }
    ]
  },
  {
    "number": 5034,
    "title": "Destructuring variable declarations with types",
    "created_at": "2015-09-30T07:28:02Z",
    "closed_at": "2015-09-30T14:42:42Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/5034",
    "body": "There doesn't seem to be a way to specify type information on destructuring variable declarations with types.  For example:\n\n```\nfunction someFunc(data: any) {\n    const { x:string, y:number, z:boolean } = data;\n}\n```\n\nThis will be interpreted, as per ES6 rules, as the field `data.x` being assigned to a variable named `string` and so on.\n\nThe alternative syntax discussed before in another issue:\n\n```\nfunction someFunc(data: any) {\n    const { x::string, y::number, z::boolean } = data;\n}\n```\n\ndid not make it into the current version.\n\nCurrently, you need to use initializers to _fudge_ the typing info:\n\n```\nfunction someFunc(data: any) {\n    const { x=\"\", y=0, z=false } = data;\n}\n```\n\nbut then it becomes weird if you want a different default value:\n\n```\nfunction someFunc(data: any) {\n    const { x=null as string, y=null as number, z=null as boolean } = data;\n}\n```\n\nCan we put back a way to declare the types of destructuring pieces?  This is very useful especially when integrating with legacy code, where there is limited type information upstream.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/5034/comments",
    "author": "schungx",
    "comments": [
      {
        "user": "ahejlsberg",
        "created_at": "2015-09-30T13:26:24Z",
        "body": "You _can_ use type annotations with destructuring patterns, but only on the top-level pattern:\n\n``` typescript\nfunction someFunc(data: any) {\n    const { x, y } : { x: number, y: number } = data;\n}\n```\n\nIt's not the greatest, but at least it is clear what is going on. I'm concerned that proposals to introduce more overloaded meanings for `:` or `as` in destructuring patterns just make matters worse.\n"
      },
      {
        "user": "schungx",
        "created_at": "2015-09-30T14:42:42Z",
        "body": "Not the greatest, since it requires double-typing the property names which may lead to errors before 1.6.  1.6 will now catch the mismatched property names.\n\nBut I hear you about over-over-loading `:`.\n"
      },
      {
        "user": "RobertoMalatesta",
        "created_at": "2016-05-12T09:39:52Z",
        "body": "At @ahejlsberg  sorry to bug you on an already closed issue, \nbut having naming parameters would be a boon expecially when having functions/methods with more than an optional parameter.\n\nES6 destructuring does not fit the bill since having to pass a single data parameter and then destructuring:\n1) does not allow to use the signature as an implicit documentation for the function user.\n2) forces the implementer to unpack the data\n\nC# has it and it's one of the things I miss most in Java (I would set naming parameters mandatory sometimes).\n\nIf the problem with them is the overloading of \" : \", cannot we use, say, \" := \" ?\n\nTo avoid run-time performance, naming a parameter could only be accepted in a call where all parameters are named and passed, thus allowing the compiler to rearrange them.\n\nThanks for 30+yrs of good compilers -- RM\n"
      }
    ]
  },
  {
    "number": 5006,
    "title": "program recreated on every services call (programUpToDate always returns false)",
    "created_at": "2015-09-28T23:03:27Z",
    "closed_at": "2015-11-13T06:33:43Z",
    "labels": [
      "Question",
      "API"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/5006",
    "body": "From `programUpToDate` in services/services.ts:\n\n```\n// If number of files in the program do not match, it is not up-to-date\nlet rootFileNames = hostCache.getRootFileNames();\nif (program.getSourceFiles().length !== rootFileNames.length) {\n    return false;\n}\n```\n\n`program.getSourceFiles()` is generally longer than `rootFileNames`, because it includes non-root files (the default lib `lib.d.ts`, plus any files included by `import` or `<reference>`)\n\nAs a result of this, `program` is re-created on every `synchronizeHostData` call, resulting in a lot of unnecessary work being done.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/5006/comments",
    "author": "jeffreymorlan",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2015-09-28T23:13:31Z",
        "body": "Which version are you using? \n\nwith 1.6, createProgram takes an old program as an option allowing for reusing almost all of the program structure. the time spent in \"refreshing\" a program if nothing changed should be in the order of 10 ms. if you are not seeing that, then there is something more going on.\n"
      },
      {
        "user": "jeffreymorlan",
        "created_at": "2015-09-28T23:32:48Z",
        "body": "Version 1.6. `createProgram` doesn't take a long time _itself_, but it does mean that calling `getSemanticDiagnostics` on all source files in a large project takes significantly longer than it should (over twice as long). Type checking one file requires doing some of the work to type check other files, and that work gets thrown away if the program is recreated for each file.\n\nAs a workaround I'm implementing `getProjectVersion` in the LanguageServiceHost, but other editors probably don't do that (tsserver doesn't at least)\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2015-09-29T00:41:09Z",
        "body": "that is correct. you have two options, you can implement as you noted getProjectVersion, or make sure you do the resolution separably and make sure to pass all files to the language service, so that the program will always be used (i.e. `rootfiles === oldProgram.sourceFiles()`). \n\nFor tsserver, it does not query for all files for errors, it only does for open files, which limits the number of requests. \n\nthe value here is it simplifies the host implementation, and the host does not even need to know about what a project is.\n"
      }
    ]
  },
  {
    "number": 4968,
    "title": "Cannot export class expressions",
    "created_at": "2015-09-25T12:58:54Z",
    "closed_at": "2015-09-28T18:18:25Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/4968",
    "body": "```\nvar SomeClass = new (class\n{\n\n});\n```\n\nYields:\nExported variable 'SomeClass' has or is using private name '(Anonymous class)'.\n\nBug? Spec?\n\n(My goal was to use this structure as a singleton class of sorts, rather than making a class and remembering to mark all members as static)\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/4968/comments",
    "author": "Truebase-com",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2015-09-25T16:47:42Z",
        "body": "This error is generated as the compiler is writing the declaration file; it could not write a type annotation for your variable; generally a class types can not be inlined as  an object type literal, and the winter does not introduce new named declarations that were not in the file. One possible change is to allow for class expressions to be used at type position. \n\nTo Silve this issue, either make it a class declaration or give your variable an explicit type annotation so the .d.ts file can use it instead.\n"
      },
      {
        "user": "Truebase-com",
        "created_at": "2015-09-25T16:52:25Z",
        "body": "Ok, so I guess this doesn't work then. I was hoping for an improved syntax for static classes that doesn't involve exporting two members (Thing and ThingStatic), or remembering to make every member static.\n"
      },
      {
        "user": "ahejlsberg",
        "created_at": "2015-09-25T18:24:12Z",
        "body": "Just as an aside, a simple way to make a singleton is to export a namespace:\n\n``` typescript\nexport namespace Utils {\n    export function foo(...) {...}\n    export function bar(...) {...}\n}\n```\n"
      }
    ]
  },
  {
    "number": 4927,
    "title": "Inline casting? ",
    "created_at": "2015-09-22T14:57:10Z",
    "closed_at": "2015-09-22T16:20:04Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/4927",
    "body": "Instead of doing something like the following:\n\n```\nlet myCastedObj = <SomeType>obj\n\nmyCastedObj.doSomething()\n```\n\nCan I do the following?\n\n```\n<<SomeType>obj>.doSomething()\n```\n\nIt _seems_ like I can't but is there a way to achieve this?\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/4927/comments",
    "author": "iam3yal",
    "comments": [
      {
        "user": "kitsonk",
        "created_at": "2015-09-22T15:25:44Z",
        "body": "``` typescript\n(<SomeType> obj).doSomething();\n```\n"
      },
      {
        "user": "iam3yal",
        "created_at": "2015-09-23T16:39:26Z",
        "body": "@kitsonk thanks mate! :)\n"
      }
    ]
  },
  {
    "number": 4863,
    "title": "Manually add to SystemJS imports, just like <amd-dependency> does for AMD",
    "created_at": "2015-09-18T19:57:14Z",
    "closed_at": "2015-09-18T20:54:22Z",
    "labels": [
      "Needs More Info",
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/4863",
    "body": "I'm developing with Aurelia which uses SystemJS loader. \nThere are cases where I need to use special kind of \"import\" to load CSS dynamically.\nwhile the code below is fine with Babel, it obviously doesn't compile with TypeScript\n`import 'bootstrap/css/bootstrap.css!'`\n\nTo make use of this feature I had to switch to AMD module loader and use `<amd-dependency path=\"bootstrap/css/bootstrap.css!\">` which emits proper code\n\nI'd love to see similar feature for SystemJS\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/4863/comments",
    "author": "migajek",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2015-09-18T20:07:16Z",
        "body": ">  it obviously doesn't compile with TypeScript\n\nthis compiles fine for me. what version are you using?\n\n``` cmd\nc:\\ts>type c:\\test\\module3.ts\nimport 'bootstrap/css/bootstrap.css!'\n\nc:\\ts>tsc c:\\test\\module3.ts --m system\n\nc:\\ts>type c:\\test\\module3.js\nSystem.register(['bootstrap/css/bootstrap.css!'], function(exports_1) {\n    return {\n        setters:[\n            function (_1) {}],\n        execute: function() {\n        }\n    }\n});\n```\n"
      },
      {
        "user": "migajek",
        "created_at": "2015-09-18T20:50:22Z",
        "body": "@mhegazy my bad, I'm _really_ sorry, this seems to be related to the (outdated) ReSharper I'm using.\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2015-09-18T20:54:22Z",
        "body": "No worries. Glad we got to the bottom of it.\n"
      }
    ]
  },
  {
    "number": 4838,
    "title": "Extending from a class with generics breaks type checking?",
    "created_at": "2015-09-17T09:54:26Z",
    "closed_at": "2015-09-17T14:32:27Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/4838",
    "body": "Hello all.\n\nWhle trying to implement a simple serialization for my models, I stumbled upon what I think is a bug.\n\nConsider the following scenario:\n\n``` typescript\ninterface ITest {\n    a: number,\n    b: number\n}\n\nclass Test extends BaseModel<ITest> {\n    constructor(obj:ITest) {\n        super(obj);\n    }\n}\n\nclass BaseModel<T> {\n    constructor(obj:T) {\n        for (var propName in obj) {\n            this[propName] = obj[propName];\n        }\n    }\n}\n\nvar array:Test[];\narray.push({c: \"test\"});\n```\n\nI expect the array.push() in the last line to fail because I would be pushing something that does not conform. Instead, no error is thrown on that line.\n\nAm I doing something wrong?\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/4838/comments",
    "author": "lorthirk",
    "comments": [
      {
        "user": "ahejlsberg",
        "created_at": "2015-09-17T14:32:07Z",
        "body": "Problem is that the `Test` type has no members, meaning that any object type assignable to it. This is an effect of TypeScript's structural type system (specifically, a source object type is assignable to a target object type as long as the source object type has all the properties of the target object type--which in your case is none). Once you add members to `Test` you get the expected behavior.\n"
      }
    ]
  },
  {
    "number": 4713,
    "title": "Questions about type inference for tuple types in 1.6 spec",
    "created_at": "2015-09-09T19:48:07Z",
    "closed_at": "2015-09-09T21:29:14Z",
    "labels": [
      "Question",
      "Spec"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/4713",
    "body": "The following text was added in 1.6 spec (3.11.7):\n\n> Otherwise, if S and T are tuple types with the same number of elements, inferences are made from each element type in S to each corresponding element type in T\n\nIt's a little bit unclear why special processing for tuples is needed. Inferences for element types would be made anyway, because default processing for object types would make inferences for each property, including tuple numerical properties. Is it just to prevent inferences for numerical index signatures? Could you provide an example where default processing can go wrong?\n\nAnd the second question. What happens if S and T are tuple types with different numbers of elements? Default processing for object types or no inferences at all?\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/4713/comments",
    "author": "osdm",
    "comments": [
      {
        "user": "DanielRosenwasser",
        "created_at": "2015-09-09T20:01:25Z",
        "body": "> What happens if S and T are tuple types with different numbers of elements? \n\nI believe that in this case, default processing for object types takes effect, so inferences are made from properties { `0`, `1`, ... `n` }, etc.\n\n@ahejlsberg might be able to answer your other question (and potentially correct me).\n"
      },
      {
        "user": "ahejlsberg",
        "created_at": "2015-09-09T21:29:03Z",
        "body": "See #4153 regarding your first question.\n\nRegarding your second question, if tuple lengths don't match we just do the default processing for object types.\n"
      },
      {
        "user": "osdm",
        "created_at": "2015-09-09T22:46:09Z",
        "body": "Thanks!\n"
      }
    ]
  },
  {
    "number": 4710,
    "title": "Ability to exclude some compiled .ts files from output",
    "created_at": "2015-09-09T14:33:26Z",
    "closed_at": "2015-09-10T16:10:07Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/4710",
    "body": "It would be good (and probably necessary for big projects) to have implementation that supports the following (I will provide a concreate example) use case:\n1. I have the terminal.ts file that depends on the core.ts, env.ts files:\n\n```\n///<reference path=\"env\">\n///<reference path=\"core\">\n\n// this is terminal.ts\n```\n1. I already included the compiled version of it in the main index.html file:\n\n``` html\n<html>\n...\n<script src=\"env-core-terminal_merged.js\"></script>\n</html>\n```\n\nThe env-core-terminal_merged.js contains compiled content of the following files: env.ts, core.ts, terminal.ts. I created the env-core-terminal_merged.js file with the following command:\n\n```\ntsc --out public/js/env-core-terminal_merged.js terminal.ts\n```\n\nIn this case the tsc will find all files (env.ts and core.ts) using ///reference directive and merge them into one.\n3. Now for some area of the site I need other files, say editor.ts that depends on env.ts, core.ts and other editor specic files: color.ts, mode.ts:\n\n```\n///<reference path=\"env\">\n///<reference path=\"core\">\n///<reference path=\"color\">\n///<reference path=\"mode\">\n\n// this is editor.ts\n```\n\nI want to include it like this:\n\n``` html\n<html>\n...\n<script src=\"env-core-terminal-merged.js\"></script>\n<script src=\"color-mode-editor_merged.js\"></script>\n</html>\n```\n\nand I created it with the following command:\n\n```\ntsc --out public/js/color-mode-editor_merge.js editor.ts\n```\n\nBut now there is a problem: as the editor.ts depends on the core.ts and env.ts the tsc will paste the compiled content of them into the color-mode-editor_merged.js again. But I need to have only one the compiled content of the core.ts, env.ts be included. I can't include only one file that will have compiled content for the all .ts files and replace the env-core-terminal-merged.js with it, because the site has block architecture and each block can define its own javascript files and have a common part for all blocks (in this case the common part is defined in the env-core-terminal-merged.js) For now to resolve of this problem I can only open the color-mode-editor_merged.js with editor and delete the compiled content of the core.ts and env.ts by hand (manually).\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/4710/comments",
    "author": "ghost",
    "comments": [
      {
        "user": "weswigham",
        "created_at": "2015-09-09T17:24:18Z",
        "body": "I believe the conventional wisdom right now is to reference the generated `.d.ts` files for the files whose sources you don't wish to compile, rather than the original sources.\n"
      },
      {
        "user": "ghost",
        "created_at": "2015-09-10T16:09:58Z",
        "body": "@weswigham, yes it works, thanks.\n"
      }
    ]
  },
  {
    "number": 4687,
    "title": "Declare variable as typeof external module without import",
    "created_at": "2015-09-08T03:36:12Z",
    "closed_at": "2015-09-08T21:30:12Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/4687",
    "body": "Hey there,\n\nIs it possible to write an external (commonjs) module \"A\", then in another module \"B\"'s code, declare a variable as being typeof module \"A\" without using import which ends up require-ing module \"A\".\n\nThe reason I want to do this is that I will be passing a reference to module \"A\" to the constructor of a class in another module \"B\", because I want module \"A\" to be a singleton. But I want to type the argument in the constructor to that of module \"A\", as if module \"A\" had been imported using import A = require(\"A\");\n\nThe reason I want a singleton module is that this module might contain instances of classes that manage database connections, etc, and I don't really want them re-initialising each time I have to import; I want to be able to pass them around rather than rely on potential \"node-module cache\" magic.\n\nIs there a way to do this? I've thought of other ways I can achieve want I want but this feels like the simplest, if it's possible.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/4687/comments",
    "author": "Roam-Cooper",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2015-09-08T17:59:56Z",
        "body": "Module imports are elided if they are not used in a value position. so if your import of module `A` is only used in a type position the `require` call will not be written out.\n\nfor instance:\n\n``` ts\n// B.ts\nimport s = require(\"./A\");\nvar x: typeof s;\n```\n\nemits\n\n``` js\nvar x;\n```\n\ndoes this answer your question?\n"
      },
      {
        "user": "Roam-Cooper",
        "created_at": "2015-09-08T21:30:05Z",
        "body": "Oh, that's great! It definitely answers my question. I couldn't find this in the documentation, so thanks a tonne for your help. :)\n"
      },
      {
        "user": "BaamAadmi",
        "created_at": "2018-01-10T07:50:01Z",
        "body": "Hi Folks,\r\nI have a question which is on the same lines. I tried above solution but it did now work for me. \r\nI am importing classes from a webpack module parent   import { A, B } from \"parent\";\r\nI simply want to call constructor for these classes. I tried  const a = A( { data: 1} );  This does not give any TS error on compile. But it breaks on runtime javascript saying ,   Type error A is not a constructor. \r\n\r\nDo I need to create custom types and add it in devDependancies ? Or is there a specific way to export my \"parent\" module like export default. \r\n\r\nAny help is appreciated. \r\n\r\nCheers,\r\nSudeep"
      }
    ]
  },
  {
    "number": 4677,
    "title": "Function none optional parameters are not enforced",
    "created_at": "2015-09-07T06:52:13Z",
    "closed_at": "2015-09-08T18:39:51Z",
    "labels": [
      "By Design",
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/4677",
    "body": "This code will compile with NO errors:\n\n``` code\ntype callback = (a:number, b:string)=>void;\nvar c : callback = function(a:number) {}; // b is not optional\n```\n\nThis also can be found for example on forEach of the Array declarations in lib.d.ts:\n\n``` code\nforEach(callbackfn: (value: T, index: number, array: T[]) => void, thisArg?: any): void;\n```\n\nindex, and array should be marked as optional. In practice (Like the example above) TypeScript will not error if you didn't supply them, but it should.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/4677/comments",
    "author": "gilamran",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2015-09-08T18:39:47Z",
        "body": "In JavaScript it is not a runtime error to pass additional parameters to a function. in this example, callback says it will provide 2 parameters, but your function expression, says it only needs one. your function would still work at runt time, and this is a valid assignment. this is similar to declaring a second parameter `b` but never using it. the oposite however is not correct.\n\n``` ts\ntype callback = (a:number, b:string)=>void;\nvar c1 : callback = function(a:number) { }; // OK, will get an extra argument at runtime that will be ignored\nvar c2 : callback = function(a:number, b: string) { }; // OK, still, will get a b that will never be used\n\nvar c : callback = function(a, b, c) { }; // Error, this function declares it needs 3 arguments, callback will only pass 2, this is not a safe assignment.\n```\n"
      },
      {
        "user": "danquirk",
        "created_at": "2015-09-08T19:30:13Z",
        "body": "In addition, not only is this allowed in JS, but it's used constantly. If we did this:\n_In practice (Like the example above) TypeScript will not error if you didn't supply them, but it should._\nthen nearly every Array.map and such function call would now be an error in TypeScript. People don't want to write `[1,2,3 ].map((val, idx, arr) => val + 1);` just to satisfy the compiler.\n"
      }
    ]
  },
  {
    "number": 4663,
    "title": "the exact behaviour of assignment semantics on callable types",
    "created_at": "2015-09-05T07:02:52Z",
    "closed_at": "2015-09-07T00:05:16Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/4663",
    "body": "hello\nconsider this: var pickyCallable: {(l: any): any, (): aType };\nin the above example, only functions that have _both_ (l: any): any and (): aType signatures could be assigned to this \"pickyCallable\" thing; is this the actual behaviour of the typecheckr?\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/4663/comments",
    "author": "icefapper",
    "comments": [
      {
        "user": "ahejlsberg",
        "created_at": "2015-09-07T00:05:05Z",
        "body": "No, that's not how it works. In an assignment `f = g`, where `f` and `g` are functions of type `F` and `G`, for each signature in `F` there must be _at least one_ compatible signature in `G`, but `F` and `G` aren't required to be identical. So:\n\n``` typescript\nvar x: { (x: any): any, (): aType };\nvar y: { (x: any): any };\nvar z: { (): aType };\nx = y;  // Error\nx = z;  // Ok\n```\n\nThe `x = y` assignment is an error because `x` can be called with no arguments, but `y` always expects an argument. The `x = z` assignment is ok because `y` is free to ignore the argument possibly passed to `x`, and `aDate` is assignment compatible with `any`.\n\nSee also #4661.\n"
      }
    ]
  },
  {
    "number": 4661,
    "title": "assignment semantics for callable object types",
    "created_at": "2015-09-05T07:01:20Z",
    "closed_at": "2015-09-05T07:02:01Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/4661",
    "body": "hello\nconsider this: \n\n``` ts\nvar pickyCallable: {(l: any): any, (): aType };\n```\n\nin the above example, only functions that have _both_ `(l: any): any` and `(): aType` signatures could be assigned to this \"pickyCallable\" thing; could I ask if I'm right?\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/4661/comments",
    "author": "icefapper",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2015-09-05T20:42:15Z",
        "body": "the general rule is you can pass more arguments to a function than it expects, as they will be ignored, but the opposite is not true.\n\nso\n\n``` ts\nvar pickyCallable: { (l: any): any, (): number };\n\npickyCallable = (a) => a; // Error. pickyCallable can be called with no arguments, but this function expects one\npickyCallable = () => 2; // OK, as the additional argument will be ignored\n```\n"
      }
    ]
  },
  {
    "number": 4635,
    "title": "Interface in function declaration statement",
    "created_at": "2015-09-04T06:32:18Z",
    "closed_at": "2015-09-04T16:47:45Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/4635",
    "body": "There is a interface like this:\n\n``` ts\ninterface searchFunc {\n    (source: string, subString: string): boolean;\n}\n```\n\nI know I can use it in **function definition expression**:\n\n``` ts\nvar mySearch: searchFunc = function(src, sub) {\n    var result = src.search(sub);\n    if (result == -1) {\n        return false;\n    }\n    else {\n        return true;\n    }\n}\n```\n\nBut how can I use it in **function declaration statement** like below? Do I need to change the structure of interface?\n\n``` ts\nfunction mySearch(src, sub): searchFunc {\n    var result = src.search(sub);\n    if (result == -1) {\n        return false;\n    }\n    else {\n        return true;\n    }\n}\n```\n\nI'm waiting online,hope a answering.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/4635/comments",
    "author": "ChuanfengLai",
    "comments": [
      {
        "user": "DanielRosenwasser",
        "created_at": "2015-09-04T07:03:34Z",
        "body": "The short answer is you can't do it for a function declaration, only a function expression. You can still use your interface to ensure that when passing `mySearch` somewhere that its type is compatible, but you can't have your parameter types inferred the same way.\n"
      },
      {
        "user": "ChuanfengLai",
        "created_at": "2015-09-04T07:45:40Z",
        "body": "Thank for your answer  :).\n"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2015-09-04T07:50:37Z",
        "body": "You're very welcome!\n"
      }
    ]
  },
  {
    "number": 4605,
    "title": "Cast to derived class is invalid even after checking the type",
    "created_at": "2015-09-02T16:35:28Z",
    "closed_at": "2015-09-02T22:09:42Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/4605",
    "body": "The following code doesn't compile even though I would expect it to. Inside the if statement, we know that the greeter is a ChildGreeter, but we are not allowed to cast to it for some reason. \n\n```\nclass Greeter {\n   greet() { console.log(\"Hi\"); }\n}\n\nclass ChildGreeter extends Greeter {\n    greetChild() { console.log(\"Hi child\"); }\n}\n\nfunction greet<T extends Greeter>(greeter: T) {\n    if(greeter instanceof ChildGreeter){\n        // the following cast is invalid\n        var childGreeter = <ChildGreeter>greeter;\n    }\n}\n```\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/4605/comments",
    "author": "DavidRigglemanININ",
    "comments": [
      {
        "user": "DavidRigglemanININ",
        "created_at": "2015-09-02T16:37:10Z",
        "body": "The workaround is to do a cast of `<ChildGreeter><Object> greeter`, but this shouldn't be necessary\n"
      },
      {
        "user": "xLama",
        "created_at": "2015-09-02T16:48:45Z",
        "body": "TS 1.7.0-dev.20150901\nIt does not work either:\n\n```\nclass Greeter {\n   greet() { console.log(\"Hi\"); }\n}\n\nclass ChildGreeter extends Greeter {\n    greetChild() { console.log(\"Hi child\"); }\n}\n\nfunction isChildGreeter(a: Greeter): a is ChildGreeter {\n    return a instanceof ChildGreeter;\n\n}\n\nfunction greet<T extends Greeter>(greeter: T) {\n    if(isChildGreeter(greeter)){\n        greeter.greetChild(); //  Property 'greetChild' does not exist on type 'T'\n    }\n}\n```\n"
      },
      {
        "user": "falsandtru",
        "created_at": "2015-09-02T16:53:24Z",
        "body": "Generic type `T` is not extended from `ChildGreeter` .\n\n``` ts\n- function greet<T extends Greeter>(greeter: T) {\n+ function greet<T extends ChildGreeter>(greeter: T) {\n```\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2015-09-02T22:09:31Z",
        "body": "As @falsandtru mentioned, a value of type `T` is not guarantteed to be `ChildGreeter`. consider this:\n\n``` ts\nclass AnotherChildGreeter extends Greeter {\n    NotGreetChild() { console.log(\"Hi another child\"); }\n}\n```\n\nYou can either use `ChildGreeter` as your constraint, or cast to `any`.\n"
      },
      {
        "user": "DavidRigglemanININ",
        "created_at": "2015-09-03T12:10:13Z",
        "body": "I'm not sure I fully understand. I know T is not guaranteed to be ChildGreeter, but it can be, right? Are you saying even if I checked that T is an instance of ChildGreeter, it may not actually be an instance of ChildGreeter?\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2015-09-03T17:39:41Z",
        "body": "it is not safe to assume that `T` is assignment compatible with `ChildGreeter` nor that `ChildGreeter` is assignment compatible with `T`.\n\n``` ts\nvar t : T;\nvar childGreeter: ChildGreeter;\n\nt = childGreeter;  //  Not true, T might be of type AnotherChildGreeter, and would be missing NotGreetChild method if the assignment was allowed\nchildGreeter = t;  // Not true either, if T is AnotherChildGreeter, childGreeeter is now missing greetChild method if the assignment was allowed\n```\n\nThis is basically what a cast operator does, it checks that the conversion is correct in at least one way, either up casting to a base type or down casting to a more specialized type; but you can not do it across. so:\n\n``` ts\n// valid casts\nvar g = <Greeter> childGreeter; // up cast\nvar c = <ChildGreeter> g;  // down cast\n\n// invalid cast\nvar x = <number> \"string\";  // Error: Neither type `string` nor type `number` is assignable to the other\n```\n\nAgain, to work around this, you need to cast twice, once to a common base type, and then down to your more specialized type:\n\n``` ts\nvar child = <ChildGreeter><Greeter> t; // OK\n```\n\nBut the question here, is why do you have a generic function, that declares a constraint on a base type has any knowledge about a specialized version of it. Either this function should not be generic, or it should have a different constraint.\n"
      },
      {
        "user": "RaphiStein",
        "created_at": "2018-03-16T22:20:43Z",
        "body": "Personally I was having this issue when trying to cast a variable onto itself, for example\r\n\r\n`mycustomobj = <CastToThis> mycustomobj;`\r\n\r\nI solved it by simply creating a new var\r\n\r\n`let newcustomobj = <CastToThis> mycustomobj`"
      }
    ]
  },
  {
    "number": 4601,
    "title": "Compiled variable name not match `import` name",
    "created_at": "2015-09-02T08:59:24Z",
    "closed_at": "2015-09-02T22:28:16Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/4601",
    "body": "``` ts\nimport J from 'jquery';\n\nJ('body').css('background', 'yellow');\n```\n\ncomes out this...\n\n``` js\nvar jquery_1 = require('jquery');\njquery_1[\"default\"]('body').css('background', 'yellow');\n```\n\nWhy didn't it just use 'J' instead of 'jquery_1'!?\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/4601/comments",
    "author": "wang-prtimes",
    "comments": [
      {
        "user": "kitsonk",
        "created_at": "2015-09-02T10:02:42Z",
        "body": "It is as designed because you are trying to import the default export of a module and the compiler is trying to do it in a way it knows won't cause it runtime problems, but I think what you really want is this:\n\n``` typescript\nimport * as J from 'jquery';\n\nJ('body).css('background', 'yellow');\n```\n\nThat should emit as:\n\n``` js\nvar J = require('jquery');\nJ('body').css('background', 'yellow');\n```\n"
      }
    ]
  },
  {
    "number": 4532,
    "title": "How to add new module system in Visual Studio plugin",
    "created_at": "2015-08-28T20:43:48Z",
    "closed_at": "2015-08-28T21:23:50Z",
    "labels": [
      "Question",
      "API"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/4532",
    "body": "I did the fork and I've also changed typescript compiler, adding a new module system ModuleKind.ExtJS.\nNow I'm able to invoke tsc.js with argument \"-m extjs\".\n\nMy only problem now is to set argument \"-m extjs\" in the visual studio feature \"compile on save\" .\n\nVisual studio seems to ignore this new enum that I settled in my project msbuild file.\n\nThere is any other way to add or change compiler arguments with the visual studio plugin?\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/4532/comments",
    "author": "fabioparra",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2015-08-28T21:23:36Z",
        "body": "There is no way at the moment. these values are hard-coded in the Visual Studio plugin.\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2015-08-28T21:24:22Z",
        "body": "Related to #2656\n"
      },
      {
        "user": "DickvdBrink",
        "created_at": "2015-08-28T21:35:55Z",
        "body": "@fabioparra, you might want to do it like below. I know it is not the nicest thing to manually hack in `csproj` but it does work!\n\nChange the `csproj` below the import line to the following (so you only need to add the property group not the `import` statement)\n\n```\n  <Import Project=\"$(MSBuildExtensionsPath32)\\Microsoft\\VisualStudio\\v$(VisualStudioVersion)\\TypeScript\\Microsoft.TypeScript.targets\" Condition=\"Exists('$(MSBuildExtensionsPath32)\\Microsoft\\VisualStudio\\v$(VisualStudioVersion)\\TypeScript\\Microsoft.TypeScript.targets')\" />\n  <PropertyGroup>\n    <TypeScriptBuildConfigurations>$(TypeScriptBuildConfigurations) --tmp</TypeScriptBuildConfigurations>\n  </PropertyGroup>\n```\n\nOutput to prove that it works:\n\n```\n1>  Task Parameter:TypeScriptCompileBlocked=False (TaskId:15)\n1>  C:\\Program Files (x86)\\Microsoft SDKs\\TypeScript\\1.5\\tsc.exe  --sourcemap --target ES5 --noEmitOnError --locale en-US --tmp \"C:\\Users\\dvdbrink\\documents\\visual studio 2015\\Projects\\TypeScriptHTMLApp1\\TypeScriptHTMLApp1\\app.ts\" (TaskId:15)\n1>VSTSC : error TS5023: Build: Unknown compiler option 'tmp'.\n1>   (TaskId:15)\n1>  The command exited with code 1. (TaskId:15)\n```\n"
      },
      {
        "user": "fabioparra",
        "created_at": "2015-08-31T16:19:28Z",
        "body": "Hi, thanks for your responses. \n@DickvdBrink, your sugention works only when building the project. When I save the file, vs editor plugin doesn't use TypeScriptBuildConfigurations tag.\n"
      }
    ]
  },
  {
    "number": 4529,
    "title": "Re-export class from namespace",
    "created_at": "2015-08-28T19:18:33Z",
    "closed_at": "2015-09-17T00:30:04Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/4529",
    "body": "I want to re-export some class defined in a module scope from a nested namespace. First I tried new ES6 syntax, but got an error:\n\n``` ts\nexport class Foo {}\nexport namespace a {\n    export { Foo } // TS1194: Export declarations are not permitted in a namespace.\n}\n```\n\nОк, tried `export import`:\n\n``` ts\nexport class Foo {}\nexport namespace a {\n    export import Foo = Foo; // TS2303: Circular definition of import alias 'Foo'.\n}\n```\n\nSo I have to define temporary import:\n\n``` ts\nexport class Foo {}\nimport FooTemp = Foo; // TS2503: Cannot find namespace 'Foo'.\n```\n\nOk, let's declare module `Foo` also:\n\n``` ts\nexport class Foo {}\nexport module Foo {}\nimport FooTemp = Foo;\nexport namespace a {\n    export import Foo = FooTemp;\n}\n```\n\nAnd only now the compilation is successful. It's really complicated workaround. And it forces to define extra variable in generated JS. I would prefer the first or second code sample. Or maybe is there another way?\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/4529/comments",
    "author": "Koloto",
    "comments": [
      {
        "user": "Koloto",
        "created_at": "2015-08-28T19:31:01Z",
        "body": "I found better workaround - rename the source class:\n\n``` ts\nclass FooTemp {}\nmodule FooTemp {}\nexport { FooTemp as Foo }\nexport namespace a {\n    export import Foo = FooTemp;\n}\n```\n\nIt's also complicated but there is no extra variable in JS.\n"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2015-08-28T21:28:12Z",
        "body": "There's not much we can do here since, at runtime, the name `Foo` only has one meaning inside `a`.\n"
      },
      {
        "user": "Koloto",
        "created_at": "2015-08-29T09:03:34Z",
        "body": "@RyanCavanaugh Why ES6 export declarations are not supported in namespaces? In the generated JS code this can look like this:\n\n```\n    var Foo = (function () {\n        function Foo() {\n        }\n        return Foo;\n    })();\n    exports.Foo = Foo;\n    var a;\n    (function (a) {\n        a.Foo = Foo;\n    })(a = exports.a || (exports.a = {}));\n```\n\nThis works fine at runtime.\n\nAnd why do I have to declare module/namespace `Foo` to import class `Foo`?\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2015-09-17T00:30:04Z",
        "body": "> And why do I have to declare module/namespace Foo to import class Foo?\n\nThere is no reason really. we wanted to limit the use of imports to avoid conflicts with ES6 syntax. i think we should reconsider. @Koloto would you mind filing a suggestion for it.\n"
      },
      {
        "user": "rybolt",
        "created_at": "2016-07-08T20:02:31Z",
        "body": "@mhegazy anything come out of this? if so could you link from here, as I landed here via google search.  Thanks.\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2016-07-08T21:25:13Z",
        "body": "no issue tracking this.\n"
      },
      {
        "user": "robey",
        "created_at": "2017-01-23T00:11:14Z",
        "body": "I got here from a desperate search too. It appears to still be broken? Any new word?\r\n"
      },
      {
        "user": "lsagetlethias",
        "created_at": "2017-02-03T15:43:39Z",
        "body": "Please make it append. Non intuitive workaround can lead to bad practices.\r\n\r\n```typescript\r\nimport Class1 from \"./Class1\";\r\nimport Class2 from \"./Class2\";\r\nimport {Class3, Class4} from \"./OtherClasses1\";\r\nimport {Class5, Class6} from \"./OtherClasses2\";\r\n\r\nexport {Class1, Class2} //ok\r\n\r\nexport namespace OtherClasses {\r\n    export {Class3, Class4, Class5, Class6}; // export not permitted...\r\n}\r\n// or better\r\nexport {Class3, Class4, Class5, Class6} as OtherClasses; // not working nether obviously.\r\n\r\n// -- This workaround works, but it's sad to use it like this...\r\nexport const OtherClasses = {\r\n    Class3: Class3,\r\n    Class4: Class4,\r\n    Class5: Class5,\r\n    Class6: Class6,\r\n};\r\n```"
      },
      {
        "user": "MaximBalaganskiy",
        "created_at": "2017-02-20T00:54:09Z",
        "body": "@bios21 does TS let you define variables in other modules?\r\n`\r\nvar someVar: rootModule.OtherClasses.Class3;\r\n`\r\nI cannot get it to work in my project - TS complains \"TS2305: Module 'rootModule' has no exported member 'OtherClasses'\" although the following line is compiled\r\n`\r\nconsole.log(rootModule.OtherClasses.Class3);\r\n`"
      },
      {
        "user": "lsagetlethias",
        "created_at": "2017-02-20T09:27:28Z",
        "body": "@MaximBalaganskiy I have no problem with this line.\r\nDummy code for example:\r\n\r\n```typescript\r\n// MyModule.ts\r\nexport default class Sub {} // (Sub ~= Class3 in your snippet)\r\n```\r\n\r\n```typescript\r\n// index.ts (my entry point in webpack context)\r\n// all exports are bundled into the rootModule object\r\nimport Sub from './MyModule';\r\n\r\nexport const NS = { //in this fake namespace, it's !object! not type description (NS ~= OtherClasses in your snippet)\r\n    Sub: Sub // can be 'AnyOtherVarName: Sub' ; Sub type is invariant in this case except if you 'import-as' it.\r\n}\r\n```\r\n\r\n```typescript\r\n// in any other external ts file\r\nimport * as rootModule from 'the-module-bundled';\r\nimport {NS} from 'the-module-bundled';\r\nvar someVar: rootModule.NS.Sub; // ok\r\nvar someOtherVar = new rootModule.NS.Sub(); // ok\r\nvar someVarAgain: NS.Sub; // ok\r\nvar someOtherVarAgain = new NS.Sub(); // ok\r\n```"
      }
    ]
  },
  {
    "number": 4499,
    "title": "How should empty arrays and union types work together in 1.6?",
    "created_at": "2015-08-27T19:30:21Z",
    "closed_at": "2015-08-27T21:05:49Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/4499",
    "body": "``` ts\nvar p = new Array<string>();\nvar q = true ? p : [];\nq[0]\n```\n\nMy reasoning follows, please correct me if I'm wrong.\nAccording to 1.5 spec, type of q[0] was calculated in the following way:\n1. Take union type of `Array<string>` and empty array (`Array<Undefined>`).\n2. Reduce that union type, which gives us `Array<string>`, because string is a supertype of undefined.\n3. Widen that type (changes nothing).\n4. Type of q[0] is string.\n\nAccording to 1.6 spec, type of q[0] should be calculated in the following way:\n1. Take union type of `Array<string>` and empty array (`Array<Undefined>`).\n2. No reduce is happening.\n3. Widen that type, resulting in `(Array<string> | Array<any>)`.\n4. Type of q[0] is `(string | any)`.\n\nBut that would break \"no implicit any\". Where did I make a mistake?\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/4499/comments",
    "author": "osdm",
    "comments": [
      {
        "user": "DanielRosenwasser",
        "created_at": "2015-08-27T20:44:05Z",
        "body": "@ahejlsberg, can you check into this?\n"
      },
      {
        "user": "ahejlsberg",
        "created_at": "2015-08-27T21:05:22Z",
        "body": "@osdm You're right, we no longer do subtype reduction in union types, however we still do deduplication as discussed in #4115. This has yet to make it into the spec. In the example above, `Array<Undefined>` is considered a duplicate of `Array<string>` so the type of the `?:` operation simply becomes `Array<string>`.\n"
      }
    ]
  },
  {
    "number": 4345,
    "title": "Array Type Interface dotted notation",
    "created_at": "2015-08-17T23:06:27Z",
    "closed_at": "2015-08-17T23:38:26Z",
    "labels": [
      "By Design",
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/4345",
    "body": "```\ninterface Interface {\n      [id: string]: string;\n}\n\nvar a:Interface = {\n      b: 'foo'\n};\n\na.b = 'bar';\n```\n\nThrows an error:\n\n```\nProperty 'b' does not exist on type 'Interface'\n```\n\nPossible to solve? Maybe treat Array index as 'any':\n\n```\nvar a:any = {};\na.b= \"foobar\";\n```\n\nThis one is ok.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/4345/comments",
    "author": "S-ed",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2015-08-17T23:19:00Z",
        "body": "to access the member `b` you need to define it in the interface. e.g:\n\n``` ts\ninterface Interface {\n      b: string;\n}\n\nvar a:Interface;\na.b = 'bar'; // OK\n```\n\nalternatively you can use string indexing to access your property:\n\n``` ts\ninterface Interface {\n      [id: string]: string;\n}\n\nvar a:Interface;\n\na[\"b\"] = 'bar'; // OK, type of a[\"b\"] is defined in the string indexer definition in Interface\n```\n\nif you give a value the type `any`, it can have any number of properties, and the compiler will not enforce any rules there. \n"
      }
    ]
  },
  {
    "number": 4323,
    "title": "outDir compiler option description or function unclear",
    "created_at": "2015-08-14T23:44:40Z",
    "closed_at": "2015-08-17T17:41:04Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/4323",
    "body": "The description \"Redirect output structure to the directory\" seems to imply mimicing of the source structure in the specified directory. \n\nFor example, I take the above description to mean:\nif source is \"app/app.ts\", then output should be <outDir>/app/app.js\n\nOutputs are placed in directory without structure. What is the correct behavior? \n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/4323/comments",
    "author": "ldminoc",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2015-08-17T17:41:04Z",
        "body": "`--outDir` will mimic the input structure. the root of the input files is computed to be the longest common subpath of all input files, if you have one file, that is not going to work obviously.\n\nuse `--rootDir` to tell the compiler where is the root of your sources is. so in your case `--rootDir ./` should result in `<outDir>/app/app.js`\n"
      },
      {
        "user": "ldminoc",
        "created_at": "2015-08-18T00:51:32Z",
        "body": "Thanks, your answer describes the behavior I was expecting. (Looks like <outDir>  got left out in my original post).\n"
      }
    ]
  },
  {
    "number": 4314,
    "title": "How can I debug language service with TSX?",
    "created_at": "2015-08-14T08:54:12Z",
    "closed_at": "2015-08-16T07:19:33Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/4314",
    "body": "I've been debugging TypeScript with dev mode in Visual Studio but my VS2015 does not support .tsx file. Adding extension mapping does not help me very much as it doesn't really load language service.\n\nAre there other good tools to debug language service with TSX file?\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/4314/comments",
    "author": "saschanaz",
    "comments": [
      {
        "user": "DanielRosenwasser",
        "created_at": "2015-08-15T16:41:12Z",
        "body": "You can create a fourslash test and run the test in the browser with `jake runtests-browser t=yourTestName` or add a `debugger` statement to your test and run `jake runtests-browser t=fourslash`. Then open your F12 tools to trigger an appropriate debug point.\n"
      },
      {
        "user": "saschanaz",
        "created_at": "2015-08-15T19:03:14Z",
        "body": "`jake runtest-browser`. Thanks! :+1:\n"
      }
    ]
  },
  {
    "number": 4293,
    "title": "Bug in transpiled __extend code ?",
    "created_at": "2015-08-12T22:01:38Z",
    "closed_at": "2015-08-12T22:48:08Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/4293",
    "body": "I have a problem with some code produced by typescript.\n\n``` js\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    __.prototype = b.prototype;\n    d.prototype = new __();\n};\n```\n\nI get the following error when run under node :\n\n```\n d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype,\n                                                                   ^\nTypeError: Cannot read property 'prototype' of undefined\n    at __extends (/home/vincent/dev/codingame/heatdetector/code.js:4:68)\n    at /home/vincent/dev/codingame/heatdetector/code.js:113:5\n    at Object.<anonymous> (/home/vincent/dev/codingame/heatdetector/code.js:162:3)\n    at Module._compile (module.js:456:26)\n    at Object.Module._extensions..js (module.js:474:10)\n    at Module.load (module.js:356:32)\n    at Function.Module._load (module.js:312:12)\n    at Function.Module.runMain (module.js:497:10)\n    at startup (node.js:119:16)\n    at node.js:935:3\n```\n\nThe only calling code of __extends in the transpiled code is this:\n\n``` js\nvar Move = (function (_super) {\n    __extends(Move, _super);\n    function Move(param1, param2) {\n        if (param1 && param1.x && param2 && param2.x) {\n            _super.call(this, param1, param2);\n        }\n        if (typeof param1 === \"number\" && typeof param2 === \"number\") {\n            _super.call(this, param1, param2);\n        }\n        if (typeof param1 === \"number\" && param2 && param2.x) {\n            _super.call(this, param1, param2);\n        }\n    }\n```\n\nProblem present both in 1.5.3 and in 1.6.0-dev.20150812 nigthly\nI can give you more information and try to do a minimal repro if you need it.\n\nThank you.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/4293/comments",
    "author": "vjau",
    "comments": [
      {
        "user": "adidahiya",
        "created_at": "2015-08-12T22:08:14Z",
        "body": "Your super class hasn't been defined at that point in the code yet. Check that the order of your scripts is correct.\n"
      },
      {
        "user": "vjau",
        "created_at": "2015-08-13T06:41:31Z",
        "body": "You are right, but how comes the compiler doesn't warn me about that ?\n"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2015-08-13T07:09:33Z",
        "body": "@vjau we're tracking this in #2854\n"
      },
      {
        "user": "kodeine",
        "created_at": "2017-02-26T21:06:57Z",
        "body": "i am getting the same problem.\r\n`Uncaught TypeError: Cannot read property 'prototype' of undefined`\r\n"
      }
    ]
  },
  {
    "number": 4273,
    "title": "Is there a way to get all references to external modules from the compiler API?",
    "created_at": "2015-08-11T11:27:36Z",
    "closed_at": "2015-09-17T00:24:26Z",
    "labels": [
      "Question",
      "API"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/4273",
    "body": "I would like to have a list of all references to external modules after compilation to be able to bundle these modules for the browser.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/4273/comments",
    "author": "Lenne231",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2015-08-11T19:22:59Z",
        "body": "take a look at  #3687. let us know if this addresses your needs.\n"
      }
    ]
  },
  {
    "number": 4270,
    "title": "How do I enable strict mode in TypeScript?",
    "created_at": "2015-08-11T07:47:59Z",
    "closed_at": "2015-08-11T17:13:57Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/4270",
    "body": "I can't found option in Visual Studio for enable strict mode when compiling typescript to JS. Without this option Ecmascript 6 code not working in chrome, because required strict mode. \n\n```\nUncaught SyntaxError: Block-scoped declarations (let, const, function, class) not yet supported outside strict mode\n```\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/4270/comments",
    "author": "ghost",
    "comments": [
      {
        "user": "DanielRosenwasser",
        "created_at": "2015-08-11T07:51:31Z",
        "body": "Just add `\"use strict\"` to the top of your file.\n"
      },
      {
        "user": "ClaudenirFreitas",
        "created_at": "2016-02-11T10:37:04Z",
        "body": "IIFE with 'use strict';\n(function() {\n'use strict';\n...\n})();\n"
      },
      {
        "user": "dharness",
        "created_at": "2016-05-26T16:01:34Z",
        "body": "Doesn't it seem a tad obtuse to add \"use strict\"; to every file? Is there any way to enforce strict mode in every file?\n"
      },
      {
        "user": "kitsonk",
        "created_at": "2016-05-26T16:10:17Z",
        "body": "All ESM modules will automatically be interpreted in strict mode, as per the standard.\n\nIf the code you are compiling is to CJS, AMD or UMD, TypeScript automatically emits the `'use strict';` prolog in order to maintain the run-time compatibility with ESM.\n\nIf it is a \"plain\" non-modular file, then TypeScript is like JavaScript, in that it is an opt-in feature.\n"
      },
      {
        "user": "mattmccutchen",
        "created_at": "2016-10-10T19:23:58Z",
        "body": "If anyone else finds this thread in a search, the latest status is that a compiler option to enable strict mode is planned (#10758).\n"
      }
    ]
  },
  {
    "number": 4243,
    "title": "Update to 1.5.4 remains in the 1.5.3",
    "created_at": "2015-08-09T07:40:12Z",
    "closed_at": "2015-08-09T08:15:06Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/4243",
    "body": "After updating via Visual Studio 2015 nuget or through npm the installed version shows still the version 1.5.3\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/4243/comments",
    "author": "blfuentes",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2015-08-09T08:15:06Z",
        "body": "the release 1.5.4 only had one issue fixed (#3939), there are no version changes to the compiler or the language service code. they all still have the 1.5.3 version.\n"
      }
    ]
  },
  {
    "number": 4232,
    "title": "error importing from default object",
    "created_at": "2015-08-08T00:38:00Z",
    "closed_at": "2015-08-08T00:47:11Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/4232",
    "body": "Sorry if this is a dup.\n\nShould I be able to do this? Trying to do something like:\n\nFoo.ts\n\n``` ts\nexport default {\n  Foo: {\n    bar: 'baz'\n  }\n}\n```\n\n``` ts\nimport { Foo } from './Foo';\n```\n\nbut get `Module '\"./Foo\"' has no exported member 'Foo'`\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/4232/comments",
    "author": "mwilc0x",
    "comments": [
      {
        "user": "danquirk",
        "created_at": "2015-08-08T00:47:11Z",
        "body": "You want\n\n``` ts\nimport Foo from './Foo'\n```\n\nto get the default export. The { } syntax is for getting named exports (and/or renaming them yourself)\n"
      },
      {
        "user": "mwilc0x",
        "created_at": "2015-08-08T00:59:19Z",
        "body": "But then I would have to do `Foo.Foo.bar` instead of just wanting to do `Foo.bar`\n\nDoes that make sense?\n"
      },
      {
        "user": "kitsonk",
        "created_at": "2015-08-08T15:30:29Z",
        "body": "The you want to do something like this:\n\n``` typescript\nexport let Foo = {\n  bar: 'bad'\n};\nexport default { Foo: Foo }; /* or something more sensible */\n```\n\nThen you can:\n\n``` typescript\nimport { Foo } from './Foo';\n```\n\nDefault create the return value for the module (sort of like `export = value`).  If you want to export something else that you can require in, then you need to export it, but not `export default`.\n"
      }
    ]
  },
  {
    "number": 4214,
    "title": "ES6 module import doesn't require relative identifier to load relative file",
    "created_at": "2015-08-07T12:39:58Z",
    "closed_at": "2015-08-10T21:52:35Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/4214",
    "body": "This could be by design but it just surprised me and I wanted to verify behavior.\n\nWith CommonJS, relative modules must start with \"./\" or \"../\", otherwise it's considered to be a top-level module.\n\nAs near as I can tell with ES6, module naming is \"loader implementation specific\". It would seem that TypeScript's implementation does not require \"./\" or \"../\" to reference a relative file. For example:\n\n``` typescript\n// dep.ts\n\nexport class Test {}\n\n// app.ts\n\nimport { Test } from 'dep';\n```\n\nIs this intended? I'm not super familiar with prevailing ES6 module loading standards, but I put together a quick test using SystemJS. It also does not allow referencing a relative module without './' or '../' _unless_ that module happens to be in the preconfigured \"base\" URL. In other words, the above example would probably work out of the box, but the following would not:\n\n``` typescript\n// components/helper.ts\n\nexport function someHelper();\n\n// components/dep.ts\n\nimport * as helper from 'helper'; // this line would error at runtime in SystemJS, but not in TS\n\nexport class Test {}\n\n// app.ts\n\nimport { Test } from 'components/dep';\n```\n\nMy understanding is that work is being made in #2338 and things like #4154 which may help to alleviate issues like this since it would allow TypeScript to be aware of that \"loader-implementation specific\" part. In the meantime, is the current default correct? As an alternative, perhaps it would make sense for ES6 imports to not have this behavior **if** --module commonjs is set, since this clearly does not follow the CJS spec.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/4214/comments",
    "author": "jbrantly",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2015-08-10T21:31:04Z",
        "body": "@jbrantly the current module resolution logic is a bit weird :D. if you are loafing module \"helpers\", the compiler will look for a file called \"helpers.d.ts\" in the current directory, then will keep walking up the directory tree searching for \"helpers.d.ts\"...\n\nobviously this is not correct, hence #2338. @vladima is actively working on this now. so hopefully we have some relief soon.\n\nbut just to make sure i understood correctly, you want it to be an error to not use \"./\" or \"../\" with relative modules?\n"
      },
      {
        "user": "jbrantly",
        "created_at": "2015-08-10T21:39:02Z",
        "body": "> but just to make sure i understood correctly, you want it to be an error to not use \"./\" or \"../\" with relative modules?\n\nIn short, yes.\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2015-08-10T21:52:31Z",
        "body": "good.. it should be soon :D\n"
      },
      {
        "user": "jbrantly",
        "created_at": "2015-08-10T21:59:05Z",
        "body": "Thanks for confirmation of intended behavior :+1: \n"
      }
    ]
  },
  {
    "number": 4209,
    "title": "Reexport of non-instantiated entity forces TS to emit JS-code",
    "created_at": "2015-08-07T08:42:19Z",
    "closed_at": "2015-08-10T23:37:18Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/4209",
    "body": "I don't know if it is correct by design but a snippet that follows produces a JS-code though I feel that it shouldn't.\n\n```\nnamespace B {\n    export interface I {    \n    }\n}\n\nnamespace A {\n    export import I = B.I\n}\n```\n\nemits \n\n``` javascript\nvar A;\n(function (A) {\n})(A || (A = {}));\n\n```\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/4209/comments",
    "author": "lazdmx",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2015-08-07T15:54:52Z",
        "body": "imports are always force the container to be instantiated.\n\ni would use type alias declartons instread:\n\n``` ts\nnamespace B {\n    export interface I {    \n    }\n}\n\nnamespace A {\n    export type I = B.I\n}\n```\n"
      }
    ]
  },
  {
    "number": 4192,
    "title": "Bug: code repeated in my cordova appBundle.js",
    "created_at": "2015-08-06T18:33:46Z",
    "closed_at": "2015-08-06T21:02:52Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/4192",
    "body": "With Visual Studio 2015 RTM, In my cordova project, the compiled appBundle.js is repeating code at the end of the file, and doesn't repeat it sequentially.  For example, in the following example, debugMode is false when I use it in my project code, but it should be true.\n\nHere is a simplified example of what happens : \n\nFile config.ts\n\n```\nvar debugMode: boolean = false;\ndebugMode = true;\nvar enableWindowLog: boolean = false;\nvar configMode: string = \"\"\n\nif (debugMode) {\n    enableWindowLog = true;\n    configMode = \"-dev\";\n}\n```\n\nFile index.ts\n\n```\n//My app code\n```\n\nCompiled appBundle.js\n\n```\nvar debugMode = false;\ndebugMode = true;\nvar enableWindowLog = false;\nvar configMode = \"\";\nif (debugMode) {\n    enableWindowLog = true;\n    configMode = \"-dev\";\n}\n\n// My project code compiled\n\nvar debugMode = false;\nvar enableWindowLog = false;\nvar configMode = \"\";\nvar debugMode = false;\ndebugMode = true;\nvar enableWindowLog = false;\nvar configMode = \"\";\nif (debugMode) {\n    enableWindowLog = true;\n    configMode = \"-dev\";\n}\nvar debugMode = false;\ndebugMode = true;\nvar enableWindowLog = false;\nvar configMode = \"\";\nif (debugMode) {\n    enableWindowLog = true;\n    configMode = \"-dev\";\n}\nvar debugMode = false;\ndebugMode = true;\nvar enableWindowLog = false;\nvar configMode = \"\";\nif (debugMode) {\n    enableWindowLog = true;\n    configMode = \"-dev\";\n}\nvar debugMode = false;\ndebugMode = true;\nvar enableWindowLog = false;\nvar configMode = \"\";\nif (debugMode) {\n    enableWindowLog = true;\n    configMode = \"-dev\";\n}\nvar debugMode = false;\nvar enableWindowLog = false;\nvar configMode = \"\";\n```\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/4192/comments",
    "author": "NGumby",
    "comments": [
      {
        "user": "danquirk",
        "created_at": "2015-08-06T19:31:42Z",
        "body": "Can you share the actual compiler invocation command that's causing this? (presumably in the Output window)\n"
      },
      {
        "user": "NGumby",
        "created_at": "2015-08-06T20:36:35Z",
        "body": "1>Target \"PreComputeCompileTypeScript\" in file \"C:\\Program Files (x86)\\MSBuild\\Microsoft\\VisualStudio\\v14.0\\TypeScript\\Microsoft.TypeScript.targets\" from project \"D:\\CompuSport\\trunk\\CS Cordova\\CS.Cordova\\CS.Cordova.jsproj\" (target \"CompileTypeScript\" depends on it):\n1>Using \"VsTsc\" task from assembly \"C:\\Program Files (x86)\\MSBuild\\Microsoft\\VisualStudio\\v14.0\\TypeScript\\TypeScript.tasks.dll\".\n1>Task \"VsTsc\"\n1>  C:\\Program Files (x86)\\Microsoft SDKs\\TypeScript\\1.5\\tsc.exe --project \"D:\\CompuSport\\trunk\\CS Cordova\\CS.Cordova\\scripts\" COMPUTE_PATHS_ONLY\n1>Done executing task \"VsTsc\".\n\nhere is my tsconfig.json\n\n```\n{\n    \"compilerOptions\": { \n        \"noImplicitAny\": false,\n        \"noEmitOnError\": true,\n        \"removeComments\": false,\n        \"sourceMap\": false,\n        \"out\": \"www/scripts/appBundle.js\",\n        \"target\": \"es5\"\n    }\n}\n```\n"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2015-08-06T20:46:18Z",
        "body": "I'm guessing what's happening is that the Cordova project system, or something else (maybe a source code control tool?), is mirroring config.ts to some other locations in the project folder. `tsconfig` without a file will pick up all .ts files, recursively, in its containing folder. Can you verify that only the two .ts files that you expect to be there exist in the project folder?\n"
      },
      {
        "user": "NGumby",
        "created_at": "2015-08-06T21:02:52Z",
        "body": "Oh yeah, I had a subfolders with a bunch of config.xxxx.ts files that overwrites config.ts with a grunt task.  It was the fact that the repeats where at the end that threw me off.\n\nSorry about that, and thanks for pointing me in the good direction.\n"
      }
    ]
  },
  {
    "number": 4184,
    "title": "Completion for return value from `Promise.then`",
    "created_at": "2015-08-06T09:18:27Z",
    "closed_at": "2015-08-26T20:02:46Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/4184",
    "body": "Hi,\n\n**Version**: TS 1.5\n\nIn the code below, I would like return-value completion help for `function ff` the same as that for `function f`.\n\n``` typescript\ndeclare class Promise<TResult> {\n    then<TNext>(onFulfill?: (result: TResult) => TNext | Promise<TNext>): Promise<TNext>;\n}\n\ninterface Foo {\n    bar: string;\n}\n\nfunction f(): Foo {\n    return {\n        b // Okay: completion for property `bar` of `Foo`\n    };\n}\n\nfunction ff(): Promise<Foo> {\n\n    let p: Promise<any>;\n\n    return (\n        p.then(result =>{\n\n            return {\n                b // No completion?\n            };\n        })\n    )\n}\n```\n\nIs that going to be possible?\n\nThanks.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/4184/comments",
    "author": "NoelAbrahams",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2015-08-26T20:02:45Z",
        "body": "I do not see how we can make this work correctly, returning an object literal that is not a Foo is fine in this code, the issue is that the result of p.then is not assignable to the `Promise<Foo>`. in general the completion in object literals is driven by the contextual type flowing in, and in this case there is none. \n"
      }
    ]
  },
  {
    "number": 4171,
    "title": "Creating a class whose instances will be instances of Error",
    "created_at": "2015-08-05T22:05:25Z",
    "closed_at": "2015-08-10T23:39:44Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/4171",
    "body": "Hi,\n\nI'm creating some custom error classes, but ran into an issue when using jasmine's `expect(fn).toThrowError(MyCustomError);`\n\nThe problem is that jasmine's `toThrowError` matcher checks that the exception thrown by `fn` is an instance of `Error`. This is clumsy to satisfy in TypeScript, as in `lib.d.ts` `Error` is an interface.\n\nThus, if one creates `MyCustomError` in the most straightforward and intuitive way supported:\n\n``` javascript\nexport class MyCustomError implements Error { \n  public name: string = 'MyCustomError';\n  public message: string;\n}\n```\n\nand throws an instance of this class, code such as that in jasmine that checks for an instance of `Error` will fail. And yet, their assumption seems quite legitimate.\n\nHere's the code I ended up with:\n\n``` javascript\nexport class MyCustomError implements Error { \n  public name: string = 'MyCustomError';\n  public message: string;\n}\n\nMyCustomError.prototype = Object.create(Error.prototype);\n```\n\nThis will satisfy the `instanceof Error` constraint, but it's fairly unintuitive for what seems like a common task (creating a runtime subtype of `Error`) -- one that shouldn't require setting the `prototype` property manually.\n\nAny thoughts?\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/4171/comments",
    "author": "matthewjh",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2015-08-05T22:18:26Z",
        "body": "Upgrade to TypeScript nightly build (`npm install typescript@next`), or wait until TypeScript 1.6, then write\n\n``` ts\nclass MyCustomError extends Error {\n}\n```\n"
      },
      {
        "user": "matthewjh",
        "created_at": "2015-08-05T22:19:55Z",
        "body": "Oh cool. Out of interest, why was `Error` an interface in the first place and what motivated the change?\n"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2015-08-05T22:21:57Z",
        "body": "Prior to some other changes, it wasn't possible to augment an existing class the same way you can an interface (multiple class declarations were an error, rather than merging like interfaces do).\n\nThe change in 1.6 is that we allow arbitrary expressions in `extends` clauses instead of requiring the symbol to point to a class.\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2015-08-10T23:39:44Z",
        "body": "Looks like the original issue has been answered. please reactivate if you are running into other issues.\n"
      }
    ]
  },
  {
    "number": 4140,
    "title": "Can't define variable using type of typeof",
    "created_at": "2015-08-04T04:37:39Z",
    "closed_at": "2015-08-07T15:53:14Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/4140",
    "body": "I declared `test` module to export the global mongoose variable as below.\ntest1.d.ts:\n\n``` javascript\n  declare module \"test\" {\n    import _mongoose = require('mongoose');\n    export var export_mongoose: typeof _mongoose;\n  }\n```\n\nI tried to define mongoose.Model using the export_mongoose variable. Please refer to below code:\ntest2.ts:\n\n``` javascript\n  /// \\<reference path=\"test1.d.ts\" /\\>\n  import test = require('test');\n  var model: test.export_mongoose.Model\\<number\\>;  // it doesn't work.\n  var model = test.export_mongoose;  // it works well.\n```\n\nHowever, tsc compiler shows a following error message:\n  TS2305: Module `test` has no exported member `export_mongoose`.\n\nI think the export_mongoose is not proper as type cause defined by `typeof`.\nCan I use the `export_mongoose` as type?\n\nIt would be helpful for me if you have any idea on this.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/4140/comments",
    "author": "estherk0",
    "comments": [
      {
        "user": "DanielRosenwasser",
        "created_at": "2015-08-04T04:51:10Z",
        "body": "When you use `var export_mongoose = _mongoose`, `export_mongoose` only takes on the _value side_ of `_mongoose`.\n\nInstead of using `export_mongoose`, I suggest you instead export the import directly:\n\n``` TypeScript\ndeclare module \"test\" {\n    export import _mongoose = require(\"mongoose\");\n}\n```\n"
      },
      {
        "user": "estherk0",
        "created_at": "2015-08-04T07:36:30Z",
        "body": "Thanks for a quick reply!\n\nI understood how this code works.\nBut I have to use an export_mongoose variable for sharing the mongoose object in many places, not only test2.ts. \n\nIf there is no way to solve this problem, I will import mongoose and use it for type:\n\n``` javascript\nimport mongoose = ('mongoose');\nvar test_var: mongoose.Model<...>;\n```\n"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2015-08-04T14:27:07Z",
        "body": "Try \n\n``` Typescript\ndeclare module \"test\" {\n    import mongoose = require(\"mongoose\");\n    export import export_mongoose = mongoose;\n```\n\nThe `import...=` declaration above creates an alias to all meanings of `mongoose`.\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2015-08-04T17:17:56Z",
        "body": "I would use the ES6 import/export syntax here.\n\n``` Typescript\ndeclare module \"test\" {\n   // import it locally \n   import * as mongoose from \"mongoose\";\n   // use the import\n   var test_var: mongoose.Model<...>;\n\n   // export it directly from \"mongoose\" module\n   export * from \"mongoose\";\n```\n"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2015-08-04T17:40:45Z",
        "body": "Yes - if you're still intent on doing it the way you wanted, you can do something like\n\n``` TypeScript\ndeclare module \"test\" {\n    import * as mongoose from \"mongoose\";\n    export { mongoose as export_mongoose };\n}\n```\n"
      },
      {
        "user": "estherk0",
        "created_at": "2015-08-07T08:07:01Z",
        "body": "This is an exactly what I wanted to do. It works for me. Thanks.\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2015-08-07T15:53:20Z",
        "body": "glad that helped.\n"
      }
    ]
  },
  {
    "number": 4123,
    "title": "TSC does not emit in correct order when using tsconfig file and 'out'/'umd'",
    "created_at": "2015-08-02T20:14:48Z",
    "closed_at": "2015-08-10T23:35:44Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/4123",
    "body": "Compiler options in tsconfig file:\n\n```\n  \"compilerOptions\": {\n    \"target\": \"es5\",\n    \"module\": \"umd\",\n    \"out\": \"build/js/code.js\",\n    \"declaration\": true\n  }\n```\n\nOne of my classes, App.ViewModels.Search is always emitted before App.ViewModels.ViewModelBase, which the former extends, causing an exception when __extends is called.\n\n```\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    __.prototype = b.prototype;\n    d.prototype = new __();\n};\nvar Podchoosee;\n(function (Podchoosee) {\n    var ViewModels;\n    (function (ViewModels) {\n        var Search = (function (_super) {\n            __extends(Search, _super);\n            function Search() {\n                _super.apply(this, arguments);\n            }\n            return Search;\n        })(Podchoosee.ViewModels.ViewModelBase);\n        ViewModels.Search = Search;\n    })(ViewModels = Podchoosee.ViewModels || (Podchoosee.ViewModels = {}));\n})(Podchoosee || (Podchoosee = {}));\nvar Podchoosee;\n(function (Podchoosee) {\n    var ViewModels;\n    (function (ViewModels) {\n        var ViewModelBase = (function () {\n            function ViewModelBase() {\n            }\n            ...\n            return ViewModelBase;\n        })();\n        ViewModels.ViewModelBase = ViewModelBase;\n    })(ViewModels = Podchoosee.ViewModels || (Podchoosee.ViewModels = {}));\n})(Podchoosee || (Podchoosee = {}));\n```\n\nAdding an explicit reference to the ViewModelBase file in Search causes correct ordering, however this seems to defeat the purpose of using tsconfig.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/4123/comments",
    "author": "coreyRalli",
    "comments": [
      {
        "user": "danquirk",
        "created_at": "2015-08-03T20:26:32Z",
        "body": "What is 'the purpose of using tsconfig' to you here? Indeed the purpose would be to use the `files` property to explicitly define the ordering of files as required for their various dependency relationships. The TypeScript compiler does not attempt to automatically infer the correct order that your files should be compiled.\n"
      }
    ]
  },
  {
    "number": 4115,
    "title": "Reducing union types when inferring type parameters in function invocations",
    "created_at": "2015-08-01T15:40:49Z",
    "closed_at": "2015-08-03T20:22:16Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/4115",
    "body": "Spec 3.4 says:\n\n> Union types are reduced to the smallest possible set of constituent types using these rules\n\nBut in compiler they are not reduced in case of inferring type parameters in function invocations. For example:\n\n``` typescript\nvar o = {};\n\n// According to spec, type of p should be reduced to {}\nfunction f<T>(p: T | typeof o): T \n{\n    var t: T;\n    var temp = t || o; // here union type is reduced, and it is really {}\n    return null;\n}\n\n// Another function where type of p is really {}. According to spec, it should be equal to f, shouldn't it?\nfunction f2<T>(p: typeof o): T \n{\n    return null;\n}\n\n// But really they are different\nvar e = f(5); // number\nvar e2 = f2(5); // {}\n```\n\nCould you please clarify, when union type are really reduced and when they are not.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/4115/comments",
    "author": "osdm",
    "comments": [
      {
        "user": "JsonFreeman",
        "created_at": "2015-08-01T19:31:33Z",
        "body": "I imagine you are using the latest from master. Constituents in a union type are no longer reduced, at least not by the subtype relation. I believe this change is reflected in spec update #4033.\n"
      },
      {
        "user": "JsonFreeman",
        "created_at": "2015-08-01T19:36:57Z",
        "body": "And the code change for removing subtype reduction is #3823.\n"
      },
      {
        "user": "ahejlsberg",
        "created_at": "2015-08-01T23:21:06Z",
        "body": "> Union types are reduced to the smallest possible set of constituent types using these rules\n\nThat paragraph has been removed from the spec.\n\nI have yet to add a description of the new deduplication algorithm, but basically a type S is considered a duplicate of a type T if:\n- S and T are identical,\n- S is undefined,\n- S is null and T is not undefined,\n- S is an object literal type, T is an object type, and S has a property set that is a duplicate of T's,\n- S and T are array types, and S has an element type that is a duplicate of T's.\n- S and T are tuple types, and S has element types that are duplicates of T's.\n\nIn other words, we get rid of types that are identical to other types in the set, except they may have nulls or undefineds where the other types don't.\n\nThe implementation of this algorithm is in the `removeDuplicateTypes` function in checker.ts.\n"
      },
      {
        "user": "osdm",
        "created_at": "2015-08-02T00:32:03Z",
        "body": "@JsonFreeman @ahejlsberg Thanks for updates!\n"
      }
    ]
  },
  {
    "number": 4069,
    "title": "systemjs plugin import, typescript says module not found",
    "created_at": "2015-07-29T07:51:35Z",
    "closed_at": "2015-08-10T23:35:32Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/4069",
    "body": "typescript doesn't like `import somethingHTML from 'components/something/something.html!text';`complains it can't find a module.\n\n`import 'components/something/something.html!text';`\nwould work but not usable since I can't assign it to the template property of a component in angular.\n\nusing \njspm install text=github:systemjs/plugin-text\n\nWhat's odd is importing css via the systemjs loader works fine...\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/4069/comments",
    "author": "ghost",
    "comments": [
      {
        "user": "kitsonk",
        "created_at": "2015-07-29T08:33:23Z",
        "body": "I think you will need to declare an ambient module, something like this I think:\n\n``` typescript\ndeclare module 'components/something/something.html!text' {\n    var text: string;\n    export = text;\n}\n```\n"
      },
      {
        "user": "ghost",
        "created_at": "2015-07-31T05:47:37Z",
        "body": "@kitsonk  that works but that means I will need to do that for every template file.\n\nThis might be an issue @guybedford can solve in the plugin.\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2015-07-31T15:49:38Z",
        "body": "This is not something that systemJs or an extension can solve for you. There is a suggestion for the issue in #2709.\n"
      }
    ]
  },
  {
    "number": 4054,
    "title": "Common generic parameter type inference doesn't work for derived parameter types",
    "created_at": "2015-07-28T13:30:22Z",
    "closed_at": "2015-07-28T16:56:57Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/4054",
    "body": "Consider following definitions:\n\n```\nclass BaseClass<T> {\n}\n\nclass DerivedClass extends BaseClass<number> {\n}\n\nfunction usingParameters<T>(c:BaseClass<T>, p:T) {\n}\n```\n\nIn `usingParameters(new BaseClass<number>(), \"string\")` call common type inference works well and as a result can't infer common generic parameter type and compiler fails with error.\n\nIn `usingParameters(new DerivedClass(), \"string\");` call common type inference doesn't seem to check if `DerivedClass` derives exactly from `BaseClass<string>` or that `\"string\"` is not `number` and everything compiles well.\n\nThe same thing about object notation\n\n```\ninterface IParameters<T> {\n    c: BaseClass<T>,\n    p: T\n}\n\nfunction usingObject<T>(IParameters<T>) {\n}\n\nusingObject({ c: new BaseClass<number>(), p: \"string\" }); //Fails\nusingObject({ c: new DerivedClass(), p: \"string\" }); //Compiles\n```\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/4054/comments",
    "author": "outring",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2015-07-28T16:56:56Z",
        "body": "The problem here is that `BaseClass` doesn't have any members of type `T`. So in terms of a structural type system, `class DerivedClass extends BaseClass<number>` is the same as `class DerivedClass extends BaseClass<Rocket>` -- they have identical members.\n\nIf you add a member of type `T` to `BaseClass`, everything works like you expect. In practice, you should _never_ have an unconsumed generic type parameter, as it's completely meaningless.\n"
      },
      {
        "user": "outring",
        "created_at": "2015-07-29T04:31:07Z",
        "body": "I'm terribly sorry, the real code has the generic member and it doesn't work as expected too, and I thought that the code above is equivalent. The problem in my real code must be somewhere else, I'll try to figure out where. Thank you!\n"
      },
      {
        "user": "outring",
        "created_at": "2015-07-29T04:52:00Z",
        "body": "Ok, it seems that I have isolated the real problem and it applies only to objects and, what is the most important, nested objects.\n\n```\nclass BaseClass<T> {\n    p:T;\n}\n\nclass DerivedClass extends BaseClass<number> {\n}\n\ninterface IParameters<T> {\n    c: BaseClass<T>,\n    p: T,\n    content?: IParameters<any>\n}\n\nfunction usingObject<T>(p:IParameters<T>) {\n}\n\nusingObject({ \n    c: new BaseClass<number>(),\n    p: 1,\n    content: {  //Must fail\n        c: new BaseClass<number>(), \n        p: \"string\"\n    }\n});\n\nusingObject({ \n    c: new DerivedClass(), \n    p: 1,\n    content: {  //Must fail\n        c: new DerivedClass(),\n        p: \"string\"\n    }\n});\n```\n\nIn the example above, `content` property is incorrect and must not typecheck, but it does. I can imagine, that there could be the performance problem when typechecking such structures, so maybe there is another common way to build typesafe nested structures?\n"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2015-07-29T05:10:20Z",
        "body": "The example is working as intended because `content` is defined as `IParameters<any>`, so `content.p` is of type `any` and `content.c` is of type `IParameters<any>`.\n\nYou can tweak the example a little and get correct errors:\n\n``` ts\ninterface IParameters<T> {\n    c: BaseClass<T>,\n    p: T,\n    content?: IParameters<T>\n}\n\nfunction usingObject<T>(p:IParameters<T>): T {\n    return null;\n}\n\nlet a = usingObject({ \n    c: new BaseClass<string>(),\n    p: '1',\n    content: {  //Must fail\n        c: new BaseClass<string>(), \n        p: '32'\n    }\n});\n\nlet b = usingObject({ \n    c: new DerivedClass(), \n    p: 1,\n    content: {  //Must fail, does\n        c: new DerivedClass(),\n        p: \"string\"\n    }\n});\n```\n"
      },
      {
        "user": "outring",
        "created_at": "2015-07-29T05:16:48Z",
        "body": "Got it, thank you. But the problem is that the `content: IParameters<T>` could not share parent's `T`, there could be any other type and it seems that there's no way to say, the the `T` could be `any`, but only certain `any` :(\n"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2015-07-29T06:47:31Z",
        "body": "Is this closer to what you want?\n\n``` ts\ninterface IParameters<T, U> {\n    c: BaseClass<T>,\n    p: T,\n    content?: IParameters<U, any>\n}\n```\n"
      },
      {
        "user": "outring",
        "created_at": "2015-07-29T06:53:15Z",
        "body": "Yep, I've already tried that, but it works only for 2 levels of nesting :) \n"
      },
      {
        "user": "outring",
        "created_at": "2015-07-29T06:57:31Z",
        "body": "But now I got it, and it seems, that there is no easy way to achieve what I want. Ideal solution is possibility to constrain `any` to single type which requires proposition and possibly violates some of the type system concepts :D\nFor now I'll try to solve it another way. Thank you very much!\n"
      }
    ]
  },
  {
    "number": 3980,
    "title": "Class expression inside a generic function bug",
    "created_at": "2015-07-22T15:10:11Z",
    "closed_at": "2015-07-22T17:41:12Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/3980",
    "body": "This code seems to be valid TS:\n\n``` ts\ninterface ReactClass<P, S> {\n    setState(state: S): void;\n}\n\ninterface Props {}\n\ninterface State {\n    hovered: boolean;\n}\n\nfunction createComponent<P extends Props, S extends State>() {\n    return class Component implements ReactClass<P, S> {\n        constructor() {\n            this.setState({ hovered: true })\n        }\n\n        setState(state: S): void {}\n    }\n}\n```\n\nBut it fails to compile:\n\n```\nissue.tsx(15,27): error TS2345: Argument of type '{ hovered: boolean; }' is not assignable to parameter of type 'S'.\n```\n\nIs it a bug?\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/3980/comments",
    "author": "s-panferov",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2015-07-22T17:39:54Z",
        "body": "this is not really related to classes or functions. the constraint on S is it has to be _at least_ of type state, but does not mean that a value of type State is assignable to it, it may need more properties that are missing in the base type.\n\nhere is a simplified version of your snippit:\n\n``` ts\nfunction setState<T extends State>(t: T) {\n    var s: State = { hovered: true };\n\n    s = t; // OK, t is a T, which is a State\n    t = s; // Error, s may not be a T\n}\n```\n"
      },
      {
        "user": "s-panferov",
        "created_at": "2015-07-22T17:41:11Z",
        "body": "@mhegazy I understand, thanks!\n"
      }
    ]
  },
  {
    "number": 3977,
    "title": "InterfaceTypeWithBaseTypes.baseTypes is lazily loaded without clear API to do that",
    "created_at": "2015-07-22T09:42:13Z",
    "closed_at": "2015-07-23T03:47:52Z",
    "labels": [
      "Question",
      "Fixed",
      "API"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/3977",
    "body": "This issue appeared after upgrading from 1.4 to 1.5 - the baseTypes of a class were always returning `undefined` - by looking in the source I found that calling, for example, `getConstructSignatures()` would lazily load the data.\n\n```\n    if (node.kind === ts.SyntaxKind.ClassDeclaration) {\n        var cl = <ts.InterfaceTypeWithBaseTypes>checker.getTypeAtLocation(node);\n        console.log(cl.baseTypes); // prints \"undefined\"\n        cl.getConstructSignatures();\n        console.log(cl.baseTypes); // prints the actual base types\n    }\n```\n\nIt seems that instead of exposing the field `baseTypes`, there should be a method `getBaseTypes()` - similar to other such changes in the API.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/3977/comments",
    "author": "Knagis",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2015-07-22T17:27:46Z",
        "body": "pinging @JsonFreeman\n"
      },
      {
        "user": "JsonFreeman",
        "created_at": "2015-07-22T17:49:10Z",
        "body": "In general, there are two recommendations for using the Types API:\n1. Do not cast to a type that grants you access to more properties. These properties are generally hidden in a subtype for a reason.\n2. Do not directly access properties that start with `resolved`\n\nInstead, you should call a function that gets you these things and that will take care of the lazy computation.\n\n@Knagis In the version of the code that you're looking at, we do indeed have a getBaseTypes that you should call.\n\nIf you update to the latest in master, getBaseTypes is still there, but InterfaceTypeWithBaseTypes is gone. Instead there is a property called resolvedBaseTypes which should not be accessed. There is additionally resolvedBaseConstructorType which should not be accessed (for that one you call getBaseConstructorTypeOfClass).\n\nI wish there were a better way to hide members that should not be accessed directly, but the only way I know of is to use privates, which today require that the containing type be a class. And we don't use classes in the compiler.\n\nAlthough now that ambient classes and interfaces can be merged, maybe we can.\n"
      },
      {
        "user": "JsonFreeman",
        "created_at": "2015-07-22T17:49:31Z",
        "body": "@mhegazy Is there anything that needs to be done here?\n"
      },
      {
        "user": "JsonFreeman",
        "created_at": "2015-07-22T17:54:17Z",
        "body": "@Knagis, are you asking us to expose the getBaseTypes function on the TypeChecker interface? What are you trying to use it for?\n\nAlso, I think we should designate these properties as internal.\n"
      },
      {
        "user": "Knagis",
        "created_at": "2015-07-22T19:30:54Z",
        "body": "> @Knagis In the version of the code that you're looking at, we do indeed have a getBaseTypes that you should call.\n\nIn the master branch I only see `resolvedBaseTypes` field but no `getBaseTypes()` method.\n\n---\n\nI am writing code that extracts certain classes and properties from the code and creates documentation page from that. I need base types both to check if a class should be included in the documentation (if it is derived from a certain base class) and to display the type hierarchy there. Is there a different approach I should use for this purpose?\n"
      },
      {
        "user": "JsonFreeman",
        "created_at": "2015-07-22T20:00:38Z",
        "body": "I was talking with @mhegazy and he suggested maybe getting the base type nodes from the AST and then getting the types of those base type nodes. So if you have the class declaration node `classNode`, you would `classNode.heritageClauses`, find the extends list in there, call it `heritage`. Then `heritage.types`, and those will be expressions with type arguments. Then call `checker.getTypeAtLocation` on that base type node. And then it should give you the right thing.\n"
      },
      {
        "user": "Knagis",
        "created_at": "2015-07-22T20:48:12Z",
        "body": "That could be done, it just slightly increases the complexity since there can be multiple declarations.\n\nWhat is the reason why the Type could not expose the baseTypes? If I call `Type.getProperties()`, it returns all properties including inherited properties from base types - so it does have this information internally.\n"
      },
      {
        "user": "JsonFreeman",
        "created_at": "2015-07-22T20:50:55Z",
        "body": "Oh I see, you are not using the TypeChecker interface, you are using the Type interface defined in services. I think you're right - it's reasonable for us to expose getBaseTypes().\n"
      },
      {
        "user": "JsonFreeman",
        "created_at": "2015-07-22T22:32:28Z",
        "body": "@Knagis does #3990 address your need?\n"
      },
      {
        "user": "Knagis",
        "created_at": "2015-07-23T03:47:52Z",
        "body": "Yes, it does.\nThank you!\n"
      }
    ]
  },
  {
    "number": 3933,
    "title": "Unable to use combinators on prototypes.",
    "created_at": "2015-07-20T19:05:22Z",
    "closed_at": "2015-07-21T15:40:31Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/3933",
    "body": "I can not apply combinators to prototype. A combinator is a function that takes a function and returns another function. I use these to divide up functionality. I can use them in TypeScript, but they do not go on the prototype. I struggled to get them on the prototype, but TypeScript always throws an error. Here is an example of what I was trying to do. Inspired by TypeScript unions types I found many cases where I would like to pass T or T[]. I needed to write the code to handle this many places. So I wrote a combinator to handle this. So I would have:\n\n``` javascript\nfunctionThatCanHandleBoth = makeFunctionToHandleArrayAndSingle(handleSingleFunction)\n```\n\nI want to put this on the prototype because I want to use these functions in objects that have many instances.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/3933/comments",
    "author": "willseitz",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2015-07-20T19:21:59Z",
        "body": "If i understand the issue correctly, you want to consolidate handling of parameter in one place, how about using decorators,\n\n``` ts\nclass C {\n    @makeFunctionToHandleArrayAndSingle\n     handleSingleFunction<T>(a:T) {\n\n    }\n}\n```\n\nalso you can put it directelly on the prototype if you want to:\n\n``` ts\nclass C {\n    handler: <T>(a: T | T[]) => void;\n}\n\nC.prototype.handler = makeFunctionToHandleArrayAndSingle(handleSingleFunction);\n```\n"
      },
      {
        "user": "willseitz",
        "created_at": "2015-07-21T15:40:31Z",
        "body": "*Edited a few times *\n\nThanks for the response. Both those approaches work (I had tried the second, but decorators were new to me), but I couldn't get either to preserve context aka 'this' at the time. I discovered that this issue was actually in how I was making the decorator and not in the transpiled code. \n\nFor reference here is a sample:\n\n``` javascript```\nvar decorate = function(func) {\n    console.log(\"decoration being set up\");\n    return function() {\n        console.log(\"/-----\\\\\");\n        var retval = func.apply(this,arguments);\n        console.log(\"\\\\-----/\");\n        return retval;\n    }\n}\n\nclass Dog {\n    constructor(private barkNoise: string) {\n\n    }\n    bark() {\n        console.log(this.barkNoise);\n    }\n}\n\n\nDog.prototype.bark = decorate(Dog.prototype.bark);\n\nvar littleDog = new Dog(\"Yip\");\nvar bigDog = new Dog(\"Woof\");\n\nlittleDog.bark();\nlittleDog.bark();\nlittleDog.bark();\nbigDog.bark();\n```\n\nand the decorator version:\n\n``` javascript\nvar decorate = (target, name, property) => {\n    console.log(\"decoration being set up\");\n    var func = property.value;\n// This must remain 'function', using fat arrow will disturb the context\n    property.value = function (...args) {\n        console.log(\"/-----\\\\\");\n        var retval = func.apply(this,args);\n        console.log(\"\\\\-----/\");\n        return retval;\n    }\n}\n\nclass Dog {\n    constructor(private barkNoise: string) {        \n    }\n    @decorate\n    bark() {\n        console.log(this.barkNoise);\n    }\n}\n\nvar littleDog = new Dog(\"Yip\");\nvar bigDog = new Dog(\"Woof\");\n\nlittleDog.bark();\nlittleDog.bark();\nlittleDog.bark();\nbigDog.bark();\n```\n"
      }
    ]
  },
  {
    "number": 3865,
    "title": "Object.create return type",
    "created_at": "2015-07-15T14:13:30Z",
    "closed_at": "2015-08-10T23:31:58Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/3865",
    "body": "Hi,\n\nJust curious as to the reasoning behind `Object.create` having a return value of type `any` in lib.d.ts.\n\nWouldn't this make more sense?\n\n`create<T extends A>(o: A, properties?: PropertyDescriptorMap): T;`\n\nsince the returned object is guaranteed to have the properties of `o` through prototypal inheritance.\n\nAt present I'd like to create many objects (via literals) of type `X`, but given that many of the properties are shared, using `Object.create` makes a lot of sense. It seems a shame that I must use this at the expense of typing. \n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/3865/comments",
    "author": "matthewjh",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2015-07-15T16:53:32Z",
        "body": "Mostly we see `Object.create` being used in code that doesn't really benefit from typing, or with `Object.create(null)` to create a map object, which is going to require a type assertion anyway.\n\n> At present I'd like to create many objects (via literals) of type X, but given that many of the properties are shared, using Object.create makes a lot of sense\n\nCan you post some examples of what this looks like? I can't think of any code that it would meaningfully benefit from a different declaration of `Object.create` in the scenario you describe.\n"
      },
      {
        "user": "dead-claudia",
        "created_at": "2015-07-18T08:28:12Z",
        "body": "And `Object.create(Foo.prototype)` is not necessarily the same as `new Foo()`. Especially if the constructor itself defines methods passed as arguments. And the other option is a matter of where the cast goes. Usually, the second is better.\n\n``` ts\nlet foo = Object.create<FooLike>(Foo.prototype);\nlet foo = <FooLike> Object.create(Foo.prototype);\n```\n"
      },
      {
        "user": "matthewjh",
        "created_at": "2015-07-18T19:10:55Z",
        "body": "@impinball Of course it isn't, but I don't really see what relevance that has here. Also, I don't think the former line in your block of code is a cast, but a type parameter.\n\n@RyanCavanaugh, here's an example:\n\n``` javascript\ninterface IHouse {\n   location: Coordindate;\n   price: number;\n   developerName: string;\n}\n\nvar baseHouse = {\n  location: new Coordinate(50, 100),\n  price: 350000,\n  developerName: 'Test Developer'\n};\n\nvar house1 = Object.create(baseHouse);\nhouse1.price = 400000;\n\nvar house2 = Object.create(baseHouse);\nhouse2.price = 360000;\n\n// Assume the type of buildHouses is `(houses: IHouse[]) => void`\nbuildHouses([\n   house1,\n   house2\n]);\n```\n\nThis code will work because `house1` and `house2` will be typed as `any` via `Object.create`, even though we know that its return value will have type `typeof baseHouse`. Why not add type information where possible so that the type checker has a greater scope to be useful… isn't that a 'tenet' of TypeScript? For me it's not so much a matter of 'do we need typing here?' but more one of 'why are we using 'any' in a case where the return type is entirely determined?'\n"
      },
      {
        "user": "kitsonk",
        "created_at": "2015-07-18T20:04:09Z",
        "body": "@matthewjh I understand what you are saying, and from an overall logic perspective it makes sense, but what problem do you see with this?\n\n``` typescript\nvar house1 = <IHouse> Object.create(baseHouse);\nhouse1.price = 400000;\n\nvar house2 = <IHouse> Object.create(baseHouse);\nhouse2.price = 360000;\n```\n\nIf you made the change you suggested, everyone using `Object.create` would have to pass an type argument, breaking a lot of peoples code, making it more difficult for people to migrate to TypeScript, when in fact to get the same effective type guarding you have to type the same amount of letters, just a little bit to the left.\n"
      },
      {
        "user": "matthewjh",
        "created_at": "2015-07-18T20:25:08Z",
        "body": "That's a fair point, but the same could be said for many things:\n\n`var doubledNumbers = numbers.map((x) => x * 2);`\nvs\n`var doubledNumbers = <number[]> numbers.map((x) => x * 2);`\n\nSure, we can use a cast based on what 'we' think the type is, but we shouldn't wherever possible. That's why we have a type inference system and type checking in the first place -- to cut humans out of figuring out types themselves and thereby making errors.\n\nThe problem with casting the return value of `Object.create` is the same as the problem with casting in general: we're telling the type system that value `a` WILL have type `T`, and that it should accept that as fact. \n\nGiven\n\n`var house2 = <IHouse> Object.create(baseHouse);`\n\nwhat happens if `baseHouse` is changed so that it no longer implements `IHouse`? This line of code doesn't break as far as the TypeScript compiler is concerned, and if we try to use `house2` as an `IHouse` it of course passes type checking happily -- but it shouldn't. I believe this would likely cause a runtime rather than compile time error, which is exactly what static type analysis systems are supposed to prevent.\n\nIf the definition of `Object.create` was \n\n`create<T>(o: T): T;`\n\nthis would be easily prevented and picked up during type analysis without introducing any breaking changes (because T could be inferred).\n\nThe problem is that when property descriptors are passed to Object.create the returned type will be a supertype of T, which is why my original proposal was\n`create<T extends A>(o: A, properties?: PropertyDescriptorMap): T;`\n\nHowever, that would be a breaking change as you point out (assuming TypeScript's type inference system isn't able to infer cases where `typeof A === typeof T`, and reduce `T extends A` to `T`, i.e. the case where no new properties are added via descriptors... I have no idea). Is there any reason why the definition below wouldn't suffice WITHOUT the need for breaking changes?\n\n`create<T>(o: T, properties?: PropertyDescriptorMap): T;`\n\nT could still be inferred in most (all?) cases, and the typing will still, I believe, be correct even if property descriptors are passed, because if you add properties to a `T` it's still a `T`. If you want to assign to a supertype with additional properties that are added via descriptors, you would have to cast it, but I would suggest that this is a very, very, very, rare use case.\n\nI'm still new to TypeScript myself, so feel free to point out any errors I've made. :)\n\n(By the way, Kit, I recognised your name in the notification of your comment. I used to work at Sky!)\n"
      },
      {
        "user": "dead-claudia",
        "created_at": "2015-07-19T06:52:20Z",
        "body": "Okay. I see what you mean WRT interfaces. Object.create doesn't change interfaces, but it doesn't work with class prototypes.\n"
      },
      {
        "user": "dead-claudia",
        "created_at": "2015-07-19T06:53:36Z",
        "body": "And as for `Object.create<T>(object: T)`, that could be done as a PR now, without any extra implementation work.\n"
      },
      {
        "user": "dead-claudia",
        "created_at": "2015-07-19T20:42:51Z",
        "body": "Oops... Ignore that comment. (that would require using only the interface, which TypeScript doesn't support.) \n"
      }
    ]
  },
  {
    "number": 3791,
    "title": "No error checking on generic abstract method",
    "created_at": "2015-07-09T07:58:34Z",
    "closed_at": "2015-07-09T17:08:09Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/3791",
    "body": "``` typescript\nexport abstract class ComposerContent<PropsT, StatesT, FetchT> extends ReactComposerComponent< PropsT, StatesT > {\n    public abstract fetch< FetchT >(): FetchT;\n}\n\nclass Feed1 extends ComposerContent<{}, {}, boolean> {\n    fetch() {\n        return 'string'; // no error should be boolean?\n    }\n}\n\nclass Feed2 extends ComposerContent<{}, {}, boolean> {\n    fetch(): string { // no error\n        return 'string';\n    }\n}\n```\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/3791/comments",
    "author": "tinganho",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2015-07-09T17:08:09Z",
        "body": "The type parameter `FetchT` in `fetch` is shadowing the outer generic type parameter from the class. Remove it and errors appear.\n"
      },
      {
        "user": "danquirk",
        "created_at": "2015-07-09T18:56:40Z",
        "body": "I wonder how often this sort of shadowing is necessary/desirable, it's not unreasonable to just error on it in the first place.\n"
      }
    ]
  },
  {
    "number": 3785,
    "title": "problem with rest params and function overloading",
    "created_at": "2015-07-08T21:04:47Z",
    "closed_at": "2015-07-09T17:55:52Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/3785",
    "body": "``` ts\nexport function injection(clazz: Class)\n    export function injection(...metadata: Metadata[])\n    export function injection(...value: any[]) {\n\n        if (typeof value === typeof []) {\n            return (clazz: Class) => {\n                Injector.instance.register(clazz, value);\n            }\n        }\n        else {\n            Injector.instance.register(<any>value);\n        }\n    }\n```\n\nI`v got the compilation error\n\n```\nArgument of type 'any[]' is not assignable to parameter of type 'Metadata'.\n```\n\nand \n\n```\nArgument of type 'any[]' is not assignable to parameter of type 'Metadata'.\n  Property 'name' is missing in type 'any[]'.   \n```\n\nHave you any idea?\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/3785/comments",
    "author": "OlegDokuka",
    "comments": [
      {
        "user": "danquirk",
        "created_at": "2015-07-08T21:10:20Z",
        "body": "What code is actually triggering the compilation error? Those lines you pasted do not have the errors you're mentioning.\n"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2015-07-08T22:00:44Z",
        "body": "I'm presuming the code looks like this:\n\n``` ts\ninterface Class { }\ninterface Metadata {\n    name: string;\n}\n\ndeclare var Injector: {\n    instance: {\n        register(c: Class, value: Metadata[]);\n        register(c: Class);\n    }\n}\n\nfunction injection(clazz: Class)\nfunction injection(...metadata: Metadata[])\nfunction injection(...value: any[]) {\n    if (typeof value === typeof []) {\n        return (clazz: Class) => {\n            Injector.instance.register(clazz, value);\n        }\n    }\n    else {\n        Injector.instance.register(<any>value);\n    }\n}\n```\n\nSeveral problems going on here.\n\nFirst, this line is wrong:\n\n``` ts\n   function injection(...value: any[]) {\n```\n\nHaving a rest arg in the implementation signature means that you're always going to have your arguments wrapped in an array, which means you're never going to hit the `else` clause. Instead, this should be `value: any`.\n\nMore accurately, though, you can write:\n\n``` ts\n    function injection(value: Metadata[]|Class) {\n```\n\nIf you do this, we can move on to the next problem.\n\n``` ts\n    if (typeof value === typeof []) {\n```\n\nThis code is also wrong (or at least overstates its specificity). `typeof []` is `\"object\"`, so this test is always going to be `true` for a bunch of things that aren't arrays. It's more accurate to write\n\n``` ts\n        if (value instanceof Array) {\n```\n\nIf you do both these fixes, the entire example compiles without error:\n\n``` ts\ninterface Class { }\ninterface Metadata {\n    name: string;\n}\n\ndeclare var Injector: {\n    instance: {\n        register(c: Class, value: Metadata[]);\n        register(c: Class);\n    }\n}\n\nfunction injection(clazz: Class)\nfunction injection(...metadata: Metadata[])\nfunction injection(value: Metadata[]|Class) {\n    if (value instanceof Array) {\n        return (clazz: Class) => {\n            Injector.instance.register(clazz, value);\n        }\n    }\n    else {\n        Injector.instance.register(<any>value);\n    }\n}\n```\n"
      },
      {
        "user": "OlegDokuka",
        "created_at": "2015-07-09T05:48:28Z",
        "body": "Thanks a lot!!!\n"
      }
    ]
  },
  {
    "number": 3704,
    "title": "Redundant lines of code generated from constructors?",
    "created_at": "2015-07-02T02:12:51Z",
    "closed_at": "2015-07-06T16:55:54Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/3704",
    "body": "Hello everyone.\n\nI'm learning TypeScript and I noticed some weird behaviour. I don't know if it's intentional or not and I didn't find answers because I don't know exactly how to describe the issue since English is not my main language. But let me show you an example:\n\nI have this class:\n\n``` typescript\nclass Vector2D {\n\n    X: number;\n    Y: number;\n\n    constructor();\n    constructor(X: number, Y: number);\n    constructor(X?: number, Y?: number) {\n        this.X = X || 0;\n        this.Y = Y || 0;\n    }\n}\n```\n\nAnd it generates this javascript code, which is fine:\n\n``` typescript\nvar Vector2D = (function () {\n    function Vector2D(X, Y) {\n        this.X = X || 0;\n        this.Y = Y || 0;\n    }\n    return Vector2D;\n})();\n```\n\nHowever, from what I understand, there is a shorter way to write that code that should do exactly the same:\n\n``` typescript\nclass Vector2D {\n\n    constructor();\n    constructor(X: number, Y: number);\n    constructor(public X?: number, public Y?: number) {\n        this.X = X || 0;\n        this.Y = Y || 0;\n    }\n}\n```\n\nAnd it generates this Javascript code:\n\n``` typescript\nvar Vector2D = (function () {\n    function Vector2D(X, Y) {\n        this.X = X;\n        this.Y = Y;\n        this.X = X || 0;\n        this.Y = Y || 0;\n    }\n    return Vector2D;\n})();\n```\n\nIt does the same, but notice those two extra lines that have no purpose. So I don't know if I'm doing something wrong, or if this is a normal behaviour or some kind bug.\n\nThanks for your attention. Greetings! :)\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/3704/comments",
    "author": "MaikelChan",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2015-07-02T03:06:25Z",
        "body": "When annotating a constructor paramter with `public`, `private` or `protected`, the compiler emits code to intialize the properties for you. this helps with common pattern with instance properties initialized to constructor arguments.\n\nSo\n\n``` ts\nclass C {\n    constructor(private x, public y) {}\n}\n```\n\nis equivalent to:\n\n``` ts\nclass C {\n    private x;\n    public y;\n    constructor(x, y) {\n         this.x = x;\n         this.y = y;\n    }\n}\n```\n\nin your example you are intializing the values to `0` if they are empty, so to do that you can:\n\n``` ts\nclass Vector2D {\n\n    constructor();\n    constructor(X: number, Y: number);\n    constructor(public X = 0, public Y = 0) {\n    }\n}\n```\n\nor as:\n\n``` ts\nclass Vector2D {\n    public X: number;\n    public Y: number;\n\n    constructor();\n    constructor(X: number, Y: number);\n    constructor(X?: number, Y?: number) {\n        this.X = X || 0;\n        this.Y = Y || 0;\n    }\n}\n```\n"
      },
      {
        "user": "emilekberg",
        "created_at": "2015-07-05T20:45:28Z",
        "body": "I'm not sure if it's a wierd behaviour or if you're just not using default parameters as intended. For instance why don't you just do this:\n\n```\nclass Vector2D {\n    X: number;\n    Y: number;\n    constructor(X:number = 0, Y:number = 0) {\n        this.X = X;\n        this.Y = Y;\n    }\n}\n```\n\nthis should cover all the constructors you asked for without overloading it.\n\nor \n\n```\nclass Vector2D {\n    constructor(public X:number = 0, public y:number = 0) {\n    }\n}\n```\n"
      }
    ]
  },
  {
    "number": 3609,
    "title": "AST does not include an `Any` token for restructured bindings",
    "created_at": "2015-06-23T19:57:30Z",
    "closed_at": "2015-06-23T20:10:24Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/3609",
    "body": "The AST will not include an Any token when parsing restructured bindings. I wrote the following program to demonstrate.\n\ntest.ts\n\n``` typescript\nlet {a: any, b: number} = {a: 2, b: 4};\n```\n\nprint_tokens.js\n\n``` javascript\nvar ts = require('typescript');\nvar fs = require('fs');\n\nvar txt = fs.readFileSync(\"test.ts\").toString('utf-8');\nvar sf = ts.createSourceFile(\"test.ts\", txt, 1 /* es5*/ , false);\n\nfunction printKinds(node) {\n  console.log(node.kind);\n  ts.forEachChild(node, printKinds);\n}\n\nts.forEachChild(sf, printKinds);\n```\n\nWe expect two Any tokens (code=112).  The output is:\n\n```\n180\n199\n198\n150\n152\n65\n65\n152\n65\n65\n154\n224\n65\n7\n224\n65\n7\n1\n```\n\nWhen I change test.ts to\n\n``` typescript\nlet a: any = 2;\n```\n\nI get\n\n```\n180\n199\n198\n65\n112\n7\n1\n```\n\nwhich includes 112.\n\nIs this expected behavior?\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/3609/comments",
    "author": "leeavital",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2015-06-23T20:10:24Z",
        "body": "Yes. The names `any` and `number` in your example are _identifiers_ in the value space, not keywords that are types. This destructuring means \"Take the `a` member of the RHS and assign it to the variable `any` and take the `b` member of the RHS and assign it to the variable `number`\".\n\n``` ts\nlet {a: any, b: number} = { a: 2, b: 4 };\n\nany = 43;\nany = 'foo'; // error\nnumber = 100;\nnumber = 'bar'; // error\n```\n"
      },
      {
        "user": "danquirk",
        "created_at": "2015-06-23T20:23:24Z",
        "body": "For completeness, if you want a type annotation on a destructuring binding you need to apply it to the whole binding, not individual elements, since ES6 uses that syntax for renaming:\n\n``` ts\nlet {a, b}: { a: any; b: number } = { a: 2, b: 4 };\nb = 'no'; // error\n```\n"
      }
    ]
  },
  {
    "number": 3581,
    "title": "Create type Math on Window, in lib.d.ts",
    "created_at": "2015-06-20T02:58:24Z",
    "closed_at": "2015-06-20T23:50:14Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/3581",
    "body": "`tested with tsc 1.5.0-alpha`\n\n```\nvar n = window.Math.min(1, 2);\n```\n\n`error TS2339: Property 'Math' does not exist on type 'Window'.`\nWorkaround:\n\n```\nvar n = (<any>window).Math.min(1, 2);\n```\n\nThis does not seem alright. It seems normal to have `Map`, `Set`(ES6), `Map`(ES6) available on `Window`. Please let me know if this is not the correct way to access `Math`\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/3581/comments",
    "author": "aicioara",
    "comments": [
      {
        "user": "kitsonk",
        "created_at": "2015-06-20T06:08:40Z",
        "body": "Is there a reason you aren't doing?\n\n``` ts\nvar n = Math.min(1, 2);\n```\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2015-06-20T18:22:10Z",
        "body": "if you want to augment window, just add the definition as such:\n\n``` ts\ninterface Window {\n    Math: typeof Math;\n}\n```\n"
      },
      {
        "user": "mariusschulz",
        "created_at": "2015-06-20T19:59:55Z",
        "body": "@mhegazy This solves the problem, but I'm still wondering: Is there any reason _not_ to add this typing (directly or augmented) to _lib.d.ts_?\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2015-06-20T23:50:14Z",
        "body": "Window is considered the global polluter. any thing you put on the global scope in a js file in a web context, is accessible of window, and this in the global scope. Use of window/this/global scope to declare variables is considered an anti-pattern, and accessing global of window hinders your code from working with other js environments, e.g. node. TypeScript opted in a more conservative world view where you do not pollute the global namespace by default, and you need to declare any of these pollutants. Math and DOM APIs are not any different in this sense from any other user defined variables. \n"
      }
    ]
  },
  {
    "number": 3571,
    "title": "Question : Is it possible to get specific code completions such as a list of constructors in JS after typing the keyword new ?",
    "created_at": "2015-06-19T13:38:05Z",
    "closed_at": "2015-08-10T23:09:54Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/3571",
    "body": "I don't know if it is possible to get such specific completions after the keyword new in JS using TypeScript, any advice ?\n\nThanks for your help guys !\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/3571/comments",
    "author": "ghost",
    "comments": [
      {
        "user": "DanielRosenwasser",
        "created_at": "2015-06-19T13:42:18Z",
        "body": "Right now we don't do type-directed completion at a given location - we simply provide all entities in scope as well as keywords.\n\nYou could potentially use the returned completion data after a `new` to see if each entry has a construct signature or is a `void`-returning function, and filter that down.\n"
      },
      {
        "user": "ghost",
        "created_at": "2015-06-19T13:49:01Z",
        "body": "Thank you for your answers, you really help me !\n\nGuessing if I'm currently typing a new statement shouldn't be to difficult, and if I just have to filter some results could easily make the job and be of good help.\n\nI'll share my experience as soon as possible.\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2015-08-10T23:09:54Z",
        "body": "@DanielRosenwasser  can you log an issue to track contextual-type-driven completion?\n"
      }
    ]
  },
  {
    "number": 3562,
    "title": "Computed properties",
    "created_at": "2015-06-18T19:17:44Z",
    "closed_at": "2015-08-10T23:08:23Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/3562",
    "body": "``` typescript\nconst nameMember = \"_name\";\n\nclass Cls {\n    private [nameMember]: string;\n\n    constructor(name: string) {\n        this[nameMember] = name;\n    }\n}\n```\n\nCould be wrong, but isn't this now legal syntax? In both ES5 and ES6 modes, this generates the error:\n\n\"_A computed property name in a class property declaration must directly refer to a built-in symbol._\"\n\nComputed properties are listed on the Roadmap for Typescript 1.5 - is that still the case? If so, will ES6 mode be required, or will it work with ES5? Thanks.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/3562/comments",
    "author": "jamiewinder",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2015-06-18T21:28:35Z",
        "body": "Computed property names are valid in object literals. They are not supported as class property declarations (note that property declarations are not part of the ES6 class specification, so this is orthogonal to ES5/ES6).\n"
      },
      {
        "user": "jamiewinder",
        "created_at": "2015-06-18T21:51:40Z",
        "body": "Understood, thanks. I think a similar syntax would be useful specifically for TypeScript though. The code above effectively indicates that if a property is accessed on an instance of this class with the specified const variable (i.e. a[nameMember]) then assume the return value is a string. \n\nPerhaps this is something different entirely, but it'd be very handy.\n"
      },
      {
        "user": "JsonFreeman",
        "created_at": "2015-06-18T23:27:43Z",
        "body": "The feature you are asking for is constant propagation. We'd have to recognize in certain contexts that a const declared name corresponds uniquely to a single value. Then we could support class properties for these kinds of constants.\n\nOne requirement is that we could only support string or number literals because we have to know the value of that const at compile time. Otherwise we cannot know if two different consts refer to the same value.\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2015-08-10T23:08:23Z",
        "body": "Constant propagation is covered by #3964\n"
      }
    ]
  },
  {
    "number": 3549,
    "title": "No source for the diagnosticInformationMap generation?",
    "created_at": "2015-06-18T13:08:48Z",
    "closed_at": "2015-06-18T17:25:26Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/3549",
    "body": "We have diagnosticInformationMap.generated.ts and its diagnosticMessages.json source, but there doesn't seem to be any build step that produces the former from the latter, nor does there seem to be any file in the repo for the generator source.\n\nThe generator should be checked in, the build process fixed to invoke it, and diagnosticInformationMap.generated.ts should be added to .gitignore and removed from the index.\n\nIt's possible that I'm overlooking something here.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/3549/comments",
    "author": "ghost",
    "comments": [
      {
        "user": "ghost",
        "created_at": "2015-06-18T17:25:26Z",
        "body": "> It's possible that I'm overlooking something here.\n\nIn fact, I was.  (Was grepping only through ./src instead of project-wide.)\n\nThe generator is processDiagnosticMessages.ts, invoked by Jakefile.js.\n"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2015-06-18T17:27:43Z",
        "body": "To clarify for others, the command you're interested in is\n\n``` Shell\njake generate-diagnostics\n```\n"
      }
    ]
  },
  {
    "number": 3522,
    "title": "Inline classes not supported",
    "created_at": "2015-06-16T16:50:03Z",
    "closed_at": "2015-06-16T17:12:09Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/3522",
    "body": "```\nfunction ident(x) { return x; }\n\nvar Foo = ident(class Foo {})\n```\n\nThrows:\n\n```\nerror TS9003: 'class' expressions are not currently supported.\n```\n\nI believe that is a valid ES6 syntax, and it should work.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/3522/comments",
    "author": "mhevery",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2015-06-16T16:57:20Z",
        "body": "We are adding the support for class expressions currently. class expressions should be fully supported in 1.6.\n"
      },
      {
        "user": "danquirk",
        "created_at": "2015-06-16T17:12:09Z",
        "body": "#497 is the main source of discussion\n"
      }
    ]
  },
  {
    "number": 3505,
    "title": "Mixins and the applyMixins function?",
    "created_at": "2015-06-13T19:03:02Z",
    "closed_at": "2015-07-14T17:56:12Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/3505",
    "body": "Hi,\n\nSince the compiler can distinguish between a class being used as an interface, what is the reason the compiler does not automatically emit \"applyMixins\" at the end of the compilation cycle? It there a particular reason for this? \n\nRegards,\nGevik.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/3505/comments",
    "author": "blendsdk",
    "comments": [
      {
        "user": "danquirk",
        "created_at": "2015-06-15T16:34:56Z",
        "body": "Are you asking why the current behavior is this?\n\n``` ts\nclass Foo { \n   doStuff() { return 'hi'; }\n}\nclass Bar implements Foo { // error here, but should automatically mixin doStuff?\n}\n```\n"
      },
      {
        "user": "benliddicott",
        "created_at": "2015-07-14T17:32:21Z",
        "body": "I think the question is, why can't we do this:\n\n```\nclass Foo { \n   doStuff() { return 'hi'; }\n}\n class Yung { \n   doStuff2() { return 'hi'; }\n}\n// FAILS\nclass Bar extends Foo, Yung { // error here, but should automatically mixin doStuff?\n}\n```\n\nCurrently we do:\n\n```\n// SUCCEEDS\n```\n\n   class Bar extends Foo implements Yung { \n        constructor(){super();}\n    }\n    applyMixins(Bar, [Yung]);\n\nI think @blendsdk is asking why you can't extend two classes, and the compiler emit the `applyMixins` call automatically, to implicitly turn the FAILS example into the SUCCEEDS example.\n"
      },
      {
        "user": "danquirk",
        "created_at": "2015-07-14T17:56:12Z",
        "body": "Because the type system is structural the `extends` and `implements` clauses are generally best thought of as statements of intent and a desire to have the compiler validate you have done what you intended.\n\nAt this point changing the behavior of these statements would be an enormous breaking change so it's not something we'd do without new syntax of some sort.\n"
      },
      {
        "user": "benliddicott",
        "created_at": "2015-07-14T20:35:03Z",
        "body": "@danquirk thanks for the note. I get changing the behaviour of `implements` would be a breaking change. But allowing multiple `extends` with different semantics for the second onwards, would not, since these are currently syntax errors. (Actually I am not advocating this, I am advocating #3854 as a different route to the same goal. I just picked this issue up while looking for related issues. I am just trying to clarify what I take to be the OP's point.)\n"
      }
    ]
  },
  {
    "number": 3479,
    "title": "Generic function overloading in TS 1.4+, dummy declaration needed?",
    "created_at": "2015-06-11T14:53:19Z",
    "closed_at": "2015-06-12T23:57:04Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/3479",
    "body": "I'm trying to understand why the following code doesn't compile with TS 1.4+:\n\n``` typescript\ninterface ITest<A> {\n}\n\nfunction test(): ITest<void>;\nfunction test<A>(a?: A): ITest<A> {\n    return <any>{};\n}\nvar t = test<string>();\n```\n\nBut this one compiles fine:\n\n``` typescript\ninterface ITest<A> {\n}\n\nfunction test(): ITest<void>;\nfunction test<A>(a?: A): ITest<A>; // ADDED THIS DUMMY LINE\nfunction test<A>(a?: A): ITest<A> {\n    return <any>{};\n}\nvar t = test<string>();\n```\n\nIs this a feature or a bug?\n\nThanks,\nPeter\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/3479/comments",
    "author": "ziriax",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2015-06-11T20:04:31Z",
        "body": "This is a common source of error. the function implementation is not included in the signatures of the functions when there are more than one. \n\nso:\n\n``` ts\n// only one overload\nfunction a(): void;\nfunction a(...args: any[]): void {\n\n}\n```\n"
      }
    ]
  },
  {
    "number": 3428,
    "title": "What it type `[[string, number]]` vs `[string, number][]`",
    "created_at": "2015-06-08T21:59:20Z",
    "closed_at": "2015-06-08T22:06:05Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/3428",
    "body": "```\nvar items: [[string, number]];\nfor (let item of items) { // item: [string, number]\n   let name = item[0];  // name: string\n   let quantity = item[1]; // quantity: number\n}\n```\n\n```\nvar items: [string, number][];\nfor (let item of items) { // item: [string, number]\n   let name = item[0];  // name: string\n   let quantity = item[1]; // quantity: number\n}\n```\n\nThey look the same but can't assign to each other:\n\n```\nvar a: [[string, number]];\nvar b: [string, number][];\na = b.map(c => c); // Error: Type '[string, number][]' is not assignable to type '[[string, number]]'.  Property '0' is missing in type '[string, number][]'\na = b.map(c => [c[0], c[1]]); // Error: Type '(string | number)[][]' is not assignable to type '[[string, number]]'. Property '0' is missing in type '(string | number)[][]'\nb = a.map(c => c); // OK\nb = a.map(c => [c[0], c[1]]); // Error: Type '(string | number)[][]' is not assignable to type '[[string, number]]'. Type '(string | number)[]' is not assignable to type '[string, number]'. Property '0' is missing in type '(string | number)[]'\n```\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/3428/comments",
    "author": "unional",
    "comments": [
      {
        "user": "DanielRosenwasser",
        "created_at": "2015-06-08T22:06:01Z",
        "body": "`[[string, number]]` is a single-element tuple where the element has the type `[string, number]`.\n\n`[string, number][]` is an array of `[string, number]` tuples.\n\n@unional, I think questions such as these would be better fit for either StackOverflow or our Gitter room.\n"
      },
      {
        "user": "unional",
        "created_at": "2015-06-08T22:09:26Z",
        "body": "Thanks. Didn't know gitter room exist. Will move questions like these over there.\n"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2015-06-08T22:26:45Z",
        "body": "No worries - we only recently got the Gitter room so it's easy to miss.\n"
      }
    ]
  },
  {
    "number": 3422,
    "title": "Config to compile `const enum` as `enum` in development / Get SyntaxKind during development",
    "created_at": "2015-06-08T18:30:20Z",
    "closed_at": "2015-06-08T18:54:04Z",
    "labels": [
      "By Design",
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/3422",
    "body": "Hi,\n\nWhen I work on the code, I have to change `SyntaxKind` from `const enum` to `enum` so that I can do `write(`kind: ${SyntaxKind[node.kind]}`)`.\n\nIs there a way to config the compiler and jake to treat `const enum` as `enum` so this would work?\nOr is there another way to get the SyntaxKind without doing `SyntaxKind[node.kind]`?\n\nThanks,\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/3422/comments",
    "author": "unional",
    "comments": [
      {
        "user": "DanielRosenwasser",
        "created_at": "2015-06-08T18:54:04Z",
        "body": "You can keep the mapping at runtime with `--preserveConstEnum` for debugging purposes, but this behavior is the point of const enums.\n"
      },
      {
        "user": "unional",
        "created_at": "2015-06-08T20:59:50Z",
        "body": "jake already passes `--preserveConstEnums` to tsc.js, but it still fails compilation:\n\n`error TS2476: A const enum member can only be accessed using a string literal`\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2015-06-08T23:43:44Z",
        "body": "these exist only for debugging purposes. if you really want to do that cast to any. `(<any>ts).SyntaxKind[node.kind]`\n"
      },
      {
        "user": "unional",
        "created_at": "2015-06-09T00:33:19Z",
        "body": "great! That's exactly what I'm doing. Just to write out stuffs to understand about the node for debug purposes.\n\n`(<any>ts).SyntaxKind[node.kind]` works because `(<any>ts)` suppress all type checks?\n\nThanks a lot!\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2015-06-09T04:24:57Z",
        "body": "yes.\n"
      }
    ]
  },
  {
    "number": 3416,
    "title": "modules import failed",
    "created_at": "2015-06-08T12:56:03Z",
    "closed_at": "2015-08-10T23:06:55Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/3416",
    "body": "I've got next linking issue:\nsever.ts:\n/// <reference path='./_server.ts' />\nimport restify = require('restify');\nimport mongodb = require('mongodb');\nimport debug = require('debug');\nimport utils = require('utils/utils');\nimport routz = require('routes/routes');\n\nexport module Backends {\n\n```\n  class Backend {\n    public server:any;\n\n    private dbUtils:utils.DbUtils;\n\n    constructor() {\n        debug.log(\"starting server\");\n        this.startServer();\n\n        debug.log(\"init mongo\");\n        this.initDb();\n\n        debug.log(\"init routes\");\n        this.initRoutes();\n\n    }\n\n    startServer():void {\n        this.server = restify.createServer();\n        this.server.use(restify.bodyParser());\n        this.server.listen('8080', ()=> {\n            debug.log('listening port: 8080');\n        })\n    }\n\n    initRoutes():void {\n        var rts:routz.routes.Routes = new routz.routes.Routes(this.server,this.dbUtils);\n    }\n```\n\n...\n\n/routes/routes.ts:\n\n/// <reference path='../../server/_server.ts' />\n\nimport utils = require('../utils/utils');\nimport userRoutes = require('./userRoutes');\n\nexport module routes {\nexport class Routes {\n\n```\n/**\n * Initialize all application routes\n * @param app\n */\nconstructor(app:any,dto: utils.DbUtils) {\n    var userRoutes = new userRoutes.UserRoutes(app,dto);\n}\n```\n\n}\n\n}\n\n_server.ts\n\n/// <reference path='../bower_components/DefinitelyTyped/restify/restify.d.ts'/>\n/// <reference path='../bower_components/DefinitelyTyped/mongodb/mongodb.d.ts'/>\n/// <reference path='../bower_components/DefinitelyTyped/debug/debug.d.ts'/>\n/// <reference path='../bower_components/DefinitelyTyped/node/node.d.ts'/>\n\n/// <reference path='../server/routes/routes.ts'/>\n\n/// <reference path='../server/utils/utils.ts'/>\n\n/// <reference path='../server/routes/userRoutes.ts'/>\n\n/// <reference path='../server/dto/usersDTO.ts'/>\n\n/// <reference path='../server/server.ts' />\n\neverything compiles fine, when starting nodejs I've got next issue:\n\n[15:52:26] Error: Cannot find module 'routes/routes'\n    at Function.Module._resolveFilename (module.js:336:15)\n    at Function.Module._load (module.js:278:25)\n    at Module.require (module.js:365:17)\n    at require (module.js:384:17)\n    at Object.<anonymous> (/Users/mdomarev/workspace/singularex/angular-typescript-gulp-seed/dist/server.js:88:13)\n    at Module._compile (module.js:460:26)\n    at Object.Module._extensions..js (module.js:478:10)\n    at Module.load (module.js:355:32)\n    at Function.Module._load (module.js:310:12)\n    at Module.require (module.js:365:17)\n    at require (module.js:384:17)\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/3416/comments",
    "author": "sneerin",
    "comments": [
      {
        "user": "sneerin",
        "created_at": "2015-06-08T13:00:53Z",
        "body": "I used require('./routes/routes') and  require('routes/routes') not of them helped.\nts version 1.4.1, \n\ncompilining with next options \nfunction compileServerScripts() {\n    var tsProject = $.typescript.createProject({\n        target: 'ES5',\n        module: 'commonjs',\n        inlineSourceMap:true,\n        inlineSources:true,\n        separateCompilation:false,\n        declarationFiles: true,\n        noExternalResolve: false,\n        sortOutput: true\n    });\n    var opt = {\n        tsProject: tsProject,\n        inPath: ['server/**/*.ts', '/typings/**/*.ts'],\n        outDefPath: '.tmp/definitions/server',\n        outJsPath: '.tmp/js/server',\n        outJsFile: 'server.js'\n    }\n    return compileTS(opt);\n}\n"
      },
      {
        "user": "danquirk",
        "created_at": "2015-06-08T22:29:00Z",
        "body": "This seems better suited to StackOverflow unless you think this is likely a compiler bug.\n"
      },
      {
        "user": "sneerin",
        "created_at": "2015-06-09T10:32:36Z",
        "body": "if it is compiled it should work fine, am I wrong, but after compilation It's failed to start because of require issue. That's what compiler should handle I think. \n"
      },
      {
        "user": "mhegazy",
        "created_at": "2015-06-09T20:02:25Z",
        "body": "looks like node is trying to find a module \"routes/routes\", is it in your node_modules?\nif you have an empty .js file with only `var r = require(\"routes/routes\");` does it work if you run it with node?\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2015-08-10T23:06:54Z",
        "body": "Looks like the original issue has been answered. please reactivate if you are running into other issues.\n"
      }
    ]
  },
  {
    "number": 3413,
    "title": "Import `export =` using `import X from \"Y\"` syntax",
    "created_at": "2015-06-08T08:46:30Z",
    "closed_at": "2015-06-08T17:37:04Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/3413",
    "body": "*\\* Y.ts **\n\n``` ts\nvar Y = { a: 1}\nexport = Y\n```\n\n*\\* A.ts **\n\n``` ts\nimport X from \"Y\"\n```\n\nWould it work or I need to import it using `import X = require(\"Y\")`?\nVisual Studio Code underline `X` as error saying `Module 'Y' has no default export.`\n\nThanks,\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/3413/comments",
    "author": "unional",
    "comments": [
      {
        "user": "zhongsp",
        "created_at": "2015-06-08T13:23:43Z",
        "body": "> A module that uses `export =` to export a non-module entity in place of the module itself must be imported using the existing `import x = require(\"foo\")` syntax as is the case today.\n\nSo, one way is to modify A.ts:\n\n``` ts\nimport X = require(\"Y\");\n```\n\nAnother way, as the error msg suggest, modify Y.ts:\n\n``` ts\nvar Y = { a: 1 };\nexport { Y as default };\n```\n"
      },
      {
        "user": "ahejlsberg",
        "created_at": "2015-06-08T17:36:48Z",
        "body": "Unless you're interfacing with existing CommonJS or AMD modules, I would avoid the `export =` construct. Instead, use the new module constructs introduced in ES6:\n\n``` typescript\n// ------ y.ys ------\nexport default { a: 1 };\n\n// ------ a.ts ------\nimport x from \"./y\";\nconsole.log(x.a);\n```\n"
      }
    ]
  },
  {
    "number": 3405,
    "title": "Cannot find module during runtests",
    "created_at": "2015-06-07T07:06:16Z",
    "closed_at": "2015-06-08T20:36:30Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/3405",
    "body": "Put these two files under tests/cases/compiler, and run `jake runtests tests=Blade`\n\n**BladeMaterial.ts**\n\n``` ts\n//@module: amd\n\n/**\n * The base blade material class.\n */\nexport default class BladeMaterial {\n    stiffness: number\n    hardness: number\n    constructor(public name: string) {\n    }\n}\n```\n\n**BladeCompositeMaterial.ts**\n\n``` ts\n//@module: amd\n\nimport BladeMaterial from \"BladeMaterial\";\n\n/**\n * Composite material for blade.\n */\nexport default class BladeCompositeMaterial extends BladeMaterial {\n    constructor(public name: string) {\n        super(name);\n    }\n}\n```\n\nThe **BladeCompositeMaterial.ts** fails with TS2307: Cannot find module 'BladeMaterial`.\n\nI tap into `program.getSourceFile` and add:\n\n``` ts\nconsole.log(`${fileName}, hasProperty(...) => ${hasProperty(filesByName, fileName)}, filesByName: ${filesByName[fileName]}`);\n```\n\ni.e.\n\n``` ts\n\nfunction getSourceFile(fileName: string) {\n    fileName = host.getCanonicalFileName(normalizeSlashes(fileName));\n    console.log(`${fileName}, hasProperty(...) => ${hasProperty(filesByName, fileName)}, filesByName: ${filesByName[fileName]}`);\n    return hasProperty(filesByName, fileName) ? filesByName[fileName] : undefined;\n}\n```\n\nthe output result of `jake runtests tests=Blade` shows the order of the file matters:\ntests/cases/compiler/bladematerial.ts, hasProperty(...) => true, filesByName: undefined\ntests/cases/compiler/bladematerial.d.ts, hasProperty(...) => true, filesByName: undefined\ntests/cases/bladematerial.ts, hasProperty(...) => true, filesByName: undefined\ntests/cases/bladematerial.d.ts, hasProperty(...) => true, filesByName: undefined\ntests/bladematerial.ts, hasProperty(...) => true, filesByName: undefined\ntests/bladematerial.d.ts, hasProperty(...) => true, filesByName: undefined\nbladematerial.ts, hasProperty(...) => true, filesByName: undefined\nbladematerial.d.ts, hasProperty(...) => true, filesByName: undefined\n\n  ․․․․․․․․․tests/cases/compiler/bladematerial.ts, hasProperty(...) => true, filesByName: [object Object]\ntests/cases/compiler/bladematerial.ts, hasProperty(...) => true, filesByName: [object Object]\ntests/cases/compiler/bladematerial.ts, hasProperty(...) => true, filesByName: [object Object]\n\nThe caller of `program.getSourceFile()` which creates this problem is in checker.ts: 882, in function `resolveExternalModuleName`: `sourceFile = forEach(supportedExtensions, extension => host.getSourceFile(fileName + extension));`\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/3405/comments",
    "author": "unional",
    "comments": [
      {
        "user": "DanielRosenwasser",
        "created_at": "2015-06-07T18:52:19Z",
        "body": "Tests in `compiler` and conformance` are independent of one another. If I recall correctly, you can make a multifile test in one file as so:\n\n``` TypeScript\n// @filename: BladeMaterial.ts\nexport function blah() {\n}\n\n// @filename: BladeCompositeMaterial\nimport { blah } from \"BladeMaterial\";\n```\n\nLet us know if that helps.\n"
      },
      {
        "user": "unional",
        "created_at": "2015-06-07T18:59:49Z",
        "body": "Yeah, I found that out after digging through the harness.ts, program.ts for a few hours. :(.\nIt may help others if CONTRIBUTING.md would mention that. :)\n"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2015-06-07T20:05:57Z",
        "body": "Sorry about that - that's a good suggestion, I'll fix it up in a bit.\n"
      },
      {
        "user": "danquirk",
        "created_at": "2015-06-08T20:27:34Z",
        "body": "Yeah we should probably put it in the wiki too.\n"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2015-06-08T20:36:29Z",
        "body": "Done in #3424.\n"
      }
    ]
  },
  {
    "number": 3398,
    "title": "Did `runtests` copy all test files to tests/cases/compiler/ folder?",
    "created_at": "2015-06-06T00:44:20Z",
    "closed_at": "2015-06-13T00:04:49Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/3398",
    "body": "I'm writing tests for my fork and notice the `currentSourceFile.filename` says my file is under `/tests/cases/compiler` instead of in the sub-folder I originally put it in.  I wouldn't figure it out in the jakefile.\n\nThe file I have was located in `tests/cases/compiler/extjs/TableTennis/Equipments/BladeMaterial.ts` and the `currentSourceFile.fileName` is `tests/cases/compiler/BladeMaterial.ts`.  The output file did go to `tests/baselines/local/BladeMaterial.ts`.\n\nThanks\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/3398/comments",
    "author": "unional",
    "comments": [
      {
        "user": "danquirk",
        "created_at": "2015-06-06T00:49:40Z",
        "body": "There's some stuff hardcoded assuming tests/cases/compiler doesn't have child folders (since it never has before). If you put your tests under tests/cases/conformance you'll probably see more what you expect. The relevant code is not in the Jakefile but in src/harness/compilerRunner.ts as that defines how the raw source files that are our tests are dynamically built up into the describe/it calls that mocha requires and how to check/baseline the results.\n"
      },
      {
        "user": "unional",
        "created_at": "2015-06-06T02:06:12Z",
        "body": "How do I run the code in conformance correctly? I move the test file there and I got call stack overflow.\n"
      },
      {
        "user": "unional",
        "created_at": "2015-06-06T02:12:18Z",
        "body": "btw, it does keep the path in the conformance folder.\n"
      },
      {
        "user": "unional",
        "created_at": "2015-06-07T17:52:54Z",
        "body": "When I put the files in conformance, the test runs but at the end it has an error in \"after all\" hook saying call stack overflow.\n"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2015-06-07T18:20:57Z",
        "body": "Are you using the `tests=blahblah` flag when running? I know this is something we've ran into as well but I don't know the details.\n"
      },
      {
        "user": "unional",
        "created_at": "2015-06-07T18:22:21Z",
        "body": "Yes.\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2015-06-13T00:04:49Z",
        "body": "This is already tracked by #3273\n"
      }
    ]
  },
  {
    "number": 3329,
    "title": "Function type error in union type",
    "created_at": "2015-06-01T19:31:47Z",
    "closed_at": "2015-06-01T19:36:54Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/3329",
    "body": "I have been having issues with union types when using a function type as the second type in the union.\n\nAccording to the TypeScript 1.4 Language Specification: (3.4 Union Types, page 29)\n- A | B is equivalent to B | A\n\nThe following example compiles correctly:\n\n``` typescript\nfunction test(x: (y) => boolean | boolean) {\n    //do something with x\n}\n```\n\nBut this one gives an error:\n\n``` typescript\nfunction test(x: boolean | (y) => boolean) {\n    //do something with x\n}\n```\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/3329/comments",
    "author": "joeskeen",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2015-06-01T19:36:20Z",
        "body": "The language in the spec is a specification of type system behavior, not grammar.\n\nYou can fix this with parens:\n\n``` ts\nfunction test2(x: boolean | ((y) => boolean)) {\n    //do something with x\n}\n```\n"
      },
      {
        "user": "joeskeen",
        "created_at": "2015-06-01T19:36:42Z",
        "body": "Perfect, thanks\n"
      },
      {
        "user": "btesser-r7",
        "created_at": "2016-03-04T17:58:27Z",
        "body": "```\nfunction test(x: (y) => boolean | boolean) {\n    //do something with x\n}\n```\n\nlooks like what you are trying to accomplish is this:\n\n```\nfunction test(x: (y) => (boolean | boolean)) {\n    //do something with x\n}\n```\n"
      }
    ]
  },
  {
    "number": 3318,
    "title": "How can I debug compilation?",
    "created_at": "2015-05-31T13:31:13Z",
    "closed_at": "2015-06-01T10:02:03Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/3318",
    "body": "This is less an issue but a request for advice. I try to change the way code for namespaces is emitted.\n\nCurrently the typescript code\n\n```\nnamespace A{\n    var x = 42;\n}\n```\n\nis  emitted as\n\n```\nvar A;\n(function (A) {\n    var x = 42;\n})(A || (A = {}));\n```\n\nwhich I want to change to be emitted as\n\n```\n    var A_x = 42;\n```\n\nObviously, all references to x also need to become A_x .\n\nI walkted through emitter.ts and declarationEmitter.ts but without being able to stepping through the compilation with a debugger it is hard to fully understand the pieces. So my question:\n\n How can I debug compilation ?\n Hints on my namespace hack are also appreciated.     \n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/3318/comments",
    "author": "urbanhop",
    "comments": [
      {
        "user": "DanielRosenwasser",
        "created_at": "2015-06-01T06:02:58Z",
        "body": "If you're on Windows with a program that can use the script debugging interface (e.g. Visual Studio), you can use cscript with with `/X` flag to signal that it should stop on the first statement.\n\nIf you want to make it faster, use the Chakra engine using something like the flag `/E:{16d51579-a30b-4c8b-a276-0ff4dc41e755}`.\n\nIf you don't have that privilege, you can use `node-inspector` and run the compiler with `node --debug-brk build/local/tsc.js`.\n\nAs a word of caution, if you're intending on sending this out as a PR, I don't think we're inclined to accept something like that (or at least, we'd need a proposal to consider first). If it's for your own personal purposes, I fully encourage you to learn about the compiler and experiment. I'd look into `emitIdentifier` in `emitter.ts`.\n"
      },
      {
        "user": "urbanhop",
        "created_at": "2015-06-01T10:02:03Z",
        "body": "Thank you so much Daniel, this was very helpful. \n\nNo PR indended, pure private hack for some very specific reasons.\n"
      }
    ]
  },
  {
    "number": 3290,
    "title": "Map,Set ... in ES5 target",
    "created_at": "2015-05-28T08:52:59Z",
    "closed_at": "2015-05-28T17:49:17Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/3290",
    "body": "After update the typescript compiler from version 1.4.1 to 1.5.0 beta, the source code included in my project became to make error log such as 'Map is not found'.\nThus, I researched this problem, and I reached an conclusion. The lib.d.ts became not to contain Map and Set definitions except ES6 being selected in tsconfig.json.\n\nActually, Map and Set is specification of ES6. It is natural that we can't use Map and Set in the project targeting ES5 or lower.\nBut we could use Map and Set even if I select ES5 as the target before typescript 1.4.1.\nI know that making it being enabled to use Map and Set in the project that is made for ES5 contains risk.\nBecause there is some of browsers not supporting Map and Set.\n\nHowever, I think it is better to make some of property of configuration that is for switching to use these definitions or not. Don't you think so?\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/3290/comments",
    "author": "kyasbal",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2015-05-28T17:42:24Z",
        "body": "@LimeStreem we removed some IE-specific types from the library in 1.5.0-beta. you can just define the type in one of your files like:\n\n``` ts\ninterface Map<K, V> {\n    clear(): void;\n    delete(key: K): boolean;\n    forEach(callbackfn: (value: V, index: K, map: Map<K, V>) => void, thisArg?: any): void;\n    get(key: K): V;\n    has(key: K): boolean;\n    set(key: K, value: V): Map<K, V>;\n    size: number;\n}\ndeclare var Map: {\n    new <K, V>(): Map<K, V>;\n    prototype: Map<any, any>;\n}\ninterface Set<T> {\n    add(value: T): Set<T>;\n    clear(): void;\n    delete(value: T): boolean;\n    forEach(callbackfn: (value: T, index: T, set: Set<T>) => void, thisArg?: any): void;\n    has(value: T): boolean;\n    size: number;\n}\ndeclare var Set: {\n    new <T>(): Set<T>;\n    prototype: Set<any>;\n}\n```\n"
      },
      {
        "user": "kyasbal",
        "created_at": "2015-05-28T17:49:17Z",
        "body": "Wow, I appreciate you to write this code snippet! :laughing: \nI wonder this issue will help a lot of typescript users!\n"
      },
      {
        "user": "nin-jin",
        "created_at": "2017-06-27T09:57:39Z",
        "body": "```\r\ndeclare class WeakMap< Key , Value > {\r\n\tdelete( key : Key ) : boolean\r\n\tget( key : Key ) : Value\r\n\thas( key : Key ) : boolean\r\n\tset( key : Key , value : Value ) : Map< Key , Value >\r\n}\r\n\r\ndeclare class Map< Key , Value > {\r\n\tclear(): void\r\n\tdelete( key : Key ) : boolean\r\n\tforEach< Context = any >( handler : ( this : Context , value : Value , key : Key , map : Map< Key , Value > ) => void , context? : Context ) : void\r\n\tget( key : Key ) : Value\r\n\thas( key : Key ) : boolean\r\n\tset( key : Key , value : Value ) : Map< Key , Value >\r\n\tsize : number\r\n}\r\n\r\ndeclare class Set< Value > {\r\n\tadd( value : Value ) : Set< Value >\r\n\tclear() : void\r\n\tdelete( value : Value ) : boolean\r\n\tforEach< Context = any >( handler : ( this : Context , value : Value , key : Value , map : Set< Value > ) => void , context? : Context ) : void\r\n\thas( value : Value ) : boolean\r\n\tsize : number\r\n}\r\n```"
      }
    ]
  },
  {
    "number": 3243,
    "title": "vs plugin, 1.5beta regression: can not extend from class in external import",
    "created_at": "2015-05-21T13:29:24Z",
    "closed_at": "2015-05-21T17:44:52Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/3243",
    "body": "this works in older versions.\n\nwhen I have the following code in 1.5beta:\n\n```\nimport refs = require(\"../refs\");\nvar xlib = refs.xlib;\n\nexport class PjscBe extends xlib.ClassBase{}\n```\n\nI get the following error:\n`265  Cannot find name 'xlib'.`\n\nthis issue goes away if I remove the extends.  I can use my external module in other ways just fine:\n`var log = new xlib.diagnostics.logging.Logger(__filename);`\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/3243/comments",
    "author": "jasonswearingen",
    "comments": [
      {
        "user": "ahejlsberg",
        "created_at": "2015-05-21T16:14:11Z",
        "body": "Which older versions does it work in? Anyway, looks to me like the issue is that you're attempting to reference a variable (`xlib`) in a type name (`xlib.ClassBase`), which isn't possible. It should work if you change the declaration of `xlib` to be an `import`:\n\n``` typescript\nimport refs = require(\"../refs\");\nimport xlib = refs.xlib;\n\nexport class PjscBe extends xlib.ClassBase {}\n```\n\nThis will enable `xlib` to be used in both value and type positions.\n"
      },
      {
        "user": "jasonswearingen",
        "created_at": "2015-05-21T17:44:52Z",
        "body": "I'm pretty sure this was working in the 1.4 vs plugin, but it might have been in 1.3.\n\nthank you for the solution Anders, `import xlib = refs.xlib;` works.  I did not know you could `import` without the `require` syntax.\n"
      }
    ]
  },
  {
    "number": 3240,
    "title": "Be able to check the type of a generic",
    "created_at": "2015-05-21T00:20:52Z",
    "closed_at": "2015-06-12T22:54:49Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/3240",
    "body": "Let's say I have the following class\n\n``` typescript\nclass Foo<A>\n```\n\nNow let's say in a function, we want to take action depending if `A` is `number`, for example.  Is there any way we can check the value of the generic?\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/3240/comments",
    "author": "bluong",
    "comments": [
      {
        "user": "danquirk",
        "created_at": "2015-05-21T00:43:43Z",
        "body": "You will need to check on some property of the type which uses A since that's the only thing that will actually exist at runtime.\n\n``` ts\nclass Foo<A> {\n    constructor(public bar: A) { }\n    doStuff() {\n        if (typeof this.bar === \"number\") {\n            // ...   \n        } else if (typeof this.bar === \"string\") {\n            // ...\n        }   \n    }\n}\n```\n"
      }
    ]
  },
  {
    "number": 3213,
    "title": "Access to static fields via constructor property",
    "created_at": "2015-05-19T10:57:45Z",
    "closed_at": "2015-06-08T03:12:15Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/3213",
    "body": "This is example of correct code, though compiler raises an error `Property 'bar' does not exist on type 'Function'.`\n\n``` typescript\nclass A {\n    static bar(): void {\n        alert(\"Oh hi!\");\n    }\n\n    foo(): void {\n        this.constructor.bar(); //<-- compiler error\n    }\n}\n```\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/3213/comments",
    "author": "dvoyni",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2015-05-21T22:03:01Z",
        "body": "pinging @rbuckton for this one. the main reason is that constructor is not guaranteed to be set to the right thing all the time; consider an ambient class from a .d.ts modeling an existing js class implementation.\n"
      },
      {
        "user": "rbuckton",
        "created_at": "2015-05-21T22:15:01Z",
        "body": "Consider the following:\n\n``` ts\nclass A {\n    static x() { return 1; }\n    y() {\n        let z = this.constructor.x(); // z: string;\n        console.log(typeof z);\n    }\n}\n\nclass B extends A {\n    static x() { return undefined; }\n}\n\nclass C extends B {\n    static x() { return \"text\"; }\n}\n\nlet a = new A();\na.y(); // prints: \"number\";\nlet b = new B();\nb.y(); // prints: \"undefined\";\nlet c = new C();\nc.y(); // prints: \"string\";\n```\n\nIf we made `constructor` have the type `typeof A` here, a derived type could return something unexpected.\n"
      },
      {
        "user": "dvoyni",
        "created_at": "2015-05-22T02:32:07Z",
        "body": "Got it. Thank you.\n\nI've found this workaround:\n\n``` typescript\nclass A {\n    static bar(): void {\n        alert(\"Oh hi!\");\n    }\n\n    foo(): void {\n        (<AStatic>this.constructor).bar();\n    }\n}\n\nnew A().foo();\n\ninterface AStatic {\n    new (): A\n    bar(): void\n}\n```\n\nIs there any simpler solution?\n"
      },
      {
        "user": "oxyflour",
        "created_at": "2015-06-08T03:09:54Z",
        "body": "Hi, I just found that using <typeof A> instead of <AStatic> is ok : )\n\n``` typescript\nclass A {\n    static bar(): void {\n        alert('hello')\n    }\n    foo(): void {\n        (<typeof A> this.constructor).bar()\n    }\n}\n\nnew A().foo()\n```\n"
      },
      {
        "user": "dvoyni",
        "created_at": "2015-06-08T03:12:15Z",
        "body": "Wow, that's very nice! Thanks\n"
      }
    ]
  },
  {
    "number": 3193,
    "title": "type-safe cast",
    "created_at": "2015-05-18T00:24:07Z",
    "closed_at": "2015-05-18T02:58:09Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/3193",
    "body": "There doesn't seem to be a safe cast in Typescript. (&lt;T&gt; x) does no dynamic check. This is a very common need and is provided in every other optionally and gradually typed language I know of. What is needed is something like:\n\n```\nfunction cast<T>(x: any): T {\n    if (x instanceof T) return x;\n    throw new Error('type cast exception');\n}\n```\n\nexcept that doesn't compile. Is there an alternative solution I'm missing?\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/3193/comments",
    "author": "JonathanMEdwards",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2015-05-18T02:58:09Z",
        "body": "``` ts\nfunction cast<T>(instance: T, ctor: { new(...args: any[]): T }): T {\n    if (instance instanceof ctor) return instance;\n    throw new Error('type cast exception');\n}\n```\n\nThe reason there's no built-in operation for this is that it's not possible at runtime to detect many things (for example, `(x: number) => any` and `(x: string) => any` are indistinguishable from a runtime perspective).\n"
      },
      {
        "user": "JonathanMEdwards",
        "created_at": "2015-05-18T03:27:11Z",
        "body": "I think you're just saying that instanceof is broken on primitives in JavaScript. But why can't we have a cast operation that is consistent with the semantics of instanceof? Which would work as expected on classes.\n"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2015-05-18T03:31:36Z",
        "body": "Can you post an example of how you'd want that to work? `instanceof` is already a qualifying operation for a type guard (e.g. if you have `var x: Giraffe|Elephant`, `if(x instanceof Giraffe) { x.longNeck(); }` works)\n"
      },
      {
        "user": "JonathanMEdwards",
        "created_at": "2015-05-18T03:45:32Z",
        "body": "Like I said:\n\n```\nfunction cast<T>(x: any): T {\n    if (x instanceof T) return x;\n    throw new Error('type cast exception');\n}\n```\n\nI find I keep repeating that boilerplate which mimics a \"normal\" safe cast operation.\n"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2015-05-18T03:48:34Z",
        "body": "For example, let's say you wrote the following:\n\n``` ts\ninterface Foo {\n  (x: string): void;\n}\n\nvar j: any = whatever;\nvar x = cast<Foo>(j);\n```\n\n``` ts\n/* write the JavaScript you would expect to be emitted here */\n```\n\nThe `cast` function _that can exist_ is the one I wrote above -- you have to specify the constructor function, but the types work as expected and the runtime behavior is correct.\n"
      },
      {
        "user": "JonathanMEdwards",
        "created_at": "2015-05-18T11:55:01Z",
        "body": "OK. I'd expect that to be an error, but that certainly would be annoying for a supposed cast expression.\nHow does your suggestion work? This doesn't:\n\n```\nfunction cast<T>(instance: T, ctor: { new(...args: any[]): T }): T {\n    if (instance instanceof ctor) return instance;\n    throw new Error('type cast exception');\n}\nclass A {\n    foo: number;\n}\nvar x: A | number = new A();\nvar y:A = cast<A>(x, A);\n```\n\ntest.ts(9,19): error TS2345: Argument of type 'number | A' is not assignable to parameter of type 'A'.\n  Type 'number' is not assignable to type 'A'.\n"
      },
      {
        "user": "duanyao",
        "created_at": "2015-05-18T16:25:59Z",
        "body": "This works:\n\n``` javascript\nfunction cast<T>(instance, ctor: { new(...args: any[]): T }): T { // instance should be \"any\"\n    if (instance instanceof ctor) return instance;\n    throw new Error('type cast exception');\n}\nclass A {\n    foo: number;\n}\nvar x: A | number = new A();\nvar y = cast(x, A); // type param is not required\n```\n"
      },
      {
        "user": "JonathanMEdwards",
        "created_at": "2015-05-18T22:43:55Z",
        "body": "Thanks @duanyao that's exactly what I was looking for!\n"
      }
    ]
  },
  {
    "number": 3154,
    "title": "Unable to install wrapper function from parameter decorator",
    "created_at": "2015-05-13T18:50:06Z",
    "closed_at": "2015-06-13T00:02:00Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/3154",
    "body": "While attempting to create a decorator for checking if a parameter is `null` and throwing, I found that the code emitted is overwriting the wrapper function I'm installing.\n\n``` ts\nfunction throwIfNull(target: any, key: string, index: number) {\n    let original = target[key];\n    return function () {\n        if (arguments[index] === null) {\n            throw new TypeError(`Argument #${index} must be defined and not null`);\n        }\n        original.apply(this, arguments);\n    };\n}\n\nclass Foo {\n    bar(@throwIfNull baz?: any) {\n        console.log('here');\n    }\n}\n\nvar foo = new Foo();\nfoo.bar(null);\n```\n\nThe emitted JavaScript (ES5) is:\n\n``` js\nvar __decorate = this.__decorate || function (decorators, target, key, desc) {\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") return Reflect.decorate(decorators, target, key, desc);\n    switch (arguments.length) {\n        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);\n        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);\n        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);\n    }\n};\nvar __param = this.__param || function(index, decorator) { return function (target, key) { decorator(target, key, index); } };\nfunction throwIfNull(target, key, index) {\n    var original = target[key];\n    return function () {\n        if (arguments[index] === null) {\n            throw new TypeError(\"Argument #\" + index + \" must be defined and not null\");\n        }\n        original.apply(this, arguments);\n    };\n}\nvar Foo = (function () {\n    function Foo() {\n    }\n    Foo.prototype.bar = function (baz) {\n        console.log('here');\n    };\n    Object.defineProperty(Foo.prototype, \"bar\",\n        __decorate([\n            __param(0, throwIfNull)\n        ], Foo.prototype, \"bar\", Object.getOwnPropertyDescriptor(Foo.prototype, \"bar\")));\n    return Foo;\n})();\nvar foo = new Foo();\nfoo.bar(null);\n```\n\nThe problem stems from `__decorate` returning the original property descriptor because the function returned by `__param` doesn't return anything. This causes the original property descriptor to be installed back onto `Foo.prototype`.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/3154/comments",
    "author": "bryanforbes",
    "comments": [
      {
        "user": "edhager",
        "created_at": "2015-05-13T19:04:35Z",
        "body": "If function created by __param is modified to return the value returned by decorate(), then that value will have to be a property descriptor; not just a function.  @bryanforbes' decorator above would have to change to something like this:\n\n``` javascript\nfunction throwIfNull(target: any, key: string, index: number) {\n    let original = target[key];\n    var property = Object.getOwnPropertyDescriptor(proto, key);\n    property.value = function () {\n        if (arguments[index] === null) {\n            throw new TypeError(`Argument #${index} must be defined and not null`);\n        }\n        original.apply(this, arguments);\n    };\n    return property;\n}\n```\n\nI am wondering if that is the intent of parameter decorators?\n"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2015-05-14T01:40:05Z",
        "body": "While I _think_ I'm seeing the issue, I don't want to misspeak; I think @rbuckton might be better served to answer this.\n"
      },
      {
        "user": "rbuckton",
        "created_at": "2015-05-14T02:17:31Z",
        "body": "Parameter decorators are not able to change the target. If you want to be able to change the target, you have to use a method decorator instead.\n\n``` ts\nclass Foo {\n  @validate\n  bar(@throwIfNull baz) {}\n}\n```\n\nHere, throwIfNull would be a marker that writes some kind of metadata, and validate would wrap the method.\n"
      },
      {
        "user": "bryanforbes",
        "created_at": "2015-05-14T02:40:18Z",
        "body": "So parameter decorators are only for \"markers\" or metadata, but the other three types of decorators can be used to dynamically inject functionality?\n"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2015-05-23T03:55:59Z",
        "body": "@bryanforbes I believe this is the case, though can @mhegazy or @rbuckton confirm?\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2015-05-25T22:19:40Z",
        "body": "Here are the four decorator types:\n\n``` ts\ntype ClassDecorator = <TFunction extends Function>(target: TFunction) => TFunction | void;\ntype PropertyDecorator = (target: Object, propertyKey: string | symbol) => void;\ntype MethodDecorator = <T>(target: Object, propertyKey: string | symbol, descriptor: TypedPropertyDescriptor<T>) => TypedPropertyDescriptor<T> | void;\ntype ParameterDecorator = (target: Object, propertyKey: string | symbol, parameterIndex: number) => void;\n```\n\nClass decorators, and method decorators are the ones that can return a value, and hence change the behavior. the property and parameter ones do not get to return anything.\n"
      }
    ]
  },
  {
    "number": 3120,
    "title": "Do not emit helper function declarations on compilation",
    "created_at": "2015-05-11T21:51:40Z",
    "closed_at": "2015-05-11T21:53:45Z",
    "labels": [
      "Duplicate",
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/3120",
    "body": "Is it possible to prohibit TS to emit helper function declarations (e.g. _extend, _decorate) into every compiled file?\n\nI have a setup, when we storm is compiling every TS file separately and I end up with many isolated helper function declarations. Thanks.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/3120/comments",
    "author": "tomitrescak",
    "comments": [
      {
        "user": "danquirk",
        "created_at": "2015-05-11T21:53:45Z",
        "body": "See #1350\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2015-05-19T06:58:43Z",
        "body": "In next release 1.5.2, you can use `--noEmitHelpers` to suppress emitting all hetpers.\n\nbtw. it is already in master\n"
      }
    ]
  },
  {
    "number": 3053,
    "title": "Cannot use `typeof` on an empty module",
    "created_at": "2015-05-06T12:34:37Z",
    "closed_at": "2015-08-10T23:06:04Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/3053",
    "body": "Hi, \n\nTS: 1.4/1.5\n\nIn the following, the compiler issues an error on the last line:\n\n``` typescript\nmodule foo {\n\n    export module bar {\n        export class F { }\n    }\n\n    export module empty {\n    }\n}\n\nvar x: typeof foo.bar; // okay\nvar y: typeof foo.empty; // Property empty does not exist on type 'typeof foo'\n```\n\nThis has turned out to be a problem for the case when a module is defined across multiple files. For certain references the module will be empty, as it is initialised in a different context.\n\nWhy do we have no error for `bar` but an error for `empty`?\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/3053/comments",
    "author": "NoelAbrahams",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2015-05-06T15:29:08Z",
        "body": "This is the difference between an _instantiated_ module (one that has at least one value, or executable code, in it) and an _uninstantiated_ module (which only has types or other uninstantiated modules in it).\n\nIt's meaningless to say `typeof empty` because there is no value named `empty`. At the point that you get this error, `typeof empty`, if it existed, would be `{}`, so you should write that instead.\n\nIf you want to make `empty` instantiated for some workaround reason, you can place a `var dummy;` in it to force it to be instantiated.\n\n> This has turned out to be a problem for the case when a module is defined across multiple files\n\nCan you clarify this? If the compiler can't see those other files, it's meaningless to write `typeof empty`; if it can, you shouldn't get this error.\n"
      },
      {
        "user": "NoelAbrahams",
        "created_at": "2015-05-06T15:51:09Z",
        "body": "@RyanCavanaugh,\n\nThe use case is to capture the shape of an existing module and to ensure that we get a compilation error if the shape of the original module changes:\n\n``` typescript\n// Original\nmodule foo {\n    export module empty {\n    }\n}\n\n// Copy\ninterface Copy {\n    foo: {\n       empty: typeof foo.empty;\n   }\n}\n\n```\n\n> At the point that you get this error, typeof empty, if it existed, would be {}, so you should write that instead\n\nThat's a rather strange argument. What if someone were to add a type to the empty module at a later stage? We'd have to go change all the references.\n\nI took a look at #420, but wasn't certain that would cover the case. In any case to the naked eye this looks like a bug.\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2015-08-10T23:06:04Z",
        "body": "looks like #420 would address the underlying issue. \n"
      }
    ]
  },
  {
    "number": 3021,
    "title": "Getting \"Maximum call stack size exceeded\" when using \"getDocumentHighlights\" with reference paths and modules in 1.5.0-beta",
    "created_at": "2015-05-04T17:29:01Z",
    "closed_at": "2015-05-05T17:07:59Z",
    "labels": [
      "Question",
      "Fixed"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/3021",
    "body": "If I have code that looks something like this: \n\n``` typescript\n/// <reference path=\"nounreachable.test.ts\" />\n\nmodule S {\n  var template = '';\n}\n```\n\nand I try to do getDocumentHighlights on \"template\" in just that one file, I get a \"Maximum call stack size exceeded\" error. Am I doing something wrong? Or can you guys fix this, please? Thanks!\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/3021/comments",
    "author": "gscshoyru",
    "comments": [
      {
        "user": "DanielRosenwasser",
        "created_at": "2015-05-04T17:52:09Z",
        "body": "Hey @gscshoyru, is the definition file required to reproduce this error?\n"
      },
      {
        "user": "gscshoyru",
        "created_at": "2015-05-04T17:54:14Z",
        "body": "The definition file isn't necessary, it's just the existence of a reference path that causes the bug. It's the combination of the module and the reference path that does it for some reason, if you don't have have one or the other the bug doesn't happen. \n"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2015-05-04T17:57:43Z",
        "body": "Got it, I'll try to look into it as soon as I get in.\n"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2015-05-04T18:52:48Z",
        "body": "Not able to repro - can you supply both a call stack and the original call that's triggering it? What set of parameters are you passing in when calling?\n"
      },
      {
        "user": "gscshoyru",
        "created_at": "2015-05-04T21:34:42Z",
        "body": "Ok, sorry, I apparently I copied the wrong thing since it was failing that way before. Now it's failing if there's a ../ in the reference path, like `/// <reference path=\"../nounreachable.test.ts\" />`. It may also have something to with how we're doing it, though, since we are creating our own language service host and whatnot -- I can add the code for that if it's necessary, and you still can't repro. \n"
      },
      {
        "user": "gscshoyru",
        "created_at": "2015-05-04T21:38:40Z",
        "body": "Actually, here:\n\n``` typescript\nmodule Lint {\n    export function createLanguageServiceHost(fileName: string, source: string) {\n        var host: ts.LanguageServiceHost = {\n            getScriptFileNames: () => [fileName],\n            getScriptVersion: () => \"1\",\n            getScriptSnapshot: () => {\n                return {\n                    getText: (start, end) => source.substring(start, end),\n                    getLength: () => source.length,\n                    getLineStartPositions: () => ts.computeLineStarts(source),\n                    getChangeRange: (oldSnapshot) => undefined\n                };\n            },\n            getCurrentDirectory: () => \"\",\n            getScriptIsOpen: () => true,\n            getCompilationSettings: () => Lint.createCompilerOptions(),\n            getDefaultLibFileName: () => \"lib.d.ts\",\n            log: (message) => { /* */ }\n        };\n\n        return host;\n    }\n}\n\nvar documentRegistry = ts.createDocumentRegistry();\nvar languageServiceHost = Lint.createLanguageServiceHost(\"file.ts\", sourceFile.getFullText());\nvar languageService = ts.createLanguageService(languageServiceHost, documentRegistry);\nlanguageService.getDocumentHighlights(\"file.ts\", position, [\"file.ts\"]);\n```\n\nThis is what we're doing (paraphrased a little) that's causing the issue. \n"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2015-05-04T22:05:59Z",
        "body": "Still not able to repro.\n\n> `ts.computeLineStarts(source)`\n\nDoesn't seem to be publicly exposed anymore, how are you doing this?\n\n> `Lint.createCompilerOptions()`\n\nNot sure what we get back from this, could be useful for the repro\n\n---\n\nHere's what I'm currently working with:\n\n``` TypeScript\n/// <reference path=\"built/local/typescript.d.ts\" />\n\nimport * as ts from \"typescript\"\n\nmodule Lint {\n    export function createLanguageServiceHost(fileName: string, source: string) {\n        var host: ts.LanguageServiceHost = {\n            getScriptFileNames: () => [fileName],\n            getScriptVersion: () => \"1\",\n            getScriptSnapshot: () => {\n                return {\n                    getText: (start, end) => source.substring(start, end),\n                    getLength: () => source.length,\n                    getLineStartPositions: () => (<any>ts).computeLineStarts(source),\n                    getChangeRange: (oldSnapshot) => undefined\n                };\n            },\n            getCurrentDirectory: () => \"\",\n            getScriptIsOpen: () => true,\n            getCompilationSettings: () => ({}),\n            getDefaultLibFileName: () => \"lib.d.ts\",\n            log: (message) => { /* */ }\n        };\n\n        return host;\n    }\n}\n\nvar sourceText = \"/// <reference path=\\\"../TypeScript3/foo.ts\\\" />\\n\\nmodule m {\\n    var s;\\n}\\n\";\n\nvar documentRegistry = ts.createDocumentRegistry();\nvar languageServiceHost = Lint.createLanguageServiceHost(\"boo.ts\", sourceText);\nvar languageService = ts.createLanguageService(languageServiceHost, documentRegistry);\n\nfor (var i = 0; i < sourceText.length; i++) {\n    console.log(JSON.stringify(languageService.getDocumentHighlights(\"boo.ts\", i, [\"boo.ts\"])));\n}\n```\n\nI'm asking for highlights at every position in the document and I'm still not running into any problems.\n"
      },
      {
        "user": "gscshoyru",
        "created_at": "2015-05-04T22:24:34Z",
        "body": "Sorry, create compiler options is just \n\n``` typescript\nexport function createCompilerOptions(): ts.CompilerOptions {\n        return {\n            target: ts.ScriptTarget.ES5\n        };\n    }\n```\n\nso shouldn't be anything special.\n\nYou're right that it doesn't blow up that way, but it does blow up if you do `/// <reference path=\\\"../foo.ts` instead. Not entirely sure why. \n\nIt also seems to blow up without reference paths if you have imports with the same problem, such as `import xyz = require(\"../xyz\");` instead of the reference path.\n"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2015-05-05T02:11:50Z",
        "body": "@gscshoyru the problem is that your `getScriptSnapshot` is not actually using its given parameters, nor is it trying to appropriately resolve the filename it is given.\n\n---\n\nEdit: Specifically, you're just returning the same source file as the root, so when requesting the file `../foo.ts`, you'll end up with the original file contents that have a reference comment asking for `../foo.ts` which is, relative to the original root, `../../foo.ts`.\n"
      },
      {
        "user": "ashwinr",
        "created_at": "2015-05-05T04:16:05Z",
        "body": "@DanielRosenwasser Thanks for the reply. Is there any way to ignore imports/references when calling this LS API (or other LS APIs in general)? TSLint doesn't actually need to resolve imports since it works on a file-by-file basis. Thanks again!\n"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2015-05-05T05:57:10Z",
        "body": "@ashwinr you should be able to just return an empty string if it's not one of the files you're interested in. Let us know how that works out.\n"
      },
      {
        "user": "vladima",
        "created_at": "2015-05-05T06:19:53Z",
        "body": "@ashwinr you can set `noResolve` to `true` in compilation options to tell compiler that it should not do any file resolutions except files that were provided explicitly\n"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2015-05-05T06:31:50Z",
        "body": "^^^ Do what Vlad said.\n"
      },
      {
        "user": "gscshoyru",
        "created_at": "2015-05-05T13:15:22Z",
        "body": "Looks like setting noResolve to true does the trick. Thanks ever so much, and sorry for the confusion! \n"
      }
    ]
  },
  {
    "number": 3005,
    "title": "Using ES6 type default library when targetting ES5 output",
    "created_at": "2015-05-02T11:08:10Z",
    "closed_at": "2015-08-10T23:21:36Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/3005",
    "body": "I'm building a project for 'modern' but not bleeding-edge browsers (IE >= 10, Chrome/Firefox from mid-last year onwards), this means targeting ES5 output since ES6 language features are incomplete. However I'm able to use many ES6 library features either via polyfills (Map, Set, Promise) or because browsers added support for them early on (eg. DataView is available in IE 10 and later).\n\nAt the moment the language and library targets in TSC are controlled by the same --target option, which makes this difficult, more so in TS 1.5.0-beta because a number of ES6 APIs that used to be in the lib.d.ts file (Map, DataView) are now only found in the ES6 library.\n\nSome possible solutions:\n- Always make ES6 type definitions available - leave it up to TSC users to determine what APIs they can target.\n- Put all the type definitions in the same file, but provide a way to annotate methods which are part of a given ES-version. eg. Rust allows annotations like `#[stable(feature = \"rust1\", since = \"1.0.0\")]` on a method to indicate which version of the library a method became available in. Compiler flags could then be used to allow or deny use of ES6 interfaces.\n- A simple compiler switch that specifies the library target, separately from the language/emit target.\n\nThoughts?\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/3005/comments",
    "author": "robertknight",
    "comments": [
      {
        "user": "DanielRosenwasser",
        "created_at": "2015-05-02T21:03:31Z",
        "body": "This is something I've suggested a few times to @mhegazy and @jonathandturner - right now we don't provide a good facility for this. \n\nRight now the easiest thing to do is to manually include the `lib.es6.d.ts` file within the compiler directory, or even just grab it from our repo and put it in your source; but I agree that it's pretty ad-hoc.\n\nIdeally, there would be a `.d.ts` file for your polyfill library, probably adapted for our es6 typings. Out of curiosity, what polyfill library do you use?\n"
      },
      {
        "user": "robertknight",
        "created_at": "2015-05-02T21:16:25Z",
        "body": "> Out of curiosity, what polyfill library do you use?\n\nI'm using es6-collections for Map and Set. For anything supported by IE >= 10 (eg. DataView) I'm not using anything. For Promise there are a long list of options and polyfills for that might not be needed much longer.\n"
      },
      {
        "user": "yortus",
        "created_at": "2015-05-03T01:04:52Z",
        "body": "This is relevant in node/iojs scenarios too, but is broader than just .d.ts support. ES6 feature support is patchy in V8, some things are available and some aren't. It would be great if TSC could somehow support finer target granularity not just with the .d.ts, but also with emit. For instance I must set target=ES5 for node, but would like to tell the compiler to use ES6 emit for already supported things.\n\nCase in point: I'm working with generators a lot at the moment and use a forked TSC that emits ES5 + generators (which are emitted just fine when targetting ES6).\n"
      },
      {
        "user": "Bobris",
        "created_at": "2015-07-15T22:25:03Z",
        "body": "This makes really big problem, as author of library which contains Promise polyfill I cannot define Promise myself or it will not be compilable in ES6 mode due to clash of Promise name or If I will not include it, it will not be compilable in ES5 mode. Referencing lib.es6.d.ts directly is also no go, as I cannot force my users to do same hack and reference my forked lib.es6.d.ts.\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2015-08-10T23:21:36Z",
        "body": "this is now tracked in #4168.\n"
      }
    ]
  },
  {
    "number": 2974,
    "title": "rooDir does not seems to work with JS files",
    "created_at": "2015-04-30T21:16:35Z",
    "closed_at": "2015-06-12T22:53:20Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/2974",
    "body": "I have following structure\n\n```\n└───src\n    ├───external\n    │   └───lib\n    └───App\n        ├───Class\n```\n\n`src/external/lib/` contains 2 files, `lib.js` and `lib.d.ts`.\nIn `src/App/Class/Class.ts` I am importing `../../external/lib/lib` and it works fine, but generates following structure:\n\n```\n└───dist\n    └───App\n        ├───Class\n```\n\nWith JS files in `dist/App/Class`. My config is:\n\n``` json\n{\n  \"compilerOptions\": {\n    \"module\": \"commonjs\",\n    \"sourceMap\": false,\n    \"target\": \"ES5\",\n    \"noImplicitAny\": true,\n    \"outDir\": \"./dist\",\n    \"rootDir\": \"./src\"\n  },\n  \"files\": [\n    \"src/main.ts\"\n  ]\n}\n```\n\nSo I thought what `rootDir` property should solve this problem and transfer entire structure to `dist` folder. Am I doing something wrong?\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/2974/comments",
    "author": "NekR",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2015-04-30T21:31:28Z",
        "body": "The compiler does not copy files. I would add a post build task to copy your dependencies into the output folder.\n\nThe issue `--rootDir` is solving is consistenlly identifiing the root of your files. with out the flag, it is the logest common path of all inputs, that means that something like:\n\n```\n└───src\n    └───App\n        ├───Class1\n        |    └───a.ts\n        ├───Class2\n              └───b.ts\n```\n\nthe output structure without `--rootDir` will look like:\n\n```\n└───dist\n        ├───Class1\n        |    └───a.js\n        ├───Class2\n              └───b.js\n```\n\nwith no way of making `App` show up. `--rootDir .\\src` will cause App to be generated.\n\n> Totally off topic, nice tree you have there, how dd generate that?\n"
      },
      {
        "user": "NekR",
        "created_at": "2015-04-30T21:44:03Z",
        "body": "@mhegazy Yep, I originally structured it in a way where external dependencies are living in separate top level folder and `src` folder contains same tree in `external` sub-folder with only `.d.ts` files, but it really feels uncomfortable to have such duplicated structure. So I thought `--rootDir` might resolve this, sorry if I misunderstood its intention.\n\n> Totally off topic, nice tree you have there, how dd generate that?\n\nWindows command `tree` made it for me. Actually it's not quite useful for big tree since it does not have level parameter :(\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2015-06-12T22:53:20Z",
        "body": "Looks like this is addresses. please reopen if there is missing information.\n"
      }
    ]
  },
  {
    "number": 2931,
    "title": "Compiler Conditionals",
    "created_at": "2015-04-27T17:18:01Z",
    "closed_at": "2015-04-27T19:36:08Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/2931",
    "body": "I'm currently using the tsconfig file in our project and I want to have two of them one that outputs es5 and one that outputs es6. Things are working great until I try and target es6 and run into the issue where I'm supplying a definition file for ES6-Promises.\n\n```\n[TsProject] Compiling Project Files...\n[TsProject] c:/Code/Exceptionless.JavaScript/node_modules/typescript/bin/lib.es6.d.ts(4727,11): error TS2300: Duplicate identifier 'Promise'.\n[TsProject] c:/Code/Exceptionless.JavaScript/node_modules/typescript/bin/lib.es6.d.ts(4812,13): error TS2300: Duplicate identifier 'Promise'.\n[TsProject] typings/es6-promise/es6-promise.d.ts(10,15): error TS2300: Duplicate identifier 'Promise'.\n[TsProject] typings/es6-promise/es6-promise.d.ts(40,16): error TS2300: Duplicate identifier 'Promise'.\n[TsProject] typings/es6-promise/es6-promise.d.ts(70,2): error TS1203: Export assignment cannot be used when targeting ECMAScript 6 or higher. Consider using 'export default' instead.\n[TsProject] Build completed with errors. Outputs generated.\n[12:17:44] Finished 'typescript' after 2.76 s\n```\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/2931/comments",
    "author": "niemyjski",
    "comments": [
      {
        "user": "niemyjski",
        "created_at": "2015-04-27T17:31:03Z",
        "body": "What would be the best way to get around this?\n"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2015-04-27T18:23:17Z",
        "body": "It sounds like you're using a polyfill for ES6 promises?\n\nOne fix would be to pass the `--noLib` compiler flag and manually specify the ES5-only `lib.es5.d.ts` file as a compilation input. That ensures you're not using any other ES6-only features.\n\nAlternatively, you could not include the ES6 polyfill .d.ts file in your ES6 build configuration.\n"
      },
      {
        "user": "niemyjski",
        "created_at": "2015-04-27T18:27:37Z",
        "body": "Yes, I need to use promises in es5 land and most people have them but I just wanted the definition file imported. But when my build targets es6 that definition already exists and hence the error. I need to conditionally exclude it based on my target. How would I do this from a tsconfig.json file?? This work around doesn't seem end user friendly / straightforward and would make build setups more complicated.\n"
      },
      {
        "user": "niemyjski",
        "created_at": "2015-04-27T18:28:19Z",
        "body": "I have no option to not include it as I'm putting it in my references.d.ts file and every typescript file references that file and it's required for es5 or I get a ton of errors.\n"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2015-04-27T18:47:20Z",
        "body": "Another option is to include a reference to the ES5 lib.d.ts file in your references.d.ts file. That way you have the same set of input files between both compilation targets.\n"
      },
      {
        "user": "niemyjski",
        "created_at": "2015-04-27T19:02:39Z",
        "body": "I don't want to do that because I want a fully targeted es6 build :(. \n"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2015-04-27T19:09:40Z",
        "body": "I don't understand how that's possible at the same time as wanting an ES5 build from the same codebase. Can you give some examples of constructs you want to compile one way in ES5 and another way in ES6 that _doesn't_ work with any of the suggested fixes?\n"
      },
      {
        "user": "niemyjski",
        "created_at": "2015-04-27T19:16:08Z",
        "body": "I have one set of files written in typescript. I want to target es5 and es6. The reason for this is because my library needs to be self contained and references an external es6 js library. In this scenario my es5 build will polyfil things but my es6 build won't (much smaller). So with this said when my build targets es5 via tsconfig.json I get a million errors saying No such promise definition but es6 target works. When I add the es6 promise definition to my references.ts file es5 build succeeds but my es6 build fails with duplicate def.\n"
      },
      {
        "user": "niemyjski",
        "created_at": "2015-04-27T19:26:23Z",
        "body": "I was assuming that since things are transpiled that I could have one target es6 and it would just use the es6 syntax but if I targeted es5 it would convert it to use the es5 compliant code. For example the of operator...\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2015-04-27T19:28:26Z",
        "body": "in your tsconfig for es5, include your promise .d.ts, in your tsconfig for es6 do not. would that work?\n"
      },
      {
        "user": "niemyjski",
        "created_at": "2015-04-27T19:36:08Z",
        "body": "That works!. Thank you.. Case of the mondays.\n"
      },
      {
        "user": "niemyjski",
        "created_at": "2015-04-27T19:50:04Z",
        "body": "This seems to work but broke other things like unit tests which haven't been updated to the new format.\n"
      }
    ]
  },
  {
    "number": 2912,
    "title": "Cannot cast to type after instanceof operator check",
    "created_at": "2015-04-24T20:20:27Z",
    "closed_at": "2016-02-20T00:38:54Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/2912",
    "body": "In below code, the line `var vaaa = <Aaa>v;` reports error: `error TS2352: Build: Neither type 'T' nor type 'Aaa' is assignable to the other.`. I should be able to even access Aaa members without case because of this guard check.\n\nIs this bug or I'm doing something against specification?\n\n``` ts\ninterface IHolder<T> {\n  base: T;\n  variant1: T;\n  variant2: T;\n}\nclass Holder<T> implements IHolder<T> {\n  base: T;\n  variant1: T;\n  variant2: T;\n}\n\nclass Aaa {\n  item: string;\n}\nclass Test {\n  someValue: IHolder<Aaa>;\n\n  constructor() {\n    this.someValue = new Holder<Aaa>();\n    this.aaa(this.someValue);\n  }\n\n  aaa<T>(vv: IHolder<T>): void {\n    var v = vv.base;\n\n    if (v instanceof Aaa) {\n      var vaaa = <Aaa>v;\n    }\n  }\n}\n```\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/2912/comments",
    "author": "wgebczyk",
    "comments": [
      {
        "user": "wgebczyk",
        "created_at": "2015-04-28T15:54:32Z",
        "body": "Can someone confirm bug or deny?\n"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2015-04-28T16:20:18Z",
        "body": "It's not a bug according to the spec -- we don't narrow variables of a generic type parameter type, so the `instanceof` check does nothing in terms of modifying the assignability of `v` inside the `if` block.\n"
      },
      {
        "user": "wgebczyk",
        "created_at": "2015-04-28T17:32:53Z",
        "body": "OK. I understand that in some cases the guard/if statement is meaningless.\nAs the language is young, could we get warning whenever such meaningless \"thing\" is spotted in sources? Writing IF usually express some assumptions and having kind compiler that reminds on silly code would be beneficial!\n"
      },
      {
        "user": "danquirk",
        "created_at": "2015-04-28T19:10:18Z",
        "body": "The problem is that there're a lot of valid uses of this code. To make it an error would break a lot of peoples' current codebases. \n"
      },
      {
        "user": "wgebczyk",
        "created_at": "2015-04-28T21:44:52Z",
        "body": "1. That's why I suggest to have warning.\n2. Can you tell me in my example with generics, that it might be valid?\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2016-02-20T00:38:53Z",
        "body": "as noted by @danquirk, a warring is not appropriate here. you need to constrain T:\n\n``` ts\n    aaa<T extends Aaa>(vv: IHolder<T>): void {\n        var t: T;\n        var a: Aaa;\n\n        a = t; // OK\n        t = a; // still not OK, T is Aaa but Aaa is not guaranteed to be T\n\n        (<Aaa>t) // OK, as T is assignable to Aaa\n    }\n```\n"
      }
    ]
  },
  {
    "number": 2908,
    "title": "Suggestion: Add a special key that would disable resolving files that are missing in file list passed to the compiler",
    "created_at": "2015-04-24T14:06:07Z",
    "closed_at": "2015-04-24T17:12:44Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/2908",
    "body": "Currently a compiler can be given one single file from where it can resolve all dependencies by looking at the file system. Most of the time it is a very convenient feature, but when I need to clearly separate one set of files from another I wish I could turn it off. So that unless a file is explicitly in the list passed to the compiler, I don't want it to be resolved.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/2908/comments",
    "author": "zpdDG4gta8XKpMCd",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2015-04-24T16:36:44Z",
        "body": "use `--noResolve`.\n"
      },
      {
        "user": "zpdDG4gta8XKpMCd",
        "created_at": "2015-04-24T17:12:48Z",
        "body": "Thanks!\n"
      }
    ]
  },
  {
    "number": 2906,
    "title": "Automatically resolve class dependency",
    "created_at": "2015-04-24T09:05:11Z",
    "closed_at": "2015-04-24T17:20:00Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/2906",
    "body": "For example two class in two files:\n`class A extends B{}`\n`class B{}`\nCompile with `tsc -t ES5 --out out.js A.ts B.ts`, generate js is:\n\n```\nvar __extends = this.__extends || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    __.prototype = b.prototype;\n    d.prototype = new __();\n};\nvar A = (function (_super) {\n    __extends(A, _super);\n    function A() {\n        _super.apply(this, arguments);\n    }\n    return A;\n})(B);\nvar B = (function () {\n    function B() {\n    }\n    return B;\n})();\n```\n\nThe code won't run since B is not defined when defining A.\nCan the compiler automatically resolve class dependency and place the generated B code before A?\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/2906/comments",
    "author": "J-F-Liu",
    "comments": [
      {
        "user": "vasa-c",
        "created_at": "2015-04-24T10:33:51Z",
        "body": "`/// <reference path=\"b.ts\" />`\nit should help\n"
      },
      {
        "user": "J-F-Liu",
        "created_at": "2015-04-24T10:58:19Z",
        "body": "It is tedious to specify reference for lots of files.\n"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2015-04-24T17:20:00Z",
        "body": "If you want to compile all the files in a directory, just use tsconfig.json.\n"
      }
    ]
  },
  {
    "number": 2904,
    "title": "Question: What's the quality requirement for `master`",
    "created_at": "2015-04-24T05:23:33Z",
    "closed_at": "2015-04-24T06:58:09Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/2904",
    "body": "Primarily : do you guys ever pull into master with failing tests?\n\nJust a friendly question :)\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/2904/comments",
    "author": "basarat",
    "comments": [
      {
        "user": "CyrusNajmabadi",
        "created_at": "2015-04-24T06:32:54Z",
        "body": "Not ever intentionally.  The last time i can remember it happening would be years ago.  Don't do this.  Thx :)\n"
      },
      {
        "user": "basarat",
        "created_at": "2015-04-24T06:58:09Z",
        "body": "Awesome :+1: \n"
      }
    ]
  },
  {
    "number": 2844,
    "title": "Duplicate identifier error in Visual Studio 2015 CTP",
    "created_at": "2015-04-21T07:36:34Z",
    "closed_at": "2015-04-22T13:12:59Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/2844",
    "body": "Hi\n\nI create the new \"typescript\" project.\nI generate the description file for the app.ts by `tsp --target es5 -d app.ts`\n\nI immediately receive the duplicate identifier error.\nI am not sure how to deal with this issue as I want to have both implementation and description files in my project.\n\nHere are the files `app.ts`\n\n``` javascript\nclass Greeter {\n    element: HTMLElement;\n    span: HTMLElement;\n    timerToken: number;\n\n    constructor(element: HTMLElement) {\n        this.element = element;\n        this.element.innerHTML += \"The time is: \";\n        this.span = document.createElement('span');\n        this.element.appendChild(this.span);\n        this.span.innerText = new Date().toUTCString();\n    }\n\n    start() {\n        this.timerToken = setInterval(() => this.span.innerHTML = new Date().toUTCString(), 500);\n    }\n\n    stop() {\n        clearTimeout(this.timerToken);\n    }\n\n}\n\nwindow.onload = () => {\n    var el = document.getElementById('content');\n    var greeter = new Greeter(el);\n    greeter.start();\n};\n```\n\nand `app.d.ts`\n\n``` javascript\ndeclare class Greeter {\n    element: HTMLElement;\n    span: HTMLElement;\n    timerToken: number;\n    constructor(element: HTMLElement);\n    start(): void;\n    stop(): void;\n}\n```\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/2844/comments",
    "author": "tomitrescak",
    "comments": [
      {
        "user": "DanielRosenwasser",
        "created_at": "2015-04-21T08:00:49Z",
        "body": "Do you mean that you're receiving duplicate identifier errors in VS when you have `app.ts` and `app.d.ts` (or another file that refers to `app.d.ts`) open at the same time?\n\nAlso could you be more specific with which duplicate identifier errors you're getting from underscore.d.ts?\n"
      },
      {
        "user": "tomitrescak",
        "created_at": "2015-04-21T11:47:19Z",
        "body": "I have both app.ts and app.d.ts in my project and I am receiving duplicate identifier error. Removing app.d.ts from the project seemed to help in a specific case.\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2015-04-21T16:37:50Z",
        "body": "both app.ts and app.d.ts define the same objects. so you will get the duplicate identifier errors. you only need one of them, and not both. your .ts expresses API shape and implementation, where as your .d.ts expresses your API shape only. so if you are coding against it, you can use either, but not both.\n\nI usually think of .js + .d.ts together as package (e.g. a .net dll) that you use .js portion for execution, and .d.ts portion for typechecking. but both are outputs.\n"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2015-04-21T23:19:59Z",
        "body": "@tomitrescak does this resolve your issues?\n"
      },
      {
        "user": "tomitrescak",
        "created_at": "2015-04-22T03:25:43Z",
        "body": "OK. The weird thing here is tha according to Typescript conventions I should always create d.t.s files and reserence them instead of the .ts files. This behaviour of Visual Studio makes this job a bit more difficult.\n"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2015-04-22T04:14:12Z",
        "body": "If you have a group of files part of a common project, I don't see any reason you shouldn't just reference the `.ts` file. The `.d.ts` is more useful to an external consumer.\n\nIf you're familiar with C/C++, think of a `.d.ts` as a header file that describes the interface to a linked library, which is the `.js` file here.\n"
      },
      {
        "user": "tomitrescak",
        "created_at": "2015-04-22T13:12:59Z",
        "body": "Thanks for your help.\n"
      }
    ]
  },
  {
    "number": 2833,
    "title": "Export default let/var not working",
    "created_at": "2015-04-20T06:30:30Z",
    "closed_at": "2015-04-20T18:09:56Z",
    "labels": [
      "By Design",
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/2833",
    "body": "Are default let/var supported in TS?\n\n``` typescript\nexport default let variable1 = \"string1\";\nexport default var variable2 = \"string2\";\n```\n\nRight now they just throw a compile error:\n\n```\nerror TS1005: ';' expected.\n```\n\nI'm currently using master for testing. And everything works by removing the `default` keyword.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/2833/comments",
    "author": "tinganho",
    "comments": [
      {
        "user": "tinganho",
        "created_at": "2015-04-20T06:51:32Z",
        "body": "FYI `export default const` also throws an error.\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2015-04-20T18:09:46Z",
        "body": "This is not supported by the ES6 module spec. only class and function declarations are allowed.\n\n``` ts\nlet variable1 = \"string\";\nexport default variable1;\n```\n"
      }
    ]
  },
  {
    "number": 2755,
    "title": "error TS6050: Unable to open file 'tsconfig.json'.",
    "created_at": "2015-04-14T02:03:54Z",
    "closed_at": "2015-04-14T02:50:22Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/2755",
    "body": "Why?\nI'm not giving reasons for this to happen:\n   1- Running on windows.\n   2- I've closed the tsconfig.json file.\n   2- The command is \"tsc\" under a folder that has the following tsconfig.json file:\n\n```\n{\n    \"files\": [\n        './js/**/*.ts',\n        './modules/**/*.ts'\n    ]\n}\n```\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/2755/comments",
    "author": "ladaltamirano",
    "comments": [
      {
        "user": "danquirk",
        "created_at": "2015-04-14T02:44:03Z",
        "body": "tsc config doesn't support globbing, does removing that fix the error?\n"
      },
      {
        "user": "ladaltamirano",
        "created_at": "2015-04-14T02:50:22Z",
        "body": "Yeap...\nHey, at least modify the error message! I thought the issue had to do with what it communicated! But it didn't!...\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2015-04-14T02:51:48Z",
        "body": " #2627 is tracking showing the errors .\n"
      },
      {
        "user": "luzianz",
        "created_at": "2015-05-31T01:23:59Z",
        "body": "valid json uses **double** quotes, not single.\n"
      }
    ]
  },
  {
    "number": 2712,
    "title": "Question about importing js file in typescript fashion",
    "created_at": "2015-04-10T17:52:58Z",
    "closed_at": "2015-04-10T19:26:19Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/2712",
    "body": "I am trying to import an existing javascript source file(not a 3rd party module) into my typescript file using `import ... = require()` syntax with no success. Could you please help me point out anything I did wrong in the following isolated example?\n\nadd.js\n\n``` javascript\nmodule.exports = function (n1, n2) {\n    return n1 + n2;\n};\n```\n\nadd.d.ts\n\n``` typescript\ndeclare module \"add\" {\n    function add(n1: number, n2: number): number;\n    export = add;\n}\n```\n\nmain.ts\n\n``` typescript\n/// <reference path='node.d.ts' />\n/// <reference path='add.d.ts' />\nimport add = require('./add');\nconsole.log(add(1, 2));\n```\n\nWhen I try to compile `main.ts`, I got the following error:\n\n```\nerror TS2306: File 'add.d.ts' is not an external module.\n```\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/2712/comments",
    "author": "ericlu88",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2015-04-10T18:16:02Z",
        "body": "Since you defclared add as an ambient module, in your consumtion file, main.ts do not use relative paths.\n\n``` ts\n/// <reference path='node.d.ts' />\n/// <reference path='add.d.ts' />\nimport add = require('add');\nconsole.log(add(1, 2));\n```\n"
      },
      {
        "user": "ericlu88",
        "created_at": "2015-04-10T18:21:33Z",
        "body": "@mhegazy This works with the compiler, but the generated js file will have `var add = require(add)`, which is incorrect module loading code for node. Node will error at runtime:\n\n```\nError: Cannot find module 'add'\n    at Function.Module._resolveFilename (module.js:336:15)\n    at Function.Module._load (module.js:278:25)\n    at Module.require (module.js:365:17)\n    at require (module.js:384:17)\n    at Object.<anonymous> (/Users/EricLu/Documents/Temp/main.js:3:11)\n    at Module._compile (module.js:460:26)\n    at Object.Module._extensions..js (module.js:478:10)\n    at Module.load (module.js:355:32)\n    at Function.Module._load (module.js:310:12)\n    at Function.Module.runMain (module.js:501:10)\n```\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2015-04-10T18:35:45Z",
        "body": "if you want to use relative path in the import, you will need:\n1. put the add.d.ts next to add.js\n2. define the file as an external module:\n\n```\n// add.d.ts\ndeclare function add(n1: number, n2: number): number;\nexport = add;\n```\n\ni.e. loose the \"declare module \"add\"\" part.\n\n#### more details:\n\nThere are two ways to define declarations for a .js module:\n\n1  using `declare module \"foo\"` and then you can have multiple module definitions in the same file:\n\n``` ts\n\n// mydefinitions.d.ts\ndeclare module \"mod1\" {\n    export var x = 0;\n}\n\ndeclare module \"mod2\" {\n    export var y = 0;\n}\n\ndeclare module \"mod3\" {\n    export var z = 0;\n}\n```\n\nand consuming them would have to be using absolute names:\n\n``` ts\n// main.ts\n\n/// <reference path=\"myDefintions.d.ts\" />\nimport * as mod1 from \"mod1\";\nimport mod2 = require(\"mod2\");\nimport {z} from \"mod3\";\n```\n\n2 alternatively you can define as a file, where the name of the file is the name of the module\n\n``` ts\n// myModule.d.ts\n\ndeclare var m = 0;\nexport = m;\n```\n\nand consume it as a normal .ts module:\n\n``` ts\nimport m = require(\"./myModule\");\nm.toString();\n```\n"
      },
      {
        "user": "ericlu88",
        "created_at": "2015-04-10T19:23:44Z",
        "body": "Cool, this works perfectly! Thanks a lot!\n"
      },
      {
        "user": "canmrt",
        "created_at": "2015-06-29T09:51:47Z",
        "body": "How can I import a javascript file which consists of several modules with a single d.ts file by using relative paths?\n\nExample:\n\n``` js\n// bundle.js\ndefine('alert/alert', [\n    'require',\n    'exports'\n], function (require, exports) {\n    var Alert = function () {\n        function Alert() {\n        }\n        Alert.prototype.alert = function (message) {\n            alert(message);\n        };\n        return Alert;\n    }();\n    exports.Alert = Alert;\n});\ndefine('log/log', [\n    'require',\n    'exports'\n], function (require, exports) {\n    var Log = function () {\n        function Log() {\n        }\n        Log.prototype.log = function (message) {\n            console.log(message);\n        };\n        return Log;\n    }();\n    exports.Log = Log;\n});\ndefine('bundle', [\n    'require',\n    'exports',\n    'alert/alert',\n    'log/log'\n], function (require, exports, alert_1, log_1) {\n    exports.Alert = alert_1.Alert;\n    exports.Log = log_1.Log;\n});\n```\n\n``` js\n// bundle.d.ts\ndeclare module 'alert/alert' {\n    export class Alert {\n        alert(message: string): void;\n    }\n\n}\ndeclare module 'log/log' {\n    export class Log {\n        log(message: string): void;\n    }\n\n}\ndeclare module 'bundle' {\n    import { Alert as _Alert } from 'alert/alert';\n    import { Log as _Log } from 'log/log';\n    export var Alert: typeof _Alert;\n    export var Log: typeof _Log;\n\n}\n```\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2015-06-29T18:43:49Z",
        "body": "@canmrt add a /// <reference to your bundle.d.ts and then import your modules by name. e.g.:\n\n``` ts\nimport { Log } from \"log/log\";\n```\n"
      },
      {
        "user": "canmrt",
        "created_at": "2015-06-30T09:19:40Z",
        "body": "@mhegazy this works nice, thanks a lot!\n"
      }
    ]
  },
  {
    "number": 2626,
    "title": "for of does not work for multi dimentional arrays",
    "created_at": "2015-04-06T04:03:06Z",
    "closed_at": "2015-04-06T04:04:45Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/2626",
    "body": "I would expect it to work: \n\n``` ts\nvar foo:any[][] = [];\nfor(var item of foo){\n    console.log(foo);\n}\n```\n\nBut it fails with `is not an array or string type`. \n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/2626/comments",
    "author": "basarat",
    "comments": [
      {
        "user": "basarat",
        "created_at": "2015-04-06T04:04:45Z",
        "body": "sorry it works. needed more :coffee: \n"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2015-04-06T17:36:07Z",
        "body": ":coffee: :coffee: :coffee: \n"
      }
    ]
  },
  {
    "number": 2609,
    "title": "Class decorator parameters",
    "created_at": "2015-04-03T19:57:28Z",
    "closed_at": "2015-04-08T22:57:28Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/2609",
    "body": "I'm fairly sure I have the syntax right:\n\n``` javascript\n@ClassDecoratorTest(\"Test\")\nclass Test\n{\n}\n\nfunction ClassDecorationTest(target, name)\n{\n}\n```\n\nBut this won't compile. I get the following error on the @ClassDecorator line:\n\nerror TS2346: Supplied parameters do not match any signature of call target.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/2609/comments",
    "author": "jamiewinder",
    "comments": [
      {
        "user": "ghost",
        "created_at": "2015-04-05T18:52:57Z",
        "body": "This code works. It will log \"Test\" to the console.\n\n``` typescript\n@ClassDecoratorTest(\"Test\")\nclass Test {\n}\n\nfunction ClassDecoratorTest(str) {\n    return function (target): void {\n        target['d_value'] = str;\n        return target;\n    }\n}\n\nconsole.log(Test['d_value']);\n```\n\nWhen passing arguments you have to return a function with the correct format. `tsc` helps you with it, if you provide a wrong signature, it will tell you what you've done wrong.\n"
      },
      {
        "user": "jamiewinder",
        "created_at": "2015-04-08T22:57:28Z",
        "body": "Perfect, thanks.\n"
      }
    ]
  },
  {
    "number": 2600,
    "title": "Debugging in a Windows 8 Store app?",
    "created_at": "2015-04-02T23:53:18Z",
    "closed_at": "2015-06-12T18:43:13Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/2600",
    "body": "Is it possible to debug (set breakpoints, step, etc.) in a Visual Studio 2012 Windows 8 Store app using TypeScript?  I can't get VS to recognize the breakpoints I set in my TypeScript files so I can't debug.  \n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/2600/comments",
    "author": "TradeArcher2020",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2015-04-06T19:42:17Z",
        "body": "It should be possible. it is possible that you are running into bugs as well. We have not looked at VS2012 in over a year now.\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2015-06-12T18:43:13Z",
        "body": "closing this issue for now, please reopen if there further details needed.\n"
      }
    ]
  },
  {
    "number": 2556,
    "title": "Differentiate between two type aliases.",
    "created_at": "2015-03-31T02:35:34Z",
    "closed_at": "2015-04-21T06:39:46Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/2556",
    "body": "Let's say I declared the following types\n\ntype Foo;\ntype FooGenerator = () => Foo;\ntype FooGeneratorGenerator = () => FooGenerator;\n\nIs there any way to differentiate between FooGenerator and FooGeneratorGenerator?  (If I were to replace Foo with string or so, I can make a differentiation between the first and the second one using typeof it seems, but I still cannot find a difference between the second and third forms)\n\nNote that my use case does have arguments inside the types, but I removed them for simplicity\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/2556/comments",
    "author": "bluong",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2015-03-31T03:36:50Z",
        "body": "I am not sure i understand the question.\n\n> type Foo;\n\nthis is syntactically invalid. you need a right hand-side for this alias declaration to be meaningful.\n\n> type FooGenerator = () => Foo;\n\nFooGenerator is a function that takes no arguments and returns a Foo\n\n> type FooGeneratorGenerator = () => FooGenerator;\n\nFooGeneratorGenerator  is a function that takes no arguments and returns a function.\n\nNot sure what you want to do here. can you explain the problem?\n"
      },
      {
        "user": "bluong",
        "created_at": "2015-03-31T05:28:51Z",
        "body": "> type Foo;\n\nI'm just using this to declare some arbitrary type.  If `Foo` was string, then this example would still be valid.\n\ntype StringGenerator = () => string;\ntype StringGeneratorGenerator = () => StringGenerator;\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2015-03-31T07:05:30Z",
        "body": "What do you mean by \" differentiate between FooGenerator and FooGeneratorGenerator?\" \n"
      },
      {
        "user": "basarat",
        "created_at": "2015-03-31T07:22:37Z",
        "body": "@bluong I think you are asking: \n\n``` ts\ntype Foo = any;\ntype FooGenerator = () => Foo;\ntype FooGeneratorGenerator = () => FooGenerator;\n\nvar foo: Foo;\nvar fooGenerator: FooGenerator; \nvar fooGeneratorGenerator: FooGeneratorGenerator;\n\n// Are they the same or different?\nfooGenerator = fooGeneratorGenerator = fooGenerator;\n```\n\nProvide a code sample that _doesn't work and should_ or _does work and shouldn't_. \n"
      },
      {
        "user": "danquirk",
        "created_at": "2015-03-31T18:49:40Z",
        "body": "As we have a structural type system the answer is no, you cannot differentiate based on the alias names if they're identical in structure. A more concrete example might be helpful to understand exactly what you're trying to do though, it's possible there's a better option.\n"
      }
    ]
  },
  {
    "number": 2544,
    "title": "Cannot find doc on tsc --in myfile.es6 --out myfile.js",
    "created_at": "2015-03-30T00:58:14Z",
    "closed_at": "2015-03-30T12:04:14Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/2544",
    "body": "I cannot find any comments on this anywhere on the internet.\n\nI prefer to name my es6 files something other than *.ts\n\nThanks,  Maybe some version in the future.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/2544/comments",
    "author": "ghost",
    "comments": [
      {
        "user": "DanielRosenwasser",
        "created_at": "2015-03-30T05:44:55Z",
        "body": "To clarify, are you asking about compiling files with a ~~`.js`~~ `.es6` extension? Our compiler currently doesn't support this. Is there any specific reason you feel averse to using the `.ts` extension? Are there any downsides to doing so?\n\n_Edited to reflect .es6 extension_\n"
      },
      {
        "user": "ghost",
        "created_at": "2015-03-30T06:46:54Z",
        "body": "I'm sorry,\n\nI want to name my files *.es6 (but the extension should be irrelevant).\n\nMaybe something like this:  tsc --in myfile.es6 --out myfile.js\n\nAs programs like typescript and babel mature they will complement each.  And as newer versions of ECMAscript come out I could use *.es7, *.es6 on the same line...\n\nBut I can always preprocess my files if I want to rename them.\n"
      },
      {
        "user": "ghost",
        "created_at": "2015-03-30T12:04:14Z",
        "body": "Thanks, that pretty much confirms what I was thinking.\n\nTypeScript works great, I'll be using it regularly.\n"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2015-03-30T19:23:59Z",
        "body": "Glad to hear it, hope it isn't too much trouble. We're very much committed to conforming closely to ES6 and as it becomes more concrete, ES7, so ideally you shouldn't ever need to feel concerned about which edition of ECMAScript since TypeScript will support it.\n"
      }
    ]
  },
  {
    "number": 2492,
    "title": "tsconfig.json purpose?",
    "created_at": "2015-03-25T19:00:57Z",
    "closed_at": "2015-03-25T19:28:46Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/2492",
    "body": "Question: tsconfig.json appears to be a reasonable way to specify a compilation context. Why isn't it available from the command line? ( tsc -c tsconfig.json ). I would like to be able to use tsconfig.json within a build system ( gulp based ) rather than it be a build system.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/2492/comments",
    "author": "ToddThomson",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2015-03-25T19:19:51Z",
        "body": "On the command line you can run:\n\n> tsc -p <Directory path of tsconfig.json>\n\nor just call tsc with no file arguments in a directory with tsconfig.json in it\n\n> tsc\n\nyou can configure your build systems to call tsc with -p. @ivogabe might be able to help you better here.\n"
      },
      {
        "user": "ToddThomson",
        "created_at": "2015-03-25T19:28:46Z",
        "body": "Thank-you.\nAnd thank-you to the team!\n"
      }
    ]
  },
  {
    "number": 2490,
    "title": "Question: top-level interface and ES6 \"export default AssignmentExpression\"",
    "created_at": "2015-03-25T15:57:50Z",
    "closed_at": "2015-03-26T09:21:03Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/2490",
    "body": "I see that this works in compiler built from recent sources:\n\n```\nexport default A;\ninterface A {}\n```\n\nAccording to the ES6 specification, after \"export default\" we only have three options:\n1) class declaration\n2) hoistable declaration (i.e., function or generator declaration)\n3) AssignmentExpression\n\nIf we treat \"A\" from my example as an AssignmentExpression, then it should work exactly the same way as AssignmentExpression in any other place, e.g. \"var x = A\".\n\nFor \"var x = A\" we reasonably have  'Cannot find name A'.\nBut in my example above, 'A' is resolved.\n\nIt means, that after 'export default' we have something different from an ordinary AssignmentExpression.\n\nAre there some special rules for what can appear after export default in the statement?\nDoes it have a special meaning in case of \"export default Identifier\"?\nThanks!\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/2490/comments",
    "author": "zhuravlikjb",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2015-03-25T17:25:22Z",
        "body": "Note: there are some additional changes to how export default and export = work that is not in master now. see #2460 for more details.\n\nIn the current implementation `export default Identifier` indicates exporting all meanings of the Identifier (value, type and namespace), that is the same behavior in `export = Identifier`.\n\nAt compile time the compiler will elide exports that do not have a value, and in the given example, interface A, the export default statement, and any imports to the default binding in other modules will not be written to your .js output.\n"
      },
      {
        "user": "zhuravlikjb",
        "created_at": "2015-03-26T09:10:25Z",
        "body": "Thanks a lot, now it's clear for me, and I see that #2460 is merged into master, so I'll see and try the new changes. You may close this question, thanks.\n"
      }
    ]
  },
  {
    "number": 2486,
    "title": "getNavigationBarItems for entire project",
    "created_at": "2015-03-25T09:30:21Z",
    "closed_at": "2015-03-25T23:47:30Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/2486",
    "body": "i.e for the entire program, not just a single file. Is there such a function already?\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/2486/comments",
    "author": "basarat",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2015-03-25T16:45:03Z",
        "body": "getNavigateToItems with no searchValue should give you something closer. this is what we use in VS for Ctrl+, to find named declarations throughout the project. \n\nif you want to show something like class hierarchy, or something a la VS progression view, then you need to add a new function that does something similar to getNavigateToItems more than getNaviagationBarItems. I think we would be interested in taking a feature like this in the LS interface, assuming this is what you have in mind.\n\nA distinction to make is that getNaviagationBarItems is purely syntactic and operates on a file level, if you want to do some sort of aggregation of global hierarchy, you want to do something along the lines of getNavigateToItems that would walk the global symbol table, and drill in from there.\n\nlet us know what you have in mind, also pinging @CyrusNajmabadi for this issue.\n"
      },
      {
        "user": "basarat",
        "created_at": "2015-03-25T20:54:36Z",
        "body": "Cool. NavigateToItems is probably what I was looking for. I'm not concerned about a global hierarchy ❤️\n"
      },
      {
        "user": "CyrusNajmabadi",
        "created_at": "2015-03-25T22:28:12Z",
        "body": "I'm not exactly sure what you're asking for.  Can you help explain what purpose this would serve?  How would this feature manifest itself to the user?\n\nThanks!\n"
      },
      {
        "user": "basarat",
        "created_at": "2015-03-26T02:20:34Z",
        "body": "> getNavigateToItems with no searchValue should give you something closer. \n\nIt give me an empty array : `[]`\n\n`var items = languageService.getNavigateToItems('');`\n"
      },
      {
        "user": "CyrusNajmabadi",
        "created_at": "2015-03-26T07:03:09Z",
        "body": "What are you trying to accomplish?  Thanks.\n"
      },
      {
        "user": "basarat",
        "created_at": "2015-03-26T07:08:03Z",
        "body": "conversation continued in #2500 \n"
      }
    ]
  },
  {
    "number": 2420,
    "title": "Unsupported file encoding",
    "created_at": "2015-03-19T00:46:40Z",
    "closed_at": "2015-03-19T00:53:46Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/2420",
    "body": "Hi, i have a typescript file which provide string translations for Italian in my solution, when i compile the solution, i got follow compile errors:\n\nSeverity    Code    Description Project File    Line\nError       Build: Cannot read file 'D:/workdir/devunits/song_cordova20150227_dev/src/cordova/scripts/app/I18N/it-IT/Strings.ts': Unsupported file encoding.\n\nEnv and Tools i used:\nVS2015 CTP5 (incl. TS 1.4), Cordova project.\n\nHere is the content of cordova/scripts/app/I18N/it-IT/Strings.ts: \n\n\"use strict\";\nexport var Strings = {\n    MsgMarkUpShareFailed: \"Impossibile condividere i markup in OneNote\",\n    Erase: \"Cancella\",\n    TextForSelectJTFolder: \"Selezionare la cartella JT suddivisa\",\n    Error_Printing: \"Errore durante la stampa del modello\",\n    SharedFileNotFoundExceptionMessage: \"Impossibile trovare il file richiesto in OneDrive. Verificare con gli utenti che condividono il file che siano state accordate le necessarie autorizzazioni.\",\n    Property_LastAuthor: \"Ultimo autore\",\n    OpenInJT2Go: \"Apri in JT2Go\",\n    ShowPMI: \"Mostra PMI\",\n    Share: \"Condividi\",\n    MsgBedDepth: \"La  profondità deve essere maggiore di 0.\",\n    Cancel: \"Annulla\",\n    Error_NonPositiveVolume: \"Stampa interrotta. Il modello non ha un volume positivo\",\n    Dimensions: \"Quote\",\n    DrillUp: \"Drill up\",\n    MsgBedHeight: \"L'altezza deve essere maggiore di 0.\",\n    Property: \"Proprietà\",\n    Note: \"Nota\",\n    MsgPLMXMLWasModified: \"Il markup è stato modificato e deve essere salvato. Salvarlo ora?\",\n    Loading: \"Caricamento\",\n    Created: \"creato\",\n    Property_Parts: \"Parti\",\n    OrientTo: \"Orienta verso\",\n    DrillDown: \"Drill down\",\n    Section: \"Sezione: \",\n    Samples: \"Campioni\",\n    Print: \"Stampa\",\n    Property_ProjectName: \"Nome progetto\",\n    AlignToView: \"Allinea a vista\",\n    TakeImage: \"Scegli immagine\",\n    ToLast: \"Vai all'ultimo\",\n    Property_Density: \"Densità\",\n    DFS: \"Simboli feature Datum\",\n    Default: \"Predefinita\",\n    MsgPLMXMLNotMatchJTError: \"Questo file plmxml non corrisponde al file jt attualmente aperto. Selezionare il file corretto e riportare.\",\n    MsgFailedCreateHomePage: \"Errore durante la creazione della pagina iniziale.\",\n    Snapshot: \"Istantanea\",\n    BedHeight: \"Altezza (mm)\",\n    PinToStart: \"Aggancia all'avvio\",\n    Property_Unit: \"Unità\",\n    PrintBedDepth: \"Profondità\",\n    SelectionColor: \"Finestra dei colori\",\n    Home: \"Pagina iniziale\",\n    Pan: \"Sposta\",\n    Text: \"Caricatore di testo\",\n    Property_DocumentNumber: \"Nr. documento\",\n    MsgBedWidth: \"Lo spessore deve essere maggiore di 0.\",\n    TextForSelectJT: \"Selezionare un file JT\",\n    Properties: \"Proprietà\",\n    DefaultMarkupItemDescription: \"Commenti senza titolo\",\n    Property_TranslationDate: \"Data conversione\",\n    FinishPrinting: \"Dati inviati alla stampante 3D\",\n    FCF: \"Fotogrammi controllo feature\",\n    Error_InvalidModel: \"Stampa interrotta. Il modello non è definito correttamente\",\n    Property_Company: \"Azienda\",\n    General: \"Generale\",\n    PMIFilters: \"Filtri PMI\",\n    MeasurementPoints: \"Punti di misurazione\",\n    Save: \"Salva\",\n    Open: \"Apri\",\n    ChooseImage: \"Scegli immagine\",\n    Property_NameOfSavingApplication: \"Nome dell'applicazione da salvare\",\n    BedWidth: \"Larghezza (mm)\",\n    Other: \"Altro\",\n    OneDriveLoadMarkupExceptionMessage: \"Errore durante l'apertura del markup da OneDrive\",\n    SettingLanguage: \"Lingua\",\n    DatumTargets: \"Destinazioni datum\",\n    SpotWelds: \"Punti di unione\",\n    StartPrinting: \"Stampa iniziata. L'operazione potrebbe richiedere alcuni minuti\",\n    HidePMI: \"Nascondi PMI\",\n    ShareToOneNote: \"Condividi in OneNote\",\n    Accept: \"Accetta\",\n    Less: \"Meno\",\n    More: \"Altro\",\n    Property_CADSource: \"Origine CAD\",\n    PMIPanelState: \"Selezionare i tipi PMI da visualizzare\",\n    SelectAll: \"Seleziona tutto\",\n    MsgGreaterThan: \"{0} deve essere maggiore di 0.\",\n    ToggleCamera: \"Attiva/Disattiva  videocamera\",\n    CollapseBar: \"Comprimi barra\",\n    Normal: \"Normale\",\n    DeleteView: \"Elimina vista\",\n    Error_NonManifold: \"Stampa interrotta. Il modello non è impermeabile\",\n    OneDriveAuthenticationExceptionMessage: \"Errore durante il caricamento del file richiesto perché le credenziali di autenticazione presentano un'anomalia per quanto riguarda la connessione a OneDrive.\",\n    LanguageTag: \"it-IT\",\n    Property_LastSaveDate: \"Data ultimo salvataggio\",\n    Property_TriangleCount: \"Numero di triangoli\",\n    AppDescription: \"Un'applicazione di rendering 3D per la visualizzazione di file di formato JT.\",\n    View: \"Vista\",\n    Property_Keywords: \"Parole chiave\",\n    LoadFile: \"Carica\",\n    EditDescription: \"Modifica descrizione\",\n    ShowAllPMI: \"Mostra tutte le informazioni PMI\",\n    BedDepth: \"Spessore (mm)\",\n    Delete: \"Elimina\",\n    Property_ApplicationName: \"Nome applicazione\",\n    FullScreen: \"Schermo intero\",\n    Error_LoadPart: \"Impossibile aprire il file JT specificato\",\n    ModelView: \"Vista modello\",\n    Fit: \"Adatta\",\n    SharingStatus: \"Condivisione\",\n    LoadingStatus: \"Caricamento\",\n    RestoreDefaults: \"Ripristina i default\",\n    ExceedPrintableAreaMessage: \"Il modello supera l'area stampabile\",\n    HideAllPMI: \"Nascondi tutte le informazioni PMI\",\n    Recent: \"Recente\",\n    TextForSelectImage: \"Seleziona un file di immagine\",\n    Error: \"Errore\",\n    Property_Geometry: \"Geometria\",\n    Locators: \"Localizzatori\",\n    OneDriveLoginExceptionMessage: \"Impossibile eseguire l'accesso a OneDrive\",\n    Property_Comments: \"Commenti\",\n    Property_Category: \"Categoria\",\n    Property_Attribute: \"Attributo\",\n    Settings: \"Impostazioni\",\n    Spin: \"Rotazione\",\n    Hide: \"Nascondi\",\n    Freehand: \"A mano libera\",\n    PrintBedWidth: \"Larghezza\",\n    Attribute: \"Attributo\",\n    Property_TranslatorVersion: \"Versione convertitore\",\n    Reset: \"Ripristina\",\n    Options: \"Opzioni\",\n    Surface: \"Superficie\",\n    BackgroundColor: \"Colore sfondo\",\n    ViewType: \"Visualizza tipo\",\n    Property_VertexCount: \"Numero di vertici\",\n    LoadFileExceptionMessage: \"Si è verificato un errore durante il caricamento del file.\",\n    Status_Pinned_Success: \"JT2Go è agganciato allo schermo iniziale\",\n    Property_Length: \"Lunghezza\",\n    FontFamily: \"Segoe UI\",\n    Property_Subject: \"Oggetto\",\n    PMIColor: \"Colore PMI\",\n    PartLoaderExceptionMessage: \"Si è verificato un errore durante il caricamento del file JT specificato.\",\n    Property_Author: \"Autore\",\n    MsgMarkUpShareSuccessed: \"Markup condivisi correttamente in OneNote\",\n    ClearAll: \"Cancella tutto\",\n    Property_OriginationDate: \"Data di origine\",\n    OneDriveConnectionExceptionMessage: \"Errore durante il caricamento del file richiesto causato dalla connessione OneDrive.\",\n    MsgExpectedNumber: \"{0} deve essere un numero.\",\n    Part: \"Parte\",\n    Status_Pinned_Failure: \"Errore durante l'aggancio di JT2GO alla schermata iniziale\",\n    LiveCamera: \"Videocamera live\",\n    Legal: \"Legale\",\n    Property_Name: \"Nome\",\n    Property_Width: \"Larghezza\",\n    Discard: \"Elimina\",\n    Decline: \"Calo\",\n    MsgFailedCreateLicensePage: \"Errore durante la creazione della pagina di licenze.\",\n    Geometry: \"Geometria\",\n    ShowAllParts: \"Mostra tutte le parti\",\n    Property_Material: \"Materiale\",\n    ToFirst: \"Vai al primo\",\n    ShatteredFolderIncorrectExceptionMessage: \"Si è verificato un problema durante il caricamento della cartella suddivisa. Verificare di aver selezionato la cartella esatta.\",\n    PrivacyPolicy: \"Criteri sulla privacy\",\n    PrintBedHeight: \"Altezza\",\n    Property_Title: \"Titolo\",\n    WaitingStatus: \"Attesa\",\n    Background: \"Sfondo\",\n    CoordinateSystems: \"Sistemi di coordinate\",\n    Property_Height: \"Altezza\",\n    Structure: \"Struttura\",\n    DefaultMarkupItemDescriptionWithUserName: \"Commenti di {0}\",\n    Default3DPrinter: \"Stampante 3D predefinita\",\n    Help: \"Guida\"\n}\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/2420/comments",
    "author": "franksoong",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2015-03-19T00:49:02Z",
        "body": "The compiler does not support ANSI encoding, which i am guessing the encoding for this file. so you need to save the file in Unicode, to do that, in VS go to file\\Advanced Save Options, select \"Unicode (UTF-8 with Signature)\" and hit ok. save your file and try again.\n"
      },
      {
        "user": "franksoong",
        "created_at": "2015-03-19T00:53:35Z",
        "body": "this fix my issue, much thanks for the tips!!\n"
      }
    ]
  },
  {
    "number": 2373,
    "title": "Passthrough require(\"jsfile\") for commonjs",
    "created_at": "2015-03-16T16:53:03Z",
    "closed_at": "2015-03-16T22:01:36Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/2373",
    "body": "Hello Typescipters,\n\nI'm using the `Q` library with its typings installed via `tsd`.\nIn a module I'm using\n\n``` typescript\n/// <reference path=\"../typings/q/Q.d.ts\"/>\n// ...\n```\n\ncompiled with\n\n``` bash\ntsc -m commonjs --out test.js test.ts\ntsc --version\nmessage TS6029: Version 1.4.1.0\n```\n\nand would like `test.js` to contain a line like\n\n``` javascript\nvar Q = require(\"path/to/q\"); // to be executed by nodejs\n```\n\nwhere `path/to/q` points to the javascript file and has nothing to do with `../typings/q/Q.d.ts`.\nUsing `import Q = require(\"path/to/q\");` won't work as it probably expects a typescript module.\n\n``` bash\nbuilder.ts(5,32): error TS2307: Cannot find external module './../bower_components/q/q'.\n```\n\nI haven't found how to achieve this without rolling out some hackish _ad-hoc_ source markup/parse/replace. Have I overlooked something?\n\nIn a way I'm trying to \"link\" to the library code (in the C meaning) with node's `require` after having included the declarations (references to the `d.ts`).\n\nIf this is not currently possible, may I suggest a pass-through version of `require()` which kicks in when `-m commonjs` is used? Perhaps `js_require(\"blabla\")` which would be emitted as node's `require(\"blabla\")`. This would make it a lot easier to leverage other tools which analyze `require` statements.\n\nGreetings\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/2373/comments",
    "author": "dbarbeau",
    "comments": [
      {
        "user": "DanielRosenwasser",
        "created_at": "2015-03-16T17:29:13Z",
        "body": "> Using `import Q = require(\"path/to/q\");` won't work as it probably expects a typescript module.\n\nThe `import` keyword with a `require(...)` on the RHS works the same way as if you'd used a `var` except that it also brings in type information at compile time. What you can do in `test.js` is include both the `/// <reference path=\"../typings/q/Q.d.ts\"/>` and then `import Q = require(\"path/to/q\");`. Give it a try and let us know. If not, maybe there's some information I'm missing.\n"
      },
      {
        "user": "dbarbeau",
        "created_at": "2015-03-16T18:02:20Z",
        "body": "Hi! And thanks!\nI think you meant using `var` instead of `import`, because\n\n``` typescript\n/// <reference path='typings/q/Q.d.ts'/>\nimport q = require(\"bower_components/q/q\");\nvar deferred = Q.Promise(function(a,b,c){});\n```\n\nthrows `error TS2307: Cannot find external module 'bower_components/q/q'` and no code is generated (the output file is blank) while\n\n``` typescript\n/// <reference path='typings/q/Q.d.ts'/>\nvar q = require(\"bower_components/q/q\");\nvar deferred = Q.Promise(function(a,b,c){});\n```\n\nthrows `error TS2304: Cannot find name 'require'` and... the compiler does output the code I want :)\nSo it does work, though user feedback is a bit misleading!\n\n**EDIT:** To remove the TS2304 error, I had to add a reference tag to `node.d.ts`. Changing `import` to `var` has some consequences!\n\nThanks again ;)\n"
      },
      {
        "user": "dbarbeau",
        "created_at": "2015-03-16T18:44:34Z",
        "body": "I should have done a few more tests, because there is a catch:\n\n``` typescript\n/// <reference path=\"typings/node/node.d.ts\"/>\n/// <reference path=\"typings/q/Q.d.ts\"/>\n\nvar Q            = require(\"./../bower_components/q/q\");   /* LINE X */\nimport path   = require(\"path\"); /* LINE Y */\n\nvar qprom = Q.Promise(function(a,b,c){\n    var dummy = path.join(__dirname, \"yo\");  /* LINE Z */\n});\n```\n\nThe reference tag will declare Q with the type information.\n**LINE X** will declare another Q.\n\nIf you compile it like this, tsc 1.4.1.0 will emit no error, but also no code :)\nRemove **LINE Y** and **LINE Z** and you'll get.\n\n``` bash\nrequiretest2.ts(4,5): error TS2300: Duplicate identifier 'Q'.\ntypings/q/Q.d.ts(10,18): error TS2300: Duplicate identifier 'Q'.\ntypings/q/Q.d.ts(14,18): error TS2300: Duplicate identifier 'Q'.\ntypings/q/Q.d.ts(16,16): error TS2300: Duplicate identifier 'Q'.\n```\n\nSeems reasonable enough, although the compiler does emit the code I want. \n\nNow, suppose that TS2300 didn't emit code (or that I simply want to avoid having errors in my code). I'd have to write my typescript code against the Q declared in the 'Q.d.ts' file, but this would conflict with the Q created on the `require(...)` line. So, I'd have to write `var smallq = require(...);` instead of **LINE X**, but then at runtime nodejs would complain that `Q` doesn't exist. Or I write against `smallq` and lose the benefit of types.\n\nI'm in a deadlock :)\n"
      },
      {
        "user": "danquirk",
        "created_at": "2015-03-16T20:13:13Z",
        "body": "You absolutely want to use `import` and not `var`. Without `import` there is no type information associated with the `Q` you declared. You also just want to require the name as `'q'` and not the relative path. The last 3 lines of Q.d.ts are written to enable this pattern, similar to why you can require `\"path\"` like that from node.d.ts. This is how it should look:\n\n``` ts\n/// <reference path=\"Q.d.ts\"/>\nimport Q = require('q');\n\nvar aprom = Q.Promise((a,b,c) => {\n    console.log('hi');\n});\n```\n\nemits:\n\n```\n> tsc a.ts -m commonjs\n> type a.js\n/// <reference path=\"Q.d.ts\"/>\nvar Q = require('q');\nvar aprom = Q.Promise(function (a, b, c) {\n    console.log('hi');\n});\n```\n"
      },
      {
        "user": "dbarbeau",
        "created_at": "2015-03-16T22:01:36Z",
        "body": "Thank you @DanielRosenwasser and @danquirk  for the clear instructions, I wasn't going the right way. Now, I just had one issue in that compiling that exact file (`a.ts`) with:\n\n``` bash\ntsc a.ts -m commonjs --out a.js\n```\n\n(notice the --out flag) produced an empty `a.js`, whereas just omitting the `--out a.js` flag worked. I'm a bit confused, I'll need to check my installation, there's something fishy. Regarding the initial question I think it has been answered so this issue is closed.\n\n### LAST MINUTE OMG\n\nThe `--out` doesn't do what I expected it to do!\n\n``` bash\n> rm *.js\n> tsc a.ts -m commonjs --out ahaha.js\n> ls -l\ntotal 8\n-rw-rw-r--. 1 d d 136 16 mars  22:51 a.js\n-rw-rw-r--. 1 d d 131 16 mars  22:40 a.ts\n-rw-rw-r--. 1 d d   0 16 mars  22:51 ahaha.js\n```\n\nI was NOT expecting `a.js`, I thought the output would just end up in `ahaha.js`. So by specifiying that flag, I was overwriting tsc's output with a blank file. But why is it blank?\nI'll need to check my basic assumptions of life (like does `gcc -o` behave like this?)... wow!\n\nThanks again!\nDaniel\n"
      },
      {
        "user": "danquirk",
        "created_at": "2015-03-16T23:02:46Z",
        "body": "You generally don't want to use --out with external modules like you have. The target file for --out only gets whatever is in the global namespace. This is good when you're concatenating multiple internal modules together but it doesn't support concatenating multiple files together into a single external module. So most of the time you'll get 1 js file per ts file and an empty file that you asked --out for. We have an issue logged somewhere around here to consider just making it an error if --out creates an empty file since other people also get confused by this behavior .\n"
      }
    ]
  },
  {
    "number": 2318,
    "title": "Cannot import property of external module",
    "created_at": "2015-03-12T16:29:34Z",
    "closed_at": "2015-03-24T17:18:10Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/2318",
    "body": "With internal modules, one can do this:\n\n``` typescript\nimport MyType = mymodule.MyType\n```\n\nWith external modules, this is a syntax error:\n\n``` typescript\nimport MyType = require('mymodule').MyType;\n```\n\nThe solution is a second import statement:\n\n``` typescript\nimport mymodule = require('mymodule');\nimport MyType = mymodule.MyType;\n```\n\nA suggestion would be to allow a `require(...)` call to be followed by dotted property access.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/2318/comments",
    "author": "sccolbert",
    "comments": [
      {
        "user": "danquirk",
        "created_at": "2015-03-12T18:53:28Z",
        "body": "I suspect the guidance here is going to be to make use of whichever style of ES6 module import is best for your scenario and we'll avoid adding much functionality to our original external module style/syntax (in order to encourage people to use ES6 style module syntax).\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2015-03-12T19:07:23Z",
        "body": "With the new syntax, your example would be:\n\n``` ts\nimport {MyType} from \"mymodule\";\n```\n"
      }
    ]
  },
  {
    "number": 2315,
    "title": "make operators available for extensions of Number",
    "created_at": "2015-03-12T12:48:18Z",
    "closed_at": "2015-03-12T14:18:41Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/2315",
    "body": "Hello, \n\nI recently tried to extends Number to various interfaces (such as int, char, float, double, ...)\nit works well until I try to apply operators on them: \n\n``` ts\ninterface int extends Number {}\nvar a: int = 1;\nvar b: int = 2;\nvar c: int = a+b; // -> error\n```\n\nI don't completely understand why this is not supported.\n\nThe purpose would be to use those type information in an clang-like compiler from typescript to native code.\n\nIs that a bug or not supported on purpose?\n\nThanks, \n\nRégis\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/2315/comments",
    "author": "JeWaVe",
    "comments": [
      {
        "user": "DickvdBrink",
        "created_at": "2015-03-12T13:00:37Z",
        "body": "You may want to use `type` in this case like below which I think should work correctly (and user lower case number in that case).\n\n```\ntype int = number;\nvar a: int = 1;\nvar b: int = 2;\nvar c: int = a+b;\n```\n"
      },
      {
        "user": "JeWaVe",
        "created_at": "2015-03-12T13:05:40Z",
        "body": "Thanks, \n\nis this instruction a typedef?\n\nWill \"a\" have the \"int\" type attached or only number?\n"
      },
      {
        "user": "DickvdBrink",
        "created_at": "2015-03-12T14:12:28Z",
        "body": "I believe it is called a `Type Aliases`. Effectively it just a copy with a different name and it is still a number;\n\nSo if you create a function which accepts a type alias called \"int\" it still accepts a number as it is actually the same thing.\n"
      },
      {
        "user": "JeWaVe",
        "created_at": "2015-03-12T14:18:36Z",
        "body": "That's not exactly what I'd need. \nI'd rather see int as a specialization of number, and therefore it would be a different type.\nbut it's probably enough for what I'd like to do.\nthanks!\n"
      }
    ]
  },
  {
    "number": 2288,
    "title": "Question: is it intended?",
    "created_at": "2015-03-10T21:31:12Z",
    "closed_at": "2015-03-10T21:46:05Z",
    "labels": [
      "By Design",
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/2288",
    "body": "``` typescript\nclass Company {\n    constructor(public name: string) {\n    }\n}\n\nclass Employee {\n    constructor(public name: string) {\n    }\n}\n\nvar array = new Array<Employee>();\narray.push(new Company('Google')); // No error or warning.\n```\n\nI made a similar error and I was surprised that the VS didn't even render a warning. I use TypeScript version 1.4. Are there any plans to deal with it, or is it going to stay this way?\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/2288/comments",
    "author": "Dzienny",
    "comments": [
      {
        "user": "danquirk",
        "created_at": "2015-03-10T21:46:05Z",
        "body": "This is by design. TypeScript uses structural typing to determine assignability. The name of a type is irrelevant, what matters is its shape. In this case your Company and Employee types are identical based on their shape, so they are assignable to one another. If they had a disjoint set of properties you would see the error you expect. This design is intended to enable common JavaScript/TypeScript patterns that mix named types (classes/interfaces) with unnamed types (object literals and function types).\n"
      },
      {
        "user": "Dzienny",
        "created_at": "2015-03-10T22:23:30Z",
        "body": "I see and I suppose, in this case, it would be possible to have both - ie enable common JavaScript/TypeScript patterns and warn a programmer when appropriate. In the example there are two Typescript classes that probably have a different meaning/purpose and the compiler could notice it. The programmer would have to add explicit cast to get rid of the warning, example:\n\n``` typescript\narray.push(<Employee>new Company('Google'));\n```\n"
      },
      {
        "user": "danquirk",
        "created_at": "2015-03-10T22:35:45Z",
        "body": "How does the compiler notice it? Only when the types are identical? Why should it be illegal to have 2 things that are shaped the same? What if they're not precisely identical?\n\n``` ts\ninterface Point {\n    x: number;\n    y: number\n}\n\ninterface Point3D {\n    x: number;\n    y: number;\n    z: number\n}\n\nvar arr: Array<Point>;\nvar p3: Point3D;\narr.push(p3); // error? by what logic?\n```\n\nYou can find a lot of discussion about this in #202\n"
      },
      {
        "user": "Dzienny",
        "created_at": "2015-03-11T00:13:17Z",
        "body": "In case of TypeScript classes the compiler could look at their shape first, and then look at their name and scope. Then if the shape is different, it would produce the standard error \"Type 'a' is not assignable to type 'b'; else if the name or scope are different, it would produce a warning about the missing cast.\n\nIn the given example, I would really prefer to have a warning and have to make a cast to get rid of it, since putting a 3d point into a 2d points array may indicate a potential error. The 3d point should probably be projected onto 2d space first, or maybe some other computation could be needed. Or maybe that is exactly what the author intended; a cast would make the intention clear. To me one of the main points of having type checks is to detect potential problems as early as possible and I believe this extra check would help.\n"
      },
      {
        "user": "danquirk",
        "created_at": "2015-03-11T01:21:55Z",
        "body": "Your proposal is essentially to add a nominal check on top of structural checks. This simply isn't going to happen. It doesn't mesh with how people actually use JavaScript today and would be a massive breaking change. Yes there are patterns where structural typing does not give you the same safety as nominal typing. Conversely, there are patterns nominal typing does not allow, or makes extremely painful, which structural typing makes simple or possible at all. There are trade offs with each, but the domain in which TypeScript is in necessitates structural typing. We don't want to be in a situation where you constantly have to annotate and cast your object literals and other correct, working JavaScript code just to satisfy the compiler.\n"
      }
    ]
  },
  {
    "number": 2284,
    "title": "Request : A way to say that something is of a Generic Interface type",
    "created_at": "2015-03-10T08:37:55Z",
    "closed_at": "2015-03-10T13:22:44Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/2284",
    "body": "As an example: \n\n``` ts\n// Function 'F' takes function 'a' \n// and returns a new function which has exactly the same set of args as function 'a'\ninterface F<A extends Function>{\n    (a:A):A;\n}\n\n// Is there a way to say:\nvar Foo:F;\n\n// Or am I forced to do : \nvar HigherOrderFunction: <A extends Function>(a:A)=>A;\n```\n\nI don't think there is currently a way to say what I want to say beyond duplicating the interface definition inline. \n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/2284/comments",
    "author": "basarat",
    "comments": [
      {
        "user": "ahejlsberg",
        "created_at": "2015-03-10T13:21:48Z",
        "body": "You can write this:\n\n``` typescript\ninterface F {\n    <A extends Function>(a: A): A;\n}\n```\n\nOr, if you prefer, using a type alias:\n\n``` typescript\ntype F = <A extends Function>(a: A) => A;\n```\n"
      }
    ]
  },
  {
    "number": 2189,
    "title": "Tuple type vs. array-of-union-type",
    "created_at": "2015-03-03T08:19:15Z",
    "closed_at": "2015-03-03T09:24:25Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/2189",
    "body": "Have I made a silly mistake here? I thought the tuple type `[string, number]` was roughly equivalent to the array-of-union-type `(string | number)[]`, and that the following was therefore legal:\n\n```\nfunction lengths (xs: string[]): [string, number][] {\n   return xs.map((x: string) => [x, x.length])\n}\n```\n\nHowever tsc 1.4 complains:\n\n```\nConfig.ts(127,11): error TS2322: Type '(string | number)[][]' is not assignable to type '[string, number][]'.      Type '(string | number)[]' is not assignable to type '[string, number]'.\n    Property '0' is missing in type '(string | number)[]'.\n```\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/2189/comments",
    "author": "rolyp",
    "comments": [
      {
        "user": "DanielRosenwasser",
        "created_at": "2015-03-03T08:46:10Z",
        "body": "I _believe_ (and others on the team should feel free to correct me) that this has to do with the way in which contextual typing takes effect (i.e. it _doesn't_ take effect on the return type of a call expression).\n\nIn other words, `lengths`'s return type doesn't impact your call's type, and so the language computes the type `(string | number)[]`.\n\nYou can get the behavior you want by giving your lambda a return type.\n\n``` TypeScript\nfunction lengths(xs: string[]): [string, number][] {\n    return xs.map((x): [string, number] => [x, x.length]);\n}\n```\n"
      },
      {
        "user": "rolyp",
        "created_at": "2015-03-03T09:13:53Z",
        "body": "Ah, interesting. Thanks.\n\nAs an aside, I've become wary of adding types to lambdas: at least, adding parameter types seems to be broken (code which didn't type-check when the parameter type annotation was omitted type-checks fine with a suitable annotation, and then fails at runtime). I'll probably post an example at some point. It looks like the inferred type isn't being checked against the annotation, so the annotation is behaving like a cast.\n\nBut here you're talking about adding a return type, which is certainly an improvement on my current workaround (which involves any `<any>` cast). Cheers.\n"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2015-03-03T09:24:25Z",
        "body": "Glad this helps, though, we'd definitely like to see an example where you run into the situation you mentioned if you can reproduce it.\n"
      }
    ]
  },
  {
    "number": 2149,
    "title": "Define variable to match declared variable with 'new'",
    "created_at": "2015-02-26T10:24:05Z",
    "closed_at": "2015-02-26T14:31:52Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/2149",
    "body": "It is possible to define variable with declared when the function name is not 'new'\n\n``` typescript\ninterface X {\n}\ndeclare var X: {\n    f(): X;\n}\n\n// OK, compatible type\nvar X = {\n    f() { return <X>null; }\n};\n\n\ninterface Y {\n}\ndeclare var Y: {\n    new(): Y;\n}\n\n// Not compatible types\n// new() : Y vs. new() => Y\nvar Y = {\n    new() { return <Y>null; }\n};\n```\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/2149/comments",
    "author": "NN---",
    "comments": [
      {
        "user": "ahejlsberg",
        "created_at": "2015-02-26T14:31:12Z",
        "body": "Yes, you can do that by putting the property name in quotes in the declaration:\n\n``` typescript\ninterface Y {\n}\ndeclare var Y: {\n    \"new\"(): Y;  // Quotes to indicate this is not a construct signature\n}\n\n// OK, compatible type\nvar Y = {\n    new() { return <Y>null; }\n};\n```\n"
      },
      {
        "user": "NN---",
        "created_at": "2015-02-26T18:33:47Z",
        "body": "Oh, I didn't knew about quotes syntax.\nActually it is logical since identifier can be quoted, but most people don't do it.\n\nFound it in the spec.\n\nTS spec:\n\n```\nMethod Signature:\n  PropertyName ?opt CallSignature\n```\n\nES spec:\n\n```\nPropertyName :\n  IdentifierName\n  StringLiteral\n  NumericLiteral\n```\n\nIt would be nice to mention 'new' case in the spec or in Q&A page.\nThanks.\n"
      },
      {
        "user": "NN---",
        "created_at": "2015-02-26T18:40:19Z",
        "body": "@ahejlsberg The only problem is that I cannot change the declaration :)\nIt is in lib.d.ts\nI am trying to define variable of Blob:\n\n``` typescript\ninterface Blob {\n    type: string;\n    size: number;\n    msDetachStream(): any;\n    slice(start?: number, end?: number, contentType?: string): Blob;\n    msClose(): void;\n}\ndeclare var Blob: {\n    prototype: Blob;\n    new (blobParts?: any[], options?: BlobPropertyBag): Blob;\n}\n```\n"
      },
      {
        "user": "ahejlsberg",
        "created_at": "2015-02-26T19:12:47Z",
        "body": "Not quite sure what you mean by \"trying to define variable of Blob\". Do you mean define a value that can be assigned to Blob? The Blob variable represents a constructor function (i.e. it is a variable of a constructor function type). To produce an assignment compatible value, you'll likely want to declare a class. For example:\n\n``` typescript\nclass MyBlob implements Blob {\n    type: string;\n    size: number;\n    constructor(blobParts?: any[], options?: BlobPropertyBag) {\n    }\n    msDetachStream(): any {\n        return undefined;\n    }\n    slice(start?: number, end?: number, contentType?: string): Blob {\n        return undefined;\n    }\n    msClose(): void {\n    }\n}\n```\n\nYou can then assign the class constructor function to the `Blob` variable:\n\n``` typescript\nBlob = MyBlob;\n```\n\nNote, it is important to understand that there are two distinct and different things called Blob: A type (produced by the interface declaration) and a variable (with an _unnamed_ constructor function type whose return value is the Blob interface). In type positions, Blob refers to the interface type, and in value positions (such as expressions) Blob refers to the constructor function.\n"
      },
      {
        "user": "NN---",
        "created_at": "2015-02-26T19:18:17Z",
        "body": "I want to define the variable that is declared by 'declare var Blob : { ... }' .\n\n``` typescript\nvar Blob = {  \n // prototype and the constructor\n};\n```\n"
      },
      {
        "user": "ahejlsberg",
        "created_at": "2015-02-26T20:03:02Z",
        "body": "You can't do that with an object literal because an object literal isn't \"callable\", i.e. it can't have a call or construct signature. Instead you need to write\n\n``` typescript\nvar Blob = MyBlob;\n```\n\nwhere `MyBlob` is a constructor function name introduced by a suitable class declaration (like my example above). Or you can assign some suitable constructor function object typed as `any` that you know has the correct shape.\n\nIt's important to understand that\n\n``` typescript\ndeclare var Blob: {\n    prototype: Blob;\n    new (blobParts?: any[], options?: BlobPropertyBag): Blob;\n}\n```\n\ndoesn't introduce a property named \"new\", but rather introduces a construct signature that defines how to call the constructor function using the `new` operator, as in\n\n```\nvar x = new Blob(...);\n```\n\nSo, basically the declaration says that `Blob` is a variable of a constructor function type that (a) has a property named `prototype` and (b) can be called using `new` with the specified parameters.\n"
      },
      {
        "user": "NN---",
        "created_at": "2015-02-26T21:04:04Z",
        "body": "Unfortunately this doesn't work.\nIt works with explicit cast, is it a bug ?\n\n``` typescript\ninterface QQ {\n}\n\ndeclare var QQ:{\n    new(): QQ;\n}\n\nclass QQImpl {\n    constructor() {}\n}\n\nvar QQ = QQImpl; // Doesn't work \n\n// But works with explicit cast !\nvar QQ = <{new():QQ;}> QQImpl;\n```\n"
      },
      {
        "user": "ahejlsberg",
        "created_at": "2015-02-26T21:14:35Z",
        "body": "You're getting an error because your `var QQ = QQImpl;` statement redeclares `QQ` with a (slightly) different type. The following works:\n\n``` typescript\ninterface QQ {\n}\n\ndeclare var QQ:{\n    prototype: QQ; // Include prototype property to make type identical to class\n    new(): QQ;\n}\n\nclass QQImpl {\n    constructor() {}\n}\n\nvar QQ = QQImpl; // Ok, types of QQ and QQImpl identical\n```\n\nAs does this:\n\n``` typescript\ninterface QQ {\n}\n\ndeclare var QQ:{\n    new(): QQ;\n}\n\nclass QQImpl {\n    constructor() {}\n}\n\nQQ = QQImpl; // Assignment, not redeclaration\n```\n"
      },
      {
        "user": "NN---",
        "created_at": "2015-02-26T21:20:08Z",
        "body": "The first sample doesn't work since the QQImpl doesn't have prototype property and types are incompatible.\nThe second one is not what I need because it produces the following JS.\nIt will fail in strict parsing mode if nobody defined QQ before.\n\n``` javascript\nvar QQImpl = (function () {\n    function QQImpl() {\n    }\n    return QQImpl;\n})();\nQQ = QQImpl; // Assignment, not redeclaration\n```\n"
      },
      {
        "user": "ahejlsberg",
        "created_at": "2015-02-26T21:41:29Z",
        "body": "It works in master, but apparently not with 1.3 or earlier.\n\nI'm still not sure what you're trying to accomplish so it's hard to make further suggestions. If all you care about is declaring a class QQ that has the same shape as the interface/var QQ, then you can simply do this:\n\n``` typescript\nclass QQ {\n}\n```\n\nThis introduces **_both**_ an interface QQ and a \"variable\" QQ (the constructor function) and in use you'll see the same effect as if you had declared the separate interface and variable.\n"
      },
      {
        "user": "NN---",
        "created_at": "2015-02-27T07:05:29Z",
        "body": "Ok, the situation is the following.\nI am using ES5 and browser specific features but some of them don't exist in other environments like nodejs or other browsers.\nNow I want to define a variable and make everything works without getting RefereneError.\nI can access to all variables through 'window' object and then it is possible to check and assign easily:\n\n``` typescript\nif (window.Blob) {\n   // Use window.Blob\n}\n```\n\nBut I don't want to change my code, moreover some definition libraries do not define global variables both globally and in window, so it means that I must rewrite definitions.\n\nI can add pure JS file that does the simple thing: \"function Blob() {}\" and that's all I need.\nI wanted to solve it using TypeScript language.\nSince I have typing and all interfaces defined I won't make a mistake in defining variables or types.\n\nI hope it is clear now.\nThanks.\n"
      },
      {
        "user": "NN---",
        "created_at": "2015-02-27T18:58:16Z",
        "body": "Found it ! :)\nYour code is totally correct but I was missing the 'var' part and it works as expected when I add it.\nThe only change is that I must specify the exact type of the declared variable.\nI would like to see whether it can be inferred somehow there. \n\n``` typescript\nclass MyBlob implements Blob {\n    constructor(blobParts?: any[], options?: BlobPropertyBag) { }\n    msDetachStream(): any {}\n    slice(start?: number, end?: number, contentType?: string): Blob { throw new Error(\"Not implemented\"); }\n    msClose(): void {}\n    type: string;\n    size: number;\n}\nvar Blob: {\n    prototype: Blob;\n    new(blobParts?: any[], options?: BlobPropertyBag): Blob;\n} = MyBlob;\n```\n"
      }
    ]
  },
  {
    "number": 2147,
    "title": "Question, how to make a variable within declared module name",
    "created_at": "2015-02-26T06:41:20Z",
    "closed_at": "2015-02-26T07:16:30Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/2147",
    "body": "I am writing a test and I have an issue.\nThe test runner doesn't have the global object I need since it is running in a different environment.\nI want to create this object because strict mode complains otherwise, but TypeScript cannot do it.\n\nI have declaration:\n\n``` typescript\ndeclare module Q {\n    function f(): string;\n}\n```\n\nand usage\n\n``` typescript\nvar x = Q.f();\n```\n\nNow in my test I want to mock Q.f and create object of my own.\n\n``` typescript\nvar Q = { ... }\n```\n\nThe TypeScript complains about multiple declarations.\n\nThere is a workaround to access the module through the global 'window' object in the code and then it is possible to test it.\n\n``` typescript\ninterface Window {\n Q: QInterface;\n}\n\ninterface QInterface {\n    function f(): string;\n}\n\n// the code\nvar x = !!window.Q ? window.Q.f() : \"\";\n```\n\nI would like to not use the workaround and find some solution without changing my code.\nThanks.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/2147/comments",
    "author": "NN---",
    "comments": [
      {
        "user": "DanielRosenwasser",
        "created_at": "2015-02-26T06:45:13Z",
        "body": "It sounds like describing your module with an interface will solve your problem.\n\n``` TypeScript\ninterface Q {\n    f(): string;\n}\n\nvar Q = {\n    f() {\n        return \"Hello\";\n    }\n}\n\nvar x = Q.f();\n```\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2015-02-26T06:53:02Z",
        "body": "how about;\n\n``` TypeScript\ndeclare var Q : {\n    f(): string;\n};\n```\n\nlater on in your tests:\n\n``` TypeScript\nvar Q = {\n    f() { .. }\n}\n```\n"
      },
      {
        "user": "NN---",
        "created_at": "2015-02-26T06:59:59Z",
        "body": "@DanielRosenwasser I don't see how it solves it\n@mhegazy It means that I must rewrite all the definition files that don't use 'var' .\nSome of definitions files are in the following form:\n\n``` typescript\ndeclare module A.B {\n function f(): Interface;\n interface I {}\n}\ndeclare module A.C {\n function g(): Interface; // Yes the same name as A.B but different meaning of course.\n interface I {}\n}\n//2500 similar lines\n```\n\nIs there easy way to refactor it ?:)\n"
      },
      {
        "user": "NN---",
        "created_at": "2015-02-26T07:02:50Z",
        "body": "If I could use modules as types specifiers then it would be easy to refactor the code for 'var' .\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2015-02-26T07:03:28Z",
        "body": "The probelm is that a module and var do not really merge. the var will override the value of the module, so this is why it is flagged as an error.\n\nhow about this:\n\n``` TypeScript\n// declaration\ndeclare module M {\n    function f(): string;\n}\n\n\n// tests\nmodule M { \n    M.f = ()=> \"\";\n}\n```\n"
      },
      {
        "user": "NN---",
        "created_at": "2015-02-26T07:13:41Z",
        "body": "@mhegazy Great idea ! :)\nDidn't think about just defining the module.\nThanks :)\n"
      }
    ]
  },
  {
    "number": 2135,
    "title": "Import statement causes problem with external module ",
    "created_at": "2015-02-25T10:32:56Z",
    "closed_at": "2015-02-26T05:11:18Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/2135",
    "body": "I'm trying to write a tool for `Typescript`. Though I got some problem:\n\nIn scanner.ts:\n\n``` typescript\n/// <reference path=\"../../typings/node/node.d.ts\" />\n/// <reference path=\"../../typings/typescript/typescript.d.ts\" />\n/// <reference path=\"types.ts\" />\n\nimport ts = require(\"typescript\");\n\nmodule pp {\n    var textToToken: Map<AnnotationSyntaxKind> = {\n        \"@\": AnnotationSyntaxKind.AtsignToken,\n        \"@if\": AnnotationSyntaxKind.IfKeyword,\n        \"@endif\": AnnotationSyntaxKind.EndIfKeyword,\n        \"@requires\": AnnotationSyntaxKind.RequiresKeyword\n    }\n}\n```\n\nIn types.ts:\n\n``` typescript\nmodule pp {\n    export interface Map<T> {\n        [index: string]: T;\n    }\n\n    export const enum AnnotationSyntaxKind {\n        AtsignToken,\n        IfKeyword,\n        EndIfKeyword,\n        RequiresKeyword\n    }\n}\n```\n\nThis setup will yield:\n\n```\nsrc/preprocessor/scanner.ts(8,22): error TS2314: Generic type 'Map<K, V>' requires 2 type argument(s).\nsrc/preprocessor/scanner.ts(9,14): error TS2304: Cannot find name 'AnnotationSyntaxKind'.\nsrc/preprocessor/scanner.ts(10,16): error TS2304: Cannot find name 'AnnotationSyntaxKind'.\nsrc/preprocessor/scanner.ts(11,19): error TS2304: Cannot find name 'AnnotationSyntaxKind'.\nsrc/preprocessor/scanner.ts(12,22): error TS2304: Cannot find name 'AnnotationSyntaxKind'.\n```\n\nBut when I remove this line of code in scanner.ts:\n\n``` typescript\nimport ts = require(\"typescript\");\n```\n\nEverything works fine.\n\nWhat have I done wrong?\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/2135/comments",
    "author": "tinganho",
    "comments": [
      {
        "user": "danquirk",
        "created_at": "2015-02-25T19:25:10Z",
        "body": "Adding an `import` like that to scanner makes it an external module. This means everything inside it is in a new scope and the things from internal modules in other files are no longer accessible. Generally you do not want to mix internal and external modules.\n"
      },
      {
        "user": "tinganho",
        "created_at": "2015-02-25T20:58:11Z",
        "body": "@danquirk how do I achieve what I want to achieve then?\n\nI want to re-use some of the values in typescript like the enum `ts.SyntaxKind` in `scanner.ts`\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2015-02-25T23:46:48Z",
        "body": "in your external module do not add module pp, and refer to Map as pp.Map.\n"
      },
      {
        "user": "tinganho",
        "created_at": "2015-02-26T05:11:18Z",
        "body": "@mhegazy thanks!\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2015-02-26T05:47:04Z",
        "body": "u r most welcome :) \n"
      }
    ]
  },
  {
    "number": 2099,
    "title": "Generic constraint with type list",
    "created_at": "2015-02-21T18:25:31Z",
    "closed_at": "2015-02-23T03:48:01Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/2099",
    "body": "It is a generalization of #2049 .\nI would like to see generic specifying concrete types:\n\n``` typescript\n// Can specify only A<number> or A<string>\ninterface A<T is number|string|Object> { }  \n\ninterface B<T is number|string> extends A<T> {} // number|string is subtype of number|string|Object .\n```\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/2099/comments",
    "author": "NN---",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2015-02-23T03:48:01Z",
        "body": "In order to be considered, we need suggestions to have at least _some_ motivating use cases, examples of desired usage, examples of things that would be / would not be errors and why, etc.. We don't have resources to ask clarifying questions teasing out what these things mean.\n"
      },
      {
        "user": "NN---",
        "created_at": "2015-02-23T09:56:51Z",
        "body": "One of use cases is the following:\n\n``` typescript\ninterface KeyValueBase<K> {\n  f(): K;\n}\n\ninterface KeyValue<K is number|string, V> extends KeyValueBase<K> {\n [key: K]: V\n}\n```\n\nThe key type must be string or number , it is impossible to define this generic right now.\nIt can be possible to define it and use the type if the feature existed.\n"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2015-02-23T10:03:54Z",
        "body": "You could also use a type alias.\n\n``` TypeScript\ntype Key = number | string;\n\ninterface KeyValueBase {\n  f(): Key;\n}\n\ninterface KeyValue extends KeyValueBase {\n [key: Key]: V\n}\n```\n"
      },
      {
        "user": "NN---",
        "created_at": "2015-02-23T12:54:46Z",
        "body": "@DanielRosenwasser It is not the same since I don't know the exact type.\nAlso the indexer is one of possible samples.\n"
      },
      {
        "user": "litera",
        "created_at": "2017-01-26T09:22:54Z",
        "body": "Object indexer is the perfect example and use case for `is` genetic type parameter constraint. This hasn't been updated in a while. Is there any progress?"
      },
      {
        "user": "litera",
        "created_at": "2017-01-26T09:25:21Z",
        "body": "@DanielRosenwasser And btw even when using type aliasing TSLint still throws an error."
      },
      {
        "user": "massimonewsuk",
        "created_at": "2018-01-26T15:35:15Z",
        "body": "One issue I had is with `Object.entries`, but the type definition for that was pretty simple:\r\n\r\n```\r\ninterface ObjectConstructor {\r\n    entries<TValue>(object: { [key: string]: TValue }): [string, TValue][];\r\n    entries<TValue>(object: { [key: number]: TValue }): [string, TValue][];\r\n}\r\n```\r\n\r\nI understand it won't work for everything (objects that aren't strictly used as maps), so it would probably be better to just have your own \"wrapper function\" around Object.entries, but I thought I'd mention it in case it helps anyone else who finds this issue."
      }
    ]
  },
  {
    "number": 2067,
    "title": "--mapRoot doesn't seem to work",
    "created_at": "2015-02-18T22:21:10Z",
    "closed_at": "2015-02-28T11:13:45Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/2067",
    "body": "`tsc --sourceMap --mapRoot maproot/ --out a.js t.ts`\n\nIt simply places the .js.map files in the same directory as the --out file.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/2067/comments",
    "author": "danihodovic",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2015-02-26T07:00:24Z",
        "body": "maproot does not place the files in a different place, it just controls the reference to the map file in the .js file. the assumption here is that you will move the map files to a different location, possibly a local directory, where as the other .js files are on your server, or a different server, etc.. it just tells the debugger where to look for the map files instead of next to the .js files.\n"
      },
      {
        "user": "danihodovic",
        "created_at": "2015-02-27T11:28:52Z",
        "body": "So the maproot command is there for the debugger to locate the map files, not for moving them anywhere? \n"
      },
      {
        "user": "mhegazy",
        "created_at": "2015-02-27T18:33:18Z",
        "body": "correct. if you look at the javascript output, last line of your file, you will find the reference to the map file. this is what maproot controls. e.g.:\n\n``` TypeScript\n//# sourceMappingURL=rooot\\t1.js.map\n```\n"
      },
      {
        "user": "danihodovic",
        "created_at": "2015-02-28T11:13:44Z",
        "body": "I see. Thanks! Closing.\n"
      }
    ]
  },
  {
    "number": 1896,
    "title": "Scanner does not reach end of file token under some circumstances",
    "created_at": "2015-02-02T21:30:06Z",
    "closed_at": "2015-02-02T22:59:14Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/1896",
    "body": "I haven't looked into this in full detail yet -- I have only the one example -- but if I have code of the form:\n\n``` typescript\nvar scanner = ts.createScanner(ts.ScriptTarget.ES5, false, sourceFile.text);\nwhile (scanner.scan() !== ts.SyntaxKind.EndOfFileToken) {\n    // do stuff here\n}\n```\n\nbut sourceFile.text is something that doesn't compile like just `var a=;` then the loop never exits, as the end of file token is never hit -- it just hits the semicolon token over and over again. Is this on purpose? Is there a more standard way to loop until you hit the last token? (I would assume checking if the previous start is the same as the current start, which is easy enough to do, but I'm not sure how intentional this is, regardless).\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/1896/comments",
    "author": "gscshoyru",
    "comments": [
      {
        "user": "DanielRosenwasser",
        "created_at": "2015-02-02T22:30:34Z",
        "body": "Woah, that doesn't seem like it could be right - I tried this out\n\n``` TypeScript\n/// <reference path=\"bin/typescript.d.ts\" />\n\nimport ts = require(\"typescript\");\nvar sourceText = \"var a=;\";\n\nvar scanner = ts.createScanner(ts.ScriptTarget.ES5, false, sourceText);\n\nwhile (true) {\n    var token = scanner.scan();\n    console.log(\"\" + token + \": \" + ts.SyntaxKind[token]);\n\n    if (token === ts.SyntaxKind.EndOfFileToken) {\n        break;\n    }\n}\n```\n\n```\n> node .\\bin\\tsc.js .\\scanSample.ts --module commonjs\nscanSample.ts(10,48): error TS4085: Index expression arguments in 'const' enums must be of type 'string'.\n```\n\n(ignore the error)\n\n```\nnode .\\scanSample.js\n96: VarKeyword\n5: LastTriviaToken\n63: Identifier\n51: FirstAssignment\n21: FirstOperator\n1: EndOfFileToken\n```\n"
      },
      {
        "user": "gscshoyru",
        "created_at": "2015-02-02T22:44:32Z",
        "body": "...that is decidedly odd. That simple bit seems to work fine for me as well -- but my code is very clearly breaking here, and I'm not sure why. Let me investigate a bit. \n"
      },
      {
        "user": "gscshoyru",
        "created_at": "2015-02-02T22:59:13Z",
        "body": "...nevermind. I figured out where I went wrong; it was something else. Sorry, and thanks!\n"
      }
    ]
  },
  {
    "number": 1877,
    "title": "Different rules for function parameter compatibility when assignment is on a different line to variable declaration.",
    "created_at": "2015-01-31T19:06:04Z",
    "closed_at": "2015-01-31T19:21:58Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/1877",
    "body": "A function can choose to omit parameters defined in a signature, as shown by function `a` below. Callers of `a` must still supply arguments, but the function does not need to use them.\n\nDespite this, if the same function is assigned later in the program, this no longer applies and the identical function is now not compatible, as shown with function `b`.\n\n``` typescript\ninterface X {\n    (source: number): boolean;\n}\n\nvar a: X = function() { return true; }\n\nvar b: X;\n// Why is this an error?\nvar b = function() { return true; }\n```\n\nShouldn't both of these cases follow the same rules?\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/1877/comments",
    "author": "Steve-Fenton",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2015-01-31T19:21:58Z",
        "body": "This is an error because duplicate definitions of the same variable must have the _exact_ same type. This includes cases where the type of the variable is inferred from its initializer.\n\nIt's similar to if you had written\n\n``` ts\nvar x: Animal;\nvar x: Dog;\n```\n\nIf you removed the `var` keyword from the last line, you wouldn't see an error.\n"
      },
      {
        "user": "Steve-Fenton",
        "created_at": "2015-01-31T21:09:49Z",
        "body": "Sorry about that one... I spent too long staring at the right-hand side of the code to realise the problem was on the left! Thanks Ryan.\n"
      }
    ]
  },
  {
    "number": 1867,
    "title": "Private variables in definition files",
    "created_at": "2015-01-30T12:51:15Z",
    "closed_at": "2015-02-02T18:45:01Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/1867",
    "body": "When I produced definition files (.d.ts) for my projects, private variables of classes are also present.\n\nMost of the time, I use internal libraries that require others definition files (jquery.d.ts for example), or definition files that are not present in lib.d.ts (Promises.d.ts and TouchEvent.d.ts for example).\n\nBut as I use private variables in my classes for wich the type is only defined in these definition files, my project generated definition file contains these types.\n\nSo without publish all the other .d.ts files with my project one, it is unusable.\n\nIs there a way to manage it ? Or just remove the private variables to prevent these cases ?\n\nThanks\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/1867/comments",
    "author": "paztis",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2015-01-30T18:06:59Z",
        "body": "> But as I use private variables in my classes for wich the type is only defined in these definition files, my project generated definition file contains these types.\n\nCan you clarify? When the compiler generates a .d.ts for a class, it doesn't put type annotations on private members, so this shouldn't be a problem.\n"
      },
      {
        "user": "paztis",
        "created_at": "2015-01-31T20:45:49Z",
        "body": "Indeed, I had not noticed that they were not typed.\nI must have some public variables referencing these types.\n"
      },
      {
        "user": "georgehdd",
        "created_at": "2016-04-12T05:58:26Z",
        "body": "A year later: privates are still generated in d.ts. Why are they there ? what is their added values ?\nThis forces my class to be treated as a nominal type instead of structural type.\n"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2016-04-12T17:29:03Z",
        "body": "It's absolutely necessary to have privates in generated .d.ts files. Otherwise you could derive from that class, declare a private of your own with the same name, and unknowingly stomp on your base class's private variable value. That failure mode would be very, very difficult to debug.\n"
      }
    ]
  },
  {
    "number": 1866,
    "title": "Can compiler only emit declaration file ?",
    "created_at": "2015-01-30T12:44:06Z",
    "closed_at": "2015-04-21T06:37:28Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/1866",
    "body": "Is there a way to only emit the declaration file (.d.ts) with the compiler and not the js file ?\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/1866/comments",
    "author": "paztis",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2015-01-30T18:07:07Z",
        "body": "There is no supported flags that would do that, only emit all or do not emit at all (--noEmit). Consider using --outDir and picking only the .d.ts files.\n"
      },
      {
        "user": "nojvek",
        "created_at": "2017-05-17T15:47:11Z",
        "body": "I'm thinking of adding a --noEmitJs flag. Would you be willing to entertain that thought?"
      },
      {
        "user": "mhegazy",
        "created_at": "2017-05-17T15:56:38Z",
        "body": "> I'm thinking of adding a --noEmitJs flag. Would you be willing to entertain that thought?\r\n\r\nif there is a compelling scenario.\r\n"
      },
      {
        "user": "nojvek",
        "created_at": "2017-05-17T17:22:29Z",
        "body": "**Scenario: Auto-Generate typings for a pure js project**\r\n\r\nCurrently typings for js projects are manually hand maintained. A ton of typings are out of date with the actual code. Typings are kind of documentation and if they are separate from code, they will eventually get out of sync. \r\n\r\nwith --checkJs, JS lib authors get extra benefit of validating code with jsdoc typings. Being able to auto generate just <lib>.d.ts from their existing code would make life easier. This can be done as part of the build step.\r\n\r\nBasically if `declarations:true` and `noEmitJs:true`, only declarations should still be generated\r\n\r\nProposal:\r\n ```\r\ncompilerOptions: {\r\n   module: 'amd',\r\n   outFile: 'build/types.d.ts',\r\n   declarations: true,\r\n   allowJs: true,\r\n   checkJs: true, // optional\r\n   noEmitJs: true,\r\n},\r\ninclude: [\r\n    'src/**.js'\r\n]\r\n```\r\n\r\nThis would just generate a single .d.ts file from the project that you can add as part of package.json.  No hand maintenance. \r\n\r\n"
      },
      {
        "user": "trulysinclair",
        "created_at": "2017-07-17T01:17:15Z",
        "body": "Useful if you only want to generate the declaration files but not compile the js. Current usage for me would be that I'm generating an Electron application. I want the d.ts files in respective directories but the js files don't need to be created because they're made during application compilation and would cause only unnecessary clutter beforehand. "
      }
    ]
  },
  {
    "number": 1832,
    "title": "Cast to index signature (question)",
    "created_at": "2015-01-28T12:49:39Z",
    "closed_at": "2015-01-28T20:48:35Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/1832",
    "body": "Each ES object is a dictionary of string keys.\nTherefore it is allowed to write either a.b or a[\"b\"] in ES.\n\nTS doesn't allow this unless you specify index signature.\nAlso you cannot cast to this type without casting to 'any' .\n\n``` typescript\nvar q: { a: number; } = { a: 1 };\n\n// This is not allowed since 'q' type is not assignable to this type.\n(<{[x:string]:any}>q)[\"a\"] = 2;\n\n// This is allowed since any can be casted to anything.\n(<{[x:string]:any}><any>q)[\"a\"] = 2;\n```\n\n'Object' type from lib.d.ts doesn't have index signature either, so you cannot use it as well.\nIs there anything better than casting to 'any' ?\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/1832/comments",
    "author": "NN---",
    "comments": [
      {
        "user": "stephanedr",
        "created_at": "2015-01-28T18:19:50Z",
        "body": "Don't need any cast.\nFrom playground:\n\n```\nvar q: { a: number; } = { a: 1 };\nq[\"a\"] = 2;     // OK\nq[\"a\"] = \"foo\"; // Error \"string not assignable to number\"\nvar n = q[\"a\"]; // n is number\n```\n"
      },
      {
        "user": "NN---",
        "created_at": "2015-01-28T19:59:07Z",
        "body": "This is okay, but think about more generic usage like:\n\n``` typescript\nvar q = {};\n\nfunction f(index: string) {\n (<{[x:string]:any]}>q)[index]) = 1; // This won't work\n}\n```\n"
      },
      {
        "user": "danquirk",
        "created_at": "2015-01-28T20:04:10Z",
        "body": "The generic usage is what was already written. You have syntax errors in your latest example.\n\n``` ts\nvar q = {};\n\nfunction f(index: string) {\n    q[index] = 1; // works\n    (<{[x:string]:any}>q)[index] = 1; // also works, but a meaningless extra cast\n}\n```\n"
      },
      {
        "user": "NN---",
        "created_at": "2015-01-28T20:09:43Z",
        "body": "I see why it works.\nI have disabled 'Allow implicit 'any' types'.\n"
      },
      {
        "user": "NN---",
        "created_at": "2015-01-28T20:51:10Z",
        "body": "The question is why it does require explicit cast to any in order to make cast for type with indexer ?\n"
      },
      {
        "user": "NoelAbrahams",
        "created_at": "2015-02-02T16:35:11Z",
        "body": "Hi, I think this is actually a bug and the issue should be re-opened.\n\nHere is a more straightforward repro:\n\n``` typeScript\ninterface Indexer {\n    [x: string]: number;\n}\n\ninterface Foo {\n    id: number;\n}\n\n\nvar x: Foo\n\n/*Error: Neither type 'Foo' nor type 'Indexer' is assignable to the other.\n Index signature is missing in type 'Foo'.*/\nvar y = <Indexer>x;\n\n```\n\nThe object `Foo` is clearly indexable by `string` to produce a number, hence the type assertion should be permitted.\n"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2015-02-02T17:40:48Z",
        "body": "> The object Foo is clearly indexable by string to produce a number\n\nThis isn't how index signatures work. Consider something like this:\n\n``` ts\nvar z: Foo = { id: 42, name: 'bob' };\nvar y = <Indexer>x; // Should be allowed (?)\nvar j = y['name']; // j: number, j === 'bob' :(\n```\n"
      }
    ]
  },
  {
    "number": 1831,
    "title": "Is it possible to import everything from the module ?",
    "created_at": "2015-01-28T11:27:35Z",
    "closed_at": "2015-03-02T09:31:59Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/1831",
    "body": "I can do 'import Alias = Module' but I don't find a syntax for simple 'import Module' to import everything.\nDo I miss something ?\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/1831/comments",
    "author": "NN---",
    "comments": [
      {
        "user": "danquirk",
        "created_at": "2015-01-28T19:01:45Z",
        "body": "`import alias = module` creates an alias to `module`. Anything that was accessible from `module` should now be accessible via `alias`.\n\n`import foo = require('myModule')` works similarly, where everything exported in `myModule` is now accessible via `foo`. \n\nWhat exactly are you trying to do?\n"
      },
      {
        "user": "NN---",
        "created_at": "2015-01-28T19:33:32Z",
        "body": "I want something like import \\* from Module.\n"
      },
      {
        "user": "danquirk",
        "created_at": "2015-01-28T19:40:32Z",
        "body": "We'll be fully aligning with ES6 module syntax in the near future.\n"
      },
      {
        "user": "NN---",
        "created_at": "2015-01-28T19:54:45Z",
        "body": "Great, waiting for it :)\n"
      }
    ]
  },
  {
    "number": 1763,
    "title": "Not generating output for exported const enum makes the enum useless from regular JavaScript",
    "created_at": "2015-01-21T20:56:39Z",
    "closed_at": "2015-01-21T22:08:23Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/1763",
    "body": "Currently, no JavaScript is generated for const enum declarations (the language spec does not seem to address const enums).\n\nIs there a way to get the benefit of aggressive compile-time enum evaluation while still generating the JS enum object?\n\nIt would be nice if the computed values in the example below would be computed at compile-time like is done for const enum, but retain the generated JS so that the enum can be used from non-typescript applications:\n\n``` typescript\nexport enum Things {\n    ThingA = 0x1,\n    ThingB = 0x2,\n    ThingC = 0x4,\n    Mask = ThingA | ThingB | ThingC,\n}\n```\n\nDesired output:\n\n``` javascript\nvar Things;\n(function (Things) {\n    Things[Things[\"ThingA\"] = 1] = \"ThingA\";\n    Things[Things[\"ThingB\"] = 2] = \"ThingB\";\n    Things[Things[\"ThingC\"] = 4] = \"ThingC\";\n    Things[Things[\"Mask\"] = 7] = \"Mask\";\n})(Things || (Things = {}));\n```\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/1763/comments",
    "author": "sccolbert",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2015-01-21T21:29:44Z",
        "body": "The `--preserveConstEnums` flag does exactly this.\n"
      },
      {
        "user": "sccolbert",
        "created_at": "2015-01-21T22:08:23Z",
        "body": "Perfect. Thanks!\n"
      }
    ]
  },
  {
    "number": 1739,
    "title": "how to uninstall 1.4",
    "created_at": "2015-01-20T10:33:48Z",
    "closed_at": "2015-01-20T19:48:05Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/1739",
    "body": "",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/1739/comments",
    "author": "v-vairam",
    "comments": [
      {
        "user": "DavidRigglemanININ",
        "created_at": "2015-01-20T16:05:21Z",
        "body": "I may be able to provide some help here since I had to do the same thing after encountering a bug in 1.4 that forced me to uninstall that version. You can uninstall version 1.4 from the Remove Programs functionality in the Control Panel. In my case, I then also had to right click on version 1.3 in the Control Panel, click Modify, and then select Repair in order to restore TypeScript integration back into Visual Studio for 1.3\n"
      },
      {
        "user": "danquirk",
        "created_at": "2015-01-20T19:48:05Z",
        "body": "As mentioned, if you've installed it on VS2013 then there should be a normal Add/Remove Programs entry you can uninstall it from. \n"
      },
      {
        "user": "v-vairam",
        "created_at": "2015-01-20T19:50:18Z",
        "body": "thanks. :) it helped.\n"
      }
    ]
  },
  {
    "number": 1684,
    "title": "Is there some special handling or type inference for null values?",
    "created_at": "2015-01-15T19:02:18Z",
    "closed_at": "2015-03-02T09:35:26Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/1684",
    "body": "I would like to know if there is some sort of special support for null values in Typescript, like the Maybe Types in Flow ?\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/1684/comments",
    "author": "ghost",
    "comments": [
      {
        "user": "danquirk",
        "created_at": "2015-01-15T20:57:07Z",
        "body": "See #185 and #1265\n"
      }
    ]
  },
  {
    "number": 1656,
    "title": "Infer type from the usage",
    "created_at": "2015-01-13T11:00:21Z",
    "closed_at": "2015-01-13T18:50:19Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/1656",
    "body": "Are there any plans for type inference from the usage ?\nFor instance:\n\n``` typescript\nfunction f() : number;\n\nvar a;\ntry {  \n  a = f();\n} catch {\n  a = 2;\n}\n```\n\nI would like to see this code compiling.\nNow I must put the type explicitly.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/1656/comments",
    "author": "NN---",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2015-01-13T18:50:19Z",
        "body": "No. In general, inference from usage can be hard to reason about (e.g. if `a` were initialized with a `Cat` in the `try` and a `Dog` in the `finally` is that an error?) and often detects fewer errors than expected.\n"
      }
    ]
  },
  {
    "number": 1565,
    "title": "Null calling pre-compile check",
    "created_at": "2014-12-26T18:06:20Z",
    "closed_at": "2014-12-27T13:25:23Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/1565",
    "body": "Hi. I'm working on a bit bigger project that is fully driven by TS, and I noticed that compiler doesn't check if variables that have as type object, are filled with instances anywhere. I didn't realize that so now my project is full of variables that were never initialized. So I thought that this would help a lot, and it isn't that hard to check. But I'm a horrible JS programmer. I hate even look at JS. So... just an idea. \n\nThanks for reading.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/1565/comments",
    "author": "ghost",
    "comments": [
      {
        "user": "DanielRosenwasser",
        "created_at": "2014-12-27T05:37:44Z",
        "body": "Have you looked into our `--noImplicitAny` flag?\n\nWhen an assignable entity has no context for which it can infer a type (either by initialization, or an explicit type annotation), our type system automatically infers the type (or types of its constituents) to be `any`.\n\nFor instance, our compiler would error (but still emit) on all of the following with `--noImplicitAny`:\n\n``` TypeScript\nvar a;                 // type: any\nvar b = null;          // type: any\nvar c = undefined;     // type: any\nvar d = [];            // type: any[]\nvar e = [[null]];      // type: any[][]\n```\n"
      },
      {
        "user": "ghost",
        "created_at": "2014-12-27T09:29:53Z",
        "body": "Oh. Ok... Thanks that helps. \n"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2014-12-27T13:25:23Z",
        "body": "No problem. If that's not _actually_ helping you could simply use a regular expression on your codebase to see if you're not initializing a variable on declaration.\n\n```\nvar [^=]+$\n```\n\nThough, with this, you'll have to check instance members in classes separately.\n"
      }
    ]
  },
  {
    "number": 1531,
    "title": "Generic interface",
    "created_at": "2014-12-18T15:25:54Z",
    "closed_at": "2015-01-18T09:52:30Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/1531",
    "body": "hi\n\nIs there any reason im getting error \n\n> Property 'test' of type '(callBack: (results: T) => void) => any' is not assignable to string index type 'T'.  \n\nFor the following code\n\n```\ninterface IProxyArray<T> {\n    [index: string]: T;\n    test(callBack: (results: T) => void);\n}\n```\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/1531/comments",
    "author": "vclteam",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2014-12-18T16:30:02Z",
        "body": "A string indexer is a _constraint_ on all the members of the type. The idea is that we don't want code like this to happen:\n\n``` ts\nvar x: IProxyArray<string> = ...;\nvar i = 'test';\nvar s = x[i].substr(3); // Error, substr is not a method of Function\n```\n"
      },
      {
        "user": "vclteam",
        "created_at": "2014-12-19T05:56:47Z",
        "body": "A string indexer define how u access to the object with an index.\nin term of javescript you can still access the object methods\n\nany idea of a workaround  for this\n\n```\ninterface IProxyArray<T> {\n    [index: string]: T;\n    test(callBack: (results: T) => void);\n}\n\nvar x: IProxyArray<string> = ...;\nvar s:string = x[i].substr(3);\nx.test((data:string=>{});\n```\n"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2014-12-19T07:05:10Z",
        "body": "What is `i` in this example?\n"
      },
      {
        "user": "vclteam",
        "created_at": "2014-12-19T13:41:41Z",
        "body": "string\n"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2014-12-19T19:57:10Z",
        "body": "There's no way to say \"this object returns a T when indexed with _all_ strings **except** the ones that have the same text as the methods in my object. Maybe just use\n\n``` TypeScript\ninterface IProxyArray<T> {\n    values: { [index: string]: T };\n    test(callBack: (results: T) => void);\n}\n```\n\nor\n\n``` TypeScript\ninterface IProxyArray<T> {\n    get(index: string): T;\n    set(index: string, value: T): void;\n    test(callBack: (results: T) => void);\n}\n```\n"
      }
    ]
  },
  {
    "number": 1487,
    "title": "Tuple type checking",
    "created_at": "2014-12-15T14:33:18Z",
    "closed_at": "2014-12-18T01:47:15Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/1487",
    "body": "I haven't had the time to investigate yet, but was surprised to see the following compile without error with tsc.exe shipped in the VS extension v1.3:\n    var testingzetuple: [number, string] = [1, \"world\", \"foreva\"];\nor\n    var testingzetuple: [number, number] = [1, 2, 3];\nIs that the expected behaviour? Shouldn't tuple type [t1,...,tn] be limited to size n?\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/1487/comments",
    "author": "codespare",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2014-12-17T18:53:07Z",
        "body": "By the substitution principle, a longer tuple is a subtype of a shorter tuple (assuming their first _n_ elements are the same).\n"
      },
      {
        "user": "codespare",
        "created_at": "2014-12-18T01:47:15Z",
        "body": "That makes sense given it is defined as an interface. I was implicitly assuming something similar to .NET System.Tuple definition which doesn't have that flexibility. Thank you for the clarification.\n"
      }
    ]
  },
  {
    "number": 1481,
    "title": "Can an optional and required field of merged interfaces yield a required field?",
    "created_at": "2014-12-14T19:09:06Z",
    "closed_at": "2015-06-12T18:35:20Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/1481",
    "body": "I have this case from using the mongoose library, in which my domain object, A, might have a DB _id, but the mongoose.Document always has an _id.\nI use type A when not in the mongoose portions of the app, and type ADocument only within those parts that deal directly with mongoose.  Note that mongoose defines Document to contain _id like this:\n\n```\ninterface Document {\n    _id: string;\n}\n```\n\nI tried to model the A - ADocument relationship like this:\n\n```\ninterface A {\n    _id?: string;\n}\ninterface ADoc extends A, mongoose.Document {   \n}\n```\n\nbut I get this error:\n_Interface 'ADoc' cannot simultaneously extend types 'A' and 'Document':\n Named properties '_id' of types 'A' and 'Document' are not identical._\n\nI can get around this error by making _id be either optional in both definitions, or required in both.\n\nI expect that the compiler can infer that _id is now required in ADoc. \nIs the current behavior of issuing an error the correct behavior? \nIf so, does it make sense to merge such fields so they become required?\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/1481/comments",
    "author": "psnider",
    "comments": [
      {
        "user": "DanielRosenwasser",
        "created_at": "2014-12-14T20:32:57Z",
        "body": "Hm, I'm not sure about the actual semantics as per the spec behind this (a little hard for me to access it), but if you explicitly declare `_id` in `ADoc`, you should be able to get rid of this error.\n\n``` TypeScript\ninterface Document {\n    _id: string;\n}\n\ninterface A {\n    _id?: string;\n}\n\ninterface ADoc extends A, Document {\n    _id: string;\n}\n```\n"
      },
      {
        "user": "psnider",
        "created_at": "2014-12-14T22:00:25Z",
        "body": "I followed your advice, and placed _id in the merged classes explicitly, and this removed the errors.\nThanks.\n\nAs for the spec , I couldn't find anything in the spec that addresses this case.\nAnd regarding the semantics, it seems to me that optional may be satisfied by required, if\noptional is interpreted as \"might be present\", and required is interpreted as \"is present\".\nWhich is what your suggested fix does as well.\n"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2014-12-15T03:36:13Z",
        "body": "The spec addresses this in section 7.1:\n\n> The following constraints must be satisfied by an interface declaration or otherwise a compile-time error occurs:\n> - [...]\n> - Inherited properties with the same name must be identical (section 3.8.2).\n\nThe relevant definition of \"identical member\" at 3.8.2 is:\n\n> Two members are considered identical when\n> - they are public properties with identical names, **optionality**, and types,\n\nIn general we only ever merge properties when they are completely identical.\n"
      },
      {
        "user": "Igorbek",
        "created_at": "2014-12-15T23:47:23Z",
        "body": "@RyanCavanaugh so how does having merging field in target interface fix the error? Does it only check convertibility to interfaces extended from?\n"
      },
      {
        "user": "danquirk",
        "created_at": "2015-01-06T02:55:56Z",
        "body": "@Igorbek You've now overridden the declarations from the inherited members. The compiler then checks that with the overridden declaration ADoc is a subtype of A and a subtype of Document.\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2015-06-12T18:35:20Z",
        "body": "looks like no further information required. closing.\n"
      },
      {
        "user": "shrishailya",
        "created_at": "2018-02-28T14:01:24Z",
        "body": "Thanks @DanielRosenwasser "
      }
    ]
  },
  {
    "number": 1446,
    "title": "No common supertype between {optional, optional} and {required, absent}",
    "created_at": "2014-12-11T00:45:00Z",
    "closed_at": "2015-01-27T14:48:50Z",
    "labels": [
      "Bug",
      "Question",
      "Fixed",
      "Breaking Change",
      "Spec"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/1446",
    "body": "We made the change that an object type with a missing property cannot be a subtype of an object with an optional property. This made subtype choose better results in some cases, because it fixed cases of nonantisymmetry in the subtype relation. But now there are cases where you get an error in type argument inference because a pair of type has no common supertype.\n\n``` ts\ninterface I {\n    a?: string;\n    b?: string;\n}\n\nvar i: I;\n\nfunction foo<T>(p1: T, p2: T) { }\n\nfoo(i, { a: \"\" }); // Error because neither type is a supertype of the other\n```\n\nOne interpretation is that in this case `I` should be the common supertype. To make this happen, we would say that instead of a missing property being a supertype of an optional, it is a subtype. In this view, missing and required are both specific cases of optional, and optional is a supertype of both.\n\nAnother fix is a change in type argument inference. If finding a common supertype does not yield a result, we can have another round where we use assignability. In the above example, this would not produce an error, since the object literal is assignable to `I`. \n\nThe issue here is that it may lead to results that depend on the order of the arguments. Both would select the first type in the following case:\n\n``` ts\ninterface I1 {\n   a?: string\n}\ninterface I2 {\n   b?: string\n}\nvar i1: I1, i2: I2;\nfoo(i1, i2);\n```\n\nBoth proposed fixes would choose I1 because it is first, whereas now we at least get an error consistently no matter the argument order.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/1446/comments",
    "author": "JsonFreeman",
    "comments": [
      {
        "user": "ahejlsberg",
        "created_at": "2015-01-23T00:57:05Z",
        "body": "@JsonFreeman The thing that gets us in trouble here is that we regard an object literal as having a _complete_ type when in reality we only know about the properties that were actually specified.\n\nAnother way to think of it is that an object literal's type has a known set of required properties (those that were specified) and an infinite set of optional properties with any spelling and the value undefined. In that world view, the object literal `{ a: \"\" }` has a type that is a subtype of `{ a?: string; b?: string; }` because it has an phantom optional property `b` with the value undefined. An object literal's phantom optional properties would go away during widening (the same process that converts undefined and null types to the any type), so assigning `{ a: \"\" }` to a variable would produce an inferred type of `{ a: string }`.\n\nThis same process could be used as an alternative to #1774. We wouldn't need to copy missing properties from the contextual type as we could just rely on the phantom optional properties.\n"
      },
      {
        "user": "JsonFreeman",
        "created_at": "2015-01-23T02:02:26Z",
        "body": "If I understand you correctly, your point could be alternatively stated like the following. Given two types S and T, if p is an optional property in T that is missing in S, then:\n1. If S originated as an object literal, then S is a subtype of T (from the perspective of p)\n2. If S did not originate as an object literal, then T is a subtype of S (from the perspective of p)\n\nThe observation is that an object literal cannot express whether a property is optional or required, only if it is present or absent. So as long as it is present with the right type, or absent, it is fit to be a subtype of the optional.\n\nThe one thing I am concerned about is that in this scheme: Whether or not the type originated in an object literal can completely flip the relation. So consider the following:\n\n``` ts\ninterface WithOptional {\n    x?: string;\n}\nvar withOpt: WithOptional = {};\nvar withoutOpt1: {} = {};\nvar withoutOpt2 = {};\nfunction foo<T>(p1: T, p2: T) { }\nfoo(withOpt, withoutOpt1).x; // error\nfoo(withOpt, withoutOpt2).x; // no error\n```\n\nwithoutOpt1 has no properties, but withoutOpt2 has infinitely many optional properties of type undefined.\n"
      },
      {
        "user": "JsonFreeman",
        "created_at": "2015-01-23T02:08:49Z",
        "body": "Actually, reading your explanation again, I neglected the part about widening. So withoutOpt1 and withoutOpt2 actually would have the same type.\n\nSo the key difference between this and #1774 is that #1774 only happens when you contextually type, whereas this proposal happens when you don't widen. The latter happens in strictly more places I believe.\n"
      },
      {
        "user": "JsonFreeman",
        "created_at": "2015-01-23T02:16:51Z",
        "body": "One thing that occurs to me, is that the case where there are no inference candidates would give a different result with the new scheme:\n\n``` ts\ninterface WithOptional<T> {\n    x?: T;\n}\ndeclare function foo<T>(p1: WithOptional<T>): T;\nfoo({}); // Used to infer {}, now we would infer any\n\ninterface WithOptionalAndUnion<T> {\n     x?: T // primary\n     y: string | T; // secondary\n}\ndeclare function bar<T>(p1: WithOptionalAndUnion<T>): T;\nbar({ y: \"\" }); // Used to infer string, now we would infer any\n```\n"
      },
      {
        "user": "JsonFreeman",
        "created_at": "2015-01-23T02:19:21Z",
        "body": "But all in all, I do think this is a good idea.\n"
      },
      {
        "user": "JsonFreeman",
        "created_at": "2015-01-23T02:46:58Z",
        "body": "There is a case I can think of that the contextual typing idea #1774 fixes, but this proposal (by itself) does not:\n\n``` ts\ndeclare function foo(p: () => { x?: number }): number;\ndeclare function foo(p: any): any;\n\nvar result = foo(() => { return {}; }); //#1774 gives number, this proposal gives any\n```\n"
      },
      {
        "user": "JsonFreeman",
        "created_at": "2015-01-24T02:38:51Z",
        "body": "I thought about this some more, and discovered something very strange about this idea:\n\n``` ts\ndeclare function foo<T>(p1: T, p2: T): T;\nfoo({ a: \"\" }, { });\n```\n\nIntuitively, this would infer `{ }`. However, it sounds like your scheme would actually make this an error, because neither argument is a subtype of the other. This is because the object literal `{ }` would actually have a type like `{ a?: undefined }`. So it is not a supertype of `{ a: string }`, because undefined is not a supertype of string. But it's not a subtype either because an optional cannot be a subtype of a required property.\n"
      },
      {
        "user": "ahejlsberg",
        "created_at": "2015-01-24T15:19:16Z",
        "body": "@JsonFreeman No, your example ends up inferring `{}` as you would expect. Forget about the \"phantom\" properties and think of it this way instead: An object literal type is a subtype of of a type T even if the object literal type is missing some of the optional properties in T, but once the object literal type is widened to a regular type this is no longer the case. In your example. It is effectively as if object literal types play by the old rules (pre-#919) before widening.\n"
      },
      {
        "user": "ahejlsberg",
        "created_at": "2015-01-24T17:23:59Z",
        "body": "@JsonFreeman I've got a fix for this in #1795.\n"
      }
    ]
  },
  {
    "number": 1293,
    "title": "Extending an external module",
    "created_at": "2014-11-28T13:38:40Z",
    "closed_at": "2014-12-01T20:02:52Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/1293",
    "body": "I'm trying to extend an external node module:\n\n``` javascript\n// a) Use an import?\nimport System.Fs.Node = require('fs');\n\n// b) Hackery? \nvar System = System || {}\nvar System.Fs = System.Fs || {}\nvar System.Fs.Node = require('fs')\n\nmodule System.Fs.Node {\n\n    var path = require('path');\n\n    interface IfOptions_mkdir {\n        mode?: number\n        recursive: boolean\n    }\n\n    export function mkdirSync($path: string, $options: IfOptions_mkdir|number) {\n        try {\n...\n```\n\nAny thoughts on how I might/should be extending an external module?\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/1293/comments",
    "author": "jbondc",
    "comments": [
      {
        "user": "jbondc",
        "created_at": "2014-11-28T13:53:50Z",
        "body": "I think this could work, wins points for readability:\n\n``` javascript\nmodule System.Fs.Node {\n    export * from \"fs\";\n\n    export function mkdirSync($path: string, $options: IfOptions_mkdir|number) {\n     //...\n    }\n  }\n```\n"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2014-12-01T20:02:52Z",
        "body": "You can do this today:\n\nIn a separate .d.ts file:\n\n``` ts\ndeclare module \"fs\" {\n  stuff: number;\n}\n```\n\nIn your monkeypatcher:\n\n``` ts\n/// reference the above .d.ts file\nimport fs = require('fs');\nfs.stuff = 3;\n```\n\nI don't think we're going to add extra syntax for this since it's (hopefully?) not a common scenario.\n"
      },
      {
        "user": "jbrantly",
        "created_at": "2015-10-19T03:35:48Z",
        "body": "FWIW this no longer works when using node resolution and \"proper external modules\". The ambient module simply overrides any node-resolved one.\n"
      }
    ]
  },
  {
    "number": 1023,
    "title": "How to append method to Array.prototype with .d.ts",
    "created_at": "2014-11-01T07:07:15Z",
    "closed_at": "2014-11-01T08:46:48Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/1023",
    "body": "I need to append a method to Array.prototype such as  \n\n```\nArray.prototype.first = function(){\n    //blablabla\n}\n\n```\n\nHow to write this `.d.ts` file .\n\nThanks all \n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/1023/comments",
    "author": "WanderWang",
    "comments": [
      {
        "user": "DanielRosenwasser",
        "created_at": "2014-11-01T08:46:48Z",
        "body": "Hi there @WanderWang, it's just:\n\n``` TypeScript\ninterface Array<T> {\n    first(): T;\n}\n```\n\nThe declarations for `Array<T>` will merge.\n\nNote that in the future, questions relating to achieving tasks in TypeScript should be asked on sites such as StackOverflow, whereas our issue tracker is not the appropriate place to ask such questions.\n"
      },
      {
        "user": "WanderWang",
        "created_at": "2014-11-01T09:50:42Z",
        "body": "Thanks \n"
      }
    ]
  },
  {
    "number": 978,
    "title": "Types of property 'xxx' are incompatible",
    "created_at": "2014-10-28T11:37:29Z",
    "closed_at": "2015-06-12T18:41:44Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/978",
    "body": "I`m switching from TS 0.9.5 to 1.1 CTP and have this simplified .d.ts:\n\n``` ts\ninterface FooArray<T> extends Foo<T[]> {\n    subscribeTo(transform?: (val: any) => T): FooArray<T>;\n}\ninterface Foo<T> {\n    subscribeTo(transform?: (val: any) => T): Foo<T>;\n}\n```\n\nCompilation has failed failed with:\n error TS2429: Interface 'FooArray<T>' incorrectly extends interface 'Foo<T[]>':\n    Types of property 'subscribeTo' are incompatible:\n      Type '(transform?: (val: any) => T) => Foo<T>' is not assignable to type '(transform?: (val: any) => T[]) => Foo<T[]>':\n        Types of parameters 'transform' and 'transform' are incompatible:\n          Type '(val: any) => T' is not assignable to type '(val: any) => T[]':\n            Type 'T' is not assignable to type 'T[]':\n              Property 'length' is missing in type '{}'.\n\nNote that the TS 0.9.5 compiles the below code while 1.0/1.1-CTP does not.\n\nQuestions:\n1) Shouldn't FooArray.subscribeTo should be treated as an overload and added to the FooArray`s contract? I.e. FooArray will have two subscribeTo methods.\n2) How to fix it?\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/978/comments",
    "author": "ruslanmogilevskiy",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2014-10-28T15:03:28Z",
        "body": "We no longer merge overloads across members like in 0.9.5. The equivalent definition would be:\n\n``` ts\ninterface Foo<T> {\n    subscribeTo(transform?: (val: any) => T): Foo<T>;\n}\ninterface FooArray<T> extends Foo<T> {\n    subscribeTo(transform?: (val: any) => T): Foo<T>;\n    subscribeTo(transform?: (val: any) => T[]): FooArray<T>;\n}\n```\n"
      },
      {
        "user": "diegovilar",
        "created_at": "2015-03-20T12:54:07Z",
        "body": "@RyanCavanaugh Any specific reason for that? Makes it a copy/paste job to extend+overload interface members...\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2015-06-12T18:41:44Z",
        "body": "resolving overloads is order dependent, not merging results in a more predictable system.\n"
      }
    ]
  },
  {
    "number": 972,
    "title": "Release notes for TypeScript 1.1?",
    "created_at": "2014-10-27T13:35:32Z",
    "closed_at": "2015-04-21T06:36:10Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/972",
    "body": "Are there release notes for 1.1 somewhere that show what changed? I read on the roadmap and official blog post that it's a drop-in replacement and is faster, but is there more details than that?\n\nThanks,\n\nSam\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/972/comments",
    "author": "samuelneff",
    "comments": [
      {
        "user": "danquirk",
        "created_at": "2014-10-27T21:54:30Z",
        "body": "What sort of details are you looking for exactly? We rewrote the whole compiler so there're a lot of changes ;) You can browse the source and changeset history yourself as well.\n"
      },
      {
        "user": "csnover",
        "created_at": "2014-10-30T23:42:07Z",
        "body": "I asked for the same thing in #834 \n"
      },
      {
        "user": "mhegazy",
        "created_at": "2015-04-21T06:36:10Z",
        "body": "We have been keeping detailed release notes since then. Closing.\n"
      }
    ]
  },
  {
    "number": 969,
    "title": "v1.1.0.0: suggestion: support exporting types from within module to sever implementation dependencies",
    "created_at": "2014-10-26T01:20:20Z",
    "closed_at": "2015-04-21T06:49:12Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/969",
    "body": "I'm using commonjs modules on node.\n\nI want to find a way to hide **all** implementation details from users of my modules.\nBut I cannot figure out how to protect my users from the dependencies on modules that are required by my modules.\n\nFor example:\nI'm using nodemailer within a module I wrote.\nI don't want the user of my module to need to know the implementation, \nso I don't want them to have to reference or import nodemailer.\n\nMy module uses the **Transport** class from nodemailer.d.ts in its public interface.\nI can't find a way to export the nodemailer.Transport class from my module, as if it was defined in my module.\nI want my user to reference only my module (and not have to reference nodemailer).\n\nIs there a way to do this? (I can't find it.)\nIf not, I suggest adding a way to export the declarations of a module (nodemailer in this case) so the user can use them without referencing the implementation-specific module. Of course, the compiler would track the reference, in order to resolve type errors.\n\nFor example, I would like to be able to write code such as;\n\nMyModule.d.ts:\n\n```\n/// <reference path='nodemailer.d.ts' />\nexport nodemailer.Transport;\n```\n\nto make the symbol **Transport** available from my module, and then the user code might be:\n\n```\n/// <reference path='MyModule.d.ts' />\n\nfunction f() : Transport {...}\n```\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/969/comments",
    "author": "psnider",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2014-11-26T20:51:56Z",
        "body": "You can `export import` symbols from other modules (e.g. `export import t = Transport.Foo`). Does that solve your use case?\n"
      }
    ]
  },
  {
    "number": 958,
    "title": "Support prototype extension of built-in types",
    "created_at": "2014-10-24T21:48:08Z",
    "closed_at": "2014-10-24T23:24:37Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/958",
    "body": "I can extend the `String` interface like so:\n\n``` ts\ninterface String {\n  upper(): String;\n}\n```\n\nI would expect that I could then do:\n\n``` ts\nString.prototype.upper = String.prototype.toUpperCase;\n```\n\nOr:\n\n``` ts\nString.prototype.upper = String.prototype.upper || function() {\n  return this.toUpperCase();\n};\n```\n\nOr even this:\n\n``` ts\nvar foo: String = 'bar'; // Type 'String' is missing property 'upper' from type 'String'.\n```\n\nIt would be nice if the `string` keyword would, of course, accommodate this change as well.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/958/comments",
    "author": "jednano",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2014-10-24T22:04:22Z",
        "body": "All the code you wrote compiles without error.\n\nDid you write `interface String {` inside a module (internal or external)? That would declare a new type instead of extending the existing one.\n"
      },
      {
        "user": "jednano",
        "created_at": "2014-10-24T23:24:36Z",
        "body": "Ah, you are right. Sorry. Looks like I have to create a `d.ts` file and just extend the interface there. Now it all makes sense.\n"
      }
    ]
  },
  {
    "number": 888,
    "title": "Missing implicit any error for inferring an \"any\" implicitly as a type argument",
    "created_at": "2014-10-14T00:28:32Z",
    "closed_at": "2015-06-13T00:05:41Z",
    "labels": [
      "Won't Fix",
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/888",
    "body": "``` TS\nclass C<T> {\n    constructor(x: T);\n    constructor(x: T, y: T);\n    constructor(public x: T, public y?: T) { }\n}\n\nvar constructC: <T>(CConstructorFunction: new (x: T, y: T) => C<T>) => C<T>;\nvar x = constructC(C).x;\n```\n\nThe way the type argument inference rules work, we end up inferring to the T's in `CConstructorFunction` from the T's in C's constructor. But because C is generic, it gets instantiated with `any` for that process. We don't give an implicit any error in this case. Is this something we want to do?\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/888/comments",
    "author": "JsonFreeman",
    "comments": [
      {
        "user": "DanielRosenwasser",
        "created_at": "2015-04-23T21:30:04Z",
        "body": "Any reason `any` is inferred in this process instead of `{}`?\n"
      },
      {
        "user": "JsonFreeman",
        "created_at": "2015-04-23T21:38:21Z",
        "body": "It says this in Section 3.10.6 (Type Inference) in the spec. We are making inferences from S to T (in this case `C` to `new (x: T, y: T) => C<T>`. We hit the following bullet, which causes us to instantiate C with any.\n\n> If M is a construct signature and a corresponding construct signature N exists in S, N is instantiated with the Any type as an argument for each type parameter (if any) and inferences are made from parameter types in N to the corresponding parameter types in M for positions that are present in both signatures, and from the return type of N to the return type of M.\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2015-06-12T22:51:15Z",
        "body": "Should this be a bug instead?\n"
      },
      {
        "user": "JsonFreeman",
        "created_at": "2015-06-12T23:53:12Z",
        "body": "I guess. I'm not sure how we'd detect the implicit any here. We may have to have a different type to track the implicit any introduced by generic signature erasure, and then change it to a regular any at the end of the inference process, or when inferentially typing a parameter. I'm worried that the type would leak though.\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2015-06-12T23:56:42Z",
        "body": "I am inclined to punt on this one. it is rather complicated, we get the right type, but we miss the noImplicitAny warning.\n"
      },
      {
        "user": "JsonFreeman",
        "created_at": "2015-06-13T00:02:52Z",
        "body": "That is fine with me\n"
      }
    ]
  },
  {
    "number": 887,
    "title": "Missing implicit any error for accessing member off a generic class's prototype",
    "created_at": "2014-10-14T00:24:38Z",
    "closed_at": "2015-06-12T18:34:33Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/887",
    "body": "``` TS\nclass D<T> { \n    x: T;\n}\nvar x = D.prototype.x;\n```\n\n`x` implicitly has type `any`, but we give no error for it. Should this be an error?\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/887/comments",
    "author": "JsonFreeman",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2014-10-15T20:53:01Z",
        "body": "if it is flagged, what can you do to remedy that, not use prototype? there is no way to \"fix\" the error that I can think of..\nI think this is along the lines of the catch variable, that is always typed as any and we do not flag it either.\n"
      },
      {
        "user": "JsonFreeman",
        "created_at": "2014-10-15T21:43:13Z",
        "body": "Right, there would be no way out of this one.\n"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2014-10-15T23:12:40Z",
        "body": "Presumably you'd want to write `(<D<any>>(D.prototype)).x` ?\n"
      },
      {
        "user": "JsonFreeman",
        "created_at": "2014-10-15T23:14:40Z",
        "body": "I'm not sure how we would implement it to make that work. Merely accessing .prototype generates the offending `any`, and we'd have to have a notion of what causes that `any` to \"land somewhere\".\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2015-06-12T18:34:32Z",
        "body": "looks like we have no good answer, so i am inclined to punt on this.\n"
      }
    ]
  },
  {
    "number": 845,
    "title": "'protected' keyword.  When is this available?",
    "created_at": "2014-10-07T18:00:06Z",
    "closed_at": "2014-10-07T18:43:46Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/845",
    "body": "I just installed 1.1.0-1 but it doesn't seem to allow for the protected keyword.\n\nAlso, I'm curious if anyone knows how to update TypeScript support in WebStorm since it appears to have conflicting inspections for TypeScript.  'protected' is not allowed when using 'use strict'. :|\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/845/comments",
    "author": "electricessence",
    "comments": [
      {
        "user": "danquirk",
        "created_at": "2014-10-07T18:43:46Z",
        "body": "If you're referring to the Visual Studio release we just did (the CTP with 1.1) that was just focused on the performance improvements of the new compiler. New features (like protected, tuples, etc) will come in a future release but we don't have a specific date to announce. Naturally the latest compiler bits from GitHub do contain those features.\n\nAs far as WebStorm goes you'd have to ask those guys. I'm unfamiliar with their TypeScript plans regarding the new compiler and any language service work they plan to do.\n"
      }
    ]
  },
  {
    "number": 576,
    "title": "Definition files and globals",
    "created_at": "2014-08-31T19:55:04Z",
    "closed_at": "2014-09-02T19:29:09Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/576",
    "body": "Almost all definition files so readily available you know where, do a `declare module` or `declare var`. Isn't this a huge problem? If I forget to import an implementation of a declared module and then use it, compiler will never give me an error, but the app will crash horribly at run time.\n\nOne way I see how to solve this is to write definition files only with a `declare module \"topLevelName\"`, so you can't accidentally use it without requiring it first. But this creates a problem for things such as jQuery, because people tend to not `require` it but just put it into global context. In this case current approach is actually working correctly.\n\nI just can't seem to wrap my head around this huge limitation of the system. Am I missing something?\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/576/comments",
    "author": "ifeltsweet",
    "comments": [
      {
        "user": "DanielRosenwasser",
        "created_at": "2014-09-01T18:13:31Z",
        "body": "The idea of the definition files like those found on like DefinitelyTyped and elsewhere (for which we truly appreciate the effort, and are not shy about this :smiley:) is that the declarations are effectively like saying \"I have existing JavaScript code that conforms to this structure and these types.\" It's kind of like a header file in C.\n\nDefinition files are surprisingly flexible in what they can express - and they need to be so that they can express the rich approaches and patterns that library writers utilize, sometimes in an effort to achieve some common patterns that TypeScript itself facilitates. But because there's more than one way to do it, it can be very difficult to confirm and/or reconcile the effective type/value/namespace layout that a library uses with its respective definition file.\n\nAdditionally, like you said, much of the time, people just stitch files together without an explicit `require` or anything of the sort. `require` isn't even a standard thing in JS. Sometimes you even get declarations \"for free\" - think `lib.d.ts` which describes a sort of union/intersection of different values that exist by default in many JS runtimes. It doesn't seem like there's a good consistent rule for this sort of thing.\n\nYou have a good point. I've certainly been in the situation of futzing around with definition files and forgetting to `require` them. I'm just not entirely sure how well we could enforce something like this. Seems like work better served by a linter.\n"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2014-09-02T19:29:09Z",
        "body": "If you really wanted to do this \"correctly\", you would just split up the files:\n\n**jquery-core.d.ts**\n\n``` ts\ndeclare module __jquery {\n  /* .... */\n}\n```\n\n**jquery-internal.d.ts**\n\n``` ts\n/// <reference path=\"jquery-core.d.ts\" />\ndeclare var $: typeof __jquery;\n```\n\n**jquery.d.ts**\n\n```\n/// <reference path=\"jquery-core.d.ts\" />\nexport = __jquery;\n```\n\nThe benefit of being more restrictive about which symbols are introduced seems to not be outweighed by having multiple files to manage. Forgetting to import a thing results in a rather immediate runtime error, so it's not too hard to remember to do.\n"
      }
    ]
  },
  {
    "number": 536,
    "title": "Can contextual typing apply to merged declarations?",
    "created_at": "2014-08-26T21:01:11Z",
    "closed_at": "2015-08-05T21:49:06Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/536",
    "body": "Courtesy of @danquirk \n\n4.19 Contextual Typing says:\n\n> Contextual typing of an expression e by a type T proceeds as follows:\n> ·         ...\n> ·         If e is an expression of a function type that contains exactly one generic call signature and no other members, and T is a function type with exactly one non-generic call signature, then any inferences made for type parameters referenced by the parameters of T’s call signature are fixed (section 4.12.2) and, if e’s call signature can successfully be instantiated in the context of T’s call signature (section 3.8.5), e’s type is changed to a function type with that instantiated signature.\n> ·         Otherwise, e is processed without a contextual type.\n\nWhy do we have the restriction for 'no other members'? (as opposed to just no other call signatures). This section is for how to apply contextual typing in a case like:\n\n``` TypeScript\nmap(identity, xs);\n```\n\nwhere identity is a function from T -> T. It's not clear why this should be invalid if for example identity is a fundule which has some additional static properties tacked on which wouldn't affect contextual typing.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/536/comments",
    "author": "mhegazy",
    "comments": [
      {
        "user": "ahejlsberg",
        "created_at": "2015-08-05T21:49:06Z",
        "body": "We want to restrict the cases where we do this because it causes fixing of the type parameters, and therefore no further inferences for those type parameters.\n"
      }
    ]
  },
  {
    "number": 423,
    "title": "Usage of void type ",
    "created_at": "2014-08-11T12:05:01Z",
    "closed_at": "2014-08-11T19:17:04Z",
    "labels": [
      "By Design",
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/423",
    "body": "Why this is allowed ?\n\n``` typescript\ninterface A<T> {\n f(x:number,a: T);\n}\n\n<A<void>>(null).f(1); \n```\n\nWhile calling the function via variable not ?\n\n``` typescript\nvar a = <A<void>>(null);\na.f(1);\n```\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/423/comments",
    "author": "NN---",
    "comments": [
      {
        "user": "basarat",
        "created_at": "2014-08-11T12:10:36Z",
        "body": "> While calling the function via variable not ?\n\nIts not about the variable. Your assertion needs brackets (note no variable): \n\n``` ts\ninterface A<T> {\n f(x:number,a: T);\n}\n\n(<A<void>>(null)).f(1);  // Error\n```\n"
      },
      {
        "user": "NN---",
        "created_at": "2014-08-11T12:30:09Z",
        "body": "I see.\nIt means it is impossible to use 'void' here and call a function without passing 'undefined' argument explicitly. \n"
      },
      {
        "user": "basarat",
        "created_at": "2014-08-11T12:32:50Z",
        "body": "> It means it is impossible to use 'void' here and call a function without passing 'undefined' argument explicitly\n\nyes.\n\nIf you want to prevent `T` being `void` you can use `extends` e.g. \n\n``` ts\ninterface A<T extends Object> {\n f(x:number,a: T);\n}\n\n(<A<void>>(null)) // error \n```\n"
      }
    ]
  },
  {
    "number": 403,
    "title": "Should not emit unreferenced exported value import from unexported internal module",
    "created_at": "2014-08-08T01:23:00Z",
    "closed_at": "2014-09-02T13:49:47Z",
    "labels": [
      "Question",
      "Spec"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/403",
    "body": "``` TS\nmodule M {\n     module N {\n          export import i = M;\n     }\n}\n```\n\nWe should not emit \"var i = M;\" because it cannot be reached from the global namespace. N is not exported.\n\nTechnically this means M and N could be considered uninstantiated, but that is another level of optimization.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/403/comments",
    "author": "JsonFreeman",
    "comments": [
      {
        "user": "ahejlsberg",
        "created_at": "2014-09-02T13:49:47Z",
        "body": "Yes, we could potentially not emit the `N.i = M;` assignment, but it's not clear it is worthwhile. I would prefer not to make any changes here.\n"
      }
    ]
  },
  {
    "number": 327,
    "title": "TSC incorrectly selects overloaded method signature",
    "created_at": "2014-08-01T13:47:17Z",
    "closed_at": "2014-08-01T18:33:11Z",
    "labels": [
      "By Design",
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/327",
    "body": "Hi,\n\nI added a strongly typed jQuery.each method overload in order to perform type check when compiling my ts files:\n\n```\neach<T>(collection: { [key: string]: T }, callback: (indexInArray: string, valueOfElement: T) => any): any;   // Added by me\neach(collection: any, callback: (indexInArray: any, valueOfElement: any) => any): any;\n```\n\nWhen using this method, tsc doesn't perform type check and allows you to write a code that will fail at runtime. For example:\n\n```\n/// <reference path=\"../../Lib/jquery.d.ts\" />\nvar args: { [key: string]: number } = {};\n$.each(args, (index: number, val) => {\n    var chr = val.charAt(0);\n});\n```\n\nThere is no error at compile time, because val is treated as any. This happens because tsc chooses less specific overload with **any**s. However, I'd like to see a compilation error.\n\nI **do** see compilation error when I write it as:\n\n```\n$.each(args, (index, val) => {\n    var chr = val.charAt(0);\n});\n```\n\nWhy is that?\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/327/comments",
    "author": "chebum",
    "comments": [
      {
        "user": "danquirk",
        "created_at": "2014-08-01T18:33:11Z",
        "body": "The first overload cannot be picked given the type annotations you used in the first example. The callback says it is of type `(string,T)=>any` and you provided a `(number, any)=>void` so the first overload is skipped and the compiler looks for other matches in the overload set. The second overload does match since it all it requires is a value of any type and a function with 2 arguments, so `val` gets the type `any` and no error occurs.\n\nThe second example chooses the first overload because the `args` value you provided has a type that matches the first parameter and creates an inference of `number` for `T`. Since there are no type annotations on the function call the compiler will attempt to contextually type the arguments based on the overload it picked. So `val` is now treated as a number which of course does not have a `charAt` member.\n\nThe presence of an overload with `any` all over the place means that any calls to `each` will be extremely permissive since any combination of types will succeed as long as the arguments are a value plus a 2 argument callback function.\n"
      }
    ]
  },
  {
    "number": 266,
    "title": "Can't recognize methods of a form name.",
    "created_at": "2014-07-27T15:19:46Z",
    "closed_at": "2014-07-28T15:08:33Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/266",
    "body": "I was programatically submiting a form when I found this issue. Typescript doesn't recognized dynamic identifiers in \"document\". Then:\n\n`document.form1.submit()` throws an exception saying that \"form1\" doesn't exist in document.\n\nIf we do:\n\n`var form1: any;`\n\nor anything else it yet throws us an error. And it can't be corrected by defining as \n\n`var document.form1: any;\ndocument.form1.submit();`\n\nIt yet throws an error, but in this time is an error in parsing (TS1005).\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/266/comments",
    "author": "haskellcamargo",
    "comments": [
      {
        "user": "NoelAbrahams",
        "created_at": "2014-07-27T17:43:41Z",
        "body": "Here are some workarounds:\n\n``` TypeScript\n// Extend the native Document type\ninterface Document {\n\n    form1: HTMLFormElement;\n}\n\ndocument.form1.submit();\n\n\n// or\n(<HTMLFormElement>(<any>document).form1).submit();\n\n// or \n(<HTMLFormElement>document[\"form1\"]).submit();\n```\n\nQuestions on TypeScript usage should getter a quicker response from StackOverflow.\n"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2014-07-28T15:08:33Z",
        "body": "Please use StackOverflow for questions about TypeScript. Thanks!\n"
      }
    ]
  },
  {
    "number": 177,
    "title": "Module Implementation",
    "created_at": "2014-07-22T01:10:54Z",
    "closed_at": "2015-04-20T22:47:35Z",
    "labels": [
      "Question"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/177",
    "body": "Hi, I've noticed that the current typescript module implementation is different from the proposal in Ecmascript 6 - is this planned to be changed?\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/177/comments",
    "author": "hsdk123",
    "comments": [
      {
        "user": "danquirk",
        "created_at": "2014-07-22T02:34:46Z",
        "body": "We do intend to align TypeScript with ES6 in general, and specifically modules, once the ES6 spec is fully locked down.\n"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2015-04-20T22:47:35Z",
        "body": "Linking to #2242 and closing.\n"
      }
    ]
  },
  {
    "number": 59422,
    "title": "Debug Failure. Expected 55 <= 54",
    "created_at": "2024-07-25T11:38:54Z",
    "closed_at": "2024-07-29T20:31:17Z",
    "labels": [
      "Bug",
      "Help Wanted",
      "Fix Available"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/59422",
    "body": "### 🔎 Search Terms\n\nDebug Failure,Expected 55 <= 54\n\n### 🕗 Version & Regression Information\n\n- This is a crash in version 5.5.4\n\n### ⏯ Playground Link\n\n_No response_\n\n### 💻 Code\n\n```ts\r\nfunction identity<T>(arg: T: T {\r\n    return arg;\r\n}\r\n```\r\n\n\n### 🙁 Actual behavior\n\n```ts\r\n/usr/lib/node_modules/typescript/lib/tsc.js:120196\r\n      throw e;\r\n      ^\r\n\r\nError: Debug Failure. Expected 55 <= 54\r\n    at assertDiagnosticLocation (/usr/lib/node_modules/typescript/lib/tsc.js:13507:9)\r\n    at createFileDiagnostic (/usr/lib/node_modules/typescript/lib/tsc.js:17266:3)\r\n    at checkPotentialUncheckedRenamedBindingElementsInTypes (/usr/lib/node_modules/typescript/lib/tsc.js:80540:13)\r\n    at /usr/lib/node_modules/typescript/lib/tsc.js:84135:11\r\n    at addLazyDiagnostic (/usr/lib/node_modules/typescript/lib/tsc.js:84177:33)\r\n    at checkSourceFileWorker (/usr/lib/node_modules/typescript/lib/tsc.js:84126:7)\r\n    at checkSourceFile (/usr/lib/node_modules/typescript/lib/tsc.js:84087:5)\r\n    at checkSourceFileWithEagerDiagnostics (/usr/lib/node_modules/typescript/lib/tsc.js:84178:5)\r\n    at forEach (/usr/lib/node_modules/typescript/lib/tsc.js:32:22)\r\n    at getDiagnosticsWorker (/usr/lib/node_modules/typescript/lib/tsc.js:84197:5)\r\n```\n\n### 🙂 Expected behavior\n\nTSC should report a syntax error instead of crashing\n\n### Additional information about the issue\n\ntsconfig.json\r\n```json\r\n{\r\n  \"compilerOptions\": {\r\n    \"target\": \"ESNext\",\r\n    \"module\": \"CommonJS\",\r\n    \"moduleResolution\": \"Node\",\r\n    \"esModuleInterop\": true,\r\n    \"skipLibCheck\": true,\r\n    \"forceConsistentCasingInFileNames\": true,\r\n    \"lib\": [\"es2023\",\"dom\"],\r\n    \"noEmitOnError\":true\r\n  },\r\n  \"include\": [\r\n    \"TScorpus/*\"\r\n  ],\r\n  \"exclude\": [\r\n    \"node_modules\"\r\n  ]\r\n}\r\n```",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/59422/comments",
    "author": "Roise-yue",
    "comments": [
      {
        "user": "jakebailey",
        "created_at": "2024-07-25T22:26:37Z",
        "body": "> This is a crash in version 5.5.4\r\n\r\nI know you've been posting a bunch of crashes, but can you please use one of the options that the template asks for?\r\n\r\n- ~This is a crash~ (we should delete this option, honestly)\r\n- This changed between versions ______ and _______\r\n- This changed in commit or PR _______\r\n- This is the behavior in every version I tried, and I reviewed the FAQ for entries about _________\r\n- I was unable to test this on prior versions because _______\r\n\r\n\r\nInformation about whether or not a crash is \"new\" is pretty important."
      },
      {
        "user": "Roise-yue",
        "created_at": "2024-07-27T02:09:23Z",
        "body": "> > This is a crash in version 5.5.4\r\n> \r\n> I know you've been posting a bunch of crashes, but can you please use one of the options that the template asks for?\r\n> \r\n> * ~This is a crash~ (we should delete this option, honestly)\r\n> * This changed between versions ______ and _______\r\n> * This changed in commit or PR _______\r\n> * This is the behavior in every version I tried, and I reviewed the FAQ for entries about _________\r\n> * I was unable to test this on prior versions because _______\r\n> \r\n> Information about whether or not a crash is \"new\" is pretty important.\r\n\r\nThank you for the quick fix to the issue I submitted. I will provide more detailed information based on the template you provided when submitting the issue in the future."
      }
    ]
  },
  {
    "number": 58801,
    "title": "\"Move to file\" on global code unnecessarily imports/exports, generates invalid code",
    "created_at": "2024-06-07T17:14:03Z",
    "closed_at": "2024-06-19T00:24:24Z",
    "labels": [
      "Bug",
      "Help Wanted",
      "Effort: Moderate",
      "Domain: Refactorings"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/58801",
    "body": "```ts\r\n// main.ts\r\n\r\ninterface String {\r\n    malkovich(): string;\r\n}\r\n\r\n[|String.prototype.malkovich = function (): string {\r\n    return \"malkovich\";\r\n}|]\r\n```\r\n\r\n1. Select the range.\r\n2. Request \"move to a new file\"\r\n\r\n## Current\r\n\r\n```ts\r\n// newFile.ts\r\nimport { String } from \"./strs\";\r\n\r\nString.prototype.malkovich = function (): string {\r\n    return \"malkovich\";\r\n};\r\n\r\n// main.ts\r\nexport export export export export export export interface String {\r\n    malkovich(): string;\r\n}\r\n\r\nexport export export export export export \r\n```\r\n\r\n## Expected\r\n\r\n```ts\r\n// newFile.ts\r\nString.prototype.malkovich = function (): string {\r\n    return \"malkovich\";\r\n};\r\n\r\n// main.ts\r\ninterface String {\r\n    malkovich(): string;\r\n}",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/58801/comments",
    "author": "DanielRosenwasser",
    "comments": [
      {
        "user": "fatcerberus",
        "created_at": "2024-06-07T18:29:39Z",
        "body": "Wait, it really produces long strings of `export` keywords like that?  What the heck."
      },
      {
        "user": "nick-fallon",
        "created_at": "2024-06-10T07:27:40Z",
        "body": "This is very specific to Visual Studio Code dropdown menus. This cannot be reproduced as specified on other IDEs, such as Intellij/JetBrains.\r\n\r\nIn JetBrains, instead of the dropdown saying \"Move to a new file\", it says, \"Move class '\\<class-name\\> to file \\<class-name\\>.ts'\"\r\n\r\nSo, it seems to tie in to how the IDE is refactoring things."
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2024-06-10T17:45:23Z",
        "body": "The logic is provided from TypeScript's language server. It is possible that this is an issue with VS Code, but I don't see any evidence of that yet. It is more likely that JetBrains is providing its own refactorings that are not powered by our language service."
      }
    ]
  },
  {
    "number": 58265,
    "title": "JSDoc comment string with the keyword \"@private\" before import statement in JS file result in cryptic error TS1191 during compilation",
    "created_at": "2024-04-20T04:25:35Z",
    "closed_at": "2024-04-25T04:18:32Z",
    "labels": [
      "Bug",
      "Help Wanted"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/58265",
    "body": "### 🔎 Search Terms\n\ncomment import statement bug private\n\n### 🕗 Version & Regression Information\n\nVersion 5.4.5\r\n\r\nI am the author and maintainer of the `ejs` library, which is widely used and has to work in old JavaScript runtimes. I am exploring `tsc` as a possibility for writing more modern JS, but transpiling back to ES5 for release. I have a tsconfig with `allowJs` true, and a single JS file where the actual code is a single import statement, and running `tsc` on it resulted in a cryptic error message, ` TS1191: An import declaration cannot have modifiers.`\r\n\r\nAfter more than an hour of fruitlessly searching the Web, and trying different things, I finally realized that this error was happening because of a multi-line comments (specifically JSDoc), just above my import statement that contained the string `@private`.\r\n\r\n\r\n\r\n\n\n### ⏯ Playground Link\n\n_No response_\n\n### 💻 Code\n\nMinimal breaking example. Actual JSDoc in the comment is much more verbose, but does include `@private` as a reference to the namespace\r\n\r\n```js\r\n'use strict';\r\n\r\n/** @private */\r\n\r\nimport { foo } from './test.js';\r\n\r\nconsole.log(foo);\r\n```\r\n\n\n### 🙁 Actual behavior\n\nCompiler exits with `error TS1191: An import declaration cannot have modifiers.`\n\n### 🙂 Expected behavior\n\nI expected it to compile my file, because my file is valid JavaScript.\n\n### Additional information about the issue\n\n_No response_",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/58265/comments",
    "author": "mde",
    "comments": [
      {
        "user": "saram-aman",
        "created_at": "2024-04-20T13:50:20Z",
        "body": "@mde would you like to assign the task to me, i got a fix!"
      },
      {
        "user": "mde",
        "created_at": "2024-04-20T16:36:40Z",
        "body": "I do not appear to have the ability to assign an owner, presumably because I am not in the org? I am logged into GH, but there is no active UI around those actions."
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2024-04-25T04:18:53Z",
        "body": "Thanks @a-tarasyuk!"
      },
      {
        "user": "mde",
        "created_at": "2024-04-25T04:37:18Z",
        "body": "Thank you for fixing this, @a-tarasyuk!"
      }
    ]
  },
  {
    "number": 57590,
    "title": "Formatter should remove spaces between `...` and type name in tuple spread",
    "created_at": "2024-03-01T03:50:29Z",
    "closed_at": "2024-03-04T17:48:49Z",
    "labels": [
      "Suggestion",
      "Help Wanted",
      "Domain: Formatter",
      "Experience Enhancement"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/57590",
    "body": "### 🔎 Search Terms\n\nautoformat, spaces\n\n### 🕗 Version & Regression Information\n\n5.5.0-dev.20240229\n\n### ⏯ Playground Link\n\n_No response_\n\n### 💻 Code\n\n```ts\r\nlet a: [...     any[]];\r\n/**/           let b = 123;\r\n```\r\n\n\n### 🙁 Actual behavior\n\nDo not remove extra spaces.\n\n### 🙂 Expected behavior\n\n```ts\r\nlet a: [...any[]];\r\n/**/ let b = 123;\r\n```\n\n### Additional information about the issue\n\n_No response_",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/57590/comments",
    "author": "LiST-GIT",
    "comments": [
      {
        "user": "LiST-GIT",
        "created_at": "2024-03-01T03:51:36Z",
        "body": "vscode setting.json\r\n```json\r\n{\r\n    \"[typescriptreact]\": {\r\n        \"editor.defaultFormatter\": \"vscode.typescript-language-features\"\r\n    },\r\n}\r\n```"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2024-03-01T17:21:20Z",
        "body": "I'm not really sure if the `/**/    let` gap should be removed. Comments are generally \"ignored\" as best we can for format purposes, so it looks more like an indentation than anything else.\r\n\r\n`...     any` should definitely be trimmed, though"
      }
    ]
  },
  {
    "number": 57302,
    "title": "Cannot move symbols from tsx to ts files",
    "created_at": "2024-02-05T07:37:31Z",
    "closed_at": "2024-02-16T18:36:25Z",
    "labels": [
      "Bug",
      "Help Wanted"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/57302",
    "body": "* have tsx file with some function\r\n* select the function, invoke the \"move to file\" code action\r\n* the picker doesn't allow for ts files, only tsx files",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/57302/comments",
    "author": "jrieken",
    "comments": [
      {
        "user": "mjbvz",
        "created_at": "2024-02-05T16:09:39Z",
        "body": "Are they part of the same tsconfig project? We only show files within a project"
      },
      {
        "user": "mjbvz",
        "created_at": "2024-02-05T16:42:11Z",
        "body": "Actually pretty easy to repo:\n\n`foo.ts`\n```ts\nexport function foo() {\n    console.log('foo');\n}\n```\n\n`bar.tsx`\n```tsx\nexport function bar() {\n    console.log('bar');\n}\n```\n\nTry moving `bar`\n\n\n🐛  `foo.ts` is not shown"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2024-02-05T21:18:43Z",
        "body": "Presumably this is because the selection _might_ contain JSX tags, but we should just check for that"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2024-02-16T18:36:47Z",
        "body": "Thanks @a-tarasyuk!"
      }
    ]
  },
  {
    "number": 56401,
    "title": "\"Extract to type alias\" not available at end of span",
    "created_at": "2023-11-14T21:49:26Z",
    "closed_at": "2024-01-05T17:52:28Z",
    "labels": [
      "Bug",
      "Help Wanted",
      "Domain: Refactorings",
      "Effort: Casual"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/56401",
    "body": "```ts\r\ninterface Yadda<T> {\r\n    x: T\r\n}\r\n\r\nexport let blah: Yadda/*a*/<string>/*b*/;\r\n```\r\n\r\n**Expected**: At both `a` and `b`, *extract to type alias* is offered as a refactoring.\r\n**Actual**: Only `a` offers the refactoring.",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/56401/comments",
    "author": "DanielRosenwasser",
    "comments": [
      {
        "user": "babakks",
        "created_at": "2023-11-19T22:05:16Z",
        "body": "@DanielRosenwasser I've just submitted a PR for this. Please review it whenever you deem fit."
      }
    ]
  },
  {
    "number": 56007,
    "title": "Search with search engine to reduce duplicate issues",
    "created_at": "2023-10-06T04:59:33Z",
    "closed_at": "2024-04-22T15:43:51Z",
    "labels": [
      "Help Wanted"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/56007",
    "body": "### Acknowledgement\n\n- [X] I acknowledge that issues using this template may be closed without further explanation at the maintainer's discretion.\n\n### Comment\n\n**Problem:** You and I create duplicate issues not because one didn‘t search, but because the GitHub search engine sucks. Its search algorithm is defective that the actually relevant search results most often appear on page 5 or something because synonyms are not generally considered.\r\n\r\n**Solution:** Mention in both the CONTRIBUTING.md and the issue templates that, instead of searching in GitHub, search for `site:github.com/microsoft/TypeScript <your keywords>` in your favorite search engine. In most cases, relevant results should appear on the top even if one is not sure and doesn‘t include the correct terminology.",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/56007/comments",
    "author": "graphemecluster",
    "comments": [
      {
        "user": "MartinJohns",
        "created_at": "2023-10-06T05:34:43Z",
        "body": "Honestly, most people simply suck at searching for issues. They never bother looking up on how to search correctly. Even something simple as `in:title` can drastically improve the search result.\r\n\r\nThe GitHub issue search, while not being perfect, works fine. People are just too lazy or uneducated to use it."
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2023-10-06T16:56:06Z",
        "body": "Worth a shot I guess"
      }
    ]
  },
  {
    "number": 55694,
    "title": "Format issues",
    "created_at": "2023-09-09T16:39:09Z",
    "closed_at": "2023-09-12T18:36:05Z",
    "labels": [
      "Bug",
      "Help Wanted",
      "Effort: Moderate",
      "Domain: Formatter"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/55694",
    "body": "### 🔎 Search Terms\n\n\"autoformat\" \"?=\"\n\n### 🕗 Version & Regression Information\n\n- This is a bug which occurs on saving file. It is disappearing if I remove formatter settings in `settings.json`.\r\n  \r\n Eslint/Prettier complains on it as it `?` and `=` should be separate in such cases.\r\n\n\n### ⏯ Playground Link\n\n_No response_\n\n### 💻 Code\n\n```ts\r\nexport class SomeError extends Error {\r\n    message: string;\r\n    data? = {};\r\n}\r\n```\r\n```json\r\n{ \r\n  \"[typescript]\": {\r\n    \"editor.defaultFormatter\": \"vscode.typescript-language-features\"\r\n  },\r\n}\r\n```\n\n### 🙁 Actual behavior\n\n`? =` is being joint into `?=`\n\n### 🙂 Expected behavior\n\nkeep `? =` as it is written\n\n### Additional information about the issue\n\n_No response_",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/55694/comments",
    "author": "rasul-sisutech",
    "comments": [
      {
        "user": "MartinJohns",
        "created_at": "2023-09-09T16:52:25Z",
        "body": "Sounds like an issue with eslint or prettier, not with TypeScript."
      },
      {
        "user": "fatcerberus",
        "created_at": "2023-09-09T18:15:21Z",
        "body": "@MartinJohns OP says eslint/prettier is *complaining* because the VSCode/TypeScript \"format on save\" feature has changed a property declaration to `data ?= {}` (which is not syntactically valid), if I’ve read it right."
      },
      {
        "user": "andrewbranch",
        "created_at": "2023-09-11T18:54:36Z",
        "body": "I have literally never seen `data? = {}` and didn’t know it was allowed, which is wild because it seems like legitimately useful syntax"
      }
    ]
  },
  {
    "number": 54956,
    "title": "'Convert named export to default export' removes type-information",
    "created_at": "2023-06-29T15:00:14Z",
    "closed_at": "2023-10-08T13:23:40Z",
    "labels": [
      "Bug",
      "Help Wanted"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/54956",
    "body": "Type: <b>Bug</b>\r\n\r\n1. select a  type annotated named export in a tsx file   \r\n1. hit `ctrl+.`\r\n1. select 'Convert named export to default export' \r\n1. observe how your type info is discarded \r\n\r\nbefore:\r\n```tsx \r\nexport const LabelList: React.FC<{ labelIds: number[] }> = ({ labelIds }) => {\r\n  const labels = useSelector<Types.RootState, LabelsState>(\r\n    ({ labels }) => labels,\r\n  );\r\n  return (\r\n    <div>\r\n      {labelIds.length ? (\r\n        labelIds.map(l => labels![l]).map(l => <LabelToken label={l} />)\r\n      ) : (\r\n        <small className={styles.noDescription}>No labels</small>\r\n      )}\r\n    </div>\r\n  );\r\n};\r\n```\r\n\r\nafter:\r\n```tsx\r\nexport default ({ labelIds }) => {\r\n  const labels = useSelector<Types.RootState, LabelsState>(\r\n    ({ labels }) => labels,\r\n  );\r\n\r\n  return (\r\n    <div>\r\n      {labelIds.length ? (\r\n        labelIds.map(l => labels![l]).map(l => <LabelToken label={l} />)\r\n      ) : (\r\n        <small className={styles.noDescription}>No labels</small>\r\n      )}\r\n    </div>\r\n  );\r\n};\r\n```\r\n \r\ninlining the type-annotations in a default export may not be possible (im not sure), but an intemediate variable can be exported as a default  \r\n\r\nVS Code version: Code 1.79.2 (695af097c7bd098fbf017ce3ac85e09bbc5dda06, 2023-06-14T08:59:55.818Z)\r\nOS version: Linux x64 6.2.6-76060206-generic\r\nModes:\r\n\r\n<details>\r\n<summary>System Info</summary>\r\n\r\n|Item|Value|\r\n|---|---|\r\n|CPUs|AMD Ryzen 7 5800U with Radeon Graphics (16 x 3547)|\r\n|GPU Status|2d_canvas: enabled<br>canvas_oop_rasterization: disabled_off<br>direct_rendering_display_compositor: disabled_off_ok<br>gpu_compositing: enabled<br>multiple_raster_threads: enabled_on<br>opengl: enabled_on<br>rasterization: enabled<br>raw_draw: disabled_off_ok<br>video_decode: enabled<br>video_encode: disabled_software<br>vulkan: disabled_off<br>webgl: enabled<br>webgl2: enabled<br>webgpu: disabled_off|\r\n|Load (avg)|2, 1, 1|\r\n|Memory (System)|13.49GB (1.87GB free)|\r\n|Process Argv|--unity-launch --crash-reporter-id f14012b5-d0f7-448a-910a-706fee85982f|\r\n|Screen Reader|no|\r\n|VM|0%|\r\n|DESKTOP_SESSION|pop|\r\n|XDG_CURRENT_DESKTOP|Unity|\r\n|XDG_SESSION_DESKTOP|pop|\r\n|XDG_SESSION_TYPE|x11|\r\n</details><details><summary>Extensions (46)</summary>\r\n\r\nExtension|Author (truncated)|Version\r\n---|---|---\r\njest-snippets|and|1.9.1\r\nvscode-zipfs|arc|3.0.0\r\nvscode-toggle-quotes|Bri|0.3.6\r\nvscode-eslint|dba|2.4.2\r\nes7-react-js-snippets|dsz|4.4.3\r\nprettier-vscode|esb|9.16.0\r\ncode-runner|for|0.12.0\r\nshell-format|fox|7.2.5\r\ngitlab-workflow|Git|3.68.0\r\neasy-snippet|inu|0.6.3\r\nplantuml|jeb|2.17.5\r\nbetter-shellscript-syntax|jef|1.6.1\r\nbash-ide-vscode|mad|1.37.0\r\ndirenv|mkh|0.14.0\r\nvscode-docker|ms-|1.25.1\r\nisort|ms-|2022.8.0\r\npython|ms-|2023.10.1\r\nvscode-pylance|ms-|2023.6.40\r\njupyter|ms-|2023.5.1101742258\r\njupyter-keymap|ms-|1.1.2\r\njupyter-renderers|ms-|1.0.15\r\nvscode-jupyter-cell-tags|ms-|0.1.8\r\nvscode-jupyter-slideshow|ms-|0.1.5\r\nremote-containers|ms-|0.295.0\r\nremote-ssh|ms-|0.102.0\r\nremote-ssh-edit|ms-|0.86.0\r\nremote-explorer|ms-|0.4.0\r\nsqltools|mtx|0.28.0\r\nvscode-jest|Ort|5.2.3\r\nvscode-versionlens|pfl|1.5.0\r\nbash-extension-pack|pin|2.0.0\r\nvscode-react-refactor|pla|1.1.3\r\nansible|red|2.4.78\r\nvscode-yaml|red|1.13.0\r\nvscode-gitweblinks|red|2.9.2\r\nbash-debug|rog|0.3.9\r\nshebang-snippets|rpi|0.1.4\r\njs-snippets|run|0.2.6\r\nrust-analyzer|rus|0.3.1566\r\nvscode-taskexplorer|spm|2.13.2\r\nshellcheck|tim|0.32.6\r\njinja|who|0.0.8\r\nchange-case|wma|1.0.0\r\nJavaScriptSnippets|xab|1.8.0\r\ncursor-align|yo1|1.1.0\r\nmarkdown-pdf|yza|1.4.4\r\n\r\n\r\n</details><details>\r\n<summary>A/B Experiments</summary>\r\n\r\n```\r\nvsliv368:30146709\r\nvsreu685:30147344\r\npython383:30185418\r\nvspor879:30202332\r\nvspor708:30202333\r\nvspor363:30204092\r\nvslsvsres303:30308271\r\nvserr242cf:30382550\r\npythontb:30283811\r\nvsjup518:30340749\r\npythonptprofiler:30281270\r\nvshan820:30294714\r\nvstes263:30335439\r\nvscod805:30301674\r\nbinariesv615:30325510\r\nbridge0708:30335490\r\nbridge0723:30353136\r\nvsaa593:30376534\r\npythonvs932:30410667\r\npy29gd2263:30776702\r\nvsclangdc:30486549\r\nc4g48928:30535728\r\ndsvsc012:30540252\r\npynewext54:30695312\r\nazure-dev_surveyone:30548225\r\nvscccc:30610679\r\n3biah626:30602489\r\npyind779:30671433\r\n89544117:30613380\r\npythonsymbol12:30671437\r\n2i9eh265:30646982\r\nshowlangstatbar:30737416\r\nvsctsb:30748421\r\npythonms35:30701012\r\n03d35959:30757346\r\n57b77579:30736110\r\npythonfmttext:30731395\r\npythoncmv:30756943\r\nfixshowwlkth:30771522\r\npythongtdpath:30769146\r\ni26e3531:30769768\r\ndh2dc718:30776458\r\npythonidxpt:30772539\r\npythondjangotscf:30772537\r\npythonnoceb:30776495\r\n\r\n```\r\n\r\n</details>\r\n\r\n<!-- generated by issue reporter -->",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/54956/comments",
    "author": "midgethoen",
    "comments": [
      {
        "user": "midgethoen",
        "created_at": "2023-06-30T07:52:17Z",
        "body": "I can give fixing/improving this a go if someone can give me a little guidance on where to start :)"
      },
      {
        "user": "awareness481",
        "created_at": "2023-10-07T09:58:04Z",
        "body": "I think this has been fixed, using the refactor test for the following code\r\n\r\n```ts\r\ntype A = any;\r\n\r\nexport const LabelList: A = () => {};\r\n```\r\n\r\nresults in\r\n\r\n```ts\r\ntype A = any;\r\n\r\nconst LabelList: A = () => {};\r\nexport default LabelList;\r\n```\r\n\r\nThe code from OP also seems to be formatted correctly."
      },
      {
        "user": "midgethoen",
        "created_at": "2023-10-08T13:23:40Z",
        "body": "@awareness481 , thnx for the headsup. i upgraded and verified that it now works as expected. awesome!"
      }
    ]
  },
  {
    "number": 54284,
    "title": "Move to file should be returned when on part of a const or function ",
    "created_at": "2023-05-16T23:56:54Z",
    "closed_at": "2023-08-04T17:00:35Z",
    "labels": [
      "Bug",
      "Help Wanted",
      "Domain: Refactorings",
      "Fix Available"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/54284",
    "body": "# Bug Report\r\n\r\n<!--\r\n  Please fill in each section completely. Thank you!\r\n-->\r\n\r\n### 🔎 Search Terms\r\n- refactor\r\n- refactoring\r\n\r\n### 🕗 Version & Regression Information\r\n\r\n5.1.0-dev.20230509\r\n\r\n### Repo\r\n\r\n1. Try running the move to file refactoring by explicitly requesting it when the cursor is on `const` or `function` in:\r\n\r\n```ts\r\nconst a = 1;\r\nfunction foo() { }\r\n```\r\n\r\n### bug\r\nThe move to file refactorings  are not returned in this case. You can only move these by selecting the entire statement: `const a = 1;` or `function foo() { }`\r\n\r\nI'd expect:\r\n\r\n- When refactorings are automatically requested (by moving the cursor around the file) we do not return these refactorings\r\n- However when the refactorings are manually requested, we should try to expand the current selection the the nearest enclosing symbol and return a move to file refactoring for it (if it can be moved)",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/54284/comments",
    "author": "mjbvz",
    "comments": [
      {
        "user": "gabritto",
        "created_at": "2023-05-24T19:23:41Z",
        "body": "This may or may not be the same bug, but I noticed that `Move to file` and `Move to new file` only show up in the list of refactorings if I select the whole statement including the semicolon, e.g. `|const x = 1;|`. If I select everything but miss the semicolon, it doesn't show up, e.g. `|const x = 1|;`"
      }
    ]
  },
  {
    "number": 53374,
    "title": "verbatimModuleSyntax = true switches incremental compilation to isolatedModules = true",
    "created_at": "2023-03-20T12:29:20Z",
    "closed_at": "2023-03-27T22:02:05Z",
    "labels": [
      "Bug",
      "Help Wanted"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/53374",
    "body": "Hello, the new option `verbatimModuleSyntax` has a very simple and clear description, but nothing is said here about how this option affects incremental compilation.\r\n\r\n```JS\r\ncompilerOptions = {\r\n  incremental: true,\r\n  isolatedModules: false,\r\n  verbatimModuleSyntax: true,\r\n}\r\n\r\n```\r\n\r\nWhen this option is enabled, when changing a file on which other files depend (they import this file), these dependent files are not added to the set of changed files, the same effect will be if you enable the `isolatedModules = true` option.\r\n\r\nI wanted to know if this is intended behavior or a bug?\r\nNot including dependent files in the set of changed files breaks some logic in our builder.",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/53374/comments",
    "author": "uasan",
    "comments": [
      {
        "user": "fatcerberus",
        "created_at": "2023-03-20T12:34:38Z",
        "body": "`isolatedModules: false, verbatimModuleSyntax: true` is not a valid combination - the latter implies the former.  In fact this set of options should produce an error to the effect that both of those options can't be specified at the same time."
      },
      {
        "user": "uasan",
        "created_at": "2023-03-20T14:37:56Z",
        "body": "Ok, then you need to give an error with this combination of settings"
      },
      {
        "user": "fatcerberus",
        "created_at": "2023-03-20T14:44:03Z",
        "body": "> Ok, then you need to give an error with this combination of settings\r\n\r\nLike I said, it already should be doing that now.\r\n\r\n> TS5104: Option 'isolatedModules' is redundant and cannot be specified with option 'verbatimModuleSyntax'"
      },
      {
        "user": "uasan",
        "created_at": "2023-03-20T14:57:26Z",
        "body": "unfortunately in version TS 5.0.2 i don't get this error"
      },
      {
        "user": "fatcerberus",
        "created_at": "2023-03-20T15:04:51Z",
        "body": "Huh.  Guess there is a bug, then, just not the one you thought it was 😄 "
      },
      {
        "user": "JoshuaKGoldberg",
        "created_at": "2023-03-27T18:15:56Z",
        "body": "Err, I get this locally with TS 5.0.2?\r\n\r\n```plaintext\r\n$ cat tsconfig.json\r\n{\r\n  \"compilerOptions\": {\r\n    \"incremental\": true,\r\n    \"isolatedModules\": true,\r\n    \"verbatimModuleSyntax\": true\r\n  }\r\n}\r\n```\r\n\r\n```plaintext\r\n$ tsc --version\r\nVersion 5.0.2\r\n```\r\n\r\n```plaintext\r\n$ tsc\r\ntsconfig.json:4:5 - error TS5104: Option 'isolatedModules' is redundant and cannot be specified with option 'verbatimModuleSyntax'.\r\n\r\n4     \"isolatedModules\": true,\r\n      ~~~~~~~~~~~~~~~~~\r\n\r\n\r\nFound 1 error in tsconfig.json:4\r\n```"
      }
    ]
  },
  {
    "number": 53138,
    "title": "CMD click on key doesn't navigate to references on typescript satisfies Record<>. ",
    "created_at": "2023-03-07T09:32:22Z",
    "closed_at": "2023-04-13T22:29:20Z",
    "labels": [
      "Bug",
      "Help Wanted"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/53138",
    "body": "Type: Bug\r\n\r\nSteps to reproduce:\r\n\r\n```typescript\r\nconst STRINGS = {\r\n  title: 'A Title',\r\n} satisfies Record<string,string>;\r\n\r\n//somewhere in app\r\nSTRINGS.title\r\n```\r\n\r\nCMD-click on `STRINGS.title works`; it takes me to the declaration.\r\nHowever, CMD click on title declared in the STRINGS object doesn't take me to the references.\r\n\r\nRight click + Go to references works. Removing the _satisfies_ fixes the issue.",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/53138/comments",
    "author": "simonsterckx",
    "comments": [
      {
        "user": "mjbvz",
        "created_at": "2023-03-07T17:11:11Z",
        "body": "The issue here is that `definitionAndBoundSpan` on `title` returns nothing on `title`. It returns a valid span if you remove the `satisfies`"
      }
    ]
  },
  {
    "number": 52751,
    "title": "'Extract type' from property signature with erroneous initializer causes assertion failure",
    "created_at": "2023-02-14T00:24:48Z",
    "closed_at": "2023-02-16T21:15:56Z",
    "labels": [
      "Bug",
      "Help Wanted",
      "Effort: Moderate",
      "Fix Available",
      "Old-Crawler-Detected"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/52751",
    "body": "```ts\r\ntype Foo = [|{\r\n    x: string = someString;\r\n}|]\r\n```\r\n\r\nRequest an \"extract to type alias\" refactoring on the specified `[|range|]`:\r\n\r\n```\r\n Debug Failure. False expression: Token end is child end\r\nError: Debug Failure. False expression: Token end is child end\r\n    at processChildNode (typescript/lib/tsserver.js:165873:17)\r\n    at typescript/lib/tsserver.js:165804:9\r\n    at visitNode2 (typescript/lib/tsserver.js:29284:18)\r\n    at forEachChildInPropertySignature (typescript/lib/tsserver.js:29340:167)\r\n    at forEachChild (typescript/lib/tsserver.js:29798:35)\r\n    at processNode (typescript/lib/tsserver.js:165801:5)\r\n    at processChildNode (typescript/lib/tsserver.js:165880:7)\r\n    at processChildNodes (typescript/lib/tsserver.js:165923:32)\r\n    at typescript/lib/tsserver.js:165817:9\r\n    at visitNodes (typescript/lib/tsserver.js:29289:14)\r\n    at forEachChildInTypeLiteral (typescript/lib/tsserver.js:29399:12)\r\n    at forEachChild (typescript/lib/tsserver.js:29798:35)\r\n    at processNode (typescript/lib/tsserver.js:165801:5)\r\n    at processChildNode (typescript/lib/tsserver.js:165880:7)\r\n    at typescript/lib/tsserver.js:165804:9\r\n    at visitNode2 (typescript/lib/tsserver.js:29284:18)\r\n    at forEachChildInTypeAliasDeclaration (typescript/lib/tsserver.js:29575:144)\r\n    at forEachChild (typescript/lib/tsserver.js:29798:35)\r\n    at processNode (typescript/lib/tsserver.js:165801:5)\r\n    at formatSpanWorker (typescript/lib/tsserver.js:165609:5)\r\n    at typescript/lib/tsserver.js:165549:105\r\n    at getFormattingScanner (typescript/lib/tsserver.js:164365:15)\r\n    at Object.formatNodeGivenIndentation (typescript/lib/tsserver.js:165549:10)\r\n    at getFormattedTextOfNode (typescript/lib/tsserver.js:163762:43)\r\n    at format (typescript/lib/tsserver.js:163742:27)\r\n    at computeNewText (typescript/lib/tsserver.js:163743:219)\r\n    at typescript/lib/tsserver.js:163704:25\r\n    at mapDefined (typescript/lib/tsserver.js:2627:22)\r\n    at typescript/lib/tsserver.js:163702:28\r\n    at mapDefined (typescript/lib/tsserver.js:2627:22)\r\n    at Object.getTextChangesFromChanges (typescript/lib/tsserver.js:163696:12)\r\n    at ChangeTracker.getChanges (typescript/lib/tsserver.js:163585:35)\r\n    at ChangeTracker.with (typescript/lib/tsserver.js:163083:20)\r\n    at Object.getRefactorEditsToExtractType [as getEditsForAction] (typescript/lib/tsserver.js:156988:60)\r\n    at Object.getEditsForRefactor (typescript/lib/tsserver.js:156469:31)\r\n    at Object.getEditsForRefactor2 [as getEditsForRefactor] (typescript/lib/tsserver.js:135592:32)\r\n    at IpcIOSession.getEditsForRefactor (typescript/lib/tsserver.js:178779:49)\r\n    at getEditsForRefactor (typescript/lib/tsserver.js:177034:43)\r\n```",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/52751/comments",
    "author": "DanielRosenwasser",
    "comments": [
      {
        "user": "DanielRosenwasser",
        "created_at": "2023-02-14T00:28:27Z",
        "body": "As usual, this has to do with the visitor with `visitEachChild` not actually visiting the `initializer` property on `PropertySignature`s, even though `forEachChild` does.\r\n\r\nAnd as usual, it's awkward because `updatePropertySignature` doesn't give control over it. It really should either drop the property signature entirely or provide a mechanism to update it. I'd probably lean towards the latter"
      },
      {
        "user": "rbuckton",
        "created_at": "2023-02-15T21:19:27Z",
        "body": "`initializer` on a property signature is a grammar error and isn't part of a syntactically valid AST. Supporting it in `visitEachChild` would require adding it to the `updatePropertySignature` factory method, which I'm not a fan of. I may look into an alternate approach, as I'd eventually like to find a way to remove these grammar-error-only node properties from nodes to reduce memory overhead."
      },
      {
        "user": "rbuckton",
        "created_at": "2023-02-15T21:25:42Z",
        "body": "I don't think the issue is with `visitEachChild`, since new positions are assigned by the printer via a `TextChangesWriter`."
      },
      {
        "user": "rbuckton",
        "created_at": "2023-02-15T22:56:22Z",
        "body": "> I don't think the issue is with `visitEachChild`, since new positions are assigned by the printer via a `TextChangesWriter`.\r\n\r\nAh, never mind. Both the emitter and `visitEachChild` need to be fixed for this to work."
      }
    ]
  },
  {
    "number": 52370,
    "title": "Provide snippet completions for `@param` in JSDoc",
    "created_at": "2023-01-23T09:54:58Z",
    "closed_at": "2023-04-04T18:35:11Z",
    "labels": [
      "Suggestion",
      "Help Wanted",
      "Effort: Moderate",
      "Domain: Completion Lists",
      "Domain: JSDoc",
      "Fix Available"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/52370",
    "body": "```ts\r\n/**\r\n * @para$\r\n */\r\nfunction printValue(value, maximumFractionDigits) {\r\n}\r\n```\r\n\r\nToday, we provide the expected `@param` JSDoc tag completion.\r\n\r\nHowever, if we're going by the book with JSDoc, the name of the parameter is already known. Can we provide snippet completions that contain the name of the parameter?\r\n\r\nThoughts:\r\n\r\n1. This should work in both JS and TS.\r\n  1. In TS it should have a placeholder by the comment\r\n  2. In JS it should have a placeholder that starts on the type, followed by a placeholder at the comment\r\n2. I don't know (/remember) how this should work with destructuring.",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/52370/comments",
    "author": "DanielRosenwasser",
    "comments": [
      {
        "user": "ufukbakan",
        "created_at": "2023-01-27T13:25:37Z",
        "body": "snippet completors related to IDEs, not directly to typescript. However I guess you use VSCode and it already does what you want. \r\nWrite your function, go to the line just before your function, type ```/**``` then hit enter, it should autocomplete params and names"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2023-01-30T18:53:33Z",
        "body": "> snippet completors related to IDEs, not directly to typescript. \r\n\r\nTypeScript provides certain snippet completions for IDEs, such as object and class member completions and `switch`/`case` completions.\r\n\r\n> However I guess you use VSCode and it already does what you want.\r\n\r\nIt doesn't work if you have a preceding JSDoc comment declared using a `@typedef` or an `@overload` tag.\r\n\r\n```ts\r\n/** @typedef {string} Id */\r\n\r\n/**<- No comment scaffolding here\r\nfunction foo(x, y, z) {\r\n}\r\n```"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2023-01-30T19:01:41Z",
        "body": "Actually, that is itself TypeScript bug on the `docCommentTemplate` command - I likely wouldn't have filed this issue if TypeScript actually provided that."
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2023-02-04T01:37:50Z",
        "body": "I still think things like the `@type` tag and `@typedef` tag would be good as snippets, because I can never remember the names of these things."
      },
      {
        "user": "ufukbakan",
        "created_at": "2023-02-14T08:15:45Z",
        "body": "> > snippet completors related to IDEs, not directly to typescript.\r\n> \r\n> TypeScript provides certain snippet completions for IDEs, such as object and class member completions and `switch`/`case` completions.\r\n> \r\n> > However I guess you use VSCode and it already does what you want.\r\n> \r\n> It doesn't work if you have a preceding JSDoc comment declared using a `@typedef` or an `@overload` tag.\r\n> \r\n> ```ts\r\n> /** @typedef {string} Id */\r\n> \r\n> /**<- No comment scaffolding here\r\n> function foo(x, y, z) {\r\n> }\r\n> ```\r\n\r\nBest thing you can do right now is inserting the line ```_;```  after your type def. For example:\r\n```js\r\n/** @typedef {string} Id */\r\n_;\r\n/** <- will autocomplete\r\nfunction foo(x, y, z) {\r\n}\r\n```\r\nWhen finished coding you can replace ```_;```  lines with empty string using CTRL+H, I still think its about vscode not typescript"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2023-02-14T08:20:14Z",
        "body": "Thank you for the suggestions; however, I am a maintainer of the product and am aware of the workarounds."
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2023-02-24T23:27:49Z",
        "body": "Things like\r\n\r\n* `@type`\r\n* `@satisfies`\r\n\r\nand more might be worthwhile to offer as snippet completions here."
      }
    ]
  },
  {
    "number": 52233,
    "title": "Ambient modules declared with patterns are offered in path completions",
    "created_at": "2023-01-14T01:04:17Z",
    "closed_at": "2023-01-17T17:41:18Z",
    "labels": [
      "Bug",
      "Help Wanted",
      "Domain: Completion Lists",
      "Fix Available",
      "Effort: Casual"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/52233",
    "body": "```ts\r\n// globals.d.ts\r\ndeclare module \"*.css\";\r\n```\r\n\r\n```ts\r\n// index.ts\r\nimport * as yadda from \"$\";\r\n```\r\n\r\nRequest completions at `$`\r\n\r\n**Expected**: Do not offer `*.css` in completions.\r\n**Actual** We offer `*.css` in completions.",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/52233/comments",
    "author": "DanielRosenwasser",
    "comments": [
      {
        "user": "fatcerberus",
        "created_at": "2023-01-14T05:29:28Z",
        "body": "Out of curiosity, if you *do* accept the completion and import from `*.css`, do you get the types from that declaration?  Because that should also be fixed if so 😉 "
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2023-01-17T23:02:40Z",
        "body": "Thanks @a-tarasyuk!"
      }
    ]
  },
  {
    "number": 52177,
    "title": "Wrong space in type assertions when using array",
    "created_at": "2023-01-09T21:49:14Z",
    "closed_at": "2023-01-11T22:59:24Z",
    "labels": [
      "Bug",
      "Help Wanted",
      "Domain: Formatter"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/52177",
    "body": "*TS Template added by @mjbvz*\r\n\r\n**TypeScript Version**: 4.9.4\r\n\r\n**Search Terms**\r\n- format\r\n\r\n---\r\n\r\nType: <b>Bug</b>\r\n\r\nWhen formatting a ts file with \"typescript.format.insertSpaceAfterTypeAssertion\": true\r\nthe file should be like this:\r\n\r\n```ts\r\nlet a = <string> \"\";\r\nlet b = <number> 1;\r\nlet c = <any[]> [];\r\nlet d = <string[]> [];\r\nlet e = <string[]> [\"e\"];\r\n```\r\n\r\nbut, after formatting, the array ones get removed the space, and it becomes like this:\r\n\r\n```ts\r\nlet a = <string> \"\";\r\nlet b = <number> 1;\r\nlet c = <any[]>[];\r\nlet d = <string[]>[];\r\nlet e = <string[]>[\"e\"];\r\n```\r\n\r\nVS Code version: Code 1.74.2 (e8a3071ea4344d9d48ef8a4df2c097372b0c5161, 2022-12-20T10:27:19.253Z)\r\nOS version: Linux x64 5.19.0-28-generic\r\nModes:\r\nSandboxed: No\r\n\r\n<details>\r\n<summary>System Info</summary>\r\n\r\n|Item|Value|\r\n|---|---|\r\n|CPUs|Intel(R) Core(TM) i5-4670K CPU @ 3.40GHz (4 x 3666)|\r\n|GPU Status|2d_canvas: enabled<br>canvas_oop_rasterization: disabled_off<br>direct_rendering_display_compositor: disabled_off_ok<br>gpu_compositing: enabled<br>multiple_raster_threads: enabled_on<br>opengl: enabled_on<br>rasterization: enabled<br>raw_draw: disabled_off_ok<br>skia_renderer: enabled_on<br>video_decode: disabled_software<br>video_encode: disabled_software<br>vulkan: disabled_off<br>webgl: enabled<br>webgl2: enabled<br>webgpu: disabled_off|\r\n|Load (avg)|1, 1, 1|\r\n|Memory (System)|11.56GB (5.19GB free)|\r\n|Process Argv|--disable-extensions --crash-reporter-id 7fc8d030-ec7d-42f0-9204-5c18918eb561|\r\n|Screen Reader|no|\r\n|VM|0%|\r\n|DESKTOP_SESSION|ubuntu|\r\n|XDG_CURRENT_DESKTOP|Unity|\r\n|XDG_SESSION_DESKTOP|ubuntu|\r\n|XDG_SESSION_TYPE|x11|\r\n</details>Extensions disabled<details>\r\n<summary>A/B Experiments</summary>\r\n\r\n```\r\nvsliv368:30146709\r\nvsreu685:30147344\r\npython383:30185418\r\nvspor879:30202332\r\nvspor708:30202333\r\nvspor363:30204092\r\nvslsvsres303:30308271\r\npythonvspyl392:30443607\r\nvserr242:30382549\r\npythontb:30283811\r\nvsjup518:30340749\r\npythonptprofiler:30281270\r\nvshan820:30294714\r\nvstes263cf:30335440\r\npythondataviewer:30285071\r\nvscod805cf:30301675\r\nbinariesv615:30325510\r\nbridge0708:30335490\r\nbridge0723:30353136\r\ncmake_vspar411:30581797\r\nvsaa593cf:30376535\r\npythonvs932:30410667\r\ncppdebug:30492333\r\nvscaat:30438848\r\nvsclangdf:30486550\r\nc4g48928:30535728\r\ndsvsc012cf:30540253\r\nazure-dev_surveyone:30548225\r\npyindex848cf:30577861\r\nnodejswelcome1:30587005\r\n3biah626:30602489\r\n3d0df643:30613357\r\n89544117:30613380\r\nfim-prod:30623723\r\n\r\n```\r\n\r\n</details>\r\n\r\n<!-- generated by issue reporter -->",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/52177/comments",
    "author": "ouqilbo",
    "comments": [
      {
        "user": "DanielRosenwasser",
        "created_at": "2023-01-11T22:59:39Z",
        "body": "Thanks @a-tarasyuk!"
      }
    ]
  },
  {
    "number": 51225,
    "title": "Go-to-definition on `case` or `default` should jump to the containing `switch` statement if available.",
    "created_at": "2022-10-19T00:43:37Z",
    "closed_at": "2024-01-11T19:14:04Z",
    "labels": [
      "Help Wanted",
      "Good First Issue",
      "Experience Enhancement",
      "Domain: Symbol Navigation"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/51225",
    "body": "```ts\r\n/*END*/switch (null) {\r\n  /*START*/case null: break;\r\n}\r\n```\r\n\r\n```ts\r\n/*END*/switch (null) {\r\n  /*START*/default: break;\r\n}\r\n```\r\n\r\nThose should work.\r\n\r\nThe following should not have issues.\r\n\r\n```ts\r\nexport /*a*/default {}\r\n```\r\n\r\n```ts\r\nexport default { /*a*/case }\r\n/*b*/default;\r\n/*c*/case 42;\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/51225/comments",
    "author": "DanielRosenwasser",
    "comments": [
      {
        "user": "sviat9440",
        "created_at": "2022-10-20T06:49:43Z",
        "body": "If you try to go to the beginning of the SwitchStatement, there is a small problem: The position after the previous expression (including spaces, line breaks, and so on) is considered to be the beginning of the SwitchStatement\r\n\r\nTestCase:\r\n```\r\n////      switch (null) {\r\n////          case null: break;\r\n////      }\r\n////\r\n////      /*end*/switch (null) {\r\n////         [|/*start*/case|] null: break;\r\n////      }\r\n```\r\n\r\nResult:\r\n```\r\n// @Filename: /tests/cases/fourslash/goToDefinitionSwitch4.ts\r\n     switch (null) {\r\n         case null: break;\r\n     }/*ACTUAL*/\r\n\r\n     /*EXPECTED*/switch (null) {\r\n        case null: break;\r\n     }\r\n```\r\n\r\nI suggest going to the beginning of the block and not to the beginning of the SwitchStatement\r\n```\r\n////      switch (null) {\r\n////          case null: break;\r\n////      }\r\n////\r\n////      switch (null) /*end*/{\r\n////         [|/*start*/case|] null: break;\r\n////      }\r\n```\r\n\r\nOr:\r\n```\r\n////      switch (null) {\r\n////          case null: break;\r\n////      }\r\n////\r\n////      switch (/*end*/null) {\r\n////         [|/*start*/case|] null: break;\r\n////      }\r\n```"
      },
      {
        "user": "MohitBansal321",
        "created_at": "2023-02-22T06:28:43Z",
        "body": "close this issue if it fixed\r\n@DanielRosenwasser "
      },
      {
        "user": "Rohankeshav",
        "created_at": "2023-10-01T22:53:20Z",
        "body": "is the issue fixed?\r\n"
      }
    ]
  },
  {
    "number": 51223,
    "title": "Go-to-definition on `await`/`yield` should probably jump to the containing respective async function/generator",
    "created_at": "2022-10-19T00:26:57Z",
    "closed_at": "2022-12-20T21:30:00Z",
    "labels": [
      "Help Wanted",
      "Good First Issue",
      "Experience Enhancement",
      "Domain: Symbol Navigation"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/51223",
    "body": "Similar to #51222.\r\n\r\n```ts\r\nasync function outerAsyncFun() {\r\n  let af = /*END*/async () => {\r\n    /*START*/await Promise.resolve(0);\r\n  }\r\n}\r\n```\r\n\r\n```ts\r\nfunction* outerGen*() {\r\n  /*END*/function* gen() {\r\n    /*START*/yield 100;\r\n  }\r\n  return gen\r\n}\r\n```\r\n\r\nWe should probably do nothing in cases like top-level `await`, or where `await` does not have a direct corresponding `async` function, and `yield` does not have a direct corresponding generator.",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/51223/comments",
    "author": "DanielRosenwasser",
    "comments": [
      {
        "user": "fatcerberus",
        "created_at": "2022-10-19T01:19:31Z",
        "body": "I would expect GTD on `await` to jump to the `async` keyword of the containing function, in line with how e.g. VS C# intellisense highlights the `async` keyword (and incidentally, all the other `await`s in the same function) when you place the cursor on an `await`."
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2022-10-19T18:51:19Z",
        "body": "I guess maybe there's a catch with\r\n\r\n```ts\r\nclass Foo {\r\n  /*END1*/public /*END2*/async yadda() {\r\n    /*START*/await 10;\r\n  }\r\n}\r\n```\r\n\r\nI feel like the distance is not that big that it matters whether we pick `END1` or `END2`. I could go both ways.\r\n\r\nThinking about it some more, I wonder if it makes sense to always make the go-to-definition succeed, even if the containing function isn't async or a generator. If you're in the error case, it can be helpful to jump to whichever function contains the keyword."
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2022-10-19T18:52:29Z",
        "body": "Also, another fun test case based on the \"should not fail\" strategy\".\r\n\r\n```ts\r\nfunction* gen() {\r\n  /*END(???)*/class C { [/*START*/yield 10]() {} }\r\n}\r\n```"
      }
    ]
  },
  {
    "number": 51222,
    "title": "Go-to-definition on `return` statements should jump to the containing function declaration",
    "created_at": "2022-10-19T00:21:40Z",
    "closed_at": "2022-10-19T18:32:41Z",
    "labels": [
      "Help Wanted",
      "Good First Issue",
      "Experience Enhancement",
      "Domain: Symbol Navigation"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/51222",
    "body": "```ts\r\nfunction foo() {\r\n    return /*END*/() => {\r\n        /*START*/return 10;\r\n    }\r\n}\r\n```\r\n\r\nGo to definition on `START` should jump you up to the containing function.\r\n\r\nIt should be resilient to questionable placements of `return` and do nothing, as in the following cases.\r\n\r\n```ts\r\n/*a*/return;\r\n\r\n\r\nfunction foo() {\r\n    class Foo {\r\n       static { /*b*/return; }\r\n    }\r\n}\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/51222/comments",
    "author": "DanielRosenwasser",
    "comments": [
      {
        "user": "DanielRosenwasser",
        "created_at": "2022-10-19T18:34:09Z",
        "body": "Thank you @a-tarasyuk!"
      },
      {
        "user": "sheetalkamat",
        "created_at": "2022-10-19T18:50:26Z",
        "body": "@DanielRosenwasser Suggestion, we probably can get find all references to show all return statements and signature? \r\n"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2022-10-19T18:56:59Z",
        "body": "Agreed, I was thinking this last night too!"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2022-10-19T19:25:56Z",
        "body": "@sheetalkamat, I filed #51232 for that. I think the big question is whether it should just return whatever document highlights returns, or it should return a more-curated list."
      }
    ]
  },
  {
    "number": 49566,
    "title": "Implicit this.property completions not returned while writing property",
    "created_at": "2022-06-15T22:18:39Z",
    "closed_at": "2022-06-16T19:43:51Z",
    "labels": [
      "Bug",
      "Help Wanted",
      "Fix Available",
      "Effort: Casual"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/49566",
    "body": "# Bug Report\r\n\r\n<!--\r\n  Please fill in each section completely. Thank you!\r\n-->\r\n\r\n### 🔎 Search Terms\r\n\r\n- suggest / suggestions\r\n- completions \r\n- insertText\r\n\r\n### 🕗 Version & Regression Information\r\n\r\n4.8.0-dev.20220614, not a regression\r\n\r\n### 💻 Repo\r\n\r\nFor the following code:\r\n\r\n```ts\r\nclass Foo { \r\n    private _prop = 123;\r\n    public prop = _pr // trigger suggest here\r\n}\r\n```\r\n\r\nTrigger suggestions on the public version of prop\r\n\r\n### 🙁 Actual behavior\r\n\r\nNo suggestions shown.\r\n\r\n### 🙂 Expected behavior\r\n\r\nWe should return a suggestion for `_prop` that inserts `this._prop` when accepted. This is what happens when you trigger suggestions inside of method bodies",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/49566/comments",
    "author": "mjbvz",
    "comments": [
      {
        "user": "fatcerberus",
        "created_at": "2022-06-15T22:30:40Z",
        "body": "Somewhat off-topic but I always find it weird seeing `this` in a property initializer, because I tend to view the initializer as having static scope.  Similarly if I see `public x = Math.random()` I'll tend to think all instances will get the same value until I remember that's not how it works.  Having the initializer not be evaluated until the constructor is called--and then *evaluating it in constructor scope*--is counterintuitive given the structure of the code."
      }
    ]
  },
  {
    "number": 48277,
    "title": "Add parameter type inlay hints after `?` operator",
    "created_at": "2022-03-15T21:25:58Z",
    "closed_at": "2022-03-16T18:38:41Z",
    "labels": [
      "Bug",
      "Help Wanted",
      "Domain: Inlay Hints"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/48277",
    "body": "# Bug Report\r\n\r\n<!--\r\n  Please fill in each section completely. Thank you!\r\n-->\r\n\r\n### 🔎 Search Terms\r\n\r\n- typescript.inlayHints.parameterTypes.enabled\r\n \r\n### 🕗 Version & Regression Information\r\n\r\n4.7.0-dev.20220315\r\n\r\nNot a regression\r\n\r\n### 💻 Code\r\n\r\nIn VS Code, enable `typescript.inlayHints.parameterTypes.enabled`\r\n\r\n```ts\r\ninterface IFoo { \r\n    bar(x?: boolean): void;\r\n}\r\n\r\nconst a: IFoo = {\r\n    bar: function (x?): void {\r\n        throw new Error(\"Function not implemented.\");\r\n    }\r\n} \r\n```\r\n\r\n\r\n### 🙁 Actual behavior\r\n\r\nThe parameter type inlay hints are shown between `x` and `?`\r\n\r\n### 🙂 Expected behavior\r\n\r\nThe inlay hint should come after the `?`: `x? : boolean | undefined`\r\n\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/48277/comments",
    "author": "mjbvz",
    "comments": [
      {
        "user": "DanielRosenwasser",
        "created_at": "2022-03-16T18:39:18Z",
        "body": "Thank you @a-tarasyuk!"
      }
    ]
  },
  {
    "number": 48191,
    "title": "Quick-fix duplicates comments on \"Add definite assignment assertion to property\"",
    "created_at": "2022-03-09T12:48:58Z",
    "closed_at": "2022-03-17T16:57:10Z",
    "labels": [
      "Bug",
      "Help Wanted",
      "Good First Issue",
      "Domain: Quick Fixes"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/48191",
    "body": "Issue Type: <b>Bug</b>\r\n\r\nFirst all, congrats and really thank you for this great IDE. It's amazing so Kudos for your work.\r\nNow the small issue I've found. It's a really low-priority issue I think.\r\n\r\nLet say we have a 'class' definition with a property and an inline comment:\r\n```\r\nclass MyClass {\r\n  myField: string; // some comment\r\n}\r\n```\r\nThen typescript will complain\r\n```\r\nProperty 'myField' has no initializer and is not definitely assigned in the constructor.ts(2564)\r\n```\r\nand offer a quick fix: `Add definite assignment assertion to property 'myField: string;'`\r\n\r\nIf you accepts the quick fix, you will get the comment repeated twice (and that's not expected):\r\n```\r\nclass MyClass {\r\n  myField!: string; // some comment\r\n // some comment\r\n}\r\n```\r\n\r\nSame or similar issue you will have if the comment is in the previous line\r\n```\r\nclass MyClass {\r\n  // some comment\r\n  myField: string; \r\n}\r\n```\r\nor if it done with  /* */ type comment (in below example, you will get comment-1 and comment-2 twice):.\r\n```\r\nclass MyClass {\r\n  /* some comment 1 */\r\n  myField: string;   /* some comment 2*/\r\n}\r\n```\r\n\r\nWell that's it. Thank you again for your hard work.\r\n\r\nVS Code version: Code 1.64.2 (f80445acd5a3dadef24aa209168452a3d97cc326, 2022-02-09T22:00:56.651Z)\r\nOS version: Darwin arm64 21.3.0\r\nRestricted Mode: No\r\n\r\n<details>\r\n<summary>System Info</summary>\r\n\r\n|Item|Value|\r\n|---|---|\r\n|CPUs|Apple M1 Pro (10 x 24)|\r\n|GPU Status|2d_canvas: enabled<br>gpu_compositing: enabled<br>metal: disabled_off<br>multiple_raster_threads: enabled_on<br>oop_rasterization: enabled<br>opengl: enabled_on<br>rasterization: enabled<br>skia_renderer: disabled_off_ok<br>video_decode: enabled<br>webgl: enabled<br>webgl2: enabled|\r\n|Load (avg)|3, 3, 3|\r\n|Memory (System)|16.00GB (0.66GB free)|\r\n|Process Argv|--crash-reporter-id 26c4a453-e54c-4a09-a052-392fe2f5791a|\r\n|Screen Reader|no|\r\n|VM|0%|\r\n</details>Extensions: none<details>\r\n<summary>A/B Experiments</summary>\r\n\r\n```\r\nvsliv368:30146709\r\nvsreu685:30147344\r\npython383cf:30185419\r\nvspor879:30202332\r\nvspor708:30202333\r\nvspor363:30204092\r\npythonvspyl392:30443607\r\npythontb:30283811\r\npythonvspyt551cf:30345471\r\npythonptprofiler:30281270\r\nvshan820:30294714\r\nvstes263:30335439\r\nvscorecescf:30445987\r\npythondataviewer:30285071\r\nvscod805:30301674\r\npythonvspyt200:30340761\r\nbinariesv615:30325510\r\nbridge0708:30335490\r\nbridge0723:30353136\r\nvsaa593cf:30376535\r\nvsc1dst:30438360\r\npythonvs932:30410667\r\nwslgetstarted:30449410\r\nvsclayoutctrt:30448491\r\ndsvsc008:30440022\r\npythonvsnew555:30442236\r\nvsbas813:30436447\r\nvscscmwlcmc:30438804\r\nvscgsvid2:30447481\r\nhelix:30440343\r\ndockersurvey3cf:30446834\r\nvscaat:30438848\r\n\r\n```\r\n\r\n</details>\r\n\r\n<!-- generated by issue reporter -->",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/48191/comments",
    "author": "rafahoro",
    "comments": [
      {
        "user": "MQuy",
        "created_at": "2022-03-16T20:50:39Z",
        "body": "Hi, I would like to work on this bug :D"
      }
    ]
  },
  {
    "number": 48163,
    "title": "Do not issue ` Left side of comma operator is unused and has no side effects` error on `(0, expr)` this-removing pattern",
    "created_at": "2022-03-07T21:08:59Z",
    "closed_at": "2023-01-25T18:13:54Z",
    "labels": [
      "Bug",
      "Help Wanted",
      "Domain: Error Messages"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/48163",
    "body": "Both our and babel's output emits `(0, expr)` in many places to unbind the `this` from the call that's about to be done. Ergo, the `0, expr` pattern is _not_ without side-effects, and is, in fact, a _very_ highly used pattern that we probably shouldn't issue an error on. It's probably OK to special-case the literal-zero LHS as a signal to silence the error.",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/48163/comments",
    "author": "weswigham",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2022-03-08T15:59:13Z",
        "body": "I would prefer `0` as the left operand *and* the parent expression is a call"
      },
      {
        "user": "muuvmuuv",
        "created_at": "2022-10-14T07:02:05Z",
        "body": "Damn, any workaround for this? I am in a NX Workspace, and we are trying to compile a custom executor.\r\n\r\n```\r\n >  NX   ⨯ Unable to compile TypeScript:\r\n\r\n   apps/entergon/webpack.config.ts:9:19 - error TS2695: Left side of comma operator is unused and has no side effects.\r\n\r\n   9 const _default = (0, _webpack.createConfig)(\"entergon\", (config)=>{\r\n```"
      },
      {
        "user": "shicks",
        "created_at": "2022-12-21T17:46:02Z",
        "body": "This is a duplicate of #35866"
      },
      {
        "user": "shicks",
        "created_at": "2023-01-25T17:49:23Z",
        "body": "This should be able to be closed now that #51989 is merged."
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2023-01-25T18:13:54Z",
        "body": "Thanks!"
      }
    ]
  },
  {
    "number": 47989,
    "title": "TS Server fatal error:  Debug Failure. Text of property name cannot be read from non-literal-valued ComputedPropertyNames",
    "created_at": "2022-02-20T09:40:49Z",
    "closed_at": "2022-03-07T22:18:55Z",
    "labels": [
      "Bug",
      "Help Wanted",
      "Good First Issue",
      "Fix Available"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/47989",
    "body": "\nIssue Type: <b>Bug</b>\n\n❗️❗️❗️ Please fill in the sections below to help us diagnose the issue ❗️❗️❗️\n\n**TypeScript Version:** 4.7.0-dev.20220219\n\n**Steps to reproduce crash**\n1.\n2.\n3.\n\n**TS Server Log**\n❗️Server logging disabled. To help us fix crashes like this, please enable logging by setting:\n```json\n\"typescript.tsserver.log\": \"verbose\"\n```\nAfter enabling this setting, future crash reports will include the server log.\n\n**TS Server Error Stack**\nServer: `semantic`\n```\nError: Debug Failure. Text of property name cannot be read from non-literal-valued ComputedPropertyNames\n    at getTextOfPropertyName (/Users/cleverboy/.vscode/extensions/ms-vscode.vscode-typescript-next-4.7.20220219/node_modules/typescript/lib/tsserver.js:14844:33)\n    at /Users/cleverboy/.vscode/extensions/ms-vscode.vscode-typescript-next-4.7.20220219/node_modules/typescript/lib/tsserver.js:15400:32\n    at Array.filter (<anonymous>)\n    at getPropertyAssignment (/Users/cleverboy/.vscode/extensions/ms-vscode.vscode-typescript-next-4.7.20220219/node_modules/typescript/lib/tsserver.js:15398:41)\n    at getTsConfigPropArray (/Users/cleverboy/.vscode/extensions/ms-vscode.vscode-typescript-next-4.7.20220219/node_modules/typescript/lib/tsserver.js:15432:36)\n    at Object.getTsConfigPropArrayElementValue (/Users/cleverboy/.vscode/extensions/ms-vscode.vscode-typescript-next-4.7.20220219/node_modules/typescript/lib/tsserver.js:15423:32)\n    at fileIncludeReasonToRelatedInformation (/Users/cleverboy/.vscode/extensions/ms-vscode.vscode-typescript-next-4.7.20220219/node_modules/typescript/lib/tsserver.js:117131:41)\n    at processReason (/Users/cleverboy/.vscode/extensions/ms-vscode.vscode-typescript-next-4.7.20220219/node_modules/typescript/lib/tsserver.js:117071:58)\n    at Array.forEach (<anonymous>)\n    at createDiagnosticExplainingFile (/Users/cleverboy/.vscode/extensions/ms-vscode.vscode-typescript-next-4.7.20220219/node_modules/typescript/lib/tsserver.js:117051:91)\n    at addProgramDiagnosticExplainingFile (/Users/cleverboy/.vscode/extensions/ms-vscode.vscode-typescript-next-4.7.20220219/node_modules/typescript/lib/tsserver.js:117088:36)\n    at checkSourceFilesBelongToPath (/Users/cleverboy/.vscode/extensions/ms-vscode.vscode-typescript-next-4.7.20220219/node_modules/typescript/lib/tsserver.js:116712:25)\n    at /Users/cleverboy/.vscode/extensions/ms-vscode.vscode-typescript-next-4.7.20220219/node_modules/typescript/lib/tsserver.js:115131:295\n    at Object.getCommonSourceDirectory (/Users/cleverboy/.vscode/extensions/ms-vscode.vscode-typescript-next-4.7.20220219/node_modules/typescript/lib/tsserver.js:108383:105)\n    at getCommonSourceDirectory (/Users/cleverboy/.vscode/extensions/ms-vscode.vscode-typescript-next-4.7.20220219/node_modules/typescript/lib/tsserver.js:115131:44)\n    at verifyCompilerOptions (/Users/cleverboy/.vscode/extensions/ms-vscode.vscode-typescript-next-4.7.20220219/node_modules/typescript/lib/tsserver.js:116946:27)\n    at Object.createProgram (/Users/cleverboy/.vscode/extensions/ms-vscode.vscode-typescript-next-4.7.20220219/node_modules/typescript/lib/tsserver.js:115043:9)\n    at synchronizeHostData (/Users/cleverboy/.vscode/extensions/ms-vscode.vscode-typescript-next-4.7.20220219/node_modules/typescript/lib/tsserver.js:161959:26)\n    at Proxy.getProgram (/Users/cleverboy/.vscode/extensions/ms-vscode.vscode-typescript-next-4.7.20220219/node_modules/typescript/lib/tsserver.js:162091:13)\n    at ConfiguredProject.Project.updateGraphWorker (/Users/cleverboy/.vscode/extensions/ms-vscode.vscode-typescript-next-4.7.20220219/node_modules/typescript/lib/tsserver.js:167138:53)\n    at ConfiguredProject.Project.updateGraph (/Users/cleverboy/.vscode/extensions/ms-vscode.vscode-typescript-next-4.7.20220219/node_modules/typescript/lib/tsserver.js:167067:42)\n    at ConfiguredProject.updateGraph (/Users/cleverboy/.vscode/extensions/ms-vscode.vscode-typescript-next-4.7.20220219/node_modules/typescript/lib/tsserver.js:168102:63)\n    at updateProjectIfDirty (/Users/cleverboy/.vscode/extensions/ms-vscode.vscode-typescript-next-4.7.20220219/node_modules/typescript/lib/tsserver.js:168591:45)\n    at /Users/cleverboy/.vscode/extensions/ms-vscode.vscode-typescript-next-4.7.20220219/node_modules/typescript/lib/tsserver.js:170922:33\n    at callback (/Users/cleverboy/.vscode/extensions/ms-vscode.vscode-typescript-next-4.7.20220219/node_modules/typescript/lib/tsserver.js:168534:33)\n    at /Users/cleverboy/.vscode/extensions/ms-vscode.vscode-typescript-next-4.7.20220219/node_modules/typescript/lib/tsserver.js:168517:186\n    at /Users/cleverboy/.vscode/extensions/ms-vscode.vscode-typescript-next-4.7.20220219/node_modules/typescript/lib/tsserver.js:168549:30\n    at Object.forEach (/Users/cleverboy/.vscode/extensions/ms-vscode.vscode-typescript-next-4.7.20220219/node_modules/typescript/lib/tsserver.js:183:30)\n    at forEachResolvedProjectReferenceProjectWorker (/Users/cleverboy/.vscode/extensions/ms-vscode.vscode-typescript-next-4.7.20220219/node_modules/typescript/lib/tsserver.js:168540:23)\n    at forEachResolvedProjectReferenceProject (/Users/cleverboy/.vscode/extensions/ms-vscode.vscode-typescript-next-4.7.20220219/node_modules/typescript/lib/tsserver.js:168517:34)\n    at ProjectService.assignProjectToOpenedScriptInfo (/Users/cleverboy/.vscode/extensions/ms-vscode.vscode-typescript-next-4.7.20220219/node_modules/typescript/lib/tsserver.js:170921:29)\n    at /Users/cleverboy/.vscode/extensions/ms-vscode.vscode-typescript-next-4.7.20220219/node_modules/typescript/lib/tsserver.js:171249:97\n    at Object.flatMap (/Users/cleverboy/.vscode/extensions/ms-vscode.vscode-typescript-next-4.7.20220219/node_modules/typescript/lib/tsserver.js:508:25)\n    at ProjectService.applyChangesInOpenFiles (/Users/cleverboy/.vscode/extensions/ms-vscode.vscode-typescript-next-4.7.20220219/node_modules/typescript/lib/tsserver.js:171249:41)\n    at Session.handlers.ts.Map.ts.getEntries._a.<computed> (/Users/cleverboy/.vscode/extensions/ms-vscode.vscode-typescript-next-4.7.20220219/node_modules/typescript/lib/tsserver.js:172408:46)\n    at /Users/cleverboy/.vscode/extensions/ms-vscode.vscode-typescript-next-4.7.20220219/node_modules/typescript/lib/tsserver.js:174344:88\n    at IpcIOSession.Session.executeWithRequestId (/Users/cleverboy/.vscode/extensions/ms-vscode.vscode-typescript-next-4.7.20220219/node_modules/typescript/lib/tsserver.js:174335:28)\n    at IpcIOSession.Session.executeCommand (/Users/cleverboy/.vscode/extensions/ms-vscode.vscode-typescript-next-4.7.20220219/node_modules/typescript/lib/tsserver.js:174344:33)\n    at IpcIOSession.Session.onMessage (/Users/cleverboy/.vscode/extensions/ms-vscode.vscode-typescript-next-4.7.20220219/node_modules/typescript/lib/tsserver.js:174370:35)\n    at process.<anonymous> (/Users/cleverboy/.vscode/extensions/ms-vscode.vscode-typescript-next-4.7.20220219/node_modules/typescript/lib/tsserver.js:177005:31)\n    at process.emit (events.js:315:20)\n    at emit (internal/child_process.js:903:12)\n    at processTicksAndRejections (internal/process/task_queues.js:81:21)\n```\n\nVS Code version: Code 1.64.2 (f80445acd5a3dadef24aa209168452a3d97cc326, 2022-02-09T22:00:58.347Z)\nOS version: Darwin x64 19.6.0\nRestricted Mode: No\n\n<details>\n<summary>System Info</summary>\n\n|Item|Value|\n|---|---|\n|CPUs|Intel(R) Core(TM) i7-1068NG7 CPU @ 2.30GHz (8 x 2300)|\n|GPU Status|2d_canvas: enabled<br>gpu_compositing: enabled<br>metal: disabled_off<br>multiple_raster_threads: enabled_on<br>oop_rasterization: enabled<br>opengl: enabled_on<br>rasterization: enabled<br>skia_renderer: disabled_off_ok<br>video_decode: enabled<br>webgl: enabled<br>webgl2: enabled|\n|Load (avg)|3, 4, 4|\n|Memory (System)|32.00GB (0.85GB free)|\n|Process Argv|. --crash-reporter-id 5fd547a4-8095-4da3-b161-81501bd2f60f|\n|Screen Reader|no|\n|VM|0%|\n</details><details><summary>Extensions (50)</summary>\n\nExtension|Author (truncated)|Version\n---|---|---\nvscode-mini-book|bao|0.0.13\nvscode-styled-jsx|bla|2.1.1\nsimple-react-snippets|bur|1.2.6\ngallery|byt|0.5.2\nbytesec-vscode|byt|1.0.52\nthief-book|C-T|0.0.9\nthrift|cdu|0.0.1\nnpm-intellisense|chr|1.4.1\npath-intellisense|chr|2.8.0\nvscode-css-modules|cli|0.4.1\nes7-react-js-snippets|dsz|4.4.3\ngitlens|eam|11.7.0\ntslint|eg2|1.0.47\nvscode-highlight|fab|1.6.0\ncode-runner|for|0.11.7\nanes|gam|0.0.2\nlintlens|ghm|3.0.2\ngo|gol|0.31.1\nformat-modified|Gru|0.0.30\nbeautify|Hoo|1.5.0\njuejin|luz|0.2.24\nprettify-json|moh|0.0.3\nvscode-docker|ms-|1.19.0\nvscode-language-pack-zh-hans|MS-|1.64.7\npython|ms-|2022.0.1814523869\nvscode-pylance|ms-|2022.2.3\njupyter|ms-|2022.1.1301854968\njupyter-keymap|ms-|1.0.0\njupyter-renderers|ms-|1.0.6\nremote-containers|ms-|0.217.4\nvscode-typescript-next|ms-|4.7.20220219\nvscode-typescript-tslint-plugin|ms-|1.3.3\ndebugger-for-chrome|msj|4.13.0\nvscode-jest|Ort|4.2.1\nconvert-css-in-js|pau|1.1.3\nreader|ren|1.1.7\ncss-to-js|ris|0.2.1\nvs-code-prettier-eslint|rve|3.1.0\nstylelint|shi|0.51.0\ncode-spell-checker|str|2.1.7\nsass-indented|syl|1.8.19\ntabnine-vscode|Tab|3.5.25\nvsprettier|tee|1.0.0\npython|tht|0.2.3\nreact-redux-es6-snippets|tim|2.1.0\nvscode-jsx-style-languageserver|upp|1.0.0\nvscode-icons|vsc|11.10.0\nJavaScriptSnippets|xab|1.8.0\nReactSnippets|xab|2.4.0\njson|Zai|2.0.2\n\n\n</details><details>\n<summary>A/B Experiments</summary>\n\n```\nvsliv368cf:30146710\nvsreu685:30147344\npython383:30185418\nvspor879:30202332\nvspor708:30202333\nvspor363:30204092\npythonvspyl392:30425749\npythontb:30283811\npythonvspyt551:30345470\npythonptprofiler:30281270\nvshan820:30294714\nvstes263:30335439\npythondataviewer:30285071\nvscod805:30301674\npythonvspyt200:30340761\nbinariesv615:30325510\nbridge0708:30335490\nbridge0723:30353136\nvsaa593cf:30376535\nvsc1dst:30438360\npythonvs932:30410667\nwslgetstartedc:30433508\nvsclayoutctrt:30437039\nvsrem710:30416614\ndsvsc009:30440023\npythonvsnew555:30436484\nvsbas813:30436447\nvscscmwlcmt:30438805\nhelix:30440343\n\n```\n\n</details>\n\n<!-- generated by issue reporter -->",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/47989/comments",
    "author": "cleverboy32",
    "comments": [
      {
        "user": "DanielRosenwasser",
        "created_at": "2022-02-23T01:10:41Z",
        "body": "Hi, would you be able to provide your project or a minimal repro? In this case, I think your tsconfig might have been the most interesting piece to repro this."
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2022-02-23T23:10:52Z",
        "body": "Here's **a** repro.\r\n\r\n```json5\r\n{\r\n    [\"oops!\" + 42]: \"true\",\r\n    \"files\": [\r\n        \"nonexistentfile.ts\"\r\n    ]\r\n}\r\n```\r\n\r\nThen run `tsc`.\r\n\r\nBasically trigger an error with a non-existent file so that we launch into some recovery routine to give a nice error message in the `tsconfig.json`. The error condition is having a computed property.\r\n\r\nThe most straightforward fix would be to do a check before calling `getTextOfPropertyName`.\r\n\r\nA more resilient check might be to rewrite `getTextOfPropertyName` with overloads, or force it to take a parameter that specifies whether it should hard-error or return `undefined`. But I wouldn't go too crazy."
      }
    ]
  },
  {
    "number": 47417,
    "title": "Code fix crash  in JSDoc with strictPropertyInitialization",
    "created_at": "2022-01-13T00:37:41Z",
    "closed_at": "2022-01-16T21:44:07Z",
    "labels": [
      "Bug",
      "Help Wanted",
      "Domain: Quick Fixes",
      "Crash",
      "Fix Available",
      "Effort: Casual"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/47417",
    "body": "```ts\r\n// @strictPropertyInitialization: true\r\n\r\n////// @ts-check\r\n////\r\n////class C {\r\n////    /** @type {string} */\r\n////    foo;\r\n////\r\n////    constructor() {\r\n////        \r\n////    }\r\n////}\r\n```\r\n\r\nRequest code actions.\r\n\r\n```\r\nResponse received: getCodeFixes (73). Request took 3 ms. Success: false . Message: Error processing request. Cannot read property 'kind' of undefined\r\nTypeError: Cannot read property 'kind' of undefined\r\n    at Object.isUnionTypeNode ([USERDIR]\\AppData\\Local\\Programs\\Microsoft VS Code Insiders\\resources\\app\\extensions\\node_modules\\typescript\\lib\\tsserver.js:27948:21)\r\n    at addUndefinedType ([USERDIR]\\AppData\\Local\\Programs\\Microsoft VS Code Insiders\\resources\\app\\extensions\\node_modules\\typescript\\lib\\tsserver.js:153377:28)\r\n    at [USERDIR]\\AppData\\Local\\Programs\\Microsoft VS Code Insiders\\resources\\app\\extensions\\node_modules\\typescript\\lib\\tsserver.js:153371:92\r\n    at Function.ChangeTracker.with ([USERDIR]\\AppData\\Local\\Programs\\Microsoft VS Code Insiders\\resources\\app\\extensions\\node_modules\\typescript\\lib\\tsserver.js:144341:17)\r\n    at getActionForAddMissingUndefinedType ([USERDIR]\\AppData\\Local\\Programs\\Microsoft VS Code Insiders\\resources\\app\\extensions\\node_modules\\typescript\\lib\\tsserver.js:153371:60)\r\n    at Object.getCodeActions ([USERDIR]\\AppData\\Local\\Programs\\Microsoft VS Code Insiders\\resources\\app\\extensions\\node_modules\\typescript\\lib\\tsserver.js:153326:21)\r\n    at [USERDIR]\\AppData\\Local\\Programs\\Microsoft VS Code Insiders\\resources\\app\\extensions\\node_modules\\typescript\\lib\\tsserver.js:145527:77\r\n    at Object.flatMap ([USERDIR]\\AppData\\Local\\Programs\\Microsoft VS Code Insiders\\resources\\app\\extensions\\node_modules\\typescript\\lib\\tsserver.js:522:25)\r\n    at Object.getFixes ([USERDIR]\\AppData\\Local\\Programs\\Microsoft VS Code Insiders\\resources\\app\\extensions\\node_modules\\typescript\\lib\\tsserver.js:145527:23)\r\n    at [USERDIR]\\AppData\\Local\\Programs\\Microsoft VS Code Insiders\\resources\\app\\extensions\\node_modules\\typescript\\lib\\tsserver.js:160394:35\r\n    at Object.flatMap ([USERDIR]\\AppData\\Local\\Programs\\Microsoft VS Code Insiders\\resources\\app\\extensions\\node_modules\\typescript\\lib\\tsserver.js:522:25)\r\n    at Object.getCodeFixesAtPosition ([USERDIR]\\AppData\\Local\\Programs\\Microsoft VS Code Insiders\\resources\\app\\extensions\\node_modules\\typescript\\lib\\tsserver.js:160392:23)\r\n    at IOSession.Session.getCodeFixes ([USERDIR]\\AppData\\Local\\Programs\\Microsoft VS Code Insiders\\resources\\app\\extensions\\node_modules\\typescript\\lib\\tsserver.js:171880:64)\r\n    at Session.handlers.ts.Map.ts.getEntries._a.<computed> ([USERDIR]\\AppData\\Local\\Programs\\Microsoft VS Code Insiders\\resources\\app\\extensions\\node_modules\\typescript\\lib\\tsserver.js:170516:61)\r\n    at [USERDIR]\\AppData\\Local\\Programs\\Microsoft VS Code Insiders\\resources\\app\\extensions\\node_modules\\typescript\\lib\\tsserver.js:172193:88\r\n    at IOSession.Session.executeWithRequestId ([USERDIR]\\AppData\\Local\\Programs\\Microsoft VS Code Insiders\\resources\\app\\extensions\\node_modules\\typescript\\lib\\tsserver.js:172184:28)\r\n    at IOSession.Session.executeCommand ([USERDIR]\\AppData\\Local\\Programs\\Microsoft VS Code Insiders\\resources\\app\\extensions\\node_modules\\typescript\\lib\\tsserver.js:172193:33)\r\n    at IOSession.Session.onMessage ([USERDIR]\\AppData\\Local\\Programs\\Microsoft VS Code Insiders\\resources\\app\\extensions\\node_modules\\typescript\\lib\\tsserver.js:172219:35)\r\n    at Interface.<anonymous> ([USERDIR]\\AppData\\Local\\Programs\\Microsoft VS Code Insiders\\resources\\app\\extensions\\node_modules\\typescript\\lib\\tsserver.js:174824:31)\r\n    at Interface.emit (events.js:315:20)\r\n    at Interface._onLine (readline.js:337:10)\r\n    at Interface._normalWrite (readline.js:482:12)\r\n    at Socket.ondata (readline.js:194:10)\r\n    at Socket.emit (events.js:315:20)\r\n    at addChunk (internal/streams/readable.js:309:12)\r\n    at readableAddChunk (internal/streams/readable.js:284:9)\r\n    at Socket.Readable.push (internal/streams/readable.js:223:10)\r\n    at Pipe.onStreamRead (internal/stream_base_commons.js:188:23)\r\n```",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/47417/comments",
    "author": "DanielRosenwasser",
    "comments": [
      {
        "user": "DanielRosenwasser",
        "created_at": "2022-01-14T02:25:15Z",
        "body": "Haven't been able to get this one to test correctly. Maybe you can give a shot at getting fourslash to work @RyanCavanaugh. Here's what I managed to put together.\r\n\r\n```ts\r\n/// <reference path=\"./fourslash.ts\" />\r\n\r\n// @checkJs: true\r\n// @strictPropertyInitialization: true\r\n\r\n// @Filename: /foo.js\r\n//// //start\r\n//// class C {\r\n////     /** @type {string} */\r\n////     foo/*$*/;\r\n//// \r\n////     constructor() {}\r\n//// }\r\n\r\ngoTo.marker(\"$\");\r\nverify.codeFixAll({\r\n    fixId: \"addMissingPropertyUndefinedType\",\r\n    fixAllDescription: \"Add undefined type to all uninitialized properties\",\r\n    newFileContent: `//start\r\nclass C {\r\n    /** @type {string | undefined} */\r\n    foo/*$*/;\r\n\r\n    constructor() {}\r\n}\r\n`,\r\n});\r\n```"
      },
      {
        "user": "a-tarasyuk",
        "created_at": "2022-01-14T20:22:45Z",
        "body": "`fixStrictClassInitialization` doesn't support JavaScript files. \r\nIt contains three code actions `addMissingPropertyDefiniteAssignmentAssertions`, `addMissingPropertyUndefinedType`, `addMissingPropertyInitializer`. \r\n\r\n`addMissingPropertyDefiniteAssignmentAssertions` added `!` token which is not valid in JavaScript. \r\n`addMissingPropertyUndefinedType` doesn't support JSDoc types, only TypeScript. Do we need to support it in JavaScript?\r\n`addMissingPropertyInitializer` can be used in JavaScript, however, need to fix the resolving type from JSDoc tags, only question is - do we need to check the target version?\r\n\r\n/cc @DanielRosenwasser @RyanCavanaugh \r\n\r\n\r\n"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2022-01-14T20:27:48Z",
        "body": "Like the other issue, I could go either way on either supporting this or not supporting this.\r\n\r\nThe crash seems to be coming from the `addMissingPropertyUndefinedType`, and it's easy enough to get the effective type annotation for JSDoc (using `getEffectiveTypeAnnotationNode`), so making it work in JS is easy in theory.\r\n\r\nFor `addMissingPropertyDefiniteAssignmentAssertions`, I would not support the fix.\r\n\r\nFor `addMissingPropertyInitializer`, either works - though I don't know how useful the fix even is today."
      },
      {
        "user": "a-tarasyuk",
        "created_at": "2022-01-14T20:32:20Z",
        "body": "@DanielRosenwasser The main issue to support `addMissingPropertyUndefinedType` in JS will be replacing the JSDoc type. \r\n\r\n> For addMissingPropertyInitializer, either works - though I don't know how useful the fix even is today.\r\n\r\nWe can try to support `addMissingPropertyUndefinedType` and `addMissingPropertyInitializer` and completely disable `addMissingPropertyDefiniteAssignmentAssertions`. Or omit QF in JS.\r\n\r\n"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2022-01-14T20:52:35Z",
        "body": "Here's my preference:\r\n\r\n* Disable `addMissingPropertyDefiniteAssignmentAssertions` in JS\r\n* Disable `addMissingPropertyInitializer` in JS\r\n* Support `addMissingPropertyUndefinedType` in JS by using `getEffectiveTypeAnnotationNode`\r\n"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2022-01-16T21:44:20Z",
        "body": "Thanks @a-tarasyuk!"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2022-01-31T21:00:56Z",
        "body": "Cherry-pick didn't go through."
      }
    ]
  },
  {
    "number": 47076,
    "title": "Improve non-top-level import/export error, especially for JS",
    "created_at": "2021-12-09T00:53:24Z",
    "closed_at": "2022-02-09T21:19:30Z",
    "labels": [
      "Bug",
      "Fixed",
      "Help Wanted",
      "Good First Issue",
      "Domain: Error Messages"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/47076",
    "body": "ES imports and exports can only be used at the top level of a module. This is illegal:\r\n\r\n```ts\r\nfunction container() {\r\n  import 'fs'\r\n  export { container }\r\n  namespace N { }\r\n}\r\n```\r\n\r\nThe current errors for these three statements are vague and, for JS, contain irrelevant terms:\r\n\r\nActual:\r\n\r\n(1) \"An import declaration can only be used in a namespace or module.\"\r\n(2) \"An export declaration can only be used in a module.\"\r\n(3) \"A namespace declaration is only allowed in a namespace or module.\"\r\n\r\nExpected:\r\n\r\n(1) When the node is in a JS file, \"An import declaration can only be used at the top level of a module.\"\r\n  Otherwise, \"An import declaration can only be used at the top level of a namespace or module.\"\r\n(2) When the node is in a JS file, \"An export declaration can only be used at the top level of a module.\"\r\n  Otherwise, \"An export declaration can only be used at the top level of a namespace or module.\"\r\n(3) \"A namespace declaration is only allowed at the top level of a module.\"\r\n\r\nImplementation:\r\n`checkGrammarModuleElementContext` issues these errors. I don't know whether it's better to make it smarter or just avoid calling it for case (1).",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/47076/comments",
    "author": "sandersn",
    "comments": [
      {
        "user": "fatcerberus",
        "created_at": "2021-12-09T18:20:58Z",
        "body": "Isn’t `export` used inside namespaces too?  So (2) should probably be “An export declaration can only be used at the top level of module *or namespace*.”"
      },
      {
        "user": "vicente-s",
        "created_at": "2021-12-21T09:11:54Z",
        "body": "Hey everyone, I'd like to take on this issue."
      },
      {
        "user": "lokicodedaily",
        "created_at": "2022-01-02T05:53:03Z",
        "body": "can I work on this issue?"
      },
      {
        "user": "sandersn",
        "created_at": "2022-01-11T18:49:32Z",
        "body": "@lokicodedaily sure, although you might want to co-ordinate with @vicente-s."
      },
      {
        "user": "sandersn",
        "created_at": "2022-01-11T18:50:51Z",
        "body": "@fatcerberus Good point. I updated the Expected section."
      },
      {
        "user": "islandryu",
        "created_at": "2022-01-17T07:04:18Z",
        "body": "@sandersn \r\nI tried to fix it in #47087, but did I do something wrong in the PR procedure?\r\nI would be grateful for any feedback."
      },
      {
        "user": "sandersn",
        "created_at": "2022-01-26T22:05:11Z",
        "body": "@islandryu I'm backlogged on community PRs. I'll review it when I can."
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2022-02-09T21:43:52Z",
        "body": "Thank you @islandryu!"
      }
    ]
  },
  {
    "number": 46824,
    "title": "Some private identifier errors are duplicated and uninformative",
    "created_at": "2021-11-16T17:59:02Z",
    "closed_at": "2021-12-16T20:07:12Z",
    "labels": [
      "Bug",
      "Help Wanted",
      "Good First Issue"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/46824",
    "body": "From privateNameInInExpression.errors.txt:\r\n\r\n```\r\n            const b = #fiel in v; // Bad - typo in privateID\r\n                      ~~~~~\r\n!!! error TS2304: Cannot find name '#fiel'.\r\n                      ~~~~~\r\n!!! error TS2339: Property '#fiel' does not exist on type 'any'.\r\n            for (#field in v) { /**/ } // Bad - 'in' not allowed\r\n                 ~~~~~~\r\n!!! error TS1451: Private identifiers are only allowed in class bodies and may only be used as part of a class member declaration, property access, or on the left-hand-side of an 'in' expression\r\n                 ~~~~~~\r\n!!! error TS2406: The left-hand side of a 'for...in' statement must be a variable or a property access.\r\n```\r\n\r\nExpected: One error on each line of code: \"Cannot find name '#fiel'\" and \"The left-hand side of a 'for...in' statement must be a variable or property access.\"\r\nActual: Two errors on each line.\r\n\r\nThe cause is that `checkGrammarPrivateIdentifierExpression` does not check whether other errors might apply. From my most recent read of it, I think only the first error is actually valuable, and that the \"Cannot find name '#fiel'\" error can be issued elsewhere. It's not really a grammatical error in any case -- it's likely just issued there because the ES spec refers to these errors as syntactic.",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/46824/comments",
    "author": "sandersn",
    "comments": [
      {
        "user": "Andrewnt219",
        "created_at": "2021-12-06T20:24:20Z",
        "body": "Hi @sandersn, can I try to solve this one?"
      },
      {
        "user": "sandersn",
        "created_at": "2021-12-06T23:54:49Z",
        "body": "Go ahead; let me know if you need any help."
      },
      {
        "user": "Andrewnt219",
        "created_at": "2021-12-09T06:29:38Z",
        "body": "Sorry, it took me a while to understand the setup and flow of the project.\r\n\r\nFrom the issue, I assume you want to remove the \"Cannot find name '#fiel'\" when there is:\r\n\"The left-hand side of a 'for...in' statement must be a variable or property access.\" or \r\n\"Private identifiers are not allowed outside class bodies.\".\r\n\r\nFrom what I understand, the `checkGrammarPrivateIdentifierExpression` has 3 checks matching the 3 errors above, and it is only called when the expression syntax is private. So I cannot remove any of those if check because it affects other cases, but rather find a way to show only one of them in the case of multiple privateName errors?\r\n\r\n```ts\r\n// Code reference\r\n\r\nfunction checkGrammarPrivateIdentifierExpression(privId: PrivateIdentifier): boolean {\r\n    if (!getContainingClass(privId)) {\r\n        return grammarErrorOnNode(privId, Diagnostics.Private_identifiers_are_not_allowed_outside_class_bodies);\r\n    }\r\n    if (!isExpressionNode(privId)) {\r\n        return grammarErrorOnNode(privId, Diagnostics.Private_identifiers_are_only_allowed_in_class_bodies_and_may_only_be_used_as_part_of_a_class_member_declaration_property_access_or_on_the_left_hand_side_of_an_in_expression);\r\n    }\r\n    if (!getSymbolForPrivateIdentifierExpression(privId)) {\r\n        return grammarErrorOnNode(privId, Diagnostics.Cannot_find_name_0, idText(privId));\r\n    }\r\n    return false;\r\n}\r\n```\r\n"
      },
      {
        "user": "sandersn",
        "created_at": "2021-12-10T22:36:26Z",
        "body": "Having thought about it a little more, I think I'd like to see\r\n\r\n\"Property '#fiel' does not exist on type 'any'.\r\n\r\nfor the first error and\r\n\r\nThe left-hand side of a 'for...in' statement must be a variable or a property access.\r\n\r\nfor the second. For the first error, the check for \"cannot find name {0}\" in  checkGrammarPrivateIdentifierExpression needs to also check that `privId`'s parent isn't an `in` expression. In the same way, the check for \"Private identifiers are only allowed in class bodies\" should also check that `privId`'s parent isn't a `for...in` statement. That should avoid the duplicated errors.\r\n"
      },
      {
        "user": "Andrewnt219",
        "created_at": "2021-12-11T04:16:37Z",
        "body": "Thanks, it's pretty clear now. I'll try to send a PR tomorrow."
      }
    ]
  },
  {
    "number": 46810,
    "title": "Octal literal error is usually duplicated",
    "created_at": "2021-11-15T17:39:57Z",
    "closed_at": "2021-12-06T20:46:08Z",
    "labels": [
      "Bug",
      "Help Wanted",
      "Good First Issue",
      "Domain: Error Messages"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/46810",
    "body": "The binder issues an error on all octal literals that are in strict mode: inside a class or module.\r\nThe checker issues an error on all octal literal types, and octal literal values when the target is `es5` or higher or the value is in the initialiser of an enum member.\r\n\r\n```ts\r\nexport enum E {\r\n    A = 12 + 01\r\n}\r\nconst orbitol: 01 = 01\r\n```\r\n\r\nExpected: one error on each `01`.\r\nActual: Two errors on each `01`.\r\n\r\nThis means that octal literals nearly always get two errors, because most code targets es5 or higher and is inside a module.\r\n\r\nThe checker implementation is a bit flabby and inefficient, but is probably the best place to consolidate the errors -- and efficiency doesn't matter much for syntax that's hardly ever used. I don't think it would be difficult to re-create the equivalent of the binder's `inStrictMode` flag.",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/46810/comments",
    "author": "sandersn",
    "comments": [
      {
        "user": "jayeclark",
        "created_at": "2021-11-16T16:35:45Z",
        "body": "Hi @sandersn! I'm new to the repository (poking around in issues as a way to better understand the inner workings of Typescript.) I've found where the first duplicate error issue above arises and it seems like it might be most straightforward to fix within the binder. \r\n\r\nIf I'm interpreting the explanation above correctly, the conditional to issue an error for an octal literal in strict mode should first check that the target is < es5. (If the target is es5 or higher, a general error will be issued for the octal literal, so the strict mode error is unnecessary and redundant.) \r\n\r\nDoes that sound accurate?\r\n\r\nI'll open a draft PR so that the location in the code & the suggested solution are a little clearer, but please don't hesitate to give feedback if I'm off base."
      }
    ]
  },
  {
    "number": 46666,
    "title": "No outlining span returned for multiline comment",
    "created_at": "2021-11-03T16:48:13Z",
    "closed_at": "2021-11-04T19:43:01Z",
    "labels": [
      "Bug",
      "Help Wanted",
      "Domain: Outlining",
      "Effort: Casual"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/46666",
    "body": "# Bug Report\r\n\r\n### 🔎 Search Terms\r\n\r\n- getOutliningSpans\r\n- fold / folding\r\n\r\n### 🕗 Version & Regression Information\r\n4.5.0-dev.20211029\r\n\r\n\r\n### 💻 Repro\r\n\r\nFor the code:\r\n\r\n```js\r\n/*\r\nx\r\n*/\r\n\r\nconsole.log(1) \r\n```\r\n\r\nTry folding the multiline comment\r\n\r\n### 🐛  Repro\r\n\r\nNo outlining span returned\r\n\r\nOne is returned if you remove `console.log(1)`",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/46666/comments",
    "author": "mjbvz",
    "comments": [
      {
        "user": "zohaibmalik994",
        "created_at": "2021-11-03T16:53:02Z",
        "body": "Also @mjbvz  , I have a feature request to have an option to fold/unfold a selection of desired code. It can also fix a lot of such problems in future."
      },
      {
        "user": "andrewbranch",
        "created_at": "2021-11-03T23:14:33Z",
        "body": "Works if you put a space before `x`"
      }
    ]
  },
  {
    "number": 46529,
    "title": "Cannot read property 'escapedName' of undefined",
    "created_at": "2021-10-26T01:06:58Z",
    "closed_at": "2022-02-01T01:07:15Z",
    "labels": [
      "Bug",
      "Help Wanted",
      "Domain: JSDoc",
      "Domain: JavaScript",
      "Crash",
      "Effort: Casual"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/46529",
    "body": "# Bug Report\r\n\r\n<!--\r\n  Please fill in each section completely. Thank you!\r\n-->\r\n\r\n### 🔎 Search Terms\r\n\r\n- jsdoc\r\n- javascript\r\n\r\n### 🕗 Version & Regression Information\r\n\r\n4.5.0-dev.20211025\r\n\r\n### 💻 Repro\r\n\r\n1. Starting with the code:\r\n\r\n```ts\r\n/**\r\n * @typedef {{\r\n *  (a) => string\r\n * }} Callback2\r\n */\r\nfunction foo() { }\r\n```\r\n\r\n2. After the `a` inside the typedef, type `:x`\r\n\r\n### Bug\r\n\r\n\r\n```\r\n ERR <semantic> TypeScript Server Error (4.5.0-dev.20211025)\r\nCannot read property 'escapedName' of undefined\r\nTypeError: Cannot read property 'escapedName' of undefined\r\n    at getSignatureFromDeclaration (/Users/matb/projects/san/node_modules/typescript/lib/tsserver.js:57785:48)\r\n    at getThisTypeOfDeclaration (/Users/matb/projects/san/node_modules/typescript/lib/tsserver.js:54849:43)\r\n    at tryGetThisTypeAt (/Users/matb/projects/san/node_modules/typescript/lib/tsserver.js:69726:32)\r\n    at Object.tryGetThisTypeAt (/Users/matb/projects/san/node_modules/typescript/lib/tsserver.js:47036:32)\r\n    at getGlobalCompletions (/Users/matb/projects/san/node_modules/typescript/lib/tsserver.js:129361:48)\r\n    at tryGetGlobalSymbols (/Users/matb/projects/san/node_modules/typescript/lib/tsserver.js:129277:25)\r\n    at getCompletionData (/Users/matb/projects/san/node_modules/typescript/lib/tsserver.js:129030:22)\r\n    at Object.getCompletionsAtPosition (/Users/matb/projects/san/node_modules/typescript/lib/tsserver.js:128020:34)\r\n    at Proxy.getCompletionsAtPosition (/Users/matb/projects/san/node_modules/typescript/lib/tsserver.js:159572:35)\r\n    at IOSession.Session.getCompletions (/Users/matb/projects/san/node_modules/typescript/lib/tsserver.js:171037:64)\r\n    at Session.handlers.ts.Map.ts.getEntries._a.<computed> (/Users/matb/projects/san/node_modules/typescript/lib/tsserver.js:169882:61)\r\n    at /Users/matb/projects/san/node_modules/typescript/lib/tsserver.js:171686:88\r\n    at IOSession.Session.executeWithRequestId (/Users/matb/projects/san/node_modules/typescript/lib/tsserver.js:171677:28)\r\n    at IOSession.Session.executeCommand (/Users/matb/projects/san/node_modules/typescript/lib/tsserver.js:171686:33)\r\n    at IOSession.Session.onMessage (/Users/matb/projects/san/node_modules/typescript/lib/tsserver.js:171712:35)\r\n    at Interface.<anonymous> (/Users/matb/projects/san/node_modules/typescript/lib/tsserver.js:174317:31)\r\n    at Interface.emit (events.js:315:20)\r\n    at Interface._onLine (readline.js:337:10)\r\n    at Interface._normalWrite (readline.js:482:12)\r\n    at Socket.ondata (readline.js:194:10)\r\n    at Socket.emit (events.js:315:20)\r\n    at addChunk (internal/streams/readable.js:309:12)\r\n    at readableAddChunk (internal/streams/readable.js:284:9)\r\n    at Socket.Readable.push (internal/streams/readable.js:223:10)\r\n    at Pipe.onStreamRead (internal/stream_base_commons.js:188:23): Error: <semantic> TypeScript Server Error (4.5.0-dev.20211025)\r\n```",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/46529/comments",
    "author": "mjbvz",
    "comments": [
      {
        "user": "sandersn",
        "created_at": "2022-02-01T01:04:42Z",
        "body": "I can't repro this in a fresh folder running a tsserver built from `main` or `release-4.5`. I also tried in a JS file with a tsconfig that includes it. @mjbvz can you give more detail on your repro?\r\n\r\nHere's what I tried\r\n\r\n```\r\n$ mkdir ts-bug\r\n$ cd ts-bug\r\n$ touch foo.js\r\n$ code .\r\n```\r\n\r\nPaste in your example, then type `:x` after `a`. It completes to XMLDocument instead of crashing for me."
      },
      {
        "user": "mjbvz",
        "created_at": "2022-02-01T01:07:15Z",
        "body": "Yes I can't repo this anymore either. It was fixed in 4.5 after I filed this issue"
      }
    ]
  },
  {
    "number": 46371,
    "title": "No completion for `assert` keyword",
    "created_at": "2021-10-14T23:42:47Z",
    "closed_at": "2022-01-28T00:17:43Z",
    "labels": [
      "Bug",
      "Help Wanted",
      "Fix Available",
      "Rescheduled",
      "Effort: Casual"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/46371",
    "body": "```ts\r\nimport * as thing from \"thing\" /**/\r\n```\r\n\r\nRequest completions at `/**/`.\r\n\r\n**Expected**: Completions provide the `assert` keyword.\r\n\r\n**Actual** No assert keyword is present in the completion list.",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/46371/comments",
    "author": "DanielRosenwasser",
    "comments": [
      {
        "user": "andrewbranch",
        "created_at": "2021-10-20T18:41:43Z",
        "body": "@xiaoxiangmoe if it says “help wanted” you can do it 👍 "
      }
    ]
  },
  {
    "number": 46032,
    "title": "Crash trying to assing undefined[] to never[]",
    "created_at": "2021-09-23T18:51:51Z",
    "closed_at": "2022-02-12T15:39:22Z",
    "labels": [
      "Bug",
      "Help Wanted",
      "Effort: Moderate",
      "Crash",
      "Fix Available"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/46032",
    "body": "# Bug Report\r\n\r\n<!--\r\n  Please fill in each section completely. Thank you!\r\n-->\r\n\r\n### 🔎 Search Terms\r\n`never[] crash` `generalized source shouldn't be assignable` `never union`\r\n<!--\r\n  What search terms did you use when trying to find an existing bug report?\r\n  List them here so people in the future can find this one more easily.\r\n-->\r\n\r\n### 🕗 Version & Regression Information\r\n\r\nIn 4.0 starts to crash, still happens in the nightly build.\r\n\r\nTo reproduce the crash, create a file and paste the code, the simply compile it with \r\n\r\n```\r\ntsc file.ts\r\n```\r\n\r\n- [x] This is a crash\r\n- This changed between versions 3.9 and 4.0\r\n\r\n### 💻 Code\r\n\r\n<!-- Please post the relevant code sample here as well-->\r\n```ts\r\ninterface A {\r\n  foo: \"a\";\r\n}\r\n\r\ninterface B {\r\n  foo: \"b\";\r\n}\r\n\r\ntype Union = A & B;\r\n\r\nfunction func(): { value: Union[] } {\r\n  return {\r\n    value: [],\r\n  };\r\n}\r\n```\r\n\r\n### 🙁 Actual behaviour\r\n\r\nCrashes with error\r\n\r\n```\r\nError: Debug Failure. False expression: generalized source shouldn't be assignable\r\n    at reportRelationError (/Users/eliancordoba/ts-crash/node_modules/typescript/lib/tsc.js:47173:30)\r\n    at reportErrorResults (/Users/eliancordoba/ts-crash/node_modules/typescript/lib/tsc.js:47368:25)\r\n    at isRelatedTo (/Users/eliancordoba/ts-crash/node_modules/typescript/lib/tsc.js:47329:17)\r\n    at typeArgumentsRelatedTo (/Users/eliancordoba/ts-crash/node_modules/typescript/lib/tsc.js:47570:39)\r\n    at relateVariances (/Users/eliancordoba/ts-crash/node_modules/typescript/lib/tsc.js:47961:34)\r\n    at structuredTypeRelatedTo (/Users/eliancordoba/ts-crash/node_modules/typescript/lib/tsc.js:47911:46)\r\n    at recursiveTypeRelatedTo (/Users/eliancordoba/ts-crash/node_modules/typescript/lib/tsc.js:47653:53)\r\n    at isRelatedTo (/Users/eliancordoba/ts-crash/node_modules/typescript/lib/tsc.js:47308:38)\r\n    at checkTypeRelatedTo (/Users/eliancordoba/ts-crash/node_modules/typescript/lib/tsc.js:46997:26)\r\n    at elaborateElementwise (/Users/eliancordoba/ts-crash/node_modules/typescript/lib/tsc.js:46407:38)\r\n```\r\n\r\n### 🙂 Expected behaviour\r\n\r\nEither show an error message or compile successfully\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/46032/comments",
    "author": "ElianCordoba",
    "comments": [
      {
        "user": "ahejlsberg",
        "created_at": "2022-02-09T15:17:13Z",
        "body": "Note that the assertion failure happens only when `--strictNullChecks` is disabled."
      }
    ]
  },
  {
    "number": 45713,
    "title": "[CLI DX] Improve the 'x errors' message in the CLI",
    "created_at": "2021-09-03T19:26:54Z",
    "closed_at": "2021-12-07T10:50:44Z",
    "labels": [
      "Help Wanted",
      "Good First Issue",
      "Experience Enhancement",
      "Effort: Casual"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/45713",
    "body": "# Suggestion\r\n\r\nAs of 4.4, a run of `tsc` looks like:\r\n\r\n```sh\r\n$ /Users/ortatherox/dev/typescript/repros/compilerSamples/node_modules/.bin/tsc\r\n                                                                               \r\n// ...                                                                         \r\n                                                                               \r\nFound 4 errors.                                                                \r\n```\r\n\r\nI propose instead we change this message in two key ways, depending on the number of files are raised with errors:\r\n\r\n#### Single file\r\n\r\n```\r\n$ /Users/ortatherox/dev/typescript/repros/compilerSamples/node_modules/.bin/tsc\r\n                                                                               \r\n// ...                                                                         \r\n                                                                               \r\nFound 1 error in index.ts:4                                                    \r\n``` \r\n\r\n#### Multi file\r\n\r\n\r\n```\r\n$ /Users/ortatherox/dev/typescript/repros/compilerSamples/node_modules/.bin/tsc\r\n                                                                               \r\n// ...                                                                         \r\n\r\nFound 4 errors in 3 files.           \r\n                                     \r\nErrors  Files                        \r\n                                     \r\n     2  index.ts:2                   \r\n     1  other.ts:4                   \r\n     1  third.ts:8\r\n``` \r\n\r\n## Reasoning\r\n\r\nFor single files, it's a nice quick small dx improvement which lets you click directly to the file. For multi-files, it's a way to understand the entire scope of your compiler errors. Today to understand what files and where the general amount of errors come from you need to scan the entire text, and if that has scrolled off the terminal - then this is hard to do. \r\n\r\nIn both cases we only link to the file and line, having the character on the file isn't that useful at this point.\r\n\r\n## Exceptions\r\n\r\nA PR should _not_ include these changes in watch mode. We think there are third-party apps which rely on the text in watch mode, and we want to make sure we've found those and made sure they can handle the changes to the output. So, to not block PRs we request keeping the watch mode as the same output.",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/45713/comments",
    "author": "orta",
    "comments": [
      {
        "user": "rbargholz",
        "created_at": "2021-09-04T01:42:02Z",
        "body": "I'd be interested to give this a shot if it hasn't been picked up yet. This would be my first foray into the code so I'll look into it as well first."
      },
      {
        "user": "orta",
        "created_at": "2021-09-04T07:40:37Z",
        "body": "Sure, give it a shot there's no need to try and claim the issue - until there's a solid WIP PR it's open for anyone to give it a go.\r\n"
      },
      {
        "user": "rbargholz",
        "created_at": "2021-09-05T09:33:21Z",
        "body": "@orta Apologies for my new-ness, may I ask about running tests? I've implemented the first part of this ticket (I am yet to implement a breakdown of the errors), but multiple files and single files are handled. When running tests I appear to have a number of them failing with this kind of error:\r\n```\r\n  15)\r\n\r\n         unittests:: tsbuild:: exitCodeOnBogusFile:: test exit code\r\n           tsc -b bogus.json exitCodeOnBogusFile:: test exit code\r\n             exitCodeOnBogusFile\r\n               test exit code\r\n                 \"before all\" hook for \"Generates files matching the baseline\":\r\n     Error: Debug Failure.\r\n      at C:\\Users\\rbarg\\dev\\TypeScript\\src\\compiler\\utilities.ts:5850:79\r\n      at String.replace (<anonymous>)\r\n      at formatStringFromArgs (src\\compiler\\utilities.ts:5850:21)\r\n      at Object.createCompilerDiagnostic (src\\compiler\\utilities.ts:5971:20)\r\n      at Object.getErrorSummaryText (src\\compiler\\watch.ts:135:13)\r\n      at Object.reportErrorSummary (src\\executeCommandLine\\executeCommandLine.ts:752:53)\r\n      at reportErrorSummary (src\\compiler\\tsbuildPublic.ts:2028:24)\r\n      at build (src\\compiler\\tsbuildPublic.ts:1696:9)\r\n      at Object.build (src\\compiler\\tsbuildPublic.ts:1947:86)\r\n      at performBuild (src\\executeCommandLine\\executeCommandLine.ts:745:75)\r\n      at Object.executeCommandLine (src\\executeCommandLine\\executeCommandLine.ts:647:24)\r\n      at tscCompile (src\\testRunner\\unittests\\tsc\\helpers.ts:113:9)\r\n      at Context.<anonymous> (src\\testRunner\\unittests\\tsc\\helpers.ts:163:31)\r\n      at processImmediate (internal/timers.js:464:21)\r\n```\r\nIs this common?"
      },
      {
        "user": "rbargholz",
        "created_at": "2021-09-06T10:46:25Z",
        "body": "> @orta Apologies for my new-ness, may I ask about running tests? I've implemented the first part of this ticket (I am yet to implement a breakdown of the errors), but multiple files and single files are handled. When running tests I appear to have a number of them failing with this kind of error:\r\n> \r\n> ```\r\n>   15)\r\n> \r\n>          unittests:: tsbuild:: exitCodeOnBogusFile:: test exit code\r\n>            tsc -b bogus.json exitCodeOnBogusFile:: test exit code\r\n>              exitCodeOnBogusFile\r\n>                test exit code\r\n>                  \"before all\" hook for \"Generates files matching the baseline\":\r\n>      Error: Debug Failure.\r\n>       at C:\\Users\\rbarg\\dev\\TypeScript\\src\\compiler\\utilities.ts:5850:79\r\n>       at String.replace (<anonymous>)\r\n>       at formatStringFromArgs (src\\compiler\\utilities.ts:5850:21)\r\n>       at Object.createCompilerDiagnostic (src\\compiler\\utilities.ts:5971:20)\r\n>       at Object.getErrorSummaryText (src\\compiler\\watch.ts:135:13)\r\n>       at Object.reportErrorSummary (src\\executeCommandLine\\executeCommandLine.ts:752:53)\r\n>       at reportErrorSummary (src\\compiler\\tsbuildPublic.ts:2028:24)\r\n>       at build (src\\compiler\\tsbuildPublic.ts:1696:9)\r\n>       at Object.build (src\\compiler\\tsbuildPublic.ts:1947:86)\r\n>       at performBuild (src\\executeCommandLine\\executeCommandLine.ts:745:75)\r\n>       at Object.executeCommandLine (src\\executeCommandLine\\executeCommandLine.ts:647:24)\r\n>       at tscCompile (src\\testRunner\\unittests\\tsc\\helpers.ts:113:9)\r\n>       at Context.<anonymous> (src\\testRunner\\unittests\\tsc\\helpers.ts:163:31)\r\n>       at processImmediate (internal/timers.js:464:21)\r\n> ```\r\n> \r\n> Is this common?\r\n\r\nThis has come good, I found it was due to some baselines that didn't match, or were causing some issues."
      },
      {
        "user": "orta",
        "created_at": "2021-09-06T15:13:11Z",
        "body": "Ace, sorry just read all this - looking good so far 👍🏻 "
      }
    ]
  },
  {
    "number": 45607,
    "title": "Snippet import statement completions don't work for 'import type'",
    "created_at": "2021-08-28T00:47:15Z",
    "closed_at": "2021-09-23T23:13:18Z",
    "labels": [
      "Bug",
      "Help Wanted",
      "Good First Issue",
      "Fix Available",
      "Domain: Auto-import"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/45607",
    "body": "```ts\r\n// @filename: yadda.ts\r\nexport interface Yadda {\r\n}\r\n\r\n// @filename: badda.ts\r\nimport type /**/\r\n```\r\n\r\nRequest completions at `/**/`\r\n\r\n**Expected**\r\n\r\n`Yadda` is a completion item.\r\n\r\n**Actual**\r\n\r\n`Yadda` is not a completion item.",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/45607/comments",
    "author": "DanielRosenwasser",
    "comments": [
      {
        "user": "iamdevelopergirl",
        "created_at": "2021-08-28T12:40:40Z",
        "body": "Can I work on this? This is my first time contributing to Typescript. "
      },
      {
        "user": "orta",
        "created_at": "2021-08-28T14:34:10Z",
        "body": "You can, give it a shot!"
      },
      {
        "user": "Pika-Pool",
        "created_at": "2021-09-01T13:56:38Z",
        "body": "Hey @orta, could you please point me to a file/snippet of code where I can start looking for this issue in the source code?"
      },
      {
        "user": "iamdevelopergirl",
        "created_at": "2021-09-01T14:17:30Z",
        "body": "Hey @Pika-Pool, I started looking in to the issue and found related completions under src/services/completion.ts. But I could not get to solve the issue yet. "
      },
      {
        "user": "andrewbranch",
        "created_at": "2021-09-01T20:27:45Z",
        "body": "Hint: the function that needs a change is `getImportCompletionNode`."
      },
      {
        "user": "a-tarasyuk",
        "created_at": "2021-09-01T20:40:06Z",
        "body": "@andrewbranch do we need to have `type` import in `getInsertTextAndReplacementSpanForImportCompletion` for this case?\r\n\r\n"
      },
      {
        "user": "andrewbranch",
        "created_at": "2021-09-01T22:27:39Z",
        "body": "Yes, or alternatively the replacement span could be smaller, after `import` and `type`. For now, the whole import declaration gets replaced just because that was easiest and really had no downside."
      }
    ]
  },
  {
    "number": 45501,
    "title": "VS Code removes spaces between empty object literals even if `insertSpaceAfterOpeningAndBeforeClosingEmptyBraces` is true",
    "created_at": "2021-08-13T06:22:24Z",
    "closed_at": "2021-08-24T18:28:58Z",
    "labels": [
      "Bug",
      "Help Wanted",
      "Domain: Formatter"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/45501",
    "body": "\r\nIssue Type: <b>Bug</b>\r\n\r\nI have enabled the `insertSpaceAfterOpeningAndBeforeClosingEmptyBraces` option in settings.json and I still see that empty object literals with a space between them (`{ }`) are collapsed to remove the space (`{}`).\r\n\r\nAs an extended example, doing the following works as expected:\r\n```js\r\nclass Foo {\r\n  doFoo() { }\r\n}\r\n```\r\n\r\nBut this does not:\r\n```js\r\nconst foo = { }\r\n```\r\n\r\nUpon saving, the second item gets collapsed to `const foo = {}`\r\n\r\nVS Code version: Code 1.59.0 (379476f0e13988d90fab105c5c19e7abc8b1dea8, 2021-08-04T23:13:12.822Z)\r\nOS version: Windows_NT x64 10.0.19042\r\nRestricted Mode: No\r\n\r\n<details>\r\n<summary>System Info</summary>\r\n\r\n|Item|Value|\r\n|---|---|\r\n|CPUs|11th Gen Intel(R) Core(TM) i5-1135G7 @ 2.40GHz (8 x 2419)|\r\n|GPU Status|2d_canvas: enabled<br>gpu_compositing: enabled<br>multiple_raster_threads: enabled_on<br>oop_rasterization: enabled<br>opengl: enabled_on<br>rasterization: enabled<br>skia_renderer: enabled_on<br>video_decode: enabled<br>vulkan: disabled_off<br>webgl: enabled<br>webgl2: enabled|\r\n|Load (avg)|undefined|\r\n|Memory (System)|7.69GB (0.42GB free)|\r\n|Process Argv|--crash-reporter-id 98bbd91f-17e6-483f-a746-35cacbab776f|\r\n|Screen Reader|no|\r\n|VM|0%|\r\n</details><details><summary>Extensions (4)</summary>\r\n\r\nExtension|Author (truncated)|Version\r\n---|---|---\r\nbetter-comments|aar|2.1.0\r\nbracket-pair-colorizer-2|Coe|0.2.1\r\nvscode-eslint|dba|2.1.23\r\nindent-rainbow|ode|7.5.0\r\n\r\n(1 theme extensions excluded)\r\n\r\n</details><details>\r\n<summary>A/B Experiments</summary>\r\n\r\n```\r\nvsliv368:30146709\r\nvsreu685:30147344\r\npython383cf:30185419\r\npythonvspyt602:30300191\r\nvspor879:30202332\r\nvspor708:30202333\r\nvspor363:30204092\r\npythonvspyt639:30300192\r\npythontb:30283811\r\npythonptprofiler:30281270\r\nvshan820:30294714\r\nvstes263:30335439\r\npythondataviewer:30285071\r\npythonvsuse255:30340121\r\nvscod805cf:30301675\r\npythonvspyt200:30340761\r\nvscextlangct:30333562\r\nbinariesv615:30325510\r\npythonvssor306:30344512\r\nbridge0708:30335490\r\nvstre464:30350172\r\nbridge0723:30351747\r\n\r\n```\r\n\r\n</details>\r\n\r\n<!-- generated by issue reporter -->",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/45501/comments",
    "author": "UmarGhouse",
    "comments": [
      {
        "user": "theGreen233",
        "created_at": "2021-08-24T14:03:43Z",
        "body": "Hello, we are a group of researchers developing machine learning techniques to locate issues suitable for newcomers, and our model consider this issue as likely a \"good first issue\". May we recommend you to label it as \"good first issue\" so newcomers know where to choose?\r\n\r\nThank you!"
      }
    ]
  },
  {
    "number": 44638,
    "title": "`git clone` fails on Windows",
    "created_at": "2021-06-17T22:21:00Z",
    "closed_at": "2021-06-18T16:06:51Z",
    "labels": [
      "Help Wanted",
      "Infrastructure"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/44638",
    "body": "At current `master` (5afe42e14e61d7e4df5d75cc0022283711cb593a) there are several test files with colliding names, and several with overly long names.\r\n\r\n```\r\nerror: unable to create file tests/baselines/reference/tscWatch/emitAndErrorUpdates/incremental/assumeChangesOnlyAffectDirectDependenciesAndD/updates-errors-when-file-transitively-exported-file-changes/when-there-are-circular-import-and-exports.js: Filename too long\r\nerror: unable to create file tests/baselines/reference/tscWatch/emitAndErrorUpdates/incremental/assumeChangesOnlyAffectDirectDependenciesAndD/updates-errors-when-file-transitively-exported-file-changes/when-there-are-no-circular-import-and-exports.js: Filename too long\r\n\r\nwarning: the following paths have collided (e.g. case-sensitive paths\r\non a case-insensitive filesystem) and only one from the same\r\ncolliding group is in the working tree:\r\n\r\n  'tests/baselines/reference/typeOfThis.errors.txt'\r\n  'tests/baselines/reference/typeofThis.errors.txt'\r\n  'tests/baselines/reference/typeOfThis.js'\r\n  'tests/baselines/reference/typeofThis.js'\r\n  'tests/baselines/reference/typeOfThis.symbols'\r\n  'tests/baselines/reference/typeofThis.symbols'\r\n  'tests/baselines/reference/typeOfThis.types'\r\n  'tests/baselines/reference/typeofThis.types'\r\n```",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/44638/comments",
    "author": "reverofevil",
    "comments": [
      {
        "user": "reverofevil",
        "created_at": "2021-06-17T22:26:52Z",
        "body": "Introduced in #43695 and #43898\r\n\r\n@sheetalkamat @Zzzen"
      },
      {
        "user": "IllusionMH",
        "created_at": "2021-06-18T02:31:41Z",
        "body": "Also related #38998 "
      },
      {
        "user": "Zzzen",
        "created_at": "2021-06-18T07:07:56Z",
        "body": "Path collisions can be fixed by simply renaming to `typeofThis2`."
      }
    ]
  },
  {
    "number": 44273,
    "title": "TypeScript preserves 'override' modifier on properties in JavaScript esnext output",
    "created_at": "2021-05-26T21:24:23Z",
    "closed_at": "2021-06-03T22:42:20Z",
    "labels": [
      "Bug",
      "Fixed",
      "Help Wanted",
      "Good First Issue",
      "Domain: JS Emit",
      "Fix Available"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/44273",
    "body": "# Bug Report\r\n\r\n### 🔎 Search Terms\r\noverride, property, esnext\r\n\r\n### 🕗 Version & Regression Information\r\nBug in new feature of version 4.3\r\n\r\n### 💻 Code\r\n```typescript\r\nclass Base {\r\n    state?: string;\r\n}\r\n    \r\nexport default class TestClass extends Base {\r\n    override state = \"string\";\r\n}\r\n```\r\n\r\n### 🙁 Actual behavior\r\nCompiling this code for target **esnext** the override keyword on properties is preserved:\r\n\r\n    tsc -t esnext TestClass.ts\r\n\r\n```js\r\nclass Base {\r\n    state;\r\n}\r\nexport default class TestClass extends Base {\r\n    override state = \"string\";\r\n}\r\n```\r\n\r\n### 🙂 Expected behavior\r\nThe `override` keyword should be removed from the javascript output, as it is already done correctly for methods.\r\n\r\n(Compiling for other targets (e.g. es2021) works correctly as the property is transformed to a constructor initialization.)\r\n\r\nMaybe related to #43535",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/44273/comments",
    "author": "AsamK",
    "comments": [
      {
        "user": "DanielRosenwasser",
        "created_at": "2021-05-27T05:57:20Z",
        "body": "~We have tests for this, we just didn't read them correctly.~ nevermind"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2021-06-03T22:42:53Z",
        "body": "Thanks @a-tarasyuk!"
      }
    ]
  },
  {
    "number": 43679,
    "title": "TS6059 reports half-true reason for file being in the program",
    "created_at": "2021-04-14T21:07:39Z",
    "closed_at": "2022-05-10T17:34:04Z",
    "labels": [
      "Help Wanted",
      "Effort: Moderate",
      "Experience Enhancement",
      "Fix Available",
      "Rescheduled"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/43679",
    "body": "# Bug Report\r\n\r\nI am going to take a calculated risk here and skip the 1.5h work of form filling, because this seems to be a really simple issue.\r\n\r\nThis error message is half-true and misleading:\r\n\r\n```\r\nerror TS6059: File '/fasthome/rulatir/works/zrup/utility/ts/jsdoc.ts' is not under 'rootDir' '/fasthome/rulatir/works/zrup/ts'. 'rootDir' is expected to contain all source files.\r\n  The file is in the program because:\r\n    Matched by include pattern '**/*' in '/fasthome/rulatir/works/zrup/tsconfig.json'\r\n```\r\n\r\nThe claim in the last line is false. There is no '\\*\\*/\\*' include pattern specified anywhere in my tsconfig.json. There is no key in my entire tsconfig.json that contains case-insensitive strings \"include\" or \"pattern\". There is not a single occurrence of the string '\\*\\*/\\*' in my tsconfig.json.\r\n\r\nWhat this means is that the offending value actually comes from defaults, and should be overriden in tsconfig.json by adding an appropriate key.\r\n\r\nExpected last line of the error message:\r\n\r\n```\r\n    Matched by the default include pattern '**/*' (override by setting the <whatever it is named> option in tsconfig.json)\r\n```",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/43679/comments",
    "author": "rulatir",
    "comments": [
      {
        "user": "DanielRosenwasser",
        "created_at": "2021-04-14T22:04:31Z",
        "body": "If there's a way to detect whether a rule came from the defaults, it would be nice to call that out in `--explainFiles`."
      }
    ]
  },
  {
    "number": 43503,
    "title": "Error messages inconsistently use backticks and single quotes",
    "created_at": "2021-04-02T16:51:14Z",
    "closed_at": "2021-04-29T14:15:32Z",
    "labels": [
      "Help Wanted",
      "Good First Issue",
      "Domain: Error Messages"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/43503",
    "body": "A lot of new error messages use backticks where old messages use single quotes. Errors should use single quotes unless there's a good reason not to.\r\n\r\nSpecifically, \r\n\r\n* Backticks around tsconfig properties and values should use single quotes.\r\n* 7035 has surrounds `declare module '{0}'` with backticks. That is probably correct, but only if the code that fixes the error literally includes a string, like `declare module \"fs\" {`\r\n* 7040 has a single-quote/backtick mismatch that should just be single quoted.\r\n\r\nIf this is your first issue, you'll need to change diagnosticMessages.json, then `gulp runtests-parallel` followed by `gulp baseline-accept`. You should `git blame` error 7035 to look at the PR that added it.",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/43503/comments",
    "author": "sandersn",
    "comments": [
      {
        "user": "krishnaanaril",
        "created_at": "2021-04-04T05:04:30Z",
        "body": "I'm interested to submit a PR."
      },
      {
        "user": "sandersn",
        "created_at": "2021-04-05T15:42:35Z",
        "body": "Great! If you need help, try discord.gg/typescript. There are a couple of channels there where knowledgeable people hang out."
      }
    ]
  },
  {
    "number": 43278,
    "title": "'Convert to ES6 module' generates invalid code when accessing '.default'",
    "created_at": "2021-03-16T22:18:23Z",
    "closed_at": "2021-03-30T22:24:31Z",
    "labels": [
      "Bug",
      "Help Wanted",
      "Good First Issue",
      "Domain: Quick Fixes",
      "Domain: JavaScript"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/43278",
    "body": "```js\r\nlet fetch = require('node-fetch');\r\n\r\nfetch.default()\r\n```\r\n\r\nExecute the `Convert to ES6 module` quick fix.\r\n\r\n**Expected**\r\n\r\n```js\r\nimport nodeFetch from 'node-fetch';\r\n\r\nnodeFetch()\r\n```\r\n\r\n**Actual**\r\n\r\n```ts\r\nimport { default } from 'node-fetch';\r\n\r\ndefault()\r\n```",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/43278/comments",
    "author": "DanielRosenwasser",
    "comments": [
      {
        "user": "sangxxh",
        "created_at": "2021-03-18T11:07:01Z",
        "body": "I'd like to have a look at this issue"
      }
    ]
  },
  {
    "number": 43085,
    "title": "Improve rendering of JSDoc comment text with displayparts",
    "created_at": "2021-03-04T23:47:00Z",
    "closed_at": "2021-04-09T16:44:44Z",
    "labels": [
      "Help Wanted",
      "Good First Issue",
      "Experience Enhancement"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/43085",
    "body": "#41877 improves parsing of jsdoc comment text as well as giving the language service the option of providing display parts for comments instead of text. Currently everything is just `\"text\"` except for links. However, with small tweaks to code like `getCommentDisplayParts` in services/jsDoc.ts, it would be possible to format `@param` names as `\"parameterName\"`, `@template` names as `\"typeParameterName\"`, etc. \r\n\r\nThis could make display a lot prettier.\r\n\r\nNote: depends on #41877 being merged.",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/43085/comments",
    "author": "sandersn",
    "comments": [
      {
        "user": "sangxxh",
        "created_at": "2021-03-05T10:39:51Z",
        "body": "I'd like to work on this issue, I'll watch for when #41877 is merged"
      },
      {
        "user": "sangxxh",
        "created_at": "2021-03-22T10:04:27Z",
        "body": "Now awaiting #43312 "
      }
    ]
  },
  {
    "number": 42849,
    "title": "Unnecessary elaboration about not being assignable to type parameters",
    "created_at": "2021-02-17T23:29:37Z",
    "closed_at": "2021-03-05T19:15:05Z",
    "labels": [
      "Suggestion",
      "Help Wanted",
      "Domain: Error Messages",
      "Experience Enhancement"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/42849",
    "body": "```ts\r\nasync function foo<T>(x: T): Promise<T> {\r\n  let yaddable = await getXOrYadda(x);\r\n  return yaddable;\r\n}\r\n\r\ninterface Yadda {\r\n  stuff: string,\r\n  things: string,\r\n}\r\n\r\ndeclare function getXOrYadda<T>(x: T): T | Yadda;\r\n```\r\n\r\nHere, you'll get an error like\r\n\r\n```\r\nType 'T | Yadda' is not assignable to type 'T'.\r\n  'T' could be instantiated with an arbitrary type which could be unrelated to 'T | Yadda'.\r\n    Type 'Yadda' is not assignable to type 'T'.\r\n      'T' could be instantiated with an arbitrary type which could be unrelated to 'Yadda'.\r\n```\r\n\r\n## Proposed\r\n\r\nEither\r\n\r\n```\r\nType 'T | Yadda' is not assignable to type 'T'.\r\n    Type 'Yadda' is not assignable to type 'T'.\r\n      'T' could be instantiated with an arbitrary type which could be unrelated to 'Yadda'.\r\n```\r\n\r\nor\r\n\r\n```\r\nType 'T | Yadda' is not assignable to type 'T'.\r\n  'T' could be instantiated with an arbitrary type which could be unrelated to 'T | Yadda'.\r\n```",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/42849/comments",
    "author": "DanielRosenwasser",
    "comments": [
      {
        "user": "jonhue",
        "created_at": "2021-02-25T09:56:21Z",
        "body": "I created a pull request that makes the proposed change (#42952) but had one small question about the behavior in scenarios related to the one discussed here."
      }
    ]
  },
  {
    "number": 42292,
    "title": "Incorrect signature help position for non-trailing rest arguments",
    "created_at": "2021-01-12T10:16:52Z",
    "closed_at": "2021-02-05T17:37:29Z",
    "labels": [
      "Bug",
      "Help Wanted",
      "Effort: Moderate",
      "Domain: Signature Help",
      "Fix Available"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/42292",
    "body": "```ts\r\ndeclare function doStuff(...args: [...names: string[], shouldCapitalize: boolean]): void;\r\ndoStuff(\"fee\", \"fai\"/**/, \"foh\",  true);\r\n```\r\n\r\nTrigger signature help at `/**/`\r\n\r\n**Current**: Signature help indicates that we're in the second argument - **shouldCapitalize**.\r\n**Expected**: Signature help indicates that we're still in the first (rest) argument: **names**",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/42292/comments",
    "author": "DanielRosenwasser",
    "comments": [
      {
        "user": "DanielRosenwasser",
        "created_at": "2021-01-12T10:21:34Z",
        "body": "@ahejlsberg do we have any sort of reusable logic for this one? I think there's a pretty rough UX/UI issue where the user hasn't written the full invocation out yet:\r\n\r\n```ts\r\ndoStuff(\"fee\", \"fai\" /*signatureHelpHere*/\r\n```"
      },
      {
        "user": "sandersn",
        "created_at": "2021-01-25T22:03:04Z",
        "body": "It's actually worse -- if you ask for signature help on `\"foh\"`, then there's no active argument at all, even though it should still be `names`."
      },
      {
        "user": "sandersn",
        "created_at": "2021-02-01T22:56:50Z",
        "body": "(I couldn't find any good way to reuse the checker logic -- its basic assumptions are not oriented toward highlighting the 'current' parameter, but toward finding assignability errors for all parameters.)"
      }
    ]
  },
  {
    "number": 41827,
    "title": "Infer parameter from usage doesn't work on interface parameters",
    "created_at": "2020-12-05T00:41:26Z",
    "closed_at": "2020-12-07T22:00:46Z",
    "labels": [
      "Bug",
      "Fixed",
      "Help Wanted",
      "Effort: Moderate",
      "Domain: Quick Fixes"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/41827",
    "body": "```ts\r\ninterface Options {\r\n    reportError(start, length, message): void;\r\n}\r\n\r\nfunction stuff(opts: Options) {\r\n    opts.reportError(0, 1, \"hello\")\r\n}\r\n```\r\n\r\nRequest a quick fix to infer all types from usage. Currently you'll get\r\n\r\n```ts\r\ninterface Options {\r\n    reportError(start: any, length: any, message: any): void;\r\n}\r\n\r\nfunction stuff(opts: Options) {\r\n    opts.reportError(0, 1, \"hello\")\r\n}\r\n```\r\n\r\nEven though we should be able to infer\r\n\r\n```ts\r\ninterface Options {\r\n    reportError(start: number, length: number, message: string): void;\r\n}\r\n\r\nfunction stuff(opts: Options) {\r\n    opts.reportError(0, 1, \"hello\")\r\n}\r\n```",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/41827/comments",
    "author": "DanielRosenwasser",
    "comments": [
      {
        "user": "Leulz",
        "created_at": "2020-12-06T01:02:59Z",
        "body": "Hey there. I am looking for somewhat simple tasks to tackle in the the JS/TS ecosystem, and this one apparently fits what I'm looking for.\r\n\r\nIf that's okay with the contributors, I'd like to try building a solution for this."
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2020-12-07T22:01:54Z",
        "body": "Thanks @a-tarasyuk!"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2020-12-07T22:03:05Z",
        "body": "@Leulz sorry this already got fixed - I'd try taking a look at other issues marked as `help wanted` or `good first issue`."
      }
    ]
  },
  {
    "number": 41786,
    "title": "Incorrect quick fix for \"use element access\"",
    "created_at": "2020-12-02T22:39:46Z",
    "closed_at": "2020-12-04T21:37:17Z",
    "labels": [
      "Bug",
      "Help Wanted",
      "Effort: Moderate",
      "Domain: Quick Fixes",
      "Fix Available"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/41786",
    "body": "```ts\r\n// @noPropertyAccessFromIndexSignature: true\r\n\r\ndeclare let x: { y: { [x: string]: string } };\r\n\r\nx.y.yadda/**/;\r\n```\r\n\r\nRequest quick fixes here.\r\n\r\n*Current behavior**:\r\n\r\nQuick fix is suggested for `y`, the code results in\r\n\r\n```ts\r\ndeclare let x: { y: { [x: string]: string } };\r\n\r\nx[\"y\"].yadda;\r\n```\r\n\r\n**Expected**:\r\n\r\nQuick fix is suggested for `yadda`, the code results in\r\n\r\n```ts\r\ndeclare let x: { y: { [x: string]: string } };\r\n\r\nx.y[\"yadda\"];\r\n```",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/41786/comments",
    "author": "DanielRosenwasser",
    "comments": [
      {
        "user": "Kingwl",
        "created_at": "2020-12-03T02:58:12Z",
        "body": "Wow....."
      }
    ]
  },
  {
    "number": 39245,
    "title": "Weird related diagnostic for missing rest parameter arguments",
    "created_at": "2020-06-24T22:49:12Z",
    "closed_at": "2020-07-30T00:25:14Z",
    "labels": [
      "Bug",
      "Help Wanted",
      "Effort: Moderate",
      "Domain: Error Messages",
      "Fix Available"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/39245",
    "body": "```ts\r\nfunction partialCall<T extends Arr, U extends Arr, R>(f: (...args: [...T, ...U]) => R, ...headArgs: T) {\r\n    return (...b: U) => f(...headArgs, ...b)\r\n}\r\n\r\nconst foo = (x: string, y: number, z: boolean) => {}\r\n\r\nconst f3 = partialCall(foo, \"hello\");\r\n\r\nf3();\r\n```\r\n\r\nWe get an error like\r\n\r\n```ts\r\nExpected 2 arguments, but got 0.\r\n(related): An argument for 'b' was not provided.\r\n```\r\n\r\n`b` refers to the rest parameter of the arrow function in `partialCall`. This behavior is misleading or incorrect. Any of the following would be improvements.\r\n\r\n1. Switch to a diagnostic that reflects a more appropriate actual parameter name \"An argument for 'y' was not provided.\"\r\n1. Switch to a new diagnostic: \"Arguments for the rest parameter 'b' were not provided.\"\r\n1. Remove the related diagnostic in this case.",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/39245/comments",
    "author": "DanielRosenwasser",
    "comments": [
      {
        "user": "ahejlsberg",
        "created_at": "2020-06-26T19:09:39Z",
        "body": "Agree with your recommendations. BTW, this doesn't really have anything to do with variadic tuples, you can observe the same behavior today in a `partialCall` that just binds the first parameter, e.g.\r\n\r\n```ts\r\nfunction partialCall<T, U extends unknown[], R>(f: (x: T, ...args: U) => R, headArg: T)\r\n```\r\n"
      }
    ]
  },
  {
    "number": 39047,
    "title": "Default formatter cant format JS Optional catch binding properly",
    "created_at": "2020-06-12T13:19:52Z",
    "closed_at": "2020-06-29T17:10:45Z",
    "labels": [
      "Bug",
      "Help Wanted",
      "Effort: Moderate",
      "Domain: Formatter"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/39047",
    "body": "\r\n*TS Template added by @mjbvz*\r\n\r\n**TypeScript Version**: 4.0.0-dev.20200611\r\n\r\n**Search Terms**\r\n- format / formatting\r\n- try/catch\r\n\r\n---\r\n\r\nIssue Type: <b>Bug</b>\r\n\r\nReproduction code:\r\n```js\r\n\"use strict\";\r\ntry {\r\n    throw new Error();\r\n} catch        {\r\n    console.info(\"Hello world\");\r\n}\r\n```\r\nExpected behaviour:\r\nWhen vscode tried formatting the code, the extra spaces should be removed.\r\n\r\nWhat happend:\r\nThe extra spaces can not be removed via formatting. (But when I put `()` in spaces, formatter can format the code properly.)\r\nDoes this issue occur when all extensions are disabled?: Yes\r\nDoes this issue occur on Insider build?: Yes\r\n\r\nMy vscode setting:\r\n`\"editor.defaultFormatter\": null`\r\n\r\nVS Code version: Code 1.46.0 (a5d1cc28bb5da32ec67e86cc50f84c67cc690321, 2020-06-10T09:03:20.462Z)\r\nOS version: Windows_NT x64 10.0.19041\r\n\r\n<details>\r\n<summary>System Info</summary>\r\n\r\n|Item|Value|\r\n|---|---|\r\n|CPUs|Intel(R) Core(TM) i7-6500U CPU @ 2.50GHz (4 x 2592)|\r\n|GPU Status|2d_canvas: enabled<br>flash_3d: enabled<br>flash_stage3d: enabled<br>flash_stage3d_baseline: enabled<br>gpu_compositing: enabled<br>multiple_raster_threads: enabled_on<br>oop_rasterization: disabled_off<br>protected_video_decode: unavailable_off<br>rasterization: enabled<br>skia_renderer: disabled_off_ok<br>video_decode: enabled<br>viz_display_compositor: enabled_on<br>viz_hit_test_surface_layer: disabled_off_ok<br>webgl: enabled<br>webgl2: enabled|\r\n|Load (avg)|undefined|\r\n|Memory (System)|7.90GB (1.68GB free)|\r\n|Process Argv||\r\n|Screen Reader|no|\r\n|VM|0%|\r\n</details><details><summary>Extensions (7)</summary>\r\n\r\nExtension|Author (truncated)|Version\r\n---|---|---\r\nhtml-snippets|abu|0.2.1\r\nvscode-eslint|dba|2.1.5\r\nvscode-npm-script|eg2|0.3.12\r\noutput-colorizer|IBM|0.1.2\r\nluacoderassist|liw|2.3.9\r\nvscode-language-pack-zh-hans|MS-|1.46.3\r\nvetur|oct|0.24.0\r\n\r\n\r\n</details>\r\n<!-- generated by issue reporter -->",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/39047/comments",
    "author": "AnnAngela",
    "comments": [
      {
        "user": "AnnAngela",
        "created_at": "2020-06-15T14:53:04Z",
        "body": "Hmmm, IDK why this issue had been transferred to TypeScript, can anyone explain it please?"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2020-06-15T15:45:10Z",
        "body": "@AnnAngela the code for the JS formatter lives in this repo"
      }
    ]
  },
  {
    "number": 38225,
    "title": "Fix diagnostic with \"body block braces\"",
    "created_at": "2020-04-28T05:56:36Z",
    "closed_at": "2020-05-12T14:27:10Z",
    "labels": [
      "Help Wanted",
      "Good First Issue",
      "Domain: Error Messages",
      "Fix Available"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/38225",
    "body": "We have a diagnostic\r\n\r\n```\r\nRemove all incorrect body block braces.\r\n```\r\n\r\nTypically we say \"block body\" not \"body block\". Perhaps we could make it less confusing by writing \"function body braces\"",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/38225/comments",
    "author": "DanielRosenwasser",
    "comments": [
      {
        "user": "a-tarasyuk",
        "created_at": "2020-04-28T06:41:43Z",
        "body": "@DanielRosenwasser  I think this QF applied only for arrow functions, also there is QF all message\r\n\r\n```ts\r\nDiagnostics.Remove_block_body_braces\r\nDiagnostics.Remove_all_incorrect_body_block_braces\r\n```\r\n\r\nMaybe make sense to point out in QF about arrow functions? Something like so\r\n\r\n```ts\r\nRemove braces surrounding arrow body\r\nRemove braces surrounding arrow body from all functions\r\n```\r\n"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2020-04-28T06:45:33Z",
        "body": "I like\r\n\r\n```\r\nRemove braces from arrow function body.\r\nRemove braces from all arrow function bodies with relevant issues.\r\n```"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2020-04-28T06:46:38Z",
        "body": "Eh, I mean, I don't _totally_ like them, but they'll do..."
      },
      {
        "user": "a-tarasyuk",
        "created_at": "2020-04-28T06:57:40Z",
        "body": "@DanielRosenwasser Thanks"
      },
      {
        "user": "rajatdiptabiswas",
        "created_at": "2020-04-28T07:17:58Z",
        "body": "Is this issue still available to be worked on?\r\nIf yes, would you kindly let me know what exactly needs to be done so that I can try working on it?"
      }
    ]
  },
  {
    "number": 37306,
    "title": "Poor error span for unclosed JSX tags in the presence of whitespace/comments",
    "created_at": "2020-03-09T21:36:06Z",
    "closed_at": "2020-03-19T18:40:44Z",
    "labels": [
      "Fixed",
      "Help Wanted",
      "Good First Issue",
      "Domain: JSX/TSX",
      "Domain: Error Messages",
      "Experience Enhancement"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/37306",
    "body": "```tsx\r\nlet Foo = {\r\n  Bar() {\r\n    \r\n  }\r\n}\r\n\r\nlet x = <    Foo.Bar >Hello\r\n\r\n```\r\n\r\n**Expected**: An error span like\r\n\r\n```tsx\r\nlet x = <    Foo.Bar >Hello\r\n             ~~~~~~~\r\n```\r\n\r\n**Actual**: An error span like\r\n```tsx\r\n\r\nlet x = <    Foo.Bar >Hello\r\n         ~~~~~~~~~~~\r\n```",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/37306/comments",
    "author": "DanielRosenwasser",
    "comments": [
      {
        "user": "AGMETEOR",
        "created_at": "2020-03-11T23:26:21Z",
        "body": "Would like to try this one out..."
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2020-03-12T00:03:11Z",
        "body": "Go for it! I'd try running the change to see if any tests are affected first, and if not, add the one in the example in a a file named `tests/cases/compiler/errorSpanForUnclosedJsxTag.tsx`"
      },
      {
        "user": "AGMETEOR",
        "created_at": "2020-03-15T15:03:41Z",
        "body": "@DanielRosenwasser implemented a solution for this. Will be raising a PR for review shortly :)"
      },
      {
        "user": "AGMETEOR",
        "created_at": "2020-03-17T20:58:50Z",
        "body": "Hi @DanielRosenwasser , I opened a PR for this issue :)"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2020-03-19T18:41:07Z",
        "body": "Thanks @AGMETEOR!"
      }
    ]
  },
  {
    "number": 36250,
    "title": "Completions after `#` include globals",
    "created_at": "2020-01-17T01:12:58Z",
    "closed_at": "2020-01-27T22:25:35Z",
    "labels": [
      "Bug",
      "Help Wanted",
      "Good First Issue",
      "Domain: Completion Lists",
      "Fix Available"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/36250",
    "body": "```ts\r\nclass Person {\r\n    #firstName: string\r\n\r\n    constructor(firstName: string) {\r\n        this.#/**/\r\n    }\r\n}\r\n```\r\n\r\nRequest completions\r\n\r\n**Expected**: Completion list **only** includes `firstName`\r\n**Actual**: Completion list includes a global completion list.",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/36250/comments",
    "author": "DanielRosenwasser",
    "comments": [
      {
        "user": "andrewbranch",
        "created_at": "2020-01-17T01:24:41Z",
        "body": "Related: #36191\r\n\r\nI guess `this.#` doesn’t parse as a PrivateIdentifier, so my fix doesn’t work until there’s at least one more character."
      }
    ]
  },
  {
    "number": 36238,
    "title": "No spelling suggestion/quick fix for misspelled uses of an import",
    "created_at": "2020-01-16T21:50:58Z",
    "closed_at": "2020-03-03T18:58:30Z",
    "labels": [
      "Bug",
      "Help Wanted",
      "Effort: Moderate",
      "Domain: Error Messages"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/36238",
    "body": "```ts\r\n// ./foo.ts\r\n\r\nexport class SomeThing {\r\n    \r\n}\r\n```\r\n\r\n```ts\r\n// ./bar.ts\r\n\r\nimport { SomeClass } from \"./foo.js\";\r\n\r\nSomeClas\r\n```\r\n\r\n**Expected**: \"Cannot find name 'SomeClas'. Did you mean 'SomeClass'?\"\r\n**Actual**: Standard \"Cannot find name 'SomeClas'.\" error.",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/36238/comments",
    "author": "DanielRosenwasser",
    "comments": [
      {
        "user": "a-tarasyuk",
        "created_at": "2020-02-28T12:46:51Z",
        "body": "```ts\r\nimport { SomeClass } from \"./foo.js\";\r\n         ^^^^^^^^^\r\n```\r\n`SomeClass` marked as `SymbolFlags.Alias`, in the meanwhile `getResolvedSymbol` doesn't use `SymbolFlags.Alias`, only `SymbolFlags.Value | SymbolFlags.ExportValue`.\r\n\r\n`resolveNameHelper` _`(getResolvedSymbol -> resolveName -> resolveNameHelper)`_ doesn't return any suggestions because `getSuggestedSymbolForNonexistentSymbol` resolves only `SymbolFlags.Value | SymbolFlags.ExportValue` and ignores `SymbolFlags.Alias`.\r\n\r\n```ts\r\nsuggestion = getSuggestedSymbolForNonexistentSymbol(originalLocation, name, meaning);\r\n```\r\n\r\nI'm not sure that `getResolvedSymbol` should have meaning `SymbolFlags.Value | SymbolFlags.ExportValue | SymbolFlags.Alias`, because it will break some tests, and also extending `meaning` by `SymbolFlags.Alias` inside `resolveNameHelper` seems is not the right way.\r\n\r\nWhat do you @DanielRosenwasser @andrewbranch think?\r\n\r\n"
      },
      {
        "user": "andrewbranch",
        "created_at": "2020-02-28T18:12:15Z",
        "body": "The reason we don’t call `resolveNameHelper` with a meaning that includes `SymbolFlags.Alias` is that `getSymbol` (which is usually what `lookup` is in `resolveNameHelper`), when checking that a candidate symbol matches `meaning`, will resolve aliases first, then match `meaning` against the resolved symbol instead of against the alias:\r\n\r\n```ts\r\nfunction getSymbol(symbols: SymbolTable, name: __String, meaning: SymbolFlags): Symbol | undefined {\r\n    if (meaning) {\r\n        const symbol = symbols.get(name);\r\n        if (symbol) {\r\n            Debug.assert((getCheckFlags(symbol) & CheckFlags.Instantiated) === 0, \"Should never get an instantiated symbol here.\");\r\n            if (symbol.flags & meaning) {\r\n                return symbol;\r\n            }\r\n            if (symbol.flags & SymbolFlags.Alias) {\r\n                const target = resolveAlias(symbol);\r\n                // Unknown symbol means an error occurred in alias resolution, treat it as positive answer to avoid cascading errors\r\n                if (target === unknownSymbol || target.flags & meaning) {\r\n                    return symbol;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    // return undefined if we can't find a symbol.\r\n}\r\n```\r\n\r\nThe problem seems to me that `getSpellingSuggestionForName` doesn’t do the same:\r\n\r\n```ts\r\nfunction getSpellingSuggestionForName(name: string, symbols: Symbol[], meaning: SymbolFlags): Symbol | undefined {\r\n    return getSpellingSuggestion(name, symbols, getCandidateName);\r\n    function getCandidateName(candidate: Symbol) {\r\n        const candidateName = symbolName(candidate);\r\n        return !startsWith(candidateName, \"\\\"\") && candidate.flags & meaning ? candidateName : undefined;\r\n    }\r\n}\r\n```\r\n\r\nHere, `candidate.flags` is going to be `SymbolFlags.Alias`, and `meaning` is never going to match that because that’s not a, uhm, meaningful meaning to pass to `resolveNameHelper`. So I think this meaning check needs to do the same thing as `getSymbol`, where it checks the flags first, then if there’s no match and `candidate` is an alias, resolves the alias and checks the flags of the resolved symbol."
      },
      {
        "user": "a-tarasyuk",
        "created_at": "2020-02-29T16:42:49Z",
        "body": "Thanks for your feedback 👍 . I've checked and found that `symbols` can have `export=` which is `Alias` too. If a `candidate` is `export=` - `resolveAlias` returns `Circular definition of...` for code like so\r\n\r\n```ts\r\nexport = test\r\n```\r\n\r\nMaybe there are some other potential cases that will cause a similar error. What do you @andrewbranch  think is it safe to handle `Aliases` directly in `getSpellingSuggestionForName`?\r\n\r\n"
      },
      {
        "user": "andrewbranch",
        "created_at": "2020-03-02T16:55:58Z",
        "body": "I’m not totally following why `resolveAlias` on an `export=` would always result in a circularity... I think I’d have to see the whole problem and maybe work through it. If you want to experiment with it and open a WIP PR, I’d be happy to help look at it, or if you don’t feel like it I can pick it up later this cycle."
      },
      {
        "user": "a-tarasyuk",
        "created_at": "2020-03-02T19:54:33Z",
        "body": "@andrewbranch I'll create Draft PR for this issue"
      }
    ]
  },
  {
    "number": 35735,
    "title": "Avoid listing missing properties on types with only call/construct signatures",
    "created_at": "2019-12-17T21:55:20Z",
    "closed_at": "2022-03-04T21:54:38Z",
    "labels": [
      "Suggestion",
      "Help Wanted",
      "Good First Issue",
      "Domain: Error Messages",
      "Experience Enhancement",
      "PursuitFellowship"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/35735",
    "body": "Found with @RyanCavanaugh \r\n\r\n```ts\r\ninterface Dog {\r\n    barkable: true\r\n}\r\n\r\ndeclare function getRover(): Dog;\r\n\r\nexport let x: Dog = getRover;\r\n```\r\n\r\n# Expected\r\n\r\n```\r\nType '() => Dog' is not assignable to 'Dog'.(2741)\r\n  input.ts(7, 21): Did you mean to call this expression?\r\n```\r\n\r\n# Actual\r\n\r\n```\r\nProperty 'barkable' is missing in type '() => Dog' but required in type 'Dog'.(2741)\r\n  input.ts(2, 5): 'barkable' is declared here.\r\n  input.ts(7, 21): Did you mean to call this expression?\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/35735/comments",
    "author": "DanielRosenwasser",
    "comments": [
      {
        "user": "weswigham",
        "created_at": "2019-12-17T23:46:58Z",
        "body": "Hm, OK, but suppose\r\n```ts\r\ninterface Dog {\r\n    caller: {\r\n        caller: {\r\n            collar: boolean;\r\n        };\r\n    }\r\n}\r\n\r\ndeclare function getRover(): Dog;\r\n\r\nexport let x: Dog = getRover;\r\n```\r\nfor which we issue\r\n```\r\nType '() => Dog' is not assignable to type 'Dog'.\r\n  The types of 'caller.caller' are incompatible between these types.\r\n    Property 'collar' is missing in type 'Function' but required in type '{ collar: boolean; }'.(2322)\r\ninput.ts(4, 13): 'collar' is declared here.\r\ninput.ts(11, 21): Did you mean to call this expression?\r\n```\r\n\r\nwhat's the rule here? In the above example, I can't make a clear judgement call on which suggestion is more relevant."
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2019-12-18T00:08:43Z",
        "body": "If you are in the off case where you have a `name` that isn't a `string`, a `length` that isn't a `number`, or any property named `caller`, I'm sure you'll figure it out on your own."
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2019-12-18T22:30:54Z",
        "body": "When the return type of a function is an identity match for the target type, it seems extremely unlikely that \"You forgot to call it?\" is not the best possible error message. It requires a lot of construction to make something where a function *and its return type* are both plausible matches for the target.\r\n\r\nI would be curious to find out how often a function is ever an intentional *source* for a *target* with zero signatures that isn't a top-ish type. Even assigning a function to something nominally uncontroversial like `{ name: string; age?; number }` *smells* like a bug, and people have complained to that effect."
      },
      {
        "user": "weswigham",
        "created_at": "2019-12-18T22:44:10Z",
        "body": "\r\n>I would be curious to find out how often a function is ever an intentional source for a target with zero signatures that isn't a top-ish type\r\n\r\nI've seen assignments to `{length: number}` in the wild."
      },
      {
        "user": "openorclose",
        "created_at": "2020-01-28T14:43:58Z",
        "body": "Does this still need help? I would like to work on this."
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2020-02-06T01:47:14Z",
        "body": "Yes, we're still looking for help here!"
      },
      {
        "user": "openorclose",
        "created_at": "2020-02-06T04:40:10Z",
        "body": "Ok, I'll work on this!\r\n"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2020-03-27T21:47:30Z",
        "body": "I think the fix should be relatively self-contained within `structuredTypeRelatedTo`, preceding or around the block\r\n\r\n```ts\r\n                    // Even if relationship doesn't hold for unions, intersections, or generic type references,\r\n                    // it may hold in a structural comparison.\r\n                    // In a check of the form X = A & B, we will have previously checked if A relates to X or B relates\r\n                    // to X. Failing both of those we want to check if the aggregation of A and B's members structurally\r\n                    // relates to X. Thus, we include intersection types on the source side here.\r\n                    if (source.flags & (TypeFlags.Object | TypeFlags.Intersection) && target.flags & TypeFlags.Object) {\r\n                        // Report structural errors only if we haven't reported any errors yet\r\n                        const reportStructuralErrors = reportErrors && errorInfo === saveErrorInfo.errorInfo && !sourceIsPrimitive;\r\n                        result = propertiesRelatedTo(source, target, reportStructuralErrors, /*excludedProperties*/ undefined, intersectionState);\r\n                        if (result) {\r\n                            result &= signaturesRelatedTo(source, target, SignatureKind.Call, reportStructuralErrors);\r\n                            if (result) {\r\n                                result &= signaturesRelatedTo(source, target, SignatureKind.Construct, reportStructuralErrors);\r\n                                if (result) {\r\n                                    result &= indexTypesRelatedTo(source, target, IndexKind.String, sourceIsPrimitive, reportStructuralErrors, intersectionState);\r\n                                    if (result) {\r\n                                        result &= indexTypesRelatedTo(source, target, IndexKind.Number, sourceIsPrimitive, reportStructuralErrors, intersectionState);\r\n                                    }\r\n                                }\r\n                            }\r\n```"
      },
      {
        "user": "liewrichmond",
        "created_at": "2020-10-01T14:10:56Z",
        "body": "Hi, I'm new here and would like to give this a try. Would anyone mind if I started working on this?"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2020-10-01T15:50:01Z",
        "body": "@liewrichmond go for it! 👍"
      },
      {
        "user": "liewrichmond",
        "created_at": "2020-10-06T15:43:07Z",
        "body": "I've been working on a fix, and I think I might have one but it breaks a couple of tests that I'm not too sure if it's intended behavior or not.\r\n\r\nFor example, \r\n```typescript\r\ninterface Dog {\r\n    barkable: true\r\n}\r\n\r\ndeclare function getRover(): Dog\r\n\r\nlet x: any[] = []\r\n    \r\nx = getRover;\r\n```\r\n\r\n### Before Change \r\n```\r\nType '() => Dog' is missing the following properties from type 'any[]': pop, push, concat, join, and 25 more.ts(2740)\r\n```\r\n### After Change\r\n```\r\nType '() => Dog' is not assignable to type 'any[]'.ts(2322)\r\n```\r\nIs this within spec? and should I submit a PR to get feedback/suggestions on the other failing tests due to the change?"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2020-10-06T17:50:43Z",
        "body": "Yeah, that looks good. You can send a PR and we should be able to iterate on it."
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2022-03-05T00:12:48Z",
        "body": "Thank you @liewrichmond!"
      }
    ]
  },
  {
    "number": 35410,
    "title": "showConfig printing help if no config is found",
    "created_at": "2019-11-28T10:26:06Z",
    "closed_at": "2019-12-23T20:30:21Z",
    "labels": [
      "Bug",
      "Help Wanted",
      "Good First Issue"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/35410",
    "body": "**TypeScript Version:**  3.8.0-dev.20191128\r\n\r\n**Search Terms:**\r\n`showConfig`\r\n\r\n**Example**\r\nwhen running the command `tsc --showConfig` in a folder without a tsconfig.json file it shows the help page\r\n\r\n**Expected behavior:**\r\nthrow an error (for example: `no config found`) or return empty config (for example: `{}`)\r\n\r\n**Actual behavior:**\r\nshows the standard help page from `tsc -h`, wich doesn't even contain any help for `--showConfig`.\r\n**Playground Link:** None\r\n**Related Issues:** None",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/35410/comments",
    "author": "royAmmerschuber",
    "comments": [
      {
        "user": "DanielRosenwasser",
        "created_at": "2019-12-23T20:30:31Z",
        "body": "Thanks @a-tarasyuk!"
      }
    ]
  },
  {
    "number": 34934,
    "title": "Completions for private members appear in JavaScript files",
    "created_at": "2019-11-06T00:23:32Z",
    "closed_at": "2020-06-02T19:47:18Z",
    "labels": [
      "Bug",
      "Help Wanted",
      "Effort: Moderate",
      "Domain: Completion Lists",
      "Domain: JavaScript",
      "Rescheduled"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/34934",
    "body": "When a .d.ts file is included with a .js file (ostensibly created by some .ts file in a galaxy far far away) in order to get intellisense, private class members appear in completions lists. This is probably a bug and we have gotten some feedback from users that they would rather not see this.\r\n\r\nA possibly greater pain point is that when the private member shows up in completion, _the icon is wrong_, I'm guessing because we do not have the full signature for private members in .d.ts files. I believe the lack of full signatures is by design though and I don't believe there is a way to make those members appear method-like without them.\r\n\r\n**TypeScript Version:**  3.6.3\r\n\r\n<!-- Search terms you tried before logging this (so others can find this issue more easily) -->\r\n**Search Terms:**\r\nprivate completion\r\n\r\n**Code**\r\n\r\n**.d.ts**\r\n```ts\r\n// @filename:test.d.ts\r\n/** The 'Test' namespace. */\r\ndeclare namespace Test {\r\n    /** The 'Foo' class.*/\r\n    class Foo {\r\n        /** Constructor. */\r\n        constructor();\r\n        /** I'm private: don't use me. */\r\n        private MethodOne;\r\n        /** I'm public: let's do this. */\r\n        MethodTwo(): void;\r\n    }\r\n}\r\n```\r\n**.js**\r\n```ts\r\n// @filename:file.js\r\nvar foo = new Test.Foo();\r\nfoo.\r\n```\r\n\r\n**Expected behavior:**\r\nThe completion list contains `MethodTwo`.\r\n\r\n**Actual behavior:**\r\nThe completion list contains `MethodOne` and `MethodTwo`.\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/34934/comments",
    "author": "jessetrinity",
    "comments": [
      {
        "user": "orta",
        "created_at": "2019-11-06T15:12:18Z",
        "body": "Yeah, I agree - want to pair on this with me?"
      },
      {
        "user": "Jolg42",
        "created_at": "2020-01-20T09:14:45Z",
        "body": "Hi there :)\r\n\r\nSo it looks like this bug is still present in the latest stable version, what is the status on your end? Would this be fixed soon maybe?\r\n\r\nThis bug is quite annoying for developer experience as a library author because it's suggesting to developers that it is fine to use the private properties (and it's adding a lot of noise to the public ones). Most people won't even know they are actually private. So if they start using them and an internal change breaks these, it will impact the users of the library, even though it's not a real breaking change in the user-facing API."
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2020-01-20T09:26:01Z",
        "body": "Go for it - language service tests are in `tests/cases/fourslash`, look for `// @filename` comments to create mixed a mixed `.js` and `.ts` context. The core logic is in `src/services/`, probably in a file called `completions.ts`."
      },
      {
        "user": "Jolg42",
        "created_at": "2020-06-03T07:20:52Z",
        "body": "Hi @jessetrinity, will this be in a future `3.9.x` release maybe? Or like the milestone suggests the `4.0` August release?"
      },
      {
        "user": "jessetrinity",
        "created_at": "2020-06-03T18:04:36Z",
        "body": "@Jolg42 it should be in 4.0."
      }
    ]
  },
  {
    "number": 33269,
    "title": "typescript helper function wrong name ",
    "created_at": "2019-09-05T18:21:19Z",
    "closed_at": "2020-01-31T18:41:48Z",
    "labels": [
      "Bug",
      "Help Wanted",
      "Effort: Moderate",
      "Domain: Decorators",
      "Domain: JS Emit"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/33269",
    "body": "**TypeScript Version:** Version 3.7.0-dev.xxx, also 3.6.2\r\n\r\n**Search Terms:** typescript helper function wrong name __decorate_1  __decorate  \r\n\r\n**Code**\r\n\r\n```ts\r\nvar __decorate = ( ) => { };\r\n\r\nfunction d(ctor: Function) {    \r\n}\r\n@d\r\nclass C {\r\n}\r\n\r\n```\r\n\r\n**Expected behavior:** The compiler creates the same name for the inserted helper function and the use of the helper function. (`__decorate_1`)\r\n\r\n**Actual behavior:** If there is already a user-defined function that has by chance the same name as one of the TypeScript helper functions (like `__decorate` or `__metadata`), the ts compiler creates two different names for the declaration of the inserted helper and for the function call using the helper.  The same if there is just a variable global or in the same file declared with the same name as one of the TypeScript helper functions. (`declare var __decorate;` )\r\n\r\n```json\r\n{\r\n  \"compileOnSave\": false,\r\n  \"compilerOptions\": {\r\n    \"baseUrl\": \"./\",\r\n    \"outDir\": \"./\",\r\n    \"sourceMap\": true,\r\n    \"newLine\": \"LF\",\r\n    \"module\": \"esnext\",\r\n    \"target\": \"es2017\",\r\n    \"moduleResolution\": \"node\",\r\n    \"skipLibCheck\": true,\r\n    \"experimentalDecorators\": true,\r\n    \"jsx\": \"preserve\",\r\n    \"lib\": [\r\n      \"dom\",\r\n      \"es2015\",\r\n      \"es2016\",\r\n      \"es2017\"\r\n    ]\r\n  }\r\n}\r\n```\r\n\r\nResult with ts compiler version 3.6.2:\r\n```ts\r\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar __decorate = () => { };\r\nfunction d(constructor) {\r\n}\r\nlet C = class C {\r\n};\r\nC = __decorate_1([\r\n    d\r\n], C);\r\n```\r\n\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/33269/comments",
    "author": "dotnetautor",
    "comments": [
      {
        "user": "DanielRosenwasser",
        "created_at": "2019-09-05T18:31:37Z",
        "body": "It's weird to think about with `__decorate`, but this was done intentionally to support overriding the helpers - it's part of why we look up `this && this.__decorate`. See #1193 for an example of this."
      },
      {
        "user": "sandersn",
        "created_at": "2019-09-05T20:13:27Z",
        "body": "The reference `__decorate_1` at the end of the emitted code is still wrong, though."
      },
      {
        "user": "deregtd",
        "created_at": "2019-10-24T18:08:52Z",
        "body": "+1 on this.  We have to keep ReSub on v3.5.3 because 3.6.x blows up with this broken decorate reference issue.  If you want a super easy repro, pull the resub source (github/microsoft/resub) and update to a newer typescript, then observe the outputted javascript which will have a __decorate_1 reference with no matching function. :("
      }
    ]
  },
  {
    "number": 32449,
    "title": "HTMLInputElement have incompatible type for \"selectionDirection\" and setSelectionRange",
    "created_at": "2019-07-17T17:58:09Z",
    "closed_at": "2020-06-16T18:33:55Z",
    "labels": [
      "Bug",
      "Help Wanted",
      "Domain: lib.d.ts"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/32449",
    "body": "**TypeScript Version:**  3.6.0-dev.20190717\r\n**Search Terms:**\r\nselectionDirection HTMLInputElement DOM definition\r\n**Code**\r\n```ts\r\nconst el : HTMLTextAreaElement = new HTMLTextAreaElement();\r\nconst direction = el.selectionDirection;\r\nel.setSelectionRange(el.selectionStart, el.selectionEnd, direction );\r\n```\r\n\r\n**Expected behavior:**\r\nNo error, as el.selectionDirection is definitely a good value for selectionDirection\r\n\r\n**Actual behavior:**\r\ntsc throw an error because el.selectionDirection is of type \"string\" and el.setSelectionRange only accept \"forward\" | \"backward\" | \"none\"\r\n\r\nsolution : \r\nHTMLInputElement.selectionDirection should be of type : \"forward\" | \"backward\" | \"none\" instead of type string. in lib.dom.d.ts at line 7332.\r\n\r\n\r\n**Related Issues:**\r\nthe bug was introduced by the fixing of setSelectionRange as discuted in issue #20419 and PR #20459",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/32449/comments",
    "author": "xileftenurb",
    "comments": [
      {
        "user": "BuckAMayzing",
        "created_at": "2019-08-15T14:34:26Z",
        "body": "@RyanCavanaugh - I put out a PR for this one a couple of weeks back. It doesn't look like it has had anyone look at it yet. Do you know if there's someone I should tag on the PR?"
      },
      {
        "user": "ShuiRuTian",
        "created_at": "2020-06-02T03:57:30Z",
        "body": "@sandersn  Hi, I thought this issue has been fixed by the PR and could be closed."
      }
    ]
  },
  {
    "number": 32068,
    "title": "Formatting needs to leave space between consecutive less-than tokens <",
    "created_at": "2019-06-24T07:52:54Z",
    "closed_at": "2019-06-26T21:10:03Z",
    "labels": [
      "Bug",
      "Help Wanted",
      "Effort: Moderate",
      "Domain: Formatter"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/32068",
    "body": "Using VS-code to edit TypeScript.\r\n\r\nThe source code contains this statement:\r\n\r\n```typescript\r\nif (<number>foo < <number>bar) {\r\n}\r\n```\r\n\r\nIf I press <kbd>Alt</kbd> <kbd>Shift</kbd> <kbd>F</kbd> in VS-code to reformat the source which contains this statement, it becomes ...\r\n\r\n```typescript\r\nif (<number>foo <<number>bar) {\r\n}\r\n```\r\n... which no longer compiles.\r\n\r\nDoes this issue occur when all extensions are disabled?: Yes\r\n\r\n```\r\nVersion: 1.35.0 (user setup)\r\nCommit: 553cfb2c2205db5f15f3ee8395bbd5cf066d357d\r\nDate: 2019-06-04T01:17:12.481Z\r\nElectron: 3.1.8\r\nChrome: 66.0.3359.181\r\nNode.js: 10.2.0\r\nV8: 6.6.346.32\r\nOS: Windows_NT x64 10.0.17134\r\n```",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/32068/comments",
    "author": "cwellsx",
    "comments": [
      {
        "user": "mjbvz",
        "created_at": "2019-06-24T18:40:28Z",
        "body": "Confirmed with typescript@3.6.0-dev.20190623.\r\n\r\nFirst format produces:\r\n\r\n```ts\r\nif (<number>foo <<number>bar) {\r\n\r\n}\r\n```\r\n\r\nSecond format produces:\r\n\r\n```ts\r\nif (<number>foo << number > bar) {\r\n\r\n}\r\n```"
      }
    ]
  },
  {
    "number": 31640,
    "title": "Refactoring: Extract to interface",
    "created_at": "2019-05-29T02:35:48Z",
    "closed_at": "2019-08-28T18:34:41Z",
    "labels": [
      "Suggestion",
      "Help Wanted",
      "Effort: Moderate",
      "Domain: Refactorings"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/31640",
    "body": "The \"extract to type alias\" code fix is great, however, a lot of people (myself included) prefer `interface`s for object types rather than type aliases.\r\n\r\nExtract to interface should work only on an intersection type with some number of anonymous object types, named object types, and type references.\r\n\r\nExamples\r\n\r\n```ts\r\n// before\r\nlet x: { hello: string, world: string };\r\n\r\n// after\r\ninterface NewType {\r\n    hello: string;\r\n    world: string;\r\n}\r\n\r\nlet x: NewType;\r\n```\r\n\r\n```ts\r\n// before\r\nlet x: { hello: string, world: string } & Record<string, string>;\r\n\r\n// after\r\ninterface NewType extends Record<string, string> {\r\n    hello: string;\r\n    world: string;\r\n}\r\n\r\nlet x: NewType;\r\n```\r\n\r\nRelated issues:\r\n\r\n* #23869\r\n* #13082",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/31640/comments",
    "author": "DanielRosenwasser",
    "comments": [
      {
        "user": "DanielRosenwasser",
        "created_at": "2019-05-29T02:40:34Z",
        "body": "P.S. it's okay if the refactoring results in a type that doesn't actually type-check as long as it does \"the right thing\" 90% of the time - don't over-do it (e.g. running on `{ hello: number } & Record<string, string>`)"
      },
      {
        "user": "Kingwl",
        "created_at": "2019-05-29T02:55:07Z",
        "body": "> Extract to interface should work only on an intersection type with some number of anonymous object types, named object types, and type references.\r\n\r\nI prefer deny refactor if there are any type reference(and not a type literal) in the selection"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2019-05-29T02:58:55Z",
        "body": "That's fine (and understandable) - I think it's a reasonable first step for the refactoring, and it would likely hit most of the cases."
      }
    ]
  },
  {
    "number": 30948,
    "title": "Use 'Omit' instead of 'Pick<Exclude<...>>' for object rest",
    "created_at": "2019-04-16T00:21:24Z",
    "closed_at": "2019-04-30T18:19:21Z",
    "labels": [
      "Suggestion",
      "Help Wanted",
      "Good First Issue"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/30948",
    "body": "```ts\r\nfunction f<T extends { a, b }>(x: T) {\r\n    let { a, b, ...rest } = x;\r\n}\r\n```\r\n\r\nToday, we type `rest` as `Pick<T, Exclude<keyof T, \"a\" | \"b\">>`. We should try to type this as `Omit<T, \"a\" | \"b\">` if `Omit` is defined.",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/30948/comments",
    "author": "DanielRosenwasser",
    "comments": [
      {
        "user": "rpgeeganage",
        "created_at": "2019-04-25T22:26:22Z",
        "body": "Hi @sandersn,\r\nCan I take this? I like to contribute.\r\nThank you"
      },
      {
        "user": "sandersn",
        "created_at": "2019-04-25T23:10:30Z",
        "body": "Sure, go ahead! Start by looking at `let deferredGlobalPickSymbol` in checker.ts, and see where and how it's used."
      },
      {
        "user": "rpgeeganage",
        "created_at": "2019-04-26T05:53:23Z",
        "body": "@sandersn , \r\nThank you so much. I’ll start to work on this from today itself.\r\nThank you so much."
      }
    ]
  },
  {
    "number": 30398,
    "title": "Can't exponentiate BigInts",
    "created_at": "2019-03-14T15:50:10Z",
    "closed_at": "2020-05-04T17:14:49Z",
    "labels": [
      "Bug",
      "Help Wanted",
      "Good First Issue",
      "ES2017"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/30398",
    "body": "In normal JavaScript, this works `BigInt(2) ** BigInt(2)`\r\n\r\nBut writing the above in TypeScript, compiles to `Math.pow(BigInt(2), BigInt(2))`, which doesn't work.\r\n\r\nAccording to MDN:\r\n\r\n> [BigInt] cannot be used with methods in the built-in Math object\r\n\r\n---\r\n\r\nTypeScript code\r\n\r\n```ts\r\nBigInt(2) ** BigInt(2)\r\n```\r\n\r\n**Expected behavior:**\r\nReturn 4.\r\n\r\n**Actual behavior:**\r\n\r\n```\r\nTypeError: Cannot convert a BigInt value to a number\r\n    at Math.pow (<anonymous>)\r\n```",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/30398/comments",
    "author": "msafi",
    "comments": [
      {
        "user": "ajafff",
        "created_at": "2019-03-14T17:36:39Z",
        "body": "Why is this an issue? Environments that support BigInt also know the exponentiation operator.\r\nTherefore you don't need to downlevel your code. The only target that makes sense for BigInt is ESnext.\r\nIIRC there's even a compile error if you use BigInt with a different target."
      },
      {
        "user": "msafi",
        "created_at": "2019-03-14T18:51:59Z",
        "body": "@ajafff Oh, it didn't occur to me that I was downleveling. I just ran `tsc` without any configurations. Maybe that's why I was running into this issue. I'll test again later  today after setting the target to ESNext."
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2019-03-14T22:53:08Z",
        "body": "Technically I guess we could give an error when using `bigint`s in exponentiation expressions when targeting anything earlier than ES2017."
      },
      {
        "user": "santoshyadavdev",
        "created_at": "2019-03-21T18:40:40Z",
        "body": "Hi @DanielRosenwasser ,\r\n\r\nI am taking this up, let me know if anyone else working on it."
      },
      {
        "user": "santoshyadavdev",
        "created_at": "2019-03-25T17:51:25Z",
        "body": "Hi @DanielRosenwasser ,\r\n\r\nWhen we target es5 , we are getting \"error TS2304: Cannot find name 'BigInt'.\", if we change the error code to TS2737 which stands for \"BigInt literals are not available when targeting lower than ESNext.\" it will fix the issue, let me know if we can change."
      },
      {
        "user": "JoshuaKGoldberg",
        "created_at": "2019-09-11T11:36:45Z",
        "body": "This looks like it was separately already solved. With this file:\r\n\r\n```ts\r\n3 ** 4n;\r\nBigInt(2) ** BigInt(2);\r\n```\r\n\r\nTargeting `es5`, you get these errors:\r\n\r\n```\r\nindex.ts:1:1 - error TS2365: Operator '**' cannot be applied to types '3' and '4n'.\r\n\r\n1 3 ** 4n;\r\n  ~~~~~~~\r\n\r\nindex.ts:1:6 - error TS2737: BigInt literals are not available when targeting lower than ESNext.\r\n\r\n1 3 ** 4n;\r\n       ~~\r\n\r\nindex.ts:2:1 - error TS2304: Cannot find name 'BigInt'.\r\n\r\n2 BigInt(2) ** BigInt(2);\r\n  ~~~~~~\r\n\r\nindex.ts:2:14 - error TS2304: Cannot find name 'BigInt'.\r\n\r\n2 BigInt(2) ** BigInt(2);\r\n               ~~~~~~\r\n```"
      }
    ]
  },
  {
    "number": 30144,
    "title": "TypeScript has not added regression tests for the regressions",
    "created_at": "2019-02-28T09:36:09Z",
    "closed_at": "2019-03-01T00:22:48Z",
    "labels": [
      "Bug",
      "Help Wanted"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/30144",
    "body": "Regression tests for #30133 which made a lot of regressions are not added. Unfortunately the blind maintainers couldn't find my reports but at least you must add the tests written in #30118 #30049 #30047 to recover your blunder.",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/30144/comments",
    "author": "falsandtru",
    "comments": [
      {
        "user": "falsandtru",
        "created_at": "2019-02-28T09:40:35Z",
        "body": "Or to add regression tests for the large regressions you missed is also unactionable?"
      },
      {
        "user": "jack-williams",
        "created_at": "2019-02-28T10:43:09Z",
        "body": "Some regressions here #30146. It's up to the maintainers to decide if they want to merge this. Note: it's currently 3am in Seattle."
      },
      {
        "user": "falsandtru",
        "created_at": "2019-02-28T10:55:44Z",
        "body": "Nice but why you excluded #30049? And can you include my actual example code? With TypeScript, test cases usually include the reported code for reproducing in bug fixing."
      },
      {
        "user": "jack-williams",
        "created_at": "2019-02-28T11:10:12Z",
        "body": "I excluded #30049 because I did not have chance to look into that; I don't want to add a test case I don't understand. I think that all the issues reduce down to the same problem, so I'm also reluctant to add more noise to the tests. Someone on the team has been assigned to look into each of these issues, so they are not 'blind'.\r\n\r\nI used stripped down code examples that are easy to understand and directly target the issues. I don't have the time right now to change them. You are welcome to submit a fix and I will close my PR."
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2019-02-28T16:46:00Z",
        "body": "@falsandtru your attitude here is getting a bit rough. We're all trying our best here and the constant shade throwing in the past few reports is really not helpful.\r\n\r\nIf you can't report bugs here without name-calling, we'll have to ask you to not participate at all."
      },
      {
        "user": "falsandtru",
        "created_at": "2019-02-28T17:12:55Z",
        "body": "So you will miss the next large regression again until you find it yourself? It is foolish. You must learn from this mistake. Or you don't learn anything? Cool!"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2019-02-28T17:40:32Z",
        "body": "To be clear: I'm just asking you to not insult people."
      },
      {
        "user": "falsandtru",
        "created_at": "2019-02-28T17:48:26Z",
        "body": "How did you want to be explained your mistake? I don't know English enough to do it."
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2019-02-28T19:37:25Z",
        "body": "```diff\r\n- Unfortunately the blind maintainers couldn't find my reports but at least you must add the tests written in #30118 #30049 #30047 to recover your blunder.\r\n+ Unfortunately the maintainers didn't see my reports in #30118 #30049 #30047.\r\n+ This has been extremely frustrating for me.\r\n```"
      },
      {
        "user": "falsandtru",
        "created_at": "2019-02-28T22:01:48Z",
        "body": "Unfortunately, I mean **how to realize you the impact of your mistake in the first reports.** You misread again for yourself, awesome work."
      },
      {
        "user": "falsandtru",
        "created_at": "2019-02-28T22:04:15Z",
        "body": "Anyway your answer is not smart, right?\r\n\r\n> This has been extremely frustrating for me."
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2019-02-28T23:07:15Z",
        "body": "Again, you're using an abrasive tone. If I have misunderstood something for whatever reason, I'm sorry. If I've misrepresented how you feel about the situation, I'm sorry about that too. But your responses\r\n\r\n> Unfortunately, I mean **how to realize you the impact of your mistake in the first reports.** You misread again for yourself, awesome work.\r\n\r\n> Anyway your answer is not smart, right?\r\n\r\nare not constructive and are making it difficult to collaborate."
      },
      {
        "user": "falsandtru",
        "created_at": "2019-02-28T23:54:44Z",
        "body": "I mean how can you prevent the next oversight of the terrible regression such as #27697? If you missed the next terrible regression again, I have to notify it again noisily because it is a terrible regression."
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2019-03-01T00:01:08Z",
        "body": "> I have to notify it again noisily because it is a terrible regression.\r\n\r\nYou don't have to do it \"noisily\". We don't prioritize bug reports based on what kinds of insults are included with them. Thousands of people have successfully reported issues without insulting anyone. No one *needs* to call anyone names to get a bug report noticed here.\r\n\r\nIf you have determined that you're not able to report an issue without being abrasive or abusive about it, then we ask that you not report issues or comment on them. Other people who are able to report issues in a respectful manner will fill in the gap."
      },
      {
        "user": "weswigham",
        "created_at": "2019-03-01T00:22:47Z",
        "body": "> So you will miss the next large regression again until you find it yourself? It is foolish. You must learn from this mistake. Or you don't learn anything? Cool!\r\n\r\nFYI, we didn't miss this, either - we picked this up via DT within a week or so (and have since improved our DT testing infra so we can more quickly know when we break things on DT (we should know within a day reliably now) - though it was mostly slow because we all live in Seattle and were coming off being snowed in/OOF the prior week, lol). We just spent awhile attacking the issue from multiple angles because we didn't _want_ to revert #27697 if we didn't need to, and the interplay in many of the breaks with one of the other PRs merged at the same time made determining the best \"fix\" a longer task (and in the end we merged a PR with a modification on the other PR _and_ a revert of #27697). Relax - #27697 was only in `master` for two weeks. \r\n\r\nAnyways, I've merged #30146, since more tests are always gucci, so I think we're done here~"
      },
      {
        "user": "falsandtru",
        "created_at": "2019-03-01T07:04:41Z",
        "body": "You are thinking you can be understood by other people without doing anything. It's really cool idea to talk with people."
      }
    ]
  },
  {
    "number": 30037,
    "title": "Poor error messages for properties mis-handled as shorthand property declarations",
    "created_at": "2019-02-22T02:01:00Z",
    "closed_at": "2019-04-22T20:14:22Z",
    "labels": [
      "Suggestion",
      "Fixed",
      "Help Wanted",
      "Good First Issue",
      "Domain: Error Messages",
      "Experience Enhancement"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/30037",
    "body": "```ts\r\ndeclare function foo(option: { abcd: number }): void;\r\n\r\nfoo({\r\n    abcd\r\n})\r\n```\r\n\r\n**Today**\r\n\r\n```\r\nCannot find name 'abcd'.\r\n```\r\n\r\n*Ideal**\r\n\r\n```\r\nThis shorthand property declaration is invalid because a local declaration could not be found for 'abcd'. Either declare one or provide an initializer.\r\n```",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/30037/comments",
    "author": "DanielRosenwasser",
    "comments": [
      {
        "user": "Manish-Giri",
        "created_at": "2019-02-22T06:24:04Z",
        "body": "Hi! I'd like to give this a shot. "
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2019-02-22T08:56:36Z",
        "body": "Go for it! Messages in `diagnosticMessages.json`, `gulp generate-diagnostics` creates a new entry in the `Diagnostics` map, and you can specialize the message in `checker.ts`.\r\n\r\n`gulp runtests-parallel` and `gulp baseline-accept` will update the baselines."
      },
      {
        "user": "pbrahmbhatt3",
        "created_at": "2019-02-28T17:02:00Z",
        "body": "Hi,\r\n\r\nCan I work on it too?"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2019-02-28T17:47:11Z",
        "body": "Check with @manish-giri first to see if he's still working on it. If not sure!"
      },
      {
        "user": "pbrahmbhatt3",
        "created_at": "2019-02-28T18:07:18Z",
        "body": "@Manish-Giri  are you still working on it?"
      },
      {
        "user": "Manish-Giri",
        "created_at": "2019-03-01T23:33:32Z",
        "body": "@pbrahmbhatt3 Hi, yes I'm working on it. Thanks."
      },
      {
        "user": "karthikkp",
        "created_at": "2019-04-18T23:33:14Z",
        "body": "@DanielRosenwasser This has been open for a while now. Shall I work on this?"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2019-04-19T00:40:17Z",
        "body": "Sure unless anyone else here is"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2019-04-19T00:42:53Z",
        "body": "Better message:\r\n\r\n```\r\nNo value exists in scope for the shorthand property '{0}'. Either declare one or provide an initializer.\r\n```"
      },
      {
        "user": "karthikkp",
        "created_at": "2019-04-21T16:24:21Z",
        "body": "@DanielRosenwasser Out of curiosity, how many approvals are required to merge a PR?"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2019-04-22T20:15:06Z",
        "body": "Typically 2, but 1 may be fine if it's small enough.\r\n\r\nThanks for the PR!"
      }
    ]
  },
  {
    "number": 29624,
    "title": "Better errors for non-exported types",
    "created_at": "2019-01-28T20:11:33Z",
    "closed_at": "2020-01-21T21:03:23Z",
    "labels": [
      "Suggestion",
      "Fixed",
      "Help Wanted",
      "Good First Issue",
      "Domain: Error Messages",
      "Experience Enhancement"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/29624",
    "body": "```ts\r\n// @filename a.ts\r\n\r\ndeclare function foo(): any\r\n\r\ndeclare function bar(): any;\r\n\r\nexport { bar };\r\n\r\n// @filename b.ts\r\n\r\nimport { foo, bar } from \"./a\";\r\n```\r\n\r\nCurrently we provide the following error messages:\r\n\r\n```\r\nModule '\"./a\"' has no exported member 'foo'.\r\nModule '\"./a\"' has no exported member 'bar'.\r\n```\r\n\r\nWe could instead provide the errors:\r\n\r\n```\r\nModule '\"./a\"' declares 'foo' locally, but it is not exported.\r\nModule '\"./a\"' declares 'bar' locally', but it is exported as 'baz'.\r\n```\r\n\r\nAlso using the\r\n\r\n```\r\n'{0}' is declared here.\r\n```\r\n\r\nrelated span.\r\n\r\nLater on, we could provide quick fixes to respectively\r\n\r\n* Export `foo` from ./a.\r\n* Correct the usage of `bar` to `baz`.",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/29624/comments",
    "author": "DanielRosenwasser",
    "comments": [
      {
        "user": "a-tarasyuk",
        "created_at": "2019-03-29T11:22:57Z",
        "body": "@DanielRosenwasser Is there any way to check if a variable was declared in a module? I mean, in order to show message `Module '\"./a\"' declares 'foo' locally, but it is not exported.`, need to check if it was declared in a module locally. "
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2019-03-29T15:41:36Z",
        "body": "There should be a symbol table for `sourceFile.locals` if it's non-exported (as opposed to `sourceFile.symbol.exports`."
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2020-01-21T21:20:18Z",
        "body": "Thanks @a-tarasyuk!"
      }
    ]
  },
  {
    "number": 29289,
    "title": "addTypeToIntersection shouldn't use `contains`",
    "created_at": "2019-01-07T18:49:51Z",
    "closed_at": "2019-07-17T20:22:54Z",
    "labels": [
      "Help Wanted",
      "Good First Issue",
      "Infrastructure",
      "Domain: Performance"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/29289",
    "body": "Right now it uses `contains` to test for membership in the `typeSet` - this is a linear time membership check (so makes intersection construction exponential at best). Unions are sorted so at least use `binarySearch` which is a bit better - we should probably be building a membership map while constructing the intersection to keep intersections of a large number of objects performant.",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/29289/comments",
    "author": "weswigham",
    "comments": [
      {
        "user": "miloszpp",
        "created_at": "2019-07-09T20:45:42Z",
        "body": "Hi @weswigham! I had a quick look into the source code, could you give me a little hint?\r\n\r\nIn what sense is `typeSet` sorted? As I see, it's an array of `Type`. Are those `Type`s sorted by some property?"
      },
      {
        "user": "weswigham",
        "created_at": "2019-07-09T21:34:57Z",
        "body": "An intersection `typeSet` is not sorted - it keeps input order so overload order is predictable (which is why it uses `contains` right now). What I've proposed is building a map/set journaling membership while the intersection is being constructed, so membership testing is cheaper."
      },
      {
        "user": "miloszpp",
        "created_at": "2019-07-10T15:00:55Z",
        "body": "You mentioned `binarySearch` - that's why I assumed `typeSet` is sorted.\r\n\r\nSo, the solution would be to maintain a separate `Set` that would contain all items that are inside `typeSet` and use it only for membership checking?\r\n\r\nWould it make sense to change `typeSet` into an actual `Set` and later convert it into an array (inside `getIntersectionType`)?"
      },
      {
        "user": "weswigham",
        "created_at": "2019-07-10T17:05:10Z",
        "body": "Possibly - maps and sets are defined to preserve insertion order, so that should be OK."
      },
      {
        "user": "ajafff",
        "created_at": "2019-07-10T17:24:55Z",
        "body": "IIRC it caused issues to use ES6 features like `Map` and `Set` in the compiler because some users expect it to run in ES5 environments. @weswigham I know you investigated dropping support for ES5 runtimes. Is there already a decision?"
      },
      {
        "user": "weswigham",
        "created_at": "2019-07-10T17:26:54Z",
        "body": "Our `createMap` helper function polyfills `Map` on runtimes without it already~"
      },
      {
        "user": "miloszpp",
        "created_at": "2019-07-10T17:50:47Z",
        "body": "Thanks, I can take a look at it then.\r\n\r\nI saw in the guidelines that every change should have test coverage. Do you have a framework for testing performance changes, such as this one?"
      },
      {
        "user": "weswigham",
        "created_at": "2019-07-10T18:30:14Z",
        "body": "Sadly, no, not formally. We can run `@typescript-bot perf test` on the PR to validate that it doesn't regress perf in the compilations we track, at least."
      },
      {
        "user": "fatcerberus",
        "created_at": "2019-07-14T01:08:24Z",
        "body": "> exponential\r\n\r\nIf membership check is linear time O(n) and each intersection member added has to do this check O(m * n) then shouldn’t the worst-case complexity be roughly quadratic?"
      },
      {
        "user": "weswigham",
        "created_at": "2019-07-14T07:03:40Z",
        "body": "The point is moreso that it's not linear or logarithmic, so larger sets of things perform significantly worse. My language is imprecise, yes."
      },
      {
        "user": "fatcerberus",
        "created_at": "2019-07-14T13:36:13Z",
        "body": "Ah, that makes sense, thanks.  But yeah, there's a world of difference between quadratic (n^2) and exponential (2^n) growth - the former can sometimes be acceptable; the latter almost never is.  So it was important (to me) to pin down which one it actually was. :smile:"
      },
      {
        "user": "miloszpp",
        "created_at": "2019-07-16T07:54:39Z",
        "body": "@weswigham should I somehow mark the PR as ready for review?"
      }
    ]
  },
  {
    "number": 29035,
    "title": "Quick fix for 'experimentalDecorators' error",
    "created_at": "2018-12-14T23:14:35Z",
    "closed_at": "2019-04-25T21:55:04Z",
    "labels": [
      "Suggestion",
      "Help Wanted",
      "Good First Issue",
      "Domain: Quick Fixes",
      "Experience Enhancement"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/29035",
    "body": "- Open someone's JS project\r\n- See errors on all methods using decorators, that say \"Set the 'experimentalDecorators' option to remove this warning\"\r\n- But I don't know what that means or where to set it.\r\n \r\nSeems like a good opportunity for a quick fix?\r\n\r\nIt could detect whether you have a tsconfig or jsconfig already and offer to set them there. Or it could create a jsconfig with that setting. Or it could set the implicit config setting that fixes this. Do any of those make sense?",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/29035/comments",
    "author": "roblourens",
    "comments": [
      {
        "user": "mjbvz",
        "created_at": "2018-12-14T23:39:08Z",
        "body": "* The error message should probably say that this must be set in the `tsconfig` or `jsconfig`: `\"Set the 'experimentalDecorators' option in your 'tsconfig' or 'jsconfig' to remove this warning\"`\r\n\r\n* If we do have a `jsconfig` or `tsconfig`, having a quick fix that add `experimentalDecorators` the option would be helpful.\r\n\r\n* If we don't have a jsconfig or tsconfig, the best fix is probably for users to set `\"javascript.implicitProjectConfig.experimentalDecorators\": true` in VS Code. Since the error comes from TS, I'm not sure how we can hint at that "
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2018-12-14T23:48:27Z",
        "body": "Ideally this idea would be maximally useful for the next 8 months. Eventually nobody should get the error message. 😉"
      },
      {
        "user": "amaksimovich2",
        "created_at": "2019-03-14T06:37:23Z",
        "body": "@DanielRosenwasser Can I try to implement this one?"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2019-03-14T06:57:11Z",
        "body": "Sure!"
      },
      {
        "user": "amaksimovich2",
        "created_at": "2019-03-14T07:01:19Z",
        "body": "Can you give me some advices?) It's my first meet with quick fixes functionality"
      },
      {
        "user": "amaksimovich2",
        "created_at": "2019-03-19T10:06:36Z",
        "body": "@DanielRosenwasser As I understand `\"javascript.implicitProjectConfig.experimentalDecorators\": true` is a part of  VSCode config we can't add from code? And also can you explain me how basically happens review  of created PR?"
      }
    ]
  },
  {
    "number": 28893,
    "title": "Allow trailing comma on tuple types.",
    "created_at": "2018-12-07T06:51:04Z",
    "closed_at": "2018-12-10T19:33:34Z",
    "labels": [
      "Suggestion",
      "Help Wanted",
      "Committed",
      "Good First Issue"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/28893",
    "body": "```ts\r\ntype Point = [\r\n    number,\r\n    number,  // error: trailing comma not allowed\r\n];\r\n\r\nconst point = [\r\n    1,\r\n    2,\r\n];\r\n```\r\n\r\nIs there a reason the trailing comma isn't allowed in tuple types?",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/28893/comments",
    "author": "cakoose",
    "comments": [
      {
        "user": "DanielRosenwasser",
        "created_at": "2018-12-10T19:33:46Z",
        "body": "Thanks @a-tarasyuk!"
      }
    ]
  },
  {
    "number": 28296,
    "title": "Codefix for assignment to const",
    "created_at": "2018-11-01T21:53:30Z",
    "closed_at": "2018-11-01T22:22:45Z",
    "labels": [
      "Suggestion",
      "Help Wanted",
      "Good First Issue",
      "Domain: Quick Fixes"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/28296",
    "body": "**TypeScript Version:** 3.2.0-dev.20181031\r\n\r\n**Code**\r\n\r\n```ts\r\nconst isMutable = false;\r\nisMutable = true;\r\n```\r\n\r\n**Expected behavior:**\r\n\r\nThe error at `isMutable = true;` has a codefix to change `const` to `let`.\r\n\r\n**Actual behavior:**\r\n\r\nNo codefix.",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/28296/comments",
    "author": "ghost",
    "comments": [
      {
        "user": "j-oliveras",
        "created_at": "2018-11-01T22:20:39Z",
        "body": "Duplicate of #22473 (has a PR #27970)."
      }
    ]
  },
  {
    "number": 28275,
    "title": "Codefix for 'cannot find name' in for loop",
    "created_at": "2018-11-01T00:24:23Z",
    "closed_at": "2019-07-11T04:47:37Z",
    "labels": [
      "Suggestion",
      "Help Wanted",
      "Good First Issue",
      "Domain: Quick Fixes"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/28275",
    "body": "**TypeScript Version:**  3.2.0-dev.20181031\r\n\r\n**Code**\r\n\r\n```ts\r\nfor (x of []) {}\r\n```\r\n\r\n**Expected behavior:**\r\n\r\nCodefix to convert to `for (const x of []) {}`\r\n\r\n**Actual behavior:**\r\n\r\nNo codefix. It just says `Cannot find name 'x'.`. What do you mean you can't find it? It's right there! After all this time I still have to stare at this for a while to realize the error.",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/28275/comments",
    "author": "ghost",
    "comments": [
      {
        "user": "Kr4pper",
        "created_at": "2018-11-01T16:54:48Z",
        "body": "I am having a look at this. \r\n@andy-ms Would `\"Add const modifier to unresolved variable\"` be an appropriate display text for the codefix? This would be extendable into `\"Add const modifiers to all unresolved variables\"` for the codeFixAll."
      }
    ]
  },
  {
    "number": 28189,
    "title": "jake runtests debug=true does nothing",
    "created_at": "2018-10-28T16:36:15Z",
    "closed_at": "2018-10-30T14:25:43Z",
    "labels": [
      "Bug",
      "Help Wanted",
      "Infrastructure"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/28189",
    "body": "<!-- Please try to reproduce the issue with `typescript@next`. It may have already been fixed. -->\r\n**TypeScript Version:**  3.2.0-dev\r\n\r\n<!-- Search terms you tried before logging this (so others can find this issue more easily) -->\r\n**Search Terms:**\r\njake runtests, jake runtests debug=true, \r\n**Code**\r\n\r\n```ts\r\njake runtests tests=2dArrays debug=true\r\n```\r\n\r\n**Expected behavior:**\r\nNode debugger will start\r\n\r\n**Actual behavior:**\r\nTest runs as normal without stopping for debugging\r\n\r\n**Related Issues:** #27154; it looks like this regressed in #24938, specifically commit 05b40da6c15\r\n\r\nPresumably #24938 intended to remove the use of `--debug-brk` (which is what `debug=true` set) because it is deprecated. However, mocha still supports debugging using the built-in debugger by using the `debug` subcommand.\r\n\r\nThe inspect parameter for runtests should be documented regardless, but if it is intended that `inspect` should be used instead of `debug`, readme.md and contributing.md should be updated to reflect this. ",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/28189/comments",
    "author": "ispedals",
    "comments": [
      {
        "user": "ispedals",
        "created_at": "2018-10-28T17:28:24Z",
        "body": "Notes of what changes are required if this is accepted for a community PR:\r\n\r\n* Document inspect argument in description for TaskNames.runtests in jakefile\r\n* Document the inspect argument in the **Debugging the tests** section in contributing.md\r\n* If bringing back `debug` add the following to `runConsoleTests` in jakefile\r\n ```\r\nif (debug) {\r\n    args.unshift(\"debug\");\r\n}\r\n```\r\n* If `debug` isn't coming back, replace `debug=true` with `inspect=true` in readme and contributing.md and probably make debug be an alias for inspect\r\n"
      },
      {
        "user": "weswigham",
        "created_at": "2018-10-29T18:19:04Z",
        "body": "AFAIK, we just wanna remove the docs and implementation for the `debug` flag as a whole and center on `inspect`."
      }
    ]
  },
  {
    "number": 28086,
    "title": "--downlevelIteration errors should mention using later targets",
    "created_at": "2018-10-23T19:37:43Z",
    "closed_at": "2019-01-15T22:06:58Z",
    "labels": [
      "Fixed",
      "Help Wanted",
      "Good First Issue",
      "Domain: Error Messages",
      "Experience Enhancement"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/28086",
    "body": "```js\r\n// @ts-check\r\nclass Foo {\r\n  constructor(...args) {}\r\n}\r\nfunction makeFoo() {\r\n  return new Foo(...arguments)\r\n}\r\n```\r\n\r\n**Actual**\r\n\r\n> Type 'IArguments' is not an array type. Use compiler option '--downlevelIteration' to allow iterating of iterators.\r\n\r\n**Expected**\r\n\r\n> Type 'IArguments' is not an array type. Either use the '--downlevelIteration' compiler option to allow iterating on iterators, or set the '--target' option to 'es2015' or above.",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/28086/comments",
    "author": "DanielRosenwasser",
    "comments": [
      {
        "user": "kschiang19",
        "created_at": "2018-10-24T03:43:27Z",
        "body": "Hi, can I work on this issue?"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2018-10-24T08:14:02Z",
        "body": "Go for it - update `diagnosticMessages.json`, run the test suite, accept the baselines, and send us a PR."
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2019-01-15T22:07:11Z",
        "body": "Thanks @a-tarasyuk!"
      }
    ]
  },
  {
    "number": 28063,
    "title": "\"Implement inherited abstract class\" TS action generates incorrect types for longer lines",
    "created_at": "2018-10-22T21:51:12Z",
    "closed_at": "2018-12-13T19:21:37Z",
    "labels": [
      "Bug",
      "Help Wanted",
      "Good First Issue",
      "Domain: Quick Fixes"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/28063",
    "body": "_From @robotlolita on October 20, 2018 14:0_\n\nIssue Type: <b>Bug</b>\r\n\r\n### Steps to reproduce:\r\n\r\n1. Given an abstract class with abstract methods that have long signatures *and* use either a Tuple type or a generic type:\r\n\r\n```ts\r\nnamespace some.really.long.generated.type.goes.here.you.know.this_.should.be.pretty.simple {\r\n  export interface Yah {}\r\n}\r\n\r\nnamespace another.really.long.generated.type.goes.here.too.because.who.cares.about.space.do_.you.feel.me {\r\n  export interface Yah {}\r\n}\r\n\r\ninterface this_will_be_collapsed {}\r\n\r\ninterface this_is_fine {}\r\n\r\nabstract class AbstractCstVisitor {\r\n  abstract Node(arg1: [some.really.long.generated.type.goes.here.you.know.this_.should.be.pretty.simple.Yah[],  another.really.long.generated.type.goes.here.too.because.who.cares.about.space.do_.you.feel.me.Yah[]], arg2: [this_will_be_collapsed], arg3: Set<this_will_be_collapsed>, arg4: this_is_fine): Set<this_will_be_collapsed>;\r\n}\r\n```\r\n\r\n2. If you create a class that inherits from this:\r\n\r\n```ts\r\nclass CstVisitorImplementation extends AbstractCstVisitor {\r\n}\r\n```\r\n\r\n3. Then select the class's name and use the \"Implement inherited abstract class\" fix action, the type parameters for generic types and positional types in a tuple type will be written as `...`:\r\n\r\n```ts\r\nclass CstVisitorImplementation extends AbstractCstVisitor {\r\n  Node(arg1: [some.really.long.generated.type.goes.here.you.know.this_.should.be.pretty.simple.Yah[], another.really.long.generated.type.goes.here.too.because.who.cares.about.space.do_.you.feel.me.Yah[]], arg2: [...], arg3: Set<...>, arg4: this_is_fine): Set<...> {\r\n    throw new Error(\"Method not implemented.\");\r\n  }\r\n}\r\n```\r\n\r\n### Expected result:\r\n\r\nThe types should be correctly written in the generated methods:\r\n\r\n```ts\r\nclass CstVisitorImplementation extends AbstractCstVisitor {\r\n  Node(arg1: [some.really.long.generated.type.goes.here.you.know.this_.should.be.pretty.simple.Yah[],  another.really.long.generated.type.goes.here.too.because.who.cares.about.space.do_.you.feel.me.Yah[]], arg2: [this_will_be_collapsed], arg3: Set<this_will_be_collapsed>, arg4: this_is_fine): Set<this_will_be_collapsed> {\r\n    throw new Error(\"Method not implemented.\");\r\n  }\r\n}\r\n```\r\n\r\n### Additional information:\r\n\r\nThis is unlikely to show up in most code bases tbh. I only ran into this because I'm generating a lot of code, which includes abstract classes for implementing visitors on a CST directly from a grammar (which doesn't have semantic actions), so some methods have a huge amount of parameters, and consequently the lines end up pretty long.\r\n\r\nIf someone can point me where these actions are implemented I could try to submit a patch for this.\r\n\r\n---\r\n\r\nVS Code version: Code - Insiders 1.29.0-insider (45d5d153bbebed743b77e426615aade34971eb46, 2018-10-19T06:51:31.263Z)\r\nOS version: Linux x64 4.15.0-36-generic\r\n\r\n<details>\r\n<summary>System Info</summary>\r\n\r\n|Item|Value|\r\n|---|---|\r\n|CPUs|Intel(R) Core(TM) i5-6200U CPU @ 2.30GHz (4 x 2714)|\r\n|GPU Status|2d_canvas: enabled<br>checker_imaging: disabled_off<br>flash_3d: enabled<br>flash_stage3d: enabled<br>flash_stage3d_baseline: enabled<br>gpu_compositing: enabled<br>multiple_raster_threads: enabled_on<br>native_gpu_memory_buffers: disabled_software<br>rasterization: disabled_software<br>video_decode: unavailable_software<br>video_encode: unavailable_software<br>webgl: enabled<br>webgl2: enabled|\r\n|Load (avg)|2, 2, 2|\r\n|Memory (System)|7.70GB (1.70GB free)|\r\n|Process Argv|--unity-launch|\r\n|Screen Reader|no|\r\n|VM|0%|\r\n\r\n</details>Extensions: none\r\n<!-- generated by issue reporter -->\n\n_Copied from original issue: Microsoft/vscode#61385_",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/28063/comments",
    "author": "mjbvz",
    "comments": [
      {
        "user": "DanielRosenwasser",
        "created_at": "2018-10-22T22:54:36Z",
        "body": "Should just be a matter of plumbing through the appropriate flags to `typeToString` or whatever API this is using."
      }
    ]
  },
  {
    "number": 28053,
    "title": "Expected 0-2 type arguments, but got 1",
    "created_at": "2018-10-22T16:37:59Z",
    "closed_at": "2018-12-11T17:54:39Z",
    "labels": [
      "Bug",
      "Fixed",
      "Help Wanted",
      "Domain: Error Messages"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/28053",
    "body": "**TypeScript Version:**  3.2.0-dev.20181020\r\n\r\n**Code**\r\n\r\n```ts\r\nnew Map<string>();\r\n```\r\n(as of #28052)\r\n\r\n**Expected behavior:**\r\n\r\n```\r\nNo overload expects 1 type argument, but overloads do exist that expect either 0 or 2 type arguments.\r\n```\r\n\r\n**Actual behavior:**\r\n\r\n```Expected 0-2 type arguments, but got 1.```\r\n\r\n**Related Issues:** #19220\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/28053/comments",
    "author": "ghost",
    "comments": [
      {
        "user": "fatcerberus",
        "created_at": "2018-10-22T18:53:02Z",
        "body": "To be clear, the issue is with the error message and not the error itself, correct?"
      },
      {
        "user": "ghost",
        "created_at": "2018-10-22T18:57:23Z",
        "body": "Right."
      },
      {
        "user": "pesca",
        "created_at": "2018-10-27T01:02:52Z",
        "body": "@andy-ms As per #19220, the error should give the next lowest and highest arity. What if the arity is not between a pair? Consider:\r\n\r\n```ts\r\nnew Map<any, any, any>();\r\n```\r\n\r\nWe get `Expected 0-2 type arguments, but got 3` which isn't contradictory (like the one this issue is trying to address) but still misleading.\r\n\r\nAlso the expected behavior is incorrect when the given arity does not equal 1. Example: `No overload expects 3 type argument`. Several error messages overlook this detail. Possible solutions:\r\n\r\n* Relevant morphemes are parenthesized: `No overload expects 5 type argument(s)`\r\n* Relevant words are parametrized"
      },
      {
        "user": "ghost",
        "created_at": "2018-11-02T22:49:07Z",
        "body": "> Relevant words are parametrized\r\n\r\nI don't think that would work with localization -- we can't have `No_overload_expects_5_type_0, \"arguments\"` because \"arguments\" isn't the right word in yiddish. So we have to create two separate error codes if we want to support plurals.\r\n\r\nAs for `Expected 0-2 type arguments, but got 3`, I suppose that could be `No overload expects 3 arguments, but an overload does exist that expects 2 arguments.`"
      },
      {
        "user": "pesca",
        "created_at": "2018-11-06T10:05:16Z",
        "body": "@andy-ms OK, I opened a PR."
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2018-12-12T19:30:23Z",
        "body": "Thanks @pesca!"
      }
    ]
  },
  {
    "number": 27676,
    "title": "`jake local` to build entire TypeScript codebase using LKG?",
    "created_at": "2018-10-10T05:55:48Z",
    "closed_at": "2019-03-13T17:34:45Z",
    "labels": [
      "Help Wanted",
      "Infrastructure"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/27676",
    "body": "<!-- 🚨 STOP 🚨 𝗦𝗧𝗢𝗣 🚨 𝑺𝑻𝑶𝑷 🚨\r\n\r\nHalf of all issues filed here are duplicates, answered in the FAQ, or not appropriate for the bug tracker. Please read the FAQ first, especially the \"Common Feature Requests\" section.\r\n\r\n-->\r\n\r\n## Search Terms\r\n\r\nLKG build bootstrap\r\n\r\nI'm having a hard time finding search terms that give me a reasonable number of issues to review. :(\r\n\r\n## Suggestion\r\n\r\n`jake local` should build the entire TypeScript codebase using the LKG compiler, instead of using the LKG compiler for the first stage of the build and the newly built compiler for the second stage.  If it's important to be able to test the new compiler's ability to compile the whole codebase without first copying the new compiler to the LKG, there should be a separate jake target for that.\r\n\r\n## Use Cases\r\n\r\nWhen I'm working on a risky change to the compiler, currently I have to get the compiler working well enough to complete the second stage of `jake local` before I'm able to run the language service or the test suite.  Sometimes it's difficult to diagnose failures to compile such a complex real-world codebase.  If I could run the test suite, the same root cause might produce a failure on a much smaller test case that would be much easier to diagnose.  If I could run the language service in VS Code, I would get a much more rapid cycle for testing error reporting and type simplification on small examples than having to run the compiler at the command line.\r\n\r\n## Examples\r\n\r\nN/A?\r\n\r\n## Checklist\r\n\r\nMy suggestion meets these guidelines:\r\n* [X] This wouldn't be a breaking change in existing TypeScript / JavaScript code\r\n* [X] This wouldn't change the runtime behavior of existing JavaScript code\r\n* [X] This could be implemented without emitting different JS based on the types of the expressions\r\n* [X] This isn't a runtime feature (e.g. new expression-level syntax)\r\n\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/27676/comments",
    "author": "mattmccutchen",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2018-10-10T19:03:48Z",
        "body": "We absolutely agree and have been meaning to do this for a while. Using one tool for the whole build will also improve overall build times which is something we'd very much like."
      },
      {
        "user": "mattmccutchen",
        "created_at": "2018-10-10T20:48:50Z",
        "body": "I'd like to help, but I just think it won't be worthwhile for me to try to learn the ins and outs of how the build works now, let alone how you envision it to work.  I'll leave this one to you and continue working on the issues I know something about.  I could write a PR that trivially replaces `built/local/tsc.js` with `lib/tsc.js`, but it sounds like that isn't what you want."
      },
      {
        "user": "mattmccutchen",
        "created_at": "2019-02-10T18:07:22Z",
        "body": "@rbuckton Am I correct in thinking this was done in 056028b?  If so, I'll close the issue."
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2019-03-13T17:34:45Z",
        "body": "Yep, this is done now"
      }
    ]
  },
  {
    "number": 27496,
    "title": "Array functions taking predicates should not have to return boolean.",
    "created_at": "2018-10-02T11:34:51Z",
    "closed_at": "2019-04-30T16:47:13Z",
    "labels": [
      "Bug",
      "Help Wanted",
      "Domain: lib.d.ts"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/27496",
    "body": "## Search Terms\r\n\r\npredicate find force boolean\r\n\r\n## Suggestion\r\n\r\nAs per #5850 `array.prototype.filter` doesn't enforce `boolean` as a return type anymore. I want to propose the same behavior for wherever a predicate is needed. This means not only `filter`, but `find`, `some`, `every `and maybe others. These functions should not enforce boolean as return type of the predicate passed to them.\r\n\r\n## Use Cases\r\n\r\nThis will be useful wherever the developer is looking for a result that is not missing some value(s).\r\n\r\n## Examples\r\n\r\nSay I want to find the first `parkSpace` that has `position`. This works in TypeScript 3.1.1:\r\n`this.selectedParkSpace = this.parkSpaces.filter(o => o.position)[0] || null;`\r\n\r\nbut this doesn't:\r\n`this.selectedParkSpace = this.parkSpaces.find(o => o.position) || null;`\r\n\r\nFor the latter, TypeScript complains:\r\n> Type 'undefined' is not assignable to type 'boolean'.\r\n\r\n## Checklist\r\n\r\nMy suggestion meets these guidelines:\r\n* [x] This wouldn't be a breaking change in existing TypeScript / JavaScript code\r\n* [x] This wouldn't change the runtime behavior of existing JavaScript code\r\n* [x] This could be implemented without emitting different JS based on the types of the expressions\r\n* [x] This isn't a runtime feature (e.g. new expression-level syntax)\r\n\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/27496/comments",
    "author": "theSdev",
    "comments": [
      {
        "user": "ghost",
        "created_at": "2018-10-02T16:15:25Z",
        "body": "Duplicate of #19456?"
      },
      {
        "user": "theSdev",
        "created_at": "2018-10-02T17:02:09Z",
        "body": "@andy-ms definitely not. #19456 is about making this behavior optional for filter whereas I'm suggesting to expand this behavior to similar cases."
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2019-04-23T19:28:05Z",
        "body": "Based on discussion, we'd like to see this with the return type being `unknown` and see if that breaks anything"
      }
    ]
  },
  {
    "number": 27312,
    "title": "Missing semi-colon in the `extendsHelper`",
    "created_at": "2018-09-24T16:33:20Z",
    "closed_at": "2018-10-02T19:26:43Z",
    "labels": [
      "Bug",
      "Help Wanted",
      "Good First Issue"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/27312",
    "body": "The missing semi-colon after the declaration of the `extendStatics` variable/function (es2015.ts, line 4082) results in linting errors (JSHint).  For projects that contain both TypeScript and JavaScript source files, this presents a problem in CI builds, as its not always feasible to bypass semi-colon terminator requirements when linting the project.\r\n\r\nIt looks like this is just an oversight, since semi-colons are used consistently elsewhere.   \r\n\r\nThis would not show up as a build error since the helper is specified as a string of text.\r\n\r\n**Expected behavior:**\r\nThe `extendsHelper` helper should include a semi-colon after declaring the `extendsStatic` variable.\r\n\r\n**Actual behavior:**\r\nThe semi-colon is missing.\r\n\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/27312/comments",
    "author": "spratmannc",
    "comments": [
      {
        "user": "spratmannc",
        "created_at": "2018-09-24T16:44:17Z",
        "body": "#27313 Should address this."
      },
      {
        "user": "PaulIvanov",
        "created_at": "2018-10-02T05:00:55Z",
        "body": "does this issue need to be closed?"
      },
      {
        "user": "spratmannc",
        "created_at": "2018-10-02T12:48:29Z",
        "body": "No.  I'm still waiting on pull request #27313 to be reviewed.  Do I need to do something special to get it looked at?"
      },
      {
        "user": "spratmannc",
        "created_at": "2018-10-02T19:26:43Z",
        "body": "PR was completed.  Closing issue."
      }
    ]
  },
  {
    "number": 26656,
    "title": "Bad formatting for default generic type arguments in type declarations",
    "created_at": "2018-08-24T10:28:16Z",
    "closed_at": "2019-02-20T20:16:19Z",
    "labels": [
      "Bug",
      "Fixed",
      "Help Wanted",
      "Domain: Formatter"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/26656",
    "body": "<!-- Please try to reproduce the issue with `typescript@next`. It may have already been fixed. -->\r\n**TypeScript Version:**  3.1.0-dev.20180824\r\n\r\n<!-- Search terms you tried before logging this (so others can find this issue more easily) -->\r\n**Search Terms:** tuple generic space\r\n\r\n**Code**\r\nFormat this:\r\n```ts\r\ntype Foo<\r\n\tT1 extends any[],\r\n\tT2 extends any[] = []\r\n> = T1 & T2;\r\n```\r\n\r\n**Expected behavior:**\r\nEither **no change** or the following, although I would prefer no indentation on the last line to be consistent with curly braces and object literals:\r\n```ts\r\ntype Foo<\r\n\tT1 extends any[],\r\n\tT2 extends any[] = []\r\n\t> = T1 & T2;\r\n```\r\n**Actual behavior:**\r\n```ts\r\ntype Foo<\r\n\tT1 extends any[],\r\n\tT2 extends any[]=[] // <= TSLint complains about missing whitespace\r\n\t> = T1 & T2;\r\n```\r\n**Related Issues:** none found\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/26656/comments",
    "author": "AlCalzone",
    "comments": [
      {
        "user": "AlCalzone",
        "created_at": "2018-08-24T10:54:15Z",
        "body": "Using another type as a default, only one whitespace is missing:\r\n```ts\r\ntype Bar<T> = T;\r\n\r\ntype Foo<\r\n\tT1 extends any[],\r\n\tT2 extends any[] = Bar<T1>\r\n> = T1 & T2;\r\n```\r\nbecomes\r\n```ts\r\ntype Bar<T> = T;\r\n\r\ntype Foo<\r\n\tT1 extends any[],\r\n\tT2 extends any[]= Bar<T1>\r\n\t> = T1 & T2;\r\n```"
      },
      {
        "user": "collin5",
        "created_at": "2018-09-13T03:50:48Z",
        "body": "I would love to pick this up. Any pointers to point me in the right direction? thanks!"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2019-02-20T20:16:37Z",
        "body": "Thanks @fuafa!"
      }
    ]
  },
  {
    "number": 26606,
    "title": "System module format updates: dynamic import, import meta, top-level await",
    "created_at": "2018-08-22T18:04:35Z",
    "closed_at": "2019-08-09T22:55:22Z",
    "labels": [
      "Bug",
      "Help Wanted"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/26606",
    "body": "<!-- 🚨 STOP 🚨 𝗦𝗧𝗢𝗣 🚨 𝑺𝑻𝑶𝑷 🚨\r\n\r\nHalf of all issues filed here are duplicates, answered in the FAQ, or not appropriate for the bug tracker. Please read the FAQ first, especially the \"Common Feature Requests\" section.\r\n\r\n-->\r\n\r\n## Search Terms\r\n\r\nSystem modules, dynamic import, import meta, top-level await\r\n\r\n## Suggestion\r\n\r\nI wanted to just create an issue to track updates to the System module format, which are all supported in the current stable release.\r\n\r\nI've been meaning to get to this for a while, but haven't had time to dive into the code. So instead, here are the full transforms to track here for now.\r\n\r\nBabel supports all of these except for top-level await support.\r\n\r\n## Use Cases\r\n\r\nSystem module format output support for dynamic `import()`, `import.meta.x`, `import.meta.url` and top-level await.\r\n\r\n## Examples\r\n\r\n<!-- Show how this would be used and what the behavior would be -->\r\n\r\nThe transformations that are supported are the following:\r\n\r\n### Dynamic Import\r\n\r\n```js\r\nimport('./x').then(x => ...);\r\n```\r\n\r\n->\r\n\r\n```js\r\nSystem.register([], function (exports, context) {\r\n  return {\r\n    setters: [],\r\n    execute: function () {\r\n      context.import('./x').then(x => ...);\r\n    }\r\n  };\r\n});\r\n```\r\n\r\n### import.meta and import.meta.url\r\n\r\n```js\r\nconsole.log(import.meta);\r\nconsole.log(import.meta.url);\r\n```\r\n\r\n->\r\n\r\n```js\r\nSystem.register([], function (exports, context) {\r\n  return {\r\n    setters: [],\r\n    execute: function () {\r\n      console.log(context.meta);\r\n      console.log(context.meta.url);\r\n    }\r\n  };\r\n});\r\n```\r\n\r\n### Top-level await\r\n\r\n```js\r\nconsole.log('sync');\r\nawait new Promise(resolve => setTimeout(resolve));\r\nconsole.log('async');\r\n```\r\n\r\n->\r\n\r\n```js\r\nSystem.register([], function (exports, context) {\r\n  return {\r\n    setters: [],\r\n    execute: async function () {\r\n      console.log('sync');\r\n      await new Promise(resolve => setTimeout(resolve));\r\n      console.log('async');\r\n    }\r\n  };\r\n});\r\n```\r\n\r\nWhere in dependency graphs, SystemJS supports variant B of the top-level await proposal.\r\n\r\n## Checklist\r\n\r\nMy suggestion meets these guidelines:\r\n* [x] This wouldn't be a breaking change in existing TypeScript / JavaScript code\r\n* [x] This wouldn't change the runtime behavior of existing JavaScript code\r\n* [x] This could be implemented without emitting different JS based on the types of the expressions\r\n* [x] This isn't a runtime feature (e.g. new expression-level syntax)\r\n\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/26606/comments",
    "author": "guybedford",
    "comments": [
      {
        "user": "rbuckton",
        "created_at": "2019-08-09T22:15:28Z",
        "body": "A few updates:\r\n- Dynamic `import()` is already supported in System.\r\n- `import.meta` seems relatively safe and stable. I will break this out into its own issue to track this specific feature.\r\n- Top-level await is a more complicated ask. I will also break it out into its own specific issue for tracking purposes."
      },
      {
        "user": "rbuckton",
        "created_at": "2019-08-09T22:55:22Z",
        "body": "Closing in favor of the more focused issues."
      },
      {
        "user": "guybedford",
        "created_at": "2019-08-10T03:54:21Z",
        "body": "Thanks @rbuckton, great to see progress here."
      }
    ]
  },
  {
    "number": 26580,
    "title": "Codefix for \"Did you mean to include 'new'?\"",
    "created_at": "2018-08-21T16:28:14Z",
    "closed_at": "2018-11-15T00:53:26Z",
    "labels": [
      "Suggestion",
      "Fixed",
      "Help Wanted",
      "Good First Issue",
      "Domain: Quick Fixes",
      "Experience Enhancement"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/26580",
    "body": "## Suggestion\r\n\r\nGiven this code:\r\n\r\n```ts\r\nclass C {}\r\nC();\r\n```\r\nThe error message says `Did you mean to include 'new'?`. We should have code fix that adds 'new' in front of the call expression.",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/26580/comments",
    "author": "ghost",
    "comments": [
      {
        "user": "LasaleFamine",
        "created_at": "2018-10-01T08:13:42Z",
        "body": "Hi there, I would like to help with this (maybe simple) task. Have you some hint for me to start working on this? \r\n\r\nI'm just getting inside the source code, maybe I will find something meanwhile.\r\n\r\nEDIT: Whoops! I didn't see the PR already opened. I will find another issue 😄 "
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2018-11-15T00:56:51Z",
        "body": "No worries @LasaleFamine; thanks @iliashkolyar!"
      }
    ]
  },
  {
    "number": 26098,
    "title": "Better errors for indexing gettable/settable values",
    "created_at": "2018-07-31T18:32:35Z",
    "closed_at": "2019-04-30T15:31:38Z",
    "labels": [
      "Bug",
      "Fixed",
      "Help Wanted",
      "Good First Issue",
      "Domain: Error Messages"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/26098",
    "body": "@sandersn found a case where, upon turning on `noImplicitAny` in Puppeteer, we issued the following error on a `Map`:\r\n\r\n```\r\nElement implicitly has an 'any' type because type 'Map<string, Function>' has no index signature.\r\n```\r\n\r\nWe should give a more specialized error message in cases where there is no index signature, but the value has a method `get` that takes a `string`, or when \r\n\r\n```\r\nElement implicitly has an 'any' type because type '{0}' has no index signature. Did you mean to call '{1}'?\r\n```",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/26098/comments",
    "author": "DanielRosenwasser",
    "comments": [
      {
        "user": "collin5",
        "created_at": "2018-08-05T21:21:57Z",
        "body": "@DanielRosenwasser I would love to give this a try as my first PR. Any pointers to give me direction on this? Thank you!"
      },
      {
        "user": "sandersn",
        "created_at": "2018-08-06T17:19:05Z",
        "body": "@collin5 I would start by searching for the error message that you want to replace. Spaces are replaced by underscores in the code. Then add a case above that uses `getTypeOfPropertyOfType`, `getSingleCallSignature`, `getMinArgumentCount` and `getTypeAtPosition` to look for a method named get with a single string string parameter.\r\n\r\nTwo more things:\r\n1. diagnosticMessage.json is where you add error messages.\r\n2. tests/cases/compiler/ is where you add new test cases, which will add new baselines after a test run."
      },
      {
        "user": "collin5",
        "created_at": "2018-08-08T15:17:59Z",
        "body": "@sandersn Thank you! Will open a PR for this soon."
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2019-04-30T16:59:37Z",
        "body": "Thanks @collin5!"
      },
      {
        "user": "collin5",
        "created_at": "2019-04-30T18:22:52Z",
        "body": "You're most welcome 🙂."
      }
    ]
  },
  {
    "number": 25916,
    "title": "Doc comment has trailing space",
    "created_at": "2018-07-25T00:36:15Z",
    "closed_at": "2018-07-28T18:40:10Z",
    "labels": [
      "Bug",
      "Fixed",
      "Help Wanted",
      "Domain: JSDoc",
      "Domain: Quick Info"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/25916",
    "body": "**TypeScript Version:**  master\r\n\r\n**Code**\r\n\r\n```ts\r\n/// <reference path='fourslash.ts'/>\r\n\r\n// @Filename: quickInfoJsDocTags.ts\r\n/////** Doc */\r\n////const /**/x = 0;\r\n\r\nverify.quickInfoAt(\"\", \"const x: 0\", \"Doc\");\r\n```\r\n\r\n**Expected behavior:**\r\n\r\nTest passes.\r\n\r\n**Actual behavior:**\r\n\r\nTest fails. Doc comment is actually `\"Doc \"`.",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/25916/comments",
    "author": "ghost",
    "comments": [
      {
        "user": "tschaub",
        "created_at": "2018-07-27T23:37:21Z",
        "body": "I'm interested in helping out with the JSDoc support in TypeScript.  Let me know if #26029 looks like a reasonable approach to this issue.  Thanks!"
      },
      {
        "user": "ghost",
        "created_at": "2018-07-28T00:02:51Z",
        "body": "Related: #21123"
      },
      {
        "user": "mhegazy",
        "created_at": "2018-07-28T18:40:28Z",
        "body": "thanks @tschaub!"
      }
    ]
  },
  {
    "number": 25770,
    "title": "Bad error message for type used as index",
    "created_at": "2018-07-18T15:02:17Z",
    "closed_at": "2020-08-21T17:42:48Z",
    "labels": [
      "Bug",
      "Help Wanted",
      "Domain: Error Messages",
      "Domain: Mapped Types"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/25770",
    "body": "**TypeScript Version:** 3.1.0-dev.20180717\r\n\r\n**Code**\r\n\r\n```ts\r\ntype S = \"a\" | \"b\";\r\ntype O = { [S]: number };\r\n```\r\n\r\n**Expected behavior:**\r\n\r\nError message telling me to use `K in S`.\r\n\r\n**Actual behavior:**\r\n\r\n`src/a.ts:2:13 - error TS2693: 'S' only refers to a type, but is being used as a value here.`",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/25770/comments",
    "author": "ghost",
    "comments": [
      {
        "user": "a-tarasyuk",
        "created_at": "2018-07-18T17:52:56Z",
        "body": "@mhegazy @andy-ms @DanielRosenwasser which message will be acceptable to this case?"
      },
      {
        "user": "ghost",
        "created_at": "2018-07-18T18:06:53Z",
        "body": "I'm thinking something like:\r\n`'S' is a type, not a symbol. To use 'S' as a key type of a mapped type, use 'K in S'.`\r\n\r\n(Note that with `const S = Symbol();` the code would compile as-is.)\r\nNote that a mapped type will only work here if the type does not have any other properties; see #24286.\r\nWe could also add a codefix triggered by this diagnostic."
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2020-08-21T17:43:10Z",
        "body": "Thanks @a-tarasyuk!"
      }
    ]
  },
  {
    "number": 25751,
    "title": "quick fix for function only contains one jsx element and have not the return statement",
    "created_at": "2018-07-18T04:29:27Z",
    "closed_at": "2020-04-02T17:06:15Z",
    "labels": [
      "Suggestion",
      "Help Wanted",
      "Good First Issue",
      "Domain: Error Messages",
      "Domain: Quick Fixes",
      "Update Docs on Next Release"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/25751",
    "body": "<!-- 🚨 STOP 🚨 𝗦𝗧𝗢𝗣 🚨 𝑺𝑻𝑶𝑷 🚨\r\n\r\nHalf of all issues filed here are duplicates, answered in the FAQ, or not appropriate for the bug tracker. Please read the FAQ first, especially the \"Common Feature Requests\" section.\r\n\r\n-->\r\n\r\n## Search Terms\r\nquickfix, jsx, function\r\n\r\n<!-- List of keywords you searched for before creating this issue. Write them down here so that others can find this suggestion more easily -->\r\n\r\n## Suggestion\r\nquick fix for function only contains one jsx element and have not the return statement\r\n<!-- A summary of what you'd like to see added or changed -->\r\n\r\n## Use Cases\r\n\r\nthe pattern of a function with block body that only have one jsx element without return statement  \r\nthat seems a error\r\ncould we provide a quickfix for that?\r\n\r\n<!--\r\nWhat do you want to use this for?\r\nWhat shortcomings exist with current approaches?\r\n-->\r\n\r\n## Examples\r\n```ts\r\n\r\nitems.map(x => {\r\n  <div>123</div>\r\n})\r\n\r\n```\r\n\r\nto \r\n\r\n```ts\r\n\r\nitems.map(x => (\r\n  <div>123</div>\r\n))\r\n\r\n```\r\n\r\n<!-- Show how this would be used and what the behavior would be -->\r\n\r\n## Checklist\r\n\r\nMy suggestion meets these guidelines:\r\n* [x] This wouldn't be a breaking change in existing TypeScript / JavaScript code\r\n* [x] This wouldn't change the runtime behavior of existing JavaScript code\r\n* [x] This could be implemented without emitting different JS based on the types of the expressions\r\n* [x] This isn't a runtime feature (e.g. new expression-level syntax)\r\n\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/25751/comments",
    "author": "Kingwl",
    "comments": [
      {
        "user": "DanielRosenwasser",
        "created_at": "2018-07-18T05:42:31Z",
        "body": "Great idea. It doesn't even have to be limited to JSX. I'm not sure how we'd plumb the logic through, but there are two fixes I'd have in mind:\r\n\r\n1. For any block body containing a single *ExpressionStatement* whose expression's type matches the expected type, suggest the following:\r\n  * Add a `return` statement.\r\n  * Remove block body braces.\r\n  * Replace braces with parentheses.\r\n2. For any block body containing only a labeled *ExpressionStatement*, check to see if the expected type contains a property with the same name as the label, and if so, suggest\r\n  * Wrap this block with parentheses."
      },
      {
        "user": "Kingwl",
        "created_at": "2018-07-18T06:18:54Z",
        "body": "should that a quickfix? maybe refactor is more suitable"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2018-07-18T06:28:07Z",
        "body": "Well, I guess your example is a refactoring since there's no error (you just end up producing a `void[]`.\r\n\r\nThe cases I have in mind should have an associated error."
      },
      {
        "user": "Kingwl",
        "created_at": "2018-07-18T06:44:00Z",
        "body": "sometime we cannot infer the return type(no context, no type annotation)  \r\nwill we ignore those case?"
      },
      {
        "user": "Kingwl",
        "created_at": "2018-08-10T06:16:44Z",
        "body": "need some help:\r\nhow could i know type are related in quick fix without `isTypeRelatedTo`😢"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2020-04-02T17:16:36Z",
        "body": "Thanks @Kingwl!"
      }
    ]
  },
  {
    "number": 25429,
    "title": "Provide a better error message when \"async\" is mistyped?",
    "created_at": "2018-07-04T06:42:12Z",
    "closed_at": "2021-07-14T20:50:55Z",
    "labels": [
      "Bug",
      "Help Wanted",
      "Domain: Error Messages"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/25429",
    "body": "## Search Terms\r\n\r\nerror message async function \r\n\r\n## Suggestion\r\n\r\nWhen I mistype `async` as something like `asdync`, the error messages are quite unhelpful. It would be nice to have \"did you mean async?\" suggestions, as when we mistype a variable name. Perhaps if the edit distance from this particular keyword is small?\r\n\r\nIf this idea is a good one, it might make sense to expand it to `public`, `protected`, etc.\r\n\r\n## Use Cases\r\n\r\nThis is a common thing for me, sadly. I assume new users have this problem as well.\r\n\r\n## Examples\r\n\r\n```typescript\r\nasdync foo() { }\r\n\r\nclass Foo {\r\n    private asdync bar() { }\r\n}\r\n```\r\n\r\n## Checklist\r\n\r\nMy suggestion meets these guidelines:\r\n* [x] This wouldn't be a breaking change in existing TypeScript / JavaScript code\r\n* [x] This wouldn't change the runtime behavior of existing JavaScript code\r\n* [x] This could be implemented without emitting different JS based on the types of the expressions\r\n* [x] This isn't a runtime feature (e.g. new expression-level syntax)\r\n\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/25429/comments",
    "author": "JoshuaKGoldberg",
    "comments": [
      {
        "user": "bhushan-shah-dev",
        "created_at": "2018-09-12T08:20:24Z",
        "body": "I want to give this a go as my first PR, but would appreciate some direction."
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2021-07-14T20:57:19Z",
        "body": "Thank you @JoshuaKGoldberg!"
      }
    ]
  },
  {
    "number": 25356,
    "title": "Instance property is not a \"block-scoped variable\"",
    "created_at": "2018-07-02T05:20:06Z",
    "closed_at": "2018-07-03T21:11:29Z",
    "labels": [
      "Bug",
      "Fixed",
      "Help Wanted",
      "Good First Issue",
      "Domain: Error Messages"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/25356",
    "body": "```ts\r\nclass Foo {\r\n    b = this.a\r\n    a = 10\r\n}\r\n```\r\n\r\n**Expected**: `Property 'a' is used before its initialization.`\r\n**Actual**: `Block-scoped variable 'a' used before its declaration.`",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/25356/comments",
    "author": "DanielRosenwasser",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2018-07-02T17:33:49Z",
        "body": "PRs welcomed."
      },
      {
        "user": "mhegazy",
        "created_at": "2018-07-03T21:11:46Z",
        "body": "thanks @a-tarasyuk !"
      }
    ]
  },
  {
    "number": 25220,
    "title": "factory: createExpressionStatement is internal",
    "created_at": "2018-06-26T09:24:15Z",
    "closed_at": "2018-07-02T21:03:01Z",
    "labels": [
      "Suggestion",
      "Fixed",
      "Help Wanted",
      "API"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/25220",
    "body": "<!-- 🚨 STOP 🚨 𝗦𝗧𝗢𝗣 🚨 𝑺𝑻𝑶𝑷 🚨\r\n\r\nHalf of all issues filed here are duplicates, answered in the FAQ, or not appropriate for the bug tracker. Please read the FAQ first, especially the \"Common Feature Requests\" section.\r\n\r\n-->\r\n\r\n## Search Terms\r\n\r\n`createExpressionStatement`\r\n\r\n<!-- List of keywords you searched for before creating this issue. Write them down here so that others can find this suggestion more easily -->\r\n\r\n## Suggestion\r\n\r\nexpose `createExpressionStatement` for API users\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/25220/comments",
    "author": "ajafff",
    "comments": [
      {
        "user": "ajafff",
        "created_at": "2018-06-26T10:14:12Z",
        "body": "I just noticed that there is a `createStatement` which creates an `ExpressionStatement`. This is actually consistent with the inconsistencies of all the other factory functions.\r\nMaybe the misnamed functions should be deprecated in favour of functions with a better name."
      },
      {
        "user": "mhegazy",
        "created_at": "2018-06-30T00:55:51Z",
        "body": "PRs welcomed."
      },
      {
        "user": "mhegazy",
        "created_at": "2018-06-30T01:03:02Z",
        "body": "I would expose both with a comment."
      }
    ]
  },
  {
    "number": 25201,
    "title": "Code fixes for syntax errors",
    "created_at": "2018-06-25T20:48:43Z",
    "closed_at": "2020-03-12T21:55:03Z",
    "labels": [
      "Suggestion",
      "Help Wanted",
      "Good First Issue",
      "Domain: Quick Fixes"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/25201",
    "body": "**TypeScript Version:**  3.0.0-dev.20180623\r\n\r\n**Code**\r\n\r\n```ts\r\nconst o = { a: 1; b: 2 };\r\n```\r\n\r\n**Expected behavior:**\r\n\r\nGet a quick fix to replace `;` with `,`.\r\n\r\n**Actual behavior:**\r\n\r\nNo fix. Similar for `{ a: 1 b: 2 }`.",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/25201/comments",
    "author": "ghost",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2018-06-25T21:09:42Z",
        "body": "The problem with these is that we will have to add parsing support for these patterns to be able to fix them. so there is a limited set of patterns that we can support.\r\n\r\nThat said, we should be able to support he missing `,` errors listed above. "
      },
      {
        "user": "akoserwal",
        "created_at": "2018-06-27T07:34:16Z",
        "body": "@mhegazy: I would like to work on this issue.  Please, can you help me with some starting pointers? "
      },
      {
        "user": "MEXdave1997",
        "created_at": "2018-09-27T17:38:24Z",
        "body": "@akoserwal are you still working on this? I wouldn't mind helping out in finding this out.\r\n\r\n**EDIT**: Also, I would suspect that you can find something in the parser file in `src/compiler/parser.ts`"
      },
      {
        "user": "ghost",
        "created_at": "2018-10-01T17:07:40Z",
        "body": "Code fixes go in the `codefixes` folder -- don't think changes to the parser will be needed for this as long as the diagnostic it produces is usable for a code fix.\r\nSee `fixForgottenThisPropertyAccess.ts` for a simple example."
      },
      {
        "user": "adeniszczyc",
        "created_at": "2019-09-26T13:15:15Z",
        "body": "Going to take a look at continuing the work of @akoserwal on this issue now"
      }
    ]
  },
  {
    "number": 25032,
    "title": "Related error spans for multiple default exports",
    "created_at": "2018-06-18T05:50:49Z",
    "closed_at": "2019-03-12T20:15:15Z",
    "labels": [
      "Bug",
      "Help Wanted",
      "Domain: Related Error Spans"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/25032",
    "body": "Now that we support multiple related spans for errors (#10489, #22789, #24548), we'd like to improve an existing error message.\r\n\r\nCurrently, we provide an error on each declaration when a module has multiple `export default`s.\r\n\r\n```\r\nA module cannot have multiple default exports\r\n```\r\n\r\nWe can instead add a related span on all declarations but the first.\r\n\r\n```\r\nThis export conflicts with the first. \r\n```\r\n\r\nThis can help users quickly glance at the original declaration.",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/25032/comments",
    "author": "DanielRosenwasser",
    "comments": [
      {
        "user": "Kingwl",
        "created_at": "2018-07-02T10:54:50Z",
        "body": "i'd like to (try) work on this"
      },
      {
        "user": "mhegazy",
        "created_at": "2018-07-02T18:31:16Z",
        "body": "go for it."
      }
    ]
  },
  {
    "number": 24728,
    "title": "codefix for new method should include asterisk for generator functions",
    "created_at": "2018-06-06T16:19:21Z",
    "closed_at": "2018-06-08T15:57:50Z",
    "labels": [
      "Bug",
      "Fixed",
      "Help Wanted",
      "Good First Issue",
      "Domain: Quick Fixes"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/24728",
    "body": "## Search Terms\r\nasterisk, addMethodDeclaration\r\n\r\n## Suggestion\r\n\r\nWhen a new method is created that is used by a `yield *` expression, generated method should have an asterisk before its name.\r\n\r\n## Use Cases\r\n\r\nVSCode would create generator functions when the `addMissingMember` codefix is applied to an invocation inside a `YieldExpression`.\r\n\r\n## Examples\r\n\r\nNew method created by vscode for this block:\r\n\r\n```ts\r\nclass A {\r\n  private *a() {\r\n    yield* this.abc();\r\n  }\r\n}\r\n```\r\n\r\nis:\r\n\r\n```ts\r\nabc(): any {\r\n  throw new Error(\"Method not implemented.\");\r\n}\r\n```\r\n\r\nand while it is apparent that return type should be changed, it is not obvious to convert the new `abc` funciton to a generator function such as:\r\n\r\n```ts\r\n*abc(): any {\r\n  throw new Error(\"Method not implemented.\");\r\n}\r\n```\r\n\r\n## Checklist\r\n\r\nMy suggestion meets these guidelines:\r\n* [X] This wouldn't be a breaking change in existing TypeScript / JavaScript code\r\n* [X] This wouldn't change the runtime behavior of existing JavaScript code\r\n* [X] This could be implemented without emitting different JS based on the types of the expressions\r\n* [X] This isn't a runtime feature (e.g. new expression-level syntax)\r\n\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/24728/comments",
    "author": "krk",
    "comments": [
      {
        "user": "Fatehsandhu",
        "created_at": "2018-06-08T14:19:22Z",
        "body": "@RyanCavanaugh Can I take this, please?\r\nThanks"
      },
      {
        "user": "mhegazy",
        "created_at": "2018-06-08T15:58:18Z",
        "body": "thanks @krk!"
      }
    ]
  },
  {
    "number": 24709,
    "title": "Transform API: TypeError in getOrCreateEmitNode",
    "created_at": "2018-06-05T21:18:06Z",
    "closed_at": "2019-01-31T03:12:12Z",
    "labels": [
      "Bug",
      "Help Wanted",
      "API"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/24709",
    "body": "\r\n**TypeScript Version:**  3.0.0-dev.20180605\r\n\r\nSame in 2.9.1 and earlier.\r\n\r\n**Search Terms:**  `getOrCreateEmitNode`, `annotatedNodes`\r\n\r\n**Code**\r\n\r\nQuick summary: we create TS file, apply a transform which changes a method name, and compile the final AST.\r\n\r\n```ts\r\nimport * as ts from \"typescript\";\r\nimport { readFileSync } from \"fs\";\r\nimport { join } from \"path\";\r\n\r\nconst options: ts.CompilerOptions = {\r\n  target: ts.ScriptTarget.ES3,\r\n  module: ts.ModuleKind.None,\r\n  noLib: true,\r\n};\r\n\r\nconst sourceFile = transform(\r\n  ts.createSourceFile(\r\n    \"input.ts\",\r\n    \"class X { hello(userName: string) { return `Hello, ${userName}!`; } }\",\r\n    ts.ScriptTarget.ES2017,\r\n    true,\r\n    ts.ScriptKind.TS,\r\n  ),\r\n);\r\n\r\n// console.log(ts.createPrinter().printFile(sourceFile));\r\n\r\nconst host: ts.CompilerHost = {\r\n  getSourceFile(\r\n    fileName: string,\r\n    languageVersion: ts.ScriptTarget,\r\n  ): ts.SourceFile {\r\n    if (fileName === sourceFile.fileName) {\r\n      return sourceFile;\r\n    }\r\n\r\n    throw new Error(`File not found: ${fileName}`);\r\n  },\r\n  getDefaultLibFileName: () => \"lib.d.ts\",\r\n  writeFile: (_fileName, _content) => {\r\n    throw new Error(\"Unsupported!\");\r\n  },\r\n  getCurrentDirectory: () => ts.sys.getCurrentDirectory(),\r\n  getCanonicalFileName: fileName =>\r\n    ts.sys.useCaseSensitiveFileNames ? fileName : fileName.toLowerCase(),\r\n  getNewLine: () => ts.sys.newLine,\r\n  useCaseSensitiveFileNames: () => ts.sys.useCaseSensitiveFileNames,\r\n  fileExists: (fileName: string) => fileName === sourceFile.fileName,\r\n  readFile(fileName: string): string {\r\n    if (fileName === sourceFile.fileName) {\r\n      return sourceFile.getText();\r\n    }\r\n    return \"\";\r\n  },\r\n  resolveModuleNames(\r\n    _moduleNames: string[],\r\n    _containingFile: string,\r\n  ): ts.ResolvedModule[] {\r\n    throw new Error(\"Unsupported!\");\r\n  },\r\n  getDirectories(_path: string): string[] {\r\n    throw new Error(\"Unsupported!\");\r\n  },\r\n};\r\n\r\nconst program = ts.createProgram([\"input.ts\"], options, host);\r\n\r\nfunction transformSourceFile(\r\n  context: ts.TransformationContext,\r\n): ts.Transformer<ts.SourceFile> {\r\n  return (sourceFile: ts.SourceFile) => {\r\n    function visit(node: ts.Node) {\r\n      if (ts.isMethodDeclaration(node)) {\r\n        return ts.updateMethod(\r\n          node,\r\n          node.decorators,\r\n          node.modifiers,\r\n          node.asteriskToken,\r\n          ts.createIdentifier(\"foobar\"),\r\n          node.questionToken,\r\n          node.typeParameters,\r\n          node.parameters,\r\n          node.type,\r\n          node.body,\r\n        );\r\n      }\r\n\r\n      return ts.visitEachChild(node, visit, context);\r\n    }\r\n\r\n    return ts.visitEachChild(sourceFile, visit, context);\r\n  };\r\n}\r\n\r\nfunction transform(source: ts.SourceFile): ts.SourceFile {\r\n  const result = ts.transform(source, [transformSourceFile]);\r\n  const transformedSource = result.transformed[0];\r\n  result.dispose();\r\n  return transformedSource;\r\n}\r\n\r\nprogram.emit(sourceFile, (fileName, source) => {\r\n  console.log(source);\r\n});\r\n```\r\n\r\n**Expected behavior:**\r\n\r\nNo exceptions.\r\n\r\n**Actual behavior:**\r\n\r\n```\r\n/Users/test/transform-test/node_modules/typescript/lib/typescript.js:55251\r\n                getOrCreateEmitNode(sourceFile).annotatedNodes.push(node);\r\n                                                              ^\r\nTypeError: Cannot read property 'push' of undefined\r\n    at getOrCreateEmitNode (/Users/test/transform-test/node_modules/typescript/lib/typescript.js:55251:63)\r\n    at Object.setEmitFlags (/Users/test/transform-test/node_modules/typescript/lib/typescript.js:55270:9)\r\n    at visitParameter (/Users/test/transform-test/node_modules/typescript/lib/typescript.js:60754:16)\r\n    at visitTypeScript (/Users/test/transform-test/node_modules/typescript/lib/typescript.js:59155:28)\r\n    at visitorWorker (/Users/test/transform-test/node_modules/typescript/lib/typescript.js:58892:24)\r\n    at saveStateAndInvoke (/Users/test/transform-test/node_modules/typescript/lib/typescript.js:58836:27)\r\n    at visitor (/Users/test/transform-test/node_modules/typescript/lib/typescript.js:58882:20)\r\n    at visitNodes (/Users/test/transform-test/node_modules/typescript/lib/typescript.js:57074:48)\r\n    at visitParameterList (/Users/test/transform-test/node_modules/typescript/lib/typescript.js:57122:23)\r\n    at Object.visitEachChild (/Users/test/transform-test/node_modules/typescript/lib/typescript.js:57172:395)\r\n```",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/24709/comments",
    "author": "agentcooper",
    "comments": [
      {
        "user": "ispedals",
        "created_at": "2018-10-27T03:15:41Z",
        "body": "The error appears to be that in getOrCreateEmitNode, it assumes that the source file of a parse tree node will also always be a parse tree node. The example violates this assumption, resulting in the source file node having a emitNode with an undefined annotatedNodes field.\r\n\r\n\r\nForcing the source file node to always have a defined annotatedNodes field fixes the issue, but I'm not sure if the fact that the sourcefile is not a parse tree node is the real root cause."
      }
    ]
  },
  {
    "number": 24416,
    "title": "\"Implement interface\" adds properties present in base class",
    "created_at": "2018-05-25T17:14:42Z",
    "closed_at": "2018-05-30T16:20:51Z",
    "labels": [
      "Bug",
      "Fixed",
      "Help Wanted",
      "VS Code Tracked",
      "Domain: Quick Fixes"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/24416",
    "body": "_From @chrmarti on May 25, 2018 10:6_\r\n\r\nIssue Type: <b>Bug</b>\r\n\r\nRunning the code action \"Implement interface 'Interface'\" below on the compile error on `Sub` adds `foo` and `bar` where only `bar` is expected because `foo` is already on the base class:\r\n\r\n```ts\r\nclass Base {\r\n\tfoo = 1;\r\n}\r\n\r\ninterface Interface {\r\n\tfoo: number;\r\n\tbar: number;\r\n}\r\n\r\nclass Sub extends Base implements Interface {\r\n}\r\n```\r\n\r\n\r\nVS Code version: Code - Insiders 1.24.0-insider (aa1aafbabbd26e906c01e56f8a673b68a5c96666, 2018-05-23T05:11:10.604Z)\r\nOS version: Darwin x64 16.7.0\r\n\r\n<details>\r\n<summary>System Info</summary>\r\n\r\n|Item|Value|\r\n|---|---|\r\n|CPUs|Intel(R) Core(TM) i7-4770HQ CPU @ 2.20GHz (8 x 2200)|\r\n|GPU Status|2d_canvas: enabled<br>flash_3d: enabled<br>flash_stage3d: enabled<br>flash_stage3d_baseline: enabled<br>gpu_compositing: enabled<br>multiple_raster_threads: enabled_on<br>native_gpu_memory_buffers: enabled<br>rasterization: enabled<br>video_decode: enabled<br>video_encode: enabled<br>vpx_decode: enabled<br>webgl: enabled<br>webgl2: enabled|\r\n|Load (avg)|3, 3, 3|\r\n|Memory (System)|16.00GB (0.18GB free)|\r\n|Process Argv|/Applications/Visual Studio Code - Insiders.app/Contents/MacOS/Electron -psn_0_21451892|\r\n|Screen Reader|no|\r\n|VM|0%|\r\n\r\n</details><details><summary>Extensions (18)</summary>\r\n\r\nExtension|Author (truncated)|Version\r\n---|---|---\r\nautofilename|Jer|0.1.3\r\nregex|chr|0.2.0\r\nssh|chr|0.0.4\r\nvscode-eslint|dba|1.4.10\r\nghlink|dt|1.0.2\r\nEditorConfig|Edi|0.12.2\r\ntslint|eg2|1.0.29\r\nrest-client|hum|0.18.4\r\nvscode-azureappservice|ms-|0.8.1\r\nvscode-azurefunctions|ms-|0.9.1\r\nvscode-cosmosdb|ms-|0.7.1\r\nazure-account|ms-|0.4.0\r\nazurecli|ms-|0.4.1\r\ngithub-issues-prs|ms-|0.9.0\r\ndebugger-for-chrome|msj|4.4.3\r\nvscode-docker|Pet|0.0.27\r\nvscode-versionlens|pfl|0.21.0\r\nvscode-open-in-github|sys|1.7.0\r\n\r\n\r\n</details>\r\n<!-- generated by issue reporter -->\r\n\r\n_Copied from original issue: Microsoft/vscode#50450_",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/24416/comments",
    "author": "mjbvz",
    "comments": [
      {
        "user": "mjbvz",
        "created_at": "2018-05-25T17:15:50Z",
        "body": "Confirmed using TS 2.9.1-insiders-20180525 . The results is:\r\n\r\n```ts\r\nclass Sub extends Base implements Interface {\r\n  foo: number;  bar: number;\r\n\r\n}\r\n```"
      },
      {
        "user": "mhegazy",
        "created_at": "2018-05-25T21:49:12Z",
        "body": "PRs welcomed."
      },
      {
        "user": "mhegazy",
        "created_at": "2018-05-30T16:21:14Z",
        "body": "thanks @Kingwl !"
      }
    ]
  },
  {
    "number": 24414,
    "title": "Use another overload signature's documented info if exact one's info is missing",
    "created_at": "2018-05-25T16:21:32Z",
    "closed_at": "2019-07-25T22:42:59Z",
    "labels": [
      "Suggestion",
      "Help Wanted"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/24414",
    "body": "**TypeScript Version:**  3.0.0-dev.20180522\r\n\r\n<!-- Search terms you tried before logging this (so others can find this issue more easily) -->\r\n**Search Terms:** \r\n\r\n**Code**\r\n\r\n```ts\r\n/**\r\n * A\r\n */\r\nfunction f(a: 0): void;\r\nfunction f(a: number): void;\r\nfunction f(a: number) {\r\n}\r\nf(1);\r\n```\r\n\r\n**Expected behavior:**\r\n\r\n`f(1)` has documented info `A`.\r\n\r\n**Actual behavior:**\r\n\r\n`f(1)` has no documented info.\r\n\r\n**Playground Link:** <!-- A link to a TypeScript Playground \"Share\" link which demonstrates this behavior --> \r\n\r\n**Related Issues:** <!-- Did you find other bugs that looked similar? -->\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/24414/comments",
    "author": "falsandtru",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2018-05-25T16:24:41Z",
        "body": "PRs welcomed."
      },
      {
        "user": "ajafff",
        "created_at": "2018-05-25T18:06:07Z",
        "body": "This needs a little more thought than the opening post describes:\r\nDoes it only use the description or tags as well? \r\nShould it only look at other signatures if the current signature has no jsdoc comment at all? \r\nHow should `@param` tags of other signatures be handled?\r\nThis may be kind of a braking change if it also uses `@deprecated` tag of another signature. "
      },
      {
        "user": "sandersn",
        "created_at": "2019-07-25T22:42:58Z",
        "body": "Duplicate of #407"
      }
    ]
  },
  {
    "number": 24172,
    "title": "Provide a quick fix for 'module does not refer to a type'",
    "created_at": "2018-05-16T18:29:56Z",
    "closed_at": "2018-05-17T16:04:20Z",
    "labels": [
      "Bug",
      "Fixed",
      "Help Wanted",
      "Good First Issue",
      "Domain: Quick Fixes"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/24172",
    "body": "```ts\r\n// ./foo.ts\r\n\r\nexport async function bar() {\r\n    let foo: import(\"./foo\") = await import(\"./foo\");\r\n//           ^^^^^^^^^^^^^^^\r\n// Module './foo' does not refer to a type, but is used as a type here.\r\n}\r\n```\r\n\r\nWe should give a quick fix in this scenario.\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/24172/comments",
    "author": "DanielRosenwasser",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2018-05-16T19:07:16Z",
        "body": "//CC @Kingwl "
      },
      {
        "user": "Kingwl",
        "created_at": "2018-05-16T20:54:08Z",
        "body": "what should this codefix do？。"
      },
      {
        "user": "mhegazy",
        "created_at": "2018-05-16T20:59:54Z",
        "body": "change it to `typeof import(\"./foo\")` if applicable."
      }
    ]
  },
  {
    "number": 23992,
    "title": "Sugget Add a new transfomer api like `ts.createRegularExpressionLiteral`",
    "created_at": "2018-05-09T12:51:27Z",
    "closed_at": "2018-05-10T16:56:46Z",
    "labels": [
      "Bug",
      "Fixed",
      "Help Wanted",
      "API"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/23992",
    "body": "<!-- 🚨 STOP 🚨 𝗦𝗧𝗢𝗣 🚨 𝑺𝑻𝑶𝑷 🚨\r\n\r\nHalf of all issues filed here are duplicates, answered in the FAQ, or not appropriate for the bug tracker. Please read the FAQ first, especially the \"Common Feature Requests\" section.\r\n\r\n-->\r\n\r\n## Search Terms\r\n\r\n<!-- List of keywords you searched for before creating this issue. Write them down here so that others can find this suggestion more easily -->\r\n\r\n## Suggestion\r\n\r\n<!-- A summary of what you'd like to see added or changed -->\r\n\r\n## Use Cases\r\n\r\nRight now there are plenty factory api in typescript transformer, eg:\r\n\r\n```ts\r\ndeclare namespace ts {\r\n    function createNodeArray<T extends Node>(elements?: ReadonlyArray<T>, hasTrailingComma?: boolean): NodeArray<T>;\r\n    /** If a node is passed, creates a string literal whose source text is read from a source node during emit. */\r\n    function createLiteral(value: string | StringLiteral | NoSubstitutionTemplateLiteral | NumericLiteral | Identifier): StringLiteral;\r\n    function createLiteral(value: number): NumericLiteral;\r\n    function createLiteral(value: boolean): BooleanLiteral;\r\n    function createLiteral(value: string | number | boolean): PrimaryExpression;\r\n    function createNumericLiteral(value: string): NumericLiteral;\r\n    function createIdentifier(text: string): Identifier;\r\n    function updateIdentifier(node: Identifier): Identifier;\r\n    /** Create a unique temporary variable. */\r\n    function createTempVariable(recordTempVariable: ((node: Identifier) => void) | undefined): Identifier;\r\n    /** Create a unique temporary variable for use in a loop. */\r\n    function createLoopVariable(): Identifier;\r\n    /** Create a unique name based on the supplied text. */\r\n    function createUniqueName(text: string): Identifier;\r\n\r\n...\r\n...\r\n...\r\n```\r\n\r\nBut i have searched the codebase and all issue, seems like we can not create a **RegularExpressionLiteral** through transfomer api, If i understand correctly, please consider add a api to do this. If not, i am willing to hear any solution. 😄 \r\n\r\n<!--\r\nWhat do you want to use this for?\r\nWhat shortcomings exist with current approaches?\r\n-->\r\n\r\n## Examples\r\n\r\n<!-- Show how this would be used and what the behavior would be -->\r\n\r\n## Checklist\r\n\r\nMy suggestion meets these guidelines:\r\n [ ] This wouldn't be a breaking change in existing TypeScript / JavaScript code\r\n [ ] This wouldn't change the runtime behavior of existing JavaScript code\r\n [ ] This could be implemented without emitting different JS based on the types of the expressions\r\n [ ] This isn't a runtime feature (e.g. new expression-level syntax)\r\n\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/23992/comments",
    "author": "paranoidjk",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2018-05-09T16:16:43Z",
        "body": "A PR would be appreciated "
      }
    ]
  },
  {
    "number": 23589,
    "title": "stripInternal does not strip properties declared via constructor parameters",
    "created_at": "2018-04-20T22:06:05Z",
    "closed_at": "2019-03-12T20:14:48Z",
    "labels": [
      "Bug",
      "Help Wanted",
      "Domain: Declaration Emit"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/23589",
    "body": "**TypeScript Version:**  2.9.0-dev.20180420\r\n\r\n<!-- Search terms you tried before logging this (so others can find this issue more easily) -->\r\n**Search Terms:** stripInternal\r\n\r\n**Code**\r\n\r\nbug.ts:\r\n```ts\r\nexport class Foo {\r\n    constructor(/** @internal */ public bar: string) {}  \r\n    /** @internal */ zoo: string;\r\n}\r\n```\r\ntsconfig.json:\r\n```json\r\n{\r\n    \"compilerOptions\": {\r\n        \"declaration\": true,\r\n        \"stripInternal\": true\r\n    }\r\n}\r\n```\r\n\r\n**Expected behavior:**\r\n\r\nbug.d.ts:\r\n```ts\r\nexport declare class Foo {\r\n    constructor(bar: string);\r\n}\r\n```\r\nBoth `bar` and `zoo` declarations are stripped\r\n\r\n**Actual behavior:**\r\n\r\nbug.d.ts:\r\n```ts\r\nexport declare class Foo {\r\n    bar: string;\r\n    constructor(/** @internal */ bar: string);\r\n}\r\n```\r\n`bar` declaration is *not* stripped.\r\n\r\n**Playground Link:** \r\n**Related Issues:**\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/23589/comments",
    "author": "bjouhier",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2018-04-20T22:35:41Z",
        "body": "PRs welcomed"
      }
    ]
  },
  {
    "number": 23402,
    "title": "Refactoring: add braces to arrow function",
    "created_at": "2018-04-13T22:41:36Z",
    "closed_at": "2018-06-11T20:09:39Z",
    "labels": [
      "Suggestion",
      "Fixed",
      "Help Wanted",
      "Good First Issue",
      "Domain: Refactorings"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/23402",
    "body": "Insightfully suggested in #23299 by @zaaack:\r\n\r\n> +1. Add braces is very useful, too.\r\n\r\nThen substantiated further by @zuozijian3720:\r\n\r\n> +1. Add braces is very useful, too.",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/23402/comments",
    "author": "DanielRosenwasser",
    "comments": [
      {
        "user": "oliverjanik",
        "created_at": "2018-05-23T01:45:57Z",
        "body": "And remove?"
      },
      {
        "user": "oliverjanik",
        "created_at": "2018-06-13T03:51:37Z",
        "body": "This is awesome!"
      }
    ]
  },
  {
    "number": 23180,
    "title": "Generating source maps with relative path in sourceRoot option produces maps with abosolute file paths",
    "created_at": "2018-04-05T20:00:49Z",
    "closed_at": "2018-06-12T17:57:19Z",
    "labels": [
      "Bug",
      "Fixed",
      "Breaking Change",
      "Help Wanted"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/23180",
    "body": "# Problem\r\nI supply `sourceMap: true` and `sourceRoot: \"./../src/\"` options to tsc (via tsconfig) while compiling with `--declaration` flag: `tsc -d --outDir ./out`.  \r\nI expect that *.js.map will contain relative paths to ../src. \r\nInstead they contain absolute paths to my local folder:\r\n```json\r\n{\"version\":3,\"file\":\"index.js\",\"sourceRoot\":\"D:/Work/Learn/typescript/src/\",\"sources\":[\"index.ts\"],\"names\":[],\"mappings\": ... }\r\n```\r\n\r\n# Steps to reproduce\r\n\r\n```\r\nD:.\r\n│   tsconfig.json\r\n│\r\n├───out\r\n│       index.d.ts\r\n│       index.js\r\n│       index.js.map\r\n│\r\n└───src\r\n        index.ts\r\n```\r\ntsconfig.json:\r\n```json\r\n{\r\n\t\"compilerOptions\": {\r\n\t\t\"module\": \"amd\",\r\n\t\t\"target\": \"es3\",\r\n\t\t\"sourceMap\": true,\r\n\t\t\"sourceRoot\": \"./../src/\",\r\n\t\t\"noEmitHelpers\": true\r\n\t},\r\n\t\"include\": [\r\n\t\t\"**/*.ts\"\r\n\t]\r\n}\r\n```\r\n`src/index.ts`:\r\n```ts\r\nexport class MyClass {}\r\n```\r\nrun in folder with `tsconfig.json`:\r\n```shell\r\ntsc -d --outDir ./out\r\n```\r\n\r\nI tried TS 2.6, 2.7, 2.8 all of them produce the same result.",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/23180/comments",
    "author": "evil-shrike",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2018-04-26T18:04:41Z",
        "body": "PRs welcomed."
      },
      {
        "user": "a-tarasyuk",
        "created_at": "2018-05-05T16:16:23Z",
        "body": "This bug causes because each option which has property `option.isFilePath` processed by function `normalizePath`. `sourceRoot` is also processed, that's why sourceMap file contains the new path\r\n\r\n```typescript\r\nfunction normalizeNonListOptionValue(option: CommandLineOption, basePath: string, value: any): CompilerOptionsValue {\r\n    if (option.isFilePath) {\r\n        value = normalizePath(combinePaths(basePath, value));\r\n        if (value === \"\") {\r\n\t    value = \".\";\r\n        }\r\n    }\r\n\r\n    return value;\r\n}\r\n```\r\n\r\n@mhegazy I have couple questions before I'll start work on PR.\r\n\r\n1. Should we exclude only `sourceRoot` from _path_ normalization process, or need to do the same for other options?\r\n2. Is it good to add this logic to `normalizeNonListOptionValue`? Or maybe we can add the new property to `option` which will disable normalization _path_, like \r\n\r\n```typescript\r\n{\r\n       newPropertyWhichWillSkipPathNormalization: true,\r\n       name: \"sourceRoot\",\r\n       type: \"string\",\r\n       isFilePath: true,\r\n       paramType: Diagnostics.LOCATION,\r\n       category: Diagnostics.Source_Map_Options,\r\n       description: ...\r\n},\r\n```\r\nor maybe you can suggest another solution. Thanks in advance."
      },
      {
        "user": "mhegazy",
        "created_at": "2018-05-09T04:40:26Z",
        "body": "`SourceRoot` should not have the `isFilePath` flag on it. that should also apply to `mapRoot`."
      }
    ]
  },
  {
    "number": 23035,
    "title": "Pattern matcher doesn't work for name with space",
    "created_at": "2018-03-30T22:56:00Z",
    "closed_at": "2024-03-07T21:22:25Z",
    "labels": [
      "Bug",
      "Help Wanted"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/23035",
    "body": "**TypeScript Version:**  master\r\n\r\n**Code**\r\n\r\nSee `navigateToQuoted.ts` (added in #23036)\r\n\r\n**Expected behavior:**\r\n\r\n\"foo bar\" works same as \"foo-bar\".\r\n\r\n**Actual behavior:**\r\n\r\nNavigation to \"foo bar\" doesn't work.",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/23035/comments",
    "author": "ghost",
    "comments": [
      {
        "user": "Carl-Foster",
        "created_at": "2018-04-27T07:56:01Z",
        "body": "In `patternMatcher.ts` this gets called for the above check:\r\n```ts\r\n    function matchSegment(candidate: string, segment: Segment, stringToWordSpans: Map<TextSpan[]>): PatternMatch {\r\n        // First check if the segment matches as is.  This is also useful if the segment contains\r\n        // characters we would normally strip when splitting into parts that we also may want to\r\n        // match in the candidate.  For example if the segment is \"@int\" and the candidate is\r\n        // \"@int\", then that will show up as an exact match here.\r\n        //\r\n        // Note: if the segment contains a space or an asterisk then we must assume that it's a\r\n        // multi-word segment.\r\n        if (every(segment.totalTextChunk.text, ch => ch !== CharacterCodes.space && ch !== CharacterCodes.asterisk)) {\r\n            const match = matchTextChunk(candidate, segment.totalTextChunk, stringToWordSpans);\r\n            if (match) return match;\r\n        }\r\n        ...\r\n    }\r\n```\r\n\r\nI found when removed that check of the segment text containing a space or asterisk it was able to work fine and all tests passed. I'm unsure as to why there is this check, as the comment seems like it should be checking usually stripped parts (such as space or asterisk).\r\nIs there any reason why that check has to be there?"
      },
      {
        "user": "mhegazy",
        "created_at": "2018-04-27T16:03:04Z",
        "body": "@andy-ms you are more familiar with the pattern matching code, thoughts?"
      },
      {
        "user": "ghost",
        "created_at": "2018-05-02T21:10:55Z",
        "body": "The documentation on `subWordTextChunks` says:\r\n\r\n```\r\nInformation about the subwords compromising the total word.  For example, if the\r\ntext between the dots is 'GetFoo KeywordBar', then the subwords will be 'GetFoo'\r\nand 'KeywordBar'.  Those individual words will have CharacterSpans of ('Get' and\r\n'Foo') and('Keyword' and 'Bar') respectively.\r\n```\r\n\r\nIt looks like if you write 'foo bar' we will match against 'foo' *OR* 'bar', and return the best match. But we will *not* match \"foo bar\". So it treats \" \" like \"|\" in a regular expression. Not sure if that's still the desired behavior, or what other languages doo in this situation. If we didn't keep this behavior then the pattern matcher would get a lot simpler because we wouldn't have to compute `subWordTextChunks`, and then a `Segment` would just be a `TextChunk`.\r\n\r\nAs for why no tests failed, we don't seem to be running them: #23836"
      }
    ]
  },
  {
    "number": 23021,
    "title": "Nonsensical error message",
    "created_at": "2018-03-30T14:03:44Z",
    "closed_at": "2018-03-30T23:23:25Z",
    "labels": [
      "Bug",
      "Fixed",
      "Help Wanted"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/23021",
    "body": "**TypeScript Version:**  2.9.0-dev\r\n\r\n**Code**\r\n\r\n```ts\r\ntype Wat<T extends string> = { [x: T]: string };  // Error: An index signature cannot be a union type ?!?\r\n```\r\n\r\n**Expected behavior:**\r\n\r\nMeaningful error message.\r\n\r\n**Actual behavior:**\r\n\r\nError message complains about a union type, but there is no union type.\r\n\r\n**Related Issues:**\r\n\r\nThe error message is caused by #20726. There is no verification that the type is actually a union type.",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/23021/comments",
    "author": "ahejlsberg",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2018-03-30T16:17:08Z",
        "body": "@kujon wanna take a crack at this one as well?"
      }
    ]
  },
  {
    "number": 22944,
    "title": "Document highlights on async/await keywords should highlight other occurrences in the same body",
    "created_at": "2018-03-28T05:51:42Z",
    "closed_at": "2018-05-09T16:51:05Z",
    "labels": [
      "Bug",
      "Fixed",
      "Help Wanted",
      "Good First Issue"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/22944",
    "body": "```ts\r\n[|async|] function foo() {\r\n  let x = [|await|] 100;\r\n  let y = [|await|] 200;\r\n  return 300\r\n}\r\n```\r\n\r\nI'd expect each document highlight above to contain the others.\r\n\r\nI wouldn't think the `return` keyword would be included here.",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/22944/comments",
    "author": "DanielRosenwasser",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2018-05-09T16:51:34Z",
        "body": "thanks @Zzzen!"
      }
    ]
  },
  {
    "number": 22923,
    "title": "Check if element types of Promises contain a property when issuing a missing property error",
    "created_at": "2018-03-27T20:54:30Z",
    "closed_at": "2018-04-06T16:31:44Z",
    "labels": [
      "Suggestion",
      "Fixed",
      "Help Wanted",
      "Good First Issue",
      "Domain: Error Messages"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/22923",
    "body": "```ts\r\nfunction f(x: Promise<string>) {\r\n  x.toLowerCase()\r\n}\r\n```\r\n**Expected**: `Property 'toLowerCase' does not exist on type 'Promise<string>'. Did you forget to await the 'Promise<string>'?`\r\n\r\n**Actual**: `Property 'toLowerCase' does not exist on type 'Promise<string>'.`",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/22923/comments",
    "author": "DanielRosenwasser",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2018-03-28T00:36:45Z",
        "body": "PRs welcomed. great first issue. will diffidently add value to our users."
      },
      {
        "user": "mhegazy",
        "created_at": "2018-03-28T00:37:17Z",
        "body": "The follow up to this issue is to add a quick fix to add the `await` keyword."
      },
      {
        "user": "akhomchenko",
        "created_at": "2018-04-01T07:21:50Z",
        "body": "I'll try to fix this."
      }
    ]
  },
  {
    "number": 22674,
    "title": "Declare method quickfix/codeaction should create method after current quick fix location",
    "created_at": "2018-03-17T19:21:02Z",
    "closed_at": "2018-05-30T17:30:02Z",
    "labels": [
      "Bug",
      "Fixed",
      "Help Wanted",
      "Good First Issue",
      "Domain: Quick Fixes"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/22674",
    "body": "**TypeScript Version:**  2.8.0-rc\r\n\r\n<!-- Search terms you tried before logging this (so others can find this issue more easily) -->\r\n**Search Terms:** \r\n- declare method\r\n- quick fix\r\n-  code action\r\n\r\n**Code**\r\n\r\n```ts\r\nclass Foo {\r\n    a() {\r\n        this.b()\r\n    }\r\n}\r\n```\r\n\r\nTrigger the `declare method 'b'` quickfix on `this.b()`\r\n\r\n**Expected behavior:**\r\nMethod inserted after current location (or possible at end of class)\r\n\r\n```ts\r\nclass Foo {\r\n    a() {\r\n        this.b()\r\n    }\r\n    b(): any {\r\n        throw new Error(\"Method not implemented.\");\r\n    }\r\n}\r\n```\r\n\r\n**Actual behavior:**\r\nMethod inserted at top of class:\r\n\r\n```ts\r\nclass Foo {\r\n    b(): any {\r\n        throw new Error(\"Method not implemented.\");\r\n    }\r\n    a() {\r\n        this.b()\r\n    }\r\n}\r\n```\r\n\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/22674/comments",
    "author": "mattbierner",
    "comments": [
      {
        "user": "shirishp",
        "created_at": "2018-04-02T04:20:09Z",
        "body": "@mattbierner Can you please elaborate on why do you think the new method should be added after method which uses it?\r\nIMHO, having method declaration after it's use doesn't feel right (similar to variables), unless it's a private method of course."
      },
      {
        "user": "mjbvz",
        "created_at": "2018-04-02T22:18:16Z",
        "body": "@shirishp A few reasons:\r\n\r\n1. I'm mainly using this for private methods\r\n1. I generally organize methods from highest level (public apis) to lowest level (implementation details). That way you see the highest level stuff and can drill into the implementation as needed\r\n1. The current behavior puts the new method before everything in the class, including property declarations and the constructor.  "
      },
      {
        "user": "mhegazy",
        "created_at": "2018-05-30T17:30:51Z",
        "body": "thanks @vpukhanov "
      }
    ]
  },
  {
    "number": 22654,
    "title": "tsserver shouldn't assume that npm is in the same directory as node",
    "created_at": "2018-03-16T20:22:55Z",
    "closed_at": "2024-03-04T23:26:30Z",
    "labels": [
      "Bug",
      "Help Wanted"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/22654",
    "body": "Function `getDefaultNPMLocation` in `src/server/typingsInstaller/nodeTypingsInstaller.ts` is supposed to return path to `npm` binary, but it does so by assuming that `npm` is in the same directory as `node`. This is not always a case.\r\n\r\nOne example would be Debian proper, which has recent-ish Node (8.9.3 in unstable and 8.10.0 in experimental as of this writing), but hopelessly outdated npm (something from 2014). Since npm is pure JavaScript, it is possible to use Node from official repository, but npm from `npm i -g`.\r\n\r\nAt the very minimum, the function in question should verify that constructed path actually exists before returning it. If not, return just binary name and let operating system find it in `$PATH`.\r\n\r\n\r\n**TypeScript Version:**  2.8.0-dev.20180316\r\n**Search Terms:** npm location, npmlocation\r\n**Code**\r\n\r\n```sh\r\ntsserver\r\n```\r\n\r\n**Expected behavior:**\r\ntsserver is running without errors on STDOUT\r\n\r\n**Actual behavior:**\r\n```sh\r\nContent-Length: 76\r\n\r\n{\"seq\":0,\"type\":\"event\",\"event\":\"typingsInstallerPid\",\"body\":{\"pid\":31260}}\r\n/bin/sh: 1: /usr/bin/npm: not found\r\n```\r\n\r\nIt **seems** that server is running, although some functionality might be missing.\r\n\r\n**Playground Link:** N/A\r\n\r\n**Related Issues:** N/A",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/22654/comments",
    "author": "mirekdlugosz",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2018-04-03T21:40:10Z",
        "body": "PRs welcomed."
      },
      {
        "user": "mhegazy",
        "created_at": "2018-04-03T21:41:24Z",
        "body": "One thing to note here. we already have an override `--npmLocation` to the server that can be passed using vscode's setting `\"typescript.npm\"`."
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2024-03-04T23:26:30Z",
        "body": "Either this has been resolved or is not a remotely common configuration"
      }
    ]
  },
  {
    "number": 22423,
    "title": "error TS5033: Could not write file EEXIST",
    "created_at": "2018-03-09T03:56:42Z",
    "closed_at": "2023-07-10T20:23:45Z",
    "labels": [
      "Bug",
      "Help Wanted"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/22423",
    "body": "When /my exists and is empty, and I run one tsc instance with --outDir=/my/output/dir1 and concurrently run another instance with --outDir=/my/output/dir2, I sometimes get an error\r\n\r\n```\r\nerror TS5033: Could not write file '/my/output/dir2/file.js': EEXIST: file already exists, mkdir '/my/output'.\r\n```",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/22423/comments",
    "author": "pauldraper",
    "comments": [
      {
        "user": "pauldraper",
        "created_at": "2019-03-10T00:02:23Z",
        "body": "The solution here is fairly simple; rather than check if the directory exists and conditionally create it, just attempt creation and ignore EEXIST. As a bonus, it reduces the number of fs operations from 2 to 1."
      },
      {
        "user": "jakebailey",
        "created_at": "2023-07-10T20:23:45Z",
        "body": "#30135 was a duplicate of this, and was fixed in #30136 by ignoring EEXIST."
      }
    ]
  },
  {
    "number": 22399,
    "title": "Trailing comments shouldn't be kept when refactoring multiple statements",
    "created_at": "2018-03-08T02:35:28Z",
    "closed_at": "2024-03-07T20:30:19Z",
    "labels": [
      "Bug",
      "Help Wanted",
      "Effort: Moderate",
      "Domain: Refactorings"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/22399",
    "body": "```ts\r\nfunction foo() {\r\n    let x = 10;\r\n\r\n    [|x **= 2; // square\r\n    x **= 2; // square again|]\r\n}\r\n```\r\n\r\nExtract function on range\r\n\r\n**Expected:**\r\n\r\n```ts\r\n\r\nfunction foo() {\r\n    let x = 10;\r\n\r\n    asd();\r\n\r\n\r\n    function asd() {\r\n        x **= 2; // square\r\n        x **= 2; // square again\r\n    }\r\n}\r\n```\r\n\r\n**Actual:**\r\n\r\n```ts\r\nfunction foo() {\r\n    let x = 10;\r\n\r\n    asd(); // square again\r\n\r\n\r\n    function asd() {\r\n        x **= 2; // square\r\n        x **= 2;\r\n    }\r\n}\r\n```",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/22399/comments",
    "author": "DanielRosenwasser",
    "comments": [
      {
        "user": "amcasey",
        "created_at": "2018-03-08T18:16:43Z",
        "body": "@DanielRosenwasser, I'm not sure I understand what you're looking for.  I think you're suggesting that extracting `[|foo(); //comment|]` should behave differently from extracting `[|foo();|] //comment`, which - I agree - would be nice.  However, since no comments were either lost or duplicated, I would probably consider this a suggestion, rather than a bug.  How high is this on your list of priorities?"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2018-03-08T19:20:04Z",
        "body": "Nope, sorry, the key thing I have in mind here is that when I have multiple statements in a refactoring, it makes sense to move trailing trivia of the last statement *into* the extracted function body."
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2024-03-07T20:30:19Z",
        "body": "Now we duplicate the comment\r\n```ts\r\nfunction foo() {\r\n    let x = 10;\r\n\r\n    x = newFunction(x); // square again\r\n}\r\n\r\nfunction newFunction(x: number) {\r\n    x **= 2; // square\r\n    x **= 2; // square again\r\n    return x;\r\n}\r\n```\r\nIt's maybe not obvious which location is better, so letting the user delete whichever they don't like seems like a decent approach. Let's call it good enough."
      }
    ]
  },
  {
    "number": 22364,
    "title": "Extra comma left by CodeFixAll unused variables",
    "created_at": "2018-03-06T21:03:41Z",
    "closed_at": "2018-05-30T20:32:17Z",
    "labels": [
      "Bug",
      "Fixed",
      "Help Wanted",
      "Domain: Quick Fixes"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/22364",
    "body": "Code Fix All unused variables\r\n```ts\r\nimport { a, b, c, d} from \"./helpers\";\r\na;\r\n```\r\n\r\nExpected:\r\n\r\n```ts\r\nimport { a } from \"./helpers\";\r\na; \r\n```\r\n\r\nActual:\r\n```ts\r\nimport { a,  } from \"./helpers\";\r\na; \r\n```\r\nRelated Issues:\r\n#22330 and #22352\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/22364/comments",
    "author": "mhegazy",
    "comments": [
      {
        "user": "DanielRosenwasser",
        "created_at": "2018-03-07T07:58:28Z",
        "body": "#featureNotBug 😉 "
      },
      {
        "user": "Kingwl",
        "created_at": "2018-03-09T10:23:27Z",
        "body": "need some help ("
      },
      {
        "user": "vpukhanov",
        "created_at": "2018-05-30T20:12:15Z",
        "body": "@mhegazy Can't reproduce this issue on the latest \"master\" branch build. It was probably fixed."
      },
      {
        "user": "mhegazy",
        "created_at": "2018-05-30T20:32:42Z",
        "body": "thanks!"
      }
    ]
  },
  {
    "number": 22159,
    "title": "Importing types doesn't trigger an error in checkJs",
    "created_at": "2018-02-23T23:48:54Z",
    "closed_at": "2022-06-17T21:39:24Z",
    "labels": [
      "Bug",
      "Help Wanted",
      "Domain: JavaScript",
      "Fix Available",
      "Effort: Casual"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/22159",
    "body": "```ts\r\n// ./a.ts\r\nexport type Hello = string;\r\n```\r\n\r\n```js\r\nimport { Hello } from \"./a\";\r\n```\r\n\r\n**Expected:** Error: Types cannot be imported in a JavaScript file.\r\n**Actual:** No error.",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/22159/comments",
    "author": "DanielRosenwasser",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2018-03-09T23:40:31Z",
        "body": "PRs welcomed. "
      }
    ]
  },
  {
    "number": 22097,
    "title": "--pretty output is missing newlines in multi-line context",
    "created_at": "2018-02-21T21:57:10Z",
    "closed_at": "2018-02-23T20:51:02Z",
    "labels": [
      "Bug",
      "Fixed",
      "Help Wanted"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/22097",
    "body": "```\r\n$ cat file.ts \r\nconst requests: {c:string} = {\r\n  a: {\r\n    b: '',\r\n  }\r\n\r\n};\r\n\r\n$ tsc --pretty file.ts\r\nfile.ts:2:3 - error TS2322: Type '{ a: { b: string; }; }' is not assignable to type '{ c: string; }'.\r\n  Object literal may only specify known properties, and 'a' does not exist in type '{ c: string; }'.\r\n\r\n2   a: {\r\n    ~~~~3     b: '',\r\n  ~~~~~~~~~~4   }\r\n  ~~~\r\n```\r\n\r\nCan repro with tsc 2.6.2, 2.7.2, 2.8.0-dev.20180221",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/22097/comments",
    "author": "alexeagle",
    "comments": [
      {
        "user": "DanielRosenwasser",
        "created_at": "2018-02-23T20:51:24Z",
        "body": "Thanks Alex!"
      }
    ]
  },
  {
    "number": 21959,
    "title": "It is a compile time error for constant enum expressions to be evaluated to NaN or Infinity. ",
    "created_at": "2018-02-15T05:57:56Z",
    "closed_at": "2018-05-23T22:32:36Z",
    "labels": [
      "Bug",
      "Fixed",
      "Help Wanted"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/21959",
    "body": "Hi,\r\n\r\nThe documentation says\r\n\r\nIt is a compile time error for constant enum expressions to be evaluated to NaN or Infinity.\r\n\r\nBut the below code does not throw any compile time error\r\n\r\n```ts\r\nenum FMixed {\r\n    Data1 = 10 + 0.0 / 0.0,\r\n    Data2 = 0 / 0,\r\n    Data3 = 10 / 0.0\r\n}\r\n\r\nconsole.log(\"FMixed.Data1 is \"+FMixed.Data1);\r\n```\r\nTypeScript Version is 2.7.1",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/21959/comments",
    "author": "kannanwisen",
    "comments": [
      {
        "user": "kannanwisen",
        "created_at": "2018-02-20T12:25:56Z",
        "body": "Better to disallow NaN and Infinity in enum member value"
      },
      {
        "user": "orzFly",
        "created_at": "2018-05-17T18:21:21Z",
        "body": "`undefined` shouldn't be permitted in it as well."
      }
    ]
  },
  {
    "number": 21932,
    "title": "No completion for the JSDoc @template tag",
    "created_at": "2018-02-14T07:18:47Z",
    "closed_at": "2018-02-17T00:27:57Z",
    "labels": [
      "Bug",
      "Fixed",
      "Help Wanted",
      "Good First Issue",
      "Domain: JSDoc"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/21932",
    "body": "```js\r\n/**\r\n * @tem\r\n */\r\n```\r\n\r\nInsert your cursor at the `tem`\r\n\r\nRequest completions. We currently don't provide `@template` as a suggestion",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/21932/comments",
    "author": "DanielRosenwasser",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2018-02-17T00:28:42Z",
        "body": "thanks @sbezludny"
      }
    ]
  },
  {
    "number": 21875,
    "title": "Misspelled imports should also have suggested corrections",
    "created_at": "2018-02-12T02:24:25Z",
    "closed_at": "2018-03-02T18:24:56Z",
    "labels": [
      "Bug",
      "Fixed",
      "Help Wanted",
      "Domain: Error Messages"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/21875",
    "body": "```ts\r\n// helpers.ts\r\nexport function assertNever(x: never, msg: string) {\r\n    throw new Error(\"Unexpected \" + msg);\r\n}\r\n\r\n// user.ts\r\nimport { assertNevar } from \"./helpers\";\r\n\r\nassertNevar(null!, \"Spanish inquisition\");\r\n```\r\n\r\nExpected:\r\n\r\n```\r\nModule '\"./helpers\"' has no exported member 'assertNevar'. Did you mean 'assertNever'?\r\n```\r\n\r\nActual:\r\n\r\n```\r\nModule '\"./helpers\"' has no exported member 'assertNevar'.\r\n```",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/21875/comments",
    "author": "DanielRosenwasser",
    "comments": [
      {
        "user": "AlCalzone",
        "created_at": "2018-02-12T13:35:21Z",
        "body": "I know this is not supposed to be a support forum, but I've wondered this on some repros before:\r\nWhy would I ever define a function argument as `never`? Or is that some kind of artificial construct to test some specific behaviour?"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2018-03-02T06:38:03Z",
        "body": "@AlCalzone if you want to ensure that all possibilities are exhausted, `assertNever` is a handy utility.\r\n\r\n```ts\r\nfunction handleMessage(message: \"hello\" | \"world\") {\r\n  switch (message) {\r\n     case \"hello\": return 100;\r\n     case \"world\": return 200; // try removing this line\r\n     default: assertNever(message);\r\n  }\r\n}\r\n```"
      }
    ]
  },
  {
    "number": 21848,
    "title": "Allows to mutate `const` with non-null assertion",
    "created_at": "2018-02-09T23:41:37Z",
    "closed_at": "2018-02-12T18:58:00Z",
    "labels": [
      "Bug",
      "Fixed",
      "Help Wanted"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/21848",
    "body": "**TypeScript Version:**  2.8.0-dev.20180209\r\n\r\n**Code**\r\n\r\n```ts\r\ndeclare const x: number | undefined;\r\nx!++;\r\n```\r\n\r\n**Expected behavior:**\r\n\r\n```\r\nsrc/a.ts(2,2): error TS2540: Cannot assign to 'x' because it is a constant or a read-only property.\r\n```\r\n\r\n**Actual behavior:**\r\n\r\nNo error.",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/21848/comments",
    "author": "ghost",
    "comments": [
      {
        "user": "DanielRosenwasser",
        "created_at": "2018-02-10T00:10:18Z",
        "body": "But you said it was a constant?"
      },
      {
        "user": "ghost",
        "created_at": "2018-02-10T00:11:48Z",
        "body": "The *expected* behavior is an error. The actual behavior is no error. For `x: number` and `x++` there is correctly an error."
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2018-02-10T00:12:20Z",
        "body": "Sorry. It's been a long week."
      },
      {
        "user": "mhegazy",
        "created_at": "2018-02-12T18:58:17Z",
        "body": "thanks @jack-williams!"
      },
      {
        "user": "jack-williams",
        "created_at": "2018-02-12T19:02:31Z",
        "body": "No problem!"
      }
    ]
  },
  {
    "number": 21716,
    "title": "Formatting of conditional types",
    "created_at": "2018-02-07T11:03:06Z",
    "closed_at": "2018-02-08T17:28:39Z",
    "labels": [
      "Bug",
      "Fixed",
      "Help Wanted",
      "Good First Issue",
      "Domain: Formatter"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/21716",
    "body": "**TypeScript Version:**  2.7.0-dev.20180206\r\n\r\n**Expected behavior:**\r\n\r\n```ts\r\ntype Diff<T, U> = T extends U ? never : T;\r\n```\r\n\r\n**Actual behavior:**\r\n\r\n```ts\r\ntype Diff<T, U> = T extends U?never: T;\r\n```\r\n\r\n**Related Issues:**\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/21716/comments",
    "author": "falsandtru",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2018-02-07T17:26:06Z",
        "body": "@lankaapura wanna pick up this one as well?"
      },
      {
        "user": "lankaapura",
        "created_at": "2018-02-08T03:38:27Z",
        "body": "@mhegazy sure 👍 "
      },
      {
        "user": "lankaapura",
        "created_at": "2018-02-08T16:14:55Z",
        "body": "Created PR #21762, let me know if there are any changes required."
      }
    ]
  },
  {
    "number": 21617,
    "title": "Give detailed error message on `for-of` of iterators without downlevelIteration",
    "created_at": "2018-02-04T10:05:24Z",
    "closed_at": "2018-03-29T22:43:01Z",
    "labels": [
      "Bug",
      "Fixed",
      "Help Wanted",
      "Good First Issue",
      "Domain: Error Messages"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/21617",
    "body": "When someone writes code like this:\r\n```ts\r\nconst strSet: Set<string> = new Set()\r\nstrSet.add('Hello')\r\nstrSet.add('World')\r\nfor (const str of strSet) {\r\n  console.log(str)\r\n}\r\n```\r\nand gets the error\r\n```\r\nType 'Set<string>' is not an array type of a string type.\r\n```\r\nwe end up with a lot of people opening issues like #21601. We should improve this error message to be more helpful. If the target of the `for-of` is assignable to the iterator interface type (and that type is available), the error message should be changed to read something along the lines of:\r\n```\r\nType 'Set<string>' is not an array type of a string type. Use compiler option '--downlevelIteration' to allow iterating of iterators.\r\n```",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/21617/comments",
    "author": "weswigham",
    "comments": [
      {
        "user": "DanielRosenwasser",
        "created_at": "2018-02-04T17:35:17Z",
        "body": "Should it be \"array type ***or*** a string type\"?"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2018-02-04T17:36:00Z",
        "body": "Also, I'd generally avoid using the word \"transpile\" in error messages if possible."
      },
      {
        "user": "aluanhaddad",
        "created_at": "2018-02-04T22:26:00Z",
        "body": "The other missing piece here is not knowing that you need to specify things like `--lib dom.iterable` for it to work with node lists and such."
      },
      {
        "user": "isc30",
        "created_at": "2018-02-12T16:11:44Z",
        "body": "is anyone doing this? I can take care, where should I start looking?\r\nI found the tests, the diagnostic message (Type_0_is_not_an_array_type_or_a_string_type_2495) and the ts code in `checker.ts@22283`"
      },
      {
        "user": "mpsijm",
        "created_at": "2018-03-01T11:35:58Z",
        "body": "I'm currently fixing this issue. I seem to have the generating of the error working, after I have updated the tests, I'll open a PR."
      }
    ]
  },
  {
    "number": 21200,
    "title": "Filter keyword completions based on context",
    "created_at": "2018-01-16T16:09:50Z",
    "closed_at": "2018-01-20T01:26:58Z",
    "labels": [
      "Suggestion",
      "Fixed",
      "Help Wanted",
      "Domain: Completion Lists"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/21200",
    "body": "When using vscode, there are times when suggestions are poorly suggested.\r\n\r\nExample (Pipe is the cursor):\r\n\r\n```ts\r\nexport class MyClass {\r\n\r\n  public myMethod() {\r\n    |\r\n  }\r\n\r\n}\r\n```\r\n\r\nWhen I am at that location, the words `constructor` , `public`, `private`, etc. shouldn't be suggested. With the change of how vscode selects the best word, when I type `con` it suggests `console`, `constructor`, and others. Due to habit I see `console` on top of the list and press enter, however `constructor` gets inserted because of vscode suggestion logic (this gets annoying).\r\n\r\nI feel that the best way around this would be to remove items from the suggestions if they are not valid within that scope at the cursors location.",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/21200/comments",
    "author": "TheColorRed",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2018-01-16T20:54:53Z",
        "body": "Currently all our keyword completions are one group. they are either added or not. and they are always added for completions not following a `.`. \r\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2018-01-16T20:55:21Z",
        "body": "PRs welcomed for filtering the keyword completions based on the location."
      },
      {
        "user": "Kingwl",
        "created_at": "2018-01-17T06:35:31Z",
        "body": "@mhegazy actual there are some filter for keyword completions   \r\n```\r\nconst enum KeywordCompletionFilters {\r\n      None,\r\n      ClassElementKeywords,           // Keywords at class keyword\r\n      ConstructorParameterKeywords,   // Keywords at constructor parameter\r\n  }\r\n```  \r\nshould we extend this enum? or refactor it"
      },
      {
        "user": "mhegazy",
        "created_at": "2018-01-17T07:25:01Z",
        "body": "This now very limited. we only use it to get completions inside a class. we will need to make it exclusive first, i.e. do not show `public` outside a class context. and add aditional ones, e.g. `catch`/`finally`, should only show after a `try`. `break`/`continue` should only show within a loop/switch.. etc.. \r\n\r\n//cc @sheetalkamat for thoughts on best approach here."
      },
      {
        "user": "sheetalkamat",
        "created_at": "2018-01-17T19:50:09Z",
        "body": "@mhegazy  yes, the keywords are currently only filtered from class, constructor parameter locations.. Note that they still have duplicates eg. if you have already typed public for the property , you would still get public as an option.\r\n```\r\nclass c {\r\n public /*completion here will still contain public */\r\n}\r\n```\r\n\r\nI think filtering at current level is better than not having any and can be easily added. eg, at statement scope do not add property declaration modifiers in the keyword as the issue suggests and can easily be extended by adding members to ```KeywordCompletionFilters``` and adding appropriate filters in ```getKeywordCompletions```.\r\n\r\nWe could start with adding filters to remove modifiers inside the block and so on and carve out more filters in next stage as @mhegazy  states. (catch and finally only if try, or break and continue only inside loop)"
      },
      {
        "user": "mhegazy",
        "created_at": "2018-01-20T01:27:18Z",
        "body": "thanks @Kingwl "
      }
    ]
  },
  {
    "number": 21011,
    "title": "Mapped object types aren't checked for implicit any errors",
    "created_at": "2018-01-04T21:55:33Z",
    "closed_at": "2018-01-10T01:11:58Z",
    "labels": [
      "Bug",
      "Fixed",
      "Help Wanted",
      "Good First Issue"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/21011",
    "body": "```ts\r\ntype Foo = { [P in \"hello\"] };\r\n```\r\n\r\nThis is equivalent to\r\n\r\n```ts\r\ntype Foo = { [P in \"hello\"]: any };\r\n```\r\n\r\nBut doesn't trigger a `noImplicitAny` error.",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/21011/comments",
    "author": "DanielRosenwasser",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2018-01-04T21:58:58Z",
        "body": "PRs welcomed."
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2018-01-04T22:04:19Z",
        "body": "I'd expect this to provide an error like `Mapped object type implicitly has an 'any' template type.`"
      },
      {
        "user": "jack-williams",
        "created_at": "2018-01-05T15:53:55Z",
        "body": "Would the fix look something like?\r\n\r\n```typescript\r\nfunction checkMappedType(node: MappedTypeNode) {\r\n    checkSourceElement(node.typeParameter);\r\n    checkSourceElement(node.type);\r\n    // -- new code\r\n    if(noImplicitAny && nodeIsMissing(node.type)) {\r\n        error(node, Diagnostics.<SOME_NEW_ERROR_CODE_HERE>);\r\n    }\r\n    // -- end new code\r\n    const type = <MappedType>getTypeFromMappedTypeNode(node);\r\n    const constraintType = getConstraintTypeFromMappedType(type);\r\n    checkTypeAssignableTo(constraintType, stringType, node.typeParameter.constraint);\r\n}\r\n```\r\nThings I'm not sure of:\r\n- Is it better to extend and use `reportImplicitAnyError`?\r\n- Is the error checking code called too early (should it be after fetching the types?)\r\n"
      }
    ]
  },
  {
    "number": 20966,
    "title": "get (or set) function shows description from *both* get and set function on hover",
    "created_at": "2018-01-02T19:13:31Z",
    "closed_at": "2020-05-06T22:05:32Z",
    "labels": [
      "Suggestion",
      "Help Wanted",
      "Effort: Moderate",
      "VS Code Tracked"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/20966",
    "body": "_From @kleinfreund on December 24, 2017 9:36_\n\n- VSCode Version: Code 1.19.1 (0759f77bb8d86658bc935a10a64f6182c5a1eeba, 2017-12-19T09:41:01.414Z)\r\n- OS Version: Linux x64 4.13.0-21-generic\r\n- Extensions: Extensions are disabled\r\n---\r\n\r\nSteps to Reproduce:\r\n\r\n1. View the following code with language mode set to JavaScript\r\n\r\n   ```js\r\n   class Test {\r\n     constructor() {\r\n       this.value;\r\n     }\r\n   \r\n     /** Getter text */\r\n     get value() {\r\n       return this.value;\r\n     }\r\n   \r\n     /** Setter text */\r\n     set value(value) {\r\n       this.value = value;\r\n     }\r\n   }\r\n   ```\r\n\r\n2. Hover over the `value` getter (or setter) function\r\n\r\n**Expected behavior**:\r\n\r\n`Getter text` (or `Setter text`) appears in the box as the function description.\r\n\r\n**Actual behavior**:\r\n\r\n`Getter text Setter text` appears in the box as the function description.\n\n_Copied from original issue: Microsoft/vscode#40775_",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/20966/comments",
    "author": "mjbvz",
    "comments": [
      {
        "user": "mjbvz",
        "created_at": "2018-01-02T19:14:29Z",
        "body": "TS 2.7.0-insiders.20171214\r\n\r\nHere's the TS server requests/responses:\r\n\r\n```\r\n[Trace  - 11:13:13 AM] Sending request: quickinfo (212). Response expected: yes. Current queue length: 0\r\nArguments: {\r\n    \"file\": \"/Users/matb/projects/san/x.ts\",\r\n    \"line\": 13,\r\n    \"offset\": 14\r\n}\r\n[Trace  - 11:13:13 AM] Response received: quickinfo (212). Request took 3 ms. Success: true \r\nResult: {\r\n    \"kind\": \"property\",\r\n    \"kindModifiers\": \"\",\r\n    \"start\": {\r\n        \"line\": 13,\r\n        \"offset\": 12\r\n    },\r\n    \"end\": {\r\n        \"line\": 13,\r\n        \"offset\": 17\r\n    },\r\n    \"displayString\": \"(property) Test.value: any\",\r\n    \"documentation\": \"Getter text \\nSetter text \",\r\n    \"tags\": []\r\n}\r\n```"
      },
      {
        "user": "mhegazy",
        "created_at": "2018-01-04T19:06:56Z",
        "body": "The current behavior now is for symbols with multiple declarations we combine all the comments. this is to address cases where declarations merge.\r\n\r\nWe could try and filter the jsdoc based on whether the access to the symbol is a read or a write. that will require some rewiring."
      }
    ]
  },
  {
    "number": 20938,
    "title": "No string completions for indexed access types",
    "created_at": "2017-12-29T19:00:02Z",
    "closed_at": "2018-01-07T05:07:01Z",
    "labels": [
      "Bug",
      "Fixed",
      "Help Wanted",
      "Effort: Moderate",
      "Domain: Completion Lists"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/20938",
    "body": "```ts\r\ninterface Foo {\r\n    hello: number;\r\n    world: string;\r\n}\r\n\r\nlet x: Foo['']\r\n```\r\n\r\nTry to request completions within the string literal.\r\n\r\n**Expected**: completions for `hello` and `world`\r\n**Actual**: no completions",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/20938/comments",
    "author": "DanielRosenwasser",
    "comments": [
      {
        "user": "DanielRosenwasser",
        "created_at": "2017-12-29T19:00:44Z",
        "body": "@mariusschulz, you said you might be interested in working on this?"
      },
      {
        "user": "Kingwl",
        "created_at": "2017-12-30T00:31:15Z",
        "body": "i'd like to working on this😂"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2017-12-30T10:33:28Z",
        "body": "Sorry, @mariusschulz DM'd me on Twitter. You've been doing an awesome job with the PRs though @Kingwl!"
      }
    ]
  },
  {
    "number": 20873,
    "title": "strictNullChecks doesn't work with empty destructuring assignment",
    "created_at": "2017-12-23T07:28:41Z",
    "closed_at": "2018-01-18T22:24:51Z",
    "labels": [
      "Bug",
      "Fixed",
      "Help Wanted",
      "Good First Issue"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/20873",
    "body": "**TypeScript Version:**  2.7.0-dev.20171223\r\n\r\n**Code**\r\n\r\n```ts\r\nconst [] = null;\r\n```\r\n\r\n**Expected behavior:**\r\n\r\nerror\r\n\r\n**Actual behavior:**\r\n\r\npass",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/20873/comments",
    "author": "falsandtru",
    "comments": [
      {
        "user": "DanielRosenwasser",
        "created_at": "2017-12-23T09:44:33Z",
        "body": "We should reuse the `Object is possibly ____` messages and check for the RHS of any destructuring assignment. The following cases should error:\r\n\r\n```ts\r\nlet { } = null;\r\n({} = null);\r\n\r\nlet { } = undefined;\r\n({} = undefined);\r\n\r\nlet { } = Math.random() ? {} : null;\r\n({} = Math.random() ? {} : null);\r\n\r\nlet { } = Math.random() ? {} : undefined;\r\n({} = Math.random() ? {} : undefined);\r\n\r\nlet { } = Math.random() ? null : undefined;\r\n({} = Math.random() ? null : undefined);\r\n```"
      },
      {
        "user": "jack-williams",
        "created_at": "2017-12-29T23:56:55Z",
        "body": "Is anyone working on this? I'd be interested in having a go, but I don't want to impose if anyone is working on it already, or planning to.\r\n \r\nEdit: See #21110  "
      }
    ]
  },
  {
    "number": 20821,
    "title": "Allow type assertions from `T`-constrained type variable to subtypes of `T`",
    "created_at": "2017-12-20T16:53:42Z",
    "closed_at": "2022-05-19T05:25:47Z",
    "labels": [
      "Suggestion",
      "Help Wanted",
      "Experience Enhancement"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/20821",
    "body": "**TypeScript Version:**  2.6.2\r\n\r\n**Code**\r\n\r\n```ts\r\nenum ActionType {\r\n    Call\r\n}\r\n\r\ninterface Action {\r\n    type: ActionType;\r\n}\r\n\r\ninterface CallAction extends Action {\r\n    context: any;\r\n}\r\n\r\nclass Service {\r\n    exec<T extends Action>(action: T) {\r\n        if (action.type == ActionType.Call) {\r\n            (<CallAction>action).context = {};\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n**Expected behavior:**\r\n\r\nI should use cast because CallAction extends Action\r\n\r\n**Actual behavior:**\r\n\r\nI have the following compilation error:\r\n\r\n```ts\r\n(<CallAction>action).context = {};\r\n```\r\n```console\r\nType 'T' cannot be converted to type 'CallAction'.\r\nType 'T' cannot be converted to type 'CallAction'.\r\n  Type 'Action' is not comparable to type 'CallAction'.\r\n    Property 'context' is missing in type 'Action'.\r\n```",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/20821/comments",
    "author": "ghoullier",
    "comments": [
      {
        "user": "DanielRosenwasser",
        "created_at": "2017-12-20T18:55:40Z",
        "body": "Could you elaborate on why using `Action` instead of `T` isn't sufficient in this case?"
      },
      {
        "user": "ghoullier",
        "created_at": "2017-12-20T20:24:33Z",
        "body": "I have an other class Store\r\n```ts\r\nclass Store {\r\n    db = new Map<ActionType, Action[]>();\r\n    service = new Service();\r\n    store(action: Action) {\r\n        if (this.db.has(action.type)) {\r\n            this.db.set(action.type, []);\r\n        }\r\n        this.db.get(action.type).push(action);\r\n        this.service.exec(action);\r\n    }\r\n    storeGeneric<T extends Action>(action: T) {\r\n        if (this.db.has(action.type)) {\r\n            this.db.set(action.type, []);\r\n        }\r\n        this.db.get(action.type).push(action);\r\n        this.service.exec(action);\r\n    }\r\n}\r\n```\r\n\r\n```ts\r\nconst store = new Store();\r\n```\r\n\r\nThis example doesn't work \r\n```ts\r\nstore.store({\r\n    type: ActionType.Call,\r\n    context: {}\r\n});\r\n```\r\n\r\n```console\r\nArgument of type '{ type: ActionType; context: {}; }' is not assignable to parameter of type 'Action'.\r\n  Object literal may only specify known properties, and 'context' does not exist in type 'Action'.\r\n```\r\n\r\nThis example works\r\n```ts\r\nstore.storeGeneric<CallAction>({\r\n    type: ActionType.Call,\r\n    context: {}\r\n});\r\n```\r\n\r\nThat's why I use T instead Action in my Service. I see there is no problem when I switch to a non Generic method. But I want to know why it doesn't work, it's a non intuitive behavior..."
      },
      {
        "user": "ghoullier",
        "created_at": "2018-01-09T06:32:52Z",
        "body": "I solved the problem using generic class instead of generic methods\r\n\r\n```ts\r\ninterface Typed<U> {\r\n    type: U;\r\n}\r\n\r\ninterface Service<T extends Typed<U>, U> {\r\n    exec(action: T): T;\r\n}\r\n\r\nclass Store<T extends Typed<U>, U> {\r\n    db = new Map<U, T[]>();\r\n    constructor(private service: Service<T, U>) {}\r\n    store(action: T): T {\r\n        if (this.db.has(action.type)) {\r\n            this.db.set(action.type, []);\r\n        }\r\n        this.db.get(action.type).push(action);\r\n        this.service.exec(action);\r\n        return action;\r\n    }\r\n}\r\n\r\n\r\nenum ActionType {\r\n    Call\r\n}\r\n\r\ninterface Action extends Typed<ActionType>{\r\n    type: ActionType;\r\n}\r\n\r\ninterface CallAction extends Action {\r\n    context: any;\r\n}\r\n\r\nclass ActionService implements Service<Action, ActionType> {\r\n    exec(action: Action) {\r\n        if (action.type === ActionType.Call) {\r\n            console.log('ActionType.Call', (<CallAction>action).context);\r\n        }\r\n        return action;\r\n    }\r\n}\r\nconst service = new ActionService();\r\nconst store = new Store<Action, ActionType>(service);\r\nstore.store({\r\n    type: ActionType.Call\r\n});\r\n```"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2018-01-30T00:30:49Z",
        "body": "@DanielRosenwasser Over to you - we agreed that this should be allowed in the comparability relation assuming it can be reasonably spec'd."
      }
    ]
  },
  {
    "number": 20568,
    "title": "Unused type parameters should be checked by --noUnusedParameters, not --noUnusedLocals",
    "created_at": "2017-12-08T04:49:04Z",
    "closed_at": "2018-01-26T00:18:35Z",
    "labels": [
      "Bug",
      "Fixed",
      "Breaking Change",
      "Help Wanted"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/20568",
    "body": "I reviewed the compiler options for my project and decided to enable `--noUnusedLocals` but not `--noUnusedParameters` since the cost-benefit picture seems to be much better for `--noUnusedLocals`.  However, I was surprised to get an error on a type alias that has an unused type parameter for documentation purposes.  Since \"type parameter\" has \"parameter\" in the name, I expected it would be checked by `--noUnusedParameters`.  I see that several issues have been filed related to the check for unused type parameters, but no one seemed to think it was odd that the check was under `--noUnusedLocals`.\r\n\r\nThe code change is very simple, and I'll be happy to prepare a pull request if you agree with the change.  I suppose it's a breaking change if someone is using `--noUnusedParameters` and not `--noUnusedLocals`; that configuration seems unlikely.\r\n\r\n**TypeScript Version:**  current master (5e5b7706e55e3f416c0ee7bad0cdb1ecf5342b3f)\r\n\r\n**Code**\r\n\r\n```ts\r\n// Compile with --noUnusedLocals\r\ntype Oops<T> = number;\r\n```\r\n\r\n**Expected behavior:**\r\nNo errors.\r\n\r\n**Actual behavior:**\r\n```\r\nunused-type-parameter.ts(1,11): error TS6133: 'T' is declared but its value is never read.\r\n```",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/20568/comments",
    "author": "mattmccutchen",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2018-01-11T01:03:29Z",
        "body": "I suppose you are right.. this is a breaking change technically. but open to taking a PR."
      }
    ]
  },
  {
    "number": 20342,
    "title": "Add an ES2018 Target and Lib",
    "created_at": "2017-11-29T21:41:08Z",
    "closed_at": "2017-12-02T19:17:00Z",
    "labels": [
      "Bug",
      "Fixed",
      "Help Wanted",
      "Good First Issue"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/20342",
    "body": "This should include any features we support which are slated for the 2018 spec release (currently stage 4 proposals), or things we think are likely to be in it (ie, promising stage 3 proposals).",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/20342/comments",
    "author": "weswigham",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2017-11-29T22:16:07Z",
        "body": "PRs welcomed if someone wants to get to this before @weswigham does."
      },
      {
        "user": "benbraou",
        "created_at": "2017-11-30T23:46:32Z",
        "body": "I will provide a pull request for this. First contribution incoming ^^"
      },
      {
        "user": "mhegazy",
        "created_at": "2017-12-02T19:20:57Z",
        "body": "thanks @benbraou!"
      }
    ]
  },
  {
    "number": 20299,
    "title": "noImplicitReturns misidentifies generator return as function return when strictNullChecks is false",
    "created_at": "2017-11-28T09:21:01Z",
    "closed_at": "2017-11-29T23:27:32Z",
    "labels": [
      "Bug",
      "Fixed",
      "Help Wanted"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/20299",
    "body": "**TypeScript Version:** 2.6.1 -  2.7.0-dev.20171128\r\n\r\n**Code:**\r\n```ts\r\n// index.ts\r\nfunction* testGenerator() {\r\n    if (Math.random() > 0.5) {\r\n        return;\r\n    }\r\n    yield 'hello';\r\n}\r\n\r\n/* tsconfig.json\r\n{\r\n    \"files\": [\"index.ts\"],\r\n    \"compilerOptions\": {\r\n        \"lib\": [\"esnext\"], \"target\": \"ESNEXT\", \"module\": \"es2015\",\r\n        \"strictNullChecks\": true,\r\n        \"noImplicitReturns\": true\r\n    }\r\n}\r\n*/\r\n```\r\n\r\n**Expected behavior:**\r\n\r\nNo errors due to the generator's early `return`, regardless of whether `strictNullChecks` is true or false.\r\n\r\n**Actual behavior:**\r\n\r\n* No errors when `strictNullChecks` is _true_\r\n* The following error when `strictNullChecks` is _false_:\r\n  ```index.ts(3,9): error TS7030: Not all code paths return a value.```\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/20299/comments",
    "author": "trxcllnt",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2017-11-28T17:50:19Z",
        "body": "PRs welcomed!"
      },
      {
        "user": "mhegazy",
        "created_at": "2017-11-29T23:27:53Z",
        "body": "thanks @Kingwl !"
      },
      {
        "user": "trxcllnt",
        "created_at": "2017-11-30T00:13:55Z",
        "body": "@mhegazy @Kingwl thanks! I haven't tested, but this issue may affect async generators also. If so, would the fix in the PR will also fix them?"
      },
      {
        "user": "Kingwl",
        "created_at": "2017-11-30T11:44:45Z",
        "body": "@trxcllnt sure"
      }
    ]
  },
  {
    "number": 20197,
    "title": "No completion when constructor parameter name matches a type name",
    "created_at": "2017-11-21T18:32:02Z",
    "closed_at": "2024-03-08T22:07:31Z",
    "labels": [
      "Bug",
      "Help Wanted",
      "Domain: Completion Lists"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/20197",
    "body": "**TypeScript Version:**  2.6\r\n\r\n**Code**\r\n\r\n```ts\r\n\r\ndeclare namespace options {\r\n\r\n    type Foo = { value: number; }\r\n\r\n    type Bar = { text: string; }\r\n}\r\n\r\nclass Foo {\r\n\r\n    constructor(\r\n        options: op  // No completion here for namespace \"options\"\r\n    ) { \r\n\r\n        const barOptions: opt // No completion here either\r\n    }\r\n\r\n}\r\n```\r\n\r\n**Expected behavior:**\r\n\r\nThere should be completion for the `options` namespace at both positions indicated in the code sample.\r\n\r\n**Actual behavior:**\r\n\r\nThere is no completion. Things work correctly if the constructor parameter is renamed to say `options2` .\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/20197/comments",
    "author": "NoelAbrahams",
    "comments": [
      {
        "user": "Kingwl",
        "created_at": "2017-11-27T06:57:08Z",
        "body": "```\r\ndeclare namespace options {  \r\n\r\n    type Foo = { value: number; }  \r\n\r\n    type Bar = { text: string; }  \r\n\r\n} \r\n class options {  \r\n\r\n    constructor(  \r\n\r\n        options: op  // No completion here for namespace \"options\"  \r\n\r\n    ) {   \r\n\r\n        const barOptions: op // No completion here either  \r\n    }  \r\n}  \r\n```\r\n\r\nping @mhegazy \r\nshould `op` completion with class `options` and namespace modules `options`? "
      },
      {
        "user": "mhegazy",
        "created_at": "2017-11-27T19:28:00Z",
        "body": "in this case the class and the namespace are the same symbol.."
      },
      {
        "user": "Kingwl",
        "created_at": "2017-11-28T04:21:08Z",
        "body": "@mhegazy thanks for the response and i have send a pr 😄"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2024-03-08T22:07:31Z",
        "body": "These both work now"
      }
    ]
  },
  {
    "number": 20073,
    "title": "Bad formatting adding `super()` to empty constructor",
    "created_at": "2017-11-16T19:10:00Z",
    "closed_at": "2017-12-05T16:33:30Z",
    "labels": [
      "Bug",
      "Fixed",
      "Help Wanted",
      "Domain: Formatter"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/20073",
    "body": "**TypeScript Version:**  2.7.0-dev.20171115\r\n\r\n**Code**\r\n\r\n```ts\r\nclass C extends Object {\r\n    constructor() {}\r\n}\r\n```\r\n\r\nUse the quickfix.\r\n\r\n**Expected behavior:**\r\n\r\n```ts\r\nclass C extends Object {\r\n    constructor() {\r\n        super();\r\n    }\r\n}\r\n```\r\n\r\n**Actual behavior:**\r\n\r\n```ts\r\nclass C extends Object {\r\n    constructor() {super();\r\n}\r\n}\r\n```",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/20073/comments",
    "author": "ghost",
    "comments": [
      {
        "user": "charlespierce",
        "created_at": "2017-12-02T02:34:05Z",
        "body": "PR Opened to Resolve this Issue #20405 "
      }
    ]
  },
  {
    "number": 19793,
    "title": "Improve error message when `implements` is used instead of `extends`",
    "created_at": "2017-11-07T03:19:53Z",
    "closed_at": "2017-12-19T19:39:06Z",
    "labels": [
      "Suggestion",
      "Fixed",
      "Help Wanted",
      "Domain: Error Messages"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/19793",
    "body": "**TypeScript Version:**  2.7.0-dev.201xxxxx\r\n\r\n**Code**\r\n\r\n```ts\r\nclass A {\r\n\tprivate x: number;\r\n}\r\n\r\nclass B implements A {}\r\n```\r\n\r\n**Expected behavior:**\r\n\r\nBegin the error message with `class 'B' is declared to implement class 'A'. Did you mean 'extends'?`. Then continue with the specific error message.\r\n\r\n**Actual behavior:**\r\n\r\n```\r\nsrc/a.ts(5,7): error TS2420: Class 'B' incorrectly implements interface 'A'.\r\n  Property 'x' is missing in type 'B'.\r\n```\r\nNot helpful on its own because we can't implement `x`. I figure 99% of the time one intends to extend a class rather than implement, so we should just show an additional message any time one class implements another and there's an error.",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/19793/comments",
    "author": "ghost",
    "comments": [
      {
        "user": "charlespierce",
        "created_at": "2017-11-07T05:31:42Z",
        "body": "PR Opened to resolve this #19797"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2017-12-19T19:39:14Z",
        "body": "Thanks @charlespierce!"
      }
    ]
  },
  {
    "number": 19761,
    "title": "Class 'AnotherProductService' incorrectly implements interface 'ProductService'.",
    "created_at": "2017-11-06T09:58:29Z",
    "closed_at": "2017-11-07T02:54:00Z",
    "labels": [
      "Suggestion",
      "Help Wanted",
      "Domain: Error Messages"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/19761",
    "body": "I create a project with angular/cli , when I try used service, I get an error.\r\n-----\r\n\r\n**TypeScript Version:**  2.4.2\r\n**Angular CLI Version:** 1.5.0\r\n**NPM Version:** 5.0.3\r\n**Node.js Version:**  8.1.0\r\n**OS Version:**  Winwods 10 Professional Edition x64\r\n---------\r\n**Code**\r\n\r\n```ts\r\nimport { Injectable } from '@angular/core';\r\nimport { LoggerService } from './logger.service';\r\n\r\n\r\n@Injectable()\r\nexport class ProductService {\r\n\r\n  constructor(private logger: LoggerService) { }\r\n\r\n  getProduct(): Product {\r\n    this.logger.log('getProduct function');\r\n    return new Product(0, 'iphone7', 5899, 'apple phone');\r\n  }\r\n}\r\n\r\nexport class Product {\r\n\r\n  constructor(\r\n    public id: number,\r\n    public title: string,\r\n    public price: number,\r\n    public desc: string\r\n  ) {\r\n\r\n  }\r\n}\r\n```\r\n-------------\r\n```ts\r\nimport { Injectable } from '@angular/core';\r\nimport { Product, ProductService } from './product.service';\r\n\r\n@Injectable()\r\nexport class AnotherProductService implements ProductService {\r\n\r\n  getProduct(): Product {\r\n    return new Product(1, 'sunsumg7', 4899, 'sunsumg phone');\r\n  }\r\n\r\n  constructor() { }\r\n\r\n}\r\n```\r\n------------\r\n```ts\r\nimport { Injectable } from '@angular/core';\r\n\r\n@Injectable()\r\nexport class LoggerService {\r\n\r\n  constructor() { }\r\n\r\n  log(message: string) {\r\n    console.log(message);\r\n  }\r\n\r\n}\r\n```\r\n----------------\r\n```ts\r\nimport { BrowserModule } from '@angular/platform-browser';\r\nimport { NgModule } from '@angular/core';\r\n\r\nimport { AppComponent } from './app.component';\r\nimport { Product1Component } from './product1/product1.component';\r\nimport { ProductService } from './shared/product.service';\r\nimport { Product2Component } from './product2/product2.component';\r\nimport { LoggerService } from './shared/logger.service';\r\n\r\n@NgModule({\r\n  declarations: [\r\n    AppComponent,\r\n    Product1Component,\r\n    Product2Component\r\n  ],\r\n  imports: [\r\n    BrowserModule\r\n  ],\r\n  providers: [ProductService, LoggerService],\r\n  bootstrap: [AppComponent]\r\n})\r\nexport class AppModule { }\r\n```\r\n------\r\n\r\n**Expected behavior:**\r\n- If it is work, the Product where be get and show on the html.\r\n--------------\r\n\r\n**Actual behavior:**\r\n- I get an error.\r\n```\r\nERROR in src/app/shared/another-product.service.ts(5,14): error TS2420: Class 'AnotherProductService' incorrectly implements interface 'ProductService'.Property 'logger' is missing in type 'AnotherProductService'.\r\n\r\n```",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/19761/comments",
    "author": "dingziyang",
    "comments": [
      {
        "user": "ghost",
        "created_at": "2017-11-06T15:24:11Z",
        "body": "You probably meant `extends` instead of `implements`.\r\nYou can never `implement` a class with private members, so we should probably improve the error message here."
      },
      {
        "user": "dingziyang",
        "created_at": "2017-11-07T01:47:08Z",
        "body": "@andy-ms I understand what you main. Everything in interface must be public. \r\nBut, I'm sure I use implements here. Because I downloaded a study video, the teacher is doing this and it's worked. He also used Angular4 and TypeScript. \r\n**Oh! It drives me crazy!**"
      },
      {
        "user": "ghost",
        "created_at": "2017-11-07T02:08:33Z",
        "body": "It is possible to \"implement\" a class -- but it means treating the class as an interface, so you'll have to create an implementation of every one of its members.\r\nHowever, if the class you're implementing has a private member, it's impossible to implement.\r\n```ts\r\nclass A {\r\n\tprivate x: number;\r\n}\r\n// Error: Types have separate declarations of a private property 'x'.\r\nclass B implements A {\r\n\tprivate x: number;\r\n}\r\n```\r\n\r\nIt's correct that we give you this error message, because if `B implements A`, you would expect to be able to assign a `B` to an `A`, but you can't assign anything to a class with a private member unless it's derived from that class via `extends`. So the error message should just tell you that instead of telling you to implement a property that you can't possibly implement.\r\n\r\nIn your case, if you really don't intend to use `extends`, you must define an interface and have both classes implement that."
      },
      {
        "user": "dingziyang",
        "created_at": "2017-11-07T02:53:54Z",
        "body": "@andy-ms Thanks for your help. In the next section, the teacher changed ```private``` to ```public```。\r\n（＃－.－）"
      },
      {
        "user": "ghost",
        "created_at": "2017-11-07T03:20:39Z",
        "body": "Moved the error message issue to #19793."
      }
    ]
  },
  {
    "number": 19753,
    "title": "Make iterable interfaces by extending instead of method defining",
    "created_at": "2017-11-05T16:22:52Z",
    "closed_at": "2019-05-07T23:09:51Z",
    "labels": [
      "Bug",
      "Help Wanted",
      "Domain: lib.d.ts",
      "Good First Issue"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/19753",
    "body": "`[Symbol.iterator](): IterableIterator<T>;` is verbose. It is not modern es style. Should use `extends Iterable<T>` instead.\r\n\r\n**TypeScript Version:**  master\r\n\r\n**Expected behavior:**\r\n\r\n```ts\r\ninterface NonIterableIterator<T> {\r\n    next(value?: any): IteratorResult<T>;\r\n    return?(value?: any): IteratorResult<T>;\r\n    throw?(e?: any): IteratorResult<T>;\r\n}\r\n\r\ninterface Iterator<T> extends NonIterableIterator<T> {\r\n    [Symbol.iterator](): Iterator<T>;\r\n}\r\n\r\ninterface Iterable<T> {\r\n    [Symbol.iterator](): Iterator<T>;\r\n}\r\n\r\ninterface Array<T> extends Iterable<T> {\r\n}\r\n```\r\n\r\nor\r\n\r\n```ts\r\ninterface Iterable<T, I extends NonIterableIterator<T> = Iterator<T>> {\r\n    [Symbol.iterator](): I;\r\n}\r\n```\r\n\r\n**Actual behavior:**\r\n\r\n```ts\r\ninterface Iterator<T> {\r\n    next(value?: any): IteratorResult<T>;\r\n    return?(value?: any): IteratorResult<T>;\r\n    throw?(e?: any): IteratorResult<T>;\r\n}\r\n\r\ninterface Iterable<T> {\r\n    [Symbol.iterator](): Iterator<T>;\r\n}\r\n\r\ninterface IterableIterator<T> extends Iterator<T> {\r\n    [Symbol.iterator](): IterableIterator<T>;\r\n}\r\n\r\ninterface Array<T> {\r\n    /** Iterator */\r\n    [Symbol.iterator](): IterableIterator<T>;\r\n}\r\n```",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/19753/comments",
    "author": "falsandtru",
    "comments": [
      {
        "user": "DanielRosenwasser",
        "created_at": "2017-11-06T07:48:42Z",
        "body": "Seems like a good idea. PRs are welcome."
      },
      {
        "user": "MhdTlb",
        "created_at": "2017-11-09T05:02:05Z",
        "body": "I would like to work on this issue but i need some help for my first PR"
      },
      {
        "user": "mhegazy",
        "created_at": "2017-11-09T17:27:20Z",
        "body": "I think @falsandtru already has a PR out."
      },
      {
        "user": "rbuckton",
        "created_at": "2019-05-07T23:05:31Z",
        "body": "An `Iterable` subtype should be able to define its own return type for `[Symbol.iterator]()` as long as it is assignment compatible. Adding an extra type parameter to `Iterable` for this case seems unnecessary and uses up a type argument position better reserved for possibly defining the `TReturn` and `TNext` types, as per #30790. It also will result in significantly more verbose output when we emit declaration files and infer an `Iterable<T, I>`, since we always emit *all* type arguments for inferred types."
      },
      {
        "user": "falsandtru",
        "created_at": "2019-05-08T09:02:26Z",
        "body": "To be clear, the problem caused by this issue will be fixed by #30790."
      }
    ]
  },
  {
    "number": 19670,
    "title": "node.getText(sourceFile) crashes when node.kind == Identifier",
    "created_at": "2017-11-01T21:41:50Z",
    "closed_at": "2017-11-01T23:37:07Z",
    "labels": [
      "Bug",
      "Fixed",
      "Help Wanted",
      "API"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/19670",
    "body": "**TypeScript Version:**  2.7.0-dev.20171101\r\n\r\nThis program uses the TypeScript compiler's API to walk the AST (abstract syntax tree) of some parsed TypeScript source code. Compilation works fine; when you run the program, it should display the node type (`SyntaxKind`) and text of every node in the AST.\r\n\r\n**Code**\r\n\r\n```ts\r\nimport * as fs from \"fs\";\r\nimport * as ts from \"typescript\";\r\n\r\nconst source = 'console.log(\"hello, world\")';\r\n\r\nconst host: ts.LanguageServiceHost = {\r\n    getCompilationSettings: () => ({}),\r\n    getScriptFileNames: () => [\"example.ts\"],\r\n    getScriptVersion: (filename: string) => \"helloworld\",\r\n    getScriptSnapshot: (filename: string): ts.IScriptSnapshot => {\r\n        return {\r\n            getText: (start: number, end: number) => source.slice(start, end),\r\n            getLength: () => source.length,\r\n            getChangeRange: (oldSnapshot: ts.IScriptSnapshot) => undefined\r\n        };\r\n    },\r\n    getCurrentDirectory: process.cwd,\r\n    getDefaultLibFileName: (options: ts.CompilerOptions) => \"node_modules/typescript/lib/lib.d.ts\",\r\n    getNewLine: () => \"\\n\"\r\n};\r\n\r\nconst languageService = ts.createLanguageService(host);\r\nconst sourceFile = ts.createSourceFile(\"example.ts\", source, ts.ScriptTarget.ES2015);\r\n\r\nfunction visit(parent: ts.Node, node: ts.Node, ind: string) {\r\n    // This next line will crash when it reaches an Identifier node for the identifier 'console':\r\n    console.log(ind + ts.SyntaxKind[node.kind] + \":\" + node.getText(sourceFile).replace(/\\n/g, \"\\\\n\"));\r\n\r\n    // If you use this version instead, it will not crash, because sourceFile() is passed in to node.getStart():\r\n    //console.log(ind + ts.SyntaxKind[node.kind] + \":\" + source.substring(node.getStart(sourceFile), node.getEnd()).replace(/\\n/g, \"\\\\n\"));\r\n\r\n    ts.forEachChild(node, (child: ts.Node) => {\r\n        visit(node, child, ind + \"  \");\r\n    });\r\n}\r\n\r\nvisit(null, sourceFile, \"\");\r\n```\r\n\r\n**Expected behavior:**\r\nThis program uses the TypeScript compiler's API. Compilation works fine; when you run the program, it should display the node type (`SyntaxKind`) and text of every node in the AST.\r\n\r\n**Actual behavior:**\r\nIt displays the first several nodes of the AST correctly. But when it reaches the node for the `console` identifier, it crashes:\r\n\r\n```\r\nSourceFile:console.log(\"hello, world\")\r\n  ExpressionStatement:console.log(\"hello, world\")\r\n    CallExpression:console.log(\"hello, world\")\r\n      PropertyAccessExpression:console.log\r\n/Users/mikemorearty/src/typescript/crashdemo/node_modules/typescript/lib/typescript.js:7479\r\n        return ts.skipTrivia((sourceFile || getSourceFileOfNode(node)).text, node.pos);\r\n                                                                       ^\r\n\r\nTypeError: Cannot read property 'text' of undefined\r\n    at Object.getTokenPosOfNode (/Users/mikemorearty/src/typescript/crashdemo/node_modules/typescript/lib/typescript.js:7479:72)\r\n    at IdentifierObject.TokenOrIdentifierObject.getStart (/Users/mikemorearty/src/typescript/crashdemo/node_modules/typescript/lib/typescript.js:95162:23)\r\n    at IdentifierObject.TokenOrIdentifierObject.getText (/Users/mikemorearty/src/typescript/crashdemo/node_modules/typescript/lib/typescript.js:95183:77)\r\n    at visit (/Users/mikemorearty/src/typescript/crashdemo/index.js:24:61)\r\n    at /Users/mikemorearty/src/typescript/crashdemo/index.js:28:9\r\n    at visitNode (/Users/mikemorearty/src/typescript/crashdemo/node_modules/typescript/lib/typescript.js:12655:24)\r\n    at Object.forEachChild (/Users/mikemorearty/src/typescript/crashdemo/node_modules/typescript/lib/typescript.js:12786:24)\r\n    at visit (/Users/mikemorearty/src/typescript/crashdemo/index.js:27:8)\r\n    at /Users/mikemorearty/src/typescript/crashdemo/index.js:28:9\r\n    at visitNode (/Users/mikemorearty/src/typescript/crashdemo/node_modules/typescript/lib/typescript.js:12655:24)\r\n```\r\n\r\nThe fix is easy: In `src/services/services.ts` line 279, `sourceFile` needs to be passed in to `this.getStart()`. In other words:\r\n\r\n```\r\ndiff --git a/src/services/services.ts b/src/services/services.ts\r\nindex 06edd621e9..cd6fe86771 100644\r\n--- a/src/services/services.ts\r\n+++ b/src/services/services.ts\r\n@@ -276,7 +276,10 @@ namespace ts {\r\n         }\r\n\r\n         public getText(sourceFile?: SourceFile): string {\r\n-            return (sourceFile || this.getSourceFile()).text.substring(this.getStart(), this.getEnd());\r\n+            if (!sourceFile) {\r\n+                sourceFile = this.getSourceFile();\r\n+            }\r\n+            return sourceFile.text.substring(this.getStart(sourceFile), this.getEnd());\r\n         }\r\n\r\n         public getChildCount(): number {\r\n```\r\n\r\nIn fact, this same change already exists farther up in the same file, in `class NodeObject`.",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/19670/comments",
    "author": "mmorearty",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2017-11-01T22:46:54Z",
        "body": "A PR would be appreciated. "
      }
    ]
  },
  {
    "number": 19493,
    "title": "insertSpaceBeforeTypeAnnotation",
    "created_at": "2017-10-26T09:58:21Z",
    "closed_at": "2018-01-08T21:25:03Z",
    "labels": [
      "Suggestion",
      "Fixed",
      "Help Wanted",
      "Domain: Formatter"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/19493",
    "body": "Any chance this could be an option?\r\n\r\nSimilar behaviour to `insertSpaceAfterTypeAssertion`\r\n\r\n`function RGBtoHSB( param1: Int, param2: Int, param3: Int )` would become\r\n`function RGBtoHSB( param1 : Int, param2 : Int, param3 : Int )`",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/19493/comments",
    "author": "mastef",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2018-01-08T21:25:22Z",
        "body": "thanks @Kingwl !"
      },
      {
        "user": "mastef",
        "created_at": "2018-01-08T21:27:45Z",
        "body": "Thank you!"
      }
    ]
  },
  {
    "number": 19367,
    "title": "No path completions for dynamic import expressions",
    "created_at": "2017-10-20T07:14:49Z",
    "closed_at": "2017-10-31T21:11:12Z",
    "labels": [
      "Bug",
      "Fixed",
      "Help Wanted",
      "Good First Issue",
      "Domain: Completion Lists"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/19367",
    "body": "```ts\r\n// @Filename: ./a.ts\r\nexport {};\r\n```\r\n\r\n```ts\r\n// @Filename: ./b.ts\r\nlet a = import('./');\r\n```\r\n\r\nRequest completion after the `./`\r\n\r\n**Expected**: `b` is a valid entry.\r\n**Actual**: No completions",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/19367/comments",
    "author": "DanielRosenwasser",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2017-10-31T21:11:29Z",
        "body": "thanks @Kingwl!"
      }
    ]
  },
  {
    "number": 19352,
    "title": "Improve wrong usage of `case` compile errors",
    "created_at": "2017-10-19T20:50:34Z",
    "closed_at": "2020-08-27T17:58:13Z",
    "labels": [
      "Bug",
      "Help Wanted",
      "Domain: Error Messages"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/19352",
    "body": "<!-- BUGS: Please use this template. -->\r\n\r\n<!-- Please try to reproduce the issue with `typescript@next`. It may have already been fixed. -->\r\n**TypeScript Version:**  2.6.0-dev.201xxxxx\r\n\r\n**Code**\r\n```\r\n// This works\r\nfor (const cs of [1,2,3]) console.log(cs);\r\n\r\n// This doesn't, but the compile error is cryptic\r\n// Variable declaration expected.\r\n// '=' expected.\r\nfor (const case of [1, 2, 3]) console.log(case);\r\n```\r\n\r\n**Expected behavior:**\r\nEmit an error like `\"case\" clauses can only appear in a switch statement`\r\n\r\n**Actual behavior:**\r\nEmits these errors:\r\n`Variable declaration expected.`\r\n`'=' expected.`\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/19352/comments",
    "author": "ubershmekel",
    "comments": [
      {
        "user": "massimonewsuk",
        "created_at": "2018-05-09T11:03:13Z",
        "body": "I had this same error message just now and spent like 10 minutes trying to decipher it. It's not a very good error message at all.\r\n\r\nIt is also printed out for a simple line of code like this:\r\n```\r\nconst case = \"123\";\r\n```\r\n\r\nWould be cool if it could say something like cannot use reserved keyword as variable name."
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2020-08-27T17:58:28Z",
        "body": "Thanks @JoshuaKGoldberg!"
      }
    ]
  },
  {
    "number": 19349,
    "title": "Symbol-named properties get element-access completions",
    "created_at": "2017-10-19T20:36:23Z",
    "closed_at": "2017-10-30T19:37:13Z",
    "labels": [
      "Bug",
      "Fixed",
      "Help Wanted",
      "Good First Issue",
      "Domain: Completion Lists"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/19349",
    "body": "```ts\r\nconst c = Symbol();\r\nlet obj = { [Symbol.iterator]: 100 };\r\nlet a = obj['/**/']\r\n```\r\n\r\nGo to the `/**/` marker and request a completion.\r\n\r\n**Expected**: No completions.\r\n**Actual**: Completions for `__@iterator`!\r\n\r\nCurrently with #15473, this is exacerbated.",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/19349/comments",
    "author": "DanielRosenwasser",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2017-10-19T20:44:23Z",
        "body": "PRs welcomed."
      },
      {
        "user": "rbuckton",
        "created_at": "2017-10-22T00:26:41Z",
        "body": "I created a PR to fix this, since this is more noticeable with the dynamic names PR."
      }
    ]
  },
  {
    "number": 19192,
    "title": "Language Service don't show protected members in recursive generic types",
    "created_at": "2017-10-15T14:11:02Z",
    "closed_at": "2017-11-09T01:44:12Z",
    "labels": [
      "Bug",
      "Fixed",
      "Help Wanted",
      "Domain: Completion Lists"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/19192",
    "body": "**TypeScript Version:**  2.6.0-dev.20171015\r\n\r\n```ts\r\nexport class TestBase<T extends TestBase<T>>\r\n{\r\n    private privateMethod(p: any): void { }\r\n    protected protectedMethod(p: any): void { }\r\n\r\n    public publicMethod1(t: T): void\r\n    {\r\n        t. /* <---- press Ctrl+Space here, ts language service only shows private and public methods, protectedMethod is hidden */\r\n\r\n        t.protectedMethod(null/* if I write the method name by myself, the method arguments shown here is fine */);\r\n        //no error, ts compiler knows that I can call protectedMethod\r\n    }\r\n\r\n    public publicMethod2(t: TestBase<T>): void\r\n    {\r\n        t. /* <---- press Ctrl+Space here, it's OK, it shows me everithing */\r\n    }\r\n}\r\n```\r\n\r\n**Expected behavior:**\r\nTo show protectedMethod when I press Ctrl+Space\r\n\r\n**Actual behavior:**\r\nDon't show protectedMethod when I press Ctrl+Space\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/19192/comments",
    "author": "lmcarreiro",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2017-10-16T17:11:08Z",
        "body": "PRs welcomed."
      },
      {
        "user": "mhegazy",
        "created_at": "2017-11-09T01:44:32Z",
        "body": "thanks @Kingwl !"
      }
    ]
  },
  {
    "number": 19037,
    "title": "Formatter: Indent of newline after statement should be based on last statement, not last line",
    "created_at": "2017-10-09T16:01:18Z",
    "closed_at": "2024-03-08T22:14:57Z",
    "labels": [
      "Bug",
      "Help Wanted",
      "Domain: Formatter"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/19037",
    "body": "**TypeScript Version:**  nightly (2.6.0-dev.20171007)\r\n\r\nThis appears to be a problem in VSCode but not in Visual Studio.\r\n\r\n**Code**\r\n\r\n```ts\r\nMath.max(\r\n    1,\r\n    2,\r\n    3);\r\n```\r\n\r\n**Expected behavior:**\r\n\r\nPressing 'enter' should take me back to the indentation of `Math.max`, which is the start of the previous statement.\r\n\r\n**Actual behavior:**\r\n\r\nTakes me to the indentation of `3`, which is the start of the previous line.",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/19037/comments",
    "author": "ghost",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2017-10-09T18:03:21Z",
        "body": "This seems to be specific to VSCode scenario. I do not see the same behavior in VS."
      }
    ]
  },
  {
    "number": 18893,
    "title": "Hard-to-diagnose \"Cannot find global type 'Symbol'.\" error",
    "created_at": "2017-10-02T20:55:45Z",
    "closed_at": "2022-12-01T22:32:50Z",
    "labels": [
      "Bug",
      "Help Wanted",
      "Good First Issue",
      "Domain: Error Messages"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/18893",
    "body": "**TypeScript Version:**  nightly (2.6.0-dev.20170930)\r\n\r\n**Code**\r\n\r\n```ts\r\ninterface A {\r\n    m(x: string): void;\r\n}\r\n\r\ndeclare class B {\r\n    m(x: string | symbol): void;\r\n}\r\n\r\ndeclare class C extends B implements A {}\r\n```\r\n\r\nCompile with `--lib es5 --target es6`.\r\n\r\n**Expected behavior:**\r\n\r\nA useful error message, containing a location of the error, and a suggestion of how to fix it.\r\nAlternately, no error, since this code is correct.\r\n\r\n**Actual behavior:**\r\n\r\n```\r\nerror TS2318: Cannot find global type 'Symbol'.\r\n```\r\n\r\nIt looks like this will be hard to fix because the error happens in type comparison; but this error was very difficult to track down so it would be nice to get an error location.",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/18893/comments",
    "author": "ghost",
    "comments": [
      {
        "user": "begincalendar",
        "created_at": "2017-10-04T04:09:17Z",
        "body": "I believe this is the stacktrace for the issue:\r\n```\r\nresolveNameHelper (checker.ts:1161)\r\nresolveName (checker.ts:890)\r\ngetGlobalSymbol (checker.ts:7100)\r\ngetGlobalTypeSymbol (checker.ts:7095)\r\ngetGlobalType (checker.ts:7106)\r\ngetGlobalESSymbolType (checker.ts:7123)\r\ngetApparentType (checker.ts:6085)\r\ngetPropertiesOfType (checker.ts:5922)\r\nisRelatedTo (checker.ts:8968)\r\neachTypeRelatedToType (checker.ts:9192)\r\nisRelatedTo (checker.ts:8998)\r\ncompareSignaturesRelated (checker.ts:8589)\r\nsignatureRelatedTo (checker.ts:9720)\r\nsignaturesRelatedTo (checker.ts:9689)\r\nstructuredTypeRelatedTo (checker.ts:9460)\r\nrecursiveTypeRelatedTo (checker.ts:9300)\r\nisRelatedTo (checker.ts:9025)\r\npropertiesRelatedTo (checker.ts:9559)\r\nstructuredTypeRelatedTo (checker.ts:9458)\r\nrecursiveTypeRelatedTo (checker.ts:9300)\r\nisRelatedTo (checker.ts:9025)\r\ncheckTypeRelatedTo (checker.ts:8853)\r\ncheckTypeAssignableTo (checker.ts:8502)\r\ncheckClassLikeDeclaration (checker.ts:21693)\r\ncheckClassDeclaration (checker.ts:21610)\r\ncheckSourceElement (checker.ts:22750)\r\nforEach (core.ts:186)\r\ncheckSourceFileWorker (checker.ts:22841)\r\ncheckSourceFile (checker.ts:22815)\r\nforEach (core.ts:186)\r\ngetDiagnosticsWorker (checker.ts:22917)\r\ngetDiagnostics (checker.ts:22880)\r\ngetEmitResolver (checker.ts:534)\r\nemitWorker (program.ts:1162)\r\n(anonymous) (program.ts:1115)\r\nrunWithCancellationToken (program.ts:1238)\r\nemit (program.ts:1115)\r\ncompileFiles (harness.ts:1197)\r\n(anonymous) (compilerRunner.ts:116)\r\n```\r\n\r\nI've just started looking at the TypeScript internals so I'm not yet sure how/why that whole path is taken, but I thought I should post the trace as a start (to help anyone else more experienced)."
      },
      {
        "user": "begincalendar",
        "created_at": "2017-10-04T07:19:22Z",
        "body": "It appears as if type checking does not involve location `Node`s and hence I think it would be a lot of work to get an appropriate location into the error message.\r\n\r\nThat then only leaves the possibility of silencing the error.\r\n\r\nIf you take a look at __/src/compiler/checker.ts:6085__:\r\n\r\n```\r\nfunction getApparentType(type: Type): Type {                                     \r\n    const t = type.flags & TypeFlags.TypeVariable ? getBaseConstraintOfType(type) || emptyObjectType : type;\r\n    return t.flags & TypeFlags.Intersection ? getApparentTypeOfIntersectionType(<IntersectionType>t) :\r\n        t.flags & TypeFlags.StringLike ? globalStringType :                      \r\n        t.flags & TypeFlags.NumberLike ? globalNumberType :                      \r\n        t.flags & TypeFlags.BooleanLike ? globalBooleanType :                    \r\n        t.flags & TypeFlags.ESSymbol ? getGlobalESSymbolType(/*reportErrors*/ languageVersion >= ScriptTarget.ES2015) : // <-- Line 6085\r\n        t.flags & TypeFlags.NonPrimitive ? emptyObjectType :                     \r\n        t;                                                                       \r\n}\r\n```\r\n...you can see that the check occurs when the target language is >= ES2015.\r\n\r\nThe only other usage of the `getGlobalESSymbolType` function is at __/src/compiler/checker.ts:8901__:\r\n```\r\nfunction tryElaborateErrorsForPrimitivesAndObjects(source: Type, target: Type) { \r\n    const sourceType = typeToString(source);                                     \r\n    const targetType = typeToString(target);                                     \r\n                                                                                 \r\n    if ((globalStringType === source && stringType === target) ||                \r\n        (globalNumberType === source && numberType === target) ||                \r\n        (globalBooleanType === source && booleanType === target) ||              \r\n        (getGlobalESSymbolType(/*reportErrors*/ false) === source && esSymbolType === target)) { // <-- Line 8901\r\n        reportError(Diagnostics._0_is_a_primitive_but_1_is_a_wrapper_object_Prefer_using_0_when_possible, targetType, sourceType);\r\n    }                                                                            \r\n}\r\n```\r\n...and you can see that the argument for the `reportErrors` param is hard-coded (to be `false`).\r\n\r\nSo I think if we hard-code a `false` value for the call in the `getApparentType` function, it should fix this issue.\r\n\r\nDoing so would result in all usages of the `getGlobalESSymbolType` function to use the same hard-coded value (i.e. `false`) for the `reportErrors` param. So I'm not sure if we also want to remove that param altogether."
      },
      {
        "user": "ghost",
        "created_at": "2017-10-04T14:17:25Z",
        "body": "@sandersn Could you take a look at this? This is deep in the bowels of `isRelatedTo`."
      },
      {
        "user": "mhegazy",
        "created_at": "2017-10-04T17:13:09Z",
        "body": "I thought the suggestion here is to just say something like `Cannot find global type 'Symbol'. consider adding '--lib es2015' to your compilation`.. and if so, the change would be limited to `getGlobalESSymbolType` and `getGlobalType` to have an elaboration passed in to add the note about the lib."
      },
      {
        "user": "sandersn",
        "created_at": "2017-10-04T20:33:39Z",
        "body": "@rbuckton pointed out that the lib-references feature that he's working on will allow node and other packages to cleanly avoid this error by referencing `--lib es6` even when tsconfig specifies `--lib es5`. In the meantime, though, we decided it's best to stop issuing this error entirely since it's so hard to debug when libraries (like node) are the ones causing the error."
      },
      {
        "user": "abuob",
        "created_at": "2022-11-19T09:15:51Z",
        "body": "Currently going through issues with the \"Good first issue\"-label, it seems this one is outdated?\r\nThe code given in the initial description compiles fine with `--lib es5 --target es6`, there is no error anymore?"
      }
    ]
  },
  {
    "number": 18874,
    "title": "Improve Object.{keys,values,entries} static method signatures",
    "created_at": "2017-10-01T07:03:01Z",
    "closed_at": "2017-10-09T22:08:22Z",
    "labels": [
      "Suggestion",
      "Help Wanted",
      "Domain: lib.d.ts"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/18874",
    "body": "**TypeScript Version:**  master\r\n\r\n**Code**\r\n\r\n```diff\r\n-    keys(o: {}): string[];\r\n+    keys(o: any): string[];\r\n-    values<T>(o: { [s: string]: T }): T[];\r\n+    values<T>(o: { [s: string]: T } | { [n: number]: T }): T[];\r\n-    entries<T>(o: { [s: string]: T }): [string, T][];\r\n+    entries<T>(o: { [s: string]: T } | { [n: number]: T }): [string, T][];\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/18874/comments",
    "author": "falsandtru",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2017-10-04T21:42:17Z",
        "body": "`keys(o: any): string[];` allows for `keys(undefined)` and `keys(null)` which are runtime errors."
      },
      {
        "user": "mhegazy",
        "created_at": "2017-10-04T21:42:26Z",
        "body": "the other overloads seem reasonable."
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2017-10-04T21:42:39Z",
        "body": "Do we want `keys(o: object)` instead?"
      },
      {
        "user": "mhegazy",
        "created_at": "2017-10-04T21:45:18Z",
        "body": "`Object.keys(1)` is `[]` ... so not sure if we want to allow that or not."
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2017-10-04T21:50:07Z",
        "body": "The spec *appears* to call that an error\r\n\r\n> 15.2.3.14 Object.keys ( O )\r\n\r\n> When the keys function is called with argument O, the following steps are taken:\r\n\r\n> If the Type(O) is not Object, throw a TypeError exception.\r\n\r\nBut there's no error in Edge or Chrome. Checking with Brian"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2017-10-04T21:56:04Z",
        "body": "Apparently the 5.1 spec says to throw an error but the 6.0 spec specifies an implicit conversion to `object`. So I'd say disallow"
      },
      {
        "user": "falsandtru",
        "created_at": "2017-10-05T03:04:16Z",
        "body": "Do you want this?\r\n\r\n```ts\r\n    keys(o: undefined | null): never;\r\n    keys(o: any): string[];\r\n```"
      },
      {
        "user": "mhegazy",
        "created_at": "2017-10-05T16:58:05Z",
        "body": "> Do you want this?\r\n\r\nNo. this allows things like `var x: string[] = Object.keys(null);` to pass compilation, but fail at runtime."
      },
      {
        "user": "falsandtru",
        "created_at": "2017-10-05T17:07:00Z",
        "body": "I think we have no way to resolve that using current type system."
      },
      {
        "user": "mhegazy",
        "created_at": "2017-10-05T18:33:14Z",
        "body": "> I think we have no way to resolve that using current type system.\r\n\r\nwhy is that? `keys(o: {}): string[]` seems to model the behavior correctly."
      },
      {
        "user": "falsandtru",
        "created_at": "2017-10-06T01:47:47Z",
        "body": "I didn't know that improved behavior of `{}`. Then the changes we need is only `values` and `entries` methods?"
      },
      {
        "user": "falsandtru",
        "created_at": "2017-10-06T08:38:46Z",
        "body": "Fixed my PR."
      }
    ]
  },
  {
    "number": 18867,
    "title": "Print current TypeScript info at top of the TS Server log",
    "created_at": "2017-09-30T16:37:18Z",
    "closed_at": "2018-01-04T23:18:42Z",
    "labels": [
      "Bug",
      "Fixed",
      "Help Wanted"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/18867",
    "body": "**Feature Request**\r\nFor debugging purposes, it would be helpful if the TypeScript server could print some basic metadata at the top of the tsserver.log file.\r\n\r\nSome basics to include:\r\n\r\n* TypeScript Version\r\n* TSServer Path\r\n* TSServer command line arguments",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/18867/comments",
    "author": "mjbvz",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2017-10-02T23:11:45Z",
        "body": "Yes please"
      }
    ]
  },
  {
    "number": 18519,
    "title": "instanceof should error when all constituents of a union are primitives",
    "created_at": "2017-09-16T01:50:06Z",
    "closed_at": "2017-11-28T23:05:07Z",
    "labels": [
      "Bug",
      "Fixed",
      "Help Wanted"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/18519",
    "body": "```ts\r\nfunction foo(x: number | string) {\r\n    if (x instanceof Number) {\r\n        x\r\n    }\r\n}\r\n```\r\n\r\nExpected:\r\n\r\n```\r\nThe left-hand side of an 'instanceof' expression must be of type 'any', an object type or a type parameter\r\n```\r\n\r\nActual:\r\n\r\nNo error, incorrect narrowing behavior (#14426)\r\n\r\n**Edit:** Corrected the example to *actually* be a union.",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/18519/comments",
    "author": "DanielRosenwasser",
    "comments": [
      {
        "user": "ajafff",
        "created_at": "2017-09-16T05:44:59Z",
        "body": "That's not always the expected behavior. When targeting a runtime with `Symbol.hasInstance` this should be allowed:\r\n```ts\r\nclass PrimitiveNumber {\r\n    static [Symbol.hasInstance](x) {\r\n        return typeof x === 'number';\r\n    }\r\n}\r\nconsole.log(123 instanceof PrimitiveNumber); // true\r\n```"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2017-09-16T05:59:41Z",
        "body": "Sure, but\r\n\r\n1. Most people aren't doing that.\r\n2. We already error for `10 instanceof Number`"
      },
      {
        "user": "aluanhaddad",
        "created_at": "2017-09-16T07:54:11Z",
        "body": "Wouldn't an appropriate behavior then be to issue an error unless the value on the right hand side has a `[Symbol.hasInstance]` member taking a parameter of a type to which the type of value on the left hand side is assignable?"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2017-09-16T19:32:14Z",
        "body": "Something like #17360? Ironically, I think I've brought it up with @mhegazy in the past."
      },
      {
        "user": "charlespierce",
        "created_at": "2017-10-10T05:37:47Z",
        "body": "PR #19063 opened to resolve this issue."
      }
    ]
  },
  {
    "number": 18441,
    "title": "Add code fixes for all diagnostics that suggest a correction",
    "created_at": "2017-09-13T17:03:45Z",
    "closed_at": "2018-05-03T22:45:19Z",
    "labels": [
      "Suggestion",
      "Fixed",
      "Help Wanted",
      "Domain: Quick Fixes"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/18441",
    "body": "e.g. TS2663: Cannot find name 'foo'.  Did you mean the instance member 'this.foo'?",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/18441/comments",
    "author": "amcasey",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2018-05-03T22:45:19Z",
        "body": "This should be fixed now."
      }
    ]
  },
  {
    "number": 18435,
    "title": "Convert to ES6 Class Refactoring removes `export` keyword",
    "created_at": "2017-09-13T10:48:57Z",
    "closed_at": "2017-10-10T22:39:59Z",
    "labels": [
      "Bug",
      "Fixed",
      "Help Wanted",
      "Domain: Refactorings"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/18435",
    "body": "**TypeScript Version:**  2.5.2 / nightly (2.6.0-dev.20170913)\r\n\r\nApply the refactoring to the following code:\r\n**Code**\r\n```js\r\nexport function MyClass() {\r\n}\r\nMyClass.prototype.foo = function() {\r\n}\r\n```\r\n\r\n**Expected behavior:**\r\n```js\r\nexport class MyClass {\r\n    constructor() {\r\n    }\r\n    foo() {\r\n    }\r\n}\r\n```\r\n\r\n**Actual behavior:**\r\n```js\r\nclass MyClass {\r\n    constructor() {\r\n    }\r\n    foo() {\r\n    }\r\n}\r\n```\r\n\r\nTested with both 2.5.2 and the latest nightly (2.6.0-dev.20170913).",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/18435/comments",
    "author": "hbenl",
    "comments": [
      {
        "user": "amcasey",
        "created_at": "2017-09-19T01:38:40Z",
        "body": "Copying `export` is straightforward, but handling other modifiers (`default`?) and member modifiers (e.g. could `foo` be `async`) will require further thought."
      },
      {
        "user": "amcasey",
        "created_at": "2017-09-19T23:10:19Z",
        "body": "Fixing exactly this problem is very easy and I'd be happy to create a PR if will unblock someone.  Making the entire refactoring modifier-aware, on the other hand, has relatively low ROI."
      },
      {
        "user": "charlespierce",
        "created_at": "2017-10-10T17:31:42Z",
        "body": "PR #19070 Opened to resolve this issue."
      }
    ]
  },
  {
    "number": 18420,
    "title": "Leading underscore doesn't disable error on unused type parameter",
    "created_at": "2017-09-12T21:23:35Z",
    "closed_at": "2017-09-19T23:57:27Z",
    "labels": [
      "Bug",
      "Fixed",
      "Help Wanted"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/18420",
    "body": "From  #18370\r\n\r\nThis reports an unused local error on `_T`, which we shouldn't do because it has a leading underscore\r\n```ts\r\ntype Foo<_T> = { };\r\n```",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/18420/comments",
    "author": "RyanCavanaugh",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2017-09-12T22:33:59Z",
        "body": "PRs welcomed"
      }
    ]
  },
  {
    "number": 18268,
    "title": "Extract function doesn't work for nested exponentiation operator",
    "created_at": "2017-09-06T07:27:10Z",
    "closed_at": "2017-09-29T20:10:29Z",
    "labels": [
      "Bug",
      "Fixed",
      "Help Wanted",
      "Effort: Moderate",
      "Domain: Refactorings"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/18268",
    "body": "```ts\r\n1 ** 2 ** 3 ** 4\r\n```\r\n\r\nTry to extract out `2 ** 3`.\r\n\r\n**Expected**: Option to extract out `2 ** 3`\r\n**Actual**: Nothing.",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/18268/comments",
    "author": "DanielRosenwasser",
    "comments": [
      {
        "user": "amcasey",
        "created_at": "2017-09-06T19:29:40Z",
        "body": "Is it right associative?  I think the binary operator compensation code assumes all operators are left associative, so it might be blowing up.  Either way, I don't believe you could ever extract `2 ** 3`.  You'd either get `1 ** 2 ** 3` or `2 ** 3 ** 4`, depending on the associativity of the operator."
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2017-09-07T03:36:07Z",
        "body": "Yes, it's right associative. I realized the bug existed from reading the code before I actually stumbled onto it, which is why I marked this as `Future`. 😄 \r\n\r\nAlso, good point on extracting out from the middle. "
      },
      {
        "user": "amcasey",
        "created_at": "2017-09-07T17:21:46Z",
        "body": "I think I reported the same bug with assignment.  I can't remember what happened with that.  @RyanCavanaugh ?"
      }
    ]
  },
  {
    "number": 17783,
    "title": "Transpile of `export enum` should use `export let`?",
    "created_at": "2017-08-14T18:13:02Z",
    "closed_at": "2024-03-04T23:43:51Z",
    "labels": [
      "Bug",
      "Help Wanted"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/17783",
    "body": "**TypeScript Version:** nightly (2.5.0-dev.20170808)\r\n\r\nTrying to get TypeScript and Babel emits to match.\r\n(Possibly related: #15403)\r\n\r\n**Code**\r\n\r\n```ts\r\nvar E;\r\n(function (E) {\r\n})(E || (E = {}));\r\n```\r\n\r\n**Expected behavior:**\r\n\r\n```\r\nexport let E;\r\n\r\n(function (E) {\r\n  E[E[\"A\"] = 0] = \"A\";\r\n  E[E[\"B\"] = 1] = \"B\";\r\n})(E || (E = {}));\r\n```\r\n\r\n**Actual behavior:**\r\n\r\nUses `export var` instead of `export let`.",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/17783/comments",
    "author": "ghost",
    "comments": [
      {
        "user": "ggajos",
        "created_at": "2020-07-06T06:32:25Z",
        "body": "@andy-ms @RyanCavanaugh \r\nSince #15423 is about keeping `var` for global scripts to avoid redeclaration issue. Is this issue still valid?"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2020-07-08T20:27:32Z",
        "body": "Good catch; I think this now has the desired behavior?"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2024-03-04T23:43:51Z",
        "body": "This doesn't seem to have affected more than one or two people max."
      }
    ]
  },
  {
    "number": 17757,
    "title": "Unions and intersections of type predicates produce wrong type",
    "created_at": "2017-08-12T05:40:21Z",
    "closed_at": "2024-03-05T00:39:08Z",
    "labels": [
      "Bug",
      "Help Wanted"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/17757",
    "body": "**TypeScript Version:**  2.5.0-dev.20170803\r\n\r\n**Code**\r\n```ts\r\ntype Foo = typeof ts.isDoStatement | typeof ts.isWhileStatement;\r\n```\r\n\r\n**Expected behavior:**\r\nResulting type should be `(node: ts.Node) => node is (ts.DoStatement | ts.WhileStatement)`\r\n\r\n**Actual behavior:**\r\nResulting type is `(node: ts.Node) => node is ts.DoStatement`\r\n\r\nIt seems to just take the first one.",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/17757/comments",
    "author": "SamPruden",
    "comments": [
      {
        "user": "aluanhaddad",
        "created_at": "2017-08-12T13:09:32Z",
        "body": "It appears to just grab the first type predicate and ignore the rest.\r\n\r\nHere is a self-contained repro (2.5.0-dev.20170808)\r\n```ts\r\ntype IsStringOrNumber = ((x: any) => x is number) | ((x: any) => x is string);\r\n\r\ndeclare const x: any;\r\n\r\nif ((((x: any) => true) as IsStringOrNumber)(x)) {\r\n    x.toFixed();\r\n}\r\n```\r\nIntersecting type  predicates seems to have the same result, only the first signature is considered.\r\n```ts\r\ntype IsStringAndNumber = ((x: any) => x is number) & ((x: any) => x is string);\r\n```"
      },
      {
        "user": "SamPruden",
        "created_at": "2017-08-12T17:48:34Z",
        "body": "> type predicate \r\n\r\nI _knew_ using \"type guards\" like that wasn't quite right. 😂"
      },
      {
        "user": "aluanhaddad",
        "created_at": "2017-08-13T01:47:07Z",
        "body": "Being able to compose these functions would be highly useful.\r\n\r\nImagine a rather heterogeneous array elements of elements in a scenario such as\r\n```ts\r\nimport moment from 'moment';\r\n\r\ninterface Partial {\r\n  name?: string;\r\n  id?: number;\r\n  dob?: moment.Moment\r\n}\r\n\r\ndeclare const partials: Partial[];\r\n\r\ntype HasName = (x: Partial) => x is {name: string};\r\ntype HasDob = (x: Partial) => x is {dob: moment.Moment};\r\ntype HasNameAndDob = HasName & HasDob;\r\n\r\nconst hasNameAndDob: HasNameAndDob = ({name, dob}) => name && dob;\r\n\r\nconst withNamesAndDobs = mayHaveProps.filter(hasNameAndDob);\r\n```\r\nThere is some boilerplate in the example, but throw in a `compose` helper and it would make for some very nice patterns."
      },
      {
        "user": "SamPruden",
        "created_at": "2017-08-13T03:32:39Z",
        "body": "I was thinking of this more as a bug report than a feature request, but if we're doing demonstrations of value, this was my scenario.\r\n\r\nThe typescript compiler has lots of `Node` types differentiated by a `kind` enum property, but no discriminated union type exists to allow nicely switching on kinds. The compiler itself does lots of ugly and dangerous asserting to get around this. There are, however, `ts.isWhileStatement(node: Node)` style functions for almost all nodes.\r\n\r\nI was trying to put together something like this:\r\n\r\n```ts\r\nfunction isAnyOf<T extends ts.Node>(node: ts.Node, ...preds: Array<(n: ts.Node) => n is T>): node is T {\r\n    return preds.some(p => p(node));\r\n}\r\n\r\nif (isAnyOf(node, ts.isWhileStatement, ts.isIfStatement)) {\r\n    // node should have type ts.WhileStatement | ts.IfStatement\r\n    // actually just has type ts.WhileStatement\r\n}\r\n```\r\n\r\nBut with the current behaviour/bug, `T` just takes the type of whatever the first predicate is and completely ignores the others."
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2017-08-16T21:38:54Z",
        "body": "Probably an easy fix if someone wants to try"
      },
      {
        "user": "charlespierce",
        "created_at": "2017-10-06T07:48:42Z",
        "body": "@RyanCavanaugh I'm interested in tackling this issue, can you point me towards what changes will be needed? I was able to find (and fix) an issue where Type Predicates weren't being correctly handled by `getContextualSignature` in `checker.ts`, however that didn't seem to change the behavior at all. It seems that `getContextualSignature` isn't actually used inside of `resolveCall` so the Type Predicate still isn't being correctly determined."
      },
      {
        "user": "ghost",
        "created_at": "2017-10-06T15:42:27Z",
        "body": "@charlespierce By coincidence I made a commit just now fixing the union half in #17600. You could look at the intersection part once that's in; it's marked with `// TODO: GH#17757`."
      },
      {
        "user": "charlespierce",
        "created_at": "2017-10-06T16:15:12Z",
        "body": "@andy-ms Thanks, I'll take a look at the intersection part. I actually had just figured out what I was missing, but I'm glad to see I came up with essentially the same solution as you for the union signatures."
      },
      {
        "user": "jack-williams",
        "created_at": "2019-02-10T16:55:32Z",
        "body": "I think this issue can be closed. The union case correctly works by selecting both predicate types:\r\n```ts\r\ntype IsStringOrNumber = ((x: any) => x is number) | ((x: any) => x is string);\r\n\r\ndeclare const x: any;\r\n\r\nif ((((x: any) => true) as IsStringOrNumber)(x)) {\r\n    x.toFixed(); // x has type number | string\r\n}\r\n```\r\n\r\nThe intersection case still selects the first overload, but this is a general problem with intersections of signatures---it is not a particular issue with type predicates."
      }
    ]
  },
  {
    "number": 17529,
    "title": "Incorrect missing property error message for (A | B) & C.",
    "created_at": "2017-07-31T13:21:27Z",
    "closed_at": "2019-03-18T16:37:03Z",
    "labels": [
      "Bug",
      "Help Wanted",
      "Effort: Moderate",
      "Domain: Error Messages"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/17529",
    "body": "**TypeScript Version:**  2.4.0\r\n\r\n**Code**\r\n```ts\r\ntype A =\r\n    {\r\n        foo: number;\r\n    } |\r\n    {\r\n        bar: string;\r\n    };\r\n\r\ntype B = A & {\r\n    baz: boolean;\r\n};\r\n\r\nconst val: B = { foo: 42 };\r\n```\r\n\r\n**Expected behavior:**\r\nCompiler correctly reports that `baz` property is missing.\r\n\r\n**Actual behavior:**\r\nCompiler incorrectly reports the following:\r\n`Property 'bar' is missing in type '{ foo: number; }'`\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/17529/comments",
    "author": "kujon",
    "comments": [
      {
        "user": "kujon",
        "created_at": "2017-07-31T13:24:34Z",
        "body": "It can get even more confusing than this:\r\n\r\n```ts\r\ntype A =\r\n    {\r\n        foo: number;\r\n    } |\r\n    {\r\n        bar: string;\r\n    };\r\n\r\ntype B = A & {\r\n    baz: boolean;\r\n};\r\n\r\nconst val: B = { foo: 42, baz: 42 };\r\n```\r\n\r\nThe example above still gives: `Property 'bar' is missing in type '{ foo: number; baz: 42; }'.`, whereas the correct error should mention type of number being incompatible with type of boolean."
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2017-07-31T15:58:06Z",
        "body": "@sandersn has worked on something mildly similar with discriminated unions. I think it'd be great if we could improve error messages here as well though."
      },
      {
        "user": "njgraf512",
        "created_at": "2018-06-10T23:13:49Z",
        "body": "Another seemingly related example that I'm currently struggling with:\r\n\r\n```ts\r\ntype Foo = {\r\n  foo: string,\r\n}\r\ntype FooPlus = {\r\n  fooPlus: Foo\r\n}\r\n\r\ntype Bar = {\r\n  bar: string,\r\n}\r\ntype BarPlus = {\r\n  barPlus: Bar\r\n}\r\n\r\ntype Baz = {\r\n  baz: string,\r\n}\r\ntype BazPlus = {\r\n  bazPlus: Baz,\r\n}\r\n\r\ntype FooPlusBarPlusUnion = FooPlus | BarPlus;\r\n\r\ntype MyType = {\r\n  myType: string\r\n} & FooPlusBarPlusUnion & BazPlus\r\n\r\nconst myType: MyType = {\r\n  myType: 'myType',\r\n  fooPlus: {\r\n    foo: 'foo',\r\n  },\r\n  bazPlus: {\r\n    baz: 'baz',\r\n  },\r\n}\r\n```\r\n\r\nReturning error: `Property 'barPlus' is missing in type '{ myType: string; fooPlus: { foo: string; }; bazPlus: { baz: string; }; }'.`\r\n\r\nI would expect this not to error.  Should I need to use a discriminated union here? If so, could someone explain why? Adding a discriminant key to `FooPlus` and `BarPlus` does not seem to help anyway, unfortunately.\r\n\r\n<hr>\r\n\r\nAll of the above is in pursuit of the following, so if there's another way to get there (or another filed ticket to track), I'd definitely appreciate the help!\r\n\r\n```ts\r\ntype MyUnion = {\r\n  fooPlus?: FooPlus,\r\n  barPlus?: BarPlus,\r\n  bazPlus?: BazPlus,\r\n  required: string,\r\n}\r\n```\r\n\r\n`type MyUnion` is close to what I'm after, but what I really want is for `MyUnion` to have exactly  1 of the 3 optional keys it contains above plus the `required` key. This is why I was working with the intersection of union types shown above."
      },
      {
        "user": "jack-williams",
        "created_at": "2019-03-15T22:08:09Z",
        "body": "This is the error message for the original example:\r\n```\r\nType '{ foo: number; }' is not assignable to type 'B'.\r\n  Type '{ foo: number; }' is not assignable to type '{ foo: number; } & { baz: boolean; }'.\r\n    Property 'baz' is missing in type '{ foo: number; }' but required in type '{ baz: boolean; }'. [2322]\r\n```\r\nSeems like this is fixed?"
      }
    ]
  },
  {
    "number": 17494,
    "title": "Module with \"Object\" export has bad ES5 emit",
    "created_at": "2017-07-28T21:32:07Z",
    "closed_at": "2018-05-25T22:53:44Z",
    "labels": [
      "Bug",
      "Fixed",
      "Help Wanted"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/17494",
    "body": "**TypeScript Version:** 2.2 to current\r\n\r\n**Code**\r\nTS file:\r\n`export class Object {}`\r\ntsconfig.json:\r\n`{\"compilerOptions\": {\"target\": \"es5\"}}`\r\n\r\n**Expected behavior:**\r\nThe module should be able to initialize like it did in TypeScript 2.1.\r\n\r\n**Actual behavior:**\r\nModule fails to initialize; `TypeError: Object is undefined`.\r\n\r\nThe emitted code is\r\n```\r\n\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar Object = (function () {\r\n    function Object() {\r\n    }\r\n    return Object;\r\n}());\r\nexports.Object = Object;\r\n```\r\nClearly `Object.defineProperty` is intended to reference the global `Object`, but it gets an uninitialized local variable instead.",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/17494/comments",
    "author": "jeffreymorlan",
    "comments": [
      {
        "user": "DanielRosenwasser",
        "created_at": "2017-07-28T21:40:39Z",
        "body": "As a temporary workaround, you can name your class `_Object` and write `export { _Object as Object }`"
      },
      {
        "user": "rbuckton",
        "created_at": "2017-07-28T22:11:17Z",
        "body": "This should be an error, similar to the error we issue if you declare your own `_this`."
      },
      {
        "user": "mhegazy",
        "created_at": "2017-10-09T20:18:09Z",
        "body": "PRs welcomed."
      }
    ]
  },
  {
    "number": 17113,
    "title": "Arrow function is not compatible with ordinary one",
    "created_at": "2017-07-12T03:16:45Z",
    "closed_at": "2018-08-01T16:33:13Z",
    "labels": [
      "Suggestion",
      "Help Wanted",
      "Committed",
      "Good First Issue"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/17113",
    "body": "**TypeScript Version:**  2.4.1\r\n\r\n**Code**\r\n\r\n```ts\r\nclass Component {\r\n  render(): boolean {\r\n    return false;\r\n  }\r\n}\r\nclass App extends Component {\r\n  render = () => false;\r\n}\r\n```\r\n\r\n**Expected behavior:**\r\n\r\nCompiles correctly.\r\n\r\n**Actual behavior:**\r\n\r\nThe compiler reports an error:\r\n\r\n```\r\ntest.ts(7,3): error TS2424: Class 'Component' defines instance member function 'render', but extended class 'App' defines it as instance member property.\r\n```\r\n\r\nI know this may be designed, a feature rather than a bug, but such behavior is quite weird.",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/17113/comments",
    "author": "xfoxfu",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2017-07-12T06:43:36Z",
        "body": "There are good reasons not to allow the reverse case, but I can't remember why we disallow this. I think it's come up before but will take it up as a suggestion"
      },
      {
        "user": "xtuc",
        "created_at": "2017-07-12T06:50:36Z",
        "body": "An arrow fonction has no prototype or even a name. This is a good reason why they shouldn't have the same type. "
      },
      {
        "user": "kitsonk",
        "created_at": "2017-07-12T07:31:06Z",
        "body": "Also, in the base class, the method is part of the classes prototype.  You are overwriting it with a property initialiser that gets desugared in the constructor and isn't actually part of the prototype chain.  You end up with differences in own properties at run time, so they are effectively, subtly different, though the shape is the same.  At runtime, the shape of the `Class.prototype` is actually different, though I believe TypeScript includes the shape of properties in the type of the prototype, even though they aren't really there.\r\n\r\nI thought you might also get into trouble with `super` but actually that seems fine."
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2017-10-10T18:07:40Z",
        "body": "Easy PR if someone wants to submit one."
      },
      {
        "user": "Kingwl",
        "created_at": "2017-10-11T01:55:53Z",
        "body": "I would like to work on this one.😅"
      },
      {
        "user": "Kingwl",
        "created_at": "2017-10-12T03:06:50Z",
        "body": "@RyanCavanaugh @kitsonk  i have some question   \r\n```\r\nclass Component {\r\n  render(): boolean {\r\n    return false;\r\n  }\r\n}\r\nclass App extends Component {\r\n  get render () {\r\n    return () => true\r\n  }\r\n}\r\n```\r\n1. if i can override method with property, could i override method with accessor?\r\n2. could i override property defined in base with method?"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2017-10-30T19:22:18Z",
        "body": "@Kingwl \r\n1. Not sure - does it work at runtime?\r\n2. No"
      },
      {
        "user": "Kingwl",
        "created_at": "2017-11-16T07:00:16Z",
        "body": "@RyanCavanaugh   \r\n1. yes  "
      },
      {
        "user": "cshaa",
        "created_at": "2018-03-08T19:04:04Z",
        "body": "@Kingwl\r\nI don't think it makes sense to “override” a method – which in general can have any signature – with an accessor, which can be thought of as a group of methods with two overloads, one `get: () => T` and one `set: (T) => void`.\r\n\r\nHowever overriding a method with an equivalent arrow function is an useful shorthand and seems like a good idea to me. I think the right approach would be to convert the arrow function to the “full form” and treat it as a normal method (i.e. add it to the prototype, let it have a name, …).\r\n\r\nThe only problem I can think of is that we could decide to implement a C#-like syntax for method shorthands. The new syntax would be preferable to this one and we would have to deprecate it.\r\n\r\nHere's a comparsion of the current and possible syntaxes:\r\n\r\n```typescript\r\n// Current full-body syntax\r\nclass A {\r\n    function foo() { return 42; }\r\n}\r\n\r\n// Current lambda syntax\r\nclass B {\r\n    foo = () => 42;\r\n}\r\n\r\n// @coderfox's Arrow extension proposal\r\n// compiles to the full-body function\r\nclass C extends A {\r\n    foo = () => 1/0;\r\n}\r\n\r\n// C#-like expression-bodied method\r\n// compiles to the same code as A\r\n// is more elegant and clearer than B\r\nclass D {\r\n    foo() => 42;\r\n}\r\n\r\n// Extending with an exp.-bodied method\r\n// no problem, uncontroversial\r\n// works automatically as long as D works\r\nclass E extends A {\r\n    foo() => 1/0;\r\n}\r\n```\r\n\r\n@RyanCavanaugh @xtuc @kitsonk What are your opinions on this? Is the possibility of implementing expression-bodied functions enough to pass over @coderfox's syntax?"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2018-03-08T19:14:38Z",
        "body": "@m93a Class properties and arrow functions are both TC39-controlled entities now; proposals about new syntax that combine the two belong on ES Discuss or other forums."
      },
      {
        "user": "BlueSialia",
        "created_at": "2018-05-17T18:02:58Z",
        "body": "Overriding a method (instance member function) with an arrow function (instance member property)... Will the context, `this`, be different depending on what the actual object is?\r\n\r\nAlso, arrow functions can't be called with `super.foo()`. In the example of @coderfox, what would happen if I extend the class App and execute `super.render()`?"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2018-07-16T04:02:13Z",
        "body": "I have still not seen an overriding method that needed to be written that way. You end up with something less efficient by doing so. I think that might've been the original motivation."
      },
      {
        "user": "denis-sokolov",
        "created_at": "2018-08-01T14:42:22Z",
        "body": "This error TS2424 happens for me with TypeScript 2.9.2, but not with TypeScript 3.0.1."
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2018-08-01T16:33:13Z",
        "body": "Can't find the PR for this but it does appear to have been fixed."
      },
      {
        "user": "ackvf",
        "created_at": "2019-10-11T13:31:19Z",
        "body": "I get this error now with `3.7.0-dev.20191011`.\r\nNot getting this error with `3.6.2`.\r\n\r\nDid something change?"
      },
      {
        "user": "anuja8275",
        "created_at": "2020-06-11T09:17:42Z",
        "body": "> **TypeScript Version:** 2.4.1\r\n> \r\n> **Code**\r\n> \r\n> ```ts\r\n> class Component {\r\n>   render(): boolean {\r\n>     return false;\r\n>   }\r\n> }\r\n> class App extends Component {\r\n>   render = () => false;\r\n> }\r\n> ```\r\n> \r\n> **Expected behavior:**\r\n> \r\n> Compiles correctly.\r\n> \r\n> **Actual behavior:**\r\n> \r\n> The compiler reports an error:\r\n> \r\n> ```\r\n> test.ts(7,3): error TS2424: Class 'Component' defines instance member function 'render', but extended class 'App' defines it as instance member property.\r\n> ```\r\n> \r\n> I know this may be designed, a feature rather than a bug, but such behavior is quite weird.\r\n\r\nDo we have solution for this m also stuck in such issue"
      }
    ]
  },
  {
    "number": 16941,
    "title": "Module \"none\" not suggested when doing tsc --init",
    "created_at": "2017-07-05T08:24:34Z",
    "closed_at": "2017-07-10T23:54:55Z",
    "labels": [
      "Bug",
      "Help Wanted",
      "Good First Issue"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/16941",
    "body": "As per title\r\n\r\nThe tsconfig generated by tsc --init doesn't suggest \"none\" as an option for module.\r\n\r\nVersion 2.4.1",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/16941/comments",
    "author": "massimocode",
    "comments": [
      {
        "user": "DanielRosenwasser",
        "created_at": "2017-07-06T07:32:54Z",
        "body": "Just realized that this pertains to the comment placed in the tsconfig.json, and the request isn't that `tsc` should warn users to use `none`."
      }
    ]
  },
  {
    "number": 16765,
    "title": "esnext features not transpiled within method declarations in object literals with spread elements",
    "created_at": "2017-06-27T13:40:23Z",
    "closed_at": "2017-08-24T00:26:32Z",
    "labels": [
      "Bug",
      "Fixed",
      "Help Wanted"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/16765",
    "body": "**TypeScript Version:**  2.4.0\r\n\r\ncompilerOptions.target = ES5\r\n\r\n**Code**\r\n\r\n```ts\r\nconst obj = {};\r\nconst a = {\r\n    ...obj,\r\n    prop() {\r\n        return {\r\n            ...obj,\r\n            metadata: 213\r\n        }\r\n    }\r\n};\r\n```\r\n\r\n**Expected behavior:**\r\n\r\nIt compiles and transpiles the object spread operator to a call to `Object.assign`.\r\n\r\n**Actual behavior:**\r\n\r\nThe object spread operator is not transpiled but simply kept. This can lead to the following error:\r\n\r\n```\r\n TypeError: Cannot read property 'kind' of undefined\r\n    at visitObjectLiteralExpression (C:\\_myplace\\next\\graphql-proxy\\node_modules\\typescript\\lib\\typescript.js:56775:34)\r\n    at visitJavaScript (C:\\_myplace\\next\\graphql-proxy\\node_modules\\typescript\\lib\\typescript.js:55245:28)\r\n    at visitor (C:\\_myplace\\next\\graphql-proxy\\node_modules\\typescript\\lib\\typescript.js:55182:24)\r\n    at visitNode (C:\\_myplace\\next\\graphql-proxy\\node_modules\\typescript\\lib\\typescript.js:49197:23)\r\n    at Object.visitEachChild (C:\\_myplace\\next\\graphql-proxy\\node_modules\\typescript\\lib\\typescript.js:49479:46)\r\n    at visitReturnStatement (C:\\_myplace\\next\\graphql-proxy\\node_modules\\typescript\\lib\\typescript.js:55345:23)\r\n    at visitJavaScript (C:\\_myplace\\next\\graphql-proxy\\node_modules\\typescript\\lib\\typescript.js:55293:28)\r\n    at visitor (C:\\_myplace\\next\\graphql-proxy\\node_modules\\typescript\\lib\\typescript.js:55182:24)\r\n    at Object.visitNodes (C:\\_myplace\\next\\graphql-proxy\\node_modules\\typescript\\lib\\typescript.js:49248:48)\r\n    at transformFunctionBody (C:\\_myplace\\next\\graphql-proxy\\node_modules\\typescript\\lib\\typescript.js:56282:44)\r\n```\r\n\r\nProblem source:\r\n\r\nThe esnext transformer cuts off at method declarations within object literals that have an spread element, thus it never sees the inner object literal node.",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/16765/comments",
    "author": "Yogu",
    "comments": [
      {
        "user": "DanielRosenwasser",
        "created_at": "2017-08-17T06:55:35Z",
        "body": "I currently can't repro this in `master`, but the PR should still be taken for the regression test."
      }
    ]
  },
  {
    "number": 16482,
    "title": "No tests for jsconfig.json",
    "created_at": "2017-06-13T15:03:38Z",
    "closed_at": "2019-06-20T22:49:37Z",
    "labels": [
      "Help Wanted",
      "Infrastructure"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/16482",
    "body": "The string `jsconfig` does not occur in any tests.",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/16482/comments",
    "author": "ghost",
    "comments": [
      {
        "user": "DanielRosenwasser",
        "created_at": "2017-06-19T19:33:20Z",
        "body": "Feel free to triage this next time around. 😉 "
      },
      {
        "user": "weswigham",
        "created_at": "2019-06-20T22:49:37Z",
        "body": "Well. we could probably still use more, but we have 4 tests that use `jsconfig.json`s nowadays (all `fourslash`-based), all testing some jsconfig-specific scenarios, so generally good jsconfig-specific coverage. I'm going to close this issue unless someone has some specific tests they want written ❤️ "
      }
    ]
  },
  {
    "number": 16129,
    "title": "Add support for diff3-style git merge markers",
    "created_at": "2017-05-29T12:15:32Z",
    "closed_at": "2017-05-30T18:27:22Z",
    "labels": [
      "Bug",
      "Fixed",
      "Help Wanted"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/16129",
    "body": "**TypeScript Version:** (2.4.0-dev.20170528)\r\n\r\n**Code**\r\nWhen merging files with conflicting changes, git puts both changes together with conflicts markers that are correctly supported by TypeScript (markers emit `TS1185` errors and only the first block is used, the other one is treated as a comment):\r\n```ts\r\nclass C {\r\n<<<<<<< HEAD\r\n   v = 1;\r\n=======\r\n   v = 2;\r\n>>>>>>> Branch - a\r\n}\r\n```\r\nUnfortunately, in many cases it is not sufficient to have just both changes to successfully resolve the conflict. Git also supports `diff3` style (`merge.conflictStyle = diff3`) that shows common ancestors block in addition to both conflicting changes, it is thus superset of the default algorithm:\r\n```ts\r\nclass C {\r\n<<<<<<< HEAD\r\n   v = 1;\r\n||||||| merged common ancestors\r\n   v = 3;\r\n=======\r\n   v = 2;\r\n>>>>>>> Branch - a\r\n}\r\n```\r\n\r\n**Expected behavior:**\r\nI'd expect the common ancestors token `|||||||` be also recognised as merge token `TS1185` and content of this block be treated as a comment.\r\n```livescript\r\ntest.ts(2,1): error TS1185: Merge conflict marker encountered.\r\ntest.ts(4,1): error TS1185: Merge conflict marker encountered.\r\ntest.ts(6,1): error TS1185: Merge conflict marker encountered.\r\ntest.ts(8,1): error TS1185: Merge conflict marker encountered.\r\n```\r\n```javascript\r\nvar C = (function () {\r\n    function C() {\r\n        this.v = 1;\r\n    }\r\n    return C;\r\n}());\r\n```\r\n\r\n**Actual behavior:**\r\nCurrently it parses the `|||||||` token as three `||` and one `|`, emits several errors that are unrelated to the root cause (git merge) and the javascript output is wrong.\r\n```livescript\r\ntest.ts(2,1): error TS1185: Merge conflict marker encountered.\r\ntest.ts(4,1): error TS1068: Unexpected token. A constructor, method, accessor, or property was expected.\r\ntest.ts(4,3): error TS1109: Expression expected.\r\ntest.ts(4,5): error TS1109: Expression expected.\r\ntest.ts(4,7): error TS1109: Expression expected.\r\ntest.ts(4,16): error TS1005: ';' expected.\r\ntest.ts(4,23): error TS1005: ';' expected.\r\ntest.ts(6,1): error TS1185: Merge conflict marker encountered.\r\ntest.ts(8,1): error TS1185: Merge conflict marker encountered.\r\ntest.ts(9,1): error TS1128: Declaration or statement expected.\r\n```\r\n```javascript\r\nvar C = (function () {\r\n    function C() {\r\n        this.v = 1;\r\n    }\r\n    return C;\r\n}());\r\n    ||  ||  ||  | merged;\r\ncommon;\r\nancestors;\r\nv = 3;\r\n```\r\n**Fix:**\r\nI've already made a fix while trying to resolve this for me in 1ccbaab and added tests in 64a754c.",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/16129/comments",
    "author": "katemihalikova",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2017-05-30T04:55:41Z",
        "body": "Sounds like a good idea. That commit you have looks basically ready (probably undo the `ch` rename just to minimize changed lines), care to send a PR?"
      },
      {
        "user": "katemihalikova",
        "created_at": "2017-05-30T05:56:15Z",
        "body": "Sure, will send in a moment. Thanks!"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2017-05-30T08:20:06Z",
        "body": "@CyrusNajmabadi in case you're interested in this too."
      },
      {
        "user": "CyrusNajmabadi",
        "created_at": "2017-05-31T18:29:31Z",
        "body": "Thanks for letting me know.  We'll make a similar change to Roslyn if we hear any feedback about this."
      }
    ]
  },
  {
    "number": 16043,
    "title": "Incorrect formatting of expression lists",
    "created_at": "2017-05-23T20:36:59Z",
    "closed_at": "2024-03-08T22:16:26Z",
    "labels": [
      "Bug",
      "Help Wanted",
      "Domain: Formatter"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/16043",
    "body": "**TypeScript Version:**  2.3.2\r\n\r\n**Code**\r\nFormat the following code snippet using VS Code or typescript-formatter:\r\n```js\r\nfunc({\r\na: 1,\r\n}, {\r\nb: {},\r\n});\r\n```\r\n\r\n**Expected behavior:**\r\n```js\r\nfunc({\r\n    a: 1,\r\n}, {\r\n    b: {},\r\n});\r\n```\r\n**Actual behavior:**\r\n```js\r\nfunc({\r\n    a: 1,\r\n}, {\r\n        b: {},\r\n    });\r\n```\r\nAfter that, source code doesn't pass ESLint checks.",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/16043/comments",
    "author": "igelbox",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2024-03-08T22:16:26Z",
        "body": "Formats as requested now"
      }
    ]
  },
  {
    "number": 15978,
    "title": "`@lib: ES6` on fourslash test case breaks tests",
    "created_at": "2017-05-21T10:25:40Z",
    "closed_at": "2023-07-08T04:15:12Z",
    "labels": [
      "Bug",
      "Help Wanted"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/15978",
    "body": "**TypeScript Version:** master\r\n\r\n**Repro:**\r\n\r\n1. Insert `// @lib: ES6` on `test/fourslash/commentsFunctionExpression.ts`\r\n2. Run `jake runtests t=commentsFunctionExpression`\r\n\r\n**Expected behavior:**\r\n\r\nThe test should run well\r\n\r\n**Actual behavior:**\r\n\r\nNumbers unexpectedly becomes `any`:\r\n\r\n`AssertionError: At 14: quick info text: expected 'var assigned: (s: string) => any' to equal 'var assigned: (s: string) => number'`\r\n\r\nProbably the test code does not correctly check `/// <reference />` comment in lib.d.ts files but not sure how can it be fixed.",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/15978/comments",
    "author": "saschanaz",
    "comments": [
      {
        "user": "jakebailey",
        "created_at": "2023-07-08T04:15:12Z",
        "body": "Just looking at old issues; this doesn't break anymore."
      }
    ]
  },
  {
    "number": 15895,
    "title": "Formatting with multi-line if condition",
    "created_at": "2017-05-17T00:45:47Z",
    "closed_at": "2024-03-07T23:11:00Z",
    "labels": [
      "Bug",
      "Help Wanted",
      "Domain: Formatter"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/15895",
    "body": "**TypeScript Version:**  nightly (2.4.0-dev.20170516)\r\n\r\n**Code**\r\n\r\nType:\r\n\r\n```ts\r\nif (a\r\n    && b) {\r\n```\r\n\r\nHit enter. Type `return true;`. Hit enter. Type `}`.\r\n\r\n**Expected behavior:**\r\n\r\n```ts\r\nif (a\r\n    && b) {\r\n    return true;\r\n}\r\n```\r\n\r\n**Actual behavior:**\r\n\r\n```ts\r\nif (a\r\n    && b) {\r\n        return true;\r\n    }\r\n```",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/15895/comments",
    "author": "ghost",
    "comments": [
      {
        "user": "saschanaz",
        "created_at": "2017-05-26T23:10:15Z",
        "body": "This is a regression from some point of 2.2-2.4."
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2024-03-07T23:11:00Z",
        "body": "Closing due to lack of interest"
      }
    ]
  },
  {
    "number": 15879,
    "title": "`tsc --init` leaves trailing whitespace",
    "created_at": "2017-05-16T16:24:16Z",
    "closed_at": "2017-06-01T20:43:45Z",
    "labels": [
      "Bug",
      "Fixed",
      "Help Wanted"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/15879",
    "body": "**TypeScript Version:** nightly (2.4.0-dev.20170516)\r\n\r\n**Code**\r\n\r\n```sh\r\ntsc --init\r\n```\r\n\r\n**Expected behavior:**\r\n\r\nFile does not have trailing whitespace.\r\n\r\n**Actual behavior:**\r\n\r\nBlank lines in the file have trailing whitespace.",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/15879/comments",
    "author": "ghost",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2017-06-01T20:44:15Z",
        "body": "thanks @t-mrt!"
      }
    ]
  },
  {
    "number": 15642,
    "title": "Invalid intellisense when typing a dot in index key",
    "created_at": "2017-05-07T18:47:04Z",
    "closed_at": "2024-03-08T22:12:42Z",
    "labels": [
      "Bug",
      "Help Wanted",
      "Domain: Completion Lists"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/15642",
    "body": "Found this as part of issue #15635.\r\n\r\n**TypeScript Version:**  2.3 (current Playground)\r\n\r\n**Code**\r\n\r\n```ts\r\nwindow['.|'] // <-- Triggers suggestions (the | is the cursor)\r\n\r\n```\r\n\r\n**Expected behavior:**\r\nOnly properties that contain a dot are shown.\r\n\r\n**Actual behavior:**\r\nAll properties are shown as suggestions. Select `alert`, for instance, and the result will be \r\n\r\n```ts\r\nwindow['.alert']\r\n```\r\n\r\nwhich is not a valid `window` member.",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/15642/comments",
    "author": "LeviticusMB",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2024-03-08T22:12:43Z",
        "body": "This gets a correct replacement span now"
      }
    ]
  },
  {
    "number": 15447,
    "title": "Error when using `{}` intersection types with object literal",
    "created_at": "2017-04-28T17:28:27Z",
    "closed_at": "2017-06-06T17:08:34Z",
    "labels": [
      "Bug",
      "Fixed",
      "Help Wanted"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/15447",
    "body": "**TypeScript Version:**  2.3.1\r\n**Code**\r\n\r\n```ts\r\nconst foo: object & {} = {bar: 'bar'};\r\n```\r\n\r\n**Expected behavior:**\r\nNo error.\r\n\r\n**Actual behavior:**\r\nI get the following error:\r\n\r\n    Type '{ bar: string; }' is not assignable to type 'object & {}'.\r\n      Object literal may only specify known properties, and 'bar' does not exist in type 'object & {}'.\r\n\r\nThis error is not present in 2.2 or 2.3-rc. Interestingly enough, the following all work fine:\r\n\r\n```ts\r\nconst foo1: object = {bar: 'bar'};\r\nconst foo2: {} = {bar: 'bar'};\r\n\r\nclass Bar {}\r\nconst bar = new Bar();\r\nconst foo3: Bar & {} = bar;\r\n```",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/15447/comments",
    "author": "voithos",
    "comments": [
      {
        "user": "nowy",
        "created_at": "2017-05-20T08:47:31Z",
        "body": "I would like to tackle this if possible. Will create a PR. Any idea where to start?"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2017-06-06T09:24:38Z",
        "body": "Sorry we didnt' catch your comment @nowy. It's somewhat difficult to catch every comment with our volume of activity, and I just saw this because @HerringtonDarkholme sent out a PR. Definitely feel free to look into other issues with the Accepting PRs label though."
      }
    ]
  },
  {
    "number": 15346,
    "title": "allow +1 be a number literal type",
    "created_at": "2017-04-24T16:02:34Z",
    "closed_at": "2017-08-04T04:46:45Z",
    "labels": [
      "Suggestion",
      "Fixed",
      "Help Wanted",
      "Effort: Moderate"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/15346",
    "body": "const a : +1 = +1; // <-- problem\r\nconst b: 1= +1; // <-- still problem\r\nconst c: 1 = 1; // now we all square",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/15346/comments",
    "author": "zpdDG4gta8XKpMCd",
    "comments": [
      {
        "user": "rozzzly",
        "created_at": "2017-04-25T12:41:21Z",
        "body": "Assuming this is for parity with `const c: -1 = -1;` being valid?"
      },
      {
        "user": "zpdDG4gta8XKpMCd",
        "created_at": "2017-04-25T14:11:26Z",
        "body": "@rozzzly yes please"
      },
      {
        "user": "vkurchatkin",
        "created_at": "2017-05-01T23:22:39Z",
        "body": "@aleksey-bykov second example doesn't work either"
      },
      {
        "user": "zpdDG4gta8XKpMCd",
        "created_at": "2017-05-02T00:40:49Z",
        "body": "you must be using an old version of TypeScript"
      },
      {
        "user": "vkurchatkin",
        "created_at": "2017-05-02T01:06:18Z",
        "body": "@aleksey-bykov not really, built it from source."
      },
      {
        "user": "zpdDG4gta8XKpMCd",
        "created_at": "2017-05-02T01:09:17Z",
        "body": "you are right, stupid compiler can't see the constant behind the numberic expression"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2017-08-04T04:46:45Z",
        "body": "Fixed by #17425."
      }
    ]
  },
  {
    "number": 15214,
    "title": "Destructuring assignment must not suggest private/protected properties",
    "created_at": "2017-04-17T02:34:52Z",
    "closed_at": "2017-08-07T21:24:48Z",
    "labels": [
      "Bug",
      "Help Wanted",
      "Domain: Completion Lists"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/15214",
    "body": "Not limited to variable declarations.\r\n\r\n**TypeScript Version:**  2.2.2\r\n\r\n**Code**\r\n\r\n```ts\r\nconst { b } = new class {\r\n    private ab;\r\n    protected bc;\r\n};\r\n```\r\n\r\n**Expected behavior:**\r\n\r\nNo suggestion.\r\n\r\n**Actual behavior:**\r\n\r\nSuggested.\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/15214/comments",
    "author": "falsandtru",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2017-04-19T17:08:34Z",
        "body": "PRs welcomed."
      },
      {
        "user": "charlespierce",
        "created_at": "2017-07-05T17:08:08Z",
        "body": "PR opened to resolve this: #16953 "
      },
      {
        "user": "charlespierce",
        "created_at": "2017-07-12T01:21:05Z",
        "body": "@mhegazy If you get a chance could you take a look at the above PR for this issue? Thanks!"
      },
      {
        "user": "charlespierce",
        "created_at": "2017-07-26T01:06:20Z",
        "body": "I'd like to prevent #16953 from becoming stale, so if someone could take a few minutes to review, that would be greatly appreciated!"
      },
      {
        "user": "falsandtru",
        "created_at": "2017-07-26T01:16:17Z",
        "body": "@mhegazy What are you doing?"
      }
    ]
  },
  {
    "number": 15209,
    "title": "Access object with empty-string key",
    "created_at": "2017-04-16T06:13:52Z",
    "closed_at": "2017-05-01T23:37:02Z",
    "labels": [
      "Bug",
      "Fixed",
      "Help Wanted"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/15209",
    "body": "**TypeScript Version:**  2.3.0-dev.20170415\r\n\r\n```json\r\n{\r\n  \"compilerOptions\": {\r\n    \"strict\": true\r\n  }\r\n}\r\n```\r\n\r\n**Code**\r\n\r\n```ts\r\ndeclare const x: {\r\n  '': string;\r\n  'a': string;\r\n  'a-b': string;\r\n}\r\n\r\nx[''] // error TS7017: Element implicitly has an 'any' type because type '{ '': string; 'a': string; 'a-b': string; }' has no index signature.\r\nx['a'] // fine\r\nx['a-b'] // fine\r\n```\r\n\r\n**Expected behavior:**\r\nno error\r\n\r\n**Actual behavior:**\r\nerror TS7017: Element implicitly has an 'any' type because type '{ '': string; 'a': string; 'a-b': string; }' has no index signature.",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/15209/comments",
    "author": "ikatyang",
    "comments": [
      {
        "user": "HerringtonDarkholme",
        "created_at": "2017-04-18T05:47:01Z",
        "body": "May I ask the use case of empty string key? It seems like a strange pattern for me."
      },
      {
        "user": "ikatyang",
        "created_at": "2017-04-18T06:53:13Z",
        "body": "I just find out this bug accidentally, it looks strange to me too.\r\n\r\nBut it is still a legal case, so I reported it. :sweat_smile:"
      }
    ]
  },
  {
    "number": 15207,
    "title": "Type from `declare module \"*\";` import can't be accessed.",
    "created_at": "2017-04-15T22:26:44Z",
    "closed_at": "2024-03-09T00:19:32Z",
    "labels": [
      "Bug",
      "Help Wanted",
      "Domain: Error Messages"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/15207",
    "body": "**TypeScript Version:**  nightly (2.3.0-dev.20170415)\r\n\r\n**Code**\r\n\r\n**declarations.d.ts**\r\n\r\n```ts\r\ndeclare module \"*\";\r\n```\r\n\r\n**a.ts**\r\n\r\n```ts\r\nimport { T } from \"foo\";\r\nexport const x: T = 0;\r\n```\r\n\r\n**Expected behavior:**\r\n\r\nNo error.\r\n\r\n**Actual behavior:**\r\n\r\n```ts\r\na.ts(1,10): error TS6133: 'T' is declared but never used.\r\na.ts(2,17): error TS2304: Cannot find name 'T'.\r\n```",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/15207/comments",
    "author": "andy-hanson",
    "comments": [
      {
        "user": "andy-hanson",
        "created_at": "2017-04-15T22:33:08Z",
        "body": "On second thought, this is probably correct to be an error, although the error message(s) could be more helpful."
      },
      {
        "user": "mhegazy",
        "created_at": "2017-04-17T17:17:19Z",
        "body": "I do not think you should be able to pick a concrete type from an unknown entity. +1 for the error message."
      },
      {
        "user": "ghost",
        "created_at": "2017-05-03T16:05:38Z",
        "body": "This is a problem with any value used as a type:\r\n```ts\r\nconst T = 0;\r\ntype U = T;\r\n```\r\n\r\nGives `a.ts(2,10): error TS2304: Cannot find name 'T'.`\r\n\r\nIn contrast, we have a nice error message for:\r\n```ts\r\ntype T = number;\r\nconst x = T;\r\n```\r\n\r\nGives `a.ts(2,11): error TS2693: 'T' only refers to a type, but is being used as a value here.`"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2024-03-09T00:19:32Z",
        "body": "I don't know what this would mean."
      }
    ]
  },
  {
    "number": 15007,
    "title": "WriteFileCallback: sourceFiles is optional",
    "created_at": "2017-04-04T19:11:08Z",
    "closed_at": "2017-09-26T00:22:27Z",
    "labels": [
      "Bug",
      "Fixed",
      "Help Wanted",
      "API"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/15007",
    "body": "`WriteFileCallback` is defined as follows:\r\n\r\n```typescript\r\nexport interface WriteFileCallback {\r\n    (fileName: string, data: string, writeByteOrderMark: boolean, onError?: (message: string) => void, sourceFiles?: SourceFile[]): void;\r\n}\r\n```\r\nI was wondering why `sourceFiles` marked as optional. As of version 3.6, we're using this in gulp-typescript. This works fine, but ivogabe/gulp-typescript#499 describes that `sourceFiles` is `undefined` in some special case. So, when is `sourceFiles` `undefined`, and is there some way to force it being set?",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/15007/comments",
    "author": "ivogabe",
    "comments": [
      {
        "user": "ivogabe",
        "created_at": "2017-05-09T19:48:17Z",
        "body": "@vladima Any ideas?"
      },
      {
        "user": "mhegazy",
        "created_at": "2017-05-10T23:44:08Z",
        "body": "That is a bug int he declaration, soruceFiles should always be passed, it can be a single file or all files in the program."
      },
      {
        "user": "DickvdBrink",
        "created_at": "2017-05-15T17:29:02Z",
        "body": "@mhegazy, this is a bit difficult to change because `onError` is also optional. So making to make sourceFiles mandatory it is necessary to change the order of the parameters which is a bit difficult in a public API "
      },
      {
        "user": "ivogabe",
        "created_at": "2017-05-15T18:15:00Z",
        "body": "Why is `onError` optional? It could also be marked as `| undefined` instead, or is this parameter also always provided and not optional?"
      }
    ]
  },
  {
    "number": 14775,
    "title": "Replace 'tsc --help' output message's example for using response files",
    "created_at": "2017-03-21T22:40:33Z",
    "closed_at": "2017-03-22T02:39:48Z",
    "labels": [
      "Fixed",
      "Help Wanted",
      "Good First Issue"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/14775",
    "body": "Right now if you write `tsc --help`, you'll get\r\n\r\n```\r\nVersion 2.x.x-dev.123456\r\nSyntax:   tsc [options] [file ...]\r\n\r\nExamples: tsc hello.ts\r\n          tsc --outFile file.js file.ts\r\n          tsc @args.txt\r\n```\r\n\r\nNotice that last part: **`tsc @args.txt`**.\r\n\r\nResponse files are not something we've thought about in forever. `tsconfig.json` has been the standard way to use TypeScript for quite a bit now. The example given is confusing at this point.\r\n\r\nI think we should either remove it entirely or use **`tsc --project tsconfig.json`**",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/14775/comments",
    "author": "DanielRosenwasser",
    "comments": [
      {
        "user": "misoguy",
        "created_at": "2017-03-22T00:09:46Z",
        "body": "I'd like to help out on this issue if no one is on it yet."
      }
    ]
  },
  {
    "number": 14751,
    "title": "Completions on class: put statics first",
    "created_at": "2017-03-20T17:10:07Z",
    "closed_at": "2020-09-11T21:48:25Z",
    "labels": [
      "Suggestion",
      "Help Wanted",
      "Good First Issue",
      "Domain: Completion Lists"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/14751",
    "body": "**TypeScript Version:**  nightly (typescript@2.3.0-dev.20170320)\r\n\r\n**Code**\r\n\r\n```ts\r\nclass C {\r\n  static foo() {}\r\n  static bar() {}\r\n}\r\n\r\nC.\r\n```\r\n\r\n**Expected behavior:**\r\n\r\nCompletions `foo` and `bar` are first.\r\n\r\n**Actual behavior:**\r\n\r\nThey are hidden among `apply`, `arguments`, `bind`, `call`, `caller`, `length`, `name`, `prototype`, and `toString`.",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/14751/comments",
    "author": "ghost",
    "comments": [
      {
        "user": "jameshulse",
        "created_at": "2017-09-15T16:00:01Z",
        "body": "I've taken a crack at this for my contribution to TypeScript.\r\n\r\nWhen creating the completion entries in competions.ts `createCompletionEntry` all entries are given a `sortText` of `\"0\"` which means they end up in the default alphabetical order. My logic is to give the symbols merged from `Function` sortText that will cause them to appear after. The concept that seems to indicate these symbols are from an inherited class are the `mergeId` so I have gone for something similar to the following:\r\n\r\n```\r\nlet sortText = '0';\r\n\r\nif(symbol.parent.mergeId) { // undefined on symbols directly from 'C' but numerical for Function symbols\r\n    sortText = `0-${symbol.parent.mergeId}`;\r\n}\r\n```\r\n\r\nIf this doesn't sound too far off then I would happily follow the standard procedure and create a pull request etc."
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2017-09-15T17:16:46Z",
        "body": "@jameshulse sounds about right to me"
      },
      {
        "user": "ghost",
        "created_at": "2017-09-15T22:18:59Z",
        "body": "@jameshulse I think we're not correctly testing `sortText` right now. I'll try to look into that on monday."
      },
      {
        "user": "jameshulse",
        "created_at": "2017-09-16T10:31:28Z",
        "body": "Cheers @andy-ms. A potential risk is whether all clients are happy to handle non numeric `sortText`."
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2017-09-18T18:22:44Z",
        "body": "I think we should be fine. The name is `sortText` after all, and even the built-in JS `sort` function sorts numbers as if they were strings 😆 "
      },
      {
        "user": "jameshulse",
        "created_at": "2017-09-21T10:56:07Z",
        "body": "Ha good point @RyanCavanaugh. I've created a pull request to show my suggested fix. I struggled with testing part so I'm sorry if this causes more work for you guys. If you can point me in the right direction I can give it another go (was also running in to mocha errors locally annoyingly)"
      }
    ]
  },
  {
    "number": 14696,
    "title": "Ban class with empty type parameter list",
    "created_at": "2017-03-16T21:40:32Z",
    "closed_at": "2017-03-27T19:13:18Z",
    "labels": [
      "Bug",
      "Fixed",
      "Breaking Change",
      "Help Wanted",
      "Good First Issue"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/14696",
    "body": "**TypeScript Version:**  nightly (2.3.0-dev.20170316)\r\n\r\n**Code**\r\n\r\n```ts\r\nclass X<> {}\r\nfunction f<>() {}\r\nconst x: X<> = new X<>();\r\n```\r\n\r\n**Expected behavior:**\r\n\r\nAll are errors.\r\n\r\n**Actual behavior:**\r\n\r\nAll but `class X<> {}` are errors. We should consistently fail when a type parameter list is empty.",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/14696/comments",
    "author": "ghost",
    "comments": [
      {
        "user": "misoguy",
        "created_at": "2017-03-21T12:51:40Z",
        "body": "I'd like to give this a shot if no one is already on it :)"
      }
    ]
  },
  {
    "number": 14596,
    "title": "multi-line argument indentation",
    "created_at": "2017-03-11T17:01:09Z",
    "closed_at": "2024-03-11T19:06:40Z",
    "labels": [
      "Bug",
      "Help Wanted",
      "Domain: Formatter"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/14596",
    "body": "I've seen a number of indentation related bugs floating around but none quite like this.  Not sure if this is fixed by #13574.  \r\n\r\n**TypeScript Version:**  2.2.1\r\n\r\n**Explanation**\r\n\r\n```ts\r\n  public async setPosition(path: Path, col: Col, \r\n                           cursorOptions?: CursorOptions) {\r\n    await this._setPath(path);\r\n    await this.setCol(col, cursorOptions);\r\n  }\r\n\r\n  public async setPath(path: Path, cursorOptions?: CursorOptions) {\r\n    await this._setPath(path);\r\n    await this._fromMoveCol(cursorOptions);\r\n  }\r\n```\r\n\r\ngets autoformatted to\r\n\r\n```ts\r\n  public async setPosition(path: Path, col: Col,\r\n                           cursorOptions?: CursorOptions) {\r\n                             await this._setPath(path);\r\n                             await this.setCol(col, cursorOptions);\r\n                           }\r\n\r\n                           public async setPath(path: Path, cursorOptions?: CursorOptions) {\r\n                             await this._setPath(path);\r\n                             await this._fromMoveCol(cursorOptions);\r\n                           }\r\n```\r\nIf the arguments to setPosition are put on a single line, then it works fine.",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/14596/comments",
    "author": "WuTheFWasThat",
    "comments": [
      {
        "user": "rubiesonthesky",
        "created_at": "2024-03-10T13:25:01Z",
        "body": "This seems to format now to below code with VS Code Insiders with default settings.\r\n\r\n```ts\r\n    public async setPosition(path: Path, col: Col,\r\n        cursorOptions?: CursorOptions) {\r\n        await this._setPath(path);\r\n        await this.setCol(col, cursorOptions);\r\n    }\r\n\r\n    public async setPath(path: Path, cursorOptions?: CursorOptions) {\r\n        await this._setPath(path);\r\n        await this._fromMoveCol(cursorOptions);\r\n    }\r\n  ```"
      }
    ]
  },
  {
    "number": 14484,
    "title": "Error Message/Syntax Highlight improvements for \"import\" being a reserved keyword",
    "created_at": "2017-03-06T15:17:37Z",
    "closed_at": "2019-01-29T18:00:01Z",
    "labels": [
      "Duplicate",
      "Help Wanted"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/14484",
    "body": "**TypeScript Version:**  2.2.1.0 (Visual Studio 2015 Extension)\r\n\r\n**Code**\r\n\r\n```ts\r\ninterface ITest { }\r\n\r\nclass Test {\r\n    public Foo = (import: ITest2) => {};\r\n}\r\n```\r\n\r\n**Expected behavior:**\r\nAn error saying \"'import' is a reserved keyword\".\r\nAnd the \"import\" reserved keyword to be coloured as such.\r\n\r\n**Actual behavior:**\r\nAn error saying \"Expression expected\".\r\nIn the provided code above \"import\" is not coloured as being a keyword in VS2015.\r\nIt is being coloured correctly in the TS Playground.\r\n\r\nIn the following code it is coloured correctly in VS2015, although it still has same \"bad\" error message:\r\n\r\n```ts\r\ninterface ITest { }\r\n\r\nvar foo = (import: ITest2) => { };\r\n```",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/14484/comments",
    "author": "ghost",
    "comments": [
      {
        "user": "DanielRosenwasser",
        "created_at": "2019-01-27T00:24:30Z",
        "body": "Fixing the error message here shouldn't be drastically different from a fix for #16934."
      },
      {
        "user": "typescript-bot",
        "created_at": "2019-01-29T18:00:06Z",
        "body": "This issue has been marked as a 'Duplicate' and has seen no recent activity. It has been automatically closed for house-keeping purposes."
      }
    ]
  },
  {
    "number": 14137,
    "title": "Private members used only via `[]` notation trigger `--noUnusedLocals` error",
    "created_at": "2017-02-17T00:25:56Z",
    "closed_at": "2022-03-05T00:03:38Z",
    "labels": [
      "Bug",
      "Help Wanted",
      "Effort: Moderate"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/14137",
    "body": "\r\n\r\n**TypeScript Version:**  2.1.1 / nightly (2.2.0-dev.201xxxxx)\r\n\r\nVersion 2.1.6\r\n\r\n**Code**\r\n\r\n```ts\r\nclass PhoneBook {\r\n   private sally: number = 123; // error TS6133: 'sally' is declared but never used.\r\n   private sam: number =456; // error TS6133: 'sam' is declared but never used.\r\n   getNumber(who: 'sally' | 'wendy'): number {\r\n       return this[who]; // tsc is able to correctly deduce that this is a number\r\n   }\r\n}\r\nconst phoneBook = new PhoneBook();\r\nconsole.log(phoneBook.getNumber('sally'));\r\n```\r\n\r\n**Expected behavior:**\r\n\r\nUsing a private member via `[]` notation should **not** trigger `--noUnusedLocals` errors.\r\n\r\n**Actual behavior:**\r\n\r\nA private member used only via `[]` triggers `--noUnusedLocals` errors.",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/14137/comments",
    "author": "studds",
    "comments": [
      {
        "user": "studds",
        "created_at": "2017-02-17T00:31:29Z",
        "body": "It could reasonably be argued that this is not an obvious or perhaps common use case. And indeed, this can be worked around. Obviously, this example is contrived in the extreme. And yet, I would maintain that in some cases it may be a _reasonable_ use case which obeys (I believe) all the rules of the language, and ought not trigger a compiler error."
      },
      {
        "user": "kemsky",
        "created_at": "2017-03-29T11:47:21Z",
        "body": "It does not work in a more simple case like `object[\"property\"]`."
      },
      {
        "user": "mysticatea",
        "created_at": "2017-05-21T02:31:41Z",
        "body": "I have encountered this issue. In my case, I use `state` property for dynamic dispatching.\r\nCan I avoid those errors and keep dynamic dispatching?\r\n\r\n```ts\r\ntype ParserState = \"A_STATE\" | \"B_STATE\" | \"Z_STATE\"\r\n\r\nclass Parser {\r\n    private state: ParserState\r\n\r\n    constructor() {\r\n        this.state = \"A_STATE\"\r\n    }\r\n\r\n    parse() {\r\n        while (this.state !== \"Z_STATE\") {\r\n            this.state = this[this.state]()\r\n        }\r\n    }\r\n\r\n    private A_STATE(): ParserState { /* .... */ } // 'A_STATE' declared but never used.\r\n    private B_STATE(): ParserState { /* .... */ } // 'B_STATE' declared but never used.\r\n    private Z_STATE(): ParserState { /* .... */ } // 'Z_STATE' declared but never used.\r\n}\r\n```\r\n"
      },
      {
        "user": "Manusan42",
        "created_at": "2017-07-01T00:40:00Z",
        "body": "I have a similar problem like mysticatea...\r\n```ts\r\n@injectable()\r\nexport class MasterHandler {\r\n  @inject(TypeKeys.AHandler) private _aHandler: Types.AHandler;\r\n  @inject(TypeKeys.BHandler) private _bHandler: Types.BHandler;\r\n\r\n  async process(request: Request): Promise<Response> {\r\n    return await this[`_${request.scope}Handler`][request.action](request.payload);\r\n  }\r\n}\r\n```\r\nHowever, getting forced to remove some intentional unused locals like specific imports, I decided to use `tslint` till `tsc` supports warning messages. Besides that I just agree with alexeagle who said in issue #15953 :\r\n\r\n> So I believe TypeScript should avoid non-fatal diagnostics (and unused variable was a mistake).\r\n\r\nTo overcome the need of activated type info for `tslint` core rule `no-unused-variable` I came up with ajafff's `tslint-consistent-codestyle` custom rule `no-unused` which workes quiet fine (without type info) for many cases, just class members are ignored for now, but it's a brand new rule, so let's wait and see."
      },
      {
        "user": "Dervol03",
        "created_at": "2018-05-17T11:32:43Z",
        "body": "+1\r\n\r\nI opt for improving this as well, because the the `dynamic dispatching` (as named by @mysticatea) is a very efficient way of implementing the strategy pattern in TypeScript that I use a lot, as it removes the necessity of an extra object only existing to map a string to a certain function.\r\n\r\nHere is an example of a class converting a JSON schema into a valid elasticsearch mapping, that only serves the purpose of demonstration, in a real world, I wouldn't actually implement it as a class.\r\n\r\nExample:\r\n```typescript\r\nclass JsonToEsConverter {\r\n  private _esMapping: EsMap = {}\r\n\r\n  constructor(private _schema: JSONSchema) {}\r\n\r\n  public get esMapping(): EsMap {\r\n    if (_.isEmpty(this._esMapping)) {\r\n      this.buildEsMapping();\r\n    }\r\n    return this._esMapping;\r\n  }\r\n\r\n  private buildEsMapping(): void {\r\n    for (const prop in this._schema.properties) {\r\n      this._esMapping[prop] = this[`${_schema.properties[prop]}ToEsMap](_schema.properties[prop]);\r\n    }\r\n  }\r\n\r\n  private stringToEsMap(stringProp..){}\r\n  private integerToEsMap(intProp..){}\r\n  private arrayToEsMap(arrayProp...) {}\r\n}\r\n```\r\n\r\nThis is actually nice and concise. However, the compiler does not understand, that the `-ToEsMap` methods are actually used and throws an error.\r\nWhich forces me to either extract them into a separate module, which violates the separation of concerns principle and considerable augments the number of arguments the methods would have to take, or, to \"manually\" create an additional map property to hold these methods:\r\n\r\n```typescript\r\nclass JsonToEsConverter {\r\n  private _esMapping: EsMap = {};\r\n  private _converterMap: {[converterName: string]: Function};\r\n\r\n  constructor(private _schema: JSONSchema) {\r\n    this._converterMap = {\r\n      stringToEsMap: this.stringToEsMap.bind(this);\r\n      integerToEsMap: this.integerToEsMap.bind(this);\r\n      arrayToEsMap: this.arrayToEsMap.bind(this);\r\n    }\r\n  }\r\n\r\n  public get esMapping(): EsMap {\r\n    if (_.isEmpty(this._esMapping)) {\r\n      this.buildEsMapping();\r\n    }\r\n    return this._esMapping;\r\n  }\r\n\r\n  private buildEsMapping(): void {\r\n    for (const prop in this._schema.properties) {\r\n      this._esMapping[prop] = this[`${_schema.properties[prop]}ToEsMap](_schema.properties[prop]);\r\n    }\r\n  }\r\n\r\n  private stringToEsMap(stringProp..){}\r\n  private integerToEsMap(intProp..){}\r\n  private arrayToEsMap(arrayProp...) {}\r\n}\r\n```\r\nWhich doesn't really help. Or worse, move everything to static methods, which creates the same problems as the ones with a separate module\r\n  \r\n    \r\n"
      }
    ]
  },
  {
    "number": 13978,
    "title": "error TS18003: No inputs were found in config file...",
    "created_at": "2017-02-09T15:34:25Z",
    "closed_at": "2024-03-09T00:19:58Z",
    "labels": [
      "Bug",
      "Help Wanted"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/13978",
    "body": "I would like to watch all `*.ts` files in a folder and automatically compile them to `*.js`. The folder is empty to start with but then new `*.ts` files are added into it.\r\n\r\nAs it is now, the compiler errors because there are no files in the folder. I think that the error should not occur when `watch=true` as `*.ts` files can be added later on...\r\n\r\nWhat do you think?",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/13978/comments",
    "author": "oldrich-s",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2017-02-09T19:27:53Z",
        "body": "So no single .ts file anywhere?"
      },
      {
        "user": "oldrich-s",
        "created_at": "2017-02-09T19:41:53Z",
        "body": "Well it is rare but it can happen so I need to deal with it ;)\r\n\r\nI personally think that if you allow adding ts files during watch then you should also allow starting with no files as it is a legitimate use case."
      },
      {
        "user": "mhegazy",
        "created_at": "2017-02-14T06:38:16Z",
        "body": "I think the error message should still be shown, but it should not block watching."
      },
      {
        "user": "wclr",
        "created_at": "2017-05-01T21:52:38Z",
        "body": "@mhegazy I think there should be at least flag that would prevent this \"error\" from failing (exiting with code 1),  for example this breaks some automatic build process if it happens to be on folders that are not yet TS converted.  Just really strange error, warning should be yes."
      }
    ]
  },
  {
    "number": 13601,
    "title": "Better error message when users mistakenly import from named vs. default export",
    "created_at": "2017-01-20T20:25:17Z",
    "closed_at": "2019-10-01T19:12:30Z",
    "labels": [
      "Bug",
      "Fixed",
      "Help Wanted",
      "Good First Issue",
      "Domain: Error Messages"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/13601",
    "body": "At google, we've had a number of users trip over import syntax when working with libraries that have default exports.\r\n\r\nGiven this scenario:\r\n\r\n`has_named_export.ts`\r\n```\r\nexport var a = 1;\r\n```\r\n\r\n`has_default_export.ts`\r\n```\r\nvar b = '';\r\nexport default b;\r\n```\r\n\r\n1) Users often do:\r\n```\r\nimport {b} from './has_default_export';\r\n```\r\nwhich gives:\r\n`Error: module has no exported member 'b'`\r\n\r\nRequest: the error could be more helpful, like \"did you mean to import the default export, with no curly braces\"\r\nThis is especially likely when the name of the default export matches the named import.\r\nNovice users look at `has_default_export` and think that B should be importable, and may never have worked with default exports.\r\n\r\n2) Also possible:\r\n```\r\nimport a from './has_named_export';\r\n```\r\n`\"has_named_export\" has no default export`\r\n\r\nThis one is less frequent, but it could say \"did you mean to import the named import 'a' by using curly braces\"",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/13601/comments",
    "author": "alexeagle",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2017-01-20T21:26:07Z",
        "body": "Should be a rather simple check in `getExternalModuleMember` to add the elaboration. PRs are welcomed."
      },
      {
        "user": "jules-costa",
        "created_at": "2017-09-24T02:01:40Z",
        "body": "I'd like to give this a shot! This would be my first open source contribution. "
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2017-09-25T23:32:48Z",
        "body": "@jules-costa the closed PRs referenced above are fairly close to correct - I'd recommend picking out the good bits from those changes"
      },
      {
        "user": "knrt10",
        "created_at": "2018-10-01T22:40:08Z",
        "body": "@jules-costa are you still working on this issue? If not, I would like to give it a try."
      },
      {
        "user": "joaniedavis",
        "created_at": "2018-12-17T18:50:28Z",
        "body": "@knrt10 Are you still working on this issue? If not, could I take over your PR and update it with the requested fixes? "
      },
      {
        "user": "knrt10",
        "created_at": "2018-12-18T01:21:56Z",
        "body": "@joaniedavis I was little busy, but sure go ahead."
      },
      {
        "user": "breck7",
        "created_at": "2019-06-27T03:25:47Z",
        "body": "I think in general the error messaging for all import errors need an overhaul.\r\n\r\nIt seems like there are <100 different ways people setup their folder/file/node_modules/vendor folders and determining the correct way to import things when using TypeScript, taking into account issues including whether the script will be used in a Node or Browser environment, is terribly complicated.\r\n\r\nMy proposal is that *any time* there is any kind of import/require/triple directive/etc issue, TypeScript examines the user's file system for the <100 most common setups, and provides a suggestion for how they should go about specifying their imports.\r\n\r\nIs there something like that underway? I would be happy to put some time into helping."
      },
      {
        "user": "mheiber",
        "created_at": "2019-09-30T16:16:16Z",
        "body": "opening a PR soon! ^^"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2019-10-01T19:14:07Z",
        "body": "Thanks @prime-optimus!"
      }
    ]
  },
  {
    "number": 13503,
    "title": "Crash for `getTypeAtLocation(sourceFile)`",
    "created_at": "2017-01-16T00:09:55Z",
    "closed_at": "2020-08-12T07:11:26Z",
    "labels": [
      "Bug",
      "Fixed",
      "Help Wanted",
      "Fix Available"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/13503",
    "body": "**TypeScript Version:**  nightly (2.2.0-dev.20170115)\r\n\r\n**Code**\r\n\r\n```js\r\nconst fs = require(\"fs\"); const path = require(\"path\"); const ts = require(\"typescript\");\r\n\r\nconst tsconfigPath = \"sample-code/tsconfig.json\";\r\n\r\nconst { config, error } = ts.readConfigFile(tsconfigPath, path => fs.readFileSync(path, \"utf-8\"))\r\nif (error) throw error;\r\n\r\nconst parsedOptions = ts.parseJsonConfigFileContent(config, ts.sys, path.dirname(tsconfigPath));\r\nif (parsedOptions.errors.length) throw new Error(\"!\")\r\n\r\nconst program = ts.createProgram(parsedOptions.fileNames, parsedOptions.options)\r\nconst file = program.getSourceFiles()[0];\r\n\r\nprogram.getTypeChecker().getTypeAtLocation(file);\r\n```\r\n\r\n**Expected behavior:**\r\n\r\nNo crash\r\n\r\n**Actual behavior:**\r\n\r\n```\r\n/home/andy/ts-services/node_modules/typescript/lib/typescript.js:42358\r\n            while (nodeOnRightSide.parent.kind === 142 /* QualifiedName */) {\r\n                                         ^\r\n\r\nTypeError: Cannot read property 'kind' of undefined\r\n    at getLeftSideOfImportEqualsOrExportAssignment (/home/andy/ts-services/node_modules/typescript/lib/typescript.js:42358:42)\r\n    at isInRightSideOfImportOrExportAssignment (/home/andy/ts-services/node_modules/typescript/lib/typescript.js:42370:20)\r\n    at Object.getTypeOfNode [as getTypeAtLocation] (/home/andy/ts-services/node_modules/typescript/lib/typescript.js:42590:17)\r\n    at Object.<anonymous> (/home/andy/ts-services/repro.js:14:26)\r\n    at Module._compile (module.js:570:32)\r\n    at Object.Module._extensions..js (module.js:579:10)\r\n    at Module.load (module.js:487:32)\r\n    at tryModuleLoad (module.js:446:12)\r\n    at Function.Module._load (module.js:438:3)\r\n    at Module.runMain (module.js:604:10)\r\n```\r\n\r\n`sample-code/tsconfig.json` is `{}` and `sample-code/sample.ts` is empty.\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/13503/comments",
    "author": "andy-hanson",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2017-01-16T05:24:34Z",
        "body": "We should handle SourceFile specially and return immediately if it is not a module. PRs welcomed."
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2020-08-12T07:11:47Z",
        "body": "Thanks @a-tarasyuk!"
      }
    ]
  },
  {
    "number": 13236,
    "title": "No straightforward/stable way to consume lib/tsserverlibrary.js",
    "created_at": "2016-12-31T19:11:42Z",
    "closed_at": "2017-01-05T20:06:37Z",
    "labels": [
      "Bug",
      "Fixed",
      "Help Wanted"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/13236",
    "body": "**TypeScript Version:**  2.\\*.\\*-\\*\r\n\r\n**Code**\r\nThis is in a project that needs to use tsserverlibrary.js:\r\n\r\ntest.ts:\r\n```ts\r\nimport * as ts from \"typescript/lib/tsserverlibrary\";\r\n```\r\nBecause tsserverlibrary.d.ts is not a module:\r\n```ts\r\n/// <reference ...\r\ndeclare module \"typescript/lib/tsserverlibrary\" {\r\n    export = ts;\r\n}\r\n```\r\n\r\nThis still fails due to the following line in tsserverlibrary.d.ts, which in an installed package, resolves to the nonexistent file node_modules/src/types.d.ts:\r\n```ts\r\n/// <reference path=\"../../src/server/types.d.ts\" />\r\n```\r\n\r\nWith a custom copy of tsserverlibrary.d.ts, `const ts = require(...` is a potential option, but options for consuming `ts` as the declared namespace instead of `any` are clumsy.\r\n\r\n**Expected behavior:**\r\nConsumer of the TypeScript Node package can import tsserverlibrary.js without issue.\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/13236/comments",
    "author": "joelday",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2016-12-31T21:24:31Z",
        "body": "We should make the .d.ts file a module; we do that as part of the build already for typescript.d.ts; a PR would be appreciated."
      },
      {
        "user": "joelday",
        "created_at": "2016-12-31T22:14:34Z",
        "body": "Thanks, @mhegazy! Any suggestions/details I should know on resolving the types.d.ts reference? There are reference tags down the tree that refer to .ts files as well.\r\n\r\nI'll look at the existing lib generation code and go from there."
      },
      {
        "user": "joelday",
        "created_at": "2017-01-03T23:45:10Z",
        "body": "@mhegazy Submitted a PR. Thanks!"
      }
    ]
  },
  {
    "number": 13114,
    "title": "Incorrect space deletion after brace",
    "created_at": "2016-12-22T03:58:19Z",
    "closed_at": "2016-12-22T18:10:43Z",
    "labels": [
      "Bug",
      "Fixed",
      "Help Wanted",
      "Domain: Formatter"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/13114",
    "body": "**TypeScript Version:**  master branch\r\n\r\n**Code**\r\n\r\n```ts\r\n({});\r\n```\r\n\r\n**Expected behavior:**\r\n\r\n```ts\r\n( {} ); // with insertSpaceAfterOpeningAndBeforeClosingNonemptyParenthesis\r\n```\r\n\r\n**Actual behavior:**\r\n\r\n```ts\r\n( {}); // with insertSpaceAfterOpeningAndBeforeClosingNonemptyParenthesis\r\n```",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/13114/comments",
    "author": "saschanaz",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2016-12-22T18:11:06Z",
        "body": "thanks @flowmemo !"
      }
    ]
  },
  {
    "number": 13108,
    "title": "Unhelpful error when using increment with stricter checks on uninitialized variables",
    "created_at": "2016-12-22T01:30:38Z",
    "closed_at": "2023-08-28T07:15:13Z",
    "labels": [
      "Bug",
      "Help Wanted",
      "Domain: Error Messages"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/13108",
    "body": "Version: TypeScript 2.1.4\r\n\r\n```ts\r\nfunction f() {\r\n    var x;\r\n    x++;\r\n    return x;\r\n}\r\n```\r\n\r\nTurn on `noImplicitAny` and/or `strictNullChecks`.\r\n\r\nThe error that you'll get is \r\n\r\n```\r\nAn arithmetic operand must be of type 'any', 'number' or an enum type.\r\n```\r\n\r\nHowever, quick info for this variable reports that it's `any`, and the error itself doesn't tell us what the type is.",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/13108/comments",
    "author": "DanielRosenwasser",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2016-12-22T23:58:36Z",
        "body": "they type of `x` should be `undefined`. the issue seems to be with your quick info and not the error message."
      },
      {
        "user": "Andarist",
        "created_at": "2023-08-27T12:56:13Z",
        "body": "The error has been improved since then and it nows states this:\r\n> 'x' is possibly 'undefined'.(18048)\r\n\r\nThis is quite helpful and points to the issue with the code directly. I think this issue could be closed (cc @jakebailey )"
      }
    ]
  },
  {
    "number": 13099,
    "title": "Empty `super` call should be allowed when extending map",
    "created_at": "2016-12-21T19:25:45Z",
    "closed_at": "2024-02-23T20:43:20Z",
    "labels": [
      "Bug",
      "Help Wanted",
      "ES6",
      "Domain: lib.d.ts"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/13099",
    "body": "Consider the following code:\r\n```typescript\r\nclass DefaultMap extends Map {\r\n    constructor(iterable:any){\r\n        super(iterable);\r\n    }\r\n}\r\n```\r\nThis will give an error that the supplied parameters do not match the signature on the `super` call, where `new Map(iterable)` works as expected.",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/13099/comments",
    "author": "paulvanbrenk",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2016-12-21T19:59:02Z",
        "body": "Should change lib.d.ts to read as follows (move generic signature up, add optional parameter to non-generic signature):\r\n```ts\r\ninterface MapConstructor {\r\n    new <K, V>(entries?: [K, V][]): Map<K, V>;\r\n    new (entries?: any[]): Map<any, any>;\r\n    readonly prototype: Map<any, any>;\r\n}\r\n```\r\n"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2024-02-23T20:43:20Z",
        "body": "Doesn't seem like anyone cares."
      }
    ]
  },
  {
    "number": 12816,
    "title": "Newlines removed in emit for argument list",
    "created_at": "2016-12-10T00:44:43Z",
    "closed_at": "2024-03-09T00:21:23Z",
    "labels": [
      "Bug",
      "Help Wanted"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/12816",
    "body": "Using the latest 2.1 release, the below TypeScript\r\n\r\n```typescript\r\ngetCollection().then(\r\n    col => console.log(col.id),\r\n    err => console.log(err.toString())\r\n );\r\n```\r\n\r\nresults in the below emitted JavaScript\r\n\r\n```javascript\r\ngetCollection().then(function (col) { return console.log(col.id); }, function (err) { return console.log(err.toString()); });\r\n```\r\n\r\nThis makes setting breakpoints a pain in the resulting code. It would be nice if the formatting was preserved.",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/12816/comments",
    "author": "billti",
    "comments": [
      {
        "user": "srolel",
        "created_at": "2017-01-13T06:57:20Z",
        "body": "I understand you would like the output to look like this:\r\n```\r\ngetCollection().then(\r\n    function(col) {return console.log(col.id)},\r\n    function(err) {return console.log(err.toString())}\r\n );\r\n```\r\n\r\nSo that the newlines from the original code are preserved. But, how does this help with breakpoints? Perhaps something like this:\r\n\r\n```\r\ngetCollection().then(function (col) {\r\n    return console.log(col.id);\r\n}, function (err) {\r\n    return console.log(err.toString());\r\n});\r\n```\r\n\r\nMeaning to compile arrow functions to function expressions with a multi-line body.\r\n\r\n@DanielRosenwasser @mhegazy What is the reasoning behind emitting functions with single-line body? Could this be removed entirely, so that any function expression, including regular function expressions, be compiled with a multi-line body?"
      }
    ]
  },
  {
    "number": 12261,
    "title": "__awaiter with arrow functions for target = ES6/ES2015",
    "created_at": "2016-11-15T09:58:01Z",
    "closed_at": "2017-05-22T23:21:52Z",
    "labels": [
      "Won't Fix",
      "Suggestion",
      "Help Wanted"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/12261",
    "body": "In current implementation of `awaiterHelper` contains a lot of regular `function () { /* ... */ }`.\r\nI think that for target ES6/ES2015 `awaiterHelper` can be rewritten with arrow functions (they are smaller and more performant).\r\n\r\nIf arrow functions allowed at this place, can I submit PR? \r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/12261/comments",
    "author": "arusakov",
    "comments": [
      {
        "user": "gcnew",
        "created_at": "2016-11-17T09:02:17Z",
        "body": "Does a (maybe) slight performance improvement justify the added maintenance cost of diverging code paths? For me the answer is \"no\", especially considering this code can be swapped by custom helpers and is basically a temporary down-level solution.\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2017-05-22T23:21:52Z",
        "body": "After discussing this with the team it seems there is no clean way to do this without having to have 1. two different named functions, or 2. transformation running on the code itself. given the value gained here, the cost does not seem to match. closing."
      }
    ]
  },
  {
    "number": 12218,
    "title": "Incorrect formatting after readonly modifier",
    "created_at": "2016-11-14T12:15:50Z",
    "closed_at": "2016-12-21T00:10:17Z",
    "labels": [
      "Bug",
      "Fixed",
      "Help Wanted",
      "Domain: Formatter"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/12218",
    "body": "**TypeScript Version:** 2.1.1,  2.0.9, nightly (2.2.0-dev.20161114)\r\nVS Code: 1.8.0 - Insider\r\n\r\n**Code**\r\n\r\n```ts\r\n// A *self-contained* demonstration of the problem follows...\r\nclass C {\r\n  // three spaces separate the tokens readonly and property\r\n  readonly   property = {};\r\n}\r\n```\r\n\r\n**Expected behavior:**\r\nAfter applying the format command via VS Code (default `shift + alt + f`) the extra whitespace between `readonly` and property is removed just as it is with modifiers such as `public`, `private`, and `protected`\r\n\r\n**Actual behavior:** \r\nThe extra whitespace between `readonly` and `property` is retained. Note that this does not occur for other modifiers such as `public` and only occurs when `readonly` is the last modifier (\r\n`readonly public` ~~works correctly~~ is correctly a syntax error).",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/12218/comments",
    "author": "aluanhaddad",
    "comments": [
      {
        "user": "DanielRosenwasser",
        "created_at": "2016-12-21T00:10:31Z",
        "body": "Thanks for the fix @DanCorder!"
      },
      {
        "user": "aluanhaddad",
        "created_at": "2016-12-21T00:46:03Z",
        "body": "Much appreciated!"
      }
    ]
  },
  {
    "number": 11726,
    "title": "\"Cannot extend a class 'undefined'.\" when class is declared in a namespace",
    "created_at": "2016-10-19T07:12:09Z",
    "closed_at": "2016-10-25T18:45:32Z",
    "labels": [
      "Bug",
      "Fixed",
      "Help Wanted"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/11726",
    "body": "Hi,\nI noticed the error message when trying to extend a class with a private constructor says `'undefined'` if the class is in a namespace:\n\n**TypeScript Version:**  master (14e5de3b1d6eafa2d3213a72b8599ecc972ed419)\n\n**Code**\n\n``` ts\ndeclare namespace abc {\n    class XYZ {\n        private constructor();\n    }\n}\n\nclass C extends abc.XYZ {\n}\n\n```\n\n**Expected behavior:**\n\n```\nerror TS2675: Cannot extend a class 'abc.XYZ'. Class constructor is marked as private.\n```\n\n**Actual behavior:** \n\n```\nerror TS2675: Cannot extend a class 'undefined'. Class constructor is marked as private.\n```\n\nThanks!\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/11726/comments",
    "author": "kpreisser",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2016-10-19T18:45:26Z",
        "body": "A PR would be appreciated. \n"
      },
      {
        "user": "masaeedu",
        "created_at": "2016-10-25T10:14:37Z",
        "body": "@mhegazy What is the expected error for something like this?\n\n``` typescript\nmodule abc {\n  export class XYZ {\n    private constructor() {}\n  }\n}\n\nfunction foo() {\n  return abc.XYZ;\n}\n\nclass Foo extends foo() {\n}\n```\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2016-10-25T18:45:56Z",
        "body": "thanks @masaeedu!\n"
      }
    ]
  },
  {
    "number": 11676,
    "title": "Incorrect formatting with non-null assertion operator",
    "created_at": "2016-10-17T04:08:09Z",
    "closed_at": "2016-12-26T19:37:09Z",
    "labels": [
      "Bug",
      "Fixed",
      "Help Wanted",
      "Domain: Formatter"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/11676",
    "body": "**TypeScript Version:**  2.0.3\n\n**Expected behavior:**\n\n``` ts\nalert()!;\n```\n\n**Actual behavior:** \n\n``` ts\nalert() !;\n```\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/11676/comments",
    "author": "falsandtru",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2016-12-26T19:37:29Z",
        "body": "thanks @flowmemo!"
      }
    ]
  },
  {
    "number": 11660,
    "title": "erroneously error: Block-scoped variable used before its declaration",
    "created_at": "2016-10-15T10:26:06Z",
    "closed_at": "2016-10-19T20:07:49Z",
    "labels": [
      "Bug",
      "Fixed",
      "Help Wanted"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/11660",
    "body": "**TypeScript Version:**  2.0.5 \n\n**Code**\n\n``` ts\n// A.ts\nnamespace ts {\n    export function printVersion():void {\n        console.log(\"Version: \" + sys.version);\n    }\n}\n\n// B.ts\nnamespace ts {\n    export let sys:{version:string} = {version: \"2.0.5\"};\n    ts.printVersion();\n}\n\n// tsconfig.json\n{\n  \"compilerOptions\": {\n    \"target\": \"es5\",\n    \"outFile\" : \"test.js\"\n  },\n  \"files\": [\n    \"A.ts\",\n    \"B.ts\"\n  ]\n}\n```\n\nWhen I try to compile these two simple files (A.ts and B.ts) into one test.js file. The compiler reports an error: \n\n```\nA.ts(4,35): error TS2448: Block-scoped variable 'sys' used before its declaration.\n```\n\nBut if I merge these two files into one like this:\n\n```\n// Single.ts\nnamespace ts {\n    export function printVersion():void {\n        console.log(\"Version: \" + sys.version);\n    }\n    export let sys:{version:string} = {version: \"2.0.5\"};\n    ts.printVersion();\n}\n```\n\nThe compiler does not report this error.\n\nObviously the usage of `sys.version` is deferred, because it is inside a function. So it should be legal even if the usage and declaration are in separate files. Then I checked the source code of TypeScript, I think the code that caused this problem might be here:\n\nsrc/compiler/checker.ts line:585\n\n```\n function isBlockScopedNameDeclaredBeforeUse(declaration: Declaration, usage: Node): boolean {\n            const declarationFile = getSourceFileOfNode(declaration);\n            const useFile = getSourceFileOfNode(usage);\n            if (declarationFile !== useFile) {\n                if ((modulekind && (declarationFile.externalModuleIndicator || useFile.externalModuleIndicator)) ||\n                    (!compilerOptions.outFile && !compilerOptions.out)) {\n                    // nodes are in different files and order cannot be determines\n                    return true;\n                }\n\n                const sourceFiles = host.getSourceFiles();\n                return indexOf(sourceFiles, declarationFile) <= indexOf(sourceFiles, useFile);\n            }\n\n            if (declaration.pos <= usage.pos) {\n                // declaration is before usage\n                // still might be illegal if usage is in the initializer of the variable declaration\n                return declaration.kind !== SyntaxKind.VariableDeclaration ||\n                    !isImmediatelyUsedInInitializerOfBlockScopedVariable(<VariableDeclaration>declaration, usage);\n            }\n\n            // declaration is after usage\n            // can be legal if usage is deferred (i.e. inside function or in initializer of instance property)\n            return isUsedInFunctionOrNonStaticProperty(declaration, usage);\n}\n```\n\nIn the `isBlockScopedNameDeclaredBeforeUse`  function , if the `declarationFile`  and `useFile` are not the same,  it forgets to check whether the usage is deferred.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/11660/comments",
    "author": "domchen",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2016-10-17T22:41:12Z",
        "body": "we should call `isUsedInFunctionOrNonStaticProperty` in the `--out`/`--outFile` branch as well.\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2016-10-17T22:41:32Z",
        "body": "@domchen a PR would be appreciated since you debugged through this.\n"
      },
      {
        "user": "domchen",
        "created_at": "2016-10-18T02:43:44Z",
        "body": "@mhegazy No problem，I will create a pull request for this later.  :D\n"
      },
      {
        "user": "domchen",
        "created_at": "2016-10-18T03:52:06Z",
        "body": "@mhegazy I have sent you a pull request. Should I close this issue or wait for you to close it?\n"
      }
    ]
  },
  {
    "number": 11480,
    "title": "Deleting from readonly dictionary does not give a type error",
    "created_at": "2016-10-10T08:38:34Z",
    "closed_at": "2016-12-26T18:35:06Z",
    "labels": [
      "Suggestion",
      "Fixed",
      "Breaking Change",
      "Help Wanted"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/11480",
    "body": "**TypeScript Version:**  2.0.0, 2.0.3, nightly (2.1.0-dev.20161010)\n\n**Code**\n\n``` ts\n// A *self-contained* demonstration of the problem follows...\n'use strict';\n\ninterface X { readonly [key: string]: string }\n\nconst x: X = Object.freeze({\n    \"a\": \"A\",\n    \"b\": \"B\",\n    \"c\": \"C\"\n});\n\n// Error: TS2450: Left-hand side of assignment expression cannot be a constant or a read-only property.\nx[\"a\"] = \"B\";\n\n// No error - but runtime exception\n// TypeError: Cannot assign to read only property 'a' of object '#<Object>'\ndelete x[\"a\"];\n```\n\n**Expected behavior:**\n`delete x[\"a\"];` should give a compile-time error (as it predictably leads to a runtime error later on).\n\n**Actual behavior:** \nNo compile-time error is given.\n\n**Design Limitation (?)**\nI understand that this may be a design limitation as in #11180, in this case, this is another vote for the --strictReadonlyChecks flag discussed in #11180.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/11480/comments",
    "author": "paulkoerbitz",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2016-10-10T17:53:09Z",
        "body": "Seems reasonable to disallow `delete` operator on any `readonly` property or index signature\n"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2016-10-31T22:20:39Z",
        "body": "Approved for PRs. Shouldn't be too complex.\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2016-12-26T18:35:33Z",
        "body": "thanks @HerringtonDarkholme !"
      }
    ]
  },
  {
    "number": 11463,
    "title": "Suggestion: Let null assertion (`!`) operator block \"used before assigned\" errors",
    "created_at": "2016-10-08T15:12:41Z",
    "closed_at": "2017-05-23T21:13:33Z",
    "labels": [
      "Suggestion",
      "Fixed",
      "Help Wanted"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/11463",
    "body": "**TypeScript Version:**  nightly (2.1.0-dev.20161008)\n\n**Code**\n\n(Compile with `--strictNullChecks`)\n\n``` ts\nlet n: number\ndoit(() => {\n    n = 0\n})\nn! + 1\n\nfunction doit(action) { action() }\n```\n\n**Expected behavior:**\n\nNo error\n\n**Actual behavior:** \n\n`a.ts(5,1): error TS2454: Variable 'n' is used before being assigned.`\n\nThe problem is fixed by using `let n: number | undefined`,  but it's not obvious that that's the solution, and it would be intuitive for the `!` operator to work in this situation.\n\nAside: I don't see the `!` operator documented in the handbook.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/11463/comments",
    "author": "ghost",
    "comments": [
      {
        "user": "kitsonk",
        "created_at": "2016-10-09T07:22:39Z",
        "body": "Yes, some solution to immediately invoked callbacks would be great.  @novemberborn and others have had issues trying to convert a `Promise` into a deferral and we have had to actually assign noop functions to values to work around the CFA.  For example:\n\n``` typescript\nconst noop = () => { };\n\nfunction createDeferral() {\n    let complete = noop;\n    let cancel = noop;\n    const promise = new Promise<void>((resolve, reject) => {\n        complete = resolve;\n        cancel = reject;\n    });\n\n    return { complete, cancel, promise };\n}\n\nconst deferral = createDeferral();\n```\n\nWhich sort of seems silly.  I assume we would rewrite it as this with this proposal:\n\n``` typescript\nfunction createDeferral() {\n    let complete: () => void;\n    let cancel: () => void;\n    const promise = new Promise<void>((resolve, reject) => {\n        complete = resolve;\n        cancel = reject;\n    });\n\n    return { complete!, cancel!, promise };\n}\n\nconst deferral = createDeferral();\n```\n\nI also second the \"undocumented\" nature of `!`.  Several of the team found it by accident by searching issues.\n"
      },
      {
        "user": "kitsonk",
        "created_at": "2016-10-11T06:41:29Z",
        "body": "As I mentioned in #11498 I am more supportive of an annotation that indicates that the function is immediately invoked than this solution.\n"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2016-10-31T22:16:06Z",
        "body": "Approved since \"not assigned yet\" is really the same thing as \"still has `undefined` in its domain\"\n"
      }
    ]
  },
  {
    "number": 11298,
    "title": "Octal literals for enum members treated as decimal",
    "created_at": "2016-10-01T11:59:38Z",
    "closed_at": "2016-12-22T18:00:33Z",
    "labels": [
      "Bug",
      "Fixed",
      "Breaking Change",
      "Help Wanted"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/11298",
    "body": "**TypeScript Version:**  2.0.3\n\n**Code**\n\n``` ts\nenum X { A = 010 }\nconsole.log(X.A === 010);\n```\n\n**Expected behavior:**\n\nPrints `true` – `010` is an octal literal, both inside and outside an enum declaration.\n\n**Actual behavior:** \n\nPrints `false`: In the enum declaration, `010` is understood as `10`. This is because `evalConstant` in `src/compiler/checker.ts` parses the expression with\n\n``` ts\ncase SyntaxKind.NumericLiteral:\n    return +(<NumericLiteral>e).text;\n```\n\nand while `+010` is 8, `+\"010\"` is 10.\n\nIt’s possible that this behavior is already being used by some to zero-pad enum literal values (though padding is probably more useful for hexadecimal literals), and so it might be a good idea to treat this as an undocumented feature instead of a bug, and to “fix” it by documenting this behavior in the language specification (under 9.2 Enum Members, in the **_constant enum members**_ definition).\n\nThis is similar to #10101, but I think it’s a different bug.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/11298/comments",
    "author": "lucaswerkmeister",
    "comments": [
      {
        "user": "DanielRosenwasser",
        "created_at": "2016-10-01T18:56:38Z",
        "body": "In the same spirit of my comment in #10101, I'm not even sure if we should allow octal literals in enums either.\n"
      },
      {
        "user": "arusakov",
        "created_at": "2016-12-20T15:39:05Z",
        "body": "@DanielRosenwasser \r\nDo we disallow old style octal literals in enums? I can take it to work."
      },
      {
        "user": "mhegazy",
        "created_at": "2016-12-22T18:00:54Z",
        "body": "thanks @arusakov !"
      }
    ]
  },
  {
    "number": 11205,
    "title": "Union Type made of two types of arrays fails to provide all array's methods",
    "created_at": "2016-09-28T09:05:56Z",
    "closed_at": "2016-12-30T22:28:16Z",
    "labels": [
      "Bug",
      "Fixed",
      "Help Wanted",
      "Domain: lib.d.ts"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/11205",
    "body": "**TypeScript Version:**  1.8.0 / TypeScript playground\n\n**Code**\n\n``` ts\nlet x1: number[];\nlet x2: number[][];\nx1.splice(1, 1); // OK\nx2.splice(1, 1); // OK\nlet x: number[] | number[][];\nx.splice(1, 1); // Error: Supplied parameters do not match any signature of call target.\n```\n\n**Expected behavior:**\nTS tutorial states: \n\n>  If we have a value that has a union type, we can only access members that are common to all types in the union.\n\nSince both `x1: number[];` and `x2: number[][]` have `splice` method with two params, I expect the union of these two types also to have this method.\n\n**Actual behavior:** \nCompiler reports an error:  Supplied parameters do not match any signature of call target. However, it allows using another overload of `splice` function:\n\n``` ts\nlet x: number[] | number[][];\nx.splice(1); // OK\n```\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/11205/comments",
    "author": "OleksandrNechai",
    "comments": [
      {
        "user": "OleksandrNechai",
        "created_at": "2016-09-28T09:44:34Z",
        "body": "It is probably same issue as #10620 \n"
      },
      {
        "user": "kitsonk",
        "created_at": "2016-09-28T09:54:10Z",
        "body": "Yes, essentially it is the same, the subtle difference is that when matching the signature, it is matching one that it cannot union the overload:\n\n``` typescript\ninterface Array<T> {\n    splice(start: number): T[];\n    splice(start: number, deleteCount: number, ...items: T[]): T[];\n}\n```\n\nIt cannot union the type of the `...items: T[]` argument, therefore it causes an error.  Technically if there was anther overload, the code above would work, up until the point where you added arguments that you needed to insert:\n\n``` typescript\ninterface Array<T> {\n    splice(start: number): T[];\n    splice(start: number, deleteCount: number): T[];\n    splice(start: number, deleteCount: number, ...items: T[]): T[];\n}\n```\n\nBut it is better to have `(number | number[])[]` in the first place as mentioned in the issue you referenced.\n"
      },
      {
        "user": "OleksandrNechai",
        "created_at": "2016-09-28T10:46:13Z",
        "body": "> But it is better to have  (number | number[])[]  in the first place\n\nWell, then this code does not compile:\n\n``` ts\nlet x: (string[] | number[])[]\nx.forEach(e => e.splice(1, 1)); // The same error\n```\n\nUnfortunately I have both cases in my code. Whatever way I choose to describe my types I get this error :-(.\n"
      },
      {
        "user": "kitsonk",
        "created_at": "2016-09-28T12:41:15Z",
        "body": "This will work, but I suspect this is not what you want:\n\n``` typescript\nlet x: (string | number)[][]\nx.forEach(e => e.splice(1, 1));\n```\n\nAs I suspect you want an array of array of all numbers or an array of arrays of all strings.\n\nThe other option would be to help TypeScript along:\n\n``` typescript\nlet x: (string[] | number[])[];\nx.forEach((e: any[]) => e.splice(1, 1));\n```\n"
      },
      {
        "user": "OleksandrNechai",
        "created_at": "2016-09-28T13:22:53Z",
        "body": "`x.forEach((e: any[]) => e.splice(1, 1));` is pretty neat! Thanks! \nI thought transition from C# would be much easier. TS turned out to be very different beast :-)\n"
      },
      {
        "user": "kitsonk",
        "created_at": "2016-09-28T14:34:47Z",
        "body": "> TS turned out to be very different beast\n\nYou can thank JavaScript for that...  Coming from JavaScript to TypeScript (my path) is like finally getting medication to treat your insanity.  Coming from C# must be like taking medical marijuana for the first time.  Please don't let TypeScript be a gateway drug to the acid trip that is JavaScript though.\n"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2016-09-28T16:38:37Z",
        "body": "I think we should rewrite the signatures to be\n\n```\ninterface Array<T> {\n    splice(start: number, deleteCount?: number): T[];\n    splice(start: number, deleteCount: number, ...items: T[]): T[];\n}\n```\n\nwith the observation that generic types should have signatures split according to their input use of their type parameters\n"
      }
    ]
  },
  {
    "number": 11096,
    "title": "Template string args don't resolve to correct overload",
    "created_at": "2016-09-23T15:35:26Z",
    "closed_at": "2017-10-26T17:12:04Z",
    "labels": [
      "Bug",
      "Fixed",
      "Help Wanted",
      "Effort: Moderate"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/11096",
    "body": "**TypeScript Version:**  1.8.0 / nightly (2.0.0-dev.201xxxxx)\n\n**Code**\n\n``` ts\nlet frame = 0;\nwindow.addEventListener(`keydown`, e => {\n  frame = e.which - 48;  // error: Property 'which' does not exist on type 'Event'\n}, false);\n```\n\n**Expected behavior:**\nIt should work like a string literal does and resolve to the correct overload.\n\n**Actual behavior:** \nIt doesn't resolve correctly so it type checks based on the most general overload.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/11096/comments",
    "author": "DaveBrue",
    "comments": [
      {
        "user": "DanielRosenwasser",
        "created_at": "2016-09-23T15:54:27Z",
        "body": "A while back I asked if no-substitution template strings should get the same treatment as regular strings. We opted not to, but I think seeing the way that JS users have been using them in lieu of standard string literals, we should consider this again.\n\nThis means (at least) that:\n- String literal-typed template strings need to be made a thing.\n- Computed property names need to work for templates.\n"
      },
      {
        "user": "Kingwl",
        "created_at": "2017-10-26T04:07:05Z",
        "body": "seems this issue has been resolved via latest version"
      }
    ]
  },
  {
    "number": 10967,
    "title": "tsc CLI: allow boolean options to have explicit false value",
    "created_at": "2016-09-17T16:39:21Z",
    "closed_at": "2016-10-24T17:45:14Z",
    "labels": [
      "Suggestion",
      "Fixed",
      "Help Wanted"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/10967",
    "body": "I have some .d.ts files referenced in the project (from Angular 2) which are not compatible with `--strictNullChecks`.\nI want to enforce strict nulls within my own project though. So I have `tsconfig.json` with `'strictNullChecks': true` specifically to direct my editor to underline these.\nIn our google-internal build system, we have our own tsc wrapper that does specific type-checks (and uses a different generated `tsconfig.json` so this all works fine in the build.\nBut, users benefit from being able to just run a vanilla `tsc` command on the command line to diagnose setup issues.\n\nSo, I'd like to be able to override any setting in the `tsconfig.json` with a command-line option. In some cases I can do so (eg `--target=es5` overrides `'target': 'es6'`) but with boolean options only the `true` value can be passed, eg `--strictNullChecks`\n\nI propose `--strictNullChecks=false` be accepted on CLI\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/10967/comments",
    "author": "alexeagle",
    "comments": [
      {
        "user": "evmar",
        "created_at": "2016-09-19T17:15:36Z",
        "body": "(In case anyone else is wondering, I checked the tsc source and it appears that there's no way of passing in false, such as `--noStrictNullChecks`.)\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2016-09-19T17:57:58Z",
        "body": "we can add a look-ahead for boolean-based flags, and consume the result iff it is `true`|`false`.\n"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2016-09-28T22:10:21Z",
        "body": "Accepting PRs for this\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2016-10-24T17:45:34Z",
        "body": "thanks @HerringtonDarkholme!\n"
      }
    ]
  },
  {
    "number": 10909,
    "title": "Filesystem race when creating directories",
    "created_at": "2016-09-14T07:10:02Z",
    "closed_at": "2024-03-08T00:03:14Z",
    "labels": [
      "Bug",
      "Help Wanted"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/10909",
    "body": "**TypeScript Version:**  1.8.10\n\nI'm using a makefile to build a largeish typescript project. Parallel build occasionally (randomly) fails with \n\n```\n$ make -j10\n[....]\nerror TS5033: Could not write file 'path/to/file.js': EEXIST: file already exists, mkdir 'path/to'\n```\n\nSerial build works fine, but is slow. Unfortunately its random so not that easy to debug.\n\nThis looks like the usual filesystem race condition to look out for:\n\n```\nif (!pathExists(path)) {\n    // Race condition in parallel processes\n    mkdir(path);\n}\n```\n\ninstead do the race-condition-free (asking for forgiveness)\n\n```\ntry {\n    mkdir(path);\n} catch (error) {\n    if (isEEXISTS(error)) {\n        // ignore, directory exists\n   } else {\n      raise error;\n  }\n}\n```\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/10909/comments",
    "author": "vbraun",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2016-09-14T18:00:08Z",
        "body": "This does not handle all the race conditions though, writing files is another one that happens frequently. but i suppose no harm in hardening the filesystem calls.\n"
      },
      {
        "user": "cguinnup",
        "created_at": "2016-11-21T17:28:12Z",
        "body": "Note that this occurs outside of parallel Typescript builds: It just occurred with my Gulp build, where the HTML file generator made the destination directory before Typescript.  Also using version 1.8.10"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2024-03-08T00:03:14Z",
        "body": "This is properly handled now\r\n```ts\r\n                    try {\r\n                        _fs.mkdirSync(directoryName);\r\n                    }\r\n                    catch (e) {\r\n                        if (e.code !== \"EEXIST\") {\r\n                            // Failed for some other reason (access denied?); still throw\r\n                            throw e;\r\n                        }\r\n                    }\r\n```"
      }
    ]
  },
  {
    "number": 10699,
    "title": "Fix PromiseConstructor interface",
    "created_at": "2016-09-04T08:34:43Z",
    "closed_at": "2019-10-01T20:45:40Z",
    "labels": [
      "Bug",
      "Help Wanted",
      "Domain: lib.d.ts"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/10699",
    "body": "**TypeScript Version:**  master\n\n``` diff\ninterface PromiseConstructor {\n-    reject(reason: any): Promise<never>;\n-    reject<T>(reason: any): Promise<T>;\n+    reject(reason?: any): Promise<never>;\n}\n```\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/10699/comments",
    "author": "falsandtru",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2016-09-06T19:40:02Z",
        "body": "The second overload is handy for casts. it does not get picked up aromatically, it is only used if someone passes an explicit type argument. so i would keep that. \n\nchanging the argument to be optional seems correct. a PR would be appreciated.\n"
      },
      {
        "user": "falsandtru",
        "created_at": "2016-09-06T21:13:59Z",
        "body": "`Promise.reject` never changes the contextual type of Promise. So I think the fix your thoughts would be this. However, it is buggy. Anyone cannot trust a `reason` parameter type. Do you really need that?\n\n``` diff\ninterface PromiseConstructor {\n-    reject(reason: any): Promise<never>;\n-    reject<T>(reason: any): Promise<T>;\n+    reject(reason?: any): Promise<never>;\n+    reject<T>(reason: T): Promise<never>;\n}\n```\n\nAdd:\n\nCould you accept the following fix?\n\n``` diff\ninterface PromiseConstructor {\n-    new <T>(executor: (resolve: (value?: T | PromiseLike<T>) => void, reject: (reason?: any) => void) => void): Promise<T>;\n+    new <T>(executor: (resolve: (value: T | PromiseLike<T>) => void, reject: (reason?: any) => void) => void): Promise<T>;\n}\n```\n\nfor the current strict typings of `Promise.resolve`.\n\n``` ts\n    resolve<T>(value: T | PromiseLike<T>): Promise<T>;\n    resolve(): Promise<void>;\n```\n"
      },
      {
        "user": "kitsonk",
        "created_at": "2016-09-06T21:47:07Z",
        "body": "The cast is useful if you had something like this:\n\n``` typescript\nfunction looksLikeAsync(): Promise<string> {\n    if (someCondition) {\n        return Promise.resolve('foo');\n    }\n    else {\n        return Promise.reject<string>(new Error('I hate kittens'));\n    }\n}\n\nlooksLikeAsync()\n    .then((str) => { /* do something */ }, (err) => { /* handle error */ });\n```\n\nPreviously though `Promise<void>` was not assignable to `Promise<string>` but `Promise<never>` is always assignable to `Promise<string>`, though I suspect changing the typing and taking away the generic would break other peoples code who previously had to cast before `never` was a thing.\n"
      },
      {
        "user": "falsandtru",
        "created_at": "2016-09-06T22:03:48Z",
        "body": "I believe its typing is verbose.\n"
      },
      {
        "user": "kitsonk",
        "created_at": "2016-09-06T22:10:12Z",
        "body": "> I believe its typing is verbose.\n\nBut it is the only way to accomplish the use case I provided.  There are other ways to cast, but I am fairly certain people have relied upon that and would be a breaking change.  Breaking other people's code for your personal sense of verbosity is cruel when it has no direct impact on your code or usage of TypeScript.\n"
      },
      {
        "user": "falsandtru",
        "created_at": "2016-09-06T23:19:02Z",
        "body": "For example, the following case returns the unexpected type. This is very bad.\n\n``` ts\n// An expected return type is Promise<void>, actually it returns Promise<string | void>\nfunction f() {\n  return Promise.resolve()\n    .then(() => Promise.resolve(), () => Promise.reject<string>(''));\n}\n```\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2016-09-06T23:24:21Z",
        "body": "you wrote `<string>`. not sure what you expected, and not sure what the compiler could have done to save you from your self, you could as easily write `<string>Promise.reject('')`\n"
      },
      {
        "user": "falsandtru",
        "created_at": "2016-09-06T23:33:03Z",
        "body": "`<string>Promise.reject('')` is not compilable. Can you provide the case your thoughts?\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2016-09-06T23:43:24Z",
        "body": "sorry, meant `Promise<string>`. so:\n\n``` ts\nfunction f() {\n    return Promise.resolve()\n        .then(() => Promise.resolve(), () => <Promise<string>>Promise.reject(''));\n}\n```\n\nis basically the same as:\n\n``` ts\n// An expected return type is Promise<void>, actually it returns Promise<string | void>\nfunction f() {\n  return Promise.resolve()\n    .then(() => Promise.resolve(), () => Promise.reject<string>(''));\n}\n```\n\nexcept that the later is easier to write and nicer to read.\n"
      },
      {
        "user": "falsandtru",
        "created_at": "2016-09-06T23:56:39Z",
        "body": "Why you make `Promise<string | void>`? Its type is wrong. I think TypeScript shouldn't provide the such way to make incorrect types. So `Promise.reject` should always return `Promise<never>` to make a correct type.\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2016-09-07T00:05:09Z",
        "body": "that is what `Promise.reject(value)` returns.\n\nif some one chose to pass an explicit type argument, e.g. `Promise.reject<any>(value)` i do not see why we should stop them. again this is identical to `<Promise<any>> Promise.reject(value)`, just easier to write.\n"
      },
      {
        "user": "falsandtru",
        "created_at": "2016-09-07T01:48:14Z",
        "body": "`<Promise<number>>Promise.reject(0)` and `<Promise<number>>Promise.resolve(0)` have different effects, but they have a same type. `<Promise<number>>Promise.reject(0)` never make `Promise<number>` by themselves.\n\n``` ts\nPromise.reject<string>(0)\n  .catch(() => <Promise<number>>Promise.resolve(0))\n  .then(n => console.log(n)); // 0\n\nPromise.reject<string>(0)\n  .catch(() => <Promise<number>>Promise.reject(0))\n  .then(n => console.log(n)); // Uncaught (in promise) 0\n```\n\nSo actually, your type casting means `<Promise<number>><Promise<never>>Promise.reject(0)`. So the minimum type of `Promise.reject(0)` is `Promise<never>`, `<Promise<number>>` is verbose and has no reason in that case. Signatures should defined by minimum types.\n\nWhy you need to make `Promise<T>` type by `Promise.reject<T>(reason: any)` even though `Promise<never>` can assign any other `Promise<T>`? And, why you need to hide that difference of effects? `Promise<never>` would help to know the actual behavior (effect). Standard definitions should help that standard understanding.\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2016-09-09T22:41:45Z",
        "body": "just to be clear, this bug is for marking the parameter as optional. removing the overload is not desired.\n"
      },
      {
        "user": "falsandtru",
        "created_at": "2016-09-09T23:04:01Z",
        "body": "i want to fix partially and quickly about agreed points. i don't need the complete consensus. can you?\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2016-09-09T23:07:30Z",
        "body": "not sure i understand what you mean.\n"
      },
      {
        "user": "falsandtru",
        "created_at": "2016-09-09T23:16:47Z",
        "body": "i want to modify the commit in #10819. so if you don't reopen that pr, i need to open the new pr.\n"
      },
      {
        "user": "jablko",
        "created_at": "2019-10-01T20:38:42Z",
        "body": "I believe this issue was fixed in #22772 and can now be closed?"
      },
      {
        "user": "falsandtru",
        "created_at": "2019-10-01T20:45:40Z",
        "body": "That PR is reverted but anyway the issue is fixed now."
      }
    ]
  },
  {
    "number": 10681,
    "title": "Formatting with method parameters",
    "created_at": "2016-09-02T11:37:11Z",
    "closed_at": "2018-11-09T23:34:17Z",
    "labels": [
      "Bug",
      "Fixed",
      "Help Wanted",
      "Domain: Formatter"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/10681",
    "body": "Should increase the indent level with parameters.\n\n**TypeScript Version:**  2.0-rc\n\n**Expected behavior:**\n\n``` ts\n[]\n  .reduce(\n    b => b,\n    0);\n```\n\n**Actual behavior:** \n\n``` ts\n[]\n  .reduce(\n  b => b,\n  0);\n```\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/10681/comments",
    "author": "falsandtru",
    "comments": [
      {
        "user": "DanielRosenwasser",
        "created_at": "2018-11-09T23:37:34Z",
        "body": "Thanks @saschanaz!"
      }
    ]
  },
  {
    "number": 10601,
    "title": "Misleading error TS2410",
    "created_at": "2016-08-30T04:23:06Z",
    "closed_at": "2016-09-29T17:33:55Z",
    "labels": [
      "Suggestion",
      "Fixed",
      "Help Wanted"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/10601",
    "body": "**TypeScript Version:**  nightly (2.1.0-dev.20160815)\n\n**Code**\n\n``` ts\n// NB: non-strict code, valid JavaScript\nvar dyn = { foo: 'bar' };\nwith (dyn) {/***/} // ERROR TS2410: All symbols within a 'with' block will be resolved to 'any'\n```\n\n**Expected behavior:**\n\nError message that says some thing like _\"with statement is not supported in TypeScript\"_\n\n**Actual behavior:** \n\nThe error as shown in the code above. What's confusing is that:\n- the error is attributed to the _argument_ of the `with` statement (not to the statement itself)\n- the 'error' is just a message saying that you'll lose typing within the block, which is a consequence of dynamic scoping, but not an error in itself.\n- there's no mention of an error or a fix, or that `with` is not supported in TypeScript.\n\nFrom this message, I got the impression there was some way of arranging the `with` statement or its argument to get it to compile. But I think there isn't.\n\nIf you are porting code to TypeScript and it contains `with` statements, the _only_ way you'll ever get an error-free build is when you remove _all_ the `with` statements. To me that means `with` statements are not supported in TypeScript, period. I think it would be clearer to just state that in the error message (perhaps with the current message as a secondary explanation).\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/10601/comments",
    "author": "yortus",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2016-08-31T23:21:48Z",
        "body": "We would be open to accept a PR with an enhancement to the message and the error span.\n"
      }
    ]
  },
  {
    "number": 10302,
    "title": "Allow access to protected class members if the 'this' type of an (extension) function is specified",
    "created_at": "2016-08-12T12:52:40Z",
    "closed_at": "2018-06-11T20:17:59Z",
    "labels": [
      "Suggestion",
      "Fixed",
      "Help Wanted",
      "Committed",
      "Effort: Difficult"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/10302",
    "body": "First of all: Please excuse me if this issue is a duplicate of some sort, but I've searched for quite some time for a similar issue or at least an answer to the following question/bug/proposal and found nothing.\n\nIf I specify that a function has a certain (customized) 'this' type I expect that the function has full access to protected or even private fields of passed instances. Reason being that due to JavaScripts dynamic nature and it's capability to overwrite the `this` pointer, a function that is freestanding can still act like an extension method to a class.\n\nBelow you can find a simple JavaScript-like style of extending a existing class, which fails in TypeScript, because it strictly forbids access to private and protected fields outside of the actual class:\n\n``` ts\nclass MyClass {\n    protected p: number;\n\n    constructor() {\n        this.p = 123;\n    }\n}\n\ninterface MyClass {\n    extension(p: number): void;\n}\n\nMyClass.prototype.extension = function (this: MyClass, p: number) {\n    // FAILS with:\n    //   error TS2445: Property 'p' is protected and only accessible within class 'MyClass' and its subclasses.\n    this.p = p;\n}\n\nconst instance = new MyClass();\ninstance.extension(456);\n```\n\nI realize that some kind of \"official\" class extension technique will get into TypeScript sooner or later, but all of the proposals I've seen extend the actual JavaScript language with new keywords. This question/bug/proposal here though, basically does exactly the same as the existing extension proposals but within the boundaries of the JavaScript language (apart from the existing language extensions for the type checker).\n\nI thus humbly suggest to loosen this strict access control and allow us to write extension methods to at least some extend before v2.0 is finally released.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/10302/comments",
    "author": "lhecker",
    "comments": [
      {
        "user": "zpdDG4gta8XKpMCd",
        "created_at": "2016-08-15T13:03:24Z",
        "body": "thumb down: this undermines the purpose of `private` as a way to hide the internal state\n"
      },
      {
        "user": "lhecker",
        "created_at": "2016-08-15T13:44:20Z",
        "body": "@aleksey-bykov If your current function has access using `this` to an instance shouldn't you consider that function an extension of the class itself? I mean: I'm well aware that this can undermine the isolation of members when using functions like `.map` or `.forEach`, but usually the only time in JavaScript where you explicitly override the `this` reference is when you want to extend something - usually even in the way my example showed above. At least I can't remember the last time I overrode the `this` reference just for the heck of accessing private members. Would anyone else do it?\n\nAs another point: There is also an escape hatch for type casting in TypeScript by casting something to `any` - that undermines `private` in the exact same way (just much less comfortably).\n\nSo yeah: I personally consider every function whose `this` type is a class an extension of that class. JavaScript's dynamic nature allows us to do so to write compact code, so why forbid it? Maybe I'm wrong but right now I believe the advantage for having the above would be far greater than the cost of it.\n"
      },
      {
        "user": "zpdDG4gta8XKpMCd",
        "created_at": "2016-08-15T13:50:38Z",
        "body": "why do we need `private` if it doesn't protect your internal state?\n\nwhat you are suggesting is that any 3rd party code can inject some logic into your class and feel like home there\n\n`public` and `protected` members is the answer to your question, if you meant something to be seen to 3rd party code then you make it either `public` or `protected`, the `private` modifier is for your eyes only\n"
      },
      {
        "user": "lhecker",
        "created_at": "2016-08-15T14:12:38Z",
        "body": "> what you are suggesting is that any 3rd party code can inject some logic into your class and feel like home there\n\nWell first of all that's already possible since `private` is only a TypeScript-specific annotation, but does not affect actual visibility of object fields, which makes this argument kinda moot. If you're talking about directly integrating 3rd party code into your actual local project, then yeah: That would be awesome! If I integrate such code in my project with the intention of e.g. extending my class I want my class to be extended.\n\n> `public` and `protected` members is the answer to your question\n\n`protected` is the same as `private` in this case, because you can't access `protected` members from outside of the class (or it's derivatives) either. If you keep in mind how deriving a class actually works in JavaScript, you'll see that there is basically no difference if 3rd party code derives the class. This means: No manual extension of the `prototype` (or having other freestanding functions), or generating member functions dynamically.\n\nJust take my use case: I have 2 classes for a certain parser. One of the central classes is about 4000 LOC. What I did is to split up the class in a \"core\" and multiple cleanly seperated extensions, but now I've got the problem that all members have to be public, or otherwise I can't access them without `<any>`. The second class is only 300 LOC, but if I'd replace my \"hacky\" function generator with regular member functions I'd easily end up with at least 10 times the code of which everything is redundant - just with slightly adjusted parameters. If this suggestion gets through I'd lose nothing while finally being able to replace those `<any>` hacks.\n"
      },
      {
        "user": "zpdDG4gta8XKpMCd",
        "created_at": "2016-08-15T14:26:03Z",
        "body": "so what? are you suggesting to legalize a hack (accessing a member which is not supposed to be accessed)\n\nthe fact that you still can do it from JavaScript is that TypeScript is ahead of what's coming next in ES2016, 2017 or whatever\n\nif the class is your own - you have it all  you don't need this hack\nif the class is of someone else - you have no business to see what's there, because it is not yours\n\n`protected` is not the same as private because protected members can be _legally_ accessed in a derived class \n\ni hear that you have problems with the size of your class, you options as always are:\n- composition: breaking down a single class into multiple smaller ones passing private state via constructors\n- IoC: when you can inject your extensions and push necessary private context into them via parameters\n"
      },
      {
        "user": "zpdDG4gta8XKpMCd",
        "created_at": "2016-08-15T14:36:32Z",
        "body": "``` typescript\n// composition\ninterface PrivateMatters { x: number }\nclass A {\n    constructor(\n         private state: PrivateMatters\n    ) {\n         this.b = new B(this.state);\n         this.c = new C();\n    }\n    public doThis() {\n         this.b.doThat(); // state is already in B\n         this.c.doThis(this.state);\n    }\n}\n\n// ioc\nclass A {\n    constructor(\n         private state: PrivateMatters\n    ) {\n    }\n    public legallyUsingPrivateState<r>(extension: (x: number) => r): r {\n         return extension(this.state.x);\n    }\n}\n\n```\n"
      },
      {
        "user": "lhecker",
        "created_at": "2016-08-15T14:49:10Z",
        "body": "> so what? are you suggesting to legalize a hack\n\nIt's not a hack because it would imply that you can do something that you couldn't do before. And yes I'm advocating for this obviously or why should I have created the issue then?\n\n> `protected` is not the same as private because protected members can be _legally_ accessed in a derived class \n\nWould you be more comfortable with the proposal if I'd edit the title to read `protected` instead of `private`?\n\n> i hear that you have problems with the size of your class\n\nYour `legallyUsingPrivateState` method is kinda bad, because it can be accessed by \"3rd party code\" to do anything with the private state. But okay... Let's assume that the method was a private one and that the `A` class always initiates the call to an extension: It still doesn't work for accessing private/protected member _functions_, which takes up the majority of my code (obviously). If you want to do that you'd have to make `PrivateMatters` a class and move those methods to it. What you might realize now is that you have the same situation as before: Your `PrivateMatters` is what `A` was before and your `A` class now is only a wrapper around `PrivateMatters` to protect it from unwanted access...\n\nIs it really so surreal to consider that there might be classes larger than a dozen LOC? Being able to split those up is one of the major benefits of extensions.\n"
      },
      {
        "user": "zpdDG4gta8XKpMCd",
        "created_at": "2016-08-15T15:08:19Z",
        "body": "it is a hack, because you cannot access a private member from outside of a class without waiving typechecking which is what TypeScript is for\n\nyes, protecteds would be a better fit for your proposal\n\nit's not bad as long as you\n1. guarantee read-only access (ok you know my internal state, so what?)\n2. do not allow extension to do direct uncontrolled writes to it however still permit it via taking the result of the extension and placing it into the private state:\n\n``` typescript\npublic legallyUsingPrivateState(extension: (x: number) => number): void {\n    const result = extension(this.state.x); // be aware of my private x if you can't help it\n    if (result > 0) { // let me check what you want to write back\n         this.state.x = result; \n    } \n}\n```\n\nnot being able to decompose a 4000 LOC class into smaller classes is a bad sign that your code is overlycoupled, you need to reconsider the design\n"
      },
      {
        "user": "lhecker",
        "created_at": "2016-08-15T15:42:15Z",
        "body": "The discussion right now is seriously drifting away from the original issue, which makes this my last comment about this.\n\n> 1. guarantee read-only access (ok you know my internal state, so what?)\n\nYou forgot about the member functions.\n\n> 1. do not allow extension to do direct uncontrolled writes to it\n\nWhat? Should I special-case every single access? The code size just doubled for no apparent reason. Or should I do the FP way, make the state object immutable and return a new one from the extension to diff it with the previous one? While that would certainly solve it I don't see how that would make it any better. Oh and runtime cost: It's a parser. Those have to fast. Deep comparisons and/or modification bookkeeping? Not fast.\n\n> not being able to decompose a 4000 class into smaller classes is a bad sign that your code is overlycoupled, you need to reconsider the design\n\nJust a minor nitpick: There are about 50 different packet types in my case and they all belong to the parser class. Even if you make a rough estimate and divide `4000 / 50` you only get about 80 LOC per \"sub-parser\" which isn't that surprising, isn't it? And it shouldn't be so surprising that I don't want to put all of that into a single file either.\n\nAnyways: You can't just split up some things into multiple classes without causing either a serious overhead, increased complexity, increased code size, and/or violation of some core principles like DRY. In fact I'd argue that my code is as little coupled as possible because every sub-parser is only depending on the core and on nothing else. What you probably suggest is that I should do some form of indirection between the \"core\" and the parts (like IoC using a seperate state object), which just doesn't solve the general problem at hand of having the capability to extend a class in a dynamic way, since this is a dynamic language.\n\nI'm interested if you can come up with a software pattern that doesn't require the main class to be wrapped for access control (which is pointless for a user-facing class, in a language which gets compiled to JS anyways), doesn't sacrifice performance and allows me to keep my code DRY in a situation where the main class is composited out of a large number of classes with shared state.\n\nDon't go around assuming that others don't know their craft.\n"
      },
      {
        "user": "zpdDG4gta8XKpMCd",
        "created_at": "2016-08-15T15:51:35Z",
        "body": "you can extend your class in a dynamic way as much as you want provided you do it via:\n- 1. public interfaces \n- 2. carefully guarded facilities over the internal state (as was shown)\n\nthere are languages like C# and Java where hacking it to the private state (although still possible) is a hands down bad practice no questions asked, and nevertheless people are still able to craft decent parsers without running into problems like yours\n\ni cannot give you a better advice without looking at the code\n\nbottom line, even if everything you said is true and there is simply no way better to do it, it's not a reason for a feature that everyone else can live without, bad luck\n"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2016-08-15T17:46:24Z",
        "body": "Allowing access to `private` is in direct contradiction to the dozens of bugs we've had requesting we emit (impossible) code to efficiently make `private` things truly inaccessible. `protected` makes a lot of sense, though.\n"
      },
      {
        "user": "lhecker",
        "created_at": "2016-08-15T17:53:19Z",
        "body": "@RyanCavanaugh Yup I edited the title and example already. I really agree that `protected` fits the narrative of an extension much better. I think if implemented it could solve most of the pain for the people in the other issues wishing for partial/extendable classes, while still being quite a minor change.\n"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2016-08-22T23:11:03Z",
        "body": ":+1: : treat functions annotated `(this: T ...) {` as if they were inside the lexical scope of `T`'s class declaration for the purposes of `protected` members\n"
      },
      {
        "user": "lhecker",
        "created_at": "2018-06-11T22:35:15Z",
        "body": "@Kingwl @mhegazy Thanks for tackling this issue. 🎉🎉🎉\r\nSadly I'm hardly ever writing TS anymore nowadays, but I'm so glad you could solve this for me (and others)! 🙂"
      }
    ]
  },
  {
    "number": 10256,
    "title": "Show some elaboration for property not existing in union type",
    "created_at": "2016-08-10T17:24:19Z",
    "closed_at": "2016-09-13T20:57:22Z",
    "labels": [
      "Suggestion",
      "Fixed",
      "Help Wanted",
      "Committed",
      "Effort: Moderate"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/10256",
    "body": "I have some code like this, except there are about a dozen types instead of just three:\n\n``` ts\ninterface Foo {\n  kind: \"foo\";\n  name: string;\n}\ninterface Bar {\n  kind: \"bar\";\n  name: string;\n}\ninterface Qua {\n  kind: \"qua\";\n  length: string;\n}\n\ntype FBQ = Foo | Bar | Qua;\nlet x: FBQ = <any>undefined;\nconsole.log(x.name);\n```\n\nThe error reported is\n\n```\na.ts(16,15): error TS2339: Property 'name' does not exist on type 'FBQ'.\n```\n\nThis is inactionable on a union type, especially when its consituents are hidden behind an alias. We should show something like\n\n```\na.ts(16,15): error TS2339: Property 'name' does not exist on type 'FBQ'.\n   Property 'name' does not exist on type 'Qua'\n```\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/10256/comments",
    "author": "RyanCavanaugh",
    "comments": [
      {
        "user": "yahiko00",
        "created_at": "2016-08-10T21:29:40Z",
        "body": "Yes please! More generally, there are some rooms to improvement in compiler error messages.\n"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2016-08-22T23:08:23Z",
        "body": "Accepting PRs / committed for 2.1. Show an elaboration for the first type lacking the property (for whatever definition of 'first' falls out of the implementation)\n"
      },
      {
        "user": "ojsheikh",
        "created_at": "2016-08-28T11:13:04Z",
        "body": "Should there also be an elaboration when one of the constituent types has the property marked as private or protected and we are in a public context? Currently the code:\n\n``` Typescript\nclass Default {\n    member: string;\n}\nclass Private {\n    private member: number;\n}\n\nvar DP: Default | Private;\nDP.member;\n```\n\ngives the error:\n\n```\ntest.ts(9,4): error TS2339: Property 'member' does not exist on type 'Default | Private'.\n```\n\nThis could perhaps be changed to:\n\n```\ntest.ts(9,4): error TS2339: Property 'member' does not exist on type 'Default | Private'.\n  Property 'member' is private and only accessible within class 'Private'.\n```\n\nI have adjusted `checkPropertyAccessExpressionOrQualifiedName` to show an elaboration when a subtype of a union lacks a property and will open a PR once I've finished adding tests. It should not be difficult to also show an elaboration when a subtype has the property marked under a stricter access qualifier.\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2016-09-13T20:57:36Z",
        "body": "thanks @oijazsh !\n"
      }
    ]
  },
  {
    "number": 10219,
    "title": "show a tooltips on closing braces",
    "created_at": "2016-08-09T08:28:10Z",
    "closed_at": "2024-08-14T20:40:02Z",
    "labels": [
      "Suggestion",
      "Help Wanted",
      "API"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/10219",
    "body": "a tooltip on a closing brace would be helpful displaying the line of the opening brace so that you see what it belongs too\n\n```\n                      }\n                 } // <-- tooltip: switch (state) {\n            }\n      }\n```\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/10219/comments",
    "author": "zpdDG4gta8XKpMCd",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2024-08-14T20:40:02Z",
        "body": "This is a VS Code feature now"
      }
    ]
  },
  {
    "number": 10101,
    "title": "Old-style octal literal types are treated as decimal literal types",
    "created_at": "2016-08-02T21:15:47Z",
    "closed_at": "2016-12-19T21:58:21Z",
    "labels": [
      "Bug",
      "Fixed",
      "Help Wanted",
      "Good First Issue"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/10101",
    "body": "``` ts\r\n// @target: es3\r\nconst i: 010 = 8;\r\n```\r\n\r\nActual:\r\n\r\n```ts\r\nconst i: 010 = 8;\r\n      ~\r\n      Error: Type '8' is not assignable to type '10';\r\n```\r\n\r\n\r\nExpected:\r\n\r\n```ts\r\nconst i: 010 = 8;\r\n         ~~~\r\n         Error: Octal literal types must use ES2015 syntax. Use the syntax '0o10'.\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/10101/comments",
    "author": "sandersn",
    "comments": [
      {
        "user": "DanielRosenwasser",
        "created_at": "2016-08-02T21:29:04Z",
        "body": "We should just disallow octal literal types.\n"
      },
      {
        "user": "kitsonk",
        "created_at": "2016-08-03T16:46:37Z",
        "body": "Old style octal literals are disallowed in strict mode anyways and aren't actually part of ES5, only supported by convention.\n\nI would assume ES6 octal literals (e.g. `0o010`) would be allowed?\n"
      },
      {
        "user": "arusakov",
        "created_at": "2016-12-03T21:32:41Z",
        "body": "TypeScript is supporting decimal, octal and hex literal types in the master now:\r\n```ts\r\n// all below are correct\r\nconst x: 255 = 255;\r\nconst z: 0o377 = 255;\r\nconst y: 0xFF = 255;\r\n```\r\n\r\nIf old style literal types are not allowed, issue can be closed."
      },
      {
        "user": "sandersn",
        "created_at": "2016-12-05T16:46:50Z",
        "body": "Old style literal types are still allowed with `\"target\": \"es3\"`, so the bug still exists there. I agree with Daniel that they should just be disallowed. The compiler should give an error \"Octal literal types must use ES2015 syntax. Use the syntax {0o000}\". Ideally, the number in braces should be the literal that caused the error translated to ES2015 syntax."
      }
    ]
  },
  {
    "number": 9947,
    "title": "Go to definition from new this",
    "created_at": "2016-07-26T10:27:46Z",
    "closed_at": "2016-10-25T09:47:54Z",
    "labels": [
      "Bug",
      "Fixed",
      "Help Wanted"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/9947",
    "body": "Since go to definition for super methods goes to the super methods. I expect \"new this\" should go to the super constructor(provided that there is no extending/overriding declaration):\n\n``` ts\nclass A {\n    /*to here*/constructor() {\n    }\n}\n\nclass B extends A {\n    static create() {\n        return new this/*from here*/; // Doesn't go anywhere\n    }\n}\n```\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/9947/comments",
    "author": "tinganho",
    "comments": [
      {
        "user": "arusakov",
        "created_at": "2016-10-25T00:45:33Z",
        "body": "In current `master` branch `go to definition` in this case just works. Cannot reproduce bug.\n"
      },
      {
        "user": "tinganho",
        "created_at": "2016-10-25T09:47:54Z",
        "body": "Confirmed it works now.\n"
      }
    ]
  },
  {
    "number": 9843,
    "title": "IScriptSnapshot getChangeRange should allow undefined return value",
    "created_at": "2016-07-20T17:04:15Z",
    "closed_at": "2016-07-21T05:22:35Z",
    "labels": [
      "Bug",
      "Fixed",
      "Help Wanted",
      "API"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/9843",
    "body": "**TypeScript Version:**  nightly\n\n**Expected behavior:**\nThe typescriptServices.d.ts file signature for getChangeRange in the IScriptSnapshot interface should allow implementations to return undefined - as mentioned in its accompanying comment:\n\n``` ts\ninterface IScriptSnapshot {\n       // [...omitted...]\n        /**\n         * Gets the TextChangeRange that describe how the text changed between this text and\n         * an older version.  This information is used by the incremental parser to determine\n         * what sections of the script need to be re-parsed.  'undefined' can be returned if the\n         * change range cannot be determined.  However, in that case, incremental parsing will\n         * not happen and the entire document will be re - parsed.\n         */\n        getChangeRange(oldSnapshot: IScriptSnapshot): TextChangeRange | undefined;\n\n       // [...omitted...]\n    }\n```\n\n**Actual behavior:** \nIt currently does not :-)\n\n``` ts\ninterface IScriptSnapshot {\n       // [...omitted...]\n        /**\n         * Gets the TextChangeRange that describe how the text changed between this text and\n         * an older version.  This information is used by the incremental parser to determine\n         * what sections of the script need to be re-parsed.  'undefined' can be returned if the\n         * change range cannot be determined.  However, in that case, incremental parsing will\n         * not happen and the entire document will be re - parsed.\n         */\n        getChangeRange(oldSnapshot: IScriptSnapshot): TextChangeRange;\n\n       // [...omitted...]\n    }\n```\n\nI may be missing something however so apologies if I'm off the mark here!\n\nCheers.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/9843/comments",
    "author": "cgauld",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2016-07-21T00:22:05Z",
        "body": "Feel free to send a PR to update the declaration.\n"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2016-07-21T05:23:01Z",
        "body": ":+1: @HerringtonDarkholme \n"
      }
    ]
  },
  {
    "number": 9744,
    "title": "This type parsing error and incorrect type inference",
    "created_at": "2016-07-14T17:41:33Z",
    "closed_at": "2018-07-24T22:08:26Z",
    "labels": [
      "Bug",
      "Fixed",
      "Help Wanted",
      "Domain: Error Messages"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/9744",
    "body": "**TypeScript Version:**  2.0.0 (I suppose beta, though tsc -v just reports 2.0.0)\n\n**Code**\n\n``` ts\nfunction test(e: HTMLElement): void {\n    e.onclick = (this: HTMLElement, event) => { }; // error TS1005: ')' expected.\n                                                   // error TS1005: ';' expected.\n                                                   // error TS1128: Declaration or statement expected.\n\n    e.onclick = function(this: HTMLElement, event) { }; // error TS7006: Parameter 'event' implicitly has an 'any' type\n}\n```\n\n**Expected behavior:**\n1st: no parsing error.\n2nd: event: MouseEvent inference, as for `e.onclick = function(event) { };`\n\n**Actual behavior:** \n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/9744/comments",
    "author": "stephanedr",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2016-07-14T18:01:17Z",
        "body": "This is still going to be an error because it doesn't make sense for an arrow function to specify its `this` parameter (it gets the outer `this`), but we should give a semantic error instead of a parse error\n"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2016-07-14T18:03:32Z",
        "body": "Regarding the second thing, this is because we don't contextually type parameters when _any_ parameter has a type annotation. There's a bug on that somewhere but I can't find it at the moment; we should revisit it (if it's closed) at the very least for the case where the only annotated parameter is the `this` the parameter\n\nEdit: #4241\n"
      },
      {
        "user": "mattmccutchen",
        "created_at": "2018-07-22T21:34:17Z",
        "body": "Let me add on to this issue (it doesn't seem worth filing another): a `this` parameter on a generic arrow function parses but has no effect:\r\n```ts\r\nlet f = <T>(this: number) => {  // no error\r\n    let that = this;  // resolved the same way as if `this: number` were not specified;\r\n                      // may be an error depending on context and compiler options\r\n};\r\n```"
      },
      {
        "user": "mattmccutchen",
        "created_at": "2018-07-22T22:28:22Z",
        "body": "Fix is up at #25863."
      },
      {
        "user": "mhegazy",
        "created_at": "2018-07-24T22:08:46Z",
        "body": "thanks @mattmccutchen! "
      }
    ]
  },
  {
    "number": 9362,
    "title": "Format spaces between JSX attributes",
    "created_at": "2016-06-26T06:21:59Z",
    "closed_at": "2016-08-01T22:50:43Z",
    "labels": [
      "Bug",
      "Fixed",
      "Help Wanted",
      "Domain: Formatter"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/9362",
    "body": "**TypeScript Version:** The master branch as of ac6224d600ceeaca02dad0890b776e004d462e8b\n\n**Code**\n\n``` tsx\n// A self-contained demonstration of the problem follows...\n<Router       routes={3}        />;\n```\n\n**Expected behavior:**\n\n``` tsx\n<Router routes={3} />;\n```\n\n**Actual behavior:** \n\n``` tsx\n<Router       routes={3}        />;\n```\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/9362/comments",
    "author": "saschanaz",
    "comments": [
      {
        "user": "SoundBot",
        "created_at": "2016-06-28T04:03:35Z",
        "body": "I cannot reproduce it, maybe it was fixed.\n\ntest.tsx:\n\n```\n<Router       routes={3}        />;\n```\n\n`node built/local/tsc.js test.tsx --jsx preserve` gives me\n\n```\n<Router routes={3}/>;\n```\n"
      },
      {
        "user": "saschanaz",
        "created_at": "2016-06-28T04:14:09Z",
        "body": "@SoundBot It's not about compiler but about formatter. Control+K+D on VS or Alt+Shift+F on VSCode.\n"
      }
    ]
  },
  {
    "number": 9230,
    "title": "Prevent access to abstract properties in the constructor",
    "created_at": "2016-06-17T16:44:45Z",
    "closed_at": "2017-10-09T20:21:34Z",
    "labels": [
      "Bug",
      "Fixed",
      "Breaking Change",
      "Help Wanted",
      "Effort: Moderate"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/9230",
    "body": "**TypeScript Version:** \n\nnightly (and earlier)\n\n**Code**\n\n``` ts\nabstract class AbstractClass {\n    constructor(s: string) {\n        this.m(parseInt(s));\n        console.log(this.n);\n        this.n = 12;\n    }\n\n    abstract n: number;\n\n    abstract m(n: number): void;\n    m2() {\n        console.log(this.n);\n    }\n}\n```\n\n**Expected behavior:**\n\nErrors for each access and assignment of `this.n` in the constructor of the abstract property.\n\n**Actual behavior:** \nNo errors\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/9230/comments",
    "author": "sandersn",
    "comments": [
      {
        "user": "charlespierce",
        "created_at": "2017-10-07T02:56:53Z",
        "body": "PR #19005 opened to resolve this issue."
      }
    ]
  },
  {
    "number": 9133,
    "title": "TSServer should warn about supicious project setups",
    "created_at": "2016-06-13T15:06:20Z",
    "closed_at": "2018-07-17T22:19:37Z",
    "labels": [
      "Suggestion",
      "Help Wanted",
      "API",
      "VS Code Tracked"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/9133",
    "body": "**TypeScript Version:** \n\n1.8.x\n\nThe tsserver should warn when a file ends up in a virtual project although inside the workspace there is a tsconfig.json file that would cover the file but doesn't include it. This points very likely to a misconfigured project. The diagnostic maker is best generated on a file opened from the virtual project.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/9133/comments",
    "author": "dbaeumer",
    "comments": [
      {
        "user": "mjbvz",
        "created_at": "2018-07-17T22:19:37Z",
        "body": "Closing as I have not seen recent reports of this causing confusion"
      }
    ]
  },
  {
    "number": 9118,
    "title": "Format Code should not change indentation of function parameters",
    "created_at": "2016-06-13T06:49:22Z",
    "closed_at": "2016-08-18T00:15:38Z",
    "labels": [
      "Bug",
      "Duplicate",
      "Help Wanted",
      "Domain: Formatter"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/9118",
    "body": "_From @andregs on June 10, 2016 19:4_\n- VSCode Version: 1.2.0\n- OS Version: Win 10 Pro Version 1511\n\nSteps to Reproduce:\n1.  Write this code:\n\n```\n    Observable.of(this.currentTask)\n        .filter(_key => _key !== undefined)\n        .flatMap(_key => this.taskService.getTask(_key))\n        .subscribe(\n            task => {\n                this.task = task;\n                this.loading = false;\n            },\n            error => console.error(error)\n        );\n```\n1. Press `shift+alt+f` (format code)\n2. VSCode will change indentation to:\n\n```\n    Observable.of(this.currentTask)\n        .filter(_key => _key !== undefined)\n        .flatMap(_key => this.taskService.getTask(_key))\n        .subscribe(\n        task => {\n            this.task = task;\n            this.loading = false;\n        },\n        error => console.error(error)\n        );\n```\n\n_Copied from original issue: Microsoft/vscode#7545_\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/9118/comments",
    "author": "dbaeumer",
    "comments": [
      {
        "user": "dbaeumer",
        "created_at": "2016-06-13T06:49:23Z",
        "body": "The formatter is maintained by the TypeScript team. Moving.\n"
      },
      {
        "user": "saschanaz",
        "created_at": "2016-06-25T09:03:09Z",
        "body": "I think this is a duplicate of #6320.\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2016-08-18T00:15:48Z",
        "body": "closing in favor of #6320.\n"
      }
    ]
  },
  {
    "number": 8872,
    "title": "Type definition for Object.create ",
    "created_at": "2016-05-27T23:13:37Z",
    "closed_at": "2016-06-06T17:35:31Z",
    "labels": [
      "Suggestion",
      "Help Wanted",
      "Domain: lib.d.ts"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/8872",
    "body": "Is there a reason why in `lib.d.ts`, `Object.create` is defined as following:\n\n``` typescript\ncreate(o: any, properties?: PropertyDescriptorMap): any;\n```\n\nand not as following\n\n``` typescript\ncreate<T>(o: T): T;\ncreate(o: any, properties: PropertyDescriptorMap): any;\n```\n\n?\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/8872/comments",
    "author": "thorn0",
    "comments": [
      {
        "user": "basarat",
        "created_at": "2016-05-29T21:51:35Z",
        "body": "Generally one does `const someDict:{[key:string]:Something} = Object.create(null)` :rose:\n"
      },
      {
        "user": "thorn0",
        "created_at": "2016-05-29T22:07:23Z",
        "body": "The return type of `Object.create(null)` still would be `any` with my definition. Also it'd possible to write like this: `Object.create<{[key:string]:Something}>(null)`.\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2016-06-04T19:39:16Z",
        "body": "both these proposals will be an error with `--strictNullChecks` as `null` is not part of the domain of any type, except the type `null`.\n\ni would say a better definition would be:\n\n``` ts\ncreate(o: null): any;\ncreate<T>(o: T): T;\ncreate(o: any, properties: PropertyDescriptorMap): any;\n```\n"
      }
    ]
  },
  {
    "number": 8827,
    "title": "Give better message for rest parameter properties",
    "created_at": "2016-05-25T20:28:31Z",
    "closed_at": "2016-06-23T15:33:05Z",
    "labels": [
      "Bug",
      "Fixed",
      "Help Wanted",
      "Good First Issue",
      "Domain: Error Messages"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/8827",
    "body": "If I write the following code:\n\n``` ts\nclass C {\n    constructor(private ...x) {\n    }\n}\n```\n\nthen I get the error `',' expected.`.\n\nInstead, I should get an error like `A parameter property cannot be declared using a rest parameter.`\n\nAs motivation, for the following\n\n``` ts\nclass C {\n    constructor(private {x}) {\n    }\n}\n```\n\nwe currently give the error `A parameter property may not be a binding pattern.`\n\nAdditionally, in fixing this, the two should be consistent. Preferably, the new error for the latter should be `A parameter property may not be declared using a binding pattern.`\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/8827/comments",
    "author": "DanielRosenwasser",
    "comments": [
      {
        "user": "OrangeShark",
        "created_at": "2016-06-21T00:33:56Z",
        "body": "Hello, I am interested in working on this. I already had a chance to look through the code and I am wondering what would be the best way to approach this. Currently the error `',' expected.` is from the parser when trying to parse a parameter list and it considers `private` as a parameter, not a modifier to `...x` because `...` token is not allowed to follow a modifier token. Should this be changed to allow `...` to follow a modifier and then in the checker have the new error message created just like the binding pattern error mentioned above?\n"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2016-06-21T00:44:58Z",
        "body": "@OrangeShark yup, that sounds about right. I haven't been in the code recently, but if that's what we currently do for binding patterns, that's what we should probably do here.\n"
      }
    ]
  },
  {
    "number": 8742,
    "title": "tsc truncates type errors longer than 100 chars with triple-dots",
    "created_at": "2016-05-22T20:18:05Z",
    "closed_at": "2017-10-02T11:59:53Z",
    "labels": [
      "Suggestion",
      "Help Wanted"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/8742",
    "body": "I'd like to see the entire error message.\n\nIn `tsc.js`:\n\n```\n        function typeToString(type, enclosingDeclaration, flags) {\n            var writer = ts.getSingleLineStringWriter();\n            getSymbolDisplayBuilder().buildTypeDisplay(type, writer, enclosingDeclaration, flags);\n            var result = writer.string();\n            ts.releaseStringWriter(writer);\n            var maxLength = compilerOptions.noErrorTruncation || flags & 4 ? undefined : 100;\n            if (maxLength && result.length >= maxLength) {\n                result = result.substr(0, maxLength - \"...\".length) + \"...\";\n            }\n            return result;\n        }\n```\n\nBut adding in `tsconfig.json`:\n\n```\n{\n  \"compilerOptions\": {\n    \"noErrorTruncation\": true\n  }\n}\n```\n\nhas no effect.\n\nIt seems that there's no other mention of that `noErrorTruncation` in the file -- I assume it's simply undefined (and I could also find no documentation about it).\n\nAdding to `ts.optionDeclarations` this entry:\n\n```\n        {\n            name: \"noErrorTruncation\",\n            type: \"boolean\"\n        },\n\n```\n\nmakes it work.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/8742/comments",
    "author": "nh2",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2016-05-23T16:59:58Z",
        "body": "noErrorTrunction was meant for the API users calling directly into the API with CompilerOptions object, e.g. IDE's, and not from the commandline. \nThe asumption is on the commandline no one wants to see the full error, as serlized types can be huge. \nSo can you elaborate on why this is needed? and would you use this all the time? do you use `--pretty` as well?\n"
      },
      {
        "user": "nh2",
        "created_at": "2016-05-23T17:32:51Z",
        "body": "@mhegazy I definitely want to see the full error. The types I'm using (provided by others, so I cannot change them easily) are very long, and typically contain the `... & type & type` unions I care about at the end. It's OK if the errors are shortened by default, but when trying to solve type errors like in my case, it can be really hard if you can only see the first 100 chars of a 200 char type.\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2016-05-23T17:35:39Z",
        "body": "A PR to add the compiler option would be appreciated.\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2016-05-23T17:36:01Z",
        "body": "so do you use an IDE? would getting the errors there be a better option?\n"
      },
      {
        "user": "nicksnyder",
        "created_at": "2017-04-27T17:12:02Z",
        "body": "@nh2 can you clarify how you worked around this? I have a similar error that I want to see the full error for."
      },
      {
        "user": "nicksnyder",
        "created_at": "2017-04-27T17:13:53Z",
        "body": "Oh, it looks like adding this to `tsconfig.json` works now\r\n\r\n```\r\n{\r\n  \"compilerOptions\": {\r\n    \"noErrorTruncation\": true\r\n  }\r\n}\r\n```\r\n\r\nI think this issue can be closed."
      },
      {
        "user": "another-guy",
        "created_at": "2017-10-02T05:15:44Z",
        "body": "@nicksnyder I confirm that the compiler option you mentioned is working for me too. I can't speak for @nh2 but IMO this issue is fixed in the compiler."
      },
      {
        "user": "nh2",
        "created_at": "2017-10-02T11:59:53Z",
        "body": "OK great, let's close this then -- we can reopen it if we find that something doesn't work yet."
      }
    ]
  },
  {
    "number": 8626,
    "title": "Incorrect error message for empty config files",
    "created_at": "2016-05-16T18:39:49Z",
    "closed_at": "2023-08-25T17:29:01Z",
    "labels": [
      "Bug",
      "Help Wanted"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/8626",
    "body": "Create an empty `tsconfig.json` and try compiling. You'll get:\n\n```\nerror TS6053: File 'C:/Users/Daniel/foo/tsconfig.json' not found.\n```\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/8626/comments",
    "author": "DanielRosenwasser",
    "comments": [
      {
        "user": "JoshuaKGoldberg",
        "created_at": "2021-02-24T08:35:55Z",
        "body": "This has since been \"fixed\" to output:\r\n\r\n```\r\nerror TS18003: No inputs were found in config file 'C:/Code/project/tsconfig.json'. Specified 'include' paths were '[\"**/*\"]' and 'exclude' paths were '[]'.\r\n```\r\n\r\nShould a blank `tsconfig.json` be an error message? I would think so. "
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2021-02-24T18:09:51Z",
        "body": "It seems like we treat an empty tsconfig as the same as `{ }` - i.e. if there's a .ts file in the same folder, we compile it. At this point this is \"fixed\" IMO since we can't take that behavior back now."
      },
      {
        "user": "Andarist",
        "created_at": "2023-08-25T08:07:31Z",
        "body": "As concluded by Ryan above - this is already fixed and can't be changed. cc @jakebailey "
      }
    ]
  },
  {
    "number": 8600,
    "title": "Avoid including 'index' (or equivalent) as part of module name during error reporting",
    "created_at": "2016-05-13T20:48:19Z",
    "closed_at": "2023-08-07T18:55:16Z",
    "labels": [
      "Bug",
      "Help Wanted",
      "Domain: Error Messages"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/8600",
    "body": "When we resolve an external module to a folder index file like `index.d.ts` (or through the `typing` field of `package.json`), we should not consider that `index` part to be part of the filename for the purposes of error reporting.\n\nFor example, we currently display\n\n> Module '\"c:/github/DefinitelyTyped/react-router/index\"' has no exported member 'LinkProps'.\n\nInstead it should be:\n\n> Module '\"c:/github/DefinitelyTyped/react-router\"' has no exported member 'LinkProps'.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/8600/comments",
    "author": "RyanCavanaugh",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2016-06-07T23:18:25Z",
        "body": "We can not store this not he sourceFile, since a sourceFile can be part of multiple programs in different ways. we can not just remove `index.d.ts` all the time (or may be we can?). so probably we should add a list of mappings in the program, and use that when reporting these errors.\n"
      },
      {
        "user": "Andarist",
        "created_at": "2023-08-05T22:40:09Z",
        "body": "I think this is already solved:\r\n```ts\r\n// @filename: ./nested/index.d.ts\r\nexport type A = 'A'\r\n\r\n// @filename: ./foo.ts\r\nimport { B } from './nested' // Module '\"./nested\"' has no exported member 'B'.ts(2305)\r\n```\r\n\r\ncc @jakebailey "
      }
    ]
  },
  {
    "number": 8407,
    "title": "Map constructor doesn't work with target ES5, lib ES6",
    "created_at": "2016-05-01T12:54:03Z",
    "closed_at": "2016-05-05T18:10:00Z",
    "labels": [
      "Bug",
      "Fixed",
      "Help Wanted",
      "Domain: lib.d.ts"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/8407",
    "body": "**TypeScript Version:** \n\n1.7.5 / 1.8.0-beta / nightly (1.9.0-dev.20160430)\n\n**Code**\n\n``` ts\nconst x = new Map([[\"a\", 1]]); // Error\nconst y = new Map<string, number>([[\"a\", 1]]); // Error\nconst z = new Map([<[string, number]>[\"a\", 1]]); // Works\n```\n\n``` json\n{\n    \"compilerOptions\": {\n        \"target\": \"es5\",\n        \"lib\": [\"es2016\"]\n    }\n}\n```\n\n**Expected behavior:**\nNo errors\n\n**Actual behavior:** \nErrors are reported on the first two lines:\n\n```\nArgument of type '(string | number)[][]' is not assignable to parameter of type 'Iterable<[{}, {}]>'. \nArgument of type '(string | number)[][]' is not assignable to parameter of type 'Iterable<[string, number]>'.\n```\n\nI think the reason is that the compiler doesn't use iterators to resolve the type arguments when the target is ES5. Adding an overload to the `Map` constructor, which takes an array of tuples instead of an iterator, would probably fix this. I'm not sure whether this happens on more locations though, if so it might be worth to pick up iterators in the compiler even when the target is ES5.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/8407/comments",
    "author": "ivogabe",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2016-05-01T18:22:53Z",
        "body": "Iterator support are not guaranteed to exist if target is not ES6, so i think the assumption we have today is accurate. I agree with your  proposal to add an array overload for `Map`, `WeakMap`, `Set` and `WeakSet`. A PR would be appreciated.\n"
      },
      {
        "user": "ivogabe",
        "created_at": "2016-05-02T18:11:38Z",
        "body": "I've opened PR #8422\n"
      },
      {
        "user": "ivogabe",
        "created_at": "2016-05-05T18:14:27Z",
        "body": "Thanks!\n"
      }
    ]
  },
  {
    "number": 8101,
    "title": "Function expression, which lacks return-type annotation, implicitly has an 'any' return type.",
    "created_at": "2016-04-14T20:22:26Z",
    "closed_at": "2016-05-17T20:26:21Z",
    "labels": [
      "Bug",
      "Help Wanted",
      "Domain: lib.d.ts",
      "Good First Issue"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/8101",
    "body": "Hi there...\n\nI am using TS version 1.7.4...\n\nall of a sudden I started getting the error:\n\n> Error TS7011  Function expression, which lacks return-type annotation, implicitly has an 'any' return type.\n\nthe offending line of code is:\n\n`setTimeout(() => this.alertMessage = null, 2000);`\n\nnot sure why it suddenly started happening... I have been running this version for a while now... anyway... I don't understand why I am getting this error... the field \"alertMessage\" is defined as such:\n\n`alertMessage: string;`\n\nI guess I am wondering why the compiler is inferring \"any\" instead of \"string\"\n\nThank you\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/8101/comments",
    "author": "giancarloa",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2016-04-14T20:30:13Z",
        "body": "The issue is that the type of an assignment expression is always the type of the right operand, which in this case is `null` (which is widened to an implicit `any`).\n\nWe should fix this by adding an overload to `setTimeout`\n\n``` ts\ndeclare function setTimeout(handler: (...args: any[]) => any, timeout: number): number;\n```\n"
      },
      {
        "user": "giancarloa",
        "created_at": "2016-04-14T20:33:54Z",
        "body": "@RyanCavanaugh ... thanks\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2016-05-16T18:01:42Z",
        "body": "should not the return type be `void`? the result is ignored by the caller.\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2016-05-16T18:04:02Z",
        "body": "i meant the return type of the call back, i.e.:\n\n``` ts\ndeclare function setTimeout(handler: (...args: any[]) => void, timeout: number): number;\n```\n"
      }
    ]
  },
  {
    "number": 7734,
    "title": "Editor: Excess or missing arguments in a function call highlight the whole call in red, including all anonymous function bodies",
    "created_at": "2016-03-30T16:48:13Z",
    "closed_at": "2023-11-29T23:06:44Z",
    "labels": [
      "Bug",
      "Help Wanted"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/7734",
    "body": "As a follow-up to #7703, I'm trying to investigate more scenarios where excessive editor error highlighting interferes with editing or renders it less convenient. Seems like many of these have to do with anonymous functions, as in many cases they are passed as function arguments, which are usually expected to be quite short. However in callback or promise heavy code they may end up to be very long and span multiple lines or even pages.\n\nAnother case I've found is when there are excess or missing arguments in a function call, though here it would highlight the whole function call expression, which would include all the bodies of all the anonymous functions passed as arguments, and may span as many lines or pages as the call would. \n\n_Edit: removed an incorrect example!_\n\n**Reduced test cases**\nThis one happens with the `function()` syntax as well:\n\nExcess arguments:\n\n``` ts\nfunction func(f: () => void) {\n}\n\nfunc(() => {\n    let x = 1;\n    return;\n}, 42);\n\nfunc(function () {\n    let x = 1;\n    return;\n}, 42);\n```\n\nMissing arguments:\n\n``` ts\nfunction func(f: () => void, n: number) {\n}\n\nfunc(() => {\n    let x = 1;\n    return;\n});\n\nfunc(function () {\n    let x = 1;\n    return;\n});\n```\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/7734/comments",
    "author": "malibuzios",
    "comments": [
      {
        "user": "DanielRosenwasser",
        "created_at": "2016-03-30T16:54:42Z",
        "body": "Perhaps this could be alleviated if we could accurately determine if a semantic error falls within a non-completed node. We have some logic for this.\n\nAlternatively, we could just highlight the called expression.\n"
      },
      {
        "user": "malibuzios",
        "created_at": "2016-03-30T16:57:08Z",
        "body": "@DanielRosenwasser \n\nI rechecked, my first example was wrong (edited later). The whole thing was marked in red only when the call expression was closed with a closing parentheses, but I would still say it looks a bit excessive, say when there are changes in the API then whole blocks or even pages would be marked in red.\n\n_Edit: I needed to remove the three dots! :)_\n"
      },
      {
        "user": "malibuzios",
        "created_at": "2016-03-30T17:12:15Z",
        "body": "First example was wrong, sorry about that (I removed it). I'll try to find better ones.\n\nIn any case if anyone knows of more these \"wall-of-red' scenarios then please mention. I feel the editing experience (which is already pretty good, but not as good as say, C#) would improve significantly without them.\n"
      },
      {
        "user": "malibuzios",
        "created_at": "2016-03-30T17:47:17Z",
        "body": "@DanielRosenwasser \n\nIn the case missing arguments there is a simple alternative, perhaps only highlight the closing parenthesis or the last line of the call expression?\n\n``` ts\nfunction func(f: () => void, n: number) {}\n\nfunc(() => {\n    let x = 1;\n    return;\n}); <--- only the parenthesis or line highlighted\n```\n\nThe case of excessive arguments is less \"obvious\", since it would seem natural to simply highlight the excessive arguments, but in case they are anonymous functions, they could span many lines or even several pages! Highlighting only the comma, after the last argument that is not excessive seems like a viable option, though may seem somewhat \"mild\" (I'm personally completely fine with \"milder\" highlighting though :) ):\n\n``` ts\nfunction func(f: () => void) {\n}\n\nfunc(() => {\n    let x = 1;\n    return;\n}, 42); <-- only the comma highlighted here\n```\n\n_Edit: perhaps highlight from the comma only to to the end of its containing line?_\n"
      },
      {
        "user": "Andarist",
        "created_at": "2023-01-08T08:43:42Z",
        "body": "The excess arguments case got improved over the years - the missing argument case still highlights the whole call expression but perhaps it could only highlight the callee."
      }
    ]
  },
  {
    "number": 7530,
    "title": "Incorrect error message with String Literal Types",
    "created_at": "2016-03-16T01:48:19Z",
    "closed_at": "2016-03-21T17:49:09Z",
    "labels": [
      "Bug",
      "Help Wanted",
      "Domain: Error Messages"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/7530",
    "body": "**TypeScript Version:** \n\n1.8.5\n\n**Code**\n\n``` ts\ndeclare type ConstrainedString = \"La première\" | \"La primera\" | \"The first\";\n\nfunction f(s : ConstrainedString) {\n    console.log(s);\n}\n\nf(\"La primera\");\nf(\"La première\");\nf(\"The first\");\n\n\nf(\"De eerste\"); // Error message is here, as expected.\n```\n\n**Expected behavior:**\n\nThe second sentence of the error message I see under Visual Studio Code doesn't seem to make sense, does it?\n`Argument of type '\"De eerste\"' is not assignable to parameter or type '\"La première\" | \"La primera\" | \"The first\"'. Type '\"De eerste\"' is not assignable to type \"The first\"'`\n\nI wonder if I should not rather open this under VS Code.\n\n**Actual behavior:** \nRemoving that second sentence?\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/7530/comments",
    "author": "yves-dolce",
    "comments": [
      {
        "user": "DanielRosenwasser",
        "created_at": "2016-03-16T08:27:55Z",
        "body": "Duplicate of #6541. Thanks for filing!\n"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2016-03-16T08:29:45Z",
        "body": "Actually, thinking about it more, I think we can potentially make some improvements independent of #6541. When the source is of a primitive or literal type, I don't necessarily see the point in diving into these elaborations. I'll look into it.\n"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2016-03-21T18:02:52Z",
        "body": "Fixed - thanks for suggesting that @yves-dolce! The fix will be in our nightly builds `\"tomorrow\" | \"mañana\" | \"demain\"`. :smile: \n"
      },
      {
        "user": "yves-dolce",
        "created_at": "2017-05-11T21:29:56Z",
        "body": "Just saw this, while watching Build 2017... :-)\r\nThanks for the follow up."
      }
    ]
  },
  {
    "number": 7434,
    "title": "Bug: emit of shorthand property is wrong with non-ES6 ModuleKind",
    "created_at": "2016-03-08T16:34:18Z",
    "closed_at": "2016-03-09T18:30:59Z",
    "labels": [
      "Bug",
      "Fixed",
      "Help Wanted"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/7434",
    "body": "**TypeScript Version:** \n1.8.7 / nightly (1.9.0-dev.20160217)\n\nI believe there is a logical error in `emitShorthandPropertyAssignment` in `emitter.ts`. When determining whether to emit a `: name` after a shorthand property, the code checks what the current `ModuleKind` is rather than what `ScriptTarget` we have.\n\nI believe the following change is required\n\n``` diff\n// A self-contained demonstration of the problem follows...\nfunction emitShorthandPropertyAssignment(node: ShorthandPropertyAssignment) {\n    // The name property of a short-hand property assignment is considered an expression position, so here\n    // we manually emit the identifier to avoid rewriting.\n    writeTextOfNode(currentText, node.name);\n    // If emitting pre-ES6 code, or if the name requires rewriting when resolved as an expression identifier,\n    // we emit a normal property assignment. For example:\n    //   module m {\n    //       export let y;\n    //   }\n    //   module m {\n    //       let obj = { y };\n    //   }\n    // Here we need to emit obj = { y : m.y } regardless of the output target.\n-    if (modulekind !== ModuleKind.ES6 || isNamespaceExportReference(node.name)) {\n+    if (languageVersion < ScriptTarget.ES6 || isNamespaceExportReference(node.name)) {\n        // Emit identifier as an identifier\n        write(\": \");\n        emit(node.name);\n    }\n\n    if (languageVersion >= ScriptTarget.ES6 && node.objectAssignmentInitializer) {\n        write(\" = \");\n        emit(node.objectAssignmentInitializer);\n    }\n}\n```\n\nFor example, when transpiling this with `tsc --module commonjs --target es6`\n\n``` ts\nexport const foo = { a, b };\n```\n\n**Expected behavior:**\n\n``` js\n\"use strict\";\nexports.foo = { a, b };\n```\n\n**Actual behavior:** \n\n``` js\n\"use strict\";\nexports.foo = { a: a, b: b };\n```\n\nThe same example with `tsc --module amd --target es6`\n**Expected behavior:**\n\n``` js\ndefine([\"require\", \"exports\"], function (require, exports) {\n    \"use strict\";\n    exports.foo = { a, b };\n});\n```\n\n**Actual behavior:** \n\n``` js\ndefine([\"require\", \"exports\"], function (require, exports) {\n    \"use strict\";\n    exports.foo = { a: a, b: b };\n});\n```\n\nSpecifically, I'm encountering this issue when using `transpileModule` with `ModuleKind.ES6` and `SourceTarget.ES5`. The suggested change should address both use-cases.\n\n**Expected behavior:**\n\n``` js\nexport var foo = { a: a, b: b };\n```\n\n**Actual behavior:** \n\n``` js\nexport var foo = { a, b };\n```\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/7434/comments",
    "author": "Victorystick",
    "comments": [
      {
        "user": "Victorystick",
        "created_at": "2016-03-08T17:07:32Z",
        "body": "I've tried to implement the changes, but I haven't been able to update the baseline tests successfully. I don't get any clear indication of why they're failing, nor can I try using `transpileModule` manually to verify that it works.\n\n```\nDebug Failure. False expression: Output generation failed\nError: Debug Failure. False expression: Output generation failed\n    at Object.assert (/Users/oskar/github/typescript/built/local/typescript.js:1612:23)\n    at Object.transpileModule (/Users/oskar/github/typescript/built/local/typescript.js:45683:18)\n    ...\n```\n\nI'll extend the necessary changes to this:\n\n``` diff\n-    if (modulekind !== ModuleKind.ES6 || isNamespaceExportReference(node.name)) {\n+    if (languageVersion < ScriptTarget.ES6 || (modulekind === ModuleKind.ES6 && isNamespaceExportReference(node.name))) {\n```\n\nWe ought to verify that `modulekind` is ES6 before checking whether the name is a namespace export reference.\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2016-03-08T18:39:06Z",
        "body": "i do not see the same error. making the change and running all tests for me produce one change in baselines in `tests/baselines/reference/shorthandPropertyAssignmentInES6Module.js` which is actually the correct output. how can i get the error you are seeing?\n"
      },
      {
        "user": "Victorystick",
        "created_at": "2016-03-09T09:16:05Z",
        "body": "@mhegazy Sorry about the confusing comment. I encountered the `Debug Failure` when I tried to use the locally generated `typescript.js` programatically. But never mind that.\n\nYes, I get the same error as you do. The baseline fails. I'd submit a PR for this myself, but I just don't know how to update/add new tests for this.\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2016-03-09T19:22:46Z",
        "body": "thanks @Victorystick!\n"
      }
    ]
  },
  {
    "number": 7397,
    "title": "noEmit should be allowed with outDir",
    "created_at": "2016-03-05T00:51:15Z",
    "closed_at": "2016-03-12T20:33:42Z",
    "labels": [
      "Bug",
      "Fixed",
      "Help Wanted"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/7397",
    "body": "And possibly with other `out` variations. Ideally, `noEmit` should have priority over output related options.\n\nReasoning: I have a syntax checking script that should not actually write files. My build script relies on `tsconfig.json` which has `outDir` compiler option set.\n\nSyntax check command: \n\n```\n> tsc --noEmit 2>&1 | pipe_it_somewhere_for_syntax_checking\n```\n\nBuild command:\n\n```\n> tsc\n```\n\ntsconfig.json\n\n```\n{\n   ...\n   \"outDir\": \"build/\"\n   ...\n}\n```\n\nError: `error TS5053: Option 'noEmit' cannot be specified with option 'outDir'.`\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/7397/comments",
    "author": "anilanar",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2016-03-05T01:16:03Z",
        "body": "Have you considered using `noEmitOnError`?\n"
      },
      {
        "user": "anilanar",
        "created_at": "2016-03-05T01:19:40Z",
        "body": "Yes. I don't want syntax checker to write files whether there are errors or not.\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2016-03-05T01:27:04Z",
        "body": "> I don't want syntax checker to write files whether there are errors or not.\n\nI am not sure i understood this statement. what is the \"syntax checker\" here? and who is writing the files?  is it tsc? or some other tool? when do you want them to be written? and when not?\n"
      },
      {
        "user": "anilanar",
        "created_at": "2016-03-05T01:49:55Z",
        "body": "Let's assume I'm the syntax checker, I'm the builder and there are no tools involved. \n\nTo compile, I just run `tsc`. It's done based on my config in tsconfig.json.\n\nIn addition, I want to see if there are any errors or not, without writing anything to the disk. So I run `tsc --noEmit`. It complains about `outDir` and `noEmit` not working together.\n\nObviously there are workarounds for this simple example. I can omit outDir from tsconfig.json, run `tsc --outDir 'path'` to compile and run `tsc --noEmit` to syntax check.\n\nIt feels intuitively better for `noEmit` to override output related compiler options instead of returning an error.\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2016-03-05T02:48:08Z",
        "body": "I do not disagree with the original suggestion; I am just wondering why run the compiler twice on the same set of sources?\n"
      },
      {
        "user": "kylecordes",
        "created_at": "2016-03-05T13:30:37Z",
        "body": "@mhegazy  I can't answer for the others, but for me this is because I might want to check from the command line that everything is good, but I in fact never use the output I create by running tsc; the actual work happens from (for example in some projects) webpack.  if I'm running a commandline check that all is well, there's no point in admitting output in any case, because it's going to get ignored anyway and recompiled when webpack run the TS compiler. You might wonder, why ever bother to compile from the command line, since I'm using a different tool to run the compiler for actual output anyway? Probably the same answer as Anil: for a reason, I occasionally want to check from the command line that I have a clean compile.\n"
      },
      {
        "user": "anilanar",
        "created_at": "2016-03-05T14:05:09Z",
        "body": "Another use case is for vim-syntastic. It's a linter tool for vim and supports multiple languages. It uses tsc for typescript by default. It's not supposed to compile and write files so it currently uses `noEmit` option. It breaks if there's a tsconfig.json with `out*` options.\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2016-03-05T19:10:26Z",
        "body": "Thanks for the details. PRs are welcomed. The change will be to remove the error check, do not think anything else is required.\n"
      }
    ]
  },
  {
    "number": 7227,
    "title": "Trivia emitted twice in arrow function",
    "created_at": "2016-02-24T21:39:02Z",
    "closed_at": "2016-09-13T22:15:00Z",
    "labels": [
      "Bug",
      "Fixed",
      "Help Wanted"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/7227",
    "body": "Split off from issue #6982.  In TypeScript 6b05ad7, which is master as of 19 Feb 2016.\n\nThis input:\n\n``` ts\nlet x =\n/* trivia */ () => 3;\n```\n\nproduces the comment twice, with output like:\n\n```\nvar x = \n/* trivia */ \n/* trivia */ function () { return 3; }\n```\n\nThe end of the call stack at the time of the second emit is (innermost function at the top):\n\n```\nemitFunctionDeclaration (emitter.ts:4537)\nemitJavaScriptWorker (emitter.ts:7898)\nemitNodeWithoutSourceMap (emitter.ts:7749)\nemitNodeWithSourceMap (emitter.ts:7742)\nemitNodeConsideringCommentsOption (emitter.ts:7731)\n```\n\n`emitNodeConsideringCommentsOption` calls `emitLeadingComments` once before calling `emitNodeWithSourceMap` (seen here), but then `emitFunctionDeclaration` (at the bottom of this stack) itself calls `emitLeadingComments` again on the same node.\n\nThe code in `emitFunctionDeclaration` appears to try to defend against this double-emitting but gets it wrong in this case.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/7227/comments",
    "author": "evmar",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2016-09-13T22:15:00Z",
        "body": "This should be fixed in latest.\n"
      }
    ]
  },
  {
    "number": 7092,
    "title": "Space removed in JSX when applying formatter",
    "created_at": "2016-02-16T11:17:41Z",
    "closed_at": "2016-02-19T21:47:44Z",
    "labels": [
      "Bug",
      "Fixed",
      "Help Wanted",
      "Domain: JSX/TSX",
      "Domain: Formatter"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/7092",
    "body": "The following code:\n\n``` tsx\ncategories.push(<option key=\"blank\" value=\"-1\">--  Type  --</option>);\n```\n\nis being formatted to:\n\n``` tsx\ncategories.push(<option key=\"blank\" value=\"-1\">--Type--</option>);\n```\n\nworkaround is to use a string:\n\n``` tsx\ncategories.push(<option key=\"blank\" value=\"-1\">{\"--  Type  --\"}</option>);\n```\n\nWith typescript 1.7.5\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/7092/comments",
    "author": "kuon",
    "comments": [
      {
        "user": "vladima",
        "created_at": "2016-02-16T22:17:36Z",
        "body": "// pinging @SaschaNaz :)\n"
      },
      {
        "user": "saschanaz",
        "created_at": "2016-02-17T08:56:52Z",
        "body": "It seems this is because of `NoSpaceAfterUnaryPredecrementOperator` and `NoSpaceBeforeUnaryPostdecrementOperator` rules. The same bug occurs with `++`, `~`, `!` tokens.\n\n``` typescript\n// every spaces here is being deleted after formatting\n<option>~  Type</option>;\n<option>!  Type</option>;\n<option>++  Type</option>;\n<option>Type   ++</option>;\n```\n"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2016-02-19T21:48:07Z",
        "body": ":star2: \n"
      }
    ]
  },
  {
    "number": 6844,
    "title": "Error message with public class inside namespace",
    "created_at": "2016-02-02T19:07:39Z",
    "closed_at": "2016-02-03T02:33:39Z",
    "labels": [
      "Bug",
      "Fixed",
      "Help Wanted",
      "Good First Issue"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/6844",
    "body": "```\nnamespace Test {\n    public class A {\n\n    }\n}\n```\n\nThe error message on the class line is: 'public' modifier cannot appear on a module element.\n\nShouldn't that be 'on a namespace element'? Or is namespace still a semantic alias for module?\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/6844/comments",
    "author": "drake7707",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2016-02-02T19:10:12Z",
        "body": "`namespace` and `module` are identical.\n\nWe should update the error message to say `namespace`, though.\n"
      },
      {
        "user": "ahejlsberg",
        "created_at": "2016-02-02T20:01:34Z",
        "body": "No sure about that. We use the same error for a top-level element in a module. If anything we should say `'public' modifier cannot appear on a module or namespace element.\"`\n"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2016-02-02T20:10:50Z",
        "body": "Good point\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2016-02-03T02:33:45Z",
        "body": "thanks @plantain-00!\n"
      },
      {
        "user": "mihailik",
        "created_at": "2016-02-04T14:50:46Z",
        "body": "Still not right, it reads as if something is wrong with the `namespace` declaration (or namespace statement? element? definition? node? — whatever you call that lexical construction).\n\nBest to say `'public' modifier cannot appear on an element in a module or namespace. Did you mean 'external'?`\n"
      }
    ]
  },
  {
    "number": 6828,
    "title": "Cannot lookup symbol of nested function in method",
    "created_at": "2016-02-02T09:35:09Z",
    "closed_at": "2016-03-26T21:46:33Z",
    "labels": [
      "Suggestion",
      "Fixed",
      "Help Wanted",
      "API"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/6828",
    "body": "_From @tinganho on January 31, 2016 17:22_\n\nI cannot get a symbol of nested function in method.\n\n``` typescript\nclass A {\n    b() {\n       function test() {\n\n       }\n    }\n}\n```\n\nI think the symbol `test` should show up when I do `CMD + SHIFT + O`. Since it works with nested functions:\n\n``` typescript\nfunction test1 () {\n    function test2() {\n\n    }\n}\n```\n\nI can get `test2` above.\n\n_Copied from original issue: Microsoft/vscode#2584_\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/6828/comments",
    "author": "dbaeumer",
    "comments": [
      {
        "user": "dbaeumer",
        "created_at": "2016-02-02T09:35:11Z",
        "body": "_From @aeschli on February 1, 2016 10:35_\n\n@tinganho I assume this is TypeScript?\n"
      },
      {
        "user": "dbaeumer",
        "created_at": "2016-02-02T09:35:13Z",
        "body": "_From @tinganho on February 1, 2016 10:35_\n\nYes.\n"
      },
      {
        "user": "dbaeumer",
        "created_at": "2016-02-02T09:35:14Z",
        "body": "Moving to the TS team.\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2016-02-02T18:25:07Z",
        "body": "this is by desing to limit noise in the list. functions are supported to allow for JS coding patterns using nested functions. which does not seem to be that common with classes. \n"
      },
      {
        "user": "dbaeumer",
        "created_at": "2016-02-03T09:55:30Z",
        "body": "@mhegazy I think the tsserver nor the language service should make that 'design' decision. It should report the full structure. If a user interface does want to limit the noise we can either filter on the UI side or instruct the tsserver with an option when running the request. \n"
      },
      {
        "user": "tinganho",
        "created_at": "2016-02-03T10:31:00Z",
        "body": "> this is by design to limit noise in the list.\n\n@mhegazy I think I disagree here. It adds as much noise as if, if I would use a private method. Though the downside with a private method is that they cannot access local variables. \n\nI have found it quite useful to nest functions instead of declaring private methods. Since they are declared inside the methods which they are used. And most of my private methods is only used by **one** other method, I think it is more intuitive to nest the functions instead. Though, for very large methods I got a lot of nested functions. And not having the ability to find them by symbol, makes my productivity go down. And I also think something is broken every time I don't find something auto completing or not being able to find something by symbol.\n"
      },
      {
        "user": "tinganho",
        "created_at": "2016-02-03T11:07:43Z",
        "body": "Just to clarify this is the pattern I use:\n\nInstead of this:\n\n``` typescript\nif (true) {\n    a += 1;\n    b += 1;\n    c += 1;\n    d += 1;\n}\n```\n\nI can refactor it as:\n\n``` typescript\nif (true) {\n   incrementABCD();\n}\n\nfunction incrementABCD() {\n    a += 1;\n    b += 1;\n    c += 1;\n    d += 1;\n}\n```\n\nI've learnt this pattern through your source code :wink: . Though, I don't want to go pure functional since I think it lacks some typing that classes got.\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2016-02-03T18:02:09Z",
        "body": "PRs welcomed.\n"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2016-02-03T18:26:59Z",
        "body": "Also related is #4481.\n"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2016-03-26T21:46:56Z",
        "body": "Should be fixed - thanks @tinganho!\n"
      }
    ]
  },
  {
    "number": 6678,
    "title": "Const numbers that index into tuples do not produce the correct type",
    "created_at": "2016-01-27T21:47:29Z",
    "closed_at": "2024-03-12T00:14:51Z",
    "labels": [
      "Suggestion",
      "Help Wanted",
      "Effort: Moderate"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/6678",
    "body": "Hi,\n\nConstants aren't evaluate to access and cast properly union types values:\n\n``` Typescript\nconst ID = 0;\nconst NAME = 1;\n\nlet data: [number, string] = [0, \"bob\"];\n\n// This need cast to compile\nlet id: number = data[ID];\nlet name: string = data[NAME];\n```\n\nIs there a reason why it's not supported ?\n\nRegards,\nSébastien\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/6678/comments",
    "author": "sebdoucet",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2016-01-27T22:41:13Z",
        "body": "We did this for const enums (#3411); I don't see why we wouldn't for this case either\n"
      },
      {
        "user": "sebdoucet",
        "created_at": "2016-01-27T22:46:51Z",
        "body": "It's not compile because you need a cast, it does not recognize ID as 0, so it does not detect you try to get the first entry of the union types, so it does not cast it.\n\nWhat is important to read is the tuple have first entry as number and second entry as string. Without const, data[0] return a number and data[1]  return a string. With const it does not work.\n"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2016-02-01T23:44:03Z",
        "body": "Accepting PRs.\n\nSee also linked issues #6804 and #6805\n"
      },
      {
        "user": "DrSammyD",
        "created_at": "2016-04-01T20:49:22Z",
        "body": "```\nclass x{\n   public y(){ return \"string\" }\n}\nvar z= new x;\nconst y = \"y\";\nvar w = z[\"y\"]();\nvar v = z[y]();\nw.length; //Type safe\nv.length; //No longer type safe\n```\n\nShould this be changed too?\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2016-04-21T19:35:28Z",
        "body": "> Should this be changed too?\n\ni do not see why not.\n"
      },
      {
        "user": "zpdDG4gta8XKpMCd",
        "created_at": "2016-10-24T20:41:02Z",
        "body": "got bitten by it, please fix asap:\n\nnightly build Oct 24, 2016\n\n``` typescript\nconst values: [number, string] = [1, 'a'];\n\nconst one = values[0]; // number, OK\n\nconst index = 0; // index is `0` (not just a number)\nconst another = values[index]; // expected number, actual: string | number <-- WHY?\n```\n"
      },
      {
        "user": "JoshuaKGoldberg",
        "created_at": "2019-03-18T19:35:58Z",
        "body": "@RyanCavanaugh this seems to be fixed when checking TypeScript 3.3.3. `id` and `name` from the OP are correctly `number` and `string` with and without their explicit type annotations."
      }
    ]
  },
  {
    "number": 6630,
    "title": "'jake LKG' creates platform-specific line-endings when generating JS",
    "created_at": "2016-01-26T20:59:24Z",
    "closed_at": "2016-06-08T19:12:45Z",
    "labels": [
      "Bug",
      "Fixed",
      "Help Wanted",
      "Infrastructure"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/6630",
    "body": "On OS X, I ran `jake LKG` to update some files in `lib`, where all of the JS files have Windows-style (CRLF) line endings. After running the tool, the file was replaced with Unix-style (LF) line endings, which made for a messy diff when I went to stage hunks.\n\nMy system is set to checkout and commit line-endings as-is; is this an issue with the generator, or my git configuration?\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/6630/comments",
    "author": "LPGhatguy",
    "comments": [
      {
        "user": "DanielRosenwasser",
        "created_at": "2016-01-26T21:38:37Z",
        "body": "While it's not a problem per se, it makes diffing the LKG difficult, just like you saw.\n\nWe should standardize the LKG with the `--newLine` flag. I'm partial to going with `--newLine LF`, but what are your thoughts @mhegazy?\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2016-01-26T23:35:46Z",
        "body": "Sounds reasonable. +1\n"
      }
    ]
  },
  {
    "number": 6582,
    "title": "Generated js of a tsx file is formatted in a single line. Its very unreadable",
    "created_at": "2016-01-23T02:51:00Z",
    "closed_at": "2016-02-02T05:38:28Z",
    "labels": [
      "Suggestion",
      "Fixed",
      "Help Wanted"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/6582",
    "body": "It would be great if the generated js from tsx was not in a single line.  The generated js is quite unreadable. Ideally it should be nicely indented for readability. If we wanted single lines, that's what the minifier is for.\n\n```\nfunction selfTestPage() {\n    return <html>\n            <head>\n                <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"></meta>\n                <title>Self-test runner frame</title>\n                <script src=\"selfTestPage.js\" type=\"text/javascript\"></script>\n                <script src=\"selfTestPageUtils.js\" type=\"text/javascript\"></script>\n                <link href=\"selfTestPage.css\" type=\"text/css\" rel=\"stylesheet\" />\n            </head>\n            <body>\n                <header>\n                    <h1>Self-Test</h1>\n                    <span id=\"status\">Ready</span>\n                    <div id=\"failWarning\" class=\"header-warning\" hidden=\"hidden\">Note - A test has failed or timed out. F12 may be in an unstable state with unresolved promises or event handlers that aren't cleaned up. Keep that in mind when rerunning tests.</div>\n                    <div id=\"refreshWarning\" class=\"header-warning\">If the page went blank during a test run, it probably refreshed.</div>\n                </header>\n\n                <div id=\"telemetryBaselineContainer\">\n                    Copy this text to telemetryBaseline.ts\n                    <textarea id=\"telemetryBaseline\" rows=\"10\" cols=\"300\"></textarea>\n                </div>\n\n                <div id=\"controlContainer\">\n                    <label>\n                        Filter:\n                        <input id=\"testFilterBox\" type=\"text\" title=\"Use case-insensitive filtering: p:&lt;priority&gt; (eg. p:p0), t:&lt;tool&gt; (eg. t:dom) m:&lt;modulename&gt; (eg. m:accessibility)\"/>\n                    </label>\n                    <input id=\"includeAll\" type=\"checkbox\" checked=\"checked\" />\n                    <button id=\"startRun\">Run ✓'ed</button>\n\n                    <label>\n                        Disable test timeout\n                        <input id=\"disableTimeout\" type=\"checkbox\" onchange=\"onDisableTimeoutChanged()\"/>\n                    </label>\n                    <label>\n                        Update Telemetry Baseline\n                        <input id=\"updateTelemetryBaseline\" type=\"checkbox\" onchange=\"onTelemetryBaselineChanged()\" />\n                    </label>\n                </div>\n                <div id=\"testRowContainer\"></div>\n                <div id=\"eventLog\" hidden=\"hidden\"></div>\n                <input type=\"button\" id=\"stopRun\" value=\"Stop\" />\n                <input type=\"text\" id=\"webDriverTarget\" placeholder=\"WebDriver dummy input\" />\n            </body>\n        </html>;\n}\n```\n\n```\nfunction selfTestPage() {\n    return React.createElement(\"html\", null, React.createElement(\"head\", null, React.createElement(\"meta\", { \"http-equiv\": \"X-UA-Compatible\", \"content\": \"IE=edge\" }), React.createElement(\"title\", null, \"Self-test runner frame\"), React.createElement(\"script\", { \"src\": \"selfTestPage.js\", \"type\": \"text/javascript\" }), React.createElement(\"script\", { \"src\": \"selfTestPageUtils.js\", \"type\": \"text/javascript\" }), React.createElement(\"link\", { \"href\": \"selfTestPage.css\", \"type\": \"text/css\", \"rel\": \"stylesheet\" })), React.createElement(\"body\", null, React.createElement(\"header\", null, React.createElement(\"h1\", null, \"Self-Test\"), React.createElement(\"span\", { \"id\": \"status\" }, \"Ready\"), React.createElement(\"div\", { \"id\": \"failWarning\", \"class\": \"header-warning\", \"hidden\": \"hidden\" }, \"Note - A test has failed or timed out. may be in an unstable state with unresolved promises or event handlers that aren't cleaned up. Keep that in mind when rerunning tests.\"), React.createElement(\"div\", { \"id\": \"refreshWarning\", \"class\": \"header-warning\" }, \"If the page went blank during a test run, it probably refreshed.\")), React.createElement(\"div\", { \"id\": \"telemetryBaselineContainer\" }, \"Copy this text to telemetryBaseline.ts\", React.createElement(\"textarea\", { \"id\": \"telemetryBaseline\", \"rows\": \"10\", \"cols\": \"300\" })), React.createElement(\"div\", { \"id\": \"controlContainer\" }, React.createElement(\"label\", null, \"Filter:\", React.createElement(\"input\", { \"id\": \"testFilterBox\", \"type\": \"text\", \"title\": \"Use case-insensitive filtering: p:&lt;priority&gt; (eg. p:p0), t:&lt;tool&gt; (eg. t:dom) m:&lt;modulename&gt; (eg. m:accessibility)\" })), React.createElement(\"input\", { \"id\": \"includeAll\", \"type\": \"checkbox\", \"checked\": \"checked\" }), React.createElement(\"button\", { \"id\": \"startRun\" }, \"Run ✓'ed\"), React.createElement(\"label\", null, \"Disable test timeout\", React.createElement(\"input\", { \"id\": \"disableTimeout\", \"type\": \"checkbox\", \"onchange\": \"onDisableTimeoutChanged()\" })), React.createElement(\"label\", null, \"Update Telemetry Baseline\", React.createElement(\"input\", { \"id\": \"updateTelemetryBaseline\", \"type\": \"checkbox\", \"onchange\": \"onTelemetryBaselineChanged()\" }))), React.createElement(\"div\", { \"id\": \"testRowContainer\" }), React.createElement(\"div\", { \"id\": \"eventLog\", \"hidden\": \"hidden\" }), React.createElement(\"input\", { \"type\": \"button\", \"id\": \"stopRun\", \"value\": \"Stop\" }), React.createElement(\"input\", { \"type\": \"text\", \"id\": \"webDriverTarget\", \"placeholder\": \"WebDriver dummy input\" })));\n}\n\n```\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/6582/comments",
    "author": "nojvek",
    "comments": [
      {
        "user": "nojvek",
        "created_at": "2016-01-23T03:20:19Z",
        "body": "It also seems that the generated jsx doesn't have array of children, instead it keeps on appending to the args. While this is valid react.createElement definition.\n\nI would suggest createElement should be React.createElement(node:string, attrs:Object, children:array<Node|String>|string|Node\n\nIt would also make the final output look a lot nicer since the array '[' ']' will aid in the prettiness of final output.\n\nMithrill and other vdom frameworks use very similar vdom generators. It would be great if I could specify in compile time --jsx react --react-generator=\"m\". It then outputs m(..) rather than React.createElement. \n"
      },
      {
        "user": "nojvek",
        "created_at": "2016-01-23T07:01:54Z",
        "body": "I see you've added reactNamespace in the latest build. This is really awesome. Thanks. \n\nI'm giving it a shot to see if I can get the array emitter working.\n"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2016-02-02T05:38:28Z",
        "body": "Thanks @nojvek!\n"
      }
    ]
  },
  {
    "number": 6540,
    "title": "Error message for type guards are vague about rules",
    "created_at": "2016-01-19T22:29:44Z",
    "closed_at": "2016-03-02T21:56:03Z",
    "labels": [
      "Bug",
      "Fixed",
      "Help Wanted",
      "Good First Issue",
      "Domain: Error Messages"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/6540",
    "body": "From #6538\n\n``` ts\ninterface Animal {\n    animal;\n}\n\ninterface Dog extends Animal {\n    dog;\n}\n\ninterface Car {\n    car;\n}\n\nlet thing: Dog | Car;\n\nfunction isAnimal(x: Car | Dog): x is Animal {\n    return \"animal\" in x;\n}\n```\n\nCurrently we just report\n\n> Type 'Animal' is not assignable to 'Car | Dog'.\n> &nbsp;&nbsp;&nbsp;&nbsp;etc.\n\nBut that should be the _elaboration_. The first thing the user sees should be something like\n\n> A type guard's type must be assignable to its parameter's type.`\n> &nbsp;&nbsp;&nbsp;&nbsp;Type 'Animal' is not assignable to 'Car | Dog'.\n> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;etc.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/6540/comments",
    "author": "DanielRosenwasser",
    "comments": [
      {
        "user": "DanielRosenwasser",
        "created_at": "2016-01-19T22:31:30Z",
        "body": "This is a really easy bug to fix for anyone who wants to take a stab at this.\n"
      },
      {
        "user": "Vinatorul",
        "created_at": "2016-02-29T20:37:35Z",
        "body": "I am trying to do this. It was not hard to add new diagnostic message, but I am not sure where should I check that I am checking the assignability of the guarded type. Is there a special way to find it out like backtrace?\n"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2016-03-01T01:03:02Z",
        "body": "`checkTypePredicate` is where the magic happens. Specifically, this has to do with the call to `checkTypeAssignableTo`. You'll probably want to use `chainDiagnosticMessages` to create a `DiagnosticMessageChain`. \n"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2016-03-02T21:56:14Z",
        "body": "Thanks @Vinatorul!\n"
      }
    ]
  },
  {
    "number": 6524,
    "title": "Bad error message for assigning empty array to tuple type",
    "created_at": "2016-01-18T00:16:27Z",
    "closed_at": "2019-04-10T01:02:33Z",
    "labels": [
      "Bug",
      "Fixed",
      "Help Wanted",
      "Domain: Error Messages"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/6524",
    "body": "Reported in the IRC channel against 1.7.5. Still exists in 1.8.0-dev.20160117\n\n``` typescript\nvar x: [number] = [];\n```\n\n```\nfoo.ts(1,5): error TS2322: Type 'undefined[]' is not assignable to type '[number]'.\n  Property '0' is missing in type 'undefined[]'.\n```\n\nI guess `undefined` comes from the fact that the RHS array is empty, so its element type is left uninitialized. Maybe you want to detect that and have a different error message? \"An empty array is not assignable to type [number].\" or something.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/6524/comments",
    "author": "Arnavion",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2016-01-19T19:17:26Z",
        "body": "@sandersn @DanielRosenwasser would this be fixed by the proposed contextual typing changes?\n"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2016-01-19T19:48:00Z",
        "body": "If I understand things correctly, you should get `number[]` with Nathan's changes.\n\nEven if you didn't, I think I've concluded on several occasions with @JsonFreeman and @CyrusNajmabadi that surfacing the `undefined` type in error messages is not a problem.\n"
      },
      {
        "user": "Arnavion",
        "created_at": "2016-01-19T20:23:38Z",
        "body": "> Even if you didn't, I think I've concluded on several occasions with @JsonFreeman and @CyrusNajmabadi that surfacing the `undefined` type in error messages is not a problem.\n\nYou don't think it gives the impression of being a compiler bug?\n"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2016-01-19T20:28:21Z",
        "body": "That's what I argued at the time because it totally looks like we screwed up somehow. The fact that we're surfacing the `undefined` type isn't a problem so much as it is that its representation kinda, well, sucks. :smile: \n"
      },
      {
        "user": "sandersn",
        "created_at": "2016-01-20T00:25:55Z",
        "body": "I checked, looks like the error with the change in #6118 is still the same.\n"
      },
      {
        "user": "JsonFreeman",
        "created_at": "2016-01-20T07:22:34Z",
        "body": "Is there such thing as a tuple of length 0? It seems like the error ought to say something like\n\n> type [] is not assignable to type [number]\n\nwhere `[]` is the tuple of length 0. But I guess a tuple of length 0 is really the same as `undefined[]` anyway, so maybe there is no point in having that concept.\n\nThis is _not_ to say that the type `undefined` should never be surfaced in an error message. That is a separate discussion. I think the better question is not about `undefined`, but about how to improve error messages about tuple types. I think that while technically, a tuple type acts as an object with numeric properties, perhaps the error should talk about the \"size / length\" of the tuple. I think that would be more intuitive for users.\n"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2016-04-02T18:01:08Z",
        "body": "Is this still a bug given that the `null` and `undefined` types are going to be representable in 2.0?\n"
      },
      {
        "user": "Arnavion",
        "created_at": "2016-04-02T21:06:22Z",
        "body": "(1.9.0-dev.20160402)\n\nfoo.ts:\n\n``` typescript\nvar x = [];\n```\n\n`tsc -d -t es5 foo.ts`\n\nfoo.d.ts:\n\n``` typescript\ndeclare var x: any[];\n```\n\n---\n\nfoo.ts:\n\n``` typescript\nvar x: [number] = [];\n```\n\n`tsc -t es5 foo.ts`\n\n```\nfoo.ts(1,5): error TS2322: Type 'undefined[]' is not assignable to type '[number]'.\n  Property '0' is missing in type 'undefined[]'.\n```\n\nThere's no difference with `--strictNullChecks`\n\n---\n\nSo is an empty array `any[]` or `undefined[]` ? Should it be `undefined[]` even if `--strictNullChecks` isn't passed in?\n"
      },
      {
        "user": "JsonFreeman",
        "created_at": "2016-04-03T00:05:28Z",
        "body": "For the tuple case, it doesn't really matter what the element type is. The array literal is required to have an element at index 0 because of the contextual type, but it does not.\n\nFor the other case, if the array did not get widened to `any[]`, I don't think you would be able to subsequently add elements to it, which would be very limiting.\n\nBoth of these ideas are independent of strict null checking. That said, I still think it would be reasonable to have tuples of length 0, and then the message would talk about the type `[]` as the empty tuple type.\n"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2019-04-10T01:02:33Z",
        "body": "We have empty tuples now, and the new message is\r\n\r\n```\r\nProperty '0' is missing in type '[]' but required in type '[number]'.\r\n```"
      }
    ]
  },
  {
    "number": 6486,
    "title": "autocomplete imports",
    "created_at": "2016-01-14T19:49:30Z",
    "closed_at": "2016-01-14T22:43:55Z",
    "labels": [
      "Suggestion",
      "Duplicate",
      "Help Wanted",
      "API"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/6486",
    "body": "_From @amb-it-ion on January 5, 2016 14:42_\n\nI am not sure why I could not find any mention of this: I am really missing a feature to autocomplete on missing classes, e.g. when using Http from angular2/http, and given that angular2 is on the node_modules default path (or inside my tsconfig files configuration) I would expect the autocompletion to pick this definition up and add the corresponding import statement.\n\n_Copied from original issue: Microsoft/TypeScript-Sublime-Plugin#425_\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/6486/comments",
    "author": "mhegazy",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2016-01-14T19:49:31Z",
        "body": "_From @amb-it-ion on January 8, 2016 15:20_\n\nJust to clarify, I am talking about SystemJS import, .e.g. 'import {XYZ} from \"XYZ/XYZ\"'\n"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2016-01-14T22:43:55Z",
        "body": "Duplicate of #188.\n"
      }
    ]
  },
  {
    "number": 6451,
    "title": "Indentation issues on multiline call expressions",
    "created_at": "2016-01-12T09:24:58Z",
    "closed_at": "2018-11-09T23:34:17Z",
    "labels": [
      "Bug",
      "Fixed",
      "Help Wanted",
      "Domain: Formatter"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/6451",
    "body": "``` typescript\nPromise.resolve([\n]).then(\n    [\n    /* indentation expected: 8, actual: 4 */\n    ]\n    )/* type ';' -> formatter indentation expected: 0, actual: 4  */\n```\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/6451/comments",
    "author": "saschanaz",
    "comments": [
      {
        "user": "DanielRosenwasser",
        "created_at": "2018-11-09T23:37:24Z",
        "body": "Thanks @saschanaz!"
      }
    ]
  },
  {
    "number": 6326,
    "title": "Union returntype with void must return a value",
    "created_at": "2016-01-02T22:53:01Z",
    "closed_at": "2016-01-25T23:12:40Z",
    "labels": [
      "Suggestion",
      "Fixed",
      "Spec",
      "Help Wanted",
      "Good First Issue"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/6326",
    "body": "I have a method declared as `stop(): void|Promise<void> {}` which get the error\n\n> A function whose declared type is neither 'void' nor 'any' must return a value\n\nAs void is a valid return type I would expect that to be fully valid code. Specifying only void is working.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/6326/comments",
    "author": "Pajn",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2016-01-04T05:19:56Z",
        "body": "Proposing changing spec section 6.3\n\n> An explicitly typed function whose return type isn't the Void or the Any type must have at least one return statement somewhere in its body\n\nto\n\n> An explicitly typed function whose return type isn't _the Void type, the Any type, or a union type containing the Void or Any type as a constituent_ must have at least one return statement somewhere in its body\n"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2016-01-04T05:35:51Z",
        "body": "That still doesn't actually cover `Promise<void>` on its own though.\n"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2016-01-04T05:38:26Z",
        "body": "Not sure I understand the comment\n"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2016-01-04T05:48:35Z",
        "body": "The change you're proposing doesn't permit an async function whose return type annotation is `Promise<void>` to have no return statements.\n"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2016-01-04T06:09:36Z",
        "body": "I don't think anyone would want that behavior (@Pajn, care to weigh in?)\n"
      },
      {
        "user": "Pajn",
        "created_at": "2016-01-04T07:25:26Z",
        "body": "It would be nice if Promise<void> didn't require a return statement in an async function. However for the issue I had the already proposed change would be enough.\n"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2016-01-05T00:06:16Z",
        "body": "Approved, accepting PRs. Should be easy.\n"
      },
      {
        "user": "masaeedu",
        "created_at": "2016-01-15T17:26:27Z",
        "body": "@RyanCavanaugh Regarding:\n\n> An explicitly typed function whose return type isn't the Void type, the Any type, or a union type containing the Void **or Any type as a constituent** must have at least one return statement somewhere in its body\n\nIsn't the emphasized part redundant? The following already compiles:\n\n```\nfunction f(): number | any {\n}\n```\n\nI think the union resolution already recognizes that all types are subtypes of `any`, so any union involving `any` is just `any`.\n"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2016-01-15T17:50:37Z",
        "body": "I think that's an implementation side effect of the compiler. The spec doesn't specify that `number | any` is equivalent to the Any type, though.\n"
      }
    ]
  },
  {
    "number": 6320,
    "title": "unexpected chained \"then\" method indentation ",
    "created_at": "2016-01-02T15:47:37Z",
    "closed_at": "2018-11-09T23:34:17Z",
    "labels": [
      "Bug",
      "Fixed",
      "Help Wanted",
      "Domain: Formatter"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/6320",
    "body": "In VS Code (as it uses the built in formatter, I assume this is the best place to put the issue), the TS formatting produces this:\n\n```\nfoo()\n  .then<void>(\n  function(): void {\n  },\n  function(): void {\n  }\n  )\n  .then<void>(\n  function(): void {\n  },\n  function(): void {\n  }\n  );\n```\n\nI would expect this:\n\n```\nfoo()\n  .then<void>(\n    function(): void {\n    },\n    function(): void {\n    }\n  )\n  .then<void>(\n    function(): void {\n    },\n    function(): void {\n    }\n  );\n```\n\nThe former is pretty hard to read.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/6320/comments",
    "author": "jpetitte",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2016-01-07T18:19:06Z",
        "body": "//CC: @SaschaNaz \n"
      },
      {
        "user": "saschanaz",
        "created_at": "2016-01-13T06:45:55Z",
        "body": "More:\n\n``` typescript\nfoo.then\n    <\n    void // expected: 8, actual: 4\n    >(\n    function (): void {\n    },\n    function (): void {\n    }\n    );\n```\n"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2018-11-09T23:37:04Z",
        "body": "Thanks @saschanaz!"
      }
    ]
  },
  {
    "number": 6252,
    "title": "formatting problem with an object literal as an inlined result type of a function",
    "created_at": "2015-12-26T12:36:09Z",
    "closed_at": "2018-11-09T23:34:17Z",
    "labels": [
      "Bug",
      "Fixed",
      "Help Wanted",
      "Domain: Formatter",
      "VS Code Tracked"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/6252",
    "body": "```\n// given / expected\nfunction _uniteVertices<p extends string, a>(\n    minority: Pinned<p, Vertex<a>>,\n    majorityCounter: number,\n    majority: Pinned<p, Vertex<a>>\n): {\n    majorityCounter: number;\n    vertecis: Pinned<p, {\n        oldVertexId: VertexId;\n        vertex: Vertex<a>;\n    }>;\n} {\n}\n```\n\n```\n// actual\nfunction _uniteVertices<p extends string, a>(\n    minority: Pinned<p, Vertex<a>>,\n    majorityCounter: number,\n    majority: Pinned<p, Vertex<a>>\n): {\n        majorityCounter: number;\n        vertecis: Pinned<p, {\n            oldVertexId: VertexId;\n            vertex: Vertex<a>;\n        }>;\n    } {\n}\n```\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/6252/comments",
    "author": "zpdDG4gta8XKpMCd",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2016-01-07T18:56:31Z",
        "body": "//cc: @SaschaNaz \n"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2018-11-09T23:36:50Z",
        "body": "Thanks @saschanaz!"
      }
    ]
  },
  {
    "number": 6154,
    "title": "Remove restriction of properties overriding prototype methods",
    "created_at": "2015-12-18T17:13:00Z",
    "closed_at": "2018-05-24T21:12:14Z",
    "labels": [
      "Suggestion",
      "Fixed",
      "Help Wanted",
      "Good First Issue"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/6154",
    "body": "We currently enforce this rule:\n\n``` ts\nclass Base {\n  foo() {\n  }\n}\n\nclass Derived extends Base {\n  // Error, cannot override method with property\n  foo: () => { };\n}\n\n```\n\nThis breaks two real scenarios:\n- You can't declare 'foo' as a property and then mix it in later (#6147)\n- You need to implement `foo` as an arrow function because you have some unbound callers that your base class didn't\n\nThe reverse case is important to continue to enforce, but no one can remember why we have this rule.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/6154/comments",
    "author": "RyanCavanaugh",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2016-01-05T00:06:48Z",
        "body": "Pinging @bterlson to make sure we're not forgetting some weird edge case before simply removing this error\n"
      },
      {
        "user": "bterlson",
        "created_at": "2016-01-06T17:26:11Z",
        "body": "I can't think of why this should be an error (it isn't with ES classes + class property declarations proposal, either).\n"
      },
      {
        "user": "DickvdBrink",
        "created_at": "2016-03-23T17:59:43Z",
        "body": "@RyanCavanaugh, maybe the reason was because it is a bit dangerous to use them in the constructor itself? If they where both methods it worked as expected but with the base a method and the derived a property the results are different.\nNote that the code you gave (which I slightly modified) does transpile but the result is Constructor -> Base instead of Constructor -> Derived. Looking at the transpiled code it is obvious but from the TS code perspective it doesn't (might be just me).\nJust guessing here though ;)\n\n```\nclass Base {\n    constructor() {\n        alert(\"constructor\")\n        this.foo();\n    }\n  foo () {\n      alert(\"BASE\")\n  }\n}\n\nclass Derived extends Base {\n  // Error, cannot override method with property\n  foo =  () => { alert(\"Derived\"); };\n}\n\nnew Derived();\n```\n"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2016-03-23T18:18:48Z",
        "body": "I'd call it mildly surprising, relative to what people's random expectations of initialization order seem to be :wink:\n"
      },
      {
        "user": "cameron-martin",
        "created_at": "2017-10-31T20:57:55Z",
        "body": "I can have a look at this one, as my first issue :)"
      }
    ]
  },
  {
    "number": 6127,
    "title": "Completion fails to find subsequent declaration in incomplete ternary",
    "created_at": "2015-12-17T06:53:53Z",
    "closed_at": "2018-01-08T21:16:18Z",
    "labels": [
      "Bug",
      "Fixed",
      "Help Wanted",
      "Effort: Moderate"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/6127",
    "body": "``` ts\n1 ? f // does not work the autocompletion, `func` cannot select.\n1 ? 1 : f // work the autocompletion, `func` can select.\n\nfunction func() {}\n```\n\nDivides #6079.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/6127/comments",
    "author": "falsandtru",
    "comments": [
      {
        "user": "DanielRosenwasser",
        "created_at": "2015-12-17T08:02:56Z",
        "body": "Specifically, you will only see this if you have one ternary at a time. In other words, this works:\n\n``` ts\n1 ? 1 : f/**/\n\nfunction func() {}\n```\n\nand this does not work:\n\n``` ts\n1 ? f/**/\n\nfunction func() { }\n```\n\nI think this is actually due to the parse error where we expect a `:`, and then assume we must have a function expression in the false branch. Since a function expression doesn't create a binding in the rest of the function, it won't show up in your completion list.\n\nI wonder if a reasonable thing to do would be to parse out a missing node if the colon is missing and the following token is on the next line. It'd be reasonable to try it out.\n"
      },
      {
        "user": "falsandtru",
        "created_at": "2015-12-17T10:46:39Z",
        "body": "Sorry for my poor English. Thanks for your fix.\n"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2015-12-17T18:37:41Z",
        "body": "It's fine, I knew what you meant, I was just changing the title so whoever works on this knows exactly what the problem is. :smile: \n"
      },
      {
        "user": "mhegazy",
        "created_at": "2018-01-08T21:16:37Z",
        "body": "thanks @Kingwl !"
      }
    ]
  },
  {
    "number": 6088,
    "title": "Position right before block gets incorrect indentation",
    "created_at": "2015-12-13T13:09:11Z",
    "closed_at": "2023-08-03T16:17:15Z",
    "labels": [
      "Bug",
      "Help Wanted"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/6088",
    "body": "``` typescript\n{\n/* expected indentation: 4, actual: 0*/\n    {\n    /* expected indentation: 8, actual: 4*/\n        {\n        }\n    }\n}\n```\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/6088/comments",
    "author": "saschanaz",
    "comments": [
      {
        "user": "Andarist",
        "created_at": "2023-08-03T10:42:24Z",
        "body": "I'm not exactly sure what this was about but if it's about entering a new line at those positions:\r\n```ts\r\n{/*1*/\r\n    {/*2*/\r\n        {\r\n        }\r\n    }\r\n}\r\n```\r\nthen it works OK today and the indentation is as expected. cc @jakebailey "
      }
    ]
  },
  {
    "number": 5947,
    "title": "import statement formatting problems:",
    "created_at": "2015-12-05T18:56:03Z",
    "closed_at": "2016-09-20T23:26:58Z",
    "labels": [
      "Bug",
      "Fixed",
      "Help Wanted"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/5947",
    "body": "```\n// given\nimport {\n    numbers as bn,\n    optional as bo,\n    base as bb,\n    array as ba,\n    list as bl\n} from '@bykov/basics';\n```\n\n```\n// actual\nimport {\nnumbers as bn,\noptional as bo,\nbase as bb,\narray as ba,\nlist as bl\n} from '@bykov/basics';\n```\n\n```\n// expected\nimport {\n    numbers as bn,\n    optional as bo,\n    base as bb,\n    array as ba,\n    list as bl\n} from '@bykov/basics';\n```\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/5947/comments",
    "author": "zpdDG4gta8XKpMCd",
    "comments": [
      {
        "user": "saschanaz",
        "created_at": "2015-12-05T19:20:03Z",
        "body": "#4516 is also related.\n"
      },
      {
        "user": "DanCorder",
        "created_at": "2015-12-07T16:42:42Z",
        "body": "Actually this may already be fixed by #4609\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2015-12-07T17:37:47Z",
        "body": "thanks @DanCorder!\n"
      }
    ]
  },
  {
    "number": 5932,
    "title": "Missing definitions of IndexedDB Database API",
    "created_at": "2015-12-04T15:55:45Z",
    "closed_at": "2015-12-05T08:13:17Z",
    "labels": [
      "Bug",
      "Fixed",
      "Breaking Change",
      "Help Wanted",
      "Domain: lib.d.ts"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/5932",
    "body": "I have found the following definitions missing in the IndexedDB API\n- [x] IDBObjectStoreParameters\n- [x] IDBIndexParameters\n- [x] multiEntry property of IDBIndex\n\nI have yet to check out the complete API and what's missing. If someone can list them down I can write the definitions.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/5932/comments",
    "author": "aksharpatel47",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2015-12-04T23:24:25Z",
        "body": "PRs are welcomed.\n"
      }
    ]
  },
  {
    "number": 5926,
    "title": "Incorrect formatting for single parameter in arrow functions",
    "created_at": "2015-12-04T10:56:46Z",
    "closed_at": "2015-12-08T18:20:19Z",
    "labels": [
      "Bug",
      "Fixed",
      "Help Wanted"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/5926",
    "body": "_From @xeoneux on December 3, 2015 18:20_\n\nUsing Format Code, `array.map(val=>val*2);` gets formatted to `array.map(val=> val * 2);`\n\nThere's no space between the parameter `val` and the `=>` after formatting.\n\n_Copied from original issue: Microsoft/vscode#982_\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/5926/comments",
    "author": "dbaeumer",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2015-12-08T18:20:37Z",
        "body": "thanks @SaschaNaz!\n"
      }
    ]
  },
  {
    "number": 5904,
    "title": "Allow type predicates to be within parenthesis",
    "created_at": "2015-12-02T23:41:59Z",
    "closed_at": "2015-12-03T02:45:38Z",
    "labels": [
      "Bug",
      "Won't Fix",
      "Help Wanted"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/5904",
    "body": "This is valid:\n\n``` ts\nfunction isA<A>(x: any): (boolean) { return false; }\n```\n\nThis doesn't parse:\n\n``` ts\nfunction isA<A>(x: any): (x is A) { return false; }\n```\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/5904/comments",
    "author": "weswigham",
    "comments": [
      {
        "user": "DanielRosenwasser",
        "created_at": "2015-12-02T23:44:23Z",
        "body": "What is the compelling scenario here?\n"
      },
      {
        "user": "weswigham",
        "created_at": "2015-12-02T23:44:58Z",
        "body": "Consistency.\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2015-12-03T02:45:38Z",
        "body": "Do not think it would block any scenario, though I agree with consistency, would take a fix for it, but do not think it is worth keeping around.\n"
      }
    ]
  },
  {
    "number": 5902,
    "title": "Support type guards as the last element of comma operator lists",
    "created_at": "2015-12-02T23:29:59Z",
    "closed_at": "2016-10-25T04:30:43Z",
    "labels": [
      "Bug",
      "Fixed",
      "Help Wanted",
      "Good First Issue"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/5902",
    "body": "For example:\n\n``` ts\nlet x: string | string[];\nif (x = getValue(), Array.isArray(x)) {\n  // x should be string[]\n}\nelse {\n  // x should be string\n}\n```\n\nor\n\n``` ts\nvar x: string | string[] = (x = getValue(), Array.isArray(x)) ? x[0] : x;\n```\n\nYou can certainly argue this use of the comma operator is gratuitous, but it seems like a slight oversight that we don't respect it when looking at type guards.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/5902/comments",
    "author": "weswigham",
    "comments": [
      {
        "user": "arusakov",
        "created_at": "2016-10-25T02:13:47Z",
        "body": "These type guards already exist in current master (3bdff73c16b5a7eca2407500254764618b35bce4).\n"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2016-10-25T04:30:43Z",
        "body": "Confirmed\n"
      }
    ]
  },
  {
    "number": 5830,
    "title": "fluent api style method chain formatting problem",
    "created_at": "2015-11-30T16:40:52Z",
    "closed_at": "2018-11-09T23:34:17Z",
    "labels": [
      "Bug",
      "Fixed",
      "Help Wanted",
      "Domain: Formatter"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/5830",
    "body": "Seen in 1.8 nightly build (1.8.0-dev.20151130)\n\n```\n// given:\nnew Start()\n   .then(\n      true,\n      false\n   ).then(\n      1234,\n      'xyz'\n   ).then(\n      'abc',\n      '987'\n   );\n```\n\n```\n// actual:\nnew Start()\n   .then(\n   true,\n   false\n   ).then(\n   1234,\n   'xyz'\n   ).then(\n   'abc',\n   '987'\n   );\n```\n\n```\n// expected:\nnew Start()\n   .then(\n      true,\n      false\n   ).then(\n      1234,\n      'xyz'\n   ).then(\n      'abc',\n      '987'\n   );\n```\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/5830/comments",
    "author": "zpdDG4gta8XKpMCd",
    "comments": [
      {
        "user": "magnushiie",
        "created_at": "2017-08-13T20:02:55Z",
        "body": "Note that as described in #14675, a trailing comma causes a different (although still incorrect indentation currently):\r\n```ts\r\nsomeVar\r\n  .chain(\r\n  'arg1',\r\n  'arg2',\r\n)\r\n  .chain(\r\n  3,\r\n  4,\r\n);\r\n```\r\n"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2018-11-09T23:36:21Z",
        "body": "Thanks @saschanaz!"
      }
    ]
  },
  {
    "number": 5810,
    "title": "Commenting a function in an array emits duplicate comments",
    "created_at": "2015-11-27T08:32:53Z",
    "closed_at": "2015-12-21T23:03:39Z",
    "labels": [
      "Bug",
      "Fixed",
      "Help Wanted"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/5810",
    "body": "Hi all,\n\nCommenting a function inside an array emits duplicated comments after the `ts` is transpiled to `js`.\n\nbelow is an example.\n\n``` js\n// TypeScript file\nvar testArrayWithFunc = [\n    // 関数\n    function() {\n        console.log();\n    },\n    // 文字列\n    '1',\n    // 数値\n    2\n]\n```\n\nThe transpiled `js` file is as below\n\n``` js\n// Transpiled JavaScript file\nvar testArrayWithFunc = [\n    // 関数\n    // 関数\n    function () {\n        console.log();\n    },\n    // 文字列\n    '1',\n    // 数値\n    2\n];\n```\n\nThe `// 関数` part is emitted two times.  It looks like it is emitted only if the target is a function.\nI apologize not having enough time to narrow down the problem further and thanks in advance.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/5810/comments",
    "author": "kenfdev",
    "comments": [
      {
        "user": "DanielRosenwasser",
        "created_at": "2015-11-28T02:51:00Z",
        "body": "Confirmed in Version 1.8.0-dev.20151127\n"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2015-12-21T21:29:22Z",
        "body": "Thanks for the fix @DanCorder!\n"
      }
    ]
  },
  {
    "number": 5766,
    "title": "Some signatures should use union instead of overloads",
    "created_at": "2015-11-24T06:13:33Z",
    "closed_at": "2017-03-13T23:33:43Z",
    "labels": [
      "Suggestion",
      "Fixed",
      "Help Wanted",
      "Domain: lib.d.ts"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/5766",
    "body": "I think, this code should be correct code by fixes of lib.d.ts or type system.\n\n``` ts\nvar separator: string|RegExp;\n'str'.split(separator); // type error\n```\n## Manual: Replace to union types\n\nResolve by type definition.\n\nfrom:\n\n``` ts\n// lib.d.ts\n    split(separator: string, limit?: number): string[];\n    split(separator: RegExp, limit?: number): string[];\n```\n\nto:\n\n``` ts\n// lib.d.ts\n    split(separator: string|RegExp, limit?: number): string[];\n```\n## Automatic: Generate union types\n\nResolve by auto generated merged signature from overloads.\n\nfrom:\n\n``` ts\n// lib.d.ts\n    split(separator: string, limit?: number): string[];\n    split(separator: RegExp, limit?: number): string[];\n```\n\nGenerate the merged signature internally, implicitly.\n\nto:\n\n``` ts\n// in memory\n    split(separator: string, limit?: number): string[];\n    split(separator: RegExp, limit?: number): string[];\n    split(separator: string|RegExp, limit?: number): string[]; // generated\n```\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/5766/comments",
    "author": "falsandtru",
    "comments": [
      {
        "user": "ahejlsberg",
        "created_at": "2015-11-24T14:29:27Z",
        "body": "Agreed, we should fix the declaration of `split` to take a union type for the first parameter.\n"
      },
      {
        "user": "falsandtru",
        "created_at": "2015-11-24T14:52:59Z",
        "body": "Thanks! Should I create a list of all integration targets? Such as String#match/replace/search, and more many types. This is steady manual works.\n"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2015-11-24T20:55:27Z",
        "body": "It's probably worth having a script or something to find these cases.\n\nUnfortunately we can't perform this merging on the type system side because the two forms (two overloads vs one overload with a union) actually have rather different semantics in practice.\n"
      },
      {
        "user": "falsandtru",
        "created_at": "2015-11-25T01:36:43Z",
        "body": "All right, I'll leave it up to you.\n"
      },
      {
        "user": "falsandtru",
        "created_at": "2016-01-15T08:59:30Z",
        "body": "When TypeScript fixes this issue? I want to fix this issue myself partially if TypeScript doesn't fix this issue until next version 1.8.\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2016-01-16T00:04:21Z",
        "body": "@falsandtru feel free to send a PR for the issue.\n"
      },
      {
        "user": "falsandtru",
        "created_at": "2016-01-16T02:01:23Z",
        "body": "@mhegazy thanks, I'll fix it.\n"
      }
    ]
  },
  {
    "number": 5572,
    "title": "Pasting nested block comment causes mangling",
    "created_at": "2015-11-09T17:25:59Z",
    "closed_at": "2023-08-02T18:32:12Z",
    "labels": [
      "Bug",
      "Help Wanted"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/5572",
    "body": "Hi,\n\n**Version:**: TS 1.6 / VS 2015\n\nIn the following snippet\n\n``` typescript\n/**\n * The result can be [1] \n */\nfunction foo() {\n\n    // [2] then(() => /*next tick*/ assert.isTrue(...);)\n}\n```\n\nCopying and pasting [2] at the point where it says [1] causes the comment to be mangled.\n\nThis is occurring because of the nested comment `/*next tick*/`\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/5572/comments",
    "author": "NoelAbrahams",
    "comments": [
      {
        "user": "Andarist",
        "created_at": "2023-08-02T17:33:27Z",
        "body": "I'm not really sure if this is something that should be fixed. I'd be surprised if TypeScript would rewrite somehow what I just pasted using the regular paste action. If the paste introduces syntax errors in the document, that's on me as the user and I think it's fine/expected that I would have to fix this on my own. @jakebailey WDYT?"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2023-08-02T18:32:12Z",
        "body": "I agree; paste should not imply random edits. We have no idea what the user intent is."
      },
      {
        "user": "NoelAbrahams",
        "created_at": "2023-08-02T20:12:46Z",
        "body": "I've spent the last eight years ruminating on the right solution for this and, after trying out many agonising alternatives, I agree this doesn't need fixing."
      }
    ]
  },
  {
    "number": 5534,
    "title": "instanceof type guard does not narrow type of `this`",
    "created_at": "2015-11-04T23:31:42Z",
    "closed_at": "2016-05-06T16:18:01Z",
    "labels": [
      "Bug",
      "Fixed",
      "Help Wanted"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/5534",
    "body": "Here's an example which demonstrates (tested on 1.6.2 and current playground):\n\n``` typescript\nclass Foo {\n    a: number;\n\n    foo(): string {\n        if (this instanceof Bar) {\n            return this.b;  // not okay - `this` typed as Foo\n        }\n        return '';\n    }\n\n    bar(): string {\n        let that = this;\n        if (that instanceof Bar) {\n            return that.b;  // okay - `that` typed as Bar\n        }\n        return ''\n    }\n}\n\n\nclass Bar extends Foo {\n    b: string;\n}\n```\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/5534/comments",
    "author": "sccolbert",
    "comments": [
      {
        "user": "kitsonk",
        "created_at": "2015-11-05T08:02:57Z",
        "body": "I think this is all related to polymorphic `this` #4910 which isn't in 1.6.2 (and playground is 1.6.2).  Before that, you couldn't change the `this` type.\n"
      },
      {
        "user": "ahejlsberg",
        "created_at": "2015-11-05T14:58:43Z",
        "body": "Type guards currently only affect parameters and local variables, but I agree it seems reasonable to also have them apply to `this`. @kitsonk No, not related to the polymorphic `this` feature, the restriction is still there in current builds.\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2016-05-06T16:18:01Z",
        "body": "This should be working as expected in master.\n"
      }
    ]
  },
  {
    "number": 5389,
    "title": "\"Cannot read property 'flags' of undefined\" error when compiling nested array destruction",
    "created_at": "2015-10-24T08:49:56Z",
    "closed_at": "2015-10-27T16:46:23Z",
    "labels": [
      "Bug",
      "Fixed",
      "Help Wanted"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/5389",
    "body": "Hi,\n\nI found `tsc` crashes when compiling nested array destruction in function parameter (example below).\n## TypeScript version\n\n1.8.0-dev.20151024 (installed via `npm install typescript@next`)\n## Example Source\n\n``` js\nconst nestedArray = [[[1, 2]], [[3, 4]]];\n\nnestedArray.forEach(([[a, b]]) => {\n  console.log(a, b);\n});\n```\n## Command\n\n```\ntsc index.ts\n```\n## Trace\n\n```\n/Users/seanchas116/Repos/seanchas116/typescript-destructuring-test/node_modules/typescript/lib/tsc.js:30338\n                throw e;\n                ^\n\nTypeError: Cannot read property 'flags' of undefined\n    at getSymbolLinks (/Users/seanchas116/Repos/seanchas116/typescript-destructuring-test/node_modules/typescript/lib/tsc.js:10715:23)\n    at assignBindingElementTypes (/Users/seanchas116/Repos/seanchas116/typescript-destructuring-test/node_modules/typescript/lib/tsc.js:17679:25)\n    at assignTypeToParameterAndFixTypeParameters (/Users/seanchas116/Repos/seanchas116/typescript-destructuring-test/node_modules/typescript/lib/tsc.js:17689:17)\n    at assignContextualParameterTypes (/Users/seanchas116/Repos/seanchas116/typescript-destructuring-test/node_modules/typescript/lib/tsc.js:17666:17)\n    at checkFunctionExpressionOrObjectLiteralMethod (/Users/seanchas116/Repos/seanchas116/typescript-destructuring-test/node_modules/typescript/lib/tsc.js:17860:29)\n    at checkExpressionWorker (/Users/seanchas116/Repos/seanchas116/typescript-destructuring-test/node_modules/typescript/lib/tsc.js:18503:28)\n    at checkExpression (/Users/seanchas116/Repos/seanchas116/typescript-destructuring-test/node_modules/typescript/lib/tsc.js:18445:42)\n    at checkExpressionWithContextualType (/Users/seanchas116/Repos/seanchas116/typescript-destructuring-test/node_modules/typescript/lib/tsc.js:18399:26)\n    at checkApplicableSignature (/Users/seanchas116/Repos/seanchas116/typescript-destructuring-test/node_modules/typescript/lib/tsc.js:17162:31)\n    at chooseOverload (/Users/seanchas116/Repos/seanchas116/typescript-destructuring-test/node_modules/typescript/lib/tsc.js:17448:30)\n```\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/5389/comments",
    "author": "seanchas116",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2015-10-27T17:16:52Z",
        "body": "thanks @seanchas116!\n"
      }
    ]
  },
  {
    "number": 5378,
    "title": "Identity comparisons of type parameters with different names",
    "created_at": "2015-10-23T14:15:10Z",
    "closed_at": "2015-11-09T21:32:43Z",
    "labels": [
      "Bug",
      "Fixed",
      "Help Wanted"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/5378",
    "body": "From spec, 3.11.2:\n\n> Two call or construct signatures are considered identical when they have the same number of type\n> parameters with identical type parameter constraints and, after substituting type Any for the type\n> parameters introduced by the signatures, identical number of parameters with identical kind (required, optional or rest) and types, and identical return types\n\nNowhere does it say that type parameters should have identical names.\n\nBut this code is highlighted with error in playground:\n\n``` ts\nclass c {\n    get x(): <T>(a: T) => T { return null; }\n    set x(p: <U>(a: U) => U) {}\n}\n```\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/5378/comments",
    "author": "osdm",
    "comments": [
      {
        "user": "DanielRosenwasser",
        "created_at": "2015-10-23T15:26:36Z",
        "body": "Looks like a bug, thanks for reporting.\n"
      }
    ]
  },
  {
    "number": 5298,
    "title": "Bad path joining for error message on existing 'tsconfig.json'",
    "created_at": "2015-10-17T00:05:28Z",
    "closed_at": "2015-10-26T06:10:03Z",
    "labels": [
      "Bug",
      "Fixed",
      "Help Wanted",
      "Good First Issue"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/5298",
    "body": "Expected:\n\n```\nerror TS5054: A 'tsconfig.json' file is already defined at: 'C:\\Users\\drosen\\foo\\tsconfig.json'.\n```\n\nActual:\n\n```\nerror TS5054: A 'tsconfig.json' file is already defined at: 'C:\\Users\\drosen\\foo/tsconfig.json'.\n```\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/5298/comments",
    "author": "DanielRosenwasser",
    "comments": [
      {
        "user": "eimfach",
        "created_at": "2015-10-17T17:33:08Z",
        "body": "I will fix it :)\n"
      },
      {
        "user": "eimfach",
        "created_at": "2015-10-17T18:03:07Z",
        "body": "Okay seems to be fixed by @brettm523\n"
      },
      {
        "user": "DickvdBrink",
        "created_at": "2015-10-24T18:49:53Z",
        "body": "the PR is merged, so this one is fixed and can be closed?\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2015-10-26T06:10:02Z",
        "body": "Thanks @DickvdBrink!\n"
      },
      {
        "user": "gcamana",
        "created_at": "2016-07-23T17:16:01Z",
        "body": "error TS5054: A 'tsconfig.json' file is already defined at: 'D:/Frontend/TypeScript/1.Intro_TS/tsconfig.json'.\nOS Windows 10\n\nas I fix it? I have the same problems\n"
      }
    ]
  },
  {
    "number": 5209,
    "title": "Add es2015 as valid target in tsconfig.json",
    "created_at": "2015-10-11T08:32:11Z",
    "closed_at": "2015-10-15T19:46:47Z",
    "labels": [
      "Suggestion",
      "Fixed",
      "Help Wanted"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/5209",
    "body": "It would be nice to be able to set the following in tsconfig.json: `\"target\": \"es2015\",` rather than `\"target\": \"es6\",`. In practice the TypeScript compiler should just interpret both the same way.\n\nGiven that they've renamed the spec, it would make sense to try and stay aligned... although the ES6 name will surely stick around for a while :)\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/5209/comments",
    "author": "dsebastien",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2015-10-12T17:37:51Z",
        "body": "This seems reasonable to me. @mhegazy ?\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2015-10-12T18:03:28Z",
        "body": "yeah.. it is unfortunate though that some tsconfig.json files will have \"es6\" where others would have \"es2015\"..\n\nmoving forward we should not use targets like \"es7\" to avoid the confusion.\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2015-10-12T18:03:41Z",
        "body": "A PR would be welcomed.\n"
      },
      {
        "user": "weswigham",
        "created_at": "2015-10-12T18:42:35Z",
        "body": "@mhegazy should the module kind names be updated as well? We have yet to make a release with the `es6` module kind.\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2015-10-12T18:43:44Z",
        "body": ":D i suppose so.\n"
      },
      {
        "user": "dhusemann",
        "created_at": "2015-10-15T11:07:26Z",
        "body": "should a target of es2016 be added already? ??\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2015-10-15T16:18:12Z",
        "body": "The target ES6 and module ES6 are already supported. this issue is about the name of the target and module; in addition to `--target ES6`, `--target ES2015` should be allowed, and both will mean the same thing. this also applies to `--module ES2015`, to be an alias for `--module ES6`\n"
      },
      {
        "user": "dsebastien",
        "created_at": "2015-10-15T20:01:20Z",
        "body": "Great :)\n"
      },
      {
        "user": "jods4",
        "created_at": "2015-10-22T12:57:58Z",
        "body": "It seems diagnostics messages were forgotten...\n`Argument_for_target_option_must_be_ES3_ES5_or_ES6`\ndoesn't mention ES2015.\n"
      }
    ]
  },
  {
    "number": 5173,
    "title": "Give more helpful error when trying to set default values on an interface",
    "created_at": "2015-10-08T17:31:32Z",
    "closed_at": "2015-12-01T21:05:09Z",
    "labels": [
      "Bug",
      "Fixed",
      "Help Wanted",
      "Effort: Moderate"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/5173",
    "body": "Today I spent a moment scratching my head at the following snippet:\n\n```\ninterface Foo {\n    bar: number = 5;\n}\n```\n\n_\"Of course!\"_ I say now, I was trying to set a default value on an interface, which makes no sense. TypeScript didn't see that this might be something I would do, and instead gave me a syntax error:\n\n```\nError TS1005: ';' expected.\nError TS1131: Property or signature expected.\nError TS1128: Declaration or statement expected.\n```\n\nWould it be possible to get a more useful error message for this case (and potentially cases like this?)\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/5173/comments",
    "author": "LPGhatguy",
    "comments": [
      {
        "user": "delta-nry",
        "created_at": "2015-10-17T20:47:52Z",
        "body": "I am part of a group of students from the University of British Columbia looking to contribute to a bug fix. Is there anything we must do to get assigned onto this bug?\n"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2015-10-18T23:03:56Z",
        "body": "Nope, it's just good that you asked so others know you're working on it. Go for it. :smile: \n"
      },
      {
        "user": "CyrusNajmabadi",
        "created_at": "2015-10-20T14:10:37Z",
        "body": "The correct way to handle this would likely be to just allow parsing a full on property inside an interface.  We can then report an error later on that an interface property cannot have an initializer.  That way the parse tree is well formed, and features like formatting/navbars/etc. all work property.\n"
      },
      {
        "user": "jbondc",
        "created_at": "2015-10-23T14:24:46Z",
        "body": "Oops, moving my comments to #4878\n"
      },
      {
        "user": "delta-nry",
        "created_at": "2015-10-26T22:57:34Z",
        "body": "I've been looking at the parser.ts file. It appears that in parseTypeMember(), if we return parsePropertyOrMethodDeclaration() for string and numeric literals instead of returning parsePropertyOrMethodSignature(), this will allow parsing full properties inside an interface. In this case, parsePropertyOrMethodDeclaration() should return parsePropertyDeclaration(). What is the best way for parsePropertyDeclaration() to report the desired error if an initializer is present on an interface property?\n"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2015-12-01T21:06:15Z",
        "body": "Thanks @delta-nry!\n"
      }
    ]
  },
  {
    "number": 5164,
    "title": "Formatter does not treat destructured imports",
    "created_at": "2015-10-08T08:10:48Z",
    "closed_at": "2019-10-31T08:50:43Z",
    "labels": [
      "Bug",
      "Help Wanted"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/5164",
    "body": "Imagine an import like this:\n\n```\nimport { IWorkbenchEditorService }  from 'vs/workbench/services/editor/common/editorService';\n```\n\nFormat, I would love if it ends up to be \n\n```\nimport {IWorkbenchEditorService}  from 'vs/workbench/services/editor/common/editorService';\n```\n\nOr whatever you guys think should be the formatting of destructured imports.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/5164/comments",
    "author": "bpasero",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2015-10-08T18:21:57Z",
        "body": "I have seen users have strong opinions on weather this should have spaces or not. so looks like this can be a new option.\n\n//CC: @SaschaNaz \n"
      },
      {
        "user": "saschanaz",
        "created_at": "2015-10-08T18:32:17Z",
        "body": "Unmerged #4609 will format the code but with spaces. A new option for this will be good but maybe after #4757.\n"
      }
    ]
  },
  {
    "number": 5030,
    "title": "An unnecessary space is inserted in ${...} by the auto formatter",
    "created_at": "2015-09-30T03:36:37Z",
    "closed_at": "2015-10-05T23:01:10Z",
    "labels": [
      "Bug",
      "Fixed",
      "Help Wanted",
      "Good First Issue"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/5030",
    "body": "This is what I get after Ctrl+K+D in VS:\n\n``` ts\nthrow Error(`${JSON.stringify(this.value) } cannot be found in ${JSON.stringify(y) }`);\n```\n\nAs you see, a space was inserted after `JSON.stringify(...)`. The bug doesn't appear if a plain variable is used: `${x}`.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/5030/comments",
    "author": "d180cf",
    "comments": [
      {
        "user": "saschanaz",
        "created_at": "2015-10-04T18:44:39Z",
        "body": "Does this accept PR?\n"
      },
      {
        "user": "vladima",
        "created_at": "2015-10-04T19:27:00Z",
        "body": "Sure! PR will definitely be appreciated\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2015-10-05T23:01:28Z",
        "body": "thanks @SaschaNaz !\n"
      }
    ]
  },
  {
    "number": 4996,
    "title": "Assignment across lines are not indented properly",
    "created_at": "2015-09-28T03:59:48Z",
    "closed_at": "2015-09-29T22:12:40Z",
    "labels": [
      "Bug",
      "Fixed",
      "Help Wanted"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/4996",
    "body": "Expected:\n\n``` typescript\nlet t: number;\nt =\n    1 + 2;\n```\n\nActual:\n\n``` typescript\nlet t: number;\nt =\n1 + 2;\n```\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/4996/comments",
    "author": "zhengbli",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2015-09-28T18:27:49Z",
        "body": "//CC: @SaschaNaz \n"
      },
      {
        "user": "mhegazy",
        "created_at": "2015-09-29T22:13:17Z",
        "body": "thanks @SaschaNaz!\n"
      }
    ]
  },
  {
    "number": 4986,
    "title": "tsc --watch should show more information(eg: time) when recompiling",
    "created_at": "2015-09-26T12:45:29Z",
    "closed_at": "2015-09-29T20:12:45Z",
    "labels": [
      "Suggestion",
      "Fixed",
      "Help Wanted",
      "Good First Issue"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/4986",
    "body": "eg:\n\n```\nmessage TS6032: File change detected. Starting incremental compilation...\nmessage TS6042: Compilation complete. Watching for file changes.\nmessage TS6032: File change detected. Starting incremental compilation...\nmessage TS6042: Compilation complete. Watching for file changes.\nmessage TS6032: File change detected. Starting incremental compilation...\nmessage TS6042: Compilation complete. Watching for file changes.\nmessage TS6032: File change detected. Starting incremental compilation...\nmessage TS6042: Compilation complete. Watching for file changes.\nmessage TS6032: File change detected. Starting incremental compilation...\nmessage TS6042: Compilation complete. Watching for file changes.\nmessage TS6032: File change detected. Starting incremental compilation...\nmessage TS6042: Compilation complete. Watching for file changes.\nmessage TS6032: File change detected. Starting incremental compilation...\nmessage TS6042: Compilation complete. Watching for file changes.\nmessage TS6032: File change detected. Starting incremental compilation...\nmessage TS6042: Compilation complete. Watching for file changes.\nmessage TS6032: File change detected. Starting incremental compilation...\nmessage TS6042: Compilation complete. Watching for file changes.\nmessage TS6032: File change detected. Starting incremental compilation...\nmessage TS6042: Compilation complete. Watching for file changes.\n```\n\nThe nodemon's information seems better:\n\n```\n26 Sep 15:59:58 - [nodemon] matched rule: **\\*.*\n26 Sep 15:59:58 - [nodemon] changes after filters (before/after): 1/1\n26 Sep 15:59:58 - [nodemon] restarting due to changes...\n26 Sep 15:59:58 - [nodemon] tests\\cacheKeyRule.js\n\n26 Sep 15:59:58 - [nodemon] starting `node app.js`\n26 Sep 15:59:58 - [nodemon] child pid: 8160\n```\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/4986/comments",
    "author": "plantain-00",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2015-09-29T20:18:01Z",
        "body": "thanks @MartyIX !\n"
      }
    ]
  },
  {
    "number": 4984,
    "title": "Trailing whitespace is not removed by formatter on 'empty' lines",
    "created_at": "2015-09-26T09:59:52Z",
    "closed_at": "2016-01-08T00:43:21Z",
    "labels": [
      "Bug",
      "Fixed",
      "Help Wanted"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/4984",
    "body": "The following test fails:\n\n``` typescript\n/// <reference path='fourslash.ts' />\n\n////    /*1*/\n////    /*2*/\n\nformat.document();\nverify.currentFileContentIs(\"\\n\");\n```\n\n_(where the contents before marker 2 are a `\\t` character)_\n\nI notice trailing whitespace is not removed from comments; whilst I would argue trailing whitespace should be removed across the board, I think it should at least be removed from lines only containing whitespace. \n\nThoughts?\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/4984/comments",
    "author": "myitcv",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2015-09-28T18:06:29Z",
        "body": "We do not touch comments, and this is by design. comments are not code, and should not be formatted.\nas for empty lines, this is more of an optimization, and can be removed.\n"
      },
      {
        "user": "myitcv",
        "created_at": "2015-09-28T18:29:42Z",
        "body": "> comments are not code, and should not be formatted.\n\nThanks for confirming this is the position as far as TypeScript is concerned.\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2016-01-08T00:43:49Z",
        "body": "thanks @SaschaNaz!\n"
      }
    ]
  },
  {
    "number": 4912,
    "title": "Template string expression statement leading with object literal gives incorrect emit",
    "created_at": "2015-09-21T23:11:25Z",
    "closed_at": "2018-12-17T20:48:05Z",
    "labels": [
      "Bug",
      "Fixed",
      "Help Wanted",
      "Good First Issue"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/4912",
    "body": "Something like\n\n``` TypeScript\n`${ { hello: 10; world: 20 } }HELLO`\n```\n\nwill get emitted as \n\n``` JavaScript\n{ hello: 10; world: 20 } + \"HELLO\"\n```\n\nAs an expresssion statement, the former evaluates to `\"[object Object]HELLO\"` while the latter evaluates to `NaN`.\n\nThis is because the former gets parsed as:\n\n``` TypeScript\n// block body\n{\n    hello: 10;\n    world: 20;\n};\n\"HELLO\";\n```\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/4912/comments",
    "author": "DanielRosenwasser",
    "comments": [
      {
        "user": "DanielRosenwasser",
        "created_at": "2015-09-21T23:12:02Z",
        "body": "Note this also applies to arrow functions, function expressions, and class expressions.\n"
      },
      {
        "user": "weswigham",
        "created_at": "2015-09-22T02:51:17Z",
        "body": "Interestingly, we also output _extra_ parenthesis when doing a destructuring assignment within a template expression:\n\n``` ts\nlet x,y;\n`${ {x,y} = {x: 2, y: 3} }HELLO`\n```\n\nemits as:\n\n``` js\nvar x, y;\n((_a = { x: 2, y: 3 }, x = _a.x, y = _a.y, _a)) + \"HELLO\";\nvar _a;\n```\n\nAdditionally, the declaration of the temporary variable is placed after the expression - there's nothing expressly wrong with that, but it seems like bad form.\n"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2015-09-22T03:58:29Z",
        "body": "I might have a fix for this, so let's leave it assigned to me for now.\n"
      },
      {
        "user": "anirudhrb",
        "created_at": "2017-09-02T13:59:41Z",
        "body": "Is this still open? If yes, I would like to attempt a fix. :)"
      },
      {
        "user": "kitsonk",
        "created_at": "2017-09-02T16:28:17Z",
        "body": "It doesn't appear to be.\r\n\r\n```ts\r\n`${{ hello: 10, world: 20 }}HELLO`;\r\n```\r\n\r\n...emits...\r\n\r\n```js\r\n({ hello: 10, world: 20 } + \"HELLO\");\r\n```\r\n\r\nBoth result in the same string of:\r\n\r\n```\r\n[object Object]HELLO\r\n```\r\n\r\nSo ultimately this issue should be closed as the ES6+ behaviour matches the down-emit behaviour."
      },
      {
        "user": "j-oliveras",
        "created_at": "2018-12-16T11:21:16Z",
        "body": "@DanielRosenwasser This can be closed, is solved since minimum September 2017.\r\n```ts\r\n`${{ hello: 10, world: 20 }}HELLO`;\r\n\r\n`${() => 0}HELLO`;\r\n\r\n`${function () { }}HELLO`;\r\n\r\n`${class a { }}HELLO`;\r\n```\r\n\r\nis compiled to (comments are the result running it on firefox console):\r\n```js\r\n({ hello: 10, world: 20 } + \"HELLO\"); // [object Object]HELLO\r\n\r\n(function () { return 0; } + \"HELLO\"); // function () { return 0; }HELLO\r\n\r\n(function () { } + \"HELLO\"); // function () { }HELLO\r\n\r\n/** @class */ (function () {\r\n    function a() {\r\n    }\r\n    return a;\r\n}()) + \"HELLO\"; /* function a() {\r\n    }HELLO */\r\n```\r\n"
      }
    ]
  },
  {
    "number": 4909,
    "title": "Suggestion: Remove generated code from repo",
    "created_at": "2015-09-21T22:49:16Z",
    "closed_at": "2015-09-22T00:16:41Z",
    "labels": [
      "Bug",
      "Fixed",
      "Help Wanted"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/4909",
    "body": "After seeing #4884, I'd like to ask about this. Having `diagnosticInformationMap.generated.ts` in the repo seems fine since it's part of the build, but since we want to check if for duplicate IDs we should consider incorporating the generation of the code into the standard build process, rather than a script run by hand as-needed.\n\nThe only downsides I can see are that editor intellisense for the Diagnostic object won't work after a clean clone until after a build or pre-build is run, and we'll lose the ability to simply run `tsc` over the compiler folder and get a functioning compiler (you have to generate the generated code first).\n\nAs far as upsides go, adopting this strategy should result in fewer merge conflicts in diagnostic messages and, additionally, will add a warning in the form of a failed build in a PRs when someone tries to add a message with an identical message id to one in master.\n\nTo do this, we should remove the generated code file from the repo, add the filename to the `.gitignore`, and make the script to rebuild it run as part of the build process.\n\nDoes anyone feel strongly about this?\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/4909/comments",
    "author": "weswigham",
    "comments": [
      {
        "user": "danquirk",
        "created_at": "2015-09-21T23:00:34Z",
        "body": "Since one other downside would be increased build time for `tsc` it's worth noting that `jake generate-diagnostics` today takes a negligible amount of time, < 1s.\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2015-09-21T23:20:38Z",
        "body": "sounds reasonable to me. we can give it a try and if we find missing the file affecting the productivity we can always put it back, though i doubt it.\n"
      }
    ]
  },
  {
    "number": 4701,
    "title": "Error message should be fixed for ambient module inside namespace",
    "created_at": "2015-09-08T23:54:44Z",
    "closed_at": "2015-10-01T04:40:28Z",
    "labels": [
      "Bug",
      "Fixed",
      "Help Wanted",
      "Good First Issue"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/4701",
    "body": "``` TypeScript\nnamespace n {\n    declare module \"m\" {\n        var x;\n    }\n}\n```\n\nCurrently: `TS2435: Ambient modules cannot be nested in other modules.`\nSuggested: `TS2435: Ambient modules cannot be nested in other modules or namespaces.`\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/4701/comments",
    "author": "DanielRosenwasser",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2015-09-18T22:40:01Z",
        "body": "Feel free to send a PR for this.\n"
      }
    ]
  },
  {
    "number": 4603,
    "title": "`(<any>2).property;` emits invalid code `2.property;`",
    "created_at": "2015-09-02T11:59:06Z",
    "closed_at": "2015-09-10T19:15:07Z",
    "labels": [
      "Bug",
      "Fixed",
      "Help Wanted"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/4603",
    "body": "Seems to be an old minor bug.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/4603/comments",
    "author": "vilicvane",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2015-09-02T22:06:21Z",
        "body": "PRs are welcomed. \n"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2015-09-10T19:15:07Z",
        "body": "Thanks!\n"
      }
    ]
  },
  {
    "number": 4587,
    "title": "Invalid parse error with newline and division",
    "created_at": "2015-09-01T08:08:18Z",
    "closed_at": "2023-07-05T23:02:19Z",
    "labels": [
      "Bug",
      "Help Wanted"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/4587",
    "body": "This snippet (note the newline) produces a parse error\n\n``` javascript\nif ((a / b > c) &&\nd) {\n// Do stuff\n}\n```\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/4587/comments",
    "author": "jrieken",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2015-09-01T17:35:40Z",
        "body": "@vladima can you take a look\n"
      },
      {
        "user": "JoshuaKGoldberg",
        "created_at": "2020-01-02T09:55:50Z",
        "body": "There is no longer a parse error for that snippet! 🙌 "
      },
      {
        "user": "jakebailey",
        "created_at": "2023-07-05T23:02:19Z",
        "body": "Just looking at ancient issues; this bug has been fixed longer than I can reasonably test without a time machine to resurrect a machine which can build such old versions of TS; I'm going to close this."
      },
      {
        "user": "jrieken",
        "created_at": "2023-07-06T07:31:16Z",
        "body": "2015!"
      }
    ]
  },
  {
    "number": 4516,
    "title": "Support formatting for named imports/export clauses",
    "created_at": "2015-08-28T01:29:01Z",
    "closed_at": "2016-06-27T20:30:37Z",
    "labels": [
      "Bug",
      "Fixed",
      "Help Wanted"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/4516",
    "body": "``` TypeScript\nexport{x,y as yy,z}from \"foo\"\n```\n\nShould be fixed to\n\n``` TypeScript\nexport { x, y as yy, z } from \"foo\"\n```\n\nSimilarly, \n\n``` TypeScript\nimport{x,y as yy,z}from \"foo\"\n```\n\nShould be fixed to\n\n``` TypeScript\nimport { x, y as yy, z } from \"foo\"\n```\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/4516/comments",
    "author": "DanielRosenwasser",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2015-08-28T01:53:03Z",
        "body": "Pinging @SaschaNaz for this one.\n"
      }
    ]
  },
  {
    "number": 4487,
    "title": "'declare' modifier required on top-level type alias in a .d.ts file",
    "created_at": "2015-08-27T01:15:59Z",
    "closed_at": "2015-10-26T06:26:18Z",
    "labels": [
      "Bug",
      "Fixed",
      "Help Wanted",
      "Good First Issue"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/4487",
    "body": "``` TypeScript\ntype Foo = number;\n```\n\nSave this as a .d.ts file, you'll get an error about how a `declare` modifier is required in a top-level declaration.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/4487/comments",
    "author": "DanielRosenwasser",
    "comments": [
      {
        "user": "DanielRosenwasser",
        "created_at": "2015-10-22T20:38:21Z",
        "body": "@maybejulian is interested in taking this on.\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2015-10-26T06:26:41Z",
        "body": "thanks @maybejulian!\n"
      }
    ]
  },
  {
    "number": 4486,
    "title": "Formatting for union types needs improvements",
    "created_at": "2015-08-27T01:11:52Z",
    "closed_at": "2016-02-22T20:42:03Z",
    "labels": [
      "Bug",
      "Fixed",
      "Help Wanted"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/4486",
    "body": "``` TypeScript\ntype T = A\n       | B\n       | C;\n```\n\nIf I try adding another union arm to the RHS of `T`, formatting ruins everything.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/4486/comments",
    "author": "DanielRosenwasser",
    "comments": [
      {
        "user": "saschanaz",
        "created_at": "2015-08-27T09:02:17Z",
        "body": "What's the expected result?\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2015-08-27T16:55:06Z",
        "body": "@DanielRosenwasser i believe this is handled by #4442.\n"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2015-08-27T17:37:53Z",
        "body": "I'd expect the `|`s to stay aligned to each other - if #4442 doesn't handle that, it doesn't have to be done there, but it would be great for us to have it eventually.\n"
      },
      {
        "user": "saschanaz",
        "created_at": "2015-08-27T18:03:51Z",
        "body": "#4442 doesn't handle that. Maybe a new indentation style will give the better result, like the one discussed in #3781. \n"
      },
      {
        "user": "mhegazy",
        "created_at": "2016-02-22T20:42:02Z",
        "body": "looks fixed now.\n"
      }
    ]
  },
  {
    "number": 4479,
    "title": "Find references/get occurrences on 'this' doesn't work in class expressions",
    "created_at": "2015-08-26T23:13:17Z",
    "closed_at": "2015-08-28T21:47:23Z",
    "labels": [
      "Bug",
      "Fixed",
      "Help Wanted"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/4479",
    "body": "``` TypeScript\nvar x = class C {\n    public x;\n    public y;\n    public z;\n    constructor() {\n        [|this|].x;\n        [|this|].y;\n        [|this|].z;\n    }\n    foo() {\n        return [|this|].x;\n    }\n}\n```\n\nAll the above spans should find the same references.\n\nIssue is caused by `getThisReferencesInFile` in `services.ts`.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/4479/comments",
    "author": "DanielRosenwasser",
    "comments": [
      {
        "user": "DickvdBrink",
        "created_at": "2015-08-28T17:42:46Z",
        "body": "Hi @DanielRosenwasser, is this something that is up for grabs or you want to do this yourself?\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2015-08-28T20:10:34Z",
        "body": "@DickvdBrink feel free to send a PR\n"
      }
    ]
  },
  {
    "number": 4438,
    "title": "Formatting issue in 1.6",
    "created_at": "2015-08-25T08:40:59Z",
    "closed_at": "2015-08-27T21:52:53Z",
    "labels": [
      "Bug",
      "Fixed",
      "Help Wanted"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/4438",
    "body": "can be seen in 9a6db930b48b2e51216739aa0d9430e13121cc93\n\nbefore (unformatted)\n\n``` typescript\nfunction renderElement(\n    element: Element,\n    writer: upw.Writer,\n    options: uh2p.Options,\n    renderNode: (\n        node: Node,\n        parentBox: cb.Box,\n        parentStyles: CSSStyleDeclaration,\n        writer: upw.Writer,\n        options: uh2p.Options\n    ) => void\n): void {\n}\n```\n\nafter formatting actual\n\n``` typescript\nfunction renderElement(\n    element: Element,\n    writer: upw.Writer,\n    options: uh2p.Options,\n    renderNode: (\n    node: Node,\n    parentBox: cb.Box,\n    parentStyles: CSSStyleDeclaration,\n    writer: upw.Writer,\n    options: uh2p.Options\n    ) => void\n): void {\n}\n```\n\nafter formatting expected\n\n``` typescript\nfunction renderElement(\n    element: Element,\n    writer: upw.Writer,\n    options: uh2p.Options,\n    renderNode: (\n        node: Node,\n        parentBox: cb.Box,\n        parentStyles: CSSStyleDeclaration,\n        writer: upw.Writer,\n        options: uh2p.Options\n    ) => void\n): void {\n}\n```\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/4438/comments",
    "author": "zpdDG4gta8XKpMCd",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2015-08-27T22:16:22Z",
        "body": "thanks @SaschaNaz!\n"
      }
    ]
  },
  {
    "number": 4354,
    "title": "Invalid identifiers generated when importing files with leading numbers",
    "created_at": "2015-08-19T01:07:42Z",
    "closed_at": "2015-08-19T17:25:26Z",
    "labels": [
      "Bug",
      "Fixed",
      "Help Wanted"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/4354",
    "body": "Targeting commonjs, when importing files with leading numbers in their names results in invalid js emitted.\n\nGiven these inputs:\n### 10_lib.ts\n\n```\nexport function Foo(){};\n```\n### main.ts\n\n``` typescript\nimport { Foo } from './10_lib';\n\nFoo();\n```\n\nCompiling with\n\n```\n$ tsc --modules commonjs main.ts\n```\n\nGenerates\n### main.js\n\n```\nvar 10_lib_1 = require('./10_lib');\n10_lib_1.Foo();\n```\n\nWhich is invalid, and when run errors with:\n\n```\n$ node main.js\n.../main.js:1\n(function (exports, require, module, __filename, __dirname) { var 10_lib_1 = r\n                                                                  ^^\nSyntaxError: Unexpected token ILLEGAL\n```\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/4354/comments",
    "author": "DavidSouther",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2015-08-19T17:25:51Z",
        "body": "thanks @DavidSouther!\n"
      }
    ]
  },
  {
    "number": 4346,
    "title": "TypeCheckerHost interface should not be exported",
    "created_at": "2015-08-17T23:57:10Z",
    "closed_at": "2015-08-21T19:23:40Z",
    "labels": [
      "Bug",
      "Help Wanted",
      "API"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/4346",
    "body": "The `TypeCheckerHost` interface isn't referenced anywhere else in `typescriptServices.d.ts`. Is this an error? Unlike `LanguageService`, you can get a `TypeChecker` with `getTypeChecker()` on `ts.Program`. So exposing `TypeCheckerHost` seems unnecessary.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/4346/comments",
    "author": "adidahiya",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2015-08-18T00:10:12Z",
        "body": "Sounds correct. A PR would be appreciated!\n"
      }
    ]
  },
  {
    "number": 4249,
    "title": "`arguments` not in intellisense list",
    "created_at": "2015-08-10T10:56:23Z",
    "closed_at": "2015-08-18T16:51:58Z",
    "labels": [
      "Bug",
      "Fixed",
      "Help Wanted"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/4249",
    "body": "Start typing `argu` in a function body and the only suggestion is the `IArguments` interface.\n\nWhat's more annoying is that VS Code always accepts the first item in the list on the dot key no matter what you have typed...\n\n (I do not think it normally suggests interface names in non-type positions, so I guess somewhere in the code the interface is confused with the `arguments` keyword?)\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/4249/comments",
    "author": "qc00",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2015-08-10T17:42:20Z",
        "body": "`arguments` is never put in the completion list (see #2433). we could inject it in the list if you are requesting completion inside a function.\n"
      },
      {
        "user": "shmuelie",
        "created_at": "2015-08-13T21:47:25Z",
        "body": "I'd like to second the request for it to be in the auto completion inside a function.\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2015-08-18T16:51:58Z",
        "body": "Thanks @Schmavery!\n"
      }
    ]
  },
  {
    "number": 4221,
    "title": "Leading space in generic parameter ignored by autoformat",
    "created_at": "2015-08-07T18:08:30Z",
    "closed_at": "2015-08-12T20:46:53Z",
    "labels": [
      "Bug",
      "Fixed",
      "Help Wanted"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/4221",
    "body": "Hi,\n\n**Version**: VS2015/TS 1.5\n\nIn the code below,\n\n``` typescript\ninterface Foo<T> {\n}\n\nlet foo: Foo<  { bar: string }> = undefined\n```\n\nAutoformat (Cntrl+K, Cntrl+D) does not remove the space between `Foo<` and `{ bar`. (It does remove any trailing spaces e.g. `bar: string } __ >`.)\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/4221/comments",
    "author": "NoelAbrahams",
    "comments": [
      {
        "user": "NoelAbrahams",
        "created_at": "2015-08-07T19:22:58Z",
        "body": "Here's a slightly different case, where extra _trailing_ spaces are not removed:\n\n``` typescript\nlet publisher: {};\n\n(<any>      publisher).subscribe(item => {\n\n    console.log(item);\n});\n```\n\nThe spaces after `<any>` are not affected by autoformat, but any extra spaces before `<any>` are removed correctly.\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2015-08-07T22:45:30Z",
        "body": "//CC: @SaschaNaz, you might find this interesting.\n"
      },
      {
        "user": "saschanaz",
        "created_at": "2015-08-09T07:38:05Z",
        "body": "Hmm, I'll take a look.\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2015-08-11T19:30:45Z",
        "body": "thanks @SaschaNaz!\n"
      }
    ]
  },
  {
    "number": 4026,
    "title": "Isolate transpile from type checker code.",
    "created_at": "2015-07-25T17:10:47Z",
    "closed_at": "2019-07-29T21:50:38Z",
    "labels": [
      "Suggestion",
      "Needs Proposal",
      "Help Wanted",
      "Effort: Moderate"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/4026",
    "body": "Currently, if you want to do runtime transpilation in the browser you need to ship the entire compiler to the browser (~2.3MB).  I suspect that the code required for just the `transpile` method would be much smaller if it could be isolated from the type checking code\n\nI would like to see the two separated into different files so I can ship the transpiler to the browser in a relatively small package and do runtime transpilation of TypeScript into JavaScript.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/4026/comments",
    "author": "MicahZoltu",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2015-07-25T19:05:48Z",
        "body": "It should be simple to separate transpile from services, that saves you 500-600 KB; separating it from the checker is more work though. if would be open to taking a PR for the first, and discussing the design of the second.\n"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2019-07-29T21:50:38Z",
        "body": "Closing due to lack of other feedback or demand"
      }
    ]
  },
  {
    "number": 4004,
    "title": "amd reexport symbols",
    "created_at": "2015-07-23T19:01:02Z",
    "closed_at": "2021-12-15T21:58:43Z",
    "labels": [
      "Bug",
      "Help Wanted",
      "Effort: Moderate"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/4004",
    "body": "I have been trying the new reexport feature together with amd modules, and found a strange detail.\n\nIt seem like the compiler does not understand that the symbol need to be reexported. So this code : \n\n``` typescript\n/// <amd-dependency path=\"text!extern_view.html\" name=\"view\"/>\ndeclare var view: string;\n\nexport {view};\nexport function test() {}\n```\n\nusing the tsc --module amd ...\n\nemits the following : \n\n``` javascript\ndefine([\"require\", \"exports\", \"text!extern_view.html\"], function (require, exports, view) {\n    function test() {\n    }\n    exports.test = test;\n});\n```\n\nhere the function is exported but the imported amd module is totally ignored, and therefor not reexported.\n\nIf, I ... on the other hand make a variable using this export and the export this new value, it works as expected, like this : \n\n``` typescript\n/// <amd-dependency path=\"text!extern_view.html\" name=\"view_tmp\"/>\ndeclare var view_tmp: string;\n\nlet view = view_tmp;\nexport {view};\nexport function test() {}\n```\n\nIs this a known issue or have I misunderstood the reexport idea ?\n\nRegards \n\n/BL\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/4004/comments",
    "author": "druppy",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2021-12-15T21:58:42Z",
        "body": "Closing due to lack of activity - presumed fixed or irrelevant by now"
      }
    ]
  },
  {
    "number": 3885,
    "title": "GoToDef/FindAllRefs for object binding elements do not trace back to their defining property",
    "created_at": "2015-07-16T00:01:08Z",
    "closed_at": "2019-02-22T02:02:18Z",
    "labels": [
      "Bug",
      "Fixed",
      "Help Wanted"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/3885",
    "body": "``` TypeScript\ninterface I {\n    /*def*/property: string;\n}\n\nlet x: I;\nlet { /*use*/property } = x;\n```\n\nGo to definition on `use` doesn't currently take us to `def`; it instead jumps back to `use`.\n\nLikewise, find all references on `use` should give us the identifier at `def` but it currently does not.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/3885/comments",
    "author": "DanielRosenwasser",
    "comments": [
      {
        "user": "weswigham",
        "created_at": "2015-07-18T07:28:34Z",
        "body": "IMO, the existing behavior makes sense since `property` is an assignment. A destructing assignment, sure, but still an assignment. If I wanted to see where, in scope, the `property` variable comes from, the current behavior is correct.\n"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2015-07-18T18:45:55Z",
        "body": "We made a similar change with shorthand properties in #1184 and it is a desirable change. The idea is that in this example, if you are already on that definition you are clearly disinterested in where the variable definition is coming from, so we allow you to jump to the property definition.\n\nThis way, you can always get back to the property from a variable declaration with an extra `F12` or whatever your editor's Go-To-Definition supports.\n\nFor example:\n\n``` TypeScript\ninterface I {\n    /*afterTwoGoToDefs*/property: string;\n}\n\nlet x: I;\nlet { /*afterOneGoToDef*/property } = x;\n\n/*goToDefOnHere*/property += \" hello\";\n```\n"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2019-02-22T02:02:16Z",
        "body": "I dunno who did it but this is fixed now."
      }
    ]
  },
  {
    "number": 3859,
    "title": "False error when using directive prologues inside constructor with initialized properties.",
    "created_at": "2015-07-14T21:09:11Z",
    "closed_at": "2015-07-23T07:09:37Z",
    "labels": [
      "Bug",
      "Fixed",
      "Help Wanted"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/3859",
    "body": "```\nclass A {\n}\n\nclass B extends A {\n    public s: number = 9;\n\n    constructor () {\n        \"use strict\";   // no error?\n        super();\n    }\n}\n```\n\nresults in \"A 'super' call must be the first statement in the constructor when a class contains initialized properties or has parameter properties.\"\n\nconnected issue #3454\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/3859/comments",
    "author": "ShyykoSerhiy",
    "comments": [
      {
        "user": "DanielRosenwasser",
        "created_at": "2015-07-15T06:57:15Z",
        "body": "Yeah, this seems like a bug, though, keep in mind that a class is implicitly going to be parsed in strict mode in 1.5 - though, we don't have strict mode semantics if a method handle loses its `this` context.\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2015-07-16T00:00:21Z",
        "body": "@ShyykoSerhiy feel free to send a PR.\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2015-07-23T07:09:37Z",
        "body": "thanks @ShyykoSerhiy !\n"
      }
    ]
  },
  {
    "number": 3849,
    "title": "Occurrence highlighting doesn't work on class expression members",
    "created_at": "2015-07-13T23:07:15Z",
    "closed_at": "2015-07-14T22:59:39Z",
    "labels": [
      "Bug",
      "Fixed",
      "Help Wanted"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/3849",
    "body": "``` TypeScript\n var x = class C {\n    [|public|] x;\n    [|public|] y;\n}\n\nvar y = class D {\n    [|static|] a;\n    [|static|] private b;\n}\n```\n\nI don't believe occurrence highlighting works for any of these modifiers.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/3849/comments",
    "author": "DanielRosenwasser",
    "comments": [
      {
        "user": "DanielRosenwasser",
        "created_at": "2015-07-14T00:02:05Z",
        "body": "@DickvdBrink no pressure, but would you be interested in this issue?\n"
      },
      {
        "user": "DickvdBrink",
        "created_at": "2015-07-14T06:38:28Z",
        "body": "Yeah will do. Hopefully I have some time tonight :)\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2015-07-15T23:57:42Z",
        "body": "thanks @DickvdBrink \n"
      }
    ]
  },
  {
    "number": 3840,
    "title": "Occurrences highlighting should support the 'abstract' keyword",
    "created_at": "2015-07-13T17:43:37Z",
    "closed_at": "2015-07-14T00:11:19Z",
    "labels": [
      "Bug",
      "Fixed",
      "Help Wanted"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/3840",
    "body": "``` TypeScript\nabstract class C {\n    abstract foo();\n    abstract bar();\n}\n\nabstract class D {\n    abstract baz();\n}\n```\n\nOccurrences for `abstract` on methods/properties in the same class should all get highlighted. They should potentially highlight their owning class's `abstract`. Not sure about `abstract` on `C` triggering `abstract` on `D`\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/3840/comments",
    "author": "DanielRosenwasser",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2015-07-13T18:58:21Z",
        "body": "looks like a bug-level change. @aozgaa can pick it up if he has time.\n"
      },
      {
        "user": "DickvdBrink",
        "created_at": "2015-07-13T20:51:08Z",
        "body": "Might be a dumb question but asking it anyway xD\n\nWhen I trigger the highlight on `abstract class C` should it highlight the members too?  \n"
      },
      {
        "user": "mhegazy",
        "created_at": "2015-07-13T20:54:57Z",
        "body": "i would say highlighting an `abstract` modifier for the class, should highlight all the abstract modifiers on members, and vice versa.\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2015-07-14T00:11:18Z",
        "body": "thanks @DickvdBrink \n"
      }
    ]
  },
  {
    "number": 3813,
    "title": "Cover src/server/session.ts - Session API with tests",
    "created_at": "2015-07-10T18:03:06Z",
    "closed_at": "2015-08-04T01:28:00Z",
    "labels": [
      "Bug",
      "Fixed",
      "Help Wanted",
      "API"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/3813",
    "body": "Since we now export Session in tslssl.js, we should add tests for its public API.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/3813/comments",
    "author": "weswigham",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2015-07-13T21:05:03Z",
        "body": "@weswigham care to send us some tests :)\n"
      },
      {
        "user": "weswigham",
        "created_at": "2015-07-13T22:15:44Z",
        "body": "@mhegazy will do\n"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2015-08-04T04:53:52Z",
        "body": "Thanks @weswigham!\n"
      }
    ]
  },
  {
    "number": 3486,
    "title": "typescriptServices.js is not \"strict mode\" friendly",
    "created_at": "2015-06-12T10:12:39Z",
    "closed_at": "2015-07-09T19:09:53Z",
    "labels": [
      "Bug",
      "Fixed",
      "Help Wanted",
      "API"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/3486",
    "body": "I am using typescript for a project where strict mode is enabled and I have some problem using typescriptServices.js because it is not \"strict mode\" friendly. As an example, \"arguments\" must not be used as an identifier ...\n\nThis is not a big deal, hope this issue will soon be fixed ;)\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/3486/comments",
    "author": "ghost",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2015-06-12T16:15:24Z",
        "body": "Pleas feel free to send PRs to fix these issue.\n"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2015-07-09T19:09:53Z",
        "body": "Hey @Yellowmat, @ShyykoSerhiy sent us a fix which should be in our `master` branch. Give it a try and let us know how it works out.\n"
      },
      {
        "user": "ghost",
        "created_at": "2015-07-10T09:42:33Z",
        "body": "Hi @DanielRosenwasser !\n\nThanks for the fix !\n\nI'll test this ASAP, no doubt it will work ;)\n"
      }
    ]
  },
  {
    "number": 3454,
    "title": "Directive prologues are not preserved",
    "created_at": "2015-06-09T20:59:17Z",
    "closed_at": "2015-07-15T23:53:42Z",
    "labels": [
      "Bug",
      "Fixed",
      "Help Wanted"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/3454",
    "body": "``` typescript\nclass C {\n    constructor (private foo) {\n        \"use strict\";\n    }\n}\n```\n\nis transformed into\n\n``` js\nvar C = (function () {\n    function C(foo) {\n        this.foo = foo;\n        \"use strict\";\n    }\n    return C;\n})();\n```\n\nthus the directive prologue is lost.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/3454/comments",
    "author": "olov",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2015-07-15T23:53:42Z",
        "body": "thanks @ShyykoSerhiy!\n"
      }
    ]
  },
  {
    "number": 3440,
    "title": "typeof const enum",
    "created_at": "2015-06-09T11:57:59Z",
    "closed_at": "2023-07-05T22:29:25Z",
    "labels": [
      "Bug",
      "Help Wanted"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/3440",
    "body": "```\nconst enum Bar { a, b}\nvar c: typeof Bar.a; // 'const' enum can only be used in property or index access expressions or the right hand side of an import declaration or export assignment.\n```\n\nShould it be allowed?\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/3440/comments",
    "author": "jbondc",
    "comments": [
      {
        "user": "danquirk",
        "created_at": "2015-06-09T20:04:45Z",
        "body": "Seems reasonable. The error is clearly wrong as it's referencing the restrictions on const enums in value positions.\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2015-06-09T20:38:35Z",
        "body": "is not that just `Bar`? \n\nWhile I agree that this is an incorrect behavior, i do not see a real motivation to fix it.\n"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2015-06-10T15:15:50Z",
        "body": "Your first comment was about `typeof e.m`, but now you're talking about `typeof e`. Those are two very different things -- `typeof e.m` is a long way of writing `e`, but there's a reasonable use case to allow `typeof e`.\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2015-06-11T19:40:31Z",
        "body": "@jbondc feel free to send a PR for this if this is interesting to you. please limit the scope to skipping the error reporting if the use of const enum is in a type position.\n"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2015-06-17T15:12:17Z",
        "body": "> but there's a reasonable use case to allow `typeof e`\n\n@RyanCavanaugh considering that const enums do not always have a runtime representation, could you explain what that might be?\n"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2015-06-17T15:32:45Z",
        "body": "In input positions (e.g. function parameters), `typeof E` seems equally valid whether `E` is const or not\n"
      },
      {
        "user": "NoelAbrahams",
        "created_at": "2017-11-20T17:44:20Z",
        "body": "@mhegazy, can this be added to the next milestone? Seems an obvious bug that needs fixing.\r\n\r\nUse case:\r\n\r\n```ts\r\nconst enum Bar {\r\n  good = 1,\r\n  bad = 2,\r\n  ugly = 4\r\n}\r\n\r\n// type Rating = 'good' | 'bad' | 'ugly';\r\ntype Rating = keyof typeof Bar; // Error: 'const' enums can only be used in property or index access expressions...\r\n```\r\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2017-11-20T19:01:54Z",
        "body": "The bug is marked as `help wanted`. if we do get a PR for fixing it we will include it in the next release."
      },
      {
        "user": "NoelAbrahams",
        "created_at": "2017-11-20T19:59:49Z",
        "body": "Ah, okay. I was under the impression that only minor bugs are left to the community."
      },
      {
        "user": "mhegazy",
        "created_at": "2017-11-20T20:06:55Z",
        "body": "We do accept PRs for bugs and features regardless of complexity."
      },
      {
        "user": "beheh",
        "created_at": "2018-05-14T13:12:39Z",
        "body": "The `keyof typeof Bar` issue was reraised in #21031 and fixed in #21083 (which was released with 2.7). As such this issue can probably be closed."
      },
      {
        "user": "jakebailey",
        "created_at": "2023-07-05T22:29:25Z",
        "body": "Just looking at ancient issues; yeah, this one is fixed as `keyof typeof Bar` now works."
      }
    ]
  },
  {
    "number": 3411,
    "title": "Should treat const and enum (at least const enum) value the same as literals for indexers.",
    "created_at": "2015-06-08T03:41:16Z",
    "closed_at": "2015-10-08T22:39:27Z",
    "labels": [
      "Suggestion",
      "Fixed",
      "Help Wanted",
      "Effort: Moderate"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/3411",
    "body": "``` typescript\nconst DATA_END_INDEX = 2;\n\nenum OptimizedDataIndex {\n    start,\n    data,\n    end\n}\n\ninterface OptimizedData {\n    0: number;\n    1: any[];\n    2: number;\n}\n\nvar data: OptimizedData;\nvar start = OptimizedData[OptimizedDataIndex.start];\nvar end = OptimizedData[DATA_END_INDEX];\n// expecting no error. `start` and `end` should be numbers.\n```\n\nThis should also apply to something like tuples directly written as `[TypeA, TypeB, ...]`.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/3411/comments",
    "author": "vilicvane",
    "comments": [
      {
        "user": "danquirk",
        "created_at": "2015-06-08T21:46:47Z",
        "body": "Presumably your example intended to index into `data` and not the interface type. This is sort of the simplest case of constant propogation/flow control since the compiler can at least assume the name<->value pairs here are immutable.\n"
      },
      {
        "user": "vilicvane",
        "created_at": "2015-06-10T16:55:25Z",
        "body": "So can I take that as \"this suggestion is reasonable\"? :D\n"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2015-06-10T18:00:32Z",
        "body": "Summary: When we see a property access where the indexing expression is an enum member, we should resolve the property access as if the indexing expression were actually the computed value of the enum member's value.\n\nIn other words, `var x = Foo[E.bar]` is equivalent to `var x = Foo[2]` if we can resolve `E.bar` to its value `2`.\n"
      },
      {
        "user": "vilicvane",
        "created_at": "2015-06-11T01:35:54Z",
        "body": "And also consts, I think.\n"
      },
      {
        "user": "jbondc",
        "created_at": "2015-08-28T14:29:29Z",
        "body": "Added a patch for the const enum access. Would also like to see these work:\n\n```\nconst one = 1;\nmodule dot {\n   export const one = 1; \n}\nconst enum numbers {\n    one = 1\n}\nconst oneRef = one;\n\ninterface OptimizedData {\n    0: number;\n    1: any[];\n    2: number;\n}\nlet data:OptimizedData \n\n// works\ndata[1] // any[]\ndata[numbers.one] // any[]\n\n// should work\ndata[one] // any[]\ndata[dot.one] // any[]\ndata[oneRef] // any[]\n```\n\nThe last 3 could work but require better tracking of constants and constant propagation like @danquirk mentioned. Don't think you need flow control to do it properly, have gotten it working without anyways.\n"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2015-10-05T22:50:45Z",
        "body": "Approved for `const enum` members only. @jbondc can you get your PR up-to-date?\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2015-10-05T23:07:55Z",
        "body": "@jbondc, we would appreciate it if you can keep it only for const enums, and not for generic constant propagation.\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2015-10-08T22:41:26Z",
        "body": "thanks @jbondc!\n"
      }
    ]
  },
  {
    "number": 3326,
    "title": "jake not compiling tsserver.js",
    "created_at": "2015-06-01T18:06:51Z",
    "closed_at": "2015-06-24T20:49:49Z",
    "labels": [
      "Bug",
      "Fixed",
      "Help Wanted"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/3326",
    "body": "When I make a change (e.g. in emitter.ts or program.ts), sometimes tsserver.js is not updated. Other files (tsc.js, typescript.js, and typescriptServices.js) are.  If I delete the tsserver.js file and jake again, it will be created.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/3326/comments",
    "author": "unional",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2015-06-01T19:20:17Z",
        "body": "JakeFile.js does not list them as dependencies to this task. adding them should solve the issue. a PR would be appreciated.\n"
      }
    ]
  },
  {
    "number": 3287,
    "title": "Do not strip end of file newlines in emit",
    "created_at": "2015-05-27T21:45:27Z",
    "closed_at": "2023-07-07T18:54:03Z",
    "labels": [
      "Suggestion",
      "Help Wanted"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/3287",
    "body": "When using `tsc`, every file output does not have a newline at the end of the file. Is this intended? If so, it would be nice to have a flag to change this behavior.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/3287/comments",
    "author": "uber5001",
    "comments": [
      {
        "user": "danquirk",
        "created_at": "2015-05-27T21:53:50Z",
        "body": "To what end? Can you not put newlines at the end of your source files if there's some need for this in your toolchain? Or are you saying your EOF newlines are getting removed?\n"
      },
      {
        "user": "uber5001",
        "created_at": "2015-05-27T22:04:52Z",
        "body": "The original typescript files are formatted with newlines before EOF, and the output es5 files are not.\n"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2015-08-05T16:57:18Z",
        "body": "Happy to take a PR that patches this up\n"
      },
      {
        "user": "jakebailey",
        "created_at": "2023-07-07T18:54:03Z",
        "body": "Just looking at old issues; I tested the emitter on inputs without a trailing newline all the way back to 0.8 and every version has added a trailing newline, so I'm pretty sure this is not a problem (and maybe never was). But if this really is still happening, happy to reopen."
      }
    ]
  },
  {
    "number": 3277,
    "title": "`tsc --watch` recreates deleted source files",
    "created_at": "2015-05-27T10:44:23Z",
    "closed_at": "2015-10-01T23:16:26Z",
    "labels": [
      "Bug",
      "Fixed",
      "Help Wanted"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/3277",
    "body": "In current stable and also master (de88ede4feeabab91d032359406a19166ed5bbb2), `tsc --watch` will keep recreating `file.js` during recompilation even when the original `file.ts` source file is removed. Only workaround is to restart `tsc --watch` to make it forget about `file.ts`.\n\nFor example,\n\n```\n$ ls incorrect_recreation/\ntest2.ts  test.ts  tsconfig.json\n$ cat tsconfig.json\n<empty>\n```\n\n```\n$ node bin/tsc.js --watch -p incorrect_recreation/\nmessage TS6042: Compilation complete. Watching for file changes.\n```\n\nIn another terminal:\n\n```\n$ ls\ntest2.js  test2.ts  test.js  test.ts  tsconfig.json # as expected\n$ rm test.ts test.js \n$ ls\ntest2.js  test2.ts  tsconfig.json # so, no trace of test.js or test.ts now\n$ touch test2.ts # force a recompile and wait\n$ ls\ntest2.js  test2.ts  test.js  tsconfig.json # test.js should not have been recreated\n```\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/3277/comments",
    "author": "alexzorin",
    "comments": [
      {
        "user": "danquirk",
        "created_at": "2015-05-27T19:43:51Z",
        "body": "I assume tsconfig in this case isn't explicitly listing any files?\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2015-05-27T19:55:50Z",
        "body": "This is not specific to tsconfig, though tsconfig is required for to a clear manifestation. the issue is that our watch notification catches only the edit but not the delete notification, so we do not really know that the file is deleted.\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2015-05-27T21:30:15Z",
        "body": "looking at the API i am not sure if there is an easy way we can detect the deleted event without having to hit the disk on every change request, or checking file stats all the time.. we will need to look more into this.\n"
      },
      {
        "user": "alexzorin",
        "created_at": "2015-05-27T21:33:32Z",
        "body": "Is there a particular reason that watches are created on the source file themselves and not the directory in which they are contained? This way, info is provided on file edit (albeit not a full `stat()`), as well as creation/move/deletion within the directory. I believe this is how tools like `tail` work.\n\nThere is second issue in tsc that it does not pick up new `*.ts` files, which might also be solved this way.\n\nSpeaking only generally, I am not sure whether node provides the adequate APIs/portability to achieve this.\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2015-05-27T21:40:21Z",
        "body": "The problem is node has two interfaces, watchFile, this is cross-platform, but only does files, and watch, not cross-platform and does directories. We have looked into this with the tsconfig file and did not find a good way that 1. works on all platforms, 2. does not have a dependency on a third party node package that can not be used in other engines and 3. has good performance. the conclusion was adding and removing files is not common enough to warrant the complexity. this assumption may not be true now as more ppl run into this issue.\n"
      },
      {
        "user": "DickvdBrink",
        "created_at": "2015-05-28T20:47:01Z",
        "body": "Maybe we could check the stat.size property (which the `watchFile` listener provides) and if It is `0` it means the file is moved/deleted or someone just emptied the file (but that is not that common I think)\n\nSo that would not increase the disk hits that much (but doesn't solve newly created files though).\nIt is a bit of suboptimal solution I guess.. :]\n"
      },
      {
        "user": "Arnavion",
        "created_at": "2015-06-18T00:51:51Z",
        "body": "@mhegazy fs.watchFile already allows you to know if the watched file is deleted. The \"current\" Stats object has modified time set to the zero Date, so `mtime.getTime() === 0` can be used to detect deletion. (It's because libuv calls the callback with a default zero-initialized uv_stat_t reference, although this is not documented in libuv's nor node's docs as far as I can see).\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2015-06-18T02:01:43Z",
        "body": "Nice. Thanks @Arnavion, that would do the trick. We would accept a PR implementing @Arnavion's proposal.\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2015-10-01T23:17:00Z",
        "body": "Thanks @ShyykoSerhiy \n"
      }
    ]
  },
  {
    "number": 3276,
    "title": "Diagnostic elaboration is not consistently reported in language service",
    "created_at": "2015-05-27T07:07:39Z",
    "closed_at": "2024-07-15T18:11:41Z",
    "labels": [
      "Bug",
      "Help Wanted"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/3276",
    "body": "Adapted from #3275:\n\n``` TypeScript\nclass GenericThingamabob<T> {\n    constructor(private entity: T) {}\n    add(item: T) { }\n}\n\nclass CouponInfo {\n    private couponTag: {};\n}\n\nclass Snake {\n    private snakeTag: {};\n}\n\nvar blah = new GenericThingamabob(new CouponInfo());\n\nblah.add(new Snake());\n//       ~~~~~~~~~~~\nvar x: CouponInfo = new Snake();\n//  ~\n```\n\nOn the first error, I get\n\n```\nArgument of type 'Snake' is not assignable to parameter of type 'CouponInfo'.\n  Property 'couponTag' is missing in type 'Snake'\n```\n\nOn the second, I get\n\n```\nType 'Snake' is not assignable to type 'CouponInfo'.\n```\n\nNote that if you turned `blah.add(new Snake());` into a variable assignment like `var a: CouponInfo = new Snake()`, you'll get the same issue.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/3276/comments",
    "author": "DanielRosenwasser",
    "comments": [
      {
        "user": "Andarist",
        "created_at": "2023-08-01T22:43:22Z",
        "body": "There is a complex interplay here between `headMessage`, `overrideNextErrorInfo `, and perhaps also `lastSkippedInfo`.\r\n\r\nCalls coming from `checkVariableLikeDeclaration` don't have any `headMessage`. Based on that an early return might be chosen in `reportErrorResults` based on `!headMessage && maybeSuppress` (this early return also assigns to `lastSkippedInfo`). This basically happens when we only test `var x: CouponInfo = new Snake();` and in such a case the reported errors looks like this:\r\n> Property 'couponTag' is missing in type 'Snake' but required in type 'CouponInfo'.(2741)\r\n\r\nIt's worth noting that in this scenario the default head message that would be computed (\"Type 'Snake' is not assignable to type 'CouponInfo'.(2322)\") is not reported exactly because it was skipped.\r\n\r\nThe elaboration is reported here though based on the `reportUnmatchedProperty` call that happened when checking this variable declaration.\r\n\r\nWhen we put both a function call and a variable declaration in the file, like this\r\n```ts\r\nblah.add(new Snake());\r\nvar x: CouponInfo = new Snake();\r\n```\r\n\r\nThen this call never~ skips reporting the `headMessage` part because it comes with its own `headMessage`. The elaboration part is reported together with it because `reportUnmatchedProperty` gets called when checking that function call.\r\n\r\nSo why the elaboration part is not reported for the variable declaration case? It's because when checking that we never get to `reportUnmatchedProperty`. It happens within `propertiesRelatedTo` but that gets called transitively by `recursiveTypeRelatedTo` and that's a heavily cached function. In the current implementation, it is intended that for each relation key errors are not always elaborated in full (it looks to me that it's the whole purpose of `RelationComparisonResult.Reported`). \r\n\r\nSo when checking the variable declaration we hit the cache, we never go into `propertiesRelatedTo`+`reportUnmatchedProperty` and thus we never `overrideNextErrorInfo++`. So this time in `reportErrorResults` we don't skip reporting the default head message but we also never have a chance to report the elaboration."
      }
    ]
  },
  {
    "number": 3268,
    "title": "Cannot rename LHS of import specifier when its name is prefixed with two underscores",
    "created_at": "2015-05-26T19:42:52Z",
    "closed_at": "2017-07-06T23:06:17Z",
    "labels": [
      "Bug",
      "Help Wanted"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/3268",
    "body": "**`fileA.ts`**\n\n``` TypeScript\nexport function __foo() {\n}\n```\n\n**`fileB.ts`**\n\n``` TypeScript\nimport { __foo/**/ as bar } from \"./fileA\";\n\nbar();\n```\n\nTry renaming `__foo` at the marker. This won't work.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/3268/comments",
    "author": "DanielRosenwasser",
    "comments": [
      {
        "user": "weswigham",
        "created_at": "2017-07-06T23:06:17Z",
        "body": "This should be fixed by #16915."
      }
    ]
  },
  {
    "number": 3028,
    "title": "Formatting of unary operands is missing some cases",
    "created_at": "2015-05-04T22:57:03Z",
    "closed_at": "2023-08-10T22:18:15Z",
    "labels": [
      "Bug",
      "Help Wanted"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/3028",
    "body": "The following lines are not formatted:\n\n``` ts\n+     1;\n-      1;\n```\n\nI expect them to be formatted to the following:\n\n``` ts\n+1;\n-1;\n```\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/3028/comments",
    "author": "JsonFreeman",
    "comments": [
      {
        "user": "Andarist",
        "created_at": "2023-08-01T18:59:23Z",
        "body": "This issue is already fixed, cc @jakebailey "
      }
    ]
  },
  {
    "number": 2831,
    "title": "TSServer: completions request should return isMemberCompletion & isNewIdentifierLocation",
    "created_at": "2015-04-19T21:03:30Z",
    "closed_at": "2018-07-16T17:10:24Z",
    "labels": [
      "Suggestion",
      "Fixed",
      "Help Wanted",
      "API",
      "VS Code Tracked"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/2831",
    "body": "This eases the proposal of snippets on the editor side. For example if the completions are member completions no or different snippets can be provided\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/2831/comments",
    "author": "dbaeumer",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2015-04-20T19:28:43Z",
        "body": "Thanks @dbaeumer. PRs welcomed\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2016-12-16T00:42:58Z",
        "body": "As we talked earlier, VSCode will also need some information about the lexical location for the completion. @mjbvz can you provide the full list of flags needed? "
      },
      {
        "user": "mjbvz",
        "created_at": "2018-07-16T17:10:24Z",
        "body": "I believe this has been handled by #17488"
      }
    ]
  },
  {
    "number": 2779,
    "title": "Property initializers capture the wrong 'arguments' value",
    "created_at": "2015-04-15T21:36:50Z",
    "closed_at": "2024-03-22T23:47:57Z",
    "labels": [
      "Bug",
      "Help Wanted"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/2779",
    "body": "When a variable named `arguments` is used in a property initializer, our emitted code refers to the wrong `arguments`.\n\nInput\n\n``` TypeScript\nvar arguments = 100;\n\nclass C {\n    y = arguments;\n    constructor() {\n    }\n}\n```\n\nOutput\n\n``` JavaScript\nvar arguments = 100;\nvar C = (function () {\n    function C() {\n        this.y = arguments;\n    }\n    return C;\n})();\n\n```\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/2779/comments",
    "author": "DanielRosenwasser",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2015-05-07T03:51:30Z",
        "body": "This looks like the instance side of #442.\n"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2024-03-22T23:47:57Z",
        "body": "All cool code is in strict mode now"
      }
    ]
  },
  {
    "number": 2632,
    "title": "invoking methods on numbers",
    "created_at": "2015-04-06T16:05:44Z",
    "closed_at": "2015-06-24T22:07:20Z",
    "labels": [
      "Bug",
      "Help Wanted"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/2632",
    "body": "The rules for numeric constants do not follow the same rules for numeric variables. I don't know if this is an error, or just an oddity.  \n\ntest1 and test4 behave as expected. Numbers are converted to strings.\n\ntest2 does not compile without spaces. \n\ntest3 does compile, but strips the spaces.  This is not a valid javascript without the space.  It would be valid with the space.\n\nThe Typescript compiles to this javascript.\n\nTypescript:\n\n``` ts\n  var i:number = 1;\n  var test1 = i.toString();  \n\n  // var test2 = 2.toString(); // compiler error\n  var test3 = 3 .toString(); // runtime error\n  var test4 = new Number(4).toString();\n```\n\nJavaScript:\n\n``` js\nvar i = 1;\nvar test1 = i.toString();\n// var test2 = 2.toString(); // compiler error\nvar test3 = 3.toString(); // runtime error\nvar test4 = new Number(4).toString();\n```\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/2632/comments",
    "author": "TimKelly2",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2015-04-06T16:27:14Z",
        "body": "Summary:\ntest1 is the correct behavior\ntest2 is the correct behavior (the right thing to write is 2..toString())\n**test3 is a bug**\ntest4 is the correct behavior\n"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2015-04-06T19:48:04Z",
        "body": "11.2.1 describes behavior, not syntax.\n\nThe key section is 7:\n\n> The source text is scanned from left to right, repeatedly taking the longest possible sequence of characters as the next input element.\n\nA trailing dot is an allowed production of `DecimalLiteral` (7.8.3), so the sequence `2.` is greedily interpreted as a `DecimalLiteral`\n"
      },
      {
        "user": "CyrusNajmabadi",
        "created_at": "2015-04-06T19:56:58Z",
        "body": "Note: this is due to the following lexical grammar rule in the ES5 specification:\n\n```\nDecimalLiteral ::\n    DecimalIntegerLiteral . DecimalDigits_opt ExponentPart_opt\n```\n\nBecause of that rule, along with the relevant part of the spec that Ryan quoted, it follows that \"2.toString()\" is scanned into the following input elements\n\n```\n2.\ntoString\n(\n)\n```\n\nThere is no grammar production that can handle that sequence of input elements.   Changing to \"2..toString()\" produces this sequence of input elements.\n\n```\n2.\n.\ntoString\n(\n)\n```\n\nThis is properly handled during parsing as the invocation `()` of a property-access-expression `2. . toString`\n\n> I don't know if this is an error, or just an oddity. \n\nIt's an oddity due to the historical decisions of JavaScript with their grammar.  In languages like C#, `2.ToString()` parses properly as `2.` is not a legal numeric constant.\n"
      }
    ]
  },
  {
    "number": 2628,
    "title": "Missing space after formatting array return type.",
    "created_at": "2015-04-06T06:22:24Z",
    "closed_at": "2015-05-26T23:46:35Z",
    "labels": [
      "Bug",
      "Fixed",
      "Help Wanted"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/2628",
    "body": "In 1.5 alpha (VS 2013):\n\n``` typescript\nfunction listAPIFiles(path: string): string[] {/*press enter here*/}\n```\n\nResults in:\n\n``` typescript\nfunction listAPIFiles(path: string): string[]{\n}\n```\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/2628/comments",
    "author": "vilicvane",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2015-04-06T17:39:27Z",
        "body": "There might be a duplicate bug on this somewhere\n"
      },
      {
        "user": "vilicvane",
        "created_at": "2015-04-07T03:00:25Z",
        "body": "1.4 has a similar bug, 1.5 seems to have only fixed it partially.\n"
      }
    ]
  },
  {
    "number": 2432,
    "title": "'arguments' object not supported by findAllRefs/getOccurrences",
    "created_at": "2015-03-20T00:19:39Z",
    "closed_at": "2023-08-01T20:47:36Z",
    "labels": [
      "Bug",
      "Help Wanted"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/2432",
    "body": "``` TypeScript\nfunction foo() {\n    arguments;\n\n    arguments;\n}\n```\n\n_Expected_: Find all refs on either `arguments` will give you both of the above. Get occurrences will highlight both.\n\n_Actual_: No highlighting, no references found.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/2432/comments",
    "author": "DanielRosenwasser",
    "comments": [
      {
        "user": "Andarist",
        "created_at": "2023-08-01T18:39:02Z",
        "body": "This works OK today, the issue can be closed. cc @jakebailey "
      }
    ]
  },
  {
    "number": 2282,
    "title": "Arrow functions require no line terminator before arrow `=>` token",
    "created_at": "2015-03-10T01:06:43Z",
    "closed_at": "2015-03-16T01:59:54Z",
    "labels": [
      "Bug",
      "Fixed",
      "Breaking Change",
      "Help Wanted"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/2282",
    "body": "I just noticed this today while working on implementing rest parameters in arrow functions in v8. v8 and SpiderMonkey are both getting this wrong right now, but Traceur and Babel both get this right.\n\nIt's probably a pretty simple fix\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/2282/comments",
    "author": "caitp",
    "comments": [
      {
        "user": "danquirk",
        "created_at": "2015-03-10T01:11:25Z",
        "body": "Do we need/want to enforce the same restriction in TypeScript or just ensure that the ES6 emit for arrow functions doesn't preserve such newlines? It would be a breaking change to disallow this now, we've been allowing this for ES5:\n\n``` ts\nvar x = () \n=> {}\n```\n\nemits\n\n``` js\nvar x = function () {\n};\n```\n"
      },
      {
        "user": "caitp",
        "created_at": "2015-03-10T01:13:06Z",
        "body": "I should have clarified:\n\n``` js\nvar x = (a)\n  => 1\n```\n\nshould translate to:\n\n``` js\nvar x = (a);\n  => 1; // syntax error, unexpected `=>`\n```\n"
      },
      {
        "user": "caitp",
        "created_at": "2015-03-10T01:13:52Z",
        "body": "I think it's unlikely anyone is using this syntax, since it's much harder to read, but if it breaks apps then it might not be worth fixing.\n"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2015-03-10T01:22:44Z",
        "body": "@CyrusNajmabadi and I just discussed this offline; apparently we've sort of known about this, but haven't committed to it since it's a breaking change.\n\nThat said, he and I would prefer to take the breaking change.\n"
      }
    ]
  },
  {
    "number": 2272,
    "title": "Emit destructuring patterns in 'for...in' statements for ES3/5",
    "created_at": "2015-03-09T18:25:37Z",
    "closed_at": "2024-03-01T23:06:21Z",
    "labels": [
      "Bug",
      "Help Wanted"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/2272",
    "body": "The following is allowed by the ES6 grammar:\n\n``` ts\nfor (var [a, b] in []) { }\n```\n\nThis results in a type check error, because it doesn't make sense to destructure a string key. But it should still emit correctly downlevel. Right now we emit:\n\n``` js\nfor (var _a = void 0, a = _a[0], b = _a[1] in []) { }\n```\n\nwhich is incorrect.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/2272/comments",
    "author": "JsonFreeman",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2015-03-10T20:02:02Z",
        "body": "so what is the proposed emit?\n"
      },
      {
        "user": "JsonFreeman",
        "created_at": "2015-03-10T20:19:26Z",
        "body": "Similar to 'for...of', but 'for...in'-ified:\n\n``` js\nfor (var _a in []) {\n    var a = _a[0], b = _a[1];\n}\n```\n"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2024-03-01T23:06:21Z",
        "body": "Doesn't seem like anyone has noticed this"
      }
    ]
  },
  {
    "number": 1976,
    "title": "Incorrect error in declaration emit for set accessors",
    "created_at": "2015-02-07T04:05:42Z",
    "closed_at": "2017-11-08T18:02:39Z",
    "labels": [
      "Bug",
      "Help Wanted"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/1976",
    "body": "Compile the following with -declaration:\n\n``` ts\nmodule M {\n    interface I { }\n    export class C {\n        set foo(x: I) { }\n    }\n}\n```\n\nThe error says, \"Parameter 'foo' of public property setter from exported class has or is using private name 'I'.\"\n\nBut it should not be parameter 'foo', it should be parameter 'x'.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/1976/comments",
    "author": "JsonFreeman",
    "comments": [
      {
        "user": "NaridaL",
        "created_at": "2017-09-19T23:25:14Z",
        "body": "For comparison, the error if the return type of a getter is inaccessible doesn't mention anything except the type itself:\r\n\r\n`Return type of public static property getter from exported class has or is using private name '{0}'.`\r\n\r\nI'd suggest bringing the setter error in line with that, which prop is the problem is obvious from the location of the error, and it's a setter -- which parameter it is isn't a big mystery.\r\n\r\n> Parameter of public property setter from exported class has or is using private name 'I'."
      },
      {
        "user": "mhegazy",
        "created_at": "2017-09-19T23:28:44Z",
        "body": "sounds like a good proposal."
      }
    ]
  },
  {
    "number": 1843,
    "title": "Unhelpful error in destructuring assignment",
    "created_at": "2015-01-29T00:06:50Z",
    "closed_at": "2015-04-21T23:19:12Z",
    "labels": [
      "Bug",
      "Fixed",
      "Help Wanted"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/1843",
    "body": "Consider the following:\n`var [,,y] = [1, [[2], 3]];`\n\nThe error I get is Type '[number, (number | number[])[]]' has no property '2'. This is not actionable.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/1843/comments",
    "author": "paulvanbrenk",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2015-01-29T00:52:26Z",
        "body": "any suggestions on how to make this more palatable?\n"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2015-01-29T01:15:55Z",
        "body": "`Tuple of type [blah, (blah | blah[])[]] with cardinality '3' cannot be indexed at '2'`\n\nI dunno.\n"
      },
      {
        "user": "paulvanbrenk",
        "created_at": "2015-01-29T01:19:51Z",
        "body": "The Type .... can be destructured in at most 2 parts. \n\nI would not use the word cardinality.... it has no meaning if you are not familiar with set theory.\n"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2015-01-29T01:32:29Z",
        "body": "with length*\n\nYeah, I'm mostly trying to avoid pluralization for 1-tuples.\n"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2015-04-21T22:56:21Z",
        "body": "@paulvanbrenk, I think @caitp has addressed this in #2238. Can you confirm?\n"
      },
      {
        "user": "caitp",
        "created_at": "2015-04-21T23:13:00Z",
        "body": "It looks similar to #2090\n"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2015-04-21T23:19:04Z",
        "body": "Yup. Just spoke with Paul, this is indeed closed.\n"
      }
    ]
  },
  {
    "number": 1836,
    "title": "Smart indent result is incorrect after a binary operator",
    "created_at": "2015-01-28T20:00:57Z",
    "closed_at": "2016-02-22T17:57:29Z",
    "labels": [
      "Bug",
      "Won't Fix",
      "Help Wanted"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/1836",
    "body": "``` ts\nfunction f() {\n    return a &&\n        b && /*cursor here*/\n}\n```\n\nTriggering smart indent will align the cursor with the return keyword, although I would expect it to be aligned with `b`. This is specifically the case when the previous line ends with a binary operator because there is no ASI interpretation available.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/1836/comments",
    "author": "JsonFreeman",
    "comments": [
      {
        "user": "JsonFreeman",
        "created_at": "2015-02-18T01:27:55Z",
        "body": "Please also fix for ternary conditional operator\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2016-02-22T17:57:29Z",
        "body": "Closing for housekeeping purposes. The behavior outlined in the OP has been in place for over 13 month now and have not got any updates on this issue. Please file a new issue if an action is required.\n"
      }
    ]
  },
  {
    "number": 1835,
    "title": "Use generic for Object.seal(), freeze() and preventExtensions()",
    "created_at": "2015-01-28T19:23:18Z",
    "closed_at": "2015-03-10T19:24:16Z",
    "labels": [
      "Bug",
      "Fixed",
      "Help Wanted"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/1835",
    "body": "To me, seal(), freeze() and preventExtensions() should be declared like:\n`seal<T>(o: T): T;`\n\nAdding it to ObjectConstructor does not help, the 'any' version is taken first.\nThe only solution I've found is to patch lib.d.ts...\nIs there a better way?\nOr could you update lib.d.ts?\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/1835/comments",
    "author": "stephanedr",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2015-01-28T19:38:59Z",
        "body": "I think the main reason is we had these in lib.d.ts before generics were introduced. I think it would be safe to change it, if it breaks exiting code, it most probably did not work in the first place.\n\nA PR would be appreciated. the change should be in src\\lib\\code.d.ts\n"
      }
    ]
  },
  {
    "number": 1833,
    "title": "const enum: supress value comment in emitted javascript",
    "created_at": "2015-01-28T13:28:41Z",
    "closed_at": "2015-02-03T00:37:36Z",
    "labels": [
      "Bug",
      "Fixed",
      "Help Wanted"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/1833",
    "body": "Propose that the value comment associated with const enums be supressed when using \"removeComments\" flag.\n\nTypeScript 1.4:\n\n``` javascript\nconst enum color {red,  green, blue}\nvar c = color.blue;\n```\n\nEmitted javascript (TS 1.4):\n\n``` javascript\nvar c = 2 /* blue */;\n```\n\nChange so that, with \"removeComments\" flag, emits:\n\n``` javascript\nvar c=2;`\n```\n\nThis is consistent with the goal of reducing the size of the generated code (although I'll run the javascript thru the Closure Compiler for release) and it is odd to see these enum values stand out as the only comments in the javascript.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/1833/comments",
    "author": "stanthomas",
    "comments": [
      {
        "user": "NN---",
        "created_at": "2015-01-28T14:41:43Z",
        "body": ":+1: removeComments should remove comments.\n"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2015-01-28T17:22:12Z",
        "body": "Should be a simple fix if someone wants to send a PR over\n"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2015-01-28T18:27:07Z",
        "body": " :-1: ~~This would bring unnecessary complexity and the comments are useful for debugging. If, as you said, you're going to run it through something that's going to strip out the comments, why does it matter?~~\n"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2015-01-28T18:40:23Z",
        "body": "I don't think it's unreasonable or complex that emitter shouldn't _add_ new comments when you've passed the (already-supported) `--removeComments` flag.\n"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2015-01-28T19:28:58Z",
        "body": "My apologies, I thought that the `removeComments` flag was proposed. If we already have it in place, it makes sense in that context. :+1: \n"
      },
      {
        "user": "stanthomas",
        "created_at": "2015-01-29T22:41:22Z",
        "body": "pull request submitted\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2015-02-03T00:37:25Z",
        "body": "Fixed by #1855\n"
      }
    ]
  },
  {
    "number": 1798,
    "title": "Incomprehensible error message when parameter clashes with type in Lib.d.ts",
    "created_at": "2015-01-25T16:30:07Z",
    "closed_at": "2016-02-22T17:55:04Z",
    "labels": [
      "Bug",
      "Fixed",
      "Help Wanted"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/1798",
    "body": "Hi,\n\n**TS**: 1.4\n\nThe following code:\n\n``` typeScript\ndeclare module foo {\n\n    interface DragEvent {\n\n        foo(): void;\n        dataTransfer: DataTransfer;\n    }\n\n    interface Baz {\n\n        bar(handler: (event: foo.DragEvent) => void): void;\n    }\n\n    interface BazInternal {\n\n        equals(other: Baz): boolean;\n    }\n}\n\nclass Baz implements foo.BazInternal {\n\n    public equals(other: Baz) {\n        return true;\n    }\n\n    public bar(handler: (event: DragEvent) => void) {\n    }\n}\n```\n\nCauses the compiler to issue an incomprehensible error message:\n\n```\nClass 'Baz' incorrectly implements interface 'BazInternal'.\n  Types of property 'equals' are incompatible.\n    Type '(other: Baz) => boolean' is not assignable to type '(other: Baz) => boolean'.\n      Types of parameters 'other' and 'other' are incompatible.\n        Type 'Baz' is not assignable to type 'Baz'.\n          Types of property 'bar' are incompatible.\n            Type '(handler: (event: DragEvent) => void) => void' is not assignable to type '(handler: (event: DragEvent) => void) => void'.\n              Types of parameters 'handler' and 'handler' are incompatible.\n                Type '(event: DragEvent) => void' is not assignable to type '(event: DragEvent) => void'.\n                  Types of parameters 'event' and 'event' are incompatible.\n                    Type 'DragEvent' is not assignable to type 'DragEvent'.\n                      Property 'foo' is missing in type 'DragEvent'.    \n```\n\nThe relevant items are:\n- The signature for `public bar` should have been `public bar(handler: (event: foo.DragEvent) => void)`\n- To reproduce the error, the interface `foo.DragEvent` should have an additional method `foo(): void;` (in order to distinguish it from the type in `lib.d.ts`)\n-  For the line `Type 'Baz' is not assignable to type 'Baz'` to be printed there should be both a class and an interface called `Baz`.\n\nRelated issues: #1419 #1796 \n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/1798/comments",
    "author": "NoelAbrahams",
    "comments": [
      {
        "user": "DanielRosenwasser",
        "created_at": "2015-01-25T19:43:26Z",
        "body": "> Type 'Baz' is not assignable to type 'Baz'.\n\nAs this is related to #1419, #1575 should partially  help with some of what you're seeing here.\n"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2015-01-31T05:19:13Z",
        "body": "If we could actually get the `Type 'Baz' is not assignable to type 'Baz'.` portion fixed, then this would at least not be quite as crazy. Unfortunately we\"re not doing that somewhere.\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2016-02-22T17:55:04Z",
        "body": "this shoudl be fixed now. it shows:\n\n> Class 'Baz' incorrectly implements interface 'BazInternal'.\n>   Types of property 'equals' are incompatible.\n>     Type '(other: Baz) => boolean' is not assignable to type '(other: Baz) => boolean'.\n>       Types of parameters 'other' and 'other' are incompatible.\n>         Type 'Baz' is not assignable to type 'foo.Baz'.\n>           Types of property 'bar' are incompatible.\n>             Type '(handler: (event: DragEvent) => void) => void' is not assignable to type '(handler: (event: DragEvent) => void) => void'.\n>               Types of parameters 'handler' and 'handler' are incompatible.\n>                 Type '(event: DragEvent) => void' is not assignable to type '(event: DragEvent) => void'.\n>                   Types of parameters 'event' and 'event' are incompatible.\n>                     Type 'DragEvent' is not assignable to type '**foo.DragEvent**'.\n>                       Property 'foo' is missing in type 'DragEvent'.\n"
      }
    ]
  },
  {
    "number": 1766,
    "title": "Interface name and SyntaxKind are different for MethodDeclaration and PropertyDeclaration",
    "created_at": "2015-01-21T23:26:32Z",
    "closed_at": "2016-02-22T17:51:35Z",
    "labels": [
      "Suggestion",
      "Fixed",
      "Help Wanted"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/1766",
    "body": "This is more of a suggestion than an actual bug -- for all of the other corresponding interfaces and syntax kinds (so far) the name of the syntax kind and the name of the corresponding interface are the same (for instance IfStatement, ClassDeclaration, etc). This makes it very easy to find the other one when coding using language services, which is great. But for some reason, the interface MethodDeclaration corresponds to the syntax kind Method, and the interface PropertyDeclaration corresponds to the syntax kind Property, which makes them more difficult to find. I think it might make more sense to have them all be consistent, to make them easier to find and easier to code with. What do you guys think? \n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/1766/comments",
    "author": "gscshoyru",
    "comments": [
      {
        "user": "CyrusNajmabadi",
        "created_at": "2015-01-21T23:38:41Z",
        "body": "@gscshoyru Yup.  We should def do that.  I tried to unify things a while back, but it looks like i missed a couple of cases.  Thanks!\n"
      },
      {
        "user": "gscshoyru",
        "created_at": "2015-01-22T19:20:10Z",
        "body": "Found another -- Constructor is the syntax kind and ConstructorDeclaration is the interface. \n"
      },
      {
        "user": "gscshoyru",
        "created_at": "2015-01-28T22:43:56Z",
        "body": "And one more -- TypeAssertion is the interface and TypeAssertionExpression is the syntaxKind\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2015-01-30T04:41:18Z",
        "body": "A PR would be welcomed.\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2016-02-22T17:51:35Z",
        "body": "this should be fixed now.\n"
      }
    ]
  },
  {
    "number": 1706,
    "title": "Union Type inference not working in class (ts version 1.4)",
    "created_at": "2015-01-17T13:13:17Z",
    "closed_at": "2023-07-07T18:42:46Z",
    "labels": [
      "Suggestion",
      "Help Wanted"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/1706",
    "body": "Hi,\nUnion type inference is not working inside classes functions. For example trying to compile the below code : \n\n``` TypeScript\ntype NameOrNameArray = string | string[];\n\nclass NameCreator {\n\n    constructor(public name:NameOrNameArray) {}\n\n    createName():string {\n        if (typeof this.name === \"string\") {\n            return name;\n        }\n        else {\n            this.name.forEach((elem)=>{\n                console.log(elem);\n            });\n            return this.name.join(\" \");\n        }\n    }\n}\n```\n\ngives the error : \n\n```\nProperty 'forEach' does not exist on type 'string | string[]'.\n```\n\nThe same code works well when using a function. Same error in Visual studio and in the Playground.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/1706/comments",
    "author": "erichillah",
    "comments": [
      {
        "user": "erichillah",
        "created_at": "2015-01-17T14:23:33Z",
        "body": "I am able to remove the error only by using explicit type assertion\n\n``` TypeScript\n(<string[]>this.name).forEach((elem)=>{\n    console.log(elem);\n });\n return (<string[]>this.name).join(\" \");\n```\n"
      },
      {
        "user": "ahejlsberg",
        "created_at": "2015-01-17T16:55:30Z",
        "body": "Type guards only work on simple variables, not properties of an object, so you need to copy the property into a local variable.\n\n``` TypeScript\ntype NameOrNameArray = string | string[];\n\nclass NameCreator {\n\n    constructor(public name: NameOrNameArray) {}\n\n    createName(): string {\n        var name = this.name;  // Copy into variable\n        if (typeof name === \"string\") {\n            return name;\n        }\n        else {\n            name.forEach(elem => {\n                console.log(elem);\n            });\n            return name.join(\" \");\n        }\n    }\n}\n```\n\nWe have this restriction because we want to track (to the best of our abilities) that there are no assignments to the variable in the guarded section. This is pretty much impossible to do correctly for properties without extensive flow and alias analysis. For example:\n\n``` typescript\nfunction printString(s: string) { ... }\nclass Foo {\n    name: string | string[];\n    foo() {\n        if (typeof this.name === \"string\") {\n            this.bar();\n            printString(this.name);  // Ok?\n        }\n    }\n    bar() {\n        this.name = [\"hello\"];\n    }\n}\n```\n\nThis is just a simple example. You can construct increasingly impossible ones with little effort.\n\nA possible alternative to our current design is to allow type guards to work on dotted names of the form `x.y.z` or `this.x.y.z` and to ignore the effects of assignments to such names (or parts of them). But it would mean that we wouldn't catch errors like the one in the example above.\n"
      },
      {
        "user": "erichillah",
        "created_at": "2015-01-18T01:17:52Z",
        "body": "Thanks, i get a much better understanding of type guard. The use of class properties or 'global variables' doesn't really make sense as it's pretty much impossible to make sure that the condition `typeof this.name === \"string\"` will still be true accross the type guarded scope. So i guess it'll still be confusing to allow dotted name in type guards.\n"
      },
      {
        "user": "antoinerousseau",
        "created_at": "2015-01-22T14:45:11Z",
        "body": "Hi, is this issue going to be fixed?\n"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2015-01-22T17:13:48Z",
        "body": "We still need to work out the exact semantics of how this would work. It's less clear exactly what forms should be allowed since non-local effects are much easier on class members. Consider, for example:\n\n``` ts\nclass Thing {\n    x: string|number;\n\n    ensureXisString() {\n        this.x = this.x.toString();\n    }   \n\n    someMethod() {\n        if(typeof this.x === 'number') {\n            this.ensureXisString();\n            // Narrowed to this.x: number here, which is 100% wrong\n        }\n    }\n}\n```\n"
      },
      {
        "user": "danieljsinclair",
        "created_at": "2015-01-26T18:32:15Z",
        "body": "It would be nice if type guards recognised `Array.isArray()`\n\nthis doesn't seem to work either (v1.4) \n    `instanceof Array`\n"
      },
      {
        "user": "ahejlsberg",
        "created_at": "2015-01-26T18:40:01Z",
        "body": "@danieljsinclair The `x instanceof Array` issue was fixed in #1657.\n"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2015-04-27T23:54:23Z",
        "body": "Tentatively approved. Need to see how this impacts real-world code.\n"
      },
      {
        "user": "jakebailey",
        "created_at": "2023-07-07T18:42:46Z",
        "body": "Just looking at old issues; this one was fixed in TS 2.0 when control flow analysis was introduced."
      }
    ]
  },
  {
    "number": 1653,
    "title": "Language services hard-codes newline to \\r\\n",
    "created_at": "2015-01-13T01:25:55Z",
    "closed_at": "2015-01-19T23:54:27Z",
    "labels": [
      "Bug",
      "Help Wanted"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/1653",
    "body": "services/services.ts `createCompilerHost` function hardcodes `getNewLine` to \"\\r\\n\" instead of providing a way for the LanguageServiceHost to define it (or at least using ts.sys.newLine).\n\nRefs #372.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/1653/comments",
    "author": "csnover",
    "comments": [
      {
        "user": "nycdotnet",
        "created_at": "2015-02-12T02:34:07Z",
        "body": "@mhegazy Would you consider a PR to add this to tsc?  We've gotten requests for this in grunt-ts, and we don't currently have a way to support it without tsc supporting it directly.  Thanks.\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2015-02-16T06:38:36Z",
        "body": "We already have an issue for it #1693. Looks like we need a new compiler flag for it. PR welcomed. I have no good ideas for the name though... --newLine \\n or --newLine CRLR / LR.\n"
      }
    ]
  },
  {
    "number": 1632,
    "title": "--noImplicitAny is an error, not a warning",
    "created_at": "2015-01-10T13:26:48Z",
    "closed_at": "2015-01-12T14:22:45Z",
    "labels": [
      "Bug",
      "Fixed",
      "Help Wanted"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/1632",
    "body": "The help says it's a warning, but it actually fails the build with an error:\n\n```\n--noImplicitAny    Warn on expressions and declarations with an implied 'any' type.\n```\n\nI believe this should say something like:\n\n```\n--noImplicitAny    Raise an error on expressions and declarations with an implied 'any' type.\n```\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/1632/comments",
    "author": "lptr",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2015-01-10T14:01:37Z",
        "body": "Fair point. PR would be appreciated :)\n"
      }
    ]
  },
  {
    "number": 1605,
    "title": "Error span for no best common type among return types",
    "created_at": "2015-01-06T01:12:33Z",
    "closed_at": "2016-02-22T17:43:46Z",
    "labels": [
      "Bug",
      "Fixed",
      "Help Wanted"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/1605",
    "body": "``` ts\nfunction foo() {\n   if (true) {\n      return 0;\n   }\n   else {\n      return \"\";\n   }\n}\n```\n\nThis is an error, but the error is on the entire function. It should be smaller.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/1605/comments",
    "author": "JsonFreeman",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2016-02-22T17:43:46Z",
        "body": "should be fixed in latest.\n"
      }
    ]
  },
  {
    "number": 1576,
    "title": "Unnecessary parentheses in element access expressions",
    "created_at": "2014-12-30T20:34:26Z",
    "closed_at": "2017-09-05T20:02:14Z",
    "labels": [
      "Bug",
      "Fixed",
      "Help Wanted"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/1576",
    "body": "Input:\n\n``` TypeScript\nvar r = window[`${ \"doc\" }ument`];\n```\n\nExpected:\n\n``` JavaScript\nvar r = window[\"doc\" + \"ument\"];\n```\n\nActual:\n\n``` JavaScript\nvar r = window[(\"doc\" + \"ument\")];\n```\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/1576/comments",
    "author": "DanielRosenwasser",
    "comments": [
      {
        "user": "j-oliveras",
        "created_at": "2017-09-01T15:37:08Z",
        "body": "Seems fixed (tested with playground). I unknown what version/commit fixed it (maybe the referenced pull)."
      }
    ]
  },
  {
    "number": 1502,
    "title": "Path casing in require",
    "created_at": "2014-12-16T14:34:39Z",
    "closed_at": "2015-10-27T21:07:41Z",
    "labels": [
      "Bug",
      "Fixed",
      "Help Wanted"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/1502",
    "body": "The path specified in the require keyword is case-sensitive. There are good reasons for that, but it can be confusing, especially given that a project folder in Visual Studio Solution Explorer can have a different casing from the corresponding filesystem folder. It is entirely possible for a project to look like everything is correct in VS, including the casing, and still get \"unable to resolve\".\n\nIt would be nice if, in cases where a module cannot be found, but a module with the same path in different case exists, the compiler gave some kind of hint or warning.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/1502/comments",
    "author": "FilippoPolo",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2014-12-16T18:21:26Z",
        "body": "+1 for better error message.\n"
      },
      {
        "user": "benliddicott",
        "created_at": "2015-09-08T15:06:51Z",
        "body": "see also #3626 and #2011\nMy vote: If it's going to fail _anywhere_ make it fail _everywhere_ and fail _fast_ and with a good message.\n"
      },
      {
        "user": "vladima",
        "created_at": "2015-10-27T20:20:17Z",
        "body": "#5275 introduces a flag `forceConsistentCasingInFileNames` - when it is set compiler will report an error if some file has multiple references with inconsistent casing inside the program\n"
      },
      {
        "user": "vladima",
        "created_at": "2015-10-27T21:07:41Z",
        "body": "fixed in e811fecda645cd7905821d48fcf5f757dbedfa50\n"
      }
    ]
  },
  {
    "number": 1097,
    "title": "Error span is on entire return expression for incompatible return type",
    "created_at": "2014-11-08T01:20:44Z",
    "closed_at": "2016-02-22T17:24:52Z",
    "labels": [
      "Bug",
      "Won't Fix",
      "Help Wanted"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/1097",
    "body": "``` ts\nfunction f(): number {\n    return (() => {\n         return \"\";\n    })();\n}\n```\n\nThe whole lambda is squiggled. We should have logic to determine the best span for error reporting, given a node.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/1097/comments",
    "author": "JsonFreeman",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2016-02-22T17:25:17Z",
        "body": "Closing for housekeeping purposes. The behavior outlined in the OP has been in place for over 18 month now and have not got any updates on this issue. Please file a new issue if an action is required.\n"
      }
    ]
  },
  {
    "number": 1042,
    "title": "Loosen restriction on requiring return expressions when a throw is used instead",
    "created_at": "2014-11-03T21:08:27Z",
    "closed_at": "2017-09-20T20:17:01Z",
    "labels": [
      "Suggestion",
      "Help Wanted"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/1042",
    "body": "Per #947, we currently require a `return` expression in a non-void returning function unless the first and only expression is a `throw` statement. This is basically an exemption to allow for `throw new Exception('Not Yet Implemented')`. It seems reasonable to allow throwing further along in a block if we're willing to try to track control flow, at which point we could likely also check for appropriate `return` expressions from all branches.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/1042/comments",
    "author": "danquirk",
    "comments": [
      {
        "user": "vladima",
        "created_at": "2014-11-04T07:38:54Z",
        "body": "I have a branch with an implementation of  simple control flow analysis that captures cases like this atop of new compiler. It is slightly out of date but I think it'll take less than a day to sync it\n"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2015-07-27T21:16:27Z",
        "body": "We should treat `throw` as equivalent to `return` for the purposes of this check\n"
      },
      {
        "user": "Ptival",
        "created_at": "2016-06-24T18:17:06Z",
        "body": "Any update on this? I often use `throw ...;` and `debugger;` to close branches that should not happen and have no meaningful return values.\n"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2016-06-24T18:33:27Z",
        "body": "The new control analysis work should make this issue obsolete. Have you tried `typescript@next` ?\n"
      },
      {
        "user": "Ptival",
        "created_at": "2016-06-24T18:37:54Z",
        "body": "No, I'm stuck on the npmjs version. (1.8.10?)\n\nGood to know then! :-)\n"
      },
      {
        "user": "NaridaL",
        "created_at": "2017-09-20T10:44:14Z",
        "body": "@RyanCavanaugh I think this can be closed?"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2017-09-20T20:17:01Z",
        "body": "Agree, thanks!"
      }
    ]
  },
  {
    "number": 828,
    "title": "Do not create JavaScript files on errors",
    "created_at": "2014-10-06T15:45:59Z",
    "closed_at": "2014-11-17T16:54:53Z",
    "labels": [
      "Suggestion",
      "Fixed",
      "Help Wanted"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/828",
    "body": "It seems that the TypeScript compiler still produces JavaScript output when the .ts files contains errors:\n\n```\nfunction testFunc(x: string) {\n}\ntestFunc(1);\n```\n\nCompiling this file gives me an error message:\nE:/tmp/typescripttest/Errors.ts(3,1): error TS2082: Supplied parameters do not match any signature of call target:\n        Could not apply type 'string' to argument 1 which is of type 'number'.\nE:/tmp/typescripttest/Errors.ts(3,1): error TS2087: Could not select overload for 'call' expression.\n\nBut nevertheless a .js is created.\n\nThis seems odd to me. If a compiler reports an error, I do not expect it to create an output file and do as if the compilation would succeed. So the hint which tsc is giving me here is more of a type of a warning: There is something wrong, but the compiler still tries to continue.\n\nWhy is this important?\nPeople tend to \"ignore\" the errors if they are not fatal. \nAdditionally, this heavily confuses our CI server, since the error just \"disappears\" on the next build (we do not recompile the tsc if they are older than the resulting JavaScript). \n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/828/comments",
    "author": "kersam-bl",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2014-10-06T17:42:34Z",
        "body": "We definitely want the behavior that the compiler _can_ emit in the presence of type errors. This is a key scenario for migrating existing JavaScript -- you rename some .js file to .ts, get some type errors, but want to keep getting compilation of it while you refactor it to remove the type errors. They are 'warnings' in that sense; we cannot _guarantee_ that your program does not work just because it has type errors.\n\nThat said, we recognize that this isn't always the behavior you want. Incremental builds get messed up by this on a fairly regular basis. We need something to address this scenario.\n\nThe most straightforward thing would be a command line flag (`--doNotEmitOnErrors` ? Could use a better name) that disables emit if we see type errors, same as how we don't emit if there are parse errors.\n"
      },
      {
        "user": "danquirk",
        "created_at": "2014-10-06T19:31:50Z",
        "body": "The compiler error code does now reflect the various possible outcomes of the compilation (ex `EmitReturnStatus.JSGeneratedWithSemanticErrors`) so it should be possible for tools like grunt-ts to give you some ability to configure your preferred behavior for cases like this (where what you want here is essentially 'warnings as errors').\n"
      },
      {
        "user": "DickvdBrink",
        "created_at": "2014-11-17T09:49:31Z",
        "body": "This one is fixed and can be closed right?\n"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2014-11-17T16:54:53Z",
        "body": "Yep. Documenting that we merged this in with the name `noEmitOnError`\n"
      }
    ]
  },
  {
    "number": 789,
    "title": "Fourslash facilities for testing script lexical structure are lacking",
    "created_at": "2014-09-30T21:51:20Z",
    "closed_at": "2016-02-20T21:32:07Z",
    "labels": [
      "Bug",
      "Help Wanted",
      "Revisit",
      "Infrastructure"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/789",
    "body": "Right now when doing a fourslash test for a file's lexical structure, the idea is to set up markers which represent portions of the lexical tree, and do something like \n\n``` TypeScript\ntest.markers().forEach((marker) => {\n    verify.getScriptLexicalStructureListContains(marker.data.itemName, marker.data.kind, marker.fileName, marker.data.parentName);\n});\n\nverify.getScriptLexicalStructureListCount(N);\n```\n\nevery time.\n\nThis is highly undesirable because it allows us to be implicit about the relations between different lexical items. It would be _much_ more desirable if we simply had a function that took the lexical structure as a JS object, and confirmed that the expected structure matches the actual structure.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/789/comments",
    "author": "DanielRosenwasser",
    "comments": [
      {
        "user": "RyanCavanaugh",
        "created_at": "2014-09-30T21:55:34Z",
        "body": "Should we just baseline a text representation of the file's lexical structure with each test instead?\n"
      },
      {
        "user": "danquirk",
        "created_at": "2014-09-30T22:06:07Z",
        "body": "I believe that's what our old LS unit tests essentially did with a bunch of json in string form inside .ts files.\n"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2014-09-30T23:30:11Z",
        "body": "Why a text representation instead of just passing something like\n\n``` TypeScript\n{\n    name: \"Foo\",\n    kind: \"class\",\n    children: [\n        {\n            /* ... */\n        }\n    ]\n}\n```\n\nor even make a DSL-style structure like\n\n``` TypeScript\nlexStructureClass(\"Foo\",\n    lexStructureMethod(\"bar\"),\n    /* ... */);\n```\n\nto a function `verify.scriptLexicalStructureIs(/* ... */)`?\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2015-04-21T06:59:57Z",
        "body": "@DanielRosenwasser this should be fixed now, correct?\n"
      },
      {
        "user": "DanielRosenwasser",
        "created_at": "2015-04-21T07:28:31Z",
        "body": "Not really, this is part of an ongoing concern over the way fourslash itself tests, and is the original issue that caused us to consider baselining API results, and as @RyanCavanaugh suggested\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2016-02-20T21:32:07Z",
        "body": "We have no intimidate plans for changing how fourslash works today. Closing for now, marking it as revisit.\n"
      }
    ]
  },
  {
    "number": 783,
    "title": "Unnecessary \"eval\" in type services  (bug for CSP)",
    "created_at": "2014-09-30T16:40:44Z",
    "closed_at": "2015-01-12T23:18:13Z",
    "labels": [
      "Suggestion",
      "Fixed",
      "Help Wanted"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/783",
    "body": "The file `TypeScript / src / services / core / timer.ts` contains an unnecessary `eval` on line 3.\n\nPlease replace:\n\n``` typescript\nvar global: any = <any>Function(\"return this\").call(null);\n```\n\nby\n\n``` typescript\nvar global: any = <any>(function(){return this;}).call(null);\n```\n\nAs it stands now, this is the only 'eval' in the Typescript services library and it causes trouble when deploying typescript services on websites that use HTML5 Content Security Policies (CSP) to turn off eval. It is a big hassle now to manually patch the sources.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/783/comments",
    "author": "daanx",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2014-09-30T18:27:45Z",
        "body": "Please not that this code will be removed by the time we ship TypeScript 1.3\n"
      },
      {
        "user": "Arnavion",
        "created_at": "2014-11-11T07:47:50Z",
        "body": "Note that the proposed replacement will not work in strict mode.\n"
      },
      {
        "user": "daanx",
        "created_at": "2014-12-05T18:23:21Z",
        "body": "To make it work in strict mode, I guess you can simply lift the function out:\n\n``` typescript\nfunction get_this() { return this; }\nvar global : any = <any>get_this.call(null);\n```\n"
      },
      {
        "user": "Arnavion",
        "created_at": "2014-12-05T18:39:00Z",
        "body": "@daanx That only matters if get_this is not part of the services code but is instead supplied by the user script that's using the services, otherwise it'll still be in strict mode and return null.\n"
      }
    ]
  },
  {
    "number": 712,
    "title": "Improve error message for using ^ on boolean values",
    "created_at": "2014-09-19T22:24:46Z",
    "closed_at": "2014-10-06T04:45:16Z",
    "labels": [
      "Bug",
      "Fixed",
      "Help Wanted"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/712",
    "body": "From #587 - \n\nWe should give a better, more helpful error message when the ^ operator is used on boolean values.\n\nFrom the comment:\n\nGiven this decision, may I suggest improving the error message to state something akin to the following?\n\n\"error TS0000: The ^ operator is not allowed for boolean types. Consider using !== instead.\"\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/712/comments",
    "author": "sophiajt",
    "comments": [
      {
        "user": "chrisbubernak",
        "created_at": "2014-10-02T15:33:47Z",
        "body": "If no one is working on this already I'd like to give this a shot. I've spoken with @DanielRosenwasser and have a pretty good idea of how I want to tackle it.\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2014-10-02T16:16:04Z",
        "body": "thanks @chrisbubernak. go for it :)\n"
      },
      {
        "user": "chrisbubernak",
        "created_at": "2014-10-05T23:54:15Z",
        "body": "This was fixed in pr #823.\n"
      }
    ]
  },
  {
    "number": 528,
    "title": "Show better error message for unresolved references due to missing prefix",
    "created_at": "2014-08-26T20:34:40Z",
    "closed_at": "2016-01-14T21:14:48Z",
    "labels": [
      "Suggestion",
      "Fixed",
      "Help Wanted",
      "Good First Issue"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/528",
    "body": "```\nmodule Foo {\n    class X {\n      public static F() {}\n      public static G() { F(); }\n    }\n}\n```\n\nCurrent error is:  \n\n> Cannot find name 'F'.\n\nSuggestion:\n\n> Cannot find name 'F'. Did you mean to prefix the static function invocation with the class name, 'X.F()' ?\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/528/comments",
    "author": "mhegazy",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2016-01-14T21:14:56Z",
        "body": "thanks @ShyykoSerhiy!\n"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2016-01-14T21:27:25Z",
        "body": "This is awesome, no pun intended. I hope we can do more of this in the future.\n"
      }
    ]
  },
  {
    "number": 527,
    "title": "Flag all instances of duplicate definitions",
    "created_at": "2014-08-26T20:27:19Z",
    "closed_at": "2014-10-03T21:10:18Z",
    "labels": [
      "Bug",
      "Fixed",
      "Help Wanted"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/527",
    "body": "This input results in one \"Duplicate identifier\" error on the second declaration. it would be helpful to have all of them flagged. this also applies to duplicate implementations incase of functions.\n\n``` TypeScript\ninterface I {\n    a\n}\n\ninterface I {\n    a\n}\n```\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/527/comments",
    "author": "mhegazy",
    "comments": [
      {
        "user": "yuit",
        "created_at": "2014-10-03T21:10:18Z",
        "body": "Implement in pull request #798 \n"
      }
    ]
  },
  {
    "number": 475,
    "title": "Recursive function type is printed using \"any\" if the function is not in scope",
    "created_at": "2014-08-18T21:10:50Z",
    "closed_at": "2016-02-20T21:18:30Z",
    "labels": [
      "Bug",
      "Duplicate",
      "Help Wanted"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/475",
    "body": "``` TS\nvar x = function f() { return f; };\nvar x = function () { var y; return y; };\n```\n\nWe get the following error message:\nSubsequent variable declarations must have the same type.  Variable 'x' must be of type '() => any', but here has type '() => any'.\n\nThis is essentially the same as #463. The first declaration of x has type `() => typeof f`, but because f is not in the global scope, we say it is any, even though it is clearly not.\n\nWe have a similar problem for function declarations (and likely for module instances and class constructors):\n\n``` TS\nfunction g() {\n    return function f() {\n        return f;\n    };\n}\n\nvar numberFn = <() => number>(g());\n```\n\nWe get the following error on the type assertion:\nNeither type '() => number' nor type '() => any' is assignable to the other.\n\nBut in fact '() => number' _is_ assignable to '() => any'!\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/475/comments",
    "author": "JsonFreeman",
    "comments": [
      {
        "user": "JsonFreeman",
        "created_at": "2014-08-18T21:29:14Z",
        "body": "The relevant test case for this bug is:\ntests/cases/compiler/functionExpressionReturningItself.ts\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2016-02-20T21:18:30Z",
        "body": "closing in favor of #463\n"
      }
    ]
  },
  {
    "number": 463,
    "title": "How to print anonymous recursive types",
    "created_at": "2014-08-15T21:16:03Z",
    "closed_at": "2022-12-16T16:10:16Z",
    "labels": [
      "Bug",
      "Help Wanted"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/463",
    "body": "``` TS\nvar a: { foo: typeof a; }\n```\n\n`a` has a recursive type. If we try to print this type, it prints `{ foo: any; }`, but it does not behave as such in type comparisons. So we are lying when we print it.\n\nWhen fixing this, it's important to consider both displaying a type to the user, and generating .d.ts files.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/463/comments",
    "author": "JsonFreeman",
    "comments": [
      {
        "user": "danquirk",
        "created_at": "2014-08-15T21:43:22Z",
        "body": "Related to #402?\n"
      },
      {
        "user": "JsonFreeman",
        "created_at": "2014-08-15T21:56:21Z",
        "body": "Yes, it is related\n"
      },
      {
        "user": "ahejlsberg",
        "created_at": "2014-08-16T13:49:29Z",
        "body": "I don't think that should be a bug. Consider:\n\n``` typescript\ndeclare function f(): { foo: typeof f; }\nvar g: () => { foo: typeof g; }\n```\n\nWe currently permit both of those and correctly generate recursive types. The old compiler is oddly inconsistent in these cases, making an `any` in `f` but not in `g`. The new compiler handles both, as well as your initial example.\n\nWe should fix the type printer to handle the recursion.\n"
      },
      {
        "user": "JsonFreeman",
        "created_at": "2014-08-17T03:33:54Z",
        "body": "I think recursive types are nice, but typeToString does not print them correctly. Right now if you try to print the type of a in my initial example:\n\n``` TS\nvar a: { foo: typeof a; };\n```\n\nYou get `{ foo: any; }`, which is not the correct type. That means if you have the following test:\n\n``` TS\nvar a: { foo: typeof a; };\nvar a: { foo: any; };\n```\n\nYou will get an error that the types are not identical, yet the resulting error will tell you that both types are `{ foo: any; }`. We could say that recursive types are allowed and this is just a bug in typeToString. But then we'd also have to make sure that it works in .d.ts generation.\n"
      },
      {
        "user": "JsonFreeman",
        "created_at": "2014-08-17T03:41:10Z",
        "body": "Also, if we keep the type recursive and do not change it to `{ foo: any; }`, then we have to do that for all the following cases too:\n\n``` TS\nvar a = { foo: a };\nvar b = [b];\nvar c = () => c;\n```\n"
      },
      {
        "user": "JsonFreeman",
        "created_at": "2014-08-17T04:12:09Z",
        "body": "And then we'd get into inconsistencies when we have something of the following form:\n\n``` TS\nvar a = foo(a);\n```\n\nfor some function foo.\nThe reason we do not have this problem for function declarations, module instance types, and class constructor types is that we already know something about the structure of these types, just by virtue of the semantics of declaring these entities. For example, an instantiated module will always be an object type whose properties are its exports, and therefore we have a structural basis for making a recursive type that behaves consistently.\nFor vars, we do not have this luxury because a var can have any type at all. We have no basis for defining the structure of a type, and then making it recursive because we have to resolve the expression on the right hand side before we know anything.\nUnless you are saying that we should support recursive types only in the _type annotation_ of a var, and not its initializer! This is plausible, but then we would have to have a special check for the non-contractive case:\n\n``` TS\nvar a: typeof a;\n```\n"
      },
      {
        "user": "ahejlsberg",
        "created_at": "2014-08-17T19:02:09Z",
        "body": "Yes, I was talking recursive types in type annotations. This is something we already support and we shouldn't undo that simply because we can't produce an accurate string representation of those types. I think the current solution of outputting `any` when recursion is detected in an unnamed type is a reasonable compromise.\n\nWe might consider outputting `...` instead, perhaps after a couple of iterations:\n\n``` typescript\n{ foo: { foo: { foo: ... } } }\n```\n\nBut that obviously is more work and might cause us to generate an invalid .d.ts unless we also include logic to produce errors in such cases.\n"
      },
      {
        "user": "JsonFreeman",
        "created_at": "2014-08-18T07:03:00Z",
        "body": "I don't think we should deemphasize the importance of printing the type correctly. It is a big part of the user experience of the language. I do think that we should ensure we have a reasonable way to print a type before trying to support it in the type system. One thing the user should never get is a message like the following:\n\nSubsequent variable declarations must have the same type.  Variable 'a' must be of type '{ foo: any; }', but here has type '{ foo: any; }'.\n\nThis is the result of trying to compile the example I provided above:\n\n``` TS\nvar a: { foo: typeof a; };\nvar a: { foo: any; };\n```\n"
      },
      {
        "user": "JsonFreeman",
        "created_at": "2014-09-08T18:22:02Z",
        "body": "I'm going to reopen this bug and change the title. This bug is still tracking the issue for actually printing the types correctly. There is good material here we can use for that. Also going to mention design bug #517, since it's very relevant here.\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2016-02-20T21:19:17Z",
        "body": "A fix here should handle the case outlined in #475.\n"
      },
      {
        "user": "Andarist",
        "created_at": "2022-12-16T13:38:30Z",
        "body": "To the best of my understanding of the issue at hand - this is already fixed and the issue could be closed cc @RyanCavanaugh "
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2022-12-16T16:10:16Z",
        "body": "Wow, throwback. Indeed. Thanks @Andarist !"
      }
    ]
  },
  {
    "number": 457,
    "title": "Isolated unreferenced files in compiler tests are not compiled by the harness compiler",
    "created_at": "2014-08-15T00:18:45Z",
    "closed_at": "2016-02-20T21:17:20Z",
    "labels": [
      "Bug",
      "Won't Fix",
      "Help Wanted",
      "Infrastructure"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/457",
    "body": "The two tests\n- tests/cases/compiler/externalModuleResolution.ts\n- tests/cases/compiler/externalModuleResolution2.ts\n\neach have file regions that are not compiled by the test harness. The harness uses only the last file as a root, if the last file has a require or ///reference. All other files are only compiled if they are referenced. The tests mentioned above have file regions that are not referenced by the root file. They need to be converted to project tests.\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/457/comments",
    "author": "JsonFreeman",
    "comments": [
      {
        "user": "mhegazy",
        "created_at": "2016-02-20T21:17:20Z",
        "body": "Does not seem to be an issue that we run into often. closing for housekeeping purposes.\n"
      }
    ]
  },
  {
    "number": 134,
    "title": "Should not allow numeric names on enum members",
    "created_at": "2014-07-17T20:48:41Z",
    "closed_at": "2014-10-10T23:24:54Z",
    "labels": [
      "Suggestion",
      "Fixed",
      "Help Wanted"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/134",
    "body": "Because of the way the codegen works for enums, we really do not emit sensible code when the enum members have numeric names. Consider this innocent looking example (compiler gives no errors here):\n\n``` TypeScript\nenum E {\n    1, 2, 3\n}\n\nconsole.log([E[1], E[2], E[3]].join(',')); // Prints 2,3,2 instead of 0,1,2\nconsole.log(E[1].toExponential()); // Crash\nconsole.log(E[2].toExponential()); // Crash\nconsole.log(E[3].toExponential()); // Prints 2e+0\n```\n\nCodegen:\n\n``` JavaScript\nvar E;\n(function (E) {\n    E[E[\"1\"] = 0] = \"1\";\n    E[E[\"2\"] = 1] = \"2\";\n    E[E[\"3\"] = 2] = \"3\";\n})(E || (E = {}));\n\nconsole.log([E[1], E[2], E[3]].join(','));\nconsole.log(E[1].toExponential());\nconsole.log(E[2].toExponential());\nconsole.log(E[3].toExponential());\n```\n\nSo my question is why do we allow numeric  names in an enum, if we cannot emit it right. We can explain to users the semantics for an enum, but our codegen for this pretty confined construct doesn’t adhere to those semantics, and it crashes! Also, an enum with numeric member names does not correspond to an existing javascript pattern that we want to support. I don’t see any reason for this to be allowed.\n\nI realize this is a breaking change. Do people have objections to this break?\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/134/comments",
    "author": "JsonFreeman",
    "comments": [
      {
        "user": "JsonFreeman",
        "created_at": "2014-07-17T20:50:49Z",
        "body": "To emphasize, while this is not a serious issue in terms of its impact, enums are a prepackaged typescript concept (not a javascript pattern), and in this case, we do not emit them in a way that matches our own semantics for them.\n"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2014-07-28T22:20:09Z",
        "body": "Seems ready to discuss.\n"
      },
      {
        "user": "RyanCavanaugh",
        "created_at": "2014-09-19T19:17:22Z",
        "body": "Discussed in design meeting and approved.\n"
      },
      {
        "user": "chrisbubernak",
        "created_at": "2014-10-06T15:11:04Z",
        "body": "Did anyone end up working on this? I've looked into it a bit and the fix seems pretty straight forward, the more tedious aspect is going to be cleaning up a good chunk of test cases that all use the following Enum:\n\nenum ENUM1 { 1, 2, \"\" };\n\nAnyways if we still want this done and no one picked it up I'll give it a shot.\n"
      },
      {
        "user": "mhegazy",
        "created_at": "2014-10-06T16:22:31Z",
        "body": "Thanks @chrisbubernak. Please proceed with your PR.\n"
      }
    ]
  },
  {
    "number": 102,
    "title": "[Errors][Message] Module in type reference",
    "created_at": "2014-07-17T19:57:44Z",
    "closed_at": "2017-10-30T19:38:19Z",
    "labels": [
      "Bug",
      "Fixed",
      "Help Wanted"
    ],
    "url": "https://github.com/microsoft/TypeScript/issues/102",
    "body": "tests/cases/compiler/primaryExpressionMods.ts \n\n``` TypeScript\nmodule M\n{\nexport interface P { x: number; y: number; }\nexport var a = 1;\n}\n\nvar p: M.P; // Used as ModuleName\n\nvar m: M = M; // Used as TypeName and PrimaryExpression (error on TypeName)\n\nvar m2: typeof M = M; // Used as PrimaryExpression in TypeQuery\n\nvar x1 = M.a; // Used as PrimaryExpression\n\nvar x2 = m.a; // Same as M.a\n\nvar q: m.P; // Error\n```\n\nOld Compiler\n\n```\nType reference cannot refer to container 'M'.\n```\n\n New Compiler\n\n```\nCannot find name 'M'.\n```\n",
    "comments_url": "https://api.github.com/repos/microsoft/TypeScript/issues/102/comments",
    "author": "mhegazy",
    "comments": [
      {
        "user": "begincalendar",
        "created_at": "2017-10-13T04:26:27Z",
        "body": "I believe a solution might be:\r\n\r\n```\r\ndiff --git a/src/compiler/checker.ts b/src/compiler/checker.ts\r\nindex 9347329..20a57f0 100644\r\n--- a/src/compiler/checker.ts\r\n+++ b/src/compiler/checker.ts\r\n@@ -1366,7 +1366,7 @@ namespace ts {\r\n                 }\r\n             }\r\n             else if (meaning & (SymbolFlags.Type & ~SymbolFlags.NamespaceModule & ~SymbolFlags.Value)) {\r\n-                const symbol = resolveSymbol(resolveName(errorLocation, name, SymbolFlags.NamespaceModule & ~SymbolFlags.Type, /*nameNotFoundMessage*/undefined, /*nameArg*/ undefined, /*isUse*/ false));\r\n+                const symbol = resolveSymbol(resolveName(errorLocation, name, (SymbolFlags.ValueModule | SymbolFlags.NamespaceModule) & ~SymbolFlags.Type, /*nameNotFoundMessage*/undefined, /*nameArg*/ undefined, /*isUse*/ false));\r\n                 if (symbol) {\r\n                     error(errorLocation, Diagnostics.Cannot_use_namespace_0_as_a_type, unescapeLeadingUnderscores(name));\r\n                     return true;\r\n```\r\n\r\n...but it breaks a lot of other tests.\r\n\r\n~~I'm also thinking that the same logical OR should be used for the check to see whether a module is used as a value, but if that's the case then I wonder why `SymbolFlags.ValueModule` and `SymbolFlags.NamespaceModule` exist separately in the first place.~~"
      },
      {
        "user": "mhegazy",
        "created_at": "2017-10-30T19:38:56Z",
        "body": "thanks @begincalendar!"
      }
    ]
  }
]