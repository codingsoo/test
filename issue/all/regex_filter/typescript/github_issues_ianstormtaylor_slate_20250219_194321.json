[
  {
    "number": 4075,
    "title": "Is Slate dead?",
    "created_at": "2021-02-11T16:42:05Z",
    "closed_at": "2021-02-11T23:36:44Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ianstormtaylor/slate/issues/4075",
    "body": "I understand that Slate is still beta, but as of right now, there are PRs that solve real problems that are not merged for months. There is active community around this editor, but without merging I feel that our work goes to vain. Does that mean that Slate is pretty much dead?\r\n\r\nWe're currently using custom fork of Slate, but that is temporary solution, not permanet one. Are there any plans how to solve current situation or should we move to Draft.js?",
    "comments_url": "https://api.github.com/repos/ianstormtaylor/slate/issues/4075/comments",
    "author": "Mangatt",
    "comments": [
      {
        "user": "Mangatt",
        "created_at": "2021-02-11T19:43:50Z",
        "body": "Last stable version on NPM is 0.59.0 (released on 25 Sep 2020), changelog has last entry for 0.58.0."
      },
      {
        "user": "Mangatt",
        "created_at": "2021-02-11T19:49:18Z",
        "body": "Just for clarification - we really appreciate huge amount of work that was put into this project. We have spent with Slate quite a lot of time as well.\r\n\r\nBut since we are (and not just us) building product that is used in production, we need to know where we stands, hence this issue."
      },
      {
        "user": "ianstormtaylor",
        "created_at": "2021-02-11T23:36:44Z",
        "body": "> I understand that Slate is still beta, but as of right now, there are PRs that solve real problems that are not merged for months. There is active community around this editor, but without merging I feel that our work goes to vain. Does that mean that Slate is pretty much dead?\r\n> \r\n> Last stable version on NPM is 0.59.0 (released on 25 Sep 2020), changelog has last entry for 0.58.0.\r\n\r\nThe last release of `next` was 3 days ago, which included PRs merged by contributors. I'm sure once @thesunny feels it's good he'll release it to `latest` as well.\r\n\r\nAs for the changelog, that sounds like a perfect thing to PR then.\r\n\r\n> We're currently using custom fork of Slate, but that is temporary solution, not permanet one. Are there any plans how to solve current situation or should we move to Draft.js?\r\n> \r\n> Just for clarification - we really appreciate huge amount of work that was put into this project. We have spent with Slate quite a lot of time as well.\r\n> \r\n> But since we are (and not just us) building product that is used in production, we need to know where we stands, hence this issue.\r\n\r\nSlate has been pretty clear about the level of commitment it guarantees for a long time, which is \"not a lot\". \r\n\r\nI understand your frustration, but there's not tons I can do without working for free.\r\n\r\nAs always, if anyone who's been made good contributions wants to help maintain with commit/merge/release access I'd be happy to grant it. There are currently 15+ people with commit access right now, which is more than most projects. The tough part is that people are busy and Slate is inherently complex.\r\n\r\nThere are other ways you can help... if anyone is down to help with triaging/closing issues and pull requests that would be great too, I can give access for that. Or people can just go through older issues and comment that they can be closed and that's helpful too.\r\n\r\nYou're obviously free to use Draft.js or any other editor if you want if those guarantees aren't enough for whatever your needs are."
      }
    ]
  },
  {
    "number": 4052,
    "title": "How to insert multiple pictures in a row",
    "created_at": "2021-01-22T05:23:44Z",
    "closed_at": "2021-01-22T15:21:13Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ianstormtaylor/slate/issues/4052",
    "body": "As the title ",
    "comments_url": "https://api.github.com/repos/ianstormtaylor/slate/issues/4052/comments",
    "author": "stan900814",
    "comments": [
      {
        "user": "ianstormtaylor",
        "created_at": "2021-01-22T15:21:13Z",
        "body": "Hey, thanks for using Slate! Unfortunately, we can't offer support for usage questions in the issues here because it becomes overwhelming to maintain the project if the issues are filled with questions. \r\n\r\nHowever, we do have a Slack channel and people are constantly asking and answering questions in there. So I'm going to close this issue, but I definitely recommend joining the Slack channel if you want to find people that might be able to help. \r\n\r\nThanks for understanding!"
      }
    ]
  },
  {
    "number": 4026,
    "title": "Identifiers for PointRef, RangeRef",
    "created_at": "2020-12-24T03:47:28Z",
    "closed_at": "2021-03-09T05:34:39Z",
    "labels": [
      "question",
      "⚑ needs info"
    ],
    "url": "https://github.com/ianstormtaylor/slate/issues/4026",
    "body": "### Feature request\r\n\r\nAdd the ability to define custom identifiers when creating a `PointRef`, `RangeRef`\r\n\r\n>Editor.rangeRef(editor, at, { id: 42 });\r\n\r\nor something like this\r\n\r\n>Editor.rangeRef(editor, at, { data: { id: 42 } });",
    "comments_url": "https://api.github.com/repos/ianstormtaylor/slate/issues/4026/comments",
    "author": "ovionlogis",
    "comments": [
      {
        "user": "BrentFarese",
        "created_at": "2021-01-31T15:15:03Z",
        "body": "What is the use case for this?  This needs more info, really."
      },
      {
        "user": "ovionlogis",
        "created_at": "2021-03-09T04:38:38Z",
        "body": "@BrentFarese Hi, I apologize for such a late reply.\r\nIn general, the problem is not relevant, since bookmarks are mutable, you can add any fields to them.\r\nBut in general, my case is this: I wanted to make something like invisible bookmarks that do not affect the markup of the text. I keep the bookmarks separate from the text, but when changing the text I need to keep the bookmarks up to date. Therefore, I preliminarily put bookmarks on the text, change the text, then save the bookmarks and text separately."
      },
      {
        "user": "ianstormtaylor",
        "created_at": "2021-03-09T05:34:39Z",
        "body": "Depending on how you've architected your codebase this should be solveable with a `Map` or `WeakMap` outside of Slate's concern I think. So I don't think it makes sense to add extra metadata to core to handle it."
      }
    ]
  },
  {
    "number": 3646,
    "title": "Export Key Class",
    "created_at": "2020-05-01T16:12:26Z",
    "closed_at": "2020-05-01T17:47:44Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ianstormtaylor/slate/issues/3646",
    "body": "There is a method `findKey` on `ReactEditor` which returns a `Key` object. The `Key` class is not exported from the `index.ts`, though. I can only import it from `dist`.\r\n\r\nI'm wondering if it's smart to base my implementation on `Key` or if it's meant to be used internally only.\r\n\r\nDoes it make sense to export it from `index.ts`?\r\n\r\n",
    "comments_url": "https://api.github.com/repos/ianstormtaylor/slate/issues/3646/comments",
    "author": "alfechner",
    "comments": [
      {
        "user": "cameracker",
        "created_at": "2020-05-01T17:47:44Z",
        "body": "Hi @alfechner , thanks for using slate.\r\n\r\nFor questions like this, we encourage you to visit the slate slack channel instead of asking on the github. This will help us keep the github issue tracker focused on bug reports and feature enhancements. This is outlined in the issue template, which next time we'd also appreciate you use.\r\n\r\nThanks for your understanding."
      }
    ]
  },
  {
    "number": 3567,
    "title": "onChange gets fired even no change is made (i.e. if I put it out of focus without any changes made)",
    "created_at": "2020-03-29T22:45:46Z",
    "closed_at": "2020-03-30T20:02:22Z",
    "labels": [
      "question",
      "discussion"
    ],
    "url": "https://github.com/ianstormtaylor/slate/issues/3567",
    "body": "#### Do you want to request a _feature_ or report a _bug_?\r\n\r\n*Bug*\r\n\r\n#### What's the current behavior?\r\n\r\n`onChange` gets fired even if I don't make any changes on editable text. For example, if I put focus on editable text, make no changes and immediately click out of it,  'onChange' callback is triggered. How can I prevent this behavior? \r\nIt's problem because every `onChange` re-renders my component where editable text is located and I don't want this additional re-render.\r\n\r\n#### What's the expected behavior?\r\n\r\nSlate version (npm packages):\r\n _\"slate\": \"*\",_\r\n_\"slate-history\": \"*\",_\r\n_\"slate-react\": \"*\",_\r\n\r\nBrowser: Chrome / Safari / Firefox / Edge\r\nOS: Mac\r\n",
    "comments_url": "https://api.github.com/repos/ianstormtaylor/slate/issues/3567/comments",
    "author": "ebasic",
    "comments": [
      {
        "user": "cameracker",
        "created_at": "2020-03-30T16:39:24Z",
        "body": "onChange is fired as part of selection change. This is an unavoidable behavior and is required for slate to work. Instead, I'd focus on making your `onChange` loop as tight as possible. The rerender impact, even for a large document, should not be a burden for react."
      },
      {
        "user": "ebasic",
        "created_at": "2020-03-30T20:00:57Z",
        "body": "Solved and shared code by **@piyushpatel** on Slack:\r\n\r\n`const handleChange = useCallback(val => {`\r\n    `const ops = editor.operations.filter(o => {`\r\n      `if (o) {`\r\n        `return o.type !== 'set_selection';`\r\n     ` }`\r\n      `return false;`\r\n   ` });`\r\n\r\n   ` if (ops && Array.isArray(ops) && ops.length > 0) {`\r\n      `onChange(val);`\r\n    `}`\r\n  `}, []);`"
      }
    ]
  },
  {
    "number": 3420,
    "title": "Super confused about adding node data.",
    "created_at": "2020-01-10T16:45:47Z",
    "closed_at": "2020-01-10T19:57:28Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ianstormtaylor/slate/issues/3420",
    "body": "```\r\nonUpdateData = (key, value) => {\r\n    this.state.editor.setNodeByKey(nodeKey, value);\r\n  }\r\n```\r\nSo the nodeKey is correct, the value is just an object, but during deserialize/serialize the data is not there. Am I doing something wrong here?\r\n",
    "comments_url": "https://api.github.com/repos/ianstormtaylor/slate/issues/3420/comments",
    "author": "Hammond2789",
    "comments": [
      {
        "user": "ianstormtaylor",
        "created_at": "2020-01-10T19:57:28Z",
        "body": "Hey, thanks for using Slate! Unfortunately, we can't offer support for usage questions in the issues here because it becomes overwhelming to maintain the project if the issues are filled with questions. \r\n\r\nHowever, we do have a Slack channel and people are constantly asking and answering questions in there. So I'm going to close this issue, but I definitely recommend joining the Slack channel if you want to find people that might be able to help. \r\n\r\nThanks for understanding!"
      }
    ]
  },
  {
    "number": 3378,
    "title": "Attempted import error: 'Value' is not exported from 'slate'.",
    "created_at": "2019-12-22T09:03:16Z",
    "closed_at": "2019-12-23T00:32:17Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ianstormtaylor/slate/issues/3378",
    "body": "Hello, when I try to parse `Slate value` into html using `slate-html-serializer`. But I recieved an error like this:\r\n```\r\n./node_modules/slate-html-serializer/lib/slate-html-serializer.es.js\r\nAttempted import error: 'Value' is not exported from 'slate'.\r\n```\r\nMy code:\r\n```\r\nimport HTML from 'slate-html-serializer';\r\n\r\n<Slate editor={editor} value={value} onChange={value => {\r\n      const html = new HTML();\r\n      console.log(html.serialize(value))\r\n      setValue(value)\r\n}}>\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/ianstormtaylor/slate/issues/3378/comments",
    "author": "thaind97git",
    "comments": [
      {
        "user": "cvlmtg",
        "created_at": "2019-12-22T17:21:06Z",
        "body": "@thaind97git are you perhaps using slate-html-serializer with slate > 0.47 ?"
      },
      {
        "user": "ianstormtaylor",
        "created_at": "2019-12-23T00:32:17Z",
        "body": "Hey, thanks for using Slate! Unfortunately, we can't offer support for usage questions in the issues here because it becomes overwhelming to maintain the project if the issues are filled with questions. \r\n\r\nHowever, we do have a Slack channel and people are constantly asking and answering questions in there. So I'm going to close this issue, but I definitely recommend joining the Slack channel if you want to find people that might be able to help. \r\n\r\nThanks for understanding!"
      }
    ]
  },
  {
    "number": 3335,
    "title": "path of rendered element",
    "created_at": "2019-12-17T20:51:58Z",
    "closed_at": "2019-12-17T21:53:53Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ianstormtaylor/slate/issues/3335",
    "body": "#### Do you want to request a _feature_ or report a _bug_?\r\n\r\nfeature\r\n\r\n#### What's the current behavior?\r\n\r\ncurrently an element being rendered receives two props: `element` and `attributes` and this makes impossible to create interactive elements. in the previous version of slate this was possible because each node had a `key` property and it was possible to operate on the node like e.g. `editor.setNodeByKey(node.key, node);`\r\n\r\nSlate: 0.55.2\r\nBrowser: all\r\nOS: all\r\n\r\n#### What's the expected behavior?\r\n\r\neach element being rendered should receive a `path` props or some other mean to make it possible to operate on that element\r\n",
    "comments_url": "https://api.github.com/repos/ianstormtaylor/slate/issues/3335/comments",
    "author": "cvlmtg",
    "comments": [
      {
        "user": "ianstormtaylor",
        "created_at": "2019-12-17T21:53:53Z",
        "body": "Hey, thanks for using Slate! Unfortunately, we can't offer support for usage questions in the issues here because it becomes overwhelming to maintain the project if the issues are filled with questions. \r\n\r\nHowever, we do have a Slack channel and people are constantly asking and answering questions in there. So I'm going to close this issue, but I definitely recommend joining the Slack channel if you want to find people that might be able to help. \r\n\r\nThanks for understanding!"
      },
      {
        "user": "cvlmtg",
        "created_at": "2019-12-17T21:56:24Z",
        "body": "@ianstormtaylor Hi, actually mine wasn't a usage question, it's the request for a feature that was present in the previous release and that is currently missing. Maybe did I describe it poorly? "
      }
    ]
  },
  {
    "number": 3285,
    "title": "v0.52.6 Slate doesn't auto-normalize",
    "created_at": "2019-12-10T16:09:51Z",
    "closed_at": "2019-12-10T17:58:22Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ianstormtaylor/slate/issues/3285",
    "body": "#### Do you want to request a _feature_ or report a _bug_?\r\n\r\nBug?\r\n\r\n#### What's the current behavior?\r\n\r\nIt doesn't seem to auto-normalize when the editor is created. I have wrote a `withSchema` plugin that wants to enforce a specific layout. However, this doesn't happen when the editor is created and only when start typing on it.\r\n\r\n```typescript\r\nexport const withSchema = (nodes: Element[]) => (editor: Editor): Editor => {\r\n  const { normalizeNode } = editor\r\n\r\n  editor.normalizeNode = entry => {\r\n    const [, path] = entry\r\n\r\n    if (path.length === 0) {\r\n      /**\r\n       * Ensure it has exactly the same number of nodes\r\n       * specified in `nodes` argument\r\n       */\r\n      if (editor.children.length < nodes.length) {\r\n        const insertLength = nodes.length - editor.children.length\r\n        const start = nodes.length - insertLength\r\n\r\n        for (let i = start; i < nodes.length; i++) {\r\n          Editor.insertNodes(editor, nodes[i])\r\n        }\r\n      }\r\n      /**\r\n       * Remove extra nodes and set each node\r\n       * to the specified type in `nodes`\r\n       */\r\n      if (editor.children.length > nodes.length) {\r\n        for (const [child, childPath] of Node.children(editor, path)) {\r\n          const index = childPath[0]\r\n\r\n          if (index >= nodes.length) {\r\n            Editor.removeNodes(editor, { at: childPath })\r\n          } else if (child.type !== nodes[index]) {\r\n            Editor.setNodes(editor, { type: nodes[index].type }, { at: childPath })\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    return normalizeNode(entry)\r\n  }\r\n\r\n  return editor\r\n}\r\n...\r\n  const editor = useMemo(\r\n    () => withReact(withSchema(createEditor())),\r\n    []\r\n  )\r\n```\r\n\r\nI don't know if this is the expected behavior or not. The way I'm going around this issue is like this:\r\n```javascript\r\n  React.useLayoutEffect(() => {\r\n    Editor.normalize(editor, { force: true })\r\n  }, [editor])\r\n```\r\n\r\nIf I try to do `Editor.normalize` within the `withSchema` plugin after overwriting `normalizeNode`, it doesn't do anything because `Editor.isNormalizing` returns `true` (??)\r\n\r\nSlate: 0.52.6\r\nBrowser: -\r\nOS: -\r\n\r\n#### What's the expected behavior?\r\n\r\nIf it's not the expected behavior, then it should normalize nodes when editor is created.\r\n",
    "comments_url": "https://api.github.com/repos/ianstormtaylor/slate/issues/3285/comments",
    "author": "eddyw",
    "comments": [
      {
        "user": "ianstormtaylor",
        "created_at": "2019-12-10T17:58:22Z",
        "body": "Not normalizing everything on create is the new expected behavior, yup. It's an expensive operation, and the old way made it hard to opt-out of. In the majority of cases the data will have be saved from a previously normalized state, so it's wasted effort.\r\n\r\nThe way you're doing it sounds right. Another approach is to call `Editor.normalize` right after wherever you are calling `createEditor()` (after mixing in your plugins).\r\n\r\nIf you want to open another issue to discuss the `Editor.normalize` and `isNormalizing` interaction, that sounds good. I'm not sure what to do there."
      },
      {
        "user": "eddyw",
        "created_at": "2019-12-10T19:20:30Z",
        "body": "> The way you're doing it sounds right. Another approach is to call Editor.normalize right after wherever you are calling createEditor() (after mixing in your plugins).\r\n\r\nActually, I have tried this:\r\n```typescript\r\n  const editor = useMemo(\r\n    () => {\r\n      const e = withReact(withSchema(createEditor()))\r\n      Editor.normalize(e, { force: true })\r\n      return e\r\n    },\r\n    []\r\n  )\r\n```\r\n\r\nAnd it doesn't work and it made sense because the editor hasn't gotten a `value` just yet. I'm guessing `useLayoutEffect` would be the only way to go?"
      },
      {
        "user": "ianstormtaylor",
        "created_at": "2019-12-10T19:43:19Z",
        "body": "@eddyw ah yeah good point. I guess `useLayoutEffect` is the way then."
      }
    ]
  },
  {
    "number": 3278,
    "title": "Programmatically set `text` for text node",
    "created_at": "2019-12-09T15:50:01Z",
    "closed_at": "2019-12-10T22:52:02Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ianstormtaylor/slate/issues/3278",
    "body": "#### Do you want to request a _feature_ or report a _bug_?\r\n\r\n_Improvement_\r\n\r\n#### What's the current behavior?\r\n\r\nAFAIK, there is no obvious way to set the `text` of a text/leaf node. There was a recent update which disallowed the usage of the `set_node` operation to set the `text`.\r\n\r\nI'm sure that there are reasons for not allowing the replacement of text this way. One issue was that selection errors could arise if the selection covered offsets which following text replacement no longer existed (i.e. if the replaced text was shorter in length). This could however be solved so that - if the selection following replacement would be out of bounds - the selection is adjusted in connection with the replacement. \r\n\r\nIs there any other known issues or reasons not to have a method/operation to set or replace text in text nodes? If not, I'd be happy to look into making a PR. \r\n\r\nSlate: 0.52.X\r\n\r\n#### What's the expected behavior?\r\n\r\nA user should be able to programmatically set the text of a text node.\r\n",
    "comments_url": "https://api.github.com/repos/ianstormtaylor/slate/issues/3278/comments",
    "author": "objectlegal",
    "comments": [
      {
        "user": "ianstormtaylor",
        "created_at": "2019-12-09T16:59:09Z",
        "body": "If you have the path of the text node you can do it with `Editor.insertText`. Because paths are converted to ranges, deleted, and then inserted at the collapsed point. \r\n\r\nSimilarly you can replace the full text of an element with the same approach. "
      }
    ]
  },
  {
    "number": 3274,
    "title": "What Minimum Version of Chrome Does Slate Support",
    "created_at": "2019-12-08T09:42:11Z",
    "closed_at": "2019-12-08T19:30:05Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ianstormtaylor/slate/issues/3274",
    "body": "What is the lowest version of Chrome Slate should support?\r\n\r\nIn our continuous integration pipeline we are seeing Slate 0.5+ failing on Chrome 75 and earlier (76 and onwards works fine). Is that to be expected or should Slate support these earlier versions?",
    "comments_url": "https://api.github.com/repos/ianstormtaylor/slate/issues/3274/comments",
    "author": "scottfr",
    "comments": [
      {
        "user": "ianstormtaylor",
        "created_at": "2019-12-08T19:30:05Z",
        "body": "Honestly, no idea. But I'm down to have it support the latest two versions. Which right now seems like 78 and 77. If people have specific issues with a recent version they can open issues for whatever the bug is."
      }
    ]
  },
  {
    "number": 3234,
    "title": "Lazy loading Slate components that are offscreen?",
    "created_at": "2019-12-04T20:35:30Z",
    "closed_at": "2019-12-05T16:14:37Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ianstormtaylor/slate/issues/3234",
    "body": "#### Do you want to request a _feature_ or report a _bug_?\r\n\r\nFeature\r\n\r\n#### What's the current behavior?\r\n\r\nOffscreen components must be rendered to DOM (it seems)\r\n\r\nSlate: 0.45.1\r\nBrowser: Electron\r\nOS: Windows\r\n\r\n#### What's the expected behavior?\r\n\r\nI don't know what behavior I'd expect with my code exactly as written, but I'm not clear on _why_ this fails. It fails with: `Error: Unable to find a DOM node for \"179\". This is often because of forgetting to add `props.attributes` to a custom component.`\r\n\r\n```js\r\nreturn (\r\n  <LazyLoad\r\n    placeholder={<MyPlaceholderComponent {...attributes} />}>\r\n    <MyActualComponent {...attributes} />\r\n  </LazyLoad>\r\n)\r\n```\r\n\r\nIs there some way to make this work? I'm confused as to what _exactly_ is going wrong here, which makes it tough to move forward on.",
    "comments_url": "https://api.github.com/repos/ianstormtaylor/slate/issues/3234/comments",
    "author": "Nantris",
    "comments": [
      {
        "user": "Nantris",
        "created_at": "2019-12-04T21:07:46Z",
        "body": "Closest thing we can do now appears to be:\r\n\r\n```js\r\nreturn (\r\n  <LazyLoad\r\n    placeholder={<MyPlaceholder {...attributes}>{children}</MyPlaceholder>\r\n    <MyActualComponent {...attributes} />\r\n  </LazyLoad>\r\n)\r\n```"
      },
      {
        "user": "ianstormtaylor",
        "created_at": "2019-12-05T16:14:37Z",
        "body": "Hey, thanks for using Slate! Unfortunately, we can't offer support for usage questions in the issues here because it becomes overwhelming to maintain the project if the issues are filled with questions. \r\n\r\nHowever, we do have a Slack channel and people are constantly asking and answering questions in there. So I'm going to close this issue, but I definitely recommend joining the Slack channel if you want to find people that might be able to help. \r\n\r\nThanks for understanding!"
      }
    ]
  },
  {
    "number": 3201,
    "title": "Where to see slate@0.40 document site?",
    "created_at": "2019-12-03T05:12:20Z",
    "closed_at": "2019-12-03T06:48:32Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ianstormtaylor/slate/issues/3201",
    "body": "",
    "comments_url": "https://api.github.com/repos/ianstormtaylor/slate/issues/3201/comments",
    "author": "imcuttle",
    "comments": [
      {
        "user": "ianstormtaylor",
        "created_at": "2019-12-03T06:48:32Z",
        "body": "Hey, thanks for using Slate! Unfortunately, we can't offer support for usage questions in the issues here because it becomes overwhelming to maintain the project if the issues are filled with questions. \r\n\r\nHowever, we do have a Slack channel and people are constantly asking and answering questions in there. So I'm going to close this issue, but I definitely recommend joining the Slack channel if you want to find people that might be able to help. \r\n\r\nThanks for understanding!"
      }
    ]
  },
  {
    "number": 3107,
    "title": "How to DIY my schema attribute?",
    "created_at": "2019-11-10T18:30:58Z",
    "closed_at": "2019-11-10T20:02:58Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ianstormtaylor/slate/issues/3107",
    "body": "I want to DIY my schema like `isVoid`, then we could write some schema plugin like `isVoid`.\r\n\r\n```javascript\r\nconst myBlockPlugin = {\r\n   schema: {\r\n           blocks: {\r\n                'block-tag': {\r\n                    // Note here\r\n                    isWhole: true,\r\n                    parent: {object: 'document'}\r\n                }\r\n            }\r\n   },\r\n  // ...\r\n}\r\n\r\nplugins: [\r\n   isWholeSchemaPlugin(),\r\n   myBlockPlugin()\r\n]\r\n```",
    "comments_url": "https://api.github.com/repos/ianstormtaylor/slate/issues/3107/comments",
    "author": "imcuttle",
    "comments": [
      {
        "user": "ianstormtaylor",
        "created_at": "2019-11-10T20:02:58Z",
        "body": "Hey, thanks for using Slate! Unfortunately, we can't offer support for usage questions in the issues here because it becomes overwhelming to maintain the project if the issues are filled with questions. \r\n\r\nHowever, we do have a Slack channel and people are constantly asking and answering questions in there. So I'm going to close this issue, but I definitely recommend joining the Slack channel if you want to find people that might be able to help. \r\n\r\nThanks for understanding!"
      }
    ]
  },
  {
    "number": 3009,
    "title": "How do you know if the editor has any content",
    "created_at": "2019-09-09T01:53:55Z",
    "closed_at": "2019-09-09T02:00:18Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ianstormtaylor/slate/issues/3009",
    "body": "How do you know if the editor has any content  ",
    "comments_url": "https://api.github.com/repos/ianstormtaylor/slate/issues/3009/comments",
    "author": "JinJieTan",
    "comments": [
      {
        "user": "ianstormtaylor",
        "created_at": "2019-09-09T02:00:18Z",
        "body": "Hey, thanks for using Slate! Unfortunately, we can't offer support for usage questions in the issues here because it becomes overwhelming to maintain the project if the issues are filled with questions. \r\n\r\nHowever, we do have a Slack channel and people are constantly asking and answering questions in there. So I'm going to close this issue, but I definitely recommend joining the Slack channel if you want to find people that might be able to help. \r\n\r\nThanks for understanding!"
      },
      {
        "user": "JinJieTan",
        "created_at": "2019-09-09T02:05:44Z",
        "body": "I just want to know how to determine if there is any content in the current editor, because I find that the values generated after I auto-focus to compare are not equal"
      }
    ]
  },
  {
    "number": 2857,
    "title": "Merge Tags or fields ? ",
    "created_at": "2019-06-07T04:19:11Z",
    "closed_at": "2019-06-07T16:41:42Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ianstormtaylor/slate/issues/2857",
    "body": "#### Do you want to request a _feature_ or report a _bug_?\r\n## I think a feature\r\n\r\nMerge tags allow users to dynamically add content to the HTML later,\r\n\r\nlike curly brackets {{ ... }} or square brackets [ ... ] or any other.\r\n\r\nThanks",
    "comments_url": "https://api.github.com/repos/ianstormtaylor/slate/issues/2857/comments",
    "author": "Nothing-Works",
    "comments": [
      {
        "user": "ianstormtaylor",
        "created_at": "2019-06-07T16:41:42Z",
        "body": "Hey, thanks for using Slate! Unfortunately, we can't offer support for usage questions in the issues here because it becomes overwhelming to maintain the project if the issues are filled with questions. \r\n\r\nHowever, we do have a Slack channel and people are constantly asking and answering questions in there. So I'm going to close this issue, but I definitely recommend joining the Slack channel if you want to find people that might be able to help. \r\n\r\nThanks for understanding!"
      }
    ]
  },
  {
    "number": 2614,
    "title": "Logo Design",
    "created_at": "2019-02-25T13:40:32Z",
    "closed_at": "2019-02-26T17:58:47Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ianstormtaylor/slate/issues/2614",
    "body": "Hi, I'm a logo designer, I just saw your project, congrats to you it's a succesful project and if you want I can make a free logo for your project. So, what do you think?",
    "comments_url": "https://api.github.com/repos/ianstormtaylor/slate/issues/2614/comments",
    "author": "tebriz159",
    "comments": [
      {
        "user": "ianstormtaylor",
        "created_at": "2019-02-26T17:58:39Z",
        "body": "Hey @tebriz159, thank you for the offer! We actually have a (fairly minimalist) logo already in the readme, so we're good on that front. But I appreciate it, thanks!"
      }
    ]
  },
  {
    "number": 2508,
    "title": "Handling <br/> html serializer creates double space",
    "created_at": "2018-12-22T21:02:13Z",
    "closed_at": "2019-01-29T02:20:14Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ianstormtaylor/slate/issues/2508",
    "body": "Hey there!\r\n\r\nI have a need to be able to paste the following code into the editor\r\n\r\n`<p>hello world</p><p><br></p><p>hello again</p>`\r\n\r\nThat inner `<p><br></p>` causes the editor to generate extra spans before and after the <br> tag, and this somehow adds an extra space into the editor :/. I've verified that all of the examples of the editor show this behavior too (try copy and pasting some HTML with that format). \r\n\r\nI'm trying to figure out a way to work around this. I am using the `slate-html-serializer` to handle the serialization. I have a special rule for handling the br:\r\n\r\n```\r\n{ \r\n              deserialize(el) {\r\n\t\t\tif (el.tagName.toLowerCase() !== \"br\") return;\r\n\t\t\treturn {\r\n\t\t\t\tobject: \"inline\",\r\n\t\t\t\ttype: \"br\"\r\n\t\t\t};\r\n\t\t},\r\n\t\tserialize(object, children) {\r\n\t\t\tif (object.type !== \"br\") return;\r\n\r\n\t\t\treturn <br />;\r\n\t\t}\r\n}\r\n```\r\n\r\nI've also got the renderNode code as follows:\r\n\r\n```\r\ncase \"br\":\r\n    return <br />;\r\n```\r\n\r\nI've also tried the using newline in the deserializer, but that resulted in the same behaviour :(.\r\n\r\nAny ideas?",
    "comments_url": "https://api.github.com/repos/ianstormtaylor/slate/issues/2508/comments",
    "author": "alex-hioperator",
    "comments": [
      {
        "user": "pjshy",
        "created_at": "2018-12-25T01:08:56Z",
        "body": "can you ignore the br tag in paste html ?"
      },
      {
        "user": "alexbkogan",
        "created_at": "2018-12-31T19:31:35Z",
        "body": "I was able to work around it with some replacements of characters, though tbh if feels hacky. Wondering if there's a predictable way to handle the new lines?"
      },
      {
        "user": "ianstormtaylor",
        "created_at": "2019-01-29T02:20:14Z",
        "body": "Hey, thanks for using Slate! Unfortunately, we can't offer support for usage questions in the issues here because it becomes overwhelming to maintain the project if the issues are filled with questions. \r\n\r\nHowever, we do have a Slack channel and people are constantly asking and answering questions in there. So I'm going to close this issue, but I definitely recommend joining the Slack channel if you want to find people that might be able to help. \r\n\r\nThanks for understanding!"
      }
    ]
  },
  {
    "number": 2486,
    "title": "How do I get current leaves?",
    "created_at": "2018-12-06T17:53:33Z",
    "closed_at": "2018-12-07T03:05:47Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ianstormtaylor/slate/issues/2486",
    "body": "How do I get the lowest leaves for which the current coordinate is located?",
    "comments_url": "https://api.github.com/repos/ianstormtaylor/slate/issues/2486/comments",
    "author": "KingJeason",
    "comments": [
      {
        "user": "ianstormtaylor",
        "created_at": "2018-12-07T03:05:47Z",
        "body": "Hey, thanks for using Slate! Unfortunately, we can't offer support for usage questions in the issues here because it becomes overwhelming to maintain the project if the issues are filled with questions. \r\n\r\nHowever, we do have a Slack channel and people are constantly asking and answering questions in there. So I'm going to close this issue, but I definitely recommend joining the Slack channel if you want to find people that might be able to help. \r\n\r\nThanks for understanding!"
      },
      {
        "user": "KingJeason",
        "created_at": "2018-12-07T03:07:34Z",
        "body": "I'm sorry for my unclear express"
      }
    ]
  },
  {
    "number": 2473,
    "title": "HTML Serializer needs to use key-utils to generate compatible keys",
    "created_at": "2018-12-03T20:51:45Z",
    "closed_at": "2019-01-30T20:11:29Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ianstormtaylor/slate/issues/2473",
    "body": "#### Do you want to request a _feature_ or report a _bug_?\r\n\r\nbug\r\n\r\n#### What's the current behavior?\r\n\r\nIf you have multiple editors on a page, and some create values using ```Value.fromJSON()``` and some use slate-html-serializer, then they data-keys will be confused because they index using different values.\r\nThis can cause different issues, but the one I noticed is that clicking in one editor will focus a different one.\r\n\r\n#### What's the expected behavior?\r\n\r\nunique keys in the data.\r\n\r\n#### Workaround\r\n\r\nAfter deserializing the object, you can ```toJSON()``` and then ```Value.fromJSON()``` to use key-utils indirectly.\r\n",
    "comments_url": "https://api.github.com/repos/ianstormtaylor/slate/issues/2473/comments",
    "author": "JuanValencia",
    "comments": [
      {
        "user": "cameracker",
        "created_at": "2018-12-04T18:08:47Z",
        "body": "I believe this is an environment issue and is causing the `slate-html-serializer` to use a different key generator than the slate core library, which in turn causes the key collision problem. \r\n\r\nThings to check for this problem:\r\n1. Duplicate slate dependencies in the yarn.lock file\r\n2. Incorporation of a second slate dependency via a `yarn link` to a library that also uses slate\r\n3. Potentially incorrect peer or dev dependency constraints"
      },
      {
        "user": "erdinc",
        "created_at": "2019-01-30T15:08:52Z",
        "body": "@JuanValencia did you come up with solution? I have the same issue with multiple editors losing focus."
      },
      {
        "user": "ianstormtaylor",
        "created_at": "2019-01-30T20:11:29Z",
        "body": "Hey, thanks for using Slate! Unfortunately, we can't offer support for usage questions in the issues here because it becomes overwhelming to maintain the project if the issues are filled with questions. \r\n\r\nHowever, we do have a Slack channel and people are constantly asking and answering questions in there. So I'm going to close this issue, but I definitely recommend joining the Slack channel if you want to find people that might be able to help. \r\n\r\nThanks for understanding!"
      }
    ]
  },
  {
    "number": 2429,
    "title": "Deep merge for data",
    "created_at": "2018-11-15T20:31:33Z",
    "closed_at": "2018-11-15T20:38:53Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ianstormtaylor/slate/issues/2429",
    "body": "For any non-trivial data `setBlocks` properties does not work, because the data prop is overridden entirely. The current workaround is copy paste Commands.setBlocksAtRange logic into an app, but that's not ideal. \r\n\r\nIs this use case too rare or am I missing something?\r\n\r\n```js\r\neditor.setBlocks({\r\n  data: { props: { style: { valueStyle: { id: styleId } } } },\r\n});\r\n```",
    "comments_url": "https://api.github.com/repos/ianstormtaylor/slate/issues/2429/comments",
    "author": "steida",
    "comments": [
      {
        "user": "ianstormtaylor",
        "created_at": "2018-11-15T20:38:53Z",
        "body": "My gut tells me this isn't something Slate is likely to support out of the box, because merging always ends up being implementation-specific. And if an API merges by default it's usually hard to tell it about cases where you don't want to merge. But you can always create (and even open-source) a `mergeBlocksData` command and use that instead."
      },
      {
        "user": "steida",
        "created_at": "2018-11-15T20:41:30Z",
        "body": "And properties as a transformation functions? That's would be very nice, because now I have to copy paste code, which is not nice."
      }
    ]
  },
  {
    "number": 2340,
    "title": "slate-md-serializer with Next.js",
    "created_at": "2018-10-27T17:29:31Z",
    "closed_at": "2018-10-27T18:57:16Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ianstormtaylor/slate/issues/2340",
    "body": "Got an error... when trying serializer/deserialize slate-tree into/back Markdown (NEXT.JS)\r\n\r\n```\r\nimport MdSerializer from 'slate-md-serializer'\r\nconsole.log(MdSerializer.deserialize(''))\r\n```\r\n\r\n**Error:**\r\n`TypeError: slate_md_serializer__WEBPACK_IMPORTED_MODULE_6___default.a.deserialize is not a function`",
    "comments_url": "https://api.github.com/repos/ianstormtaylor/slate/issues/2340/comments",
    "author": "markolofsen",
    "comments": [
      {
        "user": "ianstormtaylor",
        "created_at": "2018-10-27T18:57:16Z",
        "body": "Hey @markolofsen this repo doesn't have the `slate-md-serializer`, but feel free to open this up on that one!"
      }
    ]
  },
  {
    "number": 2276,
    "title": "How to generate MD format?",
    "created_at": "2018-10-17T11:22:30Z",
    "closed_at": "2018-10-17T18:58:34Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ianstormtaylor/slate/issues/2276",
    "body": "How to convert slate-content to markdown?\r\n\r\nHow I does it see:\r\n1. Save content from slate to db (JSON?)\r\n2. Load content for slate from db\r\n3. Convert content to MD format (with Python) — << How?",
    "comments_url": "https://api.github.com/repos/ianstormtaylor/slate/issues/2276/comments",
    "author": "markolofsen",
    "comments": [
      {
        "user": "tomaratyn",
        "created_at": "2018-10-17T18:18:54Z",
        "body": "I think you will have to write your own converter. Iterate through the document tree (it's just JSON, parseable in Python) and convert blocks/marks into markdown. \r\n\r\nOne of the core ideas of Slate is that there is no mandatory schema, so there is no standard converter."
      },
      {
        "user": "ianstormtaylor",
        "created_at": "2018-10-17T18:58:34Z",
        "body": "Hey, thanks for using Slate! Unfortunately, we can't offer support for usage questions in the issues here because it becomes overwhelming to maintain the project if the issues are filled with questions. \r\n\r\nHowever, we do have a Slack channel and people are constantly asking and answering questions in there. So I'm going to close this issue, but I definitely recommend joining the Slack channel if you want to find people that might be able to help. \r\n\r\nThanks for understanding!"
      },
      {
        "user": "markolofsen",
        "created_at": "2018-10-18T02:24:56Z",
        "body": "It doesn't helped, but thanks "
      },
      {
        "user": "jbriales",
        "created_at": "2021-04-10T07:00:32Z",
        "body": "@ianstormtaylor maybe sharing a link to the relevant Slack channel would be useful here?"
      }
    ]
  },
  {
    "number": 2049,
    "title": "Schema normalization doesn't seem to work as outlined in the changelog",
    "created_at": "2018-08-07T23:22:25Z",
    "closed_at": "2018-08-07T23:35:58Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ianstormtaylor/slate/issues/2049",
    "body": "I'm trying to update my schema, but it seems like the _only_ method for matching that works is to write rules exactly like this:\r\n\r\n```javascript\r\nconst schemaRules = {\r\n  blocks: {\r\n    list_item: {\r\n      nodes: [\r\n        { match: { type: 'paragraph' } },\r\n        { match: { type: 'ol_list' } },\r\n        { match: { type: 'ul_list' } },\r\n      ],\r\n      normalize: (change, error) => {\r\n        //  Some code\r\n      }\r\n    }\r\n  }\r\n}\r\n```\r\n\r\nTrying something like this has no effect:\r\n\r\n```javascript\r\nconst schemaRules = {\r\n  blocks: {\r\n    list_item: {\r\n      nodes: [{ type: 'paragraph' }, { type: 'ol_list' }, { type: 'ul_list' }],\r\n      normalize: (change, error) => {\r\n        //  Some code\r\n      }\r\n    }\r\n  }\r\n}\r\n```\r\n\r\nI tried with the property name `node` and `nodes` but no effect. Am I doing something wrong here? More examples would be great!",
    "comments_url": "https://api.github.com/repos/ianstormtaylor/slate/issues/2049/comments",
    "author": "Nantris",
    "comments": [
      {
        "user": "ianstormtaylor",
        "created_at": "2018-08-07T23:35:57Z",
        "body": "@Slapbox that's correct, the second syntax doesn't work because the objects in the `nodes` array are not match objects, but constraints themselves like `min/max/etc.` They constrain match objects as their `.match` property."
      },
      {
        "user": "ianstormtaylor",
        "created_at": "2018-08-07T23:37:58Z",
        "body": "If you're looking to only allow certain types of nodes, it would be:\r\n\r\n```js\r\nconst schemaRules = {\r\n  blocks: {\r\n    list_item: {\r\n      nodes: [\r\n        { \r\n          match: [{ type: 'paragraph' }, { type: 'ol_list' }, { type: 'ul_list' }]\r\n        }\r\n      ],\r\n      normalize: (change, error) => {\r\n        //  Some code\r\n      }\r\n    }\r\n  }\r\n}\r\n```"
      },
      {
        "user": "Nantris",
        "created_at": "2018-08-07T23:49:16Z",
        "body": "Thanks for the clarification @ianstormtaylor, I see my misunderstanding now.\r\n\r\nThis choice makes a lot of sense. Thanks for the constant improvements!"
      }
    ]
  },
  {
    "number": 1998,
    "title": "Limit decorateNode() to only the focused line?",
    "created_at": "2018-07-27T17:39:40Z",
    "closed_at": "2018-07-27T18:29:49Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ianstormtaylor/slate/issues/1998",
    "body": "Any thoughts on passing the `editor` prop to `decorateNodes` for the purpose of scoping decorations to the currently selected block? I'm sure there are other use cases as well.",
    "comments_url": "https://api.github.com/repos/ianstormtaylor/slate/issues/1998/comments",
    "author": "Nantris",
    "comments": [
      {
        "user": "ianstormtaylor",
        "created_at": "2018-07-27T18:29:49Z",
        "body": "Hey @Slapbox please search for the other issues that asked for `value` to be passed down. It's not possible as currently architected, because of memoization."
      },
      {
        "user": "Nantris",
        "created_at": "2018-07-27T18:47:01Z",
        "body": "@ianstormtaylor understood. Thanks very much as always for taking the time to reply."
      }
    ]
  },
  {
    "number": 1960,
    "title": "Access to the editor's current selection inside a schema or normalize function",
    "created_at": "2018-07-09T17:16:45Z",
    "closed_at": "2018-08-08T00:51:02Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ianstormtaylor/slate/issues/1960",
    "body": "I asked in the Slack, and it seemed like others also thought it would be useful to have access to the editor's current selection in the schema or normalize function.\r\n\r\nThe specific use case that I need this for is to be able to write a schema to remove all Inlines of type \"link\" that have an empty `href` data value and are not currently selected in the Editor (the user is probably still editing the link if it is selected).\r\n",
    "comments_url": "https://api.github.com/repos/ianstormtaylor/slate/issues/1960/comments",
    "author": "thallada",
    "comments": [
      {
        "user": "ianstormtaylor",
        "created_at": "2018-08-08T00:51:02Z",
        "body": "Hey @thallada, this has been asked before, but the issue is that the normalization of nodes is memoized for performance. We need to be able to validate a node without external information in a deterministic way. If people are allowed to take the `value` or `selection` into account this contract is broken unfortunately."
      }
    ]
  },
  {
    "number": 1937,
    "title": "Collaborative editing how do I read the change.operation value from the backend and render?",
    "created_at": "2018-06-26T03:19:38Z",
    "closed_at": "2018-08-08T00:53:03Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ianstormtaylor/slate/issues/1937",
    "body": "I am connecting a `slate.js` component with firebase realtime database towards collaborative editing. Right now I have a simple master-slave setup between two editors that are from two different accounts. The master account reads the `change` in the `onChange` function and save the `change.operations` in the firebase realtime database. the slave account should `readChange` the database and write the value to the `state.value`. However currently I am not sure how to call the slave's `writeChange` function so that the slave renders the updated text from the master. The naive solution of putting the `writeChange` function in the `onChange` listener crashes the app on load. Code below: \r\n\r\n    export class SlateContainer extends Component {\r\n    \r\n      \tconstructor(props){\r\n    \r\n    \t\tsuper(props);\r\n    \r\n    \t\tthis.state = { value  : initVal\r\n    \t\t\t         , pid    : '' \r\n    \t\t\t         , master : false\r\n    \t\t\t     \t};\r\n    \r\n    \t}\r\n    \r\n    \t// set master slave status. user prop is loaded\r\n    \t// as a consumer context from another container\r\n        componentWillMount(){\r\n    \r\n        \tconst email = this.props.user.email;\r\n    \r\n        \tif (email === 'master9@gmail.com')\r\n        \t\tthis.setState({ master : true })\r\n    \r\n        }\r\n    \r\n    \r\n    \t// after mounted, load project\r\n        componentDidMount(){\r\n    \r\n    \t\tconst name = 'slate-project';\r\n    \r\n    \t\tthis.state.master \r\n    \t\t? this.loadMasterProject(name)\r\n        \t: this.loadSlaveProject (name);\r\n    \r\n        }\r\n    \r\n    \r\n        // load project if exists, else create one\r\n    \tloadMasterProject = async (name ) => {\r\n    \t\t// load project from master perspective\r\n    \t}\r\n    \r\n    \r\n    \tloadSlaveProject = async (name) => {\r\n    \t\t// load as slave\r\n    \t}\r\n    \r\n    \tonChange = change => {\r\n                 \r\n                // the bug is here: if I run readChange from the slave side\r\n               // then the app crashes on load. what works is just: \r\n             // `this.state.master ? this.writeChange(change) : false`\r\n    \t\tthis.state.master\r\n    \t\t? this.writeChange(change)\r\n    \t\t: this.readChange()\r\n    \r\n    \t}\r\n    \r\n    \twriteChange = (change) => {\r\n    \r\n    \t\tconst ops = change.operations\r\n    \t\t\t.filter(o => o.type !== 'set_selection' && o.type !== 'set_value')\r\n    \t\t\t.toJS();\r\n    \r\n    \t\tthis.setState({ value : change.value });\r\n    \t\tProject.save( this.props.user.id, this.state.pid, JSON.stringify(ops))\r\n    \t}\r\n    \r\n    \r\n    \t/**\r\n    \t\tListen to server for change and apply value. where would I call this function?\r\n    \t*/\r\n    \treadChange = () => {\r\n    \r\n    \t\tconst id  = this.props.user.id;\r\n    \t\tconst pid = this.state.pid    ;\r\n    \r\n    \t\tfirebaseApp.database().ref('path/to/project-id').on('value', snap => {\r\n    \r\n    \t\t\tconst raw_ops = snap.val().delta;\r\n    \t\t\tconst ops = JSON.parse(raw_ops);\r\n    \t\t\tconst value  = this.state.value;\r\n    \r\n    \t\t\t// this throw the error on load\r\n    \t\t\t// const change = value.change().applyOperations(ops);\r\n    \t\t\t// this.setState({ value : change.value });\r\n    \r\n    \t\t})\t\t\r\n    \t}\r\n    \r\n    \trender (){\r\n    \t\treturn (\r\n    \t\t\t<Editor className='editor'\r\n    \t\t\t\tvalue     = {this.state.value}\r\n    \t\t\t\tonChange  = {this.onChange}\r\n    \t\t\t\tonKeyDown = {this.onKeyDown}\r\n    \t\t\t/>\r\n    \t\t)\r\n    \t}\r\n    }\r\n\r\n\r\nNote the data is properly passed through the realtime db, so this is not a firebase db problem. ",
    "comments_url": "https://api.github.com/repos/ianstormtaylor/slate/issues/1937/comments",
    "author": "lingxiao",
    "comments": [
      {
        "user": "ianstormtaylor",
        "created_at": "2018-08-08T00:53:03Z",
        "body": "Hey @lingxiao, we can't answer detailed questions here, but check out the `#collaboration` channel in the Slack for people who may be able to help."
      },
      {
        "user": "ccorcos",
        "created_at": "2019-05-15T04:25:10Z",
        "body": "It would be nice to followup here so others don't have to signup and go hunting through Slack :)"
      }
    ]
  },
  {
    "number": 1894,
    "title": "Comparison of slate vs rest when considering webcomponents use",
    "created_at": "2018-06-12T04:23:34Z",
    "closed_at": "2018-06-12T17:43:00Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ianstormtaylor/slate/issues/1894",
    "body": "Hi, I've been looking at some editors to use with a webcomponents app (shadow DOM) and I think majority of them don't support shadow DOM yet.\n\nI see that this project started initially when you tried other editors. I am wondering if you can suggest if this or any other library is a good fit for webcomponents (editor within a shadow DOM) usage?",
    "comments_url": "https://api.github.com/repos/ianstormtaylor/slate/issues/1894/comments",
    "author": "AndreasGalster",
    "comments": [
      {
        "user": "ianstormtaylor",
        "created_at": "2018-06-12T17:43:00Z",
        "body": "Hey, thanks for using Slate! Unfortunately, we can't offer support for usage questions in the issues here because it becomes overwhelming to maintain the project if the issues are filled with questions. \r\n\r\nHowever, we do have a Slack channel and people are constantly asking and answering questions in there. So I'm going to close this issue, but I definitely recommend joining the Slack channel if you want to find people that might be able to help. \r\n\r\nThanks for understanding!"
      }
    ]
  },
  {
    "number": 1873,
    "title": "Maintain cursor position based on remote change",
    "created_at": "2018-06-02T00:16:42Z",
    "closed_at": "2018-08-08T00:56:28Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ianstormtaylor/slate/issues/1873",
    "body": "I have a working implementation collaboratively syncing Slate editors, however, I cannot figure out how to handle integrating an external change while maintaining the user's current cursor position. Any thoughts on how to approach this?",
    "comments_url": "https://api.github.com/repos/ianstormtaylor/slate/issues/1873/comments",
    "author": "bigfish24",
    "comments": [
      {
        "user": "ianstormtaylor",
        "created_at": "2018-08-08T00:56:28Z",
        "body": "Hey, thanks for using Slate! Unfortunately, we can't offer support for usage questions in the issues here because it becomes overwhelming to maintain the project if the issues are filled with questions. \r\n\r\nHowever, we do have a Slack channel and people are constantly asking and answering questions in there. So I'm going to close this issue, but I definitely recommend joining the Slack channel if you want to find people that might be able to help. \r\n\r\nThanks for understanding!"
      }
    ]
  },
  {
    "number": 1822,
    "title": "Calling preventDefault inside onKeyDown  doesn't stop `Enter`, `Backspace`",
    "created_at": "2018-05-05T10:26:05Z",
    "closed_at": "2018-05-07T03:27:35Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ianstormtaylor/slate/issues/1822",
    "body": "#### What's the current behavior?\r\n\r\nI defined onKeyDown as follows\r\n\r\n```\r\nonKeyDown = (event, change) => {\r\n    event.preventDefault()\r\n}\r\n```\r\nI press keys, and I cannot input chars like: 'a', 'b', etc, but 'Enter', 'Backspace' still take effect.\r\n\r\n#### What's the expected behavior?\r\n\r\n 'Enter' or 'Backspace' should not take effect when `preventDefault` is called.\r\n",
    "comments_url": "https://api.github.com/repos/ianstormtaylor/slate/issues/1822/comments",
    "author": "gaoxiaoliangz",
    "comments": [
      {
        "user": "ianstormtaylor",
        "created_at": "2018-05-07T03:27:35Z",
        "body": "Hey, thanks for using Slate! Unfortunately, we can't offer support for usage questions in the issues here because it becomes overwhelming to maintain the project if the issues are filled with questions. \r\n\r\nHowever, we do have a Slack channel and people are constantly asking and answering questions in there. So I'm going to close this issue, but I definitely recommend joining the Slack channel if you want to find people that might be able to help. \r\n\r\nThanks for understanding!"
      }
    ]
  },
  {
    "number": 1706,
    "title": "Not able to delete list item bullet",
    "created_at": "2018-03-16T10:07:24Z",
    "closed_at": "2018-03-21T01:57:58Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ianstormtaylor/slate/issues/1706",
    "body": "Dear Team,\r\n\r\nI'm facing a issue with list items when i try to make a list like : \r\n\r\n- A\r\n- B\r\n- C\r\n\r\nwhen doing Backspace first bullet item is not getting delete\r\n- \r\n\r\nAny help and suggestion would be appreciated. Thanks",
    "comments_url": "https://api.github.com/repos/ianstormtaylor/slate/issues/1706/comments",
    "author": "harryprimoko",
    "comments": [
      {
        "user": "cameracker",
        "created_at": "2018-03-16T20:27:20Z",
        "body": "Could you elaborate a bit more on the expectations, and provide a GIF? The issue template has a tool that you can use to generate one.\r\n\r\nThanks :)"
      },
      {
        "user": "ianstormtaylor",
        "created_at": "2018-03-21T01:57:58Z",
        "body": "Hey, thanks for using Slate! Unfortunately, we can't offer support for usage questions in the issues here because it becomes overwhelming to maintain the project if the issues are filled with questions.\r\n\r\nHowever, we do have a Slack channel and people are constantly asking and answering questions in there. So I'm going to close this issue, but I definitely recommend joining the Slack channel if you want to find people that might be able to help.\r\n\r\nThanks for understanding!"
      }
    ]
  },
  {
    "number": 1600,
    "title": "Feature Request: Support for Angular 5",
    "created_at": "2018-02-05T01:11:43Z",
    "closed_at": "2018-02-05T17:46:06Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ianstormtaylor/slate/issues/1600",
    "body": "Can slate work with Angular?",
    "comments_url": "https://api.github.com/repos/ianstormtaylor/slate/issues/1600/comments",
    "author": "shyamal890",
    "comments": [
      {
        "user": "schneidmaster",
        "created_at": "2018-02-05T01:31:00Z",
        "body": "Hi there! Slate intentionally keeps a very lean core in the `slate` package itself, with `slate-react` containing the logic to render Slate as a React component. It would likely be possible to develop a plugin analogous to `slate-react` to render a Slate editor in Angular. I believe there are also plugins that let you render React components within Angular that you could try with `slate-react`. However, I don't think any sort of official support for Angular is in the cards, at least in the near future."
      }
    ]
  },
  {
    "number": 1569,
    "title": "isInRange does not work when testing if a not selected node is part of the given selection",
    "created_at": "2018-01-29T07:00:11Z",
    "closed_at": "2018-08-08T01:15:44Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ianstormtaylor/slate/issues/1569",
    "body": "#### Do you want to request a *feature* or report a *bug*?\r\nbug\r\n#### What's the current behavior?\r\nI`m looping through all child nodes of the Document and trying to find a node that is part of the current selection by:\r\n```javascript\r\nconst range = value.selection\r\nconst document = value.document\r\n\r\ndocument.nodes\r\n        .find(node => node.isInRange(range));\r\n```\r\n\r\nAs soon as isInRange is called on a node that is **not** part of the range, it will throw a normalization warning and modifying the range: \r\n```javascript\r\nWarning: The range was invalid and was reset. The range in question was: ...\r\n```\r\n\r\n#### What's the expected behavior?\r\nBecause of that, isInRange can not be used to find not selected nodes or filter selected from not selected nodes. Although from the name i would expect this to be possible.\r\n\r\nPossible solution:\r\n\r\nA) isInRange should have a option to deactivate normalization \r\nB) find a way to remove normalization for this use case\r\n\r\nI would prefer B) because A) makes Slate less easy to use.\r\n\r\n",
    "comments_url": "https://api.github.com/repos/ianstormtaylor/slate/issues/1569/comments",
    "author": "ch1ll0ut1",
    "comments": [
      {
        "user": "zhujinxuan",
        "created_at": "2018-01-30T20:43:27Z",
        "body": "I do not think `isInRange` is whether a node is in the range;  Because range only stores key and offset in itself, node method can do at most whether a node is including or is overlapped by a range.\r\n\r\nI doubt whether the annotation and the name of that function is a bug."
      },
      {
        "user": "ch1ll0ut1",
        "created_at": "2018-01-31T03:36:19Z",
        "body": "@zhujinxuan i looked into the code and from what i understand the method does check if the node or any childs is part of the given range"
      },
      {
        "user": "ianstormtaylor",
        "created_at": "2018-08-08T01:15:44Z",
        "body": "Hey, thanks for using Slate! Unfortunately, we can't offer support for usage questions in the issues here because it becomes overwhelming to maintain the project if the issues are filled with questions. \r\n\r\nHowever, we do have a Slack channel and people are constantly asking and answering questions in there. So I'm going to close this issue, but I definitely recommend joining the Slack channel if you want to find people that might be able to help. \r\n\r\nThanks for understanding!"
      }
    ]
  },
  {
    "number": 1527,
    "title": "Would you like to add flow type check in some files?",
    "created_at": "2018-01-12T16:08:18Z",
    "closed_at": "2018-01-12T18:12:19Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ianstormtaylor/slate/issues/1527",
    "body": "#### Do you want to request a *feature* or report a *bug*?\r\nfeature;\r\n\r\n#### What's the current behavior?\r\nSome plugins are using flow to type check with the slate.  However, flow is not smart enough to intercept some types inside the slate. \r\n\r\nI am just wondering whether or not it is appreciated of submitting PRs of adding flow annotation for type checking in some files?\r\n\r\nThank you\r\nJinxuan Zhu ",
    "comments_url": "https://api.github.com/repos/ianstormtaylor/slate/issues/1527/comments",
    "author": "zhujinxuan",
    "comments": [
      {
        "user": "ianstormtaylor",
        "created_at": "2018-01-12T18:12:16Z",
        "body": "Hey @zhujinxuan, good question. I don't want to add Flow to the codebase though. If we were to consider one of the type systems down the road it would be TypeScript, but even that I think should be punted for nearer to a 1.0 release.\r\n\r\nI think plugins can do whatever they please on this front, but it doesn't need to impact the core codebase."
      }
    ]
  },
  {
    "number": 1521,
    "title": "How to move range to the start of a `isVoid` block if the `isVoid` block is at the start of the document",
    "created_at": "2018-01-11T16:09:44Z",
    "closed_at": "2018-01-12T18:16:48Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ianstormtaylor/slate/issues/1521",
    "body": "**Do you want to request a feature or report a bug?**\r\nbug\r\n\r\n**What's the current behavior?**\r\n\r\n\r\nBecause all ranges are inside Text Nodes, suppose we have an `isVoid === true` image block moved to the start of a document, then it seems impossible to move selection to the real start of the document (for example, users press leftArrow at the end of the image)  insert text before the image.\r\n\r\nThank you\r\nJinxuan Zhu",
    "comments_url": "https://api.github.com/repos/ianstormtaylor/slate/issues/1521/comments",
    "author": "zhujinxuan",
    "comments": [
      {
        "user": "zGrav",
        "created_at": "2018-01-11T18:40:09Z",
        "body": "My workaround around this was actually putting in two empty textnodes previous and after the image:D"
      },
      {
        "user": "bengotow",
        "created_at": "2018-01-11T18:49:30Z",
        "body": "Hey @zhujinxuan — I think I've seen a related problem. If an isVoid block is the last node of the document or the last/deepest child of the last node, select-all doesn't work in the editor. I tried to hack a fix to this by ensuring that my HTML serialization inserts an empty space after the last node, but it's not a perfect fix."
      },
      {
        "user": "zhujinxuan",
        "created_at": "2018-01-11T19:22:48Z",
        "body": "@zGrav Consider that the user delete the text node....\r\n\r\nI am thinking about \r\n```\r\n  schema: \r\n      image: inline, fakeEmptyTextInline\r\n```\r\nAnd then we can then ensure `fakeEmptyTextInline` is not editable."
      },
      {
        "user": "ianstormtaylor",
        "created_at": "2018-01-12T18:16:45Z",
        "body": "Hey @zhujinxuan good question. \r\n\r\n> Because all ranges are inside Text Nodes, suppose we have an isVoid === true image block moved to the start of a document, then it seems impossible to move selection to the real start of the document (for example, users press leftArrow at the end of the image) insert text before the image.\r\n\r\nFrom Slate's perspective, there is no \"real start of the document\" in that sense. If the first block in a document is a void image block, that's the first thing you can select. There's no way to select \"before\" that block because selections can only live inside blocks, and there is nothing before that block. If you need to always be able to select before an image, you can either ensure that there's always a paragraph before it, or add custom logic to ensure that pressing up/left/etc. when an image void node is selected actually inserts a paragraph before it.\r\n\r\n@bengotow that sounds like something we should fix, feel free to open a new issue for it!"
      },
      {
        "user": "tvrcgo",
        "created_at": "2019-03-26T04:07:56Z",
        "body": "My workaround was copied void image block to second line and deleted the first one. :("
      }
    ]
  },
  {
    "number": 1263,
    "title": "Request: access to parent node or document in schema rules",
    "created_at": "2017-10-19T18:32:45Z",
    "closed_at": "2017-10-26T16:29:44Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ianstormtaylor/slate/issues/1263",
    "body": "Right now there is no way to get the parent of a node when specifying schema rules. (Unless I'm missing something.) This means there is no way to enforce a rule like: in any block, if an inline node of type X exists (with some custom data), another inline node of type X has to exist (with some other custom data). I guess for every block you could iterate through all the children, but it's definitely less efficient than just writing a rule for nodes of type X.",
    "comments_url": "https://api.github.com/repos/ianstormtaylor/slate/issues/1263/comments",
    "author": "AlexeiAndreev",
    "comments": [
      {
        "user": "ianstormtaylor",
        "created_at": "2017-10-26T16:29:44Z",
        "body": "Hey @AlexeiAndreev this is unfortunately how the schema works. The rules are memoized based on the nodes themselves, such that they can be cached when the node hasn't changed. But if you want to perform a normalization based on multiple nodes, you have to use their parent instead.\r\n\r\nI'd be open to a `rule.next/previous` similar to `rule.parent` though, if someone wanted to add that functionality to the schema."
      }
    ]
  },
  {
    "number": 1211,
    "title": "Hidden nodes (blocks and inlines)",
    "created_at": "2017-10-09T03:07:52Z",
    "closed_at": "2017-10-10T14:07:40Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ianstormtaylor/slate/issues/1211",
    "body": "This is a feature idea for hidden blocks/inlines as a first-class citizen.\r\n\r\nI'm working on folding behavior in my editor. So, in some instances, certain chunks of the document should not be visible.\r\n\r\nHowever, I'm struggling to find a way to implement this. Since Slate operates on the visible content, if the blocks are styled to not be displayed and the user operates on the surrounding area, the blocks can be easily deleted from the document in error. Or, if I style them to be rendered but not visible (absolutely positioned off-screen, for example), they still steal the selection when moving between lines.\r\n\r\nIf I create a fragment of the blocks and store it elsewhere when folded, then insert it back in when unfolded, I mess with the operation history, which is not ideal for collaborative editing.\r\n\r\nSo, my suggestion (which I would be willing to look into implementation details and maybe even take a stab at it) is to support an `isHidden` property on nodes that allows a node to be included in the document, but not rendered. I'm not sure if this would mess with selection, but I'd imagine it could function somewhat like `isVoid`?",
    "comments_url": "https://api.github.com/repos/ianstormtaylor/slate/issues/1211/comments",
    "author": "alanchrt",
    "comments": [
      {
        "user": "alanchrt",
        "created_at": "2017-10-09T04:04:09Z",
        "body": "Another angle on it is that it's not Slate's concern to ignore rendering on bits of the document, since that's just presentation. Which, it may be desirable in some cases to have hidden element properties just be presentational and not part of the document data, eg. if the folded state wasn't actually a property of the document, but instead the individual user or device viewing the document (probably will be true in my case). The presentation would be determined by data external to the editor and document.\r\n\r\nIn that case, the ideal outcome would be that Slate could handle blocks or inlines with `display: none` and still treat them as part of the document (ie. not delete or replace them on splits and other adjacent operations), but ignore them for selection."
      },
      {
        "user": "YurkaninRyan",
        "created_at": "2017-10-09T13:15:15Z",
        "body": "What would happen if you just set the content editable of all of those hidden blocks to false?  and then with css made it so they couldn't be selected?"
      },
      {
        "user": "ianstormtaylor",
        "created_at": "2017-10-09T17:08:24Z",
        "body": "Hey @alanctkc, interesting problem and good write up!\r\n\r\nFor all of the solutions you present the problems do seem like they make it impossible to get right. \r\n\r\nI think there might be one other user land solution which would be to use `onChange` (and maybe `onBeforeChange` to look at the operations that are there and if any of them effect the hidden nodes, to ignore them. \r\n\r\nThere might be a few pieces missing from core to make this solution super easy to do—allowing `onChange` to return a new change object entirely being one of them I think. But I think there's enough there to mock-up a hacky solution. And then we could add to core where it makes sense for cleaning it up. \r\n\r\nCan you investigate that? Let me know what you find out!\r\n\r\nI'd rather not have to add more logic that complicated how core handles changes themselves, since it gets convoluted fast. "
      },
      {
        "user": "alanchrt",
        "created_at": "2017-10-10T02:12:27Z",
        "body": "@ianstormtaylor Thanks for the reply! Actually, that's the path I started down last night, and it got relatively complicated pretty quickly. That said, I'm not against complicated if I can close all the loops and it ends up being the most userland-ish.\r\n\r\nHere are some things I ran into:\r\n\r\n- The hidden blocks don't necessarily get referenced in the operations. So, I ended up being able to look up the nodes in the operations by path, if they were the right type of blocks, check their siblings (the hidden folded blocks are siblings, not children), and make a little bit of progress. But, what if the hidden block is in the range of a selection? Do I search down every tree in the range for folded blocks?\r\n- I don't actually want to ignore the operations, but I'd rather unfold the hidden block before the change if it affects the block. So, for example, if you hit delete from the beginning of a visible block following a hidden block, I want to unfold the hidden block and delete the following block text back into that folded block as would happen unfolded. Also, I want some operations to proceed as normal. For example, if you select a range or select all (and hidden blocks are in the selection range), then delete, I want to delete the hidden blocks as well.\r\n- Because of the above, I need a whitelist of operations to let proceed as normal, (maybe) a list to ignore, and a list to unfold before operating.\r\n- This is just unfamiliarity with Slate, but how would I alter the change in `onBeforeChange` to insert operations _before_ the ones already in the change? Is the `operations` property mutable, or is there some other API?\r\n\r\n@YurkaninRyan that's actually a super interesting idea messing with `contenteditable`, and one I hadn't thought about at all. Theoretically, I could style stuff off-screen and avoid it stealing the selection during movement. Copy and paste might be a little unexpected, but I'm not actually against having the folded blocks show up in pastes. Does Slate provide an API for `contenteditable` manipulation, or am I on my own trying to gain control of the DOM over React's binding? Sounds pretty hacky in the latter case."
      },
      {
        "user": "ianstormtaylor",
        "created_at": "2017-10-10T04:59:15Z",
        "body": "@alanctkc can you give a visual example of a delete operation involving a fold? Not sure I totally understand what your desired outcome it."
      },
      {
        "user": "alanchrt",
        "created_at": "2017-10-10T14:07:40Z",
        "body": "Wellllllll, shoot. I did some testing to try to get a visual, and actually discovered Slate is doing all the right things under the hood for folding to work properly, with no accidentally destructive operations. Whenever performing operations around hidden blocks, they _are_ actually treated as if they were still in the document like visible blocks. The data is right there, and I somehow completely missed it.\r\n\r\nMy problem was in the way I referenced blocks for unfolding... the fold/unfold UI was on a sibling block of the hidden block, so if the sibling relationship changed during an operation, then I wasn't able to unfold the hidden block by referencing it as a sibling of the visible UI, and I mistook that for the hidden block being deleted (it's not).\r\n\r\nSo, all that to say, there are a few tweaks I need to make to preserve references to hidden blocks properly, and a couple edge case behaviors I'd like to modify, but Slate is totally doing the expected thing and isn't a part of the equation at all. In fact, I'm not building a code editor (Ace already got that one in the bag), but the folding behavior I have using Slate seems to already behave almost identical to folding in my code editor out of the box.\r\n\r\nThanks for the attention to this and sorry for the noise! Let me know if it's still not clear, but it seems like Slate already supports hidden nodes. :)"
      },
      {
        "user": "ianstormtaylor",
        "created_at": "2017-10-10T15:13:01Z",
        "body": "Haha awesome :smile:"
      }
    ]
  },
  {
    "number": 1179,
    "title": "onKeyDown can not prevent keys like `enter`, `delete` ",
    "created_at": "2017-09-25T07:15:59Z",
    "closed_at": "2017-10-17T19:11:04Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ianstormtaylor/slate/issues/1179",
    "body": "Hi,\r\nI am build a annotator tools,  I need a  editable switcher, which means :\r\n\r\n1. if this.state.editable === false,  only can add `marks` (by predefined shortcut ) and `ctrl-z` to rollback. But can not edit original text by other keys.\r\n\r\n2. if this.state.editable === true,  can add marks and also can edit the text .\r\n\r\nI copy the example and write code like below\r\n\r\n```\r\nonKeyDown = (event, data, change) => {\r\n    if (!this.state.editable)\r\n      event.preventDefault()\r\n\r\n    if (!event.altKey) return\r\n    ....\r\n  }\r\n```\r\n\r\nBut I found  `event.preventDefault()` donot prevent  keys like `enter`, `delete` `backspace`  ?\r\n",
    "comments_url": "https://api.github.com/repos/ianstormtaylor/slate/issues/1179/comments",
    "author": "eromoe",
    "comments": [
      {
        "user": "YurkaninRyan",
        "created_at": "2017-09-25T13:27:22Z",
        "body": "Would it be easier to just call undo yourself, and set readOnly to `true`?"
      },
      {
        "user": "ianstormtaylor",
        "created_at": "2017-10-17T19:11:04Z",
        "body": "Hey, thanks for using Slate! Unfortunately, we can't offer support for usage questions in the issues here because it becomes overwhelming to maintain the project if the issues are filled with questions. \r\n\r\nHowever, we do have a Slack channel and people are constantly asking and answering questions in there. So I'm going to close this issue, but I definitely recommend joining the Slack channel if you want to find people that might be able to help. \r\n\r\nThanks for understanding!"
      }
    ]
  },
  {
    "number": 1039,
    "title": "Leaf Block Discussion",
    "created_at": "2017-08-29T17:17:02Z",
    "closed_at": "2017-09-19T17:37:41Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ianstormtaylor/slate/issues/1039",
    "body": "Recently, I've noticed bugs in `slate-edit-list` and `slate-edit-table`, where upon pasting, the inner most child would end up as the first block, and then after it the container would be pasted.  After digging into the code I think I found a couple of pain points.\r\n\r\n`insertFragmentAtRange` does logic involving `firstBlock` and `lastBlock` being the same block.  I think this is where these two plugins start to fall apart.  `getBlocks` only returns leaf blocks, so you won't get your full table, or your bulleted list.  You'll get the inner most bullet, or a table cell.\r\n\r\nNow, I know I've heard before that a lot of operations refer to Leaf Blocks, however, i'm wondering if that means we should rethink things like `wrapBlock`.  What do we need to fix here?  `insertFragment`'s behavior?",
    "comments_url": "https://api.github.com/repos/ianstormtaylor/slate/issues/1039/comments",
    "author": "YurkaninRyan",
    "comments": [
      {
        "user": "ianstormtaylor",
        "created_at": "2017-09-04T22:27:43Z",
        "body": "Hey @YurkaninRyan, search issues for `insertFragmentByKey`, I think there's a discussion of it. Let me know if you think that would solve the issue. I might be misunderstanding though."
      },
      {
        "user": "YurkaninRyan",
        "created_at": "2017-09-05T14:11:32Z",
        "body": "@ianstormtaylor I think it just might, i'll take a crack at it"
      }
    ]
  },
  {
    "number": 1036,
    "title": "Horizontal Rules in markup?",
    "created_at": "2017-08-29T00:26:31Z",
    "closed_at": "2017-09-04T22:27:58Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ianstormtaylor/slate/issues/1036",
    "body": "Should a < hr > tag/dividing line that contains no children be implemented as a mark or as a block with custom behavior?\r\n\r\nNot quite sure how to tackle this, so I would appreciate any input.",
    "comments_url": "https://api.github.com/repos/ianstormtaylor/slate/issues/1036/comments",
    "author": "anewusr",
    "comments": [
      {
        "user": "dmitrizzle",
        "created_at": "2017-08-29T05:49:02Z",
        "body": "Definitely a block. I had it set up in my schema as:\r\n```javascript\r\n    divider: props => {\r\n      const { node, state } = props\r\n      const focus = state.isFocused && state.selection.hasEdgeIn(node)\r\n      const className = focus ? \"focus\" : \"nofocus\"\r\n      return <hr className={className} />\r\n    },\r\n```\r\nAbove adds a class name to your `<hr/>` when it's selected; it will be removed with backspace."
      },
      {
        "user": "YurkaninRyan",
        "created_at": "2017-08-29T14:01:30Z",
        "body": "@anewusr `isVoid`, is the property you should look up.  It was an a-ha moment for me.  Basically is just a node without editable content"
      },
      {
        "user": "anewusr",
        "created_at": "2017-08-29T17:29:25Z",
        "body": "Excellent advice! Thanks @YurkaninRyan  and @dmitrizzle "
      }
    ]
  },
  {
    "number": 896,
    "title": "Make TEXT_RULE overridable",
    "created_at": "2017-06-21T17:21:40Z",
    "closed_at": "2017-06-21T21:25:55Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ianstormtaylor/slate/issues/896",
    "body": "In the Html deserializer there is a `TEXT_RULE` that is being appended to a list of rules by default. This works perfectly for 99% of the use cases but for 1% (which might be a huge 1% for some) it prevents the lib user from working on a `text` level when pasting. Pasting from word brings in an armageddon of html with four horsemen of weird symbols and edge cases. At the moment there is no way to just \"skip this mess\" for text elements because if we return nothing from our rule the `TEXT_RULE` will handle it. It would be nice to have a way to tell the deserializer not to append a `TEXT_RULE` to a stack of rules that user provides. We have to basically fork the deserializer and use our own version that only differs in the `TEXT_RULE`.\r\n",
    "comments_url": "https://api.github.com/repos/ianstormtaylor/slate/issues/896/comments",
    "author": "SamWyld",
    "comments": [
      {
        "user": "ianstormtaylor",
        "created_at": "2017-06-21T21:25:55Z",
        "body": "I think you can return `null` and further rules will be skipped."
      },
      {
        "user": "SamWyld",
        "created_at": "2017-06-22T09:29:01Z",
        "body": "I thought that would be the case however when returning null from any of the rules, this error occurs: `Uncaught TypeError: Cannot read property 'kind' of undefined`"
      },
      {
        "user": "ianstormtaylor",
        "created_at": "2017-06-22T16:08:23Z",
        "body": "Are you on the latest version of Slate? (Just checking.) If so, I'd be open to a pull request that fixes whatever it was. I thought I had already used the `null` in practice myself, but maybe not."
      }
    ]
  },
  {
    "number": 864,
    "title": "HTML Deserialization Rules Question",
    "created_at": "2017-06-03T22:18:28Z",
    "closed_at": "2017-06-21T21:04:38Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ianstormtaylor/slate/issues/864",
    "body": "I see 2 different ways to set up the rules for deserialization. Each rule having its own function, or one deserialization function. Which is better? Does it matter?\r\n\r\nMethod 1 (what im using)\r\n```\r\ndeserialize: (el, next) => {\r\n                if (this.BLOCKS[el.name]) {\r\n                    return {\r\n                        kind: 'block',\r\n                        type: this.BLOCKS[el.name],\r\n                        nodes: next(el.children),\r\n                        data: this.getData(el.name, el.attribs),\r\n                        isVoid: (this.VOID[el.name] ? this.VOID[el.name] : false),\r\n                    };\r\n                }\r\n\r\n                if (this.INLINE[el.name]) {\r\n                    return {\r\n                        kind: 'inline',\r\n                        type: this.INLINE[el.name],\r\n                        nodes: next(el.children),\r\n                        data: this.getData(el.name, el.attribs),\r\n                        isVoid: (this.VOID[el.name] ? this.VOID[el.name] : false),\r\n                    };\r\n                }\r\n\r\n\t\tif (this.MARKS[el.name]) {\r\n                    return {\r\n\t\t\tkind: 'mark',\r\n\t\t\ttype: this.MARKS[el.name],\r\n\t\t\tnodes: next(el.children),\r\n\t\t\tdata: this.getData(el.name, el.attribs),\r\n\t\t\tisVoid: (this.VOID[el.name] ? this.VOID[el.name] : false),\r\n                    };\r\n\t}\r\n\r\n\treturn;\r\n},\r\n```\r\n\r\nMethod 2 (what im trying to use like the paste-html example)\r\n```\r\nRULES = [\r\n\t\t{\r\n\t\t\tdeserialize(el, next) {\r\n                const type = this.BLOCKS[el.tagName];\r\n                if (!type) return null;\r\n\t\t\t\treturn {\r\n\t\t\t\t\tkind: 'block',\r\n\t\t\t\t\ttype: type,\r\n\t\t\t\t\tnodes: next(el.children),\r\n\t\t\t\t\tdata: this.getData(el.name, el.attribs),\r\n\t\t\t\t\tisVoid: (this.VOID[el.name] ? this.VOID[el.name] : false),\r\n\t\t\t\t};\r\n\t\t\t}\r\n\t\t},\r\n\t\t{\r\n\t\t\tdeserialize(el, next) {\r\n                const type = this.INLINE[el.tagName];\r\n                if (!type) return null;\r\n                return {\r\n                    kind: 'inline',\r\n                    type: type,\r\n                    nodes: next(el.children),\r\n                    data: this.getData(el.name, el.attribs),\r\n                    isVoid: (this.VOID[el.name] ? this.VOID[el.name] : false),\r\n                };\r\n\t\t\t}\r\n\t\t},\r\n\t\t{\r\n\t\t\tdeserialize(el, next) {\r\n                const type = this.MARKS[el.tagName];\r\n                if (!type) return null;\r\n                return {\r\n                    kind: 'mark',\r\n                    type: type,\r\n                    nodes: next(el.children),\r\n                    data: this.getData(el.name, el.attribs),\r\n                    isVoid: (this.VOID[el.name] ? this.VOID[el.name] : false),\r\n                };\r\n\t\t\t}\r\n\t\t},\r\n];\r\n```",
    "comments_url": "https://api.github.com/repos/ianstormtaylor/slate/issues/864/comments",
    "author": "Soletiq",
    "comments": [
      {
        "user": "ianstormtaylor",
        "created_at": "2017-06-21T21:04:38Z",
        "body": "Hey @Soletiq, nope it doesn't matter, whatever you prefer for whatever reasons you prefer it."
      }
    ]
  },
  {
    "number": 839,
    "title": "onSelect doesn't fire when using right/left arrows on Mac",
    "created_at": "2017-05-25T00:44:23Z",
    "closed_at": "2017-08-22T23:51:14Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ianstormtaylor/slate/issues/839",
    "body": "1. Create empty lines in document\r\n1. Add plugin with onSelect\r\n2. console.log() there\r\n3. Move cursor using left/right arrows on mac\r\n4. onSelect doesn't log\r\n5. onSelect does log when using up/down",
    "comments_url": "https://api.github.com/repos/ianstormtaylor/slate/issues/839/comments",
    "author": "natew",
    "comments": [
      {
        "user": "danburzo",
        "created_at": "2017-08-19T11:22:35Z",
        "body": "Confirming that `onSelect` is not triggered on plugins when navigating a set of empty blocks with the left/right arrow keys."
      },
      {
        "user": "ianstormtaylor",
        "created_at": "2017-08-22T23:51:08Z",
        "body": "@natew what are you looking to do with `onSelect`? I think this is slightly confusing from a UX perspective, but you are probably looking to use `onChange` instead. \r\n\r\nThe `onSelect` plugin handler is for handling DOM-level selections, in case you wanted to coerce them into a selection change. Mostly this is all handled by the core plugin, so you'd never need to use it. I'm going to close this one on that assumption, but feel free to respond if you have a use case that I'm not considering. Thanks!"
      },
      {
        "user": "hanstarj",
        "created_at": "2019-05-30T19:00:07Z",
        "body": "Hi @ianstormtaylor, my use case for onSelect is to make something like the hovering menu in the examples, but I want to make it appear only when selection by user is done, like Medium's editor. onSelect event is triggered when selection is complete in textarea, so I thought that onSelect in Slate would behave in the same way, but it's not. What is the recommended way to implement that in Slate?"
      }
    ]
  },
  {
    "number": 825,
    "title": "The placeholder doesn't take up width",
    "created_at": "2017-05-18T20:49:46Z",
    "closed_at": "2017-10-26T20:41:18Z",
    "labels": [
      "question",
      "⚑ ux"
    ],
    "url": "https://github.com/ianstormtaylor/slate/issues/825",
    "body": "When I have an `Editor` inline with other elements, or within a table cell, the `Editor` placeholder won't take up width, so it overlaps the element to the right.\r\n\r\nI tried setting `placeholderStyle` to `display: inline-block`, which doesn't help this problem.\r\n\r\nI tried setting `placeholderStyle` to `white-space: nowrap`, which prevents the text from wrapping when it's a squooshed cell of a table.\r\n\r\nI tried setting `placeholderStyle` to `position: static`, which does make the placeholder take up  width, but it puts the editor cursor *above* the placeholder.",
    "comments_url": "https://api.github.com/repos/ianstormtaylor/slate/issues/825/comments",
    "author": "tashburn",
    "comments": [
      {
        "user": "ianstormtaylor",
        "created_at": "2017-10-26T20:41:18Z",
        "body": "Hey @tashburn in the newest version of Slate the placeholder logic has changed, and you can define your own components to render for the placeholder, so you should have complete control over this now!"
      },
      {
        "user": "tashburn",
        "created_at": "2017-10-27T05:42:19Z",
        "body": "@ianstormtaylor Fantastic. Thanks for letting me know."
      }
    ]
  },
  {
    "number": 823,
    "title": "BBCode serialization",
    "created_at": "2017-05-18T16:36:44Z",
    "closed_at": "2017-05-21T17:42:00Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ianstormtaylor/slate/issues/823",
    "body": "#### Do you want to request a *feature* or report a *bug*?\r\nRequest feature\r\n\r\nMy application has to be able to convert to and from bbcode. The serialization slate already offers is great, but this would make it even better!",
    "comments_url": "https://api.github.com/repos/ianstormtaylor/slate/issues/823/comments",
    "author": "Soletiq",
    "comments": [
      {
        "user": "ianstormtaylor",
        "created_at": "2017-05-21T17:42:00Z",
        "body": "Hey @Soletiq, good question. Serializing to/from BBCode is a good use case, but it's not something that Slate's core logic is going to provide. Instead, it's definitely something that would work as a third-party module, so I'd encourage you to create it!"
      }
    ]
  },
  {
    "number": 762,
    "title": "prevent focusing void inline nodes",
    "created_at": "2017-04-27T08:09:58Z",
    "closed_at": "2017-05-08T08:30:17Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ianstormtaylor/slate/issues/762",
    "body": "is it possible to prevent focusing void inline nodes and make them act like characters? i.e. only allow the cursor the be on either side of the node, not \"on\" it.\r\n\r\nI tried to create a rule for this, but couldn't quite figure out how to check if a node has focus:\r\n```js\r\n{\r\n  match: node => node.kind === 'inline' && node.isVoid,\r\n  validate: node => // how to check if the node has focus here?,\r\n  normalize: (transform, node) => // move cursor to either side\r\n}\r\n```",
    "comments_url": "https://api.github.com/repos/ianstormtaylor/slate/issues/762/comments",
    "author": "httnn",
    "comments": [
      {
        "user": "SamyPesse",
        "created_at": "2017-04-27T09:00:37Z",
        "body": "The selection and the nodes are two distinct data sets. The schema rules can't be used to \"normalize\" the selection.\r\n\r\nInstead you could apply a transform in your `onChange` if the selection is in a void node:\r\n\r\n```js\r\nclass App extends React.Component {\r\n    state = {\r\n        state: initialState\r\n    }\r\n\r\n    onChange = (state) => {\r\n        const { startBlock, document } = state;\r\n\r\n        // The selection is in a void node.\r\n        if (startBlock.isVoid) {\r\n            const next = document.getNextBlock(startBlock.key);\r\n        \r\n            // The transform can be improved to move to next OR prev block\r\n            // By comparing the selection with the one of this.state.state\r\n            // And testing that \"next\" exists\r\n            state = state.transform()\r\n                .collapseToStartOf(nextBlock)\r\n                .apply()\r\n        }\r\n    \r\n        this.setState({ state })\r\n    }\r\n\r\n    render = () => {\r\n        return (\r\n            <Editor\r\n                state={this.state.state}\r\n                onChange={this.onChange}\r\n                />\r\n        )\r\n    }\r\n}\r\n```\r\n\r\nThis example can be improved, and maybe @ianstormtaylor has a better/simpler solution :)\r\n"
      },
      {
        "user": "SamyPesse",
        "created_at": "2017-04-27T09:02:55Z",
        "body": "Note: it could be exported as a Slate plugin using `onBeforeChange`:\r\n\r\n```js\r\nconst noSelectionInVoid = {\r\n    onBeforeChange(state) {\r\n       const { startBlock, document } = state\r\n\r\n        // The selection is in a void node.\r\n        if (startBlock.isVoid) {\r\n            const next = document.getNextBlock(startBlock.key);\r\n        \r\n            // The transform can be improved to move to next OR prev block\r\n            // By comparing the selection with the one of this.state.state\r\n            // And testing that \"next\" exists\r\n            state = state.transform()\r\n                .collapseToStartOf(nextBlock)\r\n                .apply()\r\n        }\r\n\r\n        return state\r\n    }\r\n};\r\n```\r\n\r\nand you can pass this plugin to your `<Editor plugins={[ noSelectionInVoid ]} />`\r\n"
      },
      {
        "user": "httnn",
        "created_at": "2017-04-27T11:18:05Z",
        "body": "@SamyPesse I see, think I'll go with the plugin approach then :)\r\n\r\none more thing: how would I get `this.state.state` for comparing previous cursor position in the plugin example?"
      },
      {
        "user": "httnn",
        "created_at": "2017-05-08T08:30:17Z",
        "body": "I don't think it's possible to read the current state in `onBeforeChange` in a plugin"
      },
      {
        "user": "httnn",
        "created_at": "2017-05-30T11:52:39Z",
        "body": "for anyone interested, managed to solve this eventually with a plugin like this:\r\n```js\r\nclass SkipVoidNodesPlugin {\r\n  direction = '';\r\n  onKeyDown(event, keyData, state) {\r\n    if (keyData.key === 'left') {\r\n      this.direction = 'Previous';\r\n    } else if (keyData.key === 'right') {\r\n      this.direction = 'Next';\r\n    } else {\r\n      this.direction = '';\r\n    }\r\n  }\r\n  onBeforeChange(state) {\r\n    if (this.direction !== '') {\r\n      const focusedNode = state.focusInline || state.focusText;\r\n      if (focusedNode.isVoid) {\r\n        return state.transform()[`collapseToEndOf${this.direction}Text`]().apply();\r\n      }\r\n    }\r\n  }\r\n}\r\n```"
      },
      {
        "user": "ara4n",
        "created_at": "2018-05-12T23:31:31Z",
        "body": "for those looking at this today, the bad news is that `onBeforeChange`, `Transform` and `State` have gone. the good news seems to be that the same trick works if you do it in `onChange` with `Change`, with something like this:\r\n\r\n```js\r\n    onChange = (change: Change) => {\r\n        let value = change.value;\r\n        if (this.direction !== '') {\r\n            const focusedNode = value.focusInline || value.focusText;\r\n            if (focusedNode.isVoid) {\r\n                change = change[`collapseToEndOf${ this.direction }Text`]();\r\n                value = change.value;\r\n            }\r\n        }\r\n        // ...\r\n        this.setState({\r\n            value,\r\n        });\r\n    }\r\n```"
      }
    ]
  },
  {
    "number": 739,
    "title": "Use removeNodeByKey on the last node breaks editor's state",
    "created_at": "2017-04-21T09:18:23Z",
    "closed_at": "2017-04-21T10:53:42Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ianstormtaylor/slate/issues/739",
    "body": "Hello! Not sure if this is intended or not but if you remove the last node in a editor's state with `removeNodeByKey` the editor state became unworkable, the documents nodes became an empty `List` and I got a warning and an error in console every time I try to type something in the editor:\r\n\r\n`Warning: An object was passed to a Node method instead of a `key` string. This was previously supported, but is being deprecated because it can have a negative impact on performance. The object in question was: null`\r\n\r\nand the error:\r\n\r\n`Uncaught Error: Invalid `key` argument! It must be either a block, an inline, a text, or a string. You passed: \"null\".`",
    "comments_url": "https://api.github.com/repos/ianstormtaylor/slate/issues/739/comments",
    "author": "ingro",
    "comments": [
      {
        "user": "skogsmaskin",
        "created_at": "2017-04-21T09:23:27Z",
        "body": "Hi! You should set up a rule in you schema that takes care of this for you, as Slate doesn't have any assumptions of what should happen (like which content should be insterted when empty). This is a good thing really, however I think this should be better documented, as this question comes up often.\r\n\r\nFor example:\r\n\r\n```\r\n    rules: [\r\n      // Rule to insert a default block when document is empty\r\n      {\r\n        match: node => {\r\n          return node.kind === 'document'\r\n        },\r\n        validate: document => {\r\n          return document.nodes.size ? null : true\r\n        },\r\n        normalize: (transform, document) => {\r\n          const block = Block.create({\r\n            type: 'paragraph'\r\n          })\r\n          transform\r\n            .insertNodeByKey(document.key, 0, block)\r\n            .focus()\r\n        }\r\n      }\r\n    ]\r\n```"
      },
      {
        "user": "ingro",
        "created_at": "2017-04-21T10:53:42Z",
        "body": "Well thanks for the clarification, I'm using `slate` only from few days and I've missed the `rules` section on the schema! Thanks again, I can close this!"
      }
    ]
  },
  {
    "number": 731,
    "title": "Add sample code for inserting inline",
    "created_at": "2017-04-19T15:44:51Z",
    "closed_at": "2017-08-01T20:49:35Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ianstormtaylor/slate/issues/731",
    "body": "There seems to be no examples of inserting inline. I looked at examples and tests for insertInline. I tried the insertInline call, and nothing seemed to work. Then I tried to insert with a serialiser and insertFragment, which didn't work either.\r\n\r\nI could only get it to work when inserting a block.\r\n\r\nIn general the tests are very limited and seem like a warning sign for the project for people evaluating. I think adding tests that cover the API well would be very helpful to show how to use Slate.",
    "comments_url": "https://api.github.com/repos/ianstormtaylor/slate/issues/731/comments",
    "author": "thepian",
    "comments": [
      {
        "user": "ianstormtaylor",
        "created_at": "2017-04-24T19:19:37Z",
        "body": "Hey @thepian, happy to accept PRs that add tests. There are quite a few for transforms, but testing the browser interaction with `contenteditable` is a bit harder to mock, so I haven't dug into it yet."
      },
      {
        "user": "ianstormtaylor",
        "created_at": "2017-08-01T20:49:35Z",
        "body": "Closing this since it's old. There are examples of inserting inlines I believe (emoji, link, etc.) and if anyone wants to help with the docs or tests they are welcome!"
      }
    ]
  },
  {
    "number": 722,
    "title": "read-only with hovering menu",
    "created_at": "2017-04-13T11:22:29Z",
    "closed_at": "2017-04-24T19:16:21Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ianstormtaylor/slate/issues/722",
    "body": "Hi, I am new to editor field. My question is that is it possible to make slate editor read-only and also can popup hovering menu at the same time ? Thank you !",
    "comments_url": "https://api.github.com/repos/ianstormtaylor/slate/issues/722/comments",
    "author": "Harryhaha",
    "comments": [
      {
        "user": "ianstormtaylor",
        "created_at": "2017-04-24T19:16:21Z",
        "body": "Hey @Harryhaha yes this should be possible, but since it's read-only you won't be able to position it based on the selection, and would need to figure out another way to position it instead."
      },
      {
        "user": "coniel",
        "created_at": "2020-06-09T00:55:15Z",
        "body": "For anyone looking for an easy way to implement this (it's a bit hacky but it works):\r\n\r\nI added a `selectionOnly` prop to my editor. When enabled, the `onChange` callback does nothing (so the content can't be modified) and the caret is made invisible using the style prop.\r\n\r\n```\r\nstyle={{ caretColor: selectionOnly ? 'transparent' : 'auto' }}\r\n```\r\n\r\nThe end result is the equivalent of a `readOnly` editor but with functioning selection."
      }
    ]
  },
  {
    "number": 695,
    "title": "Selecting actual \"typed content\" when rendered content is selected.",
    "created_at": "2017-03-30T13:05:14Z",
    "closed_at": "2017-03-30T14:29:00Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ianstormtaylor/slate/issues/695",
    "body": "Let's say I type `(c)` and convert it to ©. Or, maybe I convert `:)` to 😄 .\r\nIs it possible to get actual typed content when I selected rendered content. So, selecting the emoji should give me `:)`. \r\n\r\nEssentially mapping selection/cursor position from rendered content to typed content.\r\n\r\nIs something like that possible?",
    "comments_url": "https://api.github.com/repos/ianstormtaylor/slate/issues/695/comments",
    "author": "jatins",
    "comments": [
      {
        "user": "ianstormtaylor",
        "created_at": "2017-03-30T14:28:58Z",
        "body": "Hey @jatins, I'm not totally sure what you mean, but Slate is only concerned with the actual content, and not any previous representation that happened to be converted. So my guess is the answer is no. Of course, you can keep your own mapping around to do that if you want, but it wouldn't be handled by core. Feel free to ask follow up questions though!"
      },
      {
        "user": "jatins",
        "created_at": "2017-03-30T15:09:08Z",
        "body": "What I meant was, let's say I have a plugin which converts `:)` to 😄 .\r\n\r\nSo, in this case, the _typed content_ (the thing that was actually typed) is `:)` and rendered content being the emoji.\r\n\r\nNow when I select the emoji, I want to know what is selected in the _typed content_. However, I guess it wouldn't be possible since, as you mentioned, slate only knows about what's rendered.\r\n\r\n"
      },
      {
        "user": "ianstormtaylor",
        "created_at": "2017-03-30T16:36:50Z",
        "body": "Yup, unfortunately not. What's your use case?"
      },
      {
        "user": "jatins",
        "created_at": "2017-03-30T18:23:07Z",
        "body": "@ianstormtaylor I have some custom parsing logic for the text. So, `onKeyDown()` I parse the _entire content_ of current block, create a new slate block from parsed content and replace the existing block with new block.\r\n\r\nSo, let's say `-[ ] ` at the start of line becomes a check box. But `abcd -[ ]` should be rendered as plain text.\r\n\r\nConsider this scenario:\r\n1. User types `-[ ] ` -> renders a check box.\r\n2. User goes to the start of this block (that is the places his cursor before the check box) and types `abcd`. So, essentially the user _typed content_ now is `abcd-[ ] ` which should not be rendered as a check list. \r\n\r\nI can save what the user types in separate model. But now I have to map actions in _rendered content_ to actions in _typed content_ but unless I have a mapping between two, I am not sure how that'll work."
      },
      {
        "user": "oyeanuj",
        "created_at": "2017-04-17T19:12:40Z",
        "body": "@jatins For things like emojis and checkboxes, if you use inline nodes, then you could use the `data` property of the node to store the original text?"
      },
      {
        "user": "jatins",
        "created_at": "2017-04-18T09:58:46Z",
        "body": "@oyeanuj Thanks for the suggestion! \r\nYes, that's probably something I could do. I'll look into it."
      },
      {
        "user": "michaelpietrykowski",
        "created_at": "2017-04-18T16:19:21Z",
        "body": "@jatins That will work, I am doing basically the same thing.\r\nJust iterate over the nodes and check if `node.type === yourEmojiType`. If true, do `result += node.data.get('originalText')`, otherwise `result += node.text`."
      }
    ]
  },
  {
    "number": 685,
    "title": "Deserializing code and pre",
    "created_at": "2017-03-25T19:28:05Z",
    "closed_at": "2017-04-28T20:05:24Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ianstormtaylor/slate/issues/685",
    "body": "In my schema, I have two possible code layouts, one is for inline elements:\r\n\r\n```html\r\n<p>\r\n  Foo <code>foo</code> foo\r\n</p>\r\n```\r\n\r\nand one is for blocks:\r\n\r\n```html\r\n<pre>\r\n  <code>foo</code>\r\n</pre>\r\n```\r\n\r\nNow, I have the following deserialization rule:\r\n\r\n```js\r\n  deserialize = (el, next) => {\r\n    switch (el.tagName) {\r\n      case 'code':\r\n        return {\r\n          kind: 'mark',\r\n          type: CODE,\r\n          data: Data.create({}),\r\n          nodes: next(el.children)\r\n        }\r\n      case 'pre':\r\n        return {\r\n          kind: 'block',\r\n          type: CODE,\r\n          nodes: next(el.children)\r\n        }\r\n    }\r\n  }\r\n```\r\n\r\nUnfortunately, this causes that `<pre><code>asdf</code></pre>` will result in the following diff:\r\n\r\n```\r\n    - Expected\r\n    + Received\r\n\r\n    @@ -3,11 +3,20 @@\r\n\r\n         Object {\r\n           \"kind\": \"block\",\r\n           \"nodes\": Array [\r\n             Object {\r\n               \"kind\": \"text\",\r\n    -          \"text\": \"asdf\",\r\n    +          \"ranges\": Array [\r\n    +            Object {\r\n    +              \"marks\": Array [\r\n    +                Object {\r\n    +                  \"type\": \"CODE/CODE\",\r\n    +                },\r\n    +              ],\r\n    +              \"text\": \"asdf\",\r\n    +            },\r\n    +          ],\r\n             },\r\n           ],\r\n           \"type\": \"CODE/CODE\",\r\n         },\r\n```\r\n\r\nwhich looks wrong because we have a mark and a pre, which will result in `<pre><code><code>asdf</code></code></pre>`. On next import, this will get even more nested, and so on.\r\n\r\nSo, how do I get the output I desire?",
    "comments_url": "https://api.github.com/repos/ianstormtaylor/slate/issues/685/comments",
    "author": "aeneasr",
    "comments": [
      {
        "user": "thepian",
        "created_at": "2017-04-27T09:20:25Z",
        "body": "It seems to me that you want to define a node type for code as well as a mark for code. If you have `<pre><code></code></pre>` you don't add the mark inside a pre block"
      },
      {
        "user": "ianstormtaylor",
        "created_at": "2017-04-28T20:05:24Z",
        "body": "The way to solve this is to have your serializer rule for marks check first that the `<code>` element isn't inside a `<pre>` parent I think."
      }
    ]
  },
  {
    "number": 641,
    "title": "Uncaught TypeError: node.getRanges is not a function",
    "created_at": "2017-03-02T15:31:43Z",
    "closed_at": "2017-03-02T16:54:11Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ianstormtaylor/slate/issues/641",
    "body": "```\r\nconst firstNode = state.document.nodes.get(0);\r\n\r\nstate.transform().removeTextByKey(firstNode.key, 0, 3);\r\n```\r\n\r\nThrows \"Uncaught TypeError: node.getRanges is not a function\" at \"Object.Transforms.removeTextOperation\" at line 250\r\n\r\nIt seems like the node doesn't have a getRanges function.\r\n",
    "comments_url": "https://api.github.com/repos/ianstormtaylor/slate/issues/641/comments",
    "author": "santiagopuentep",
    "comments": [
      {
        "user": "ianstormtaylor",
        "created_at": "2017-03-02T16:54:11Z",
        "body": "Hey @santiagopuentep, I think this is actually because `removeTextByKey` requires a `kind == 'text'` node, instead of a block or inline. I believe if you do:\r\n\r\n```js\r\nconst firstText = state.document.getFirstText()\r\nstate.transform().removeTextByKey(firstText.key, 0, 3)\r\n```\r\n\r\n...it will work! Let me know if not though."
      },
      {
        "user": "santiagopuentep",
        "created_at": "2017-03-02T19:20:06Z",
        "body": "That worked. Thanks!\r\n\r\nShouldn't it have a check for the correct node? Or maybe a more descriptive error?\r\n\r\nAlso, I don't see `Document.getFirstText()` documented. I think it's missing.\r\n\r\nGreat job with the editor by the way, I love it, **much** better than draft.js that was driving me pretty crazy with some things and was hard to understand."
      }
    ]
  },
  {
    "number": 616,
    "title": "Question: best way to handle saving to Firebase",
    "created_at": "2017-02-22T11:07:56Z",
    "closed_at": "2017-03-27T17:52:02Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ianstormtaylor/slate/issues/616",
    "body": "Hi,\r\n\r\nI have an issue when trying to set up editing flow while saving changes to Firebase.\r\n\r\n1. I set up a listener to `/documents/:documentId` endpoint.\r\n2. Listener loads the document for the first time.\r\n3. I deserialize the document with `Raw.deserialize` and pass it to Editor state.\r\n4. I make some change in the editor.\r\n5. `onDocumentChange` handler triggers.\r\n6. I serialize Editor state with `Raw.serialize` in the `onDocumentChange` handler and save the result to the `/documents/:documentId` endpoint.\r\n7. At this moment the listener detects the change and gives me the new document (which is already in the Editor). \r\nIf I deserialize it again and pass it to the Editor as new state, it seems like the Editor is re-rendered and it loses focus. \r\nAnd it doesn't feel right to deserialize it again, because the latest version of the document is already in the Editor state. \r\nBut I don't see any way of checking that the document which came from the listener is the same as the document which is inside the editor, except deep equality check, which can be slow when documents are big. \r\nOther way could be to load the document only once, and don't establish the listener, but I would like to keep the realtime update. \r\n\r\nThanks in advance for any advice\r\n",
    "comments_url": "https://api.github.com/repos/ianstormtaylor/slate/issues/616/comments",
    "author": "optimistiks",
    "comments": [
      {
        "user": "jgrimes",
        "created_at": "2017-03-11T12:56:45Z",
        "body": "You could generate a `documentVersion` that is also saved in Firebase when serializing. You can check that before deserializing (or even retrieving) the document data from Firebase. "
      }
    ]
  },
  {
    "number": 615,
    "title": "Using placeholder with custom renderer for default paragraph",
    "created_at": "2017-02-22T04:32:52Z",
    "closed_at": "2017-02-22T22:17:28Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ianstormtaylor/slate/issues/615",
    "body": "Hi @ianstormtaylor! I have a component that, ideally, I would like to use instead of the default paragraph renderer. But, the `placeholder` text prop on the editor seems to work when using the default but not the custom component. \r\n\r\nIs that expected? If yes, do you think it would make sense for the standard `placeholder` prop to the `Editor` to be used if `placeholder` is not supplied in the custom component?\r\n\r\nI am hesitant to put the placeholder on the custom paragraph renderer, as then it would show up with every new paragraph. Is there an efficient way to prevent that, other than checking if it is the only node in its parent and that the parent is `Document`?\r\n\r\nThank you!",
    "comments_url": "https://api.github.com/repos/ianstormtaylor/slate/issues/615/comments",
    "author": "oyeanuj",
    "comments": [
      {
        "user": "ianstormtaylor",
        "created_at": "2017-02-22T22:17:25Z",
        "body": "Hey @oyeanuj check out the source for the Core plugin, which is the logic that creates the default placeholding logic. You can use the `<Placeholder>` component to achieve what you're trying to achieve I believe.\r\n\r\nRight now the `placeholder` attribute only applies to the default block, which is a bit confusing I agree. Potentially should be removed altogether in the future. Or find a better way."
      },
      {
        "user": "laurensiusadi",
        "created_at": "2018-06-19T03:03:07Z",
        "body": "@oyeanuj I found a solution using CSS to add placeholder on custom component.\r\nLeaving this here for future references.\r\n\r\nIn custom component render function\r\n```\r\n<span className={`${this.props.node.text.length > 0 ? '' : 'placeholder'}`}>\r\n   {children}\r\n</span>\r\n```\r\n\r\nInside CSS file\r\n```\r\n.placeholder::before {\r\n  content: \"Placeholder goes here\";\r\n  display: block;\r\n  position: absolute;\r\n  color: grey;\r\n  pointer-events: none;\r\n}\r\n```"
      }
    ]
  },
  {
    "number": 575,
    "title": "Trigger onChange after schema/normalize",
    "created_at": "2017-01-30T12:15:35Z",
    "closed_at": "2017-08-01T20:40:35Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ianstormtaylor/slate/issues/575",
    "body": "Hi, when plugin implements schema rules and normalize by them, it works fine, but these changes are not sent to state. This effectively mean that saved and displayed states are out of sync.\r\n\r\nSo I guess there should be onChange event triggered after normalizing.",
    "comments_url": "https://api.github.com/repos/ianstormtaylor/slate/issues/575/comments",
    "author": "Mangatt",
    "comments": [
      {
        "user": "ianstormtaylor",
        "created_at": "2017-01-30T18:32:15Z",
        "body": "Hey @Mangatt can you describe your use case where this is causing issues?\r\n\r\nI agree with you at first glance, it seems like plugins should be able to access the \"true\" state of the editor, instead of only the pre-normalized state. \r\n\r\nI initially thought we could move the normalize into the `onBeforeChange` stack, but right now the way the accumulator handlers like `onBeforeChange` and `onChange` work, this wouldn't be possible, since they can always return a new value, and normalization has to occur after any place where a new value can be returned.\r\n\r\nBut there's also a possibility that we could add `onAfter*` handlers, which are purely observers, which might solve your case. But I'd like to know more first so that I can be sure it's the right solution! Thanks"
      },
      {
        "user": "Mangatt",
        "created_at": "2017-01-30T19:36:10Z",
        "body": "My problem first occured with lists, when I wrapped selected items in list and let rules handle wrapping blocks in list in LI's.\r\n\r\nBut there are some more problems with normalizing with schema:\r\n- toolbar buttons do not necessarily show correct state of selection (block type is selected even when rule already changed this block into something else)\r\n- before saving to server, you need to trigger focus / blur to ensure that showed state will be really the one that will be saved\r\n- findDOMNode is not reliable since nodes can change on the fly\r\n\r\nWhat I am proposing is that when state is normalized by any of the plugins, there should be triggered standard onChange event by slate, after all plugins are done with normalizing. Just to flush changes to parent component, to ensure internal and external states are same."
      },
      {
        "user": "ianstormtaylor",
        "created_at": "2017-01-30T23:00:44Z",
        "body": "That should already be happening though—that the parent `Editor` will re-receive new `props.state` with the newly-changed, fully-normalized `state`?"
      },
      {
        "user": "Mangatt",
        "created_at": "2017-01-31T08:04:41Z",
        "body": "No, it's not happening right now. I'm managing state with redux and plugin rule is merging sibling lists into one.\r\n\r\nEditor shows only merged list, but redux has state before merging (multiple lists). After I focus editor, correct state is sent to redux."
      },
      {
        "user": "ianstormtaylor",
        "created_at": "2017-01-31T18:24:31Z",
        "body": "Can you make a very simple test case that reproduces this so it's easier to debug?"
      },
      {
        "user": "Mangatt",
        "created_at": "2017-02-01T09:19:13Z",
        "body": "That might be difficult since you have to track saved state and I think that jsfiddle does not support that. Here is my rule that joins sibling lists:\r\n\r\n```javascript\r\n{\r\n\tmatch: node => node.kind == 'block' || node.kind == 'document',\r\n\tvalidate(block) {\r\n\t\t//Join sibling lists\r\n\t\tconst lists = block.nodes.filter((block, key, blocks) => block.type == type && key && blocks.get(key-1).type == type);\r\n\t\treturn lists.size ? lists : null;\r\n\t},\r\n\tnormalize(transform, block, lists) {\r\n\t\tlists.map(list => {\r\n\t\t\tlet prev = transform.state.document.getPreviousSibling(list.key);\r\n\t\t\tlist.nodes.map(listItem => {\r\n\t\t\t\ttransform.moveNodeByKey(listItem.key, prev.key, Infinity);\r\n\t\t\t});\r\n\t\t\ttransform.removeNodeByKey(list.key);\r\n\t\t})\r\n\t\treturn transform;\r\n\t}\r\n}\r\n```\r\n\r\nCan you use this to reproduce that problem? If not, I can try to think something out at jsfiddle eventually."
      },
      {
        "user": "YurkaninRyan",
        "created_at": "2017-06-22T23:40:38Z",
        "body": "@Mangatt Did you happen to find a solution to this problem?  I'm having a similar problem that i'm trying to recreate in a fiddle, but no matter what I do it works perfectly in the fiddle (checked React Versions, bare bones in my app, etc... )"
      },
      {
        "user": "YurkaninRyan",
        "created_at": "2017-06-23T14:06:57Z",
        "body": "Fixed half of it today by upgrading from `0.20.2` to `0.20.4`.  It seems like the normalize calls are still not firing an onChange event when the normalize happens on initial load.  e.g if I have a rule where there must always be one PARAGRAPH element.\r\n\r\n1. Deserialize Empty Html\r\n2. Get Empty State, pass into editor.\r\n3. Normalize happens to add PARAGRAPH, but editor doesn't update until I focus.\r\n\r\nMy quick fix for this was just to auto focus the editor :+1:"
      },
      {
        "user": "ianstormtaylor",
        "created_at": "2017-08-01T20:40:35Z",
        "body": "This issue hasn't had a response in a while, and it's unclear if it's still present in the latest versions of Slate. To keep the issues easier to manage, since there are so many being opened every day, I'm going to close this old one out. \r\n\r\nBut if you notice that the bug is still happening, please feel free to comment and it can be revisited. It might be an edge case that not many people run into, in which case the fastest way to get it fixed would probably be to write a pull request for it.\r\n\r\nThanks for understanding!"
      }
    ]
  },
  {
    "number": 550,
    "title": "How to convert custom HTML?How to keep the property style?",
    "created_at": "2017-01-11T06:34:47Z",
    "closed_at": "2017-01-17T18:18:51Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ianstormtaylor/slate/issues/550",
    "body": "How to convert custom HTML?Such as the following HTML:\r\n\r\n`<div class=\"comp-text\"><p style=\"text-align:justify;\">富文<code>本模</code>块</p><h2>新内容</h2><p>增加了内容和颜色&nbsp;</p><p>no color<span style=\"color: rgb(251,160,38);\">color01</span>no color<span style=\"color: rgb(0,168,133);\">color01</span>no color</p></div>`\r\n\r\n**How to keep the property style?**",
    "comments_url": "https://api.github.com/repos/ianstormtaylor/slate/issues/550/comments",
    "author": "saymy",
    "comments": [
      {
        "user": "ianstormtaylor",
        "created_at": "2017-01-17T18:18:51Z",
        "body": "Hey @saymy it depends on your use case, but if you're just trying to keep the `color` style there you might want to create a `data.color` property in the `Node` in question's `data` property—which is reserved for custom data. Then you can render that `data.color` value as part of your rendering logic.\r\n\r\nIf you want to keep more complex information, you might need to store it as a string, or some other serialized format. But `Node.data` is a good starting point."
      },
      {
        "user": "saymy",
        "created_at": "2017-01-18T01:32:24Z",
        "body": "thanks"
      }
    ]
  },
  {
    "number": 546,
    "title": "Serialize redo/undo stack?",
    "created_at": "2017-01-05T20:58:30Z",
    "closed_at": "2017-01-12T19:22:43Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ianstormtaylor/slate/issues/546",
    "body": "Hi there,\r\n\r\nI wonder if it is possible to serialize the redo/ undo stack together with the document content?\r\nSo that once I save and close the browser, open it again to load the document from a file, I\r\nwould still be able to do undo and redo on the changes I made previously?",
    "comments_url": "https://api.github.com/repos/ianstormtaylor/slate/issues/546/comments",
    "author": "khanhhaduc",
    "comments": [
      {
        "user": "ianstormtaylor",
        "created_at": "2017-01-06T02:04:13Z",
        "body": "Hey @khanhhaduc, it's definitely possible. You'd need to serialize/deserialize it on your own though since it's not supported out of the box. I don't think it'd would be too hard, if you take a look at the source to see how `State` objects are created with a `History`.\r\n\r\nI'd also accept a pull request that split `History` into its own `src/models/history.js` and exported it at the top-level to make this use case easier if you wanted to write one!"
      },
      {
        "user": "callingmybluff",
        "created_at": "2019-04-03T08:19:07Z",
        "body": "Did not think of separating `History` but that actually makes much sense. Will be looking into doing so as I will be using this feature, as mentioned in #2678 and #2672"
      }
    ]
  },
  {
    "number": 456,
    "title": "Is the key a reliable block identifier between saves?",
    "created_at": "2016-11-25T23:52:55Z",
    "closed_at": "2016-11-28T18:57:53Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ianstormtaylor/slate/issues/456",
    "body": "First of all, this is an absolutely amazing project. I rewrote a huge chunk of a DraftJS editor in a tiny fraction of the code. The abstractions and thought put into this are top notch.\r\n\r\nThe question is, is the block.key a reliable unique identifier for a block between saves?\r\n\r\nRaw.serialize throws away the keys and that's fine. But assuming I write a serialize/deserialize where it saves out the keys and load them back in, can I expect that the Editor won't just throw away the keys in a future version?\r\n\r\nSpecifically, I use the keys as a simple but effective way to keep track of edits that happened on a page since the user last visited. So, if a user goes away and a page was updated by another team member, the blocks that have been updated have a little highlight on their right edge. This is so that the user doesn't have to read through an entire page trying to figure out what has changed. The user just has to look through the highlighted blocks.\r\n\r\nI currently use DraftJS block keys to track this. I'd like to switch the Editor to SlateJS and use the keys in the same way.\r\n\r\nGiven the change to discard keys on serialize/deserialize, I wanted to make sure that there were no future plans to simply do away with keys as a reliable indicator of a block's identity.",
    "comments_url": "https://api.github.com/repos/ianstormtaylor/slate/issues/456/comments",
    "author": "thesunny",
    "comments": [
      {
        "user": "ianstormtaylor",
        "created_at": "2016-11-28T18:57:53Z",
        "body": "Hey @thesunny, good question!\r\n\r\nThere short answer is no, but I've added a few sections to the docs so that hopefully it's easier to find the answer for others in the future. Here they are:\r\n\r\n> ### `key`\r\n> `String`\r\n> \r\n> A short-lived, unique identifier for the node.\r\n> \r\n> By default, keys are **not** meant to be long-lived unique identifiers for nodes that you might store in a database, or elsewhere. They are meant purely to identify a node inside of a single Slate instance. For that reason, they are simply auto-incrementing strings. (eg. `'0'`, `'1'`, `'2'`, ...) \r\n> \r\n> If you want to make your keys uniqueness long-lived, you'll need to supply your own key generating function via the [`setKeyGenerator`](../utils/utils.md#setkeygenerator) util.\r\n\r\nAnd:\r\n\r\n> ### `setKeyGenerator`\r\n> `setKeyGenerator(generator: Function) => Void`\r\n> \r\n> Allows you to specify your own key generating function, instead of using Slate's built-in default generator which simply uses auto-incrementing number strings. (eg. `'0'`, `'1'`, `'2'`, ...)\r\n> \r\n> This will act globally on all uses of the Slate dependency.\r\n"
      }
    ]
  },
  {
    "number": 423,
    "title": "General issues with async programmatic manipulation of editor",
    "created_at": "2016-11-15T01:51:20Z",
    "closed_at": "2016-11-17T23:05:22Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ianstormtaylor/slate/issues/423",
    "body": "I'd like to follow up with more specific details, but for now I'm opening this ticket to track this class of issue. I'm working on a plugin that needs to fetch results from an API which it then uses to manipulate the editor's state. I've run into several issues with state transformations triggering at coincidental timings that cause the editor to raise uncaught errors.\r\n\r\nJust to better understand some context: from the API documentation at least, it seems this use case has not been explored much yet? A lot of the transformations seem to be catered toward users invoking them via commands (by operating on cursor selections, for the most part). Manipulating the selection in order to trigger transformations is also clumsy (e.g. restoring the original user cursor is not easy) so I'm thinking I'm treating in uncharted territory with this use case.\r\n\r\nI think I have workarounds for the issues I've run into so far, but would like to explore this further.",
    "comments_url": "https://api.github.com/repos/ianstormtaylor/slate/issues/423/comments",
    "author": "aehlke",
    "comments": [
      {
        "user": "ianstormtaylor",
        "created_at": "2016-11-17T23:05:22Z",
        "body": "Hey @aehlke not sure if you've solved this or not, since it's a bit vague. But in general, when working with asynchronous transforms be sure to use `editor.getState` right before trying to modify it, otherwise you might end up with a stale state being used, in which case any changes that were made between the time it was accessed and the time the async operation was completed might be lost.\n\nI'm doing to close this issue since it's not easily actionable. If you run into specific things, feel free to open another one (best to include code samples).\n"
      }
    ]
  },
  {
    "number": 386,
    "title": "Is it possible to use slate with angularjs?",
    "created_at": "2016-10-16T14:08:56Z",
    "closed_at": "2016-10-17T23:22:42Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ianstormtaylor/slate/issues/386",
    "body": "It seems this project needs `React` and work only in the project that use `React`.\nAm I correct?\n",
    "comments_url": "https://api.github.com/repos/ianstormtaylor/slate/issues/386/comments",
    "author": "mikeandersun",
    "comments": [
      {
        "user": "SamyPesse",
        "created_at": "2016-10-17T12:24:56Z",
        "body": "Yes, Slates is using `React` as rendering engine. You cannot replace React by Angularjs in Slate,  but you can probably use React with AngularJS (I'll not advise you to do so: both are large and equivalent dependencies).\n"
      }
    ]
  },
  {
    "number": 382,
    "title": "Support React as AMD module",
    "created_at": "2016-10-13T03:31:08Z",
    "closed_at": "2016-11-17T03:05:09Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ianstormtaylor/slate/issues/382",
    "body": "I'm wondering why `window.React` is used in NPM package instead of consuming it (at least, as fallback) as AMD module?\n\nI'm not using React otherwise and I don't really want to mess around with it, just want to consume everything like usual AMD dependencies.\n\nLooks like Slate is currently enforcing build system and/or the whole React ecosystem on those who want to use it as one of many tools on the projects.\n\nIs this something that can be supported?\n",
    "comments_url": "https://api.github.com/repos/ianstormtaylor/slate/issues/382/comments",
    "author": "nazar-pc",
    "comments": [
      {
        "user": "nazar-pc",
        "created_at": "2016-10-13T08:15:22Z",
        "body": "And `slate` itself I guess too, otherwise I'm getting:\n\n```\nUncaught ReferenceError: exports is not defined\n```\n"
      },
      {
        "user": "SamyPesse",
        "created_at": "2016-10-17T13:02:27Z",
        "body": "Are you importing the `dist/slate.js` or `lib/index.js` ?\n"
      },
      {
        "user": "nazar-pc",
        "created_at": "2016-10-17T13:08:13Z",
        "body": "`dist/slate.min.js`.\n`lib` is all CommonJS which is not browser-compatible (at least if you don't have a bunch of stuff for build process, which I don't want to add just for this library).\n"
      },
      {
        "user": "ianstormtaylor",
        "created_at": "2016-11-17T03:05:08Z",
        "body": "Hey @nazar-pc, I'm not sure exactly what you're asking for. \n\nThere's a bundled version in `dist/slate.js`, which has all of Slate packaged up (except for React which you need to bring yourself). And then there's the default method of requiring it like a regular node module. For now those are the only two supported out-of-the-box ways to use Slate. If you'd like to use it in a different way, you're free to clone and build from the source yourself, but I can't support a bunch of other build outputs right now I think.\n"
      },
      {
        "user": "nazar-pc",
        "created_at": "2016-11-17T11:49:12Z",
        "body": " I thought Slate is designed to run in browser. If this is correct, then why the default way of loading it is like regular node module? It simply doesn't work in browser, there is AMD designed for browsers. Not supporting it out-of-the-box (especially considering that UMD is trivial to implement) and forcing people to manually include React on the page doesn't make any sense to me. It simply doesn't work in browser and forcing people to use certain build tools, which is even worse.\n\nI hope to see UMD build where React is loaded as dependency rather than from global scope.\n"
      }
    ]
  },
  {
    "number": 342,
    "title": "operation to replace document entirely?",
    "created_at": "2016-09-20T19:02:27Z",
    "closed_at": "2016-09-22T23:17:25Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ianstormtaylor/slate/issues/342",
    "body": "My editor is partially-collaborative, in the sense that multiple people can edit documents at the same time, but they can't see what the other people are doing. This mostly works in practice since we have a limited number of people working in the same document and even fewer working in the same Slate editor.\n\nWhen changes happen, the new complete document (stored in HTML) is distributed to other clients and the other clients silently swap it out with the old state. The issue I am facing now is that the undo/redo history is removed since it is a brand new state. In the pre-0.14 transform I could simply save a new version of the document into the history, however with this new operation-based transform that is not so easy.\n\nSo is it possible to get an operation that totally overwrites the state's document with a new document?\n",
    "comments_url": "https://api.github.com/repos/ianstormtaylor/slate/issues/342/comments",
    "author": "tyler-johnson",
    "comments": [
      {
        "user": "ianstormtaylor",
        "created_at": "2016-09-22T23:17:25Z",
        "body": "I don't think this is something that will become an operation, since the operations are intended to be small for OT/CRDT use. However, it could become a transform if it proves useful to enough people.\n\nAlthough for now what you could do is manually make the same thing happen, by looping the document and removing all the top-level nodes. And then looping the new document and inserting all of its top-level nodes. Hope that helps!\n"
      },
      {
        "user": "ianstormtaylor",
        "created_at": "2016-09-22T23:18:59Z",
        "body": "PS. Of course you could also migrate to an operation-based update schema, where you just send each set of operations over the wire instead, and apply them in the other persons editor (without performing OT) and then I think the history would work like normal.\n"
      },
      {
        "user": "tyler-johnson",
        "created_at": "2016-09-27T18:21:08Z",
        "body": "@ianstormtaylor thanks for the suggestion!\n\nThe transform goes through fine, but the editor gets into a state where further edits throw these errors:\n\n```\nUncaught Error: Invalid `key` argument! It must be either a block, an inline, a text, or a string. You passed: \"null\".\n```\n\n```\nError: Could not find a descendant node with key \"a5ok\".\n```\n\nHere is the transform I am using. I am doing something incorrectly? or perhaps this is related to #353?\n\n``` js\nlet transform = state.transform();\n\nstate.document.nodes.forEach(n => {\n  transform = transform.removeNodeByKey(n.key);\n});\n\nnewstate.document.nodes.forEach((n, index) => {\n  transform = transform.insertNodeByKey(state.document.key, index, n);\n});\n\nstate = transform.apply();\n```\n"
      },
      {
        "user": "ianstormtaylor",
        "created_at": "2016-09-27T21:33:18Z",
        "body": "Hmm that first error is particularly strange, do you happen to have a stack trace to know why `null` is passed as a key somewhere? Not sure what would be causing that.\n"
      },
      {
        "user": "chilijung",
        "created_at": "2016-10-04T17:49:13Z",
        "body": "I've also get the error\n\n```\nUncaught Error: Invalid `key` argument! It must be either a block, an inline, a text, or a string. You passed: \"null\".\n```\n\nwhen using `removeNodeByKey` API. I've tried to find out why, but still can't find what cause the error.\n"
      },
      {
        "user": "sdemontfort",
        "created_at": "2017-09-14T06:55:03Z",
        "body": "I can run `removeNodeByKey` without an error, but  as soon as I type into the editor afterwards, I get the error:\r\n`Invalid `key` argument! It must be either a block, an inline, a text, or a string. You passed: null`\r\n\r\nMy editor element is also shown as empty, with no elements inside it whatsoever.\r\n\r\nIs this still a known problem?"
      },
      {
        "user": "jobergner",
        "created_at": "2018-02-06T11:28:53Z",
        "body": "Same problem as @sdemontfort . Can't find a way to work around it."
      }
    ]
  },
  {
    "number": 266,
    "title": "Schema rules question: Validation against a node's parents",
    "created_at": "2016-08-24T07:49:24Z",
    "closed_at": "2016-08-29T12:10:47Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ianstormtaylor/slate/issues/266",
    "body": "Hello again, now with a real question.\n\nI am implementing a validation rule for lists with a classic structure, a parent `list-block` that can contains only a list of `item-block`:\n\n```\nlist-block\n    [\n        item-block\n    ]    \n```\n\nI can easily validate a `list-block` node's children to be `item-blocks`. But I am not sure **how to validate that any `item-blocks` is a descendant of a `list-block`**.\n\nI could make a global rule that looks for orphan `item-block` across the whole document, like this:\n\n``` js\nconst ITEM_BLOCK_RULE = {\n    // Apply rule to all blocks\n    match: function matchAllBlock () ...,\n\n    validate: function (block) {\n        // If the block is not a list-block,\n        // but has an orphan item-block as child,\n        // invalidate.\n    },\n\n    normalize: ... // remove orphan item-blocks\n}\n```\n\nBut I instinctively would like to implement a rule like this:\n\n``` js\nconst ITEM_BLOCK_RULE = {\n    match: function matchItemBlock () ...,\n\n    // Extra <document> parameter\n    validate: function (node, document) {\n        // Use the document reference to check that node's parent\n        // is a list-block\n    },\n\n    normalize: ... // remove the item-block if it is orphan\n}\n```\n\nDo you think it would make sense to pass a reference to the document as parameter to `validate` ? This would help to implement these kind of context sensitive rules.\n\nThanks for the awesome work.\n",
    "comments_url": "https://api.github.com/repos/ianstormtaylor/slate/issues/266/comments",
    "author": "Soreine",
    "comments": [
      {
        "user": "Soreine",
        "created_at": "2016-08-24T07:55:05Z",
        "body": "Thinking about it now, passing the `document` as reference could prevent some cool optimizations like memoizing the `validate` functions (to only execute the validation on nodes that have changed).\n"
      },
      {
        "user": "ianstormtaylor",
        "created_at": "2016-08-24T22:05:53Z",
        "body": "Ah yup, the memoization is the reason I opted not to do that. Sadly I think it's something we have to constrain since validation will be called so often that without being able to lock it down a lot for performance things will get slow.\n\nSame goes for the `decorate` method too if I remember correctly.\n\nSo yeah, it would need to be implemented with the \"all blocks\" technique instead. But that'll give us better performance.\n\nLet me know if you have any more questions!\n"
      },
      {
        "user": "Soreine",
        "created_at": "2016-08-29T12:10:47Z",
        "body": "Definitely. Thanks!\nI went for the \"all blocks\" technique. And it even made the code cleaner. Since we can split the normalization rules for a type of block into several rules (`{match, validate, normalize}`), I was able to just move that bit of logic into its own rule at the \"all blocks\" level. The other rules can stay at their relevant level.\n"
      }
    ]
  },
  {
    "number": 241,
    "title": "Markdown",
    "created_at": "2016-08-12T16:45:27Z",
    "closed_at": "2016-08-15T22:02:19Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ianstormtaylor/slate/issues/241",
    "body": "Tried to use **word** to get bold, it didn't happen.\n",
    "comments_url": "https://api.github.com/repos/ianstormtaylor/slate/issues/241/comments",
    "author": "vdms",
    "comments": [
      {
        "user": "ianstormtaylor",
        "created_at": "2016-08-12T18:32:42Z",
        "body": "Hey @vdms, do you mean that you type `**bold**` into one of the examples and nothing happened? \n\nIf so, that's normal, because the examples just show you how to implement different types of functionality, but they don't try to handle _all_ the functionality anyone might want. They're there to show you how to use the API. I've got that specific `**bold**` functionality working in my own editor, and I might open-source a library for it in a bit, but it wouldn't be in Slate's \"core\" library. Does that make sense? Happy to explain further if you have any questions!\n"
      },
      {
        "user": "ianstormtaylor",
        "created_at": "2016-08-15T22:02:19Z",
        "body": "Gonna close this, but let me know if you have any more info or questions!\n"
      },
      {
        "user": "vdms",
        "created_at": "2016-09-09T17:10:28Z",
        "body": "That makes sense. Thank you.\n"
      }
    ]
  },
  {
    "number": 240,
    "title": "the 'escape' function didn't work",
    "created_at": "2016-08-12T16:44:52Z",
    "closed_at": "2016-08-22T16:20:50Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ianstormtaylor/slate/issues/240",
    "body": "I am using Windows 10, Chrome lastest version in 12 of Aug 2016.\nTried to see the demo where we use the esc, but simply didn't work. \n",
    "comments_url": "https://api.github.com/repos/ianstormtaylor/slate/issues/240/comments",
    "author": "vdms",
    "comments": [
      {
        "user": "ianstormtaylor",
        "created_at": "2016-08-12T18:33:26Z",
        "body": "Hey @vdms which example were you on? and what functionality are you talking about? and what are the steps to reproduce? Is there an error in the console or is it just not doing anything at all?\n"
      }
    ]
  },
  {
    "number": 222,
    "title": "Capability to disable console.log statements.",
    "created_at": "2016-08-04T12:07:29Z",
    "closed_at": "2016-08-04T17:57:29Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ianstormtaylor/slate/issues/222",
    "body": "They are useful when debugging slate, but they get in the way when I attempt to debug other parts of my system.  Being able to toggle them would be great.\n",
    "comments_url": "https://api.github.com/repos/ianstormtaylor/slate/issues/222/comments",
    "author": "ctrlplusb",
    "comments": [
      {
        "user": "ianstormtaylor",
        "created_at": "2016-08-04T17:57:28Z",
        "body": "Hey @ctrlplusb do you mean the `debug` calls? Right now they should be Local Storage based, so that if you have `debug=\"*\"` set they will show up. You can disable all debug calls by removing the `debug` key, or you can disable Slate's only by doing something like `debug=\"*,-slate:*\"` I believe. Let me know if that helps!\n"
      },
      {
        "user": "ctrlplusb",
        "created_at": "2016-08-04T18:57:15Z",
        "body": "Aha, sorry I had no idea you were using the debug library. Should have checked. Thanks!\n"
      },
      {
        "user": "ianstormtaylor",
        "created_at": "2016-08-04T19:26:09Z",
        "body": "No worries!\n"
      }
    ]
  },
  {
    "number": 209,
    "title": "Plugin / Export transformations",
    "created_at": "2016-07-31T15:56:07Z",
    "closed_at": "2016-08-01T19:04:58Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ianstormtaylor/slate/issues/209",
    "body": "This issue is mostly a question about plugin conventions. I'm working on a few plugins for lists, tables and code edition.\nAnd for example the `slate-edit-table` should provides some transformations (`insertRow`, `insertColumn`, etc).\n\nI'm wondering that could be the best API for this:\n1. Export these transformation as `transform(state: State) : State` from the module\n2. Plugin extends the `Transform` class\n\n---\n### 1. Plugin module exports these method\n\n**Good:** avoid extending an internal object\n**Bad**: we have to pass all options to all calls\n\n``` js\nimport EditTable from 'slate-edit-table'\n\nconst opts = { typeTable: 'table', typeRow: 'table-tr', typeCell: 'table-cell' }\n\nconst plugins = [\n  EditTable(opts)\n]\n\n// Later in code:\n\nthis.onChange(\n    EditTable.insertRow(this.state.state, opts)\n);\n```\n### 2. Plugin extends the `Transform`\n\n**Good:** same API for core transformation and plugin transformations\n**Bad**: we have to extend an internal object (Slate can provides an API for plugin to do so?)\n\n``` js\nimport EditTable from 'slate-edit-table'\n\nconst plugins = [\n  EditTable({ typeTable: 'table', typeRow: 'table-tr', typeCell: 'table-cell' })\n]\n\n// Later in code:\n\nthis.onChange(\n    this.state.state\n         .transform()\n         .insertRow()\n         .apply()\n);\n```\n\n---\n\n**Personal opinion:** I prefer the second method.\n",
    "comments_url": "https://api.github.com/repos/ianstormtaylor/slate/issues/209/comments",
    "author": "SamyPesse",
    "comments": [
      {
        "user": "ianstormtaylor",
        "created_at": "2016-08-01T18:55:59Z",
        "body": "Good question! I think the second method isn't something I'd recommend, at least not yet, because it gets a bit hacky with extending the transform object. But I do like the idea of providing an API for transforms, I'll open another issue for that.\n\nIn the meantime, I'd probably do something similar to the first method, but instead of taking a `state` and returning a `state`, I'd have it take a `transform`. So that you'd do things like:\n\n``` js\nlet transform = state\n  .transform()\n  .insertText('some text')\n\ntransform = EditTable.insertRow(transform)\n\nreturn transform\n  .insertFragment(someFragment)\n  .apply()\n```\n\nStill not as nice as chaining only, but it allows you to use it the same way other transforms are used, and be part of a single `apply()` transaction.\n"
      },
      {
        "user": "SamyPesse",
        "created_at": "2016-08-01T19:04:58Z",
        "body": "Yes, I'll start with this API, and change it if Slate moves to an another one.\n\nIt's clear that if Slates grows an ecosystem of plugins, it will require a API convention for plugins to expose transformations.\n\n## \n\nSince you'll open another PR, I'm closing this one.\n"
      }
    ]
  },
  {
    "number": 184,
    "title": "Quickest way to wrap just selected text in a block?",
    "created_at": "2016-07-27T20:56:05Z",
    "closed_at": "2016-07-28T20:56:36Z",
    "labels": [
      "question",
      "♥ help"
    ],
    "url": "https://github.com/ianstormtaylor/slate/issues/184",
    "body": "I know there is probably a way to do this easily, however I am getting tripped up with transforms and selections.\n\nI know about `wrapBlock()` however it wraps the entire block and not just the selection. I desire functionality like `wrapInline()` where only the portion of the block that is in the selection is wrapped. How might I accomplish this in a single transform?\n",
    "comments_url": "https://api.github.com/repos/ianstormtaylor/slate/issues/184/comments",
    "author": "tyler-johnson",
    "comments": [
      {
        "user": "ianstormtaylor",
        "created_at": "2016-07-27T21:53:21Z",
        "body": "Good question! I don't believe there's a way to do this in a single transform, at least not right now. What are you using it for? Just curious for thinking through the use case.\n\nBut off the top of my head I think you could do:\n\n``` js\nconst { selection } = state\nconst next = state.\n  .transform()\n  .splitBlockAtRange(selection.collapseToEnd())\n  .collapseToStart()\n  .splitBlock()\n  .wrapBlock(...)\n```\n\nNot the simplest, but you have to split at the end block first, because if you split at the start first you might end up splitting the current node before the ending point, invalidating the current selection.\n\nIt's not amazing that `wrapBlock` and `wrapInline` have different splitting methods, but when I wrote `wrapBlock` that seemed like the most common way you'd want it. Perhaps they both need a `{ split: true }` option or something. (Although they'd need to take the depth as well.)\n"
      },
      {
        "user": "tyler-johnson",
        "created_at": "2016-07-27T23:30:57Z",
        "body": "Ah yes the `.splitBlockAtRange(selection.collapseToEnd())` is what I believe I was missing. I will make another attempt at this tomorrow. I am still a novice at this immutability stuff and it didn't occur to me that I could transform the content without moving the selection around. Thanks.\n\nAs for the use case, I am looking for alternative ways to solve #178. I was thinking that perhaps the popup could be embedded in the document next to the inline text it is linked to. Since the popup content will require block nodes, I assumed that all the parent nodes would need to be block nodes as well. Truthfully an Inline node would fit better. So I guess this leads to another question: Can Inline nodes contain Block nodes as children?\n\n---\n\nPersonally I think the functionality of `wrapBlock` and `wrapInline` are to be expected as the documentation describes them as \"Wrap the {Inline/Block} nodes in the current selection\". To me that says that _no_ splitting of blocks or inlines will take place at the selection boundaries and new nodes will simply wrap the existing ones. Additionally, it makes sense that `wrapInline` would split Text nodes when there are no inline nodes to wrap. I would expect the same functionality from `wrapBlock` if the document just had text nodes but it seems like documents always contain blocks.\n\nPerhaps you could add two new methods with names like `wrapRangeWithBlock` and `wrapRangeWithInline`?  Interestingly these could have the added benefit of wrapping _inside_ the current block or inline instead of wrapping on the outside (assuming that's how `wrapBlock` and `wrapInline` work currently).\n"
      },
      {
        "user": "ianstormtaylor",
        "created_at": "2016-07-28T19:39:15Z",
        "body": "I could be down with that, having `splitAndWrapBlock` and `splitAndWrapInline` seems like it would solve the problem. If you want to take a stab at PR'ing that I'd be down to help merge!\n"
      },
      {
        "user": "tyler-johnson",
        "created_at": "2016-07-28T20:33:28Z",
        "body": "So I have implemented what you had suggested, and it is close to what I am looking for not exactly right. Perhaps there are some limitations around what sort of siblings a block node can have, I'm not sure.\n\nWhat I am looking to create from a serialized standpoint is structure that looks like this. If before the transform I have this:\n\n``` yaml\nnodes:\n  - kind: block\n    type: paragraph\n    nodes:\n      - kind: text\n        text: before word after\n```\n\nI am looking to turn it into this:\n\n``` yaml\nnodes:\n  - kind: block\n    type: paragraph\n    nodes:\n      - kind: text\n        text: before\n      - kind: block\n        type: paragraph\n        nodes:\n          - kind: text\n            text: word\n      - kind: text\n        text: after\n```\n\nNotice the inner block is surrounded by text nodes. Is this possible? Totally fine if it is not as now that I attempt to explain it I realize there may be some issues with it. 😆\n\nAs for the `splitAndWrapBlock` and `splitAndWrapInline`: I will definitely try implementing them!\n"
      },
      {
        "user": "ianstormtaylor",
        "created_at": "2016-07-28T20:41:19Z",
        "body": "Ah yeah, blocks can only have either `Block` children or `Inline/Text` children, but not mixed. I would say that this is not enforced very well anywhere right now though. Need to add it in to `.normalize` to make it truly enforced, good call!\n"
      },
      {
        "user": "tyler-johnson",
        "created_at": "2016-07-28T20:56:36Z",
        "body": "Okay no problem thanks for clarifying this!\n"
      }
    ]
  },
  {
    "number": 178,
    "title": "Question - embedding editors within editors (editor inception)",
    "created_at": "2016-07-26T21:47:12Z",
    "closed_at": "2016-07-28T20:20:19Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ianstormtaylor/slate/issues/178",
    "body": "I am wondering the best approach for placing editors within editors. On the surface this seems very trivial with Slate compared to other WYSIWYGs, however I need the histories (undo/redo) of the editors to be connected.\n\nMy use case goes like this:\n1. User types text into editor.\n2. User highlights inline text and adds a \"popup\" (ie. annotation). This action pauses the original editor and opens a second editor for the popup's contents.\n3. User decides after creating the popup that they don't want the popup, so they press Cmd-z to undo. Ideally this would reverse the previous state, destroying the popup and returning to the original text.\n4. Then the user decides they really did want the popup, so within the original editor the press Cmd-Shift-z thus redoing the previous action and returning to the popup mode.\n\nAfter a brief reading of the Transform, State and Document code this seems rather doable by sharing the History object between editor states. What is tripping me up is how to let the states know which editor the history was made in so it can smartly switch between editors as the user undoes and redoes changes.\n\nI would like to mention that I have implemented this scenario in many, many different WYSIWYGs with varying degrees of success. The closest I have come so far is with Quill, which our production application is currently running. Not a single editor manages to come close to having undo/redo support with embed editors and all of them had issues with switching between two editors. To me this is the true power of Slate and IMO is the absolutely the future of WYSIWYG on the web. So kudos for doing what everyone else has fallen short at.\n",
    "comments_url": "https://api.github.com/repos/ianstormtaylor/slate/issues/178/comments",
    "author": "tyler-johnson",
    "comments": [
      {
        "user": "ianstormtaylor",
        "created_at": "2016-07-27T18:40:04Z",
        "body": "Thanks 😄  glad you like it!\n\nQuestion, since you have more context on this than me, what changes would you make to the architecture to make this possible?\n"
      },
      {
        "user": "tyler-johnson",
        "created_at": "2016-07-28T17:49:53Z",
        "body": "Okay after giving this a lot of thought and a thorough reading of Slate's code, I guess what I am asking for is **multiple document/editor support**.\n\nI'm not totally sure how this manifests itself in Slate, but in my mind documents/editors would share a couple of features:\n- Undo/redo history. Ideally typing cmd-z in one editor would undo a change in different editor (if that was the last change in history). I know with immutability this may be difficult to do transparently, however I think there is a real use case here. Our users have been asking for it for a while now, but it has been incredibly complex to achieve in Quill.\n- _Some, but not all_ plugins. Obviously this already doable, however I'm thinking more that there is a shared state of sorts so that plugins could be aware of all the connected documents/editors.\n"
      },
      {
        "user": "ianstormtaylor",
        "created_at": "2016-07-28T19:41:54Z",
        "body": "The history one makes sense to me. What is the \"some, but not all plugins\" need for?\n"
      },
      {
        "user": "tyler-johnson",
        "created_at": "2016-07-28T20:20:19Z",
        "body": "I just meant that I would have some plugins that are just for individual editors and some plugins that all the editors would share. Of course there may not be any difference in the API for this.\n\nI'm going to close this issue since I consider it solved. We do not need support for multiple documents anytime soon, so I will probably open an issue for this down the road, assuming it doesn't get solved in the mean time. Thank you for all your help!\n"
      },
      {
        "user": "ianstormtaylor",
        "created_at": "2016-07-28T20:43:11Z",
        "body": "Ah gotcha, sounds good thanks man!\n"
      }
    ]
  },
  {
    "number": 149,
    "title": "Question - Asynchronous Plugins",
    "created_at": "2016-07-21T17:28:00Z",
    "closed_at": "2016-07-21T18:01:33Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ianstormtaylor/slate/issues/149",
    "body": "Sorry if this has been asked before, I haven't been able to find anything on it, and would be more than fine submitting a PR with an example if I can figure it out.\n\nIs it possible to write a plugin that would perform some asynchronous behaviour and update the state when completed?  For instance, rather than just auto detecting a link, it would make a request to bit.ly to grab a short link and replace it with that.\n\nObviously, it would have to be non blocking so I'm not sure how you would do this.\n\nThanks!\n",
    "comments_url": "https://api.github.com/repos/ianstormtaylor/slate/issues/149/comments",
    "author": "gpfunk",
    "comments": [
      {
        "user": "oyeanuj",
        "created_at": "2016-07-21T17:35:50Z",
        "body": "This would also be useful in the case of rich embeds, and while doing things like mentions, etc.\n"
      },
      {
        "user": "ianstormtaylor",
        "created_at": "2016-07-21T18:01:27Z",
        "body": "Hey @gpfunk, great question!\n\nEach of the handlers you can define in your plugin receive both the `state` (the current `State` object), as well as the `editor` (a reference to the `<Editor>` component). For synchronous plugins, the easiest thing to do is to do return a newly transformed state.\n\nFor asynchronous plugins though, you obviously can't do that. But, you can call the `editor.getState()` method to retrieve the current state at any later point. And then you can call the `editor.onChange(state: State)` method with a newly transformed state at any later point to trigger an update.\n\nSo off the top of my head, you could do something like:\n\n``` js\nasync function onKeyDown(e, state, editor) {\n  const value = await someAsyncOperation()\n  const currentState = editor.getState()\n  const newState = currentState\n    .transform()\n    .insertText(value)\n    .apply()\n\n  editor.onChange(newState)\n}\n```\n\nI haven't added any async plugins myself yet—although I have plans too—so let me know if you run into any issues!\n"
      },
      {
        "user": "hobbes7878",
        "created_at": "2018-07-20T14:24:45Z",
        "body": "@ianstormtaylor One issue I've run into while creating an async plugin is maintaining the default fall-through behavior.\r\n\r\nFor example, I have a plugin that watches for a user to paste a link to a tweet and then asynchronously round trips to get the oembed code from Twitter's API to render it.\r\n\r\nThe problem I'm having right now is that I can't fall through for pastes that aren't tweets. For example:\r\n\r\n```javascript\r\nfunction myTweetPlugin() {\r\n  return {\r\n    async onPaste(event, change, editor){\r\n      const transfer = getEventTransfer(event);\r\n      const { text } = transfer;\r\n     \r\n      if (!testIsTweet(text)) return; // This doesn't fall through and blocks subsequent paste behavior...\r\n\r\n      // Behavior for tweets\r\n      const data = await fetchTweetOembed(text);\r\n      const newState = change.insertBlock({\r\n        type: 'tweet',\r\n        data,\r\n      });\r\n      editor.onChange(newState);\r\n    }\r\n  }\r\n}\r\n```\r\n\r\nI'd definitely appreciate any ideas to help keep the async behavior composable with other plugins."
      },
      {
        "user": "hobbes7878",
        "created_at": "2018-07-20T14:45:36Z",
        "body": "... and I've answered my own question ... Thanks, everyone, I'll be here all week!\r\n\r\n```javascript\r\nfunction myTweetPlugin() {\r\n  return {\r\n    async handleTweet(url, change, editor){\r\n      const data = await fetchTweetOembed(text);\r\n      const newState = change.insertBlock({\r\n        type: 'tweet',\r\n        data,\r\n      });\r\n      editor.onChange(newState);\r\n    },\r\n\r\n    onPaste(event, change, editor){\r\n      const transfer = getEventTransfer(event);\r\n      const { text } = transfer;\r\n     \r\n      if (!testIsTweet(text)) return; // Falls through correctly!\r\n      // Behavior for tweets in its own async func\r\n      this.handleTweet(text, change, editor);\r\n    }\r\n  }\r\n}\r\n```\r\n\r\nUpshot: don't make your core plugin methods async if you want them to be composable with other plugins using the same methods."
      },
      {
        "user": "nrochatvc",
        "created_at": "2023-06-28T13:22:47Z",
        "body": "Hello! Sorry to comment on this one but `editor.getState()` is not available anymore in `Editor`\r\nHow can we achieve the async behavior on plugins using the new structure:\r\n\r\n```typescript\r\nexport const withHtml = (editor: Editor) => {\r\n\r\n  editor.insertData = async data => {\r\n    const html = data.getData('text/html')\r\n    if (html) {\r\n      const parsed = new DOMParser().parseFromString(html, 'text/html')\r\n      const fragment = deserialize(parsed.body)\r\n      const imagesFragment = await processImages(fragment)\r\n      Transforms.insertFragment(editor, imagesFragment)\r\n      return\r\n    }\r\n    insertData(data)\r\n  }\r\n\r\n  return editor\r\n}\r\n``` \r\n\r\nIs there any example we can follow?\r\nThanks!"
      }
    ]
  },
  {
    "number": 136,
    "title": "Restoring previous selection",
    "created_at": "2016-07-20T20:48:54Z",
    "closed_at": "2016-07-20T22:16:18Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/ianstormtaylor/slate/issues/136",
    "body": "Frikken loving this project!!\n\nI have an auto save pipeline which will then result in a redux auto prop pass in, which then causes a rerender.  This works okay from a content standpoint as it is simply reloading the content I just saved, however I am having problems with restoring the selection state.\n\nAt the moment I track all changes via the `onChange` event.  Then when I receive the \"persisted\" state back from redux I want to try and restore the selection using the existing state that is currently on the component, but I can't seem to get this to work.  \n\nHere is my current attempt:\n\n``` javascript\n// The state from props/redux.\nconst editorState = Raw.deserialize(this.props.editorState);\n\n// Any existing tracked state.\nconst { editorState: existingEditorState } = this.state;\n\nlet selectionProps;\n\nif (!!existingEditorState) {\n  selectionProps = {\n    anchorKey: existingEditorState.anchorKey,\n    anchorOffset: existingEditorState.anchorOffset,\n    focusKey: existingEditorState.focusKey,\n    focusOffset: existingEditorState.focusOffset,\n    isFocused: existingEditorState.isFocused,\n    isBackward: existingEditorState.isBackward\n  };\n}\n\nthis.setState({\n  editorState: !!props\n    // Try re-set the existing selection.\n    ? editorState.transform().moveTo(selectionProps).apply()\n    // First time render, use as is. \n    : editorState\n});\n```\n\nAny ideas?  Have I completely misunderstood the API docs? :)\n",
    "comments_url": "https://api.github.com/repos/ianstormtaylor/slate/issues/136/comments",
    "author": "ctrlplusb",
    "comments": [
      {
        "user": "ctrlplusb",
        "created_at": "2016-07-20T21:06:21Z",
        "body": "Ok, hmmm, I think I have a bit more insight into the issue. I see there are `anchorKey` and `focusKey` props.  But I believe these keys will be different on my nodes after I deserialize the updated state and pass it to `Editor`. \n"
      },
      {
        "user": "ianstormtaylor",
        "created_at": "2016-07-20T21:53:38Z",
        "body": "Yup, that's right. The keys are randomly generated whenever you serialize/deserialize an `State` right now, so the selection won't find the same nodes anymore. It seems like the better way to go would be to have the editor not need to re-load the identical state, since this would result in a lot of extra re-rendering since the immutable objects would also all be re-created.\n"
      },
      {
        "user": "ctrlplusb",
        "created_at": "2016-07-20T22:03:24Z",
        "body": "Brilliant, that is exactly what I went for in the end.  :)\n"
      },
      {
        "user": "ctrlplusb",
        "created_at": "2016-07-20T22:07:01Z",
        "body": "One thing that just came to mind... \n\nWould this affect an SSR implementation? i.e. the unique keys create a different hash of the react content which results in the reconciler doing a full rerender?\n"
      },
      {
        "user": "ianstormtaylor",
        "created_at": "2016-07-20T22:16:08Z",
        "body": "Possibly! I think it might end up reconciling because of the changes keys (although it would for changed immutable instances regardless), but it won't end up re-rendering. But just that once is probably fine. The real performance issue would be reconciling/rerendering on each content change I think. But I might be missing something there, haven't looked into it deeply yet!\n"
      },
      {
        "user": "ianstormtaylor",
        "created_at": "2016-07-20T22:16:18Z",
        "body": "Going to close for now, glad that helped!\n"
      }
    ]
  },
  {
    "number": 89,
    "title": "Table Edit with GUI",
    "created_at": "2016-07-15T07:34:12Z",
    "closed_at": "2016-07-17T21:39:42Z",
    "labels": [
      "question",
      "for plugins"
    ],
    "url": "https://github.com/ianstormtaylor/slate/issues/89",
    "body": "Is there plan to implement features for create and edit table with GUI?\n",
    "comments_url": "https://api.github.com/repos/ianstormtaylor/slate/issues/89/comments",
    "author": "worifon",
    "comments": [
      {
        "user": "ianstormtaylor",
        "created_at": "2016-07-15T15:50:26Z",
        "body": "Hey, good question!\n\nAs far as the \"core\" logic of Slate goes, it doesn't prescribe any notion of what your \"schema\" should be, so it won't have any knowledge of tables, nope. \n\nThat being said, tables are a good example of what would go in a plugin. There's an example in the `./examples` directory that shows the beginnings of how tables might be implemented, but it's very basic, and leaves out lots of logic. \n\nFor one of the editors I'm working on, I plan to need to implement tables a bit down the road, so I might create an open-sourced plugin for them then. They'd be more like how Dropbox Paper's tables work than Google Sheets. But it's still a ways away as a need for me. \n\nHope that explains it! Feel free to follow up with more questions. \n"
      }
    ]
  }
]