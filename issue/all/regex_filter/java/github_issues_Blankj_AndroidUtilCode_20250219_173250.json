[
  {
    "number": 24,
    "title": "sp工具类相关",
    "created_at": "2016-08-11T01:10:57Z",
    "closed_at": "2016-08-13T09:39:27Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/Blankj/AndroidUtilCode/issues/24",
    "body": "private static SharedPreferences sp;\n\nprivate static SharedPreferences getInstance(Context context) {\n        if(sp == null) {\n            sp = context.getSharedPreferences(\"config\", Context.MODE_PRIVATE);\n        }\n        return sp;\n}\n\n获取sp推荐这样写的写法，效率高一点。\n",
    "comments_url": "https://api.github.com/repos/Blankj/AndroidUtilCode/issues/24/comments",
    "author": "ssyijiu",
    "comments": [
      {
        "user": "Blankj",
        "created_at": "2016-08-11T01:14:23Z",
        "body": "你这是单例了，这样sp的name不能修改了\n"
      },
      {
        "user": "ssyijiu",
        "created_at": "2016-08-11T01:45:34Z",
        "body": "怎么说呢，代码量大到一定程度后，自己写的也不敢确定sp的name在哪里改了，所以现在这样 我要是用的话在get和put之前肯定会先初始化一下sp的name，但这样又很麻烦，不这样心里不放心。 \n"
      },
      {
        "user": "ssyijiu",
        "created_at": "2016-08-11T01:51:04Z",
        "body": "建议这样，大多数用一个单例的sp，有特殊保存比如token还是自己重新封装好:\n\n```\n   // 如果需要一个单独的SharedPreferences来保存某些数据，例如：token，可以这样：\nprivate static final String PRE_TOKEN = \"token\";\nprivate static SharedPreferences getInstance(Context context, String preferenceName) {\n    if(sp == null) {\n        sp = context.getSharedPreferences(preferenceName, Context.MODE_PRIVATE);\n    }\n    return sp;\n}\n\npublic static void putToken(Context context, String token) {\n    sp = getInstance(context,PRE_TOKEN);\n    sp.edit().putString(PRE_TOKEN, token).apply();\n}\n\npublic static String getToken(Context context) {\n    sp = getInstance(context,PRE_TOKEN);\n    return sp.getString(PRE_TOKEN,\"\");\n}\n```\n"
      },
      {
        "user": "Blankj",
        "created_at": "2016-08-11T01:58:23Z",
        "body": "保存特殊的只需要改name就好了挺方便的，单例的话就修改不了，还要重新开一个单例，其实单例只是为了复用上次存在的值，而这个单例的区别就是getSharedPreferences这一个步骤，你是直接读取上次的sp，而我是调用getSharedPreferences获得，性能基本没区别啦，考虑到使用方便就不单例了\n"
      }
    ]
  },
  {
    "number": 16,
    "title": "期待总结相关代码的Kotlin+anko版本",
    "created_at": "2016-08-05T12:12:07Z",
    "closed_at": "2016-08-05T16:20:08Z",
    "labels": [
      "question"
    ],
    "url": "https://github.com/Blankj/AndroidUtilCode/issues/16",
    "body": "毕竟现在Kotlin也是Android开发的生力军了不是吗\n\n先咨询一下，你们觉得什么样的排版合适（两门语言的当然要分开啦），然后我发个pull request给你们。 :+1:\n",
    "comments_url": "https://api.github.com/repos/Blankj/AndroidUtilCode/issues/16/comments",
    "author": "ice1000",
    "comments": [
      {
        "user": "Blankj",
        "created_at": "2016-08-05T15:33:44Z",
        "body": "这个我是还没用Kotlin开发过，只知道些语法方面的，毕竟谷歌还没收录Kotlin，至于之后会不会，那就之后再说了，对这方面的兴趣可以有，但运用到时机开发的话还是风险有风险的，我还是一枚菜鸟，Java都没啃完呢，23333\n"
      }
    ]
  },
  {
    "number": 1793,
    "title": "LogUtils能否添加一个回调?",
    "created_at": "2023-12-11T16:36:07Z",
    "closed_at": "2023-12-15T15:13:12Z",
    "labels": [
      "help wanted"
    ],
    "url": "https://github.com/Blankj/AndroidUtilCode/issues/1793",
    "body": "## 描述需求\r\n如下面代码所示,我需要记录崩溃信息,之后再手动结束进程,但是有时没有记录完就被杀了,看到log写入文件是由一个Runnable来完成的,是否可以添加一个Callback来解决该问题呢?\r\n```kotlin\r\nprivate fun handleException(ex: Throwable?): Boolean {\r\n        ex?.printStackTrace()\r\n        if (ex == null) {\r\n            return false\r\n        }\r\n        LogUtils.e(ex)\r\n        Process.killProcess(Process.myPid())\r\n        exitProcess(1)\r\n    }\r\n```\r\n\r\n",
    "comments_url": "https://api.github.com/repos/Blankj/AndroidUtilCode/issues/1793/comments",
    "author": "phcbest",
    "comments": [
      {
        "user": "AdminQQZ",
        "created_at": "2023-12-15T03:40:49Z",
        "body": "提 pr 上来"
      },
      {
        "user": "phcbest",
        "created_at": "2023-12-15T14:02:55Z",
        "body": "> 提 pr 上来\r\n\r\npr会合吗,我看很多PR很久都没响应了,我明天提一个吧虽然不知是否会合"
      },
      {
        "user": "phcbest",
        "created_at": "2023-12-15T15:13:09Z",
        "body": "> 提 pr 上来\r\n\r\n看了一下代码,改回调确实对代码侵入性比较大,而且不太符合LogUtils这种打完日志就不管的场景,我权衡考虑之下还是用FilteIOUtils直接写了个新的崩溃日志文件\r\n\r\n"
      }
    ]
  },
  {
    "number": 1681,
    "title": "反射获取复杂结构属性值",
    "created_at": "2022-08-04T12:00:20Z",
    "closed_at": "2022-08-05T09:50:38Z",
    "labels": [
      "help wanted"
    ],
    "url": "https://github.com/Blankj/AndroidUtilCode/issues/1681",
    "body": "## 描述需求\r\n\r\n拥有一个类实例对象，该类包含一个接口的实现类，但是不知道是哪个实现类。以这样的方式嵌套n次，最后拿到最后一个节点的成员变量string值。实际场景类似代码监控当前Activity请求的url链接。\r\n\r\n## 可借鉴的\r\n\r\n依据是否包含孙子对象来确定子对象的具体实现类吗？\r\n\r\n\r\n\r\n",
    "comments_url": "https://api.github.com/repos/Blankj/AndroidUtilCode/issues/1681/comments",
    "author": "CGreen11",
    "comments": [
      {
        "user": "CGreen11",
        "created_at": "2022-08-04T12:07:29Z",
        "body": "DActivity  {\r\n    AInterface a;\r\n}\r\ndebug 模式能看到DActivity  \r\n                                         --》a\r\n                                                 --》b\r\n                                                        --》c  \r\n                                                                 ...... \r\n                                                                       --》string=\"www.www.www\""
      },
      {
        "user": "shouzhong",
        "created_at": "2022-08-05T07:51:08Z",
        "body": "首先网络请求是否属于自己的业务代码，如果是的话，我觉得不如自己弄个拦截器之类的东西，这样更好维护，感觉更重要的是代码要规范化，类似这种需求实现起来就更简单"
      },
      {
        "user": "CGreen11",
        "created_at": "2022-08-05T09:50:37Z",
        "body": "万物可用穷举法"
      }
    ]
  },
  {
    "number": 1555,
    "title": "ZipUtils#unzipFile解压增加Charset参数",
    "created_at": "2021-10-13T06:33:10Z",
    "closed_at": "2021-10-14T10:27:44Z",
    "labels": [
      "help wanted"
    ],
    "url": "https://github.com/Blankj/AndroidUtilCode/issues/1555",
    "body": "## ZipUtils#unzipFile解压增加Charset参数\r\n\r\n因为编码问题，压缩包解压报错\r\n\r\n\r\n## 可借鉴的\r\n\r\nZipFile zipFile = new ZipFile(path, Charset.forName(\"gbk\")); \r\n",
    "comments_url": "https://api.github.com/repos/Blankj/AndroidUtilCode/issues/1555/comments",
    "author": "KevinLoveGitHub",
    "comments": [
      {
        "user": "MYaoDan",
        "created_at": "2024-12-07T08:35:49Z",
        "body": "ZipUtils.unzipFile不支持ZipFile 参数呀"
      }
    ]
  },
  {
    "number": 1501,
    "title": "Kotlin codebase",
    "created_at": "2021-05-17T03:21:09Z",
    "closed_at": "2021-05-28T15:27:14Z",
    "labels": [
      "help wanted"
    ],
    "url": "https://github.com/Blankj/AndroidUtilCode/issues/1501",
    "body": "Hello!\r\nAny plans to move the codebase to Kotlin? Besides making significant performance improvements, it will also reduce the library size, and as you know will have much less boilerplate code. Even though down under they're both getting executed in JVM.\r\nKnowing how busy you are, but still I'm asking if you have any plans to move the codebase to Kotlin or at least assign a team of people to do it? \r\n\r\nThank you and keep up the good work!",
    "comments_url": "https://api.github.com/repos/Blankj/AndroidUtilCode/issues/1501/comments",
    "author": "XiXiongMaoXiong",
    "comments": [
      {
        "user": "Blankj",
        "created_at": "2021-05-28T10:37:41Z",
        "body": "没有这个必要哈"
      },
      {
        "user": "XiXiongMaoXiong",
        "created_at": "2021-05-28T15:27:11Z",
        "body": "> 没有这个必要哈\r\n\r\nOK"
      }
    ]
  },
  {
    "number": 1441,
    "title": "什么时候新增悬浮窗啊？",
    "created_at": "2021-01-28T01:10:39Z",
    "closed_at": "2021-02-21T19:43:03Z",
    "labels": [
      "help wanted"
    ],
    "url": "https://github.com/Blankj/AndroidUtilCode/issues/1441",
    "body": "## 描述需求\r\n\r\n新增应用内悬浮窗，免权限。\r\n新增全局悬浮窗，需要权限。\r\n",
    "comments_url": "https://api.github.com/repos/Blankj/AndroidUtilCode/issues/1441/comments",
    "author": "yutils",
    "comments": [
      {
        "user": "Blankj",
        "created_at": "2021-02-21T19:42:55Z",
        "body": "这目前来看没必要吧"
      }
    ]
  },
  {
    "number": 1409,
    "title": "RomUtils 判断锤子手机增加 \"deltainno\"",
    "created_at": "2020-12-28T06:58:25Z",
    "closed_at": "2021-02-21T19:19:56Z",
    "labels": [
      "help wanted"
    ],
    "url": "https://github.com/Blankj/AndroidUtilCode/issues/1409",
    "body": "String[] ROM_SMARTISAN = {\"smartisan\", \"deltainno\"};",
    "comments_url": "https://api.github.com/repos/Blankj/AndroidUtilCode/issues/1409/comments",
    "author": "goodluckier",
    "comments": [
      {
        "user": "Blankj",
        "created_at": "2021-02-21T19:19:44Z",
        "body": "1.30.6 版本已修复"
      }
    ]
  },
  {
    "number": 1399,
    "title": "强烈希望在ToastUtils中，加入一个方法，能手动将全局的showShort()和showLong()变为以前的黑色背景，因为黑色比白色好看!!!",
    "created_at": "2020-12-16T09:36:13Z",
    "closed_at": "2021-01-22T02:48:18Z",
    "labels": [
      "help wanted"
    ],
    "url": "https://github.com/Blankj/AndroidUtilCode/issues/1399",
    "body": "如题，黑色比白色好看!!!\r\n但是代码太漂亮了，不想自己重写玷污了它(QAQ，其实是懒)，所以希望作者增加方法",
    "comments_url": "https://api.github.com/repos/Blankj/AndroidUtilCode/issues/1399/comments",
    "author": "NightMoonCat",
    "comments": [
      {
        "user": "zhoujia456888",
        "created_at": "2020-12-17T03:42:54Z",
        "body": "可以自己定义一个ToastUtils1,调用utilcode.ToastUtils的make.setBgColor、make.setBgResource 、make.setTextColor等方法"
      },
      {
        "user": "FunTc",
        "created_at": "2020-12-23T03:22:33Z",
        "body": "ToastUtils中带有方法可以设置，ToastUtils.getDefaultMaker().setMode(ToastUtils.MODE.DARK)就可以是黑色的背景了，如果颜色达不到你的预期，可以调用ToastUtils.getDefaultMaker().setBgColor()和ToastUtils.getDefaultMaker().setTextColor()来自定义，不过最新版的ToastUtils还存在Bug，请注意"
      },
      {
        "user": "kangdawei",
        "created_at": "2021-01-22T02:44:28Z",
        "body": "> ToastUtils中带有方法可以设置，ToastUtils.getDefaultMaker().setMode(ToastUtils.MODE.DARK)就可以是黑色的背景了，如果颜色达不到你的预期，可以调用ToastUtils.getDefaultMaker().setBgColor()和ToastUtils.getDefaultMaker().setTextColor()来自定义，不过最新版的ToastUtils还存在Bug，请注意\r\n\r\nimplementation 'com.blankj:utilcodex:1.30.5'  里面有"
      },
      {
        "user": "NightMoonCat",
        "created_at": "2021-01-22T02:48:15Z",
        "body": "非常感谢大家的回复，确实已经各位提供的方式处理了"
      }
    ]
  },
  {
    "number": 1397,
    "title": "希望可以增加一个在根布局动态添加视图的工具类，如下:",
    "created_at": "2020-12-16T01:08:46Z",
    "closed_at": "2021-02-21T19:42:34Z",
    "labels": [
      "help wanted"
    ],
    "url": "https://github.com/Blankj/AndroidUtilCode/issues/1397",
    "body": "## 可借鉴的\r\n\r\n/**\r\n * 根布局添加视图工具类\r\n */\r\npublic class RootLayoutUtil {\r\n    /**\r\n     * 添加一个视图到屏幕最顶层\r\n     */\r\n    public static void addViewOnWindow(View view, int w, int h, int x, int y) {\r\n        Activity activity = (Activity) view.getContext();\r\n        ViewGroup root = activity.findViewById(android.R.id.content);\r\n        FrameLayout.LayoutParams layoutParams = new FrameLayout.LayoutParams(w, h);\r\n        layoutParams.leftMargin = x;\r\n        layoutParams.topMargin = y;\r\n        root.addView(view, -1, layoutParams);\r\n    }\r\n\r\n    /**\r\n     * 添加隐藏按钮到当前活动窗口最顶层。隐藏按钮：人眼看不到且得连续点击四次才会触发事件\r\n     */\r\n    public static void addHideButtonOnWindow(Context context, int w, int h, int x, int y, Runnable runnable) {\r\n        Activity activity = (Activity) context;\r\n        ViewGroup root = activity.findViewById(android.R.id.content);\r\n        FrameLayout.LayoutParams layoutParams = new FrameLayout.LayoutParams(w, h);\r\n        layoutParams.leftMargin = x;\r\n        layoutParams.topMargin = y;\r\n        View view = new View(activity);\r\n        view.setOnClickListener(new OnMultiClickListener(4) {\r\n            @Override\r\n            public void onTriggerClick(View v) {\r\n                runnable.run();\r\n            }\r\n        });\r\n        root.addView(view, -1, layoutParams);\r\n    }\r\n}\r\n\r\n/**\r\n * 连续点击监听器\r\n */\r\npublic abstract class OnMultiClickListener implements View.OnClickListener {\r\n\r\n    private static final long DEFAULT_INTERVAL = 666;\r\n\r\n    private final int mTriggerClickCount;\r\n    private final long mClickInterval;\r\n\r\n    private long mLastClickTime;\r\n    private int mClickCount;\r\n\r\n    public OnMultiClickListener(int triggerClickCount) {\r\n        this(triggerClickCount, DEFAULT_INTERVAL);\r\n    }\r\n\r\n    public OnMultiClickListener(int triggerClickCount, long clickInterval) {\r\n        this.mTriggerClickCount = triggerClickCount;\r\n        this.mClickInterval = clickInterval;\r\n    }\r\n\r\n    public abstract void onTriggerClick(View v);\r\n\r\n    public void onBeforeTriggerClick(View v, int count) {\r\n    }\r\n\r\n    @Override\r\n    final public void onClick(View v) {\r\n        if (mTriggerClickCount <= 1) {\r\n            onTriggerClick(v);\r\n            return;\r\n        }\r\n        long curTime = System.currentTimeMillis();\r\n\r\n        if (curTime - mLastClickTime < mClickInterval) {\r\n            mClickCount++;\r\n            if (mClickCount == mTriggerClickCount) {\r\n                onTriggerClick(v);\r\n            } else if (mClickCount < mTriggerClickCount) {\r\n                onBeforeTriggerClick(v, mClickCount);\r\n            } else {\r\n                mClickCount = 1;\r\n                onBeforeTriggerClick(v, mClickCount);\r\n            }\r\n        } else {\r\n            mClickCount = 1;\r\n            onBeforeTriggerClick(v, mClickCount);\r\n        }\r\n        mLastClickTime = curTime;\r\n    }\r\n}\r\n",
    "comments_url": "https://api.github.com/repos/Blankj/AndroidUtilCode/issues/1397/comments",
    "author": "mao19951015",
    "comments": [
      {
        "user": "Blankj",
        "created_at": "2021-02-21T19:27:40Z",
        "body": "增加视图这个自己写一个吧，连续点击这个 ClickUtils 里就有"
      }
    ]
  },
  {
    "number": 1394,
    "title": "关于ToastUtils的一点建议",
    "created_at": "2020-12-13T10:42:47Z",
    "closed_at": "2021-02-21T19:28:53Z",
    "labels": [
      "help wanted"
    ],
    "url": "https://github.com/Blankj/AndroidUtilCode/issues/1394",
    "body": "试了公司几部测试机 ，包括原生系统，android10之后即使通知被关闭，toast依然可以正常弹出，所以我想android10之后这个bug应该已经被修补好了\r\n另外关于toast被弹窗挡住的问题，建议topActivity使用windowManager，其他activity使用decorView的方式，这样至少能保证栈顶的toast正常显示，如果刚好出现第二个activity有弹窗挡住toast的情况，只能建议用户finish之后再showToast，或者改变toast的显示位置",
    "comments_url": "https://api.github.com/repos/Blankj/AndroidUtilCode/issues/1394/comments",
    "author": "jingzz1",
    "comments": [
      {
        "user": "Blankj",
        "created_at": "2020-12-14T02:56:06Z",
        "body": "这个建议不错"
      },
      {
        "user": "Blankj",
        "created_at": "2021-02-21T19:28:46Z",
        "body": "1.30.6 版本已支持"
      }
    ]
  },
  {
    "number": 1376,
    "title": "AndroidX适配？",
    "created_at": "2020-11-23T05:58:25Z",
    "closed_at": "2020-11-23T08:42:55Z",
    "labels": [
      "help wanted"
    ],
    "url": "https://github.com/Blankj/AndroidUtilCode/issues/1376",
    "body": "## 能否适配下AndroidX?",
    "comments_url": "https://api.github.com/repos/Blankj/AndroidUtilCode/issues/1376/comments",
    "author": "AndroidLi123",
    "comments": [
      {
        "user": "Blankj",
        "created_at": "2020-11-23T08:42:49Z",
        "body": "不是有 androidx 版本么"
      }
    ]
  },
  {
    "number": 1374,
    "title": "Checking Battery Optimisation status",
    "created_at": "2020-11-16T10:44:18Z",
    "closed_at": "2021-02-21T19:38:39Z",
    "labels": [
      "help wanted"
    ],
    "url": "https://github.com/Blankj/AndroidUtilCode/issues/1374",
    "body": "Would be awesome if you add the functionality of checking whether the app is being optimised by the system PowerManager or not.\r\nThis can be added to PermissionUtils:\r\n\r\n```\r\nfun isBatteryOptimisationEnabledForMyApp() : Boolean{\r\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {\r\n            return !(context.getSystemService(POWER_SERVICE) as PowerManager).isIgnoringBatteryOptimizations(AppUtils.getAppPackageName())\r\n        }\r\n        return false\r\n    }\r\n```",
    "comments_url": "https://api.github.com/repos/Blankj/AndroidUtilCode/issues/1374/comments",
    "author": "XiXiongMaoXiong",
    "comments": [
      {
        "user": "Blankj",
        "created_at": "2021-02-21T19:38:27Z",
        "body": "1.30.6 版本已支持"
      }
    ]
  },
  {
    "number": 1368,
    "title": "建议NetWorkUtils增加监听wifi列表变化的API",
    "created_at": "2020-11-11T01:13:31Z",
    "closed_at": "2020-11-13T07:39:56Z",
    "labels": [
      "help wanted"
    ],
    "url": "https://github.com/Blankj/AndroidUtilCode/issues/1368",
    "body": "```java\r\n    public static List<ScanResult> getWifiScanResult() {\r\n        if (!getWifiEnabled()){\r\n            return new LinkedList<>();\r\n        }\r\n        @SuppressLint(\"WifiManagerLeak\")\r\n        WifiManager manager = (WifiManager) Utils.getApp().getSystemService(WIFI_SERVICE);\r\n        return manager.getScanResults();\r\n    }\r\n\r\n    private static Set<Utils.Consumer<List<ScanResult>>> scanResultConsumers = new HashSet<>();\r\n    public static void registScanResultConsumer(Utils.Consumer<List<ScanResult>> consumer){\r\n        scanResultConsumers.add(consumer);\r\n        startScanWifi();\r\n    }\r\n\r\n    public static void unRegistScanResultConsumer(Utils.Consumer<List<ScanResult>> consumer){\r\n        scanResultConsumers.remove(consumer);\r\n    }\r\n\r\n    private static void scanWifi(){\r\n        if (!getWifiEnabled()){\r\n            return;\r\n        }\r\n        @SuppressLint(\"WifiManagerLeak\")\r\n        WifiManager manager = (WifiManager) Utils.getApp().getSystemService(WIFI_SERVICE);\r\n        manager.startScan();\r\n    }\r\n\r\n    private static Timer timer;\r\n    private static List<ScanResult> lastScanResult;\r\n    private static void startScanWifi(){\r\n        if (timer == null){\r\n            timer = new Timer();\r\n            timer.schedule(new TimerTask() {\r\n                @Override\r\n                public void run() {\r\n\r\n                    LogUtils.d();\r\n\r\n                    if (scanResultConsumers.isEmpty()){\r\n                        stopScanWifi();\r\n                    } else {\r\n\r\n                        if (getWifiEnabled()){\r\n                            scanWifi();\r\n                        }\r\n\r\n                        final List<ScanResult> scanResults = getWifiScanResult();\r\n                        LogUtils.d(scanResults);\r\n                        if (!isSameScanResult(lastScanResult,scanResults)){\r\n                            for (final Utils.Consumer<List<ScanResult>> consumer : scanResultConsumers){\r\n                                UtilsBridge.runOnUiThread(new Runnable() {\r\n                                    @Override\r\n                                    public void run() {\r\n                                        consumer.accept(scanResults);\r\n                                        lastScanResult = scanResults;\r\n                                    }\r\n                                });\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            },0,5*1000);\r\n        }\r\n    }\r\n\r\n    private static void stopScanWifi(){\r\n        timer.cancel();\r\n        timer = null;\r\n    }\r\n\r\n    private static boolean isSameScanResult(List<ScanResult> l1,List<ScanResult> l2){\r\n\r\n        if (isEmpty(l1) && isEmpty(l2)){\r\n            return true;\r\n        }\r\n        if (isEmpty(l1) || isEmpty(l2)){\r\n            return false;\r\n        }\r\n        if (l1.size() != l2.size()){\r\n            return false;\r\n        }\r\n        for (int i=0;i<l1.size();i++){\r\n            if (!areScanResultItemSame(l1.get(i),l2.get(i)) || (areScanResultItemSame(l1.get(i),l2.get(i)) && !areScanResultContentSame(l1.get(i),l2.get(i)))){\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    public static boolean isEmpty(Collection coll) {\r\n        return coll == null || coll.size() == 0;\r\n    }\r\n\r\n    private static boolean areScanResultItemSame(ScanResult r1,ScanResult r2){\r\n        return r1 != null && r2 != null && Objects.equals(r1.BSSID,r2.BSSID);\r\n    }\r\n\r\n    private static boolean areScanResultContentSame(ScanResult r1,ScanResult r2){\r\n        return r1 != null && r2 != null && Objects.equals(r1.SSID,r2.SSID) && Objects.equals(r1.capabilities,r2.capabilities) && Objects.equals(r1.level,r2.level);\r\n    }\r\n\r\n```",
    "comments_url": "https://api.github.com/repos/Blankj/AndroidUtilCode/issues/1368/comments",
    "author": "XXQAQ",
    "comments": [
      {
        "user": "XXQAQ",
        "created_at": "2020-11-11T01:15:17Z",
        "body": "典型调用：\r\n```java\r\n   Utils.Consumer<List<ScanResult>> wifiConsumer = new Utils.Consumer<List<ScanResult>>() {\r\n        @Override\r\n        public void accept(List<ScanResult> scanResults) {\r\n            if (getWifiListDialog().isShowing()){\r\n                setScanResultList(scanResults);\r\n            }\r\n        }\r\n    };\r\n\r\n        NetworkUtils.registScanResultConsumer(wifiConsumer);\r\n\r\n//        NetworkUtils.unRegistScanResultConsumer(wifiConsumer);\r\n```"
      },
      {
        "user": "Blankj",
        "created_at": "2020-11-13T07:39:47Z",
        "body": "已增加，可以参考我实现的哈，比你的更细致点哦"
      }
    ]
  },
  {
    "number": 1362,
    "title": "CleanUtils",
    "created_at": "2020-11-02T09:50:43Z",
    "closed_at": "2020-11-13T07:40:58Z",
    "labels": [
      "help wanted"
    ],
    "url": "https://github.com/Blankj/AndroidUtilCode/issues/1362",
    "body": "清理app数据建议加上\r\n\r\nActivityManager am = (ActivityManager) Utils.getApp().getSystemService(Context.ACTIVITY_SERVICE);\r\nam.clearApplicationUserData();",
    "comments_url": "https://api.github.com/repos/Blankj/AndroidUtilCode/issues/1362/comments",
    "author": "Jasperben",
    "comments": [
      {
        "user": "Blankj",
        "created_at": "2020-11-06T07:16:58Z",
        "body": "下版本加上"
      },
      {
        "user": "Blankj",
        "created_at": "2020-11-13T07:40:45Z",
        "body": "新版本已新增"
      }
    ]
  },
  {
    "number": 1360,
    "title": "TimeUtils功能增加建议",
    "created_at": "2020-10-29T10:17:32Z",
    "closed_at": "2020-10-29T12:05:56Z",
    "labels": [
      "help wanted"
    ],
    "url": "https://github.com/Blankj/AndroidUtilCode/issues/1360",
    "body": "## 描述需求\r\n\r\nTimeUtils 中 只能格式化 完整的时间戳，\r\n\r\n在我的开发中经常会使用到一些倒计时或者 时间是固定的 50分钟.\r\n\r\n而我会直接给一个50分钟的毫秒值，将50分钟的毫秒值（3000000毫秒）格式化成 50:00 然而当前的工具库并不能实现这个功能。\r\n\r\n我都是自己再写方法去计算这个毫秒当前是多少时长。\r\n\r\n比如有时候获取的是一个视频的时长，将这个时长进行格式化成 (HH:mm:ss)\r\n\r\n我希望有这样的功能：\r\n\r\nfun(3000000,\"HH:mm:ss\")-> \"00:50:00\"\r\n\r\nfun(\"00:50:00\",\"HH:mm:ss\",TimeUnit.HOURS) -> 0.5 \r\n\r\nfun(\"00:50:00\",\"HH:mm:ss\",TimeUnit.MINUTES) -> 50\r\n\r\nfun(\"00:50:00\",\"HH:mm:ss\",TimeUnit.SECONDS) -> 3000\r\n\r\n\r\n\r\n\r\n",
    "comments_url": "https://api.github.com/repos/Blankj/AndroidUtilCode/issues/1360/comments",
    "author": "Dboy233",
    "comments": [
      {
        "user": "Blankj",
        "created_at": "2020-10-29T11:57:52Z",
        "body": "这个自己封装实现下就好了，取整、取余而已，不通用哈"
      }
    ]
  },
  {
    "number": 1357,
    "title": "isDeveloperOptionsEnabled in DeviceUtils",
    "created_at": "2020-10-26T15:15:59Z",
    "closed_at": "2020-10-27T08:45:29Z",
    "labels": [
      "help wanted"
    ],
    "url": "https://github.com/Blankj/AndroidUtilCode/issues/1357",
    "body": "Please add this method to the DeviceUtils module as it is required and \r\n\r\nA simple check would be like this:\r\n\r\n`return Settings.Global.getInt(context.contentResolver, Settings.Global.DEVELOPMENT_SETTINGS_ENABLED,0) == 1`\r\n\r\n\r\nThank you for your awesome library, this really saved a lot of time for me! And every time I discover something new and useful in it... Glad that people like you exist! ❤",
    "comments_url": "https://api.github.com/repos/Blankj/AndroidUtilCode/issues/1357/comments",
    "author": "XiXiongMaoXiong",
    "comments": [
      {
        "user": "Blankj",
        "created_at": "2020-10-26T17:47:47Z",
        "body": "Next version will support it."
      },
      {
        "user": "Blankj",
        "created_at": "2020-10-27T08:44:59Z",
        "body": "The version of 1.30.2 has published."
      }
    ]
  },
  {
    "number": 1352,
    "title": "Android 10存储适配",
    "created_at": "2020-10-19T17:26:57Z",
    "closed_at": "2020-10-24T19:29:11Z",
    "labels": [
      "help wanted"
    ],
    "url": "https://github.com/Blankj/AndroidUtilCode/issues/1352",
    "body": "",
    "comments_url": "https://api.github.com/repos/Blankj/AndroidUtilCode/issues/1352/comments",
    "author": "GXSZone",
    "comments": [
      {
        "user": "GXSZone",
        "created_at": "2020-10-21T09:12:31Z",
        "body": "我自己的就一点，写好了，我还是希望能用上库的，依赖都依赖了，干脆都用上，哈哈"
      },
      {
        "user": "Blankj",
        "created_at": "2020-10-24T18:57:33Z",
        "body": "怎么适配？不是你们自己换到应用目录不就好了吗？"
      }
    ]
  },
  {
    "number": 1349,
    "title": "闹钟",
    "created_at": "2020-10-16T08:30:45Z",
    "closed_at": "2020-10-24T19:34:38Z",
    "labels": [
      "help wanted"
    ],
    "url": "https://github.com/Blankj/AndroidUtilCode/issues/1349",
    "body": "大佬 请问能增加个设置系统闹钟的功能么?以及系统日历的日程添加",
    "comments_url": "https://api.github.com/repos/Blankj/AndroidUtilCode/issues/1349/comments",
    "author": "lhc9102",
    "comments": [
      {
        "user": "Blankj",
        "created_at": "2020-10-24T19:34:32Z",
        "body": "使用不是很广泛，你要是有好的代码可以提交上来到 subutil 哈"
      }
    ]
  },
  {
    "number": 1346,
    "title": "关于电话权限的问题",
    "created_at": "2020-10-12T09:45:17Z",
    "closed_at": "2020-10-12T10:24:02Z",
    "labels": [
      "help wanted"
    ],
    "url": "https://github.com/Blankj/AndroidUtilCode/issues/1346",
    "body": "能不能把获取设备信息和拨打电话的权限分开来，不要一块获取",
    "comments_url": "https://api.github.com/repos/Blankj/AndroidUtilCode/issues/1346/comments",
    "author": "lchang70163",
    "comments": [
      {
        "user": "Blankj",
        "created_at": "2020-10-12T09:56:02Z",
        "body": "你可以单独传入那个权限而不用我的权限组就行"
      }
    ]
  },
  {
    "number": 1337,
    "title": "android10的手机使用FileUtils.listFilesInDir()扫描公有music目录不成功，没有适配吗？",
    "created_at": "2020-09-26T03:38:27Z",
    "closed_at": "2020-09-28T03:16:06Z",
    "labels": [
      "help wanted"
    ],
    "url": "https://github.com/Blankj/AndroidUtilCode/issues/1337",
    "body": "",
    "comments_url": "https://api.github.com/repos/Blankj/AndroidUtilCode/issues/1337/comments",
    "author": "KunPengZheng",
    "comments": [
      {
        "user": "Blankj",
        "created_at": "2020-09-28T03:15:59Z",
        "body": "Android 10 不允许直接访问 SD 卡目录，这个需要你自己适配，FileUtils.listFilesInDir() 是对 File 进行操作，两者是没有关系的。"
      }
    ]
  },
  {
    "number": 1323,
    "title": "LogUtils能否支持多方位输出",
    "created_at": "2020-09-10T01:08:13Z",
    "closed_at": "2020-10-24T19:07:03Z",
    "labels": [
      "help wanted"
    ],
    "url": "https://github.com/Blankj/AndroidUtilCode/issues/1323",
    "body": "## 描述需求\r\n\r\n现在支持Logcat实时输出，能否提供扩展支持更多的输出方式，像Okhttp的拦截器一样，按需自定义添加。目前想存进room以及实时上传到服务器。\r\n\r\n\r\n## 可借鉴的\r\n\r\n无",
    "comments_url": "https://api.github.com/repos/Blankj/AndroidUtilCode/issues/1323/comments",
    "author": "qiushui95",
    "comments": [
      {
        "user": "Blankj",
        "created_at": "2020-10-24T19:06:57Z",
        "body": "新版本 1.30.0 已发布，可以查看新增接口"
      }
    ]
  },
  {
    "number": 1322,
    "title": "希望CrashUtils可以增加自定义数据",
    "created_at": "2020-09-09T07:52:20Z",
    "closed_at": "2020-10-24T19:07:20Z",
    "labels": [
      "help wanted"
    ],
    "url": "https://github.com/Blankj/AndroidUtilCode/issues/1322",
    "body": "## Describe the feature\r\n\r\n希望CrashUtils在输出crash日志时可以自定义部分头部数据\r\n比如渠道号之类的\r\n\r\n\r\n## Reference\r\n\r\nCrashUtils#getUncaughtExceptionHandler()\r\n",
    "comments_url": "https://api.github.com/repos/Blankj/AndroidUtilCode/issues/1322/comments",
    "author": "xmt328",
    "comments": [
      {
        "user": "Blankj",
        "created_at": "2020-10-22T10:30:44Z",
        "body": "已经写好了，明天发版支持"
      },
      {
        "user": "xmt328",
        "created_at": "2020-10-23T02:30:04Z",
        "body": "十分感谢"
      },
      {
        "user": "Blankj",
        "created_at": "2020-10-24T19:07:12Z",
        "body": "新版本 1.30.0 已发布"
      }
    ]
  },
  {
    "number": 1318,
    "title": "I am sorry if this is not relevant.. ",
    "created_at": "2020-09-04T13:27:09Z",
    "closed_at": "2020-10-22T12:05:48Z",
    "labels": [
      "help wanted"
    ],
    "url": "https://github.com/Blankj/AndroidUtilCode/issues/1318",
    "body": "This is literally by far the best Android library I have ever came across, it made my development life a whole lot easier.\r\nI was wondering if you have any PayPal so I can donate a little, because I don't use Chinese funding apps nor do I want to. (No offense there)",
    "comments_url": "https://api.github.com/repos/Blankj/AndroidUtilCode/issues/1318/comments",
    "author": "XiXiongMaoXiong",
    "comments": [
      {
        "user": "Blankj",
        "created_at": "2020-10-22T12:05:39Z",
        "body": "Thank you for your support. My PayPal account is blankj@qq.com.  :-)"
      }
    ]
  },
  {
    "number": 1317,
    "title": "希望增加NetworkUtils.java中的获取当前连接的信号强度",
    "created_at": "2020-09-04T04:24:24Z",
    "closed_at": "2020-09-07T10:35:07Z",
    "labels": [
      "help wanted"
    ],
    "url": "https://github.com/Blankj/AndroidUtilCode/issues/1317",
    "body": "\r\n\r\n",
    "comments_url": "https://api.github.com/repos/Blankj/AndroidUtilCode/issues/1317/comments",
    "author": "Carey0732",
    "comments": [
      {
        "user": "Blankj",
        "created_at": "2020-09-07T10:34:58Z",
        "body": "自己实现下吧，或者可以给我提 pr 哈"
      }
    ]
  },
  {
    "number": 1313,
    "title": "希望能增加一个限流工具类",
    "created_at": "2020-09-01T01:50:03Z",
    "closed_at": "2020-10-24T19:09:34Z",
    "labels": [
      "help wanted"
    ],
    "url": "https://github.com/Blankj/AndroidUtilCode/issues/1313",
    "body": "## 描述需求\r\n\r\n简洁地描述下需求。\r\n       点击事件或者监听推送时，偶尔会出现短时间内重复执行多次任务的情景，\r\n可以用这个类来判断。一般大家都是在全局变量里记录一下上次运行的时间，这样不太干净。\r\n\r\n## 可借鉴的\r\n我简单封装的\r\n/**\r\n * 限流工具类，可用于防止短时间内重复执行同一任务\r\n * （暂未考虑多线程下情景）\r\n */\r\npublic class FastUtil {\r\n\r\n    private static Map<String, Long> lastTimeMap = new HashMap<>();\r\n\r\n    public static boolean isFast(String key, long interval) {\r\n        if (lastTimeMap.get(key) == null) {\r\n            lastTimeMap.put(key, 0L);\r\n        }\r\n        long time = System.currentTimeMillis();\r\n        long timeD = time - lastTimeMap.get(key);\r\n        if (0 < timeD && timeD < interval) {\r\n            return true;\r\n        }\r\n        lastTimeMap.put(key, time);\r\n        return false;\r\n    }\r\n\r\n    public static void isFast(String key, long interval, Runnable callback) {\r\n        if (lastTimeMap.get(key) == null) {\r\n            lastTimeMap.put(key, 0L);\r\n        }\r\n        long time = System.currentTimeMillis();\r\n        long timeD = time - lastTimeMap.get(key);\r\n        if (0 < timeD && timeD < interval) {\r\n            callback.run();\r\n        }\r\n        lastTimeMap.put(key, time);\r\n    }\r\n\r\n    public static boolean isNotFast(String key, long interval) {\r\n        return !isFast(key, interval);\r\n    }\r\n\r\n    public static void isNotFast(String key, long interval, Runnable callback) {\r\n        if (!isFast(key, interval)) {\r\n            callback.run();\r\n        }\r\n    }\r\n}\r\n",
    "comments_url": "https://api.github.com/repos/Blankj/AndroidUtilCode/issues/1313/comments",
    "author": "mao19951015",
    "comments": [
      {
        "user": "Blankj",
        "created_at": "2020-09-01T02:38:21Z",
        "body": "点击事件去重有 ClickUtils，推送为啥要重复推送一样的？"
      },
      {
        "user": "mao19951015",
        "created_at": "2020-09-01T02:43:17Z",
        "body": "本质都是收到消息执行一段代码，外接系统都是不可信任的。 就比如我们公司，用MQ推送消息，每5分钟让终端设备签到一次，一些新人不会配置，经常会导致在一秒内连续推十几次相同的消息。"
      },
      {
        "user": "Blankj",
        "created_at": "2020-10-24T19:09:26Z",
        "body": "新版本 1.30.0 已发布，DebouncingUtils#isValid"
      }
    ]
  },
  {
    "number": 1288,
    "title": "为啥加解密这一块MD5 SHA1这些只有加密没有解密呢~",
    "created_at": "2020-07-31T08:41:19Z",
    "closed_at": "2020-09-01T07:52:48Z",
    "labels": [
      "help wanted"
    ],
    "url": "https://github.com/Blankj/AndroidUtilCode/issues/1288",
    "body": "为啥加解密这一块MD5 SHA1这些只有加密没有解密呢~\r\n",
    "comments_url": "https://api.github.com/repos/Blankj/AndroidUtilCode/issues/1288/comments",
    "author": "love-311",
    "comments": [
      {
        "user": "Blankj",
        "created_at": "2020-07-31T08:47:35Z",
        "body": "先去了解下加密的基础知识再提问题比较合理吧？"
      },
      {
        "user": "love-311",
        "created_at": "2020-07-31T08:50:25Z",
        "body": "不好意思，看网上各种MD5在线解密，没有去了解仔细就提问题了~"
      }
    ]
  },
  {
    "number": 1287,
    "title": "建议大佬增加一个VolumeUtils",
    "created_at": "2020-07-29T06:08:15Z",
    "closed_at": "2020-10-24T19:14:18Z",
    "labels": [
      "help wanted"
    ],
    "url": "https://github.com/Blankj/AndroidUtilCode/issues/1287",
    "body": "## 描述需求\r\n\r\n统一增减一档所有音量，按百分比增减音量，按照类型控制音量，获取某个音量最大值等等\r\n\r\n\r\n## 可借鉴的\r\n\r\n如果有的话，可以给出一些参考文章、链接、代码、\r\n```java\r\npublic class AudioHelper {\r\n    private AudioHelper(Context context) {\r\n        initAudioManager(context);\r\n    }\r\n\r\n    public synchronized static AudioHelper getInstance(Context context) {\r\n        if (INSTANCE == null)\r\n            INSTANCE = new AudioHelper(context);\r\n        return INSTANCE;\r\n    }\r\n\r\n    private static AudioHelper INSTANCE;\r\n    private Context context;\r\n    private AudioManager audioManager;\r\n\r\n    /**\r\n     * 初始化音频管理器\r\n     */\r\n    private void initAudioManager(Context context) {\r\n        this.context = context.getApplicationContext();\r\n        audioManager = (AudioManager) this.context.getSystemService(Context.AUDIO_SERVICE);\r\n        audioManager.setMode(AudioManager.MODE_IN_COMMUNICATION);\r\n        audioManager.setSpeakerphoneOn(true);//默认为扬声器播放\r\n    }\r\n\r\n    /**\r\n     * 设置是否使用扬声器\r\n     *\r\n     * @param speakerMode true为使用扬声器,false为使用耳机\r\n     */\r\n    public void speakerhoneSwitch(boolean speakerMode) {\r\n        audioManager.setSpeakerphoneOn(speakerMode);\r\n    }\r\n\r\n    /**\r\n     * 获取音频流的最大音量\r\n     *\r\n     * @param streamType 音频流类型\r\n     */\r\n    public int getMaxVolume(int streamType) {\r\n        return audioManager.getStreamMaxVolume(streamType);\r\n    }\r\n\r\n    /**\r\n     * 获取音频流的当前音量\r\n     *\r\n     * @param streamType 音频流类型\r\n     */\r\n    public int getCurrentVolume(int streamType) {\r\n        return audioManager.getStreamVolume(streamType);\r\n    }\r\n\r\n    /**\r\n     * 获取播放音乐时的最大音响\r\n     */\r\n    public int getMusicMaxVolume() {\r\n        return getMaxVolume(AudioManager.STREAM_MUSIC);\r\n    }\r\n\r\n    /**\r\n     * 获取铃声的最大音响\r\n     */\r\n    public int getRingMaxVolume() {\r\n        return getMaxVolume(AudioManager.STREAM_RING);\r\n    }\r\n\r\n    /**\r\n     * 获取提示音的最大音响\r\n     */\r\n    public int getAlamMaxVolume() {\r\n        return getMaxVolume(AudioManager.STREAM_ALARM);\r\n    }\r\n\r\n    /**\r\n     * 获取通知的最大音响\r\n     */\r\n    public int getNotificationMaxVolume() {\r\n        return getMaxVolume(AudioManager.STREAM_NOTIFICATION);\r\n    }\r\n\r\n    /**\r\n     * 获取系统音的最大音响\r\n     */\r\n    public int getSystemMaxVolume() {\r\n        return getMaxVolume(AudioManager.STREAM_SYSTEM);\r\n    }\r\n\r\n    /**\r\n     * 获取通话的最大音响\r\n     */\r\n    public int getVoiceCallMaxVolume() {\r\n        return getMaxVolume(AudioManager.STREAM_VOICE_CALL);\r\n    }\r\n\r\n    /**\r\n     * 获取双音频的最大音响\r\n     */\r\n    public int getDTMFMaxVolume() {\r\n        return getMaxVolume(AudioManager.STREAM_DTMF);\r\n    }\r\n\r\n    /**\r\n     * 直接设置音响大小\r\n     *\r\n     * @param streamType 音频类类型\r\n     * @param volume     音频大小\r\n     */\r\n    public void setVolume(int streamType, int volume) {\r\n        volume = (volume > getMaxVolume(streamType)) ? getMaxVolume(streamType) : volume;\r\n        audioManager.setStreamVolume(streamType,\r\n                volume,\r\n                AudioManager.FLAG_PLAY_SOUND | AudioManager.FLAG_SHOW_UI);\r\n    }\r\n\r\n    /**\r\n     * 调大音量\r\n     *\r\n     * @param streamType 音频类类型\r\n     */\r\n    public void raiseVolume(int streamType) {\r\n        int currentVolume = getCurrentVolume(streamType);\r\n        if (currentVolume < getMaxVolume(streamType)) {\r\n            audioManager.adjustStreamVolume(streamType,\r\n                    AudioManager.ADJUST_RAISE,\r\n                    AudioManager.FLAG_PLAY_SOUND | AudioManager.FLAG_SHOW_UI);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 调小音量\r\n     */\r\n    public void lowerVolume(int streamType) {\r\n        int currentVolume = getCurrentVolume(streamType);\r\n        if (currentVolume > 0) {\r\n            audioManager.adjustStreamVolume(streamType,\r\n                    AudioManager.ADJUST_LOWER,\r\n                    AudioManager.FLAG_SHOW_UI);\r\n        }\r\n    }\r\n\r\n    public void raiseMusicVolume() {\r\n        raiseVolume(AudioManager.STREAM_MUSIC);\r\n    }\r\n\r\n    public void lowerMusicVolume() {\r\n        lowerVolume(AudioManager.STREAM_MUSIC);\r\n    }\r\n```\r\n\r\n和\r\n\r\n```java\r\n/**\r\n * 音量调节管理器\r\n */\r\npublic class VoiceManager {\r\n    private static final String TAG = \"VoiceManager\";\r\n    Context context;\r\n    AudioManager mAudioManager;\r\n\r\n    public VoiceManager(Context context) {\r\n        this.context = context;\r\n        if (mAudioManager == null) {\r\n            mAudioManager = (AudioManager) context.getSystemService(Service.AUDIO_SERVICE);\r\n        }\r\n    }\r\n\r\n    /***\r\n     * 增大音量\r\n     */\r\n    public void addVoice() {\r\n        dealCallVoice(true);\r\n        dealSystemVoice(true);\r\n        dealRingVoice(true);\r\n        dealMediaVoice(true);\r\n        dealMessageVoice(true);\r\n    }\r\n\r\n\r\n    /***\r\n     * 减少声音\r\n     */\r\n    public void reduceVoice() {\r\n        dealCallVoice(false);\r\n        dealSystemVoice(false);\r\n        dealRingVoice(false);\r\n        dealMediaVoice(false);\r\n        dealMessageVoice(false);\r\n    }\r\n\r\n    /**\r\n     * 提示音设置\r\n     *\r\n     * @param b\r\n     */\r\n    private void dealMessageVoice(boolean b) {\r\n        if (mAudioManager == null) {\r\n            mAudioManager = (AudioManager) context.getSystemService(Service.AUDIO_SERVICE);\r\n        }\r\n        int max = mAudioManager.getStreamMaxVolume(AudioManager.STREAM_ALARM);\r\n        int current = mAudioManager.getStreamVolume(AudioManager.STREAM_ALARM);\r\n        Log.i(TAG, \"===处理前提示音音量====\" + current + \"  /\" + max);\r\n        if (b) {\r\n            if (current == max) {\r\n                return;\r\n            }\r\n            mAudioManager.setStreamVolume(AudioManager.STREAM_ALARM, current + 1, 0);\r\n        } else {\r\n            if (current < 1) {\r\n                return;\r\n            }\r\n            mAudioManager.setStreamVolume(AudioManager.STREAM_ALARM, current - 1, 0);\r\n        }\r\n        int maxdeal = mAudioManager.getStreamMaxVolume(AudioManager.STREAM_ALARM);\r\n        int currentdeal = mAudioManager.getStreamVolume(AudioManager.STREAM_ALARM);\r\n        Log.e(TAG, \"===处理前后提示音音量====\" + currentdeal + \"  /\" + maxdeal);\r\n    }\r\n\r\n    /***\r\n     * 处理媒体音量\r\n     * @param b\r\n     */\r\n    private void dealMediaVoice(boolean b) {\r\n        if (mAudioManager == null) {\r\n            mAudioManager = (AudioManager) context.getSystemService(Service.AUDIO_SERVICE);\r\n        }\r\n        int mediamax = mAudioManager.getStreamMaxVolume(AudioManager.STREAM_MUSIC);\r\n        int mediacurrent = mAudioManager.getStreamVolume(AudioManager.STREAM_MUSIC);\r\n        Log.i(TAG, \"===处理前媒体音量====\" + mediacurrent + \"  /\" + mediamax);\r\n        if (b) {\r\n            if (mediacurrent == mediamax) {\r\n                return;\r\n            }\r\n            mAudioManager.setStreamVolume(AudioManager.STREAM_MUSIC, mediacurrent + 1, 0);\r\n        } else {\r\n            if (mediacurrent < 1) {\r\n                return;\r\n            }\r\n            mAudioManager.setStreamVolume(AudioManager.STREAM_MUSIC, mediacurrent - 1, 0);\r\n        }\r\n    }\r\n\r\n    /***\r\n     * 铃声音量\r\n     * @param b\r\n     */\r\n    private void dealRingVoice(boolean b) {\r\n        if (mAudioManager == null) {\r\n            mAudioManager = (AudioManager) context.getSystemService(Service.AUDIO_SERVICE);\r\n        }\r\n        int ringmax = mAudioManager.getStreamMaxVolume(AudioManager.STREAM_RING);\r\n        int ringcurrent = mAudioManager.getStreamVolume(AudioManager.STREAM_RING);\r\n        Log.i(TAG, \"===处理前铃声音量====\" + ringcurrent + \"  /\" + ringmax);\r\n        if (b) {\r\n            if (ringcurrent == ringmax) {\r\n                return;\r\n            }\r\n            mAudioManager.setStreamVolume(AudioManager.STREAM_RING, ringcurrent + 1, 0);\r\n        } else {\r\n            if (ringcurrent < 1) {\r\n                return;\r\n            }\r\n            mAudioManager.setStreamVolume(AudioManager.STREAM_RING, ringcurrent - 1, 0);\r\n        }\r\n    }\r\n\r\n    /***\r\n     * 处理系统音量\r\n     * @param b\r\n     */\r\n    private void dealSystemVoice(boolean b) {\r\n        if (mAudioManager == null) {\r\n            mAudioManager = (AudioManager) context.getSystemService(Service.AUDIO_SERVICE);\r\n        }\r\n        int sysmax = mAudioManager.getStreamMaxVolume(AudioManager.STREAM_SYSTEM);\r\n        int syscurrent = mAudioManager.getStreamVolume(AudioManager.STREAM_SYSTEM);\r\n        Log.i(TAG, \"===设置前系统音量====\" + syscurrent + \"  /\" + sysmax);\r\n        if (b) {\r\n            if (syscurrent == sysmax) {\r\n                return;\r\n            }\r\n            mAudioManager.setStreamVolume(AudioManager.STREAM_SYSTEM, syscurrent + 1, 0);\r\n        } else {\r\n            if (syscurrent < 1) {\r\n                return;\r\n            }\r\n            mAudioManager.setStreamVolume(AudioManager.STREAM_SYSTEM, syscurrent - 1, 0);\r\n        }\r\n    }\r\n\r\n    /***\r\n     *  处理通话音量\r\n     * @param isAdd\r\n     * true 是音量+\r\n     * false 是音量-\r\n     */\r\n    private void dealCallVoice(boolean isAdd) {\r\n        if (mAudioManager == null) {\r\n            mAudioManager = (AudioManager) context.getSystemService(Service.AUDIO_SERVICE);\r\n        }\r\n        int callmax = mAudioManager.getStreamMaxVolume(AudioManager.STREAM_VOICE_CALL);\r\n        int callcurrent = mAudioManager.getStreamVolume(AudioManager.STREAM_VOICE_CALL);\r\n        Log.e(TAG, \"=====设置前通话音量==\" + callcurrent + \"/\" + callmax);\r\n        if (isAdd) {\r\n            if (callcurrent == callmax) {\r\n                return;\r\n            }\r\n            mAudioManager.setStreamVolume(AudioManager.STREAM_VOICE_CALL, callcurrent + 1, 0);\r\n        } else {\r\n            if (callcurrent < 1) {\r\n                return;\r\n            }\r\n            mAudioManager.setStreamVolume(AudioManager.STREAM_VOICE_CALL, callcurrent - 1, 0);\r\n        }\r\n    }\r\n\r\n\r\n    /***\r\n     * 静音\r\n     */\r\n    public void stopMediaVoice() {\r\n        if (mAudioManager == null) {\r\n            mAudioManager = (AudioManager) context.getSystemService(Service.AUDIO_SERVICE);\r\n        }\r\n        mAudioManager.setStreamVolume(AudioManager.STREAM_MUSIC, 0, 0);  //设置媒体音量为 0\r\n    }\r\n```\r\n",
    "comments_url": "https://api.github.com/repos/Blankj/AndroidUtilCode/issues/1287/comments",
    "author": "mao19951015",
    "comments": [
      {
        "user": "Blankj",
        "created_at": "2020-10-24T19:14:10Z",
        "body": "新版本 1.30.0 已发布，已新增 VolumeUtils"
      }
    ]
  },
  {
    "number": 1280,
    "title": "可否降低下耦合性",
    "created_at": "2020-07-16T07:29:06Z",
    "closed_at": "2020-07-16T07:44:31Z",
    "labels": [
      "help wanted"
    ],
    "url": "https://github.com/Blankj/AndroidUtilCode/issues/1280",
    "body": "\r\n能否不把一个工具类依赖一堆",
    "comments_url": "https://api.github.com/repos/Blankj/AndroidUtilCode/issues/1280/comments",
    "author": "Reginer",
    "comments": [
      {
        "user": "Blankj",
        "created_at": "2020-07-16T07:35:09Z",
        "body": "能否不要单独拷一个类出去用？"
      },
      {
        "user": "Reginer",
        "created_at": "2020-07-16T07:38:19Z",
        "body": "@Blankj   是的呀。\r\n以前经常在这里拷贝工具类(ToastUtils   FileUtils .. )，放到工程里基本都能用。\r\n\r\n刚看有些代码更新了，再一拷贝就很多错。\r\n\r\n之前那样是有哪不好么\r\n"
      },
      {
        "user": "Blankj",
        "created_at": "2020-07-16T07:42:08Z",
        "body": "换了设计方案，通过 UtilsBridge 来做桥接，以前那样因为存在代码的冗余，一个地方修复了，有的地方就漏了，不推荐拷贝，有的拷贝就会隐性存在问题。"
      },
      {
        "user": "Reginer",
        "created_at": "2020-07-16T07:44:26Z",
        "body": "代码有重复，漏改确实是个问题。\r\n\r\n一个依赖全部放进去感觉又太多了 。"
      },
      {
        "user": "Blankj",
        "created_at": "2020-07-16T07:49:02Z",
        "body": "项目都开启混淆的么？开了混淆就不用顾虑了呀"
      }
    ]
  },
  {
    "number": 1271,
    "title": "CacheDiskUtils",
    "created_at": "2020-07-04T02:45:39Z",
    "closed_at": "2020-07-27T08:14:52Z",
    "labels": [
      "help wanted"
    ],
    "url": "https://github.com/Blankj/AndroidUtilCode/issues/1271",
    "body": "请问下作者我这样获取的大小为什么总是0，cacheUtils文件夹里确定放入了图片文件CacheDiskUtils.getInstance(\"cacheUtils\").getCacheSize()",
    "comments_url": "https://api.github.com/repos/Blankj/AndroidUtilCode/issues/1271/comments",
    "author": "ghost",
    "comments": [
      {
        "user": "AndyRenJie",
        "created_at": "2020-07-14T15:35:54Z",
        "body": "同样追问，解决了么"
      },
      {
        "user": "aheven",
        "created_at": "2020-07-15T00:53:34Z",
        "body": "@Blankj 发现一个问题，Cache文件夹在部分手机上运行系统手机管家清理内存的时候会删除Cache文件夹。所以存储的东西会丢失"
      },
      {
        "user": "ghost",
        "created_at": "2020-07-27T08:14:28Z",
        "body": "> 同样追问，解决了么\r\n\r\n一开始就搞错了，作者的CacheDiskUtils.getInstance(\"cacheUtils\").getCacheSize()是内置目录缓存，就是路径/data/data/package/cache/cacheUtils这个。"
      }
    ]
  },
  {
    "number": 1270,
    "title": "设置阴影能不能加下x轴y轴偏移量",
    "created_at": "2020-06-30T04:13:16Z",
    "closed_at": "2020-09-07T13:10:52Z",
    "labels": [
      "help wanted"
    ],
    "url": "https://github.com/Blankj/AndroidUtilCode/issues/1270",
    "body": "## 描述需求\r\n\r\n设置阴影能不能加下x轴y轴偏移量，谢谢\r\n",
    "comments_url": "https://api.github.com/repos/Blankj/AndroidUtilCode/issues/1270/comments",
    "author": "huozhihao",
    "comments": [
      {
        "user": "Blankj",
        "created_at": "2020-09-07T13:10:43Z",
        "body": "这个之前搞过，效果不是很好，就不支持了"
      }
    ]
  },
  {
    "number": 1262,
    "title": "完善ClickUtils",
    "created_at": "2020-06-17T03:43:17Z",
    "closed_at": "2020-10-24T19:17:38Z",
    "labels": [
      "help wanted"
    ],
    "url": "https://github.com/Blankj/AndroidUtilCode/issues/1262",
    "body": "## 描述需求\r\n\r\n简洁地描述下需求。\r\n现在有ClickUtils来防止抖动，但是目前这样子的侵入性比较大，比如我是使用butterknife的OnClick注解去生成方法的。建议增加一种返回布尔值的判断。\r\n\r\n## 可借鉴的\r\n\r\n例子代码：\r\n\r\n```\r\npublic class FastClickHelper {\r\n\r\n    private static final class FastClickHelperHolder {\r\n        private static final FastClickHelper INSTANCE = new FastClickHelper();\r\n    }\r\n\r\n    public static FastClickHelper get() {\r\n        return FastClickHelperHolder.INSTANCE;\r\n    }\r\n\r\n    private LruCache<View, Long> mViewCache;\r\n\r\n    private FastClickHelper() {\r\n        // 设置最大缓存的个数\r\n        mViewCache = new LruCache<>(16);\r\n    }\r\n\r\n    public boolean isFastClick(View view) {\r\n        return isFastClick(view, 1000);\r\n    }\r\n\r\n    public boolean isFastClick(View view, long ms) {\r\n        Long last = mViewCache.get(view);\r\n        if (last == null) {\r\n            mViewCache.put(view, SystemClock.elapsedRealtime());\r\n            return false;\r\n        }\r\n        //进行比较\r\n        if (Math.abs(SystemClock.elapsedRealtime() - last) > ms) {\r\n            //重新设置最后一次点击时间\r\n            mViewCache.put(view, SystemClock.elapsedRealtime());\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    public void clear() {\r\n        mViewCache.evictAll();\r\n    }\r\n\r\n}\r\n\r\n```\r\n\r\n\r\n",
    "comments_url": "https://api.github.com/repos/Blankj/AndroidUtilCode/issues/1262/comments",
    "author": "liweijieok",
    "comments": [
      {
        "user": "Blankj",
        "created_at": "2020-09-07T10:39:48Z",
        "body": "下版本会有  DebouncingUtils 来支持"
      },
      {
        "user": "Blankj",
        "created_at": "2020-10-24T19:17:21Z",
        "body": "新版本 1.30.0 已发布"
      }
    ]
  },
  {
    "number": 1258,
    "title": "ServiceUtils. startForegroundService",
    "created_at": "2020-06-12T02:20:39Z",
    "closed_at": "2020-10-24T19:27:29Z",
    "labels": [
      "help wanted"
    ],
    "url": "https://github.com/Blankj/AndroidUtilCode/issues/1258",
    "body": "private void startService(Class<?> cls) {\r\n        try {\r\n            Intent intent = new Intent(Utils.getApp(), cls);\r\n            intent.setFlags(Intent.FLAG_INCLUDE_STOPPED_PACKAGES);\r\n            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\r\n                Utils.getApp().startForegroundService(intent);\r\n            } else {\r\n                Utils.getApp().startService(intent);\r\n            }\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n        }\r\n    }",
    "comments_url": "https://api.github.com/repos/Blankj/AndroidUtilCode/issues/1258/comments",
    "author": "Jasperben",
    "comments": [
      {
        "user": "Blankj",
        "created_at": "2020-06-12T02:26:24Z",
        "body": "说清楚点？？"
      },
      {
        "user": "Liberations",
        "created_at": "2020-08-18T08:16:28Z",
        "body": "8.0以上启动服务会报错。必须开启前台服务"
      },
      {
        "user": "Blankj",
        "created_at": "2020-10-24T19:19:36Z",
        "body": "新版本 1.30.0 已发布"
      },
      {
        "user": "xmlxin",
        "created_at": "2020-11-18T05:15:34Z",
        "body": "也遇到这个问题了，1.29.0版本没有问题，更新到1.30.0出现这个问题"
      },
      {
        "user": "Jasperben",
        "created_at": "2020-11-18T09:56:57Z",
        "body": "> 也遇到这个问题了，1.29.0版本没有问题，更新到1.30.0出现这个问题\r\n\r\n这是你service写的有问题"
      }
    ]
  },
  {
    "number": 1256,
    "title": "建议PermissionUtils类的isGranted方法支持PermissionConstants作为参数",
    "created_at": "2020-06-09T07:48:30Z",
    "closed_at": "2020-10-24T19:28:51Z",
    "labels": [
      "help wanted"
    ],
    "url": "https://github.com/Blankj/AndroidUtilCode/issues/1256",
    "body": "## 描述需求\r\n\r\nPermissionUtils的permission方法是支持PermissionConstants作为参数的。\r\n一般来说会认为isGranted方法也是支持的，容易造成错误的使用。\r\n事实上我是发现判断出现问题，看了源码才知道是不支持的。\r\n建议isGranted方法支持PermissionConstants作为参数。\r\n\r\n",
    "comments_url": "https://api.github.com/repos/Blankj/AndroidUtilCode/issues/1256/comments",
    "author": "zjhcode",
    "comments": [
      {
        "user": "Blankj",
        "created_at": "2020-06-10T10:10:03Z",
        "body": "下版本支持吧"
      },
      {
        "user": "Blankj",
        "created_at": "2020-10-24T19:22:10Z",
        "body": "新版本 1.30.0 已发布"
      }
    ]
  },
  {
    "number": 1253,
    "title": "可以新增一个判断当前设备是否支持深色(暗黑)模式的函数",
    "created_at": "2020-06-02T10:05:11Z",
    "closed_at": "2020-06-10T10:10:36Z",
    "labels": [
      "help wanted"
    ],
    "url": "https://github.com/Blankj/AndroidUtilCode/issues/1253",
    "body": "## 是否可以新增一个 判断当前设备是否支持深色模式的方法函数？\r\n\r\n可根据改函数方法处理一些 UI 需求\r\n\r\n",
    "comments_url": "https://api.github.com/repos/Blankj/AndroidUtilCode/issues/1253/comments",
    "author": "yibaimishenlan",
    "comments": [
      {
        "user": "Blankj",
        "created_at": "2020-06-03T06:23:24Z",
        "body": "上代码？\r\n"
      },
      {
        "user": "yibaimishenlan",
        "created_at": "2020-06-05T07:51:23Z",
        "body": "惭愧， 我不会啊，更没有代码了[囧😶]。 这个需求是我在看微信的时候  发现微信做了判断的。微信-我的-设置-通用 中 “深色模式” item 会根据当前设备是否支持深色模式来设置显示和隐藏。"
      },
      {
        "user": "Blankj",
        "created_at": "2020-06-05T08:16:18Z",
        "body": "你说的深色模式是哪里深色？状态栏还是什么？"
      }
    ]
  },
  {
    "number": 1237,
    "title": "PermissionUtils的onGranted回调里面建议加一个isAll参数，表示是否全部都同意",
    "created_at": "2020-05-07T09:18:57Z",
    "closed_at": "2020-05-07T09:55:48Z",
    "labels": [
      "help wanted"
    ],
    "url": "https://github.com/Blankj/AndroidUtilCode/issues/1237",
    "body": "```java\r\nPermissionUtils.permission(PermissionConstants.CALENDAR, PermissionConstants.MICROPHONE)\r\n                .rationale { activity, shouldRequest -> DialogHelper.showRationaleDialog(activity, shouldRequest) }\r\n                .callback(object : PermissionUtils.FullCallback {\r\n                    override fun onGranted(permissionsGranted: List<String>) {\r\n                        LogUtils.d(permissionsGranted)\r\n                        if (permissionsGranted.size == 2) {\r\n                            showSnackbar(true, \"Calendar or Microphone is granted\")\r\n                        }\r\n                        itemsView.updateItems(bindItems())\r\n                    }\r\n\r\n                    override fun onDenied(permissionsDeniedForever: List<String>,\r\n                                          permissionsDenied: List<String>) {\r\n                        LogUtils.d(permissionsDeniedForever, permissionsDenied)\r\n                        if (permissionsDeniedForever.isNotEmpty()) {\r\n                            showSnackbar(false, \"Calendar or Microphone is denied forever\")\r\n                        } else {\r\n                            showSnackbar(false, \"Calendar or Microphone is denied\")\r\n                        }\r\n                        itemsView.updateItems(bindItems())\r\n                    }\r\n                })\r\n                .request()\r\n```\r\n这个可以多个权限请求，有的同意，有的拒绝的情况下，不用总去判断permissionsGranted.size是否和自己传进来的一样大!,有时候会再加入有个权限，但是忘记吧permissionsGranted.size == 2改成permissionsGranted.size == 3，导致错误",
    "comments_url": "https://api.github.com/repos/Blankj/AndroidUtilCode/issues/1237/comments",
    "author": "LLQQHH",
    "comments": [
      {
        "user": "Blankj",
        "created_at": "2020-05-07T09:49:29Z",
        "body": "这个尽可能业务方自己的做吧，Array (PermissionConstants.CALENDAR, PermissionConstants.MICROPHONE) 声明为变量，然后用它的 size 比较即可，我这边修改 api 的成本比较大，成千上万开发者升级后都需要适配这个接口改动。"
      },
      {
        "user": "LLQQHH",
        "created_at": "2020-05-07T09:52:59Z",
        "body": "嗯，我就是建议，改动大就算了"
      },
      {
        "user": "Blankj",
        "created_at": "2020-05-07T09:55:34Z",
        "body": "我改动不大，主要是我这边修改接口对大家适配代价比较大。"
      },
      {
        "user": "Blankj",
        "created_at": "2020-05-26T06:18:49Z",
        "body": "最新版本有个 SingleCallback 接口满足你了。"
      },
      {
        "user": "LLQQHH",
        "created_at": "2020-05-26T06:20:02Z",
        "body": "好的，我看看"
      }
    ]
  },
  {
    "number": 1227,
    "title": "PermissionUtils 希望增加一个请求结束的回调",
    "created_at": "2020-04-21T10:40:21Z",
    "closed_at": "2020-04-23T17:24:56Z",
    "labels": [
      "help wanted"
    ],
    "url": "https://github.com/Blankj/AndroidUtilCode/issues/1227",
    "body": "## 描述需求\r\n\r\n一般情况下可能会PermissionUtils请求多种权限.但不一定需要根据结果回调来处理逻辑,可能只是接着走下一步流程. 比如说打开应用一次请求多个权限. 权限结束后进入应用首页.\r\n如果使用请求结果的回调来写, 多种权限 有的接收有的拒绝,这样的话,他里面的两种方法都会走, 我们就没法很好的利用\r\n\r\n```\r\n  PermissionUtils.permission(\r\n          PermissionConstants.CAMERA,\r\n          PermissionConstants.STORAGE,\r\n          PermissionConstants.LOCATION\r\n  )\r\n          .callback(new PermissionUtils.FullCallback() {\r\n              @Override\r\n              public void onGranted(List<String> permissionsGranted) {\r\n                  LogUtils.dTag(TAG, \"onGranted: \" + permissionsGranted);\r\n              }\r\n              @Override\r\n              public void onDenied(List<String> permissionsDeniedForever, List<String> permissionsDenied) {\r\n                  LogUtils.dTag(TAG, \"onDenied: \" + permissionsDeniedForever + \"~\" + permissionsDenied);\r\n              }\r\n              \r\n              public void onFinish(){\r\n                  // 请求后的下一步操作 与是否拥有该权限无关\r\n              }\r\n          })\r\n          //.rationale(new PermissionUtils.OnRationaleListener() {\r\n          //    @Override\r\n          //    public void rationale(UtilsTransActivity activity, ShouldRequest shouldRequest) {\r\n          //        LogUtils.dTag(TAG, \"rationale: \" + shouldRequest);\r\n          //    }\r\n          //})\r\n          .request();\r\n```\r\n\r\n## 可借鉴的\r\n\r\n\r\n",
    "comments_url": "https://api.github.com/repos/Blankj/AndroidUtilCode/issues/1227/comments",
    "author": "prczhb",
    "comments": [
      {
        "user": "Blankj",
        "created_at": "2020-04-23T03:33:09Z",
        "body": "先这样解决吧。\r\n```java  \r\nPermissionUtils.permission(\r\n          PermissionConstants.CAMERA,\r\n          PermissionConstants.STORAGE,\r\n          PermissionConstants.LOCATION\r\n  )\r\n          .callback(new PermissionUtils.FullCallback() {\r\n              @Override\r\n              public void onGranted(List<String> permissionsGranted) {\r\n                  LogUtils.dTag(TAG, \"onGranted: \" + permissionsGranted);\r\n                  onFinish();\r\n              }\r\n              @Override\r\n              public void onDenied(List<String> permissionsDeniedForever, List<String> permissionsDenied) {\r\n                  LogUtils.dTag(TAG, \"onDenied: \" + permissionsDeniedForever + \"~\" + permissionsDenied);\r\n                  onFinish();\r\n              }\r\n\r\n              boolean isFinished = false;\r\n              \r\n              public void onFinish(){\r\n                  if (!isFinished) {\r\n                      isFinished = true;\r\n                  }\r\n                  // 请求后的下一步操作 与是否拥有该权限无关\r\n              }\r\n          })\r\n          //.rationale(new PermissionUtils.OnRationaleListener() {\r\n          //    @Override\r\n          //    public void rationale(UtilsTransActivity activity, ShouldRequest shouldRequest) {\r\n          //        LogUtils.dTag(TAG, \"rationale: \" + shouldRequest);\r\n          //    }\r\n          //})\r\n          .request();\r\n```"
      },
      {
        "user": "Blankj",
        "created_at": "2020-05-26T06:19:42Z",
        "body": "最新版本有个 SingleCallback 接口满足你了。"
      }
    ]
  },
  {
    "number": 1225,
    "title": "ImageUtils的getBitmap(final InputStream is, final int maxWidth, final int maxHeight)方法有OOM的风险",
    "created_at": "2020-04-16T16:46:42Z",
    "closed_at": "2020-04-18T18:41:50Z",
    "labels": [
      "help wanted"
    ],
    "url": "https://github.com/Blankj/AndroidUtilCode/issues/1225",
    "body": "## 描述需求\r\n\r\nImageUtils的getBitmap(final InputStream is, final int maxWidth, final int maxHeight)方法有OOM的风险。\r\n其他的getBitmap有限制maxWidth和maxHeight的方法，均是先设置options.inJustDecodeBounds = true不加载到内存获取图片宽高，再计算压缩比例的方式。\r\n唯独处理InputStream的方法，在限制maxWidth和maxHeight时，是先将InputStream转化成byte[]，再计算压缩比例，这一步，图片数据已经加载到内存，如果是一张非常大的图片，是有OOM的风险的。\r\n为何不同样先设置options.inJustDecodeBounds = true获取宽高，再通过BitmapFactory.decodeStream(input, null, bitmapOptions)来压缩图片？\r\n\r\n\r\n",
    "comments_url": "https://api.github.com/repos/Blankj/AndroidUtilCode/issues/1225/comments",
    "author": "zjhcode",
    "comments": [
      {
        "user": "Blankj",
        "created_at": "2020-04-17T12:40:43Z",
        "body": "好的，已发现。"
      },
      {
        "user": "Blankj",
        "created_at": "2020-04-18T18:33:53Z",
        "body": "1.28.1 已修复"
      }
    ]
  },
  {
    "number": 1221,
    "title": "为什么ThreadUtils没有关闭线程池的方法",
    "created_at": "2020-04-09T09:23:42Z",
    "closed_at": "2020-04-09T18:08:53Z",
    "labels": [
      "help wanted"
    ],
    "url": "https://github.com/Blankj/AndroidUtilCode/issues/1221",
    "body": "## 描述需求\r\n\r\n如题，不怕造成内存溢出吗？\r\n\r\n\r\n",
    "comments_url": "https://api.github.com/repos/Blankj/AndroidUtilCode/issues/1221/comments",
    "author": "bunny-pu",
    "comments": [
      {
        "user": "Blankj",
        "created_at": "2020-04-09T18:08:45Z",
        "body": "内存溢出和线程池是否关闭并没有什么直接联系吧，线程闲置了自然会挂起并不消耗资源，线程池的存在就是为了统一调度线程，并不是频繁去关闭开启它。"
      }
    ]
  },
  {
    "number": 1219,
    "title": "能否添加一下Utils移除runnable的方法",
    "created_at": "2020-04-09T06:52:49Z",
    "closed_at": "2020-04-09T20:38:11Z",
    "labels": [
      "help wanted"
    ],
    "url": "https://github.com/Blankj/AndroidUtilCode/issues/1219",
    "body": "## 描述需求\r\n\r\n和Utils.runOnUiThread、runOnUiThreadDelayed方法对应的，\r\n能否添加一下移除runnable的方法\r\n",
    "comments_url": "https://api.github.com/repos/Blankj/AndroidUtilCode/issues/1219/comments",
    "author": "SheepYang1993",
    "comments": [
      {
        "user": "Blankj",
        "created_at": "2020-04-09T20:38:02Z",
        "body": "1.27.6 新增 ThreadUtils.getMainHandler"
      }
    ]
  },
  {
    "number": 1218,
    "title": "PermissionConstants增加权限",
    "created_at": "2020-04-09T03:29:42Z",
    "closed_at": "2020-04-09T06:46:49Z",
    "labels": [
      "help wanted"
    ],
    "url": "https://github.com/Blankj/AndroidUtilCode/issues/1218",
    "body": "PermissionConstants 里面的权限不够，我想增加有什么方法嘛？必须得lib这个类重写吗",
    "comments_url": "https://api.github.com/repos/Blankj/AndroidUtilCode/issues/1218/comments",
    "author": "neabea",
    "comments": [
      {
        "user": "Blankj",
        "created_at": "2020-04-09T04:08:10Z",
        "body": "直接往 permission 后加权限就行了"
      },
      {
        "user": "Blankj",
        "created_at": "2020-04-09T05:33:56Z",
        "body": "再说为啥会有不够？android 新加权限了吗？"
      },
      {
        "user": "neabea",
        "created_at": "2020-04-09T05:45:20Z",
        "body": "比如判断位置服务，可能是不是权限，这个相关的有支持嘛"
      },
      {
        "user": "Blankj",
        "created_at": "2020-04-09T05:50:19Z",
        "body": "属于动态权限才需要请求的，不是动态权限为何需要请求？定位的请求权限不是已经有了么。"
      },
      {
        "user": "neabea",
        "created_at": "2020-04-09T06:03:33Z",
        "body": "申请了动态位置权限，如果没开位置服务也是定位不了的，所以我还要判断位置服务开没开，我是想加这个"
      },
      {
        "user": "Blankj",
        "created_at": "2020-04-09T06:06:20Z",
        "body": "这又不属于动态权限了，为何要加到这里来？"
      },
      {
        "user": "neabea",
        "created_at": "2020-04-09T06:23:21Z",
        "body": "我开始以为位置服务也是动态权限，查了下通过setting可以查询"
      }
    ]
  },
  {
    "number": 1211,
    "title": "[FEATURE] Android 10 适配",
    "created_at": "2020-04-01T09:16:12Z",
    "closed_at": "2020-04-11T16:53:22Z",
    "labels": [
      "help wanted"
    ],
    "url": "https://github.com/Blankj/AndroidUtilCode/issues/1211",
    "body": "## 描述需求\r\n\r\nAndroid 10 的 API 适配。\r\n\r\n梳理哪些 API 存有问题？\r\n\r\n\r\n## 可借鉴的\r\n\r\n欢迎大家留言或者提供参考代码。\r\n\r\n",
    "comments_url": "https://api.github.com/repos/Blankj/AndroidUtilCode/issues/1211/comments",
    "author": "Blankj",
    "comments": [
      {
        "user": "GXSZone",
        "created_at": "2020-10-19T16:48:19Z",
        "body": "咋关了，需求很强烈啊"
      },
      {
        "user": "MrDon94",
        "created_at": "2021-05-26T01:32:52Z",
        "body": "+1"
      }
    ]
  },
  {
    "number": 1158,
    "title": "修正BarUtils错误",
    "created_at": "2020-01-15T12:09:32Z",
    "closed_at": "2020-01-15T12:27:59Z",
    "labels": [
      "help wanted"
    ],
    "url": "https://github.com/Blankj/AndroidUtilCode/pull/1158",
    "body": "",
    "comments_url": "https://api.github.com/repos/Blankj/AndroidUtilCode/issues/1158/comments",
    "author": "crmemo",
    "comments": [
      {
        "user": "Blankj",
        "created_at": "2020-01-15T12:13:10Z",
        "body": "1.26.1 分支已经修改啦，下版本会更新的哦。"
      }
    ]
  },
  {
    "number": 1013,
    "title": "android Q变更 原来的READ_PHONE_STATE权限已经不能获得IMEI和序列号。",
    "created_at": "2019-08-22T01:26:33Z",
    "closed_at": "2019-08-28T03:54:42Z",
    "labels": [
      "help wanted"
    ],
    "url": "https://github.com/Blankj/AndroidUtilCode/issues/1013",
    "body": "AndroidQ中去掉了READ_PHONE_STATE权限,取而代之的是一个系统级别的权限:READ_PRIVILEGED_PHONE_STATE,所以Android Q平台无论如何也不会再有IMEI和序列号",
    "comments_url": "https://api.github.com/repos/Blankj/AndroidUtilCode/issues/1013/comments",
    "author": "OneGreenHand",
    "comments": [
      {
        "user": "Blankj",
        "created_at": "2019-08-26T02:54:49Z",
        "body": "最新版本 1.25.9 对 SDK 大于等于 29 的我直接返回空字符串了。"
      }
    ]
  },
  {
    "number": 944,
    "title": "路径工具有问题",
    "created_at": "2019-06-09T04:32:02Z",
    "closed_at": "2019-06-27T02:34:12Z",
    "labels": [
      "help wanted"
    ],
    "url": "https://github.com/Blankj/AndroidUtilCode/issues/944",
    "body": "getInternalAppSpPath: \r\n\r\n/data/user/0/com.lzu.yuh.lzushared_prefs\r\n\r\n应该是/data/user/0/com.lzu.yuh.lzu/shared_prefs",
    "comments_url": "https://api.github.com/repos/Blankj/AndroidUtilCode/issues/944/comments",
    "author": "yuhldr",
    "comments": [
      {
        "user": "Blankj",
        "created_at": "2019-06-09T08:22:07Z",
        "body": "好的，下版本会修复"
      }
    ]
  },
  {
    "number": 916,
    "title": "LogUtils的LogBorderSwitch分行机制对中文支持不好",
    "created_at": "2019-05-14T02:15:33Z",
    "closed_at": "2019-06-03T09:29:22Z",
    "labels": [
      "help wanted"
    ],
    "url": "https://github.com/Blankj/AndroidUtilCode/issues/916",
    "body": "## Describe the bug\r\n\r\nA clear and concise description of what the bug is.\r\n\r\n- The version of utilcode: 1.23.0\r\n- The device: \r\n- The version of device: API 27 \r\n\r\n## The code of bug\r\n\r\n     StringBuilder sb = new StringBuilder();\r\n        for (int i = 0; i < 1024; i++) {\r\n            sb.append(\"{测试内容 = \").append(i).append(\"}\");\r\n        }\r\n        LogUtils.d(sb.toString());\r\n\r\n## Screenshots\r\n库中的核心判断代码如下：\r\n\r\n    int len = msg.length();\r\n    int countOfSub = len / MAX_LEN;\r\n\r\n\r\n建议改成： \r\n\r\n    int len = msg.getBytes().length();\r\n    int countOfSub = len / MAX_LEN;",
    "comments_url": "https://api.github.com/repos/Blankj/AndroidUtilCode/issues/916/comments",
    "author": "fly904021125",
    "comments": [
      {
        "user": "Blankj",
        "created_at": "2019-05-17T14:30:13Z",
        "body": "这不行的，后面 substring 不是根据这个 len 来会出问题的，我把 MAX_LEN 值改小点吧，一般 logcat 输出都是比较短的"
      },
      {
        "user": "Blankj",
        "created_at": "2019-06-03T08:32:39Z",
        "body": "1.24.0 已修复"
      },
      {
        "user": "fly904021125",
        "created_at": "2019-06-03T09:26:47Z",
        "body": "修改MAX_LEN不失为一种有效率的方法\r\n\r\n    public static List<String> splitLog(String msg) {\r\n        List<String> list = new ArrayList<>();\r\n        int index = 0;\r\n        int step = 1;\r\n        while (index < msg.length()) {\r\n            int stepTotal = step * 500;\r\n            boolean isEnd = false;\r\n            if (stepTotal + index > msg.length()) {\r\n                stepTotal = msg.length() - index;\r\n                isEnd = true;\r\n            }\r\n            if (msg.substring(index, index + stepTotal).getBytes().length > MAX_LEN || isEnd && step == 1) {\r\n                if (isEnd && step == 1) {\r\n                    list.add(msg.substring(index, index + stepTotal));\r\n                    index = index + stepTotal;\r\n                } else {\r\n                    step--;\r\n                    list.add(msg.substring(index, index + step * 500));\r\n                    index = index + step * 500;\r\n                }\r\n\r\n                step = 1;\r\n            } else {\r\n                step++;\r\n            }\r\n\r\n        }\r\n        return list;\r\n    }\r\n\r\n这是个人所写的将一个长字符串分割成小于MAX_LEN字节长度的字符串List的方法，可能对您后续优化会有帮助"
      },
      {
        "user": "Blankj",
        "created_at": "2019-06-03T09:28:20Z",
        "body": "已经修复了哈，以前本来就分割的，只是汉字字节占了两个，所以同等长度的 logcat 就输出不完"
      }
    ]
  },
  {
    "number": 859,
    "title": "日志打印工具有个空指针异常(偶尔)",
    "created_at": "2019-03-07T07:15:18Z",
    "closed_at": "2019-03-08T05:50:32Z",
    "labels": [
      "help wanted"
    ],
    "url": "https://github.com/Blankj/AndroidUtilCode/issues/859",
    "body": "## Describe the bug\r\n\r\n日志打印有一个偶尔出现的空指针异常\r\n\r\n- The version of utilcode: 1.23.5\r\n- The device: Android Tablet \r\n- The version of device: Android5.1.1\r\n\r\n## The code of bug\r\n\r\n<!-- e.g. \r\n```java\r\nCrashUtils.init();\r\n```\r\n-->\r\n```\r\nLogUtils.i(\"\");\r\n```\r\n\r\n## The stack of crash\r\n\r\n<!-- e.g. \r\n```\r\nCaused by: java.lang.NullPointerException: u should init first\r\n   at com.blankj.utilcode.util.Utils.getApp(Utils.java:98)\r\n   at com.blankj.utilcode.util.CrashUtils.<clinit>(CrashUtils.java:55)\r\n   at com.blankj.utilcode.util.CrashUtils.init(CrashUtils.java:168) \r\n   at com.blankj.androidutilcode.UtilsApp.initCrash(UtilsApp.java:71) \r\n   at com.blankj.androidutilcode.UtilsApp.onCreate(UtilsApp.java:33) \r\n```\r\n-->\r\n\r\n```\r\n java.lang.NullPointerException: Attempt to get length of null array\r\n        at com.blankj.utilcode.util.LogUtils.deleteDueLogs(LogUtils.java:527)\r\n        at com.blankj.utilcode.util.LogUtils.createOrExistsFile(LogUtils.java:506)\r\n        at com.blankj.utilcode.util.LogUtils.print2File(LogUtils.java:477)\r\n        at com.blankj.utilcode.util.LogUtils.log(LogUtils.java:225)\r\n        at com.blankj.utilcode.util.LogUtils.i(LogUtils.java:136)\r\n```",
    "comments_url": "https://api.github.com/repos/Blankj/AndroidUtilCode/issues/859/comments",
    "author": "xiexindev",
    "comments": [
      {
        "user": "Blankj",
        "created_at": "2019-03-08T03:32:59Z",
        "body": "1.23.7 版本教你做人"
      },
      {
        "user": "xiexindev",
        "created_at": "2019-03-08T03:36:45Z",
        "body": "大柯基佬你今天要要穿女装. 不然怎么祝你节日快乐..."
      },
      {
        "user": "Blankj",
        "created_at": "2019-03-08T03:37:41Z",
        "body": "我热爱工作，不穿女装"
      }
    ]
  },
  {
    "number": 754,
    "title": "ImageUtils.scale的问题",
    "created_at": "2018-12-17T08:17:35Z",
    "closed_at": "2018-12-25T08:56:50Z",
    "labels": [
      "help wanted"
    ],
    "url": "https://github.com/Blankj/AndroidUtilCode/issues/754",
    "body": "Bitmap的createScaledBitmap方法的官方描述是If the specified width and height are the same as the current width and height of the source bitmap, the source bitmap is returned and no new bitmap is created.所以原始的bitmap和返回的bitmap可能是同一个,所以在是否回收的判断上应该这样更好点：\r\n if (recycle && !src.isRecycled() && ret != src) src.recycle();\r\n该类的其他方法同理",
    "comments_url": "https://api.github.com/repos/Blankj/AndroidUtilCode/issues/754/comments",
    "author": "jiezigg",
    "comments": [
      {
        "user": "Blankj",
        "created_at": "2018-12-17T09:02:49Z",
        "body": "好的哈"
      },
      {
        "user": "Blankj",
        "created_at": "2018-12-25T08:56:44Z",
        "body": "新版本已修复哈"
      }
    ]
  },
  {
    "number": 751,
    "title": "关于APP安装的问题",
    "created_at": "2018-12-17T06:07:10Z",
    "closed_at": "2018-12-17T06:27:59Z",
    "labels": [
      "help wanted"
    ],
    "url": "https://github.com/Blankj/AndroidUtilCode/issues/751",
    "body": "java.lang.NullPointerException: Attempt to invoke virtual method 'android.content.res.XmlResourceParser android.content.pm.ProviderInfo.loadXmlMetaData(android.content.pm.PackageManager, java.lang.String)' on a null object reference\r\n        at android.support.v4.content.FileProvider.parsePathStrategy(FileProvider.java:605)\r\n        at android.support.v4.content.FileProvider.getPathStrategy(FileProvider.java:579)\r\n        at android.support.v4.content.FileProvider.getUriForFile(FileProvider.java:417)\r\n        at com.blankj.utilcode.util.AppUtils.getInstallAppIntent(AppUtils.java:940)\r\n        at com.blankj.utilcode.util.AppUtils.installApp(AppUtils.java:84)\r\n        at com.blankj.utilcode.util.AppUtils.installApp(AppUtils.java:72)\r\n\r\n\r\n版本：1.22.2\r\n",
    "comments_url": "https://api.github.com/repos/Blankj/AndroidUtilCode/issues/751/comments",
    "author": "tiamosu",
    "comments": [
      {
        "user": "Blankj",
        "created_at": "2018-12-17T06:14:26Z",
        "body": "不好意思，发版删了点东西，已发布 1.22.3。你试试吧"
      }
    ]
  },
  {
    "number": 728,
    "title": "按键防抖工具",
    "created_at": "2018-11-26T07:06:33Z",
    "closed_at": "2018-12-29T11:21:36Z",
    "labels": [
      "help wanted"
    ],
    "url": "https://github.com/Blankj/AndroidUtilCode/issues/728",
    "body": "可否考虑增加一个botton防抖动的工具，如：onClick（view-->{util.check();do somthing}）",
    "comments_url": "https://api.github.com/repos/Blankj/AndroidUtilCode/issues/728/comments",
    "author": "houyuehai",
    "comments": [
      {
        "user": "Blankj",
        "created_at": "2018-12-29T11:20:37Z",
        "body": "1.22.9 版本\r\n```\r\nif (AntiShakeUtils.isValid(view, 200)) {\r\n    xxx\r\n}\r\n```"
      }
    ]
  },
  {
    "number": 702,
    "title": "关于使用了 tinker, 并且配置enableProxyApplication = true 的 app的相关问题",
    "created_at": "2018-11-12T09:49:45Z",
    "closed_at": "2018-11-20T16:47:22Z",
    "labels": [
      "help wanted"
    ],
    "url": "https://github.com/Blankj/AndroidUtilCode/issues/702",
    "body": "对于utils 版本超过1.19.0的库,由于采用了FileProvider4UtilCode注册初始化,该项初始化是在 oncreate 之前的,对于没有使用 tinker 的用户来说并没有问题,但是对于使用了 tinker ,并且配置enableProxyApplication = true的同学来说,由于 tinker 使用了代理,所以在 FileProvider4UtilCode初始化时,会被 tinker hook住,并替换为 tinker 的壳 application, 并不是真正的你们代码中写的 application, 这就会导致 utils 中注册的registerActivityLifecycleCallbacks都注册到了 tinker 的 application 中,从而导致 ActivityUtils.getTopActivity()为空,和Utils.getApp()获得到的 application为 tinker 的壳.\r\n目前我的解决方案就是设置enableProxyApplication = false,并采取相关 tinker 配置,具体配置请查阅 tinker 的文档,由于我是使用了 bugly 的间接使用 tinker, 所以具体参数名称可能有出入,还有一种方案就是保留在1.19.0版本上,要么不使用 tinker, 暂时没想到其他的解决方法,如果有其他的解决方法,欢迎反馈",
    "comments_url": "https://api.github.com/repos/Blankj/AndroidUtilCode/issues/702/comments",
    "author": "ldj365",
    "comments": [
      {
        "user": "chenxi2035",
        "created_at": "2018-11-13T05:35:34Z",
        "body": "没详细看过，有个思路 ：把bugly打的包打开后，看看注册的apllication类的内容，可以找找线索。"
      }
    ]
  },
  {
    "number": 657,
    "title": "PhoneUtils.call",
    "created_at": "2018-10-08T02:37:44Z",
    "closed_at": "2018-10-25T11:46:03Z",
    "labels": [
      "help wanted"
    ],
    "url": "https://github.com/Blankj/AndroidUtilCode/issues/657",
    "body": "- The version of utilcode: 1.16.4\r\n- The device: EEBBK/full_S1S\r\n- The version of device: 24\r\n\r\n```\r\nPhoneUtils.call(phoneNumber)\r\n```\r\n\r\n# main(1)\r\n\r\nandroid.content.ActivityNotFoundException\r\n\r\nNo Activity found to handle Intent { act=android.intent.action.CALL dat=tel:xxxxxxxxxx flg=0x10000000 }\r\n```\r\n\r\nPhoneUtils.call方法中没有检测intent.resolveActivity返回null的情况\r\n",
    "comments_url": "https://api.github.com/repos/Blankj/AndroidUtilCode/issues/657/comments",
    "author": "weikano",
    "comments": [
      {
        "user": "Blankj",
        "created_at": "2018-10-08T02:55:07Z",
        "body": "这个自己先加个 try catch 处理下或者先用 IntentUtils.isIntentAvailable 处理下，下版本我会用返回值处理下是否找到"
      },
      {
        "user": "Blankj",
        "created_at": "2018-10-25T11:45:28Z",
        "body": "1.21.1 版本已加哈"
      }
    ]
  },
  {
    "number": 652,
    "title": "Toast弹不出来",
    "created_at": "2018-09-29T06:49:38Z",
    "closed_at": "2018-09-29T08:47:37Z",
    "labels": [
      "help wanted"
    ],
    "url": "https://github.com/Blankj/AndroidUtilCode/issues/652",
    "body": "最新1.20.3 版， ToastUtils 在部分小米手机上弹不出来Toast，例如 红米 Note 4x",
    "comments_url": "https://api.github.com/repos/Blankj/AndroidUtilCode/issues/652/comments",
    "author": "lks6123",
    "comments": [
      {
        "user": "Blankj",
        "created_at": "2018-09-29T06:55:16Z",
        "body": "前两天也有人反应这个问题，我手头没相关机器，你有空的话帮我打断点调试下吧，主要是 ToastUtils 下面这段代码，看看 `identifier` 有没有找到，我觉得是这个问题\r\n```java\r\nprivate static Toast makeNormalToast(Context context, CharSequence text, int duration) {\r\n    if (\"Xiaomi\".equals(Build.MANUFACTURER)) {\r\n        Toast toast = new Toast(context);\r\n        int identifier = Resources.getSystem()\r\n                .getIdentifier(\"transient_notification\", \"layout\", \"android\");\r\n        View view = getView(identifier);\r\n        toast.setView(view);\r\n        toast.setDuration(duration);\r\n        TextView tv = view.findViewById(android.R.id.message);\r\n        tv.setText(text);\r\n        return toast;\r\n    }\r\n    return Toast.makeText(context, text, duration);\r\n}\r\n```"
      },
      {
        "user": "Blankj",
        "created_at": "2018-09-29T08:47:15Z",
        "body": "试试 1.20.4 版本，已经解决了"
      }
    ]
  },
  {
    "number": 641,
    "title": "English version of Update Log",
    "created_at": "2018-09-18T21:53:27Z",
    "closed_at": "2018-09-19T05:44:12Z",
    "labels": [
      "help wanted"
    ],
    "url": "https://github.com/Blankj/AndroidUtilCode/issues/641",
    "body": "Hello!\r\n\r\nYour library is one of the most used, congratulations to the work.\r\n\r\nWhat do you think about creating a log version in English?\r\nMany of the users do not read Chinese 😉 \r\n\r\nI am not native English speaker (I am Brazilian), but I agree that English has become an international language.\r\nI like to follow the changelog of the projects I use, but in Chinese it gets complicated.\r\n\r\nThanks!!",
    "comments_url": "https://api.github.com/repos/Blankj/AndroidUtilCode/issues/641/comments",
    "author": "thiagotalma",
    "comments": [
      {
        "user": "Blankj",
        "created_at": "2018-09-19T02:05:42Z",
        "body": "Ok, I will do it."
      }
    ]
  },
  {
    "number": 600,
    "title": "建议：AppUtils新增签名获取",
    "created_at": "2018-08-16T10:36:33Z",
    "closed_at": "2018-08-26T07:11:20Z",
    "labels": [
      "help wanted"
    ],
    "url": "https://github.com/Blankj/AndroidUtilCode/issues/600",
    "body": "建议AppUtils类新增getAppSignatureSHA256、getAppSignatureMD5方法",
    "comments_url": "https://api.github.com/repos/Blankj/AndroidUtilCode/issues/600/comments",
    "author": "i11m20n",
    "comments": [
      {
        "user": "Blankj",
        "created_at": "2018-08-26T07:11:01Z",
        "body": "1.19.3 版本已新增"
      }
    ]
  },
  {
    "number": 595,
    "title": "CleanUtils.cleanInternalCache()后CacheDiskUtils数据无法写入",
    "created_at": "2018-08-14T06:05:51Z",
    "closed_at": "2018-08-23T14:56:12Z",
    "labels": [
      "help wanted"
    ],
    "url": "https://github.com/Blankj/AndroidUtilCode/issues/595",
    "body": "**The version of utilcode: 1.18.3**\r\n调用CleanUtils.cleanInternalCache();后，再去使用CacheDiskUtils出现数据无法写入的问题。\r\n跟踪发现这个方法会删除cacheUtils这个文件夹，\r\n而由于CACHE_MAP的存在，再去使用CacheDiskUtils.getInstance()并不会重新创建这个文件夹。\r\n建议在CacheDiskUtils.getInstance().clear()中同时清空CACHE_MAP。\r\n```java\r\npublic static CacheDiskUtils getInstance(@NonNull final File cacheDir,\r\n                                             final long maxSize,\r\n                                             final int maxCount) {\r\n        final String cacheKey = cacheDir.getAbsoluteFile() + \"_\" + maxSize + \"_\" + maxCount;\r\n        CacheDiskUtils cache = CACHE_MAP.get(cacheKey);\r\n        if (cache == null) {\r\n            if (!cacheDir.exists() && !cacheDir.mkdirs()) {\r\n                throw new RuntimeException(\"can't make dirs in \" + cacheDir.getAbsolutePath());\r\n            }\r\n            cache = new CacheDiskUtils(cacheKey, new DiskCacheManager(cacheDir, maxSize, maxCount));\r\n            CACHE_MAP.put(cacheKey, cache);\r\n        }\r\n        return cache;\r\n    }\r\n```",
    "comments_url": "https://api.github.com/repos/Blankj/AndroidUtilCode/issues/595/comments",
    "author": "congjinruo",
    "comments": [
      {
        "user": "Blankj",
        "created_at": "2018-08-14T09:27:39Z",
        "body": "已修改为如下实现，下版本会升级，建议你自己定义一个固定缓存路径用，用系统的话有些手机会不定时清理缓存导致缓存被清。\r\n```java\r\npublic static CacheDiskUtils getInstance(@NonNull final File cacheDir,\r\n                                         final long maxSize,\r\n                                         final int maxCount) {\r\n    final String cacheKey = cacheDir.getAbsoluteFile() + \"_\" + maxSize + \"_\" + maxCount;\r\n    if (cacheDir.exists()) {\r\n        CacheDiskUtils cache = CACHE_MAP.get(cacheKey);\r\n        if (cache == null) {\r\n            DiskCacheManager cacheManager = new DiskCacheManager(cacheDir, maxSize, maxCount);\r\n            cache = new CacheDiskUtils(cacheKey, cacheManager);\r\n            CACHE_MAP.put(cacheKey, cache);\r\n        }\r\n        return cache;\r\n    }\r\n    if (cacheDir.mkdirs()) {\r\n        DiskCacheManager cacheManager = new DiskCacheManager(cacheDir, maxSize, maxCount);\r\n        return CACHE_MAP.put(cacheKey, new CacheDiskUtils(cacheKey, cacheManager));\r\n    } else {\r\n        throw new RuntimeException(\"can't make dirs in \" + cacheDir.getAbsolutePath());\r\n    }\r\n}\r\n```"
      },
      {
        "user": "congjinruo",
        "created_at": "2018-08-14T12:00:14Z",
        "body": "好的，非常感谢大佬的代码，帮了很多忙。"
      },
      {
        "user": "Blankj",
        "created_at": "2018-08-23T14:56:02Z",
        "body": "1.19.1 已可用"
      },
      {
        "user": "scsfwgy",
        "created_at": "2018-11-13T03:59:11Z",
        "body": "v1.20.4\r\n\r\n`can't make dirs in /data/user/0/com.tophold.xcfd/cache/cacheUtils\r\n`\r\n\r\nj```\r\nava.lang.RuntimeException:can't make dirs in /data/user/0/com.tophold.xcfd/cache/cacheUtils\r\n--\r\n5 com.blankj.utilcode.util.CacheDiskUtils.com.blankj.utilcode.util.CacheDiskUtils getInstance(java.io.File,long,int)(CacheDiskUtils.java:147)\r\n6 com.blankj.utilcode.util.CacheDiskUtils.com.blankj.utilcode.util.CacheDiskUtils getInstance(java.lang.String,long,int)(CacheDiskUtils.java:105)\r\n7 com.blankj.utilcode.util.CacheDiskUtils.com.blankj.utilcode.util.CacheDiskUtils getInstance()(CacheDiskUtils.java:65)\r\n8 com.blankj.utilcode.util.CacheDoubleUtils.com.blankj.utilcode.util.CacheDoubleUtils getInstance()(CacheDoubleUtils.java:36)\r\n\r\n\r\n\r\n```\r\n\r\n@Blankj \r\n\r\n"
      },
      {
        "user": "scsfwgy",
        "created_at": "2018-11-13T04:22:48Z",
        "body": "会不会是多线程问题？比如两个线程同时调用getInstanc()方法.....\r\n@Blankj "
      },
      {
        "user": "scsfwgy",
        "created_at": "2018-11-13T04:56:54Z",
        "body": "测试出来的其它问题\r\n\r\nException in thread \"Thread-3\" Exception in thread \"Thread-2\" Exception in thread \"Thread-1\" Exception in thread \"Thread-0\" java.util.ConcurrentModificationException\r\n\tat android.support.v4.util.SimpleArrayMap.put(SimpleArrayMap.java:440)\r\n\tat com.blankj.utilcode.util.CacheMemoryUtils.getInstance(CacheMemoryUtils.java:56)\r\n\tat com.blankj.utilcode.util.CacheMemoryUtils.getInstance(CacheMemoryUtils.java:42)\r\n\tat com.blankj.utilcode.util.CacheMemoryUtils.getInstance(CacheMemoryUtils.java:32)\r\n\tat com.blankj.utilcode.util.CacheDoubleUtils.getInstance(CacheDoubleUtils.java:36)\r\n\r\n\r\n\r\n @Test\r\n    public void testCacheTest() {\r\n        System.out.println(\"--------\");\r\n        for (int i = 0; i < 5; i++) {\r\n            new Thread(new Runnable() {\r\n                @Override\r\n                public void run() {\r\n                    CacheDoubleUtils instance = CacheDoubleUtils.getInstance();\r\n                    Log.d(TAG, \"run: \"+instance);\r\n                    System.out.println(\"---->\"+instance);\r\n                    try {\r\n                        Thread.sleep(100);\r\n                    } catch (InterruptedException e) {\r\n                        e.printStackTrace();\r\n                    }\r\n                }\r\n            }).start();\r\n        }\r\n    }\r\n"
      },
      {
        "user": "Blankj",
        "created_at": "2018-11-13T05:24:48Z",
        "body": "这个我知道的，下版本会修复多线程的问题"
      },
      {
        "user": "scsfwgy",
        "created_at": "2018-11-14T02:45:58Z",
        "body": "@Blankj  有可能是多进程的问题，之前在Application中初始化的时候没注意，realm、还有你这个工具类都出现了问题，并且一般都是在极光的推送进程中出现了此问题。你可以测试一下。我这边也在测试。"
      }
    ]
  },
  {
    "number": 588,
    "title": "运营商判断有更新",
    "created_at": "2018-08-11T04:33:56Z",
    "closed_at": "2018-08-11T10:19:30Z",
    "labels": [
      "help wanted"
    ],
    "url": "https://github.com/Blankj/AndroidUtilCode/issues/588",
    "body": "移动：46000，46002，46007，46020；\r\n\r\n联通：46001，46006，46009；\r\n\r\n电信：46003，46005，46011；\r\n",
    "comments_url": "https://api.github.com/repos/Blankj/AndroidUtilCode/issues/588/comments",
    "author": "Khaos116",
    "comments": [
      {
        "user": "Blankj",
        "created_at": "2018-08-11T10:17:59Z",
        "body": "如果用 `PhoneUtils.getSimOperatorName` 可以获取到吗，你说的这个是用在 `PhoneUtils.getSimOperatorByMnc`，下版本会更新，感谢提供"
      },
      {
        "user": "Khaos116",
        "created_at": "2018-08-15T07:04:27Z",
        "body": "恩"
      }
    ]
  },
  {
    "number": 579,
    "title": "为IntentUtils新增检查Intent是否可用的方法",
    "created_at": "2018-08-08T05:47:47Z",
    "closed_at": "2018-08-08T08:45:49Z",
    "labels": [
      "help wanted"
    ],
    "url": "https://github.com/Blankj/AndroidUtilCode/issues/579",
    "body": "  实际使用中发现某些系统中无法使用Intent进行分享，建议为IntentUtils添加该方法用于检查intent是否可用\r\n\r\n    /**\r\n     * Check the Intent is Availeble\r\n     *\r\n     * @param intent The intent\r\n     * @return is Availeble\r\n     */\r\n    public static boolean isIntentAvaileble(Intent intent){\r\n        List resolves = getApp().getPackageManager().queryIntentActivities(intent,0);\r\n        return resolves.size()>0;\r\n    }",
    "comments_url": "https://api.github.com/repos/Blankj/AndroidUtilCode/issues/579/comments",
    "author": "XXQAQ",
    "comments": [
      {
        "user": "Blankj",
        "created_at": "2018-08-08T08:45:29Z",
        "body": "```java\r\n/**\r\n * Return whether the intent is available.\r\n *\r\n * @param intent The intent.\r\n * @return {@code true}: yes<br>{@code false}: no\r\n */\r\npublic static boolean isIntentAvailable(final Intent intent) {\r\n    return Utils.getApp().getPackageManager().queryIntentActivities(intent, 0).size() > 0;\r\n}\r\n```\r\n下版本加入吧，可以关注下个版本哦"
      }
    ]
  },
  {
    "number": 543,
    "title": "新增的CacheDiskUtil,新增key的时候，两个maxCount？是不是写误了？maxSize+maxCount？",
    "created_at": "2018-06-29T05:59:45Z",
    "closed_at": "2018-06-29T06:50:53Z",
    "labels": [
      "help wanted"
    ],
    "url": "https://github.com/Blankj/AndroidUtilCode/issues/543",
    "body": "新增的CacheDiskUtil,新增cacheKey的时候，两个maxCount？是不是写误了？maxSize+maxCount？\r\n原：\r\nfinal String cacheKey = cacheDir.getAbsoluteFile() + \"_\" + maxCount + \"_\" + maxCount;",
    "comments_url": "https://api.github.com/repos/Blankj/AndroidUtilCode/issues/543/comments",
    "author": "blackbai11",
    "comments": [
      {
        "user": "Blankj",
        "created_at": "2018-06-29T06:02:16Z",
        "body": "是的，下版本会修复"
      },
      {
        "user": "Blankj",
        "created_at": "2018-06-29T06:10:03Z",
        "body": "1.17.2 已可用"
      }
    ]
  },
  {
    "number": 497,
    "title": "ActivityUtils类中添加方法",
    "created_at": "2018-05-15T08:29:01Z",
    "closed_at": "2018-05-15T09:15:47Z",
    "labels": [
      "help wanted"
    ],
    "url": "https://github.com/Blankj/AndroidUtilCode/issues/497",
    "body": "ActivityUtils.java类中是否可以添加startActivityForResult的方法。",
    "comments_url": "https://api.github.com/repos/Blankj/AndroidUtilCode/issues/497/comments",
    "author": "XaXoYi369",
    "comments": [
      {
        "user": "Blankj",
        "created_at": "2018-05-15T09:15:34Z",
        "body": "已添加到 1.15.1"
      }
    ]
  },
  {
    "number": 480,
    "title": "ToastUtils的字体偏大，比较难看，建议可以选择显示默认字体大小",
    "created_at": "2018-05-03T07:32:03Z",
    "closed_at": "2018-05-03T07:51:49Z",
    "labels": [
      "help wanted"
    ],
    "url": "https://github.com/Blankj/AndroidUtilCode/issues/480",
    "body": "ToastUtils的字体偏大，比较难看，建议可以选择显示默认字体大小\r\n目前是通过如下方式实现了默认字体大小：\r\nToast toast = Toast.makeText(getApplicationContext(), \"\", Toast.LENGTH_SHORT);\r\nTextView textView = (TextView) toast.getView().findViewById(android.R.id.message);\r\nToastUtils.setMsgTextSize(SizeUtils.px2sp(textView.getTextSize()));",
    "comments_url": "https://api.github.com/repos/Blankj/AndroidUtilCode/issues/480/comments",
    "author": "zjhcode",
    "comments": [
      {
        "user": "Blankj",
        "created_at": "2018-05-03T07:51:33Z",
        "body": "升级 1.14.3 即可，之前设置字体样式留下来的 bug"
      }
    ]
  },
  {
    "number": 465,
    "title": "急急急 ！1.13.16 版本 xml 和别的 远程库冲突，1.13.15正常！求解！！！！",
    "created_at": "2018-04-23T09:51:15Z",
    "closed_at": "2018-04-23T11:27:27Z",
    "labels": [
      "help wanted"
    ],
    "url": "https://github.com/Blankj/AndroidUtilCode/issues/465",
    "body": "急急急 ！1.13.16 版本 xml 和别的 远程库冲突，1.13.15正常！求解！！！！",
    "comments_url": "https://api.github.com/repos/Blankj/AndroidUtilCode/issues/465/comments",
    "author": "chenenqiang12345",
    "comments": [
      {
        "user": "Blankj",
        "created_at": "2018-04-23T09:59:07Z",
        "body": "应该是你工程里有个 `provider_paths.xml` 文件，我改名了，换成 `util_provider_paths.xml`了，试试 1.13.17 吧"
      },
      {
        "user": "chenenqiang12345",
        "created_at": "2018-04-23T10:28:02Z",
        "body": "这干嘛用的 "
      },
      {
        "user": "Blankj",
        "created_at": "2018-04-23T10:41:45Z",
        "body": "自己靠搜索引擎去了解把"
      },
      {
        "user": "chenenqiang12345",
        "created_at": "2018-04-23T10:51:37Z",
        "body": "  api 'com.blankj:utilcode:+'\r\n    api 'com.jph.takephoto:takephoto_library:+'\r\n这 2个 冲突 你试下"
      },
      {
        "user": "Blankj",
        "created_at": "2018-04-23T11:20:16Z",
        "body": "使用 1.13.18，我已经测试过了"
      }
    ]
  },
  {
    "number": 463,
    "title": "PhoneUtils add listABIs()",
    "created_at": "2018-04-20T03:12:31Z",
    "closed_at": "2018-04-20T06:43:21Z",
    "labels": [
      "help wanted"
    ],
    "url": "https://github.com/Blankj/AndroidUtilCode/pull/463",
    "body": "获取优先支持哪些cpu架构",
    "comments_url": "https://api.github.com/repos/Blankj/AndroidUtilCode/issues/463/comments",
    "author": "ZQiang94",
    "comments": [
      {
        "user": "Blankj",
        "created_at": "2018-04-20T06:41:01Z",
        "body": "已加入到 DeviceUtils#getABIs， 引入 1.13.15 版本即可\r\n```java\r\n/**\r\n * Return an ordered list of ABIs supported by this device. The most preferred ABI is the first\r\n * element in the list.\r\n *\r\n * @return an ordered list of ABIs supported by this device\r\n */\r\npublic static String[] getABIs() {\r\n    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {\r\n        return Build.SUPPORTED_ABIS;\r\n    } else {\r\n        if (!TextUtils.isEmpty(Build.CPU_ABI2)) {\r\n            return new String[]{Build.CPU_ABI, Build.CPU_ABI2};\r\n        }\r\n        return new String[]{Build.CPU_ABI};\r\n    }\r\n}\r\n```"
      }
    ]
  },
  {
    "number": 459,
    "title": "建议增加 获取进程名称",
    "created_at": "2018-04-18T07:38:08Z",
    "closed_at": "2018-04-18T12:10:44Z",
    "labels": [
      "help wanted"
    ],
    "url": "https://github.com/Blankj/AndroidUtilCode/issues/459",
    "body": "getProcessName",
    "comments_url": "https://api.github.com/repos/Blankj/AndroidUtilCode/issues/459/comments",
    "author": "cymok",
    "comments": [
      {
        "user": "Blankj",
        "created_at": "2018-04-18T12:10:27Z",
        "body": "1.13.14 版本，Process#getCurrentProcessName"
      }
    ]
  },
  {
    "number": 458,
    "title": "关于新版SPUtils",
    "created_at": "2018-04-18T02:59:39Z",
    "closed_at": "2018-04-18T08:09:29Z",
    "labels": [
      "help wanted"
    ],
    "url": "https://github.com/Blankj/AndroidUtilCode/issues/458",
    "body": "你好，目前新版的spuitls是不是put的value不能为null了  \r\n同样的代码 我去年依赖的UtilCode项目put的value是null不报空指针\r\n昨天依赖了新版的utilCode然后用之前的代码 put的value为null就报空指针\r\n Caused by: java.lang.NullPointerException: Argument 'value' of type String (#1 out of 2, zero-based) is marked by @android.support.annotation.NonNull but got null for it\r\n  at com.blankj.utilcode.util.SPUtils.put(SPUtils.java:62)",
    "comments_url": "https://api.github.com/repos/Blankj/AndroidUtilCode/issues/458/comments",
    "author": "zhuzhao404",
    "comments": [
      {
        "user": "Blankj",
        "created_at": "2018-04-18T03:08:15Z",
        "body": "因为依赖了 apply plugin: \"tech.harmonysoft.oss.traute\"，导致有 @NonNull 注解的如果传入 null 会报错，我改一下注解吧"
      },
      {
        "user": "zhuzhao404",
        "created_at": "2018-04-18T03:10:57Z",
        "body": "哦 这样啊  我暂时判断了下是null就return了  防止报错  "
      },
      {
        "user": "zhuzhao404",
        "created_at": "2018-04-18T03:11:04Z",
        "body": "谢谢"
      },
      {
        "user": "Blankj",
        "created_at": "2018-04-18T08:09:20Z",
        "body": "你用最新版本吧 1.13.13"
      }
    ]
  },
  {
    "number": 440,
    "title": "ActivityUtils.startActivity(……) 方法抛出 NoSuchElementException 异常",
    "created_at": "2018-03-27T08:43:44Z",
    "closed_at": "2018-04-19T05:46:50Z",
    "labels": [
      "help wanted"
    ],
    "url": "https://github.com/Blankj/AndroidUtilCode/issues/440",
    "body": "当 Utils.sActivityList 的 size 为 0 时，ActivityUtils.startActivity(……) 方法将抛出 NoSuchElementException 异常；\r\n    public static void startActivity(@NonNull final Class<?> clz) {\r\n        Context context = getActivityOrApp();\r\n        startActivity(context, null, context.getPackageName(), clz.getName(), null);\r\n    }\r\n    private static Context getActivityOrApp() {\r\n        Activity topActivity = getTopActivity();\r\n        return topActivity == null ? Utils.getApp() : topActivity;\r\n    }\r\n    public static Activity getTopActivity() {\r\n        final Activity topActivity = Utils.getActivityList().getLast();\r\n        ……\r\n    }\r\n    public E getLast() {\r\n        final Node<E> l = last;\r\n        if (l == null)\r\n            throw new NoSuchElementException();\r\n        return l.item;\r\n    }",
    "comments_url": "https://api.github.com/repos/Blankj/AndroidUtilCode/issues/440/comments",
    "author": "JasonPiao",
    "comments": [
      {
        "user": "JasonPiao",
        "created_at": "2018-03-30T03:03:36Z",
        "body": "getActivityOrApp() 的逻辑可以改为，当 AppUtils.isAppForeground() == true 且 Utils.getActivityList() 不为 null、size 大于 0 时，使用 ActivityUtils.getTopActivity()，否则使用 Utils.getApp()；\r\n否则若 App 在后台运行，startActivity 会被系统忽略；部分设备固件对此做了兼容，但考虑到兼容性，在代码中处理更好；"
      },
      {
        "user": "Blankj",
        "created_at": "2018-04-08T03:06:39Z",
        "body": "那个异常我现在做了判断\r\n```java\r\n    public static Activity getTopActivity() {\r\n        final LinkedList<Activity> activityList = Utils.getActivityList();\r\n        if (activityList != null && activityList.size() > 0) {\r\n            final Activity topActivity = activityList.getLast();\r\n            if (topActivity != null) {\r\n                return topActivity;\r\n            }\r\n        }\r\n    ...\r\n    }\r\n```\r\n那判断前后台是为什么要加入？"
      },
      {
        "user": "JasonPiao",
        "created_at": "2018-04-08T03:14:58Z",
        "body": "若 App 在后台运行，通过 Activity 进行 startActivity 会被系统忽略；\r\n部分设备固件对此做了兼容，但考虑到兼容性，在代码中处理更好；"
      },
      {
        "user": "Blankj",
        "created_at": "2018-04-08T03:17:23Z",
        "body": "通过 Activity 进行 startActivity 会被系统忽略确定不是因为 NoSuchElementException 异常吗，确定不是的话那我就改成你说的。"
      },
      {
        "user": "Blankj",
        "created_at": "2018-04-08T11:52:08Z",
        "body": "你试试最新版本 1.13.8"
      },
      {
        "user": "hujxhed",
        "created_at": "2021-04-20T14:35:37Z",
        "body": "getActivityList 1.25.9 和最新版本，返回数据的顺序是不是变化了？"
      }
    ]
  },
  {
    "number": 435,
    "title": "PermissionUtils.request() 方法跨进程调用问题",
    "created_at": "2018-03-20T07:01:02Z",
    "closed_at": "2018-03-21T02:58:50Z",
    "labels": [
      "help wanted"
    ],
    "url": "https://github.com/Blankj/AndroidUtilCode/issues/435",
    "body": "在子进程中使用 PermissionUtils.request() 不生效；\r\n从代码判断，PermissionActivity 是默认在主进程运行；\r\nPermissionUtils.sInstance 每个进程中都有一个，因此跨进程调用时无法获取到；\r\n建议把权限参数通过 Intent 来传递；\r\n        @Override\r\n        protected void onCreate(@Nullable Bundle savedInstanceState) {\r\n            if (sInstance.mThemeCallback != null) {\r\n                sInstance.mThemeCallback.onActivityCreate(this);\r\n            }\r\n            super.onCreate(savedInstanceState);\r\n\r\n            if (sInstance.rationale(this)) {\r\n                finish();\r\n                return;\r\n            }\r\n            if (sInstance.mPermissionsRequest != null) {\r\n                int size = sInstance.mPermissionsRequest.size();\r\n                if (size <= 0) return;\r\n                requestPermissions(sInstance.mPermissionsRequest.toArray(new String[size]), 1);\r\n            }\r\n        }",
    "comments_url": "https://api.github.com/repos/Blankj/AndroidUtilCode/issues/435/comments",
    "author": "JasonPiao",
    "comments": [
      {
        "user": "Blankj",
        "created_at": "2018-03-20T07:54:43Z",
        "body": "那你在子进程初始化工具类了吗？这调用和进程没关系的吧，你一个进程可以，那另一个进程肯定也是可以的。"
      },
      {
        "user": "JasonPiao",
        "created_at": "2018-03-20T08:17:01Z",
        "body": "两个进程都初始化过工具类，在主进程调用 request() 成功，在子进程调用 request() 失败；\r\n问题所在已经贴出来了；\r\n在子进程调用 request() 时，由于 PermissionActivity 运行在主进程，因此 onCreate 方法里获取到的 PermissionUtils.sInstance 是主进程的，mPermissionsRequest 始终为空；\r\n不如你动手试试；"
      },
      {
        "user": "JasonPiao",
        "created_at": "2018-03-20T08:34:13Z",
        "body": "        <activity\r\n            android:name=\"com.blankj.utilcode.util.PermissionUtils$PermissionActivity\"\r\n            android:configChanges=\"orientation|keyboardHidden|screenSize\"\r\n            android:process=\":pbx\"\r\n            android:theme=\"@style/ActivityTranslucent\"\r\n            android:windowSoftInputMode=\"stateHidden|stateAlwaysHidden\"/>\r\n验证过手动指定 PermissionActivity 所在进程后，在子进程中申请权限是成功的；\r\n相对地，在主进程中申请权限就无效了；\r\n建议把权限参数通过 Intent 来传递；"
      },
      {
        "user": "JasonPiao",
        "created_at": "2018-03-20T08:41:14Z",
        "body": "另外 1.13.4 版本测试权限为空时，PermissionActivity 会以透明界面的形式显示；\r\n建议权限为空时把 PermissionActivity finish() 掉；"
      },
      {
        "user": "Blankj",
        "created_at": "2018-03-20T17:00:52Z",
        "body": "我说怎么会出现 PermissionActivity 中 mPermissionsRequest 的 size 为 0 的情况。现在解决了已经，\r\n用 1.13.5 版本即可，PermissionActivity 增加 `android:multiprocess=\"true\"` 属性即可，你说的那种方式对于接口是无法序列化的，所以实现不了。"
      },
      {
        "user": "JasonPiao",
        "created_at": "2018-03-21T00:30:27Z",
        "body": "ok，thanks；\r\nandroid:multiprocess=\"true\"\r\n有这个配置，学到了；"
      }
    ]
  },
  {
    "number": 353,
    "title": "NetworkUtils能增加一个移动数据网络是否可用的方法吗",
    "created_at": "2017-12-23T03:27:19Z",
    "closed_at": "2017-12-28T08:27:08Z",
    "labels": [
      "help wanted"
    ],
    "url": "https://github.com/Blankj/AndroidUtilCode/issues/353",
    "body": "```\r\n    public static boolean isMobileConnected(Context context) {\r\n        if (context != null) {\r\n            //获取手机所有连接管理对象(包括对wi-fi,net等连接的管理)\r\n            ConnectivityManager manager = (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);\r\n            //获取NetworkInfo对象\r\n            NetworkInfo networkInfo = manager.getActiveNetworkInfo();\r\n            //判断NetworkInfo对象是否为空 并且类型是否为MOBILE\r\n            if (null != networkInfo && networkInfo.getType() == ConnectivityManager.TYPE_MOBILE)\r\n                return networkInfo.isAvailable();\r\n        }\r\n        return false;\r\n    }\r\n```",
    "comments_url": "https://api.github.com/repos/Blankj/AndroidUtilCode/issues/353/comments",
    "author": "conghuahuadan",
    "comments": [
      {
        "user": "Blankj",
        "created_at": "2017-12-23T14:11:25Z",
        "body": "下版本会有 `isMobileData`"
      },
      {
        "user": "Blankj",
        "created_at": "2017-12-28T08:26:44Z",
        "body": "已更新 请查看"
      }
    ]
  },
  {
    "number": 341,
    "title": "IntentUtils类下的相机getCaptureIntent方法获取的相机意图，跳转相机还没拍照，onActivityResult就回调。",
    "created_at": "2017-12-14T09:29:47Z",
    "closed_at": "2018-01-12T03:03:16Z",
    "labels": [
      "help wanted"
    ],
    "url": "https://github.com/Blankj/AndroidUtilCode/issues/341",
    "body": "在onActivityResult回调无法获取到图片",
    "comments_url": "https://api.github.com/repos/Blankj/AndroidUtilCode/issues/341/comments",
    "author": "chenyiyao",
    "comments": [
      {
        "user": "Blankj",
        "created_at": "2017-12-14T09:35:14Z",
        "body": "你 Activity 是 singleTask 模式？"
      },
      {
        "user": "chenyiyao",
        "created_at": "2017-12-14T09:39:03Z",
        "body": "@Blankj 不是的，是获取的意向中添加了Intent.FLAG_ACTIVITY_NEW_TASK这个标签。去掉这个就没问题了"
      },
      {
        "user": "Blankj",
        "created_at": "2017-12-14T09:40:08Z",
        "body": "嗯，5.0 以下的机器会这样，5.0 以后的就没事，我写个是否 new task 的参数吧。"
      },
      {
        "user": "chenyiyao",
        "created_at": "2017-12-14T09:49:52Z",
        "body": "@Blankj 我用的是魅族pro6 是7.0的"
      },
      {
        "user": "Blankj",
        "created_at": "2017-12-14T09:58:19Z",
        "body": "机器不一样吧，哈哈，下个版本会改。"
      },
      {
        "user": "Blankj",
        "created_at": "2017-12-28T09:49:21Z",
        "body": "新版本已发布，已修复哈"
      }
    ]
  },
  {
    "number": 338,
    "title": "正则更新",
    "created_at": "2017-12-14T02:09:50Z",
    "closed_at": "2017-12-14T07:13:10Z",
    "labels": [
      "help wanted"
    ],
    "url": "https://github.com/Blankj/AndroidUtilCode/issues/338",
    "body": "柯基好，\r\n中国移动新增了198开头的号码选择，中国联通则是166开头，中国电信是199开头。\r\n`RegexConstants` 中的 `REGEX_MOBILE_EXACT` 正则要更新一下。 \r\n`^((13[0-9])|(14[5,7])|(15[0-3,5-9])|(17[0,1,3,5-8])|(18[0-9])|(166)|(199)|(198)|(147))\\\\d{8}$`\r\n/**\r\n     * 正则：手机号（精确）\r\n     * <p>移动：134(0-8)、135、136、137、138、139、147、150、151、152、157、158、159、178、182、183、184、187、188</p>\r\n     * <p>联通：130、131、132、145、155、156、171、175、176、185、186</p>\r\n     * <p>电信：133、153、173、177、180、181、189</p>\r\n     * <p>全球星：1349</p>\r\n     * <p>虚拟运营商：170</p>\r\n     */\r\n    public static final String REGEX_MOBILE_EXACT  = \"^((13[0-9])|(14[5,7])|(15[0-3,5-9])|(17[0,1,3,5-8])|(18[0-9])|(147))\\\\d{8}$\";",
    "comments_url": "https://api.github.com/repos/Blankj/AndroidUtilCode/issues/338/comments",
    "author": "zenchen3331",
    "comments": [
      {
        "user": "Blankj",
        "created_at": "2017-12-14T02:31:42Z",
        "body": "已更新 1.9.12 版本"
      }
    ]
  },
  {
    "number": 323,
    "title": "建议将EmptyUtil里判断String的部分换为CharSequence",
    "created_at": "2017-11-28T09:07:12Z",
    "closed_at": "2017-11-28T09:19:32Z",
    "labels": [
      "help wanted"
    ],
    "url": "https://github.com/Blankj/AndroidUtilCode/issues/323",
    "body": "出现了一个bug，当传递进来的对象是CharSequence时，isEmpty失效，建议将String换成接口类CharSequence",
    "comments_url": "https://api.github.com/repos/Blankj/AndroidUtilCode/issues/323/comments",
    "author": "jiezigg",
    "comments": [
      {
        "user": "Blankj",
        "created_at": "2017-11-28T09:09:44Z",
        "body": "好哒，感谢"
      }
    ]
  },
  {
    "number": 321,
    "title": "ImageUtils添加一个给图片增加图层颜色的方法",
    "created_at": "2017-11-24T16:57:30Z",
    "closed_at": "2018-03-21T04:29:57Z",
    "labels": [
      "help wanted"
    ],
    "url": "https://github.com/Blankj/AndroidUtilCode/pull/321",
    "body": "",
    "comments_url": "https://api.github.com/repos/Blankj/AndroidUtilCode/issues/321/comments",
    "author": "yogkin",
    "comments": [
      {
        "user": "Blankj",
        "created_at": "2018-03-21T04:29:36Z",
        "body": "已加入 ImageUtils#drawColor "
      }
    ]
  },
  {
    "number": 302,
    "title": "添加shell返回换行",
    "created_at": "2017-10-31T07:52:33Z",
    "closed_at": "2017-10-31T08:10:36Z",
    "labels": [
      "help wanted"
    ],
    "url": "https://github.com/Blankj/AndroidUtilCode/pull/302",
    "body": "shell结果换行。\r\n之前的结果会将shell返回后的字符串拼接在一起，如果使用ls 、ps等这样的命令导致输出的文件夹都拼接在一起无法友好的查看，也不符合命令输出的格式。",
    "comments_url": "https://api.github.com/repos/Blankj/AndroidUtilCode/issues/302/comments",
    "author": "BolexLiu",
    "comments": [
      {
        "user": "Blankj",
        "created_at": "2017-10-31T08:02:17Z",
        "body": "好的，使用 `System.getProperty(\"line.separator\");`更好哦"
      },
      {
        "user": "BolexLiu",
        "created_at": "2017-10-31T08:02:28Z",
        "body": "@Blankj  这个脚本检测是哪里出错了，没有看懂。"
      },
      {
        "user": "BolexLiu",
        "created_at": "2017-10-31T08:06:15Z",
        "body": "好的。我改下"
      },
      {
        "user": "Blankj",
        "created_at": "2017-10-31T08:08:34Z",
        "body": "我也不太清楚，An error occurred while generating the build script. 中文问题？"
      },
      {
        "user": "Blankj",
        "created_at": "2017-10-31T08:10:47Z",
        "body": "我把换行符和文件分割符都写在`Utils`里了，然后把以前用到的都替换掉。"
      }
    ]
  },
  {
    "number": 301,
    "title": "screen demo里注释错了",
    "created_at": "2017-10-31T02:08:15Z",
    "closed_at": "2017-10-31T03:01:30Z",
    "labels": [
      "help wanted"
    ],
    "url": "https://github.com/Blankj/AndroidUtilCode/issues/301",
    "body": "小问题",
    "comments_url": "https://api.github.com/repos/Blankj/AndroidUtilCode/issues/301/comments",
    "author": "Bradmrhong",
    "comments": [
      {
        "user": "Blankj",
        "created_at": "2017-10-31T02:29:07Z",
        "body": "ok"
      }
    ]
  },
  {
    "number": 297,
    "title": "关于ImageUtils.getBitmap(InputStream, int, int)方法",
    "created_at": "2017-10-25T03:32:26Z",
    "closed_at": "2017-10-25T04:01:52Z",
    "labels": [
      "help wanted"
    ],
    "url": "https://github.com/Blankj/AndroidUtilCode/issues/297",
    "body": "这个方法使用了两次流,第二次使用的是一个无效流，返回的Bitmap总是null",
    "comments_url": "https://api.github.com/repos/Blankj/AndroidUtilCode/issues/297/comments",
    "author": "FrankKwok",
    "comments": [
      {
        "user": "Blankj",
        "created_at": "2017-10-25T03:38:14Z",
        "body": "是的，流只能用一次"
      },
      {
        "user": "Blankj",
        "created_at": "2017-10-25T03:57:55Z",
        "body": "好的，我已经改了，新版本1.9.5"
      }
    ]
  },
  {
    "number": 296,
    "title": "Log边框问题",
    "created_at": "2017-10-24T09:43:33Z",
    "closed_at": "2017-10-25T04:01:34Z",
    "labels": [
      "help wanted"
    ],
    "url": "https://github.com/Blankj/AndroidUtilCode/issues/296",
    "body": "设置setBorderSwitch(false)之后,log依然有个边框1.9.3版本",
    "comments_url": "https://api.github.com/repos/Blankj/AndroidUtilCode/issues/296/comments",
    "author": "sweet2o09",
    "comments": [
      {
        "user": "Blankj",
        "created_at": "2017-10-24T13:58:47Z",
        "body": "已发现，明日修复"
      },
      {
        "user": "Blankj",
        "created_at": "2017-10-25T03:00:51Z",
        "body": "已发布新版本"
      }
    ]
  },
  {
    "number": 285,
    "title": "(建议)关于判断App是否已经安装的局限性",
    "created_at": "2017-09-29T07:37:15Z",
    "closed_at": "2017-10-01T10:10:55Z",
    "labels": [
      "help wanted"
    ],
    "url": "https://github.com/Blankj/AndroidUtilCode/issues/285",
    "body": "首先 , 感谢大神提供了这个工具, 使用起来非常方便, 其中, 我在使用过程中发现了一些局限, 注意,只是说局限,不是缺陷什么的, 因为像我这样的需求还是比较少的;\r\n源码中,判断应用是否已经安装主要是通过是否有启动的Intent去判断的\r\n`!isSpace(packageName) && IntentUtils.getLaunchAppIntent(packageName) != null;`\r\n但是, 我现在有一个项目, 需求是判断一个服务框架是否已经安装, 由于这个服务框架只有一个NoDisplay的Activity和一些Service组成,不需要桌面图标, 所以没有\r\n`<category android:name=\"android.intent.category.LAUNCHER\"/>`属性\r\n(我的项目是把LAUNCHER改为DEFAULT了,Action也改了)\r\n那么问题就在这里, 我这样肯定是获取不到LaunchIntent的, 最终结果就是我的App已经安装了,但是工具的判断为false,导致了一些问题;\r\n\r\n所以,我建议是否考虑添加一个根据action和Category字符串得到ResolveInfo 是否非空的方法去判断App是否安装\r\n下面贴上我自己的相关代码:\r\n`Intent intent = new Intent(ACTION_STRING);`\r\n`intent.addCategory(Intent.CATEGORY_DEFAULT);`\r\n`PackageManager pm = getPackageManager();`\r\n`ResolveInfo info = pm.resolveActivity(intent, 0);`\r\n`if (info != null) {`\r\n`// 软件已安装`\r\n`} else {`\r\n`//软件未安装`",
    "comments_url": "https://api.github.com/repos/Blankj/AndroidUtilCode/issues/285/comments",
    "author": "xiexindev",
    "comments": [
      {
        "user": "Blankj",
        "created_at": "2017-09-29T08:33:35Z",
        "body": "ok，下版本会有"
      },
      {
        "user": "Blankj",
        "created_at": "2017-10-01T10:10:40Z",
        "body": "已更新"
      }
    ]
  },
  {
    "number": 278,
    "title": "ActivityUtils中的finishAllActivities()方法有错",
    "created_at": "2017-09-21T07:38:27Z",
    "closed_at": "2017-09-26T08:46:59Z",
    "labels": [
      "help wanted"
    ],
    "url": "https://github.com/Blankj/AndroidUtilCode/issues/278",
    "body": "    /**\r\n     * 结束所有activity\r\n     */\r\n    public static void finishAllActivities() {\r\n        List<Activity> activityList = Utils.sActivityList;\r\n        for (int i = activityList.size() - 1; i >= 0; --i) {\r\n            activityList.get(i).finish();\r\n            **activityList.remove(i);**\r\n        }\r\n    }\r\n\r\n集合在遍历时不能修改 会报错：ConcurrentModificationException",
    "comments_url": "https://api.github.com/repos/Blankj/AndroidUtilCode/issues/278/comments",
    "author": "LJW123",
    "comments": [
      {
        "user": "Blankj",
        "created_at": "2017-09-21T08:29:01Z",
        "body": "我把remove去掉就行了，生命周期里走了remove了，下个版本更新"
      },
      {
        "user": "Blankj",
        "created_at": "2017-09-26T08:46:51Z",
        "body": "1.9.1已解决"
      }
    ]
  },
  {
    "number": 275,
    "title": "CrashUtils自定义路径",
    "created_at": "2017-09-18T06:50:33Z",
    "closed_at": "2017-09-27T04:12:34Z",
    "labels": [
      "help wanted"
    ],
    "url": "https://github.com/Blankj/AndroidUtilCode/issues/275",
    "body": "CrashUtils自定义路径遇到崩溃没有退出app，程序一直卡着，而且文件没有写入自定义的路径，默认可以；\r\nCrashUtils.init(ConstantsValue.CRASH_DIR);//自定义的不可用\r\nCrashUtils.init();//可以使用",
    "comments_url": "https://api.github.com/repos/Blankj/AndroidUtilCode/issues/275/comments",
    "author": "zhuzhao404",
    "comments": [
      {
        "user": "Blankj",
        "created_at": "2017-09-20T06:52:16Z",
        "body": "有个地方写错了变量，下个版本就好"
      },
      {
        "user": "flyjin",
        "created_at": "2017-09-23T03:11:29Z",
        "body": "没有什么友好的提示 "
      },
      {
        "user": "Blankj",
        "created_at": "2017-09-26T09:07:01Z",
        "body": "@zhuzhao404 1.9.1已解决"
      }
    ]
  },
  {
    "number": 274,
    "title": "FragmentUtils的addFragment再hideAllShowFragment之后,实测切换fragment会跳闪，切换不顺滑。",
    "created_at": "2017-09-15T10:21:44Z",
    "closed_at": "2017-10-25T05:37:33Z",
    "labels": [
      "help wanted"
    ],
    "url": "https://github.com/Blankj/AndroidUtilCode/issues/274",
    "body": "",
    "comments_url": "https://api.github.com/repos/Blankj/AndroidUtilCode/issues/274/comments",
    "author": "pcxjsl",
    "comments": [
      {
        "user": "Blankj",
        "created_at": "2017-09-16T10:40:35Z",
        "body": "先隐藏再显示呢"
      },
      {
        "user": "pcxjsl",
        "created_at": "2017-09-18T03:52:35Z",
        "body": "都试过了，最后自己写开启同一个FragmentTransaction切换是没问题的，我看了源码，猜测哦，源码里是开启了不同FragmentTransaction导致的吧。"
      },
      {
        "user": "Blankj",
        "created_at": "2017-09-20T02:50:19Z",
        "body": "你调用两个函数的话那就是启动两个事务"
      },
      {
        "user": "pcxjsl",
        "created_at": "2017-09-20T03:09:26Z",
        "body": "那这样不就有问题吗？切换跳闪很明显，应该要让它们这些函数在一个事务里操作就切换顺滑，肉眼没感觉。"
      },
      {
        "user": "Blankj",
        "created_at": "2017-09-20T03:17:17Z",
        "body": "你是要实现什么？"
      },
      {
        "user": "pcxjsl",
        "created_at": "2017-09-20T03:19:53Z",
        "body": "就是简单的一个activity上面点击底部radiobutton， show，hide ，Fragment哦~"
      },
      {
        "user": "Blankj",
        "created_at": "2017-09-20T03:20:40Z",
        "body": "不是有个hideShowFragment么"
      },
      {
        "user": "pcxjsl",
        "created_at": "2017-09-20T03:27:37Z",
        "body": "我好像试过这个方法的，都不行~ 一般都是先hideAll再show点击那个fragment，hideShowFragment要传一个oldFragment? 你去试验一下吧，我再去试试看。"
      },
      {
        "user": "Blankj",
        "created_at": "2017-10-25T04:02:34Z",
        "body": "可以试试新版本啦，已修改"
      }
    ]
  },
  {
    "number": 270,
    "title": "把sActivityList暴露出来吧",
    "created_at": "2017-09-07T06:32:33Z",
    "closed_at": "2017-09-26T09:08:28Z",
    "labels": [
      "help wanted"
    ],
    "url": "https://github.com/Blankj/AndroidUtilCode/issues/270",
    "body": "Utils里面的sActivityList是否可以暴露出来，因为这边会有对Activity堆栈进行一些特殊的管理，既然有了就不先再重复了。",
    "comments_url": "https://api.github.com/repos/Blankj/AndroidUtilCode/issues/270/comments",
    "author": "SjAndy88",
    "comments": [
      {
        "user": "SjAndy88",
        "created_at": "2017-09-07T06:33:41Z",
        "body": "\r\n// Activity堆栈管理\r\npublic class ActivityManager {\r\n    private static volatile ActivityManager mInstance;\r\n\r\n    public List<Activity> getActivityLists() {\r\n        return mActivityList;\r\n    }\r\n\r\n    private static List<Activity> mActivityList;\r\n\r\n    private ActivityManager() {\r\n        mActivityList = ActivityUtils.getActivityList();\r\n    }\r\n\r\n    public static ActivityManager getInstance() {\r\n        if (mInstance == null) {\r\n            synchronized (ActivityManager.class) {\r\n                if (mInstance == null) {\r\n                    mInstance = new ActivityManager();\r\n                }\r\n            }\r\n        }\r\n        return mInstance;\r\n    }\r\n\r\n    // 入栈\r\n    public void addActivity(Activity activity) {\r\n        mActivityList.add(activity);\r\n    }\r\n\r\n    // 出栈\r\n    public void removeActivity(Activity activity) {\r\n        mActivityList.remove(activity);\r\n    }\r\n\r\n    //  彻底退出\r\n    public void finishAllActivity() {\r\n        ActivityUtils.finishAllActivities();\r\n    }\r\n\r\n    // 结束指定类名的Activity\r\n    public void finishActivity(Class<? extends Activity> cls) {\r\n        for (Activity activity : mActivityList) {\r\n            if (activity.getClass().equals(cls)) {\r\n                finishActivity(activity);\r\n            }\r\n        }\r\n    }\r\n\r\n    // 查找栈中是否存在指定的activity\r\n    public boolean checkActivity(Class<?> cls) {\r\n        for (Activity activity : mActivityList) {\r\n            if (activity.getClass().equals(cls)) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    // 结束指定的Activity\r\n    public void finishActivity(Activity activity) {\r\n        if (activity != null) {\r\n            activity.finish();\r\n            activity.overridePendingTransition(0, 0);\r\n        }\r\n    }\r\n\r\n    // finish指定的activity之上所有的activity\r\n    public boolean finishToActivity(Class<? extends Activity> actCls, boolean isIncludeSelf) {\r\n        List<Activity> buf = new ArrayList<>();\r\n        int size = mActivityList.size();\r\n        Activity activity;\r\n        for (int i = size - 1; i >= 0; i--) {\r\n            activity = mActivityList.get(i);\r\n            if (activity.getClass().isAssignableFrom(actCls)) {\r\n                for (Activity a : buf) {\r\n                    finishActivity(a);\r\n                }\r\n                return true;\r\n            } else if (i == size - 1 && isIncludeSelf) {\r\n                buf.add(activity);\r\n            } else if (i != size - 1) {\r\n                buf.add(activity);\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    // finish除最新activity之外所有的同类型activity\r\n    public void finishOthersActivity(Class<? extends Activity> cls) {\r\n        boolean findCur = false;\r\n        int size = mActivityList.size();\r\n        for (int i = size - 1; i >= 0; i--) {\r\n            Activity activity = mActivityList.get(i);\r\n            if (activity.getClass().equals(cls)) {\r\n                if (!findCur) {\r\n                    findCur = true;\r\n                } else {\r\n                    finishActivity(activity);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"
      },
      {
        "user": "SjAndy88",
        "created_at": "2017-09-07T06:34:49Z",
        "body": "// 结束指定的Activity\r\npublic void finishActivity(Activity activity) {\r\n    if (activity != null) {\r\n        activity.finish();\r\n        activity.overridePendingTransition(0, 0);\r\n    }\r\n}\r\n\r\n不需要自己主动remove，以为ActivityLifecycleCallbacks会在onActivityDestroyed回调中remove"
      },
      {
        "user": "Blankj",
        "created_at": "2017-09-26T09:08:03Z",
        "body": "@flztsj 1.9.1已可使用"
      }
    ]
  },
  {
    "number": 266,
    "title": "APP审核不通过（3.2.9 包含厌恶信息检测）",
    "created_at": "2017-09-01T07:39:16Z",
    "closed_at": "2017-09-05T02:12:57Z",
    "labels": [
      "help wanted"
    ],
    "url": "https://github.com/Blankj/AndroidUtilCode/issues/266",
    "body": "我在一个POS机项目中使用这个工具库，提交对方审核提示有两处没有通过审核要求：\r\n\r\n建议：希望能避免敏感词会出现\r\n\r\n敏感词：u can\\'t fuck me...(出现次数:3)\r\n文件：com/blankj/utilcode/utils/IntentUtils.smali\r\n\r\n该应用中存在私自拨打电话或者发送短信等行为【1】处。\r\n--\r\n1敏感词：android.intent.action.CALL文件：com/blankj/utilcode/utils/IntentUtils.smali\r\n\r\n",
    "comments_url": "https://api.github.com/repos/Blankj/AndroidUtilCode/issues/266/comments",
    "author": "zhuozuoying",
    "comments": [
      {
        "user": "Blankj",
        "created_at": "2017-09-01T07:41:26Z",
        "body": "ok，这个类疏漏了"
      },
      {
        "user": "jp1017",
        "created_at": "2017-09-01T07:42:26Z",
        "body": ":cry: "
      }
    ]
  },
  {
    "number": 262,
    "title": "请问我的缓存文件为何获取到总是0",
    "created_at": "2017-08-29T06:54:25Z",
    "closed_at": "2017-08-30T07:27:06Z",
    "labels": [
      "help wanted"
    ],
    "url": "https://github.com/Blankj/AndroidUtilCode/issues/262",
    "body": "请问cacheUtils.getInstance()是获取android/data/包名/cache中所有的缓存包括文件夹里的吗？\r\n我用这个方法获取到的缓存一直都为0\r\n我在cache文件里有一个叫xBitmapCache的文件夹，里面有3个文件，我用cacheUtils.getInstance(\"xBitmapCache\")获取到的缓存依然是0\r\n不是很理解，求解\r\n",
    "comments_url": "https://api.github.com/repos/Blankj/AndroidUtilCode/issues/262/comments",
    "author": "HeJingWei",
    "comments": [
      {
        "user": "HeJingWei",
        "created_at": "2017-08-29T07:43:48Z",
        "body": "我怎么才能每次都获取到android/data/包名/cache下的缓存  然后实现清理缓存的功能呢？"
      },
      {
        "user": "Blankj",
        "created_at": "2017-08-29T07:49:44Z",
        "body": "因为是异步计算吧，你延迟会去获取就不是0了，之后我搞个回调吧。"
      },
      {
        "user": "HeJingWei",
        "created_at": "2017-08-29T08:01:07Z",
        "body": " 那我用cacheUtils.getInstance()获取到的是android/data/包名/cache中所有的缓存吗，包括所有文件夹下的吗？"
      },
      {
        "user": "Blankj",
        "created_at": "2017-08-29T08:05:42Z",
        "body": "你用我的CacheUtils存缓存怎么会存文件夹？只能获取文件，你要获取文件大小那就用FileUtils"
      },
      {
        "user": "HeJingWei",
        "created_at": "2017-08-29T08:13:28Z",
        "body": "好的"
      },
      {
        "user": "Blankj",
        "created_at": "2017-08-30T06:40:11Z",
        "body": "已修复此bug，现在异步获取size就可以了，同步的话会卡哦"
      },
      {
        "user": "HeJingWei",
        "created_at": "2017-08-30T07:26:00Z",
        "body": "好的哈！辛苦了"
      },
      {
        "user": "candrwow",
        "created_at": "2017-12-26T03:11:37Z",
        "body": "@Blankj 你好，CacheUtils.getInstance().getCacheSize()方法仍然获取到的是0，是需要其他配置吗，在主线程或是rxjava的异步里结果都是0，设置里获取到的cache是有几兆的，设备是模拟器"
      },
      {
        "user": "Blankj",
        "created_at": "2017-12-26T03:12:27Z",
        "body": "用最新版本读写，你要搞清楚这个缓存并不是安卓的缓存"
      },
      {
        "user": "candrwow",
        "created_at": "2017-12-26T03:26:07Z",
        "body": "@Blankj 这边之前使用的1.9.10,现在替换了1.9.12，实体机和模拟器仍然是0，实体机上在系统设置里看到的缓存大小是304k，"
      },
      {
        "user": "Blankj",
        "created_at": "2017-12-26T03:27:02Z",
        "body": "设置里的缓存和我这个缓存不是一个东西啊  大哥"
      },
      {
        "user": "candrwow",
        "created_at": "2017-12-26T03:42:36Z",
        "body": "我看到cache就以为是系统缓存，理解错了。3Q"
      }
    ]
  },
  {
    "number": 261,
    "title": "Toast一直按就会一会弹",
    "created_at": "2017-08-29T01:45:49Z",
    "closed_at": "2017-08-31T06:47:15Z",
    "labels": [
      "help wanted"
    ],
    "url": "https://github.com/Blankj/AndroidUtilCode/issues/261",
    "body": "Toast一直按就会一会弹",
    "comments_url": "https://api.github.com/repos/Blankj/AndroidUtilCode/issues/261/comments",
    "author": "CookerMa",
    "comments": [
      {
        "user": "Blankj",
        "created_at": "2017-08-29T02:19:54Z",
        "body": "？什么意思"
      },
      {
        "user": "CookerMa",
        "created_at": "2017-08-29T07:14:57Z",
        "body": "Toast 每次按都会重复弹"
      },
      {
        "user": "Blankj",
        "created_at": "2017-08-29T07:46:04Z",
        "body": "toast弱引用问题，我在想办法改"
      },
      {
        "user": "Blankj",
        "created_at": "2017-08-30T06:40:48Z",
        "body": "已修复此bug"
      }
    ]
  },
  {
    "number": 258,
    "title": "ToastUtils显示的字体没法被改变",
    "created_at": "2017-08-28T01:33:34Z",
    "closed_at": "2017-08-31T06:47:24Z",
    "labels": [
      "help wanted"
    ],
    "url": "https://github.com/Blankj/AndroidUtilCode/issues/258",
    "body": "使用反射更改App的默认字体，发现ToastUtils弹出的字体不会被改变",
    "comments_url": "https://api.github.com/repos/Blankj/AndroidUtilCode/issues/258/comments",
    "author": "SjAndy88",
    "comments": [
      {
        "user": "Blankj",
        "created_at": "2017-08-28T02:15:57Z",
        "body": "你setCustomView或者用spannable都可以修改字体"
      },
      {
        "user": "SjAndy88",
        "created_at": "2017-08-28T02:31:25Z",
        "body": "没理解"
      },
      {
        "user": "Blankj",
        "created_at": "2017-08-28T02:33:11Z",
        "body": "Toast可以自定义视图，你自己传个已经设置字体的layout进去，spannable的话自己查吧"
      },
      {
        "user": "SjAndy88",
        "created_at": "2017-08-28T02:35:11Z",
        "body": "不是单个换字体，现在是App全局换字体，而且只是简单的Toast 每次还得set layout。。"
      },
      {
        "user": "SjAndy88",
        "created_at": "2017-08-28T02:59:39Z",
        "body": "@Blankj 为什么不能debug？"
      },
      {
        "user": "sooner0493",
        "created_at": "2017-08-30T06:17:01Z",
        "body": "自定义视图我看源码里并没有给text赋值的地方。。。"
      },
      {
        "user": "Blankj",
        "created_at": "2017-08-30T06:18:41Z",
        "body": "你自定义View里不会自己放个TextView吗"
      }
    ]
  },
  {
    "number": 254,
    "title": "ToastUtils 被检测到内存泄露",
    "created_at": "2017-08-25T07:30:00Z",
    "closed_at": "2017-08-27T12:49:24Z",
    "labels": [
      "help wanted"
    ],
    "url": "https://github.com/Blankj/AndroidUtilCode/issues/254",
    "body": "ToastUtils的静态成员变量sToast内存泄漏。是调用自定义Toast那个方法后触发的。\r\n检测持有Toast.mNextView，引用到了自定义Toast View的上下文，导致调用该工具的Activity没法释放。感觉还是静态成员变量的锅。\r\n",
    "comments_url": "https://api.github.com/repos/Blankj/AndroidUtilCode/issues/254/comments",
    "author": "JingleDingDang",
    "comments": [
      {
        "user": "zhuhj8",
        "created_at": "2017-08-25T07:33:16Z",
        "body": "本工具的ToastUtils没有使用Activity实例，使用的applicationcontext"
      },
      {
        "user": "Blankj",
        "created_at": "2017-08-25T07:35:45Z",
        "body": "我Toast引用的自定义View是弱引用啦，不会泄漏的，你找个我代码泄漏的地方我看看"
      },
      {
        "user": "Blankj",
        "created_at": "2017-08-25T07:36:07Z",
        "body": "@heroPool 你咋这么快"
      },
      {
        "user": "zhuhj8",
        "created_at": "2017-08-25T07:38:12Z",
        "body": "是，使用的weaklyActivity，"
      },
      {
        "user": "Blankj",
        "created_at": "2017-08-30T06:36:51Z",
        "body": "@JingleDingDang 已修复内存泄露bug，引起的原因是由于你给sToast设置了自定义View，在Activity退出的时候View还在sToast中引用着没有销毁，所以导致了Activity泄露。"
      },
      {
        "user": "Blankj",
        "created_at": "2017-08-31T02:34:53Z",
        "body": "@JingleDingDang 你传入的view肯定和activiy生命周期相绑定，如下\r\n``` java\r\nLayoutInflater.from(xxActivity).inflate(layout, null);\r\n```\r\n这样的话会造成泄露。\r\n但如果你把xxActivity改成application就没事了"
      }
    ]
  },
  {
    "number": 213,
    "title": "手机号码验证格式错误",
    "created_at": "2017-07-05T06:32:04Z",
    "closed_at": "2017-08-02T08:59:49Z",
    "labels": [
      "help wanted"
    ],
    "url": "https://github.com/Blankj/AndroidUtilCode/issues/213",
    "body": "171打头的联通手机号，用正则表达式，无法验证通过。",
    "comments_url": "https://api.github.com/repos/Blankj/AndroidUtilCode/issues/213/comments",
    "author": "tingmaa",
    "comments": [
      {
        "user": "Blankj",
        "created_at": "2017-07-05T06:51:13Z",
        "body": "这个手机号是不断增多的，所以我也不可能一直追赶上进度，需要你们自己更新哈，我更新肯定没你那快，我下版本就加上171的"
      }
    ]
  },
  {
    "number": 210,
    "title": "一点小小的建议",
    "created_at": "2017-06-24T06:53:59Z",
    "closed_at": "2017-07-05T04:27:10Z",
    "labels": [
      "help wanted"
    ],
    "url": "https://github.com/Blankj/AndroidUtilCode/issues/210",
    "body": "作者你好，感谢你开源的这个项目，对我的工作效率非常大，但我也有一些建议希望采纳：\r\n由于工作需要用到cacheutils 我从之前的版本升级到1.7.1，发现其中有许多变动的地方：\r\n1. SpUtils 获取方式变化 ,导致我整个项目的SpUtils都需要变化。\r\n2. sputils.get(String , String ),以前没有值则是获取的null，现在却是“”。导致我代码许多判断都失效。\r\n3.  SpannableStringUtils改名为SpanUtils，并且其中的一些方法名也修改\r\n\r\n1.3点提示报错还好，第2点没有任何提示，看了源码才发现，希望作者对于第2点这样的情况考虑变动的影响，或者在文档中提示，同时考虑一下方法修改形式对于以前集成开发者的影响，谢谢！",
    "comments_url": "https://api.github.com/repos/Blankj/AndroidUtilCode/issues/210/comments",
    "author": "Fitem",
    "comments": [
      {
        "user": "YunlongYang",
        "created_at": "2017-06-24T12:19:20Z",
        "body": "1.作者把null改成\"\"就是不想返回空指针出异常\r\n2.判断字符串为空最好用TextUtils.isEmpty来判断\r\n3.当你的代码有很多地方在判断同一个值，怎么不统一成一个方法呢"
      },
      {
        "user": "Blankj",
        "created_at": "2017-06-24T14:56:43Z",
        "body": "不好意思哈，给你带来了不便，有些东西都是在不断优化的，当你修改版本号了，或多或少是会出现这种错误，而且我用新函数替代了老函数一般都不加过时注解，不过一般都是朝好的方面发展的，而且改动一般也不是很大。\r\n\r\n根据你的问题我可以给你提几个你可以吸取的建议，SpUtils你用的时候自己可以再封装一层，那样只需要修改你自己封装的那一层即可，而且SP操作都应该放在同一个地方一般，第二点的话 @YunlongYang 已经帮我回答了，或者你可以用我的StringUtils解决，第三点的话函数名改了的话全剧替换一下吧只能。\r\n\r\n不过，你升级版本只是要用到CacheUtils，那么为何不把这个类拷出来即可呢，哈哈。"
      },
      {
        "user": "Fitem",
        "created_at": "2017-06-25T13:17:16Z",
        "body": "首先感觉楼上两位周末花时间的解答！在此感谢两位！！！\r\n\r\n想一想确实是自己的问题：\r\n第一，太依赖了第三方库，没有考虑到第三方库版本更新或者替换第三方库的情况\r\n第二，没有对可能会经常出现的代码进行一个统一的管理，这些问题自己以后都要注意。\r\n\r\n对于函数名的变更我也是用的全局替换（顺带一提AS的全局查找预览真的很赞！），至于TextUtils我还是经常用的(QAQ)。\r\n\r\n最后，祝作者的utils库越来越火，我是从简书到Github，从开始的6K到11K Star的见证者(ZZZ)"
      },
      {
        "user": "jp1017",
        "created_at": "2017-06-25T13:23:35Z",
        "body": ":+1: "
      }
    ]
  },
  {
    "number": 136,
    "title": "SpannableStringUtils设置字体大小单位",
    "created_at": "2017-02-16T03:56:40Z",
    "closed_at": "2017-04-22T00:50:55Z",
    "labels": [
      "help wanted"
    ],
    "url": "https://github.com/Blankj/AndroidUtilCode/issues/136",
    "body": "大神怎么没有设置字体大小单位的API？有时一行文字大小会各不同，如此：\r\nspannableString.setSpan(new AbsoluteSizeSpan(textSize, true), start, end, Spanned.SPAN_INCLUSIVE_EXCLUSIVE);",
    "comments_url": "https://api.github.com/repos/Blankj/AndroidUtilCode/issues/136/comments",
    "author": "hxxxxxxxk",
    "comments": [
      {
        "user": "Blankj",
        "created_at": "2017-02-16T04:03:41Z",
        "body": "setProportion，你说的那我也下版本也加进去哈"
      },
      {
        "user": "hxxxxxxxk",
        "created_at": "2017-02-16T05:09:54Z",
        "body": "@Blankj 有看到，setProportion使用的是RelativeSizeSpan，我觉得AbsoluteSizeSpan自由度更好些，期待新版本~~~"
      }
    ]
  },
  {
    "number": 135,
    "title": "一些小建议，还望采纳",
    "created_at": "2017-02-15T02:46:17Z",
    "closed_at": "2017-07-07T11:24:44Z",
    "labels": [
      "help wanted"
    ],
    "url": "https://github.com/Blankj/AndroidUtilCode/issues/135",
    "body": "1.`IntentUtils`中的`getInstallAppIntent(File file)`方法，其中\"com.your.package.fileProvider\"里面的package是可以拿到的吧，所以这里是不是还没有改过来？\r\n\r\n```java\r\nUri contentUri = FileProvider.getUriForFile(Utils.getContext(), \"com.your.package.fileProvider\", file);\r\n```\r\n\r\n2.`SDCardUtils`中的`getSDCardPath`方法，个人感觉在sd卡不在的时候返回null比返回\"sdcard unable!\"好些，否则调用方拿到一个非null非空的字符串可能会以为路径存在，同理这个类中的其他方法也建议返回null。\r\n\r\n```java\r\npublic static String getSDCardPath() {\r\n        if (!isSDCardEnable()) return null;//\"sdcard unable!\"\r\n        //...\r\n}\r\n```\r\n\r\n3.`PhoneUtils`中`getPhoneStatus`方法里面`PhoneType`拼写有笔误，漏了`P`\r\n\r\n4.`SizeUtils`中`mListener`成员变量可以不用定义，也就是下面几句可以不用，`forceGetViewSize`方法调用的时候会传入listener\r\n\r\n```java\r\npublic static void setListener(onGetSizeListener listener) {\r\n  mListener = listener;\r\n}\r\n\r\nprivate static onGetSizeListener mListener;\r\n```\r\n\r\n最后，再次感谢你的分享。\r\n",
    "comments_url": "https://api.github.com/repos/Blankj/AndroidUtilCode/issues/135/comments",
    "author": "javayhu",
    "comments": [
      {
        "user": "Blankj",
        "created_at": "2017-02-15T14:24:10Z",
        "body": "感谢你的建议哈，下版本会更新哈"
      },
      {
        "user": "Blankj",
        "created_at": "2017-02-16T04:05:49Z",
        "body": "@wrightakencom  welcome"
      }
    ]
  },
  {
    "number": 132,
    "title": "SPUtils put方法修改为重载，开发者无需关心put是什么类型",
    "created_at": "2017-02-10T09:05:35Z",
    "closed_at": "2017-07-07T11:10:09Z",
    "labels": [
      "help wanted"
    ],
    "url": "https://github.com/Blankj/AndroidUtilCode/pull/132",
    "body": "",
    "comments_url": "https://api.github.com/repos/Blankj/AndroidUtilCode/issues/132/comments",
    "author": "DanteAndroid",
    "comments": [
      {
        "user": "Blankj",
        "created_at": "2017-02-10T09:56:16Z",
        "body": ":rofl: 你就一定要把我sp改掉，好吧好吧，就听你的，下个版本会更新的，另外的我也会选择性地提交上去的，多谢你的pr哈"
      },
      {
        "user": "DanteAndroid",
        "created_at": "2017-02-10T10:06:29Z",
        "body": "谢老哥，第一次pr"
      },
      {
        "user": "a1067111756",
        "created_at": "2017-06-06T15:10:10Z",
        "body": "可以添加一个SP保存参数是集合类型数据的方法，网上采取的方案是先json化保存，取出来在数组化。希望能添加进去"
      },
      {
        "user": "Blankj",
        "created_at": "2017-06-07T04:50:27Z",
        "body": "@a1067111756 sp干嘛保存那么麻烦的，用cacheUtils即可"
      },
      {
        "user": "a1067111756",
        "created_at": "2017-07-05T11:44:45Z",
        "body": "因为想把数据持久化保存，但数据并不大，不想用数据库或者存储到本地文件"
      },
      {
        "user": "Blankj",
        "created_at": "2017-07-06T01:59:06Z",
        "body": "sp也是存入文件，一样的道理，而且还有大小限制。"
      }
    ]
  },
  {
    "number": 125,
    "title": "SDCardUtils下获取SD卡路径在Android 6.0以上存在兼容性问题",
    "created_at": "2017-01-18T03:24:30Z",
    "closed_at": "2017-11-30T02:55:14Z",
    "labels": [
      "help wanted"
    ],
    "url": "https://github.com/Blankj/AndroidUtilCode/issues/125",
    "body": "自己测试在三星 S7 Edge（Android 6.0）下，执行cat /proc/mounts，返回的数据里有包含sdcard的数据，但是里面不包含android_secure，但是手机是已经插入了外置SD卡的。因此使用你那种方法在这个手机上是无法正常获取到路径的；然而Environment.getExternalStorageDirectory().getPath() + File.separator返回的也不是正确的路径。推荐作者在6.0以上使用反射的方式去反射android.os.storage.DiskInfo判断存储设备的类型和反射android.os.storage.VolumeInfo.GetPath去获取其对应的路径。",
    "comments_url": "https://api.github.com/repos/Blankj/AndroidUtilCode/issues/125/comments",
    "author": "panden",
    "comments": [
      {
        "user": "panden",
        "created_at": "2017-01-18T03:32:25Z",
        "body": "以下是在三星 S7 Edge（Android 6.0）下执行cat /proc/mounts后返回的数据：\r\nrootfs / rootfs ro,seclabel,size=1662316k,nr_inodes=415579 0 0\r\ntmpfs /dev tmpfs rw,seclabel,nosuid,relatime,size=1734720k,nr_inodes=433680,mode=755 0 0\r\ndevpts /dev/pts devpts rw,seclabel,relatime,mode=600 0 0\r\nnone /dev/cpuctl cgroup rw,relatime,cpu 0 0\r\nadb /dev/usb-ffs/adb functionfs rw,relatime 0 0\r\nproc /proc proc rw,relatime 0 0\r\nsysfs /sys sysfs rw,seclabel,relatime 0 0\r\nselinuxfs /sys/fs/selinux selinuxfs rw,relatime 0 0\r\ndebugfs /sys/kernel/debug debugfs rw,seclabel,relatime 0 0\r\nnone /sys/fs/cgroup tmpfs rw,seclabel,relatime,size=1734720k,nr_inodes=433680,mode=750,gid=1000 0 0\r\nnone /acct cgroup rw,relatime,cpuacct 0 0\r\ntmpfs /mnt tmpfs rw,seclabel,relatime,size=1734720k,nr_inodes=433680,mode=755,gid=1000 0 0\r\ntmpfs /mnt/secure tmpfs rw,seclabel,relatime,size=1734720k,nr_inodes=433680,mode=700 0 0\r\ntmpfs /mnt/secure/asec tmpfs rw,seclabel,relatime,size=1734720k,nr_inodes=433680,mode=700 0 0\r\n/data/knox/tmp_sdcard /mnt/knox sdcardfs rw,seclabel,nosuid,nodev,relatime,mask=0077 0 0\r\n/data/knox/sdcard /mnt/knox/default/knox-emulated sdcardfs rw,seclabel,nosuid,nodev,relatime,low_uid=1000,low_gid=1000,gid=9997,multi_user,mask=0006 0 0\r\n/data/knox/sdcard /mnt/knox/read/knox-emulated sdcardfs rw,seclabel,nosuid,nodev,relatime,low_uid=1000,low_gid=1000,gid=9997,multi_user,mask=0027 0 0\r\n/data/knox/sdcard /mnt/knox/write/knox-emulated sdcardfs rw,seclabel,nosuid,nodev,relatime,low_uid=1000,low_gid=1000,gid=9997,multi_user,mask=0007 0 0\r\n/data/knox/secure_fs/enc_media /mnt/shell/enc_media sdcardfs rw,seclabel,nosuid,nodev,relatime,low_uid=1000,low_gid=1000,gid=9997,multi_user,reserved=20MB 0 0\r\n/data/media /mnt/runtime/default/emulated sdcardfs rw,seclabel,nosuid,nodev,noexec,relatime,low_uid=1023,low_gid=1023,gid=1015,multi_user,mask=0006,reserved=20MB 0 0\r\n/data/media /mnt/runtime/read/emulated sdcardfs rw,seclabel,nosuid,nodev,noexec,relatime,low_uid=1023,low_gid=1023,gid=9997,multi_user,mask=0027,reserved=20MB 0 0\r\n/data/media /mnt/runtime/write/emulated sdcardfs rw,seclabel,nosuid,nodev,noexec,relatime,low_uid=1023,low_gid=1023,gid=9997,multi_user,mask=0007,reserved=20MB 0 0\r\n/dev/block/vold/public:179,1 /mnt/media_rw/5699-0226 vfat rw,dirsync,nosuid,nodev,noexec,noatime,nodiratime,uid=1023,gid=1023,fmask=0007,dmask=0007,allow_utime=0020,codepage=437,iocharset=iso8859-1,shortname=mixed,utf8,errors=remount-ro 0 0\r\n/mnt/media_rw/5699-0226 /mnt/runtime/default/5699-0226 sdcardfs rw,seclabel,nosuid,nodev,noexec,relatime,low_uid=1023,low_gid=1023,gid=1015,mask=0006 0 0\r\n/mnt/media_rw/5699-0226 /mnt/runtime/read/5699-0226 sdcardfs rw,seclabel,nosuid,nodev,noexec,relatime,low_uid=1023,low_gid=1023,gid=9997,mask=0022 0 0\r\n/mnt/media_rw/5699-0226 /mnt/runtime/write/5699-0226 sdcardfs rw,seclabel,nosuid,nodev,noexec,relatime,low_uid=1023,low_gid=1023,gid=9997,mask=0022 0 0\r\n/mnt/shell/enc_media /mnt/shell/enc_emulated ecryptfs rw,seclabel,nodev,relatime,ecryptfs_fnek_sig=692023e47af0fd70,ecryptfs_sig=692023e47af0fd70,userid=0,sdp_enabled,partition_id=1,ecryptfs_cipher=aes,ecryptfs_key_bytes=32,ecryptfs_enable_cc,ecryptfs_passthrough,base=,label= 0 0\r\n/dev/block/dm-0 /system ext4 ro,seclabel,relatime,norecovery 0 0\r\n/dev/block/bootdevice/by-name/efs /efs ext4 rw,seclabel,nosuid,nodev,noatime,discard,journal_checksum,journal_async_commit,noauto_da_alloc,data=ordered 0 0\r\n/dev/block/bootdevice/by-name/cache /cache ext4 rw,seclabel,nosuid,nodev,noatime,discard,journal_checksum,journal_async_commit,noauto_da_alloc,data=ordered 0 0\r\n/dev/block/bootdevice/by-name/persist /persist ext4 rw,seclabel,nosuid,nodev,noatime,discard,journal_checksum,journal_async_commit,noauto_da_alloc,data=ordered 0 0\r\n/dev/block/bootdevice/by-name/dsp /dsp ext4 rw,seclabel,nosuid,nodev,relatime,data=ordered 0 0\r\n/dev/block/bootdevice/by-name/apnhlos /firmware vfat ro,context=u:object_r:firmware_file:s0,relatime,uid=1000,gid=1000,fmask=0337,dmask=0227,codepage=437,iocharset=iso8859-1,shortname=lower,errors=remount-ro 0 0\r\n/dev/block/bootdevice/by-name/modem /firmware-modem vfat ro,context=u:object_r:firmware_file:s0,relatime,uid=1000,gid=1000,fmask=0337,dmask=0227,codepage=437,iocharset=iso8859-1,shortname=lower,errors=remount-ro 0 0\r\n/dev/block/bootdevice/by-name/persdata /persdata/absolute ext4 rw,seclabel,nosuid,nodev,relatime,data=ordered 0 0\r\n/dev/block/dm-1 /data ext4 rw,seclabel,nosuid,nodev,noatime,discard,journal_checksum,journal_async_commit,noauto_da_alloc,debug_bdinfo,data=ordered 0 0\r\n/data/knox/secure_fs/enc_user /data/enc_user ecryptfs rw,seclabel,nodev,relatime,ecryptfs_fnek_sig=692023e47af0fd70,ecryptfs_sig=692023e47af0fd70,userid=0,sdp_enabled,partition_id=0,ecryptfs_cipher=aes,ecryptfs_key_bytes=32,ecryptfs_enable_cc,ecryptfs_passthrough,base=,label= 0 0\r\ntmpfs /storage tmpfs rw,seclabel,relatime,size=1734720k,nr_inodes=433680,mode=755,gid=1000 0 0\r\n/data/media /storage/emulated sdcardfs rw,seclabel,nosuid,nodev,noexec,relatime,low_uid=1023,low_gid=1023,gid=9997,multi_user,mask=0007,reserved=20MB 0 0\r\n/mnt/media_rw/5699-0226 /storage/5699-0226 sdcardfs rw,seclabel,nosuid,nodev,noexec,relatime,low_uid=1023,low_gid=1023,gid=9997,mask=0022 0 0\r\ntmpfs /storage/self tmpfs rw,seclabel,relatime,size=1734720k,nr_inodes=433680,mode=755,gid=1000 0 0"
      },
      {
        "user": "Blankj",
        "created_at": "2017-01-18T03:33:29Z",
        "body": "6.0还没完善呢，之后会完善的"
      },
      {
        "user": "panden",
        "created_at": "2017-01-18T03:39:00Z",
        "body": "这个是自己用过的一个在Android 6.0以上去获取路径的代码，作者可以参考下；\r\n `//API 23 Android 6.0 获取外置SD卡和USB设备的路径,能获取外置和usb设备的路径\r\n    private String getStoragePath23(Context context, boolean isUsb){\r\n\r\n        String path=\"\";\r\n\r\n        if(Build.VERSION.SDK_INT<23)return path;\r\n\r\n\r\n        StorageManager mStorageManager = (StorageManager) context.getSystemService(Context.STORAGE_SERVICE);\r\n        Class<?> volumeInfoClazz=null;\r\n        Class<?> diskInfoClaszz=null;\r\n\r\n        try {\r\n            volumeInfoClazz = Class.forName(\"android.os.storage.VolumeInfo\");\r\n            diskInfoClaszz = Class.forName(\"android.os.storage.DiskInfo\");\r\n\r\n            Method StorageManager_getVolumes=Class.forName(\"android.os.storage.StorageManager\").getMethod(\"getVolumes\");\r\n            Method VolumeInfo_GetDisk = volumeInfoClazz.getMethod(\"getDisk\");\r\n            Method VolumeInfo_GetPath = volumeInfoClazz.getMethod(\"getPath\");\r\n            Method DiskInfo_IsUsb = diskInfoClaszz.getMethod(\"isUsb\");\r\n            Method DiskInfo_IsSd = diskInfoClaszz.getMethod(\"isSd\");\r\n\r\n            List<Object> List_VolumeInfo = (List<Object>) StorageManager_getVolumes.invoke(mStorageManager);\r\n            for(int i=0; i<List_VolumeInfo.size(); i++){\r\n                Object volumeInfo = List_VolumeInfo.get(i);\r\n                Object diskInfo = VolumeInfo_GetDisk.invoke(volumeInfo);\r\n\r\n\r\n                if(diskInfo==null)continue;\r\n\r\n                boolean sd= (boolean) DiskInfo_IsSd.invoke(diskInfo);\r\n                boolean usb= (boolean) DiskInfo_IsUsb.invoke(diskInfo);\r\n\r\n                File file= (File) VolumeInfo_GetPath.invoke(volumeInfo);\r\n               // Logger.d(\"diskinfo=\"+file.getAbsolutePath()+\"; is_usb=\"+usb+\";  is_sd=\"+sd);\r\n\r\n                if(isUsb == usb){//usb\r\n                    path=file.getAbsolutePath();\r\n                    break;\r\n                }else if(!isUsb == sd){//sd\r\n                    path=file.getAbsolutePath();\r\n                    break;\r\n                }\r\n\r\n            }\r\n\r\n        } catch (ClassNotFoundException e) {\r\n            e.printStackTrace();\r\n        } catch (NoSuchMethodException e) {\r\n            e.printStackTrace();\r\n        } catch (InvocationTargetException e) {\r\n            e.printStackTrace();\r\n        } catch (IllegalAccessException e) {\r\n            e.printStackTrace();\r\n        }\r\n        return path;\r\n    }`"
      },
      {
        "user": "Blankj",
        "created_at": "2017-01-18T10:58:51Z",
        "body": ":+1: "
      },
      {
        "user": "wanghc0",
        "created_at": "2017-03-22T14:09:03Z",
        "body": "已经加上去了吗?\r\n怎么使用呢?"
      },
      {
        "user": "moter",
        "created_at": "2017-06-05T07:48:00Z",
        "body": "@panden 你的这个方法也存在局限性，在小米6.0系统上亲测不适用。我参考了很多大神的，现在用的方法如下\r\npublic static List<String> getExtSDCardPath(Context context) {\r\n        StorageManager storageManager = (StorageManager) context.getSystemService(Context\r\n                .STORAGE_SERVICE);\r\n        ArrayList<String> paths = new ArrayList<String>();\r\n        String rootPath = Environment.getExternalStorageDirectory().getAbsolutePath();\r\n        try {\r\n            Class<?>[] paramClasses = {};\r\n            Method getVolumePathsMethod = StorageManager.class.getMethod(\"getVolumePaths\", paramClasses);\r\n            getVolumePathsMethod.setAccessible(true);\r\n            Object[] params = {};\r\n            Object invoke = getVolumePathsMethod.invoke(storageManager, params);\r\n            paths = new ArrayList<String>(Arrays.asList((String[]) invoke));\r\n        } catch (NoSuchMethodException e1) {\r\n            e1.printStackTrace();\r\n        } catch (IllegalArgumentException e) {\r\n            e.printStackTrace();\r\n        } catch (IllegalAccessException e) {\r\n            e.printStackTrace();\r\n        } catch (InvocationTargetException e) {\r\n            e.printStackTrace();\r\n        }\r\n        if (!paths.contains(rootPath))\r\n            paths.add(0, rootPath);\r\n        return paths;\r\n    }"
      }
    ]
  },
  {
    "number": 95,
    "title": "东西很全，但是有个建议",
    "created_at": "2016-12-08T08:04:10Z",
    "closed_at": "2016-12-22T03:38:17Z",
    "labels": [
      "help wanted"
    ],
    "url": "https://github.com/Blankj/AndroidUtilCode/issues/95",
    "body": "首先感谢作者的辛苦劳动。但是这个库有个地方我很不满意，就是竟然没有context free。就是可以提供一个init接口，初始化application的context，这样很多只要求application的context的utils就可以不用传入context。\r\n例如`SPUtils`我想保存东西发现竟然不能直接调用静态方法。（以防不知道，有一个`PreferenceManager.getDefaultSharedPreferences()\r\n`方法可以传入application的context）\r\n另外，\r\n```\r\n    public void putInt(String key, int value) {\r\n        editor.putInt(key, value).apply();\r\n    }\r\n    public void putString(String key, String value) {\r\n        editor.putString(key, value).apply();\r\n    }\r\n\r\n```\r\n竟然没有使用重载，也许我too young，实在无法理解。",
    "comments_url": "https://api.github.com/repos/Blankj/AndroidUtilCode/issues/95/comments",
    "author": "DanteAndroid",
    "comments": [
      {
        "user": "jp1017",
        "created_at": "2016-12-08T08:06:14Z",
        "body": "> 竟然没有使用重载，也许我too young，实在无法理解。\r\n\r\n怎么重载？？？"
      },
      {
        "user": "DanteAndroid",
        "created_at": "2016-12-08T08:50:50Z",
        "body": "```\r\n    public static void save(String key, String value) {\r\n        editor.putString(key, value);\r\n        editor.apply();\r\n    }\r\n    public static void save(String key, boolean value) {\r\n        editor.putBoolean(key, value);\r\n        editor.apply();\r\n    }\r\n    public static void save(String key, int value) {\r\n        editor.putInt(key, value);\r\n        editor.apply();\r\n    }\r\n```\r\n这是我写的util，这样一个save 方法，根据需要传入int、String、bool都可以。"
      },
      {
        "user": "Blankj",
        "created_at": "2016-12-08T13:19:33Z",
        "body": "@DanteAndroid 第一个提议不错， 第二个你虽然save可以有很多重载，但是取呢，还是得写成我这样的，可以参考Bundle的读写亦是如此。"
      },
      {
        "user": "DanteAndroid",
        "created_at": "2016-12-09T02:35:34Z",
        "body": "取我知道不能写重载啊。。谢谢采纳。"
      },
      {
        "user": "Blankj",
        "created_at": "2016-12-09T02:37:28Z",
        "body": "@DanteAndroid 所以为了对称，不然看着舒服吗"
      },
      {
        "user": "jp1017",
        "created_at": "2016-12-09T02:41:42Z",
        "body": "> 所以为了对称，不然看着舒服吗\r\n\r\n强迫症重度患者"
      },
      {
        "user": "Blankj",
        "created_at": "2016-12-09T02:44:01Z",
        "body": "@jp1017 这也是设计之美，不然谷歌为啥不把Bundle的put和SP原生的put封装为一个save哈"
      },
      {
        "user": "jp1017",
        "created_at": "2016-12-09T02:53:08Z",
        "body": "> 这也是设计之美\r\n\r\n这波我服 :+1: :smile: "
      },
      {
        "user": "DanteAndroid",
        "created_at": "2016-12-09T07:19:23Z",
        "body": "@Blankj 说为了对称，我没意见。但是后面举例感觉完全不是一回事。官方提供的方法本来就该是低耦合的，不会帮你封装太多的"
      },
      {
        "user": "Blankj",
        "created_at": "2016-12-09T07:25:58Z",
        "body": "仁者见仁智者见智吧"
      },
      {
        "user": "Blankj",
        "created_at": "2016-12-22T03:38:10Z",
        "body": "@DanteAndroid 已加入`Utils.init(context);`来初始化"
      }
    ]
  },
  {
    "number": 88,
    "title": "PinyinUtil 里无法识别部分汉字",
    "created_at": "2016-11-29T09:58:11Z",
    "closed_at": "2016-12-22T03:37:11Z",
    "labels": [
      "help wanted"
    ],
    "url": "https://github.com/Blankj/AndroidUtilCode/issues/88",
    "body": "用该工具类，会将覃，邝，闫，滕，邬等大量姓氏识别为 “zuo” ",
    "comments_url": "https://api.github.com/repos/Blankj/AndroidUtilCode/issues/88/comments",
    "author": "Camsson",
    "comments": [
      {
        "user": "FloHin",
        "created_at": "2016-12-01T18:53:12Z",
        "body": "I would be eager to help, but i don't understand "
      },
      {
        "user": "huzhicheng1993",
        "created_at": "2016-12-02T08:01:25Z",
        "body": "岑 cen 的首字母会识别为z。以前做个汉字转拼音，因为存在多音字所以或多或少存在问题（做一些特殊处理），有一个库叫做pinyi4j倒是挺好用的。"
      },
      {
        "user": "Blankj",
        "created_at": "2016-12-02T08:03:26Z",
        "body": "@huzhicheng1993 那个我知道，我不想引进jar包，常用的可以解决就好了，多音字的话就要加多音字的一个集合，后续等我完善吧"
      },
      {
        "user": "Blankj",
        "created_at": "2016-12-22T03:37:04Z",
        "body": "@Camsson 现在试试，已经更新了哦，简繁体都可以"
      }
    ]
  },
  {
    "number": 87,
    "title": "CrashUtils的bug",
    "created_at": "2016-11-25T07:10:23Z",
    "closed_at": "2016-12-03T04:28:55Z",
    "labels": [
      "help wanted"
    ],
    "url": "https://github.com/Blankj/AndroidUtilCode/issues/87",
    "body": "保存日志文件时，文件名以时间命名(yyyy-MM-dd HH:mm:ss),会报异常；文件名中不能出现“：”",
    "comments_url": "https://api.github.com/repos/Blankj/AndroidUtilCode/issues/87/comments",
    "author": "liuh",
    "comments": [
      {
        "user": "Blankj",
        "created_at": "2016-11-30T12:56:02Z",
        "body": "虽然我不是报异常，但查看文件名确实有问题，我下个版本把\":\"换成其他可以用的"
      }
    ]
  },
  {
    "number": 81,
    "title": "DeviceUtils 可以加入重启到recovery 、重启到fastboot",
    "created_at": "2016-11-11T08:31:28Z",
    "closed_at": "2016-11-23T10:24:10Z",
    "labels": [
      "help wanted"
    ],
    "url": "https://github.com/Blankj/AndroidUtilCode/issues/81",
    "body": "",
    "comments_url": "https://api.github.com/repos/Blankj/AndroidUtilCode/issues/81/comments",
    "author": "BroganGrow",
    "comments": [
      {
        "user": "Blankj",
        "created_at": "2016-11-12T11:55:16Z",
        "body": "已加，下次更新会显示\n"
      },
      {
        "user": "jp1017",
        "created_at": "2016-11-12T11:57:02Z",
        "body": "> 已加，下次更新会显示\n\n厉害了啊`博览科技`\n"
      }
    ]
  },
  {
    "number": 79,
    "title": "AppUtils可以加个获取app的入口activity名称",
    "created_at": "2016-11-01T08:08:41Z",
    "closed_at": "2016-11-23T10:24:10Z",
    "labels": [
      "help wanted"
    ],
    "url": "https://github.com/Blankj/AndroidUtilCode/issues/79",
    "body": "",
    "comments_url": "https://api.github.com/repos/Blankj/AndroidUtilCode/issues/79/comments",
    "author": "BroganGrow",
    "comments": [
      {
        "user": "Blankj",
        "created_at": "2016-11-12T16:32:18Z",
        "body": "已加在ActivityUtils中，下版更新\n"
      }
    ]
  },
  {
    "number": 75,
    "title": "FileUtils可加入修改文件、文件夹名称的方法",
    "created_at": "2016-10-29T05:56:24Z",
    "closed_at": "2016-10-31T10:25:56Z",
    "labels": [
      "help wanted"
    ],
    "url": "https://github.com/Blankj/AndroidUtilCode/issues/75",
    "body": "",
    "comments_url": "https://api.github.com/repos/Blankj/AndroidUtilCode/issues/75/comments",
    "author": "BroganGrow",
    "comments": [
      {
        "user": "Blankj",
        "created_at": "2016-10-29T07:35:09Z",
        "body": "🆗 \n"
      }
    ]
  },
  {
    "number": 71,
    "title": "Android 6.0之后动态权限",
    "created_at": "2016-10-27T05:41:44Z",
    "closed_at": "2018-01-12T02:28:40Z",
    "labels": [
      "help wanted"
    ],
    "url": "https://github.com/Blankj/AndroidUtilCode/issues/71",
    "body": "是否考虑加一个Android 6.0之后动态权限管理相关的帮助类？\n",
    "comments_url": "https://api.github.com/repos/Blankj/AndroidUtilCode/issues/71/comments",
    "author": "haiker2011",
    "comments": [
      {
        "user": "Blankj",
        "created_at": "2016-10-27T05:45:17Z",
        "body": "我现在还没用到，国内还不多现在，之后应该会加\n"
      },
      {
        "user": "Yang-zh",
        "created_at": "2016-11-03T07:55:42Z",
        "body": "附议，这个调个系统原生对话框放在UtilCode里蛮不错的\n"
      },
      {
        "user": "Blankj",
        "created_at": "2016-12-08T13:23:54Z",
        "body": "@haiker2011 手机已升级到6.0，这两天会添加上去"
      },
      {
        "user": "Blankj",
        "created_at": "2018-01-12T02:28:26Z",
        "body": "@haiker2011 @Yang-zh 1.11.0 版本开始已经加入了PermissionUtils"
      }
    ]
  },
  {
    "number": 69,
    "title": "FileUtils.getFileMD5 oom",
    "created_at": "2016-10-25T09:41:30Z",
    "closed_at": "2016-10-31T12:32:43Z",
    "labels": [
      "help wanted"
    ],
    "url": "https://github.com/Blankj/AndroidUtilCode/issues/69",
    "body": "FileUtils.getFileMD5  处理大文件，报内存溢出。\n建议EncryptUtils.encryptMD5File中使用：\n`\npublic static byte[] encryptMD5File(File file) {\n        if (file == null) return null;\n        FileInputStream fis = null;\n        DigestInputStream digestInputStream = null;\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            fis = new FileInputStream(file);\n            digestInputStream = new DigestInputStream(fis, md);\n            byte[] buffer = new byte[256 * 1024];\n            while (digestInputStream.read(buffer) > 0) ;\n            // 获取最终的MessageDigest\n            md = digestInputStream.getMessageDigest();\n            return md.digest();\n        } catch (NoSuchAlgorithmException | IOException e) {\n            e.printStackTrace();\n            return null;\n        } finally {\n            CloseUtils.closeIO(fis);\n        }\n    }\n`\n",
    "comments_url": "https://api.github.com/repos/Blankj/AndroidUtilCode/issues/69/comments",
    "author": "scrat000",
    "comments": [
      {
        "user": "Blankj",
        "created_at": "2016-10-26T01:40:45Z",
        "body": "下个版本修正哈\n"
      },
      {
        "user": "Blankj",
        "created_at": "2016-10-31T12:07:55Z",
        "body": "你的是多大的文件？\n"
      },
      {
        "user": "Blankj",
        "created_at": "2016-10-31T12:33:08Z",
        "body": "这个确实是最快的\n"
      },
      {
        "user": "scrat000",
        "created_at": "2016-11-01T02:40:32Z",
        "body": "几十MB吧，对文件MD5\n"
      },
      {
        "user": "Blankj",
        "created_at": "2016-11-01T02:41:55Z",
        "body": "我几百兆，几个G的都测了，就这个digestInputStream 最快，已更新\n"
      },
      {
        "user": "scrat000",
        "created_at": "2016-11-01T02:55:47Z",
        "body": "是android平台上测的吗？不要忽略内存限制\n"
      },
      {
        "user": "Blankj",
        "created_at": "2016-11-01T02:57:52Z",
        "body": "这个只依赖java层，所以单元测试一下就可以了，内存这个我没有具体看，但这个是缓存流里面的，应该可以\n"
      }
    ]
  },
  {
    "number": 68,
    "title": "CloseUtils has a problem?",
    "created_at": "2016-10-21T02:12:00Z",
    "closed_at": "2016-10-31T10:29:48Z",
    "labels": [
      "help wanted"
    ],
    "url": "https://github.com/Blankj/AndroidUtilCode/issues/68",
    "body": "`public static void closeIO(Closeable... closeables) {\n        if (closeables == null) return;\n        try {\n            for (Closeable closeable : closeables) {\n                if (closeable != null) {\n                    closeable.close();\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }`\nchange to \n`public static void closeIO(Closeable... closeables) {\n        if (closeables == null) return;\n            for (Closeable closeable : closeables) {\n            if (closeable != null) {\n               try{\n                     closeable.close();\n                   }\n              }catch(IOException e){\n                    e.printStackTrace();\n                    continue;\n              }\n           }\n    }`\n",
    "comments_url": "https://api.github.com/repos/Blankj/AndroidUtilCode/issues/68/comments",
    "author": "DanielYP",
    "comments": [
      {
        "user": "Blankj",
        "created_at": "2016-10-21T07:26:59Z",
        "body": "thx for ur issues, I will fix it in next version.\nyou'd better format the code☺\n"
      },
      {
        "user": "DanielYP",
        "created_at": "2016-10-21T08:38:03Z",
        "body": ":)\n"
      }
    ]
  },
  {
    "number": 67,
    "title": "KeyBoardUtils中的isShowSoftInput()方法无效",
    "created_at": "2016-10-18T11:28:23Z",
    "closed_at": "2016-10-31T10:29:53Z",
    "labels": [
      "help wanted"
    ],
    "url": "https://github.com/Blankj/AndroidUtilCode/issues/67",
    "body": "",
    "comments_url": "https://api.github.com/repos/Blankj/AndroidUtilCode/issues/67/comments",
    "author": "MarnoDev",
    "comments": [
      {
        "user": "Blankj",
        "created_at": "2016-10-20T13:06:14Z",
        "body": "这个我测了，也找了好多，找不到好使的，要不就只能去掉了\n"
      }
    ]
  },
  {
    "number": 66,
    "title": "获取app签名错误",
    "created_at": "2016-10-17T08:27:22Z",
    "closed_at": "2016-10-31T10:30:26Z",
    "labels": [
      "help wanted"
    ],
    "url": "https://github.com/Blankj/AndroidUtilCode/issues/66",
    "body": "public static Signature[] getAppSignature(Context context, String packageName)\n\n这个方法通过pm.getPackageInfo(packageName, 0)获取到的signatures是null。如果传入参数PackageManager.GET_SIGNATURES就可以正确获取到。系统是5.1.1 api22，小米\n",
    "comments_url": "https://api.github.com/repos/Blankj/AndroidUtilCode/issues/66/comments",
    "author": "yikuo123",
    "comments": [
      {
        "user": "Blankj",
        "created_at": "2016-10-17T08:46:50Z",
        "body": "ok，我刚刚也发现了\n"
      }
    ]
  },
  {
    "number": 62,
    "title": "判断App是否在前台，获取前台App的包名（仅支持系统App），同时对不同版本做兼容",
    "created_at": "2016-10-14T09:14:21Z",
    "closed_at": "2016-10-15T03:24:19Z",
    "labels": [
      "help wanted"
    ],
    "url": "https://github.com/Blankj/AndroidUtilCode/pull/62",
    "body": "> 判断 APP 是否在前台\n- 第三方 APP 通过 `RunningAppProcessInfo` 进可判断自己应用本身是否在前台，二不能判断某个 APP 是否在前台；\n- 系统 APP 可先获得前台 APP 包名，然后做对比，这样就可以判断某个 APP 是否在前台\n\n> 如果需要获取前台 APP 的包名（仅针对系统 APP，第三方 APP 没有 `PACKAGE_USAGE_STATS` 权限），针对不同的版本做了兼容\n- API < 21，采用 `RunningTaskInfo`，需添加 `android.permission.GET_TASKS` 权限\n- 22 > API >= 21，采用 `RunningAppProcessInfo`\n- API >= 22，采用 `UsageStatsManager`，需添加 `android.permission.PACKAGE_USAGE_STATS` 权限\n",
    "comments_url": "https://api.github.com/repos/Blankj/AndroidUtilCode/issues/62/comments",
    "author": "onlylemi",
    "comments": [
      {
        "user": "onlylemi",
        "created_at": "2016-10-15T03:19:20Z",
        "body": "@Blankj @jp1017 做了兼容，系统 APP 可以获取前台包名\n"
      },
      {
        "user": "Blankj",
        "created_at": "2016-10-17T15:25:00Z",
        "body": "```\n/**\n * 获取前台应用包名\n *\n * @param context 上下文\n * @return 前台应用包名\n */\npublic static String getForegroundApp(Context context) {\n    ActivityManager manager = (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);\n    List<ActivityManager.RunningAppProcessInfo> infos = manager.getRunningAppProcesses();\n    if (infos == null || infos.size() == 0) {\n        return null;\n    }\n    for (ActivityManager.RunningAppProcessInfo ra : infos) {\n        if (ra.importance == ActivityManager.RunningAppProcessInfo.IMPORTANCE_FOREGROUND) {\n            return ra.processName;\n        }\n    }\n    return null;\n}\n```\n\n这个也可以判断其他应用，所以不需要其他方法了，你的getPackegeName3和4我root测试都是返回null\n"
      },
      {
        "user": "onlylemi",
        "created_at": "2016-10-18T00:15:19Z",
        "body": "@Blankj \n\n你这种就是 getPackegeName2，此方法在 API 21 之前只有在自己的 APP 在前台时可以抓取到其包名，其他 APP 在前台时 `infos.size()` 为 0，是获取不到的；API 21 之后采用系统提供的 `UsageStatsManager` 是可以获取到的（**仅支持系统 APP 调用，第三方 APP 调用返回 null**），亲测可用\n"
      },
      {
        "user": "Blankj",
        "created_at": "2016-10-18T15:55:08Z",
        "body": "我今天测试了，stackoverflow上也说到不需要 系统应用，只需要添加Intent intent = new Intent(Settings.ACTION_USAGE_ACCESS_SETTINGS);这个选项应用打开，在加上那个权限即可，下面是我的完整代码。\n\n```\n/**\n/**\n * 获取前台应用包名\n * <p>当不是查看当前App，且SDK >= 22时，\n * 需添加权限 {@code <uses-permission android:name=\"android.permission.PACKAGE_USAGE_STATS\"/>}</p>\n *\n * @param context 上下文\n * @return 前台应用包名\n */\npublic static String getForegroundProcessName(Context context) {\n    ActivityManager manager = (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);\n    List<ActivityManager.RunningAppProcessInfo> infos = manager.getRunningAppProcesses();\n    if (infos != null && infos.size() != 0) {\n        for (ActivityManager.RunningAppProcessInfo info : infos) {\n            if (info.importance == ActivityManager.RunningAppProcessInfo.IMPORTANCE_FOREGROUND) {\n                return info.processName;\n            }\n        }\n    }\n    if (android.os.Build.VERSION.SDK_INT > android.os.Build.VERSION_CODES.LOLLIPOP) {\n        PackageManager packageManager = context.getPackageManager();\n        Intent intent = new Intent(Settings.ACTION_USAGE_ACCESS_SETTINGS);\n        List<ResolveInfo> list = packageManager.queryIntentActivities(intent, PackageManager.MATCH_DEFAULT_ONLY);\n        System.out.println(list);\n        if (list.size() > 0) {// 有\"有权查看使用权限的应用\"选项\n            try {\n                ApplicationInfo info = packageManager.getApplicationInfo(context.getPackageName(), 0);\n                AppOpsManager aom = (AppOpsManager) context.getSystemService(Context.APP_OPS_SERVICE);\n                if (aom.checkOpNoThrow(AppOpsManager.OPSTR_GET_USAGE_STATS, info.uid, info.packageName) != AppOpsManager.MODE_ALLOWED) {\n                    context.startActivity(intent);\n                }\n                if (aom.checkOpNoThrow(AppOpsManager.OPSTR_GET_USAGE_STATS, info.uid, info.packageName) != AppOpsManager.MODE_ALLOWED) {\n                    LogUtils.d(\"getForegroundApp\", \"没有打开\\\"有权查看使用权限的应用\\\"选项\");\n                    return null;\n                }\n                UsageStatsManager usageStatsManager = (UsageStatsManager) context.getSystemService(Context.USAGE_STATS_SERVICE);\n                long endTime = System.currentTimeMillis();\n                long beginTime = endTime - 86400000 * 7;\n                List<UsageStats> usageStatses = usageStatsManager.queryUsageStats(UsageStatsManager.INTERVAL_BEST, beginTime, endTime);\n                if (usageStatses == null || usageStatses.isEmpty()) return null;\n                UsageStats recentStats = null;\n                for (UsageStats usageStats : usageStatses) {\n                    if (recentStats == null || usageStats.getLastTimeUsed() > recentStats.getLastTimeUsed()) {\n                        recentStats = usageStats;\n                    }\n                }\n                return recentStats == null ? null : recentStats.getPackageName();\n            } catch (PackageManager.NameNotFoundException e) {\n                e.printStackTrace();\n            }\n        } else {\n            LogUtils.d(\"getForegroundApp\", \"无\\\"有权查看使用权限的应用\\\"选项\");\n        }\n    }\n    return null;\n}\n```\n"
      },
      {
        "user": "onlylemi",
        "created_at": "2016-10-20T00:50:50Z",
        "body": "@Blankj \n\n我刚刚在 `小米note` 上测试了，是不可以的，返回 null。权限管理里并没有该权限，可能跟系统厂商有关\n"
      },
      {
        "user": "Blankj",
        "created_at": "2016-10-20T00:53:42Z",
        "body": "恩，有些厂商给阉割了，所以加了if (list.size() > 0)这个判断，我MIUI8和原生6.0测的，\n"
      }
    ]
  },
  {
    "number": 56,
    "title": "getSHA1",
    "created_at": "2016-10-09T02:43:58Z",
    "closed_at": "2016-10-09T04:30:30Z",
    "labels": [
      "help wanted"
    ],
    "url": "https://github.com/Blankj/AndroidUtilCode/pull/56",
    "body": "### 获取应用的 `SHA1` 值\n",
    "comments_url": "https://api.github.com/repos/Blankj/AndroidUtilCode/issues/56/comments",
    "author": "jp1017",
    "comments": [
      {
        "user": "jp1017",
        "created_at": "2016-10-09T02:44:55Z",
        "body": "@Blankj :smile: \n"
      },
      {
        "user": "Blankj",
        "created_at": "2016-10-09T02:49:18Z",
        "body": "你这是info.signatures[0]的sha1加密，那么你就调用EncryptUtils的encryptSHA1ToString()即可，对吧\n"
      },
      {
        "user": "Blankj",
        "created_at": "2016-10-09T02:51:30Z",
        "body": "我给了加密，不是每个人都需要sha1加密的，你们自己去组装就好了，不然还有对签名的MD5加密等等，再说貌似info.signatures[0]已经实现过加密了的吧\n"
      },
      {
        "user": "jp1017",
        "created_at": "2016-10-09T02:58:39Z",
        "body": "@Blankj 是的，这个又封装了一次，你可以 merge，然后用 `encryptSHA1ToString()` 替换掉后面代码。\n\n:smile: \n\n可快速获取到SHA1值而已，比对百度高德地图key，而不用再去命令行一遍一遍的确认。。。\n"
      },
      {
        "user": "Blankj",
        "created_at": "2016-10-09T03:02:15Z",
        "body": "说，你是不是想to be contributor  :)\n"
      },
      {
        "user": "jp1017",
        "created_at": "2016-10-09T03:06:53Z",
        "body": "@Blankj  \n\n> Just making the world simple, easy, and fine. :smiling_imp: \n"
      }
    ]
  },
  {
    "number": 55,
    "title": "EncryptUtils line:143 重复调用encryptMD5File",
    "created_at": "2016-10-08T08:05:43Z",
    "closed_at": "2016-10-08T08:24:33Z",
    "labels": [
      "help wanted"
    ],
    "url": "https://github.com/Blankj/AndroidUtilCode/issues/55",
    "body": "如题\npublic static String encryptMD5File2String(File file) {\n        return encryptMD5File(file) != null ? bytes2HexString(encryptMD5File(file)) : \"\";\n    }\n\n改成：\n\n```\npublic static String encryptMD5File2String(File file) {\n    byte[] bytes = encryptMD5File(file);\n    return bytes  != null ? bytes2HexString(bytes ) : \"\";\n}\n```\n",
    "comments_url": "https://api.github.com/repos/Blankj/AndroidUtilCode/issues/55/comments",
    "author": "zuolongxiang",
    "comments": [
      {
        "user": "Blankj",
        "created_at": "2016-10-08T08:10:00Z",
        "body": "GOOD!\n"
      },
      {
        "user": "Blankj",
        "created_at": "2016-10-08T08:12:26Z",
        "body": "好久之前写的了，现在要更新一波规范\n"
      },
      {
        "user": "jp1017",
        "created_at": "2016-10-08T08:32:31Z",
        "body": "更新完再关闭盲 :smile: :+1: :100: :eggplant: \n"
      }
    ]
  },
  {
    "number": 52,
    "title": "fix FileUtils.getFileExtension()",
    "created_at": "2016-09-27T12:23:43Z",
    "closed_at": "2016-09-27T13:07:48Z",
    "labels": [
      "help wanted"
    ],
    "url": "https://github.com/Blankj/AndroidUtilCode/pull/52",
    "body": "修复由于获取文件拓展名错误，导致的一系列问题（如6.0安装APK异常）\n",
    "comments_url": "https://api.github.com/repos/Blankj/AndroidUtilCode/issues/52/comments",
    "author": "imkarl",
    "comments": [
      {
        "user": "Blankj",
        "created_at": "2016-09-27T13:07:26Z",
        "body": "Thx!\n"
      }
    ]
  },
  {
    "number": 51,
    "title": "getLaunchAppIntent typo fix",
    "created_at": "2016-09-27T07:54:46Z",
    "closed_at": "2016-09-27T08:17:30Z",
    "labels": [
      "help wanted"
    ],
    "url": "https://github.com/Blankj/AndroidUtilCode/pull/51",
    "body": "",
    "comments_url": "https://api.github.com/repos/Blankj/AndroidUtilCode/issues/51/comments",
    "author": "jdsingh",
    "comments": [
      {
        "user": "Blankj",
        "created_at": "2016-09-27T07:56:18Z",
        "body": "Thx for ur pr!\n"
      }
    ]
  },
  {
    "number": 50,
    "title": "ImageUtils.java中添加颜色边框代码的错误",
    "created_at": "2016-09-27T02:58:40Z",
    "closed_at": "2016-09-28T00:49:07Z",
    "labels": [
      "help wanted"
    ],
    "url": "https://github.com/Blankj/AndroidUtilCode/issues/50",
    "body": "```\npublic static Bitmap addFrame(Bitmap src, int borderWidth, int color, boolean recycle) {\n        if (isEmptyBitmap(src)) return null;\n        //int newWidth = src.getWidth() + borderWidth >> 1;\n        //int newHeight = src.getHeight() + borderWidth >> 1;\n        int newWidth = src.getWidth() + (borderWidth << 1);\n        int newHeight = src.getHeight() + (borderWidth << 1);\n        Bitmap ret = Bitmap.createBitmap(newWidth, newHeight, src.getConfig());\n        Canvas canvas = new Canvas(ret);\n        Rect rec = canvas.getClipBounds();\n        Paint paint = new Paint();\n        paint.setColor(color);\n        paint.setStyle(Paint.Style.STROKE);\n        paint.setStrokeWidth(borderWidth);\n        canvas.drawRect(rec, paint);\n        canvas.drawBitmap(src, borderWidth, borderWidth, null);\n        if (recycle && !src.isRecycled()) src.recycle();\n        return ret;\n    }\n```\n\n 新create出来的图片长宽需要加上边框需要乘以2不是除以2，另外加减乘除的优先级比移位优先级高，需要带上括号。\n",
    "comments_url": "https://api.github.com/repos/Blankj/AndroidUtilCode/issues/50/comments",
    "author": "xuwei5720",
    "comments": [
      {
        "user": "Blankj",
        "created_at": "2016-09-27T12:16:14Z",
        "body": "嗯哼，下回更新会解决，除你说的之外还有个bug哦，'paint.setStrokeWidth(borderWidth);'是从中间开始画的，所以画笔宽度要乘以二\n"
      }
    ]
  },
  {
    "number": 48,
    "title": "update NetworkUtils",
    "created_at": "2016-09-26T07:39:21Z",
    "closed_at": "2016-09-26T09:29:57Z",
    "labels": [
      "help wanted"
    ],
    "url": "https://github.com/Blankj/AndroidUtilCode/pull/48",
    "body": "增加根据域名获取ip地址工具 :smile: \n",
    "comments_url": "https://api.github.com/repos/Blankj/AndroidUtilCode/issues/48/comments",
    "author": "jp1017",
    "comments": [
      {
        "user": "Blankj",
        "created_at": "2016-09-26T09:29:28Z",
        "body": "下个版本加上\n"
      }
    ]
  },
  {
    "number": 44,
    "title": "增加点方法。",
    "created_at": "2016-09-18T09:59:56Z",
    "closed_at": "2016-09-19T14:24:39Z",
    "labels": [
      "help wanted"
    ],
    "url": "https://github.com/Blankj/AndroidUtilCode/pull/44",
    "body": "又增加了些 项目里没有的。\n",
    "comments_url": "https://api.github.com/repos/Blankj/AndroidUtilCode/issues/44/comments",
    "author": "BinarySatan",
    "comments": [
      {
        "user": "Blankj",
        "created_at": "2016-09-19T01:43:51Z",
        "body": "由于有些代码有重复，所以我就不merge了，谢谢你的pr，我之后会手动添上。\n"
      },
      {
        "user": "BinarySatan",
        "created_at": "2016-09-19T02:00:30Z",
        "body": "好的\n"
      }
    ]
  },
  {
    "number": 31,
    "title": "Make public static fields final",
    "created_at": "2016-08-19T03:06:56Z",
    "closed_at": "2016-08-20T08:59:17Z",
    "labels": [
      "help wanted"
    ],
    "url": "https://github.com/Blankj/AndroidUtilCode/pull/31",
    "body": "This reduces the possibility of accidents or malicious code changes vulnerability, especially as most of these fields are in the encryption-related util class.\n",
    "comments_url": "https://api.github.com/repos/Blankj/AndroidUtilCode/issues/31/comments",
    "author": "vpop",
    "comments": [
      {
        "user": "Blankj",
        "created_at": "2016-08-19T05:32:44Z",
        "body": "These fields are provided for users to change the mode on purpose.\n"
      },
      {
        "user": "vpop",
        "created_at": "2016-08-19T07:08:18Z",
        "body": "That's fine, I am not making them `private`, just `final`, so people don't change the value of `AES_Algorithm` class variable for example from _AES_ to _Caesar_.\n"
      },
      {
        "user": "Blankj",
        "created_at": "2016-08-19T08:08:49Z",
        "body": "I chang the field of DES_Algorithm private static final. The field of DES_Transformation is public static. If it's final, user can't change DES_Transformation to DES/ECB/PKCS5Padding.\n"
      }
    ]
  },
  {
    "number": 29,
    "title": "完善工具类",
    "created_at": "2016-08-15T08:19:54Z",
    "closed_at": "2016-09-01T04:21:15Z",
    "labels": [
      "help wanted"
    ],
    "url": "https://github.com/Blankj/AndroidUtilCode/issues/29",
    "body": "单位转换，比如dp转px . .. . . . .\n文件操作，文件创建 删除  压缩等等....\nBitmap处理工具类，毛玻璃  圆角  转byte[]之类的.....\nMD5 . Base64 工具类......\n",
    "comments_url": "https://api.github.com/repos/Blankj/AndroidUtilCode/issues/29/comments",
    "author": "zhaoxiuyu",
    "comments": [
      {
        "user": "Blankj",
        "created_at": "2016-08-15T08:29:35Z",
        "body": "单位在SizeUtils，文件和图片操作这两天会加，MD，Base64都在Encode和Encrypt里\n"
      }
    ]
  },
  {
    "number": 27,
    "title": "Close the buffered source reader",
    "created_at": "2016-08-13T17:36:53Z",
    "closed_at": "2016-08-14T03:05:53Z",
    "labels": [
      "help wanted"
    ],
    "url": "https://github.com/Blankj/AndroidUtilCode/pull/27",
    "body": "Could not use `try-with-resources` due to min Android API limitations for that (19+).\n",
    "comments_url": "https://api.github.com/repos/Blankj/AndroidUtilCode/issues/27/comments",
    "author": "vpop",
    "comments": [
      {
        "user": "Blankj",
        "created_at": "2016-08-14T03:05:45Z",
        "body": "Thx for ur commit.\n"
      }
    ]
  },
  {
    "number": 17,
    "title": "open and close statusbar",
    "created_at": "2016-08-05T12:43:32Z",
    "closed_at": "2016-08-07T06:45:35Z",
    "labels": [
      "help wanted"
    ],
    "url": "https://github.com/Blankj/AndroidUtilCode/pull/17",
    "body": "- 增加打开、关闭通知栏工具\n- 判断设备是否 root\n",
    "comments_url": "https://api.github.com/repos/Blankj/AndroidUtilCode/issues/17/comments",
    "author": "jp1017",
    "comments": [
      {
        "user": "Blankj",
        "created_at": "2016-08-07T06:44:36Z",
        "body": "打开、关闭通知栏我测试没反应，root已加\n"
      },
      {
        "user": "jp1017",
        "created_at": "2016-08-07T07:35:59Z",
        "body": "抱歉，遗漏了权限：\n\n```\n  <uses-permission android:name=\"android.permission.EXPAND_STATUS_BAR\"/>\n```\n"
      }
    ]
  },
  {
    "number": 13,
    "title": "添加判断状态栏是否存在",
    "created_at": "2016-08-05T04:46:00Z",
    "closed_at": "2016-08-05T08:01:15Z",
    "labels": [
      "help wanted"
    ],
    "url": "https://github.com/Blankj/AndroidUtilCode/pull/13",
    "body": "在ScreenUtils中添加了，判断状态栏是否存在的方法。\n",
    "comments_url": "https://api.github.com/repos/Blankj/AndroidUtilCode/issues/13/comments",
    "author": "tiandawu",
    "comments": [
      {
        "user": "Blankj",
        "created_at": "2016-08-05T08:00:08Z",
        "body": "已改，谢谢提供，由于格式有点问题，所以我手动修改，没merge\n"
      }
    ]
  },
  {
    "number": 11,
    "title": "手机号码的正则",
    "created_at": "2016-08-04T04:18:02Z",
    "closed_at": "2016-08-05T02:23:45Z",
    "labels": [
      "help wanted"
    ],
    "url": "https://github.com/Blankj/AndroidUtilCode/issues/11",
    "body": " private static Pattern mobilePattern;\n    /**\n     \\* 移动：134(0-8)、135、136、137、138、139、147、150、151、152、157、158、159、178、182、183、184、187、188\n     \\* 联通：130、131、132、145、155、156、175、176、185、186\n     \\* 电信：133、153、173、177、180、181、189\n     \\* 全球星：1349\n     \\* 虚拟运营商：170\n     *\n     \\* @param mobileNo\n     \\* @return\n     */\n\n```\n/**\n * 验证手机格式\n */\npublic static boolean isMobileNO(String mobiles) {\n\n\n    if (mobilePattern == null) {\n        mobilePattern = Pattern.compile(\"^((13[0-9])|(14[5,7])|(15[0-3,5-8])|(17[0,3,5-8])|(18[0-9])|(147))\\\\d{8}$\");\n    }\n    return mobilePattern.matcher(mobiles).matches();\n}\n```\n",
    "comments_url": "https://api.github.com/repos/Blankj/AndroidUtilCode/issues/11/comments",
    "author": "MIkeeJY",
    "comments": [
      {
        "user": "lanseyou",
        "created_at": "2016-08-04T07:58:59Z",
        "body": "全球星，亮了。\n"
      },
      {
        "user": "MIkeeJY",
        "created_at": "2016-08-04T08:35:37Z",
        "body": "@lanseyou 美国一家很屌的公司\n"
      },
      {
        "user": "Blankj",
        "created_at": "2016-08-04T09:05:42Z",
        "body": "ok，isDetialMobileNO诞生，简短粗暴那个也做保留，我会做区分\n"
      }
    ]
  },
  {
    "number": 6,
    "title": "MD5加密是这样写吗？",
    "created_at": "2016-08-03T02:02:00Z",
    "closed_at": "2016-08-05T03:16:08Z",
    "labels": [
      "help wanted"
    ],
    "url": "https://github.com/Blankj/AndroidUtilCode/issues/6",
    "body": "对字符串 ‘“lxm” 进行MD5加密\n\ngetMD5 = 8fae1645fdb13cc84924ae63b08584ff, time = 6\nmd5 = 8fae1645fdb13cc84924ae63b08584ff, time = 0\nencryptMD5 = -7051e9ba024ec337b6db519c4f7a7b01, time = 0\n\n上面两个是以前用过的算法加密结果是一样的，在cmd5.com查询原文也是正确的，最后一个是你的算法的结果。\n",
    "comments_url": "https://api.github.com/repos/Blankj/AndroidUtilCode/issues/6/comments",
    "author": "ssyijiu",
    "comments": [
      {
        "user": "Blankj",
        "created_at": "2016-08-03T02:27:26Z",
        "body": "好，我去看看，改了跟你说哈，可进群交流哈\n"
      },
      {
        "user": "Blankj",
        "created_at": "2016-08-03T03:32:36Z",
        "body": "问题已发现，我转的是有符号位的16进制，所以造成不同，第一位小于8的话结果是相同的，之后代码会更新的\n"
      },
      {
        "user": "Blankj",
        "created_at": "2016-08-03T05:37:54Z",
        "body": "加解密已进一步优化完毕，主要昨天匆匆测了一遍，测试量有点小，现在MD5和SHA都可以了\n"
      },
      {
        "user": "ssyijiu",
        "created_at": "2016-08-04T03:52:42Z",
        "body": "@Blankj 还有点建议，感觉MD5做的太多了，它本身只是一个加密算法，只负责加密就好了，不应该做过多的其他事情（非空判断），这些应该由使用者在进行MD5之前自己判断。还有希望重载一个getMD5(String data, saltValue) MD5加密加盐。仅供参考。\n"
      },
      {
        "user": "Blankj",
        "created_at": "2016-08-05T00:58:05Z",
        "body": "我一直在纠结要不要判空，你这么一说我就不加了，ok，重载会跟上\n"
      },
      {
        "user": "Blankj",
        "created_at": "2016-08-05T03:15:55Z",
        "body": "已加\n"
      }
    ]
  },
  {
    "number": 5,
    "title": "forceGetViewSize() has bug",
    "created_at": "2016-08-02T09:53:06Z",
    "closed_at": "2016-08-05T00:56:07Z",
    "labels": [
      "help wanted"
    ],
    "url": "https://github.com/Blankj/AndroidUtilCode/issues/5",
    "body": "我在onCreat() 里面`forceGetViewSize(heroImageView);`\n\n返回[3600, 2024]\n\n实际上我的height只有差不多900，宽大概400\n",
    "comments_url": "https://api.github.com/repos/Blankj/AndroidUtilCode/issues/5/comments",
    "author": "ninjachen",
    "comments": [
      {
        "user": "Blankj",
        "created_at": "2016-08-02T14:53:24Z",
        "body": "好，我也去试试，那个总共有三种方法，我选了最简的，改了会说的\n"
      }
    ]
  },
  {
    "number": 3,
    "title": "给个建议",
    "created_at": "2016-08-02T08:02:27Z",
    "closed_at": "2016-08-05T00:55:58Z",
    "labels": [
      "help wanted"
    ],
    "url": "https://github.com/Blankj/AndroidUtilCode/issues/3",
    "body": "给个建议，最好是能在代码片段上注明代码片段涉及的权限，这样用起来更加方便。\n",
    "comments_url": "https://api.github.com/repos/Blankj/AndroidUtilCode/issues/3/comments",
    "author": "iQuick",
    "comments": [
      {
        "user": "jp1017",
        "created_at": "2016-08-02T08:04:29Z",
        "body": "Good, :+1: \n"
      },
      {
        "user": "Blankj",
        "created_at": "2016-08-02T09:18:40Z",
        "body": "恩，我现在都改成那样的了哦，看注释会感觉萌萌哒，晚上来一波更新\n"
      }
    ]
  },
  {
    "number": 1,
    "title": "md文件有乱码",
    "created_at": "2016-07-31T06:21:29Z",
    "closed_at": "2016-08-05T00:55:39Z",
    "labels": [
      "help wanted"
    ],
    "url": "https://github.com/Blankj/AndroidUtilCode/issues/1",
    "body": "我用手机端github打开md有乱码。forkhub\n另外，作者可以把这些代码合并成几个utils类\n",
    "comments_url": "https://api.github.com/repos/Blankj/AndroidUtilCode/issues/1/comments",
    "author": "sunzcdev",
    "comments": [
      {
        "user": "Blankj",
        "created_at": "2016-07-31T13:30:37Z",
        "body": "编码已转为utf8无bom，经forkhub测试乱码已解决，后续会考虑整理成utils类的\n"
      },
      {
        "user": "Blankj",
        "created_at": "2016-07-31T13:40:07Z",
        "body": "工具类的话之后我会写在我的Android开发框架里的utils包中的，到时候会放上地址的，这里的话还是md查阅起来比较方便我觉得。\n"
      }
    ]
  }
]